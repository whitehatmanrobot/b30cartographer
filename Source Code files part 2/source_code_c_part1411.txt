ce Glasse)          Created
//
//  Notes: This is taken from OLE2 file moniker code
//
//----------------------------------------------------------------------------
int CountSegments ( LPSTR pch )
{
    DEBUG_ENTER((DBG_MONIKER,
                Int,
                "CountSegments",
                "%.80q",
                pch
                ));
                
    PerfDbgLog(tagCUrlMon, NULL, "+CountSegments");
    //  counts the number of pieces in a path, after the first colon, if
    //  there is one

    int n = 0;
    LPSTR pch1;
    pch1 = pch;
    while (*pch1 != '\0' && *pch1 != ':') IncLpch(pch1);
    if (*pch1 == ':') pch = ++pch1;
    while (*pch != '\0')
    {
        while (*pch && IsSeparator(*pch)) pch++;
        if (*pch) n++;
        while (*pch && (!IsSeparator(*pch))) IncLpch(pch);
    }

    PerfDbgLog1(tagCUrlMon, NULL, "-CountSegments (n:%ld)", n);

    DEBUG_LEAVE(n);
    return n;
}


//+---------------------------------------------------------------------------
//
//  Function: HrGetRelativePath
//
//  Synopsis: Compute and return relative path from url path
//            lpszBase to url path lpszOther.
//
//  Arguments:  [lpszBase] -- the base path without the scheme and host info
//              [lpszOther] -- the target path without the scheme and host
//              [dwProto] -- DLD_PROTOCOL_XXX value, indicating the scheme
//                           of the urls.
//              [lpszHost] -- the host name for the urls
//              [lpszRelPath] -- buffer of size MAX_URL_SIZE that returns the
//                               relative path.
//
//  Returns: NOERROR, MK_S_HIM, MK_E_NOTBINDABLE, or some other hresult.
//
//  History:   8-20-96   ClarG  (Clarence Glasse)          Created
//
//  Notes: This is based on OLE2 file moniker code
//
//----------------------------------------------------------------------------
HRESULT HrGetRelativePath(
    LPSTR lpszBase, LPSTR lpszOther, DWORD dwProto, LPSTR lpszHost,
    LPSTR lpszRelPath)
{
    DEBUG_ENTER((DBG_MONIKER,
                Hresult,
                "HrGetRelativePath",
                "%.80q, %.80q, %#x, %.80q, %.80q",
                lpszBase, lpszOther, dwProto, lpszHost, lpszRelPath
                ));
                
    PerfDbgLog(tagCUrlMon, NULL, "+HrGetRelativePath");
    HRESULT hr = NOERROR;
    LPSTR lpszRover;
    LPSTR lpszMarker;
    LPSTR lpch;
    LPSTR lpchStripBaseSav = NULL;
    char  ch1;
    char  ch2;
    char  chStripBaseSav;
    char  chNull = '\0';
    int i;
    int cAnti;

    lpszRelPath[0] = 0;

    // if neither lpszBase nor lpszRelPath look like absolute url or file
    // paths, return MK_E_NOTBINDALBE
    if (!lpszBase[0] || !lpszOther[0])
    {
        hr = MK_E_NOTBINDABLE;
        goto End;
    }

    if ((lpszBase[0] != '\\') && (lpszBase[0] != '/') && (lpszBase[1] != ':'))
    {
        hr = MK_E_NOTBINDABLE;
        goto End;
    }

    if ((lpszOther[0] != '\\') && (lpszOther[0] != '/') && (lpszOther[1] != ':'))
    {
        hr = MK_E_NOTBINDABLE;
        goto End;
    }

    if (lstrcmpi(lpszBase, lpszOther) == 0)
    {
        // if paths are equal, relative path is empty string
        lpszRelPath[0] = 0;
        hr = NOERROR;
        goto End;
    }

    // if base does not end in a separator, remove its last piece
    lpch = lpszBase + lstrlen(lpszBase);
    for( ; ((!(IsSeparator(*lpch))) && (lpch > lpszBase)); DecLpch(lpszBase, lpch) );
    if (IsSeparator(*lpch))
    {
        IncLpch(lpch);
        lpchStripBaseSav = lpch;
        chStripBaseSav = *lpch;
        *lpch = '\0';
    }

    lpszRover = lpszBase;
    lpszMarker = lpszRover;
    i = 0;
    lpszOther = lpszOther;

    while (*lpszRover != '\0')
    {
        while (*lpszRover && IsSeparator(*lpszRover)) lpszRover++;
        while (*lpszRover && !IsSeparator(*lpszRover)) IncLpch(lpszRover);
        //      the first part of the path is between m_szPath and
        //      lpszRover
        i = (int) (lpszRover - lpszBase);
        ch1 = *lpszRover;
        ch2 = *(lpszOther + i);
        *lpszRover = '\0';
        *(lpszOther + i) = '\0';

        if (lstrcmpi(lpszBase, lpszOther) == 0)
            lpszMarker = lpszRover;
        else
            lpszRover = &chNull;

        *(lpszBase + i) = ch1;
        *(lpszOther + i) = ch2;
    }

    //  common portion is from lpszBase to lpszMarker
    i = (int) (lpszMarker - lpszBase);
    if ((!lpszHost || !lpszHost[0]) && (i == 0))
    {
        lstrcpy(lpszRelPath, lpszOther);
        hr = MK_S_HIM;
        goto End;
    }

    lpszRover = lpszRelPath;
    while (IsSeparator(*(lpszOther+i))) i++;
    cAnti = CountSegments(lpszMarker);

    while (cAnti)
    {
        if (dwProto != DLD_PROTOCOL_FILE)
            lstrcpy(lpszRover, "../");
        else
            lstrcpy(lpszRover, "..\\");
        lpszRover += 3;
        cAnti--;
    }

    lstrcpy(lpszRover, lpszOther + i);

End:
    if (lpchStripBaseSav)
    {
        *lpchStripBaseSav = chStripBaseSav;
    }

    PerfDbgLog2(tagCUrlMon, NULL, "-HrGetRelativePath [%s], hr:%lx", lpszRelPath?lpszRelPath:"", hr);

    DEBUG_LEAVE(hr);
    return hr;
}


#ifdef URLMON_RELPATHTO_PARSE_QUERY_PARAMS
//+---------------------------------------------------------------------------
//
//  Function: ParseUrlQuery
//
//  Synopsis: Parse the Query portion of a url
//
//  Arguments:  [pszURL] -- url to parse; the query portion is "removed" from
//                          pszURL when function returns.
//              [ppszQuery] -- returns pointer to query portion of URL
//
//  Returns: nothing
//
//  History:   8-20-96   ClarG  (Clarence Glasse)          Created
//
//  Notes: This is based on OLE2 file moniker code
//
//----------------------------------------------------------------------------
void ParseUrlQuery(LPSTR pszURL, LPSTR *ppszQuery)
{
    DEBUG_ENTER((DBG_MONIKER,
                None,
                "ParseUrlQuery",
                "%.80q, %#x",
                pszURL, ppszQuery
                ));
                
    PerfDbgLog(tagCUrlMon, NULL, "+ParseUrlQuery");
    LPSTR pch = NULL;

    *ppszQuery = NULL;

    for (pch = pszURL; *pch; IncLpch(pch))
    {
        if (*pch == '?')
        {
            *pch = '\0';
            pch++;
            if (*pch)
                *ppszQuery = pch;
            break;
        }
    }

    PerfDbgLog(tagCUrlMon, NULL, "-ParseUrlQuery");

    DEBUG_LEAVE(0);
}


//+---------------------------------------------------------------------------
//
//  Function: ParseUrlParams
//
//  Synopsis: Parse the Params portion of a url
//
//  Arguments:  [pszURL] -- url to parse; the params portion is "removed" from
//                          pszURL when function returns.
//              [ppszParams] -- returns pointer to params portion of URL
//
//  Returns: nothing
//
//  History:   8-20-96   ClarG  (Clarence Glasse)          Created
//
//  Notes: This is based on OLE2 file moniker code
//
//----------------------------------------------------------------------------
void ParseUrlParams(LPSTR pszURL, LPSTR *ppszParams)
{
    DEBUG_ENTER((DBG_MONIKER,
                None,
                "ParseUrlParams",
                "%.80q, %#x",
                pszURL, ppszParams
                ));
                
    PerfDbgLog(tagCUrlMon, NULL, "+ParseUrlParams");
    LPSTR pch = NULL;

    *ppszParams = NULL;

    for (pch = pszURL; *pch; IncLpch(pch))
    {
        if (*pch == ';')
        {
            *pch = '\0';
            pch++;
            if (*pch)
                *ppszParams = pch;
            break;
        }
    }

    PerfDbgLog(tagCUrlMon, NULL, "-ParseUrlParams");

    DEBUG_LEAVE(0);
}


//+---------------------------------------------------------------------------
//
//  Function: AddParamsAndQueryToRelPath
//
//  Synopsis: Given a computed relative URL path from a base to a target,
//            append the appropriate Params and Query info.
//
//  Arguments:  [szRelPath] -- computed relative path
//              [pszParamsBase] -- Params info of base URL
//              [pszParamsOther] -- Params info of target URL
//              [pszQueryBase] -- Query info of base URL
//              [pszQueryOther] -- Query info of target URL
//
//  Returns: nothing
//
//  History:   8-20-96   ClarG  (Clarence Glasse)          Created
//
//  Notes: This is based on OLE2 file moniker code
//
//----------------------------------------------------------------------------
void AddParamsAndQueryToRelPath(
    LPSTR szRelPath,
    LPSTR pszParamsBase, LPSTR pszParamsOther,
    LPSTR pszQueryBase, LPSTR pszQueryOther)
{
    DEBUG_ENTER((DBG_MONIKER,
                None,
                "AddParamsAndQueryToRelPath",
                "%.80q, %.80q, %.80q, %.80q, %.80q",
                szRelPath, pszParamsBase, pszParamsOther, pszQueryBase, pszQueryOther
                ));
                
    PerfDbgLog(tagCUrlMon, NULL, "+AddParamsAndQueryToRelPath");

    if (szRelPath[0])
    {
        if (pszParamsOther)
        {
            lstrcat(szRelPath, ";");
            lstrcat(szRelPath, pszParamsOther);
        }
        if (pszQueryOther)
        {
            lstrcat(szRelPath, "?");
            lstrcat(szRelPath, pszQueryOther);
        }
    }
    else
    {
        if (pszParamsOther &&
            (!pszParamsBase || (lstrcmpi(pszParamsOther, pszParamsBase) !=  0)))
        {
            lstrcat(szRelPath, ";");
            lstrcat(szRelPath, pszParamsOther);

            if (pszQueryOther)
            {
                lstrcat(szRelPath, "?");
                lstrcat(szRelPath, pszQueryOther);
            }
        }
        else if (pszQueryOther &&
                 (!pszQueryBase || (lstrcmpi(pszQueryOther, pszQueryBase) !=  0)))
        {
            lstrcat(szRelPath, "?");
            lstrcat(szRelPath, pszQueryOther);
        }
    }

    PerfDbgLog(tagCUrlMon, NULL, "-AddParamsAndQueryToRelPath");

    DEBUG_LEAVE(0);
}
#endif // URLMON_RELPATHTO_PARSE_QUERY_PARAMS
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\urlmon\urlhlink\hlinkez.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:       hlinkez.cxx
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:
//              5-15-96   Ramesh G -  Major modifications
//              5-17-96   Ramesh G -  Added Frames support
//                        Ramesh G -  Modified variable names to Hungarian Notation
//              6-19-96   Ramesh G -  Modifications
//              7-25-96   Ramesh G -  Modifications
//                              8-05-96   Ramesh G -  Merged HlinkSimple...String() and Moniker()
//                                                                        HlinkSimpleNavigateToString() creates the moniker
//                                                                        and calls HlinkSimpleNavigateToMoniker()
//----------------------------------------------------------------------------
#define USE_SYSTEM_URL_MONIKER
#define INITGUID
#define STR_SIZE        20

#include "hlink.h"
#include "ocidl.h"
#include "docobj.h"
#include "exdisp.h"
#include "shellapi.h"
#include "servprov.h"
#include "urlhlink.h"
#include "htiface.h"
#include "wininet.h"
#include <shlwapi.h>
#include <shlwapip.h>
#include <mshtml.h>
#include "mshtmdid.h"
#include <delaydll.h>
#include "sdll.hxx"

#ifndef GUID_NULL
struct __declspec(uuid("00000000-0000-0000-0000-000000000000")) GUID_NULL;
#define GUID_NULL __uuidof(struct GUID_NULL)
#endif

class HLinkDll
{
public:
    HLinkDll();
        HRESULT HlinkCreateFromMoniker(
                                IMoniker* pmkSource,
                                LPCWSTR szLocation,
                                LPCWSTR szFriendlyName,
                                IHlinkSite* phlSite,
                                DWORD dwSiteData,
                                IUnknown* punkOuter,
                                REFIID riid,
                                void** ppv);
private:

    BOOL LoadFunc( LPCSTR lpProcName, FARPROC & fp );
    typedef HRESULT (STDAPICALLTYPE * LPFNHlinkCreateFromMoniker)(
                                IMoniker* pmkSource,
                                LPCWSTR szLocation,
                                LPCWSTR szFriendlyName,
                                IHlinkSite* phlSite,
                                DWORD dwSiteData,
                                IUnknown* punkOuter,
                                REFIID riid,
                                void** ppv);
    LPFNHlinkCreateFromMoniker m_lpfnHlinkCreateFromMoniker;

    HMODULE m_hmodule;
    BOOL    m_error;

};

inline HRESULT HLinkDll::HlinkCreateFromMoniker(
                                IMoniker* pmkSource,
                                LPCWSTR szLocation,
                                LPCWSTR szFriendlyName,
                                IHlinkSite* phlSite,
                                DWORD dwSiteData,
                                IUnknown* punkOuter,
                                REFIID riid,
                                void** ppv)
{

    if( !LoadFunc("HlinkCreateFromMoniker",*(FARPROC*)&m_lpfnHlinkCreateFromMoniker) )
        return(E_FAIL);

     return m_lpfnHlinkCreateFromMoniker(
                                pmkSource,
                                szLocation,
                                szFriendlyName,
                                phlSite,
                                dwSiteData,
                                punkOuter,
                                riid,
                                ppv);
}


HLinkDll::HLinkDll()
{
    m_hmodule = 0;
    m_error = 0;
    m_lpfnHlinkCreateFromMoniker = 0;
}

#if 0
HLinkDll::~HLinkDll()
{
    if( m_hmodule )
        ::FreeLibrary( m_hmodule );
}
#endif

BOOL HLinkDll::LoadFunc( LPCSTR lpProcName, FARPROC & fp )
{
    if( m_error )
        return(0);

    if( fp )
        return(1);

    if( !m_hmodule )
    {
        m_hmodule = ::LoadLibrary( "HLINK.DLL" );

        if( !m_hmodule )
        {
           m_error = 1;
           return(0);
        }

    }

    fp = ::GetProcAddress( m_hmodule, lpProcName );

    return( fp != 0 );
}

static HLinkDll hlink;


//////////////////
static int wclen(LPCWSTR szStr)
{
    int cbStr=0;
    if(szStr!=NULL)
        while(szStr[cbStr]!=NULL)
            ++cbStr;

    return cbStr;
}

////////////////////////////

static HRESULT GetAnInterface
(
    IUnknown    *   punk,
    const IID &     riid,
    void **         pout,

    BOOL            bCheckServiceProvider,
    const IID &     siid,
    const IID &     siid_riid,
    void **         sout
)
{
    IOleObject *      oleObj    = 0;
    IOleClientSite *  oleSite   = 0;
    IOleContainer *   container = 0;
    IUnknown *        service   = 0;

    HRESULT           hr = E_FAIL;

    // Initialize passed in interface pointers: calling code assumes NULL for failure
    if(pout)
            *pout = NULL;
    if(sout)
            *sout = NULL;

    if(punk)
            hr = punk->QueryInterface( IID_IOleObject, (void **)&oleObj );

    // BUBUG: I think this returns a wrong hr if QS fails but the QI passes - jp
    while( SUCCEEDED(hr) && oleObj )
    {
            if( oleSite )
            {
                    //oleSite->Release();
                    oleSite = 0;
            }

            hr = oleObj->GetClientSite(&oleSite);

            if( FAILED(hr) || !oleSite)
                    break;

            if( bCheckServiceProvider)
            {
                    IServiceProvider * servProv;

                    hr = oleSite->QueryInterface( IID_IServiceProvider, (void**)&servProv);

                    if( SUCCEEDED(hr) )
                    {
                            hr = servProv->QueryService
                                                                    (
                                                                            siid,
                                                                            siid_riid,
                                                                            (void **)&service
                                                                    );

                            servProv->Release();
                    }

                    if( SUCCEEDED(hr) )
                    {
                            bCheckServiceProvider = FALSE;

                            hr = service->QueryInterface( riid, pout );
                    }

                    if( SUCCEEDED(hr) )
                            break;

            }

            if( container )
            {
                    container->Release();
                    container = 0;
            }

            hr = oleSite->GetContainer( &container );

            if( FAILED(hr) )
                    break;

            hr = container->QueryInterface( riid, pout );

            if( SUCCEEDED(hr) )
                    break;

            oleObj->Release();
            oleObj = 0;

            hr = container->QueryInterface( IID_IOleObject, (void**)&oleObj );

    }

    if( oleSite )
    {
        oleSite->Release();
        oleSite = 0;
    }

    if( oleObj )
        oleObj->Release();

    if( container )
        container->Release();

    if( service )
    {
        if (sout)
            *sout = service;
        else
            service->Release();
    }

    return( hr );
}

//
//  GetUrlScheme() returns one of the URL_SCHEME_* constants as
//  defined in shlwapip.h
//  example "http://foo" returns URL_SCHEME_HTTP
//
static DWORD GetUrlSchemeW(IN LPCWSTR pcszUrl)
{
    if(pcszUrl)
    {
        PARSEDURLW pu;
        pu.cbSize = sizeof(pu);
        if(SUCCEEDED(ParseURLW(pcszUrl, &pu)))
            return pu.nScheme;
    }
    return URL_SCHEME_INVALID;
}



BOOL IsSpecialUrl(WCHAR *pchURL)
{
    UINT      uProt;
    uProt = GetUrlSchemeW(pchURL);
    return (URL_SCHEME_JAVASCRIPT == uProt || 
            URL_SCHEME_VBSCRIPT == uProt ||
            URL_SCHEME_ABOUT == uProt);
}

HRESULT WrapSpecialUrlFlat(LPWSTR pszUrl, DWORD cchUrl)
{
    HRESULT     hr = S_OK;

    if (IsSpecialUrl(pszUrl))
    {
        //
        // If this is javascript:, vbscript: or about:, append the
        // url of this document so that on the other side we can
        // decide whether or not to allow script execution.
        //

        // QFE 2735 (Georgi XDomain): [alanau]
        //
        // If the special URL contains an %00 sequence, then it will be converted to a Null char when
        // encoded.  This will effectively truncate the Security ID.  For now, simply disallow this
        // sequence, and display a "Permission Denied" script error.
        //
        if (StrStrW(pszUrl, L"%00"))
        {
            hr = E_ACCESSDENIED;
        }
        else
        {
            // munge the url in place
            //

            // someone could put in a string like this:
            //     %2501 OR %252501 OR %25252501
            // which, depending on the number of decoding steps, will bypass security
            // so, just keep decoding while there are %s and the string is getting shorter
            int nPreviousLen = 0;
            while ( (nPreviousLen != lstrlenW(pszUrl)) && (StrChrW(pszUrl, L'%')))
            {
                nPreviousLen = lstrlenW(pszUrl);
                int nNumPercents;
                int nNumPrevPercents = 0;

                // Reduce the URL
                //
                for (;;)
                {
                    // Count the % signs.
                    //
                    nNumPercents = 0;

                    WCHAR *pch = pszUrl;
                    while (pch = StrChrW(pch, L'%'))
                    {
                        pch++;
                        nNumPercents++;
                    }

                    // If the number of % signs has changed, we've reduced the URL one iteration.
                    //
                    if (nNumPercents != nNumPrevPercents)
                    {
                        WCHAR szBuf[INTERNET_MAX_URL_LENGTH];
                        DWORD dwSize;

                        // Encode the URL 
                        hr = CoInternetParseUrl(pszUrl, 
                            PARSE_ENCODE, 
                            0,
                            szBuf,
                            INTERNET_MAX_URL_LENGTH,
                            &dwSize,
                            0);

                        StrCpyNW(pszUrl, szBuf, cchUrl);

                        nNumPrevPercents = nNumPercents;
                    }
                    else
                    {
                        // The URL is fully reduced.  Break out of loop.
                        //
                        break;
                    }
                }
            }

            // Now scan for '\1' characters.
            //
            if (StrChrW(pszUrl, L'\1'))
            {
                // If there are '\1' characters, we can't guarantee the safety.  Put up "Permission Denied".
                //
                hr = E_ACCESSDENIED;
            }
        }
    }

    return hr;
}


static HRESULT GetAMoniker
(
     IUnknown *                         pUnk,
     LPCWSTR                            szTarget,
     IMoniker * *                       ppMoniker
)
{
   HRESULT hr;
   IBindHost * pBindHost = 0;

   hr = GetAnInterface
       (
           pUnk,
           IID_IBindHost,
           (void**)&pBindHost,
           TRUE,
           IID_IBindHost,
           IID_IBindHost,
           NULL
       );

   if( pBindHost )
   {
      hr = pBindHost->CreateMoniker((LPWSTR)szTarget,NULL,ppMoniker,0);
          pBindHost->Release();
   }
   else
      hr = ::CreateURLMoniker(0,szTarget,ppMoniker);

   return(hr);
}


STDAPI HlinkSimpleNavigateToString
(
    /* [in] */ LPCWSTR  szTarget,      // required - target document - null if local jump w/in doc
    /* [in] */ LPCWSTR  szLocation,    // optional, for navigation into middle of a doc
    /* [in] */ LPCWSTR  szTargetFrame,   // optional, for targeting frame-sets
    /* [in] */ IUnknown *pUnk,         // required - we'll search this for other necessary interfaces
    /* [in] */ IBindCtx *pBndctx,          // optional. caller may register an IBSC in this
    /* [in] */ IBindStatusCallback * pBscb,
    /* [in] */ DWORD    grfHLNF,       // flags (TBD - HadiP needs to define this correctly?)
    /* [in] */ DWORD    dwReserved     // for future use, must be NULL
)
{
    IWebBrowserApp  *pExplorer = 0;
    IHlinkFrame     *pHlframe  = 0;
    ITargetFrame    *pTargetFrame = 0;
        IMoniker            *pMoniker = 0;

    HRESULT         hr = S_OK;

    if ( szTarget && *szTarget )
        hr = GetAMoniker( pUnk, szTarget, &pMoniker );

        if ( SUCCEEDED(hr) )
                hr = HlinkSimpleNavigateToMoniker (
                           pMoniker,
                           szLocation,
                           szTargetFrame,
                           pUnk,
                           pBndctx,
                           pBscb,
                           grfHLNF,
                           dwReserved );

        if ( pMoniker )
                pMoniker->Release();

    return( hr );

}

#define ARRAYSIZE(a)    (sizeof(a)/sizeof(a[0]))

BOOL AccessAllowed(LPCWSTR pwszURL1, LPCWSTR pwszURL2)
{
    BOOL fRet = FALSE;
    IInternetSecurityManager *pSecMgr = NULL;

    if (pwszURL1 && pwszURL2)
    {
        if (StrCmpW(pwszURL1, pwszURL2) == 0)
        {
            // No need to check if URLs are the same
            fRet = TRUE;
        }
        else if (SUCCEEDED(CoCreateInstance(CLSID_InternetSecurityManager, 
                                            NULL, 
                                            CLSCTX_INPROC_SERVER,
                                            IID_IInternetSecurityManager, 
                                            (void **)&pSecMgr)))
        {
            BYTE reqSid[MAX_SIZE_SECURITY_ID], docSid[MAX_SIZE_SECURITY_ID];
            DWORD cbReqSid = ARRAYSIZE(reqSid);
            DWORD cbDocSid = ARRAYSIZE(docSid);

            if (   SUCCEEDED(pSecMgr->GetSecurityId(pwszURL1, reqSid, &cbReqSid, 0))
                && SUCCEEDED(pSecMgr->GetSecurityId(pwszURL2, docSid, &cbDocSid, 0))
                && (cbReqSid == cbDocSid)
                && (memcmp(reqSid, docSid, cbReqSid) == 0))                    
            {
                fRet = TRUE;
            }
            pSecMgr->Release();
        }
    }
    return fRet;
}

BOOL AccessAllowed(ITargetFrame* pSrcFrame, IHlinkFrame* pTargetFrame)
{
    IDispatch*          pdisp[2] = {0};
    IServiceProvider*   pIsp[2] = {0};
    DISPPARAMS          dp;
    VARIANT             VarUrl[2];
    UINT                uiErr;
    BOOL                fRet = FALSE;
    HRESULT             hr;
    int                 idx;

    if(!pTargetFrame || !pSrcFrame)
    {        
        goto cleanup;
    }

    hr = pTargetFrame->QueryInterface(IID_IServiceProvider, (LPVOID *)&pIsp[0]);

    if(hr)
        goto cleanup;

    hr = pSrcFrame->QueryInterface(IID_IServiceProvider, (LPVOID *)&pIsp[1]);

    if(hr)
        goto cleanup;

    VariantInit(&VarUrl[0]);
    VariantInit(&VarUrl[1]);

    for (idx = 0; idx < 2; idx++)
    {
        hr = pIsp[idx]->QueryService(IID_IHTMLWindow2, IID_IDispatch, (LPVOID *)&pdisp[idx]);

        if(hr)
        {
            hr = pIsp[idx]->QueryService(IID_IWebBrowserApp, IID_IDispatch, (LPVOID *)&pdisp[idx]);
        }

        if(hr)
            goto cleanup;

        ZeroMemory((PVOID)&dp, sizeof(dp));

        hr = pdisp[idx]->Invoke(
                    DISPID_SECURITYCTX, 
                    IID_NULL, 
                    LOCALE_SYSTEM_DEFAULT, 
                    DISPATCH_PROPERTYGET,
                    &dp, 
                    &VarUrl[idx], 
                    NULL, 
                    &uiErr);
    
        if(hr)
            goto cleanup;

        if (V_VT(&VarUrl[idx]) != VT_BSTR || !V_BSTR(&VarUrl[idx]))
        {
            goto cleanup;
        }

        if (hr)
            goto cleanup;
    }

    fRet = AccessAllowed(V_BSTR(&VarUrl[0]), V_BSTR(&VarUrl[1]));

cleanup:
    for (idx = 0; idx < 2; idx++)
    {
        if(pdisp[idx])
            pdisp[idx]->Release();
        if(pIsp[idx])
            pIsp[idx]->Release();

        VariantClear(&VarUrl[idx]);
    }
    return fRet;
}



STDAPI HlinkSimpleNavigateToMoniker
(
    /* [in] */ IMoniker *pmkTarget,    // required - target document - (may be null if local jump w/in doc)
    /* [in] */ LPCWSTR  szLocation,    // optional, for navigation into middle of a doc
    /* [in] */ LPCWSTR  szTargetFrame, // optional, for targeting frame-sets
    /* [in] */ IUnknown *pUnk,         // required - we'll search this for other necessary interfaces
    /* [in] */ IBindCtx *pBndctx,      // optional. caller may register an IBSC in this
    /* [in] */ IBindStatusCallback * pBscb,
    /* [in] */ DWORD    grfHLNF,       // flags
    /* [in] */ DWORD    dwReserved     // for future use, must be NULL
)
{
    IWebBrowserApp * pExplorer = 0;
    IHlinkFrame *   pHlframe  = 0;
    ITargetFrame *  pTargetFrameSrc = 0;
    CShellDll       sdll;
    LPWSTR pszUrl = NULL;

    HRESULT         hr, htemp;

    if (pmkTarget == NULL)
    {
         if (szLocation &&  *szLocation)
         {
              grfHLNF |= HLNF_INTERNALJUMP;
              hr = S_OK;
         }
         else
              return E_INVALIDARG; //no location specified for internal jump
    }
    else
    {
        DWORD dwId;

        if (SUCCEEDED(pmkTarget->IsSystemMoniker(&dwId)) &&
            MKSYS_URLMONIKER == dwId)
        {

            if (SUCCEEDED(pmkTarget->GetDisplayName(NULL, NULL, &pszUrl)))
            {
                HRESULT hrSecure = WrapSpecialUrlFlat(pszUrl, lstrlenW(pszUrl) + 1);
                

                if (FAILED(hrSecure))
                {
                    CoTaskMemFree(pszUrl);
                    return hrSecure;
                }
            }
        }
    }

    if (pUnk)
        hr = GetAnInterface
              (
               pUnk,
               IID_IWebBrowserApp,
               (void**)&pExplorer,
               TRUE,
               IID_IHlinkFrame,
               IID_IHlinkFrame,
               (void**)&pHlframe
              );

    IHlink * pLink = 0;

    hr = hlink.HlinkCreateFromMoniker
              (
               pmkTarget,
               szLocation,
               L"TheName",
               0, // hlsite,
               0, NULL,
               IID_IHlink,
               (void**)&pLink
              );

    if (SUCCEEDED(hr) && pHlframe)
    {
        BOOL fAccessAllowed = TRUE;

         if (szTargetFrame && *szTargetFrame)
         {
              long len = (lstrlenW(szTargetFrame) + 1) * sizeof(char);
              char szTargetFrameName[STR_SIZE+1];
              len  = (len > STR_SIZE) ? STR_SIZE : len;
              WideCharToMultiByte(CP_ACP, 0, szTargetFrame, -1, (LPSTR)szTargetFrameName, len, NULL, NULL);
              if (lstrcmpi(szTargetFrameName,"_blank") == 0)
                  grfHLNF |= HLNF_OPENINNEWWINDOW;
              else
              {
                  htemp = GetAnInterface
                           (
                             pUnk,
                             IID_ITargetFrame,
                             (void**)&pTargetFrameSrc,
                             TRUE,
                             IID_ITargetFrame,
                             IID_ITargetFrame,
                             NULL
                            );
                  IUnknown *punkTargetFrame = 0;
                  if (SUCCEEDED(htemp))
                      htemp = pTargetFrameSrc->FindFrame(szTargetFrame,
                                                pHlframe,
                                                FINDFRAME_JUSTTESTEXISTENCE,
                                                &punkTargetFrame);
                  IHlinkFrame *pTargetHlinkFrame = 0;
                  if (punkTargetFrame)
                  {
                      IServiceProvider *pIsp = 0;

                      //      Get the IHlinkFrame for the target'ed frame and the source.
                      htemp = punkTargetFrame->QueryInterface(IID_IServiceProvider, (LPVOID *)&pIsp);
                      if (pIsp != NULL)
                      {
                          // NOTE: SID_SHLinkFrame should be the guidService
                          htemp = pIsp->QueryService(IID_IWebBrowserApp, IID_IHlinkFrame, (LPVOID*) &pTargetHlinkFrame);
                          pIsp->Release();
                      }

                      fAccessAllowed = (!IsSpecialUrl(pszUrl) ||
                                        AccessAllowed(pTargetFrameSrc, pTargetHlinkFrame));
                  }
                  else
                  {
                    grfHLNF |= HLNF_OPENINNEWWINDOW;
                  }
                  if (punkTargetFrame)
                      punkTargetFrame->Release();

                  if (pTargetFrameSrc)
                      pTargetFrameSrc->Release();


                  if (pTargetHlinkFrame)
                  {
                      pHlframe->Release();
                      pHlframe = pTargetHlinkFrame;
                  }
              }
         }

         if(!fAccessAllowed)
         {
             hr = E_ACCESSDENIED;
             goto exit;
         }

         hr = pHlframe->Navigate(grfHLNF,
                         pBndctx,
                         pBscb,
                         pLink);
    }
    else
        hr = E_FAIL;


    if ( FAILED(hr) && pHlframe)
    {       // Navigation through pHlframe failed, we will retrieve the
            // corresponding IWebBrowserApp interface and try navigation.
            if (pExplorer)
            {
                    pExplorer->Release();
                    pExplorer = 0;
            }
            pHlframe->QueryInterface(IID_IWebBrowserApp, (void **)&pExplorer);
    }

    if (FAILED(hr) && pExplorer && pmkTarget)
    {
        LPOLESTR szTarget;
        hr = pmkTarget->GetDisplayName(pBndctx,NULL,&szTarget);

            if (SUCCEEDED(hr))
                    hr = pExplorer->Navigate(
                            szTarget,
                            0,
                            0,
                            0,
                            0);

            CoTaskMemFree(szTarget);
    }

// pExplorer->Navigate  ShellExecute's
// We need not ShellExecute when pExplorer is not NULL

    if (FAILED(hr) && !pExplorer && pmkTarget)
    {
       // Our container does not support hyperlinking. We need to shell execute
       // explorer and go to the link.

       // We need to translate the string to ANSI
        CHAR szPath[MAX_PATH];
        DWORD cchPath = MAX_PATH;
        LPOLESTR szTarget;
        pmkTarget->GetDisplayName(pBndctx,NULL,&szTarget);
        int cbStr = 2 * wclen(szTarget + 1);
        
        char *pszAnsiTarget = new char[cbStr];
        if( !pszAnsiTarget )
            goto cleanup;

        // ASSERT(pszAnsiTarget)


        WideCharToMultiByte(CP_ACP, 0, szTarget, -1, pszAnsiTarget, cbStr, 0, 0);
        pszAnsiTarget[cbStr-1] = '\0';


        if(SUCCEEDED(PathCreateFromUrl(pszAnsiTarget, szPath, &cchPath, 0)))
        {
            HANDLE hFile = CreateFile(szPath,
                        GENERIC_READ,
                        FILE_SHARE_READ,
                        NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL);

            if (INVALID_HANDLE_VALUE != hFile)
            {
                CloseHandle(hFile);

                HINSTANCE hInst = NULL;
                if( S_OK == sdll.Init() )
                    hInst = sdll.ShellExecute(
                        NULL, "open", "iexplore.exe", 
                        szPath, NULL, SW_SHOWNORMAL );

                //
                // Return value < 32 indicates error
                //
                hr = ((ULONG_PTR)hInst > 32) ? S_OK : E_FAIL;
            }
            else
                hr = E_FAIL;
        }
        else
        {
            HINSTANCE hInst = NULL;
            if( S_OK == sdll.Init() )
                hInst = sdll.ShellExecute(
                            NULL, "open", "iexplore.exe", 
                            (LPCTSTR)pszAnsiTarget, NULL, SW_SHOWNORMAL );
            //
            // Return value < 32 indicates error
            //
            hr = ((ULONG_PTR)hInst > 32) ? S_OK : E_FAIL;
        }
cleanup:
        if( pszAnsiTarget )
            delete[] pszAnsiTarget;

        CoTaskMemFree(szTarget);
    }

exit:

    if (pExplorer)
        pExplorer->Release();
    if (pHlframe)
        pHlframe->Release();
    if (pLink)
        pLink->Release();
    if(pszUrl)
        CoTaskMemFree(pszUrl);


    return( hr );
}

//////////////////////////////////////////////////////////////////////////
//
//    HlinkGoBack
//
STDAPI HlinkGoBack(IUnknown *pUnk)
{
   IWebBrowserApp *     pExplorer = 0;
   IHlinkFrame *        pHlframe  = 0;
   HRESULT              hr;


   hr = GetAnInterface
         (
          pUnk,
          IID_IWebBrowserApp,
          (void**)&pExplorer,
          TRUE,
          IID_IHlinkFrame,
          IID_IHlinkFrame,
          (void**)&pHlframe
         );

   if ( SUCCEEDED(hr) )
        hr = pHlframe->Navigate(HLNF_NAVIGATINGBACK, 0, 0, 0);

   if ( FAILED(hr) && pExplorer )
        hr = pExplorer->GoBack();

   if ( pExplorer )
            pExplorer->Release();

   if ( pHlframe )
            pHlframe->Release();

   return (hr);
}

//////////////////////////////////////////////////////////////////////////
//
//    HlinkGoForward
//
//////////////////////////////////////////////////////////////////////////

STDAPI HlinkGoForward(IUnknown *pUnk)
{
   IWebBrowserApp *     pExplorer = 0;
   IHlinkFrame *        pHlframe  = 0;
   HRESULT              hr;

   hr = GetAnInterface
         (
          pUnk,
          IID_IWebBrowserApp,
          (void**)&pExplorer,
          TRUE,
          IID_IHlinkFrame,
          IID_IHlinkFrame,
          (void**)&pHlframe
         );

   if (SUCCEEDED(hr))
       hr = pHlframe->Navigate(HLNF_NAVIGATINGFORWARD, 0, 0, 0);

   if ( FAILED(hr) && pExplorer )
       hr = pExplorer->GoForward();

   if ( pExplorer )
           pExplorer->Release();

   if ( pHlframe )
           pHlframe->Release();

   return (hr);
}

//////////////////////////////////////////////////////////////////////////
//
//    HlinkNavigateString
//
//////////////////////////////////////////////////////////////////////////

STDAPI HlinkNavigateString(IUnknown *pUnk, LPCWSTR szTarget)
{
   HRESULT  hr;

   hr = HlinkSimpleNavigateToString(szTarget, NULL, NULL, pUnk, NULL, 0, 0, 0);

   return (hr);
}

//////////////////////////////////////////////////////////////////////////
//
//    HlinkNavigateMoniker
//
//////////////////////////////////////////////////////////////////////////

STDAPI HlinkNavigateMoniker(IUnknown *pUnk, IMoniker *pmkTarget)
{
   HRESULT  hr;

   hr = HlinkSimpleNavigateToMoniker(pmkTarget, NULL, NULL, pUnk, NULL,NULL, 0, 0);

   return (hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\urlmon\urlhlink\memcpy.c ===
/***
*memcpy.c - contains memcpy routine
*
*       Copyright (c) 1988-1993, Microsoft Corporation. All right reserved.
*
*Purpose:
*       memcpy() copies a source memory buffer to a destination buffer.
*       Overlapping buffers are not treated specially, so propogation may occur.
*
*******************************************************************************/

//#include "cruntime.h"
#include <string.h>

#ifdef _MSC_VER
#pragma function(memcpy)
#endif  /* _MSC_VER */

/***
*memcpy - Copy source buffer to destination buffer
*
*Purpose:
*       memcpy() copies a source memory buffer to a destination memory buffer.
*       This routine does NOT recognize overlapping buffers, and thus can lead
*       to propogation.
*
*       For cases where propogation must be avoided, memmove() must be used.
*
*Entry:
*       void *dst = pointer to destination buffer
*       const void *src = pointer to source buffer
*       size_t count = number of bytes to copy
*
*Exit:
*       Returns a pointer to the destination buffer
*
*Exceptions:
*******************************************************************************/

void * __cdecl memcpy (
        void * dst,
        const void * src,
        size_t count
        )
{
        void * ret = dst;

#if defined (_M_MRX000) || defined (_M_ALPHA) || defined (_M_PPC)
        {
        extern void RtlMoveMemory( void *, const void *, size_t count );

        RtlMoveMemory( dst, src, count );
        }
#else  /* defined (_M_MRX000) || defined (_M_ALPHA) || defined (_M_PPC) */
        /*
         * copy from lower addresses to higher addresses
         */
        while (count--) {
                *(char *)dst = *(char *)src;
                dst = (char *)dst + 1;
                src = (char *)src + 1;
        }
#endif  /* defined (_M_MRX000) || defined (_M_ALPHA) || defined (_M_PPC) */

        return(ret);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\urlmon\urlhlink\urlhlink.h ===
#pragma message("MESSAGE: include urlmon.h stead of urlhlink.h")
#include "urlmon.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\urlmon\urlhlink\memcmp.c ===
/***
*memcmp.c - compare two blocks of memory
*
*       Copyright (c) 1985-1993, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines memcmp() - compare two memory blocks lexically and
*       find their order.
*
*******************************************************************************/

//#include "cruntime.h"
#include <string.h>

#ifdef _MSC_VER
#pragma function(memcmp)
#endif  /* _MSC_VER */

/***
*int memcmp(buf1, buf2, count) - compare memory for lexical order
*
*Purpose:
*       Compares count bytes of memory starting at buf1 and buf2
*       and find if equal or which one is first in lexical order.
*
*Entry:
*       void *buf1, *buf2 - pointers to memory sections to compare
*       size_t count - length of sections to compare
*
*Exit:
*       returns < 0 if buf1 < buf2
*       returns  0  if buf1 == buf2
*       returns > 0 if buf1 > buf2
*
*Exceptions:
*
*******************************************************************************/

int __cdecl memcmp (
        const void * buf1,
        const void * buf2,
        size_t count
        )
{
        if (!count)
                return(0);

        while ( --count && *(char *)buf1 == *(char *)buf2 ) {
                buf1 = (char *)buf1 + 1;
                buf2 = (char *)buf2 + 1;
        }

        return( *((unsigned char *)buf1) - *((unsigned char *)buf2) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\urlmon\urlhlink\urlostrm.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:       URLOSTRM.CXX
//
//  Contents:   Public interface and implementation of the URL
//              Open Stream APIs
//
//  Classes:    many (see below)
//
//  Functions:
//
//  History:    04-22-96    VictorS         Created
//              05-16-96    Jobi            Modified
//              06-06-96    Jobi            Modified
//              07-05-96    Ramesh          Modified
//----------------------------------------------------------------------------
#ifndef unix
// For some reaon on unix this causes NOERROR compile errors
#include "winerror.h"
#endif /* unix */
#include "ocidl.h"
#include "servprov.h"
#include "tchar.h"
#include "wininet.h"
#include "urlmki.h"
#include "urlhlink.h"
#include <shlwapi.h>
#include <shlwapip.h>

#define URLOSTRM_DONOT_NOTIFY_ONDATA    0xFF
#define URLOSTRM_NOTIFY_ONDATA            0x00

//----------------------------------------------------------//
//                                                          //
//  This file can never be compiled with the _UNICODE or    //
//  UNICODE macros defined.                                 //
//                                                          //
//----------------------------------------------------------//

//----------------------------------------------------------//
//  MACROS
//----------------------------------------------------------//

    // These macros can go away when macros and implementation of
    // the InetSDK has settled down...

#define IS_E_PENDING(x)  (x == E_PENDING)
#define LPUOSCALLBACK LPBINDSTATUSCALLBACK
#define PUMPREAD(strm) \
            { \
                DWORD dwSize = 0; \
                char * x = new char[20]; \
                hr = strm->Read(x, 20, &dwSize ); \
                if( !IS_E_PENDING(hr) && (dwSize != 0) ) \
                { \
                DPRINTF( ("Data on the over read! %d\n", dwSize) ); \
                } \
                delete x; \
            }

#define HANDLE_ABORT(hr) \
            { if( hr == E_ABORT) \
              { m_bInAbort = 1; \
                if( m_binding ) \
                    m_binding->Abort(); \
                 return(E_ABORT); \
               } \
            }

#define CHECK_MEMORY(ptr) \
            { if( !ptr ) \
              { DPRINTF( ("Failed to alloc memory") ); \
                m_bInAbort = 1; \
                if( m_binding ) \
                    m_binding->Abort(); \
                 return(E_OUTOFMEMORY); \
               } \
            }



    //
    //  Refcount helper
    //

    // Standardized COM Ref counting. ASSUMES that class has a ULONG
    // data member called 'm_ref'.

#define IMPLEMENT_REFCOUNT(clsname) \
        STDMETHOD_(ULONG, AddRef)() \
        {   CHECK_INTERFACE(this); \
            DPRINTF( ("(%#08x) " #clsname "::Addref %d\n", this, m_ref+1) );\
            return(++m_ref); }\
        STDMETHOD_(ULONG, Release)()\
            { CHECK_INTERFACE(this); \
            DPRINTF( ( "(%#08x) " #clsname "::Release : %d\n", this, m_ref-1) );\
            if( !--m_ref )\
            { delete this; return 0; }\
          return m_ref;\
        }



//----------------------------------------------------------
//
//  DEBUG MACROS
//
//----------------------------------------------------------

#ifdef _DEBUG

    // Check the validity of a pointer - use this for all allocated memory

#define CHECK_POINTER(val) \
            if (!(val) || IsBadWritePtr((void *)(val), sizeof(void *))) \
             { DPRINTF( ("BAD POINTER: %s!\n", #val ) ); \
              return E_POINTER; }

    // Check the validity of an interface pointer. Use this for all pointers
    // to C++ objects that are supposed to have vtables.

#define CHECK_INTERFACE(val) \
            if (!(val) || IsBadWritePtr((void *)(val), sizeof(void *)) \
                  || IsBadCodePtr( FARPROC( *((DWORD **)val)) ) ) \
            { DPRINTF( ("BAD INTERFACE: %s!\n", #val ) ); \
               return E_POINTER; }

    // Simple assert. Map this to whatever general
    // framework assert you want.

#define UOSASSERT(x) { if(!(x)) dprintf( "Assert in URLOSTRM API: %s\n", #x ); }

#define DUOS            OutputDebugString( "URLOSTRM API: " );
#define DPRINTF(x)          DUOS dprintf x ;

#ifndef CHECK_METHOD
#define CHECK_METHOD( m, args ) DUOS dprintf( "(%#08x) %s(", this, #m ); dprintf args ; dprintf(")\n");
#endif

#ifndef MEMPRINTF
#define MEMPRINTF(x) DPRINTF(x)
#endif

void dprintf( char * format, ... )
{
    char out[1024];
    va_list marker;
    va_start(marker, format);
    wvsprintf(out, format, marker);
    va_end(marker);
    OutputDebugString( out );
}


#else
#define CHECK_POINTER(x)
#define CHECK_INTERFACE(x)
#define CHECK_METHOD( m, args )
#define UOSASSERT(x)
#define DPRINTF(x)
#define MEMPRINTF(x)
#endif

//----------------------------------------------------------
//
//      Local heap stuff
//
//----------------------------------------------------------

    // Keeping this here makes this code portable to any .dll
static HANDLE   g_hHeap;

#ifdef _DEBUG
    // Uncomment the line below for Debug spew of memory stuff
//#define MONITER_MEMALLOC 1
#endif

#ifdef _DEBUG
static void * _cdecl
operator new( size_t size )
{
    if( !g_hHeap )
        g_hHeap = ::GetProcessHeap();

    // Heap alloc is the fastest gun in the west
    // for the type of allocations we do here.
    void * p = HeapAlloc(g_hHeap, 0, size);

    MEMPRINTF( ("operator new(%d) returns(%#08X)\n",size, DWORD(p)) );

    return(p);
}

static void _cdecl
operator delete ( void *ptr)
{
    MEMPRINTF( ("operator delete(%#08X)\n", DWORD(ptr) ) );

    HeapFree(g_hHeap, 0, ptr);
}
#endif


//----------------------------------------------------------
//
//      class CBuffer
//
//----------------------------------------------------------


//  Generic CBuffer class for quick and dirty mem allocs.
//  Caller must check return results.

class CBuffer
{
  public:
    CBuffer(ULONG cBytes);
    ~CBuffer();

    void *GetBuffer();

  private:
    void *      m_pBuf;
    // we'll use this temp buffer for small cases.
    //
    char        m_szTmpBuf[120];
    unsigned    m_fHeapAlloc:1;
};

inline
CBuffer::CBuffer(ULONG cBytes)
{
   if( !g_hHeap )
        g_hHeap = ::GetProcessHeap();

   m_pBuf = (cBytes <= 120) ? m_szTmpBuf : HeapAlloc(g_hHeap, 0, cBytes);
   m_fHeapAlloc = (cBytes > 120);
}

inline
CBuffer::~CBuffer()
{
    if (m_pBuf && m_fHeapAlloc) HeapFree(g_hHeap, 0, m_pBuf);
}

inline
void * CBuffer::GetBuffer()
{
    return m_pBuf;
}

//=--------------------------------------------------------------------------=
//
//  String ANSI <-> WIDE helper macros
//
//  This stuff stolen from marcwan...
//
// allocates a temporary buffer that will disappear when it goes out of scope
// NOTE: be careful of that -- make sure you use the string in the same or
// nested scope in which you created this buffer. people should not use this
// class directly.  use the macro(s) below.
//
//=--------------------------------------------------------------------------=

#define MAKE_WIDE(ptrname) \
    long __l##ptrname = (lstrlen(ptrname) + 1) * sizeof(WCHAR); \
    CBuffer __CBuffer##ptrname(__l##ptrname); \
    CHECK_POINTER(__CBuffer##ptrname.GetBuffer()); \
    if( !__CBuffer##ptrname.GetBuffer()) \
        return( E_OUTOFMEMORY ); \
    MultiByteToWideChar(CP_ACP, 0, ptrname, -1, \
        (LPWSTR)__CBuffer##ptrname.GetBuffer(), __l##ptrname); \
    LPWSTR __w##ptrname = (LPWSTR)__CBuffer##ptrname.GetBuffer()

#define WIDE_NAME(ptrname) __w##ptrname

#define MAKE_ANSI(ptrname) \
    long __l##ptrname = (lstrlenW(ptrname)*2 + 1) * sizeof(char); \
    CBuffer __CBuffer##ptrname(__l##ptrname); \
    CHECK_POINTER(__CBuffer##ptrname.GetBuffer()); \
    if( !__CBuffer##ptrname.GetBuffer()) \
        return( E_OUTOFMEMORY ); \
    WideCharToMultiByte(CP_ACP, 0, ptrname, -1, \
        (LPSTR)__CBuffer##ptrname.GetBuffer(), __l##ptrname, NULL, NULL); \
    LPSTR __a##ptrname = (LPSTR)__CBuffer##ptrname.GetBuffer()

#define ANSI_NAME(ptrname) __a##ptrname


//----------------------------------------------------------
//
//      Misc helper functions
//
//----------------------------------------------------------

// These registry functions are here for support of backdoor
// flags and screamer features.

static HRESULT
GetRegDword( HKEY mainkey, LPCTSTR subkey, LPCTSTR valueName, DWORD * result )
{
    HKEY    hkey = 0;
    DWORD       dwDisposition;

    LONG dwResult = RegCreateKeyEx(
                         mainkey, subkey,
                        0, // DWORD  Reserved,  // reserved
                        0, // LPTSTR  lpClass,  // address of class string
                        REG_OPTION_NON_VOLATILE, // DWORD  dwOptions,   // special options flag
                        KEY_ALL_ACCESS, // REGSAM  samDesired,  // desired security access
                        0, // LPSECURITY_ATTRIBUTES  lpSecurityAttributes,      // address of key security structure
                        &hkey, // PHKEY  phkResult,     // address of buffer for opened handle
                        &dwDisposition // LPDWORD  lpdwDisposition      // address of disposition value buffer
                       );

    HRESULT hr = dwResult == ERROR_SUCCESS ? NOERROR : E_FAIL;

    if( SUCCEEDED(hr) )
    {
        DWORD dwType;
        DWORD dwSize = sizeof(DWORD);
        DWORD dwSavedResult = *result;

        dwResult = RegQueryValueEx(
                        hkey,   // handle of key to query
                        valueName,
                        0, // LPDWORD  lpReserved,      // reserved
                        &dwType, // LPDWORD  lpType,    // address of buffer for value type
                        (LPBYTE)result, // LPBYTE  lpData,      // address of data buffer
                        &dwSize // LPDWORD  lpcbData    // address of data buffer size
                        );

        hr = dwResult == ERROR_SUCCESS ? NOERROR : E_FAIL;

        if( FAILED(hr) )
            *result = dwSavedResult;
    }

    if( hkey )
        RegCloseKey(hkey);

    return(hr);
}


static HRESULT
GetDLMRegDWord( LPCTSTR valueName, DWORD * result  )
{
    return(GetRegDword( HKEY_LOCAL_MACHINE,
                        _TEXT("Software\\Microsoft\\DownloadManager"),
                        valueName,
                        result ) );
}


static HRESULT
MyCreateFile( LPCWSTR filename, HANDLE & hfile )
{
    // BUGBUG: in retrospect this should be a ansi function
    // not a wide string one.

    HRESULT hr = NOERROR;

/**********
    MAKE_ANSI( filename );

    hfile = ::CreateFileA(
                          ANSI_NAME(filename), // LPCTSTR  lpFileName,    // pointer to name of the file
                          GENERIC_WRITE, // DWORD  dwDesiredAccess,       // access (read-write) mode
                          0, // DWORD  dwShareMode,       // share mode
                          0, // LPSECURITY_ATTRIBUTES  lpSecurityAttributes,      // pointer to security descriptor
                          CREATE_ALWAYS, // DWORD  dwCreationDistribution,        // how to create
                          FILE_ATTRIBUTE_NORMAL, //DWORD  dwFlagsAndAttributes,   // file attributes
                          0  // HANDLE  hTemplateFile   // handle to file with attributes to copy
                         );
*************/
    hfile = CreateFileWrapW(
                filename, 
                GENERIC_WRITE, 
                0, 
                0, 
                CREATE_ALWAYS,
                FILE_ATTRIBUTE_NORMAL,
                0
        );

    // Our code likes HRESULT style error handling

    if( hfile == INVALID_HANDLE_VALUE )
        hr = MK_E_CANTOPENFILE;

    return(hr);
}



//----------------------------------------------------------
//
//      BindStatusCallback base class
//
//----------------------------------------------------------

//
//  This is the base class for the download objects. It implements
// the url mon callback interface (IBindStatusCallback) and
// IServiceProvider -- which it delegates to the caller's IBSCB.
//


    // State flags

class CBaseBSCB :   public IBindStatusCallbackMsg,
                    public IServiceProvider
{
public:

    CBaseBSCB( IUnknown * caller, DWORD bscof, LPUOSCALLBACK callback );
    virtual ~CBaseBSCB();

    STDMETHOD(KickOffDownload)( LPCWSTR szURL );

    // IUnknown
    STDMETHOD(QueryInterface)(REFIID riid, void **ppvObjOut);

    IMPLEMENT_REFCOUNT(CBaseBSCB);

    // IBindStatusCallback

    STDMETHODIMP OnStartBinding(
         DWORD grfBSCOption,
         IBinding  *pib);

    STDMETHODIMP GetPriority(
         LONG  *pnPriority);

    STDMETHODIMP OnLowResource(
         DWORD reserved);

    STDMETHODIMP OnProgress(
         ULONG ulProgress,
         ULONG ulProgressMax,
         ULONG ulStatusCode,
         LPCWSTR szStatusText);

    STDMETHODIMP OnDataAvailable(
         DWORD       grfBSCF,
         DWORD       dwSize,
         FORMATETC  *pformatetc,
         STGMEDIUM  *pstgmed);

    STDMETHODIMP OnStopBinding(
         HRESULT hresult,
         LPCWSTR szError);

    STDMETHODIMP GetBindInfo(
         DWORD  *grfBINDF,
         BINDINFO  *pbindinfo);

    STDMETHODIMP OnObjectAvailable(
         REFIID riid,
         IUnknown  *punk);

    STDMETHODIMP MessagePending(
        DWORD  dwPendingType,
        DWORD  dwPendingRecursion,
        DWORD  dwReserved);

    // IServiceProvider

    STDMETHODIMP QueryService(
            REFGUID rsid,
            REFIID iid,
            void **ppvObj);


    //  Local methods

    void    Abort();
    BOOL    IsAborted();
    BOOL    DownloadDone();
    HRESULT FinalResult();
    void    SetEncodingFlags( ULONG flags );

    IUnknown * Caller();

    // I guess at one point I thought it would be cool
    // to make all of these inlines and isolated from
    // the core functionality.

    HRESULT SignalOnData( DWORD flags, ULONG size, FORMATETC  *pformatetc);
    HRESULT SignalOnProgress( ULONG status, ULONG size, ULONG maxSize, LPCWSTR msg );
    HRESULT SignalOnStopBinding( HRESULT hr, LPCWSTR msg );

    HRESULT SignalOnStartBinding( DWORD grfBSCOption, IBinding  *pib);
    HRESULT SignalOnGetPriority(LONG*);
    HRESULT SignalOnLowResource(DWORD);
    HRESULT SignalGetBindInfo(DWORD  *grfBINDF,BINDINFO  *pbindinfo);

    virtual void    Neutralize();

    ULONG               m_ref;
    LPUOSCALLBACK       m_callback;
    IUnknown *          m_caller;
    IBinding *          m_binding;
    IServiceProvider *  m_callbackServiceProvider;
    IBindStatusCallbackMsg *_pBSCBMsg;
    BOOL                m_bInAbort : 1;
    BOOL                m_bInCache : 1;
    BOOL                m_bCheckedForServiceProvider : 1;
    DWORD               m_readSoFar;
    HRESULT             m_finalResult;

    // See notes above about IStream usage

    IStream *           m_UserStream;

    ULONG               m_maxSize;
    DWORD               m_bscoFlags;
    UINT                m_encoding;
    char                m_szCacheFileName[MAX_PATH];
};


    /*---------------------*/
    /*  INLINES            */
    /*---------------------*/

inline void     CBaseBSCB::Abort()      { m_bInAbort = 1; }
inline BOOL     CBaseBSCB::IsAborted()  { return(m_bInAbort); }
inline HRESULT  CBaseBSCB::FinalResult(){ return( m_finalResult ); }
inline IUnknown*CBaseBSCB::Caller()     { return( m_caller ); }
inline void     CBaseBSCB::SetEncodingFlags( ULONG flags ) { m_encoding = flags; }

inline HRESULT
CBaseBSCB::SignalOnData( DWORD flags, ULONG size, FORMATETC  *pformatetc )
{
        HRESULT hr=NOERROR;

        if(m_bscoFlags!=URLOSTRM_NOTIFY_ONDATA)
        return(hr);

        STGMEDIUM stg;

        stg.tymed = TYMED_ISTREAM;
        stg.pstm  = m_UserStream;
        stg.pUnkForRelease = NULL;

        if(m_callback)
                hr=m_callback->OnDataAvailable(flags,size,pformatetc,&stg);

        return(hr);
}

inline HRESULT
CBaseBSCB::SignalOnProgress( ULONG status, ULONG size, ULONG maxSize, LPCWSTR msg )
{
    if( !m_callback )
        return(NOERROR);

    if( size && !maxSize )
        maxSize = size;

    if( maxSize > m_maxSize )
        m_maxSize = maxSize;

    HRESULT hr = m_callback->OnProgress( size, m_maxSize, status, msg );

    return(hr);
}


inline HRESULT
CBaseBSCB::SignalOnStopBinding( HRESULT hres, LPCWSTR msg )
{
    if( !m_callback )
        return(NOERROR);

    HRESULT hr = m_callback->OnStopBinding( hres, msg );

    return(hr);
}



inline HRESULT
CBaseBSCB::SignalOnStartBinding( DWORD grfBSCOption, IBinding  *pib)
{
    if( !m_callback )
        return(NOERROR);
    return( m_callback->OnStartBinding(grfBSCOption,pib) );
}


inline HRESULT
CBaseBSCB:: SignalOnGetPriority(LONG* lng)
{
    if( !m_callback )
        return(E_NOTIMPL);
    return(m_callback->GetPriority(lng));
}

inline HRESULT
CBaseBSCB:: SignalOnLowResource(DWORD dw)
{
    if( !m_callback )
        return( NOERROR );
    return( m_callback->OnLowResource(dw) );
}

inline HRESULT
CBaseBSCB::SignalGetBindInfo(DWORD *grfBINDF, BINDINFO * pbindinfo)
{
    if( !m_callback )
        return(E_NOTIMPL);
    return( m_callback->GetBindInfo(grfBINDF, pbindinfo) );
}


    /*---------------------*/
    /*  OUT-OF-LINES       */
    /*---------------------*/


// Do nothing CTOR
CBaseBSCB::CBaseBSCB
(
    IUnknown *      caller,
    DWORD               bscof,
    LPUOSCALLBACK       callback
)
{
    m_binding       = 0;
    m_ref               = 0;
    m_bInAbort      = 0;
    m_bCheckedForServiceProvider = 0;
    m_bInCache      = 0;
    m_readSoFar     = 0;
    m_UserStream    = 0;
    m_encoding      = 0;
    m_bscoFlags    = bscof;
    m_callbackServiceProvider = 0;
    m_szCacheFileName[0] = NULL;
        m_finalResult   = S_OK;

    _pBSCBMsg = 0;

    if( (m_callback = callback) != 0 )
        m_callback->AddRef();

    if( (m_caller = caller) != 0 )
        caller->AddRef();
}

// Cleanup just call Neutralize();
CBaseBSCB::~CBaseBSCB()
{
    Neutralize();
}

void
CBaseBSCB::Neutralize()
{
    if( m_binding )
    {
        m_binding->Release();
        m_binding = 0;
    }
    if( m_caller )
    {
        m_caller->Release();
        m_caller = 0;
    }
    if( m_callback )
    {
        m_callback->Release();
        m_callback = 0;
    }
    if( m_callbackServiceProvider )
    {
        m_callbackServiceProvider->Release();
        m_callbackServiceProvider = 0;
    }
    if( m_UserStream )
    {
        m_UserStream->Release();
        m_UserStream = 0;
    }
    if (_pBSCBMsg)
    {
        _pBSCBMsg->Release();
    }
}

// IUnknown::QueryInterface
STDMETHODIMP
CBaseBSCB::QueryInterface
(
    const GUID &iid,
    void **     ppv
)
{
    CHECK_METHOD(CBaseBSCB::QueryInterface, ("") );

    if (iid==IID_IUnknown || iid==IID_IBindStatusCallback)
    {
        *ppv =(IBindStatusCallback*)this;
        AddRef();
        return(NOERROR);
    }


    if( iid==IID_IServiceProvider)
    {
        *ppv =(IServiceProvider*)this;
        AddRef();
        return(NOERROR);
    }

    if (iid==IID_IBindStatusCallbackMsg)
    {
        *ppv =(IBindStatusCallbackMsg*)this;
        AddRef();
        return(NOERROR);
    }


    return( E_NOINTERFACE );
}

// IServiceProvider::QueryService
STDMETHODIMP
CBaseBSCB::QueryService
(
    REFGUID rsid,
    REFIID iid,
    void **ppvObj
)
{
    CHECK_METHOD(CBaseBSCB::QueryService, ("") );

    HRESULT hr = E_NOINTERFACE;

    if (iid==IID_IBindStatusCallback)
    {
        *ppvObj =(IBindStatusCallbackMsg*)this;
        AddRef();
        return(NOERROR);
    }


    if( m_callback )
        hr = m_callback->QueryInterface( iid, ppvObj );

    if( FAILED(hr) && !m_callbackServiceProvider && !m_bCheckedForServiceProvider )
    {
       m_bCheckedForServiceProvider = 1;

       if( m_callback )
       {
            hr = m_callback->QueryInterface
                                (
                                  IID_IServiceProvider,
                                  (void**)&m_callbackServiceProvider
                                );
       }

        if( SUCCEEDED(hr) && m_callbackServiceProvider )
            hr = m_callbackServiceProvider->QueryService(rsid,iid,ppvObj);
        else
            hr = E_NOINTERFACE; // BUGBUG: what's that error code again?
    }

    HANDLE_ABORT(hr);

    return( hr );
}


// IBindStatusCallback::OnStartBinding
STDMETHODIMP
CBaseBSCB::OnStartBinding
(
    DWORD       grfBSCOption,
    IBinding   *pib
)
{
    CHECK_METHOD(CBaseBSCB::OnStartBinding, ("flags: %#08x, IBinding: %#08x",grfBSCOption,pib) );

    CHECK_INTERFACE(pib);

    HRESULT hr = SignalOnStartBinding(grfBSCOption,pib);

    // smooth over user's e_not_implemented for when we
    // return to urlmon

    if( hr == E_NOTIMPL )
        hr = NOERROR;
    else
        HANDLE_ABORT(hr);

    if( SUCCEEDED(hr) )
    {
        pib->AddRef();
        m_binding = pib;
    }

    return( hr );
}


// IBindStatusCallback::GetPriority
STDMETHODIMP
CBaseBSCB::GetPriority
(
    LONG  *pnPriority
)
{
    CHECK_METHOD(CBaseBSCB::GetPriority, ("pnPriority: %#08x", pnPriority) );
    CHECK_POINTER(pnPriority);

    if (!pnPriority)
        return E_POINTER;

    HRESULT hr = SignalOnGetPriority(pnPriority);

    if( hr == E_NOTIMPL )
    {
        // only override if caller doesn't implement.
        *pnPriority = NORMAL_PRIORITY_CLASS;
        hr = NOERROR;
    }
    else
    {
        HANDLE_ABORT(hr);
    }

    return( hr );

}


// IBindStatusCallback::OnLowResource
STDMETHODIMP
CBaseBSCB::OnLowResource( DWORD rsv)
{
    CHECK_METHOD(CBaseBSCB::OnLowResource, ("resv: %#08x",rsv) );

    HRESULT hr = SignalOnLowResource(rsv);

    // Keep downloading...

    if( hr == E_NOTIMPL )
        hr = NOERROR;
    else
        HANDLE_ABORT(hr);

    return( hr );
}


// IBindStatusCallback::OnStopBinding
STDMETHODIMP
CBaseBSCB::OnStopBinding
(
    HRESULT hresult,
    LPCWSTR szError
)
{
    CHECK_METHOD(CBaseBSCB::OnStopBinding, ("%#08X %ws", hresult, szError ? szError : L"[no error]" )  );

    // Store the hresult so we can return it to caller in the
    // blocking/sync case.

    HRESULT hr = SignalOnStopBinding( m_finalResult = hresult, szError );

    if( m_binding )
    {
        m_binding->Release();
        m_binding = 0;
    }

    if( hr == E_NOTIMPL )
        hr = NOERROR;
    else
        HANDLE_ABORT(hr);

    return( hr );
}


// IBindStatusCallback::GetBindInfo

STDMETHODIMP
CBaseBSCB::GetBindInfo
(
    DWORD  *    grfBINDF,
    BINDINFO*   pbindinfo
)
{
    CHECK_METHOD(CBaseBSCB::GetBindInfo, ("grfBINDF: %#08x, pbinfinfo ",grfBINDF) );

    CHECK_POINTER(grfBINDF);
    CHECK_POINTER(pbindinfo);

    *grfBINDF = 0;

    HRESULT hr = SignalGetBindInfo(grfBINDF,pbindinfo);

    if( SUCCEEDED(hr) || (hr == E_NOTIMPL) )
    {
        // Let the derived class choose the bind flags

        if(m_encoding)
        {
            *grfBINDF |= m_encoding;
            pbindinfo->grfBindInfoF |= m_encoding;
        }

        hr = NOERROR;
    }

    HANDLE_ABORT(hr);

    return( hr );
}


// IBindStatusCallback::OnObjectAvailable
STDMETHODIMP
CBaseBSCB::OnObjectAvailable
(
    REFIID riid,
    IUnknown  *punk
)
{
    // This should never be called
    CHECK_METHOD(CBaseBSCB::OnObjectAvailable, ("!") );
    UOSASSERT(0 && "This should never be called");
    return(NOERROR);
}

STDMETHODIMP
CBaseBSCB::OnProgress
(
    ULONG ulProgress,
    ULONG ulProgressMax,
    ULONG ulStatusCode,
    LPCWSTR szStatusText
)
{
    CHECK_METHOD(CBaseBSCB::OnProgress, ("!") );

    // URL moniker has a habit of passing ZERO
    // into ulProgressMax. So.. let's at least
    // pass in the amount we have so far...

    m_maxSize = ulProgressMax ? ulProgressMax : ulProgress;

    // This is useful information for the IStream implementation


    if( ulStatusCode == BINDSTATUS_USINGCACHEDCOPY )
        m_bInCache = TRUE;

    HRESULT hr;

    hr = SignalOnProgress( ulStatusCode, ulProgress, ulProgressMax, szStatusText );

    if( hr == E_NOTIMPL )
        hr = NOERROR;
    else
        HANDLE_ABORT(hr);

    return( hr );
}

// IBindStatusCallback::OnDataAvailable.

STDMETHODIMP
CBaseBSCB::OnDataAvailable
(
    DWORD           grfBSCF,
    DWORD           dwSize,
    FORMATETC  *pformatetc,
    STGMEDIUM  *pstgmed
)
{
    CHECK_METHOD(CBaseBSCB::OnDataAvailable,
                                ("Flags: %x, dwSize: %d", grfBSCF, dwSize) );

    HRESULT hr = NOERROR;

    // N.B Assumption here is that the pstgmed->pstm will always be the same

     if( !m_UserStream )
     {
            // We need to bump the refcount every time we
            // copy and store the pointer.

        m_UserStream = pstgmed->pstm;
        m_UserStream->AddRef();
     }

     if (*m_szCacheFileName == NULL)
     {
         STATSTG statstg;
         DWORD dwVal = 0;

         if (m_UserStream->Stat(&statstg,dwVal) == S_OK)
         {
             if (0==WideCharToMultiByte(  CP_ACP, 0, statstg.pwcsName, lstrlenW(statstg.pwcsName)+1, m_szCacheFileName,
                         MAX_PATH, NULL, NULL))
             {
                   m_szCacheFileName[0] = NULL;
             }
             if (statstg.pwcsName)
             {
                 CoTaskMemFree(statstg.pwcsName);
                 statstg.pwcsName = NULL;
             }
         }
         else
            m_szCacheFileName[0] = NULL;
     }

    hr = SignalOnData( grfBSCF, dwSize, pformatetc );

    // Tell the blocking state machine we are have data.
    // ClearState( WAITING_FOR_DATA );

    if( hr == E_NOTIMPL )
        hr = NOERROR;
    else
        HANDLE_ABORT(hr);

    return( hr );
}

// IBindStatusCallback::MessagePending.

STDMETHODIMP CBaseBSCB::MessagePending(DWORD  dwPendingType, DWORD  dwPendingRecursion, DWORD  dwReserved)
{
    MSG msg;
    HRESULT hr = NOERROR;

    if (m_callback && !_pBSCBMsg)
    {
        hr = m_callback->QueryInterface(IID_IBindStatusCallbackMsg, (void **) &_pBSCBMsg);
    }

    if (_pBSCBMsg && hr == NOERROR )
    {
        hr = _pBSCBMsg->MessagePending(dwPendingType, dwPendingRecursion, dwReserved );
    }

    return hr;
}

HRESULT
CBaseBSCB::KickOffDownload( LPCWSTR szURL )
{
    HRESULT                 hr;
    IOleObject *        pOleObject = 0;
    IServiceProvider *  pServiceProvider = 0;
    BOOL                bUseCaller = (Caller() != 0);
    IMoniker *          pmkr = 0;
    IBindCtx *          pBndCtx = 0;

    CHECK_POINTER(szURL);
    UOSASSERT(*szURL);


    IStream * pstrm = 0;

    // Don't bother if we don't have a caller...

    if( bUseCaller )
    {
        // By convention the we give the caller first crack at service
        // provider. The assumption here is that if they implement it
        // they have the decency to forward QS's to their container.

        hr = Caller()->QueryInterface( IID_IServiceProvider,
                                        (void**)&pServiceProvider );

        if( FAILED(hr) )
        {
            // Ok, now try the 'slow way' : maybe the object is an 'OLE' object
            // that knows about it's client site:

            hr = Caller()->QueryInterface( IID_IOleObject, (void**)&pOleObject );

            if( SUCCEEDED(hr) )
            {
                IOleClientSite * pClientSite = 0;

                hr = pOleObject->GetClientSite(&pClientSite);

                if( SUCCEEDED(hr) )
                {
                    // Now see if we have a service provider at that site
                    hr = pClientSite->QueryInterface
                                            ( IID_IServiceProvider,
                                            (void**)&pServiceProvider );
                }

                if( pClientSite )
                    pClientSite->Release();
            }
            else
            {
                // Ok, it's not an OLE object, maybe it's one of these
                // new fangled 'ObjectWithSites':

                IObjectWithSite * pObjWithSite = 0;

                hr = Caller()->QueryInterface( IID_IObjectWithSite,
                                                    (void**)&pObjWithSite );

                if( SUCCEEDED(hr) )
                {
                    // Now see if we have a service provider at that site

                    hr = pObjWithSite->GetSite(IID_IServiceProvider,
                                                (void**)&pServiceProvider);
                }

                if( pObjWithSite )
                    pObjWithSite->Release();

            }
            if( pOleObject )
                pOleObject->Release();

        }

        // BUGBUG: In the code above we stop looking at one level up --
        //  this may be too harsh and we should loop on client sites
        // until we get to the top...

        if( !pServiceProvider )
            hr = E_UNEXPECTED;

        IBindHost * pBindHost = 0;

        // Ok, we have a service provider, let's see if BindHost is
        // available. (Here there is some upward delegation going on
        // via service provider).

        if( SUCCEEDED(hr) )
            hr = pServiceProvider->QueryService( SID_SBindHost, IID_IBindHost,
                                                        (void**)&pBindHost );

        if( pServiceProvider )
            pServiceProvider->Release();

        pmkr = 0;

        if( pBindHost )
        {
            // This allows the container to actually drive the download
            // by creating it's own moniker.

            hr = pBindHost->CreateMoniker( LPOLESTR(szURL),NULL, &pmkr,0 );



            if( SUCCEEDED(hr) )
            {
                // This allows containers to hook the download for
                // doing progress and aborting

                hr = pBindHost->MonikerBindToStorage(pmkr, NULL, this, IID_IStream,(void**)&pstrm);
            }

            pBindHost->Release();
        }
        else
        {
            bUseCaller = 0;
        }
    }

    if( !bUseCaller )
    {
        // If you are here, then either the caller didn't pass
        // a 'caller' pointer or the caller is not in a BindHost
        // friendly environment.

        hr = ::CreateURLMoniker( 0, szURL, &pmkr );

        if( SUCCEEDED(hr) )
            hr = ::CreateBindCtx( 0, &pBndCtx );

                if( SUCCEEDED(hr) )
                {
                // Register US (not the caller) as the callback. This allows
        // us to hook all notfiications from URL moniker and filter
        // and manipulate to our satifisfaction.
                         hr = ::RegisterBindStatusCallback( pBndCtx, this, 0, 0L );
                }

            if( SUCCEEDED(hr) )
                {
                        hr = pmkr->BindToStorage( pBndCtx, NULL, IID_IStream, (void**)&pstrm );

                        // Smooth out the error code
                if( IS_E_PENDING(hr) )
                            hr = S_OK;
                }

    }

    if( pstrm )
        pstrm->Release();

    if( pmkr )
        pmkr->Release();

    if( pBndCtx )
        pBndCtx->Release();

    return(hr);
}



//----------------------------------------------------------
//
//      CPullDownload
//
//----------------------------------------------------------

// placeholder for covering the URL moniker anomolies

class CPullDownload : public CBaseBSCB
{
public:
    CPullDownload( IUnknown * caller, DWORD bscof, LPUOSCALLBACK callback );
    STDMETHODIMP GetBindInfo(
         DWORD  *grfBINDF,
         BINDINFO  *pbindinfo);
};

inline
CPullDownload::CPullDownload( IUnknown * caller, DWORD bscof, LPUOSCALLBACK callback )
    : CBaseBSCB(caller,bscof,callback)
{
}

STDMETHODIMP
CPullDownload::GetBindInfo
(
        DWORD  *        grfBINDF,
    BINDINFO  * pbindinfo
)
{
    // pointers are validated in base class

    HRESULT hr = CBaseBSCB::GetBindInfo( grfBINDF, pbindinfo );

    if( SUCCEEDED(hr))
    {
        if (*grfBINDF & BINDF_ENFORCERESTRICTED)
            *grfBINDF = BINDF_ASYNCSTORAGE | BINDF_PULLDATA | BINDF_ASYNCHRONOUS | BINDF_ENFORCERESTRICTED;
        else
            *grfBINDF = BINDF_ASYNCSTORAGE | BINDF_PULLDATA | BINDF_ASYNCHRONOUS;
    }

    return(hr);
}
//----------------------------------------------------------
//
//      Push Stream API
//
//----------------------------------------------------------

//
// Class used for implementing push model downloading when used
// in combination with the CStream object.
//
//  The general design for is this class pumps a
//  CBitBucket object with bits and the CStream object makes
//  those bits available to the caller for reading.
//

class CPushDownload : public CBaseBSCB
{
public:
    CPushDownload( IUnknown * caller, DWORD bscof, LPUOSCALLBACK callback );
    ~CPushDownload();
    STDMETHODIMP GetBindInfo(
         DWORD  *grfBINDF,
         BINDINFO  *pbindinfo);
protected:

    // CBaseBSCB

    virtual void  Neutralize();


    // IBindStatusCallback

    STDMETHODIMP OnDataAvailable
    (
         DWORD          grfBSCF,
         DWORD          dwSize,
         FORMATETC *    pFmtetc,
         STGMEDIUM *    pstgmed
    ) ;

private:
    HRESULT CleanupPush();
};


CPushDownload::CPushDownload( IUnknown * caller, DWORD bscof, LPUOSCALLBACK callback )
    : CBaseBSCB(caller,bscof, callback)
{
}

CPushDownload::~CPushDownload()
{
    CleanupPush();
}

void
CPushDownload::Neutralize()
{
    // We have to do special cleanup.

    CleanupPush();

    CBaseBSCB::Neutralize();
}

HRESULT
CPushDownload::CleanupPush()
{
    return(NOERROR);
}

STDMETHODIMP
CPushDownload::OnDataAvailable
(
     DWORD              grfBSCF,
     DWORD              dwSize,
     FORMATETC *    pFmtetc,
     STGMEDIUM *    pstgmed
)
{
    HRESULT hr = NOERROR;

    if( SUCCEEDED(hr) &&  pstgmed->pstm )
    {

        m_UserStream = pstgmed->pstm;

        // Add ref again because we are copying and storing the ptr

        m_UserStream->AddRef();

    }

    if( SUCCEEDED(hr) || IS_E_PENDING(hr) )
        hr = CBaseBSCB::OnDataAvailable(grfBSCF,dwSize,pFmtetc,pstgmed);

    return(hr);
}

STDMETHODIMP
CPushDownload::GetBindInfo
(
        DWORD  *        grfBINDF,
    BINDINFO  * pbindinfo
)
{

    HRESULT hr = CBaseBSCB::GetBindInfo( grfBINDF, pbindinfo );

    // PushDownload can not be ASYNC
    if (*grfBINDF & BINDF_ENFORCERESTRICTED)
        *grfBINDF = BINDF_ENFORCERESTRICTED;
    else
        *grfBINDF = 0;

    return(hr);
}
//----------------------------------------------------------
//
//      Block Stream API
//
//----------------------------------------------------------

class CBlockDownload : public CPushDownload
{
public:
    CBlockDownload( IUnknown * caller, DWORD bscof, LPUOSCALLBACK callback );
    ~CBlockDownload();
    STDMETHODIMP GetBindInfo(
         DWORD  *grfBINDF,
         BINDINFO  *pbindinfo);
    HRESULT GetStream( IStream ** ppStream );
};


inline
CBlockDownload::CBlockDownload( IUnknown * caller, DWORD bscof, LPUOSCALLBACK callback )
    : CPushDownload(caller,bscof, callback)
{

}

template <class T> inline
HRESULT CheckThis( T * AThisPtr )
{
    CHECK_INTERFACE(AThisPtr);
    return(NOERROR);
}

CBlockDownload::~CBlockDownload()
{
    CheckThis(this);
}

HRESULT
CBlockDownload::GetStream( IStream ** ppStream )
{
    // REMEMBER: If you get this pointer and return it
    // to caller YOU MUST add ref it before handing
    // it back via an API

    HRESULT hr = E_FAIL;

    if( m_UserStream )
    {
        *ppStream = m_UserStream;
        hr = S_OK;
    }

    return( hr );
}

STDMETHODIMP
CBlockDownload::GetBindInfo
(
    DWORD      * grfBINDF,
    BINDINFO  * pbindinfo
)
{
    HRESULT hr = CBaseBSCB::GetBindInfo( grfBINDF, pbindinfo );

    return(hr);
}
//----------------------------------------------------------
//
//      Download to file
//
//----------------------------------------------------------

//
// This class implements the File downloading code. It reads from the
// stream from urlmon and writes every buffer directly to disk.
//

class CFileDownload : public CBaseBSCB
{
public:
        CFileDownload( IUnknown * caller, DWORD bscof, LPUOSCALLBACK callback, LPCWSTR szFileName=0);
        ~CFileDownload();
    void SetFileName(LPCWSTR);

    STDMETHODIMP OnDataAvailable(
             DWORD grfBSCF,
             DWORD dwSize,
             FORMATETC  *pformatetc,
             STGMEDIUM  *pstgmed);

    STDMETHODIMP GetBindInfo(
             DWORD  *grfBINDF,
             BINDINFO  *pbindinfo);

    STDMETHOD(KickOffDownload)( LPCWSTR szURL );

    virtual void Neutralize();

private:
    HRESULT Cleanup();

    unsigned char * m_buffer;
    unsigned long   m_bufsize;
    HANDLE          m_file;
    LPCWSTR         m_filename;
    ULONG           m_okFromCache;

};

inline void
CFileDownload::SetFileName(LPCWSTR newFileName)
{
    // ASSUMES Calls to this class are synchronous

    m_filename = newFileName;
}


CFileDownload::CFileDownload
(
        IUnknown *              caller,
        DWORD                   bscof,
        LPUOSCALLBACK            callback,
        LPCWSTR                 szFileName
)
        : CBaseBSCB(caller, bscof, callback)
{
        m_buffer   = 0;
        m_bufsize  = 0;
        m_file     = INVALID_HANDLE_VALUE;
        m_filename = szFileName;

        m_okFromCache = 0;
}

CFileDownload::~CFileDownload()
{
        Cleanup();
}

STDMETHODIMP
CFileDownload::KickOffDownload( LPCWSTR szURL )
{
    // MAGIC: registry flag determines whether we
    // nuke this guy from the cache or not

    GetDLMRegDWord( _TEXT("CacheOk"), &m_okFromCache );
    return( CBaseBSCB::KickOffDownload(szURL) );
}

HRESULT CFileDownload::Cleanup()
{
        if( m_buffer )
        {
                delete m_buffer;
                m_buffer = 0;
        }

        if( m_file != INVALID_HANDLE_VALUE )
        {
                CloseHandle(m_file);
                m_file = INVALID_HANDLE_VALUE;
        }

        return(NOERROR);
}

STDMETHODIMP
CFileDownload::GetBindInfo
(
        DWORD     * grfBINDF,
        BINDINFO  * pbindinfo
)
{

    HRESULT hr = CBaseBSCB::GetBindInfo( grfBINDF, pbindinfo );

    if( SUCCEEDED(hr) && !m_okFromCache )
    {
        if (*grfBINDF & BINDF_ENFORCERESTRICTED)
            *grfBINDF = BINDF_ENFORCERESTRICTED | BINDF_PULLDATA;
        else
            *grfBINDF =  BINDF_PULLDATA;
    }
    
    return(hr);
}


STDMETHODIMP
CFileDownload::OnDataAvailable
(
    DWORD       grfBSCF,
    DWORD       dwSize,
    FORMATETC  *pformatetc,
    STGMEDIUM  *pstgmed
)
{
    // Pointers are validated in base class

    HRESULT hr = CBaseBSCB::OnDataAvailable(grfBSCF,dwSize,pformatetc,pstgmed);

    if( FAILED(hr) || (dwSize == m_readSoFar) )
        return(hr);

    if( (m_file == INVALID_HANDLE_VALUE)  && dwSize )
    {
        CHECK_POINTER(m_filename);

        hr = MyCreateFile(m_filename,m_file);

        if( FAILED(hr) )
            hr = E_ABORT;
    }

    HANDLE_ABORT(hr);

    UOSASSERT( (m_file != INVALID_HANDLE_VALUE) );

    // Only allocate a read buffer if the one we have is not
    // big enough.

    if( m_buffer && (m_bufsize < (dwSize- m_readSoFar+1)) )
    {
        delete m_buffer;
        m_buffer = 0;
        m_bufsize=0;
    }

    if( !m_buffer )
    {
        m_bufsize=dwSize- m_readSoFar+1;
        DPRINTF( ("Allocating read buffer %d\n",m_bufsize) );
        m_buffer = new unsigned char [(dwSize- m_readSoFar+1)];
    }

    CHECK_MEMORY(m_buffer);

    DWORD dwReadThisMuch = dwSize - m_readSoFar;
    DWORD dwActual       = 0;
    DWORD dwCurrentRead  = 0;

    unsigned char * temp = m_buffer;
    do
    {
        hr = m_UserStream->Read(temp,dwReadThisMuch,&dwActual);
        dwCurrentRead += dwActual;
        dwReadThisMuch -= dwActual;
        temp += dwActual;

    }
    while (!(hr == S_FALSE || hr == E_PENDING) && SUCCEEDED(hr));

    if( dwCurrentRead )
    {
        m_readSoFar += (dwReadThisMuch = dwCurrentRead);

        BOOL bWriteOk = ::WriteFile(
                            m_file, // HANDLE  hFile,    // handle to file to write to
                            m_buffer, // LPCVOID  lpBuffer,    // pointer to data to write to file
                            dwReadThisMuch,        // DWORD  nNumberOfBytesToWrite,    // number of bytes to write
                            &dwActual,    // pointer to number of bytes written
                            0 ); // LPOVERLAPPED  lpOverlapped     // addr. of structure needed for overlapped

        if( !bWriteOk )
            hr = E_FAIL;
    }

    // PUMPREAD(pstgmed->pstm);

    if (grfBSCF & BSCF_LASTDATANOTIFICATION)
    {
        CloseHandle(m_file);
        m_file = INVALID_HANDLE_VALUE;
    }

    return( hr );
}
void
CFileDownload::Neutralize()
{
    // We have to do special cleanup.

    Cleanup();

    CBaseBSCB::Neutralize();
}


//----------------------------------------------------------
//
//      Download to Cache file
//  Implementation of the CCacheFileDownload
//
//----------------------------------------------------------
// This class downloads the file to the cache and returns the cache file name
class CCacheFileDownload : public CBaseBSCB
{
public:
        CCacheFileDownload( IUnknown * caller, DWORD bscof, LPUOSCALLBACK callback, LPCWSTR szFileName=0);
        ~CCacheFileDownload();

    STDMETHODIMP OnDataAvailable(
             DWORD grfBSCF,
             DWORD dwSize,
             FORMATETC  *pformatetc,
             STGMEDIUM  *pstgmed);

    STDMETHODIMP GetBindInfo(
             DWORD  *grfBINDF,
             BINDINFO  *pbindinfo);

    STDMETHOD(KickOffDownload)( LPCWSTR szURL );
private:
        DWORD m_readSoFar;
};

CCacheFileDownload::CCacheFileDownload
(
        IUnknown *              caller,
        DWORD                   bscof,
        LPUOSCALLBACK   callback,
        LPCWSTR                 szFileName
)
        : CBaseBSCB(caller, bscof, callback)
{
        m_readSoFar=0;
}

CCacheFileDownload::~CCacheFileDownload()
{
//      Cleanup();
}

STDMETHODIMP
CCacheFileDownload::KickOffDownload( LPCWSTR szURL )
{
    return( CBaseBSCB::KickOffDownload(szURL) );
}

STDMETHODIMP
CCacheFileDownload::GetBindInfo
(
    DWORD     * grfBINDF,
    BINDINFO  * pbindinfo
)
{
    HRESULT hr = CBaseBSCB::GetBindInfo( grfBINDF, pbindinfo );
    *grfBINDF &= ~BINDF_ASYNCHRONOUS; //to fix MSN 5.0 bug 103719.
    return(hr);
}


#define READBLOCKSIZE 8192

STDMETHODIMP
CCacheFileDownload::OnDataAvailable
(
    DWORD       grfBSCF,
    DWORD       dwSize,
    FORMATETC  *pformatetc,
    STGMEDIUM  *pstgmed
)
{
    // Pointers are validated in base class
    HRESULT hr = CBaseBSCB::OnDataAvailable(grfBSCF,dwSize,pformatetc,pstgmed);

    if( FAILED(hr) || (dwSize == m_readSoFar) )
        return(hr);

    IStream * pstm = pstgmed->pstm;
    if (pstm && dwSize > m_readSoFar)
    {
        DWORD dwToRead = dwSize - m_readSoFar;
        DWORD dwActuallyRead = 1; //initialize to force it into loop
        char* lp = NULL;
   
        lp = new char[READBLOCKSIZE+1];
            
        CHECK_MEMORY(lp);

        while (dwActuallyRead)
        {
            dwActuallyRead=0;
            hr = pstm->Read(lp, READBLOCKSIZE, &dwActuallyRead);

            if(hr!=S_OK && hr!=E_PENDING)  // If Read Fails then return Error
                break;
                
            m_readSoFar += dwActuallyRead;
        }
        delete lp;
    }
    return (hr);
}



STDAPI
URLOpenPullStreamW
(
    LPUNKNOWN                   caller,
    LPCWSTR                     szURL,
    DWORD                       dwReserved,
    LPUOSCALLBACK               callback
)
{
    CHECK_POINTER(szURL);

    HRESULT hr;

    CPullDownload * download = new CPullDownload(caller,URLOSTRM_NOTIFY_ONDATA,callback);

    CHECK_POINTER(download);

    if( !download )
        hr = E_OUTOFMEMORY;
    else
    {
        download->SetEncodingFlags(dwReserved);
        hr = download->KickOffDownload(szURL);
    }

    return(hr);
}

STDAPI
URLDownloadToFileW
(
    LPUNKNOWN            caller,
    LPCWSTR             szURL,
    LPCWSTR             szFileName,
    DWORD               dwReserved,
    LPUOSCALLBACK       callback
)
{
    CHECK_POINTER(szURL);
        HRESULT hr;


    CFileDownload * strm = new CFileDownload(caller,URLOSTRM_DONOT_NOTIFY_ONDATA,callback,szFileName);

    CHECK_POINTER(strm);


    if( !strm )
        hr = E_OUTOFMEMORY;
    else
        {
        strm->AddRef(); // So that we have valid handle even after OnStopBinding()
        strm->SetEncodingFlags(dwReserved);
        hr = strm->KickOffDownload(szURL);
        }

    if (strm)
        strm->Release();
    return(hr);
}


extern void DoThreadCleanup(BOOL bInThreadDetach);
extern BOOL  g_bNT5OrGreater;

STDAPI
URLDownloadToCacheFileW
(
    LPUNKNOWN            caller,
    LPCWSTR             szURL,
    LPWSTR              szFileName,
    DWORD               dwBufLength,
    DWORD               dwReserved,
    LPUOSCALLBACK       callback
)
{
        CHECK_POINTER(szURL);

        HRESULT hr=S_OK;

        BOOL fFileURL = FALSE;

        if (dwBufLength <= 0)
        {
            hr = E_OUTOFMEMORY; // Buffer length invalid
            return hr;
        }

        //
        // 1,2, and 3 are reserved for the constants
        // URLOSTRM_USECACHE, CACHEONLY and GETNEWESTVERSION constants
        // For Compatibility with previous versions
        //
        dwBufLength = (dwBufLength < 4) ? MAX_PATH : dwBufLength;
        szFileName[0] = NULL;
        // For Cache calls
        MAKE_ANSI(szURL);


        CCacheFileDownload * strm = new CCacheFileDownload(caller,dwBufLength,callback,szFileName);

        CHECK_POINTER(strm);

        if( !strm )
        {
             hr = E_OUTOFMEMORY;
        }
        else
        {
             strm->AddRef(); // So that we have valid handle even after OnStopBinding()
             strm->SetEncodingFlags(dwReserved);
             hr = strm->KickOffDownload(szURL);
        }

        if(SUCCEEDED(hr))
        {
            if (*strm->m_szCacheFileName)
            {
                // If it is a file URL we have to convert it to WIN32 file
                CHAR szPath[MAX_PATH];
                DWORD cchPath = MAX_PATH;

                if(SUCCEEDED(PathCreateFromUrl(strm->m_szCacheFileName, szPath, &cchPath, 0)))
                {
                    fFileURL = TRUE;
                    //  url should now look like a DOS path
                    if (0==MultiByteToWideChar(CP_ACP, 0, 
                                    szPath,-1,
                                    szFileName, dwBufLength))
                    {
                        hr = E_OUTOFMEMORY;
                        szFileName[0] = NULL;
                    }
                    else
                        hr=S_OK;
                }
                if (!fFileURL)
                {
                    if (0==MultiByteToWideChar(CP_ACP, 0, strm->m_szCacheFileName,
                               lstrlen(strm->m_szCacheFileName)+1,
                               szFileName, dwBufLength))
                    {
                         hr = E_OUTOFMEMORY;
                         szFileName[0] = NULL;
                    }
                    else
                         hr=S_OK;
                }
            }
            else
                hr = E_FAIL;
        }

        if (strm)
            strm->Release();

        // WinSE QFE #3411
        // At a minimum, we may need to cleanup the notification hwnd created
        // because this thread can become unresponsive if a broadcast message
        // is sent and the client app isn't pumping messages on this thread.
        // We'll go ahead an do a full tls cleanup.

        // If this is NOT NT5 or greater, then our notification window is not a message window.
        // Clean up our thread data if no other activity on this thread.
        //
        if (!g_bNT5OrGreater)
        {
            DoThreadCleanup(FALSE);
        }

        return(hr);
}


STDAPI
URLOpenBlockingStreamW
(
    LPUNKNOWN            caller,
    LPCWSTR             szURL,
    LPSTREAM*            ppStream,
    DWORD               dwReserved,
    LPUOSCALLBACK       callback
)
{
    CHECK_POINTER(szURL);
    CHECK_POINTER(ppStream);
    HRESULT hr;

    if (!ppStream)
        return E_INVALIDARG;
        
    CBlockDownload * strm = new CBlockDownload(caller,URLOSTRM_DONOT_NOTIFY_ONDATA,callback);

    CHECK_POINTER(strm);
    if( !strm )
        hr = E_OUTOFMEMORY;
    else
    {
        strm->AddRef();
        strm->SetEncodingFlags(dwReserved);
        hr = strm->KickOffDownload(szURL);
    }


    if( SUCCEEDED(hr) )
    {
        hr = strm->GetStream(ppStream);

        // We add ref this pointer because we are handing
        // it back to the user

        if( SUCCEEDED(hr) )
           (*ppStream)->AddRef();
    }

    if (strm)
        strm->Release();

    return(hr);
}


STDAPI
URLOpenStreamW
(
    LPUNKNOWN            caller,
    LPCWSTR             szURL,
    DWORD               dwReserved,
    LPUOSCALLBACK       callback
)
{
    CHECK_POINTER(szURL);
        HRESULT hr;


    CPushDownload * strm = new CPushDownload(caller,URLOSTRM_NOTIFY_ONDATA,callback);

    CHECK_POINTER(strm);

    if( !strm )
        hr = E_OUTOFMEMORY;
    else
    {
        strm->SetEncodingFlags(dwReserved);
        hr = strm->KickOffDownload(szURL);
    }

    return(hr);
}


//
//   ANSI VERSION OF PUBLIC API
//

STDAPI
URLOpenPullStreamA
(
    LPUNKNOWN                    caller,
    LPCSTR                      szURL,
    DWORD                       dwReserved,
    LPUOSCALLBACK               callback
)
{
    MAKE_WIDE(szURL);

    return( URLOpenPullStreamW(caller, WIDE_NAME(szURL), dwReserved, callback) );
}

STDAPI
URLDownloadToFileA
(
    LPUNKNOWN            caller,
    LPCSTR              szURL,
    LPCSTR              szFileName,
    DWORD               dwReserved,
    LPUOSCALLBACK       callback
)
{
    MAKE_WIDE(szURL);
    MAKE_WIDE(szFileName);

    return( URLDownloadToFileW( caller, WIDE_NAME(szURL), WIDE_NAME(szFileName),dwReserved, callback ) );
}

STDAPI
URLDownloadToCacheFileA
(
    LPUNKNOWN            caller,
    LPCSTR              szURL,
    LPSTR               szFileName,
    DWORD               dwBufLength,
    DWORD               dwReserved,
    LPUOSCALLBACK       callback
)
{
        HRESULT hr=E_OUTOFMEMORY;

        if (dwBufLength <= 0)
            return hr;

        MAKE_WIDE(szURL);
        LPWSTR lpwszfilename= new WCHAR[MAX_PATH];

        if (lpwszfilename!=NULL)
        {
                hr=URLDownloadToCacheFileW( caller, WIDE_NAME(szURL), lpwszfilename, MAX_PATH, dwReserved, callback );

                if (SUCCEEDED(hr))
                {
                        // Convert to ANSI.
                        dwBufLength = (dwBufLength < 4) ? MAX_PATH : dwBufLength;
                        if (0==WideCharToMultiByte(     CP_ACP, 0, lpwszfilename, lstrlenW(lpwszfilename)+1,szFileName,
                                                                                dwBufLength, NULL, NULL))
                        {
                                hr = E_OUTOFMEMORY;
                                szFileName[0] = NULL;
                        }
                }
                else
                    szFileName[0] = NULL;
        delete[] lpwszfilename;
        }
        return(hr);
}

STDAPI
URLOpenBlockingStreamA
(
    LPUNKNOWN            caller,
    LPCSTR              szURL,
    LPSTREAM*            ppStream,
    DWORD               dwReserved,
    LPUOSCALLBACK       callback
)
{
    MAKE_WIDE(szURL);

    return( URLOpenBlockingStreamW(caller,WIDE_NAME(szURL),ppStream,dwReserved,callback) );
}


STDAPI
URLOpenStreamA
(
    LPUNKNOWN            caller,
    LPCSTR              szURL,
    DWORD               dwReserved,
    LPUOSCALLBACK       callback
)
{
    MAKE_WIDE(szURL);

    return( URLOpenStreamW(caller,WIDE_NAME(szURL),dwReserved,callback) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\urlmon\urltrack\trkapiw.cxx ===
// 
// Pei-Hwa Lin (peiwhal), July 17, 1997
//

#include "urltrk.h"

#ifdef unix
extern "C"
#endif /* unix */
BOOL WINAPI
IsLoggingEnabledW
(
    IN LPCWSTR  pwszUrl
)
{
    DWORD       cbSize;
    LPSTR       lpUrl = NULL;
    BOOL        bRet = FALSE;

    if (pwszUrl == NULL)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return bRet;
    }

    cbSize = lstrlenW(pwszUrl) + sizeof(WCHAR);
    lpUrl = (LPSTR)LocalAlloc(LPTR, cbSize);
    if (!lpUrl)
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return bRet;
    }

    int i=WideCharToMultiByte(CP_ACP, 0, pwszUrl, -1, lpUrl,
                    cbSize, NULL, NULL);
    if (!i)
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        LocalFree(lpUrl);
        return bRet;
    }

    bRet = IsLoggingEnabledA(lpUrl);
    LocalFree(lpUrl);
    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\urlmon\urlhlink\daytona\makefile.inc ===
obj\*\urlhlink.def: urlhlink.src

!IF $(386)
!IF "$(LINKONLY)"!=""
#MAPSYM=$(_WINBASE)\dev\tools\common\mapsym.exe -nologo
MAPSYM=mapsym.exe -nologo

!IF EXIST($(TARGETPATH)\i386\urlhlink.map)
# generate the sym file from the map file
urlhlink.sym:      $(TARGETPATH)\i386\urlhlink.map
        $(MAPSYM) -o $(TARGETPATH)\i386\urlhlink.sym $(TARGETPATH)\i386\urlhlink.map
        binplace -R $(_NTTREE) $(TARGETPATH)\i386\urlhlink.sym
        binplace -R $(_NTTREE) $(TARGETPATH)\i386\urlhlink.map
!else
# generate the sym file from the dll with coff symbols
urlhlink.sym:      $(TARGETPATH)\i386\urlhlink.lib
        $(MAPSYM) -o $(TARGETPATH)\i386\urlhlink.sym $(TARGETPATH)\i386\urlhlink.map
        binplace -R $(_NTTREE) $(TARGETPATH)\i386\urlhlink.sym
        binplace -R $(_NTTREE) $(TARGETPATH)\i386\urlhlink.map
!endif
!else
urlhlink.sym:      $(TARGETPATH)\i386\urlhlink.map
        echo Only build sym file during link phase.
!endif

!endif


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\urlmon\urltrack\urltrk.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       urltrack.h
//
//  Contents:   precompiled header file for the urltrack directory
//
//  Classes:
//
//  Functions:
//
//  History:    07-25-97   PeihwaL   Created
//
//----------------------------------------------------------------------------

#include <windows.h>
#include <windowsx.h>
#include <ole2.h>               // to get IStream for image.c
#define DISALLOW_Assert
#include <debug.h>
#include <winerror.h>
#include <winnlsp.h>
#include <wininet.h>
#include <winineti.h>
#include <urlmon.h>

typedef struct _MY_LOGGING_INFO {
   LPHIT_LOGGING_INFO   pLogInfo;
   BOOL                 fuseCache;
   BOOL                 fOffLine;
} MY_LOGGING_INFO, * LPMY_LOGGING_INFO;


ULONG _IsLoggingEnabled(LPCSTR  pszUrl);
BOOL  _WriteHitLogging(LPMY_LOGGING_INFO pLogInfo);

BOOL   IsGlobalOffline(void);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\urlmon\urltrack\trkapia.cxx ===
// 
// Pei-Hwa Lin (peiwhal), July 25, 1997
//

#include "urltrk.h"

#define TRACK_FLAGS (TRACK_OFFLINE_CACHE_ENTRY | TRACK_ONLINE_CACHE_ENTRY)

#ifdef unix
extern "C"
#endif /* unix */
BOOL WINAPI
IsLoggingEnabledA
(
    IN LPCSTR  pszUrl
)
{
    CHAR        szCanonicalUrl[INTERNET_MAX_URL_LENGTH];
    DWORD       dwSize = INTERNET_MAX_URL_LENGTH;
    BOOL        fTrack = FALSE;
    ULONG       dwTrack;

    // canonicalize URL
    InternetCanonicalizeUrlA(pszUrl, szCanonicalUrl, &dwSize, ICU_DECODE);
 
    dwTrack = _IsLoggingEnabled(szCanonicalUrl);
      
    fTrack = (dwTrack & TRACK_FLAGS);
    SetLastError(0);
    return fTrack;

}


BOOL WINAPI
WriteHitLogging
(
    IN LPHIT_LOGGING_INFO lpLogInfo
)
{
    CHAR        szCanonicalUrl[INTERNET_MAX_URL_LENGTH];
    DWORD       dwSize = INTERNET_MAX_URL_LENGTH;
    BOOL        bRet = FALSE;
    BOOL        foffline;
    ULONG       dwTrack; 
    MY_LOGGING_INFO  mLi;

    if (!lpLogInfo->lpszLoggedUrlName)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return bRet;
    }

    // canonicalize URL
    InternetCanonicalizeUrlA(lpLogInfo->lpszLoggedUrlName, szCanonicalUrl, &dwSize, ICU_DECODE);
 
    // don't log if it's disalbed at first place
    dwTrack = _IsLoggingEnabled(szCanonicalUrl);

    foffline = IsGlobalOffline();
    if (dwTrack & TRACK_FLAGS)
    {
        if (((dwTrack & TRACK_OFFLINE_CACHE_ENTRY) && foffline) ||
            ((dwTrack & TRACK_ONLINE_CACHE_ENTRY) && !foffline))
        {
            mLi.pLogInfo = lpLogInfo;
            mLi.fOffLine = foffline;
            bRet = _WriteHitLogging(&mLi);
        }
    }
    else
    {
        SetLastError(0);
        bRet = TRUE;
    }

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\urlmon\urltrack\util.cxx ===
/*-------------------------------------------------------*/
//Copyright (c) 1997  Microsoft Corporation
//
//    Util.cpp
//
//Author:
//
//
//Environment:
//
//    User Mode - Win32
//
//Revision History:
/*-------------------------------------------------------*/

#include "urltrk.h"
#include <inetreg.h>

const CHAR c_szLogFormat[] = "hh':'mm':'ss";
const CHAR c_szMode[] = "U";       // unknown
const CHAR c_szLogContainerA[] = "Log";

#define MY_CACHE_ENTRY_INFO_SIZE    512
#define MY_MAX_STRING_LEN           512

BOOL   ConvertToPrefixedURL(LPCSTR lpszUrl, LPSTR *lplpPrefixedUrl);
LPINTERNET_CACHE_ENTRY_INFOA QueryCacheEntry(LPCSTR lpUrl);
HANDLE GetLogFile(LPCSTR lpUrl, LPINTERNET_CACHE_ENTRY_INFOA pce, LPSTR lpFile);
LPSTR GetLogString(LPMY_LOGGING_INFO lpLogInfo);


ULONG _IsLoggingEnabled(LPCSTR  pszUrl)
{
    LPINTERNET_CACHE_ENTRY_INFOA pce;
    LPSTR   lpPfxUrl = NULL;
    ULONG   dwTrack;

    //
    ConvertToPrefixedURL(pszUrl, &lpPfxUrl);
    if (!lpPfxUrl)
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return 0;
    }

    pce = QueryCacheEntry(lpPfxUrl);
    if (!pce)
    {
        GlobalFree(lpPfxUrl);
        SetLastError(ERROR_FILE_NOT_FOUND);
        return 0;
    }

    dwTrack = pce->CacheEntryType;
    GlobalFree(pce);
    GlobalFree(lpPfxUrl);
    return dwTrack; 
}

BOOL _WriteHitLogging(LPMY_LOGGING_INFO pmLi)
{
    LPSTR   lpLogString = NULL;
    LPSTR   lpPfxUrl = NULL;
    LPINTERNET_CACHE_ENTRY_INFOA pce = NULL;
    HANDLE  hFile;
    CHAR    lpFile[MAX_PATH];
    DWORD   dwWritten = 0;
    BOOL    fuseCache;
    BOOL    bRet = FALSE;

    //
    ConvertToPrefixedURL(pmLi->pLogInfo->lpszLoggedUrlName, &lpPfxUrl);
    if (!lpPfxUrl)
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return bRet;
    }

    pce = QueryCacheEntry(lpPfxUrl);
    if (!pce)
    {
        GlobalFree(lpPfxUrl);
        SetLastError(ERROR_FILE_NOT_FOUND);
        return bRet;
    }

    hFile = GetLogFile(lpPfxUrl, pce, &lpFile[0]);
    if (hFile == NULL)
    {
        GlobalFree(lpPfxUrl);
        GlobalFree(pce);
        SetLastError(ERROR_FILE_NOT_FOUND);
        return bRet;
    }
    
    pmLi->fuseCache = GetUrlCacheEntryInfoExA(pmLi->pLogInfo->lpszLoggedUrlName, NULL, NULL, NULL, NULL, NULL, 0);
    lpLogString = GetLogString(pmLi);
    if (!lpLogString)
    {
        GlobalFree(lpPfxUrl);
        GlobalFree(pce);
        CloseHandle(hFile);
        return bRet; 
    }

    bRet = WriteFile(hFile, lpLogString, lstrlenA(lpLogString), &dwWritten, NULL);
       
    CloseHandle(hFile);
    GlobalFree(lpLogString);
    
    // commit change to cache
    if(bRet)
    {
        bRet = CommitUrlCacheEntry(lpPfxUrl, 
                lpFile,    //
                pce->ExpireTime,                    //ExpireTime
                pce->LastModifiedTime,              //LastModifiedTime
                pce->CacheEntryType,
                NULL,                               //lpHeaderInfo
                0,                                  //dwHeaderSize
                NULL,                               //lpszFileExtension
                0);                              //reserved
    }
    
    // free pce
    GlobalFree(pce);
    GlobalFree(lpPfxUrl);

    return bRet;
}


BOOL IsGlobalOffline(void)
{
    DWORD   dwState = 0, dwSize = sizeof(DWORD);
    BOOL    fRet = FALSE;
#ifdef _SBS_
    HMODULE hModuleHandle = GetModuleHandleA("sbswinet.dll");
#else
    HMODULE hModuleHandle = GetModuleHandleA("wininet.dll");
#endif // _SBS_

    if(!hModuleHandle)
        return FALSE;

    if(InternetQueryOptionA(NULL, INTERNET_OPTION_CONNECTED_STATE, &dwState,
        &dwSize))
    {
        if(dwState & INTERNET_STATE_DISCONNECTED_BY_USER)
            fRet = TRUE;
    }

    return fRet;
}

//
// Helper Functions
//
LPSTR GetLogString(LPMY_LOGGING_INFO pmLi)
{
    FILETIME   ftIn, ftOut;
    ULARGE_INTEGER ulIn, ulOut, ulTotal;
    SYSTEMTIME  stIn, stOut;
    LPSTR      lpData = NULL;
    CHAR       pTimeIn[10], pTimeOut[10];
              
    lpData = (LPSTR)GlobalAlloc(LPTR, lstrlenA(pmLi->pLogInfo->lpszExtendedInfo)+MY_MAX_STRING_LEN);
    if (!lpData)
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return NULL;
    }

    // calculate delta of time
    SystemTimeToFileTime(&(pmLi->pLogInfo->StartTime), &ftIn);
    SystemTimeToFileTime(&(pmLi->pLogInfo->EndTime), &ftOut);

	ulIn.LowPart = ftIn.dwLowDateTime;
	ulIn.HighPart = ftIn.dwHighDateTime;
	ulOut.LowPart = ftOut.dwLowDateTime;
	ulOut.HighPart = ftOut.dwHighDateTime;
#ifndef unix
	ulTotal.QuadPart = ulOut.QuadPart - ulIn.QuadPart;
#else
        U_QUAD_PART(ulTotal) = U_QUAD_PART(ulOut) - U_QUAD_PART(ulIn);
#endif /* unix */    
    ftOut.dwLowDateTime = ulTotal.LowPart;
    ftOut.dwHighDateTime = ulTotal.HighPart;
    FileTimeToSystemTime(&ftOut, &stOut);
    stIn = pmLi->pLogInfo->StartTime;

    // log string: timeEnter+Duration
    GetTimeFormat(LOCALE_SYSTEM_DEFAULT, TIME_FORCE24HOURFORMAT, &stIn, c_szLogFormat, pTimeIn, 10);
    GetTimeFormat(LOCALE_SYSTEM_DEFAULT, TIME_FORCE24HOURFORMAT, &stOut, c_szLogFormat, pTimeOut, 10);

    if (!pmLi->pLogInfo->lpszExtendedInfo)
    {
        wsprintf(lpData, "%s %d %.2d-%.2d-%d %s %s\r\n", c_szMode, 
                                pmLi->fuseCache, 
                                stIn.wMonth, stIn.wDay, stIn.wYear,
                                pTimeIn, pTimeOut);
    }
    else
    {
        wsprintf(lpData, "%s %d %.2d-%.2d-%d %s %s %s\r\n", c_szMode, 
                                pmLi->fuseCache, 
                                stIn.wMonth, stIn.wDay, stIn.wYear,
                                pTimeIn, pTimeOut,
                                pmLi->pLogInfo->lpszExtendedInfo);
    }

    return lpData;
}


LPSTR ReadTrackingPrefix(void)
{
    LPSTR  lpPfx = NULL;

    DWORD   cbPfx = 0;
    struct {
        INTERNET_CACHE_CONTAINER_INFOA cInfo;
        CHAR  szBuffer[MAX_PATH+INTERNET_MAX_URL_LENGTH+1];
    } ContainerInfo;
    DWORD   dwModified, dwContainer;
    HANDLE  hEnum;
  
    dwContainer = sizeof(ContainerInfo);
    hEnum = FindFirstUrlCacheContainerA(&dwModified,
                                       &ContainerInfo.cInfo,
                                       &dwContainer,
                                       0);

    if (hEnum)
    {

        for (;;)
        {
            if (!lstrcmpiA(ContainerInfo.cInfo.lpszName, c_szLogContainerA))
            {
                if (ContainerInfo.cInfo.lpszCachePrefix[0])
                {
                    DWORD cb = lstrlenA(ContainerInfo.cInfo.lpszCachePrefix)+sizeof(CHAR);
                    lpPfx = (LPSTR)GlobalAlloc(LPTR, cb);
                    if (!lpPfx)
                    {
                        SetLastError(ERROR_OUTOFMEMORY);
                        break;
                    }

                    lstrcpynA(lpPfx, ContainerInfo.cInfo.lpszCachePrefix, cb);
                }				
                break;
            }

            dwContainer = sizeof(ContainerInfo);
            if (!FindNextUrlCacheContainerA(hEnum, &ContainerInfo.cInfo, &dwContainer))
            {
                if (GetLastError() == ERROR_NO_MORE_ITEMS)
                    break;
            }

        }

        FindCloseUrlCache(hEnum);
    }
   
    return lpPfx;
}


// caller must free lplpPrefixedUrl
BOOL 
ConvertToPrefixedURL(LPCSTR lpszUrl, LPSTR *lplpPrefixedUrl)
{
    BOOL    bret = FALSE;
    LPTSTR  lpPfx = NULL;

    if (!lpszUrl)
        return bret;

    lpPfx = ReadTrackingPrefix();
    if (lpPfx)
    {
        *lplpPrefixedUrl = (LPSTR)GlobalAlloc(LPTR, lstrlenA(lpszUrl)+lstrlenA(lpPfx)+1);
        if (*lplpPrefixedUrl)
        {
            wsprintf(*lplpPrefixedUrl, "%s%s", lpPfx, lpszUrl);
            bret = TRUE;
        }

        GlobalFree(lpPfx);
    }

    return bret;
}

LPINTERNET_CACHE_ENTRY_INFOA
QueryCacheEntry(LPCSTR lpUrl)
{
    // get cache entry info
    LPINTERNET_CACHE_ENTRY_INFOA   lpCE = NULL;
    DWORD    dwEntrySize;
    BOOL     bret = FALSE;

    lpCE = (LPINTERNET_CACHE_ENTRY_INFOA)GlobalAlloc(LPTR, MY_CACHE_ENTRY_INFO_SIZE);
    if (lpCE)
    {
        dwEntrySize = MY_CACHE_ENTRY_INFO_SIZE;

        while (!(bret = GetUrlCacheEntryInfoA(lpUrl, lpCE, &dwEntrySize)))
        {
            if (GetLastError() == ERROR_INSUFFICIENT_BUFFER)
            {
                GlobalFree(lpCE);

                lpCE = (LPINTERNET_CACHE_ENTRY_INFOA)GlobalAlloc(LPTR, dwEntrySize);
                if (!lpCE)
                    break;
            }
            else
                break;
        }
    }

    if (!bret && lpCE)
    {
        GlobalFree(lpCE);
        lpCE = NULL;
        SetLastError(ERROR_FILE_NOT_FOUND);
    }

    return lpCE;

}

HANDLE GetLogFile(LPCSTR lpUrl, LPINTERNET_CACHE_ENTRY_INFOA pce, LPSTR lpFile)
{
    HANDLE  hFile = NULL;    

    // work around -- begin
    if (!CreateUrlCacheEntry(lpUrl, 512, "log", lpFile, 0))
        return NULL;
    
    if (pce->lpszLocalFileName)
    {
        if (!CopyFile(pce->lpszLocalFileName, lpFile, FALSE))
            return NULL;

        DeleteFile(pce->lpszLocalFileName);
    }
    // work around -- end

    hFile = CreateFile(lpFile,
            GENERIC_WRITE,
            FILE_SHARE_READ,
            NULL,
            OPEN_ALWAYS,
            FILE_ATTRIBUTE_NORMAL,  // | FILE_FLAG_SEQUENTIAL_SCAN,  
            NULL);
    
    if (hFile == INVALID_HANDLE_VALUE)
        return NULL;        

    // move file pointer to end
    if (0xFFFFFFFF == SetFilePointer(hFile, 0, 0, FILE_END))
    {
        CloseHandle(hFile);
        hFile = NULL;
    }
    
    return hFile;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\urlmon\utils\afxcoll.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#ifndef __AFXCOLL_H__
#define __AFXCOLL_H__
/*
#ifndef __AFX_H__
        #include <afx.h>
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif
#ifndef _AFX_FULLTYPEINFO
#pragma component(mintypeinfo, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif
*/
/////////////////////////////////////////////////////////////////////////////
// Classes declared in this file

//CObject
        // Arrays
        class CByteArray;           // array of BYTE
        class CWordArray;           // array of WORD
        class CDWordArray;          // array of DWORD
        class CUIntArray;           // array of UINT
        class CPtrArray;            // array of void*
        class CObArray;             // array of CObject*

        // Lists
        class CPtrList;             // list of void*
        class CObList;              // list of CObject*

        // Maps (aka Dictionaries)
        class CMapWordToOb;         // map from WORD to CObject*
        class CMapWordToPtr;        // map from WORD to void*
        class CMapPtrToWord;        // map from void* to WORD
        class CMapPtrToPtr;         // map from void* to void*

        // Special String variants
        class CStringArray;         // array of CStrings
        class CStringList;          // list of CStrings
        class CMapStringToPtr;      // map from CString to void*
        class CMapStringToOb;       // map from CString to CObject*
        class CMapStringToString;   // map from CString to CString

/////////////////////////////////////////////////////////////////////////////

#undef AFX_DATA
#define AFX_DATA AFX_CORE_DATA

////////////////////////////////////////////////////////////////////////////

class CByteArray : public CObject
{

        DECLARE_SERIAL(CByteArray)
public:

// Construction
        CByteArray();

// Attributes
        int GetSize() const;
        int GetUpperBound() const;
        void SetSize(int nNewSize, int nGrowBy = -1);

// Operations
        // Clean up
        void FreeExtra();
        void RemoveAll();

        // Accessing elements
        BYTE GetAt(int nIndex) const;
        void SetAt(int nIndex, BYTE newElement);
        BYTE& ElementAt(int nIndex);

        // Direct Access to the element data (may return NULL)
        const BYTE* GetData() const;
        BYTE* GetData();

        // Potentially growing the array
        void SetAtGrow(int nIndex, BYTE newElement);
        int Add(BYTE newElement);
        int Append(const CByteArray& src);
        void Copy(const CByteArray& src);

        // overloaded operator helpers
        BYTE operator[](int nIndex) const;
        BYTE& operator[](int nIndex);

        // Operations that move elements around
        void InsertAt(int nIndex, BYTE newElement, int nCount = 1);
        void RemoveAt(int nIndex, int nCount = 1);
        void InsertAt(int nStartIndex, CByteArray* pNewArray);

// Implementation
protected:
        BYTE* m_pData;   // the actual array of data
        int m_nSize;     // # of elements (upperBound - 1)
        int m_nMaxSize;  // max allocated
        int m_nGrowBy;   // grow amount

public:
        ~CByteArray();

        void Serialize(CArchive&);
#ifdef _DEBUG
        void Dump(CDumpContext&) const;
        void AssertValid() const;
#endif

protected:
        // local typedefs for class templates
        typedef BYTE BASE_TYPE;
        typedef BYTE BASE_ARG_TYPE;
};


////////////////////////////////////////////////////////////////////////////

class CWordArray : public CObject
{

        DECLARE_SERIAL(CWordArray)
public:

// Construction
        CWordArray();

// Attributes
        int GetSize() const;
        int GetUpperBound() const;
        void SetSize(int nNewSize, int nGrowBy = -1);

// Operations
        // Clean up
        void FreeExtra();
        void RemoveAll();

        // Accessing elements
        WORD GetAt(int nIndex) const;
        void SetAt(int nIndex, WORD newElement);
        WORD& ElementAt(int nIndex);

        // Direct Access to the element data (may return NULL)
        const WORD* GetData() const;
        WORD* GetData();

        // Potentially growing the array
        void SetAtGrow(int nIndex, WORD newElement);
        int Add(WORD newElement);
        int Append(const CWordArray& src);
        void Copy(const CWordArray& src);

        // overloaded operator helpers
        WORD operator[](int nIndex) const;
        WORD& operator[](int nIndex);

        // Operations that move elements around
        void InsertAt(int nIndex, WORD newElement, int nCount = 1);
        void RemoveAt(int nIndex, int nCount = 1);
        void InsertAt(int nStartIndex, CWordArray* pNewArray);

// Implementation
protected:
        WORD* m_pData;   // the actual array of data
        int m_nSize;     // # of elements (upperBound - 1)
        int m_nMaxSize;  // max allocated
        int m_nGrowBy;   // grow amount

public:
        ~CWordArray();

        void Serialize(CArchive&);
#ifdef _DEBUG
        void Dump(CDumpContext&) const;
        void AssertValid() const;
#endif

protected:
        // local typedefs for class templates
        typedef WORD BASE_TYPE;
        typedef WORD BASE_ARG_TYPE;
};


////////////////////////////////////////////////////////////////////////////

class CDWordArray : public CObject
{

        DECLARE_SERIAL(CDWordArray)
public:

// Construction
        CDWordArray();

// Attributes
        int GetSize() const;
        int GetUpperBound() const;
        void SetSize(int nNewSize, int nGrowBy = -1);

// Operations
        // Clean up
        void FreeExtra();
        void RemoveAll();

        // Accessing elements
        DWORD GetAt(int nIndex) const;
        void SetAt(int nIndex, DWORD newElement);
        DWORD& ElementAt(int nIndex);

        // Direct Access to the element data (may return NULL)
        const DWORD* GetData() const;
        DWORD* GetData();

        // Potentially growing the array
        void SetAtGrow(int nIndex, DWORD newElement);
        int Add(DWORD newElement);
        int Append(const CDWordArray& src);
        void Copy(const CDWordArray& src);

        // overloaded operator helpers
        DWORD operator[](int nIndex) const;
        DWORD& operator[](int nIndex);

        // Operations that move elements around
        void InsertAt(int nIndex, DWORD newElement, int nCount = 1);
        void RemoveAt(int nIndex, int nCount = 1);
        void InsertAt(int nStartIndex, CDWordArray* pNewArray);

// Implementation
protected:
        DWORD* m_pData;   // the actual array of data
        int m_nSize;     // # of elements (upperBound - 1)
        int m_nMaxSize;  // max allocated
        int m_nGrowBy;   // grow amount

public:
        ~CDWordArray();

        void Serialize(CArchive&);
#ifdef _DEBUG
        void Dump(CDumpContext&) const;
        void AssertValid() const;
#endif

protected:
        // local typedefs for class templates
        typedef DWORD BASE_TYPE;
        typedef DWORD BASE_ARG_TYPE;
};


////////////////////////////////////////////////////////////////////////////

class CUIntArray : public CObject
{

        DECLARE_DYNAMIC(CUIntArray)
public:

// Construction
        CUIntArray();

// Attributes
        int GetSize() const;
        int GetUpperBound() const;
        void SetSize(int nNewSize, int nGrowBy = -1);

// Operations
        // Clean up
        void FreeExtra();
        void RemoveAll();

        // Accessing elements
        UINT GetAt(int nIndex) const;
        void SetAt(int nIndex, UINT newElement);
        UINT& ElementAt(int nIndex);

        // Direct Access to the element data (may return NULL)
        const UINT* GetData() const;
        UINT* GetData();

        // Potentially growing the array
        void SetAtGrow(int nIndex, UINT newElement);
        int Add(UINT newElement);
        int Append(const CUIntArray& src);
        void Copy(const CUIntArray& src);

        // overloaded operator helpers
        UINT operator[](int nIndex) const;
        UINT& operator[](int nIndex);

        // Operations that move elements around
        void InsertAt(int nIndex, UINT newElement, int nCount = 1);
        void RemoveAt(int nIndex, int nCount = 1);
        void InsertAt(int nStartIndex, CUIntArray* pNewArray);

// Implementation
protected:
        UINT* m_pData;   // the actual array of data
        int m_nSize;     // # of elements (upperBound - 1)
        int m_nMaxSize;  // max allocated
        int m_nGrowBy;   // grow amount

public:
        ~CUIntArray();
#ifdef _DEBUG
        void Dump(CDumpContext&) const;
        void AssertValid() const;
#endif

protected:
        // local typedefs for class templates
        typedef UINT BASE_TYPE;
        typedef UINT BASE_ARG_TYPE;
};


////////////////////////////////////////////////////////////////////////////

class CPtrArray : public CObject
{

        DECLARE_DYNAMIC(CPtrArray)
public:

// Construction
        CPtrArray();

// Attributes
        int GetSize() const;
        int GetUpperBound() const;
        void SetSize(int nNewSize, int nGrowBy = -1);

// Operations
        // Clean up
        void FreeExtra();
        void RemoveAll();

        // Accessing elements
        void* GetAt(int nIndex) const;
        void SetAt(int nIndex, void* newElement);
        void*& ElementAt(int nIndex);

        // Direct Access to the element data (may return NULL)
        const void** GetData() const;
        void** GetData();

        // Potentially growing the array
        void SetAtGrow(int nIndex, void* newElement);
        int Add(void* newElement);
        int Append(const CPtrArray& src);
        void Copy(const CPtrArray& src);

        // overloaded operator helpers
        void* operator[](int nIndex) const;
        void*& operator[](int nIndex);

        // Operations that move elements around
        void InsertAt(int nIndex, void* newElement, int nCount = 1);
        void RemoveAt(int nIndex, int nCount = 1);
        void InsertAt(int nStartIndex, CPtrArray* pNewArray);

// Implementation
protected:
        void** m_pData;   // the actual array of data
        int m_nSize;     // # of elements (upperBound - 1)
        int m_nMaxSize;  // max allocated
        int m_nGrowBy;   // grow amount

public:
        ~CPtrArray();
#ifdef _DEBUG
        void Dump(CDumpContext&) const;
        void AssertValid() const;
#endif

protected:
        // local typedefs for class templates
        typedef void* BASE_TYPE;
        typedef void* BASE_ARG_TYPE;
};


////////////////////////////////////////////////////////////////////////////

class CObArray : public CObject
{

        DECLARE_SERIAL(CObArray)
public:

// Construction
        CObArray();

// Attributes
        int GetSize() const;
        int GetUpperBound() const;
        void SetSize(int nNewSize, int nGrowBy = -1);

// Operations
        // Clean up
        void FreeExtra();
        void RemoveAll();

        // Accessing elements
        CObject* GetAt(int nIndex) const;
        void SetAt(int nIndex, CObject* newElement);
        CObject*& ElementAt(int nIndex);

        // Direct Access to the element data (may return NULL)
        const CObject** GetData() const;
        CObject** GetData();

        // Potentially growing the array
        void SetAtGrow(int nIndex, CObject* newElement);
        int Add(CObject* newElement);
        int Append(const CObArray& src);
        void Copy(const CObArray& src);

        // overloaded operator helpers
        CObject* operator[](int nIndex) const;
        CObject*& operator[](int nIndex);

        // Operations that move elements around
        void InsertAt(int nIndex, CObject* newElement, int nCount = 1);
        void RemoveAt(int nIndex, int nCount = 1);
        void InsertAt(int nStartIndex, CObArray* pNewArray);

// Implementation
protected:
        CObject** m_pData;   // the actual array of data
        int m_nSize;     // # of elements (upperBound - 1)
        int m_nMaxSize;  // max allocated
        int m_nGrowBy;   // grow amount

public:
        ~CObArray();

        void Serialize(CArchive&);
#ifdef _DEBUG
        void Dump(CDumpContext&) const;
        void AssertValid() const;
#endif

protected:
        // local typedefs for class templates
        typedef CObject* BASE_TYPE;
        typedef CObject* BASE_ARG_TYPE;
};


////////////////////////////////////////////////////////////////////////////

class CStringArray : public CObject
{

        DECLARE_SERIAL(CStringArray)
public:

// Construction
        CStringArray();

// Attributes
        int GetSize() const;
        int GetUpperBound() const;
        void SetSize(int nNewSize, int nGrowBy = -1);

// Operations
        // Clean up
        void FreeExtra();
        void RemoveAll();

        // Accessing elements
        CString GetAt(int nIndex) const;
        void SetAt(int nIndex, LPCTSTR newElement);
        CString& ElementAt(int nIndex);

        // Direct Access to the element data (may return NULL)
        const CString* GetData() const;
        CString* GetData();

        // Potentially growing the array
        void SetAtGrow(int nIndex, LPCTSTR newElement);
        int Add(LPCTSTR newElement);
        int Append(const CStringArray& src);
        void Copy(const CStringArray& src);

        // overloaded operator helpers
        CString operator[](int nIndex) const;
        CString& operator[](int nIndex);

        // Operations that move elements around
        void InsertAt(int nIndex, LPCTSTR newElement, int nCount = 1);
        void RemoveAt(int nIndex, int nCount = 1);
        void InsertAt(int nStartIndex, CStringArray* pNewArray);

// Implementation
protected:
        CString* m_pData;   // the actual array of data
        int m_nSize;     // # of elements (upperBound - 1)
        int m_nMaxSize;  // max allocated
        int m_nGrowBy;   // grow amount

public:
        ~CStringArray();

        void Serialize(CArchive&);
#ifdef _DEBUG
        void Dump(CDumpContext&) const;
        void AssertValid() const;
#endif

protected:
        // local typedefs for class templates
        typedef CString BASE_TYPE;
        typedef LPCTSTR BASE_ARG_TYPE;
};


/////////////////////////////////////////////////////////////////////////////

class CPtrList : public CObject
{

        DECLARE_DYNAMIC(CPtrList)

protected:
        struct CNode
        {
                CNode* pNext;
                CNode* pPrev;
                void* data;
        };
public:

// Construction
        CPtrList(int nBlockSize = 10);

// Attributes (head and tail)
        // count of elements
        int GetCount() const;
        BOOL IsEmpty() const;

        // peek at head or tail
        void*& GetHead();
        void* GetHead() const;
        void*& GetTail();
        void* GetTail() const;

// Operations
        // get head or tail (and remove it) - don't call on empty list!
        void* RemoveHead();
        void* RemoveTail();

        // add before head or after tail
        POSITION AddHead(void* newElement);
        POSITION AddTail(void* newElement);

        // add another list of elements before head or after tail
        void AddHead(CPtrList* pNewList);
        void AddTail(CPtrList* pNewList);

        // remove all elements
        void RemoveAll();

        // iteration
        POSITION GetHeadPosition() const;
        POSITION GetTailPosition() const;
        void*& GetNext(POSITION& rPosition); // return *Position++
        void* GetNext(POSITION& rPosition) const; // return *Position++
        void*& GetPrev(POSITION& rPosition); // return *Position--
        void* GetPrev(POSITION& rPosition) const; // return *Position--

        // getting/modifying an element at a given position
        void*& GetAt(POSITION position);
        void* GetAt(POSITION position) const;
        void SetAt(POSITION pos, void* newElement);
        void RemoveAt(POSITION position);

        // inserting before or after a given position
        POSITION InsertBefore(POSITION position, void* newElement);
        POSITION InsertAfter(POSITION position, void* newElement);

        // helper functions (note: O(n) speed)
        POSITION Find(void* searchValue, POSITION startAfter = NULL) const;
                                                // defaults to starting at the HEAD
                                                // return NULL if not found
        POSITION FindIndex(int nIndex) const;
                                                // get the 'nIndex'th element (may return NULL)

// Implementation
protected:
        CNode* m_pNodeHead;
        CNode* m_pNodeTail;
        int m_nCount;
        CNode* m_pNodeFree;
        struct CPlex* m_pBlocks;
        int m_nBlockSize;

        CNode* NewNode(CNode*, CNode*);
        void FreeNode(CNode*);

public:
        ~CPtrList();
#ifdef _DEBUG
        void Dump(CDumpContext&) const;
        void AssertValid() const;
#endif
        // local typedefs for class templates
        typedef void* BASE_TYPE;
        typedef void* BASE_ARG_TYPE;
};


/////////////////////////////////////////////////////////////////////////////

class CObList : public CObject
{

        DECLARE_SERIAL(CObList)

protected:
        struct CNode
        {
                CNode* pNext;
                CNode* pPrev;
                CObject* data;
        };
public:

// Construction
        CObList(int nBlockSize = 10);

// Attributes (head and tail)
        // count of elements
        int GetCount() const;
        BOOL IsEmpty() const;

        // peek at head or tail
        CObject*& GetHead();
        CObject* GetHead() const;
        CObject*& GetTail();
        CObject* GetTail() const;

// Operations
        // get head or tail (and remove it) - don't call on empty list!
        CObject* RemoveHead();
        CObject* RemoveTail();

        // add before head or after tail
        POSITION AddHead(CObject* newElement);
        POSITION AddTail(CObject* newElement);

        // add another list of elements before head or after tail
        void AddHead(CObList* pNewList);
        void AddTail(CObList* pNewList);

        // remove all elements
        void RemoveAll();

        // iteration
        POSITION GetHeadPosition() const;
        POSITION GetTailPosition() const;
        CObject*& GetNext(POSITION& rPosition); // return *Position++
        CObject* GetNext(POSITION& rPosition) const; // return *Position++
        CObject*& GetPrev(POSITION& rPosition); // return *Position--
        CObject* GetPrev(POSITION& rPosition) const; // return *Position--

        // getting/modifying an element at a given position
        CObject*& GetAt(POSITION position);
        CObject* GetAt(POSITION position) const;
        void SetAt(POSITION pos, CObject* newElement);
        void RemoveAt(POSITION position);

        // inserting before or after a given position
        POSITION InsertBefore(POSITION position, CObject* newElement);
        POSITION InsertAfter(POSITION position, CObject* newElement);

        // helper functions (note: O(n) speed)
        POSITION Find(CObject* searchValue, POSITION startAfter = NULL) const;
                                                // defaults to starting at the HEAD
                                                // return NULL if not found
        POSITION FindIndex(int nIndex) const;
                                                // get the 'nIndex'th element (may return NULL)

// Implementation
protected:
        CNode* m_pNodeHead;
        CNode* m_pNodeTail;
        int m_nCount;
        CNode* m_pNodeFree;
        struct CPlex* m_pBlocks;
        int m_nBlockSize;

        CNode* NewNode(CNode*, CNode*);
        void FreeNode(CNode*);

public:
        ~CObList();

        void Serialize(CArchive&);
#ifdef _DEBUG
        void Dump(CDumpContext&) const;
        void AssertValid() const;
#endif
        // local typedefs for class templates
        typedef CObject* BASE_TYPE;
        typedef CObject* BASE_ARG_TYPE;
};


/////////////////////////////////////////////////////////////////////////////

class CStringList : public CObject
{

        DECLARE_SERIAL(CStringList)

protected:
        struct CNode
        {
                CNode* pNext;
                CNode* pPrev;
                CString data;
        };
public:

// Construction
        CStringList(int nBlockSize = 10);

// Attributes (head and tail)
        // count of elements
        int GetCount() const;
        BOOL IsEmpty() const;

        // peek at head or tail
        CString& GetHead();
        CString GetHead() const;
        CString& GetTail();
        CString GetTail() const;

// Operations
        // get head or tail (and remove it) - don't call on empty list!
        CString RemoveHead();
        CString RemoveTail();

        // add before head or after tail
        POSITION AddHead(LPCTSTR newElement);
        POSITION AddTail(LPCTSTR newElement);

        // add another list of elements before head or after tail
        void AddHead(CStringList* pNewList);
        void AddTail(CStringList* pNewList);

        // remove all elements
        void RemoveAll();

        // iteration
        POSITION GetHeadPosition() const;
        POSITION GetTailPosition() const;
        CString& GetNext(POSITION& rPosition); // return *Position++
        CString GetNext(POSITION& rPosition) const; // return *Position++
        CString& GetPrev(POSITION& rPosition); // return *Position--
        CString GetPrev(POSITION& rPosition) const; // return *Position--

        // getting/modifying an element at a given position
        CString& GetAt(POSITION position);
        CString GetAt(POSITION position) const;
        void SetAt(POSITION pos, LPCTSTR newElement);
        void RemoveAt(POSITION position);

        // inserting before or after a given position
        POSITION InsertBefore(POSITION position, LPCTSTR newElement);
        POSITION InsertAfter(POSITION position, LPCTSTR newElement);

        // helper functions (note: O(n) speed)
        POSITION Find(LPCTSTR searchValue, POSITION startAfter = NULL) const;
                                                // defaults to starting at the HEAD
                                                // return NULL if not found
        POSITION FindIndex(int nIndex) const;
                                                // get the 'nIndex'th element (may return NULL)

// Implementation
protected:
        CNode* m_pNodeHead;
        CNode* m_pNodeTail;
        int m_nCount;
        CNode* m_pNodeFree;
        struct CPlex* m_pBlocks;
        int m_nBlockSize;

        CNode* NewNode(CNode*, CNode*);
        void FreeNode(CNode*);

public:
        ~CStringList();

        void Serialize(CArchive&);
#ifdef _DEBUG
        void Dump(CDumpContext&) const;
        void AssertValid() const;
#endif
        // local typedefs for class templates
        typedef CString BASE_TYPE;
        typedef LPCTSTR BASE_ARG_TYPE;
};


/////////////////////////////////////////////////////////////////////////////

class CMapWordToPtr : public CObject
{

        DECLARE_DYNAMIC(CMapWordToPtr)
protected:
        // Association
        struct CAssoc
        {
                CAssoc* pNext;

                WORD key;
                void* value;
        };

public:

// Construction
        CMapWordToPtr(int nBlockSize = 10);

// Attributes
        // number of elements
        int GetCount() const;
        BOOL IsEmpty() const;

        // Lookup
        BOOL Lookup(WORD key, void*& rValue) const;

// Operations
        // Lookup and add if not there
        void*& operator[](WORD key);

        // add a new (key, value) pair
        void SetAt(WORD key, void* newValue);

        // removing existing (key, ?) pair
        BOOL RemoveKey(WORD key);
        void RemoveAll();

        // iterating all (key, value) pairs
        POSITION GetStartPosition() const;
        void GetNextAssoc(POSITION& rNextPosition, WORD& rKey, void*& rValue) const;

        // advanced features for derived classes
        UINT GetHashTableSize() const;
        void InitHashTable(UINT hashSize, BOOL bAllocNow = TRUE);

// Overridables: special non-virtual (see map implementation for details)
        // Routine used to user-provided hash keys
        UINT HashKey(WORD key) const;

// Implementation
protected:
        CAssoc** m_pHashTable;
        UINT m_nHashTableSize;
        int m_nCount;
        CAssoc* m_pFreeList;
        struct CPlex* m_pBlocks;
        int m_nBlockSize;

        CAssoc* NewAssoc();
        void FreeAssoc(CAssoc*);
        CAssoc* GetAssocAt(WORD, UINT&) const;

public:
        ~CMapWordToPtr();
#ifdef _DEBUG
        void Dump(CDumpContext&) const;
        void AssertValid() const;
#endif


protected:
        // local typedefs for CTypedPtrMap class template
        typedef WORD BASE_KEY;
        typedef WORD BASE_ARG_KEY;
        typedef void* BASE_VALUE;
        typedef void* BASE_ARG_VALUE;
};


/////////////////////////////////////////////////////////////////////////////

class CMapPtrToWord : public CObject
{

        DECLARE_DYNAMIC(CMapPtrToWord)
protected:
        // Association
        struct CAssoc
        {
                CAssoc* pNext;

                void* key;
                WORD value;
        };

public:

// Construction
        CMapPtrToWord(int nBlockSize = 10);

// Attributes
        // number of elements
        int GetCount() const;
        BOOL IsEmpty() const;

        // Lookup
        BOOL Lookup(void* key, WORD& rValue) const;

// Operations
        // Lookup and add if not there
        WORD& operator[](void* key);

        // add a new (key, value) pair
        void SetAt(void* key, WORD newValue);

        // removing existing (key, ?) pair
        BOOL RemoveKey(void* key);
        void RemoveAll();

        // iterating all (key, value) pairs
        POSITION GetStartPosition() const;
        void GetNextAssoc(POSITION& rNextPosition, void*& rKey, WORD& rValue) const;

        // advanced features for derived classes
        UINT GetHashTableSize() const;
        void InitHashTable(UINT hashSize, BOOL bAllocNow = TRUE);

// Overridables: special non-virtual (see map implementation for details)
        // Routine used to user-provided hash keys
        UINT HashKey(void* key) const;

// Implementation
protected:
        CAssoc** m_pHashTable;
        UINT m_nHashTableSize;
        int m_nCount;
        CAssoc* m_pFreeList;
        struct CPlex* m_pBlocks;
        int m_nBlockSize;

        CAssoc* NewAssoc();
        void FreeAssoc(CAssoc*);
        CAssoc* GetAssocAt(void*, UINT&) const;

public:
        ~CMapPtrToWord();
#ifdef _DEBUG
        void Dump(CDumpContext&) const;
        void AssertValid() const;
#endif


protected:
        // local typedefs for CTypedPtrMap class template
        typedef void* BASE_KEY;
        typedef void* BASE_ARG_KEY;
        typedef WORD BASE_VALUE;
        typedef WORD BASE_ARG_VALUE;
};


/////////////////////////////////////////////////////////////////////////////

class CMapPtrToPtr : public CObject
{

        DECLARE_DYNAMIC(CMapPtrToPtr)
protected:
        // Association
        struct CAssoc
        {
                CAssoc* pNext;

                void* key;
                void* value;
        };

public:

// Construction
        CMapPtrToPtr(int nBlockSize = 10);

// Attributes
        // number of elements
        int GetCount() const;
        BOOL IsEmpty() const;

        // Lookup
        BOOL Lookup(void* key, void*& rValue) const;

// Operations
        // Lookup and add if not there
        void*& operator[](void* key);

        // add a new (key, value) pair
        void SetAt(void* key, void* newValue);

        // removing existing (key, ?) pair
        BOOL RemoveKey(void* key);
        void RemoveAll();

        // iterating all (key, value) pairs
        POSITION GetStartPosition() const;
        void GetNextAssoc(POSITION& rNextPosition, void*& rKey, void*& rValue) const;

        // advanced features for derived classes
        UINT GetHashTableSize() const;
        void InitHashTable(UINT hashSize, BOOL bAllocNow = TRUE);

// Overridables: special non-virtual (see map implementation for details)
        // Routine used to user-provided hash keys
        UINT HashKey(void* key) const;

// Implementation
protected:
        CAssoc** m_pHashTable;
        UINT m_nHashTableSize;
        int m_nCount;
        CAssoc* m_pFreeList;
        struct CPlex* m_pBlocks;
        int m_nBlockSize;

        CAssoc* NewAssoc();
        void FreeAssoc(CAssoc*);
        CAssoc* GetAssocAt(void*, UINT&) const;

public:
        ~CMapPtrToPtr();
#ifdef _DEBUG
        void Dump(CDumpContext&) const;
        void AssertValid() const;
#endif

        void* GetValueAt(void* key) const;


protected:
        // local typedefs for CTypedPtrMap class template
        typedef void* BASE_KEY;
        typedef void* BASE_ARG_KEY;
        typedef void* BASE_VALUE;
        typedef void* BASE_ARG_VALUE;
};


/////////////////////////////////////////////////////////////////////////////

class CMapWordToOb : public CObject
{

        DECLARE_SERIAL(CMapWordToOb)
protected:
        // Association
        struct CAssoc
        {
                CAssoc* pNext;

                WORD key;
                CObject* value;
        };

public:

// Construction
        CMapWordToOb(int nBlockSize = 10);

// Attributes
        // number of elements
        int GetCount() const;
        BOOL IsEmpty() const;

        // Lookup
        BOOL Lookup(WORD key, CObject*& rValue) const;

// Operations
        // Lookup and add if not there
        CObject*& operator[](WORD key);

        // add a new (key, value) pair
        void SetAt(WORD key, CObject* newValue);

        // removing existing (key, ?) pair
        BOOL RemoveKey(WORD key);
        void RemoveAll();

        // iterating all (key, value) pairs
        POSITION GetStartPosition() const;
        void GetNextAssoc(POSITION& rNextPosition, WORD& rKey, CObject*& rValue) const;

        // advanced features for derived classes
        UINT GetHashTableSize() const;
        void InitHashTable(UINT hashSize, BOOL bAllocNow = TRUE);

// Overridables: special non-virtual (see map implementation for details)
        // Routine used to user-provided hash keys
        UINT HashKey(WORD key) const;

// Implementation
protected:
        CAssoc** m_pHashTable;
        UINT m_nHashTableSize;
        int m_nCount;
        CAssoc* m_pFreeList;
        struct CPlex* m_pBlocks;
        int m_nBlockSize;

        CAssoc* NewAssoc();
        void FreeAssoc(CAssoc*);
        CAssoc* GetAssocAt(WORD, UINT&) const;

public:
        ~CMapWordToOb();

        void Serialize(CArchive&);
#ifdef _DEBUG
        void Dump(CDumpContext&) const;
        void AssertValid() const;
#endif


protected:
        // local typedefs for CTypedPtrMap class template
        typedef WORD BASE_KEY;
        typedef WORD BASE_ARG_KEY;
        typedef CObject* BASE_VALUE;
        typedef CObject* BASE_ARG_VALUE;
};


/////////////////////////////////////////////////////////////////////////////

class CMapStringToPtr : public CObject
{

        DECLARE_DYNAMIC(CMapStringToPtr)
protected:
        // Association
        struct CAssoc
        {
                CAssoc* pNext;
                UINT nHashValue;  // needed for efficient iteration
                CString key;
                void* value;
        };

public:

// Construction
        CMapStringToPtr(int nBlockSize = 10);

// Attributes
        // number of elements
        int GetCount() const;
        BOOL IsEmpty() const;

        // Lookup
        BOOL Lookup(LPCTSTR key, void*& rValue) const;
        BOOL LookupKey(LPCTSTR key, LPCTSTR& rKey) const;

// Operations
        // Lookup and add if not there
        void*& operator[](LPCTSTR key);

        // add a new (key, value) pair
        void SetAt(LPCTSTR key, void* newValue);

        // removing existing (key, ?) pair
        BOOL RemoveKey(LPCTSTR key);
        void RemoveAll();

        // iterating all (key, value) pairs
        POSITION GetStartPosition() const;
        void GetNextAssoc(POSITION& rNextPosition, CString& rKey, void*& rValue) const;

        // advanced features for derived classes
        UINT GetHashTableSize() const;
        void InitHashTable(UINT hashSize, BOOL bAllocNow = TRUE);

// Overridables: special non-virtual (see map implementation for details)
        // Routine used to user-provided hash keys
        UINT HashKey(LPCTSTR key) const;

// Implementation
protected:
        CAssoc** m_pHashTable;
        UINT m_nHashTableSize;
        int m_nCount;
        CAssoc* m_pFreeList;
        struct CPlex* m_pBlocks;
        int m_nBlockSize;

        CAssoc* NewAssoc();
        void FreeAssoc(CAssoc*);
        CAssoc* GetAssocAt(LPCTSTR, UINT&) const;

public:
        ~CMapStringToPtr();
#ifdef _DEBUG
        void Dump(CDumpContext&) const;
        void AssertValid() const;
#endif

protected:
        // local typedefs for CTypedPtrMap class template
        typedef CString BASE_KEY;
        typedef LPCTSTR BASE_ARG_KEY;
        typedef void* BASE_VALUE;
        typedef void* BASE_ARG_VALUE;
};


/////////////////////////////////////////////////////////////////////////////

class CMapStringToOb : public CObject
{

        DECLARE_SERIAL(CMapStringToOb)
protected:
        // Association
        struct CAssoc
        {
                CAssoc* pNext;
                UINT nHashValue;  // needed for efficient iteration
                CString key;
                CObject* value;
        };

public:

// Construction
        CMapStringToOb(int nBlockSize = 10);

// Attributes
        // number of elements
        int GetCount() const;
        BOOL IsEmpty() const;

        // Lookup
        BOOL Lookup(LPCTSTR key, CObject*& rValue) const;
        BOOL LookupKey(LPCTSTR key, LPCTSTR& rKey) const;

// Operations
        // Lookup and add if not there
        CObject*& operator[](LPCTSTR key);

        // add a new (key, value) pair
        void SetAt(LPCTSTR key, CObject* newValue);

        // removing existing (key, ?) pair
        BOOL RemoveKey(LPCTSTR key);
        void RemoveAll();

        // iterating all (key, value) pairs
        POSITION GetStartPosition() const;
        void GetNextAssoc(POSITION& rNextPosition, CString& rKey, CObject*& rValue) const;

        // advanced features for derived classes
        UINT GetHashTableSize() const;
        void InitHashTable(UINT hashSize, BOOL bAllocNow = TRUE);

// Overridables: special non-virtual (see map implementation for details)
        // Routine used to user-provided hash keys
        UINT HashKey(LPCTSTR key) const;

// Implementation
protected:
        CAssoc** m_pHashTable;
        UINT m_nHashTableSize;
        int m_nCount;
        CAssoc* m_pFreeList;
        struct CPlex* m_pBlocks;
        int m_nBlockSize;

        CAssoc* NewAssoc();
        void FreeAssoc(CAssoc*);
        CAssoc* GetAssocAt(LPCTSTR, UINT&) const;

public:
        ~CMapStringToOb();

        void Serialize(CArchive&);
#ifdef _DEBUG
        void Dump(CDumpContext&) const;
        void AssertValid() const;
#endif

protected:
        // local typedefs for CTypedPtrMap class template
        typedef CString BASE_KEY;
        typedef LPCTSTR BASE_ARG_KEY;
        typedef CObject* BASE_VALUE;
        typedef CObject* BASE_ARG_VALUE;
};


/////////////////////////////////////////////////////////////////////////////

class CMapStringToString : public CObject
{

        DECLARE_SERIAL(CMapStringToString)
protected:
        // Association
        struct CAssoc
        {
                CAssoc* pNext;
                UINT nHashValue;  // needed for efficient iteration
                CString key;
                CString value;
        };

public:

// Construction
        CMapStringToString(int nBlockSize = 10);

// Attributes
        // number of elements
        int GetCount() const;
        BOOL IsEmpty() const;

        // Lookup
        BOOL Lookup(LPCTSTR key, CString& rValue) const;
        BOOL LookupKey(LPCTSTR key, LPCTSTR& rKey) const;

// Operations
        // Lookup and add if not there
        CString& operator[](LPCTSTR key);

        // add a new (key, value) pair
        void SetAt(LPCTSTR key, LPCTSTR newValue);

        // removing existing (key, ?) pair
        BOOL RemoveKey(LPCTSTR key);
        void RemoveAll();

        // iterating all (key, value) pairs
        POSITION GetStartPosition() const;
        void GetNextAssoc(POSITION& rNextPosition, CString& rKey, CString& rValue) const;

        // advanced features for derived classes
        UINT GetHashTableSize() const;
        void InitHashTable(UINT hashSize, BOOL bAllocNow = TRUE);

// Overridables: special non-virtual (see map implementation for details)
        // Routine used to user-provided hash keys
        UINT HashKey(LPCTSTR key) const;

// Implementation
protected:
        CAssoc** m_pHashTable;
        UINT m_nHashTableSize;
        int m_nCount;
        CAssoc* m_pFreeList;
        struct CPlex* m_pBlocks;
        int m_nBlockSize;

        CAssoc* NewAssoc();
        void FreeAssoc(CAssoc*);
        CAssoc* GetAssocAt(LPCTSTR, UINT&) const;

public:
        ~CMapStringToString();

        void Serialize(CArchive&);
#ifdef _DEBUG
        void Dump(CDumpContext&) const;
        void AssertValid() const;
#endif

protected:
        // local typedefs for CTypedPtrMap class template
        typedef CString BASE_KEY;
        typedef LPCTSTR BASE_ARG_KEY;
        typedef CString BASE_VALUE;
        typedef LPCTSTR BASE_ARG_VALUE;
};

/////////////////////////////////////////////////////////////////////////////
// Special include for Win32s compatibility
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif

#ifndef __AFXSTATE_H__
        #include <afxstat_.h>   // for MFC private state structures
#endif

/////////////////////////////////////////////////////////////////////////////
// Inline function declarations

#ifdef _AFX_ENABLE_INLINES
#define _AFXCOLL_INLINE inline
#include <afxcoll.inl>
#endif

#undef AFX_DATA
#define AFX_DATA

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif
#ifndef _AFX_FULLTYPEINFO
#pragma component(mintypeinfo, off)
#endif

#endif //!__AFXCOLL_H__

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\urlmon\utils\afxplex_.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#ifndef __AFXPLEX_H__
#define __AFXPLEX_H__

#ifndef __AFX_H__
//        #include <afx.h>
#endif

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef AFX_COLL_SEG
#pragma code_seg(AFX_COLL_SEG)
#endif

struct CPlex     // warning variable length structure
{
        CPlex* pNext;
#if (_AFX_PACKING >= 8)
        DWORD dwReserved[1];    // align on 8 byte boundary
#endif
        // BYTE data[maxNum*elementSize];

        void* data() { return this+1; }

        static CPlex* PASCAL Create(CPlex*& head, UINT nMax, UINT cbElement);
                        // like 'calloc' but no zero fill
                        // may throw memory exceptions

        void FreeDataChain();       // free this one and links
};

#ifdef AFX_COLL_SEG
#pragma code_seg()
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif

#endif //__AFXPLEX_H__

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\urlmon\utils\afxtempl.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#ifndef __AFXTEMPL_H__
#define __AFXTEMPL_H__

#ifndef __AFXPLEX_H__
//#include <afxplex_.h>
//#include "..\utils\afxplex_.h"
#endif

#ifdef unix
#include <mainwin.h>
#endif /* unix */

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif
#ifndef _AFX_FULLTYPEINFO
#pragma component(mintypeinfo, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _DEBUG
static char _szAfxTempl[] = "afxtempl.h";
#undef THIS_FILE
#define THIS_FILE _szAfxTempl
#endif

#ifndef ALL_WARNINGS
#pragma warning(disable: 4114)
#endif

/////////////////////////////////////////////////////////////////////////////
// global helpers (can be overridden)
/*
use our new for now
#ifdef new
#undef new
#define _REDEF_NEW
#endif

#ifndef _INC_NEW
        #include <new.h>
#endif
*/
template<class TYPE>
inline void AFXAPI ConstructElements(TYPE* pElements, int nCount)
{
        ASSERT(nCount == 0 ||
                AfxIsValidAddress(pElements, nCount * sizeof(TYPE)));

        // first do bit-wise zero initialization
        memset((void*)pElements, 0, nCount * sizeof(TYPE));

        // then call the constructor(s)
        for (; nCount--; pElements++)
        {
        }
}

template<class TYPE>
inline void AFXAPI DestructElements(TYPE* pElements, int nCount)
{
        ASSERT(nCount == 0 ||
                AfxIsValidAddress(pElements, nCount * sizeof(TYPE)));

        // call the destructor(s)
        for (; nCount--; pElements++)
                pElements->~TYPE();
}

template<class TYPE>
inline void AFXAPI CopyElements(TYPE* pDest, const TYPE* pSrc, int nCount)
{
        ASSERT(nCount == 0 ||
                AfxIsValidAddress(pDest, nCount * sizeof(TYPE)));
        ASSERT(nCount == 0 ||
                AfxIsValidAddress(pSrc, nCount * sizeof(TYPE)));

        // default is element-copy using assignment
        while (nCount--)
                *pDest++ = *pSrc;
}

template<class TYPE>
void AFXAPI SerializeElements(CArchive& ar, TYPE* pElements, int nCount)
{
        ASSERT(nCount == 0 ||
                AfxIsValidAddress(pElements, nCount * sizeof(TYPE)));

        // default is bit-wise read/write
        if (ar.IsStoring())
                ar.Write((void*)pElements, nCount * sizeof(TYPE));
        else
                ar.Read((void*)pElements, nCount * sizeof(TYPE));
}

#ifdef _DEBUG
#ifndef unix
template<class TYPE>
void AFXAPI DumpElements(CDumpContext& dc, const TYPE* pElements, int nCount)
{
        ASSERT(nCount == 0 ||
                AfxIsValidAddress(pElements, nCount * sizeof(TYPE)));
        &dc; // not used
        pElements;  // not used
        nCount; // not used

        // default does nothing
}
#endif /* unix */
#endif

template<class TYPE, class ARG_TYPE>
BOOL AFXAPI CompareElements(const TYPE* pElement1, const ARG_TYPE* pElement2)
{
        ASSERT(AfxIsValidAddress(pElement1, sizeof(TYPE)));
        ASSERT(AfxIsValidAddress(pElement2, sizeof(ARG_TYPE)));

        return *pElement1 == *pElement2;
}

template<class ARG_KEY>
inline UINT AFXAPI HashKey(ARG_KEY key)
{
        // default identity hash - works for most primitive values
        return PtrToUlong((void*)(DWORD_PTR)key) >> 4;
}

// special versions for CString
template<>
void AFXAPI ConstructElements(CString* pElements, int nCount);
template<>
void AFXAPI DestructElements(CString* pElements, int nCount);
template<>
void AFXAPI CopyElements(CString* pDest, const CString* pSrc, int nCount);
template<>
void AFXAPI SerializeElements(CArchive& ar, CString* pElements, int nCount);
template<>
UINT AFXAPI HashKey(LPCTSTR key);

// forward declarations
class COleVariant;
struct tagVARIANT;

// special versions for COleVariant
/*
void AFXAPI ConstructElements(COleVariant* pElements, int nCount);
void AFXAPI DestructElements(COleVariant* pElements, int nCount);
void AFXAPI CopyElements(COleVariant* pDest, const COleVariant* pSrc, int nCount);
void AFXAPI SerializeElements(CArchive& ar, COleVariant* pElements, int nCount);
void AFXAPI DumpElements(CDumpContext& dc, COleVariant* pElements, int nCount);
UINT AFXAPI HashKey(const struct tagVARIANT& var);
*/

// special versions for guids
//void AFXAPI ConstructElements(GUID* pElements, int nCount);
//void AFXAPI DestructElements(GUID* pElements, int nCount);
//void AFXAPI CopyElements(GUID* pDest, const GUID* pSrc, int nCount);
//void AFXAPI SerializeElements(CArchive& ar, GUID* pElements, int nCount);
//UINT AFXAPI HashKey(GUID key);

template<>
inline UINT AFXAPI HashKey(GUID Key)
{
   UINT hash = 0;
   BYTE FAR* lpb = (BYTE FAR*)&Key;
   UINT cbKey = sizeof(GUID);

   while (cbKey-- != 0)
        hash = 257 * hash + *lpb++;

   return hash;
}

template<>
inline UINT AFXAPI HashKey(SYSTEMTIME Key)
{
   UINT hash = 0;
   BYTE FAR* lpb = (BYTE FAR*)&Key;
   UINT cbKey = sizeof(SYSTEMTIME);

   while (cbKey-- != 0)
        hash = 257 * hash + *lpb++;

   return hash;
}
/*
inline UINT AFXAPI HashKey(IXY Key)
{
   UINT hash = 0;
   BYTE FAR* lpb = (BYTE FAR*)&Key;
   UINT cbKey = sizeof(IXY);

   while (cbKey-- != 0)
        hash = 257 * hash + *lpb++;

   return hash;
}
*/



//#define new DEBUG_NEW

/////////////////////////////////////////////////////////////////////////////
// CArray<TYPE, ARG_TYPE>

template<class TYPE, class ARG_TYPE>
class CArray : public CObject
{
public:
// Construction
        CArray();

// Attributes
        int GetSize() const;
        int GetUpperBound() const;
        void SetSize(int nNewSize, int nGrowBy = -1);

// Operations
        // Clean up
        void FreeExtra();
        void RemoveAll();

        // Accessing elements
        TYPE GetAt(int nIndex) const;
        void SetAt(int nIndex, ARG_TYPE newElement);
        TYPE& ElementAt(int nIndex);

        // Direct Access to the element data (may return NULL)
        const TYPE* GetData() const;
        TYPE* GetData();

        // Potentially growing the array
        void SetAtGrow(int nIndex, ARG_TYPE newElement);
        int Add(ARG_TYPE newElement);
        int Append(const CArray& src);
        void Copy(const CArray& src);

        // overloaded operator helpers
        TYPE operator[](int nIndex) const;
        TYPE& operator[](int nIndex);

        // Operations that move elements around
        void InsertAt(int nIndex, ARG_TYPE newElement, int nCount = 1);
        void RemoveAt(int nIndex, int nCount = 1);
        void InsertAt(int nStartIndex, CArray* pNewArray);

// Implementation
protected:
        TYPE* m_pData;   // the actual array of data
        int m_nSize;     // # of elements (upperBound - 1)
        int m_nMaxSize;  // max allocated
        int m_nGrowBy;   // grow amount

public:
        ~CArray();
        void Serialize(CArchive&);
#ifdef _DEBUG
        void Dump(CDumpContext&) const;
        void AssertValid() const;
#endif
};

/////////////////////////////////////////////////////////////////////////////
// CArray<TYPE, ARG_TYPE> inline functions

template<class TYPE, class ARG_TYPE>
inline int CArray<TYPE, ARG_TYPE>::GetSize() const
        { return m_nSize; }
template<class TYPE, class ARG_TYPE>
inline int CArray<TYPE, ARG_TYPE>::GetUpperBound() const
        { return m_nSize-1; }
template<class TYPE, class ARG_TYPE>
inline void CArray<TYPE, ARG_TYPE>::RemoveAll()
        { SetSize(0, -1); }
template<class TYPE, class ARG_TYPE>
inline TYPE CArray<TYPE, ARG_TYPE>::GetAt(int nIndex) const
        { ASSERT(nIndex >= 0 && nIndex < m_nSize);
                return m_pData[nIndex]; }
template<class TYPE, class ARG_TYPE>
inline void CArray<TYPE, ARG_TYPE>::SetAt(int nIndex, ARG_TYPE newElement)
        { ASSERT(nIndex >= 0 && nIndex < m_nSize);
                m_pData[nIndex] = newElement; }
template<class TYPE, class ARG_TYPE>
inline TYPE& CArray<TYPE, ARG_TYPE>::ElementAt(int nIndex)
        { ASSERT(nIndex >= 0 && nIndex < m_nSize);
                return m_pData[nIndex]; }
template<class TYPE, class ARG_TYPE>
inline const TYPE* CArray<TYPE, ARG_TYPE>::GetData() const
        { return (const TYPE*)m_pData; }
template<class TYPE, class ARG_TYPE>
inline TYPE* CArray<TYPE, ARG_TYPE>::GetData()
        { return (TYPE*)m_pData; }
template<class TYPE, class ARG_TYPE>
inline int CArray<TYPE, ARG_TYPE>::Add(ARG_TYPE newElement)
        { int nIndex = m_nSize;
                SetAtGrow(nIndex, newElement);
                return nIndex; }
template<class TYPE, class ARG_TYPE>
inline TYPE CArray<TYPE, ARG_TYPE>::operator[](int nIndex) const
        { return GetAt(nIndex); }
template<class TYPE, class ARG_TYPE>
inline TYPE& CArray<TYPE, ARG_TYPE>::operator[](int nIndex)
        { return ElementAt(nIndex); }

/////////////////////////////////////////////////////////////////////////////
// CArray<TYPE, ARG_TYPE> out-of-line functions

template<class TYPE, class ARG_TYPE>
CArray<TYPE, ARG_TYPE>::CArray()
{
        m_pData = NULL;
        m_nSize = m_nMaxSize = m_nGrowBy = 0;
}

template<class TYPE, class ARG_TYPE>
CArray<TYPE, ARG_TYPE>::~CArray()
{
        ASSERT_VALID(this);

        if (m_pData != NULL)
        {
                DestructElements(m_pData, m_nSize);
                delete[] (BYTE*)m_pData;
        }
}

template<class TYPE, class ARG_TYPE>
void CArray<TYPE, ARG_TYPE>::SetSize(int nNewSize, int nGrowBy)
{
        ASSERT_VALID(this);
        ASSERT(nNewSize >= 0);

        if (nGrowBy != -1)
                m_nGrowBy = nGrowBy;  // set new size

        if (nNewSize == 0)
        {
                // shrink to nothing
                if (m_pData != NULL)
                {
                        DestructElements(m_pData, m_nSize);
                        delete[] (BYTE*)m_pData;
                        m_pData = NULL;
                }
                m_nSize = m_nMaxSize = 0;
        }
        else if (m_pData == NULL)
        {
                // create one with exact size
#ifdef SIZE_T_MAX
                ASSERT(nNewSize <= SIZE_T_MAX/sizeof(TYPE));    // no overflow
#endif
                m_pData = (TYPE*) new BYTE[nNewSize * sizeof(TYPE)];
                ConstructElements(m_pData, nNewSize);
                m_nSize = m_nMaxSize = nNewSize;
        }
        else if (nNewSize <= m_nMaxSize)
        {
                // it fits
                if (nNewSize > m_nSize)
                {
                        // initialize the new elements
                        ConstructElements(&m_pData[m_nSize], nNewSize-m_nSize);
                }
                else if (m_nSize > nNewSize)
                {
                        // destroy the old elements
                        DestructElements(&m_pData[nNewSize], m_nSize-nNewSize);
                }
                m_nSize = nNewSize;
        }
        else
        {
                // otherwise, grow array
                int nGrowBy = m_nGrowBy;
                if (nGrowBy == 0)
                {
                        // heuristically determine growth when nGrowBy == 0
                        //  (this avoids heap fragmentation in many situations)
                        nGrowBy = m_nSize / 8;
                        nGrowBy = (nGrowBy < 4) ? 4 : ((nGrowBy > 1024) ? 1024 : nGrowBy);
                }
                int nNewMax;
                if (nNewSize < m_nMaxSize + nGrowBy)
                        nNewMax = m_nMaxSize + nGrowBy;  // granularity
                else
                        nNewMax = nNewSize;  // no slush

                ASSERT(nNewMax >= m_nMaxSize);  // no wrap around
#ifdef SIZE_T_MAX
                ASSERT(nNewMax <= SIZE_T_MAX/sizeof(TYPE)); // no overflow
#endif
                TYPE* pNewData = (TYPE*) new BYTE[nNewMax * sizeof(TYPE)];

                // copy new data from old
                memcpy(pNewData, m_pData, m_nSize * sizeof(TYPE));

                // construct remaining elements
                ASSERT(nNewSize > m_nSize);
                ConstructElements(&pNewData[m_nSize], nNewSize-m_nSize);

                // get rid of old stuff (note: no destructors called)
                delete[] (BYTE*)m_pData;
                m_pData = pNewData;
                m_nSize = nNewSize;
                m_nMaxSize = nNewMax;
        }
}

template<class TYPE, class ARG_TYPE>
int CArray<TYPE, ARG_TYPE>::Append(const CArray& src)
{
        ASSERT_VALID(this);
        ASSERT(this != &src);   // cannot append to itself

        int nOldSize = m_nSize;
        SetSize(m_nSize + src.m_nSize);
        CopyElements(m_pData + nOldSize, src.m_pData, src.m_nSize);
        return nOldSize;
}

template<class TYPE, class ARG_TYPE>
void CArray<TYPE, ARG_TYPE>::Copy(const CArray& src)
{
        ASSERT_VALID(this);
        ASSERT(this != &src);   // cannot append to itself

        SetSize(src.m_nSize);
        CopyElements(m_pData, src.m_pData, src.m_nSize);
}

template<class TYPE, class ARG_TYPE>
void CArray<TYPE, ARG_TYPE>::FreeExtra()
{
        ASSERT_VALID(this);

        if (m_nSize != m_nMaxSize)
        {
                // shrink to desired size
#ifdef SIZE_T_MAX
                ASSERT(m_nSize <= SIZE_T_MAX/sizeof(TYPE)); // no overflow
#endif
                TYPE* pNewData = NULL;
                if (m_nSize != 0)
                {
                        pNewData = (TYPE*) new BYTE[m_nSize * sizeof(TYPE)];
                        // copy new data from old
                        memcpy(pNewData, m_pData, m_nSize * sizeof(TYPE));
                }

                // get rid of old stuff (note: no destructors called)
                delete[] (BYTE*)m_pData;
                m_pData = pNewData;
                m_nMaxSize = m_nSize;
        }
}

template<class TYPE, class ARG_TYPE>
void CArray<TYPE, ARG_TYPE>::SetAtGrow(int nIndex, ARG_TYPE newElement)
{
        ASSERT_VALID(this);
        ASSERT(nIndex >= 0);

        if (nIndex >= m_nSize)
                SetSize(nIndex+1, -1);
        m_pData[nIndex] = newElement;
}

template<class TYPE, class ARG_TYPE>
void CArray<TYPE, ARG_TYPE>::InsertAt(int nIndex, ARG_TYPE newElement, int nCount /*=1*/)
{
        ASSERT_VALID(this);
        ASSERT(nIndex >= 0);    // will expand to meet need
        ASSERT(nCount > 0);     // zero or negative size not allowed

        if (nIndex >= m_nSize)
        {
                // adding after the end of the array
                SetSize(nIndex + nCount, -1);   // grow so nIndex is valid
        }
        else
        {
                // inserting in the middle of the array
                int nOldSize = m_nSize;
                SetSize(m_nSize + nCount, -1);  // grow it to new size
                // destroy intial data before copying over it
                DestructElements(&m_pData[nOldSize], nCount);
                // shift old data up to fill gap
                memmove(&m_pData[nIndex+nCount], &m_pData[nIndex],
                        (nOldSize-nIndex) * sizeof(TYPE));

                // re-init slots we copied from
                ConstructElements(&m_pData[nIndex], nCount);
        }

        // insert new value in the gap
        ASSERT(nIndex + nCount <= m_nSize);
        while (nCount--)
                m_pData[nIndex++] = newElement;
}

template<class TYPE, class ARG_TYPE>
void CArray<TYPE, ARG_TYPE>::RemoveAt(int nIndex, int nCount)
{
        ASSERT_VALID(this);
        ASSERT(nIndex >= 0);
        ASSERT(nCount >= 0);
        ASSERT(nIndex + nCount <= m_nSize);

        // just remove a range
        int nMoveCount = m_nSize - (nIndex + nCount);
        DestructElements(&m_pData[nIndex], nCount);
        if (nMoveCount)
                memcpy(&m_pData[nIndex], &m_pData[nIndex + nCount],
                        nMoveCount * sizeof(TYPE));
        m_nSize -= nCount;
}

template<class TYPE, class ARG_TYPE>
void CArray<TYPE, ARG_TYPE>::InsertAt(int nStartIndex, CArray* pNewArray)
{
        ASSERT_VALID(this);
        ASSERT(pNewArray != NULL);
        ASSERT_VALID(pNewArray);
        ASSERT(nStartIndex >= 0);

        if (pNewArray->GetSize() > 0)
        {
                InsertAt(nStartIndex, pNewArray->GetAt(0), pNewArray->GetSize());
                for (int i = 0; i < pNewArray->GetSize(); i++)
                        SetAt(nStartIndex + i, pNewArray->GetAt(i));
        }
}

template<class TYPE, class ARG_TYPE>
void CArray<TYPE, ARG_TYPE>::Serialize(CArchive& ar)
{
        ASSERT_VALID(this);
#ifndef unix
        // UNIX found decl commented out in coll.hxx
        CObject::Serialize(ar);
#else
	MwBugCheck();
#endif /* unix */
#ifndef unix
        if (ar.IsStoring())
        {
                ar.WriteCount(m_nSize);
        }
        else
        {
                DWORD nOldSize = ar.ReadCount();
                SetSize(nOldSize, -1);
        }
        SerializeElements(ar, m_pData, m_nSize);
#endif /* unix */
}

#ifdef _DEBUG
#ifndef unix
template<class TYPE, class ARG_TYPE>
void CArray<TYPE, ARG_TYPE>::Dump(CDumpContext& dc) const
{
        CObject::Dump(dc);

        dc << "with " << m_nSize << " elements";
        if (dc.GetDepth() > 0)
        {
                dc << "\n";
                DumpElements(dc, m_pData, m_nSize);
        }

        dc << "\n";
}
#endif /* unix */

template<class TYPE, class ARG_TYPE>
void CArray<TYPE, ARG_TYPE>::AssertValid() const
{
        CObject::AssertValid();

        if (m_pData == NULL)
        {
                ASSERT(m_nSize == 0);
                ASSERT(m_nMaxSize == 0);
        }
        else
        {
                ASSERT(m_nSize >= 0);
                ASSERT(m_nMaxSize >= 0);
                ASSERT(m_nSize <= m_nMaxSize);
                ASSERT(AfxIsValidAddress(m_pData, m_nMaxSize * sizeof(TYPE)));
        }
}
#endif //_DEBUG

#define _LIST_DEFINED_

#ifndef _LIST_DEFINED_

/////////////////////////////////////////////////////////////////////////////
// CList<TYPE, ARG_TYPE>

template<class TYPE, class ARG_TYPE>
class CList : public CObject
{
protected:
        struct CNode
        {
                CNode* pNext;
                CNode* pPrev;
                TYPE data;
        };
public:
// Construction
        CList(int nBlockSize = 10);

// Attributes (head and tail)
        // count of elements
        int GetCount() const;
        BOOL IsEmpty() const;

        // peek at head or tail
        TYPE& GetHead();
        TYPE GetHead() const;
        TYPE& GetTail();
        TYPE GetTail() const;

// Operations
        // get head or tail (and remove it) - don't call on empty list !
        TYPE RemoveHead();
        TYPE RemoveTail();

        // add before head or after tail
        POSITION AddHead(ARG_TYPE newElement);
        POSITION AddTail(ARG_TYPE newElement);

        // add another list of elements before head or after tail
        void AddHead(CList* pNewList);
        void AddTail(CList* pNewList);

        // remove all elements
        void RemoveAll();

        // iteration
        POSITION GetHeadPosition() const;
        POSITION GetTailPosition() const;
        TYPE& GetNext(POSITION& rPosition); // return *Position++
        TYPE GetNext(POSITION& rPosition) const; // return *Position++
        TYPE& GetPrev(POSITION& rPosition); // return *Position--
        TYPE GetPrev(POSITION& rPosition) const; // return *Position--

        // getting/modifying an element at a given position
        TYPE& GetAt(POSITION position);
        TYPE GetAt(POSITION position) const;
        void SetAt(POSITION pos, ARG_TYPE newElement);
        void RemoveAt(POSITION position);

        // inserting before or after a given position
        POSITION InsertBefore(POSITION position, ARG_TYPE newElement);
        POSITION InsertAfter(POSITION position, ARG_TYPE newElement);

        // helper functions (note: O(n) speed)
        POSITION Find(ARG_TYPE searchValue, POSITION startAfter = NULL) const;
                // defaults to starting at the HEAD, return NULL if not found
        POSITION FindIndex(int nIndex) const;
                // get the 'nIndex'th element (may return NULL)

// Implementation
protected:
        CNode* m_pNodeHead;
        CNode* m_pNodeTail;
        int m_nCount;
        CNode* m_pNodeFree;
        struct CPlex* m_pBlocks;
        int m_nBlockSize;

        CNode* NewNode(CNode*, CNode*);
        void FreeNode(CNode*);

public:
        ~CList();
        void Serialize(CArchive&);
#ifdef _DEBUG
        void Dump(CDumpContext&) const;
        void AssertValid() const;
#endif
};


/////////////////////////////////////////////////////////////////////////////
// CList<TYPE, ARG_TYPE> inline functions

template<class TYPE, class ARG_TYPE>
inline int CList<TYPE, ARG_TYPE>::GetCount() const
        { return m_nCount; }
template<class TYPE, class ARG_TYPE>
inline BOOL CList<TYPE, ARG_TYPE>::IsEmpty() const
        { return m_nCount == 0; }
template<class TYPE, class ARG_TYPE>
inline TYPE& CList<TYPE, ARG_TYPE>::GetHead()
        { ASSERT(m_pNodeHead != NULL);
                return m_pNodeHead->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE CList<TYPE, ARG_TYPE>::GetHead() const
        { ASSERT(m_pNodeHead != NULL);
                return m_pNodeHead->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE& CList<TYPE, ARG_TYPE>::GetTail()
        { ASSERT(m_pNodeTail != NULL);
                return m_pNodeTail->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE CList<TYPE, ARG_TYPE>::GetTail() const
        { ASSERT(m_pNodeTail != NULL);
                return m_pNodeTail->data; }
template<class TYPE, class ARG_TYPE>
inline POSITION CList<TYPE, ARG_TYPE>::GetHeadPosition() const
        { return (POSITION) m_pNodeHead; }
template<class TYPE, class ARG_TYPE>
inline POSITION CList<TYPE, ARG_TYPE>::GetTailPosition() const
        { return (POSITION) m_pNodeTail; }
template<class TYPE, class ARG_TYPE>
inline TYPE& CList<TYPE, ARG_TYPE>::GetNext(POSITION& rPosition) // return *Position++
        { CNode* pNode = (CNode*) rPosition;
                ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
                rPosition = (POSITION) pNode->pNext;
                return pNode->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE CList<TYPE, ARG_TYPE>::GetNext(POSITION& rPosition) const // return *Position++
        { CNode* pNode = (CNode*) rPosition;
                ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
                rPosition = (POSITION) pNode->pNext;
                return pNode->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE& CList<TYPE, ARG_TYPE>::GetPrev(POSITION& rPosition) // return *Position--
        { CNode* pNode = (CNode*) rPosition;
                ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
                rPosition = (POSITION) pNode->pPrev;
                return pNode->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE CList<TYPE, ARG_TYPE>::GetPrev(POSITION& rPosition) const // return *Position--
        { CNode* pNode = (CNode*) rPosition;
                ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
                rPosition = (POSITION) pNode->pPrev;
                return pNode->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE& CList<TYPE, ARG_TYPE>::GetAt(POSITION position)
        { CNode* pNode = (CNode*) position;
                ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
                return pNode->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE CList<TYPE, ARG_TYPE>::GetAt(POSITION position) const
        { CNode* pNode = (CNode*) position;
                ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
                return pNode->data; }
template<class TYPE, class ARG_TYPE>
inline void CList<TYPE, ARG_TYPE>::SetAt(POSITION pos, ARG_TYPE newElement)
        { CNode* pNode = (CNode*) pos;
                ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
                pNode->data = newElement; }

template<class TYPE, class ARG_TYPE>
CList<TYPE, ARG_TYPE>::CList(int nBlockSize)
{
        ASSERT(nBlockSize > 0);

        m_nCount = 0;
        m_pNodeHead = m_pNodeTail = m_pNodeFree = NULL;
        m_pBlocks = NULL;
        m_nBlockSize = nBlockSize;
}

template<class TYPE, class ARG_TYPE>
void CList<TYPE, ARG_TYPE>::RemoveAll()
{
        ASSERT_VALID(this);

        // destroy elements
        CNode* pNode;
        for (pNode = m_pNodeHead; pNode != NULL; pNode = pNode->pNext)
                DestructElements(&pNode->data, 1);

        m_nCount = 0;
        m_pNodeHead = m_pNodeTail = m_pNodeFree = NULL;
        m_pBlocks->FreeDataChain();
        m_pBlocks = NULL;
}

template<class TYPE, class ARG_TYPE>
CList<TYPE, ARG_TYPE>::~CList()
{
        RemoveAll();
        ASSERT(m_nCount == 0);
}

/////////////////////////////////////////////////////////////////////////////
// Node helpers
//
// Implementation note: CNode's are stored in CPlex blocks and
//  chained together. Free blocks are maintained in a singly linked list
//  using the 'pNext' member of CNode with 'm_pNodeFree' as the head.
//  Used blocks are maintained in a doubly linked list using both 'pNext'
//  and 'pPrev' as links and 'm_pNodeHead' and 'm_pNodeTail'
//   as the head/tail.
//
// We never free a CPlex block unless the List is destroyed or RemoveAll()
//  is used - so the total number of CPlex blocks may grow large depending
//  on the maximum past size of the list.
//

template<class TYPE, class ARG_TYPE>
CList<TYPE, ARG_TYPE>::CNode*
CList<TYPE, ARG_TYPE>::NewNode(CList::CNode* pPrev, CList::CNode* pNext)
{
        if (m_pNodeFree == NULL)
        {
                // add another block
                CPlex* pNewBlock = CPlex::Create(m_pBlocks, m_nBlockSize,
                                 sizeof(CNode));

                // chain them into free list
                CNode* pNode = (CNode*) pNewBlock->data();
                // free in reverse order to make it easier to debug
                pNode += m_nBlockSize - 1;
                for (int i = m_nBlockSize-1; i >= 0; i--, pNode--)
                {
                        pNode->pNext = m_pNodeFree;
                        m_pNodeFree = pNode;
                }
        }
        ASSERT(m_pNodeFree != NULL);  // we must have something

        CList::CNode* pNode = m_pNodeFree;
        m_pNodeFree = m_pNodeFree->pNext;
        pNode->pPrev = pPrev;
        pNode->pNext = pNext;
        m_nCount++;
        ASSERT(m_nCount > 0);  // make sure we don't overflow

        ConstructElements(&pNode->data, 1);
        return pNode;
}

template<class TYPE, class ARG_TYPE>
void CList<TYPE, ARG_TYPE>::FreeNode(CList::CNode* pNode)
{
        DestructElements(&pNode->data, 1);
        pNode->pNext = m_pNodeFree;
        m_pNodeFree = pNode;
        m_nCount--;
        ASSERT(m_nCount >= 0);  // make sure we don't underflow

        // if no more elements, cleanup completely
        if (m_nCount == 0)
                RemoveAll();
}

template<class TYPE, class ARG_TYPE>
POSITION CList<TYPE, ARG_TYPE>::AddHead(ARG_TYPE newElement)
{
        ASSERT_VALID(this);

        CNode* pNewNode = NewNode(NULL, m_pNodeHead);
        pNewNode->data = newElement;
        if (m_pNodeHead != NULL)
                m_pNodeHead->pPrev = pNewNode;
        else
                m_pNodeTail = pNewNode;
        m_pNodeHead = pNewNode;
        return (POSITION) pNewNode;
}

template<class TYPE, class ARG_TYPE>
POSITION CList<TYPE, ARG_TYPE>::AddTail(ARG_TYPE newElement)
{
        ASSERT_VALID(this);

        CNode* pNewNode = NewNode(m_pNodeTail, NULL);
        pNewNode->data = newElement;
        if (m_pNodeTail != NULL)
                m_pNodeTail->pNext = pNewNode;
        else
                m_pNodeHead = pNewNode;
        m_pNodeTail = pNewNode;
        return (POSITION) pNewNode;
}

template<class TYPE, class ARG_TYPE>
void CList<TYPE, ARG_TYPE>::AddHead(CList* pNewList)
{
        ASSERT_VALID(this);

        ASSERT(pNewList != NULL);
        ASSERT_VALID(pNewList);

        // add a list of same elements to head (maintain order)
        POSITION pos = pNewList->GetTailPosition();
        while (pos != NULL)
                AddHead(pNewList->GetPrev(pos));
}

template<class TYPE, class ARG_TYPE>
void CList<TYPE, ARG_TYPE>::AddTail(CList* pNewList)
{
        ASSERT_VALID(this);
        ASSERT(pNewList != NULL);
        ASSERT_VALID(pNewList);

        // add a list of same elements
        POSITION pos = pNewList->GetHeadPosition();
        while (pos != NULL)
                AddTail(pNewList->GetNext(pos));
}

template<class TYPE, class ARG_TYPE>
TYPE CList<TYPE, ARG_TYPE>::RemoveHead()
{
        ASSERT_VALID(this);
        ASSERT(m_pNodeHead != NULL);  // don't call on empty list !!!
        ASSERT(AfxIsValidAddress(m_pNodeHead, sizeof(CNode)));

        CNode* pOldNode = m_pNodeHead;
        TYPE returnValue = pOldNode->data;

        m_pNodeHead = pOldNode->pNext;
        if (m_pNodeHead != NULL)
                m_pNodeHead->pPrev = NULL;
        else
                m_pNodeTail = NULL;
        FreeNode(pOldNode);
        return returnValue;
}

template<class TYPE, class ARG_TYPE>
TYPE CList<TYPE, ARG_TYPE>::RemoveTail()
{
        ASSERT_VALID(this);
        ASSERT(m_pNodeTail != NULL);  // don't call on empty list !!!
        ASSERT(AfxIsValidAddress(m_pNodeTail, sizeof(CNode)));

        CNode* pOldNode = m_pNodeTail;
        TYPE returnValue = pOldNode->data;

        m_pNodeTail = pOldNode->pPrev;
        if (m_pNodeTail != NULL)
                m_pNodeTail->pNext = NULL;
        else
                m_pNodeHead = NULL;
        FreeNode(pOldNode);
        return returnValue;
}

template<class TYPE, class ARG_TYPE>
POSITION CList<TYPE, ARG_TYPE>::InsertBefore(POSITION position, ARG_TYPE newElement)
{
        ASSERT_VALID(this);

        if (position == NULL)
                return AddHead(newElement); // insert before nothing -> head of the list

        // Insert it before position
        CNode* pOldNode = (CNode*) position;
        CNode* pNewNode = NewNode(pOldNode->pPrev, pOldNode);
        pNewNode->data = newElement;

        if (pOldNode->pPrev != NULL)
        {
                ASSERT(AfxIsValidAddress(pOldNode->pPrev, sizeof(CNode)));
                pOldNode->pPrev->pNext = pNewNode;
        }
        else
        {
                ASSERT(pOldNode == m_pNodeHead);
                m_pNodeHead = pNewNode;
        }
        pOldNode->pPrev = pNewNode;
        return (POSITION) pNewNode;
}

template<class TYPE, class ARG_TYPE>
POSITION CList<TYPE, ARG_TYPE>::InsertAfter(POSITION position, ARG_TYPE newElement)
{
        ASSERT_VALID(this);

        if (position == NULL)
                return AddTail(newElement); // insert after nothing -> tail of the list

        // Insert it before position
        CNode* pOldNode = (CNode*) position;
        ASSERT(AfxIsValidAddress(pOldNode, sizeof(CNode)));
        CNode* pNewNode = NewNode(pOldNode, pOldNode->pNext);
        pNewNode->data = newElement;

        if (pOldNode->pNext != NULL)
        {
                ASSERT(AfxIsValidAddress(pOldNode->pNext, sizeof(CNode)));
                pOldNode->pNext->pPrev = pNewNode;
        }
        else
        {
                ASSERT(pOldNode == m_pNodeTail);
                m_pNodeTail = pNewNode;
        }
        pOldNode->pNext = pNewNode;
        return (POSITION) pNewNode;
}

template<class TYPE, class ARG_TYPE>
void CList<TYPE, ARG_TYPE>::RemoveAt(POSITION position)
{
        ASSERT_VALID(this);

        CNode* pOldNode = (CNode*) position;
        ASSERT(AfxIsValidAddress(pOldNode, sizeof(CNode)));

        // remove pOldNode from list
        if (pOldNode == m_pNodeHead)
        {
                m_pNodeHead = pOldNode->pNext;
        }
        else
        {
                ASSERT(AfxIsValidAddress(pOldNode->pPrev, sizeof(CNode)));
                pOldNode->pPrev->pNext = pOldNode->pNext;
        }
        if (pOldNode == m_pNodeTail)
        {
                m_pNodeTail = pOldNode->pPrev;
        }
        else
        {
                ASSERT(AfxIsValidAddress(pOldNode->pNext, sizeof(CNode)));
                pOldNode->pNext->pPrev = pOldNode->pPrev;
        }
        FreeNode(pOldNode);
}

template<class TYPE, class ARG_TYPE>
POSITION CList<TYPE, ARG_TYPE>::FindIndex(int nIndex) const
{
        ASSERT_VALID(this);
        ASSERT(nIndex >= 0);

        if (nIndex >= m_nCount)
                return NULL;  // went too far

        CNode* pNode = m_pNodeHead;
        while (nIndex--)
        {
                ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
                pNode = pNode->pNext;
        }
        return (POSITION) pNode;
}

template<class TYPE, class ARG_TYPE>
POSITION CList<TYPE, ARG_TYPE>::Find(ARG_TYPE searchValue, POSITION startAfter) const
{
        ASSERT_VALID(this);

        CNode* pNode = (CNode*) startAfter;
        if (pNode == NULL)
        {
                pNode = m_pNodeHead;  // start at head
        }
        else
        {
                ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
                pNode = pNode->pNext;  // start after the one specified
        }

        for (; pNode != NULL; pNode = pNode->pNext)
                if (CompareElements(&pNode->data, &searchValue))
                        return (POSITION)pNode;
        return NULL;
}

template<class TYPE, class ARG_TYPE>
void CList<TYPE, ARG_TYPE>::Serialize(CArchive& ar)
{
        ASSERT_VALID(this);
#ifndef unix
        // UNIX found decl commented out in coll.hxx
        CObject::Serialize(ar);
#else
	MwBugCheck();
#endif /* unix */
#ifndef unix
        if (ar.IsStoring())
        {
                ar.WriteCount(m_nCount);
                for (CNode* pNode = m_pNodeHead; pNode != NULL; pNode = pNode->pNext)
                {
                        ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
                        SerializeElements(ar, &pNode->data, 1);
                }
        }
        else
        {
                DWORD nNewCount = ar.ReadCount();
                TYPE newData;
                while (nNewCount--)
                {
                        SerializeElements(ar, &newData, 1);
                        AddTail(newData);
                }
        }
#endif /* unix */
}

#ifdef _DEBUG
template<class TYPE, class ARG_TYPE>
void CList<TYPE, ARG_TYPE>::Dump(CDumpContext& dc) const
{
        CObject::Dump(dc);

        dc << "with " << m_nCount << " elements";
        if (dc.GetDepth() > 0)
        {
                POSITION pos = GetHeadPosition();
                while (pos != NULL)
                {
                        dc << "\n";
                        DumpElements(dc, &((CList*)this)->GetNext(pos), 1);
                }
        }

        dc << "\n";
}

template<class TYPE, class ARG_TYPE>
void CList<TYPE, ARG_TYPE>::AssertValid() const
{
        CObject::AssertValid();

        if (m_nCount == 0)
        {
                // empty list
                ASSERT(m_pNodeHead == NULL);
                ASSERT(m_pNodeTail == NULL);
        }
        else
        {
                // non-empty list
                ASSERT(AfxIsValidAddress(m_pNodeHead, sizeof(CNode)));
                ASSERT(AfxIsValidAddress(m_pNodeTail, sizeof(CNode)));
        }
}
#endif //_DEBUG
#endif //LIST_DEFINED

/////////////////////////////////////////////////////////////////////////////
// CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
class CMap : public CObject
{
#ifndef unix
protected:
#else
  // If this was not made public we get complier warnings
    // that CMap<T,...>::CAssoc is not accessible from file scope
    // which means functions cant return CNode pointers
public:
#endif /* unix */
        // Association
        struct CAssoc
        {
                CAssoc* pNext;
                UINT nHashValue;  // needed for efficient iteration
                KEY key;
                VALUE value;
        };
public:
// Construction
        CMap(int nBlockSize = 10);

// Attributes
        // number of elements
        int GetCount() const;
        BOOL IsEmpty() const;

        // Lookup
        BOOL Lookup(ARG_KEY key, VALUE& rValue) const;

// Operations
        // Lookup and add if not there
        VALUE& operator[](ARG_KEY key);

        // add a new (key, value) pair
        void SetAt(ARG_KEY key, ARG_VALUE newValue);

        // removing existing (key, ?) pair
        BOOL RemoveKey(ARG_KEY key);
        void RemoveAll();

        // iterating all (key, value) pairs
        POSITION GetStartPosition() const;
        void GetNextAssoc(POSITION& rNextPosition, KEY& rKey, VALUE& rValue) const;

        // advanced features for derived classes
        UINT GetHashTableSize() const;
        void InitHashTable(UINT hashSize, BOOL bAllocNow = TRUE);

// Implementation
protected:
        CAssoc** m_pHashTable;
        UINT m_nHashTableSize;
        int m_nCount;
        CAssoc* m_pFreeList;
        struct CPlex* m_pBlocks;
        int m_nBlockSize;

        CAssoc* NewAssoc();
        void FreeAssoc(CAssoc*);
        CAssoc* GetAssocAt(ARG_KEY, UINT&) const;

public:
        ~CMap();
        void Serialize(CArchive&);
#ifdef _DEBUG
        void Dump(CDumpContext&) const;
        void AssertValid() const;
#endif
};

/////////////////////////////////////////////////////////////////////////////
// CMap<KEY, ARG_KEY, VALUE, ARG_VALUE> inline functions

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
inline int CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::GetCount() const
        { return m_nCount; }
template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
inline BOOL CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::IsEmpty() const
        { return m_nCount == 0; }
template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
inline void CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::SetAt(ARG_KEY key, ARG_VALUE newValue)
        { (*this)[key] = newValue; }
template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
inline POSITION CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::GetStartPosition() const
        { return (m_nCount == 0) ? NULL : BEFORE_START_POSITION; }
template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
inline UINT CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::GetHashTableSize() const
        { return m_nHashTableSize; }

/////////////////////////////////////////////////////////////////////////////
// CMap<KEY, ARG_KEY, VALUE, ARG_VALUE> out-of-line functions

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::CMap(int nBlockSize)
{
        ASSERT(nBlockSize > 0);

        m_pHashTable = NULL;
        m_nHashTableSize = 17;  // default size
        m_nCount = 0;
        m_pFreeList = NULL;
        m_pBlocks = NULL;
        m_nBlockSize = nBlockSize;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
void CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::InitHashTable(
        UINT nHashSize, BOOL bAllocNow)
//
// Used to force allocation of a hash table or to override the default
//   hash table size of (which is fairly small)
{
        ASSERT_VALID(this);
        ASSERT(m_nCount == 0);
        ASSERT(nHashSize > 0);

        if (m_pHashTable != NULL)
        {
                // free hash table
                delete[] m_pHashTable;
                m_pHashTable = NULL;
        }

        if (bAllocNow)
        {
                m_pHashTable = new CAssoc* [nHashSize];
                memset(m_pHashTable, 0, sizeof(CAssoc*) * nHashSize);
        }
        m_nHashTableSize = nHashSize;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
void CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::RemoveAll()
{
        ASSERT_VALID(this);

        if (m_pHashTable != NULL)
        {
                // destroy elements (values and keys)
                for (UINT nHash = 0; nHash < m_nHashTableSize; nHash++)
                {
                        CAssoc* pAssoc;
                        for (pAssoc = m_pHashTable[nHash]; pAssoc != NULL;
                          pAssoc = pAssoc->pNext)
                        {
                                DestructElements(&pAssoc->value, 1);
                                DestructElements(&pAssoc->key, 1);
                        }
                }

            // free hash table
            delete[] m_pHashTable;
            m_pHashTable = NULL;
        }

        m_nCount = 0;
        m_pFreeList = NULL;
        if (m_pBlocks)
        {
            m_pBlocks->FreeDataChain();
            m_pBlocks = NULL;
        }
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::~CMap()
{
    if (m_nCount)
    {
        RemoveAll();
    }
    ASSERT(m_nCount == 0);
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::CAssoc*
CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::NewAssoc()
{
        if (m_pFreeList == NULL)
        {
                // add another block
                CPlex* newBlock = CPlex::Create(m_pBlocks, m_nBlockSize, sizeof(CMap::CAssoc));
                // chain them into free list
                CMap::CAssoc* pAssoc = (CMap::CAssoc*) newBlock->data();
                // free in reverse order to make it easier to debug
                pAssoc += m_nBlockSize - 1;
                for (int i = m_nBlockSize-1; i >= 0; i--, pAssoc--)
                {
                        pAssoc->pNext = m_pFreeList;
                        m_pFreeList = pAssoc;
                }
        }
        ASSERT(m_pFreeList != NULL);  // we must have something

        CMap::CAssoc* pAssoc = m_pFreeList;
        m_pFreeList = m_pFreeList->pNext;
        m_nCount++;
        ASSERT(m_nCount > 0);  // make sure we don't overflow
        ConstructElements(&pAssoc->key, 1);
        ConstructElements(&pAssoc->value, 1);   // special construct values
        return pAssoc;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
void CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::FreeAssoc(CMap::CAssoc* pAssoc)
{
        DestructElements(&pAssoc->value, 1);
        DestructElements(&pAssoc->key, 1);
        pAssoc->pNext = m_pFreeList;
        m_pFreeList = pAssoc;
        m_nCount--;
        ASSERT(m_nCount >= 0);  // make sure we don't underflow

        // if no more elements, cleanup completely
        if (m_nCount == 0)
                RemoveAll();
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::CAssoc*
CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::GetAssocAt(ARG_KEY key, UINT& nHash) const
// find association (or return NULL)
{
        nHash = HashKey(key) % m_nHashTableSize;

        if (m_pHashTable == NULL)
                return NULL;

        // see if it exists
        CAssoc* pAssoc;
        for (pAssoc = m_pHashTable[nHash]; pAssoc != NULL; pAssoc = pAssoc->pNext)
        {
                if (CompareElements(&pAssoc->key, &key))
                        return pAssoc;
        }
        return NULL;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
BOOL CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::Lookup(ARG_KEY key, VALUE& rValue) const
{
        ASSERT_VALID(this);

        UINT nHash;
        CAssoc* pAssoc = GetAssocAt(key, nHash);
        if (pAssoc == NULL)
                return FALSE;  // not in map

        rValue = pAssoc->value;
        return TRUE;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
VALUE& CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::operator[](ARG_KEY key)
{
        ASSERT_VALID(this);

        UINT nHash;
        CAssoc* pAssoc;
        if ((pAssoc = GetAssocAt(key, nHash)) == NULL)
        {
                if (m_pHashTable == NULL)
                        InitHashTable(m_nHashTableSize);

                // it doesn't exist, add a new Association
                pAssoc = NewAssoc();
                pAssoc->nHashValue = nHash;
                pAssoc->key = key;
                // 'pAssoc->value' is a constructed object, nothing more

                // put into hash table
                pAssoc->pNext = m_pHashTable[nHash];
                m_pHashTable[nHash] = pAssoc;
        }
        return pAssoc->value;  // return new reference
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
BOOL CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::RemoveKey(ARG_KEY key)
// remove key - return TRUE if removed
{
        ASSERT_VALID(this);

        if (m_pHashTable == NULL)
                return FALSE;  // nothing in the table

        CAssoc** ppAssocPrev;
        ppAssocPrev = &m_pHashTable[HashKey(key) % m_nHashTableSize];

        CAssoc* pAssoc;
        for (pAssoc = *ppAssocPrev; pAssoc != NULL; pAssoc = pAssoc->pNext)
        {
                if (CompareElements(&pAssoc->key, &key))
                {
                        // remove it
                        *ppAssocPrev = pAssoc->pNext;  // remove from list
                        FreeAssoc(pAssoc);
                        return TRUE;
                }
                ppAssocPrev = &pAssoc->pNext;
        }
        return FALSE;  // not found
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
void CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::GetNextAssoc(POSITION& rNextPosition,
        KEY& rKey, VALUE& rValue) const
{
        ASSERT_VALID(this);
        ASSERT(m_pHashTable != NULL);  // never call on empty map

        CAssoc* pAssocRet = (CAssoc*)rNextPosition;
        ASSERT(pAssocRet != NULL);

        if (pAssocRet == (CAssoc*) BEFORE_START_POSITION)
        {
                // find the first association
                for (UINT nBucket = 0; nBucket < m_nHashTableSize; nBucket++)
                        if ((pAssocRet = m_pHashTable[nBucket]) != NULL)
                                break;
                ASSERT(pAssocRet != NULL);  // must find something
        }

        // find next association
        ASSERT(AfxIsValidAddress(pAssocRet, sizeof(CAssoc)));
        CAssoc* pAssocNext;
        if ((pAssocNext = pAssocRet->pNext) == NULL)
        {
                // go to next bucket
                for (UINT nBucket = pAssocRet->nHashValue + 1;
                  nBucket < m_nHashTableSize; nBucket++)
                        if ((pAssocNext = m_pHashTable[nBucket]) != NULL)
                                break;
        }

        rNextPosition = (POSITION) pAssocNext;

        // fill in return data
        rKey = pAssocRet->key;
        rValue = pAssocRet->value;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
void CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::Serialize(CArchive& ar)
{
        ASSERT_VALID(this);
#ifndef unix
        // UNIX found dedcl commented out in coll.hxx
        CObject::Serialize(ar);
#endif /* unix */

        if (ar.IsStoring())
        {
                ar.WriteCount(m_nCount);
                if (m_nCount == 0)
                        return;  // nothing more to do

                ASSERT(m_pHashTable != NULL);
                for (UINT nHash = 0; nHash < m_nHashTableSize; nHash++)
                {
                        CAssoc* pAssoc;
                        for (pAssoc = m_pHashTable[nHash]; pAssoc != NULL;
                          pAssoc = pAssoc->pNext)
                        {
                                SerializeElements(ar, &pAssoc->key, 1);
                                SerializeElements(ar, &pAssoc->value, 1);
                        }
                }
        }
        else
        {
                DWORD nNewCount = ar.ReadCount();
                KEY newKey;
                VALUE newValue;
                while (nNewCount--)
                {
                        SerializeElements(ar, &newKey, 1);
                        SerializeElements(ar, &newValue, 1);
                        SetAt(newKey, newValue);
                }
        }
}

#ifdef _DEBUG
#ifndef unix
template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
void CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::Dump(CDumpContext& dc) const
{
        CObject::Dump(dc);

        dc << "with " << m_nCount << " elements";
        if (dc.GetDepth() > 0)
        {
                // Dump in format "[key] -> value"
                KEY key;
                VALUE val;

                POSITION pos = GetStartPosition();
                while (pos != NULL)
                {
                        GetNextAssoc(pos, key, val);
                        dc << "\n\t[";
                        DumpElements(dc, &key, 1);
                        dc << "] = ";
                        DumpElements(dc, &val, 1);
                }
        }

        dc << "\n";
}
#endif /* unix */

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
void CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::AssertValid() const
{
        CObject::AssertValid();

        ASSERT(m_nHashTableSize > 0);
        ASSERT(m_nCount == 0 || m_pHashTable != NULL);
                // non-empty map should have hash table
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CTypedPtrArray<BASE_CLASS, TYPE>

template<class BASE_CLASS, class TYPE>
class CTypedPtrArray : public BASE_CLASS
{
public:
        // Accessing elements
        TYPE GetAt(int nIndex) const
                { return (TYPE)BASE_CLASS::GetAt(nIndex); }
        TYPE& ElementAt(int nIndex)
                { return (TYPE&)BASE_CLASS::ElementAt(nIndex); }
        void SetAt(int nIndex, TYPE ptr)
                { BASE_CLASS::SetAt(nIndex, ptr); }

        // Potentially growing the array
        void SetAtGrow(int nIndex, TYPE newElement)
           { BASE_CLASS::SetAtGrow(nIndex, newElement); }
        int Add(TYPE newElement)
           { return BASE_CLASS::Add(newElement); }
        int Append(const CTypedPtrArray<BASE_CLASS, TYPE>& src)
           { return BASE_CLASS::Append(src); }
        void Copy(const CTypedPtrArray<BASE_CLASS, TYPE>& src)
                { BASE_CLASS::Copy(src); }

        // Operations that move elements around
        void InsertAt(int nIndex, TYPE newElement, int nCount = 1)
                { BASE_CLASS::InsertAt(nIndex, newElement, nCount); }
        void InsertAt(int nStartIndex, CTypedPtrArray<BASE_CLASS, TYPE>* pNewArray)
           { BASE_CLASS::InsertAt(nStartIndex, pNewArray); }

        // overloaded operator helpers
        TYPE operator[](int nIndex) const
                { return (TYPE)BASE_CLASS::operator[](nIndex); }
        TYPE& operator[](int nIndex)
                { return (TYPE&)BASE_CLASS::operator[](nIndex); }
};

/////////////////////////////////////////////////////////////////////////////
// CTypedPtrList<BASE_CLASS, TYPE>

template<class BASE_CLASS, class TYPE>
class CTypedPtrList : public BASE_CLASS
{
public:
// Construction
        CTypedPtrList(int nBlockSize = 10)
                : BASE_CLASS(nBlockSize) { }

        // peek at head or tail
        TYPE& GetHead()
                { return (TYPE&)BASE_CLASS::GetHead(); }
        TYPE GetHead() const
                { return (TYPE)BASE_CLASS::GetHead(); }
        TYPE& GetTail()
                { return (TYPE&)BASE_CLASS::GetTail(); }
        TYPE GetTail() const
                { return (TYPE)BASE_CLASS::GetTail(); }

        // get head or tail (and remove it) - don't call on empty list!
        TYPE RemoveHead()
                { return (TYPE)BASE_CLASS::RemoveHead(); }
        TYPE RemoveTail()
                { return (TYPE)BASE_CLASS::RemoveTail(); }

        // add before head or after tail
        POSITION AddHead(TYPE newElement)
                { return BASE_CLASS::AddHead(newElement); }
        POSITION AddTail(TYPE newElement)
                { return BASE_CLASS::AddTail(newElement); }

        // add another list of elements before head or after tail
        void AddHead(CTypedPtrList<BASE_CLASS, TYPE>* pNewList)
                { BASE_CLASS::AddHead(pNewList); }
        void AddTail(CTypedPtrList<BASE_CLASS, TYPE>* pNewList)
                { BASE_CLASS::AddTail(pNewList); }

        // iteration
        TYPE& GetNext(POSITION& rPosition)
                { return (TYPE&)BASE_CLASS::GetNext(rPosition); }
        TYPE GetNext(POSITION& rPosition) const
                { return (TYPE)BASE_CLASS::GetNext(rPosition); }
        TYPE& GetPrev(POSITION& rPosition)
                { return (TYPE&)BASE_CLASS::GetPrev(rPosition); }
        TYPE GetPrev(POSITION& rPosition) const
                { return (TYPE)BASE_CLASS::GetPrev(rPosition); }

        // getting/modifying an element at a given position
        TYPE& GetAt(POSITION position)
                { return (TYPE&)BASE_CLASS::GetAt(position); }
        TYPE GetAt(POSITION position) const
                { return (TYPE)BASE_CLASS::GetAt(position); }
        void SetAt(POSITION pos, TYPE newElement)
                { BASE_CLASS::SetAt(pos, newElement); }
};

/////////////////////////////////////////////////////////////////////////////
// CTypedPtrMap<BASE_CLASS, KEY, VALUE>

template<class BASE_CLASS, class KEY, class VALUE>
class CTypedPtrMap : public BASE_CLASS
{
public:

// Construction
        CTypedPtrMap(int nBlockSize = 10)
                : BASE_CLASS(nBlockSize) { }

        // Lookup
        BOOL Lookup(BASE_CLASS::BASE_ARG_KEY key, VALUE& rValue) const
                { return BASE_CLASS::Lookup(key, (BASE_CLASS::BASE_VALUE&)rValue); }

        // Lookup and add if not there
        VALUE& operator[](BASE_CLASS::BASE_ARG_KEY key)
                { return (VALUE&)BASE_CLASS::operator[](key); }

        // add a new key (key, value) pair
        void SetAt(KEY key, VALUE newValue)
                { BASE_CLASS::SetAt(key, newValue); }

        // removing existing (key, ?) pair
        BOOL RemoveKey(KEY key)
                { return BASE_CLASS::RemoveKey(key); }

        // iteration
        void GetNextAssoc(POSITION& rPosition, KEY& rKey, VALUE& rValue) const
                { BASE_CLASS::GetNextAssoc(rPosition, (BASE_CLASS::BASE_KEY&)rKey,
                        (BASE_CLASS::BASE_VALUE&)rValue); }
};

/////////////////////////////////////////////////////////////////////////////

#undef THIS_FILE
#define THIS_FILE __FILE__

#undef new
#ifdef _REDEF_NEW
#define new DEBUG_NEW
#undef _REDEF_NEW
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif
#ifndef _AFX_FULLTYPEINFO
#pragma component(mintypeinfo, off)
#endif

#endif //__AFXTEMPL_H__

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\urlmon\utils\assert2.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       assert.cxx
//
//  Functions:  FnAssert
//              DbgDllSetSiftObject
//
//  History:     4-Jan-94   CraigWi     Created
//              16-Jun-94   t-ChriPi    Added DbgDllSetSiftObject
//
//----------------------------------------------------------------------------
#ifdef unix
#include <windows.h>
#endif /* unix */
#include <ole2.h>


STDAPI_(void) Win4AssertEx(
    char const * szFile,
    int iLine,
    char const * szMessage);

//+-------------------------------------------------------------------
//
//  Function:   FnAssert, public
//
//  Synopsis:   Prints a message and optionally stops the program
//
//  Effects:    Simply maps to Win4AssertEx for now.
//
//  History:     4-Jan-94   CraigWi     Created for Win32 OLE2.
//
//--------------------------------------------------------------------

STDAPI FnAssert( LPSTR lpstrExpr, LPSTR lpstrMsg, LPSTR lpstrFileName, UINT iLine )
{
#if DBG == 1
    char szMessage[1024];

    if (lpstrMsg == NULL)
        lstrcpyA(szMessage, lpstrExpr);
    else
        wsprintfA(szMessage, "%s; %s", lpstrExpr, lpstrMsg);

    Win4AssertEx(lpstrFileName, iLine, szMessage);
#endif
    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\urlmon\utils\assert3.cxx ===
//+---------------------------------------------------------------------------
//  Copyright (C) 1991, Microsoft Corporation.
//
//  File:       assert.cxx
//
//  Contents:   Debugging output routines for idsmgr.dll
//
//  Functions:  Assert
//              PopUpError
//
//  History:    23-Jul-91   KyleP       Created.
//              09-Oct-91   KevinRo     Major changes and comments added
//              18-Oct-91   vich        moved debug print routines out
//              10-Jun-92   BryanT      Switched to w4crt.h instead of wchar.h
//              30-Sep-93   KyleP       DEVL obsolete
//
//----------------------------------------------------------------------------

#pragma hdrstop

//
// This one file **always** uses debugging options
//

#if DBG == 1

// needed for CT TOM assert events trapping
#include <assert.hxx>

#include <stdarg.h>
#include <stdio.h>


# include <dprintf.h>            // w4printf, w4dprintf prototypes
# include <debnot.h>
# ifdef FLAT
#   include <sem.hxx>
#   include <dllsem.hxx>
# endif // FLAT

extern "C"
{

# ifdef FLAT
#  undef FAR
#  undef NEAR
# else
#  define MessageBoxA MessageBox
# endif

# include <windows.h>
}
#ifdef _CHICAGO_
int WINAPI SSMessageBox(HWND hWnd,LPCSTR lpText,LPCSTR lpCaption, UINT uType);
#endif // _CHICAGO_


extern BOOL gfService = FALSE;

unsigned long Win4InfoLevel = DEF_INFOLEVEL;
unsigned long Win4InfoMask = 0xffffffff;
unsigned long Win4AssertLevel = ASSRT_MESSAGE | ASSRT_BREAK | ASSRT_POPUP;

//+---------------------------------------------------------------------------
//
//  Function:   _asdprintf
//
//  Synopsis:   Calls vdprintf to output a formatted message.
//
//  History:    18-Oct-91   vich Created
//
//----------------------------------------------------------------------------
inline void _CRTAPI1
_asdprintf(
    char const *pszfmt, ...)
{
    va_list va;
    va_start(va, pszfmt);

    vdprintf(DEB_FORCE, "Assert", pszfmt, va);

    va_end(va);
}

//+---------------------------------------------------------------------------
//
//  Function:   _Win4Assert, private
//
//  Synopsis:   Display assertion information
//
//  Effects:    Called when an assertion is hit.
//
//  History:    12-Jul-91       AlexT   Created.
//              05-Sep-91       AlexT   Catch Throws and Catches
//              19-Oct-92       HoiV    Added events for TOM
//
//----------------------------------------------------------------------------


STDAPI_(void) Win4AssertEx(
    char const * szFile,
    int iLine,
    char const * szMessage)
{
#if defined( FLAT )
    //
    // This code is for the CT Lab only.  When running in the lab,
    // all assert popups will be trapped and notifications will
    // be sent to the manager.  If running in the office (non-lab
    // mode), the event CTTOMTrapAssertEvent will not exist and
    // consequently, no event will be pulsed.
    //

    HANDLE hTrapAssertEvent,
           hThreadStartEvent;

    if (hTrapAssertEvent = OpenEvent(EVENT_ALL_ACCESS,
                                     FALSE,
                                     CAIRO_CT_TOM_TRAP_ASSERT_EVENT))
    {
        SetEvent(hTrapAssertEvent);

        //
        // This event is to allow TOM Manager time to perform
        // a CallBack to the dispatcher.
        //
        if (hThreadStartEvent = OpenEvent(EVENT_ALL_ACCESS,
                                          FALSE,
                                          CAIRO_CT_TOM_THREAD_START_EVENT))
        {
            //
            // Wait until it's ok to popup or until timed-out
            //
            WaitForSingleObject(hThreadStartEvent, TWO_MINUTES);
        }
    }
#endif

    if (Win4AssertLevel & ASSRT_MESSAGE)
    {
# ifdef FLAT
        DWORD tid = GetCurrentThreadId();

        _asdprintf("%s File: %s Line: %u, thread id %d\n",
                   szMessage, szFile, iLine, tid);
# else  // FLAT
        _asdprintf("%s File: %s Line: %u\n", szMessage, szFile, iLine);
# endif // FLAT
    }

    if (Win4AssertLevel & ASSRT_POPUP)
    {
        int id = PopUpError(szMessage,iLine,szFile);

        if (id == IDCANCEL)
        {
            DebugBreak();
        }
    }
    else if (Win4AssertLevel & ASSRT_BREAK)
    {
        DebugBreak();
    }

}


//+------------------------------------------------------------
// Function:    SetWin4InfoLevel(unsigned long ulNewLevel)
//
// Synopsis:    Sets the global info level for debugging output
// Returns:     Old info level
//
//-------------------------------------------------------------

EXPORTIMP unsigned long APINOT
SetWin4InfoLevel(
    unsigned long ulNewLevel)
{
    unsigned long ul;

    ul = Win4InfoLevel;
    Win4InfoLevel = ulNewLevel;
    return(ul);
}


//+------------------------------------------------------------
// Function:    _SetWin4InfoMask(unsigned long ulNewMask)
//
// Synopsis:    Sets the global info mask for debugging output
// Returns:     Old info mask
//
//-------------------------------------------------------------

EXPORTIMP unsigned long APINOT
SetWin4InfoMask(
    unsigned long ulNewMask)
{
    unsigned long ul;

    ul = Win4InfoMask;
    Win4InfoMask = ulNewMask;
    return(ul);
}


//+------------------------------------------------------------
// Function:    _SetWin4AssertLevel(unsigned long ulNewLevel)
//
// Synopsis:    Sets the global assert level for debugging output
// Returns:     Old assert level
//
//-------------------------------------------------------------

EXPORTIMP unsigned long APINOT
SetWin4AssertLevel(
    unsigned long ulNewLevel)
{
    unsigned long ul;

    ul = Win4AssertLevel;
    Win4AssertLevel = ulNewLevel;
    return(ul);
}

//+------------------------------------------------------------
// Function:    PopUpError
//
// Synopsis:    Displays a dialog box using provided text,
//              and presents the user with the option to
//              continue or cancel.
//
// Arguments:
//      szMsg --        The string to display in main body of dialog
//      iLine --        Line number of file in error
//      szFile --       Filename of file in error
//
// Returns:
//      IDCANCEL --     User selected the CANCEL button
//      IDOK     --     User selected the OK button
//-------------------------------------------------------------

STDAPI_(int) PopUpError(
    char const *szMsg,
    int iLine,
    char const *szFile)
{

    int id;
    static char szAssertCaption[128];
    static char szModuleName[128];

    DWORD tid = GetCurrentThreadId();
    DWORD pid = GetCurrentProcessId();
    char * pszModuleName;

    if (GetModuleFileNameA(NULL, szModuleName, 128))
    {
        pszModuleName = strrchr(szModuleName, '\\');
        if (!pszModuleName)
        {
            pszModuleName = szModuleName;
        }
        else
        {
            pszModuleName++;
        }
    }
    else
    {
        pszModuleName = "Unknown";
    }

    sprintf(szAssertCaption,"Process: %s File: %s line %u, thread id %d.%d",
        pszModuleName, szFile, iLine, pid, tid);


    DWORD dwMessageFlags = MB_SETFOREGROUND | MB_TASKMODAL |
                           MB_ICONEXCLAMATION | MB_OKCANCEL;

#ifndef _CHICAGO_
                     //  Since this code is also used by SCM.EXE, we pass
                     //  in the following flag which causes Service pop ups
                     //  to appear on the desktop correctly

    if (gfService)
    {
        dwMessageFlags |= MB_SERVICE_NOTIFICATION | MB_DEFAULT_DESKTOP_ONLY;
    }

    id = MessageBoxA(NULL,(char *) szMsg, (LPSTR) szAssertCaption,
                     dwMessageFlags);

# ifdef _CAIRO_
    // Other processes which are services also use this code, but they
    //  have no access to set gfService, so if the above failed with an
    //  access denied error (meaning no access to the default desktop)
    //  retry as a service popup. Also, remember that we are a service
    //  so we don't waste attempts later.
    if ( !gfService && !id
         && (GetLastError() == ERROR_ACCESS_DENIED) )
    {
        gfService = TRUE;
        dwMessageFlags |= MB_SERVICE_NOTIFICATION | MB_DEFAULT_DESKTOP_ONLY;
        id = MessageBoxA(NULL,(char *) szMsg, (LPSTR) szAssertCaption,
                         dwMessageFlags);
    }
# endif

#else
    id = SSMessageBox(NULL, (char *) szMsg, (LPSTR) szAssertCaption,
                     dwMessageFlags);

#endif

    // If id == 0, then an error occurred.  There are two possibilities
    // that can cause the error:  Access Denied, which means that this
    // process does not have access to the default desktop, and everything
    // else (usually out of memory).  Oh well.

    return id;
}

//+------------------------------------------------------------
// Function:    vdprintf
//
// Synopsis:    Prints debug output using a pointer to the
//              variable information. Used primarily by the
//              xxDebugOut macros
//
// Arguements:
//      ulCompMask --   Component level mask used to determine
//                      output ability
//      pszComp    --   String const of component prefix.
//      ppszfmt    --   Pointer to output format and data
//
//-------------------------------------------------------------

//
// This semaphore is *outside* vdprintf because the compiler isn't smart
// enough to serialize access for construction if it's function-local and
// protected by a guard variable.
//
//    KyleP - 20 May, 1993
//

static CMutexSem mxs;

STDAPI_(void) vdprintf(
    unsigned long ulCompMask,
    char const   *pszComp,
    char const   *ppszfmt,
    va_list       pargs)
{
    if ((ulCompMask & DEB_FORCE) == DEB_FORCE ||
        ((ulCompMask | Win4InfoLevel) & Win4InfoMask))
    {
#if defined( FLAT )
        mxs.Request();
        DWORD tid = GetCurrentThreadId();
        DWORD pid = GetCurrentProcessId();
        if ((Win4InfoLevel & (DEB_DBGOUT | DEB_STDOUT)) != DEB_STDOUT)
#endif // FLAT
        {
            if (! (ulCompMask & DEB_NOCOMPNAME))
            {
#ifdef FLAT
#if defined(_CHICAGO_)
                //
                //  Hex Process/Thread ID's are better for Chicago since both
                //  are memory addresses.
                //
                w4dprintf( "%08x.%08x> ", pid, tid );
#else
                w4dprintf( "%d.%03d> ", pid, tid );
#endif
#endif // FLAT
                w4dprintf("%s: ", pszComp);
            }
            w4vdprintf(ppszfmt, pargs);
        }

#if defined( FLAT )
        if (Win4InfoLevel & DEB_STDOUT)
        {
            if (! (ulCompMask & DEB_NOCOMPNAME))
            {
                w4printf( "%03d> ", tid );
                w4printf("%s: ", pszComp);
            }
            w4vprintf(ppszfmt, pargs);
        }

        mxs.Release();
#endif // FLAT
    }
}

#else

int assertDontUseThisName(void)
{
    return 1;
}

#endif // DBG == 1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\urlmon\utils\bindutil.cxx ===
// Microsoft Corporation 1997
//
// This file contains methods for copying and releasing STGMEDIUMs and BINDINFOs
// (which contains a STGMEDIUM).
//
// Created: 8-15-97 t-gpease 
//

#include <urlmon.hxx>

#undef  URLMONOFFSETOF
#define URLMONOFFSETOF(t,f)   ((DWORD_PTR)(&((t*)0)->f))

//
// This function clears the BINDINFO structure. 
//
//- The "cbSize" will not be clear and will be the same as it 
// was pasted in. This is by design so that you can reuse the 
// BINDINFO (eg copy another BINDINFO into it). 
//
//- It does NOT release the memory that the BINDINFO oocupies 
// (this could be on the stack). 
//
//- It does properly release items that the BINDINFO might be 
// pointing to.
//
STDAPI_(void)
ReleaseBindInfo(BINDINFO * pbindinfo)
{
    if ( !pbindinfo)
        return;

    DWORD cb = pbindinfo->cbSize;

    UrlMkAssert( cb && 
        "CopyBindInfo(): cbSize of the BINDINFO is ZERO. We need the cbSize to be set before calling us.");
    if(!cb )
        return; // we don't know which structure it is, so don't touch it.

    if (cb >= URLMONOFFSETOF(BINDINFO, dwReserved) && pbindinfo->pUnk)
    {
        pbindinfo->pUnk->Release();
    }

    // Orginal BINDINFO no need to check size
    if (pbindinfo->szExtraInfo)
    {
        delete [] pbindinfo->szExtraInfo;
    }

    // Orginal BINDINFO no need to check size
    if (pbindinfo->szCustomVerb)
    {
        delete [] pbindinfo->szCustomVerb;
    }

    // Orginal BINDINFO no need to check size
    ReleaseStgMedium(&pbindinfo->stgmedData);

    // set this to zero so other function will not try to use the BINDINFO
    ZeroMemory(pbindinfo, cb);
    pbindinfo->cbSize = cb;  // but keep this intact

    return;
}

//
// This function copies STGMEDIUM stuctures.
//
//- Users need to allocate the memory that the STGMEDIUM Dest will be copied
// into.
//
//- If anything goes wrong, we return the proper HRESULT and STGMEDIUM.will
// have been zero-ed.
//
STDAPI
CopyStgMedium(const STGMEDIUM * pcstgmedSrc,
                 STGMEDIUM * pstgmedDest)
{
    HRESULT         hr = S_OK;

    if ( !pcstgmedSrc || !pstgmedDest )
        return E_POINTER;

    ZeroMemory(pstgmedDest, sizeof(*pstgmedDest));

    switch (pcstgmedSrc->tymed)
    {

    case TYMED_HGLOBAL:
        {
            void *          pvDest;
            const void *    pcvSrc;
            DWORD_PTR       dwcbLen;
            HGLOBAL         hGlobalDest;

            if (!pcstgmedSrc->hGlobal)
                break;  // nothing to do

            hr = E_OUTOFMEMORY;
            pcvSrc = GlobalLock(pcstgmedSrc->hGlobal);
            if (!pcvSrc)
                goto Cleanup;

            dwcbLen = GlobalSize(pcstgmedSrc->hGlobal);
            // We can't do the following line:
            // hGlobalDest = GlobalAlloc((GMEM_MOVEABLE | GMEM_SHARE), dwcbLen);
            // because we hand out the bindinfo.stgmedData.hglobal to callers
            // that do NOT lock it and use the handle instead of the pointer.
            hGlobalDest = GlobalAlloc(GMEM_FIXED | GMEM_SHARE, dwcbLen);
            if (!hGlobalDest)
            {
                GlobalUnlock(pcstgmedSrc->hGlobal);
                goto Cleanup;
            }


            pvDest = GlobalLock(hGlobalDest);
            if (!pvDest)
            {
                GlobalFree(hGlobalDest);
                GlobalUnlock(pcstgmedSrc->hGlobal);
                goto Cleanup;
            }

            UrlMkAssert(dwcbLen>>32 == 0);
            memcpy(pvDest, pcvSrc, (unsigned long)dwcbLen);

            pstgmedDest->hGlobal = hGlobalDest;

            GlobalUnlock(hGlobalDest);
            GlobalUnlock(pcstgmedSrc->hGlobal);
            hr = S_OK;
        }
        break;

    case TYMED_FILE:
        {
            if (!pcstgmedSrc->lpszFileName)
                break; // nothing to do

            hr = E_OUTOFMEMORY;

            LPWSTR lpwstr = OLESTRDuplicate(pcstgmedSrc->lpszFileName);
            if (!lpwstr)
                goto Cleanup;

            pstgmedDest->lpszFileName = lpwstr;

            hr = S_OK;
        }
        break;

    case TYMED_ISTREAM:
        {
            pstgmedDest->pstm = pcstgmedSrc->pstm;
            if ( pstgmedDest->pstm )
                pstgmedDest->pstm->AddRef();
        }
        break;

    case TYMED_ISTORAGE:
        {
            pstgmedDest->pstg = pcstgmedSrc->pstg;
            if ( pstgmedDest->pstg )
                pstgmedDest->pstg->AddRef();
        }
        break;

    default:
        UrlMkAssert( !"CloneStgMedium has encountered a TYMED it doesn't know how to copy." );
        // fall thru and copy it.

    case TYMED_NULL: // blindly copy
    case TYMED_GDI:  // Just copy...
        memcpy(pstgmedDest, pcstgmedSrc, sizeof(*pstgmedDest));
        break;
    }

    // Common things that can be copied if we get to this point.
    pstgmedDest->tymed = pcstgmedSrc->tymed;
    pstgmedDest->pUnkForRelease = pcstgmedSrc->pUnkForRelease;
    if (pstgmedDest->pUnkForRelease)
        (pstgmedDest->pUnkForRelease)->AddRef();

Cleanup:
    return hr;
}

//
// This function copies BINDINFO structures.
//
// NOTE: IE4 added properties to the BINDINFO structure. This function
//       works with both versions. If the structure is extended in the
//       future, it will blindly copy the additional properties in the 
//       structure.
//
//- Users need to allocate the memory that the BINDINFO Dest will be copied
//  into.
//
//- Users also need to set the "cbSize" of the BINDINFO Dest to 
//  the sizeof(BINDINFO) before calling (see NOTE above).
//
//- If there is a "cbSize" conflict between the Src and the Dest, we will:
//  1) Src->cbSize = Dest->cbSize, normal copy.
//  2) Src->cbSize > Dest->cbSize, copy as much info about the Src into
//     the Dest as will fit.
//  3) Src->cbSize < Dest->cbSize, copy the Src into the Dest, Zero the
//     remaining unfilled portion of the Dest.
//
//- We don't not copy the securityattribute. We clear this value of the
//  BINDINFO Dest.
//
//- If anything goes wrong, we return the proper HRESULT and clear the
//  the BINDINFO structure using ReleaseBindInfo() (below).
//  NOTE: If "cbSize" of the Dest is ZERO, we don't do anything.
//
STDAPI
CopyBindInfo( const BINDINFO * pcbiSrc,
                BINDINFO *pbiDest )
{
/****** 8-15-97 t-gpease
Current structure at the time of writing... from URLMON.H
typedef struct tagBINDINFO {
    ULONG cbSize;
    LPWSTR szExtraInfo;
    STGMEDIUM stgmedData;
    DWORD grfBindInfoF;
    DWORD dwBindVerb;
    LPWSTR szCustomVerb;
    DWORD cbstgmedData;
// new part below this line //
    DWORD dwOptions;
    DWORD dwOptionsFlags;
    DWORD dwCodePage;
    SECURITY_ATTRIBUTES securityAttributes;
    IID iid;
    IUnknown __RPC_FAR *pUnk;
    DWORD dwReserved;
} BINDINFO;

Anything bigger than this we will blindly copy.the size of cbSize
*******/

    // NOTE: hr will an error until just before the Cleanup label.
    HRESULT hr    = E_INVALIDARG;  
    DWORD   cbSrc;
    DWORD   cbDst;

    if (!pcbiSrc || !pbiDest)
        return E_POINTER;

    cbSrc = pcbiSrc->cbSize;
    cbDst = pbiDest->cbSize;
    
    UrlMkAssert( cbSrc &&
        "CopyBindInfo(): cbSize of the source is ZERO. You must set the cbSize.");
    UrlMkAssert( cbDst &&
        "CopyBindInfo(): cbSize of the destination is ZERO. It needs to be set to the size of the BINDINFO before calling us.");
    if (!cbSrc || !cbDst)
        goto Abort;   // nothing to do or can do.

    // Copy those bytes in common, zero the rest if any
    memcpy(pbiDest, pcbiSrc, min(cbSrc, cbDst));
    pbiDest->cbSize = cbDst; // always keep this intact

    if (cbDst > cbSrc)
    {
        ZeroMemory((BYTE *)pbiDest + cbSrc, cbDst - cbSrc);
    }

    if (cbDst >= URLMONOFFSETOF(BINDINFO, dwReserved))
    {
        ZeroMemory(&pbiDest->securityAttributes, sizeof(SECURITY_ATTRIBUTES));
    }

    if (pcbiSrc->pUnk && cbDst >= URLMONOFFSETOF(BINDINFO, dwReserved))
    {
        pbiDest->pUnk->AddRef();
    }

    // NULL these anything fails we don't want to free the Sources resources.
    pbiDest->szExtraInfo  = NULL;
    pbiDest->szCustomVerb = NULL;    
    
    // Original BINDINFO no need to check size
    hr = CopyStgMedium( &pcbiSrc->stgmedData, &pbiDest->stgmedData );
    if (hr)
        goto Cleanup;

    // Original BINDINFO no need to check size
    if (pcbiSrc->szExtraInfo)
    {
        LPWSTR lpwstr = OLESTRDuplicate(pcbiSrc->szExtraInfo);
        if (!lpwstr)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        pbiDest->szExtraInfo= lpwstr;
    }

    // Original BINDINFO no need to check size
    if (pcbiSrc->szCustomVerb)
    {
        LPWSTR lpwstr = OLESTRDuplicate(pcbiSrc->szCustomVerb);
        if (!lpwstr)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        pbiDest->szCustomVerb= lpwstr;
    }

Cleanup:
    if (hr)
    {
        // This will set pbiDest members to zero so other function will not 
        // try to use the new BINDINFO.
        ReleaseBindInfo( pbiDest );
    }

Abort:
    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\urlmon\utils\assert.cxx ===
//+---------------------------------------------------------------------------
//  Copyright (C) 1991, Microsoft Corporation.
//
//  File:       assert.cxx
//
//  Contents:   Debugging output routines for idsmgr.dll
//
//  Functions:  Assert
//              PopUpError
//
//  History:    23-Jul-91   KyleP       Created.
//              09-Oct-91   KevinRo     Major changes and comments added
//              18-Oct-91   vich        moved debug print routines out
//              10-Jun-92   BryanT      Switched to w4crt.h instead of wchar.h
//              30-Sep-93   KyleP       DEVL obsolete
//
//----------------------------------------------------------------------------

#pragma hdrstop

#include "urlmon.hxx"
//
// This one file **always** uses debugging options
//

#if DBG == 1

// needed for CT TOM assert events trapping
#include <assert.hxx>

#include <stdarg.h>
#include <stdio.h>


# include <dprintf.h>            // w4printf, w4dprintf prototypes
# include <debnot.h>
# ifdef FLAT
#   include <sem.hxx>
#   include <dllsem.hxx>
# endif // FLAT

extern "C"
{

# ifdef FLAT
#  undef FAR
#  undef NEAR
# else
#  define MessageBoxA MessageBox
# endif

# include <windows.h>
}
#ifdef _CHICAGO_
int WINAPI SSMessageBox(HWND hWnd,LPCSTR lpText,LPCSTR lpCaption, UINT uType);
#endif // _CHICAGO_


extern BOOL gfService = FALSE;

unsigned long Win4InfoLevel = DEF_INFOLEVEL;
unsigned long Win4InfoMask = 0xffffffff;
ULONG Win4AssertLevel = 0;

//+---------------------------------------------------------------------------
//
//  Function:   _asdprintf
//
//  Synopsis:   Calls vdprintf to output a formatted message.
//
//  History:    18-Oct-91   vich Created
//
//----------------------------------------------------------------------------
inline void __cdecl
_asdprintf(
    char const *pszfmt, ...)
{
    va_list va;
    va_start(va, pszfmt);

    vdprintf(DEB_FORCE, "Assert", pszfmt, va);

    va_end(va);
}

//+---------------------------------------------------------------------------
//
//  Function:   _Win4Assert, private
//
//  Synopsis:   Display assertion information
//
//  Effects:    Called when an assertion is hit.
//
//  History:    12-Jul-91       AlexT   Created.
//              05-Sep-91       AlexT   Catch Throws and Catches
//              19-Oct-92       HoiV    Added events for TOM
//
//----------------------------------------------------------------------------


STDAPI_(void) Win4AssertEx(
    char const * szFile,
    int iLine,
    char const * szMessage)
{
#if defined( FLAT )
    //
    // This code is for the CT Lab only.  When running in the lab,
    // all assert popups will be trapped and notifications will
    // be sent to the manager.  If running in the office (non-lab
    // mode), the event CTTOMTrapAssertEvent will not exist and
    // consequently, no event will be pulsed.
    //

    HANDLE hTrapAssertEvent,
           hThreadStartEvent;

    if (hTrapAssertEvent = OpenEvent(EVENT_ALL_ACCESS,
                                     FALSE,
                                     CAIRO_CT_TOM_TRAP_ASSERT_EVENT))
    {
        SetEvent(hTrapAssertEvent);

        //
        // This event is to allow TOM Manager time to perform
        // a CallBack to the dispatcher.
        //
        if (hThreadStartEvent = OpenEvent(EVENT_ALL_ACCESS,
                                          FALSE,
                                          CAIRO_CT_TOM_THREAD_START_EVENT))
        {
            //
            // Wait until it's ok to popup or until timed-out
            //
            WaitForSingleObject(hThreadStartEvent, TWO_MINUTES);
        }
    }
#endif

    if (Win4AssertLevel & ASSRT_MESSAGE)
    {
# ifdef FLAT
        DWORD tid = GetCurrentThreadId();

        _asdprintf("%s File: %s Line: %u, thread id %d\n",
                   szMessage, szFile, iLine, tid);
# else  // FLAT
        _asdprintf("%s File: %s Line: %u\n", szMessage, szFile, iLine);
# endif // FLAT
    }

    if (Win4AssertLevel & ASSRT_POPUP)
    {
        int id = PopUpError(szMessage,iLine,szFile);

        if (id == IDCANCEL)
        {
#ifdef FLAT
            DebugBreak();
#else
#ifndef unix
            DebugBreak();
#endif /* unix */
#endif
        }
    }
    else if (Win4AssertLevel & ASSRT_BREAK)
    {
#ifdef FLAT
        DebugBreak();
#else
#ifndef unix
        DebugBreak();
#endif /* unix */
#endif
    }

}


//+------------------------------------------------------------
// Function:    SetWin4InfoLevel(unsigned long ulNewLevel)
//
// Synopsis:    Sets the global info level for debugging output
// Returns:     Old info level
//
//-------------------------------------------------------------

EXPORTIMP unsigned long APINOT
SetWin4InfoLevel(
    unsigned long ulNewLevel)
{
    unsigned long ul;

    ul = Win4InfoLevel;
    Win4InfoLevel = ulNewLevel;
    return(ul);
}


//+------------------------------------------------------------
// Function:    _SetWin4InfoMask(unsigned long ulNewMask)
//
// Synopsis:    Sets the global info mask for debugging output
// Returns:     Old info mask
//
//-------------------------------------------------------------

EXPORTIMP unsigned long APINOT
SetWin4InfoMask(
    unsigned long ulNewMask)
{
    unsigned long ul;

    ul = Win4InfoMask;
    Win4InfoMask = ulNewMask;
    return(ul);
}


//+------------------------------------------------------------
// Function:    _SetWin4AssertLevel(unsigned long ulNewLevel)
//
// Synopsis:    Sets the global assert level for debugging output
// Returns:     Old assert level
//
//-------------------------------------------------------------

EXPORTIMP unsigned long APINOT
SetWin4AssertLevel(
    unsigned long ulNewLevel)
{
    unsigned long ul;

    ul = Win4AssertLevel;
    Win4AssertLevel = ulNewLevel;
    return(ul);
}

//+------------------------------------------------------------
// Function:    PopUpError
//
// Synopsis:    Displays a dialog box using provided text,
//              and presents the user with the option to
//              continue or cancel.
//
// Arguments:
//      szMsg --        The string to display in main body of dialog
//      iLine --        Line number of file in error
//      szFile --       Filename of file in error
//
// Returns:
//      IDCANCEL --     User selected the CANCEL button
//      IDOK     --     User selected the OK button
//-------------------------------------------------------------

STDAPI_(int) PopUpError(
    char const *szMsg,
    int iLine,
    char const *szFile)
{

    int id;
    static char szAssertCaption[128];
    static char szModuleName[128];

    DWORD tid = GetCurrentThreadId();
    DWORD pid = GetCurrentProcessId();
    char * pszModuleName;

    if (GetModuleFileNameA(NULL, szModuleName, 128))
    {
        pszModuleName = StrRChr(szModuleName, NULL, '\\');
        if (!pszModuleName)
        {
            pszModuleName = szModuleName;
        }
        else
        {
            pszModuleName++;
        }
    }
    else
    {
        pszModuleName = "Unknown";
    }

    wsprintf(szAssertCaption,"Process: %s File: %s line %u, thread id %d.%d",
        pszModuleName, szFile, iLine, pid, tid);


    DWORD dwMessageFlags = MB_SETFOREGROUND | MB_TASKMODAL |
                           MB_ICONEXCLAMATION | MB_OKCANCEL;

#ifndef _CHICAGO_
                     //  Since this code is also used by SCM.EXE, we pass
                     //  in the following flag which causes Service pop ups
                     //  to appear on the desktop correctly

    if (gfService)
    {
        dwMessageFlags |= MB_SERVICE_NOTIFICATION | MB_DEFAULT_DESKTOP_ONLY;
    }

    id = MessageBoxA(NULL,(char *) szMsg, (LPSTR) szAssertCaption,
                     dwMessageFlags);

# ifdef _CAIRO_
    // Other processes which are services also use this code, but they
    //  have no access to set gfService, so if the above failed with an
    //  access denied error (meaning no access to the default desktop)
    //  retry as a service popup. Also, remember that we are a service
    //  so we don't waste attempts later.
    if ( !gfService && !id
         && (GetLastError() == ERROR_ACCESS_DENIED) )
    {
        gfService = TRUE;
        dwMessageFlags |= MB_SERVICE_NOTIFICATION | MB_DEFAULT_DESKTOP_ONLY;
        id = MessageBoxA(NULL,(char *) szMsg, (LPSTR) szAssertCaption,
                         dwMessageFlags);
    }
# endif

#else
    id = SSMessageBox(NULL, (char *) szMsg, (LPSTR) szAssertCaption,
                     dwMessageFlags);

#endif

    // If id == 0, then an error occurred.  There are two possibilities
    // that can cause the error:  Access Denied, which means that this
    // process does not have access to the default desktop, and everything
    // else (usually out of memory).  Oh well.

    return id;
}

//+------------------------------------------------------------
// Function:    vdprintf
//
// Synopsis:    Prints debug output using a pointer to the
//              variable information. Used primarily by the
//              xxDebugOut macros
//
// Arguements:
//      ulCompMask --   Component level mask used to determine
//                      output ability
//      pszComp    --   String const of component prefix.
//      ppszfmt    --   Pointer to output format and data
//
//-------------------------------------------------------------

//
// This semaphore is *outside* vdprintf because the compiler isn't smart
// enough to serialize access for construction if it's function-local and
// protected by a guard variable.
//
//    KyleP - 20 May, 1993
//

static CMutexSem mxs;

STDAPI_(void) vdprintf(
    unsigned long ulCompMask,
    char const   *pszComp,
    char const   *ppszfmt,
    va_list       pargs)
{
    if ((ulCompMask & DEB_FORCE) == DEB_FORCE ||
        ((ulCompMask | Win4InfoLevel) & Win4InfoMask))
    {
#if defined( FLAT )
        mxs.Request();
        DWORD tid = GetCurrentThreadId();
        DWORD pid = GetCurrentProcessId();
        if ((Win4InfoLevel & (DEB_DBGOUT | DEB_STDOUT)) != DEB_STDOUT)
#endif // FLAT
        {
            if (! (ulCompMask & DEB_NOCOMPNAME))
            {
#ifdef FLAT
#if defined(_CHICAGO_)
                //
                //  Hex Process/Thread ID's are better for Chicago since both
                //  are memory addresses.
                //
                w4dprintf( "%08x.%08x> ", pid, tid );
#else
                w4dprintf( "%d.%03d> ", pid, tid );
#endif
#endif // FLAT
                w4dprintf("%s: ", pszComp);
            }
            w4vdprintf(ppszfmt, pargs);
        }

#if defined( FLAT )
        if (Win4InfoLevel & DEB_STDOUT)
        {
            if (! (ulCompMask & DEB_NOCOMPNAME))
            {
                w4printf( "%03d> ", tid );
                w4printf("%s: ", pszComp);
            }
            w4vprintf(ppszfmt, pargs);
        }

        mxs.Release();
#endif // FLAT
    }
}

#else

int assertDontUseThisName(void)
{
    return 1;
}

#endif // DBG == 1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\urlmon\utils\coll.cxx ===
#include <urlint.h>
#include <map_kv.h>
#include "coll.hxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\urlmon\utils\coletime.cxx ===
#include <urlint.h>
#include <map_kv.h>
#include "coll.hxx"
#include "coletime.hxx"
#include <math.h>


/////////////////////////////////////////////////////////////////////////////
// COleDateTime class HELPER definitions

// Verifies will fail if the needed buffer size is too large
#define MAX_TIME_BUFFER_SIZE    128         // matches that in timecore.cpp
#define MIN_DATE                (-657434L)  // about year 100
#define MAX_DATE                2958465L    // about year 9999

// Half a second, expressed in days
#define HALF_SECOND  (1.0/172800.0)

// One-based array of days in year at month start
static int rgMonthDays[13] =
{0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365};

static BOOL OleDateFromTm(WORD wYear, WORD wMonth, WORD wDay,
                          WORD wHour, WORD wMinute, WORD wSecond, DATE& dtDest);
static BOOL TmFromOleDate(DATE dtSrc, struct tm& tmDest);
static void TmConvertToStandardFormat(struct tm& tmSrc);
static double DoubleFromDate(DATE dt);
static DATE DateFromDouble(double dbl);

/////////////////////////////////////////////////////////////////////////////
// COleDateTime class

COleDateTime PASCAL COleDateTime::GetCurrentTime()
{
    return COleDateTime(::time(NULL));
}

int COleDateTime::GetYear() const
{
    struct tm tmTemp;

    if (GetStatus() == valid && TmFromOleDate(m_dt, tmTemp))
        return tmTemp.tm_year;
    else
        return AFX_OLE_DATETIME_ERROR;
}

int COleDateTime::GetMonth() const
{
    struct tm tmTemp;

    if (GetStatus() == valid && TmFromOleDate(m_dt, tmTemp))
        return tmTemp.tm_mon;
    else
        return AFX_OLE_DATETIME_ERROR;
}

int COleDateTime::GetDay() const
{
    struct tm tmTemp;

    if (GetStatus() == valid && TmFromOleDate(m_dt, tmTemp))
        return tmTemp.tm_mday;
    else
        return AFX_OLE_DATETIME_ERROR;
}

int COleDateTime::GetHour() const
{
    struct tm tmTemp;

    if (GetStatus() == valid && TmFromOleDate(m_dt, tmTemp))
        return tmTemp.tm_hour;
    else
        return AFX_OLE_DATETIME_ERROR;
}

int COleDateTime::GetMinute() const
{
    struct tm tmTemp;

    if (GetStatus() == valid && TmFromOleDate(m_dt, tmTemp))
        return tmTemp.tm_min;
    else
        return AFX_OLE_DATETIME_ERROR;
}

int COleDateTime::GetSecond() const
{
    struct tm tmTemp;

    if (GetStatus() == valid && TmFromOleDate(m_dt, tmTemp))
        return tmTemp.tm_sec;
    else
        return AFX_OLE_DATETIME_ERROR;
}

int COleDateTime::GetDayOfWeek() const
{
    struct tm tmTemp;

    if (GetStatus() == valid && TmFromOleDate(m_dt, tmTemp))
        return tmTemp.tm_wday;
    else
        return AFX_OLE_DATETIME_ERROR;
}

int COleDateTime::GetDayOfYear() const
{
    struct tm tmTemp;

    if (GetStatus() == valid && TmFromOleDate(m_dt, tmTemp))
        return tmTemp.tm_yday;
    else
        return AFX_OLE_DATETIME_ERROR;
}

#ifdef _not_this_
const COleDateTime& COleDateTime::operator=(const VARIANT& varSrc)
{
    if (varSrc.vt != VT_DATE)
    {
        TRY
        {
            COleVariant varTemp(varSrc);
            varTemp.ChangeType(VT_DATE);
            m_dt = varTemp.date;
            SetStatus(valid);
        }
        // Catch COleException from ChangeType, but not CMemoryException
        CATCH(COleException, e)
        {
            // Not able to convert VARIANT to DATE
            DELETE_EXCEPTION(e);
            m_dt = 0;
            SetStatus(invalid);
        }
        END_CATCH
    }
    else
    {
        m_dt = varSrc.date;
        SetStatus(valid);
    }

    return *this;
}
#endif //_not_this_

const COleDateTime& COleDateTime::operator=(DATE dtSrc)
{
    m_dt = dtSrc;
    SetStatus(valid);

    return *this;
}

const COleDateTime& COleDateTime::operator=(const time_t& timeSrc)
{
    // Convert time_t to struct tm
    tm *ptm = localtime(&timeSrc);

    if (ptm != NULL)
    {
        m_status = OleDateFromTm((WORD)ptm->tm_year + 1900,
                                 (WORD)(ptm->tm_mon + 1), (WORD)ptm->tm_mday,
                                 (WORD)ptm->tm_hour, (WORD)ptm->tm_min,
                                 (WORD)ptm->tm_sec, m_dt) ? valid : invalid;
    }
    else
    {
        // Local time must have failed (timsSrc before 1/1/70 12am)
        SetStatus(invalid);
        ASSERT(FALSE);
    }

    return *this;
}

const COleDateTime& COleDateTime::operator=(const SYSTEMTIME& systimeSrc)
{
    m_status = OleDateFromTm(systimeSrc.wYear, systimeSrc.wMonth,
                             systimeSrc.wDay, systimeSrc.wHour, systimeSrc.wMinute,
                             systimeSrc.wSecond, m_dt) ? valid : invalid;

    return *this;
}

const COleDateTime& COleDateTime::operator=(const FILETIME& filetimeSrc)
{
    // Assume UTC FILETIME, so convert to LOCALTIME
    FILETIME filetimeLocal;
    if (!FileTimeToLocalFileTime( &filetimeSrc, &filetimeLocal))
    {
#ifdef _DEBUG
        DWORD dwError = GetLastError();
        TRACE1("\nFileTimeToLocalFileTime failed. Error = %lu.\n\t", dwError);
#endif // _DEBUG
        m_status = invalid;
    }
    else
    {
        // Take advantage of SYSTEMTIME -> FILETIME conversion
        SYSTEMTIME systime;
        m_status = FileTimeToSystemTime(&filetimeLocal, &systime) ?
                   valid : invalid;

        // At this point systime should always be valid, but...
        if (GetStatus() == valid)
        {
            m_status = OleDateFromTm(systime.wYear, systime.wMonth,
                                     systime.wDay, systime.wHour, systime.wMinute,
                                     systime.wSecond, m_dt) ? valid : invalid;
        }
    }

    return *this;
}

BOOL COleDateTime::operator<(const COleDateTime& date) const
{
    ASSERT(GetStatus() == valid);
    ASSERT(date.GetStatus() == valid);

    // Handle negative dates
    return DoubleFromDate(m_dt) < DoubleFromDate(date.m_dt);
}

BOOL COleDateTime::operator>(const COleDateTime& date) const
{   ASSERT(GetStatus() == valid);
    ASSERT(date.GetStatus() == valid);

    // Handle negative dates
    return DoubleFromDate(m_dt) > DoubleFromDate(date.m_dt);
}

BOOL COleDateTime::operator<=(const COleDateTime& date) const
{
    ASSERT(GetStatus() == valid);
    ASSERT(date.GetStatus() == valid);

    // Handle negative dates
    return DoubleFromDate(m_dt) <= DoubleFromDate(date.m_dt);
}

BOOL COleDateTime::operator>=(const COleDateTime& date) const
{
    ASSERT(GetStatus() == valid);
    ASSERT(date.GetStatus() == valid);

    // Handle negative dates
    return DoubleFromDate(m_dt) >= DoubleFromDate(date.m_dt);
}

COleDateTime COleDateTime::operator+(const COleDateTimeSpan& dateSpan) const
{
    COleDateTime dateResult;    // Initializes m_status to valid

    // If either operand NULL, result NULL
    if (GetStatus() == null || dateSpan.GetStatus() == null)
    {
        dateResult.SetStatus(null);
        return dateResult;
    }

    // If either operand invalid, result invalid
    if (GetStatus() == invalid || dateSpan.GetStatus() == invalid)
    {
        dateResult.SetStatus(invalid);
        return dateResult;
    }

    // Compute the actual date difference by adding underlying dates
    dateResult = DateFromDouble(DoubleFromDate(m_dt) + dateSpan.m_span);

    // Validate within range
    dateResult.CheckRange();

    return dateResult;
}

COleDateTime COleDateTime::operator-(const COleDateTimeSpan& dateSpan) const
{
    COleDateTime dateResult;    // Initializes m_status to valid

    // If either operand NULL, result NULL
    if (GetStatus() == null || dateSpan.GetStatus() == null)
    {
        dateResult.SetStatus(null);
        return dateResult;
    }

    // If either operand invalid, result invalid
    if (GetStatus() == invalid || dateSpan.GetStatus() == invalid)
    {
        dateResult.SetStatus(invalid);
        return dateResult;
    }

    // Compute the actual date difference by subtracting underlying dates
    dateResult = DateFromDouble(DoubleFromDate(m_dt) - dateSpan.m_span);

    // Validate within range
    dateResult.CheckRange();

    return dateResult;
}

COleDateTimeSpan COleDateTime::operator-(const COleDateTime& date) const
{
    COleDateTimeSpan spanResult;

    // If either operand NULL, result NULL
    if (GetStatus() == null || date.GetStatus() == null)
    {
        spanResult.SetStatus(COleDateTimeSpan::null);
        return spanResult;
    }

    // If either operand invalid, result invalid
    if (GetStatus() == invalid || date.GetStatus() == invalid)
    {
        spanResult.SetStatus(COleDateTimeSpan::invalid);
        return spanResult;
    }

    // Return result (span can't be invalid, so don't check range)
    return DoubleFromDate(m_dt) - DoubleFromDate(date.m_dt);
}

BOOL COleDateTime::SetDateTime(int nYear, int nMonth, int nDay,
                               int nHour, int nMin, int nSec)
{
    return m_status = OleDateFromTm((WORD)nYear, (WORD)nMonth,
                                    (WORD)nDay, (WORD)nHour, (WORD)nMin, (WORD)nSec, m_dt) ?
                      valid : invalid;
}

#ifdef _not_yet_
BOOL COleDateTime::ParseDateTime(LPCTSTR lpszDate, DWORD dwFlags, LCID lcid)
{
    USES_CONVERSION;
    CString strDate = lpszDate;

    SCODE sc;
    if (FAILED(sc = VarDateFromStr((LPOLESTR)T2COLE(strDate), lcid,
                                   dwFlags, &m_dt)))
    {
        if (sc == DISP_E_TYPEMISMATCH)
        {
            // Can't convert string to date, set 0 and invalidate
            m_dt = 0;
            SetStatus(invalid);
            return FALSE;
        }
        else if (sc == DISP_E_OVERFLOW)
        {
            // Can't convert string to date, set -1 and invalidate
            m_dt = -1;
            SetStatus(invalid);
            return FALSE;
        }
        else
        {
            TRACE0("\nCOleDateTime VarDateFromStr call failed.\n\t");
            if (sc == E_OUTOFMEMORY)
                AfxThrowMemoryException();
            else
                AfxThrowOleException(sc);
        }
    }

    SetStatus(valid);
    return TRUE;
}

CString COleDateTime::Format(DWORD dwFlags, LCID lcid) const
{
    USES_CONVERSION;
    CString strDate;

    // If null, return empty string
    if (GetStatus() == null)
        return strDate;

    // If invalid, return DateTime resource string
    if (GetStatus() == invalid)
    {
        VERIFY(strDate.LoadString(AFX_IDS_INVALID_DATETIME));
        return strDate;
    }

    COleVariant var;
    // Don't need to trap error. Should not fail due to type mismatch
    CheckError(VarBstrFromDate(m_dt, lcid, dwFlags, &V_BSTR(&var)));
    var.vt = VT_BSTR;
    return OLE2CT(V_BSTR(&var));
}
#endif //_not_yet_

CString COleDateTime::Format(LPCTSTR pFormat) const
{
    CString strDate;
    struct tm tmTemp;

    // If null, return empty string
    if (GetStatus() == null)
        return strDate;

    // If invalid, return DateTime resource string
    if (GetStatus() == invalid || !TmFromOleDate(m_dt, tmTemp))
    {
        //VERIFY(strDate.LoadString(AFX_IDS_INVALID_DATETIME));
        return strDate;
    }

    // Convert tm from afx internal format to standard format
    TmConvertToStandardFormat(tmTemp);

    // Fill in the buffer, disregard return value as it's not necessary
    LPTSTR lpszTemp = strDate.GetBufferSetLength(MAX_TIME_BUFFER_SIZE);
    _tcsftime(lpszTemp, strDate.GetLength(), pFormat, &tmTemp);
    strDate.ReleaseBuffer();

    return strDate;
}

CString COleDateTime::Format(UINT nFormatID) const
{
    CString strFormat;
    //VERIFY(strFormat.LoadString(nFormatID) != 0);
    return Format(strFormat);
}

void COleDateTime::CheckRange()
{
    if (m_dt > MAX_DATE || m_dt < MIN_DATE) // about year 100 to about 9999
        SetStatus(invalid);
}

// serialization
#ifdef _DEBUG
CDumpContext& AFXAPI operator<<(CDumpContext& dc, COleDateTime dateSrc)
{
    dc << "\nCOleDateTime Object:";
    dc << "\n\tm_status = " << (long)dateSrc.m_status;

    COleVariant var(dateSrc);
    var.ChangeType(VT_BSTR);

    return dc << "\n\tdate = " << (LPCTSTR)var.bstrVal;
}
#endif // _DEBUG

#ifdef _not_yet_
CArchive& AFXAPI operator<<(CArchive& ar, COleDateTime dateSrc)
{
    ar << (long)dateSrc.m_status;
    return ar << dateSrc.m_dt;
}

CArchive& AFXAPI operator>>(CArchive& ar, COleDateTime& dateSrc)
{
    ar >> (long&)dateSrc.m_status;
    return ar >> dateSrc.m_dt;
}
#endif //_not_yet_

/////////////////////////////////////////////////////////////////////////////
// COleDateTimeSpan class helpers

#define MAX_DAYS_IN_SPAN    3615897L

/////////////////////////////////////////////////////////////////////////////
// COleDateTimeSpan class
long COleDateTimeSpan::GetHours() const
{
    ASSERT(GetStatus() == valid);

    double dblTemp;

    // Truncate days and scale up
    dblTemp = modf(m_span, &dblTemp);
    return (long)(dblTemp * 24);
}

long COleDateTimeSpan::GetMinutes() const
{
    ASSERT(GetStatus() == valid);

    double dblTemp;

    // Truncate hours and scale up
    dblTemp = modf(m_span * 24, &dblTemp);
    return (long)(dblTemp * 60);
}

long COleDateTimeSpan::GetSeconds() const
{
    ASSERT(GetStatus() == valid);

    double dblTemp;

    // Truncate minutes and scale up
    dblTemp = modf(m_span * 24 * 60, &dblTemp);
    return (long)(dblTemp * 60);
}

const COleDateTimeSpan& COleDateTimeSpan::operator=(double dblSpanSrc)
{
    m_span = dblSpanSrc;
    SetStatus(valid);
    return *this;
}

const COleDateTimeSpan& COleDateTimeSpan::operator=(const COleDateTimeSpan& dateSpanSrc)
{
    m_span = dateSpanSrc.m_span;
    m_status = dateSpanSrc.m_status;
    return *this;
}

COleDateTimeSpan COleDateTimeSpan::operator+(const COleDateTimeSpan& dateSpan) const
{
    COleDateTimeSpan dateSpanTemp;

    // If either operand Null, result Null
    if (GetStatus() == null || dateSpan.GetStatus() == null)
    {
        dateSpanTemp.SetStatus(null);
        return dateSpanTemp;
    }

    // If either operand Invalid, result Invalid
    if (GetStatus() == invalid || dateSpan.GetStatus() == invalid)
    {
        dateSpanTemp.SetStatus(invalid);
        return dateSpanTemp;
    }

    // Add spans and validate within legal range
    dateSpanTemp.m_span = m_span + dateSpan.m_span;
    dateSpanTemp.CheckRange();

    return dateSpanTemp;
}

COleDateTimeSpan COleDateTimeSpan::operator-(const COleDateTimeSpan& dateSpan) const
{
    COleDateTimeSpan dateSpanTemp;

    // If either operand Null, result Null
    if (GetStatus() == null || dateSpan.GetStatus() == null)
    {
        dateSpanTemp.SetStatus(null);
        return dateSpanTemp;
    }

    // If either operand Invalid, result Invalid
    if (GetStatus() == invalid || dateSpan.GetStatus() == invalid)
    {
        dateSpanTemp.SetStatus(invalid);
        return dateSpanTemp;
    }

    // Subtract spans and validate within legal range
    dateSpanTemp.m_span = m_span - dateSpan.m_span;
    dateSpanTemp.CheckRange();

    return dateSpanTemp;
}

void COleDateTimeSpan::SetDateTimeSpan(
                                      long lDays, int nHours, int nMins, int nSecs)
{
    // Set date span by breaking into fractional days (all input ranges valid)
    m_span = lDays + ((double)nHours)/24 + ((double)nMins)/(24*60) +
             ((double)nSecs)/(24*60*60);

    SetStatus(valid);
}

CString COleDateTimeSpan::Format(LPCTSTR pFormat) const
{
    CString strSpan;
    struct tm tmTemp;

    // If null, return empty string
    if (GetStatus() == null)
        return strSpan;

    // If invalid, return DateTimeSpan resource string
    if (GetStatus() == invalid || !TmFromOleDate(m_span, tmTemp))
    {
        //VERIFY(strSpan.LoadString(AFX_IDS_INVALID_DATETIMESPAN));
        return strSpan;
    }

    // Convert tm from afx internal format to standard format
    TmConvertToStandardFormat(tmTemp);

    // Fill in the buffer, disregard return value as it's not necessary
    LPTSTR lpszTemp = strSpan.GetBufferSetLength(MAX_TIME_BUFFER_SIZE);
    _tcsftime(lpszTemp, strSpan.GetLength(), pFormat, &tmTemp);
    strSpan.ReleaseBuffer();

    return strSpan;
}

CString COleDateTimeSpan::Format(UINT nFormatID) const
{
    CString strFormat;
    //VERIFY(strFormat.LoadString(nFormatID) != 0);
    return Format(strFormat);
}

void COleDateTimeSpan::CheckRange()
{
    if (m_span < -MAX_DAYS_IN_SPAN || m_span > MAX_DAYS_IN_SPAN)
        SetStatus(invalid);
}

// serialization
#ifdef _DEBUG
CDumpContext& AFXAPI operator<<(CDumpContext& dc, COleDateTimeSpan dateSpanSrc)
{
    dc << "\nCOleDateTimeSpan Object:";
    dc << "\n\tm_status = " << (long)dateSpanSrc.m_status;

    COleVariant var(dateSpanSrc.m_span);
    var.ChangeType(VT_BSTR);

    return dc << "\n\tdateSpan = " << (LPCTSTR)var.bstrVal;
}
#endif // _DEBUG

#ifdef _not_yet_
CArchive& AFXAPI operator<<(CArchive& ar, COleDateTimeSpan dateSpanSrc)
{
    ar << (long)dateSpanSrc.m_status;
    return ar << dateSpanSrc.m_span;
}

CArchive& AFXAPI operator>>(CArchive& ar, COleDateTimeSpan& dateSpanSrc)
{
    ar >> (long&)dateSpanSrc.m_status;
    return ar >> dateSpanSrc.m_span;
}
#endif //_not_yet_

/////////////////////////////////////////////////////////////////////////////
// COleDateTime class HELPERS - implementation

BOOL OleDateFromTm(WORD wYear, WORD wMonth, WORD wDay,
                   WORD wHour, WORD wMinute, WORD wSecond, DATE& dtDest)
{
    // Validate year and month (ignore day of week and milliseconds)
    if (wYear > 9999 || wMonth < 1 || wMonth > 12)
        return FALSE;

    //  Check for leap year and set the number of days in the month
    BOOL bLeapYear = ((wYear & 3) == 0) &&
                     ((wYear % 100) != 0 || (wYear % 400) == 0);

    int nDaysInMonth =
    rgMonthDays[wMonth] - rgMonthDays[wMonth-1] +
    ((bLeapYear && wDay == 29 && wMonth == 2) ? 1 : 0);

    // Finish validating the date
    if (wDay < 1 || wDay > nDaysInMonth ||
        wHour > 23 || wMinute > 59 ||
        wSecond > 59)
    {
        return FALSE;
    }

    // Cache the date in days and time in fractional days
    long nDate;
    double dblTime;

    //It is a valid date; make Jan 1, 1AD be 1
    nDate = wYear*365L + wYear/4 - wYear/100 + wYear/400 +
            rgMonthDays[wMonth-1] + wDay;

    //  If leap year and it's before March, subtract 1:
    if (wMonth <= 2 && bLeapYear)
        --nDate;

    //  Offset so that 12/30/1899 is 0
    nDate -= 693959L;

    dblTime = (((long)wHour * 3600L) +  // hrs in seconds
               ((long)wMinute * 60L) +  // mins in seconds
               ((long)wSecond)) / 86400.;

    dtDest = (double) nDate + ((nDate >= 0) ? dblTime : -dblTime);

    return TRUE;
}

BOOL TmFromOleDate(DATE dtSrc, struct tm& tmDest)
{
    // The legal range does not actually span year 0 to 9999.
    if (dtSrc > MAX_DATE || dtSrc < MIN_DATE) // about year 100 to about 9999
        return FALSE;

    long nDays;             // Number of days since Dec. 30, 1899
    long nDaysAbsolute;     // Number of days since 1/1/0
    long nSecsInDay;        // Time in seconds since midnight
    long nMinutesInDay;     // Minutes in day

    long n400Years;         // Number of 400 year increments since 1/1/0
    long n400Century;       // Century within 400 year block (0,1,2 or 3)
    long n4Years;           // Number of 4 year increments since 1/1/0
    long n4Day;             // Day within 4 year block
    //  (0 is 1/1/yr1, 1460 is 12/31/yr4)
    long n4Yr;              // Year within 4 year block (0,1,2 or 3)
    BOOL bLeap4 = TRUE;     // TRUE if 4 year block includes leap year

    double dblDate = dtSrc; // tempory serial date

    // If a valid date, then this conversion should not overflow
    nDays = (long)dblDate;

    // Round to the second
    dblDate += ((dtSrc > 0.0) ? HALF_SECOND : -HALF_SECOND);

    nDaysAbsolute = (long)dblDate + 693959L; // Add days from 1/1/0 to 12/30/1899

    dblDate = fabs(dblDate);
    nSecsInDay = (long)((dblDate - floor(dblDate)) * 86400.);

    // Calculate the day of week (sun=1, mon=2...)
    //   -1 because 1/1/0 is Sat.  +1 because we want 1-based
    tmDest.tm_wday = (int)((nDaysAbsolute - 1) % 7L) + 1;

    // Leap years every 4 yrs except centuries not multiples of 400.
    n400Years = (long)(nDaysAbsolute / 146097L);

    // Set nDaysAbsolute to day within 400-year block
    nDaysAbsolute %= 146097L;

    // -1 because first century has extra day
    n400Century = (long)((nDaysAbsolute - 1) / 36524L);

    // Non-leap century
    if (n400Century != 0)
    {
        // Set nDaysAbsolute to day within century
        nDaysAbsolute = (nDaysAbsolute - 1) % 36524L;

        // +1 because 1st 4 year increment has 1460 days
        n4Years = (long)((nDaysAbsolute + 1) / 1461L);

        if (n4Years != 0)
            n4Day = (long)((nDaysAbsolute + 1) % 1461L);
        else
        {
            bLeap4 = FALSE;
            n4Day = (long)nDaysAbsolute;
        }
    }
    else
    {
        // Leap century - not special case!
        n4Years = (long)(nDaysAbsolute / 1461L);
        n4Day = (long)(nDaysAbsolute % 1461L);
    }

    if (bLeap4)
    {
        // -1 because first year has 366 days
        n4Yr = (n4Day - 1) / 365;

        if (n4Yr != 0)
            n4Day = (n4Day - 1) % 365;
    }
    else
    {
        n4Yr = n4Day / 365;
        n4Day %= 365;
    }

    // n4Day is now 0-based day of year. Save 1-based day of year, year number
    tmDest.tm_yday = (int)n4Day + 1;
    tmDest.tm_year = n400Years * 400 + n400Century * 100 + n4Years * 4 + n4Yr;

    // Handle leap year: before, on, and after Feb. 29.
    if (n4Yr == 0 && bLeap4)
    {
        // Leap Year
        if (n4Day == 59)
        {
            /* Feb. 29 */
            tmDest.tm_mon = 2;
            tmDest.tm_mday = 29;
            goto DoTime;
        }

        // Pretend it's not a leap year for month/day comp.
        if (n4Day >= 60)
            --n4Day;
    }

    // Make n4DaY a 1-based day of non-leap year and compute
    //  month/day for everything but Feb. 29.
    ++n4Day;

    // Month number always >= n/32, so save some loop time */
    for (tmDest.tm_mon = (n4Day >> 5) + 1;
        n4Day > rgMonthDays[tmDest.tm_mon]; tmDest.tm_mon++);

    tmDest.tm_mday = (int)(n4Day - rgMonthDays[tmDest.tm_mon-1]);

    DoTime:
    if (nSecsInDay == 0)
        tmDest.tm_hour = tmDest.tm_min = tmDest.tm_sec = 0;
    else
    {
        tmDest.tm_sec = (int)nSecsInDay % 60L;
        nMinutesInDay = nSecsInDay / 60L;
        tmDest.tm_min = (int)nMinutesInDay % 60;
        tmDest.tm_hour = (int)nMinutesInDay / 60;
    }

    return TRUE;
}

void TmConvertToStandardFormat(struct tm& tmSrc)
{
    // Convert afx internal tm to format expected by runtimes (_tcsftime, etc)
    tmSrc.tm_year -= 1900;  // year is based on 1900
    tmSrc.tm_mon -= 1;      // month of year is 0-based
    tmSrc.tm_wday -= 1;     // day of week is 0-based
    tmSrc.tm_yday -= 1;     // day of year is 0-based
}

double DoubleFromDate(DATE dt)
{
    // No problem if positive
    if (dt >= 0)
        return dt;

    // If negative, must convert since negative dates not continuous
    // (examples: -1.25 to -.75, -1.50 to -.50, -1.75 to -.25)
    double temp = ceil(dt);
    return temp - (dt - temp);
}

DATE DateFromDouble(double dbl)
{
    // No problem if positive
    if (dbl >= 0)
        return dbl;

    // If negative, must convert since negative dates not continuous
    // (examples: -.75 to -1.25, -.50 to -1.50, -.25 to -1.75)
    double temp = floor(dbl); // dbl is now whole part
    return temp + (temp - dbl);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\urlmon\utils\cvar.cxx ===
#include <malloc.h>
#include <urlint.h>
#include <map_kv.h>
#include "coll.hxx"
#ifndef unix
#include "COleTime.hxx"
#else
#include "coletime.hxx"
#endif /* unix */
#include "cvar.hxx"

//void * _cdecl operator new(size_t sizeEl, ULONG cEl);
void * _cdecl operator new(size_t sizeEl, COleVariant *pCVar);

void * _cdecl operator new(size_t sizeEl, COleVariant *pCVar)
{
    return  0;
}

/*
struct AFX_EXCEPTION_LINK
{
#ifdef _AFX_OLD_EXCEPTIONS
        union
        {
                _AFX_JUMPBUF m_jumpBuf;
                struct
                {
                        void (PASCAL* pfnCleanup)(AFX_EXCEPTION_LINK* pLink);
                        void* pvData;       // extra data follows
                } m_callback;       // callback for cleanup (nType != 0)
        };
        UINT m_nType;               // 0 for setjmp, !=0 for user extension
#endif //!_AFX_OLD_EXCEPTIONS

        AFX_EXCEPTION_LINK* m_pLinkPrev;    // previous top, next in handler chain
        CException* m_pException;   // current exception (NULL in TRY block)

        AFX_EXCEPTION_LINK();       // for initialization and linking
        ~AFX_EXCEPTION_LINK()       // for cleanup and unlinking
                { AfxTryCleanup(); };
};
*/
#define TRY { AFX_EXCEPTION_LINK _afxExceptionLink; try {

#define CATCH(class, e) } catch (class* e) \
        { ASSERT(e->IsKindOf(RUNTIME_CLASS(class))); \
                _afxExceptionLink.m_pException = e;

#define AND_CATCH(class, e) } catch (class* e) \
        { ASSERT(e->IsKindOf(RUNTIME_CLASS(class))); \
                _afxExceptionLink.m_pException = e;

#define END_CATCH } }


#define THROW(e) throw e
#define THROW_LAST() (AfxThrowLastCleanup(), throw)

// Advanced macros for smaller code
#define CATCH_ALL(e) } catch (CException* e) \
        { { ASSERT(e->IsKindOf(RUNTIME_CLASS(CException))); \
                _afxExceptionLink.m_pException = e;

#define AND_CATCH_ALL(e) } catch (CException* e) \
        { { ASSERT(e->IsKindOf(RUNTIME_CLASS(CException))); \
                _afxExceptionLink.m_pException = e;

#define END_CATCH_ALL } } }

#define END_TRY } catch (CException* e) \
        { ASSERT(e->IsKindOf(RUNTIME_CLASS(CException))); \
                _afxExceptionLink.m_pException = e; } }

#define AFX_OLE_FALSE 0
#define AFX_OLE_TRUE (-1)

#ifndef _DEBUG
#define USES_CONVERSION int _convert; _convert
#else
#define USES_CONVERSION int _convert = 0;
#endif

#ifdef _DEBUG
#define UNUSED(x)
#else
#define UNUSED(x) x
#endif
#define UNUSED_ALWAYS(x) x


/////////////////////////////////////////////////////////////////////////////
// Global UNICODE<>ANSI translation helpers

LPWSTR AFXAPI AfxA2WHelper(LPWSTR lpw, LPCSTR lpa, int nChars);
LPSTR AFXAPI AfxW2AHelper(LPSTR lpa, LPCWSTR lpw, int nChars);

#define A2CW(lpa) (\
        ((LPCSTR)lpa == NULL) ? NULL : (\
                _convert = (lstrlenA(lpa)+1),\
                (LPCWSTR)AfxA2WHelper((LPWSTR) alloca(_convert*2), lpa, _convert)\
        )\
)

#define A2W(lpa) (\
        ((LPCSTR)lpa == NULL) ? NULL : (\
                _convert = (lstrlenA(lpa)+1),\
                AfxA2WHelper((LPWSTR) alloca(_convert*2), lpa, _convert)\
        )\
)

#define W2CA(lpw) (\
        ((LPCWSTR)lpw == NULL) ? NULL : (\
                _convert = (wcslen(lpw)+1)*2,\
                (LPCSTR)AfxW2AHelper((LPSTR) alloca(_convert), lpw, _convert)\
        )\
)

#define W2A(lpw) (\
        ((LPCWSTR)lpw == NULL) ? NULL : (\
                _convert = (wcslen(lpw)+1)*2,\
                AfxW2AHelper((LPSTR) alloca(_convert), lpw, _convert)\
        )\
)


#if defined(_UNICODE)
// in these cases the default (TCHAR) is the same as OLECHAR
        #define DEVMODEOLE DEVMODEW
        #define LPDEVMODEOLE LPDEVMODEW
        #define TEXTMETRICOLE TEXTMETRICW
        #define LPTEXTMETRICOLE LPTEXTMETRICW
        inline size_t ocslen(LPCOLESTR x) { return wcslen(x); }
        inline OLECHAR* ocscpy(LPOLESTR dest, LPCOLESTR src) { return wcscpy(dest, src); }
        inline LPCOLESTR T2COLE(LPCTSTR lp) { return lp; }
        inline LPCTSTR OLE2CT(LPCOLESTR lp) { return lp; }
        inline LPOLESTR T2OLE(LPTSTR lp) { return lp; }
        inline LPTSTR OLE2T(LPOLESTR lp) { return lp; }
        inline LPOLESTR TASKSTRINGT2OLE(LPOLESTR lp) { return lp; }
        inline LPTSTR TASKSTRINGOLE2T(LPOLESTR lp) { return lp; }
        inline LPDEVMODEW DEVMODEOLE2T(LPDEVMODEOLE lp) { return lp; }
        inline LPDEVMODEOLE DEVMODET2OLE(LPDEVMODEW lp) { return lp; }
        inline LPTEXTMETRICW TEXTMETRICOLE2T(LPTEXTMETRICOLE lp) { return lp; }
        inline LPTEXTMETRICOLE TEXTMETRICT2OLE(LPTEXTMETRICW lp) { return lp; }
        inline BSTR BSTR2TBSTR(BSTR bstr) { return bstr;}
#elif defined(OLE2ANSI)
// in these cases the default (TCHAR) is the same as OLECHAR
        #define DEVMODEOLE DEVMODEA
        #define LPDEVMODEOLE LPDEVMODEA
        #define TEXTMETRICOLE TEXTMETRICA
        #define LPTEXTMETRICOLE LPTEXTMETRICA
        inline size_t ocslen(LPCOLESTR x) { return lstrlenA(x); }
        inline OLECHAR* ocscpy(LPOLESTR dest, LPCOLESTR src) { return lstrcpyA(dest, src); }
        inline LPCOLESTR T2COLE(LPCTSTR lp) { return lp; }
        inline LPCTSTR OLE2CT(LPCOLESTR lp) { return lp; }
        inline LPOLESTR T2OLE(LPTSTR lp) { return lp; }
        inline LPTSTR OLE2T(LPOLESTR lp) { return lp; }
        inline LPOLESTR TASKSTRINGT2OLE(LPOLESTR lp) { return lp; }
        inline LPTSTR TASKSTRINGOLE2T(LPOLESTR lp) { return lp; }
        inline LPDEVMODE DEVMODEOLE2T(LPDEVMODEOLE lp) { return lp; }
        inline LPDEVMODEOLE DEVMODET2OLE(LPDEVMODE lp) { return lp; }
        inline LPTEXTMETRIC TEXTMETRICOLE2T(LPTEXTMETRICOLE lp) { return lp; }
        inline LPTEXTMETRICOLE TEXTMETRICT2OLE(LPTEXTMETRIC lp) { return lp; }
        inline BSTR BSTR2TBSTR(BSTR bstr) { return bstr; }
#else
        #define DEVMODEOLE DEVMODEW
        #define LPDEVMODEOLE LPDEVMODEW
        #define TEXTMETRICOLE TEXTMETRICW
        #define LPTEXTMETRICOLE LPTEXTMETRICW
        inline size_t ocslen(LPCOLESTR x) { return wcslen(x); }
        inline OLECHAR* ocscpy(LPOLESTR dest, LPCOLESTR src) { return wcscpy(dest, src); }
        #define T2COLE(lpa) A2CW(lpa)
        #define T2OLE(lpa) A2W(lpa)
        #define OLE2CT(lpo) W2CA(lpo)
        #define OLE2T(lpo) W2A(lpo)
        #define TASKSTRINGT2OLE(lpa)    AfxTaskStringA2W(lpa)
        #define TASKSTRINGOLE2T(lpo) AfxTaskStringW2A(lpo)
        #define DEVMODEOLE2T(lpo) DEVMODEW2A(lpo)
        #define DEVMODET2OLE(lpa) DEVMODEA2W(lpa)
        #define TEXTMETRICOLE2T(lptmw) TEXTMETRICW2A(lptmw)
        #define TEXTMETRICT2OLE(lptma) TEXTMETRICA2W(lptma)
        #define BSTR2TBSTR(bstr) AfxBSTR2ABSTR(bstr)
#endif

#ifdef OLE2ANSI
        #define W2OLE W2A
        #define W2COLE W2CA
        #define OLE2W A2W
        #define OLE2CW A2CW
        inline LPOLESTR A2OLE(LPSTR lp) { return lp; }
        inline LPCOLESTR A2COLE(LPCSTR lp) { return lp; }
        inline LPSTR OLE2A(LPOLESTR lp) { return lp; }
        inline LPCSTR OLE2CA(LPCOLESTR lp) { return lp; }
#else
        #define A2OLE A2W
        #define A2COLE A2CW
        #define OLE2A W2A
        #define OLE2CA W2CA
        inline LPOLESTR W2OLE(LPWSTR lp) { return lp; }
        inline LPCOLESTR W2COLE(LPCWSTR lp) { return lp; }
        inline LPWSTR OLE2W(LPOLESTR lp) { return lp; }
        inline LPCWSTR OLE2CW(LPCOLESTR lp) { return lp; }
#endif

/////////////////////////////////////////////////////////////////////////////
// helpers

static void PASCAL CheckError(SCODE sc);
static BOOL PASCAL CompareSafeArrays(SAFEARRAY* parray1, SAFEARRAY* parray2);
static void PASCAL CreateOneDimArray(VARIANT& varSrc, DWORD dwSize);
static void PASCAL CopyBinaryData(SAFEARRAY* parray,
        const void* pSrc, DWORD dwSize);

/////////////////////////////////////////////////////////////////////////////
// COleVariant class

COleVariant::COleVariant(const VARIANT& varSrc)
{
        AfxVariantInit(this);
        CheckError(::VariantCopy(this, (LPVARIANT)&varSrc));
}

COleVariant::COleVariant(LPCVARIANT pSrc)
{
        AfxVariantInit(this);
        CheckError(::VariantCopy(this, (LPVARIANT)pSrc));
}

COleVariant::COleVariant(const COleVariant& varSrc)
{
        AfxVariantInit(this);
        CheckError(::VariantCopy(this, (LPVARIANT)&varSrc));
}

COleVariant::COleVariant(LPCTSTR lpszSrc, VARTYPE vtSrc)
{
        USES_CONVERSION;
        ASSERT(vtSrc == VT_BSTR || vtSrc == VT_BSTRT);
        UNUSED(vtSrc);

        vt = VT_BSTR;
        bstrVal = NULL;

        if (lpszSrc != NULL)
        {
#ifndef _UNICODE
                if (vtSrc == VT_BSTRT)
                {
                        int nLen = lstrlen(lpszSrc);
                        bstrVal = ::SysAllocStringByteLen(lpszSrc, nLen);
                }
                else
#endif
                {
                        bstrVal = ::SysAllocString(T2COLE(lpszSrc));
                }

                /*
                BUGBUG:
                if (bstrVal == NULL)
                        AfxThrowMemoryException();
                */
        }
}

void COleVariant::SetString(LPCTSTR lpszSrc, VARTYPE vtSrc)
{
        USES_CONVERSION;
        ASSERT(vtSrc == VT_BSTR || vtSrc == VT_BSTRT);
        UNUSED(vtSrc);

        // Free up previous VARIANT
        Clear();

        vt = VT_BSTR;
        bstrVal = NULL;

        if (lpszSrc != NULL)
        {
#ifndef _UNICODE
                if (vtSrc == VT_BSTRT)
                {
                        int nLen = lstrlen(lpszSrc);
                        bstrVal = ::SysAllocStringByteLen(lpszSrc, nLen);
                }
                else
#endif
                {
                        bstrVal = ::SysAllocString(T2COLE(lpszSrc));
                }

                /*
                BUGBUG:
                if (bstrVal == NULL)
                        AfxThrowMemoryException();
                */
        }
}

COleVariant::COleVariant(short nSrc, VARTYPE vtSrc)
{
        ASSERT(vtSrc == VT_I2 || vtSrc == VT_BOOL);

        if (vtSrc == VT_BOOL)
        {
                vt = VT_BOOL;
                if (nSrc == FALSE)
                        V_BOOL(this) = AFX_OLE_FALSE;
                else
                        V_BOOL(this) = AFX_OLE_TRUE;
        }
        else
        {
                vt = VT_I2;
                iVal = nSrc;
        }
}

COleVariant::COleVariant(long lSrc, VARTYPE vtSrc)
{
        ASSERT(vtSrc == VT_I4 || vtSrc == VT_ERROR || vtSrc == VT_BOOL);

        if (vtSrc == VT_ERROR)
        {
                vt = VT_ERROR;
                scode = lSrc;
        }
        else if (vtSrc == VT_BOOL)
        {
                vt = VT_BOOL;
                if (lSrc == FALSE)
                        V_BOOL(this) = AFX_OLE_FALSE;
                else
                        V_BOOL(this) = AFX_OLE_TRUE;
        }
        else
        {
                vt = VT_I4;
                lVal = lSrc;
        }
}

// Operations
void COleVariant::Clear()
{
        VERIFY(::VariantClear(this) == NOERROR);
}

void COleVariant::ChangeType(VARTYPE vartype, LPVARIANT pSrc)
{
        // If pSrc is NULL, convert type in place
        if (pSrc == NULL)
                pSrc = this;
        if (pSrc != this || vartype != vt)
                CheckError(::VariantChangeType(this, pSrc, 0, vartype));
}

void COleVariant::Attach(VARIANT& varSrc)
{
        // Free up previous VARIANT
        Clear();

        // give control of data to COleVariant
        memcpy(this, &varSrc, sizeof(varSrc));
        varSrc.vt = VT_EMPTY;
}

VARIANT COleVariant::Detach()
{
        VARIANT varResult = *this;
        vt = VT_EMPTY;
        return varResult;
}

// Literal comparison. Types and values must match.
BOOL COleVariant::operator==(const VARIANT& var) const
{
        if (&var == this)
                return TRUE;

        // Variants not equal if types don't match
        if (var.vt != vt)
                return FALSE;

        // Check type specific values
        switch (vt)
        {
        case VT_EMPTY:
        case VT_NULL:
                return TRUE;

        case VT_BOOL:
                return V_BOOL(&var) == V_BOOL(this);

        case VT_UI1:
                return var.bVal == bVal;

        case VT_I2:
                return var.iVal == iVal;

        case VT_I4:
                return var.lVal == lVal;

        case VT_CY:
                return (var.cyVal.Hi == cyVal.Hi && var.cyVal.Lo == cyVal.Lo);

        case VT_R4:
                return var.fltVal == fltVal;

        case VT_R8:
                return var.dblVal == dblVal;

        case VT_DATE:
                return var.date == date;

        case VT_BSTR:
                return SysStringByteLen(var.bstrVal) == SysStringByteLen(bstrVal) &&
                        memcmp(var.bstrVal, bstrVal, SysStringByteLen(bstrVal)) == 0;

        case VT_ERROR:
                return var.scode == scode;

        case VT_DISPATCH:
        case VT_UNKNOWN:
                return var.punkVal == punkVal;

        default:
                if (vt & VT_ARRAY && !(vt & VT_BYREF))
                        return CompareSafeArrays(var.parray, parray);
                else
                        ASSERT(FALSE);  // VT_BYREF not supported
                // fall through
        }

        return FALSE;
}

const COleVariant& COleVariant::operator=(const VARIANT& varSrc)
{
        CheckError(::VariantCopy(this, (LPVARIANT)&varSrc));
        return *this;
}

const COleVariant& COleVariant::operator=(LPCVARIANT pSrc)
{
        CheckError(::VariantCopy(this, (LPVARIANT)pSrc));
        return *this;
}

const COleVariant& COleVariant::operator=(const COleVariant& varSrc)
{
        CheckError(::VariantCopy(this, (LPVARIANT)&varSrc));
        return *this;
}

const COleVariant& COleVariant::operator=(const LPCTSTR lpszSrc)
{
        USES_CONVERSION;
        // Free up previous VARIANT
        Clear();

        vt = VT_BSTR;
        if (lpszSrc == NULL)
                bstrVal = NULL;
        else
        {
                bstrVal = ::SysAllocString(T2COLE(lpszSrc));
                /*
                BUGBUG:
                if (bstrVal == NULL)
                        AfxThrowMemoryException();
                */
        }
        return *this;
}

const COleVariant& COleVariant::operator=(const CString& strSrc)
{
        USES_CONVERSION;
        // Free up previous VARIANT
        Clear();

        vt = VT_BSTR;
        bstrVal = ::SysAllocString(T2COLE(strSrc));
        /*
        BUGBUG:
        if (bstrVal == NULL)
                AfxThrowMemoryException();
        */

        return *this;
}

const COleVariant& COleVariant::operator=(BYTE nSrc)
{
        // Free up previous VARIANT if necessary
        if (vt != VT_UI1)
        {
                Clear();
                vt = VT_UI1;
        }

        bVal = nSrc;
        return *this;
}

const COleVariant& COleVariant::operator=(short nSrc)
{
        if (vt == VT_I2)
                iVal = nSrc;
        else if (vt == VT_BOOL)
        {
                if (nSrc == FALSE)
                        V_BOOL(this) = AFX_OLE_FALSE;
                else
                        V_BOOL(this) = AFX_OLE_TRUE;
        }
        else
        {
                // Free up previous VARIANT
                Clear();
                vt = VT_I2;
                iVal = nSrc;
        }

        return *this;
}

const COleVariant& COleVariant::operator=(long lSrc)
{
        if (vt == VT_I4)
                lVal = lSrc;
        else if (vt == VT_ERROR)
                scode = lSrc;
        else if (vt == VT_BOOL)
        {
                if (lSrc == FALSE)
                        V_BOOL(this) = AFX_OLE_FALSE;
                else
                        V_BOOL(this) = AFX_OLE_TRUE;
        }
        else
        {
                // Free up previous VARIANT
                Clear();
                vt = VT_I4;
                lVal = lSrc;
        }

        return *this;
}

/*
const COleVariant& COleVariant::operator=(const COleCurrency& curSrc)
{
        // Free up previous VARIANT if necessary
        if (vt != VT_CY)
        {
                Clear();
                vt = VT_CY;
        }

        cyVal = curSrc.m_cur;
        return *this;
}
*/
const COleVariant& COleVariant::operator=(float fltSrc)
{
        // Free up previous VARIANT if necessary
        if (vt != VT_R4)
        {
                Clear();
                vt = VT_R4;
        }

        fltVal = fltSrc;
        return *this;
}

const COleVariant& COleVariant::operator=(double dblSrc)
{
        // Free up previous VARIANT if necessary
        if (vt != VT_R8)
        {
                Clear();
                vt = VT_R8;
        }

        dblVal = dblSrc;
        return *this;
}

const COleVariant& COleVariant::operator=(const COleDateTime& dateSrc)
{
        // Free up previous VARIANT if necessary
        if (vt != VT_DATE)
        {
                Clear();
                vt = VT_DATE;
        }

        date = dateSrc.m_dt;
        return *this;
}
/*
const COleVariant& COleVariant::operator=(const CByteArray& arrSrc)
{
        int nSize = arrSrc.GetSize();

        // Set the correct type and make sure SafeArray can hold data
        CreateOneDimArray(*this, (DWORD)nSize);

        // Copy the data into the SafeArray
        CopyBinaryData(parray, arrSrc.GetData(), (DWORD)nSize);

        return *this;
}
const COleVariant& COleVariant::operator=(const CLongBinary& lbSrc)
{
        // Set the correct type and make sure SafeArray can hold data
        CreateOneDimArray(*this, lbSrc.m_dwDataLength);

        // Copy the data into the SafeArray
        BYTE* pData = (BYTE*)::GlobalLock(lbSrc.m_hData);
        CopyBinaryData(parray, pData, lbSrc.m_dwDataLength);
        ::GlobalUnlock(lbSrc.m_hData);

        return *this;
}
*/

void AFXAPI AfxVariantInit(LPVARIANT pVar)
{
        memset(pVar, 0, sizeof(*pVar));
}

/////////////////////////////////////////////////////////////////////////////
// Diagnostics

#ifdef _DEBUG
CDumpContext& AFXAPI operator <<(CDumpContext& dc, COleVariant varSrc)
{
        LPCVARIANT pSrc = (LPCVARIANT)varSrc;

        dc << "\nCOleVariant Object:";
        dc << "\n\t vt = " << pSrc->vt;

        // No support for VT_BYREF & VT_ARRAY
        if (pSrc->vt & VT_BYREF || pSrc->vt & VT_ARRAY)
                return dc;

        switch (pSrc->vt)
        {
        case VT_BOOL:
                return dc << "\n\t VT_BOOL = " << V_BOOL(pSrc);

        case VT_UI1:
                return dc << "\n\t bVal = " << pSrc->bVal;

        case VT_I2:
                return dc << "\n\t iVal = " << pSrc->iVal;

        case VT_I4:
                return dc << "\n\t lVal = " << pSrc->lVal;

        case VT_CY:
                {
                        COleVariant var(varSrc);
                        var.ChangeType(VT_BSTR);
                        return dc << "\n\t cyVal = " << (LPCTSTR)var.bstrVal;
                }

        case VT_R4:
                return dc << "\n\t fltVal = " << pSrc->fltVal;

        case VT_R8:
                return dc << "\n\t dblVal = " << pSrc->dblVal;

        case VT_DATE:
                {
                        COleVariant var(varSrc);
                        var.ChangeType(VT_BSTR);
                        return dc << "\n\t date = " << (LPCTSTR)var.bstrVal;
                }

        case VT_BSTR:
                return dc << "\n\t bstrVal = " << (LPCTSTR)pSrc->bstrVal;

        case VT_ERROR:
                return dc << "\n\t scode = " << pSrc->scode;

        case VT_DISPATCH:
        case VT_UNKNOWN:
                return dc << "\n\t punkVal = " << pSrc->punkVal;

        case VT_EMPTY:
        case VT_NULL:
                return dc;

        default:
                ASSERT(FALSE);
                return dc;
        }
}
#endif // _DEBUG


#ifdef _with_archive_
CArchive& AFXAPI operator<<(CArchive& ar, COleVariant varSrc)
{
        LPCVARIANT pSrc = (LPCVARIANT)varSrc;

        ar << pSrc->vt;

        // No support for VT_BYREF & VT_ARRAY
        if (pSrc->vt & VT_BYREF || pSrc->vt & VT_ARRAY)
                return ar;

        switch (pSrc->vt)
        {
        case VT_BOOL:
                return ar << (WORD)V_BOOL(pSrc);

        case VT_UI1:
                return ar << pSrc->bVal;

        case VT_I2:
                return ar << (WORD)pSrc->iVal;

        case VT_I4:
                return ar << pSrc->lVal;

        case VT_CY:
                ar << pSrc->cyVal.Lo;
                return ar << pSrc->cyVal.Hi;

        case VT_R4:
                return ar << pSrc->fltVal;

        case VT_R8:
                return ar << pSrc->dblVal;

        case VT_DATE:
                return ar << pSrc->date;

        case VT_BSTR:
                {
                        DWORD nLen = SysStringByteLen(pSrc->bstrVal);
                        ar << nLen;
                        if (nLen > 0)
                                ar.Write(pSrc->bstrVal, nLen * sizeof(BYTE));

                        return ar;
                }

        case VT_ERROR:
                return ar << pSrc->scode;

#ifdef _WITH_PUNK_
        case VT_DISPATCH:
        case VT_UNKNOWN:
                {
                        LPPERSISTSTREAM pPersistStream;
                        //BUGBUG
                        //CArchiveStream stm(&ar);

                        // QI for IPersistStream or IPeristStreamInit
                        SCODE sc = pSrc->punkVal->QueryInterface(
                                IID_IPersistStream, (void**)&pPersistStream);
//#ifndef _AFX_NO_OCC_SUPPORT
#ifdef _AFX_OCC_SUPPORT
                        if (FAILED(sc))
                                sc = pSrc->punkVal->QueryInterface(
                                        IID_IPersistStreamInit, (void**)&pPersistStream);
#endif
                        CheckError(sc);

                        TRY
                        {
                                // Get and archive the CLSID (GUID)
                                CLSID clsid;
                                CheckError(pPersistStream->GetClassID(&clsid));
                                ar << clsid.Data1;
                                ar << clsid.Data2;
                                ar << clsid.Data3;
                                ar.Write(&clsid.Data4[0], sizeof clsid.Data4);

                                // Always assume object is dirty
                                CheckError(pPersistStream->Save(&stm, TRUE));
                        }
                        CATCH_ALL(e)
                        {
                                pPersistStream->Release();
                                THROW_LAST();
                        }
                        END_CATCH_ALL
                        pPersistStream->Release();
                }
                return ar;
#endif //_WITH_PUNK_

        case VT_EMPTY:
        case VT_NULL:
                // do nothing
                return ar;

        default:
                ASSERT(FALSE);
                return ar;
        }
}

CArchive& AFXAPI operator>>(CArchive& ar, COleVariant& varSrc)
{
        LPVARIANT pSrc = &varSrc;

        // Free up current data if necessary
        if (pSrc->vt != VT_EMPTY)
                VariantClear(pSrc);
        ar >> pSrc->vt;

        // No support for VT_BYREF & VT_ARRAY
        if (pSrc->vt & VT_BYREF || pSrc->vt & VT_ARRAY)
                return ar;

        switch (pSrc->vt)
        {
        case VT_BOOL:
                return ar >> (WORD&)V_BOOL(pSrc);

        case VT_UI1:
                return ar >> pSrc->bVal;

        case VT_I2:
                return ar >> (WORD&)pSrc->iVal;

        case VT_I4:
                return ar >> pSrc->lVal;

        case VT_CY:
                ar >> pSrc->cyVal.Lo;
                return ar >> pSrc->cyVal.Hi;

        case VT_R4:
                return ar >> pSrc->fltVal;

        case VT_R8:
                return ar >> pSrc->dblVal;

        case VT_DATE:
                return ar >> pSrc->date;

        case VT_BSTR:
                {
                        DWORD nLen;
                        ar >> nLen;
                        if (nLen > 0)
                        {
                                pSrc->bstrVal = SysAllocStringByteLen(NULL, nLen);
                                //BUGBUG:
                                //if (pSrc->bstrVal == NULL)
                                //        AfxThrowMemoryException();

                                ar.Read(pSrc->bstrVal, nLen * sizeof(BYTE));
                        }
                        else
                                pSrc->bstrVal = NULL;

                        return ar;
                }
                break;

        case VT_ERROR:
                return ar >> pSrc->scode;

#ifdef _WITH_PUNK_
        case VT_DISPATCH:
        case VT_UNKNOWN:
                {
                        LPPERSISTSTREAM pPersistStream = NULL;
                        CArchiveStream stm(&ar);

                        // Retrieve the CLSID (GUID) and create an instance
                        CLSID clsid;
                        ar >> clsid.Data1;
                        ar >> clsid.Data2;
                        ar >> clsid.Data3;
                        ar.Read(&clsid.Data4[0], sizeof clsid.Data4);

                        // Create the object
                        SCODE sc = CoCreateInstance(clsid, NULL, CLSCTX_ALL | CLSCTX_REMOTE_SERVER,
                                pSrc->vt == VT_UNKNOWN ? IID_IUnknown : IID_IDispatch,
                                (void**)&pSrc->punkVal);
                        if (sc == E_INVALIDARG)
                        {
                                // may not support CLSCTX_REMOTE_SERVER, so try without
                                sc = CoCreateInstance(clsid, NULL,
                                        CLSCTX_ALL & ~CLSCTX_REMOTE_SERVER,
                                        pSrc->vt == VT_UNKNOWN ? IID_IUnknown : IID_IDispatch,
                                        (void**)&pSrc->punkVal);
                        }
                        CheckError(sc);

                        TRY
                        {
                                // QI for IPersistStream or IPeristStreamInit
                                sc = pSrc->punkVal->QueryInterface(
                                        IID_IPersistStream, (void**)&pPersistStream);
#ifndef _AFX_NO_OCC_SUPPORT
                                if (FAILED(sc))
                                        sc = pSrc->punkVal->QueryInterface(
                                                IID_IPersistStreamInit, (void**)&pPersistStream);
#endif
                                CheckError(sc);

                                // Always assumes object is dirty
                                CheckError(pPersistStream->Load(&stm));
                        }
                        CATCH_ALL(e)
                        {
                                // Clean up
                                if (pPersistStream != NULL)
                                        pPersistStream->Release();

                                pSrc->punkVal->Release();
                                THROW_LAST();
                        }
                        END_CATCH_ALL

                        pPersistStream->Release();
                }
                return ar;
#endif //_WITH_PUNK_

        case VT_EMPTY:
        case VT_NULL:
                // do nothing
                return ar;

        default:
                ASSERT(FALSE);
                return ar;
        }
}
#endif //_with_archive_

/////////////////////////////////////////////////////////////////////////////
// COleVariant Helpers

template<>
void AFXAPI ConstructElements(COleVariant* pElements, int nCount)
{
        ASSERT(nCount == 0 ||
                AfxIsValidAddress(pElements, nCount * sizeof(COleVariant)));

        for (; nCount--; ++pElements)
                new(pElements) COleVariant;
}

template<>
void AFXAPI DestructElements(COleVariant* pElements, int nCount)
{
        ASSERT(nCount == 0 ||
                AfxIsValidAddress(pElements, nCount * sizeof(COleVariant)));

        for (; nCount--; ++pElements)
                pElements->~COleVariant();
}

template<>
void AFXAPI CopyElements(COleVariant* pDest, const COleVariant* pSrc, int nCount)
{
        ASSERT(nCount == 0 ||
                AfxIsValidAddress(pDest, nCount * sizeof(COleVariant)));
        ASSERT(nCount == 0 ||
                AfxIsValidAddress(pSrc, nCount * sizeof(COleVariant)));

        for (; nCount--; ++pDest, ++pSrc)
                *pDest = *pSrc;
}

#ifdef _with_archive_
template<>
void AFXAPI SerializeElements(CArchive& ar, COleVariant* pElements, int nCount)
{
        ASSERT(nCount == 0 ||
                AfxIsValidAddress(pElements, nCount * sizeof(COleVariant)));

        if (ar.IsStoring())
        {
                for (; nCount--; ++pElements)
                        ar << *pElements;
        }
        else
        {
                for (; nCount--; ++pElements)
                        ar >> *pElements;
        }
}
#endif //_with_archive_

#ifdef _DEBUG
template<>
void AFXAPI DumpElements(CDumpContext& dc, COleVariant* pElements, int nCount)
{
        for (; nCount--; ++pElements)
                dc << *pElements;
}
#endif // _DEBUG

template<>
UINT AFXAPI HashKey(const struct tagVARIANT& var)
{
        switch (var.vt)
        {
        case VT_EMPTY:
        case VT_NULL:
                return 0;
        case VT_I2:
                return HashKey((DWORD)var.iVal);
        case VT_I4:
                return HashKey((DWORD)var.lVal);
        case VT_R4:
                return (UINT)(var.fltVal / 16);
        case VT_R8:
        case VT_CY:
                return (UINT)(var.dblVal / 16);
        case VT_BOOL:
                return HashKey((DWORD)V_BOOL(&var));
        case VT_ERROR:
                return HashKey((DWORD)var.scode);
        case VT_DATE:
                return (UINT)(var.date / 16);
        case VT_BSTR:
                return HashKey(var.bstrVal);
        case VT_DISPATCH:
        case VT_UNKNOWN:
                return HashKey((DWORD_PTR)var.punkVal);

        default:
                // No support for VT_BYREF & VT_ARRAY
                ASSERT(FALSE);

                // Fall through
        }

        return 0;
}

static void PASCAL CheckError(SCODE sc)
{
        if (FAILED(sc))
        {
            /*
            BUGBUG:
                if (sc == E_OUTOFMEMORY)
                        AfxThrowMemoryException();
                else
                        AfxThrowOleException(sc);
            */
        }
}
static BOOL PASCAL CompareSafeArrays(SAFEARRAY* parray1, SAFEARRAY* parray2)
{
    return FALSE;
}

#ifdef _CURRENCY_ALSO_
static BOOL PASCAL CompareSafeArrays(SAFEARRAY* parray1, SAFEARRAY* parray2)
{
        BOOL bCompare = FALSE;

        // If one is NULL they must both be NULL to compare
        if (parray1 == NULL || parray2 == NULL)
        {
                return parray1 == parray2;
        }

        // Dimension must match and if 0, then arrays compare
        DWORD dwDim1 = ::SafeArrayGetDim(parray1);
        DWORD dwDim2 = ::SafeArrayGetDim(parray2);
        if (dwDim1 != dwDim2)
                return FALSE;
        else if (dwDim1 == 0)
                return TRUE;

        // Element size must match
        DWORD dwSize1 = ::SafeArrayGetElemsize(parray1);
        DWORD dwSize2 = ::SafeArrayGetElemsize(parray2);
        if (dwSize1 != dwSize2)
                return FALSE;

        long* pLBound1 = NULL;
        long* pLBound2 = NULL;
        long* pUBound1 = NULL;
        long* pUBound2 = NULL;

        void* pData1 = NULL;
        void* pData2 = NULL;

        TRY
        {
                // Bounds must match
                pLBound1 = new long[dwDim1];
                pLBound2 = new long[dwDim2];
                pUBound1 = new long[dwDim1];
                pUBound2 = new long[dwDim2];

                size_t nTotalElements = 1;

                // Get and compare bounds
                for (DWORD dwIndex = 0; dwIndex < dwDim1; dwIndex++)
                {
                        CheckError(::SafeArrayGetLBound(
                                parray1, dwIndex+1, &pLBound1[dwIndex]));
                        CheckError(::SafeArrayGetLBound(
                                parray2, dwIndex+1, &pLBound2[dwIndex]));
                        CheckError(::SafeArrayGetUBound(
                                parray1, dwIndex+1, &pUBound1[dwIndex]));
                        CheckError(::SafeArrayGetUBound(
                                parray2, dwIndex+1, &pUBound2[dwIndex]));

                        // Check the magnitude of each bound
                        if (pUBound1[dwIndex] - pLBound1[dwIndex] !=
                                pUBound2[dwIndex] - pLBound2[dwIndex])
                        {
                                delete[] pLBound1;
                                delete[] pLBound2;
                                delete[] pUBound1;
                                delete[] pUBound2;

                                return FALSE;
                        }

                        // Increment the element count
                        nTotalElements *= pUBound1[dwIndex] - pLBound1[dwIndex] + 1;
                }

                // Access the data
                CheckError(::SafeArrayAccessData(parray1, &pData1));
                CheckError(::SafeArrayAccessData(parray2, &pData2));

                // Calculate the number of bytes of data and compare
                size_t nSize = nTotalElements * dwSize1;
                int nOffset = memcmp(pData1, pData2, nSize);
                bCompare = nOffset == 0;

                // Release the array locks
                CheckError(::SafeArrayUnaccessData(parray1));
                CheckError(::SafeArrayUnaccessData(parray2));
        }
        CATCH_ALL(e)
        {
                // Clean up bounds arrays
                delete[] pLBound1;
                delete[] pLBound2;
                delete[] pUBound1;
                delete[] pUBound2;

                // Release the array locks
                if (pData1 != NULL)
                        CheckError(::SafeArrayUnaccessData(parray1));
                if (pData2 != NULL)
                        CheckError(::SafeArrayUnaccessData(parray2));

                THROW_LAST();
        }
        END_CATCH_ALL

        // Clean up bounds arrays
        delete[] pLBound1;
        delete[] pLBound2;
        delete[] pUBound1;
        delete[] pUBound2;

        return bCompare;
}

static void PASCAL CreateOneDimArray(VARIANT& varSrc, DWORD dwSize)
{
        UINT nDim;

        // Clear VARIANT and re-create SafeArray if necessary
        if (varSrc.vt != (VT_UI1 | VT_ARRAY) ||
                (nDim = ::SafeArrayGetDim(varSrc.parray)) != 1)
        {
                VERIFY(::VariantClear(&varSrc) == NOERROR);
                varSrc.vt = VT_UI1 | VT_ARRAY;

                SAFEARRAYBOUND bound;
                bound.cElements = dwSize;
                bound.lLbound = 0;
                varSrc.parray = ::SafeArrayCreate(VT_UI1, 1, &bound);
                if (varSrc.parray == NULL)
                        AfxThrowMemoryException();
        }
        else
        {
                // Must redimension array if necessary
                long lLower, lUpper;
                CheckError(::SafeArrayGetLBound(varSrc.parray, 1, &lLower));
                CheckError(::SafeArrayGetUBound(varSrc.parray, 1, &lUpper));

                // Upper bound should always be greater than lower bound
                long lSize = lUpper - lLower;
                if (lSize < 0)
                {
                        ASSERT(FALSE);
                        lSize = 0;

                }

                if ((DWORD)lSize != dwSize)
                {
                        SAFEARRAYBOUND bound;
                        bound.cElements = dwSize;
                        bound.lLbound = lLower;
                        CheckError(::SafeArrayRedim(varSrc.parray, &bound));
                }
        }
}

static void PASCAL CopyBinaryData(SAFEARRAY* parray, const void* pvSrc, DWORD dwSize)
{
        // Access the data, copy it and unaccess it.
        void* pDest;
        CheckError(::SafeArrayAccessData(parray, &pDest));
        memcpy(pDest, pvSrc, dwSize);
        CheckError(::SafeArrayUnaccessData(parray));
}

/////////////////////////////////////////////////////////////////////////////
// COleCurrency class helpers

// Return the highest order bit composing dwTarget in wBit
#define HI_BIT(dwTarget, wBit) \
        do \
        { \
                if (dwTarget != 0) \
                        for (wBit = 32; (dwTarget & (0x00000001 << wBit-1)) == 0; wBit--);\
                else \
                        wBit = 0; \
        } while (0)

// Left shift an (assumed unsigned) currency by wBits
#define LSHIFT_UCUR(cur, wBits) \
        do \
        { \
                for (WORD wTempBits = wBits; wTempBits > 0; wTempBits--) \
                { \
                        cur.m_cur.Hi = ((DWORD)cur.m_cur.Hi << 1); \
                        cur.m_cur.Hi |= (cur.m_cur.Lo & 0x80000000) >> 31; \
                        cur.m_cur.Lo = cur.m_cur.Lo << 1; \
                } \
        } while (0)

// Right shift an (assumed unsigned) currency by wBits
#define RSHIFT_UCUR(cur, wBits) \
        do \
        { \
                for (WORD wTempBits = wBits; wTempBits > 0; wTempBits--) \
                { \
                        cur.m_cur.Lo = cur.m_cur.Lo >> 1; \
                        cur.m_cur.Lo |= (cur.m_cur.Hi & 0x00000001) << 31; \
                        cur.m_cur.Hi = ((DWORD)cur.m_cur.Hi >> 1); \
                } \
        } while (0)

/////////////////////////////////////////////////////////////////////////////
// COleCurrency class (internally currency is 8-byte int scaled by 10,000)

COleCurrency::COleCurrency(long nUnits, long nFractionalUnits)
{
        SetCurrency(nUnits, nFractionalUnits);
        SetStatus(valid);
}

const COleCurrency& COleCurrency::operator=(CURRENCY cySrc)
{
        m_cur = cySrc;
        SetStatus(valid);
        return *this;
}

const COleCurrency& COleCurrency::operator=(const COleCurrency& curSrc)
{
        m_cur = curSrc.m_cur;
        m_status = curSrc.m_status;
        return *this;
}

const COleCurrency& COleCurrency::operator=(const VARIANT& varSrc)
{
        if (varSrc.vt != VT_CY)
        {
                TRY
                {
                        COleVariant varTemp(varSrc);
                        varTemp.ChangeType(VT_CY);
                        m_cur = varTemp.cyVal;
                        SetStatus(valid);
                }
                // Catch COleException from ChangeType, but not CMemoryException
                CATCH(COleException, e)
                {
                        // Not able to convert VARIANT to CURRENCY
                        m_cur.Hi = 0;
                        m_cur.Lo = 0;
                        SetStatus(invalid);
                        DELETE_EXCEPTION(e);
                }
                END_CATCH
        }
        else
        {
                m_cur = varSrc.cyVal;
                SetStatus(valid);
        }

        return *this;
}

BOOL COleCurrency::operator<(const COleCurrency& cur) const
{
        ASSERT(GetStatus() == valid);
        ASSERT(cur.GetStatus() == valid);

        return((m_cur.Hi == cur.m_cur.Hi) ?
                (m_cur.Lo < cur.m_cur.Lo) : (m_cur.Hi < cur.m_cur.Hi));
}

BOOL COleCurrency::operator>(const COleCurrency& cur) const
{
        ASSERT(GetStatus() == valid);
        ASSERT(cur.GetStatus() == valid);

        return((m_cur.Hi == cur.m_cur.Hi) ?
                (m_cur.Lo > cur.m_cur.Lo) : (m_cur.Hi > cur.m_cur.Hi));
}

BOOL COleCurrency::operator<=(const COleCurrency& cur) const
{
        ASSERT(GetStatus() == valid);
        ASSERT(cur.GetStatus() == valid);

        return((m_cur.Hi == cur.m_cur.Hi) ?
                (m_cur.Lo <= cur.m_cur.Lo) : (m_cur.Hi < cur.m_cur.Hi));
}

BOOL COleCurrency::operator>=(const COleCurrency& cur) const
{
        ASSERT(GetStatus() == valid);
        ASSERT(cur.GetStatus() == valid);

        return((m_cur.Hi == cur.m_cur.Hi) ?
                (m_cur.Lo >= cur.m_cur.Lo) : (m_cur.Hi > cur.m_cur.Hi));
}

COleCurrency COleCurrency::operator+(const COleCurrency& cur) const
{
        COleCurrency curResult;

        // If either operand Null, result Null
        if (GetStatus() == null || cur.GetStatus() == null)
        {
                curResult.SetStatus(null);
                return curResult;
        }

        // If either operand Invalid, result Invalid
        if (GetStatus() == invalid || cur.GetStatus() == invalid)
        {
                curResult.SetStatus(invalid);
                return curResult;
        }

        // Add separate CURRENCY components
        curResult.m_cur.Hi = m_cur.Hi + cur.m_cur.Hi;
        curResult.m_cur.Lo = m_cur.Lo + cur.m_cur.Lo;

        // Increment Hi if Lo overflows
        if (m_cur.Lo > curResult.m_cur.Lo)
                curResult.m_cur.Hi++;

        // Overflow if operands same sign and result sign different
        if (!((m_cur.Hi ^ cur.m_cur.Hi) & 0x80000000) &&
                ((m_cur.Hi ^ curResult.m_cur.Hi) & 0x80000000))
        {
                curResult.SetStatus(invalid);
        }

        return curResult;
}

COleCurrency COleCurrency::operator-(const COleCurrency& cur) const
{
        COleCurrency curResult;

        // If either operand Null, result Null
        if (GetStatus() == null || cur.GetStatus() == null)
        {
                curResult.SetStatus(null);
                return curResult;
        }

        // If either operand Invalid, result Invalid
        if (GetStatus() == invalid || cur.GetStatus() == invalid)
        {
                curResult.SetStatus(invalid);
                return curResult;
        }

        // Subtract separate CURRENCY components
        curResult.m_cur.Hi = m_cur.Hi - cur.m_cur.Hi;
        curResult.m_cur.Lo = m_cur.Lo - cur.m_cur.Lo;

        // Decrement Hi if Lo overflows
        if (m_cur.Lo < curResult.m_cur.Lo)
                curResult.m_cur.Hi--;

        // Overflow if operands not same sign and result not same sign
        if (((m_cur.Hi ^ cur.m_cur.Hi) & 0x80000000) &&
                ((m_cur.Hi ^ curResult.m_cur.Hi) & 0x80000000))
        {
                curResult.SetStatus(invalid);
        }

        return curResult;
}

COleCurrency COleCurrency::operator-() const
{
        // If operand not Valid, just return
        if (!GetStatus() == valid)
                return *this;

        COleCurrency curResult;

        // Negating MIN_CURRENCY,will set invalid
        if (m_cur.Hi == 0x80000000 && m_cur.Lo == 0x00000000)
        {
                curResult.SetStatus(invalid);
        }

        curResult.m_cur.Hi = ~m_cur.Hi;
        curResult.m_cur.Lo = -(long)m_cur.Lo;

        // If cy was -1 make sure Hi correctly set
        if (curResult.m_cur.Lo == 0)
                curResult.m_cur.Hi++;

        return curResult;
}

COleCurrency COleCurrency::operator*(long nOperand) const
{
        // If operand not Valid, just return
        if (!GetStatus() == valid)
                return *this;

        COleCurrency curResult(m_cur);
        DWORD nTempOp;

        // Return now if one operand is 0 (optimization)
        if ((m_cur.Hi == 0x00000000 && m_cur.Lo == 0x00000000) || nOperand == 0)
        {
                curResult.m_cur.Hi = 0;
                curResult.m_cur.Lo = 0;
                return curResult;
        }

        // Handle only valid case of multiplying MIN_CURRENCY
        if (m_cur.Hi == 0x80000000 && m_cur.Lo == 0x00000000 && nOperand == 1)
                return curResult;

        // Compute absolute values.
        if (m_cur.Hi < 0)
                curResult = -curResult;

        nTempOp = labs(nOperand);

        // Check for overflow
        if (curResult.m_cur.Hi != 0)
        {
                WORD wHiBitCur, wHiBitOp;
                HI_BIT(curResult.m_cur.Hi, wHiBitCur);
                HI_BIT(nTempOp, wHiBitOp);

                // 63-bit limit on result. (n bits)*(m bits) = (n+m-1) bits.
                if (wHiBitCur + wHiBitOp - 1 > 63)
                {
                        // Overflow!
                        curResult.SetStatus(invalid);

                        // Set to maximum negative value
                        curResult.m_cur.Hi = 0x80000000;
                        curResult.m_cur.Lo = 0x00000000;

                        return curResult;
                }
        }

        // Break up into WORDs
        WORD wCy4, wCy3, wCy2, wCy1, wL2, wL1;

        wCy4 = HIWORD(curResult.m_cur.Hi);
        wCy3 = LOWORD(curResult.m_cur.Hi);
        wCy2 = HIWORD(curResult.m_cur.Lo);
        wCy1 = LOWORD(curResult.m_cur.Lo);

        wL2 = HIWORD(nTempOp);
        wL1 = LOWORD(nTempOp);

        // Multiply each set of WORDs
        DWORD dwRes11, dwRes12, dwRes21, dwRes22;
        DWORD dwRes31, dwRes32, dwRes41;  // Don't need dwRes42

        dwRes11 = wCy1 * wL1;
        dwRes12 = wCy1 * wL2;
        dwRes21 = wCy2 * wL1;
        dwRes22 = wCy2 * wL2;

        dwRes31 = wCy3 * wL1;
        dwRes32 = wCy3 * wL2;
        dwRes41 = wCy4 * wL1;

        // Add up low order pieces
        dwRes11 += dwRes12<<16;
        curResult.m_cur.Lo = dwRes11 + (dwRes21<<16);

        // Check if carry required
        if (dwRes11 < dwRes12<<16 || (DWORD)curResult.m_cur.Lo < dwRes11)
                curResult.m_cur.Hi = 1;
        else
                curResult.m_cur.Hi = 0;

        // Add up the high order pieces
        curResult.m_cur.Hi += dwRes31 + (dwRes32<<16) + (dwRes41<<16) +
                dwRes22 + (dwRes12>>16) + (dwRes21>>16);

        // Compute result sign
        if ((m_cur.Hi ^ nOperand) & 0x80000000)
                curResult = -curResult;

        return curResult;
}

COleCurrency COleCurrency::operator/(long nOperand) const
{
        // If operand not Valid, just return
        if (!GetStatus() == valid)
                return *this;

        COleCurrency curTemp(m_cur);
        DWORD nTempOp;

        // Check for divide by 0
        if (nOperand == 0)
        {
                curTemp.SetStatus(invalid);

                // Set to maximum negative value
                curTemp.m_cur.Hi = 0x80000000;
                curTemp.m_cur.Lo = 0x00000000;

                return curTemp;
        }

        // Compute absolute values
        if (curTemp.m_cur.Hi < 0)
                curTemp = -curTemp;

        nTempOp = labs(nOperand);

        // Optimization - division is simple if Hi == 0
        if (curTemp.m_cur.Hi == 0x0000)
        {
                curTemp.m_cur.Lo = m_cur.Lo / nTempOp;

                // Compute result sign
                if ((m_cur.Hi ^ nOperand) & 0x80000000)
                        curTemp = -curTemp;

                return curTemp;
        }

        // Now curTemp represents remainder
        COleCurrency curResult; // Initializes to zero
        COleCurrency curTempResult;
        COleCurrency curOperand;

        curOperand.m_cur.Lo = nTempOp;

        WORD wHiBitRem;
        WORD wScaleOp;

        // Quit if remainder can be truncated
        while (curTemp >= curOperand)
        {
                // Scale up and divide Hi portion
                HI_BIT(curTemp.m_cur.Hi, wHiBitRem);

                if (wHiBitRem != 0)
                        wHiBitRem += 32;
                else
                        HI_BIT(curTemp.m_cur.Lo, wHiBitRem);

                WORD wShift = (WORD)(64 - wHiBitRem);
                LSHIFT_UCUR(curTemp, wShift);

                // If Operand bigger than Hi it must be scaled
                wScaleOp = (WORD)((nTempOp > (DWORD)curTemp.m_cur.Hi) ? 1 : 0);

                // Perform synthetic division
                curTempResult.m_cur.Hi =
                        (DWORD)curTemp.m_cur.Hi / (nTempOp >> wScaleOp);

                // Scale back to get correct result and remainder
                RSHIFT_UCUR(curTemp, wShift);
                wShift = (WORD)(wShift - wScaleOp);
                RSHIFT_UCUR(curTempResult, wShift);

                // Now calculate result and remainder
                curResult += curTempResult;
                curTemp -= curTempResult * nTempOp;
        }

        // Compute result sign
        if ((m_cur.Hi ^ nOperand) & 0x80000000)
                curResult = -curResult;

        return curResult;
}

void COleCurrency::SetCurrency(long nUnits, long nFractionalUnits)
{
        COleCurrency curUnits;              // Initializes to 0
        COleCurrency curFractionalUnits;    // Initializes to 0

        // Set temp currency value to Units (need to multiply by 10,000)
        curUnits.m_cur.Lo = (DWORD)labs(nUnits);
        curUnits = curUnits * 10000;
        if (nUnits < 0)
                curUnits = -curUnits;

        curFractionalUnits.m_cur.Lo = (DWORD)labs(nFractionalUnits);
        if (nFractionalUnits < 0)
                curFractionalUnits = -curFractionalUnits;

        // Now add together Units and FractionalUnits
        *this = curUnits + curFractionalUnits;

        SetStatus(valid);
}

BOOL COleCurrency::ParseCurrency(LPCTSTR lpszCurrency,
        DWORD dwFlags,  LCID lcid)
{
        USES_CONVERSION;
        CString strCurrency = lpszCurrency;

        SCODE sc;
        if ( FAILED(sc = VarCyFromStr((LPOLESTR)T2COLE(strCurrency),
                lcid, dwFlags, &m_cur)))
        {
                if (sc == DISP_E_TYPEMISMATCH)
                {
                        // Can't convert string to CURRENCY, set 0 & invalid
                        m_cur.Hi = 0x00000000;
                        m_cur.Lo = 0x00000000;
                        SetStatus(invalid);
                        return FALSE;
                }
                else if (sc == DISP_E_OVERFLOW)
                {
                        // Can't convert string to CURRENCY, set max neg & invalid
                        m_cur.Hi = 0x80000000;
                        m_cur.Lo = 0x00000000;
                        SetStatus(invalid);
                        return FALSE;
                }
                else
                {
                        TRACE0("\nCOleCurrency VarCyFromStr call failed.\n\t");
                        if (sc == E_OUTOFMEMORY)
                                AfxThrowMemoryException();
                        else
                                AfxThrowOleException(sc);
                }
        }

        SetStatus(valid);
        return TRUE;
}

CString COleCurrency::Format(DWORD dwFlags, LCID lcid) const
{
        USES_CONVERSION;
        CString strCur;

        // If null, return empty string
        if (GetStatus() == null)
                return strCur;

        // If invalid, return Currency resource string
        if (GetStatus() == invalid)
        {
                VERIFY(strCur.LoadString(AFX_IDS_INVALID_CURRENCY));
                return strCur;
        }

        COleVariant var;
        // Don't need to trap error. Should not fail due to type mismatch
        CheckError(VarBstrFromCy(m_cur, lcid, dwFlags, &V_BSTR(&var)));
        var.vt = VT_BSTR;
        return OLE2CT(V_BSTR(&var));
}


// serialization
#ifdef _DEBUG
CDumpContext& AFXAPI operator<<(CDumpContext& dc, COleCurrency curSrc)
{
        dc << "\nCOleCurrency Object:";
        dc << "\n\tm_status = " << (long)curSrc.m_status;

        COleVariant var(curSrc);
        var.ChangeType(VT_CY);
        return dc << "\n\tCurrency = " << (LPCTSTR)var.bstrVal;
}
#endif // _DEBUG

#ifdef _with_archive_
CArchive& AFXAPI operator<<(CArchive& ar, COleCurrency curSrc)
{
        ar << (long)curSrc.m_status;
        ar << curSrc.m_cur.Hi;
        return ar << curSrc.m_cur.Lo;
}

CArchive& AFXAPI operator>>(CArchive& ar, COleCurrency& curSrc)
{
        ar >> (long&)curSrc.m_status;
        ar >> curSrc.m_cur.Hi;
        return ar >> curSrc.m_cur.Lo;
}
#endif //_with_archive_


/////////////////////////////////////////////////////////////////////////////
// COleDateTime class HELPER definitions

// Verifies will fail if the needed buffer size is too large
#define MAX_TIME_BUFFER_SIZE    128         // matches that in timecore.cpp
#define MIN_DATE                (-657434L)  // about year 100
#define MAX_DATE                2958465L    // about year 9999

// Half a second, expressed in days
#define HALF_SECOND  (1.0/172800.0)

// One-based array of days in year at month start
static int rgMonthDays[13] =
        {0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365};

static BOOL OleDateFromTm(WORD wYear, WORD wMonth, WORD wDay,
        WORD wHour, WORD wMinute, WORD wSecond, DATE& dtDest);
static BOOL TmFromOleDate(DATE dtSrc, struct tm& tmDest);
static void TmConvertToStandardFormat(struct tm& tmSrc);
static double DoubleFromDate(DATE dt);
static DATE DateFromDouble(double dbl);

/////////////////////////////////////////////////////////////////////////////
// COleDateTime class

COleDateTime PASCAL COleDateTime::GetCurrentTime()
{
        return COleDateTime(::time(NULL));
}

int COleDateTime::GetYear() const
{
        struct tm tmTemp;

        if (GetStatus() == valid && TmFromOleDate(m_dt, tmTemp))
                return tmTemp.tm_year;
        else
                return AFX_OLE_DATETIME_ERROR;
}

int COleDateTime::GetMonth() const
{
        struct tm tmTemp;

        if (GetStatus() == valid && TmFromOleDate(m_dt, tmTemp))
                return tmTemp.tm_mon;
        else
                return AFX_OLE_DATETIME_ERROR;
}

int COleDateTime::GetDay() const
{
        struct tm tmTemp;

        if (GetStatus() == valid && TmFromOleDate(m_dt, tmTemp))
                return tmTemp.tm_mday;
        else
                return AFX_OLE_DATETIME_ERROR;
}

int COleDateTime::GetHour() const
{
        struct tm tmTemp;

        if (GetStatus() == valid && TmFromOleDate(m_dt, tmTemp))
                return tmTemp.tm_hour;
        else
                return AFX_OLE_DATETIME_ERROR;
}

int COleDateTime::GetMinute() const
{
        struct tm tmTemp;

        if (GetStatus() == valid && TmFromOleDate(m_dt, tmTemp))
                return tmTemp.tm_min;
        else
                return AFX_OLE_DATETIME_ERROR;
}

int COleDateTime::GetSecond() const
{
        struct tm tmTemp;

        if (GetStatus() == valid && TmFromOleDate(m_dt, tmTemp))
                return tmTemp.tm_sec;
        else
                return AFX_OLE_DATETIME_ERROR;
}

int COleDateTime::GetDayOfWeek() const
{
        struct tm tmTemp;

        if (GetStatus() == valid && TmFromOleDate(m_dt, tmTemp))
                return tmTemp.tm_wday;
        else
                return AFX_OLE_DATETIME_ERROR;
}

int COleDateTime::GetDayOfYear() const
{
        struct tm tmTemp;

        if (GetStatus() == valid && TmFromOleDate(m_dt, tmTemp))
                return tmTemp.tm_yday;
        else
                return AFX_OLE_DATETIME_ERROR;
}

const COleDateTime& COleDateTime::operator=(const VARIANT& varSrc)
{
        if (varSrc.vt != VT_DATE)
        {
                TRY
                {
                        COleVariant varTemp(varSrc);
                        varTemp.ChangeType(VT_DATE);
                        m_dt = varTemp.date;
                        SetStatus(valid);
                }
                // Catch COleException from ChangeType, but not CMemoryException
                CATCH(COleException, e)
                {
                        // Not able to convert VARIANT to DATE
                        DELETE_EXCEPTION(e);
                        m_dt = 0;
                        SetStatus(invalid);
                }
                END_CATCH
        }
        else
        {
                m_dt = varSrc.date;
                SetStatus(valid);
        }

        return *this;
}

const COleDateTime& COleDateTime::operator=(DATE dtSrc)
{
        m_dt = dtSrc;
        SetStatus(valid);

        return *this;
}

const COleDateTime& COleDateTime::operator=(const time_t& timeSrc)
{
        // Convert time_t to struct tm
        tm *ptm = localtime(&timeSrc);

        if (ptm != NULL)
        {
                m_status = OleDateFromTm((WORD)ptm->tm_year + 1900,
                        (WORD)(ptm->tm_mon + 1), (WORD)ptm->tm_mday,
                        (WORD)ptm->tm_hour, (WORD)ptm->tm_min,
                        (WORD)ptm->tm_sec, m_dt) ? valid : invalid;
        }
        else
        {
                // Local time must have failed (timsSrc before 1/1/70 12am)
                SetStatus(invalid);
                ASSERT(FALSE);
        }

        return *this;
}

const COleDateTime& COleDateTime::operator=(const SYSTEMTIME& systimeSrc)
{
        m_status = OleDateFromTm(systimeSrc.wYear, systimeSrc.wMonth,
                systimeSrc.wDay, systimeSrc.wHour, systimeSrc.wMinute,
                systimeSrc.wSecond, m_dt) ? valid : invalid;

        return *this;
}

const COleDateTime& COleDateTime::operator=(const FILETIME& filetimeSrc)
{
        // Assume UTC FILETIME, so convert to LOCALTIME
        FILETIME filetimeLocal;
        if (!FileTimeToLocalFileTime( &filetimeSrc, &filetimeLocal))
        {
#ifdef _DEBUG
                DWORD dwError = GetLastError();
                TRACE1("\nFileTimeToLocalFileTime failed. Error = %lu.\n\t", dwError);
#endif // _DEBUG
                m_status = invalid;
        }
        else
        {
                // Take advantage of SYSTEMTIME -> FILETIME conversion
                SYSTEMTIME systime;
                m_status = FileTimeToSystemTime(&filetimeLocal, &systime) ?
                        valid : invalid;

                // At this point systime should always be valid, but...
                if (GetStatus() == valid)
                {
                        m_status = OleDateFromTm(systime.wYear, systime.wMonth,
                                systime.wDay, systime.wHour, systime.wMinute,
                                systime.wSecond, m_dt) ? valid : invalid;
                }
        }

        return *this;
}

BOOL COleDateTime::operator<(const COleDateTime& date) const
{
        ASSERT(GetStatus() == valid);
        ASSERT(date.GetStatus() == valid);

        // Handle negative dates
        return DoubleFromDate(m_dt) < DoubleFromDate(date.m_dt);
}

BOOL COleDateTime::operator>(const COleDateTime& date) const
{   ASSERT(GetStatus() == valid);
        ASSERT(date.GetStatus() == valid);

        // Handle negative dates
        return DoubleFromDate(m_dt) > DoubleFromDate(date.m_dt);
}

BOOL COleDateTime::operator<=(const COleDateTime& date) const
{
        ASSERT(GetStatus() == valid);
        ASSERT(date.GetStatus() == valid);

        // Handle negative dates
        return DoubleFromDate(m_dt) <= DoubleFromDate(date.m_dt);
}

BOOL COleDateTime::operator>=(const COleDateTime& date) const
{
        ASSERT(GetStatus() == valid);
        ASSERT(date.GetStatus() == valid);

        // Handle negative dates
        return DoubleFromDate(m_dt) >= DoubleFromDate(date.m_dt);
}

COleDateTime COleDateTime::operator+(const COleDateTimeSpan& dateSpan) const
{
        COleDateTime dateResult;    // Initializes m_status to valid

        // If either operand NULL, result NULL
        if (GetStatus() == null || dateSpan.GetStatus() == null)
        {
                dateResult.SetStatus(null);
                return dateResult;
        }

        // If either operand invalid, result invalid
        if (GetStatus() == invalid || dateSpan.GetStatus() == invalid)
        {
                dateResult.SetStatus(invalid);
                return dateResult;
        }

        // Compute the actual date difference by adding underlying dates
        dateResult = DateFromDouble(DoubleFromDate(m_dt) + dateSpan.m_span);

        // Validate within range
        dateResult.CheckRange();

        return dateResult;
}

COleDateTime COleDateTime::operator-(const COleDateTimeSpan& dateSpan) const
{
        COleDateTime dateResult;    // Initializes m_status to valid

        // If either operand NULL, result NULL
        if (GetStatus() == null || dateSpan.GetStatus() == null)
        {
                dateResult.SetStatus(null);
                return dateResult;
        }

        // If either operand invalid, result invalid
        if (GetStatus() == invalid || dateSpan.GetStatus() == invalid)
        {
                dateResult.SetStatus(invalid);
                return dateResult;
        }

        // Compute the actual date difference by subtracting underlying dates
        dateResult = DateFromDouble(DoubleFromDate(m_dt) - dateSpan.m_span);

        // Validate within range
        dateResult.CheckRange();

        return dateResult;
}

COleDateTimeSpan COleDateTime::operator-(const COleDateTime& date) const
{
        COleDateTimeSpan spanResult;

        // If either operand NULL, result NULL
        if (GetStatus() == null || date.GetStatus() == null)
        {
                spanResult.SetStatus(COleDateTimeSpan::null);
                return spanResult;
        }

        // If either operand invalid, result invalid
        if (GetStatus() == invalid || date.GetStatus() == invalid)
        {
                spanResult.SetStatus(COleDateTimeSpan::invalid);
                return spanResult;
        }

        // Return result (span can't be invalid, so don't check range)
        return DoubleFromDate(m_dt) - DoubleFromDate(date.m_dt);
}

BOOL COleDateTime::SetDateTime(int nYear, int nMonth, int nDay,
        int nHour, int nMin, int nSec)
{
        return m_status = OleDateFromTm((WORD)nYear, (WORD)nMonth,
                (WORD)nDay, (WORD)nHour, (WORD)nMin, (WORD)nSec, m_dt) ?
                valid : invalid;
}

BOOL COleDateTime::ParseDateTime(LPCTSTR lpszDate, DWORD dwFlags, LCID lcid)
{
        USES_CONVERSION;
        CString strDate = lpszDate;

        SCODE sc;
        if (FAILED(sc = VarDateFromStr((LPOLESTR)T2COLE(strDate), lcid,
                dwFlags, &m_dt)))
        {
                if (sc == DISP_E_TYPEMISMATCH)
                {
                        // Can't convert string to date, set 0 and invalidate
                        m_dt = 0;
                        SetStatus(invalid);
                        return FALSE;
                }
                else if (sc == DISP_E_OVERFLOW)
                {
                        // Can't convert string to date, set -1 and invalidate
                        m_dt = -1;
                        SetStatus(invalid);
                        return FALSE;
                }
                else
                {
                        TRACE0("\nCOleDateTime VarDateFromStr call failed.\n\t");
                        if (sc == E_OUTOFMEMORY)
                                AfxThrowMemoryException();
                        else
                                AfxThrowOleException(sc);
                }
        }

        SetStatus(valid);
        return TRUE;
}

CString COleDateTime::Format(DWORD dwFlags, LCID lcid) const
{
        USES_CONVERSION;
        CString strDate;

        // If null, return empty string
        if (GetStatus() == null)
                return strDate;

        // If invalid, return DateTime resource string
        if (GetStatus() == invalid)
        {
                VERIFY(strDate.LoadString(AFX_IDS_INVALID_DATETIME));
                return strDate;
        }

        COleVariant var;
        // Don't need to trap error. Should not fail due to type mismatch
        CheckError(VarBstrFromDate(m_dt, lcid, dwFlags, &V_BSTR(&var)));
        var.vt = VT_BSTR;
        return OLE2CT(V_BSTR(&var));
}

CString COleDateTime::Format(LPCTSTR pFormat) const
{
        CString strDate;
        struct tm tmTemp;

        // If null, return empty string
        if (GetStatus() == null)
                return strDate;

        // If invalid, return DateTime resource string
        if (GetStatus() == invalid || !TmFromOleDate(m_dt, tmTemp))
        {
                VERIFY(strDate.LoadString(AFX_IDS_INVALID_DATETIME));
                return strDate;
        }

        // Convert tm from afx internal format to standard format
        TmConvertToStandardFormat(tmTemp);

        // Fill in the buffer, disregard return value as it's not necessary
        LPTSTR lpszTemp = strDate.GetBufferSetLength(MAX_TIME_BUFFER_SIZE);
        _tcsftime(lpszTemp, strDate.GetLength(), pFormat, &tmTemp);
        strDate.ReleaseBuffer();

        return strDate;
}

CString COleDateTime::Format(UINT nFormatID) const
{
        CString strFormat;
        VERIFY(strFormat.LoadString(nFormatID) != 0);
        return Format(strFormat);
}

void COleDateTime::CheckRange()
{
        if (m_dt > MAX_DATE || m_dt < MIN_DATE) // about year 100 to about 9999
                SetStatus(invalid);
}

// serialization
#ifdef _DEBUG
CDumpContext& AFXAPI operator<<(CDumpContext& dc, COleDateTime dateSrc)
{
        dc << "\nCOleDateTime Object:";
        dc << "\n\tm_status = " << (long)dateSrc.m_status;

        COleVariant var(dateSrc);
        var.ChangeType(VT_BSTR);

        return dc << "\n\tdate = " << (LPCTSTR)var.bstrVal;
}
#endif // _DEBUG

#ifdef _with_archive_
CArchive& AFXAPI operator<<(CArchive& ar, COleDateTime dateSrc)
{
        ar << (long)dateSrc.m_status;
        return ar << dateSrc.m_dt;
}

CArchive& AFXAPI operator>>(CArchive& ar, COleDateTime& dateSrc)
{
        ar >> (long&)dateSrc.m_status;
        return ar >> dateSrc.m_dt;
}
#endif //_with_archive_

/////////////////////////////////////////////////////////////////////////////
// COleDateTimeSpan class helpers

#define MAX_DAYS_IN_SPAN    3615897L

/////////////////////////////////////////////////////////////////////////////
// COleDateTimeSpan class
long COleDateTimeSpan::GetHours() const
{
        ASSERT(GetStatus() == valid);

        double dblTemp;

        // Truncate days and scale up
        dblTemp = modf(m_span, &dblTemp);
        return (long)(dblTemp * 24);
}

long COleDateTimeSpan::GetMinutes() const
{
        ASSERT(GetStatus() == valid);

        double dblTemp;

        // Truncate hours and scale up
        dblTemp = modf(m_span * 24, &dblTemp);
        return (long)(dblTemp * 60);
}

long COleDateTimeSpan::GetSeconds() const
{
        ASSERT(GetStatus() == valid);

        double dblTemp;

        // Truncate minutes and scale up
        dblTemp = modf(m_span * 24 * 60, &dblTemp);
        return (long)(dblTemp * 60);
}

const COleDateTimeSpan& COleDateTimeSpan::operator=(double dblSpanSrc)
{
        m_span = dblSpanSrc;
        SetStatus(valid);
        return *this;
}

const COleDateTimeSpan& COleDateTimeSpan::operator=(const COleDateTimeSpan& dateSpanSrc)
{
        m_span = dateSpanSrc.m_span;
        m_status = dateSpanSrc.m_status;
        return *this;
}

COleDateTimeSpan COleDateTimeSpan::operator+(const COleDateTimeSpan& dateSpan) const
{
        COleDateTimeSpan dateSpanTemp;

        // If either operand Null, result Null
        if (GetStatus() == null || dateSpan.GetStatus() == null)
        {
                dateSpanTemp.SetStatus(null);
                return dateSpanTemp;
        }

        // If either operand Invalid, result Invalid
        if (GetStatus() == invalid || dateSpan.GetStatus() == invalid)
        {
                dateSpanTemp.SetStatus(invalid);
                return dateSpanTemp;
        }

        // Add spans and validate within legal range
        dateSpanTemp.m_span = m_span + dateSpan.m_span;
        dateSpanTemp.CheckRange();

        return dateSpanTemp;
}

COleDateTimeSpan COleDateTimeSpan::operator-(const COleDateTimeSpan& dateSpan) const
{
        COleDateTimeSpan dateSpanTemp;

        // If either operand Null, result Null
        if (GetStatus() == null || dateSpan.GetStatus() == null)
        {
                dateSpanTemp.SetStatus(null);
                return dateSpanTemp;
        }

        // If either operand Invalid, result Invalid
        if (GetStatus() == invalid || dateSpan.GetStatus() == invalid)
        {
                dateSpanTemp.SetStatus(invalid);
                return dateSpanTemp;
        }

        // Subtract spans and validate within legal range
        dateSpanTemp.m_span = m_span - dateSpan.m_span;
        dateSpanTemp.CheckRange();

        return dateSpanTemp;
}

void COleDateTimeSpan::SetDateTimeSpan(
        long lDays, int nHours, int nMins, int nSecs)
{
        // Set date span by breaking into fractional days (all input ranges valid)
        m_span = lDays + ((double)nHours)/24 + ((double)nMins)/(24*60) +
                ((double)nSecs)/(24*60*60);

        SetStatus(valid);
}

CString COleDateTimeSpan::Format(LPCTSTR pFormat) const
{
        CString strSpan;
        struct tm tmTemp;

        // If null, return empty string
        if (GetStatus() == null)
                return strSpan;

        // If invalid, return DateTimeSpan resource string
        if (GetStatus() == invalid || !TmFromOleDate(m_span, tmTemp))
        {
                VERIFY(strSpan.LoadString(AFX_IDS_INVALID_DATETIMESPAN));
                return strSpan;
        }

        // Convert tm from afx internal format to standard format
        TmConvertToStandardFormat(tmTemp);

        // Fill in the buffer, disregard return value as it's not necessary
        LPTSTR lpszTemp = strSpan.GetBufferSetLength(MAX_TIME_BUFFER_SIZE);
        _tcsftime(lpszTemp, strSpan.GetLength(), pFormat, &tmTemp);
        strSpan.ReleaseBuffer();

        return strSpan;
}

CString COleDateTimeSpan::Format(UINT nFormatID) const
{
        CString strFormat;
        VERIFY(strFormat.LoadString(nFormatID) != 0);
        return Format(strFormat);
}

void COleDateTimeSpan::CheckRange()
{
        if(m_span < -MAX_DAYS_IN_SPAN || m_span > MAX_DAYS_IN_SPAN)
                SetStatus(invalid);
}

// serialization
#ifdef _DEBUG
CDumpContext& AFXAPI operator<<(CDumpContext& dc, COleDateTimeSpan dateSpanSrc)
{
        dc << "\nCOleDateTimeSpan Object:";
        dc << "\n\tm_status = " << (long)dateSpanSrc.m_status;

        COleVariant var(dateSpanSrc.m_span);
        var.ChangeType(VT_BSTR);

        return dc << "\n\tdateSpan = " << (LPCTSTR)var.bstrVal;
}
#endif // _DEBUG

#ifdef _with_archive_
CArchive& AFXAPI operator<<(CArchive& ar, COleDateTimeSpan dateSpanSrc)
{
        ar << (long)dateSpanSrc.m_status;
        return ar << dateSpanSrc.m_span;
}

CArchive& AFXAPI operator>>(CArchive& ar, COleDateTimeSpan& dateSpanSrc)
{
        ar >> (long&)dateSpanSrc.m_status;
        return ar >> dateSpanSrc.m_span;
}
#endif //_with_archive_

/////////////////////////////////////////////////////////////////////////////
// COleDateTime class HELPERS - implementation

BOOL OleDateFromTm(WORD wYear, WORD wMonth, WORD wDay,
        WORD wHour, WORD wMinute, WORD wSecond, DATE& dtDest)
{
        // Validate year and month (ignore day of week and milliseconds)
        if (wYear > 9999 || wMonth < 1 || wMonth > 12)
                return FALSE;

        //  Check for leap year and set the number of days in the month
        BOOL bLeapYear = ((wYear & 3) == 0) &&
                ((wYear % 100) != 0 || (wYear % 400) == 0);

        int nDaysInMonth =
                rgMonthDays[wMonth] - rgMonthDays[wMonth-1] +
                ((bLeapYear && wDay == 29 && wMonth == 2) ? 1 : 0);

        // Finish validating the date
        if (wDay < 1 || wDay > nDaysInMonth ||
                wHour > 23 || wMinute > 59 ||
                wSecond > 59)
        {
                return FALSE;
        }

        // Cache the date in days and time in fractional days
        long nDate;
        double dblTime;

        //It is a valid date; make Jan 1, 1AD be 1
        nDate = wYear*365L + wYear/4 - wYear/100 + wYear/400 +
                rgMonthDays[wMonth-1] + wDay;

        //  If leap year and it's before March, subtract 1:
        if (wMonth <= 2 && bLeapYear)
                --nDate;

        //  Offset so that 12/30/1899 is 0
        nDate -= 693959L;

        dblTime = (((long)wHour * 3600L) +  // hrs in seconds
                ((long)wMinute * 60L) +  // mins in seconds
                ((long)wSecond)) / 86400.;

        dtDest = (double) nDate + ((nDate >= 0) ? dblTime : -dblTime);

        return TRUE;
}

BOOL TmFromOleDate(DATE dtSrc, struct tm& tmDest)
{
        // The legal range does not actually span year 0 to 9999.
        if (dtSrc > MAX_DATE || dtSrc < MIN_DATE) // about year 100 to about 9999
                return FALSE;

        long nDays;             // Number of days since Dec. 30, 1899
        long nDaysAbsolute;     // Number of days since 1/1/0
        long nSecsInDay;        // Time in seconds since midnight
        long nMinutesInDay;     // Minutes in day

        long n400Years;         // Number of 400 year increments since 1/1/0
        long n400Century;       // Century within 400 year block (0,1,2 or 3)
        long n4Years;           // Number of 4 year increments since 1/1/0
        long n4Day;             // Day within 4 year block
                                                        //  (0 is 1/1/yr1, 1460 is 12/31/yr4)
        long n4Yr;              // Year within 4 year block (0,1,2 or 3)
        BOOL bLeap4 = TRUE;     // TRUE if 4 year block includes leap year

        double dblDate = dtSrc; // tempory serial date

        // If a valid date, then this conversion should not overflow
        nDays = (long)dblDate;

        // Round to the second
        dblDate += ((dtSrc > 0.0) ? HALF_SECOND : -HALF_SECOND);

        nDaysAbsolute = (long)dblDate + 693959L; // Add days from 1/1/0 to 12/30/1899

        dblDate = fabs(dblDate);
        nSecsInDay = (long)((dblDate - floor(dblDate)) * 86400.);

        // Calculate the day of week (sun=1, mon=2...)
        //   -1 because 1/1/0 is Sat.  +1 because we want 1-based
        tmDest.tm_wday = (int)((nDaysAbsolute - 1) % 7L) + 1;

        // Leap years every 4 yrs except centuries not multiples of 400.
        n400Years = (long)(nDaysAbsolute / 146097L);

        // Set nDaysAbsolute to day within 400-year block
        nDaysAbsolute %= 146097L;

        // -1 because first century has extra day
        n400Century = (long)((nDaysAbsolute - 1) / 36524L);

        // Non-leap century
        if (n400Century != 0)
        {
                // Set nDaysAbsolute to day within century
                nDaysAbsolute = (nDaysAbsolute - 1) % 36524L;

                // +1 because 1st 4 year increment has 1460 days
                n4Years = (long)((nDaysAbsolute + 1) / 1461L);

                if (n4Years != 0)
                        n4Day = (long)((nDaysAbsolute + 1) % 1461L);
                else
                {
                        bLeap4 = FALSE;
                        n4Day = (long)nDaysAbsolute;
                }
        }
        else
        {
                // Leap century - not special case!
                n4Years = (long)(nDaysAbsolute / 1461L);
                n4Day = (long)(nDaysAbsolute % 1461L);
        }

        if (bLeap4)
        {
                // -1 because first year has 366 days
                n4Yr = (n4Day - 1) / 365;

                if (n4Yr != 0)
                        n4Day = (n4Day - 1) % 365;
        }
        else
        {
                n4Yr = n4Day / 365;
                n4Day %= 365;
        }

        // n4Day is now 0-based day of year. Save 1-based day of year, year number
        tmDest.tm_yday = (int)n4Day + 1;
        tmDest.tm_year = n400Years * 400 + n400Century * 100 + n4Years * 4 + n4Yr;

        // Handle leap year: before, on, and after Feb. 29.
        if (n4Yr == 0 && bLeap4)
        {
                // Leap Year
                if (n4Day == 59)
                {
                        /* Feb. 29 */
                        tmDest.tm_mon = 2;
                        tmDest.tm_mday = 29;
                        goto DoTime;
                }

                // Pretend it's not a leap year for month/day comp.
                if (n4Day >= 60)
                        --n4Day;
        }

        // Make n4DaY a 1-based day of non-leap year and compute
        //  month/day for everything but Feb. 29.
        ++n4Day;

        // Month number always >= n/32, so save some loop time */
        for (tmDest.tm_mon = (n4Day >> 5) + 1;
                n4Day > rgMonthDays[tmDest.tm_mon]; tmDest.tm_mon++);

        tmDest.tm_mday = (int)(n4Day - rgMonthDays[tmDest.tm_mon-1]);

DoTime:
        if (nSecsInDay == 0)
                tmDest.tm_hour = tmDest.tm_min = tmDest.tm_sec = 0;
        else
        {
                tmDest.tm_sec = (int)nSecsInDay % 60L;
                nMinutesInDay = nSecsInDay / 60L;
                tmDest.tm_min = (int)nMinutesInDay % 60;
                tmDest.tm_hour = (int)nMinutesInDay / 60;
        }

        return TRUE;
}

void TmConvertToStandardFormat(struct tm& tmSrc)
{
        // Convert afx internal tm to format expected by runtimes (_tcsftime, etc)
        tmSrc.tm_year -= 1900;  // year is based on 1900
        tmSrc.tm_mon -= 1;      // month of year is 0-based
        tmSrc.tm_wday -= 1;     // day of week is 0-based
        tmSrc.tm_yday -= 1;     // day of year is 0-based
}

double DoubleFromDate(DATE dt)
{
        // No problem if positive
        if (dt >= 0)
                return dt;

        // If negative, must convert since negative dates not continuous
        // (examples: -1.25 to -.75, -1.50 to -.50, -1.75 to -.25)
        double temp = ceil(dt);
        return temp - (dt - temp);
}

DATE DateFromDouble(double dbl)
{
        // No problem if positive
        if (dbl >= 0)
                return dbl;

        // If negative, must convert since negative dates not continuous
        // (examples: -.75 to -1.25, -.50 to -1.50, -.25 to -1.75)
        double temp = floor(dbl); // dbl is now whole part
        return temp + (temp - dbl);
}

/////////////////////////////////////////////////////////////////////////////
// COleSafeArray class
COleSafeArray::COleSafeArray(const SAFEARRAY& saSrc, VARTYPE vtSrc)
{
        AfxSafeArrayInit(this);
        vt = vtSrc | VT_ARRAY;
        CheckError(::SafeArrayCopy((LPSAFEARRAY)&saSrc, &parray));
        m_dwDims = GetDim();
        m_dwElementSize = GetElemSize();
}

COleSafeArray::COleSafeArray(LPCSAFEARRAY pSrc, VARTYPE vtSrc)
{
        AfxSafeArrayInit(this);
        vt = vtSrc | VT_ARRAY;
        CheckError(::SafeArrayCopy((LPSAFEARRAY)pSrc, &parray));
        m_dwDims = GetDim();
        m_dwElementSize = GetElemSize();
}

COleSafeArray::COleSafeArray(const COleSafeArray& saSrc)
{
        AfxSafeArrayInit(this);
        *this = saSrc;
        m_dwDims = GetDim();
        m_dwElementSize = GetElemSize();
}

COleSafeArray::COleSafeArray(const VARIANT& varSrc)
{
        AfxSafeArrayInit(this);
        *this = varSrc;
        m_dwDims = GetDim();
        m_dwElementSize = GetElemSize();
}

COleSafeArray::COleSafeArray(LPCVARIANT pSrc)
{
        AfxSafeArrayInit(this);
        *this = pSrc;
        m_dwDims = GetDim();
        m_dwElementSize = GetElemSize();
}

// Operations
void COleSafeArray::Attach(VARIANT& varSrc)
{
        ASSERT(varSrc.vt & VT_ARRAY);

        // Free up previous safe array if necessary
        Clear();

        // give control of data to COleSafeArray
        memcpy(this, &varSrc, sizeof(varSrc));
        varSrc.vt = VT_EMPTY;
}

VARIANT COleSafeArray::Detach()
{
        VARIANT varResult = *this;
        vt = VT_EMPTY;
        return varResult;
}

// Assignment operators
COleSafeArray& COleSafeArray::operator=(const COleSafeArray& saSrc)
{
        ASSERT(saSrc.vt & VT_ARRAY);

        CheckError(::VariantCopy(this, (LPVARIANT)&saSrc));
        return *this;
}

COleSafeArray& COleSafeArray::operator=(const VARIANT& varSrc)
{
        ASSERT(varSrc.vt & VT_ARRAY);

        CheckError(::VariantCopy(this, (LPVARIANT)&varSrc));
        return *this;
}

COleSafeArray& COleSafeArray::operator=(LPCVARIANT pSrc)
{
        ASSERT(pSrc->vt & VT_ARRAY);

        CheckError(::VariantCopy(this, (LPVARIANT)pSrc));
        return *this;
}

COleSafeArray& COleSafeArray::operator=(const COleVariant& varSrc)
{
        ASSERT(varSrc.vt & VT_ARRAY);

        CheckError(::VariantCopy(this, (LPVARIANT)&varSrc));
        return *this;
}

// Comparison operators
BOOL COleSafeArray::operator==(const SAFEARRAY& saSrc) const
{
        return CompareSafeArrays(parray, (LPSAFEARRAY)&saSrc);
}

BOOL COleSafeArray::operator==(LPCSAFEARRAY pSrc) const
{
        return CompareSafeArrays(parray, (LPSAFEARRAY)pSrc);
}

BOOL COleSafeArray::operator==(const COleSafeArray& saSrc) const
{
        if (vt != saSrc.vt)
                return FALSE;

        return CompareSafeArrays(parray, saSrc.parray);
}

BOOL COleSafeArray::operator==(const VARIANT& varSrc) const
{
        if (vt != varSrc.vt)
                return FALSE;

        return CompareSafeArrays(parray, varSrc.parray);
}

BOOL COleSafeArray::operator==(LPCVARIANT pSrc) const
{
        if (vt != pSrc->vt)
                return FALSE;

        return CompareSafeArrays(parray, pSrc->parray);
}

BOOL COleSafeArray::operator==(const COleVariant& varSrc) const
{
        if (vt != varSrc.vt)
                return FALSE;

        return CompareSafeArrays(parray, varSrc.parray);
}

void COleSafeArray::CreateOneDim(VARTYPE vtSrc, DWORD dwElements,
        void* pvSrcData, long nLBound)
{
        ASSERT(dwElements > 0);

        // Setup the bounds and create the array
        SAFEARRAYBOUND rgsabound;
        rgsabound.cElements = dwElements;
        rgsabound.lLbound = nLBound;
        Create(vtSrc, 1, &rgsabound);

        // Copy over the data if neccessary
        if (pvSrcData != NULL)
        {
                void* pvDestData;
                AccessData(&pvDestData);
                memcpy(pvDestData, pvSrcData, GetElemSize() * dwElements);
                UnaccessData();
        }
}

DWORD COleSafeArray::GetOneDimSize()
{
        ASSERT(GetDim() == 1);

        long nUBound, nLBound;

        GetUBound(1, &nUBound);
        GetLBound(1, &nLBound);

        return nUBound + 1 - nLBound;
}

void COleSafeArray::ResizeOneDim(DWORD dwElements)
{
        ASSERT(GetDim() == 1);

        SAFEARRAYBOUND rgsabound;

        rgsabound.cElements = dwElements;
        rgsabound.lLbound = 0;

        Redim(&rgsabound);
}

void COleSafeArray::Create(VARTYPE vtSrc, DWORD dwDims, DWORD* rgElements)
{
        ASSERT(rgElements != NULL);

        // Allocate and fill proxy array of bounds (with lower bound of zero)
        SAFEARRAYBOUND* rgsaBounds = new SAFEARRAYBOUND[dwDims];

        for (DWORD dwIndex = 0; dwIndex < dwDims; dwIndex++)
        {
                // Assume lower bound is 0 and fill in element count
                rgsaBounds[dwIndex].lLbound = 0;
                rgsaBounds[dwIndex].cElements = rgElements[dwIndex];
        }

        TRY
        {
                Create(vtSrc, dwDims, rgsaBounds);
        }
        CATCH_ALL(e)
        {
                // Must free up memory
                delete [] rgsaBounds;
                THROW_LAST();
        }
        END_CATCH_ALL

        delete [] rgsaBounds;
}

void COleSafeArray::Create(VARTYPE vtSrc, DWORD dwDims, SAFEARRAYBOUND* rgsabound)
{
        ASSERT(dwDims > 0);
        ASSERT(rgsabound != NULL);

        // Validate the VARTYPE for SafeArrayCreate call
        ASSERT(!(vtSrc & VT_ARRAY));
        ASSERT(!(vtSrc & VT_BYREF));
        ASSERT(!(vtSrc & VT_VECTOR));
        ASSERT(vtSrc != VT_EMPTY);
        ASSERT(vtSrc != VT_NULL);

        // Free up old safe array if necessary
        Clear();

        parray = ::SafeArrayCreate(vtSrc, dwDims, rgsabound);

        if (parray == NULL)
                AfxThrowMemoryException();

        vt = unsigned short(vtSrc | VT_ARRAY);
        m_dwDims = dwDims;
        m_dwElementSize = GetElemSize();
}

void COleSafeArray::AccessData(void** ppvData)
{
        CheckError(::SafeArrayAccessData(parray, ppvData));
}

void COleSafeArray::UnaccessData()
{
        CheckError(::SafeArrayUnaccessData(parray));
}

void COleSafeArray::AllocData()
{
        CheckError(::SafeArrayAllocData(parray));
}

void COleSafeArray::AllocDescriptor(DWORD dwDims)
{
        CheckError(::SafeArrayAllocDescriptor(dwDims, &parray));
}

void COleSafeArray::Copy(LPSAFEARRAY* ppsa)
{
        CheckError(::SafeArrayCopy(parray, ppsa));
}

void COleSafeArray::GetLBound(DWORD dwDim, long* pLbound)
{
        CheckError(::SafeArrayGetLBound(parray, dwDim, pLbound));
}

void COleSafeArray::GetUBound(DWORD dwDim, long* pUbound)
{
        CheckError(::SafeArrayGetUBound(parray, dwDim, pUbound));
}

void COleSafeArray::GetElement(long* rgIndices, void* pvData)
{
        CheckError(::SafeArrayGetElement(parray, rgIndices, pvData));
}

void COleSafeArray::PtrOfIndex(long* rgIndices, void** ppvData)
{
        CheckError(::SafeArrayPtrOfIndex(parray, rgIndices, ppvData));
}

void COleSafeArray::PutElement(long* rgIndices, void* pvData)
{
        CheckError(::SafeArrayPutElement(parray, rgIndices, pvData));
}

void COleSafeArray::Redim(SAFEARRAYBOUND* psaboundNew)
{
        CheckError(::SafeArrayRedim(parray, psaboundNew));
}

void COleSafeArray::Lock()
{
        CheckError(::SafeArrayLock(parray));
}

void COleSafeArray::Unlock()
{
        CheckError(::SafeArrayUnlock(parray));
}

void COleSafeArray::Destroy()
{
        CheckError(::SafeArrayDestroy(parray));
}

void COleSafeArray::DestroyData()
{
        CheckError(::SafeArrayDestroyData(parray));
}

void COleSafeArray::DestroyDescriptor()
{
        CheckError(::SafeArrayDestroyDescriptor(parray));
}

///////////////////////////////////////////////////////////////////////////////
// COleSafeArray Helpers
void AFXAPI AfxSafeArrayInit(COleSafeArray* psa)
{
        memset(psa, 0, sizeof(*psa));
}

/////////////////////////////////////////////////////////////////////////////
// Simple field formatting to text item - see dlgdata.cpp for base types
void AFXAPI DDX_Text(CDataExchange* pDX, int nIDC, COleDateTime& value)
{
        HWND hWndCtrl = pDX->PrepareEditCtrl(nIDC);
        if (pDX->m_bSaveAndValidate)
        {
                int nLen = ::GetWindowTextLength(hWndCtrl);
                CString strTemp;

                ::GetWindowText(hWndCtrl, strTemp.GetBufferSetLength(nLen), nLen+1);
                strTemp.ReleaseBuffer();

                if (!value.ParseDateTime(strTemp))  // throws exception
                {
                        // Can't convert string to datetime
                        AfxMessageBox(AFX_IDP_PARSE_DATETIME);
                        pDX->Fail();    // throws exception
                }
        }
        else
        {
                CString strTemp = value.Format();
                AfxSetWindowText(hWndCtrl, strTemp);
        }
}

void AFXAPI DDX_Text(CDataExchange* pDX, int nIDC, COleCurrency& value)
{
        HWND hWndCtrl = pDX->PrepareEditCtrl(nIDC);
        if (pDX->m_bSaveAndValidate)
        {
                int nLen = ::GetWindowTextLength(hWndCtrl);
                CString strTemp;

                ::GetWindowText(hWndCtrl, strTemp.GetBufferSetLength(nLen), nLen+1);
                strTemp.ReleaseBuffer();

                if (!value.ParseCurrency(strTemp))  // throws exception
                {
                        // Can't convert string to currency
                        AfxMessageBox(AFX_IDP_PARSE_CURRENCY);
                        pDX->Fail();    // throws exception
                }
        }
        else
        {
                CString strTemp = value.Format();
                AfxSetWindowText(hWndCtrl, strTemp);
        }
}

/////////////////////////////////////////////////////////////////////////////
#endif //_CURRENCY_ALSO_

//+---------------------------------------------------------------------------
//
//  Method:     COleVariant::Save
//
//  Synopsis:   saves a variant to a stream
//
//  Arguments:  [pStm] --
//              [fClearDirty] --
//
//  Returns:
//
//  History:    1-15-1997   JohannP (Johann Posch)   Created
//
//  Notes:      BUGBUG:NOT COMPLETE!
//
//----------------------------------------------------------------------------
HRESULT COleVariant::Save(IStream *pStm, BOOL fClearDirty)
{
    LPVARIANT pSrc = (LPVARIANT)this;
    HRESULT hr = NOERROR;
    ULONG cbSaved;
    COleVariant CVar;

    if (pSrc->vt & VT_BYREF || pSrc->vt & VT_ARRAY)
    {
        // No support for VT_BYREF & VT_ARRAY
        pSrc = (LPVARIANT)&CVar;
    }

    // write the variant
    hr = pStm->Write(pSrc, sizeof(VARIANT), &cbSaved);
    TransAssert(( sizeof(VARIANT) == cbSaved));
    if (hr == NOERROR)
    {
        switch (pSrc->vt)
        {
        case VT_DISPATCH:
            TransAssert((FALSE));
            hr = E_FAIL;
            break;

        case VT_UNKNOWN:
            {
                ULONG cbInterface = 0;
                IUnknown *pUnk = pSrc->punkVal;
                
                hr = CoGetMarshalSizeMax(&cbInterface, IID_IUnknown, pUnk, MSHCTX_LOCAL, 0, MSHLFLAGS_NORMAL);

                if (hr == S_OK)
                {   
                    // write the size of 
                    hr = pStm->Write(&cbInterface, sizeof(ULONG), &cbSaved);
                    // need to marshal table strong
                    hr = CoMarshalInterface(pStm, IID_IUnknown, pUnk, MSHCTX_LOCAL, 0, MSHLFLAGS_NORMAL);
                }

            }
            break;
            

        default:
        case VT_EMPTY:
        case VT_NULL:
            // do nothing
            break;

        case VT_BSTR:
            {
                DWORD nLen = SysStringByteLen(pSrc->bstrVal);
                hr = pStm->Write(&nLen, sizeof(DWORD), &cbSaved);
                if (   (hr == NOERROR)
                    && (nLen > 0))
                {
                    hr = pStm->Write(pSrc->bstrVal, nLen * sizeof(BYTE), &cbSaved);
                }
            }
            break;


    #ifdef _unused_
        case VT_BOOL:
            hr = pStm->Write((WORD)V_BOOL(pSrc), sizeof(WORD), &cbSaved);
            break;

        case VT_UI1:
            hr = pStm->Write(pSrc->bVal, sizeof(WORD), &cbSaved);
            break;

        case VT_I2:
            hr = pStm->Write((WORD)pSrc->iVal, sizeof(WORD), &cbSaved);
            break;

        case VT_I4:
            hr = pStm->Write(pSrc->lVal, sizeof(DWORD), &cbSaved);
            break;

        case VT_CY:
            hr = pStm->Write(pSrc->cyVal.Lo, sizeof(WORD), &cbSaved);
            hr = pStm->Write(pSrc->cyVal.Hi, sizeof(WORD), &cbSaved);
            break;

        case VT_R4:
            hr = pStm->Write(pSrc->fltVal, sizeof(WORD), &cbSaved);
            break;

        case VT_R8:
            hr = pStm->Write(pSrc->dblVal, sizeof(DOUBLE), &cbSaved);
            break;

        case VT_DATE:
            hr = pStm->Write(pSrc->date;
            break;

        case VT_ERROR:
            hr = pStm->Write(pSrc->scode;
            break;
    #endif //_unused_
        }
    }


    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     COleVariant::Load
//
//  Synopsis:   loads a variant from a stream
//
//  Arguments:  [pStm] --
//
//  Returns:
//
//  History:    1-15-1997   JohannP (Johann Posch)   Created
//
//  Notes:      BUGBUG:NOT COMPLETE!
//
//----------------------------------------------------------------------------
HRESULT COleVariant::Load(IStream *pStm)
{
    LPVARIANT pSrc = (LPVARIANT)this;
    HRESULT hr = NOERROR;
    ULONG cbSaved;
    COleVariant CVar;

    // Read the variant
    hr = pStm->Read(pSrc, sizeof(VARIANT), &cbSaved);
    TransAssert(( sizeof(VARIANT) == cbSaved));

    if (pSrc->vt & VT_BYREF || pSrc->vt & VT_ARRAY)
    {
        // No support for VT_BYREF & VT_ARRAY
        pSrc = (LPVARIANT)&CVar;
    }

    if (hr == NOERROR)
    {
        switch (pSrc->vt)
        {
        case VT_DISPATCH:
            TransAssert((FALSE));
            hr = E_FAIL;
            break;


        case VT_UNKNOWN:
            {
                ULONG cbInterface = 0;
                IUnknown *pUnk = 0;
                
                // write the size of 
                hr = pStm->Read(&cbInterface, sizeof(ULONG), &cbSaved);

                if (   (hr == S_OK)
                    && cbInterface)
                {

                    hr = CoUnmarshalInterface(pStm, IID_IUnknown, (void **) &pUnk);
                    if(hr == S_OK)
                    {
                        pSrc->punkVal = pUnk;
                    }
                    else
                    {
                        pSrc->punkVal = 0;
                    }
                }
                else
                {
                    pSrc->punkVal = 0;
                }
                hr = NOERROR;
            }
            break;


        default:
        case VT_EMPTY:
        case VT_NULL:
            // do nothing
            break;

        case VT_BSTR:
            {
                DWORD nLen = 0;
                hr = pStm->Read(&nLen, sizeof(DWORD), &cbSaved);

                if (nLen > 0)
                {
                    pSrc->bstrVal = SysAllocStringByteLen(NULL, nLen);

                    if (pSrc->bstrVal)
                    {
                        hr = pStm->Read(pSrc->bstrVal, nLen * sizeof(BYTE), &cbSaved);
                    }
                    else
                    {
                        hr = E_OUTOFMEMORY;
                    }
                }
            }
            break;


    #ifdef _unused_
        case VT_BOOL:
            hr = pStm->Read((WORD)V_BOOL(pSrc), sizeof(WORD), &cbSaved);
            break;

        case VT_UI1:
            hr = pStm->Read(pSrc->bVal, sizeof(WORD), &cbSaved);
            break;

        case VT_I2:
            hr = pStm->Read((WORD)pSrc->iVal, sizeof(WORD), &cbSaved);
            break;

        case VT_I4:
            hr = pStm->Read(pSrc->lVal, sizeof(DWORD), &cbSaved);
            break;

        case VT_CY:
            hr = pStm->Read(pSrc->cyVal.Lo, sizeof(WORD), &cbSaved);
            hr = pStm->Read(pSrc->cyVal.Hi, sizeof(WORD), &cbSaved);
            break;

        case VT_R4:
            hr = pStm->Read(pSrc->fltVal, sizeof(WORD), &cbSaved);
            break;

        case VT_R8:
            hr = pStm->Read(pSrc->dblVal, sizeof(DOUBLE), &cbSaved);
            break;

        case VT_DATE:
            hr = pStm->Read(pSrc->date;
            break;

        case VT_ERROR:
            hr = pStm->Read(pSrc->scode;
            break;
    #endif //_unused_
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\urlmon\utils\ccompapi.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 1993.
//
//  File:       ccompapi.cxx
//
//  Contents:   common compobj API Worker routines used by com, stg, scm etc
//
//  Classes:
//
//  Functions:
//
//  History:    31-Dec-93   ErikGav     Chicago port
//
//----------------------------------------------------------------------------

#include <windows.h>
#include <ole2sp.h>
#include <ole2com.h>


NAME_SEG(CompApi)
ASSERTDATA

static const BYTE GuidMap[] = { 3, 2, 1, 0, '-', 5, 4, '-', 7, 6, '-',
                                8, 9, '-', 10, 11, 12, 13, 14, 15 };

static const WCHAR wszDigits[] = L"0123456789ABCDEF";


//+-------------------------------------------------------------------------
//
//  Function:   wStringFromGUID2     (internal)
//
//  Synopsis:   converts GUID into {...} form without leading identifier;
//
//  Arguments:  [rguid] - the guid to convert
//              [lpszy] - buffer to hold the results
//              [cbMax] - sizeof the buffer
//
//  Returns:    amount of data copied to lpsz if successful
//              0 if buffer too small.
//
//--------------------------------------------------------------------------
INTERNAL_(int)  wStringFromGUID2(REFGUID rguid, LPWSTR lpsz, int cbMax)
{
    int i;
    LPWSTR p = lpsz;

    const BYTE * pBytes = (const BYTE *) &rguid;

    *p++ = L'{';

    for (i = 0; i < sizeof(GuidMap); i++)
    {
        if (GuidMap[i] == '-')
        {
            *p++ = L'-';
        }
        else
        {
            *p++ = wszDigits[ (pBytes[GuidMap[i]] & 0xF0) >> 4 ];
            *p++ = wszDigits[ (pBytes[GuidMap[i]] & 0x0F) ];
        }
    }
    *p++ = L'}';
    *p   = L'\0';

    return GUIDSTR_MAX;
}

#ifdef _CHICAGO_

static const CHAR szDigits[] = "0123456789ABCDEF";
//+-------------------------------------------------------------------------
//
//  Function:   wStringFromGUID2A     (internal)
//
//  Synopsis:   Ansi version of wStringFromGUID2 (for Win95 Optimizations)
//
//  Arguments:  [rguid] - the guid to convert
//              [lpszy] - buffer to hold the results
//              [cbMax] - sizeof the buffer
//
//  Returns:    amount of data copied to lpsz if successful
//              0 if buffer too small.
//
//--------------------------------------------------------------------------

INTERNAL_(int) wStringFromGUID2A(REFGUID rguid, LPSTR lpsz, int cbMax)  // internal
{
    int i;
    LPSTR p = lpsz;

    const BYTE * pBytes = (const BYTE *) &rguid;

    *p++ = '{';

    for (i = 0; i < sizeof(GuidMap); i++)
    {
        if (GuidMap[i] == '-')
        {
            *p++ = '-';
        }
        else
        {
            *p++ = szDigits[ (pBytes[GuidMap[i]] & 0xF0) >> 4 ];
            *p++ = szDigits[ (pBytes[GuidMap[i]] & 0x0F) ];
        }
    }
    *p++ = '}';
    *p   = '\0';

    return GUIDSTR_MAX;
}
#endif



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\urlmon\utils\debug.h ===
//+----------------------------------------------------------------------------
//
//	File:
//		debug.h
//
//	Contents:
//		macros and declarations for debug support--all are appropriately
//		defined to nothing when not doing debug build
//
//	Classes:
//
//	Functions:
//
//	History:
//		12/30/93 - ChrisWe - added file prologue; defined _DEBUG when
//			DBG==1; added "const" to ASSERTDATA macro
//
//-----------------------------------------------------------------------------


#ifndef _DEBUG_H_
#define _DEBUG_H_

#include <debnot.h>

#ifndef RC_INVOKED
#ifdef _DEBUG
#define DBGSTATE " Debug is on"
#else
#define DBGSTATE " Debug is off"
#endif
#endif  /* RC_INVOKED */

#ifndef _CAIRO_
#include <ole2dbg.h>
#endif

//these are bogus APIs (they do nothing)
STDAPI_(BOOL) ValidateAllObjects( BOOL fSuspicious );
STDAPI_(void) DumpAllObjects( void );

#ifdef _DEBUG
BOOL InstallHooks(void);
BOOL UnInstallHooks(void);

#undef ASSERTDATA
#define ASSERTDATA

#undef AssertSz
#define AssertSz(a,b) ((a) ? NOERROR : FnAssert(#a, b, __FILE__, __LINE__))
#undef Puts
#define Puts(s) OutputDebugString(TEXT(s))

#else   //  !_DEBUG

#define ASSERTDATA
#define AssertSz(a, b) ((void)0)
#define Puts(s) ((void)0)

#endif  //  _DEBUG


// special Assert for asserts below (since the expression is so large)
// REVIEW, shouldn't these be in the debug.h file?
#ifdef _DEBUG
#define AssertOut(a, b) { if (!(a)) FnAssert(szCheckOutParam, b, __FILE__, __LINE__); }
#else
#define AssertOut(a, b) ((void)0)
#endif

#define AssertOutPtrParam(hr, p) \
	AssertOut(SUCCEEDED(hr) && IsValidPtrIn(p, sizeof(OLECHAR)) || \
	FAILED(hr) && (p) == NULL, \
	szBadOutParam)

#define AssertOutPtrIface(hr, p) \
	AssertOut(SUCCEEDED(hr) && IsValidInterface(p) || \
	FAILED(hr) && (p) == NULL, \
	szBadOutIface)

#define AssertOutPtrFailed(p) \
	AssertOut((p) == NULL, \
	szNonNULLOutPtr)

#define AssertOutStgmedium(hr, pstgm) \
	AssertOut(SUCCEEDED(hr) && (pstgm)->tymed != TYMED_NULL || \
	FAILED(hr) && (pstgm)->tymed == TYMED_NULL, \
	szBadOutStgm)


// assert data for above assert out macros; once per dll
// Note that since these are only used in asserts, we leave them as ANSI
#define ASSERTOUTDATA \
    char szCheckOutParam[] = "check out param"; \
    char szBadOutParam[] = "Out pointer param conventions not followed"; \
    char szBadOutIface[] = "Out pointer interface conventions not followed"; \
    char szNonNULLOutPtr[] = "Out pointer not NULL on error"; \
    char szBadOutStgm[] = "Out stgmed param conventions not followed";

extern char szCheckOutParam[];
extern char szBadOutParam[];
extern char szBadOutIface[];
extern char szNonNULLOutPtr[];
extern char szBadOutStgm[];


#ifdef __cplusplus

interface IDebugStream;

/*
 *  Class CBool wraps boolean values in such a way that they are
 *  readily distinguishable fron integers by the compiler so we can
 *  overload the stream << operator.
 */

class FAR CBool
{
    BOOL value;
public:
    CBool (BOOL& b) {value = b;}
    operator BOOL( void ) { return value; }
};


/*
 *  Class CHwnd wraps HWND values in such a way that they are
 *  readily distinguishable from UINTS by the compiler so we can
 *  overload the stream << operator
 */

class FAR CHwnd
{
	HWND m_hwnd;
	public:
		CHwnd (HWND hwnd) {m_hwnd = hwnd; }
		operator HWND( void ) {return m_hwnd;}
};

/*
 * Class CAtom wraps ATOM values in such a way that they are
 *  readily distinguishable from UINTS by the compiler so we can
 *  overload the stream << operator
 */

class FAR CAtom
{
	ATOM m_atom;
	public:
		CAtom (ATOM atom) {m_atom = atom; }
		operator ATOM( void ) {return m_atom; }
};

/*
 *  IDebugStream is a stream to be used for debug output.  One
 *  implementation uses the OutputDebugString function of Windows.
 *
 *  The style is modeled on that of AT&T streams, and so uses
 *  overloaded operators.  You can write to a stream in the
 *  following ways:
 *
 *    *pdbstm << pUnk;  // calls the IDebug::Dump function to
 *                      display the object, if IDebug is supported.
 *    int n;
 *    *pdbstm << n;     // writes n in decimal
 *
-
 *    *pdbstm << sz;    // writes a string
 *
 *    CBool b(TRUE);
 *    *pdbstm << b;     // writes True or False
 *
 *    void FAR * pv;
 *    *pdbstm << pv;    // writes the address pv in hex
 *
 *    TCHAR ch;
 *    *pdbstm << ch;    // writes the character
 *
 *    ATOM atom;
 *    *pdbstm << CAtom(atom);	// writes the string extracted from the atom
 *
 *    HWND hwnd;
 *    *pdbstm << CHwnd(hwnd);  // writes the info about a window handle
 *
 *  These can be chained together, as such (somewhat artificial
 *  example):
 *
 *    REFCLSID rclsid;
 *    pUnk->GetClass(&rclsid);
 *    *pdbstm << rclsid << " at " << (void FAR *)pUnk <<':' << pUnk;
 *
 *  This produces something like:
 *
 *    CFoo at A7360008: <description of object>
 *
 *  The other useful feature is the Indent and UnIndent functions
 *  which allow an object to print some information, indent, print
 *  the info on its member objects, and unindent.  This gives
 *  nicely formatted output.
 *
 *  WARNING:  do not (while implementing Dump) write
 *
 *    *pdbstm << pUnkOuter
 *
 *  since this will do a QueryInterface for IDebug, and start
 *  recursing!  It is acceptable to write
 *
 *    *pdbstm << (VOID FAR *)pUnkOuter
 *
 *  as this will simply write the address of pUnkOuter.
 *
 */


interface IDebugStream : public IUnknown
{
    STDMETHOD_(IDebugStream&, operator << ) ( IUnknown FAR * pDebug ) = 0;
    STDMETHOD_(IDebugStream&, operator << ) ( REFCLSID rclsid ) = 0;
    STDMETHOD_(IDebugStream&, operator << ) ( int n ) = 0;
    STDMETHOD_(IDebugStream&, operator << ) ( long l ) = 0;
    STDMETHOD_(IDebugStream&, operator << ) ( ULONG l ) = 0;
    STDMETHOD_(IDebugStream&, operator << ) ( LPCTSTR sz ) = 0;
    STDMETHOD_(IDebugStream&, operator << ) ( TCHAR ch ) = 0;
    STDMETHOD_(IDebugStream&, operator << ) ( void FAR * pv ) = 0;
    STDMETHOD_(IDebugStream&, operator << ) ( CBool b ) = 0;
    STDMETHOD_(IDebugStream&, operator << ) ( CHwnd hwnd ) = 0;
    STDMETHOD_(IDebugStream&, operator << ) ( CAtom atom ) = 0;
    STDMETHOD_(IDebugStream&, Tab )( void ) = 0;
    STDMETHOD_(IDebugStream&, Indent )( void ) = 0;
    STDMETHOD_(IDebugStream&, UnIndent )( void ) = 0;
    STDMETHOD_(IDebugStream&, Return )( void ) = 0;
    STDMETHOD_(IDebugStream&, LF )( void ) = 0;
};

STDAPI_(IDebugStream FAR*) MakeDebugStream( short margin=70, short tabsize=4, BOOL fHeader=1);


interface IDebug
{
    STDMETHOD_(void, Dump )( IDebugStream FAR * pdbstm ) = 0;
    STDMETHOD_(BOOL, IsValid )( BOOL fSuspicious = FALSE ) = 0;

#ifdef NEVER
    __export IDebug(void);
    __export ~IDebug(void);
private:

#ifdef _DEBUG
    IDebug FAR * pIDPrev;
    IDebug FAR * pIDNext;

    friend void STDAPICALLTYPE DumpAllObjects( void );
    friend BOOL STDAPICALLTYPE ValidateAllObjects( BOOL fSuspicious );
#endif // _DEBUG
#endif // NEVER
};

/*************************************************************************
** The following functions can be used to log debug messages to a file
**    and simutaneously write them to the dbwin debug window.
**    The CDebugStream implementation automatically writes to a debug
**    log file called "debug.log" in the current working directory.
**    NOTE: The functions are only intended for C programmers. C++
**    programmers should use the "MakeDebugStream" instead.
*************************************************************************/

// Open a log file.
STDAPI_(HFILE) DbgLogOpen(LPCTSTR lpszFile, LPCTSTR lpszMode);

// Close the log file.
STDAPI_(void) DbgLogClose(HFILE fh);

// Write to debug log and debug window (used with cvw.exe or dbwin.exe).
STDAPI_(void) DbgLogOutputDebugString(HFILE fh, LPCTSTR lpsz);

// Write to debug log only.
STDAPI_(void) DbgLogWrite(HFILE fh, LPCTSTR lpsz);

// Write the current Date and Time to the log file.
STDAPI_(void) DbgLogTimeStamp(HFILE fh, LPCTSTR lpsz);

// Write a banner separater to the log to separate sections.
STDAPI_(void) DbgLogWriteBanner(HFILE fh, LPCTSTR lpsz);




/*
 *  STDDEBDECL macro - helper for debug declaration
 *
 */

#ifdef _DEBUG

        #define STDDEBDECL(ignore, classname ) implement CDebug:public IDebug { public: \
            CDebug( C##classname FAR * p##classname ) { m_p##classname = p##classname;} \
            ~CDebug(void) {} \
            STDMETHOD_(void, Dump)(IDebugStream FAR * pdbstm ); \
            STDMETHOD_(BOOL, IsValid)(BOOL fSuspicious ); \
            private: C##classname FAR* m_p##classname; }; \
            DECLARE_NC(C##classname, CDebug) \
            CDebug m_Debug;

    #define CONSTRUCT_DEBUG m_Debug(this),

#else //        _DEBUG

//      no debugging
#define STDDEBDECL(cclassname,classname)
#define CONSTRUCT_DEBUG

#endif  //      _DEBUG

#endif // __cplusplus

#endif // !_DEBUG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\urlmon\utils\ctime.inl ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

// Inlines for AFX.H

#ifdef _AFX_INLINE

// CTime and CTimeSpan
_AFX_INLINE CTimeSpan::CTimeSpan()
        { }
_AFX_INLINE CTimeSpan::CTimeSpan(time_t time)
        { m_timeSpan = time; }
_AFX_INLINE CTimeSpan::CTimeSpan(LONG lDays, int nHours, int nMins, int nSecs)
        { m_timeSpan = nSecs + 60* (nMins + 60* (nHours + 24* lDays)); }
_AFX_INLINE CTimeSpan::CTimeSpan(const CTimeSpan& timeSpanSrc)
        { m_timeSpan = timeSpanSrc.m_timeSpan; }
_AFX_INLINE const CTimeSpan& CTimeSpan::operator=(const CTimeSpan& timeSpanSrc)
        { m_timeSpan = timeSpanSrc.m_timeSpan; return *this; }
_AFX_INLINE LONG CTimeSpan::GetDays() const
        { return (LONG)(m_timeSpan / (24*3600L)); }
_AFX_INLINE LONG CTimeSpan::GetTotalHours() const
        { return (LONG)(m_timeSpan/3600); }
_AFX_INLINE int CTimeSpan::GetHours() const
        { return (int)(GetTotalHours() - GetDays()*24); }
_AFX_INLINE LONG CTimeSpan::GetTotalMinutes() const
        { return (LONG)(m_timeSpan/60); }
_AFX_INLINE int CTimeSpan::GetMinutes() const
        { return (int)(GetTotalMinutes() - GetTotalHours()*60); }
_AFX_INLINE LONG_PTR CTimeSpan::GetTotalSeconds() const
        { return m_timeSpan; }
_AFX_INLINE int CTimeSpan::GetSeconds() const
        { return (int)(GetTotalSeconds() - GetTotalMinutes()*60); }
_AFX_INLINE CTimeSpan CTimeSpan::operator-(CTimeSpan timeSpan) const
        { return CTimeSpan(m_timeSpan - timeSpan.m_timeSpan); }
_AFX_INLINE CTimeSpan CTimeSpan::operator+(CTimeSpan timeSpan) const
        { return CTimeSpan(m_timeSpan + timeSpan.m_timeSpan); }
_AFX_INLINE const CTimeSpan& CTimeSpan::operator+=(CTimeSpan timeSpan)
        { m_timeSpan += timeSpan.m_timeSpan; return *this; }
_AFX_INLINE const CTimeSpan& CTimeSpan::operator-=(CTimeSpan timeSpan)
        { m_timeSpan -= timeSpan.m_timeSpan; return *this; }
_AFX_INLINE BOOL CTimeSpan::operator==(CTimeSpan timeSpan) const
        { return m_timeSpan == timeSpan.m_timeSpan; }
_AFX_INLINE BOOL CTimeSpan::operator!=(CTimeSpan timeSpan) const
        { return m_timeSpan != timeSpan.m_timeSpan; }
_AFX_INLINE BOOL CTimeSpan::operator<(CTimeSpan timeSpan) const
        { return m_timeSpan < timeSpan.m_timeSpan; }
_AFX_INLINE BOOL CTimeSpan::operator>(CTimeSpan timeSpan) const
        { return m_timeSpan > timeSpan.m_timeSpan; }
_AFX_INLINE BOOL CTimeSpan::operator<=(CTimeSpan timeSpan) const
        { return m_timeSpan <= timeSpan.m_timeSpan; }
_AFX_INLINE BOOL CTimeSpan::operator>=(CTimeSpan timeSpan) const
        { return m_timeSpan >= timeSpan.m_timeSpan; }


_AFX_INLINE CTime::CTime()
        { }
_AFX_INLINE CTime::CTime(time_t time)
        { m_time = time; }
_AFX_INLINE CTime::CTime(const CTime& timeSrc)
        { m_time = timeSrc.m_time; }
_AFX_INLINE const CTime& CTime::operator=(const CTime& timeSrc)
        { m_time = timeSrc.m_time; return *this; }
_AFX_INLINE const CTime& CTime::operator=(time_t t)
        { m_time = t; return *this; }
_AFX_INLINE time_t CTime::GetTime() const
        { return m_time; }
_AFX_INLINE int CTime::GetYear() const
        { return (GetLocalTm(NULL)->tm_year) + 1900; }
_AFX_INLINE int CTime::GetMonth() const
        { return GetLocalTm(NULL)->tm_mon + 1; }
_AFX_INLINE int CTime::GetDay() const
        { return GetLocalTm(NULL)->tm_mday; }
_AFX_INLINE int CTime::GetHour() const
        { return GetLocalTm(NULL)->tm_hour; }
_AFX_INLINE int CTime::GetMinute() const
        { return GetLocalTm(NULL)->tm_min; }
_AFX_INLINE int CTime::GetSecond() const
        { return GetLocalTm(NULL)->tm_sec; }
_AFX_INLINE int CTime::GetDayOfWeek() const
        { return GetLocalTm(NULL)->tm_wday + 1; }
_AFX_INLINE CTimeSpan CTime::operator-(CTime time) const
        { return CTimeSpan(m_time - time.m_time); }
_AFX_INLINE CTime CTime::operator-(CTimeSpan timeSpan) const
        { return CTime(m_time - timeSpan.m_timeSpan); }
_AFX_INLINE CTime CTime::operator+(CTimeSpan timeSpan) const
        { return CTime(m_time + timeSpan.m_timeSpan); }
_AFX_INLINE const CTime& CTime::operator+=(CTimeSpan timeSpan)
        { m_time += timeSpan.m_timeSpan; return *this; }
_AFX_INLINE const CTime& CTime::operator-=(CTimeSpan timeSpan)
        { m_time -= timeSpan.m_timeSpan; return *this; }
_AFX_INLINE BOOL CTime::operator==(CTime time) const
        { return m_time == time.m_time; }
_AFX_INLINE BOOL CTime::operator!=(CTime time) const
        { return m_time != time.m_time; }
_AFX_INLINE BOOL CTime::operator<(CTime time) const
        { return m_time < time.m_time; }
_AFX_INLINE BOOL CTime::operator>(CTime time) const
        { return m_time > time.m_time; }
_AFX_INLINE BOOL CTime::operator<=(CTime time) const
        { return m_time <= time.m_time; }
_AFX_INLINE BOOL CTime::operator>=(CTime time) const
        { return m_time >= time.m_time; }

/////////////////////////////////////////////////////////////////////////////
#endif //_AFX_INLINE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\urlmon\utils\eqguid.cxx ===
#include  <windows.h>
#include  <ole2.h>
#include  <stdlib.h>

#ifndef _SYS_GUID_OPERATORS_
//+-------------------------------------------------------------------------
//
//  Function:	IsEqualGUID  (public)
//
//  Synopsis:	compares two guids for equality
//
//  Arguments:	[guid1]	- the first guid
//		[guid2] - the second guid to compare the first one with
//
//  Returns:	TRUE if equal, FALSE if not.
//
//--------------------------------------------------------------------------

extern "C" BOOL  __stdcall IsEqualGUID(GUID &guid1, GUID &guid2)
{
    return !memcmp((void *)&guid1,(void *)&guid2,sizeof(GUID));
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\urlmon\utils\dprintf.c ===
/***
*dprintf.c - print formatted to debug port
*
*	Copyright (c) 1985-1991, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	defines w4dprintf() - print formatted data to debug port
*	defines w4vdprintf() - print formatted output to debug port, get data
*			       from an argument ptr instead of explicit args.
*******************************************************************************/

#include "dprintf.h"		// function prototypes

#define _W4DPRINTF_
#include "printf.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\urlmon\utils\dprintf.h ===
//+---------------------------------------------------------------------------
//  Copyright (C) 1991, Microsoft Corporation.
//
//  File:       dprintf.h
//
//  Contents:   Debugging output routine function prototypes
//
//  Functions:  w4printf
//              w4vprintf
//              w4dprintf
//              w4vdprintf
//              
//  History:    18-Oct-91   vich        Created
//      
//----------------------------------------------------------------------------

#include <stdarg.h>
#ifdef unix
#include <windows.h>
#endif /* unix */
#ifdef __cplusplus
extern "C" {
#endif

#ifdef WIN32
int _cdecl w4printf(const char *format, ...);
int _cdecl w4vprintf(const char *format, va_list arglist);
#endif

int _cdecl w4dprintf(const char *format, ...);
int _cdecl w4vdprintf(const char *format, va_list arglist);

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\urlmon\utils\output.c ===
/***
*output.c - printf style output to a struct w4io
*
*   Copyright (c) 1989-1991, Microsoft Corporation. All rights reserved.
*
*Purpose:
*   This file contains the code that does all the work for the
*   printf family of functions.  It should not be called directly, only
*   by the *printf functions.  We don't make any assumtions about the
*   sizes of ints, longs, shorts, or long doubles, but if types do overlap, we
*   also try to be efficient.  We do assume that pointers are the same size
*   as either ints or longs.
*
*Revision History:
*   06-01-89  PHG   Module created
*   08-28-89  JCR   Added cast to get rid of warning (no object changes)
*   02-15-90  GJF   Fixed copyright
*   10-03-90  WHB   Defined LOCAL(x) to "static x" for local procedures
*   06-05-95  SVA   Added support for printing GUIDs.
*
*******************************************************************************/

#include <stdlib.h>
#include <limits.h>
#include <string.h>
#include <stdarg.h>
#include <basetsd.h>
#include "wchar.h"
#include "w4io.h"


/* this macro defines a function which is private and as fast as possible: */
/* for example, in C 6.0, it might be static _fastcall <type>. */
#define LOCAL(x) static x            // 100390--WHB

#define NOFLOATS                        // Win 4 doesn't need floating point

/* int/long/short/pointer sizes */

/* the following should be set depending on the sizes of various types */
// FLAT or LARGE model is assumed
#ifdef FLAT
#  define LONG_IS_INT        1       /* 1 means long is same size as int */
#  define SHORT_IS_INT       0       /* 1 means short is same size as int */
#ifdef _WIN64
#  define PTR_IS_INT         0       /* 1 means ptr is same size as int */
#else  // !_WIN64
#  define PTR_IS_INT         1       /* 1 means ptr is same size as int */
#endif // !_WIN64
#  define PTR_IS_LONG        0       /* 1 means ptr is same size as long */
#else // LARGE model
#  define LONG_IS_INT        0       /* 1 means long is same size as int */
#  define SHORT_IS_INT       1       /* 1 means short is same size as int */
#  define PTR_IS_INT         0       /* 1 means ptr is same size as int */
#  define PTR_IS_LONG        1       /* 1 means ptr is same size as long */
#endif
#define LONGDOUBLE_IS_DOUBLE 0       /* 1 means long double is same as double */

#if LONG_IS_INT
    #define get_long_arg(x) (long)get_int_arg(x)
#endif

#if PTR_IS_INT
    #define get_ptr_arg(x) (void *)get_int_arg(x)
#elif PTR_IS_LONG
    #define get_ptr_arg(x) (void *)get_long_arg(x)
#elif _WIN64
    #define get_ptr_arg(x) (void *)get_int64_arg(x)
#else 
    #error Size of pointer must be same as size of int or long
#endif

#ifndef NOFLOATS
/* These are "fake" double and long doubles to fool the compiler,
   so we don't drag in floating point. */
typedef struct {
    char x[sizeof(double)];
} DOUBLE;
typedef struct {
    char x[sizeof(long double)];
} LONGDOUBLE;
#endif


/* CONSTANTS */

//#define BUFFERSIZE CVTBUFSIZE     /* buffer size for maximum double conv */
#define BUFFERSIZE 20

/* flag definitions */
#define FL_SIGN       0x0001      /* put plus or minus in front */
#define FL_SIGNSP     0x0002      /* put space or minus in front */
#define FL_LEFT       0x0004      /* left justify */
#define FL_LEADZERO   0x0008      /* pad with leading zeros */
#define FL_LONG       0x0010      /* long value given */
#define FL_SHORT      0x0020      /* short value given */
#define FL_SIGNED     0x0040      /* signed data given */
#define FL_ALTERNATE  0x0080      /* alternate form requested */
#define FL_NEGATIVE   0x0100      /* value is negative */
#define FL_FORCEOCTAL 0x0200      /* force leading '0' for octals */
#define FL_LONGDOUBLE 0x0400      /* long double value given */
#define FL_WIDE       0x0800      /* wide character/string given */
#define FL_PTR64      0x1000      /* wide character/string given */

#ifdef _WIN64
#define FL_PTR        FL_PTR64
#else  // !_WIN64
#define FL_PTR        FL_LONG     /* as the processing specified originally... */
#endif // !_WIN64

/* state definitions */
enum STATE {
    ST_NORMAL,              /* normal state; outputting literal chars */
    ST_PERCENT,             /* just read '%' */
    ST_FLAG,                /* just read flag character */
    ST_WIDTH,               /* just read width specifier */
    ST_DOT,                 /* just read '.' */
    ST_PRECIS,              /* just read precision specifier */
    ST_SIZE,                /* just read size specifier */
    ST_TYPE                 /* just read type specifier */
};
#define NUMSTATES (ST_TYPE + 1)

/* character type values */
enum CHARTYPE {
    CH_OTHER,               /* character with no special meaning */
    CH_PERCENT,             /* '%' */
    CH_DOT,                 /* '.' */
    CH_STAR,                /* '*' */
    CH_ZERO,                /* '0' */
    CH_DIGIT,               /* '1'..'9' */
    CH_FLAG,                /* ' ', '+', '-', '#' */
    CH_SIZE,                /* 'h', 'l', 'L', 'N', 'F' */
    CH_TYPE                 /* type specifying character */
};

/* static data (read only, since we are re-entrant) */
char *nullstring = "(null)";    /* string to print on null ptr */

/* The state table.  This table is actually two tables combined into one. */
/* The lower nybble of each byte gives the character class of any         */
/* character; while the uper nybble of the byte gives the next state      */
/* to enter.  See the macros below the table for details.                 */
/*                                                                        */
/* The table is generated by maketab.c -- use the maketab program to make */
/* changes.                                                               */

/* Brief description of the table, since I can't find maketab.c - t-stevan     */
/* Each entry in form 0xYZ. Here Z is a character class used in the macro      */
/* find_char_class defined below. The character classes are defined in the     */
/* CHARTYPE enum. For example, 'I' maps to CH_TYPE. To find a particular entry */
/* Subtract the ASCI value for the space char from the character, and that is  */
/* the index to look up. The Y value is holds state transition information.    */
/* It is used in the macro find_next_state. */  
static char lookuptable[] = {
    0x06, 0x00, 0x00, 0x06, 0x00, 0x01, 0x00, 0x00,
    0x10, 0x00, 0x03, 0x06, 0x00, 0x06, 0x02, 0x10,
    0x04, 0x45, 0x45, 0x45, 0x05, 0x05, 0x05, 0x05,
    0x05, 0x35, 0x30, 0x00, 0x50, 0x00, 0x00, 0x00,
    0x00, 0x20, 0x28, 0x38, 0x50, 0x58, 0x07, 0x08,
    0x00, 0x38, 0x30, 0x30, 0x57, 0x50, 0x07, 0x00,
    0x00, 0x20, 0x20, 0x08, 0x00, 0x00, 0x00, 0x00,
    0x08, 0x60, 0x60, 0x60, 0x60, 0x60, 0x60, 0x00,
    0x00, 0x70, 0x70, 0x78, 0x78, 0x78, 0x78, 0x08,
    0x07, 0x08, 0x00, 0x00, 0x07, 0x00, 0x08, 0x08,
    0x08, 0x00, 0x00, 0x08, 0x00, 0x08, 0x00, 0x07,
    0x08
};

#define find_char_class(c)              \
        ((c) < ' ' || (c) > 'x' ?       \
            CH_OTHER                    \
        :                               \
            lookuptable[(c)-' '] & 0xF)

#define find_next_state(class, state)   \
        (lookuptable[(class) * NUMSTATES + (state)] >> 4)

#ifdef _WIN64
LOCAL(__int64) get_int64_arg(va_list *pargptr);
#endif 

#if !LONG_IS_INT
LOCAL(long) get_long_arg(va_list *pargptr);
#endif
LOCAL(int) get_int_arg(va_list *pargptr);
LOCAL(void) writestring(char *string,
                        int len,
                        struct w4io *f,
                        int *pcchwritten,
                        int fwide);

#ifndef NOFLOATS
/* extern float convert routines */
typedef int (* PFI)();
extern PFI _cfltcvt_tab[5];
#define _cfltcvt(a,b,c,d,e) (*_cfltcvt_tab[0])(a,b,c,d,e)
#define _cropzeros(a)       (*_cfltcvt_tab[1])(a)
#define _fassign(a,b,c)     (*_cfltcvt_tab[2])(a,b,c)
#define _forcdecpt(a)       (*_cfltcvt_tab[3])(a)
#define _positive(a)        (*_cfltcvt_tab[4])(a)
#define _cldcvt(a,b,c,d,e)  (*_cfltcvt_tab[5])(a,b,c,d,e)
#endif

/* Defines for printing out GUIDs */
#ifndef GUID_DEFINED
#define GUID_DEFINED
			/* size is 16 */
typedef struct  _GUID
    {
    unsigned long Data1;
    unsigned short Data2;
    unsigned short Data3;
    unsigned char Data4[ 8 ];
    }	GUID;

#endif // !GUID_DEFINED

#ifndef _REFGUID_DEFINED
#define _REFGUID_DEFINED
#define REFGUID             const GUID * const
#endif // !_REFGUID_DEFINED

/* This is actually one less than the normal GUIDSTR_MAX */
/* Because we don't tag on a NULL byte */
#define GUIDSTR_MAX (1+ 8 + 1 + 4 + 1 + 4 + 1 + 4 + 1 + 12 + 1 /* + 1 */)

/* Make sure our buffer size is big enough to hold a GUID */
#if BUFFERSIZE < GUIDSTR_MAX
#undef BUFFERSIZE
#define BUFFERSIZE GUIDSTR_MAX
#endif

/* Function used to write a GUID to a string */
int StrFromGUID(REFGUID rguid, char * lpsz, int cbMax);

/***
*int w4iooutput(f, format, argptr)
*
*Purpose:
*   Output performs printf style output onto a stream.  It is called by
*   printf/fprintf/sprintf/vprintf/vfprintf/vsprintf to so the dirty
*   work.  In multi-thread situations, w4iooutput assumes that the given
*   stream is already locked.
*
*   Algorithm:
*       The format string is parsed by using a finite state automaton
*       based on the current state and the current character read from
*       the format string.  Thus, looping is on a per-character basis,
*       not a per conversion specifier basis.  Once the format specififying
*       character is read, output is performed.
*
*Entry:
*   struct w4io *f   - stream for output
*   char *format   - printf style format string
*   va_list argptr - pointer to list of subsidiary arguments
*
*Exit:
*   Returns the number of characters written, or -1 if an output error
*   occurs.
*
*Exceptions:
*
*Notes: 
*       FIXFIX - This code does not handle I64 for __int64 and derived types.
*       FIXFIX - This code does not handle I64 10byte floats.
*       FIXFIX - This code has to be tested for IA64 8byte floats.
*
*******************************************************************************/

int _cdecl w4iooutput(struct w4io *f, const char *format, va_list argptr)
{
    int hexadd;         /* offset to add to number to get 'a'..'f' */
    char ch;            /* character just read */
    wchar_t wc;         /* wide character temp */
    wchar_t *pwc;       /* wide character temp pointer */
    int flags;          /* flag word -- see #defines above for flag values */
    enum STATE state;   /* current state */
    enum CHARTYPE chclass; /* class of current character */
    int radix;          /* current conversion radix */
    int charsout;       /* characters currently written so far, -1 = IO error */
    int fldwidth;       /* selected field with -- 0 means default */
    int fwide;
    int precision = -1;      /* selected precision -- -1 means default */
    char prefix[2];     /* numeric prefix -- up to two characters */
    int prefixlen;      /* length of prefix -- 0 means no prefix */
    int capexp;         /* non-zero = 'E' exponent signifiet, zero = 'e' */
    int no_output;      /* non-zero = prodcue no output for this specifier */
    char *text;         /* pointer text to be printed, not zero terminated */
    int textlen;        /* length of the text to be printed */
    char buffer[BUFFERSIZE];    /* buffer for conversions */

    charsout = 0;               /* no characters written yet */
    state = ST_NORMAL;          /* starting state */

    /* main loop -- loop while format character exist and no I/O errors */
    while ((ch = *format++) != '\0' && charsout >= 0) {
        chclass = find_char_class(ch);  /* find character class */
        state = find_next_state(chclass, state); /* find next state */

        /* execute code for each state */
        switch (state) {

        case ST_NORMAL:
            /* normal state -- just write character */
            f->writechar(ch, 1, f, &charsout);
            break;

        case ST_PERCENT:
            /* set default value of conversion parameters */
            prefixlen = fldwidth = no_output = capexp = 0;
            flags = 0;
            precision = -1;
            fwide = 0;
            break;

        case ST_FLAG:
            /* set flag based on which flag character */
            switch (ch) {
            case '-':
                flags |= FL_LEFT;       /* '-' => left justify */
                break;
            case '+':
                flags |= FL_SIGN;       /* '+' => force sign indicator */
                break;
            case ' ':
                flags |= FL_SIGNSP;     /* ' ' => force sign or space */
                break;
            case '#':
                flags |= FL_ALTERNATE;  /* '#' => alternate form */
                break;
            case '0':
                flags |= FL_LEADZERO;   /* '0' => pad with leading zeros */
                break;
            }
            break;

        case ST_WIDTH:
            /* update width value */
            if (ch == '*') {
                /* get width from arg list */
                fldwidth = get_int_arg(&argptr);
                if (fldwidth < 0) {
                    /* ANSI says neg fld width means '-' flag and pos width */
                    flags |= FL_LEFT;
                    fldwidth = -fldwidth;
                }
            }
            else {
                /* add digit to current field width */
                fldwidth = fldwidth * 10 + (ch - '0');
            }
            break;

        case ST_DOT:
            /* zero the precision, since dot with no number means 0
               not default, according to ANSI */
            precision = 0;
            break;

        case ST_PRECIS:
            /* update precison value */
            if (ch == '*') {
                /* get precision from arg list */
                precision = get_int_arg(&argptr);
                if (precision < 0)
                    precision = -1;     /* neg precision means default */
            }
            else {
                /* add digit to current precision */
                precision = precision * 10 + (ch - '0');
            }
            break;

        case ST_SIZE:
            /* just read a size specifier, set the flags based on it */
            switch (ch) {
#if !LONG_IS_INT
            case 'l':
                flags |= FL_LONG;   /* 'l' => long int */
                break;
#endif

#if !LONGDOUBLE_IS_DOUBLE
            case 'L':
                flags |= FL_LONGDOUBLE; /* 'L' => long double */
                break;
#endif

#if !SHORT_IS_INT
            case 'h':
                flags |= FL_SHORT;  /* 'h' => short int */
                break;
#endif
            case 'w':
                flags |= FL_WIDE;   /* 'w' => wide character */
                break;
            }
            break;

        case ST_TYPE:
            /* we have finally read the actual type character, so we       */
            /* now format and "print" the output.  We use a big switch     */
            /* statement that sets 'text' to point to the text that should */
            /* be printed, and 'textlen' to the length of this text.       */
            /* Common code later on takes care of justifying it and        */
            /* other miscellaneous chores.  Note that cases share code,    */
            /* in particular, all integer formatting is doen in one place. */
            /* Look at those funky goto statements!                        */

            switch (ch) {

            case 'c': {
                /* print a single character specified by int argument */
                wc = (wchar_t) get_int_arg(&argptr);    /* get char to print */
                * (wchar_t *) buffer = wc;
                text = buffer;
                textlen = 1;        /* print just a single character */
            }
            break;

            case 'S': {
                /* print a Counted String   */

                struct string {
                    short Length;
                    short MaximumLength;
                    char *Buffer;
                } *pstr;

                pstr = get_ptr_arg(&argptr);
                if (pstr == NULL || pstr->Buffer == NULL) {
                    /* null ptr passed, use special string */
                    text = nullstring;
                    textlen = strlen(text);
                    flags &= ~FL_WIDE;
                } else {
                    text = pstr->Buffer;
                    /* The length field is a count of bytes, not characters. */
                    if (flags & FL_WIDE)
                        textlen = pstr->Length / sizeof( wchar_t );
                    else
                        textlen = pstr->Length;
                    if (precision != -1)
                        textlen = min( textlen, precision );
                }

            }
            break;

            case 's': {
                /* print a string --                            */
                /* ANSI rules on how much of string to print:   */
                /*   all if precision is default,               */
                /*   min(precision, length) if precision given. */
                /* prints '(null)' if a null string is passed   */

                int i;
                char *p;       /* temps */

                text = get_ptr_arg(&argptr);
                if (text == NULL) {
                    /* null ptr passed, use special string */
                    text = nullstring;
                    flags &= ~FL_WIDE;
                }

                /* At this point it is tempting to use strlen(), but */
                /* if a precision is specified, we're not allowed to */
                /* scan past there, because there might be no null   */
                /* at all.  Thus, we must do our own scan.           */

                i = (precision == -1) ? INT_MAX : precision;

                /* scan for null upto i characters */
                if (flags & FL_WIDE) {
                    pwc = (wchar_t *) text;
                    while (i-- && (wc = *pwc) && (wc & 0x00ff)) {
                        ++pwc;
                        if (wc & 0xff00) {      // if high byte set,
                            break;              // error will be indicated
                        }
                    }
                    textlen = (int) (pwc - (wchar_t*)text);  /* length of string */
                } else {
                    p = text;
                    while (i-- && *p) {
                        ++p;
                    }
                    textlen = (int) (p - text);    /* length of the string */
                }
            }
            break;

            /* print a GUID */
            case 'I':
            {
                void *p;        /* temp */

                p = get_ptr_arg(&argptr);

			    if (p == NULL) 
			    {
			   		/* null ptr passed, use special string */
			   		text = nullstring;
					textlen = strlen(nullstring);
				}
				else
               	{
               		textlen = StrFromGUID(p, buffer, BUFFERSIZE); 
               		text = buffer;
				}
            }
            break;

            case 'n': {
                /* write count of characters seen so far into */
                /* short/int/long thru ptr read from args */

                void *p;            /* temp */

                p = get_ptr_arg(&argptr);

                /* store chars out into short/long/int depending on flags */
#if !LONG_IS_INT
                if (flags & FL_LONG)
                    *(long *)p = charsout;
                else
#endif

#if !SHORT_IS_INT
                if (flags & FL_SHORT)
                    *(short *)p = (short) charsout;
                else
#endif
                    *(int *)p = charsout;

                no_output = 1;              /* force no output */
            }
            break;

#ifndef NOFLOATS
            case 'E':
            case 'G':
                capexp = 1;                 /* capitalize exponent */
                ch += 'a' - 'A';            /* convert format char to lower */
                /* DROP THROUGH */
            case 'e':
            case 'f':
            case 'g':   {
                /* floating point conversion -- we call cfltcvt routines */
                /* to do the work for us.                                */
                flags |= FL_SIGNED;         /* floating point is signed conversion */
                text = buffer;              /* put result in buffer */
                flags &= ~FL_WIDE;          /* 8 bit string */

                /* compute the precision value */
                if (precision < 0)
                    precision = 6;      /* default precision: 6 */
                else if (precision == 0 && ch == 'g')
                    precision = 1;      /* ANSI specified */

#if !LONGDOUBLE_IS_DOUBLE
                /* do the conversion */
                if (flags & FL_LONGDOUBLE) {
                    _cldcvt(argptr, text, ch, precision, capexp);
                    va_arg(argptr, LONGDOUBLE);
                }
                else
#endif
                {
                    _cfltcvt(argptr, text, ch, precision, capexp);
                    va_arg(argptr, DOUBLE);
                }

                /* '#' and precision == 0 means force a decimal point */
                if ((flags & FL_ALTERNATE) && precision == 0)
                    _forcdecpt(text);

                /* 'g' format means crop zero unless '#' given */
                if (ch == 'g' && !(flags & FL_ALTERNATE))
                    _cropzeros(text);

                /* check if result was negative, save '-' for later */
                /* and point to positive part (this is for '0' padding) */
                if (*text == '-') {
                    flags |= FL_NEGATIVE;
                    ++text;
                }

                textlen = strlen(text);     /* compute length of text */
            }
            break;
#endif // NOFLOATS

            case 'd':
            case 'i':
                /* signed decimal output */
                flags |= FL_SIGNED;
                radix = 10;
                goto COMMON_INT;

            case 'u':
                radix = 10;
                goto COMMON_INT;

            case 'p':
                /* write a pointer */
                /* this is like an integer or long for Win32, __int64 for Win64 */
                /* except we force precision to pad with zeros and */
                /* output in big hex. */

                precision = 2 * sizeof(void *);     /* number of hex digits needed */
#if !PTR_IS_INT
                flags |= FL_PTR;       /* assume we're converting a long in the Win32 case */
#endif
                /* DROP THROUGH to hex formatting */

            case 'C':
            case 'X':
                /* unsigned upper hex output */
                hexadd = 'A' - '9' - 1;     /* set hexadd for uppercase hex */
                goto COMMON_HEX;

            case 'x':
                /* unsigned lower hex output */
                hexadd = 'a' - '9' - 1;     /* set hexadd for lowercase hex */
                /* DROP THROUGH TO COMMON_HEX */

            COMMON_HEX:
                radix = 16;
                if (flags & FL_ALTERNATE) {
                    /* alternate form means '0x' prefix */
                    prefix[0] = '0';
                    prefix[1] = (char)('x' - 'a' + '9' + 1 + hexadd);   /* 'x' or 'X' */
                    prefixlen = 2;
                }
                goto COMMON_INT;

            case 'o':
                /* unsigned octal output */
                radix = 8;
                if (flags & FL_ALTERNATE) {
                    /* alternate form means force a leading 0 */
                    flags |= FL_FORCEOCTAL;
                }
                /* DROP THROUGH to COMMON_INT */

            COMMON_INT: {
                /* This is the general integer formatting routine. */
                /* Basically, we get an argument, make it positive */
                /* if necessary, and convert it according to the */
                /* correct radix, setting text and textlen */
                /* appropriately. */

                ULONG_PTR number;   /* number to convert */
                int digit;          /* ascii value of digit */
                LONG_PTR l;         /* temp long value */

                /* 1. read argument into l, sign extend as needed */

#if !LONG_IS_INT
                if (flags & FL_LONG)
                    l = get_long_arg(&argptr);
                else
#endif

#if !SHORT_IS_INT
                if (flags & FL_SHORT) {
                    if (flags & FL_SIGNED)
                        l = (short) get_int_arg(&argptr); /* sign extend */
                    else
                        l = (unsigned short) get_int_arg(&argptr);    /* zero-extend*/
                }
                else
#endif

#ifdef _WIN64
// Sundown: if get_int64_arg() could be defined all the time, 
//          this 'ifdef _WIN64' could be removed.

                if (flags & FL_PTR64) {
                   l = get_int64_arg(&argptr); 
                }
                else 
#endif // _WIN64

                {
                    if (flags & FL_SIGNED)
                        l = get_int_arg(&argptr); /* sign extend */
                    else
                        l = (unsigned int) get_int_arg(&argptr);    /* zero-extend*/
                }

                /* 2. check for negative; copy into number */
                if ( (flags & FL_SIGNED) && l < 0) {
                    number = -l;
                    flags |= FL_NEGATIVE;   /* remember negative sign */
                }
                else {
                    number = l;
                }

                /* 3. check precision value for default; non-default */
                /*    turns off 0 flag, according to ANSI. */
                if (precision < 0)
                    precision = 1;              /* default precision */
                else
                    flags &= ~FL_LEADZERO;

                /* 4. Check if data is 0; if so, turn off hex prefix */
                if (number == 0)
                    prefixlen = 0;

                /* 5. Convert data to ASCII -- note if precision is zero */
                /*    and number is zero, we get no digits at all.       */

                text = &buffer[BUFFERSIZE-1];   // last digit at end of buffer
                flags &= ~FL_WIDE;              // 8 bit characters

                while (precision-- > 0 || number != 0) {
                    digit = (int)(number % radix) + '0';
                    number /= radix;            /* reduce number */
                    if (digit > '9') {
                        /* a hex digit, make it a letter */
                        digit += hexadd;
                    }
                    *text-- = (char)digit;      /* store the digit */
                }

                textlen = (int) (&buffer[BUFFERSIZE-1] - text); /* compute length of number */
                ++text;         /* text points to first digit now */


                /* 6. Force a leading zero if FORCEOCTAL flag set */
                if ((flags & FL_FORCEOCTAL) && (text[0] != '0' || textlen == 0)) {
                    *--text = '0';
                    ++textlen;          /* add a zero */
                }
            }
            break;
            }

            /* At this point, we have done the specific conversion, and */
            /* 'text' points to text to print; 'textlen' is length.  Now we */
            /* justify it, put on prefixes, leading zeros, and then */
            /* print it. */

            if (!no_output) {
                int padding;    /* amount of padding, negative means zero */

                if (flags & FL_SIGNED) {
                    if (flags & FL_NEGATIVE) {
                        /* prefix is a '-' */
                        prefix[0] = '-';
                        prefixlen = 1;
                    }
                    else if (flags & FL_SIGN) {
                        /* prefix is '+' */
                        prefix[0] = '+';
                        prefixlen = 1;
                    }
                    else if (flags & FL_SIGNSP) {
                        /* prefix is ' ' */
                        prefix[0] = ' ';
                        prefixlen = 1;
                    }
                }

                /* calculate amount of padding -- might be negative, */
                /* but this will just mean zero */
                padding = fldwidth - textlen - prefixlen;

                /* put out the padding, prefix, and text, in the correct order */

                if (!(flags & (FL_LEFT | FL_LEADZERO))) {
                    /* pad on left with blanks */
                    f->writechar(' ', padding, f, &charsout);
                }

                /* write prefix */
                writestring(prefix, prefixlen, f, &charsout, 0);

                if ((flags & FL_LEADZERO) && !(flags & FL_LEFT)) {
                    /* write leading zeros */
                    f->writechar('0', padding, f, &charsout);
                }

                /* write text */
                writestring(text, textlen, f, &charsout, flags & FL_WIDE);

                if (flags & FL_LEFT) {
                    /* pad on right with blanks */
                    f->writechar(' ', padding, f, &charsout);
                }

                /* we're done! */
            }
            break;
        }
    }

    return charsout;        /* return value = number of characters written */
}


/***
*int get_int_arg(va_list pargptr)
*
*Purpose:
*   Gets an int argument off the given argument list and updates *pargptr.
*
*Entry:
*   va_list pargptr - pointer to argument list; updated by function
*
*Exit:
*   Returns the integer argument read from the argument list.
*
*Exceptions:
*
*******************************************************************************/

LOCAL(int) get_int_arg(va_list *pargptr)
{
    return va_arg(*pargptr, int);
}

/***
*long get_long_arg(va_list pargptr)
*
*Purpose:
*   Gets an long argument off the given argument list and updates pargptr.
*
*Entry:
*   va_list pargptr - pointer to argument list; updated by function
*
*Exit:
*   Returns the long argument read from the argument list.
*
*Exceptions:
*
*******************************************************************************/


#if !LONG_IS_INT
LOCAL(long) get_long_arg(va_list *pargptr)
{
    return va_arg(*pargptr, long);
}
#endif

#ifdef _WIN64
LOCAL(__int64) get_int64_arg (
    va_list *pargptr
    )
{
    return va_arg(*pargptr, __int64);
}
#endif

/***
*void writestring(char *string, int len, struct w4io *f, int *pcchwritten, int fwide)
*
*Purpose:
*   Writes a string of the given length to the given file.  If no error occurs,
*   then *pcchwritten is incremented by len; otherwise, *pcchwritten is set
*   to -1.  If len is negative, it is treated as zero.
*
*Entry:
*   char *string     - string to write (NOT null-terminated)
*   int len          - length of string
*   struct w4io *f   - file to write to
*   int *pcchwritten - pointer to integer to update with total chars written
*   int fwide        - wide character flag
*
*Exit:
*   No return value.
*
*Exceptions:
*
*******************************************************************************/

LOCAL(void) writestring(
        char *string,
        int len,
        struct w4io *f,
        int *pcchwritten,
        int fwide)
{
    wchar_t *pwc;

    //printf("string: str=%.*s, len=%d, cch=%d, f=%d\n", len, string, len, *pcchwritten, fwide);
    if (fwide) {
        pwc = (wchar_t *) string;
        while (len-- > 0) {
            if (*pwc & 0xff00) {
                f->writechar('^', 1, f, pcchwritten);
            }
            f->writechar((char) *pwc++, 1, f, pcchwritten);
        }
    } else {
        while (len-- > 0) {
            f->writechar(*string++, 1, f, pcchwritten);
        }
    }
}


const wchar_t a_wcDigits[] = L"0123456789ABCDEF";

//+---------------------------------------------------------------------------
//
//  Function:   FormatHexNum
//
//  Synopsis:   Given a value, and a count of characters, translate
//		the value into a hex string. This is the ANSI version
//
//  Arguments:  [ulValue] -- Value to convert
//		[chChars] -- Number of characters to format
//		[pchStr] -- Pointer to output buffer
//
//  Requires:   pwcStr must be valid for chChars
//
//  History:    5-31-95   t-stevan  Copied and Modified for use in debug output function
//
//  Notes:
//
//----------------------------------------------------------------------------
void FormatHexNum( unsigned long ulValue, unsigned long chChars, char *pchStr)
{
	while(chChars--)
	{
		pchStr[chChars] = (char) a_wcDigits[ulValue & 0xF];
		ulValue = ulValue >> 4;
	}
}

//+-------------------------------------------------------------------------
//
//  Function:   StrFromGUID     (private)
//
//  Synopsis:   Converts a GUID into a string (duh!)
//
//  Arguments:  [rguid] - the guid to convert
//              [lpszy] - buffer to hold the results
//              [cbMax] - sizeof the buffer
//
//  Returns:    amount of data copied to lpsz if successful
//              0 if buffer too small.
//
//--------------------------------------------------------------------------

int StrFromGUID(REFGUID rguid, char * lpsz, int cbMax)  // internal
{
    if (cbMax < GUIDSTR_MAX)
	return 0;


//   Make the GUID into"{%08lX-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X}",

    *lpsz++ = '{';
    FormatHexNum( rguid->Data1, 8 , lpsz);
    lpsz += 8;
    *lpsz++ = '-';

    FormatHexNum( rguid->Data2, 4 , lpsz);
    lpsz += 4;
    *lpsz++ = '-';

    FormatHexNum( rguid->Data3, 4 , lpsz);
    lpsz += 4;
    *lpsz++ = '-';

    FormatHexNum( rguid->Data4[0], 2 , lpsz);
    lpsz += 2;
    FormatHexNum( rguid->Data4[1], 2 , lpsz);
    lpsz += 2;
    *lpsz++ = '-';

    FormatHexNum( rguid->Data4[2], 2 , lpsz);
    lpsz += 2;
    FormatHexNum( rguid->Data4[3], 2 , lpsz);
    lpsz += 2;
    FormatHexNum( rguid->Data4[4], 2 , lpsz);
    lpsz += 2;
    FormatHexNum( rguid->Data4[5], 2 , lpsz);
    lpsz += 2;
    FormatHexNum( rguid->Data4[6], 2 , lpsz);
    lpsz += 2;
    FormatHexNum( rguid->Data4[7], 2 , lpsz);
    lpsz += 2;

    *lpsz++ = '}';
    /* We don't want to tag on a NULL char because we don't need to print one out *\
    /* *lpsz = 0; */


    return GUIDSTR_MAX;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\urlmon\utils\inetdbg.cxx ===
/*++

Module Name:

    inetdbg.cxx

Abstract:

    Debugging functions for internet DLL

Author:

    Venkatraman Kudallur (venkatk)
    ( Ripped off from wininet )
    
Revision History:

    3-10-2000 venkatk
    Created
--*/

// !!!!!!!!!!!!!!!!!!!!!!!!!!!
/* Exchanging the order of these 2 gives following error:
    Linking Executable - dll\daytona\objd\i386\urlmon.dll for i386
dll\daytona\utils.lib(inetdbg.obj) : error LNK2001: unresolved external 
symbol "
int __cdecl _sprintf(char *,char *,char *)" (?_sprintf@@YAHPAD00@Z)
dll\daytona\objd\i386\urlmon.dll() : error LNK1120: 1 unresolved externals
dll\daytona\binplace() : error BNP0000: Unable to place file objd\i386\urlmon.
dll - exiting.
 */
 // !!!!!!!!!!!!!!!!!!!!!!!!!! Why?

#include <urlint.h>
#include "rprintf.h"
#include "registry.h"
#include "tls.h"
#include <imagehlp.h>
#include <wininet.h>  //only for InternetVersionInfo!
#include <ieverp.h>  //for version strings
 
#ifdef ENABLE_DEBUG

//from macros.h
#define PRIVATE
#define PUBLIC

//from util.cxx

DWORD
GetTickCountWrap()
{
#ifdef DEBUG_GETTICKCOUNT
    static BOOL fInit = FALSE;
    static DWORD dwDelta = 0;
    static DWORD dwBasis = 0;

    if (!fInit)
    {
        HKEY clientKey;
        if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                 TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings"),
                                 0, // reserved
                                 KEY_QUERY_VALUE,
                                 &clientKey))
        {
            DWORD dwSize = sizeof(dwDelta);
            RegQueryValueEx(clientKey, "RollOverDelta", NULL, NULL, (LPBYTE)&dwDelta, &dwSize);
        }
        dwBasis = GetTickCount();
        fInit = TRUE;
    }
    DWORD dwResult = GetTickCount() - dwBasis + dwDelta;
    return dwResult;
#else
    return GetTickCount();
#endif
}


//forward declaration
BOOL
InternetDebugGetLocalTime(
    OUT SYSTEMTIME * pstLocalTime,
    OUT DWORD      * pdwMicroSec
);

//from debugmem.h
#if defined(USE_DEBUG_MEMORY)
    //no debugmem capabilities yet.
    #define ALLOCATOR(Flags, Size) \
        LocalAlloc(Flags, Size)
    #define DEALLOCATOR(hLocal) \
        LocalFree(hLocal)
#else //Retail
    #if USE_PRIVATE_HEAP_IN_RETAIL
        #error no other memory allocation schemes defined
    #else
        #ifndef WININET_UNIX_PRVATE_ALLOCATOR
            #define ALLOCATOR(Flags, Size) \
                LocalAlloc(Flags, Size)
            #define DEALLOCATOR(hLocal) \
                LocalFree(hLocal)
        #else
            HLOCAL IEUnixLocalAlloc(UINT wFlags, UINT wBytes);
            HLOCAL IEUnixLocalFree(HLOCAL hMem);

            #define ALLOCATOR(Flags, Size)\
                IEUnixLocalAlloc(Flags, Size)
            #define DEALLOCATOR(hLocal)\
                IEUnixLocalFree(hLocal)
        #endif //WININET_UNIX_PRVATE_ALLOCATOR
    #endif //USE_PRIVATE_HEAP_IN_RETAIL
#endif //defined(USE_DEBUG_MEMORY)

//from debugmem.h
#define ALLOCATE_ZERO_MEMORY(Size) \
    ALLOCATE_MEMORY(LPTR, (Size))
#define ALLOCATE_MEMORY(Flags, Size) \
    ALLOCATOR((UINT)(Flags), (UINT)(Size))
#define FREE_MEMORY(hLocal) \
    DEALLOCATOR((HLOCAL)(hLocal))

//from macros.h
#define NEW(object) \
    (object FAR *)ALLOCATE_ZERO_MEMORY(sizeof(object))
#define DEL(object) \
    FREE_MEMORY(object)

//from Nttypes.h
#define ARGUMENT_PRESENT(ArgumentPointer)    (\
    (CHAR *)(ArgumentPointer) != (CHAR *)(NULL) )

#define INTERNET_SETTINGS_KEY       "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Internet Settings"

//from globals.cxx
#if !defined(VER_PRODUCTBUILD)
#define VER_PRODUCTBUILD    0
#endif

PRIVATE DWORD InternetBuildNumber = VER_PRODUCTBUILD;

#if !defined(VER_PRODUCTVERSION_STRING)
#define VER_PRODUCTVERSION_STRING  " "
#endif

#if !defined(URLMON_MAJOR_VERSION)
#define URLMON_MAJOR_VERSION   1
#endif

#if !defined(URLMON_MINOR_VERSION)
#define URLMON_MINOR_VERSION   2
#endif

PRIVATE INTERNET_VERSION_INFO InternetVersionInfo = {
    URLMON_MAJOR_VERSION,
    URLMON_MINOR_VERSION
};

#if 0
#endif //0

//
// private manifests
//
#define SWITCH_VARIABLE_NAME        "UrlmonDebugging"
#define CONTROL_VARIABLE_NAME       "UrlmonControl"
#define CATEGORY_VARIABLE_NAME      "UrlmonCategory"
#define ERROR_VARIABLE_NAME         "UrlmonError"
#define BREAK_VARIABLE_NAME         "UrlmonBreak"
#define DEFAULT_LOG_VARIABLE_NAME   "UrlmonLog"
#define CHECK_LIST_VARIABLE_NAME    "UrlmonCheckSerializedList"
#define LOG_FILE_VARIABLE_NAME      "UrlmonLogFile"
#define INDENT_VARIABLE_NAME        "UrlmonLogIndent"
#define NO_PID_IN_LOG_FILENAME      "UrlmonNoPidInLogFilename"
#define NO_EXCEPTION_HANDLER        "UrlmonNoExceptionHandler"

#define DEFAULT_LOG_FILE_NAME       "URLMON.LOG"

#define ENVIRONMENT_VARIABLE_BUFFER_LENGTH  80

#define PRINTF_STACK_BUFFER_LENGTH  4096

//
// private macros
//

#define CASE_OF(constant)   case constant: return # constant

//
// private prototypes
//

PRIVATE
VOID
InternetDebugPrintString(
    IN LPSTR String
    );

PRIVATE
VOID
InternetGetDebugVariableString(
    IN LPSTR lpszVariableName,
    OUT LPSTR lpszVariable,
    IN DWORD dwVariableLen
    );

PRIVATE
LPSTR
ExtractFileName(
    IN LPSTR Module,
    OUT LPSTR Buf
    );

PRIVATE
LPSTR
SetDebugPrefix(
    IN LPSTR Buffer
    );

//
//
// these variables are employed in macros, so must be public
//

PUBLIC DWORD InternetDebugErrorLevel = DBG_ERROR;
PUBLIC DWORD InternetDebugControlFlags = DBG_NO_DEBUG;
PUBLIC DWORD InternetDebugCategoryFlags = 0;
PUBLIC DWORD InternetDebugBreakFlags = 0;

//
// these variables are only accessed in this module, so can be private
//

PRIVATE int InternetDebugIndentIncrement = 2;
PRIVATE HANDLE InternetDebugFileHandle = INVALID_HANDLE_VALUE;
PRIVATE char InternetDebugFilename[MAX_PATH + 1] = DEFAULT_LOG_FILE_NAME;
PRIVATE BOOL InternetDebugEnabled = TRUE;
PRIVATE DWORD InternetDebugStartTime = 0;

extern "C" {
#if defined(UNIX) && defined(ux10)
/* Temporary fix for Apogee Compiler bug on HP only */
extern BOOL fCheckEntryOnList;
#else
BOOL fCheckEntryOnList;
#endif /* UNIX */
}

//
// high frequency performance counter globals
//

PRIVATE LONGLONG ftInit;  // initial local time
PRIVATE LONGLONG pcInit;  // initial perf counter
PRIVATE LONGLONG pcFreq;  // perf counter frequency

//
// functions
//


VOID
InternetDebugInitialize(
    VOID
    )

/*++

Routine Description:

    reads environment INETDBG flags and opens debug log file if required

Arguments:

    None.

Return Value:

    None.

--*/

{
    //
    // ensure registry key open
    //

    OpenInternetSettingsKey();

    //
    // record the starting tick count for cumulative deltas
    //

    InternetDebugStartTime = GetTickCountWrap();

    if (QueryPerformanceFrequency ((LARGE_INTEGER *) &pcFreq) && pcFreq) {

        QueryPerformanceCounter ((LARGE_INTEGER *) &pcInit);
        SYSTEMTIME st;
        GetLocalTime (&st);
        SystemTimeToFileTime (&st, (FILETIME *) &ftInit);
    }

    // check see if there are any debug variable overrides in the environment
    // or the registry. If "UrlmonLog=<!0>" is set then we use the flags that
    // are most commonly used to generate URLMON.LOG, with no console or
    // debugger output. We allow the other variables to be overridden
    //

    BOOL defaultDebugVariables = FALSE;

    InternetGetDebugVariable(DEFAULT_LOG_VARIABLE_NAME, (LPDWORD)&defaultDebugVariables);
    if (defaultDebugVariables) {
        InternetDebugEnabled = TRUE;
        InternetDebugControlFlags = INTERNET_DEBUG_CONTROL_DEFAULT;
        InternetDebugCategoryFlags = INTERNET_DEBUG_CATEGORY_DEFAULT;
        InternetDebugErrorLevel = INTERNET_DEBUG_ERROR_LEVEL_DEFAULT;
        InternetDebugBreakFlags = 0;
    }
    InternetGetDebugVariable(SWITCH_VARIABLE_NAME, (LPDWORD)&InternetDebugEnabled);
    InternetGetDebugVariable(CONTROL_VARIABLE_NAME, &InternetDebugControlFlags);
    InternetGetDebugVariable(CATEGORY_VARIABLE_NAME, &InternetDebugCategoryFlags);
    InternetGetDebugVariable(ERROR_VARIABLE_NAME, &InternetDebugErrorLevel);
    InternetGetDebugVariable(BREAK_VARIABLE_NAME, &InternetDebugBreakFlags);
    InternetGetDebugVariable(CHECK_LIST_VARIABLE_NAME, (LPDWORD)&fCheckEntryOnList);
    InternetGetDebugVariable(INDENT_VARIABLE_NAME, (LPDWORD)&InternetDebugIndentIncrement);
    InternetGetDebugVariableString(LOG_FILE_VARIABLE_NAME,
                                   InternetDebugFilename,
                                   sizeof(InternetDebugFilename)
                                   );
                                   
    DWORD InternetNoPidInLogFilename=0;
    InternetGetDebugVariable(NO_PID_IN_LOG_FILENAME, &InternetNoPidInLogFilename);

    if (!InternetNoPidInLogFilename)
    {
        char szFullPathName[MAX_PATH + 1];
        LPSTR szExecutableName;

        if (GetModuleFileName(NULL, szFullPathName, sizeof(szFullPathName))) 
        {
            szExecutableName = strrchr(szFullPathName, '\\');
            if (szExecutableName != NULL)
                ++szExecutableName;
            else
                szExecutableName = szFullPathName;
        } 
        else
            szExecutableName = "";

        DWORD cbFilenameLen = strlen(InternetDebugFilename);
        //                          ".xxxxx.yyy.#########.LOG" 
        DWORD cbProcessInfoLenMax = 1 + strlen(szExecutableName) + 1 + 9 + 1 + 3;

        if (cbProcessInfoLenMax < sizeof(InternetDebugFilename))
            wsprintf(InternetDebugFilename+cbFilenameLen, ".%s.%u.LOG", 
                szExecutableName,
                GetCurrentProcessId());
    };

    if ((InternetDebugIndentIncrement < 0) || (InternetDebugIndentIncrement > 32)) {
        InternetDebugIndentIncrement = 2;
    }

    //
    // quit now if debugging is disabled
    //

    if (!InternetDebugEnabled) {
        InternetDebugControlFlags |= (DBG_NO_DEBUG | DBG_NO_DATA_DUMP);
        return;
    }

    //
    // if we want to write debug output to file, open URLMON.LOG in the current
    // directory. Open it in text mode, for write-only (by this process)
    //

    if (InternetDebugControlFlags & DBG_TO_FILE) {
        if (!InternetReopenDebugFile(InternetDebugFilename)) {
            InternetDebugControlFlags &= ~DBG_TO_FILE;
        }
    }
}


VOID
InternetDebugTerminate(
    VOID
    )

/*++

Routine Description:

    Performs any required debug termination

Arguments:

    None.

Return Value:

    None.

--*/

{
    //moved into this function bcos we don't this only for debugging.
    CloseInternetSettingsKey();
 
    if (InternetDebugControlFlags & DBG_TO_FILE) {
        InternetCloseDebugFile();
    }
    InternetDebugControlFlags = DBG_NO_DEBUG;
}

BOOL
InternetOpenDebugFile(
    VOID
    )

/*++

Routine Description:

    Opens debug filename if not already open. Use InternetDebugFilename

Arguments:

    None.

Return Value:

    BOOL
        TRUE    - file was opened

        FALSE   - file not opened (already open or error)

--*/

{
    if (InternetDebugFileHandle == INVALID_HANDLE_VALUE) {
        InternetDebugFileHandle = CreateFile(
            InternetDebugFilename,
            GENERIC_WRITE,
            FILE_SHARE_READ,
            NULL,  // lpSecurityAttributes
            (InternetDebugControlFlags & DBG_APPEND_FILE)
                ? OPEN_ALWAYS
                : CREATE_ALWAYS,
            FILE_ATTRIBUTE_NORMAL
            | FILE_FLAG_SEQUENTIAL_SCAN
            | ((InternetDebugControlFlags & DBG_FLUSH_OUTPUT)
                ? FILE_FLAG_WRITE_THROUGH
                : 0),
            NULL
            );
        return InternetDebugFileHandle != INVALID_HANDLE_VALUE;
    }
    return FALSE;
}


BOOL
InternetReopenDebugFile(
    IN LPSTR Filename
    )

/*++

Routine Description:

    (Re)opens a debug log file. Closes the current one if it is open

Arguments:

    Filename    - new file to open

Return Value:

    None.

--*/

{
    if (InternetDebugFileHandle != INVALID_HANDLE_VALUE) {
        InternetCloseDebugFile();
    }
    if (Filename && *Filename) {
        InternetDebugFileHandle = CreateFile(
            Filename,
            GENERIC_WRITE,
            FILE_SHARE_READ,
            NULL,  // lpSecurityAttributes
            (InternetDebugControlFlags & DBG_APPEND_FILE)
                ? OPEN_ALWAYS
                : CREATE_ALWAYS,
            FILE_ATTRIBUTE_NORMAL
            | FILE_FLAG_SEQUENTIAL_SCAN
            | ((InternetDebugControlFlags & DBG_FLUSH_OUTPUT)
                ? FILE_FLAG_WRITE_THROUGH
                : 0),
            NULL
            );

        //
        // put our start info in the log file. Mainly useful when we're
        // appending to the file
        //

        if (InternetDebugFileHandle != INVALID_HANDLE_VALUE) {

            SYSTEMTIME currentTime;
            char filespec[MAX_PATH + 1];
            LPSTR filename;

            if (GetModuleFileName(NULL, filespec, sizeof(filespec))) {
                filename = strrchr(filespec, '\\');
                if (filename != NULL) {
                    ++filename;
                } else {
                    filename = filespec;
                }
            } else {
                filename = "";
            }

            InternetDebugGetLocalTime(&currentTime, NULL);

            InternetDebugPrintf("\n"
                                ">>>> Urlmon Version %d.%d Build %s.%d " __DATE__ " " __TIME__ "\n"
                                ">>>> Process %s [%d (%#x)] started at %02d:%02d:%02d.%03d %02d/%02d/%d\n",
                                InternetVersionInfo.dwMajorVersion,
                                InternetVersionInfo.dwMinorVersion,
                                VER_PRODUCTVERSION_STRING,
                                InternetBuildNumber,
                                filename,
                                GetCurrentProcessId(),
                                GetCurrentProcessId(),
                                currentTime.wHour,
                                currentTime.wMinute,
                                currentTime.wSecond,
                                currentTime.wMilliseconds,
                                currentTime.wMonth,
                                currentTime.wDay,
                                currentTime.wYear
                                );

            InternetDebugPrintf(">>>> Command line = %q\n", GetCommandLine());

            InternetDebugPrintf("\n"
                                "     InternetDebugErrorLevel      = %s [%d]\n"
                                "     InternetDebugControlFlags    = %#08x\n"
                                "     InternetDebugCategoryFlags   = %#08x\n"
                                "     InternetDebugBreakFlags      = %#08x\n"
                                "     InternetDebugIndentIncrement = %d\n"
                                "\n",
                                (InternetDebugErrorLevel == DBG_INFO)       ? "Info"
                                : (InternetDebugErrorLevel == DBG_WARNING)  ? "Warning"
                                : (InternetDebugErrorLevel == DBG_ERROR)    ? "Error"
                                : (InternetDebugErrorLevel == DBG_FATAL)    ? "Fatal"
                                : (InternetDebugErrorLevel == DBG_ALWAYS)   ? "Always"
                                : "?",
                                InternetDebugErrorLevel,
                                InternetDebugControlFlags,
                                InternetDebugCategoryFlags,
                                InternetDebugBreakFlags,
                                InternetDebugIndentIncrement
                                );
            return TRUE;
        }
    }
    return FALSE;
}


VOID
InternetCloseDebugFile(
    VOID
    )

/*++

Routine Description:

    Closes the current debug log file

Arguments:

    None.

Return Value:

    None.

--*/

{
    if (InternetDebugFileHandle != INVALID_HANDLE_VALUE) {
        if (InternetDebugControlFlags & DBG_FLUSH_OUTPUT) {
            InternetFlushDebugFile();
        }
        CloseHandle(InternetDebugFileHandle);
        InternetDebugFileHandle = INVALID_HANDLE_VALUE;
    }
}


VOID
InternetFlushDebugFile(
    VOID
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    None.

Return Value:

    None.

--*/

{
    if (InternetDebugFileHandle != INVALID_HANDLE_VALUE) {
        FlushFileBuffers(InternetDebugFileHandle);
    }
}


VOID
InternetDebugSetControlFlags(
    IN DWORD dwFlags
    )

/*++

Routine Description:

    Sets debug control flags

Arguments:

    dwFlags - flags to set

Return Value:

    None.

--*/

{
    InternetDebugControlFlags |= dwFlags;
}


VOID
InternetDebugResetControlFlags(
    IN DWORD dwFlags
    )

/*++

Routine Description:

    Resets debug control flags

Arguments:

    dwFlags - flags to reset

Return Value:

    None.

--*/

{
    InternetDebugControlFlags &= ~dwFlags;
}


VOID
InternetDebugEnter(
    IN DWORD Category,
    IN DEBUG_FUNCTION_RETURN_TYPE ReturnType,
    IN LPCSTR Function,
    IN LPCSTR ParameterList OPTIONAL,
    IN ...
    )

/*++

Routine Description:

    Creates an INTERNET_DEBUG_RECORD for the current function and adds it to
    the per-thread (debug) call-tree

Arguments:

    Category        - category flags, e.g. DBG_FTP

    ReturnType      - type of data it returns

    Function        - name of the function. Must be global, static string

    ParameterList   - string describing parameters to function, or NULL if none

    ...             - parameters to function

Return Value:

    None.

--*/

{
    if (InternetDebugControlFlags & DBG_NO_DEBUG) {
        return;
    }

    HRESULT hr = S_OK;

    CUrlMkTls tls(hr); // hr passed by reference!
    if (FAILED(hr))
        return;

    LPDEBUG_URLMON_FUNC_RECORD pCurrentFunction;
    pCurrentFunction = NEW(DEBUG_URLMON_FUNC_RECORD);

    pCurrentFunction->Stack = tls->Stack;
    pCurrentFunction->Category = Category;
    pCurrentFunction->ReturnType = ReturnType;
    pCurrentFunction->Function = Function;
    pCurrentFunction->LastTime = GetTickCountWrap();
    tls->Stack = pCurrentFunction;
    ++tls->CallDepth;

    //
    // if the function's category (FTP, GOPHER, HTTP) is selected in the
    // category flags, then we dump the function entry information
    //

    if (InternetDebugCategoryFlags & Category) {

        char buf[4096];
        LPSTR bufptr;

        bufptr = buf;
        bufptr += rsprintf(bufptr, "%s(", Function);
        __try
        {
            if (ARGUMENT_PRESENT(ParameterList)) {

                va_list parms;

                va_start(parms, ParameterList);
                bufptr += _sprintf(bufptr, (char*)ParameterList, parms);
                va_end(parms);
            }
            rsprintf(bufptr, ")\n");
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            if (((DWORD(bufptr-buf) < (sizeof("*********Exception occured!!\n")+1)))
                && (bufptr>buf))
                wsprintf(bufptr, "*********Exception occured!!\n");
            else
                wsprintf(buf, "*********Exception occured!!\n");
        }
        InternetDebugPrintString(buf);

        //
        // only increase the indentation if we will display debug information
        // for this category
        //

        tls->IndentIncrement += InternetDebugIndentIncrement;
    }
}


VOID
InternetDebugLeave(
    IN DWORD_PTR Variable,
    IN LPCSTR Filename,
    IN DWORD LineNumber
    )

/*++

Routine Description:

    Destroys the INTERNET_DEBUG_RECORD for the current function and dumps info
    about what the function is returning, if requested to do so

Arguments:

    Variable    - variable containing value being returned by function

    Filename    - name of file where DEBUG_LEAVE() invoked

    LineNumber  - and line number in Filename

Return Value:

    None.

--*/

{
    LPSTR format;
    LPSTR errstr;
    BOOL noVar;
    char formatBuf[128];
    DWORD lastError;
    char hexnumBuf[15];

    if (InternetDebugControlFlags & DBG_NO_DEBUG) {
        return;
    }

    //
    // seems that something in this path can nuke the last error, so we must
    // refresh it
    //

    lastError = GetLastError();

    HRESULT hr = S_OK;

    CUrlMkTls tls(hr); // hr passed by reference!
    if (FAILED(hr))
        return;

    LPDEBUG_URLMON_FUNC_RECORD pCurrentFunction = tls->Stack;

    if (!pCurrentFunction) {
        return;
    }

    //
    // we are about to output a diagnostic message to the debug log, debugger,
    // or console. First check that we are required to display messages at
    // this level. The level for function ENTER and LEAVE is INFO
    //

    {

        //
        // only display the string and reduce the indent if we are requested
        // for information about this category
        //

        errstr = NULL;
        noVar = FALSE;
        if (InternetDebugCategoryFlags & pCurrentFunction->Category) {
            switch (pCurrentFunction->ReturnType) {
            case None:
                format = "%s() returning VOID";
                noVar = TRUE;
                break;

            case Bool:
                Variable = (DWORD_PTR)(Variable ? "TRUE" : "FALSE");

                //
                // *** FALL THROUGH ***
                //

            case String:
                format = "%s() returning %s";
                break;

            case Int:
                format = "%s() returning %d";
                break;

            case Dword:
                format = "%s() returning %u";
                break;

            case Hresult:
                format = "%s() returning %u";
                errstr = InternetMapError((DWORD)Variable);
                if (errstr != NULL) {
                    if (*errstr == '?') {
                        rsprintf(hexnumBuf, "%#x", Variable);
                        errstr = hexnumBuf;
                        format = "%s() returning %u [?] (%s)";
                    } else {
                        format = "%s() returning %u [%s]";
                    }
                }
                break;
            
            case Handle:
            case Pointer:
                if (Variable == 0) {
                    format = "%s() returning NULL";
                    noVar = TRUE;
                } else {
                    if (pCurrentFunction->ReturnType == Handle) {
                        format = "%s() returning handle %#x";
                    } else {
                        format = "%s() returning %#x";
                    }
                }
                break;

            default:

                INET_ASSERT(FALSE);

                break;
            }

            tls->IndentIncrement -= InternetDebugIndentIncrement;
            if (tls->IndentIncrement < 0) {
                tls->IndentIncrement = 0;
            }

            //
            // add line number info, if requested
            //

            strcpy(formatBuf, format);
            if (!(InternetDebugControlFlags & DBG_NO_LINE_NUMBER)) {
                strcat(formatBuf, " (line %d)");
            }
            strcat(formatBuf, "\n");

            //
            // output an empty line if we are required to separate API calls in
            // the log. Only do this if this is an API level function, and it
            // is the top-level function
            //

            if ((InternetDebugControlFlags & DBG_SEPARATE_APIS)
            && (pCurrentFunction->Stack == NULL)) {
                strcat(formatBuf, "\n");
            }

            //
            // dump the line, depending on requirements and number of arguments
            //

            if (noVar) {
                InternetDebugPrint(formatBuf,
                                   pCurrentFunction->Function,
                                   LineNumber
                                   );
            } else if (errstr != NULL) {
                InternetDebugPrint(formatBuf,
                                   pCurrentFunction->Function,
                                   Variable,
                                   errstr,
                                   LineNumber
                                   );
            } else {
                InternetDebugPrint(formatBuf,
                                   pCurrentFunction->Function,
                                   Variable,
                                   LineNumber
                                   );
            }
/*
            //
            // output an empty line if we are required to separate API calls in
            // the log. Only do this if this is an API level function, and it
            // is the top-level function
            //

            if ((InternetDebugControlFlags & DBG_SEPARATE_APIS)
            && (pCurrentFunction->Stack == NULL)) {

                //
                // don't call InternetDebugPrint - we don't need timing, thread,
                // level etc. information just for the separator
                //

                InternetDebugOut("\n", FALSE);
            }
*/
        }
    }

    //
    // regardless of whether we are outputting debug info for this category,
    // remove the debug record and reduce the call-depth
    //

    --tls->CallDepth;
    tls->Stack = pCurrentFunction->Stack;

    DEL(pCurrentFunction);

    //
    // refresh the last error, in case it was nuked
    //

    SetLastError(lastError);
}


VOID
InternetDebugError(
    IN DWORD Error
    )

/*++

Routine Description:

    Used to display that a function is returning an error. We try to display a
    symbolic name for the error too (as when we are returning a DWORD from a
    function, using DEBUG_LEAVE)

    Displays a string of the form:

        Foo() returning error 87 [ERROR_INVALID_PARAMETER]

Arguments:

    Error   - the error code

Return Value:

    None.

--*/

{
    LPSTR errstr;
    DWORD lastError;
    char hexnumBuf[15];

    if (InternetDebugControlFlags & DBG_NO_DEBUG) {
        return;
    }
    
    //
    // seems that something in this path can nuke the last error, so we must
    // refresh it
    //

    lastError = GetLastError();
    
    HRESULT hr = S_OK;

    CUrlMkTls tls(hr); // hr passed by reference!
    if (FAILED(hr))
        return;

    LPDEBUG_URLMON_FUNC_RECORD pCurrentFunction = tls->Stack;

    if (pCurrentFunction == NULL) {
        return;
    }

    errstr = InternetMapError(Error);
    if ((errstr == NULL) || (*errstr == '?')) {
        rsprintf(hexnumBuf, "%#x", Error);
        errstr = hexnumBuf;
    }
    InternetDebugPrint("%s() returning %d [%s]\n",
                       pCurrentFunction->Function,
                       Error,
                       errstr
                       );

    //
    // refresh the last error, in case it was nuked
    //

    SetLastError(lastError);
}


VOID
InternetDebugPrint(
    IN LPSTR Format,
    ...
    )

/*++

Routine Description:

    Internet equivalent of printf()

Arguments:

    Format  - printf format string

    ...     - any extra args

Return Value:

    None.

--*/

{
    if (InternetDebugControlFlags & DBG_NO_DEBUG) {
        return;
    }

    char buf[PRINTF_STACK_BUFFER_LENGTH];
    LPSTR bufptr;

    bufptr = SetDebugPrefix(buf);
    if (bufptr == NULL) {
        return;
    }

    //
    // now append the string that the DEBUG_PRINT originally gave us
    //

    va_list list;

    va_start(list, Format);
    _sprintf(bufptr, Format, list);
    va_end(list);

    InternetDebugOut(buf, FALSE);
}


VOID
InternetDebugPrintValist(
    IN LPSTR Format,
    va_list list
    )

/*++

Routine Description:

    Internet equivalent of printf(), but takes valist as the args

Arguments:

    Format  - printf format string

    list    - stack frame of variable arguments

Return Value:

    None.

--*/

{
    if (InternetDebugControlFlags & DBG_NO_DEBUG) {
        return;
    }

    char buf[PRINTF_STACK_BUFFER_LENGTH];
    LPSTR bufptr;

    bufptr = SetDebugPrefix(buf);
    if (bufptr == NULL) {
        return;
    }

    _sprintf(bufptr, Format, list);

    InternetDebugOut(buf, FALSE);
}


PRIVATE
VOID
InternetDebugPrintString(
    IN LPSTR String
    )

/*++

Routine Description:

    Same as InternetDebugPrint(), except we perform no expansion on the string

Arguments:

    String  - already formatted string (may contain %s)

Return Value:

    None.

--*/

{
    if (InternetDebugControlFlags & DBG_NO_DEBUG) {
        return;
    }

    char buf[PRINTF_STACK_BUFFER_LENGTH];
    LPSTR bufptr;

    bufptr = SetDebugPrefix(buf);
    if (bufptr == NULL) {
        return;
    }

    //
    // now append the string that the DEBUG_PRINT originally gave us
    //

    strcpy(bufptr, String);

    InternetDebugOut(buf, FALSE);
}


VOID
InternetDebugPrintf(
    IN LPSTR Format,
    IN ...
    )

/*++

Routine Description:

    Same as InternetDebugPrint(), but we don't access the per-thread info
    (because we may not have any)

Arguments:

    Format  - printf format string

    ...     - any extra args


Return Value:

    None.

--*/

{
    if (InternetDebugControlFlags & DBG_NO_DEBUG) {
        return;
    }

    va_list list;
    char buf[PRINTF_STACK_BUFFER_LENGTH];

    va_start(list, Format);
    _sprintf(buf, Format, list);
    va_end(list);

    InternetDebugOut(buf, FALSE);
}


VOID
InternetDebugOut(
    IN LPSTR Buffer,
    IN BOOL Assert
    )

/*++

Routine Description:

    Writes a string somewhere - to the debug log file, to the console, or via
    the debugger, or any combination

Arguments:

    Buffer  - pointer to formatted buffer to write

    Assert  - TRUE if this function is being called from InternetAssert(), in
              which case we *always* write to the debugger. Of course, there
              may be no debugger attached, in which case no action is taken

Return Value:

    None.

--*/

{
    int buflen;
    DWORD written;

    buflen = strlen(Buffer);
    if ((InternetDebugControlFlags & DBG_TO_FILE)
    && (InternetDebugFileHandle != INVALID_HANDLE_VALUE)) {
        WriteFile(InternetDebugFileHandle, Buffer, buflen, &written, NULL);
        if (InternetDebugControlFlags & DBG_FLUSH_OUTPUT) {
            InternetFlushDebugFile();
        }
    }

    if (InternetDebugControlFlags & DBG_TO_CONSOLE) {
        WriteConsole(GetStdHandle(STD_OUTPUT_HANDLE),
                     Buffer,
                     buflen,
                     &written,
                     0
                     );
    }

    if (Assert || (InternetDebugControlFlags & DBG_TO_DEBUGGER)) {
        OutputDebugString(Buffer);
    }
}


VOID
InternetDebugDump(
    IN LPSTR Text,
    IN LPBYTE Address,
    IN DWORD Size
    )

/*++

Routine Description:

    Dumps Size bytes at Address, in the time-honoured debug tradition

Arguments:

    Text    - to display before dumping data

    Address - start of buffer

    Size    - number of bytes

Return Value:

    None.

--*/

{
    //
    // if flags say no data dumps then quit
    //

    if (InternetDebugControlFlags & (DBG_NO_DEBUG | DBG_NO_DATA_DUMP)) {
        return;
    }

    //
    // display the introduction text, if any
    //

    if (Text) {
        if (InternetDebugControlFlags & DBG_INDENT_DUMP) {
            InternetDebugPrint(Text);
        } else {
            InternetDebugOut(Text, FALSE);
        }
    }

    char buf[128];

    //
    // display a line telling us how much data there is, if requested to
    //

    if (InternetDebugControlFlags & DBG_DUMP_LENGTH) {
        rsprintf(buf, "%d (%#x) bytes @ %#x\n", Size, Size, Address);
        if (InternetDebugControlFlags & DBG_INDENT_DUMP) {
            InternetDebugPrintString(buf);
        } else {
            InternetDebugOut(buf, FALSE);
        }
    }

    //
    // dump out the data, debug style
    //

    while (Size) {

        int len = InternetDebugDumpFormat(Address, Size, sizeof(BYTE), buf);

        //
        // if we are to indent the data to the current level, then display the
        // buffer via InternetDebugPrint() which will apply all the thread id,
        // indentation, and other options selected, else just display the data
        // via InternetDebugOut(), which will simply send it to the output media
        //

        if (InternetDebugControlFlags & DBG_INDENT_DUMP) {
            InternetDebugPrintString(buf);
        } else {
            InternetDebugOut(buf, FALSE);
        }

        Address += len;
        Size -= len;
    }
}


DWORD
InternetDebugDumpFormat(
    IN LPBYTE Address,
    IN DWORD Size,
    IN DWORD ElementSize,
    OUT LPSTR Buffer
    )

/*++

Routine Description:

    Formats Size bytes at Address, in the time-honoured debug tradition, for
    data dump purposes

Arguments:

    Address     - start of buffer

    Size        - number of bytes

    ElementSize - size of each word element in bytes

    Buffer      - pointer to output buffer, assumed to be large enough

Return Value:

    DWORD   - number of bytes formatted

--*/

{
    //
    // we (currently) only understand DWORD, WORD and BYTE dumps
    //

    if ((ElementSize != sizeof(DWORD)) && (ElementSize != sizeof(WORD))) {
        ElementSize = sizeof(BYTE);
    }

    static char spaces[] = "                                               ";    // 15 * 3 + 2
    int i, len;

    len = min(Size, 16);
    rsprintf(Buffer, "%08x  ", Address);

    //
    // dump the hex representation of each character or word - up to 16 per line
    //

    DWORD offset = 10;

    for (i = 0; i < len; i += ElementSize) {

        DWORD value;
        LPSTR formatString;

        switch (ElementSize) {
        case 4:
            formatString = "%08x ";
            value = *(LPDWORD)&Address[i];
            break;

        case 2:
            formatString = "%04x ";
            value = *(LPWORD)&Address[i] & 0xffff;
            break;

        default:
            formatString = ((i & 15) == 7) ? "%02.2x-" : "%02.2x ";
            value = Address[i] & 0xff;
            break;
        }
        rsprintf(&Buffer[offset], formatString, value);
        offset += ElementSize * 2 + 1;
    }

    //
    // write as many spaces as required to tab to ASCII field
    //

    memcpy(&Buffer[offset], spaces, (16 - len) * 3 + 2);
    offset += (16 - len) * 3 + 2;

    //
    // dump ASCII representation of each character
    //

    for (i = 0; i < len; ++i) {

        char ch;

        ch = Address[i];
        Buffer[offset + i] =  ((ch < 32) || (ch > 127)) ? '.' : ch;
    }

    Buffer[offset + i++] = '\r';
    Buffer[offset + i++] = '\n';
    Buffer[offset + i] = '\0';

    return len;
}


VOID
InternetAssert(
    IN LPSTR Assertion,
    IN LPSTR FileName,
    IN DWORD LineNumber
    )

/*++

Routine Description:

    displays assertion message at debugger and raised breakpoint exception

Arguments:

    Assertion   - string describing assertion which failed

    FileName    - module where assertion failure occurred

    LineNumber  - at this line number

Return Value:

    None.

--*/

{
    char buffer[512];

    rsprintf(buffer,
             "\n"
             "*** Urlmon Assertion failed: %s\n"
             "*** Source file: %s\n"
             "*** Source line: %d\n"
             "*** Thread %08x\n"
             "\n",
             Assertion,
             FileName,
             LineNumber,
             GetCurrentThreadId()
             );
    InternetDebugOut(buffer, TRUE);

    //
    // break to the debugger, unless it is requested that we don't
    //

    if (!(InternetDebugControlFlags & DBG_NO_ASSERT_BREAK)) {
        DebugBreak();
    }
}


VOID
InternetGetDebugVariable(
    IN LPSTR lpszVariableName,
    OUT LPDWORD lpdwVariable
    )

/*++

Routine Description:

    Get debug variable. First examine environment, then registry

Arguments:

    lpszVariableName    - variable name

    lpdwVariable        - returned variable

Return Value:

    None.

--*/

{
    DWORD len;
    char varbuf[ENVIRONMENT_VARIABLE_BUFFER_LENGTH];

    //
    // get the debug variables first from the environment, then - if not there -
    // from the registry
    //

    len = GetEnvironmentVariable(lpszVariableName, varbuf, sizeof(varbuf));
    if (len && len < sizeof(varbuf)) {
        *lpdwVariable = (DWORD)strtoul(varbuf, NULL, 0);
    } else {
        InternetReadRegistryDword(lpszVariableName, lpdwVariable);
    }
}



PRIVATE
VOID
InternetGetDebugVariableString(
    IN LPSTR lpszVariableName,
    OUT LPSTR lpszVariable,
    IN DWORD dwVariableLen
    )

/*++

Routine Description:

    Get debug variable string. First examine environment, then registry

Arguments:

    lpszVariableName    - variable name

    lpszVariable        - returned string variable

    dwVariableLen       - size of buffer

Return Value:

    None.

--*/

{
    if (GetEnvironmentVariable(lpszVariableName, lpszVariable, dwVariableLen) == 0) {

        char buf[MAX_PATH + 1];
        DWORD len = min(sizeof(buf), dwVariableLen);

        if (InternetReadRegistryString(lpszVariableName, buf, &len) == ERROR_SUCCESS) {
            memcpy(lpszVariable, buf, len + 1);
        }
    }
}

LPSTR
InternetMapError(
    IN DWORD Error
    )

/*++

Routine Description:

    Map error code to string. Try to get all errors that might ever be returned
    by an Internet function

Arguments:

    Error   - code to map

Return Value:

    LPSTR - pointer to symbolic error name

--*/

{
    switch (Error) {

    //
    // WINERROR errors
    //

    CASE_OF(ERROR_SUCCESS);
    CASE_OF(S_FALSE);
    CASE_OF(ERROR_FILE_NOT_FOUND);
    CASE_OF(ERROR_PATH_NOT_FOUND);
    CASE_OF(ERROR_TOO_MANY_OPEN_FILES);
    CASE_OF(ERROR_ACCESS_DENIED);
    CASE_OF(ERROR_INVALID_HANDLE);
    CASE_OF(ERROR_ARENA_TRASHED);
    CASE_OF(ERROR_NOT_ENOUGH_MEMORY);
    CASE_OF(ERROR_INVALID_BLOCK);
    CASE_OF(ERROR_BAD_ENVIRONMENT);
    CASE_OF(ERROR_BAD_FORMAT);
    CASE_OF(ERROR_INVALID_ACCESS);
    CASE_OF(ERROR_INVALID_DATA);
    CASE_OF(ERROR_OUTOFMEMORY);
    CASE_OF(ERROR_INVALID_DRIVE);
    CASE_OF(ERROR_CURRENT_DIRECTORY);
    CASE_OF(ERROR_NOT_SAME_DEVICE);
    CASE_OF(ERROR_NO_MORE_FILES);
    CASE_OF(ERROR_WRITE_PROTECT);
    CASE_OF(ERROR_BAD_UNIT);
    CASE_OF(ERROR_NOT_READY);
    CASE_OF(ERROR_BAD_COMMAND);
    CASE_OF(ERROR_CRC);
    CASE_OF(ERROR_BAD_LENGTH);
    CASE_OF(ERROR_SEEK);
    CASE_OF(ERROR_NOT_DOS_DISK);
    CASE_OF(ERROR_SECTOR_NOT_FOUND);
    CASE_OF(ERROR_OUT_OF_PAPER);
    CASE_OF(ERROR_WRITE_FAULT);
    CASE_OF(ERROR_READ_FAULT);
    CASE_OF(ERROR_GEN_FAILURE);
    CASE_OF(ERROR_SHARING_VIOLATION);
    CASE_OF(ERROR_LOCK_VIOLATION);
    CASE_OF(ERROR_WRONG_DISK);
    CASE_OF(ERROR_SHARING_BUFFER_EXCEEDED);
    CASE_OF(ERROR_HANDLE_EOF);
    CASE_OF(ERROR_HANDLE_DISK_FULL);
    CASE_OF(ERROR_NOT_SUPPORTED);
    CASE_OF(ERROR_REM_NOT_LIST);
    CASE_OF(ERROR_DUP_NAME);
    CASE_OF(ERROR_BAD_NETPATH);
    CASE_OF(ERROR_NETWORK_BUSY);
    CASE_OF(ERROR_DEV_NOT_EXIST);
    CASE_OF(ERROR_TOO_MANY_CMDS);
    CASE_OF(ERROR_ADAP_HDW_ERR);
    CASE_OF(ERROR_BAD_NET_RESP);
    CASE_OF(ERROR_UNEXP_NET_ERR);
    CASE_OF(ERROR_BAD_REM_ADAP);
    CASE_OF(ERROR_PRINTQ_FULL);
    CASE_OF(ERROR_NO_SPOOL_SPACE);
    CASE_OF(ERROR_PRINT_CANCELLED);
    CASE_OF(ERROR_NETNAME_DELETED);
    CASE_OF(ERROR_NETWORK_ACCESS_DENIED);
    CASE_OF(ERROR_BAD_DEV_TYPE);
    CASE_OF(ERROR_BAD_NET_NAME);
    CASE_OF(ERROR_TOO_MANY_NAMES);
    CASE_OF(ERROR_TOO_MANY_SESS);
    CASE_OF(ERROR_SHARING_PAUSED);
    CASE_OF(ERROR_REQ_NOT_ACCEP);
    CASE_OF(ERROR_REDIR_PAUSED);
    CASE_OF(ERROR_FILE_EXISTS);
    CASE_OF(ERROR_CANNOT_MAKE);
    CASE_OF(ERROR_FAIL_I24);
    CASE_OF(ERROR_OUT_OF_STRUCTURES);
    CASE_OF(ERROR_ALREADY_ASSIGNED);
    CASE_OF(ERROR_INVALID_PASSWORD);
    CASE_OF(ERROR_INVALID_PARAMETER);
    CASE_OF(ERROR_NET_WRITE_FAULT);
    CASE_OF(ERROR_NO_PROC_SLOTS);
    CASE_OF(ERROR_TOO_MANY_SEMAPHORES);
    CASE_OF(ERROR_EXCL_SEM_ALREADY_OWNED);
    CASE_OF(ERROR_SEM_IS_SET);
    CASE_OF(ERROR_TOO_MANY_SEM_REQUESTS);
    CASE_OF(ERROR_INVALID_AT_INTERRUPT_TIME);
    CASE_OF(ERROR_SEM_OWNER_DIED);
    CASE_OF(ERROR_SEM_USER_LIMIT);
    CASE_OF(ERROR_DISK_CHANGE);
    CASE_OF(ERROR_DRIVE_LOCKED);
    CASE_OF(ERROR_BROKEN_PIPE);
    CASE_OF(ERROR_OPEN_FAILED);
    CASE_OF(ERROR_BUFFER_OVERFLOW);
    CASE_OF(ERROR_DISK_FULL);
    CASE_OF(ERROR_NO_MORE_SEARCH_HANDLES);
    CASE_OF(ERROR_INVALID_TARGET_HANDLE);
    CASE_OF(ERROR_INVALID_CATEGORY);
    CASE_OF(ERROR_INVALID_VERIFY_SWITCH);
    CASE_OF(ERROR_BAD_DRIVER_LEVEL);
    CASE_OF(ERROR_CALL_NOT_IMPLEMENTED);
    CASE_OF(ERROR_SEM_TIMEOUT);
    CASE_OF(ERROR_INSUFFICIENT_BUFFER);
    CASE_OF(ERROR_INVALID_NAME);
    CASE_OF(ERROR_INVALID_LEVEL);
    CASE_OF(ERROR_NO_VOLUME_LABEL);
    CASE_OF(ERROR_MOD_NOT_FOUND);
    CASE_OF(ERROR_PROC_NOT_FOUND);
    CASE_OF(ERROR_WAIT_NO_CHILDREN);
    CASE_OF(ERROR_CHILD_NOT_COMPLETE);
    CASE_OF(ERROR_DIRECT_ACCESS_HANDLE);
    CASE_OF(ERROR_NEGATIVE_SEEK);
    CASE_OF(ERROR_SEEK_ON_DEVICE);
    CASE_OF(ERROR_DIR_NOT_ROOT);
    CASE_OF(ERROR_DIR_NOT_EMPTY);
    CASE_OF(ERROR_PATH_BUSY);
    CASE_OF(ERROR_SYSTEM_TRACE);
    CASE_OF(ERROR_INVALID_EVENT_COUNT);
    CASE_OF(ERROR_TOO_MANY_MUXWAITERS);
    CASE_OF(ERROR_INVALID_LIST_FORMAT);
    CASE_OF(ERROR_BAD_ARGUMENTS);
    CASE_OF(ERROR_BAD_PATHNAME);
    CASE_OF(ERROR_BUSY);
    CASE_OF(ERROR_CANCEL_VIOLATION);
    CASE_OF(ERROR_ALREADY_EXISTS);
    CASE_OF(ERROR_FILENAME_EXCED_RANGE);
    CASE_OF(ERROR_LOCKED);
    CASE_OF(ERROR_NESTING_NOT_ALLOWED);
    CASE_OF(ERROR_BAD_PIPE);
    CASE_OF(ERROR_PIPE_BUSY);
    CASE_OF(ERROR_NO_DATA);
    CASE_OF(ERROR_PIPE_NOT_CONNECTED);
    CASE_OF(ERROR_MORE_DATA);
    CASE_OF(ERROR_NO_MORE_ITEMS);
    CASE_OF(ERROR_NOT_OWNER);
    CASE_OF(ERROR_PARTIAL_COPY);
    CASE_OF(ERROR_MR_MID_NOT_FOUND);
    CASE_OF(ERROR_INVALID_ADDRESS);
    CASE_OF(ERROR_PIPE_CONNECTED);
    CASE_OF(ERROR_PIPE_LISTENING);
    CASE_OF(ERROR_OPERATION_ABORTED);
    CASE_OF(ERROR_IO_INCOMPLETE);
    CASE_OF(ERROR_IO_PENDING);
    CASE_OF(ERROR_NOACCESS);
    CASE_OF(ERROR_STACK_OVERFLOW);
    CASE_OF(ERROR_INVALID_FLAGS);
    CASE_OF(ERROR_NO_TOKEN);
    CASE_OF(ERROR_BADDB);
    CASE_OF(ERROR_BADKEY);
    CASE_OF(ERROR_CANTOPEN);
    CASE_OF(ERROR_CANTREAD);
    CASE_OF(ERROR_CANTWRITE);
    CASE_OF(ERROR_REGISTRY_RECOVERED);
    CASE_OF(ERROR_REGISTRY_CORRUPT);
    CASE_OF(ERROR_REGISTRY_IO_FAILED);
    CASE_OF(ERROR_NOT_REGISTRY_FILE);
    CASE_OF(ERROR_KEY_DELETED);
    CASE_OF(ERROR_CIRCULAR_DEPENDENCY);
    CASE_OF(ERROR_SERVICE_NOT_ACTIVE);
    CASE_OF(ERROR_DLL_INIT_FAILED);
    CASE_OF(ERROR_CANCELLED);
    CASE_OF(ERROR_BAD_USERNAME);
    CASE_OF(ERROR_LOGON_FAILURE);

    CASE_OF(WAIT_FAILED);
    //CASE_OF(WAIT_ABANDONED_0);
    CASE_OF(WAIT_TIMEOUT);
    CASE_OF(WAIT_IO_COMPLETION);
    //CASE_OF(STILL_ACTIVE);

    CASE_OF(RPC_S_INVALID_STRING_BINDING);
    CASE_OF(RPC_S_WRONG_KIND_OF_BINDING);
    CASE_OF(RPC_S_INVALID_BINDING);
    CASE_OF(RPC_S_PROTSEQ_NOT_SUPPORTED);
    CASE_OF(RPC_S_INVALID_RPC_PROTSEQ);
    CASE_OF(RPC_S_INVALID_STRING_UUID);
    CASE_OF(RPC_S_INVALID_ENDPOINT_FORMAT);
    CASE_OF(RPC_S_INVALID_NET_ADDR);
    CASE_OF(RPC_S_NO_ENDPOINT_FOUND);
    CASE_OF(RPC_S_INVALID_TIMEOUT);
    CASE_OF(RPC_S_OBJECT_NOT_FOUND);
    CASE_OF(RPC_S_ALREADY_REGISTERED);
    CASE_OF(RPC_S_TYPE_ALREADY_REGISTERED);
    CASE_OF(RPC_S_ALREADY_LISTENING);
    CASE_OF(RPC_S_NO_PROTSEQS_REGISTERED);
    CASE_OF(RPC_S_NOT_LISTENING);
    CASE_OF(RPC_S_UNKNOWN_MGR_TYPE);
    CASE_OF(RPC_S_UNKNOWN_IF);
    CASE_OF(RPC_S_NO_BINDINGS);
    CASE_OF(RPC_S_NO_PROTSEQS);
    CASE_OF(RPC_S_CANT_CREATE_ENDPOINT);
    CASE_OF(RPC_S_OUT_OF_RESOURCES);
    CASE_OF(RPC_S_SERVER_UNAVAILABLE);
    CASE_OF(RPC_S_SERVER_TOO_BUSY);
    CASE_OF(RPC_S_INVALID_NETWORK_OPTIONS);
    CASE_OF(RPC_S_NO_CALL_ACTIVE);
    CASE_OF(RPC_S_CALL_FAILED);
    CASE_OF(RPC_S_CALL_FAILED_DNE);
    CASE_OF(RPC_S_PROTOCOL_ERROR);
    CASE_OF(RPC_S_UNSUPPORTED_TRANS_SYN);
    CASE_OF(RPC_S_UNSUPPORTED_TYPE);
    CASE_OF(RPC_S_INVALID_TAG);
    CASE_OF(RPC_S_INVALID_BOUND);
    CASE_OF(RPC_S_NO_ENTRY_NAME);
    CASE_OF(RPC_S_INVALID_NAME_SYNTAX);
    CASE_OF(RPC_S_UNSUPPORTED_NAME_SYNTAX);
    CASE_OF(RPC_S_UUID_NO_ADDRESS);
    CASE_OF(RPC_S_DUPLICATE_ENDPOINT);
    CASE_OF(RPC_S_UNKNOWN_AUTHN_TYPE);
    CASE_OF(RPC_S_MAX_CALLS_TOO_SMALL);
    CASE_OF(RPC_S_STRING_TOO_LONG);
    CASE_OF(RPC_S_PROTSEQ_NOT_FOUND);
    CASE_OF(RPC_S_PROCNUM_OUT_OF_RANGE);
    CASE_OF(RPC_S_BINDING_HAS_NO_AUTH);
    CASE_OF(RPC_S_UNKNOWN_AUTHN_SERVICE);
    CASE_OF(RPC_S_UNKNOWN_AUTHN_LEVEL);
    CASE_OF(RPC_S_INVALID_AUTH_IDENTITY);
    CASE_OF(RPC_S_UNKNOWN_AUTHZ_SERVICE);
    CASE_OF(EPT_S_INVALID_ENTRY);
    CASE_OF(EPT_S_CANT_PERFORM_OP);
    CASE_OF(EPT_S_NOT_REGISTERED);
    CASE_OF(RPC_S_NOTHING_TO_EXPORT);
    CASE_OF(RPC_S_INCOMPLETE_NAME);
    CASE_OF(RPC_S_INVALID_VERS_OPTION);
    CASE_OF(RPC_S_NO_MORE_MEMBERS);
    CASE_OF(RPC_S_NOT_ALL_OBJS_UNEXPORTED);
    CASE_OF(RPC_S_INTERFACE_NOT_FOUND);
    CASE_OF(RPC_S_ENTRY_ALREADY_EXISTS);
    CASE_OF(RPC_S_ENTRY_NOT_FOUND);
    CASE_OF(RPC_S_NAME_SERVICE_UNAVAILABLE);
    CASE_OF(RPC_S_INVALID_NAF_ID);
    CASE_OF(RPC_S_CANNOT_SUPPORT);
    CASE_OF(RPC_S_NO_CONTEXT_AVAILABLE);
    CASE_OF(RPC_S_INTERNAL_ERROR);
    CASE_OF(RPC_S_ZERO_DIVIDE);
    CASE_OF(RPC_S_ADDRESS_ERROR);
    CASE_OF(RPC_S_FP_DIV_ZERO);
    CASE_OF(RPC_S_FP_UNDERFLOW);
    CASE_OF(RPC_S_FP_OVERFLOW);
    CASE_OF(RPC_X_NO_MORE_ENTRIES);
    CASE_OF(RPC_X_SS_CHAR_TRANS_OPEN_FAIL);
    CASE_OF(RPC_X_SS_CHAR_TRANS_SHORT_FILE);
    CASE_OF(RPC_X_SS_IN_NULL_CONTEXT);
    CASE_OF(RPC_X_SS_CONTEXT_DAMAGED);
    CASE_OF(RPC_X_SS_HANDLES_MISMATCH);
    CASE_OF(RPC_X_SS_CANNOT_GET_CALL_HANDLE);
    CASE_OF(RPC_X_NULL_REF_POINTER);
    CASE_OF(RPC_X_ENUM_VALUE_OUT_OF_RANGE);
    CASE_OF(RPC_X_BYTE_COUNT_TOO_SMALL);
    CASE_OF(RPC_X_BAD_STUB_DATA);

    default:
        return "?";
    }
}

//
// private functions
//


PRIVATE
LPSTR
ExtractFileName(
    IN LPSTR Module,
    OUT LPSTR Buf
    )
{
    LPSTR filename;
    LPSTR extension;
    int   len;

    filename = strrchr(Module, '\\');
    extension = strrchr(Module, '.');
    if (filename) {
        ++filename;
    } else {
        filename = Module;
    }
    if (!extension) {
        extension = filename + strlen(filename);
    }
    len = (int) (extension - filename);
    memcpy(Buf, filename, len);
    Buf[len] = '\0';
    return Buf;
}


PRIVATE
LPSTR
SetDebugPrefix(
    IN LPSTR Buffer
    )
{
    HRESULT hr = S_OK;

    CUrlMkTls tls(hr); // hr passed by reference!
    if (FAILED(hr))
        return NULL;

    LPDEBUG_URLMON_FUNC_RECORD pCurrentFunction = tls->Stack;

    if (!pCurrentFunction) {
        return NULL;
    }

    if (InternetDebugControlFlags & DBG_ENTRY_TIME) {
        if (InternetDebugControlFlags & (DBG_DELTA_TIME | DBG_CUMULATIVE_TIME))
        {

            DWORD ticks;
            DWORD ticksNow;

            ticksNow = GetTickCountWrap();
            ticks = ticksNow -  ((InternetDebugControlFlags & DBG_CUMULATIVE_TIME)
                                    ? InternetDebugStartTime
                                    : pCurrentFunction->LastTime);

            Buffer += rsprintf(Buffer,
                               "% 5d.%3d ",
                               ticks / 1000,
                               ticks % 1000
                               );
            if (InternetDebugControlFlags & DBG_DELTA_TIME) {
                pCurrentFunction->LastTime = ticksNow;
            }
        } else {

            SYSTEMTIME timeNow;

            InternetDebugGetLocalTime(&timeNow, NULL);

            Buffer += rsprintf(Buffer,
                               "%02d:%02d:%02d.%03d ",
                               timeNow.wHour,
                               timeNow.wMinute,
                               timeNow.wSecond,
                               timeNow.wMilliseconds
                               );
        }
    }

/*
    if (InternetDebugControlFlags & DBG_LEVEL_INDICATOR) {
        Buffer += rsprintf(Buffer, );
    }
*/

    if (InternetDebugControlFlags & DBG_THREAD_INFO) {

        //
        // thread id
        //

        Buffer += rsprintf(Buffer, "%08x", tls->ThreadId);

        //
        // INTERNET_THREAD_INFO address
        //

        if (InternetDebugControlFlags & DBG_THREAD_INFO_ADR) {
            Buffer += rsprintf(Buffer, ":%08x", tls);
        }

        *Buffer++ = ' ';
    }

    if (InternetDebugControlFlags & DBG_CALL_DEPTH) {
        Buffer += rsprintf(Buffer, "%03d ", tls->CallDepth);
    }

    for (int i = 0; i < tls->IndentIncrement; ++i) {
        *Buffer++ = ' ';
    }

    //
    // if we are not debugging the category - i.e we got here via a requirement
    // to display an error, or we are in a function that does not have a
    // DEBUG_ENTER - then prefix the string with the current function name
    // (obviously misleading if the function doesn't have a DEBUG_ENTER)
    //

    if (pCurrentFunction != NULL) {
        if (!(pCurrentFunction->Category & InternetDebugCategoryFlags)) {
            Buffer += rsprintf(Buffer, "%s(): ", pCurrentFunction->Function);
        }
    }

    return Buffer;
}

int dprintf(char * format, ...) {

    va_list args;
    char buf[PRINTF_STACK_BUFFER_LENGTH];
    int n;

    va_start(args, format);
    n = _sprintf(buf, format, args);
    va_end(args);
    OutputDebugString(buf);

    return n;
}


LPSTR
SourceFilename(
    LPSTR Filespec
    )
{
    if (!Filespec) {
        return "?";
    }

    LPSTR p;

    if (p = strrchr(Filespec, '\\')) {

        //
        // we want e.g. common\debugmem.cxx, but get
        // common\..\win32\debugmem.cxx. Bah!
        //

        //LPSTR q;
        //
        //if (q = strrchr(p - 1, '\\')) {
        //    p = q;
        //}
    }
    return p ? p + 1 : Filespec;
}


typedef BOOL (* SYMINITIALIZE)(HANDLE, LPSTR, BOOL);
typedef BOOL (* SYMLOADMODULE)(HANDLE, HANDLE, PSTR, PSTR, DWORD, DWORD);
typedef BOOL (* SYMGETSYMFROMADDR)(HANDLE, DWORD, PDWORD, PIMAGEHLP_SYMBOL);
typedef BOOL (* SYMCLEANUP)(HANDLE);

PRIVATE HMODULE hSymLib = NULL;
PRIVATE SYMINITIALIZE pSymInitialize = NULL;
PRIVATE SYMLOADMODULE pSymLoadModule = NULL;
PRIVATE SYMGETSYMFROMADDR pSymGetSymFromAddr = NULL;
PRIVATE SYMCLEANUP pSymCleanup = NULL;


VOID
InitSymLib(
    VOID
    )
{
    if (hSymLib == NULL) {
        hSymLib = LoadLibrary("IMAGEHLP.DLL");
        if (hSymLib != NULL) {
            pSymInitialize = (SYMINITIALIZE)GetProcAddress(hSymLib,
                                                           "SymInitialize"
                                                           );
            pSymLoadModule = (SYMLOADMODULE)GetProcAddress(hSymLib,
                                                           "SymLoadModule"
                                                           );
            pSymGetSymFromAddr = (SYMGETSYMFROMADDR)GetProcAddress(hSymLib,
                                                                   "SymGetSymFromAddr"
                                                                   );
            pSymCleanup = (SYMCLEANUP)GetProcAddress(hSymLib,
                                                     "SymCleanup"
                                                     );
            if (!pSymInitialize
            || !pSymLoadModule
            || !pSymGetSymFromAddr
            || !pSymCleanup) {
                FreeLibrary(hSymLib);
                hSymLib = NULL;
                pSymInitialize = NULL;
                pSymLoadModule = NULL;
                pSymGetSymFromAddr = NULL;
                pSymCleanup = NULL;
                return;
            }
        }
        pSymInitialize(GetCurrentProcess(), NULL, FALSE);
        //SymInitialize(GetCurrentProcess(), NULL, TRUE);
        pSymLoadModule(GetCurrentProcess(), NULL, "URLMON.DLL", "URLMON", 0, 0);
    }
}


VOID
TermSymLib(
    VOID
    )
{
    if (pSymCleanup) {
        pSymCleanup(GetCurrentProcess());
        FreeLibrary(hSymLib);
    }
}


LPSTR
GetDebugSymbol(
    DWORD Address,
    LPDWORD Offset
    )
{
    *Offset = Address;
    if (!pSymGetSymFromAddr) {
        return "";
    }

    //
    // BUGBUG - only one caller at a time please
    //

    static char symBuf[512];

    //((PIMAGEHLP_SYMBOL)symBuf)->SizeOfStruct = sizeof(IMAGEHLP_SYMBOL);
    ((PIMAGEHLP_SYMBOL)symBuf)->SizeOfStruct = sizeof(symBuf);
    ((PIMAGEHLP_SYMBOL)symBuf)->MaxNameLength = sizeof(symBuf) - sizeof(IMAGEHLP_SYMBOL);
    if (!pSymGetSymFromAddr(GetCurrentProcess(),
                            Address,
                            Offset,
                            (PIMAGEHLP_SYMBOL)symBuf)) {
        ((PIMAGEHLP_SYMBOL)symBuf)->Name[0] = '\0';
    }
    return ((PIMAGEHLP_SYMBOL)symBuf)->Name;
}


#if defined(i386)

VOID
x86SleazeCallStack(
    OUT LPVOID * lplpvStack,
    IN DWORD dwStackCount,
    IN LPVOID * Ebp
    )

/*++

Routine Description:

    Similar to x86SleazeCallersAddress but gathers a variable number of return
    addresses. We assume all functions have stack frame

Arguments:

    lplpvStack      - pointer to returned array of caller's addresses

    dwStackCount    - number of elements in lplpvStack

    Ebp             - starting Ebp if not 0, else use current stack

Return Value:

    None.

--*/

{
    DWORD my_esp;

    _asm mov my_esp, esp;

    __try {
        if (Ebp == 0) {
            Ebp = (LPVOID *)(&lplpvStack - 2);
        }
        while (dwStackCount--) {
            if (((DWORD)Ebp > my_esp + 0x10000) || ((DWORD)Ebp < my_esp - 0x10000)) {
                break;
            }
            *lplpvStack++ = *(Ebp + 1);
            Ebp = (LPVOID *)*Ebp;
            if (((DWORD)Ebp <= 0x10000)
            || ((DWORD)Ebp >= 0x80000000)
            || ((DWORD)Ebp & 3)
            || ((DWORD)Ebp > my_esp + 0x10000)
            || ((DWORD)Ebp < my_esp - 0x10000)) {
                break;
            }
        }
    } __except(EXCEPTION_EXECUTE_HANDLER) {
    }
}


VOID
x86SleazeCallersAddress(
    LPVOID* pCaller,
    LPVOID* pCallersCaller
    )

/*++

Routine Description:

    This is a sleazy function that reads return addresses out of the stack/
    frame pointer (ebp). We pluck out the return address of the function
    that called THE FUNCTION THAT CALLED THIS FUNCTION, and the caller of
    that function. Returning the return address of the function that called
    this function is not interesting to that caller (almost worthy of Sir
    Humphrey Appleby isn't it?)

    Assumes:

        my ebp  =>  | caller's ebp |
                    | caller's eip |
                    | arg #1       | (pCaller)
                    | arg #2       | (pCallersCaller

Arguments:

    pCaller         - place where we return addres of function that called
                      the function that called this function
    pCallersCaller  - place where we return caller of above

Return Value:

    None.

--*/

{

    //
    // this only works on x86 and only if not fpo functions!
    //

    LPVOID* ebp;

    ebp = (PVOID*)&pCaller - 2; // told you it was sleazy
    ebp = (PVOID*)*(PVOID*)ebp;
    *pCaller = *(ebp + 1);
    ebp = (PVOID*)*(PVOID*)ebp;
    *pCallersCaller = *(ebp + 1);
}

#endif // defined(i386)


BOOL
InternetDebugGetLocalTime(
    OUT SYSTEMTIME * pstLocalTime,
    OUT DWORD      * pdwMicroSec
)
{
#ifndef ENABLE_DEBUG
    // QUICK HACK TO KEEP THINGS CLEAN AND STILL MEASURE WITH HIGH PERFORMANCE
    // COUNTER

    static BOOL pcTested = FALSE;
    static LONGLONG ftInit;  // initial local time
    static LONGLONG pcInit;  // initial perf counter
    static LONGLONG pcFreq;  // perf counter frequency

    if (!pcTested)
    {
        pcTested = TRUE;
        if (QueryPerformanceFrequency ((LARGE_INTEGER *) &pcFreq) && pcFreq)
        {
            QueryPerformanceCounter ((LARGE_INTEGER *) &pcInit);
            SYSTEMTIME st;
            GetLocalTime (&st);
            SystemTimeToFileTime (&st, (FILETIME *) &ftInit);
        }
    }

    if (!pcFreq)
        GetLocalTime (pstLocalTime);
    else
    {
        LONGLONG pcCurrent, ftCurrent;
        QueryPerformanceCounter ((LARGE_INTEGER *) &pcCurrent);
        ftCurrent = ftInit + ((10000000 * (pcCurrent - pcInit)) / pcFreq);
        FileTimeToSystemTime ((FILETIME *) &ftCurrent, pstLocalTime);
    }

    return TRUE;
#else
    if (!pcFreq)
        GetLocalTime (pstLocalTime);
    else
    {
        LONGLONG pcCurrent, ftCurrent;
        QueryPerformanceCounter ((LARGE_INTEGER *) &pcCurrent);
        ftCurrent = ftInit + ((10000000 * (pcCurrent - pcInit)) / pcFreq);
        FileTimeToSystemTime ((FILETIME *) &ftCurrent, pstLocalTime);
    }

    return TRUE;
#endif // ENABLE_DEBUG
}

#endif // ENABLE_DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\urlmon\utils\printf.h ===
/***
*printf.h - print formatted
*
*       Copyright (c) 1985-1991, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines w4*printf() - print formatted data
*       defines w4v*printf() - print formatted output, get data from an
*                              argument ptr instead of explicit args.
*
*Revision History:
*       09-02-83  RN    original sprintf
*       06-17-85  TC    rewrote to use new varargs macros, and to be vsprintf
*       04-13-87  JCR   added const to declaration
*       11-07-87  JCR   Multi-thread support
*       12-11-87  JCR   Added "_LOAD_DS" to declaration
*       05-27-88  PHG   Merged DLL and normal versions
*       06-13-88  JCR   Fake _iob entry is now static so that other routines
*                       can assume _iob entries are in DGROUP.
*       08-25-88  GJF   Define MAXSTR to be INT_MAX (from LIMITS.H).
*       06-06-89  JCR   386 mthread support
*       08-18-89  GJF   Clean up, now specific to OS/2 2.0 (i.e., 386 WIN32
*                       model). Also fixed copyright and indents.
*       02-16-90  GJF   Fixed copyright
*
*******************************************************************************/

#include <windows.h>
#include <wchar.h>
#include <stdarg.h>
#include <limits.h>
#include "w4io.h"

#if defined(_W4PRINTF_)
    static INT_PTR  fh;
//    extern long GetStdHandle(long);
//    extern void WriteFile(long fh, char *s, long cch, long * pcchret, long);
#   define _PRINTF_
#elif defined(_W4DPRINTF_)
#   define _pwritechar  _dwritechar
#   define _pflushbuf   _dflushbuf
#   define w4printf     w4dprintf
#   define w4vprintf    w4vdprintf
#   define _PRINTF_
#elif defined(_W4SPRINTF_)
#   define _pwritechar  _swritechar
#   define w4printf     w4sprintf
#   define w4vprintf    w4vsprintf
#elif defined(_W4WCSPRINTF_)
#   define _TCHAR_      wchar_t
#   define _PBUF_       pwcbuf
#   define _PSTART_     pwcstart
#   define w4printf     w4wcsprintf
#   define w4vprintf    w4vwcsprintf
#   define _pwritechar  _wwritechar
#else
#   error configuration problem
#endif

#ifndef _TCHAR_
#  define _TCHAR_       char
#  define _PBUF_        pchbuf
#  define _PSTART_      pchstart
#endif


#ifdef _PRINTF_
#   ifdef WIN32
#     undef  OutputDebugString
#     define OutputDebugString OutputDebugStringA
#   else
      extern void _pascal OutputDebugString(char *);
#   endif
    int _cdecl _pflushbuf(struct w4io *f);
#   define SPR(a)
#   define MAXSTR       128
#else
#   define SPR(a)       a,
#   define MAXSTR       INT_MAX
#endif

void _cdecl _pwritechar(int ch, int num, struct w4io *f, int *pcchwritten);
int _cdecl w4vprintf(SPR(_TCHAR_ *string) const char *format, va_list arglist);


/***
*int w4printf(format, ...) - print formatted data
*
*Purpose:
*       Prints formatted data using the format string to
*       format data and getting as many arguments as called for
*       Sets up a w4io so file i/o operations can be used.
*       w4iooutput does the real work here
*
*Entry:
*       char *format - format string to control data format/number
*       of arguments followed by list of arguments, number and type
*       controlled by format string
*
*Exit:
*       returns number of characters written
*
*Exceptions:
*
*******************************************************************************/


int _cdecl
w4printf(SPR(_TCHAR_ *string) const char *format, ...)
/*
 * 'PRINT', 'F'ormatted
 */
{
    va_list arglist;

    va_start(arglist, format);
    return(w4vprintf(SPR(string) format, arglist));
}


/***
*int w4vprintf(format, arglist) - print formatted data from arg ptr
*
*Purpose:
*       Prints formatted data, but gets data from an argument pointer.
*       Sets up a w4io so file i/o operations can be used, make string look
*       like a huge buffer to it, but _flsbuf will refuse to flush it if it
*       fills up. Appends '\0' to make it a true string.
*
*       Multi-thread: (1) Since there is no stream, this routine must never try
*       to get the stream lock (i.e., there is no stream lock either).  (2)
*       Also, since there is only one staticly allocated 'fake' iob, we must
*       lock/unlock to prevent collisions.
*
*Entry:
*       char *format    - format string, describes format of data
*       va_list arglist - varargs argument pointer
*
*Exit:
*       returns number of characters written
*
*Exceptions:
*
*******************************************************************************/

int _cdecl
w4vprintf(SPR(_TCHAR_ *string) const char *format, va_list arglist)
/*
 * 'V'ariable argument 'PRINT', 'F'ormatted
 */
{
    struct w4io outfile;
    register int retval;
#ifdef _PRINTF_
    char string[MAXSTR + 1];            // leave room for null termination
#else
    int dummy = 0;
#endif

#ifdef _W4PRINTF_
    long ldummy;

    if (fh == 0 || fh == -1)
    {
        ldummy = -11;                   // C7 bug workaround
        if ((fh = (INT_PTR)GetStdHandle(ldummy)) == 0 || fh == -1)
        {
            OutputDebugString("GetStdHandle in " __FILE__ " failed\n");
            return(-1);
        }
    }
#endif

    outfile._PBUF_ = outfile._PSTART_ = string;
    outfile.cchleft = MAXSTR;
    outfile.writechar = _pwritechar;

    retval = w4iooutput(&outfile, format, arglist);

#ifdef _PRINTF_
    if (_pflushbuf(&outfile) == -1) {
        return(-1);
    }
#else
    _pwritechar('\0', 1, &outfile, &dummy);
#endif
    return(retval);
}


void _cdecl _pwritechar(int ch, int num, struct w4io *f, int *pcchwritten)
{
    //printf("  char: ch=%c, cnt=%d, cch=%d\n", ch, num, *pcchwritten);
    while (num-- > 0) {
#ifdef _PRINTF_
        if (f->cchleft < 2 && _pflushbuf(f) == -1) {
            *pcchwritten = -1;
            return;
        }
#endif
#ifdef _W4DPRINTF_
#  ifndef WIN32
        if (ch == '\n')
        {
            *f->_PBUF_++ = '\r';
            f->cchleft--;
            (*pcchwritten)++;
        }
#  endif
#endif
        *f->_PBUF_++ = (char) ch;
        f->cchleft--;
        (*pcchwritten)++;
    }
}


#ifdef _PRINTF_
int _cdecl _pflushbuf(struct w4io *f)
{
    int cch;

    if (cch = (int)(f->pchbuf - f->pchstart))
    {
#ifdef _W4DPRINTF_
        *f->pchbuf = '\0';              // null terminate
        OutputDebugString(f->pchstart);
#else
        long cchret;

        //*f->pchbuf = '\0';            // null terminate
        //printf("%d chars: \"%s\"\n", cch, f->pchstart);
        WriteFile((HANDLE)fh, f->pchstart, cch, &cchret, 0);
        if (cch != cchret)
        {
            OutputDebugString("WriteFile in " __FILE__ " failed\n");
            return(-1);
        }
#endif
        f->pchbuf -= cch;               // reset pointer
        f->cchleft += cch;              // reset count
    }
    return(0);
}
#endif // _PRINTF_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\urlmon\utils\printf.c ===
/***
*printf.c - print formatted to stdout
*
*	Copyright (c) 1985-1991, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	defines w4printf() - print formatted data to stdout
*	defines w4vprintf() - print formatted output to stdout, get data
*			      from an argument ptr instead of explicit args.
*******************************************************************************/

#ifdef FLAT
#include "dprintf.h"		// function prototypes

#define _W4PRINTF_
#include "printf.h"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\urlmon\utils\proto.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:	proto.h
//
//  Contents:	File used to spoof idl generated h files. Used by NT1x and
//		Chicago builds.
//
//  History:	10-Nov-93 Ricksa    Created
//
//--------------------------------------------------------------------------

#include    <ole2.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\urlmon\utils\stdafx.h ===
[CODE: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\urlmon\utils\registry.cxx ===
/*++

Module Name:

    registry.cxx

Abstract:

    Functions to read/write registry parameters

Author:

    Venkatraman Kudallur (venkatk)

Revision History:

    3-10-2000 venkatk
        Created

--*/

#ifdef ENABLE_DEBUG

#include <urlint.h>
#include "registry.h"

//
// manifests
//

#define INTERNET_CLIENT_KEY         "Internet Settings"
#define SYSTEM_INI_FILE_NAME        "SYSTEM.INI"
#define NETWORK_SECTION_NAME        "Network"
#define COMPUTER_NAME_VALUE         "ComputerName"
#define PROFILE_INT_BUFFER_LENGTH   128

#define MIME_TO_FILE_EXTENSION_KEY  "MIME\\Database\\Content Type\\"
#define EXTENSION_VALUE             "Extension"

//
// macros
//

#define INTERNET_SETTINGS_KEY       "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Internet Settings"
#define INTERNET_CACHE_SETTINGS_KEY "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\5.0\\Cache"

//from macros.h
#define PRIVATE
#define PUBLIC

#define ARRAY_ELEMENTS(array) \
    (sizeof(array)/sizeof(array[0]))
//from defaults.h
#define DEFAULT_EMAIL_NAME              "user@domain"
//from wininet.w
#define ERROR_INTERNET_BAD_REGISTRY_PARAMETER    12022

PRIVATE
BOOL
IsPlatformWinNT()
{
    OSVERSIONINFO osVersionInfo;
    BOOL fRet = FALSE;
    
    osVersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    if (GetVersionEx(&osVersionInfo))
        fRet = (VER_PLATFORM_WIN32_NT == osVersionInfo.dwPlatformId);
    return fRet;
}

//
// private prototypes
//

PRIVATE
DWORD
InternetReadRegistryDwordKey(
    IN HKEY ParameterKey,
    IN LPCSTR ParameterName,
    OUT LPDWORD ParameterValue
    );

PRIVATE
DWORD
InternetReadRegistryStringKey(
    IN HKEY ParameterKey,
    IN LPCSTR ParameterName,
    OUT LPSTR ParameterValue,
    IN OUT LPDWORD ParameterLength
    );

PRIVATE
DWORD
ReadRegistryOemString(
    IN HKEY Key,
    IN LPCSTR ParameterName,
    OUT LPSTR String,
    IN OUT LPDWORD Length
    );


PRIVATE
DWORD
WriteRegistryDword(
    IN HKEY Key,
    IN LPCSTR ParameterName,
    IN DWORD ParameterValue
    );
//
// private data
//

PRIVATE HKEY hKeyInternetSettings = NULL;

//
// functions
//


DWORD
OpenInternetSettingsKey(
    VOID
    )

/*++

Routine Description:

    Opens registry key for Internet Settings branch

Arguments:

    None.

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure -

--*/

{
    if (hKeyInternetSettings == NULL) {

        DWORD dwDisposition;

        REGCREATEKEYEX(HKEY_CURRENT_USER,
                       INTERNET_SETTINGS_KEY,
                       0,     // reserved
                       NULL,  // class
                       0,     // options
                       KEY_READ | KEY_WRITE,
                       NULL,  // security attributes
                       &hKeyInternetSettings,
                       &dwDisposition
                       );
    }

    return ERROR_SUCCESS;
}


DWORD
CloseInternetSettingsKey(
    VOID
    )

/*++

Routine Description:

    Closes Internet Settings registry key

Arguments:

    None.

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure -

--*/

{
    DWORD error = ERROR_SUCCESS;

    if (hKeyInternetSettings != NULL) {
        error = REGCLOSEKEY(hKeyInternetSettings);
        hKeyInternetSettings = NULL;
    }

    return error;
}



DWORD
GetMyEmailName(
    OUT LPSTR EmailName,
    IN OUT LPDWORD Length
    )

/*++

Routine Description:

    Retrieve the user's email name from the appropriate place in the registry

Arguments:

    EmailName   - place to store email name

    Length      - IN: length of EmailName
                  OUT: returned length of EmailName (in characters, minus
                       trailing NUL)

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_FILE_NOT_FOUND
                  ERROR_PATH_NOT_FOUND

--*/

{
    DEBUG_ENTER((DBG_REGISTRY,
                 Dword,
                 "GetMyEmailName",
                 "%#x, %#x [%d]",
                 EmailName,
                 Length,
                 *Length
                 ));

    DWORD error;

    //
    // for the EmailName, we first try HKEY_CURRENT_USER. If that fails then we
    // try the same branch of the HKEY_LOCAL_MACHINE tree. If that fails,
    // invent something
    //

    static HKEY KeysToTry[2] = {HKEY_CURRENT_USER, HKEY_LOCAL_MACHINE};
    int i;

    //
    // in the event we cannot find EmailName in both HKEY_CURRENT_USER and
    // HKEY_LOCAL_MACHINE trees, then we return this default
    //

    static char DefaultEmailName[] = DEFAULT_EMAIL_NAME;

    for (i = 0; i < ARRAY_ELEMENTS(KeysToTry); ++i) {
        error = InternetReadRegistryStringKey(KeysToTry[i],
                                              "EmailName",
                                              EmailName,
                                              Length
                                              );
        if (error == ERROR_SUCCESS) {
            break;
        }
    }
    if (error != ERROR_SUCCESS) {
        if (IsPlatformWinNT()) {

            //
            // only NT supports GetUserName()
            //

            if (GetUserName(EmailName, Length)) {

                //
                // we return the length as if the result from strlen/wcslen
                //

                *Length -= sizeof(char);

                DEBUG_PRINT(REGISTRY,
                            INFO,
                            ("GetUserName() returns %q\n",
                            EmailName
                            ));

                error = ERROR_SUCCESS;
            } else {

                //
                // BUGBUG - what's the required length?
                //

                error = GetLastError();
            }
        } else {

            //
            // Win95 & Win32s: have to do something different
            //

        }

        //
        // if we still don't have an email name, we use an internal default
        //

        if (error != ERROR_SUCCESS) {

            DEBUG_PRINT(REGISTRY,
                        ERROR,
                        ("Cannot find EmailName: using default (%s)\n",
                        DefaultEmailName
                        ));

            if (*Length >= sizeof(DEFAULT_EMAIL_NAME)) {
                memcpy(EmailName, DefaultEmailName, sizeof(DEFAULT_EMAIL_NAME));

                //
                // success - returned length as if from strlen()
                //

                *Length = sizeof(DEFAULT_EMAIL_NAME) - 1;
                error = ERROR_SUCCESS;
            } else {

                //
                // failure - returned length is the required buffer size
                //

                *Length = sizeof(DEFAULT_EMAIL_NAME);
                error = ERROR_INSUFFICIENT_BUFFER;
            }
        }
    }

    DEBUG_LEAVE(error);

    return error;
}


PUBLIC
DWORD
InternetDeleteRegistryValue(
    IN LPSTR ParameterName
    )

/*++

Routine Description:

    Delets an entry from a the Internet Client registry key if the platform
    is NT/Win95.

Arguments:

    ParameterName   - name of the parameter to retrieve (e.g. AccessType)

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_PATH_NOT_FOUND

--*/

{
    DWORD error;

    DEBUG_ENTER((DBG_REGISTRY,
                Dword,
                "InternetDeleteRegistryValue",
                "%q",
                ParameterName
                ));


    HKEY clientKey;

    //
    // open the registry key containing the Internet client values (this is
    // in the same place on NT and Win95)
    //

    error = REGOPENKEYEX(HKEY_CURRENT_USER,
                         INTERNET_SETTINGS_KEY,
                         0, // reserved
                         KEY_ALL_ACCESS,
                         &clientKey
                         );


    if (error == ERROR_SUCCESS) {

        error = RegDeleteValue(clientKey,
                               ParameterName
                               );

        REGCLOSEKEY(clientKey);
    }


    DEBUG_LEAVE(error);

    return error;
}




DWORD
InternetReadRegistryDword(
    IN LPCSTR ParameterName,
    OUT LPDWORD ParameterValue
    )

/*++

Routine Description:

    Reads a single DWORD from a the Internet Client registry key if the platform
    is NT/Win95, else reads the value from SYSTEM.INI if we are running on Win32s

Arguments:

    ParameterName   - name of the parameter to retrieve (e.g. AccessType)

    ParameterValue  - pointer to place to store retrieved value

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_PATH_NOT_FOUND

--*/

{
    DEBUG_ENTER((DBG_REGISTRY,
                 Dword,
                 "InternetReadRegistryDword",
                 "%q, %x",
                 ParameterName,
                 ParameterValue
                 ));

    DWORD error = InternetReadRegistryDwordKey(HKEY_CURRENT_USER,
                                               ParameterName,
                                               ParameterValue
                                               );

    DEBUG_LEAVE(error);

    return error;
}


DWORD
InternetCacheReadRegistryDword(
    IN LPCSTR ParameterName,
    OUT LPDWORD ParameterValue
    )

/*++

Routine Description:

    Reads a single DWORD from a the Internet Client registry key if the platform
    is NT/Win95, else reads the value from SYSTEM.INI if we are running on Win32s

Arguments:

    ParameterName   - name of the parameter to retrieve (e.g. AccessType)

    ParameterValue  - pointer to place to store retrieved value

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_PATH_NOT_FOUND

--*/

{
    DEBUG_ENTER((DBG_REGISTRY,
                 Dword,
                 "InternetCacheReadRegistryDword",
                 "%q, %x",
                 ParameterName,
                 ParameterValue
                 ));

    DWORD error = ERROR_SUCCESS;
    HKEY clientKey;

    error = REGOPENKEYEX(HKEY_CURRENT_USER,
                         INTERNET_CACHE_SETTINGS_KEY,
                         0, // reserved
                         KEY_QUERY_VALUE,
                         &clientKey
                         );

    if (error == ERROR_SUCCESS) {
        error = ReadRegistryDword(clientKey,
                                  ParameterName,
                                  ParameterValue
                                  );
        REGCLOSEKEY(clientKey);
    }

    DEBUG_LEAVE(error);

    return error;
}



DWORD
InternetWriteRegistryDword(
    IN LPCSTR ParameterName,
    IN DWORD ParameterValue
    )

/*++

Routine Description:

    Writes a single DWORD from to the Internet Client registry key if the platform
    is NT/Win95, otherwise it fails.

Arguments:

    ParameterName   - name of the parameter to retrieve (e.g. AccessType)

    ParameterValue  - value to store in registry.

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_PATH_NOT_FOUND

--*/

{
    DEBUG_ENTER((DBG_REGISTRY,
                 Dword,
                 "InternetWriteRegistryDword",
                 "%q, %x",
                 ParameterName,
                 ParameterValue
                 ));

    DWORD error;

    if (hKeyInternetSettings != NULL) {
        error = WriteRegistryDword(hKeyInternetSettings,
                                   ParameterName,
                                   ParameterValue
                                   );
    } else {
        error = ERROR_SUCCESS;
    }

    DEBUG_PRINT(REGISTRY,
                INFO,
                ("InternetWriteRegistryDword(%q): value = %d (%#x)\n",
                ParameterName,
                ParameterValue,
                ParameterValue
                ));

    DEBUG_LEAVE(error);

    return error;
}



DWORD
InternetReadRegistryString(
    IN LPCSTR ParameterName,
    OUT LPSTR ParameterValue,
    IN OUT LPDWORD ParameterLength
    )

/*++

Routine Description:

    Reads a string from the Internet Client registry key on NT/Win95, or reads
    the corresponding value from SYSTEM.INI on a Win32s platform

Arguments:

    ParameterName   - name of value parameter within key (e.g. EmailName)

    ParameterValue  - pointer to string buffer for returned string

    ParameterLength - IN: number of bytes in ParameterValue
                      OUT: number of bytes in string (excluding trailing '\0')

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_PATH_NOT_FOUND

--*/

{
    DEBUG_ENTER((DBG_REGISTRY,
                 Dword,
                 "InternetReadRegistryString",
                 "%q, %x, %x [%d]",
                 ParameterName,
                 ParameterValue,
                 ParameterLength,
                 *ParameterLength
                 ));

    DWORD error = InternetReadRegistryStringKey(HKEY_CURRENT_USER,
                                                ParameterName,
                                                ParameterValue,
                                                ParameterLength
                                                );

    DEBUG_LEAVE(error);

    return error;
}


PUBLIC
DWORD
InternetReadRegistryDwordKey(
    IN HKEY ParameterKey,
    IN LPCSTR ParameterName,
    OUT LPDWORD ParameterValue
    )

/*++

Routine Description:

    Reads a single DWORD from a the Internet Client registry key if the platform
    is NT/Win95, else reads the value from SYSTEM.INI if we are running on Win32s.

    Does not modify the *ParameterValue if the registry variable cannot be read

Arguments:

    ParameterKey    - root registry key (e.g. HKEY_CURRENT_USER)

    ParameterName   - name of the parameter to retrieve (e.g. AccessType)

    ParameterValue  - pointer to place to store retrieved value

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_PATH_NOT_FOUND

--*/

{
    DEBUG_ENTER((DBG_REGISTRY,
                 Dword,
                 "InternetReadRegistryDwordKey",
                 "%s, %q, %x",
                 (ParameterKey == HKEY_LOCAL_MACHINE)
                    ? "HKEY_LOCAL_MACHINE"
                    : (ParameterKey == HKEY_CURRENT_USER)
                        ? "HKEY_CURRENT_USER"
                        : "???",
                 ParameterName,
                 ParameterValue
                 ));

    DWORD error = ERROR_SUCCESS;
    HKEY clientKey = hKeyInternetSettings;

    if (ParameterKey != HKEY_CURRENT_USER) {
        error = REGOPENKEYEX(ParameterKey,
                             INTERNET_SETTINGS_KEY,
                             0, // reserved
                             KEY_QUERY_VALUE,
                             &clientKey
                             );
    } else if (clientKey == NULL) {
        error = ERROR_PATH_NOT_FOUND;
    }

    if (error == ERROR_SUCCESS) {
        error = ReadRegistryDword(clientKey,
                                  ParameterName,
                                  ParameterValue
                                  );
        if (clientKey != hKeyInternetSettings) {
            REGCLOSEKEY(clientKey);
        }
    }

    DEBUG_PRINT(REGISTRY,
                INFO,
                ("InternetReadRegistryDwordKey(%q): value = %d (%#x)\n",
                ParameterName,
                *ParameterValue,
                *ParameterValue
                ));

    DEBUG_LEAVE(error);

    return error;
}


PRIVATE
DWORD
InternetReadRegistryStringKey(
    IN HKEY ParameterKey,
    IN LPCSTR ParameterName,
    OUT LPSTR ParameterValue,
    IN OUT LPDWORD ParameterLength
    )

/*++

Routine Description:

    Reads a string from the Internet Client registry key on NT/Win95, or reads
    the corresponding value from SYSTEM.INI on a Win32s platform

Arguments:

    ParameterKey    - root registry key (e.g. HKEY_LOCAL_MACHINE)

    ParameterName   - name of value parameter within key (e.g. EmailName)

    ParameterValue  - pointer to string buffer for returned string

    ParameterLength - IN: number of bytes in ParameterValue
                      OUT: number of bytes in string (excluding trailing '\0')

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_PATH_NOT_FOUND

--*/

{
    DEBUG_ENTER((DBG_REGISTRY,
                 Dword,
                 "InternetReadRegistryStringKey",
                 "%s (%x), %q, %x, %x [%d]",
                 (ParameterKey == HKEY_LOCAL_MACHINE)
                    ? "HKEY_LOCAL_MACHINE"
                    : (ParameterKey == HKEY_CURRENT_USER)
                        ? "HKEY_CURRENT_USER"
                        : "???",
                 ParameterKey,
                 ParameterName,
                 ParameterValue,
                 ParameterLength,
                 *ParameterLength
                 ));

    //
    // zero-terminate the string
    //

    if (*ParameterLength > 0) {
        *ParameterValue = '\0';
    }

    DWORD error = ERROR_SUCCESS;
    HKEY clientKey = hKeyInternetSettings;

    if (ParameterKey != HKEY_CURRENT_USER) {
        error = REGOPENKEYEX(ParameterKey,
                             INTERNET_SETTINGS_KEY,
                             0, // reserved
                             KEY_QUERY_VALUE,
                             &clientKey
                             );
    } else if (clientKey == NULL) {
        error = ERROR_PATH_NOT_FOUND;
    }

    if (error == ERROR_SUCCESS) {
        error = ReadRegistryOemString(clientKey,
                                      ParameterName,
                                      ParameterValue,
                                      ParameterLength
                                      );
        if (clientKey != hKeyInternetSettings) {
            REGCLOSEKEY(clientKey);
        }
    }

    DEBUG_PRINT(REGISTRY,
                INFO,
                ("InternetReadRegistryStringKey(%q): value = %q\n",
                ParameterName,
                ParameterValue
                ));

    DEBUG_LEAVE(error);

    return error;
}


PRIVATE
DWORD
ReadRegistryOemString(
    IN HKEY Key,
    IN LPCSTR ParameterName,
    OUT LPSTR String,
    IN OUT LPDWORD Length
    )

/*++

Routine Description:

    Reads a string out of the registry as an OEM string

Arguments:

    Key             - open registry key where to read value from

    ParameterName   - name of registry value to read

    String          - place to put it

    Length          - IN: length of String buffer in characters
                      OUT: length of String in characters, as if returned from
                      strlen()

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_FILE_NOT_FOUND
                    Couldn't find the parameter

                  ERROR_PATH_NOT_FOUND
                    Couldn't find the parameter

                  ERROR_INTERNET_BAD_REGISTRY_PARAMETER
                    Inconsistent registry contents

--*/

{
    DEBUG_ENTER((DBG_REGISTRY,
                 Dword,
                 "ReadRegistryOemString",
                 "%#x, %q, %#x, %#x [%d]",
                 Key,
                 ParameterName,
                 String,
                 Length,
                 *Length
                 ));

    LONG error;
    DWORD valueType;
    LPSTR str;
    DWORD valueLength;

    //
    // first, get the length of the string
    //

    valueLength = *Length;
    error = RegQueryValueEx(Key,
                            ParameterName,
                            NULL, // reserved
                            &valueType,
                            (LPBYTE)String,
                            &valueLength
                            );
    if (error != ERROR_SUCCESS) {
        goto quit;
    }

    //
    // we only support REG_SZ (single string) values in this function
    //

    if (valueType != REG_SZ) {
        error = ERROR_INTERNET_BAD_REGISTRY_PARAMETER;
        goto quit;
    }

    //
    // if 1 or 0 chars returned then the string is empty
    //

    if (valueLength <= sizeof(char)) {
        error = ERROR_PATH_NOT_FOUND;
        goto quit;
    }

    //
    // convert the ANSI string to OEM character set in place. According to Win
    // help, this always succeeds
    //

    CharToOem(String, String);

    //
    // return the length as if returned from strlen() (i.e. drop the '\0')
    //

    *Length = valueLength - sizeof(char);

    DEBUG_PRINT(REGISTRY,
                INFO,
                ("ReadRegistryOemString(%q) returning %q (%d chars)\n",
                ParameterName,
                String,
                *Length
                ));

quit:

    DEBUG_LEAVE(error);

    return error;
}


DWORD
ReadRegistryDword(
    IN HKEY Key,
    IN LPCSTR ParameterName,
    OUT LPDWORD ParameterValue
    )

/*++

Routine Description:

    Reads a DWORD parameter from the registry

    Won't modify *ParameterValue unless a valid value is read from the registry

Arguments:

    Key             - handle of open registry key where parameter resides

    ParameterName   - name of DWORD parameter to read

    ParameterValue  - returned DWORD parameter read from registry

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_PATH_NOT_FOUND
                    One of the following occurred:
                        - the parameter is not in the specified registry key
                        - the parameter is the wrong type
                        - the parameter is the wrong size

--*/

{
    DEBUG_ENTER((DBG_REGISTRY,
                 Dword,
                 "ReadRegistryDword",
                 "%x, %q, %x",
                 Key,
                 ParameterName,
                 ParameterValue
                 ));

    DWORD error;
    DWORD valueLength;
    DWORD valueType;
    DWORD value;

    valueLength = sizeof(*ParameterValue);
    error = (DWORD)RegQueryValueEx(Key,
                                   ParameterName,
                                   NULL, // reserved
                                   &valueType,
                                   (LPBYTE)&value,
                                   &valueLength
                                   );

    //
    // if the size or type aren't correct then return an error, else only if
    // success was returned do we modify *ParameterValue
    //

    if (error == ERROR_SUCCESS) {
        if (((valueType != REG_DWORD)
        && (valueType != REG_BINARY))
        || (valueLength != sizeof(DWORD))) {

            DEBUG_PRINT(REGISTRY,
                        ERROR,
                        ("valueType = %d, valueLength = %d\n",
                        valueType,
                        valueLength
                        ));

            error = ERROR_PATH_NOT_FOUND;
        } else {
            *ParameterValue = value;
        }
    }

    DEBUG_LEAVE(error);

    return error;
}


PRIVATE
DWORD
WriteRegistryDword(
    IN HKEY Key,
    IN LPCSTR ParameterName,
    IN DWORD ParameterValue
    )

/*++

Routine Description:

    Writes a DWORD parameter from the registry

    Will write ParameterValue to the key.

Arguments:

    Key             - handle of open registry key where parameter resides

    ParameterName   - name of DWORD parameter to write

    ParameterValue  - DWORD parameter to write from registry

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_PATH_NOT_FOUND
                    One of the following occurred:
                        - the parameter is not in the specified registry key
                        - the parameter is the wrong type
                        - the parameter is the wrong size

--*/

{
    DEBUG_ENTER((DBG_REGISTRY,
                 Dword,
                 "WriteRegistryDword",
                 "%x, %q, %x",
                 Key,
                 ParameterName,
                 ParameterValue
                 ));

    DWORD error;
    DWORD valueLength;
    DWORD valueType;
    DWORD value;

    valueLength = sizeof(ParameterValue);
    valueType   = REG_DWORD;
    value       = ParameterValue;

    error = (DWORD)RegSetValueEx(Key,
                                 ParameterName,
                                 NULL, // reserved
                                 valueType,
                                 (LPBYTE)&value,
                                 valueLength
                                 );

    DEBUG_PRINT(REGISTRY,
                INFO,
                ("added: valueType = %d, valueLength = %d\n",
                valueType,
                valueLength
                ));

    DEBUG_LEAVE(error);

    return error;
}

#if INET_DEBUG

typedef struct {
    LIST_ENTRY entry;
    HKEY hkey;
    char * file;
    int line;
    char name[1];
} DBGREGKEYINFO;

#if 0
SERIALIZED_LIST DbgRegKeyList;
#endif

VOID DbgRegKey_Init(VOID) {
 #if 0
    InitializeSerializedList(&DbgRegKeyList);
 #endif
}

VOID DbgRegKey_Terminate(VOID) {
 #if 0
    TerminateSerializedList(&DbgRegKeyList);
 #endif
}

void regkey_add(const char * name, HKEY hkey, char * file, int line) {
 #if 0
    if (!name) {
        name = "";
    }

    int len = lstrlen(name);
    DBGREGKEYINFO * p = (DBGREGKEYINFO *)ALLOCATE_FIXED_MEMORY(sizeof(DBGREGKEYINFO) + len);

    if (p) {
        memcpy(p->name, name, len + 1);
        p->line = line;
        p->file = file;
        p->hkey = hkey;
        InsertAtHeadOfSerializedList(&DbgRegKeyList, &p->entry);
    }
 #endif
}

void regkey_remove(HKEY hkey) {
 #if 0
    LockSerializedList(&DbgRegKeyList);

    DBGREGKEYINFO * p = (DBGREGKEYINFO *)HeadOfSerializedList(&DbgRegKeyList);
    while (p != (DBGREGKEYINFO *)SlSelf(&DbgRegKeyList)) {
        if (p->hkey == hkey) {
            RemoveFromSerializedList(&DbgRegKeyList, (PLIST_ENTRY)p);
            FREE_MEMORY(p);
            break;
        }
        p = (DBGREGKEYINFO *)p->entry.Flink;
    }
    UnlockSerializedList(&DbgRegKeyList);
 #endif
}

#undef NEW_STRING
#define NEW_STRING(str) (str)
char * regkey_name(HKEY hkey, const char * subname) {
    switch ((INT_PTR)hkey) {
    case (INT_PTR)HKEY_CLASSES_ROOT:
        return NEW_STRING("HKEY_CLASSES_ROOT");

    case (INT_PTR)HKEY_CURRENT_USER:
        return NEW_STRING("HKEY_CURRENT_USER");

    case (INT_PTR)HKEY_LOCAL_MACHINE:
        return NEW_STRING("HKEY_LOCAL_MACHINE");

    case (INT_PTR)HKEY_USERS:
        return NEW_STRING("HKEY_USERS");

    case (INT_PTR)HKEY_PERFORMANCE_DATA:
        return NEW_STRING("HKEY_PERFORMANCE_DATA");

    case (INT_PTR)HKEY_CURRENT_CONFIG:
        return NEW_STRING("HKEY_CURRENT_CONFIG");

    case (INT_PTR)HKEY_DYN_DATA:
        return NEW_STRING("HKEY_DYN_DATA");
    }

    char * name = NULL;
  #if 0
    LockSerializedList(&DbgRegKeyList);

    DBGREGKEYINFO * p = (DBGREGKEYINFO *)HeadOfSerializedList(&DbgRegKeyList);

    while (p != (DBGREGKEYINFO *)SlSelf(&DbgRegKeyList)) {
        if (p->hkey == hkey) {

            int len = lstrlen(p->name);
            int slen = lstrlen(subname);

            name = (char *)ALLOCATE_FIXED_MEMORY(len + 1 + slen + 1);
            if (name) {
                memcpy(name, p->name, len);
                name[len] = '\\';
                memcpy(name + len + 1, subname, slen + 1);
            }
            break;
        }
        p = (DBGREGKEYINFO *)p->entry.Flink;
    }
    UnlockSerializedList(&DbgRegKeyList);
  #endif
    return name;
}

void regkey_freename(char * name) {
 #if 0
    if (name) {
        FREE_MEMORY(name);
    }
 #endif
}

LONG
DbgRegOpenKey(
    IN HKEY hKey,
    IN LPCTSTR lpszSubKey,
    OUT PHKEY phkResult,
    char * file,
    int line
    )
{
    char * keyname = regkey_name(hKey, lpszSubKey);
    LONG rc = RegOpenKey(hKey, lpszSubKey, phkResult);

    if (rc == 0) {
        regkey_add(keyname, *phkResult, file, line);
    }
    regkey_freename(keyname);
    return rc;
}

LONG
DbgRegOpenKeyEx(
    IN HKEY hKey,
    IN LPCSTR lpSubKey,
    IN DWORD ulOptions,
    IN REGSAM samDesired,
    OUT PHKEY phkResult,
    char * file,
    int line
    )
{
    char * keyname = regkey_name(hKey, lpSubKey);
    LONG rc = RegOpenKeyEx(hKey, lpSubKey, ulOptions, samDesired, phkResult);

    if (rc == 0) {
        regkey_add(keyname, *phkResult, file, line);
    }
    regkey_freename(keyname);
    return rc;
}

LONG
DbgRegCreateKeyEx(
    IN HKEY hKey,
    IN LPCSTR lpSubKey,
    IN DWORD Reserved,
    IN LPSTR lpClass,
    IN DWORD dwOptions,
    IN REGSAM samDesired,
    IN LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    OUT PHKEY phkResult,
    OUT LPDWORD lpdwDisposition,
    char * file,
    int line
    )
{
    char * keyname = regkey_name(hKey, lpSubKey);
    LONG rc = RegCreateKeyEx(hKey, lpSubKey, Reserved, lpClass, dwOptions, samDesired, lpSecurityAttributes, phkResult, lpdwDisposition);

    if (rc == 0) {
        regkey_add(keyname, *phkResult, file, line);
    }
    regkey_freename(keyname);
    return rc;
}

LONG
DbgRegCloseKey(
    IN HKEY hKey
    )
{
    LONG rc = RegCloseKey(hKey);

    if (rc == 0) {
        regkey_remove(hKey);
    }
    return rc;
}

#endif // INET_DEBUG
#endif // ENABLE_DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\urlmon\utils\registry.h ===
/*++

Module Name:

    registry.h

Abstract:

    Prototypes, etc., for registry.c

Author:

    Venkatraman Kudallur (venkatk)
    ( Ripped off from wininet )
    
Revision History:

    3-10-2000 venkatk
        Created

--*/

#ifndef _REGISTRY_H_
#define _REGISTRY_H_ 1

#if defined(__cplusplus)
extern "C" {
#endif

#ifdef ENABLE_DEBUG

#define INTERNET_POLICY_KEY         "SOFTWARE\\Policies\\Microsoft\\Windows\\CurrentVersion\\Internet Settings"

//
// prototypes
//

DWORD
OpenInternetSettingsKey(
    VOID
    );

DWORD
CloseInternetSettingsKey(
    VOID
    );

DWORD
GetMyEmailName(
    OUT LPSTR EmailName,
    IN OUT LPDWORD Length
    );

DWORD
GetMyDomainName(
    OUT LPSTR DomainName,
    IN OUT LPDWORD Length
    );

BOOL
GetFileExtensionFromMimeType(
    IN LPCSTR  lpszMimeType,
    IN DWORD   dwMimeLen,
    IN LPSTR   lpszFileExtension,
    IN OUT LPDWORD lpdwLen
    );

DWORD
InternetDeleteRegistryValue(
    IN LPSTR ParameterName
    );

DWORD
InternetReadRegistryDword(
    IN LPCSTR ParameterName,
    OUT LPDWORD ParameterValue
    );


DWORD
InternetCacheReadRegistryDword(
    IN LPCSTR ParameterName,
    OUT LPDWORD ParameterValue
    );

DWORD
InternetWriteRegistryDword(
    IN LPCSTR ParameterName,
    IN DWORD ParameterValue
    );

DWORD
InternetReadRegistryDwordKey(
    IN HKEY ParameterKey,
    IN LPCSTR ParameterName,
    OUT LPDWORD ParameterValue
    );

DWORD
InternetReadRegistryString(
    IN LPCSTR ParameterName,
    OUT LPSTR ParameterValue,
    IN OUT LPDWORD ParameterLength
    );

DWORD
ReadRegistryDword(
    IN HKEY Key,
    IN LPCSTR ParameterName,
    OUT LPDWORD ParameterValue
    );


DWORD
InternetWriteRegistryString(
    IN LPCSTR ParameterName,
    IN LPSTR ParameterValue
    );

DWORD
CreateMimeExclusionTableForCache(VOID);

DWORD
CreateHeaderExclusionTableForCache(VOID);

VOID
DestroyMimeExclusionTableForCache(VOID);

VOID
DestroyHeaderExclusionTableForCache(VOID);

#endif //ENABLE_DEBUG

#if INET_DEBUG

VOID
DbgRegKey_Init(
    VOID
    );

VOID
DbgRegKey_Terminate(
    VOID
    );

LONG
DbgRegOpenKey(
    IN HKEY hKey,
    IN LPCTSTR lpszSubKey,
    OUT PHKEY phkResult,
    char * file,
    int line
    );

LONG
DbgRegOpenKeyEx(
    IN HKEY hKey,
    IN LPCSTR lpSubKey,
    IN DWORD ulOptions,
    IN REGSAM samDesired,
    OUT PHKEY phkResult,
    char * file,
    int line
    );

LONG
DbgRegCreateKeyEx(
    IN HKEY hKey,
    IN LPCSTR lpSubKey,
    IN DWORD Reserved,
    IN LPSTR lpClass,
    IN DWORD dwOptions,
    IN REGSAM samDesired,
    IN LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    OUT PHKEY phkResult,
    OUT LPDWORD lpdwDisposition,
    char * file,
    int line
    );

LONG
DbgRegCloseKey(
    IN HKEY hKey
    );

#define INITIALIZE_DEBUG_REGKEY() \
    DbgRegKey_Init()

#define TERMINATE_DEBUG_REGKEY() \
    DbgRegKey_Terminate()

#define REGOPENKEY(a, b, c) \
    DbgRegOpenKey((a), (b), (c), __FILE__, __LINE__)

#define REGOPENKEYEX(a, b, c, d, e) \
    DbgRegOpenKeyEx((a), (b), (c), (d), (e), __FILE__, __LINE__)

#define REGCREATEKEYEX(a, b, c, d, e, f, g, h, i) \
    DbgRegCreateKeyEx((a), (b), (c), (d), (e), (f), (g), (h), (i), __FILE__, __LINE__)

#define REGCLOSEKEY(a) \
    DbgRegCloseKey(a)

#else

#define INITIALIZE_DEBUG_REGKEY() \
    /* NOTHING */

#define TERMINATE_DEBUG_REGKEY() \
    /* NOTHING */

#define REGOPENKEY(a, b, c) \
    RegOpenKey((a), (b), (c))

#define REGOPENKEYEX(a, b, c, d, e) \
    RegOpenKeyEx((a), (b), (c), (d), (e))

#define REGCREATEKEYEX(a, b, c, d, e, f, g, h, i) \
    RegCreateKeyEx((a), (b), (c), (d), (e), (f), (g), (h), (i))

#define REGCLOSEKEY(a) \
    RegCloseKey(a)

#endif // INET_DEBUG

#if defined(__cplusplus)
}
#endif

#endif // _REGISTRY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\urlmon\utils\rprintf.h ===
/*++

Module Name:

    rprintf.h

Author:

    Venkatraman Kudallur (venkatk) 
    ( Ripped off from wininet )
        
Revision History:

    3-10-2000 venkatk
    Created

--*/

#ifndef _RPRINTF_H_
#define _RPRINTF_H_ 1

#ifdef UNUSED
// UNUSED - causes unneed crt bloat
int cdecl rprintf(char*, ...);
#endif

#include <stdarg.h>

int cdecl rsprintf(char*, char*, ...);
int cdecl _sprintf(char*, char*, va_list);

#define SPRINTF rsprintf
#define PRINTF  rprintf

#define RPRINTF_INCLUDED

#endif //_RPRINTF_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\urlmon\utils\rprintf.cxx ===
/*++

Module Name:

    rprintf.cxx

Abstract:

    Contents:
        rprintf     limited re-entrant version of printf
        rsprintf    limited re-entrant version of sprintf
        _sprintf    routine which does the work

Author:

    Venkatraman Kudallur (venkatk)
    ( Ripped off from wininet )

Revision History:

    3-10-2000 venkatk
        Created

--*/

#ifdef ENABLE_DEBUG

#include <urlint.h>
#include "rprintf.h"

//from macros.h
#define PRIVATE
#define PUBLIC

//
// defines for flags word
//

#define F_SPACES        0x00000001  // prefix field with spaces
#define F_ZEROES        0x00000002  // prefix field with zeroes
#define F_MINUS         0x00000004  // field is left justified
#define F_HASH          0x00000008  // hex field is prefixed with 0x/0X
#define F_XUPPER        0x00000010  // hex field has upper case letters
#define F_LONG          0x00000020  // long int/hex/oct prefix
#define F_PLUS          0x00000040  // prefix +'ve signed number with +
#define F_DOT           0x00000080  // separator for field and precision
#define F_NEAR          0x00000100  // far pointer has near prefix
#define F_FAR           0x00000200  // near pointer has far prefix
#define F_SREPLICATE    0x00000400  // this field replicated
#define F_EREPLICATE    0x00000800  // end of replications
#define F_UNICODE       0x00001000  // string is wide character (%ws/%wq)
#define F_QUOTING       0x00002000  // strings enclosed in double quotes
#define F_ELLIPSE       0x00004000  // a sized, quoted string ends in "..."

#define BUFFER_SIZE     1024

//
// minimum field widths for various ASCII representations of numbers
//

#define MIN_BIN_WIDTH   16          // minimum field width in btoa
#define MIN_HEX_WIDTH   8           // minimum field width in xtoa
#define MIN_INT_WIDTH   10          // minimum field width in itoa
#define MIN_LHEX_WIDTH  8           // minimum field width in long xtoa
#define MIN_LINT_WIDTH  10          // minimum field width in long itoa
#define MIN_LOCT_WIDTH  11          // minimum field width in long otoa
#define MIN_OCT_WIDTH   11          // minimum field width in otoa
#define MIN_UINT_WIDTH  10          // minimum field width in utoa

//
// character defines
//

#define EOSTR           '\0'
#define CR              '\x0d'
#define LF              '\x0a'

#if !defined(min)

#define min(a, b)   ((a)<(b)) ? (a) : (b)

#endif

PRIVATE int     _atoi(char**);
PRIVATE void    convert(char**, ULONG_PTR, int, int, unsigned, char(*)(ULONG_PTR*));
PRIVATE char    btoa(ULONG_PTR *);
PRIVATE char    otoa(ULONG_PTR *);
PRIVATE char    utoa(ULONG_PTR *);
PRIVATE char    xtoa(ULONG_PTR *);
PRIVATE char    Xasc(ULONG_PTR *);

/***    rprintf - a re-entrant cut-down version of printf. Understands usual
 *                  printf format characters introduced by '%' plus one or
 *                  two additions
 *
 *      ENTRY   format  - pointer to buffer containing format string defining
 *                        the output. As per usual printf the arguments to
 *                        fill in the blanks in the format string are on the
 *                        the stack after the format string
 *
 *              <args>  - arguments on stack, size and type determined from
 *                        the format string
 *
 *      EXIT    format string used to convert arguments (if any) and print
 *              the results to stdout.
 *              The number of character copied is the value returned
 */

#ifdef UNUSED
int cdecl rprintf(char* format, ...) {

    int charsPrinted = 0;
    char buffer[BUFFER_SIZE];
    DWORD nwritten;
    va_list args;

    /* print the output into  buffer then print the formatted buffer to the
     * screen
     */

    va_start(args, format);
    charsPrinted = _sprintf(buffer, format, args);
    va_end(args);

    WriteConsole(GetStdHandle(STD_OUTPUT_HANDLE),
                              buffer,
                              charsPrinted,
                              &nwritten,
                              0
                              );
    return nwritten;
}
#endif

/***    rsprintf - a re-entrant cut-down version of sprintf. See rprintf for
 *                  details
 *
 *      ENTRY   buffer  - pointer to the buffer which will receive the
 *                        formatted output
 *
 *              format  - pointer to buffer which defines the formatted
 *                        output. Consists of normal printing characters
 *                        and printf-style format characters (see rprintf)
 *
 *      EXIT    characters from format string and arguments converted to
 *              character format based on format string are copied into the
 *              buffer
 *              The number of character copied is the value returned
 */

int cdecl rsprintf(char* buffer, char* format, ...) {

    va_list args;
    int n;

    va_start(args, format);
    n = _sprintf(buffer, format, args);
    va_end(args);
    return n;
}

/***    _sprintf - performs the sprintf function. Receives an extra parameter
 *                  on the stack which is the pointer to the variable argument
 *                  list of rprintf and rsprintf
 *
 *      ENTRY   buffer  - pointer to buffer which will receive the output
 *
 *              format  - pointer to the format string
 *
 *              args    - variable argument list which will be used to fill in
 *                        the escape sequences in the format string
 *
 *      EXIT    The characters in the format string are used to convert the
 *              arguments and copy them to the buffer.
 *              The number of character copied is the value returned
 */

int cdecl _sprintf(char* buffer, char* format, va_list args) {

    char*       original = buffer;
    int         FieldWidth;
    int         FieldPrecision;
    int         FieldLen;
    BOOL        SubDone;
    int         StrLen;
    int         i;
    DWORD       flags;
    int         replications;

    while (*format) {
        switch ((unsigned)*format) {
        case '\n':

            //
            // convert line-feed to carriage-return, line-feed. But only if the
            // format string doesn't already contain a carriage-return directly
            // before the line-feed! This way we can make multiple calls into
            // this function, with the same buffer, and only once expand the
            // line-feed
            //

            if (*(buffer - 1) != CR) {
                *buffer++ = CR;
            }
            *buffer++ = LF;
            break;

        case '%':
            SubDone = FALSE;
            flags = 0;
            FieldWidth = 0;
            FieldPrecision = 0;
            replications = 1;   /* default replication is 1 */
            while (!SubDone) {
                switch ((unsigned)*++format) {
                case '%':
                    *buffer++ = '%';
                    SubDone = TRUE;
                    break;

                case ' ':
                    flags |= F_SPACES;
                    break;

                case '#':
                    flags |= F_HASH;
                    break;

                case '-':
                    flags |= F_MINUS;
                    break;

                case '+':
                    flags |= F_PLUS;
                    break;

                case '.':
                    flags |= F_DOT;
                    break;

                case '*':
                    if (flags & F_DOT) {
                        FieldPrecision = va_arg(args, int);
                    } else {
                        FieldWidth = va_arg(args, int);
                    }
                    break;

                case '@':
                    replications = _atoi(&format);
                    break;

                case '[':
                    flags |= F_SREPLICATE;
                    break;

                case ']':
                    flags |= F_EREPLICATE;
                    break;

                case '0':
                    /* if this is leading zero then caller wants
                     * zero prefixed number of given width (%04x)
                     */
                    if (!(flags & F_ZEROES)) {
                        flags |= F_ZEROES;
                        break;
                    }

                case '1':
                case '2':
                case '3':
                case '4':
                case '5':
                case '6':
                case '7':
                case '8':
                case '9':
                    if (flags & F_DOT) {
                        FieldPrecision = _atoi(&format);
                    } else {
                        FieldWidth = _atoi(&format);
                    }
                    break;

                case 'b':

                    //
                    // Binary representation
                    //

                    while (replications--) {
                        convert(&buffer,
                                va_arg(args, unsigned int),
                                (FieldWidth) ? FieldWidth : MIN_BIN_WIDTH,
                                MIN_BIN_WIDTH,
                                flags,
                                btoa
                                );
                    }
                    SubDone = TRUE;
                    break;

                case 'B':

                    //
                    // Boolean representation
                    //

                    if (va_arg(args, BOOL)) {
                        *buffer++ = 'T';
                        *buffer++ = 'R';
                        *buffer++ = 'U';
                        *buffer++ = 'E';
                    } else {
                        *buffer++ = 'F';
                        *buffer++ = 'A';
                        *buffer++ = 'L';
                        *buffer++ = 'S';
                        *buffer++ = 'E';
                    }
                    SubDone = TRUE;
                    break;

                case 'c':

                    //
                    // assume that a character is the size of the
                    // width of the stack which in turn has the same
                    // width as an integer
                    //

                    --FieldWidth;
                    while (replications--) {
                        for (i = 0; i < FieldWidth; i++) {
                            *buffer++ = ' ';
                        }
                        *buffer++ = (char) va_arg(args, int);
                    }
                    SubDone = TRUE;
                    break;

                case 'd':
                case 'i':
                    while (replications--) {

                        long l;

                        l = (flags & F_LONG) ? va_arg(args, long) : (long)va_arg(args, int);
                        if (l < 0) {
                            *buffer++ = '-';
                            if (flags & F_LONG) {
                                l = -(long)l;
                            } else {
                                l = -(int)l;
                            }
                        } else if (flags & F_PLUS) {
                            *buffer++ = '+';
                        }
                        convert(&buffer,
                                l,
                                FieldWidth,
                                (flags & F_LONG) ? MIN_LINT_WIDTH : MIN_INT_WIDTH,
                                flags,
                                utoa
                                );
                    }
                    SubDone = TRUE;
                    break;

                case 'e':
                    /* not currently handled */
                    break;

                case 'f':
                    /* not currently handled */
                    break;

                case 'F':
                    flags |= F_FAR;
                    break;

                case 'g':
                case 'G':
                    /* not currently handled */
                    break;

                case 'h':
                    /* not currently handled */
                    break;

                case 'l':
                    flags |= F_LONG;
                    break;

                case 'L':
                    /* not currently handled */
                    break;

                case 'n':
                    *(va_arg(args, int*))  = (int)(buffer - original);
                    SubDone = TRUE;
                    break;

                case 'N':
                    flags |= F_NEAR;
                    break;

                case 'o':
                    while (replications--) {
                        convert(&buffer,
                                (flags & F_LONG) ? va_arg(args, unsigned long) : (unsigned long)va_arg(args, unsigned),
                                FieldWidth,
                                (flags & F_LONG) ? MIN_LOCT_WIDTH : MIN_OCT_WIDTH,
                                flags,
                                otoa
                                );
                    }
                    SubDone = TRUE;
                    break;

                case 'p':
                    while (replications--) {

                        void* p;

                        if (!(flags & F_NEAR)) {
                            convert(&buffer,
                                    (ULONG_PTR) va_arg(args, char near *),
                                    MIN_HEX_WIDTH,
                                    MIN_HEX_WIDTH,
                                    flags | F_XUPPER,
                                    Xasc
                                    );
                            *buffer++ = ':';
                        }
                        convert(&buffer,
                                (ULONG_PTR)va_arg(args, unsigned),
                                MIN_HEX_WIDTH,
                                MIN_HEX_WIDTH,
                                flags | F_XUPPER,
                                Xasc
                                );
                    }
                    SubDone = TRUE;
                    break;

                case 'Q':       // quoted unicode string
                    flags |= F_UNICODE;
                    // *** FALL THROUGH ***

                case 'q':
                    *buffer++ = '"';
                    flags |= F_QUOTING;

                    //
                    // *** FALL THROUGH ***
                    //

                case 's':
                    while (replications--) {

                        char* s;

                        s = va_arg(args, char*);
                        if (s != NULL) {

                            // darrenmi 2/24/00 Note that if the string has a field precision,
                            // it's not always null terminated!! Don't depend on it being psz
                            // and stop when we hit our max length.
                            StrLen = 0;

                            if (flags & F_UNICODE) {
                                WCHAR   *pWork = (LPWSTR)s;
                                while((!FieldPrecision || StrLen < FieldPrecision) && *pWork)
                                {
                                    pWork++;
                                    StrLen++;
                                }
                            } else {
                                CHAR    *pWork = s;
                                while((!FieldPrecision || StrLen < FieldPrecision) && *pWork)
                                {
                                    pWork++;
                                    StrLen++;
                                }
                            }

                            FieldLen = (FieldPrecision)
                                        ? min(StrLen, FieldPrecision)
                                        : StrLen
                                        ;
                            if ((flags & F_QUOTING) && (FieldPrecision > 3) && (FieldLen == FieldPrecision)) {
                                FieldLen -= 3;
                                flags |= F_ELLIPSE;
                            }

                            for (i = 0; i < (FieldWidth - FieldLen); i++) {
                                *buffer++ = ' ';
                            }

                            if (flags & F_UNICODE) {

                                char wbuf[4096];
                                int wi;

                                WideCharToMultiByte(CP_ACP, 0,
                                        (LPWSTR)s, -1,
                                        wbuf, 4096,
                                        NULL, NULL);

                                for (wi = 0; wbuf[wi] && FieldLen; ++wi) {
                                    *buffer = wbuf[wi];

                                    //
                                    // if this is a quoted string, and it contains
                                    // \r and/or \n, then we reverse-convert these
                                    // characters, since we don't want then to
                                    // break the string. Do the same for \t
                                    //

                                    if (flags & F_QUOTING) {

                                        char ch;

                                        ch = *buffer;
                                        if ((ch == '\r') || (ch == '\n') || (ch == '\t')) {
                                            *buffer++ = '\\';
                                            *buffer = (ch == '\r')
                                                        ? 'r'
                                                        : (ch == '\n')
                                                            ? 'n'
                                                            : 't'
                                                            ;
                                        }
                                    }
                                    ++buffer;
                                    --FieldLen;
                                }
                            } else {
                                while (*s && FieldLen) {
                                    *buffer = *s++;

                                    //
                                    // if this is a quoted string, and it contains
                                    // \r and/or \n, then we reverse-convert these
                                    // characters, since we don't want then to
                                    // break the string. Do the same for \t
                                    //

                                    if (flags & F_QUOTING) {

                                        char ch;

                                        ch = *buffer;
                                        if ((ch == '\r') || (ch == '\n') || (ch == '\t')) {
                                            *buffer++ = '\\';
                                            *buffer = (ch == '\r')
                                                        ? 'r'
                                                        : (ch == '\n')
                                                            ? 'n'
                                                            : 't'
                                                            ;
                                        }
                                    }
                                    ++buffer;
                                    --FieldLen;
                                }
                            }
                            if (flags & F_ELLIPSE) {
                                *buffer++ = '.';
                                *buffer++ = '.';
                                *buffer++ = '.';
                            }
                        } else if (!(flags & F_QUOTING)) {
                            *buffer++ = '(';
                            *buffer++ = 'n';
                            *buffer++ = 'u';
                            *buffer++ = 'l';
                            *buffer++ = 'l';
                            *buffer++ = ')';
                        }
                    }
                    if (flags & F_QUOTING) {
                        *buffer++ = '"';
                    }
                    SubDone = TRUE;
                    break;

                case 'S':
                    break;

                case 'u':
                    while (replications--) {
                        convert(&buffer,
                                va_arg(args, unsigned),
                                FieldWidth,
                                MIN_UINT_WIDTH,
                                flags,
                                utoa
                                );
                    }
                    SubDone = TRUE;
                    break;

                case 'w':
                    flags |= F_UNICODE;
                    break;

                case 'X':
                    flags |= F_XUPPER;

                    //
                    // *** FALL THROUGH ***
                    //

                case 'x':
                    while (replications--) {
                        if (flags & F_HASH) {
                            *buffer++ = '0';
                            *buffer++ = (flags & F_XUPPER) ? (char)'X' : (char)'x';
                        }
                        convert(&buffer,
                                (flags & F_LONG) ? va_arg(args, unsigned long) : va_arg(args, unsigned),
                                FieldWidth,
                                (flags & F_LONG) ? MIN_LHEX_WIDTH : MIN_HEX_WIDTH,
                                flags,
                                (flags & F_XUPPER) ? Xasc : xtoa
                                );
                    }
                    SubDone = TRUE;
                    break;
                } /* switch <%-specifier> */
            }
            break;

        default:
            *buffer++ = *format;
        } /* switch <character> */
        ++format;
    } /* while */
    *buffer = EOSTR;
    return (int)(buffer - original);
}

/***    _atoi - ascii to integer conversion used to get the field width out
 *              of the format string
 *
 *      ENTRY   p - pointer to pointer to format string
 *
 *      EXIT    returns the number found in the prefix string as a (16-bit)
 *              int format string pointer is updated past the field width
 */

PRIVATE
int _atoi(char** p) {

    int n = 0;
    int i = 5;

    while ((**p >= '0' && **p <= '9') && i--) {
        n = n*10+((int)(*(*p)++)-(int)'0');
    }

    /* put the format pointer back one since the major loop tests *++format */

    --*p;
    return n;
}

/***    convert - convert number to representation defined by procedure
 *
 *      ENTRY   buffer  - pointer to buffer to receive conversion
 *              n       - number to convert
 *              width   - user defined field width
 *              mwidth  - minimum width for representation
 *              flags   - flags controlling conversion
 *              proc    - pointer to conversion routine
 *
 *      EXIT    buffer is updated to point past the number representation
 *              just put into it
 */

PRIVATE
void
convert(
    char** buffer,
    ULONG_PTR n,
    int width,
    int mwidth,
    unsigned flags,
    char (*proc)(ULONG_PTR*)
    )
{
    char    numarray[33];
    int     MinWidth;
    int     i;

    MinWidth = (width < mwidth) ? mwidth : width;
    i = MinWidth;
    do {
        numarray[--i] = (*proc)(&n);
    } while (n);
    while (width > MinWidth-i) {
        numarray[--i] = (char)((flags & F_SPACES) ? ' ' : '0');
    }
    while (i < MinWidth) {
        *(*buffer)++ = numarray[i++];
    }
}

/***    btoa - return next (least significant) char in a binary to ASCII
 *              conversion
 *
 *      ENTRY   pn  - pointer to number to convert
 *
 *      EXIT    returns next (LS) character, updates original number
 */

PRIVATE
char btoa(ULONG_PTR *pn) {

    char    rch;

    rch = (char)(*pn&1)+'0';
    *pn >>= 1;
    return rch;
}

/***    otoa - return next (least significant) char in an octal to ASCII
 *              conversion
 *
 *      ENTRY   pn  - pointer to number to convert
 *
 *      EXIT    returns next (LS) character, updates original number
 */

PRIVATE
char otoa(ULONG_PTR *pn) {

    char    rch;

    rch = (char)'0'+(char)(*pn&7);
    *pn >>= 3;
    return rch;
}

/***    utoa - return next (least significant) char in an unsigned int to
 *              ASCII conversion
 *
 *      ENTRY   pn  - pointer to number to convert
 *
 *      EXIT    returns next (LS) character, updates original number
 */

PRIVATE
char utoa(ULONG_PTR *pn) {

    char    rch;

    rch = (char)'0'+(char)(*pn%10);
    *pn /= 10;
    return rch;
}

/***    xtoa - return next (least significant) char in a hexadecimal to
 *              ASCII conversion. Returns lower case hex characters
 *
 *      ENTRY   pn  - pointer to number to convert
 *
 *      EXIT    returns next (LS) character, updates original number
 */

PRIVATE
char xtoa(ULONG_PTR *pn) {

    ULONG_PTR   n = *pn & 0x000f;
    char        rch = 	(n <= 9)
                        ? (char)n+'0'
                        : (char)n+'0'+('a'-'9'-1);

    *pn >>= 4;
    return rch;
}

/***    Xasc - return next (least significant) char in a hexadecimal to
 *              ASCII conversion. Returns upper case hex characters
 *
 *      ENTRY   pn  - pointer to number to convert
 *
 *      EXIT    returns next (LS) character, updates original number
 */

PRIVATE
char Xasc(ULONG_PTR *pn) {

    ULONG_PTR   n = *pn & 0x000f;
    char        rch = 	(n <= 9)
                        ? (char)n+'0'
                        : (char)n+'0'+('A'-'9'-1);

    *pn >>= 4;
    return rch;
}
#endif // ENABLE_DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\urlmon\utils\valid.h ===
#if DBG==1 && defined(WIN32) && !defined(_CHICAGO_)
#define VDATEHEAP() if( !HeapValidate(GetProcessHeap(),0,0)){ DebugBreak();}
#else
#define VDATEHEAP()
#endif  //  DBG==1 && defined(WIN32) && !defined(_CHICAGO_)

#define IsValidPtrIn(pv,cb)  ((pv == NULL) || !IsBadReadPtr ((pv),(cb)))
#define IsValidPtrOut(pv,cb) (!IsBadWritePtr((pv),(cb)))

STDAPI_(BOOL) IsValidInterface( void FAR* pv );


#if DBG==1
// for performance, do not do in retail builds
STDAPI_(BOOL) IsValidIid( REFIID riid );
#else
#define IsValidIid(x) (TRUE)
#endif

#ifdef _DEBUG

//** POINTER IN validation macros:
#define VDATEPTRIN( pv, TYPE ) \
        if (!IsValidPtrIn( (pv), sizeof(TYPE))) \
    return (FnAssert(#pv,"Invalid in ptr", __FILE__, __LINE__),ResultFromScode(E_INVALIDARG))
#define GEN_VDATEPTRIN( pv, TYPE, retval) \
        if (!IsValidPtrIn( (pv), sizeof(TYPE))) \
    return (FnAssert(#pv,"Invalid in ptr", __FILE__, __LINE__), retval)
#define VOID_VDATEPTRIN( pv, TYPE ) \
        if (!IsValidPtrIn( (pv), sizeof(TYPE))) {\
    FnAssert(#pv,"Invalid in ptr", __FILE__, __LINE__); return; }

//** POINTER IN validation macros for single entry/single exit functions
//** uses a goto instead of return
#define VDATEPTRIN_LABEL(pv, TYPE, label, retVar) \
        if (!IsValidPtrIn((pv), sizeof(TYPE))) \
        { retVar = (FnAssert(#pv, "Invalid in ptr", __FILE__, __LINE__), ResultFromScode(E_INVALIDARG)); \
         goto label; }
#define GEN_VDATEPTRIN_LABEL(pv, TYPE, retval, label, retVar) \
        if (!IsValidPtrIn((pv), sizeof(TYPE))) \
        { retVar = (FnAssert(#pv, "Invalid in ptr", __FILE__, __LINE__), retval); \
         goto label; }
#define VOID_VDATEPTRIN_LABEL(pv, TYPE, label) \
        if (!IsValidPtrIn((pv), sizeof(TYPE))) \
        { FnAssert(#pv, "Invalid in ptr", __FILE__, __LINE__); goto label; }

//** POINTER OUT validation macros:
#define VDATEPTROUT( pv, TYPE ) \
        if (!IsValidPtrOut( (pv), sizeof(TYPE))) \
    return (FnAssert(#pv,"Invalid out ptr", __FILE__, __LINE__),ResultFromScode(E_INVALIDARG))
#define GEN_VDATEPTROUT( pv, TYPE, retval ) \
        if (!IsValidPtrOut( (pv), sizeof(TYPE))) \
    return (FnAssert(#pv,"Invalid out ptr", __FILE__, __LINE__), retval)

//** POINTER OUT validation macros for single entry/single exit functions
//** uses a goto instead of return
#define VDATEPTROUT_LABEL( pv, TYPE, label, retVar ) \
        if (!IsValidPtrOut( (pv), sizeof(TYPE))) \
        { retVar = (FnAssert(#pv,"Invalid out ptr", __FILE__, __LINE__),ResultFromScode(E_INVALIDARG)); \
         goto label; }
#define GEN_VDATEPTROUT_LABEL( pv, TYPE, retval, label, retVar ) \
        if (!IsValidPtrOut( (pv), sizeof(TYPE))) \
        { retVar = (FnAssert(#pv,"Invalid out ptr", __FILE__, __LINE__),retval); \
         goto label; }

//** INTERFACE validation macro:
#define GEN_VDATEIFACE( pv, retval ) \
        if (!IsValidInterface(pv)) \
    return (FnAssert(#pv,"Invalid interface", __FILE__, __LINE__), retval)
#define VDATEIFACE( pv ) \
        if (!IsValidInterface(pv)) \
    return (FnAssert(#pv,"Invalid interface", __FILE__, __LINE__),ResultFromScode(E_INVALIDARG))
#define VOID_VDATEIFACE( pv ) \
        if (!IsValidInterface(pv)) {\
    FnAssert(#pv,"Invalid interface", __FILE__, __LINE__); return; }

//** INTERFACE validation macros for single entry/single exit functions
//** uses a goto instead of return
#define GEN_VDATEIFACE_LABEL( pv, retval, label, retVar ) \
        if (!IsValidInterface(pv)) \
        { retVar = (FnAssert(#pv,"Invalid interface", __FILE__, __LINE__),retval); \
         goto label; }
#define VDATEIFACE_LABEL( pv, label, retVar ) \
        if (!IsValidInterface(pv)) \
        { retVar = (FnAssert(#pv,"Invalid interface", __FILE__, __LINE__),ResultFromScode(E_INVALIDARG)); \
         goto label; }
#define VOID_VDATEIFACE_LABEL( pv, label ) \
        if (!IsValidInterface(pv)) {\
        FnAssert(#pv,"Invalid interface", __FILE__, __LINE__); goto label; }

//** INTERFACE ID validation macro:
// Only do this in debug build
#define VDATEIID( iid ) if (!IsValidIid( iid )) \
    return (FnAssert(#iid,"Invalid iid", __FILE__, __LINE__),ResultFromScode(E_INVALIDARG))
#define GEN_VDATEIID( iid, retval ) if (!IsValidIid( iid )) {\
    FnAssert(#iid,"Invalid iid", __FILE__, __LINE__); return retval; }

//** INTERFACE ID validation macros for single entry/single exit functions
//** uses a goto instead of return
#define VDATEIID_LABEL( iid, label, retVar ) if (!IsValidIid( iid )) \
        {retVar = (FnAssert(#iid,"Invalid iid", __FILE__, __LINE__),ResultFromScode(E_INVALIDARG)); \
         goto label; }
#define GEN_VDATEIID_LABEL( iid, retval, label, retVar ) if (!IsValidIid( iid )) {\
        FnAssert(#iid,"Invalid iid", __FILE__, __LINE__); retVar = retval;  goto label; }
#else



//  --assertless macros for non-debug case
//** POINTER IN validation macros:
#define VDATEPTRIN( pv, TYPE ) if (!IsValidPtrIn( (pv), sizeof(TYPE))) \
    return (ResultFromScode(E_INVALIDARG))
#define GEN_VDATEPTRIN( pv, TYPE, retval ) if (!IsValidPtrIn( (pv), sizeof(TYPE))) \
    return (retval)
#define VOID_VDATEPTRIN( pv, TYPE ) if (!IsValidPtrIn( (pv), sizeof(TYPE))) {\
    return; }

//** POINTER IN validation macros for single entry/single exit functions
//** uses a goto instead of return
#define VDATEPTRIN_LABEL(pv, TYPE, label, retVar) \
        if (!IsValidPtrIn((pv), sizeof(TYPE))) \
        { retVar = ResultFromScode(E_INVALIDARG); \
         goto label; }
#define GEN_VDATEPTRIN_LABEL(pv, TYPE, retval, label, retVar) \
        if (!IsValidPtrIn((pv), sizeof(TYPE))) \
        { retVar = retval; \
         goto label; }
#define VOID_VDATEPTRIN_LABEL(pv, TYPE, label) \
        if (!IsValidPtrIn((pv), sizeof(TYPE))) \
        { goto label; }

//** POINTER OUT validation macros:
#define VDATEPTROUT( pv, TYPE ) if (!IsValidPtrOut( (pv), sizeof(TYPE))) \
    return (ResultFromScode(E_INVALIDARG))

#define GEN_VDATEPTROUT( pv, TYPE, retval ) if (!IsValidPtrOut( (pv), sizeof(TYPE))) \
    return (retval)

//** POINTER OUT validation macros for single entry/single exit functions
//** uses a goto instead of return
#define VDATEPTROUT_LABEL( pv, TYPE, label, retVar ) \
        if (!IsValidPtrOut( (pv), sizeof(TYPE))) \
        { retVar = ResultFromScode(E_INVALIDARG); \
         goto label; }
#define GEN_VDATEPTROUT_LABEL( pv, TYPE, retval, label, retVar ) \
        if (!IsValidPtrOut( (pv), sizeof(TYPE))) \
        { retVar = retval; \
         goto label; }

//** INTERFACE validation macro:
#define VDATEIFACE( pv ) if (!IsValidInterface(pv)) \
    return (ResultFromScode(E_INVALIDARG))
#define VOID_VDATEIFACE( pv ) if (!IsValidInterface(pv)) \
    return;
#define GEN_VDATEIFACE( pv, retval ) if (!IsValidInterface(pv)) \
    return (retval)

//** INTERFACE validation macros for single entry/single exit functions
//** uses a goto instead of return
#define GEN_VDATEIFACE_LABEL( pv, retval, label, retVar ) \
        if (!IsValidInterface(pv)) \
        { retVar = retval; \
         goto label; }
#define VDATEIFACE_LABEL( pv, label, retVar ) \
        if (!IsValidInterface(pv)) \
        { retVar = ResultFromScode(E_INVALIDARG); \
         goto label; }
#define VOID_VDATEIFACE_LABEL( pv, label ) \
        if (!IsValidInterface(pv)) {\
         goto label; }

//** INTERFACE ID validation macro:
// do not do in retail build. This code USED to call a bogus version of
// IsValidIID that did no work. Now we are faster and no less stable than before.
#define VDATEIID( iid )             ((void)0)
#define GEN_VDATEIID( iid, retval ) ((void)0);

//** INTERFACE ID validation macros for single entry/single exit functions
//** uses a goto instead of return
#define VDATEIID_LABEL( iid, label, retVar ) if (!IsValidIid( iid )) \
        {retVar = ResultFromScode(E_INVALIDARG); \
         goto label; }
#define GEN_VDATEIID_LABEL( iid, retval, label, retVar ) if (!IsValidIid( iid )) {\
        retVar = retval;  goto label; }

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\urlmon\utils\sprintf.c ===
/***
*sprintf.c - print formatted to string
*
*	Copyright (c) 1985-1991, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	defines w4sprintf() - print formatted data to string
*	defines w4vsprintf() - print formatted output to a string, get data
*			       from an argument ptr instead of explicit args.
*******************************************************************************/

#define _W4SPRINTF_
#include "printf.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\urlmon\utils\timecore.cxx ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include <urlint.h>
#include <map_kv.h>
#include "coll.hxx"
#include "ctime.hxx"

/*
#include "stdafx.h"

#ifdef AFX_AUX_SEG
#pragma code_seg(AFX_AUX_SEG)
#endif

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif
*/


/////////////////////////////////////////////////////////////////////////////
// CTime - absolute time

CTime::CTime(int nYear, int nMonth, int nDay, int nHour, int nMin, int nSec, int nDST)
{
    struct tm atm;
    atm.tm_sec = nSec;
    atm.tm_min = nMin;
    atm.tm_hour = nHour;
    ASSERT(nDay >= 1 && nDay <= 31);
    atm.tm_mday = nDay;
    ASSERT(nMonth >= 1 && nMonth <= 12);
    atm.tm_mon = nMonth - 1;        // tm_mon is 0 based
    ASSERT(nYear >= 1900);
    atm.tm_year = nYear - 1900;     // tm_year is 1900 based
    atm.tm_isdst = nDST;
    m_time = mktime(&atm);
    ASSERT(m_time != -1);       // indicates an illegal input time
}

CTime::CTime(WORD wDosDate, WORD wDosTime, int nDST)
{
    struct tm atm;
    atm.tm_sec = (wDosTime & ~0xFFE0) << 1;
    atm.tm_min = (wDosTime & ~0xF800) >> 5;
    atm.tm_hour = wDosTime >> 11;

    atm.tm_mday = wDosDate & ~0xFFE0;
    atm.tm_mon = ((wDosDate & ~0xFE00) >> 5) - 1;
    atm.tm_year = (wDosDate >> 9) + 80;
    atm.tm_isdst = nDST;
    m_time = mktime(&atm);
    ASSERT(m_time != -1);       // indicates an illegal input time
}

CTime::CTime(const SYSTEMTIME& sysTime, int nDST)
{
    if (sysTime.wYear < 1900)
    {
        time_t time0 = 0L;
        CTime timeT(time0);
        *this = timeT;
    }
    else
    {
        CTime timeT(
                   (int)sysTime.wYear, (int)sysTime.wMonth, (int)sysTime.wDay,
                   (int)sysTime.wHour, (int)sysTime.wMinute, (int)sysTime.wSecond,
                   nDST);
        *this = timeT;
    }
}

CTime::CTime(const FILETIME& fileTime, int nDST)
{
    // first convert file time (UTC time) to local time
    FILETIME localTime;
    if (!FileTimeToLocalFileTime(&fileTime, &localTime))
    {
        m_time = 0;
        return;
    }

    // then convert that time to system time
    SYSTEMTIME sysTime;
    if (!FileTimeToSystemTime(&localTime, &sysTime))
    {
        m_time = 0;
        return;
    }

    // then convert the system time to a time_t (C-runtime local time)
    CTime timeT(sysTime, nDST);
    *this = timeT;
}

CTime PASCAL CTime::GetCurrentTime()
// return the current system time
{
    return CTime(::time(NULL));
}

struct tm* CTime::GetGmtTm(struct tm* ptm) const
{
    if (ptm != NULL)
    {
        *ptm = *gmtime(&m_time);
        return ptm;
    }
    else
        return gmtime(&m_time);
}

struct tm* CTime::GetLocalTm(struct tm* ptm) const
{
    if (ptm != NULL)
    {
        struct tm* ptmTemp = localtime(&m_time);
        if (ptmTemp == NULL)
            return NULL;    // indicates the m_time was not initialized!

        *ptm = *ptmTemp;
        return ptm;
    }
    else
        return localtime(&m_time);
}

#ifdef _DEBUG
CDumpContext& AFXAPI operator <<(CDumpContext& dc, CTime time)
{
    char* psz = ctime(&time.m_time);
    if ((psz == NULL) || (time.m_time == 0))
        return dc << "CTime(invalid #" << time.m_time << ")";

    // format it
    psz[24] = '\0';         // nuke newline
    return dc << "CTime(\"" << psz << "\")";
}
#endif

CArchive& AFXAPI operator <<(CArchive& ar, CTime time)
{
    //return ar << (DWORD) time.m_time;
    ASSERT(FALSE);
    return ar;
}

CArchive& AFXAPI operator >>(CArchive& ar, CTime& rtime)
{
    //return ar >> (DWORD&) rtime.m_time;
    ASSERT(FALSE);
    return ar;
}

/////////////////////////////////////////////////////////////////////////////
// CTimeSpan - relative time

#ifdef _DEBUG
CDumpContext& AFXAPI operator <<(CDumpContext& dc, CTimeSpan timeSpan)
{
    return dc << "CTimeSpan(" << timeSpan.GetDays() << " days, " <<
    timeSpan.GetHours() << " hours, " <<
    timeSpan.GetMinutes() << " minutes and " <<
    timeSpan.GetSeconds() << " seconds)";
}
#endif

CArchive& AFXAPI operator <<(CArchive& ar, CTimeSpan timeSpan)
{
    //return ar << (DWORD) timeSpan.m_timeSpan;
    ASSERT(FALSE);
    return ar;
}

CArchive& AFXAPI operator >>(CArchive& ar, CTimeSpan& rtimeSpan)
{
    //return ar >> (DWORD&) rtimeSpan.m_timeSpan;
    ASSERT(FALSE);
    return ar;
}


/////////////////////////////////////////////////////////////////////////////
// String formatting

#define maxTimeBufferSize       128
// Verifies will fail if the needed buffer size is too large

#ifdef _UNICODE
#endif

CString CTimeSpan::Format(LPCTSTR pFormat) const
// formatting timespans is a little trickier than formatting CTimes
//  * we are only interested in relative time formats, ie. it is illegal
//      to format anything dealing with absolute time (i.e. years, months,
//         day of week, day of year, timezones, ...)
//  * the only valid formats:
//      %D - # of days -- NEW !!!
//      %H - hour in 24 hour format
//      %M - minute (0-59)
//      %S - seconds (0-59)
//      %% - percent sign
{
    TCHAR szBuffer[maxTimeBufferSize];
    TCHAR ch;
    LPTSTR pch = szBuffer;

    while ((ch = *pFormat++) != '\0')
    {
        ASSERT(pch < &szBuffer[maxTimeBufferSize]);
        if (ch == '%')
        {
            switch (ch = *pFormat++)
            {
            default:
                ASSERT(FALSE);      // probably a bad format character
            case '%':
                *pch++ = ch;
                break;
            case 'D':
                pch += wsprintf(pch, _T("%ld"), GetDays());
                break;
            case 'H':
                pch += wsprintf(pch, _T("%02d"), GetHours());
                break;
            case 'M':
                pch += wsprintf(pch, _T("%02d"), GetMinutes());
                break;
            case 'S':
                pch += wsprintf(pch, _T("%02d"), GetSeconds());
                break;
            }
        }
        else
        {
            *pch++ = ch;
            if (_istlead(ch))
            {
                ASSERT(pch < &szBuffer[maxTimeBufferSize]);
                *pch++ = *pFormat++;
            }
        }
    }

    *pch = '\0';
    return szBuffer;
}


CString CTime::Format(LPCTSTR pFormat) const
// formatting timespans is a little trickier than formatting CTimes
//  * we are only interested in relative time formats, ie. it is illegal
//      to format anything dealing with absolute time (i.e. years, months,
//         day of week, day of year, timezones, ...)
//  * the only valid formats:
//      %D - # of days -- NEW !!!
//      %H - hour in 24 hour format
//      %M - minute (0-59)
//      %S - seconds (0-59)
//      %% - percent sign
{
    TCHAR szBuffer[maxTimeBufferSize];
    TCHAR ch;
    LPTSTR pch = szBuffer;

    while ((ch = *pFormat++) != '\0')
    {
        ASSERT(pch < &szBuffer[maxTimeBufferSize]);
        if (ch == '%')
        {
            switch (ch = *pFormat++)
            {
            default:
                ASSERT(FALSE);      // probably a bad format character
            case '%':
                *pch++ = ch;
                break;
            case 'D':
                pch += wsprintf(pch, _T("%ld"), GetDay());
                break;
            case 'H':
                pch += wsprintf(pch, _T("%02d"), GetHour());
                break;
            case 'M':
                pch += wsprintf(pch, _T("%02d"), GetMinute());
                break;
            case 'S':
                pch += wsprintf(pch, _T("%02d"), GetSecond());
                break;
            }
        }
        else
        {
            *pch++ = ch;
            if (_istlead(ch))
            {
                ASSERT(pch < &szBuffer[maxTimeBufferSize]);
                *pch++ = *pFormat++;
            }
        }
    }

    *pch = '\0';
    return szBuffer;
}



#ifdef _ALL_CTIME_FORMATS_
CString CTimeSpan::Format(UINT nFormatID) const
{
    CString strFormat;
    VERIFY(strFormat.LoadString(nFormatID) != 0);
    return Format(strFormat);
}

CString CTime::Format(LPCTSTR pFormat) const
{
    TCHAR szBuffer[maxTimeBufferSize];

    struct tm* ptmTemp = localtime(&m_time);
    if (ptmTemp == NULL ||
        !_tcsftime(szBuffer, _countof(szBuffer), pFormat, ptmTemp))
        szBuffer[0] = '\0';
    return szBuffer;
}

CString CTime::FormatGmt(LPCTSTR pFormat) const
{
    TCHAR szBuffer[maxTimeBufferSize];

    struct tm* ptmTemp = gmtime(&m_time);
    if (ptmTemp == NULL ||
        !_tcsftime(szBuffer, _countof(szBuffer), pFormat, ptmTemp))
        szBuffer[0] = '\0';
    return szBuffer;
}

CString CTime::Format(UINT nFormatID) const
{
    CString strFormat;
    VERIFY(strFormat.LoadString(nFormatID) != 0);
    return Format(strFormat);
}

CString CTime::FormatGmt(UINT nFormatID) const
{
    CString strFormat;
    VERIFY(strFormat.LoadString(nFormatID) != 0);
    return FormatGmt(strFormat);
}

    #ifdef _UNICODE
// These functions are provided for compatibility with MFC 3.x
CString CTime::Format(LPCSTR pFormat) const
{
    CString strFormat(pFormat);
    return Format((LPCTSTR)strFormat);
}

CString CTime::FormatGmt(LPCSTR pFormat) const
{
    CString strFormat(pFormat);
    return FormatGmt((LPCTSTR)strFormat);
}

CString CTimeSpan::Format(LPCSTR pFormat) const
{
    CString strFormat = pFormat;
    return Format((LPCTSTR)strFormat);
}
    #endif //_ALL_CTIME_FORMATS_
#endif // _UNICODE

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\urlmon\utils\wsprintf.c ===
/***
*sprintf.c - print formatted to string
*
*	Copyright (c) 1985-1991, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	defines w4wcsprintf() - print formatted data to wide character string
*	defines w4vwcsprintf() - print formatted output to a wide character
*				 string, get data from argument ptr instead
*				 of explicit args.
*******************************************************************************/

#define _W4WCSPRINTF_
#include "printf.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\urlmon\utils\valid.cxx ===
#include <ole2.h>

#include "valid.h"
#include "debug.h"

#if 1
// we cannot turn this off until we remove from the export list!
#undef IsValidPtrIn
#undef IsValidPtrOut

// BUGBUG: The following two functions are MACRO's in 2.01 code
// but we need them for now because we only run with a storage
// that uses ole232.dll. When we get rid of this these may die.

STDAPI_(BOOL) IsValidPtrIn( const void FAR* pv, UINT cb )
{                                                                                               //      NULL is acceptable
        if (pv && IsBadReadPtr(pv,cb))
        {
//              AssertSz(FALSE, "Invalid in pointer");
                return FALSE;
        }
        return TRUE;
}



STDAPI_(BOOL) IsValidPtrOut( void FAR* pv, UINT cb )
                                                                                //      NULL is not acceptable
{
        if (IsBadWritePtr(pv,cb))
        {
//              AssertSz(FALSE, "Invalid out pointer");
                return FALSE;
        }
        return TRUE;
}
#endif


STDAPI_(BOOL) IsValidInterface( void FAR* pv )
{
//
// There is nothing to do about it on UNIX.
//
#ifndef UNIX
        DWORD_PTR FAR*          pVtbl;
        BYTE FAR*               pFcn;
        volatile BYTE   bInstr;
        int                             i;

        __try {
                pVtbl = *(DWORD_PTR FAR* FAR*)pv;           // pVtbl now points to beginning of vtable

#if DBG==1
                for (i=0;i<3;++i)                                       // loop through qi,addref,rel
#else
                i=1;                                                            // in retail, just do AddRef
#endif
                {
                        pFcn = *(BYTE FAR* FAR*) &pVtbl[i];     // pFcn now points to beginning of QI,Addref, or Release
#if DBG==1
                        if (IsBadCodePtr((FARPROC FAR)pFcn)) {
                                return FALSE;
                        }
#endif
                        bInstr = *(BYTE FAR*) pFcn;             // get 1st byte of 1st instruction
                }

        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
                return FALSE;
        }
#endif /* !unix */

        return TRUE;
}


// #if DBG==1
// we cannot remove IsValidIID fcn until we remove from export list!

// This function is NOT called in retail builds.
// Its former implementation always returned TRUE thus doing NO validation.
// It now validates in debug build and is not called in retail build

#if DBG==0
#ifdef IsValidIid
#undef IsValidIid
STDAPI_(BOOL) IsValidIid( REFIID iid );
#endif
#endif

STDAPI_(BOOL) IsValidIid( REFIID iid )
{
#if DBG==1
        if (IsBadReadPtr((void*) &iid, 16)) {
                AssertSz(FALSE, "Invalid iid");
                return FALSE;
        }
#endif
        return TRUE;
}
// #endif // DBG==1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\urlmon\utils\strcore.cxx ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include <urlint.h>
#include <map_kv.h>
#include "coll.hxx"

/*
#include "stdafx.h"

#ifdef AFX_CORE1_SEG
#pragma code_seg(AFX_CORE1_SEG)
#endif

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define new DEBUG_NEW
*/

// The following macros are used on data declarations/definitions
//  (they are redefined for extension DLLs and the shared MFC DLL)
#define AFX_DATA
#define AFX_DATADEF

// used when building the "core" MFC42.DLL
#ifndef AFX_CORE_DATA
        #define AFX_CORE_DATA
        #define AFX_CORE_DATADEF
#endif

// used when building the MFC/OLE support MFCO42.DLL
#ifndef AFX_OLE_DATA
        #define AFX_OLE_DATA
        #define AFX_OLE_DATADEF
#endif

#define TRACE1(x,a)
//int AFX_CDECL _mbstowcsz(wchar_t* wcstr, const char* mbstr, size_t count);
// conversion helpers
int AFX_CDECL _wcstombsz(char* mbstr, const wchar_t* wcstr, size_t count);
int AFX_CDECL _mbstowcsz(wchar_t* wcstr, const char* mbstr, size_t count);

/////////////////////////////////////////////////////////////////////////////
// static class data, special inlines

// afxChNil is left for backward compatibility
AFX_DATADEF TCHAR afxChNil = '\0';

// For an empty string, m_pchData will point here
// (note: avoids special case of checking for NULL m_pchData)
// empty string data (and locked)
static int rgInitData[] = { -1, 0, 0, 0 };
static AFX_DATADEF CStringData* afxDataNil = (CStringData*)&rgInitData;
static LPCTSTR afxPchNil = (LPCTSTR)(((BYTE*)&rgInitData)+sizeof(CStringData));
// special function to make afxEmptyString work even during initialization
const CString& AFXAPI AfxGetEmptyString()
        { return *(CString*)&afxPchNil; }

//////////////////////////////////////////////////////////////////////////////
// Construction/Destruction

CString::CString()
{
        Init();
}

CString::CString(const CString& stringSrc)
{
        ASSERT(stringSrc.GetData()->nRefs != 0);
        if (stringSrc.GetData()->nRefs >= 0)
        {
                ASSERT(stringSrc.GetData() != afxDataNil);
                m_pchData = stringSrc.m_pchData;
                InterlockedIncrement(&GetData()->nRefs);
        }
        else
        {
                Init();
                *this = stringSrc.m_pchData;
        }
}

void CString::AllocBuffer(int nLen)
// always allocate one extra character for '\0' termination
// assumes [optimistically] that data length will equal allocation length
{
        ASSERT(nLen >= 0);
        ASSERT(nLen <= INT_MAX-1);    // max size (enough room for 1 extra)

        if (nLen == 0)
                Init();
        else
        {
                CStringData* pData =
                        (CStringData*)new BYTE[sizeof(CStringData) + (nLen+1)*sizeof(TCHAR)];
                pData->nRefs = 1;
                pData->data()[nLen] = '\0';
                pData->nDataLength = nLen;
                pData->nAllocLength = nLen;
                m_pchData = pData->data();
        }
}

void CString::Release()
{
        if (GetData() != afxDataNil)
        {
                ASSERT(GetData()->nRefs != 0);
                if (InterlockedDecrement(&GetData()->nRefs) <= 0)
                        delete[] (BYTE*)GetData();
                Init();
        }
}

void PASCAL CString::Release(CStringData* pData)
{
        if (pData != afxDataNil)
        {
                ASSERT(pData->nRefs != 0);
                if (InterlockedDecrement(&pData->nRefs) <= 0)
                        delete[] (BYTE*)pData;
        }
}

void CString::Empty()
{
        if (GetData()->nDataLength == 0)
                return;
        if (GetData()->nRefs >= 0)
                Release();
        else
                *this = &afxChNil;
        ASSERT(GetData()->nDataLength == 0);
        ASSERT(GetData()->nRefs < 0 || GetData()->nAllocLength == 0);
}

void CString::CopyBeforeWrite()
{
        if (GetData()->nRefs > 1)
        {
                CStringData* pData = GetData();
                Release();
                AllocBuffer(pData->nDataLength);
                memcpy(m_pchData, pData->data(), (pData->nDataLength+1)*sizeof(TCHAR));
        }
        ASSERT(GetData()->nRefs <= 1);
}

void CString::AllocBeforeWrite(int nLen)
{
        if (GetData()->nRefs > 1 || nLen > GetData()->nAllocLength)
        {
                Release();
                AllocBuffer(nLen);
        }
        ASSERT(GetData()->nRefs <= 1);
}

CString::~CString()
//  free any attached data
{
        if (GetData() != afxDataNil)
        {
                if (InterlockedDecrement(&GetData()->nRefs) <= 0)
                        delete[] (BYTE*)GetData();
        }
}

//////////////////////////////////////////////////////////////////////////////
// Helpers for the rest of the implementation

void CString::AllocCopy(CString& dest, int nCopyLen, int nCopyIndex,
         int nExtraLen) const
{
        // will clone the data attached to this string
        // allocating 'nExtraLen' characters
        // Places results in uninitialized string 'dest'
        // Will copy the part or all of original data to start of new string

        int nNewLen = nCopyLen + nExtraLen;
        if (nNewLen == 0)
        {
                dest.Init();
        }
        else
        {
                dest.AllocBuffer(nNewLen);
                memcpy(dest.m_pchData, m_pchData+nCopyIndex, nCopyLen*sizeof(TCHAR));
        }
}

//////////////////////////////////////////////////////////////////////////////
// More sophisticated construction

CString::CString(LPCTSTR lpsz)
{
        Init();
        if (lpsz != NULL && (DWORD_PTR)lpsz <= 0xFFFF)
        {
                UINT nID = PtrToUlong(lpsz) & 0xFFFF;
                //if (!LoadString(nID))
                //        TRACE1("Warning: implicit LoadString(%u) failed\n", nID);
        }
        else
        {
                int nLen = SafeStrlen(lpsz);
                if (nLen != 0)
                {
                        AllocBuffer(nLen);
                        memcpy(m_pchData, lpsz, nLen*sizeof(TCHAR));
                }
        }
}

/////////////////////////////////////////////////////////////////////////////
// Special conversion constructors

#ifdef _UNICODE
CString::CString(LPCSTR lpsz)
{
        Init();
        int nSrcLen = lpsz != NULL ? lstrlenA(lpsz) : 0;
        if (nSrcLen != 0)
        {
                AllocBuffer(nSrcLen);
                _mbstowcsz(m_pchData, lpsz, nSrcLen+1);
                ReleaseBuffer();
        }
}
#else //_UNICODE
CString::CString(LPCWSTR lpsz)
{
        Init();
        int nSrcLen = lpsz != NULL ? wcslen(lpsz) : 0;
        if (nSrcLen != 0)
        {
                AllocBuffer(nSrcLen*2);
                _wcstombsz(m_pchData, lpsz, (nSrcLen*2)+1);
                ReleaseBuffer();
        }
}
#endif //!_UNICODE

//////////////////////////////////////////////////////////////////////////////
// Diagnostic support

#ifdef _DEBUG
CDumpContext& AFXAPI operator<<(CDumpContext& dc, const CString& string)
{
        dc << string.m_pchData;
        return dc;
}
#endif //_DEBUG

//////////////////////////////////////////////////////////////////////////////
// Assignment operators
//  All assign a new value to the string
//      (a) first see if the buffer is big enough
//      (b) if enough room, copy on top of old buffer, set size and type
//      (c) otherwise free old string data, and create a new one
//
//  All routines return the new string (but as a 'const CString&' so that
//      assigning it again will cause a copy, eg: s1 = s2 = "hi there".
//

void CString::AssignCopy(int nSrcLen, LPCTSTR lpszSrcData)
{
        AllocBeforeWrite(nSrcLen);
        memcpy(m_pchData, lpszSrcData, nSrcLen*sizeof(TCHAR));
        GetData()->nDataLength = nSrcLen;
        m_pchData[nSrcLen] = '\0';
}

const CString& CString::operator=(const CString& stringSrc)
{
        if (m_pchData != stringSrc.m_pchData)
        {
                if ((GetData()->nRefs < 0 && GetData() != afxDataNil) ||
                        stringSrc.GetData()->nRefs < 0)
                {
                        // actual copy necessary since one of the strings is locked
                        AssignCopy(stringSrc.GetData()->nDataLength, stringSrc.m_pchData);
                }
                else
                {
                        // can just copy references around
                        Release();
                        ASSERT(stringSrc.GetData() != afxDataNil);
                        m_pchData = stringSrc.m_pchData;
                        InterlockedIncrement(&GetData()->nRefs);
                }
        }
        return *this;
}

const CString& CString::operator=(LPCTSTR lpsz)
{
        ASSERT(lpsz == NULL || AfxIsValidString(lpsz, FALSE));
        AssignCopy(SafeStrlen(lpsz), lpsz);
        return *this;
}

/////////////////////////////////////////////////////////////////////////////
// Special conversion assignment

#ifdef _UNICODE
const CString& CString::operator=(LPCSTR lpsz)
{
        int nSrcLen = lpsz != NULL ? lstrlenA(lpsz) : 0;
        AllocBeforeWrite(nSrcLen);
        _mbstowcsz(m_pchData, lpsz, nSrcLen+1);
        ReleaseBuffer();
        return *this;
}
#else //!_UNICODE
const CString& CString::operator=(LPCWSTR lpsz)
{
        int nSrcLen = lpsz != NULL ? wcslen(lpsz) : 0;
        AllocBeforeWrite(nSrcLen*2);
        _wcstombsz(m_pchData, lpsz, (nSrcLen*2)+1);
        ReleaseBuffer();
        return *this;
}
#endif  //!_UNICODE

//////////////////////////////////////////////////////////////////////////////
// concatenation

// NOTE: "operator+" is done as friend functions for simplicity
//      There are three variants:
//          CString + CString
// and for ? = TCHAR, LPCTSTR
//          CString + ?
//          ? + CString

void CString::ConcatCopy(int nSrc1Len, LPCTSTR lpszSrc1Data,
        int nSrc2Len, LPCTSTR lpszSrc2Data)
{
  // -- master concatenation routine
  // Concatenate two sources
  // -- assume that 'this' is a new CString object

        int nNewLen = nSrc1Len + nSrc2Len;
        if (nNewLen != 0)
        {
                AllocBuffer(nNewLen);
                memcpy(m_pchData, lpszSrc1Data, nSrc1Len*sizeof(TCHAR));
                memcpy(m_pchData+nSrc1Len, lpszSrc2Data, nSrc2Len*sizeof(TCHAR));
        }
}

CString AFXAPI operator+(const CString& string1, const CString& string2)
{
        CString s;
        s.ConcatCopy(string1.GetData()->nDataLength, string1.m_pchData,
                string2.GetData()->nDataLength, string2.m_pchData);
        return s;
}

CString AFXAPI operator+(const CString& string, LPCTSTR lpsz)
{
        ASSERT(lpsz == NULL || AfxIsValidString(lpsz, FALSE));
        CString s;
        s.ConcatCopy(string.GetData()->nDataLength, string.m_pchData,
                CString::SafeStrlen(lpsz), lpsz);
        return s;
}

CString AFXAPI operator+(LPCTSTR lpsz, const CString& string)
{
        ASSERT(lpsz == NULL || AfxIsValidString(lpsz, FALSE));
        CString s;
        s.ConcatCopy(CString::SafeStrlen(lpsz), lpsz, string.GetData()->nDataLength,
                string.m_pchData);
        return s;
}

//////////////////////////////////////////////////////////////////////////////
// concatenate in place

void CString::ConcatInPlace(int nSrcLen, LPCTSTR lpszSrcData)
{
        //  -- the main routine for += operators

        // concatenating an empty string is a no-op!
        if (nSrcLen == 0)
                return;

        // if the buffer is too small, or we have a width mis-match, just
        //   allocate a new buffer (slow but sure)
        if (GetData()->nRefs > 1 || GetData()->nDataLength + nSrcLen > GetData()->nAllocLength)
        {
                // we have to grow the buffer, use the ConcatCopy routine
                CStringData* pOldData = GetData();
                ConcatCopy(GetData()->nDataLength, m_pchData, nSrcLen, lpszSrcData);
                ASSERT(pOldData != NULL);
                CString::Release(pOldData);
        }
        else
        {
                // fast concatenation when buffer big enough
                memcpy(m_pchData+GetData()->nDataLength, lpszSrcData, nSrcLen*sizeof(TCHAR));
                GetData()->nDataLength += nSrcLen;
                ASSERT(GetData()->nDataLength <= GetData()->nAllocLength);
                m_pchData[GetData()->nDataLength] = '\0';
        }
}

const CString& CString::operator+=(LPCTSTR lpsz)
{
        ASSERT(lpsz == NULL || AfxIsValidString(lpsz, FALSE));
        ConcatInPlace(SafeStrlen(lpsz), lpsz);
        return *this;
}

const CString& CString::operator+=(TCHAR ch)
{
        ConcatInPlace(1, &ch);
        return *this;
}

const CString& CString::operator+=(const CString& string)
{
        ConcatInPlace(string.GetData()->nDataLength, string.m_pchData);
        return *this;
}

///////////////////////////////////////////////////////////////////////////////
// Advanced direct buffer access

LPTSTR CString::GetBuffer(int nMinBufLength)
{
        ASSERT(nMinBufLength >= 0);

        if (GetData()->nRefs > 1 || nMinBufLength > GetData()->nAllocLength)
        {
                // we have to grow the buffer
                CStringData* pOldData = GetData();
                int nOldLen = GetData()->nDataLength;   // AllocBuffer will tromp it
                if (nMinBufLength < nOldLen)
                        nMinBufLength = nOldLen;
                AllocBuffer(nMinBufLength);
                memcpy(m_pchData, pOldData->data(), (nOldLen+1)*sizeof(TCHAR));
                GetData()->nDataLength = nOldLen;
                CString::Release(pOldData);
        }
        ASSERT(GetData()->nRefs <= 1);

        // return a pointer to the character storage for this string
        ASSERT(m_pchData != NULL);
        return m_pchData;
}

void CString::ReleaseBuffer(int nNewLength)
{
        CopyBeforeWrite();  // just in case GetBuffer was not called

        if (nNewLength == -1)
                nNewLength = lstrlen(m_pchData); // zero terminated

        ASSERT(nNewLength <= GetData()->nAllocLength);
        GetData()->nDataLength = nNewLength;
        m_pchData[nNewLength] = '\0';
}

LPTSTR CString::GetBufferSetLength(int nNewLength)
{
        ASSERT(nNewLength >= 0);

        GetBuffer(nNewLength);
        GetData()->nDataLength = nNewLength;
        m_pchData[nNewLength] = '\0';
        return m_pchData;
}

void CString::FreeExtra()
{
        ASSERT(GetData()->nDataLength <= GetData()->nAllocLength);
        if (GetData()->nDataLength != GetData()->nAllocLength)
        {
                CStringData* pOldData = GetData();
                AllocBuffer(GetData()->nDataLength);
                memcpy(m_pchData, pOldData->data(), pOldData->nDataLength*sizeof(TCHAR));
                ASSERT(m_pchData[GetData()->nDataLength] == '\0');
                CString::Release(pOldData);
        }
        ASSERT(GetData() != NULL);
}

LPTSTR CString::LockBuffer()
{
        LPTSTR lpsz = GetBuffer(0);
        GetData()->nRefs = -1;
        return lpsz;
}

void CString::UnlockBuffer()
{
        ASSERT(GetData()->nRefs == -1);
        if (GetData() != afxDataNil)
                GetData()->nRefs = 1;
}

///////////////////////////////////////////////////////////////////////////////
// Commonly used routines (rarely used routines in STREX.CPP)

#ifdef unused
int CString::Find(TCHAR ch) const
{
        // find first single character
        LPTSTR lpsz = _tcschr(m_pchData, (_TUCHAR)ch);

        // return -1 if not found and index otherwise
        return (lpsz == NULL) ? -1 : (int)(lpsz - m_pchData);
}

int CString::FindOneOf(LPCTSTR lpszCharSet) const
{
        ASSERT(AfxIsValidString(lpszCharSet, FALSE));
        LPTSTR lpsz = _tcspbrk(m_pchData, lpszCharSet);
        return (lpsz == NULL) ? -1 : (int)(lpsz - m_pchData);
}
void CString::MakeReverse()
{
        CopyBeforeWrite();
        _tcsrev(m_pchData);
}
#endif //unused

void CString::MakeUpper()
{
        CopyBeforeWrite();
        ::CharUpper(m_pchData);
}

void CString::MakeLower()
{
        CopyBeforeWrite();
        ::CharLower(m_pchData);
}


void CString::SetAt(int nIndex, TCHAR ch)
{
        ASSERT(nIndex >= 0);
        ASSERT(nIndex < GetData()->nDataLength);

        CopyBeforeWrite();
        m_pchData[nIndex] = ch;
}

#ifndef _UNICODE
void CString::AnsiToOem()
{
        CopyBeforeWrite();
        ::AnsiToOem(m_pchData, m_pchData);
}
void CString::OemToAnsi()
{
        CopyBeforeWrite();
        #pragma prefast(suppress:56, "We don't hit this piece of code in the current codebase")
        ::OemToAnsi(m_pchData, m_pchData);
}
#endif

///////////////////////////////////////////////////////////////////////////////
// CString conversion helpers (these use the current system locale)

int AFX_CDECL _wcstombsz(char* mbstr, const wchar_t* wcstr, size_t count)
{
        if (count == 0 && mbstr != NULL)
                return 0;

        int result = ::WideCharToMultiByte(CP_ACP, 0, wcstr, -1,
                mbstr, count, NULL, NULL);
        ASSERT(mbstr == NULL || result <= (int)count);
        if (result > 0)
                mbstr[result-1] = 0;
        return result;
}

int AFX_CDECL _mbstowcsz(wchar_t* wcstr, const char* mbstr, size_t count)
{
        if (count == 0 && wcstr != NULL)
                return 0;

        int result = ::MultiByteToWideChar(CP_ACP, 0, mbstr, -1,
                wcstr, count);
        ASSERT(wcstr == NULL || result <= (int)count);
        if (result > 0)
                wcstr[result-1] = 0;
        return result;
}

LPWSTR AFXAPI AfxA2WHelper(LPWSTR lpw, LPCSTR lpa, int nChars)
{
        if (lpa == NULL)
                return NULL;
        ASSERT(lpw != NULL);
        // verify that no illegal character present
        // since lpw was allocated based on the size of lpa
        // don't worry about the number of chars
        lpw[0] = '\0';
        VERIFY(MultiByteToWideChar(CP_ACP, 0, lpa, -1, lpw, nChars));
        return lpw;
}

LPSTR AFXAPI AfxW2AHelper(LPSTR lpa, LPCWSTR lpw, int nChars)
{
        if (lpw == NULL)
                return NULL;
        ASSERT(lpa != NULL);
        // verify that no illegal character present
        // since lpa was allocated based on the size of lpw
        // don't worry about the number of chars
        lpa[0] = '\0';
        VERIFY(WideCharToMultiByte(CP_ACP, 0, lpw, -1, lpa, nChars, NULL, NULL));
        return lpa;
}

///////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\urlmon\utils\transhlp.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       transhlp.cxx
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    12-05-95   JohannP (Johann Posch)   Created
//
//----------------------------------------------------------------------------
#include <trans.h>

HMODULE g_hLibMlang = NULL;


//+---------------------------------------------------------------------------
//
//  Function:   SzW2ADynamic
//
//  Synopsis:   Convert Unicode string wzFrom to Ansi, and return the Ansi string.
//              The Ansi string will be written into szTo (whose size is cchTo bytes) if
//              szTo is nonNull AND it is large enough to hold the Ansi string.
//              If this is not the case, the Ansi string is dynamically allocated.
//              If 'fTaskMalloc', allocation is done thru IMalloc, otherwise it is done
//              thru new.
//
//  Arguments:  [wzFrom] --
//              [szTo] --
//              [cchTo] --
//              [fTaskMalloc] --
//
//  Returns:    If error returns NULL, otherwise returns
//              pointer to Ansi string (if different from szTo, it must be freed via
//              delete or IMalloc, as appropriate).
//
//  History:    x-xx-xx   Clarg                    Created
//              2-25-96   JohannP (Johann Posch)   Modified
//
//  Notes:
//
//----------------------------------------------------------------------------
LPSTR SzW2ADynamic(LPCWSTR wzFrom, LPSTR szTo, int cchTo, BOOL fTaskMalloc)
{
    int cchRequired;
    char *pszT = NULL;

    cchRequired = WideCharToMultiByte(CP_ACP, 0, wzFrom, -1, NULL, 0, NULL, NULL);
    cchRequired++;
    TransAssert((cchRequired > 0));

    if (szTo && cchTo && (cchTo >= cchRequired))
    {
        // szTo has enough space
        pszT = szTo;
    }
    else
    {
        // szTo is not large enough; dynamically allocate the buffer
        if (fTaskMalloc)
        {
            pszT = (char*)CoTaskMemAlloc(sizeof(char) * cchRequired);
        }
        else
        {
            pszT = new char[cchRequired];
        }
        if (!pszT)
        {
            return NULL;
        }
    }

    if (!WideCharToMultiByte(CP_ACP, 0, wzFrom, -1, pszT, cchRequired, NULL, NULL))
    {
        //TransAssert((0));
        if (pszT != szTo)
        {
            (fTaskMalloc ? CoTaskMemFree(pszT) : delete pszT);
        }
        pszT = NULL;
    }

    return pszT;
}

//+---------------------------------------------------------------------------
//
//  Function:   WzA2WDynamic
//
//  Synopsis:   Convert Ansi string szFrom to Unicode, and return the Unicode string.
//              The Unicode string will be written into wzTo (whose size is cwchTo bytes)
//              if wzTo is nonNull AND it is large enough to hold the Unicode string.
//              If this is not the case, the Unicode string is dynamically allocated.
//              If 'fTaskMalloc', allocation is done thru IMalloc, otherwise it is done
//              thru new.
//
//  Arguments:  [szFrom] --
//              [wzTo] --
//              [cwchTo] --
//              [fTaskMalloc] --
//
//  Returns:    If error returns NULL, otherwise returns
//              pointer to Unicode string (if different from wzTo, it must be freed via
//              delete or IMalloc, as appropriate).
//
//  History:    x-xx-xx   Clarg                    Created
//              2-25-96   JohannP (Johann Posch)   modified
//
//  Notes:
//
//----------------------------------------------------------------------------
LPWSTR WzA2WDynamic(LPCSTR szFrom, LPWSTR wzTo, int cwchTo, BOOL fTaskMalloc)
{
    int cwchRequired;
    WCHAR *pwzT = NULL;

    cwchRequired = MultiByteToWideChar(CP_ACP, 0, szFrom, -1, NULL, 0);
    cwchRequired++;
    TransAssert((cwchRequired > 0));

    if (wzTo && cwchTo && (cwchTo >= cwchRequired))
    {
        // wzTo has enough space
        pwzT = wzTo;
    }
    else
    {
        // wzTo is not large enough; dynamically allocate the buffer
        if (fTaskMalloc)
        {
            pwzT = (WCHAR*)CoTaskMemAlloc(sizeof(WCHAR) * cwchRequired);
        }
        else
        {
            pwzT = new WCHAR[cwchRequired];
        }

        if (!pwzT)
        {
            return NULL;
        }
    }

    if (!MultiByteToWideChar(CP_ACP, 0, szFrom, -1, pwzT, cwchRequired))
    {
        //Assert(0);
        if (pwzT != wzTo)
        {
            (fTaskMalloc ? CoTaskMemFree(pwzT) : delete pwzT);
        }

        pwzT = NULL;
    }

    return pwzT;
}

//+---------------------------------------------------------------------------
//
//  Function:   OLESTRDuplicate
//
//  Synopsis:
//
//  Arguments:  [ws] --
//
//  Returns:
//
//  History:    2-25-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
LPWSTR OLESTRDuplicate(LPCWSTR ws)
{
    DWORD cLen;
    LPWSTR wsNew = NULL;

    if (ws)
    {
        wsNew = (LPWSTR) new  WCHAR [wcslen(ws) + 1];
        if (wsNew)
        {
            wcscpy(wsNew, ws);
        }
    }

    return wsNew;
}


//+-------------------------------------------------------------------------
//
//  Function:   WideCharToMultiByteWithMlang
//
//  Synopsis:   Convert Unicode string wzFrom to Ansi by uring MLANG, 
//
//  History:    5-29-97   DanpoZ (Danpo Zhang)     Created
//
//  Notes:
//
//--------------------------------------------------------------------------
void WideCharToMultiByteWithMlang(
    LPCWSTR lpwszWide,
    LPSTR   lpszAnsi,
    int     cchAnsi,
    DWORD   dwCodePage)
{
    INT cchOut;
    INT cchIn = wcslen(lpwszWide);
    HRESULT hr = NOERROR;

    typedef HRESULT (WINAPI * pfnMLANGW2A)(
        LPDWORD, DWORD, LPCWSTR, LPINT, LPSTR, LPINT);

    static pfnMLANGW2A pfnConvertINetUnicodeToMultiByte = NULL;

    if(!g_hLibMlang)
    {
        g_hLibMlang = LoadLibraryA("mlang.dll");
        if(!g_hLibMlang)
        {
            goto End;
        }
    }

    if (!pfnConvertINetUnicodeToMultiByte)
    {
        pfnConvertINetUnicodeToMultiByte= (pfnMLANGW2A)GetProcAddress(
            g_hLibMlang, "ConvertINetUnicodeToMultiByte");
        if (!pfnConvertINetUnicodeToMultiByte)
        {
            goto End;
        }
    }
        

    // first call to get the lenth of the Multi-Byte string 
    hr = pfnConvertINetUnicodeToMultiByte(
        NULL, dwCodePage, lpwszWide, &cchIn, NULL, &cchOut);

    if( !FAILED(hr) && cchOut <= cchAnsi )
    {
        hr = pfnConvertINetUnicodeToMultiByte(
            NULL, dwCodePage, lpwszWide, &cchIn, lpszAnsi, &cchOut);
    }

End:;
    
}

DWORD StrLenMultiByteWithMlang(
    LPCWSTR lpwszWide,
    DWORD   dwCodePage)
{
    INT cchOut;
    INT cchIn = wcslen(lpwszWide);
    HRESULT hr = NOERROR;

    typedef HRESULT (WINAPI * pfnMLANGW2A)(
        LPDWORD, DWORD, LPCWSTR, LPINT, LPSTR, LPINT);

    static pfnMLANGW2A pfnConvertINetUnicodeToMultiByte = NULL;

    if(!g_hLibMlang)
    {
        g_hLibMlang = LoadLibraryA("mlang.dll");
        if(!g_hLibMlang)
        {
            goto Error;
        }
    }

    if (!pfnConvertINetUnicodeToMultiByte)
    {
        pfnConvertINetUnicodeToMultiByte= (pfnMLANGW2A)GetProcAddress(
            g_hLibMlang, "ConvertINetUnicodeToMultiByte");
        if (!pfnConvertINetUnicodeToMultiByte)
        {
            goto Error;
        }
    }
        

    // first call to get the lenth of the Multi-Byte string 
    hr = pfnConvertINetUnicodeToMultiByte(
        NULL, dwCodePage, lpwszWide, &cchIn, NULL, &cchOut);

    if( !FAILED(hr) )
    {
        return cchOut;
    }

Error:
    return 0;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\urlmon\uuid\makefile.inc ===
LIBDIR=$(SDK_LIB_DEST)
LIBFILE=$(TARGET_DIRECTORY)\uuidmon3.lib


$(LIBDIR)\chicago\$(LIBFILE) : $(LIBDIR)\$(LIBFILE)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\urlmon\utils\w4io.h ===
/***
*w4io.h - fake FILE structure for Win 4 printf/sprintf/debug printf support
*
*/

#ifdef unix
#include <windows.h>
#endif /* unix */

#if defined(M_I386) || defined(WIN32)
#  ifndef WIN32
#    define WIN32
#  endif
#elif !defined(M_I86LM)
#  error Must be FLAT or LARGE model.
#endif

#ifndef NULL
#  define NULL 0
#endif

struct w4io
{
    union
    {
        struct
        {
            wchar_t *_pwcbuf;   // wchar_t output buffer
            wchar_t *_pwcstart;
        } wc;
        struct
        {
            char *_pchbuf;      // char output buffer
            char *_pchstart;
        } ch;
    } buf ;
    unsigned int cchleft;       // output buffer character count
    void (_cdecl *writechar)(int ch,
                             int num,
                             struct w4io *f,
                             int *pcchwritten);
};

#define pwcbuf          buf.wc._pwcbuf
#define pwcstart        buf.wc._pwcstart
#define pchbuf          buf.ch._pchbuf
#define pchstart        buf.ch._pchstart

#define REG1 register
#define REG2 register

/* prototypes */
int _cdecl w4iooutput(struct w4io *stream, const char *format, va_list argptr);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\urlmon\utils\wreg.cxx ===
#include <urlmon.hxx>
#include "wreg.hxx"

#define DEB_REG DEB_ERROR

CRegistryA g_Reg;
CRegistryA *g_vpReg = &g_Reg;

//+---------------------------------------------------------------------------
//
//  Method:     CRegistryW::QueryInterface
//
//  Synopsis:
//
//  Arguments:  [riid] --
//              [ppv] --
//
//  Returns:
//
//  History:    11-11-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CRegistryW::QueryInterface( REFIID riid, void **ppv )
{
    HRESULT     hr = NOERROR;

    UrlMkDebugOut((DEB_REG, "%p _IN CRegistryW::QueryInterface (%lx, %p)\n", this, riid, ppv));

    if ((riid == IID_IUnknown) || (riid == IID_IRegistryW))
    {
        *ppv = (void FAR *)this;
        AddRef();
    }
    else
    {
        *ppv = NULL;
        hr = E_NOINTERFACE;
    }

    UrlMkDebugOut((DEB_REG, "%p OUT CRegistryW::QueryInterface (%lx)[%p]\n", this, hr, *ppv));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CRegistryW::AddRef
//
//  Synopsis:
//
//  Arguments:  [void] --
//
//  Returns:
//
//  History:    11-11-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CRegistryW::AddRef( void )
{
    UrlMkDebugOut((DEB_REG, "%p _IN CRegistryW::AddRef\n", this));

    LONG lRet = _CRefs++;

    UrlMkDebugOut((DEB_REG, "%p OUT CRegistryW::AddRef (%ld)\n", this, lRet));
    return lRet;
}

//+---------------------------------------------------------------------------
//
//  Method:     CRegistryW::Release
//
//  Synopsis:
//
//  Arguments:  [void] --
//
//  Returns:
//
//  History:    11-11-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CRegistryW::Release( void )
{
    UrlMkDebugOut((DEB_REG, "%p _IN CRegistryW::Release\n", this));

    LONG lRet = --_CRefs;
    if (_CRefs == 0)
    {
        delete this;
    }
    UrlMkDebugOut((DEB_REG, "%p OUT CRegistryW::Release (%ld)\n", this, lRet));
    return lRet;
}

// can this method be supported
STDMETHODIMP_(LONG) CRegistryW::ConnectRegistry (
     LPWSTR lpMachineName,
     HKEY hKey,
     IRegistryW **ppReg
    )
{
    UrlMkDebugOut((DEB_REG, "%p _IN CRegistryW::ConnectRegistry\n", this));
    HKEY hKeyLoc = 0;

    LONG lRet;

    lRet  = RegConnectRegistryW(lpMachineName, hKey, &hKeyLoc);

    UrlMkDebugOut((DEB_REG, "%p OUT CRegistryW::ConnectRegistry (%ld)\n", this, lRet));
    return lRet;
}


STDMETHODIMP_(LONG) CRegistryW::CloseKey (
     HKEY hKey
    )
{
    UrlMkDebugOut((DEB_REG, "%p _IN CRegistryW::CloseKey\n", this));
    LONG lRet = 0;
    lRet = RegCloseKey( hKey );

    UrlMkDebugOut((DEB_REG, "%p OUT CRegistryW::CloseKey (%ld)\n", this, lRet));
    return lRet;
}

STDMETHODIMP_(LONG) CRegistryW::CreateKey (
     HKEY hKey,
     LPCWSTR lpSubKey,
     PHKEY phkResult
    )
{
    UrlMkDebugOut((DEB_REG, "%p _IN CRegistryW::CreateKey\n", this));
    LONG lRet = 0;

    lRet = RegCreateKeyW(hKey, lpSubKey, phkResult);

    UrlMkDebugOut((DEB_REG, "%p OUT CRegistryW::CreateKey (%ld)\n", this, lRet));
    return lRet;
}

STDMETHODIMP_(LONG) CRegistryW::CreateKeyEx (
     HKEY hKey,
     LPCWSTR lpSubKey,
     DWORD Reserved,
     LPWSTR lpClass,
     DWORD dwOptions,
     REGSAM samDesired,
     LPSECURITY_ATTRIBUTES lpSecurityAttributes,
     PHKEY phkResult,
     LPDWORD lpdwDisposition
    )
{
    UrlMkDebugOut((DEB_REG, "%p _IN CRegistryW::CreateKeyEx\n", this));
    LONG lRet = 0;
    lRet = RegCreateKeyExW (
             hKey,
             lpSubKey,
             Reserved,
             lpClass,
             dwOptions,
             samDesired,
             lpSecurityAttributes,
             phkResult,
             lpdwDisposition
            );

    UrlMkDebugOut((DEB_REG, "%p OUT CRegistryW::CreateKeyEx (%ld)\n", this, lRet));
    return lRet;
}

STDMETHODIMP_(LONG) CRegistryW::DeleteKey (
     HKEY hKey,
     LPCWSTR lpSubKey
    )
{
    UrlMkDebugOut((DEB_REG, "%p _IN CRegistryW::DeleteKey\n", this));
    LONG lRet = 0;

    lRet = RegDeleteKeyW(hKey, lpSubKey);

    UrlMkDebugOut((DEB_REG, "%p OUT CRegistryW::DeleteKey (%ld)\n", this, lRet));
    return lRet;
}

STDMETHODIMP_(LONG) CRegistryW::DeleteValue (
     HKEY hKey,
     LPCWSTR lpValueName
    )
{
    UrlMkDebugOut((DEB_REG, "%p _IN CRegistryW::DeleteValue\n", this));
    LONG lRet = 0;

    lRet = RegDeleteValueW(hKey, lpValueName);

    UrlMkDebugOut((DEB_REG, "%p OUT CRegistryW::DeleteValue (%ld)\n", this, lRet));
    return lRet;
}


STDMETHODIMP_(LONG) CRegistryW::EnumKey (
     HKEY hKey,
     DWORD dwIndex,
     LPWSTR lpName,
     DWORD cbName
    )
{
    UrlMkDebugOut((DEB_REG, "%p _IN CRegistryW::EnumKey\n", this));
    LONG lRet = 0;

    lRet = RegEnumKeyW (hKey, dwIndex, lpName, cbName);

    UrlMkDebugOut((DEB_REG, "%p OUT CRegistryW::EnumKey (%ld)\n", this, lRet));
    return lRet;
}


STDMETHODIMP_(LONG) CRegistryW::EnumKeyEx (
     HKEY hKey,
     DWORD dwIndex,
     LPWSTR lpName,
     LPDWORD lpcbName,
     LPDWORD lpReserved,
     LPWSTR lpClass,
     LPDWORD lpcbClass,
     PFILETIME lpftLastWriteTime
    )
{
    UrlMkDebugOut((DEB_REG, "%p _IN CRegistryW::EnumKeyEx\n", this));
    LONG lRet = 0;

    lRet = RegEnumKeyExW(hKey,dwIndex,lpName,lpcbName,lpReserved,
                 lpClass,lpcbClass,lpftLastWriteTime);

    UrlMkDebugOut((DEB_REG, "%p OUT CRegistryW::EnumKeyEx (%ld)\n", this, lRet));
    return lRet;
}

STDMETHODIMP_(LONG) CRegistryW::EnumValue (
     HKEY hKey,
     DWORD dwIndex,
     LPWSTR lpValueName,
     LPDWORD lpcbValueName,
     LPDWORD lpReserved,
     LPDWORD lpType,
     LPBYTE lpData,
     LPDWORD lpcbData
    )
{
    UrlMkDebugOut((DEB_REG, "%p _IN CRegistryW::EnumValue\n", this));
    LONG lRet = 0;
    lRet = RegEnumValueW(hKey,dwIndex,lpValueName,
                lpcbValueName,lpReserved,lpType,lpData,lpcbData);

    UrlMkDebugOut((DEB_REG, "%p OUT CRegistryW::EnumValue (%ld)\n", this, lRet));
    return lRet;
}


STDMETHODIMP_(LONG) CRegistryW::FlushKey (HKEY hKey)
{
    UrlMkDebugOut((DEB_REG, "%p _IN CRegistryW::FlushKey\n", this));
    LONG lRet = 0;

    lRet = RegFlushKey(hKey);

    UrlMkDebugOut((DEB_REG, "%p OUT CRegistryW::FlushKey (%ld)\n", this, lRet));
    return lRet;
}


STDMETHODIMP_(LONG) CRegistryW::GetKeySecurity (
     HKEY hKey,
     SECURITY_INFORMATION SecurityInformation,
     PSECURITY_DESCRIPTOR pSecurityDescriptor,
     LPDWORD lpcbSecurityDescriptor)
{
    UrlMkDebugOut((DEB_REG, "%p _IN CRegistryW::GetKeySecurity\n", this));
    LONG lRet = 0;

    lRet = RegGetKeySecurity (hKey,SecurityInformation, pSecurityDescriptor,lpcbSecurityDescriptor);

    UrlMkDebugOut((DEB_REG, "%p OUT CRegistryW::GetKeySecurity (%ld)\n", this, lRet));
    return lRet;
}

STDMETHODIMP_(LONG) CRegistryW::LoadKey (
     HKEY  hKey,
     LPCWSTR  lpSubKey,
     LPCWSTR  lpFile
    )
{
    UrlMkDebugOut((DEB_REG, "%p _IN CRegistryW::LoadKey\n", this));
    LONG lRet = 0;

    lRet = RegLoadKeyW(hKey, lpSubKey, lpFile);

    UrlMkDebugOut((DEB_REG, "%p OUT CRegistryW::LoadKey (%ld)\n", this, lRet));
    return lRet;
}

STDMETHODIMP_(LONG) CRegistryW::NotifyChangeKeyValue (
     HKEY hKey,
     BOOL bWatchSubtree,
     DWORD dwNotifyFilter,
     HANDLE hEvent,
     BOOL fAsynchronus
    )
{
    UrlMkDebugOut((DEB_REG, "%p _IN CRegistryW::NotifyChangeKeyValue\n", this));
    LONG lRet = 0;

    lRet = RegNotifyChangeKeyValue(hKey, bWatchSubtree, dwNotifyFilter, hEvent,fAsynchronus);

    UrlMkDebugOut((DEB_REG, "%p OUT CRegistryW::NotifyChangeKeyValue (%ld)\n", this, lRet));
    return lRet;
}

STDMETHODIMP_(LONG) CRegistryW::OpenKey (
     HKEY hKey,
     LPCWSTR lpSubKey,
     PHKEY phkResult
    )
{
    UrlMkDebugOut((DEB_REG, "%p _IN CRegistryW::OpenKey\n", this));
    LONG lRet = 0;

    lRet =  RegOpenKeyW(hKey, lpSubKey, phkResult);

    UrlMkDebugOut((DEB_REG, "%p OUT CRegistryW::OpenKey (%ld)\n", this, lRet));
    return lRet;
}

STDMETHODIMP_(LONG) CRegistryW::OpenKeyEx (
     HKEY hKey,
     LPCWSTR lpSubKey,
     DWORD ulOptions,
     REGSAM samDesired,
     PHKEY phkResult
    )
{
    UrlMkDebugOut((DEB_REG, "%p _IN CRegistryW::OpenKeyEx\n", this));
    LONG lRet = 0;

    lRet = RegOpenKeyExW(hKey,lpSubKey,ulOptions,samDesired,phkResult);

    UrlMkDebugOut((DEB_REG, "%p OUT CRegistryW::OpenKeyEx (%ld)\n", this, lRet));
    return lRet;
}


STDMETHODIMP_(LONG) CRegistryW::QueryInfoKey (
     HKEY    hKey,
     LPWSTR  lpClass,
     LPDWORD lpcbClass,
     LPDWORD lpReserved,
     LPDWORD lpcSubKeys,
     LPDWORD lpcbMaxSubKeyLen,
     LPDWORD lpcbMaxClassLen,
     LPDWORD lpcValues,
     LPDWORD lpcbMaxValueNameLen,
     LPDWORD lpcbMaxValueLen,
     LPDWORD lpcbSecurityDescriptor,
     PFILETIME lpftLastWriteTime
    )
{
    UrlMkDebugOut((DEB_REG, "%p _IN CRegistryW::QueryInfoKey\n", this));
    LONG lRet = 0;

    lRet = RegQueryInfoKeyW (
         hKey,
         lpClass,
         lpcbClass,
         lpReserved,
         lpcSubKeys,
         lpcbMaxSubKeyLen,
         lpcbMaxClassLen,
         lpcValues,
         lpcbMaxValueNameLen,
         lpcbMaxValueLen,
         lpcbSecurityDescriptor,
         lpftLastWriteTime);

    UrlMkDebugOut((DEB_REG, "%p OUT CRegistryW::QueryInfoKey (%ld)\n", this, lRet));
    return lRet;
}

STDMETHODIMP_(LONG) CRegistryW::QueryValue (
     HKEY hKey,
     LPCWSTR lpSubKey,
     LPWSTR lpValue,
     LONG   *lpcbValue
    )
{
    UrlMkDebugOut((DEB_REG, "%p _IN CRegistryW::QueryValue\n", this));
    LONG lRet = 0;

    lRet = RegQueryValueW(hKey,lpSubKey,lpValue,lpcbValue);

    UrlMkDebugOut((DEB_REG, "%p OUT CRegistryW::QueryValue (%ld)\n", this, lRet));
    return lRet;
}

STDMETHODIMP_(LONG) CRegistryW::QueryMultipleValues (
     HKEY hKey,
     PVALENTXW val_list,
     DWORD num_vals,
     LPWSTR lpValueBuf,
     LPDWORD ldwTotsize
    )
{
    UrlMkDebugOut((DEB_REG, "%p _IN CRegistryW::QueryMultipleValues\n", this));
    LONG lRet = 0;

    lRet = RegQueryMultipleValuesW(hKey,(PVALENTW) val_list, num_vals, lpValueBuf, ldwTotsize);

    UrlMkDebugOut((DEB_REG, "%p OUT CRegistryW::QueryMultipleValues (%ld)\n", this, lRet));
    return lRet;
}

STDMETHODIMP_(LONG) CRegistryW::QueryValueEx (
     HKEY hKey,
     LPCWSTR lpValueName,
     LPDWORD lpReserved,
     LPDWORD lpType,
     LPBYTE lpData,
     LPDWORD lpcbData
    )
{
    UrlMkDebugOut((DEB_REG, "%p _IN CRegistryW::QueryValueEx\n", this));
    LONG lRet = 0;

    lRet = RegQueryValueExW(hKey, lpValueName, lpReserved, lpType, lpData, lpcbData);

    UrlMkDebugOut((DEB_REG, "%p OUT CRegistryW::QueryValueEx (%ld)\n", this, lRet));
    return lRet;
}

STDMETHODIMP_(LONG) CRegistryW::ReplaceKey (
     HKEY     hKey,
     LPCWSTR  lpSubKey,
     LPCWSTR  lpNewFile,
     LPCWSTR  lpOldFile
    )
{
    UrlMkDebugOut((DEB_REG, "%p _IN CRegistryW::ReplaceKey\n", this));
    LONG lRet = 0;

    lRet = RegReplaceKeyW(hKey, lpSubKey, lpNewFile, lpOldFile);

    UrlMkDebugOut((DEB_REG, "%p OUT CRegistryW::ReplaceKey (%ld)\n", this, lRet));
    return lRet;
}

STDMETHODIMP_(LONG) CRegistryW::RestoreKey (
     HKEY hKey,
     LPCWSTR lpFile,
     DWORD   dwFlags
    )
{
    UrlMkDebugOut((DEB_REG, "%p _IN CRegistryW::RestoreKey\n", this));
    LONG lRet = 0;

    lRet = RegRestoreKeyW(hKey, lpFile, dwFlags);

    UrlMkDebugOut((DEB_REG, "%p OUT CRegistryW::RestoreKey (%ld)\n", this, lRet));
    return lRet;
}

STDMETHODIMP_(LONG) CRegistryW::SaveKey (
     HKEY hKey,
     LPCWSTR lpFile,
     LPSECURITY_ATTRIBUTES lpSecurityAttributes
    )
{
    UrlMkDebugOut((DEB_REG, "%p _IN CRegistryW::SaveKey\n", this));
    LONG lRet = 0;

    lRet = RegSaveKeyW(hKey, lpFile, lpSecurityAttributes);

    UrlMkDebugOut((DEB_REG, "%p OUT CRegistryW::SaveKey (%ld)\n", this, lRet));
    return lRet;
}

STDMETHODIMP_(LONG) CRegistryW::SetKeySecurity (
     HKEY hKey,
     SECURITY_INFORMATION SecurityInformation,
     PSECURITY_DESCRIPTOR pSecurityDescriptor
    )
{
    UrlMkDebugOut((DEB_REG, "%p _IN CRegistryW::SetKeySecurity\n", this));
    LONG lRet = 0;

    lRet = RegSetKeySecurity(hKey, SecurityInformation, pSecurityDescriptor);

    UrlMkDebugOut((DEB_REG, "%p OUT CRegistryW::SetKeySecurity (%ld)\n", this, lRet));
    return lRet;
}

STDMETHODIMP_(LONG) CRegistryW::SetValue (
     HKEY hKey,
     LPCWSTR lpSubKey,
     DWORD dwType,
     LPCWSTR lpData,
     DWORD cbData
    )
{
    UrlMkDebugOut((DEB_REG, "%p _IN CRegistryW::SetValue\n", this));
    LONG lRet = 0;

    lRet = RegSetValueW(hKey, lpSubKey, dwType,lpData, cbData );

    UrlMkDebugOut((DEB_REG, "%p OUT CRegistryW::SetValue (%ld)\n", this, lRet));
    return lRet;
}

STDMETHODIMP_(LONG) CRegistryW::SetValueEx (
     HKEY hKey,
     LPCWSTR lpValueName,
     DWORD Reserved,
     DWORD dwType,
     const BYTE* lpData,
     DWORD cbData
    )
{
    UrlMkDebugOut((DEB_REG, "%p _IN CRegistryW::SetValueEx\n", this));
    LONG lRet = 0;

    lRet = RegSetValueExW(hKey, lpValueName, Reserved, dwType,lpData, cbData);

    UrlMkDebugOut((DEB_REG, "%p OUT CRegistryW::SetValueEx (%ld)\n", this, lRet));
    return lRet;
}

STDMETHODIMP_(LONG) CRegistryW::UnLoadKey (
     HKEY hKey,
     LPCWSTR lpSubKey
    )
{
    UrlMkDebugOut((DEB_REG, "%p _IN CRegistryW::UnLoadKey\n", this));
    LONG lRet = 0;

    lRet = RegUnLoadKeyW(hKey, lpSubKey);

    UrlMkDebugOut((DEB_REG, "%p OUT CRegistryW::UnLoadKey (%ld)\n", this, lRet));
    return lRet;
}


//+---------------------------------------------------------------------------
//
//  Method:     CRegistryW::QueryInterface
//
//  Synopsis:
//
//  Arguments:  [riid] --
//              [ppv] --
//
//  Returns:
//
//  History:    11-11-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CRegistryA::QueryInterface( REFIID riid, void **ppv )
{
    HRESULT     hr = NOERROR;

    UrlMkDebugOut((DEB_REG, "%p _IN CRegistryA::QueryInterface (%lx, %p)\n", this, riid, ppv));

    if ((riid == IID_IUnknown) || (riid == IID_IRegistryA))
    {
        *ppv = (void FAR *)this;
        AddRef();
    }
    else
    {
        *ppv = NULL;
        hr = E_NOINTERFACE;
    }

    UrlMkDebugOut((DEB_REG, "%p OUT CRegistryA::QueryInterface (%lx)[%p]\n", this, hr, *ppv));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CRegistryA::AddRef
//
//  Synopsis:
//
//  Arguments:  [void] --
//
//  Returns:
//
//  History:    11-11-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CRegistryA::AddRef( void )
{
    UrlMkDebugOut((DEB_REG, "%p _IN CRegistryA::AddRef\n", this));

    LONG lRet = _CRefs++;

    UrlMkDebugOut((DEB_REG, "%p OUT CRegistryA::AddRef (%ld)\n", this, lRet));
    return lRet;
}

//+---------------------------------------------------------------------------
//
//  Method:     CRegistryA::Release
//
//  Synopsis:
//
//  Arguments:  [void] --
//
//  Returns:
//
//  History:    11-11-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CRegistryA::Release( void )
{
    UrlMkDebugOut((DEB_REG, "%p _IN CRegistryA::Release\n", this));

    LONG lRet = --_CRefs;
    if (_CRefs == 0)
    {
        delete this;
    }
    UrlMkDebugOut((DEB_REG, "%p OUT CRegistryA::Release (%ld)\n", this, lRet));
    return lRet;
}

// can this method be supported
STDMETHODIMP_(LONG) CRegistryA::ConnectRegistry (
     LPSTR lpMachineName,
     HKEY hKey,
     IRegistryA **ppReg
    )
{
    UrlMkDebugOut((DEB_REG, "%p _IN CRegistryA::ConnectRegistry\n", this));
    HKEY hKeyLoc = 0;

    LONG lRet;

    lRet  = RegConnectRegistryA(lpMachineName, hKey, &hKeyLoc);

    UrlMkDebugOut((DEB_REG, "%p OUT CRegistryA::ConnectRegistry (%ld)\n", this, lRet));
    return lRet;
}


STDMETHODIMP_(LONG) CRegistryA::CloseKey (
     HKEY hKey
    )
{
    UrlMkDebugOut((DEB_REG, "%p _IN CRegistryA::CloseKey\n", this));
    LONG lRet = 0;
    lRet = RegCloseKey( hKey );

    UrlMkDebugOut((DEB_REG, "%p OUT CRegistryA::CloseKey (%ld)\n", this, lRet));
    return lRet;
}

STDMETHODIMP_(LONG) CRegistryA::CreateKey (
     HKEY hKey,
     LPCSTR lpSubKey,
     PHKEY phkResult
    )
{
    UrlMkDebugOut((DEB_REG, "%p _IN CRegistryA::CreateKey\n", this));
    LONG lRet = 0;

    lRet = RegCreateKeyA(hKey, lpSubKey, phkResult);

    UrlMkDebugOut((DEB_REG, "%p OUT CRegistryA::CreateKey (%ld)\n", this, lRet));
    return lRet;
}

STDMETHODIMP_(LONG) CRegistryA::CreateKeyEx (
     HKEY hKey,
     LPCSTR lpSubKey,
     DWORD Reserved,
     LPSTR lpClass,
     DWORD dwOptions,
     REGSAM samDesired,
     LPSECURITY_ATTRIBUTES lpSecurityAttributes,
     PHKEY phkResult,
     LPDWORD lpdwDisposition
    )
{
    UrlMkDebugOut((DEB_REG, "%p _IN CRegistryA::CreateKeyEx\n", this));
    LONG lRet = 0;
    lRet = RegCreateKeyExA (
             hKey,
             lpSubKey,
             Reserved,
             lpClass,
             dwOptions,
             samDesired,
             lpSecurityAttributes,
             phkResult,
             lpdwDisposition
            );

    UrlMkDebugOut((DEB_REG, "%p OUT CRegistryA::CreateKeyEx (%ld)\n", this, lRet));
    return lRet;
}

STDMETHODIMP_(LONG) CRegistryA::DeleteKey (
     HKEY hKey,
     LPCSTR lpSubKey
    )
{
    UrlMkDebugOut((DEB_REG, "%p _IN CRegistryA::DeleteKey\n", this));
    LONG lRet = 0;

    lRet = RegDeleteKeyA(hKey, lpSubKey);

    UrlMkDebugOut((DEB_REG, "%p OUT CRegistryA::DeleteKey (%ld)\n", this, lRet));
    return lRet;
}

STDMETHODIMP_(LONG) CRegistryA::DeleteValue (
     HKEY hKey,
     LPCSTR lpValueName
    )
{
    UrlMkDebugOut((DEB_REG, "%p _IN CRegistryA::DeleteValue\n", this));
    LONG lRet = 0;

    lRet = RegDeleteValueA(hKey, lpValueName);

    UrlMkDebugOut((DEB_REG, "%p OUT CRegistryA::DeleteValue (%ld)\n", this, lRet));
    return lRet;
}


STDMETHODIMP_(LONG) CRegistryA::EnumKey (
     HKEY hKey,
     DWORD dwIndex,
     LPSTR lpName,
     DWORD cbName
    )
{
    UrlMkDebugOut((DEB_REG, "%p _IN CRegistryA::EnumKey\n", this));
    LONG lRet = 0;

    lRet = RegEnumKeyA (hKey, dwIndex, lpName, cbName);

    UrlMkDebugOut((DEB_REG, "%p OUT CRegistryA::EnumKey (%ld)\n", this, lRet));
    return lRet;
}


STDMETHODIMP_(LONG) CRegistryA::EnumKeyEx (
     HKEY hKey,
     DWORD dwIndex,
     LPSTR lpName,
     LPDWORD lpcbName,
     LPDWORD lpReserved,
     LPSTR lpClass,
     LPDWORD lpcbClass,
     PFILETIME lpftLastWriteTime
    )
{
    UrlMkDebugOut((DEB_REG, "%p _IN CRegistryA::EnumKeyEx\n", this));
    LONG lRet = 0;

    lRet = RegEnumKeyExA(hKey,dwIndex,lpName,lpcbName,lpReserved,
                 lpClass,lpcbClass,lpftLastWriteTime);

    UrlMkDebugOut((DEB_REG, "%p OUT CRegistryA::EnumKeyEx (%ld)\n", this, lRet));
    return lRet;
}

STDMETHODIMP_(LONG) CRegistryA::EnumValue (
     HKEY hKey,
     DWORD dwIndex,
     LPSTR lpValueName,
     LPDWORD lpcbValueName,
     LPDWORD lpReserved,
     LPDWORD lpType,
     LPBYTE lpData,
     LPDWORD lpcbData
    )
{
    UrlMkDebugOut((DEB_REG, "%p _IN CRegistryA::EnumValue\n", this));
    LONG lRet = 0;
    lRet = RegEnumValueA(hKey,dwIndex,lpValueName,
                lpcbValueName,lpReserved,lpType,lpData,lpcbData);

    UrlMkDebugOut((DEB_REG, "%p OUT CRegistryA::EnumValue (%ld)\n", this, lRet));
    return lRet;
}


STDMETHODIMP_(LONG) CRegistryA::FlushKey (HKEY hKey)
{
    UrlMkDebugOut((DEB_REG, "%p _IN CRegistryA::FlushKey\n", this));
    LONG lRet = 0;

    lRet = RegFlushKey(hKey);

    UrlMkDebugOut((DEB_REG, "%p OUT CRegistryA::FlushKey (%ld)\n", this, lRet));
    return lRet;
}


STDMETHODIMP_(LONG) CRegistryA::GetKeySecurity (
     HKEY hKey,
     SECURITY_INFORMATION SecurityInformation,
     PSECURITY_DESCRIPTOR pSecurityDescriptor,
     LPDWORD lpcbSecurityDescriptor)
{
    UrlMkDebugOut((DEB_REG, "%p _IN CRegistryA::GetKeySecurity\n", this));
    LONG lRet = 0;

    lRet = RegGetKeySecurity (hKey,SecurityInformation, pSecurityDescriptor,lpcbSecurityDescriptor);

    UrlMkDebugOut((DEB_REG, "%p OUT CRegistryA::GetKeySecurity (%ld)\n", this, lRet));
    return lRet;
}

STDMETHODIMP_(LONG) CRegistryA::LoadKey (
     HKEY  hKey,
     LPCSTR  lpSubKey,
     LPCSTR  lpFile
    )
{
    UrlMkDebugOut((DEB_REG, "%p _IN CRegistryA::LoadKey\n", this));
    LONG lRet = 0;

    lRet = RegLoadKeyA(hKey, lpSubKey, lpFile);

    UrlMkDebugOut((DEB_REG, "%p OUT CRegistryA::LoadKey (%ld)\n", this, lRet));
    return lRet;
}

STDMETHODIMP_(LONG) CRegistryA::NotifyChangeKeyValue (
     HKEY hKey,
     BOOL bWatchSubtree,
     DWORD dwNotifyFilter,
     HANDLE hEvent,
     BOOL fAsynchronus
    )
{
    UrlMkDebugOut((DEB_REG, "%p _IN CRegistryA::NotifyChangeKeyValue\n", this));
    LONG lRet = 0;

    lRet = RegNotifyChangeKeyValue(hKey, bWatchSubtree, dwNotifyFilter, hEvent,fAsynchronus);

    UrlMkDebugOut((DEB_REG, "%p OUT CRegistryA::NotifyChangeKeyValue (%ld)\n", this, lRet));
    return lRet;
}

STDMETHODIMP_(LONG) CRegistryA::OpenKey (
     HKEY hKey,
     LPCSTR lpSubKey,
     PHKEY phkResult
    )
{
    UrlMkDebugOut((DEB_REG, "%p _IN CRegistryA::OpenKey (lpSubKey:%s)\n", this,lpSubKey));
    LONG lRet = 0;

    lRet =  RegOpenKeyA(hKey, lpSubKey, phkResult);

    UrlMkDebugOut((DEB_REG, "%p OUT CRegistryA::OpenKey (%ld)\n", this, lRet));
    return lRet;
}

STDMETHODIMP_(LONG) CRegistryA::OpenKeyEx (
     HKEY hKey,
     LPCSTR lpSubKey,
     DWORD ulOptions,
     REGSAM samDesired,
     PHKEY phkResult
    )
{
    UrlMkDebugOut((DEB_REG, "%p _IN CRegistryA::OpenKeyEx\n", this));
    LONG lRet = 0;

    lRet = RegOpenKeyExA(hKey,lpSubKey,ulOptions,samDesired,phkResult);

    UrlMkDebugOut((DEB_REG, "%p OUT CRegistryA::OpenKeyEx (%ld)\n", this, lRet));
    return lRet;
}


STDMETHODIMP_(LONG) CRegistryA::QueryInfoKey (
     HKEY    hKey,
     LPSTR  lpClass,
     LPDWORD lpcbClass,
     LPDWORD lpReserved,
     LPDWORD lpcSubKeys,
     LPDWORD lpcbMaxSubKeyLen,
     LPDWORD lpcbMaxClassLen,
     LPDWORD lpcValues,
     LPDWORD lpcbMaxValueNameLen,
     LPDWORD lpcbMaxValueLen,
     LPDWORD lpcbSecurityDescriptor,
     PFILETIME lpftLastWriteTime
    )
{
    UrlMkDebugOut((DEB_REG, "%p _IN CRegistryA::QueryInfoKey\n", this));
    LONG lRet = 0;

    lRet = RegQueryInfoKeyA (
         hKey,
         lpClass,
         lpcbClass,
         lpReserved,
         lpcSubKeys,
         lpcbMaxSubKeyLen,
         lpcbMaxClassLen,
         lpcValues,
         lpcbMaxValueNameLen,
         lpcbMaxValueLen,
         lpcbSecurityDescriptor,
         lpftLastWriteTime);

    UrlMkDebugOut((DEB_REG, "%p OUT CRegistryA::QueryInfoKey (%ld)\n", this, lRet));
    return lRet;
}

STDMETHODIMP_(LONG) CRegistryA::QueryValue (
     HKEY hKey,
     LPCSTR lpSubKey,
     LPSTR lpValue,
     LONG   *lpcbValue
    )
{
    UrlMkDebugOut((DEB_REG, "%p _IN CRegistryA::QueryValue (szValue:%s)\n", this,lpSubKey));
    LONG lRet = 0;

    lRet = RegQueryValueA(hKey,lpSubKey,lpValue,lpcbValue);

    UrlMkDebugOut((DEB_REG, "%p OUT CRegistryA::QueryValue (%ld)\n", this, lRet));
    return lRet;
}

STDMETHODIMP_(LONG) CRegistryA::QueryMultipleValues (
     HKEY hKey,
     PVALENTXA val_list,
     DWORD num_vals,
     LPSTR lpValueBuf,
     LPDWORD ldwTotsize
    )
{
    UrlMkDebugOut((DEB_REG, "%p _IN CRegistryA::QueryMultipleValues\n", this));
    LONG lRet = 0;

    lRet = RegQueryMultipleValuesA(hKey,(PVALENTA) val_list, num_vals, lpValueBuf, ldwTotsize);

    UrlMkDebugOut((DEB_REG, "%p OUT CRegistryA::QueryMultipleValues (%ld)\n", this, lRet));
    return lRet;
}

STDMETHODIMP_(LONG) CRegistryA::QueryValueEx (
     HKEY hKey,
     LPCSTR lpValueName,
     LPDWORD lpReserved,
     LPDWORD lpType,
     LPBYTE lpData,
     LPDWORD lpcbData
    )
{
    UrlMkDebugOut((DEB_REG, "%p _IN CRegistryA::QueryValueEx\n", this));
    LONG lRet = 0;

    lRet = RegQueryValueExA(hKey, lpValueName, lpReserved, lpType, lpData, lpcbData);

    UrlMkDebugOut((DEB_REG, "%p OUT CRegistryA::QueryValueEx (%ld)\n", this, lRet));
    return lRet;
}

STDMETHODIMP_(LONG) CRegistryA::ReplaceKey (
     HKEY     hKey,
     LPCSTR  lpSubKey,
     LPCSTR  lpNewFile,
     LPCSTR  lpOldFile
    )
{
    UrlMkDebugOut((DEB_REG, "%p _IN CRegistryA::ReplaceKey\n", this));
    LONG lRet = 0;

    lRet = RegReplaceKeyA(hKey, lpSubKey, lpNewFile, lpOldFile);

    UrlMkDebugOut((DEB_REG, "%p OUT CRegistryA::ReplaceKey (%ld)\n", this, lRet));
    return lRet;
}

STDMETHODIMP_(LONG) CRegistryA::RestoreKey (
     HKEY hKey,
     LPCSTR lpFile,
     DWORD   dwFlags
    )
{
    UrlMkDebugOut((DEB_REG, "%p _IN CRegistryA::RestoreKey\n", this));
    LONG lRet = 0;

    lRet = RegRestoreKeyA(hKey, lpFile, dwFlags);

    UrlMkDebugOut((DEB_REG, "%p OUT CRegistryA::RestoreKey (%ld)\n", this, lRet));
    return lRet;
}

STDMETHODIMP_(LONG) CRegistryA::SaveKey (
     HKEY hKey,
     LPCSTR lpFile,
     LPSECURITY_ATTRIBUTES lpSecurityAttributes
    )
{
    UrlMkDebugOut((DEB_REG, "%p _IN CRegistryA::SaveKey\n", this));
    LONG lRet = 0;

    lRet = RegSaveKeyA(hKey, lpFile, lpSecurityAttributes);

    UrlMkDebugOut((DEB_REG, "%p OUT CRegistryA::SaveKey (%ld)\n", this, lRet));
    return lRet;
}

STDMETHODIMP_(LONG) CRegistryA::SetKeySecurity (
     HKEY hKey,
     SECURITY_INFORMATION SecurityInformation,
     PSECURITY_DESCRIPTOR pSecurityDescriptor
    )
{
    UrlMkDebugOut((DEB_REG, "%p _IN CRegistryA::SetKeySecurity\n", this));
    LONG lRet = 0;

    lRet = RegSetKeySecurity(hKey, SecurityInformation, pSecurityDescriptor);

    UrlMkDebugOut((DEB_REG, "%p OUT CRegistryA::SetKeySecurity (%ld)\n", this, lRet));
    return lRet;
}

STDMETHODIMP_(LONG) CRegistryA::SetValue (
     HKEY hKey,
     LPCSTR lpSubKey,
     DWORD dwType,
     LPCSTR lpData,
     DWORD cbData
    )
{
    UrlMkDebugOut((DEB_REG, "%p _IN CRegistryA::SetValue\n", this));
    LONG lRet = 0;

    lRet = RegSetValueA(hKey, lpSubKey, dwType,lpData, cbData );

    UrlMkDebugOut((DEB_REG, "%p OUT CRegistryA::SetValue (%ld)\n", this, lRet));
    return lRet;
}

STDMETHODIMP_(LONG) CRegistryA::SetValueEx (
     HKEY hKey,
     LPCSTR lpValueName,
     DWORD Reserved,
     DWORD dwType,
     const BYTE* lpData,
     DWORD cbData
    )
{
    UrlMkDebugOut((DEB_REG, "%p _IN CRegistryA::SetValueEx\n", this));
    LONG lRet = 0;

    lRet = RegSetValueExA(hKey, lpValueName, Reserved, dwType,lpData, cbData);

    UrlMkDebugOut((DEB_REG, "%p OUT CRegistryA::SetValueEx (%ld)\n", this, lRet));
    return lRet;
}

STDMETHODIMP_(LONG) CRegistryA::UnLoadKey (
     HKEY hKey,
     LPCSTR lpSubKey
    )
{
    UrlMkDebugOut((DEB_REG, "%p _IN CRegistryA::UnLoadKey\n", this));
    LONG lRet = 0;

    lRet = RegUnLoadKeyA(hKey, lpSubKey);

    UrlMkDebugOut((DEB_REG, "%p OUT CRegistryA::UnLoadKey (%ld)\n", this, lRet));
    return lRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\urlmon\uuid\guids.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       GUIDS.C
//
//  Contents:   Defines GUIDS used in this DLL.
//
//  Classes:
//
//  Functions:
//
//  History:    11-02-95   JoeS (Joe Souza)     Created
//
//----------------------------------------------------------------------------
//#include <urlint.h>


#ifdef __cplusplus
extern "C" {
#endif

// CLSIDs of the classes implemented in this dll
//DEFINE_GUID(CLSID_URLMoniker, 0x79eac9e0, 0xbaf9, 0x11ce, 0x8c, 0x82, 0x00, 0xaa, 0x00, 0x4b, 0xa9, 0x0b);


#ifndef GUID_DEFINED
#define GUID_DEFINED

typedef struct _GUID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} GUID;
#endif // GUID_DEFINED

const GUID CLSID_StdURLMoniker =
{
    0x79eac9e0, 0xbaf9, 0x11ce, {0x8c, 0x82, 0x00, 0xaa, 0x00, 0x4b, 0xa9, 0x0b }
};
const GUID CLSID_StdURLProtocol =
{
    0x79eac9e1, 0xbaf9, 0x11ce, {0x8c, 0x82, 0x00, 0xaa, 0x00, 0x4b, 0xa9, 0x0b}
};
const GUID CLSID_HttpProtocol =
{
    0x79eac9e2, 0xbaf9, 0x11ce, {0x8c, 0x82, 0x00, 0xaa, 0x00, 0x4b, 0xa9, 0x0b}
};
const GUID CLSID_FtpProtocol =
{
    0x79eac9e3, 0xbaf9, 0x11ce, {0x8c, 0x82, 0x00, 0xaa, 0x00, 0x4b, 0xa9, 0x0b}
};
const GUID CLSID_GopherProtocol =
{
    0x79eac9e4, 0xbaf9, 0x11ce, {0x8c, 0x82, 0x00, 0xaa, 0x00, 0x4b, 0xa9, 0x0b}
};
const GUID CLSID_HttpSProtocol =
{
    0x79eac9e5, 0xbaf9, 0x11ce, {0x8c, 0x82, 0x00, 0xaa, 0x00, 0x4b, 0xa9, 0x0b}
};
const GUID CLSID_FileProtocol =
{
    0x79eac9e6, 0xbaf9, 0x11ce, {0x8c, 0x82, 0x00, 0xaa, 0x00, 0x4b, 0xa9, 0x0b}
};

const GUID CLSID_MkProtocol =
{
    0x79eac9e7, 0xbaf9, 0x11ce, {0x8c, 0x82, 0x00, 0xaa, 0x00, 0x4b, 0xa9, 0x0b}
};

const GUID CLSID_PSUrlMonProxy =
{
    0x79eac9f1, 0xbaf9, 0x11ce, {0x8c, 0x82, 0x00, 0xaa, 0x00, 0x4b, 0xa9, 0x0b}
};

const GUID IID_IAsyncMoniker =
{
    0x79eac9d3, 0xbaf9, 0x11ce, {0x8c, 0x82, 0x00, 0xaa, 0x00, 0x4b, 0xa9, 0x0b}
};

const GUID CLSID_PluginHost =
{
    0x25336920, 0x03F9, 0x11cf, {0x8F, 0xD0, 0x00, 0xAA, 0x00, 0x68, 0x6F, 0x13}
}


#ifdef __cplusplus
}
#endif


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\urlmon\wcheckcb\status.h ===
#ifndef __SILENT_BINDSTATUS__
#define __SILENT_BINDSTATUS__

#include <urlmki.h>

class CSilentCodeDLSink : public IBindStatusCallback, 
                          public ICodeInstall
{
public:
    CSilentCodeDLSink();
    ~CSilentCodeDLSink();

    // Helper function
    HRESULT WaitTillNotified();
    VOID Abort();

    // IUnknown methods
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IBindStatusCallback
    STDMETHODIMP OnStartBinding(
        /* [in] */ DWORD grfBSCOption,
        /* [in] */ IBinding *pib);
    STDMETHODIMP GetPriority(
        /* [out] */ LONG *pnPriority);
    STDMETHODIMP OnLowResource(
        /* [in] */ DWORD reserved);
    STDMETHODIMP OnProgress(
        /* [in] */ ULONG ulProgress,
        /* [in] */ ULONG ulProgressMax,
        /* [in] */ ULONG ulStatusCode,
        /* [in] */ LPCWSTR szStatusText);
    STDMETHODIMP OnStopBinding(
        /* [in] */ HRESULT hresult,
        /* [in] */ LPCWSTR szError);
    STDMETHODIMP GetBindInfo(
        /* [out] */ DWORD *grfBINDINFOF,
        /* [unique][out][in] */ BINDINFO *pbindinfo);
    STDMETHODIMP OnDataAvailable(
        /* [in] */ DWORD grfBSCF,
        /* [in] */ DWORD dwSize,
        /* [in] */ FORMATETC *pformatetc,
        /* [in] */ STGMEDIUM *pstgmed);
    STDMETHODIMP OnObjectAvailable(
        /* [in] */ REFIID riid,
        /* [iid_is][in] */ IUnknown *punk);

    // ICodeInstall methods
    STDMETHODIMP GetWindow(
                    REFGUID rguidReason,
        /* [out] */ HWND *phwnd);
    STDMETHODIMP OnCodeInstallProblem(
                   ULONG ulStatusCode, 
                   LPCWSTR szDestination, 
                   LPCWSTR szSource, 
                   DWORD dwReserved);

protected:

    BOOL            m_fAbort;
    DWORD           m_cRef;
    IBinding*       m_pBinding;
    HANDLE			m_hOnStopBindingEvt;	// Handle to manual reset events
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\urlmon\zones\afxres.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#ifndef __AFXRES_H__
#define __AFXRES_H__

#ifdef REZ  // Mac resource compiler (mrc) defines REZ
#define RC_INVOKED
#endif

#ifdef RC_INVOKED
#ifndef _INC_WINDOWS
#define _INC_WINDOWS
	#include "winres.h"           // extract from windows header
#endif
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

#ifdef APSTUDIO_INVOKED
#define APSTUDIO_HIDDEN_SYMBOLS
#endif

/////////////////////////////////////////////////////////////////////////////
// MFC resource types (see Technical note TN024 for implementation details)

#ifndef RC_INVOKED
#define RT_DLGINIT  MAKEINTRESOURCE(240)
#define RT_TOOLBAR  MAKEINTRESOURCE(241)
#endif

/////////////////////////////////////////////////////////////////////////////

#ifdef APSTUDIO_INVOKED
#undef APSTUDIO_HIDDEN_SYMBOLS
#endif

/////////////////////////////////////////////////////////////////////////////
// General style bits etc

// Tab Control styles
#ifndef TCS_MULTILINE // new in later versions of Win32
#define TCS_MULTILINE       0x0200
#endif

// ControlBar styles
#define CBRS_ALIGN_LEFT     0x1000L
#define CBRS_ALIGN_TOP      0x2000L
#define CBRS_ALIGN_RIGHT    0x4000L
#define CBRS_ALIGN_BOTTOM   0x8000L
#define CBRS_ALIGN_ANY      0xF000L

#define CBRS_BORDER_LEFT    0x0100L
#define CBRS_BORDER_TOP     0x0200L
#define CBRS_BORDER_RIGHT   0x0400L
#define CBRS_BORDER_BOTTOM  0x0800L
#define CBRS_BORDER_ANY     0x0F00L

#define CBRS_TOOLTIPS       0x0010L
#define CBRS_FLYBY          0x0020L
#define CBRS_FLOAT_MULTI    0x0040L
#define CBRS_BORDER_3D      0x0080L
#define CBRS_HIDE_INPLACE   0x0008L
#define CBRS_SIZE_DYNAMIC   0x0004L
#define CBRS_SIZE_FIXED     0x0002L
#define CBRS_FLOATING       0x0001L

#define CBRS_ORIENT_HORZ    (CBRS_ALIGN_TOP|CBRS_ALIGN_BOTTOM)
#define CBRS_ORIENT_VERT    (CBRS_ALIGN_LEFT|CBRS_ALIGN_RIGHT)
#define CBRS_ORIENT_ANY     (CBRS_ORIENT_HORZ|CBRS_ORIENT_VERT)

#define CBRS_ALL            0xFFFFL


// the CBRS_ style is made up of an alignment style and a draw border style
//  the alignment styles are mutually exclusive
//  the draw border styles may be combined
#define CBRS_NOALIGN        0x00000000L
#define CBRS_LEFT           (CBRS_ALIGN_LEFT|CBRS_BORDER_RIGHT)
#define CBRS_TOP            (CBRS_ALIGN_TOP|CBRS_BORDER_BOTTOM)
#define CBRS_RIGHT          (CBRS_ALIGN_RIGHT|CBRS_BORDER_LEFT)
#define CBRS_BOTTOM         (CBRS_ALIGN_BOTTOM|CBRS_BORDER_TOP)

/////////////////////////////////////////////////////////////////////////////
// Standard window components

// Mode indicators in status bar - these are routed like commands
#define ID_INDICATOR_EXT                0xE700  // extended selection indicator
#define ID_INDICATOR_CAPS               0xE701  // cap lock indicator
#define ID_INDICATOR_NUM                0xE702  // num lock indicator
#define ID_INDICATOR_SCRL               0xE703  // scroll lock indicator
#define ID_INDICATOR_OVR                0xE704  // overtype mode indicator
#define ID_INDICATOR_REC                0xE705  // record mode indicator
#define ID_INDICATOR_KANA               0xE706  // kana lock indicator

#define ID_SEPARATOR                    0   // special separator value

#ifndef RC_INVOKED  // code only
// Standard control bars (IDW = window ID)
#define AFX_IDW_CONTROLBAR_FIRST        0xE800
#define AFX_IDW_CONTROLBAR_LAST         0xE8FF

#define AFX_IDW_TOOLBAR                 0xE800  // main Toolbar for window
#define AFX_IDW_STATUS_BAR              0xE801  // Status bar window
#define AFX_IDW_PREVIEW_BAR             0xE802  // PrintPreview Dialog Bar
#define AFX_IDW_RESIZE_BAR              0xE803  // OLE in-place resize bar

// Note: If your application supports docking toolbars, you should
//  not use the following IDs for your own toolbars.  The IDs chosen
//  are at the top of the first 32 such that the bars will be hidden
//  while in print preview mode, and are not likely to conflict with
//  IDs your application may have used succesfully in the past.

#define AFX_IDW_DOCKBAR_TOP             0xE81B
#define AFX_IDW_DOCKBAR_LEFT            0xE81C
#define AFX_IDW_DOCKBAR_RIGHT           0xE81D
#define AFX_IDW_DOCKBAR_BOTTOM          0xE81E
#define AFX_IDW_DOCKBAR_FLOAT           0xE81F

// Macro for mapping standard control bars to bitmask (limit of 32)
#define AFX_CONTROLBAR_MASK(nIDC)   (1L << (nIDC - AFX_IDW_CONTROLBAR_FIRST))

// parts of Main Frame
#define AFX_IDW_PANE_FIRST              0xE900  // first pane (256 max)
#define AFX_IDW_PANE_LAST               0xE9ff
#define AFX_IDW_HSCROLL_FIRST           0xEA00  // first Horz scrollbar (16 max)
#define AFX_IDW_VSCROLL_FIRST           0xEA10  // first Vert scrollbar (16 max)

#define AFX_IDW_SIZE_BOX                0xEA20  // size box for splitters
#define AFX_IDW_PANE_SAVE               0xEA21  // to shift AFX_IDW_PANE_FIRST
#endif //!RC_INVOKED

#ifndef APSTUDIO_INVOKED

// common style for form views
#define AFX_WS_DEFAULT_VIEW             (WS_CHILD | WS_VISIBLE | WS_BORDER)

#endif //!APSTUDIO_INVOKED

/////////////////////////////////////////////////////////////////////////////
// Standard app configurable strings

// for application title (defaults to EXE name or name in constructor)
#define AFX_IDS_APP_TITLE               0xE000
// idle message bar line
#define AFX_IDS_IDLEMESSAGE             0xE001
// message bar line when in shift-F1 help mode
#define AFX_IDS_HELPMODEMESSAGE         0xE002
// document title when editing OLE embedding
#define AFX_IDS_APP_TITLE_EMBEDDING     0xE003
// company name
#define AFX_IDS_COMPANY_NAME            0xE004
// object name when server is inplace
#define AFX_IDS_OBJ_TITLE_INPLACE       0xE005

/////////////////////////////////////////////////////////////////////////////
// Standard Commands

// File commands
#define ID_FILE_NEW                     0xE100
#define ID_FILE_OPEN                    0xE101
#define ID_FILE_CLOSE                   0xE102
#define ID_FILE_SAVE                    0xE103
#define ID_FILE_SAVE_AS                 0xE104
#define ID_FILE_PAGE_SETUP              0xE105
#define ID_FILE_PRINT_SETUP             0xE106
#define ID_FILE_PRINT                   0xE107
#define ID_FILE_PRINT_DIRECT            0xE108
#define ID_FILE_PRINT_PREVIEW           0xE109
#define ID_FILE_UPDATE                  0xE10A
#define ID_FILE_SAVE_COPY_AS            0xE10B
#define ID_FILE_SEND_MAIL               0xE10C

#define ID_FILE_MRU_FIRST               0xE110
#define ID_FILE_MRU_FILE1               0xE110          // range - 16 max
#define ID_FILE_MRU_FILE2               0xE111
#define ID_FILE_MRU_FILE3               0xE112
#define ID_FILE_MRU_FILE4               0xE113
#define ID_FILE_MRU_FILE5               0xE114
#define ID_FILE_MRU_FILE6               0xE115
#define ID_FILE_MRU_FILE7               0xE116
#define ID_FILE_MRU_FILE8               0xE117
#define ID_FILE_MRU_FILE9               0xE118
#define ID_FILE_MRU_FILE10              0xE119
#define ID_FILE_MRU_FILE11              0xE11A
#define ID_FILE_MRU_FILE12              0xE11B
#define ID_FILE_MRU_FILE13              0xE11C
#define ID_FILE_MRU_FILE14              0xE11D
#define ID_FILE_MRU_FILE15              0xE11E
#define ID_FILE_MRU_FILE16              0xE11F
#define ID_FILE_MRU_LAST                0xE11F

// Edit commands
#define ID_EDIT_CLEAR                   0xE120
#define ID_EDIT_CLEAR_ALL               0xE121
#define ID_EDIT_COPY                    0xE122
#define ID_EDIT_CUT                     0xE123
#define ID_EDIT_FIND                    0xE124
#define ID_EDIT_PASTE                   0xE125
#define ID_EDIT_PASTE_LINK              0xE126
#define ID_EDIT_PASTE_SPECIAL           0xE127
#define ID_EDIT_REPEAT                  0xE128
#define ID_EDIT_REPLACE                 0xE129
#define ID_EDIT_SELECT_ALL              0xE12A
#define ID_EDIT_UNDO                    0xE12B
#define ID_EDIT_REDO                    0xE12C

// Window commands
#define ID_WINDOW_NEW                   0xE130
#define ID_WINDOW_ARRANGE               0xE131
#define ID_WINDOW_CASCADE               0xE132
#define ID_WINDOW_TILE_HORZ             0xE133
#define ID_WINDOW_TILE_VERT             0xE134
#define ID_WINDOW_SPLIT                 0xE135
#ifndef RC_INVOKED      // code only
#define AFX_IDM_WINDOW_FIRST            0xE130
#define AFX_IDM_WINDOW_LAST             0xE13F
#define AFX_IDM_FIRST_MDICHILD          0xFF00  // window list starts here
#endif //!RC_INVOKED

// Help and App commands
#define ID_APP_ABOUT                    0xE140
#define ID_APP_EXIT                     0xE141
#define ID_HELP_INDEX                   0xE142
#define ID_HELP_FINDER                  0xE143
#define ID_HELP_USING                   0xE144
#define ID_CONTEXT_HELP                 0xE145      // shift-F1
// special commands for processing help
#define ID_HELP                         0xE146      // first attempt for F1
#define ID_DEFAULT_HELP                 0xE147      // last attempt

// Misc
#define ID_NEXT_PANE                    0xE150
#define ID_PREV_PANE                    0xE151

// Format
#define ID_FORMAT_FONT                  0xE160

// OLE commands
#define ID_OLE_INSERT_NEW               0xE200
#define ID_OLE_EDIT_LINKS               0xE201
#define ID_OLE_EDIT_CONVERT             0xE202
#define ID_OLE_EDIT_CHANGE_ICON         0xE203
#define ID_OLE_EDIT_PROPERTIES          0xE204
#define ID_OLE_VERB_FIRST               0xE210     // range - 16 max
#ifndef RC_INVOKED      // code only
#define ID_OLE_VERB_LAST                0xE21F
#endif //!RC_INVOKED

// for print preview dialog bar
#define AFX_ID_PREVIEW_CLOSE            0xE300
#define AFX_ID_PREVIEW_NUMPAGE          0xE301      // One/Two Page button
#define AFX_ID_PREVIEW_NEXT             0xE302
#define AFX_ID_PREVIEW_PREV             0xE303
#define AFX_ID_PREVIEW_PRINT            0xE304
#define AFX_ID_PREVIEW_ZOOMIN           0xE305
#define AFX_ID_PREVIEW_ZOOMOUT          0xE306

// View commands (same number used as IDW used for control bar)
#define ID_VIEW_TOOLBAR                 0xE800
#define ID_VIEW_STATUS_BAR              0xE801
	// -> E8FF reserved for other control bar commands

// RecordForm commands
#define ID_RECORD_FIRST                 0xE900
#define ID_RECORD_LAST                  0xE901
#define ID_RECORD_NEXT                  0xE902
#define ID_RECORD_PREV                  0xE903

/////////////////////////////////////////////////////////////////////////////
// Standard control IDs

#ifdef IDC_STATIC
#undef IDC_STATIC
#endif
#define IDC_STATIC              (-1)     // all static controls

/////////////////////////////////////////////////////////////////////////////
// Standard string error/warnings

#ifndef RC_INVOKED      // code only
#define AFX_IDS_SCFIRST                 0xEF00
#endif //!RC_INVOKED

#define AFX_IDS_SCSIZE                  0xEF00
#define AFX_IDS_SCMOVE                  0xEF01
#define AFX_IDS_SCMINIMIZE              0xEF02
#define AFX_IDS_SCMAXIMIZE              0xEF03
#define AFX_IDS_SCNEXTWINDOW            0xEF04
#define AFX_IDS_SCPREVWINDOW            0xEF05
#define AFX_IDS_SCCLOSE                 0xEF06
#define AFX_IDS_SCRESTORE               0xEF12
#define AFX_IDS_SCTASKLIST              0xEF13

#define AFX_IDS_MDICHILD                0xEF1F

#define AFX_IDS_DESKACCESSORY           0xEFDA

// General strings
#define AFX_IDS_OPENFILE                0xF000
#define AFX_IDS_SAVEFILE                0xF001
#define AFX_IDS_ALLFILTER               0xF002
#define AFX_IDS_UNTITLED                0xF003
#define AFX_IDS_SAVEFILECOPY            0xF004
#define AFX_IDS_PREVIEW_CLOSE           0xF005
#define AFX_IDS_UNNAMED_FILE            0xF006
#ifdef _MAC
#define AFX_IDS_ABOUT                   0xF010
#endif
#define AFX_IDS_HIDE                    0xF011

// MFC Standard Exception Error messages
#define AFX_IDP_NO_ERROR_AVAILABLE      0xF020
#define AFX_IDS_NOT_SUPPORTED_EXCEPTION 0xF021
#define AFX_IDS_RESOURCE_EXCEPTION      0xF022
#define AFX_IDS_MEMORY_EXCEPTION        0xF023
#define AFX_IDS_USER_EXCEPTION          0xF024

// Printing and print preview strings
#define AFX_IDS_PRINTONPORT             0xF040
#define AFX_IDS_ONEPAGE                 0xF041
#define AFX_IDS_TWOPAGE                 0xF042
#define AFX_IDS_PRINTPAGENUM            0xF043
#define AFX_IDS_PREVIEWPAGEDESC         0xF044
#define AFX_IDS_PRINTDEFAULTEXT         0xF045
#define AFX_IDS_PRINTDEFAULT            0xF046
#define AFX_IDS_PRINTFILTER             0xF047
#define AFX_IDS_PRINTCAPTION            0xF048
#define AFX_IDS_PRINTTOFILE             0xF049


// OLE strings
#define AFX_IDS_OBJECT_MENUITEM         0xF080
#define AFX_IDS_EDIT_VERB               0xF081
#define AFX_IDS_ACTIVATE_VERB           0xF082
#define AFX_IDS_CHANGE_LINK             0xF083
#define AFX_IDS_AUTO                    0xF084
#define AFX_IDS_MANUAL                  0xF085
#define AFX_IDS_FROZEN                  0xF086
#define AFX_IDS_ALL_FILES               0xF087
// dynamically changing menu items
#define AFX_IDS_SAVE_MENU               0xF088
#define AFX_IDS_UPDATE_MENU             0xF089
#define AFX_IDS_SAVE_AS_MENU            0xF08A
#define AFX_IDS_SAVE_COPY_AS_MENU       0xF08B
#define AFX_IDS_EXIT_MENU               0xF08C
#define AFX_IDS_UPDATING_ITEMS          0xF08D
// COlePasteSpecialDialog defines
#define AFX_IDS_METAFILE_FORMAT         0xF08E
#define AFX_IDS_DIB_FORMAT              0xF08F
#define AFX_IDS_BITMAP_FORMAT           0xF090
#define AFX_IDS_LINKSOURCE_FORMAT       0xF091
#define AFX_IDS_EMBED_FORMAT            0xF092
// other OLE utility strings
#define AFX_IDS_PASTELINKEDTYPE         0xF094
#define AFX_IDS_UNKNOWNTYPE             0xF095
#define AFX_IDS_RTF_FORMAT              0xF096
#define AFX_IDS_TEXT_FORMAT             0xF097
// OLE datatype format error strings
#define AFX_IDS_INVALID_CURRENCY        0xF098
#define AFX_IDS_INVALID_DATETIME        0xF099
#define AFX_IDS_INVALID_DATETIMESPAN    0xF09A

// General error / prompt strings
#define AFX_IDP_INVALID_FILENAME        0xF100
#define AFX_IDP_FAILED_TO_OPEN_DOC      0xF101
#define AFX_IDP_FAILED_TO_SAVE_DOC      0xF102
#define AFX_IDP_ASK_TO_SAVE             0xF103
#define AFX_IDP_FAILED_TO_CREATE_DOC    0xF104
#define AFX_IDP_FILE_TOO_LARGE          0xF105
#define AFX_IDP_FAILED_TO_START_PRINT   0xF106
#define AFX_IDP_FAILED_TO_LAUNCH_HELP   0xF107
#define AFX_IDP_INTERNAL_FAILURE        0xF108      // general failure
#define AFX_IDP_COMMAND_FAILURE         0xF109      // command failure
#define AFX_IDP_FAILED_MEMORY_ALLOC     0xF10A

// DDV parse errors
#define AFX_IDP_PARSE_INT               0xF110
#define AFX_IDP_PARSE_REAL              0xF111
#define AFX_IDP_PARSE_INT_RANGE         0xF112
#define AFX_IDP_PARSE_REAL_RANGE        0xF113
#define AFX_IDP_PARSE_STRING_SIZE       0xF114
#define AFX_IDP_PARSE_RADIO_BUTTON      0xF115
#define AFX_IDP_PARSE_BYTE              0xF116
#define AFX_IDP_PARSE_UINT              0xF117
#define AFX_IDP_PARSE_DATETIME          0xF118
#define AFX_IDP_PARSE_CURRENCY          0xF119

// CFile/CArchive error strings for user failure
#define AFX_IDP_FAILED_INVALID_FORMAT   0xF120
#define AFX_IDP_FAILED_INVALID_PATH     0xF121
#define AFX_IDP_FAILED_DISK_FULL        0xF122
#define AFX_IDP_FAILED_ACCESS_READ      0xF123
#define AFX_IDP_FAILED_ACCESS_WRITE     0xF124
#define AFX_IDP_FAILED_IO_ERROR_READ    0xF125
#define AFX_IDP_FAILED_IO_ERROR_WRITE   0xF126

// OLE errors / prompt strings
#define AFX_IDP_STATIC_OBJECT           0xF180
#define AFX_IDP_FAILED_TO_CONNECT       0xF181
#define AFX_IDP_SERVER_BUSY             0xF182
#define AFX_IDP_BAD_VERB                0xF183
#define AFX_IDP_FAILED_TO_NOTIFY        0xF185
#define AFX_IDP_FAILED_TO_LAUNCH        0xF186
#define AFX_IDP_ASK_TO_UPDATE           0xF187
#define AFX_IDP_FAILED_TO_UPDATE        0xF188
#define AFX_IDP_FAILED_TO_REGISTER      0xF189
#define AFX_IDP_FAILED_TO_AUTO_REGISTER 0xF18A
#define AFX_IDP_FAILED_TO_CONVERT       0xF18B
#define AFX_IDP_GET_NOT_SUPPORTED       0xF18C
#define AFX_IDP_SET_NOT_SUPPORTED       0xF18D
#define AFX_IDP_ASK_TO_DISCARD          0xF18E
#define AFX_IDP_FAILED_TO_CREATE        0xF18F

// MAPI errors / prompt strings
#define AFX_IDP_FAILED_MAPI_LOAD        0xF190
#define AFX_IDP_INVALID_MAPI_DLL        0xF191
#define AFX_IDP_FAILED_MAPI_SEND        0xF192

#define AFX_IDP_FILE_NONE               0xF1A0
#define AFX_IDP_FILE_GENERIC            0xF1A1
#define AFX_IDP_FILE_NOT_FOUND          0xF1A2
#define AFX_IDP_FILE_BAD_PATH           0xF1A3
#define AFX_IDP_FILE_TOO_MANY_OPEN      0xF1A4
#define AFX_IDP_FILE_ACCESS_DENIED      0xF1A5
#define AFX_IDP_FILE_INVALID_FILE       0xF1A6
#define AFX_IDP_FILE_REMOVE_CURRENT     0xF1A7
#define AFX_IDP_FILE_DIR_FULL           0xF1A8
#define AFX_IDP_FILE_BAD_SEEK           0xF1A9
#define AFX_IDP_FILE_HARD_IO            0xF1AA
#define AFX_IDP_FILE_SHARING            0xF1AB
#define AFX_IDP_FILE_LOCKING            0xF1AC
#define AFX_IDP_FILE_DISKFULL           0xF1AD
#define AFX_IDP_FILE_EOF                0xF1AE

#define AFX_IDP_ARCH_NONE               0xF1B0
#define AFX_IDP_ARCH_GENERIC            0xF1B1
#define AFX_IDP_ARCH_READONLY           0xF1B2
#define AFX_IDP_ARCH_ENDOFFILE          0xF1B3
#define AFX_IDP_ARCH_WRITEONLY          0xF1B4
#define AFX_IDP_ARCH_BADINDEX           0xF1B5
#define AFX_IDP_ARCH_BADCLASS           0xF1B6
#define AFX_IDP_ARCH_BADSCHEMA          0xF1B7

#define AFX_IDS_OCC_SCALEUNITS_PIXELS   0xF1C0

// 0xf200-0xf20f reserved

// font names and point sizes
#define AFX_IDS_STATUS_FONT             0xF230
#define AFX_IDS_TOOLTIP_FONT            0xF231
#define AFX_IDS_UNICODE_FONT            0xF232
#define AFX_IDS_MINI_FONT               0xF233

// ODBC Database errors / prompt strings
#ifndef RC_INVOKED      // code only
#define AFX_IDP_SQL_FIRST                       0xF280
#endif //!RC_INVOKED
#define AFX_IDP_SQL_CONNECT_FAIL                0xF281
#define AFX_IDP_SQL_RECORDSET_FORWARD_ONLY      0xF282
#define AFX_IDP_SQL_EMPTY_COLUMN_LIST           0xF283
#define AFX_IDP_SQL_FIELD_SCHEMA_MISMATCH       0xF284
#define AFX_IDP_SQL_ILLEGAL_MODE                0xF285
#define AFX_IDP_SQL_MULTIPLE_ROWS_AFFECTED      0xF286
#define AFX_IDP_SQL_NO_CURRENT_RECORD           0xF287
#define AFX_IDP_SQL_NO_ROWS_AFFECTED            0xF288
#define AFX_IDP_SQL_RECORDSET_READONLY          0xF289
#define AFX_IDP_SQL_SQL_NO_TOTAL                0xF28A
#define AFX_IDP_SQL_ODBC_LOAD_FAILED            0xF28B
#define AFX_IDP_SQL_DYNASET_NOT_SUPPORTED       0xF28C
#define AFX_IDP_SQL_SNAPSHOT_NOT_SUPPORTED      0xF28D
#define AFX_IDP_SQL_API_CONFORMANCE             0xF28E
#define AFX_IDP_SQL_SQL_CONFORMANCE             0xF28F
#define AFX_IDP_SQL_NO_DATA_FOUND               0xF290
#define AFX_IDP_SQL_ROW_UPDATE_NOT_SUPPORTED    0xF291
#define AFX_IDP_SQL_ODBC_V2_REQUIRED            0xF292
#define AFX_IDP_SQL_NO_POSITIONED_UPDATES       0xF293
#define AFX_IDP_SQL_LOCK_MODE_NOT_SUPPORTED     0xF294
#define AFX_IDP_SQL_DATA_TRUNCATED              0xF295
#define AFX_IDP_SQL_ROW_FETCH                   0xF296
#define AFX_IDP_SQL_INCORRECT_ODBC              0xF297
#define AFX_IDP_SQL_UPDATE_DELETE_FAILED        0xF298
#define AFX_IDP_SQL_DYNAMIC_CURSOR_NOT_SUPPORTED    0xF299

// DAO Database errors / prompt strings
#ifndef RC_INVOKED      // code only
#define AFX_IDP_DAO_FIRST                       0xF2A0
#endif //!RC_INVOKED
#define AFX_IDP_DAO_ENGINE_INITIALIZATION       0xF2A0
#define AFX_IDP_DAO_DFX_BIND                    0xF2A1
#define AFX_IDP_DAO_OBJECT_NOT_OPEN             0xF2A2

// ICDAORecordset::GetRows Errors
//  These are not placed in DAO Errors collection
//  and must be handled directly by MFC.
#define AFX_IDP_DAO_ROWTOOSHORT                 0xF2A3
#define AFX_IDP_DAO_BADBINDINFO                 0xF2A4
#define AFX_IDP_DAO_COLUMNUNAVAILABLE           0xF2A5

/////////////////////////////////////////////////////////////////////////////
// AFX implementation - control IDs (AFX_IDC)

// Parts of dialogs
#define AFX_IDC_LISTBOX                 100
#define AFX_IDC_CHANGE                  101

// for print dialog
#define AFX_IDC_PRINT_DOCNAME           201
#define AFX_IDC_PRINT_PRINTERNAME       202
#define AFX_IDC_PRINT_PORTNAME          203
#define AFX_IDC_PRINT_PAGENUM           204

// Property Sheet control id's (determined with Spy++)
#define ID_APPLY_NOW                    0x3021
#define ID_WIZBACK                      0x3023
#define ID_WIZNEXT                      0x3024
#define ID_WIZFINISH                    0x3025
#define AFX_IDC_TAB_CONTROL             0x3020

/////////////////////////////////////////////////////////////////////////////
// IDRs for standard components

#ifndef RC_INVOKED  // code only
// These are really COMMDLG dialogs, so there usually isn't a resource
// for them, but these IDs are used as help IDs.
#define AFX_IDD_FILEOPEN                28676
#define AFX_IDD_FILESAVE                28677
#define AFX_IDD_FONT                    28678
#define AFX_IDD_COLOR                   28679
#define AFX_IDD_PRINT                   28680
#define AFX_IDD_PRINTSETUP              28681
#define AFX_IDD_FIND                    28682
#define AFX_IDD_REPLACE                 28683
#endif //!RC_INVOKED

// Standard dialogs app should leave alone (0x7801->)
#define AFX_IDD_NEWTYPEDLG              30721
#define AFX_IDD_PRINTDLG                30722
#define AFX_IDD_PREVIEW_TOOLBAR         30723
#ifdef _MAC
#define AFX_IDD_PREVIEW_SHORTTOOLBAR    30731
#endif

// Dialogs defined for OLE2UI library
#define AFX_IDD_INSERTOBJECT            30724
#define AFX_IDD_CHANGEICON              30725
#define AFX_IDD_CONVERT                 30726
#define AFX_IDD_PASTESPECIAL            30727
#define AFX_IDD_EDITLINKS               30728
#define AFX_IDD_FILEBROWSE              30729
#define AFX_IDD_BUSY                    30730

#define AFX_IDD_OBJECTPROPERTIES        30732
#define AFX_IDD_CHANGESOURCE            30733

// Standard cursors (0x7901->)
	// AFX_IDC = Cursor resources
#define AFX_IDC_CONTEXTHELP             30977       // context sensitive help
#define AFX_IDC_MAGNIFY                 30978       // print preview zoom
#define AFX_IDC_SMALLARROWS             30979       // splitter
#define AFX_IDC_HSPLITBAR               30980       // splitter
#define AFX_IDC_VSPLITBAR               30981       // splitter
#define AFX_IDC_NODROPCRSR              30982       // No Drop Cursor
#define AFX_IDC_TRACKNWSE               30983       // tracker
#define AFX_IDC_TRACKNESW               30984       // tracker
#define AFX_IDC_TRACKNS                 30985       // tracker
#define AFX_IDC_TRACKWE                 30986       // tracker
#define AFX_IDC_TRACK4WAY               30987       // tracker
#define AFX_IDC_MOVE4WAY                30988       // resize bar (server only)

// Mini frame window bitmap ID
#define AFX_IDB_MINIFRAME_MENU          30994

// CheckListBox checks bitmap ID
#define AFX_IDB_CHECKLISTBOX_NT         30995
#define AFX_IDB_CHECKLISTBOX_95         30996

// AFX standard accelerator resources
#define AFX_IDR_PREVIEW_ACCEL           30997

// AFX standard ICON IDs (for MFC V1 apps) (0x7A01->)
#define AFX_IDI_STD_MDIFRAME            31233
#define AFX_IDI_STD_FRAME               31234

/////////////////////////////////////////////////////////////////////////////
// AFX OLE control implementation - control IDs (AFX_IDC)

// Font property page
#define AFX_IDC_FONTPROP                1000
#define AFX_IDC_FONTNAMES               1001
#define AFX_IDC_FONTSTYLES              1002
#define AFX_IDC_FONTSIZES               1003
#define AFX_IDC_STRIKEOUT               1004
#define AFX_IDC_UNDERLINE               1005
#define AFX_IDC_SAMPLEBOX               1006

// Color property page
#define AFX_IDC_COLOR_BLACK             1100
#define AFX_IDC_COLOR_WHITE             1101
#define AFX_IDC_COLOR_RED               1102
#define AFX_IDC_COLOR_GREEN             1103
#define AFX_IDC_COLOR_BLUE              1104
#define AFX_IDC_COLOR_YELLOW            1105
#define AFX_IDC_COLOR_MAGENTA           1106
#define AFX_IDC_COLOR_CYAN              1107
#define AFX_IDC_COLOR_GRAY              1108
#define AFX_IDC_COLOR_LIGHTGRAY         1109
#define AFX_IDC_COLOR_DARKRED           1110
#define AFX_IDC_COLOR_DARKGREEN         1111
#define AFX_IDC_COLOR_DARKBLUE          1112
#define AFX_IDC_COLOR_LIGHTBROWN        1113
#define AFX_IDC_COLOR_DARKMAGENTA       1114
#define AFX_IDC_COLOR_DARKCYAN          1115
#define AFX_IDC_COLORPROP               1116
#define AFX_IDC_SYSTEMCOLORS            1117

// Picture porperty page
#define AFX_IDC_PROPNAME                1201
#define AFX_IDC_PICTURE                 1202
#define AFX_IDC_BROWSE                  1203
#define AFX_IDC_CLEAR                   1204

/////////////////////////////////////////////////////////////////////////////
// IDRs for OLE control standard components

// Standard propery page dialogs app should leave alone (0x7E01->)
#define AFX_IDD_PROPPAGE_COLOR         32257
#define AFX_IDD_PROPPAGE_FONT          32258
#define AFX_IDD_PROPPAGE_PICTURE       32259

#define AFX_IDB_TRUETYPE               32384

/////////////////////////////////////////////////////////////////////////////
// Standard OLE control strings

// OLE Control page strings
#define AFX_IDS_PROPPAGE_UNKNOWN        0xFE01
#define AFX_IDS_COLOR_DESKTOP           0xFE04
#define AFX_IDS_COLOR_APPWORKSPACE      0xFE05
#define AFX_IDS_COLOR_WNDBACKGND        0xFE06
#define AFX_IDS_COLOR_WNDTEXT           0xFE07
#define AFX_IDS_COLOR_MENUBAR           0xFE08
#define AFX_IDS_COLOR_MENUTEXT          0xFE09
#define AFX_IDS_COLOR_ACTIVEBAR         0xFE0A
#define AFX_IDS_COLOR_INACTIVEBAR       0xFE0B
#define AFX_IDS_COLOR_ACTIVETEXT        0xFE0C
#define AFX_IDS_COLOR_INACTIVETEXT      0xFE0D
#define AFX_IDS_COLOR_ACTIVEBORDER      0xFE0E
#define AFX_IDS_COLOR_INACTIVEBORDER    0xFE0F
#define AFX_IDS_COLOR_WNDFRAME          0xFE10
#define AFX_IDS_COLOR_SCROLLBARS        0xFE11
#define AFX_IDS_COLOR_BTNFACE           0xFE12
#define AFX_IDS_COLOR_BTNSHADOW         0xFE13
#define AFX_IDS_COLOR_BTNTEXT           0xFE14
#define AFX_IDS_COLOR_BTNHIGHLIGHT      0xFE15
#define AFX_IDS_COLOR_DISABLEDTEXT      0xFE16
#define AFX_IDS_COLOR_HIGHLIGHT         0xFE17
#define AFX_IDS_COLOR_HIGHLIGHTTEXT     0xFE18
#define AFX_IDS_REGULAR                 0xFE19
#define AFX_IDS_BOLD                    0xFE1A
#define AFX_IDS_ITALIC                  0xFE1B
#define AFX_IDS_BOLDITALIC              0xFE1C
#define AFX_IDS_SAMPLETEXT              0xFE1D
#define AFX_IDS_DISPLAYSTRING_FONT      0xFE1E
#define AFX_IDS_DISPLAYSTRING_COLOR     0xFE1F
#define AFX_IDS_DISPLAYSTRING_PICTURE   0xFE20
#define AFX_IDS_PICTUREFILTER           0xFE21
#define AFX_IDS_PICTYPE_UNKNOWN         0xFE22
#define AFX_IDS_PICTYPE_NONE            0xFE23
#define AFX_IDS_PICTYPE_BITMAP          0xFE24
#define AFX_IDS_PICTYPE_METAFILE        0xFE25
#define AFX_IDS_PICTYPE_ICON            0xFE26
#define AFX_IDS_COLOR_PPG               0xFE28
#define AFX_IDS_COLOR_PPG_CAPTION       0xFE29
#define AFX_IDS_FONT_PPG                0xFE2A
#define AFX_IDS_FONT_PPG_CAPTION        0xFE2B
#define AFX_IDS_PICTURE_PPG             0xFE2C
#define AFX_IDS_PICTURE_PPG_CAPTION     0xFE2D
#define AFX_IDS_PICTUREBROWSETITLE      0xFE30
#define AFX_IDS_BORDERSTYLE_0           0xFE31
#define AFX_IDS_BORDERSTYLE_1           0xFE32

// OLE Control verb names
#define AFX_IDS_VERB_EDIT               0xFE40
#define AFX_IDS_VERB_PROPERTIES         0xFE41

// OLE Control internal error messages
#define AFX_IDP_PICTURECANTOPEN         0xFE83
#define AFX_IDP_PICTURECANTLOAD         0xFE84
#define AFX_IDP_PICTURETOOLARGE         0xFE85
#define AFX_IDP_PICTUREREADFAILED       0xFE86

// Standard OLE Control error strings
#define AFX_IDP_E_ILLEGALFUNCTIONCALL       0xFEA0
#define AFX_IDP_E_OVERFLOW                  0xFEA1
#define AFX_IDP_E_OUTOFMEMORY               0xFEA2
#define AFX_IDP_E_DIVISIONBYZERO            0xFEA3
#define AFX_IDP_E_OUTOFSTRINGSPACE          0xFEA4
#define AFX_IDP_E_OUTOFSTACKSPACE           0xFEA5
#define AFX_IDP_E_BADFILENAMEORNUMBER       0xFEA6
#define AFX_IDP_E_FILENOTFOUND              0xFEA7
#define AFX_IDP_E_BADFILEMODE               0xFEA8
#define AFX_IDP_E_FILEALREADYOPEN           0xFEA9
#define AFX_IDP_E_DEVICEIOERROR             0xFEAA
#define AFX_IDP_E_FILEALREADYEXISTS         0xFEAB
#define AFX_IDP_E_BADRECORDLENGTH           0xFEAC
#define AFX_IDP_E_DISKFULL                  0xFEAD
#define AFX_IDP_E_BADRECORDNUMBER           0xFEAE
#define AFX_IDP_E_BADFILENAME               0xFEAF
#define AFX_IDP_E_TOOMANYFILES              0xFEB0
#define AFX_IDP_E_DEVICEUNAVAILABLE         0xFEB1
#define AFX_IDP_E_PERMISSIONDENIED          0xFEB2
#define AFX_IDP_E_DISKNOTREADY              0xFEB3
#define AFX_IDP_E_PATHFILEACCESSERROR       0xFEB4
#define AFX_IDP_E_PATHNOTFOUND              0xFEB5
#define AFX_IDP_E_INVALIDPATTERNSTRING      0xFEB6
#define AFX_IDP_E_INVALIDUSEOFNULL          0xFEB7
#define AFX_IDP_E_INVALIDFILEFORMAT         0xFEB8
#define AFX_IDP_E_INVALIDPROPERTYVALUE      0xFEB9
#define AFX_IDP_E_INVALIDPROPERTYARRAYINDEX 0xFEBA
#define AFX_IDP_E_SETNOTSUPPORTEDATRUNTIME  0xFEBB
#define AFX_IDP_E_SETNOTSUPPORTED           0xFEBC
#define AFX_IDP_E_NEEDPROPERTYARRAYINDEX    0xFEBD
#define AFX_IDP_E_SETNOTPERMITTED           0xFEBE
#define AFX_IDP_E_GETNOTSUPPORTEDATRUNTIME  0xFEBF
#define AFX_IDP_E_GETNOTSUPPORTED           0xFEC0
#define AFX_IDP_E_PROPERTYNOTFOUND          0xFEC1
#define AFX_IDP_E_INVALIDCLIPBOARDFORMAT    0xFEC2
#define AFX_IDP_E_INVALIDPICTURE            0xFEC3
#define AFX_IDP_E_PRINTERERROR              0xFEC4
#define AFX_IDP_E_CANTSAVEFILETOTEMP        0xFEC5
#define AFX_IDP_E_SEARCHTEXTNOTFOUND        0xFEC6
#define AFX_IDP_E_REPLACEMENTSTOOLONG       0xFEC7

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#endif //__AFXRES_H__

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\urlmon\wcheckcb\factory.cxx ===
#include "..\\inc\\urlint.h"
#include "..\\inc\\wcheckcb.h"
#include "..\\inc\\debug.h"

// createion method
STDMETHODIMP CreateCallbackClassFactory(IClassFactory** ppCF)
{
    *ppCF = (IClassFactory*)new CCallbackObjFactory;
    
    if (*ppCF == NULL)
        return E_OUTOFMEMORY;

    return S_OK;
}

// constructor
CCallbackObjFactory::CCallbackObjFactory()
{
    DllAddRef();
    m_cRef = 1;
    m_cLocks = 0;
}

// destructor
CCallbackObjFactory::~CCallbackObjFactory()
{
    Assert(m_cRef == 0 && m_cLocks == 0);
    DllRelease();
}


/******************************************************************************
    IUnknown methods
******************************************************************************/

STDMETHODIMP CCallbackObjFactory::QueryInterface(REFIID iid, void** ppvObject)
{
    *ppvObject = NULL;

    if (iid == IID_IUnknown || iid == IID_IClassFactory)
    {
        *ppvObject = (void*)this;
        ((LPUNKNOWN)*ppvObject)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CCallbackObjFactory::AddRef(void)
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG) CCallbackObjFactory::Release(void)
{
    if (--m_cRef)
        return m_cRef;

    delete this;
    return 0;
}


/******************************************************************************
    IClassFactory methods
******************************************************************************/

STDMETHODIMP CCallbackObjFactory::CreateInstance(
                                          LPUNKNOWN pUnkOuter, 
                                          REFIID riid, 
                                          LPVOID* ppv)
{
    *ppv = NULL;
    HRESULT hr = S_OK;

    if (pUnkOuter != NULL)
        return CLASS_E_NOAGGREGATION;

    CControlRefreshCallback *pCRC = new CControlRefreshCallback;
    if (pCRC == NULL)
        return E_OUTOFMEMORY;

    hr = pCRC->QueryInterface(riid, ppv);
    pCRC->Release();

    return hr;
}

STDMETHODIMP CCallbackObjFactory::LockServer(BOOL fLock)
{
    if (fLock)
        DllAddRef();
    else
        DllRelease();

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\urlmon\zones\regzone.cxx ===
//  File:       regzone.cxx
//
//  Contents:   Registry management for a single zone. 
//
//  Classes:    CRegZone
//
//  Functions:
//
//  History: 
//
//----------------------------------------------------------------------------

#include "zonepch.h"

// Max # of chars to the root of the zones tree (SZZONES, SZTEMPLATE,...)

#define MAX_REGZONE_ROOT        100

// Value names in the registry
#define SZZONEINDEX             __TEXT("ZoneIndex")
#define SZTEMPLATEINDEX         __TEXT("TemplateIndex")
#define SZDISPLAYNAME           __TEXT("DisplayName")
#define SZICON                  __TEXT("Icon")
#define SZDESCRIPTION           __TEXT("Description")
#define SZFLAGS                 __TEXT("Flags")

// Registry key names for the template policies


#define SZLOW                   __TEXT("Low")
#define SZMEDLOW                __TEXT("MedLow")
#define SZMEDIUM                __TEXT("Medium")
#define SZHIGH                  __TEXT("High")


CRegZone::CRegZoneCache CRegZone::s_rzcache;
HANDLE CRegZone::CRegZoneCache::s_hMutexCounter;

// Array of Value Names corresponding to zone attributes.
// These values will not be copied when doing a mass copy 
// from a template zone (HIGH, MED, LOW) to a zone. 
static LPCTSTR rgszAttributeNames [ ] = 
{
    __TEXT(""),            // The default value is excluded as well. 
    SZZONEINDEX,
    SZTEMPLATEINDEX,
    SZDISPLAYNAME,
    SZDESCRIPTION,
    SZICON,
    SZFLAGS,
    SZMINLEVEL,
    SZRECLEVEL,
    SZCURRLEVEL,
};

struct templateNameIdxMap
{
    URLTEMPLATE index;
    LPCTSTR    pszName;
};

static templateNameIdxMap 
TemplateNameIdxMap [ ] = 
{    
    { URLTEMPLATE_LOW,          SZLOW },
    { URLTEMPLATE_MEDLOW,       SZMEDLOW},
    { URLTEMPLATE_MEDIUM,       SZMEDIUM},
    { URLTEMPLATE_HIGH,         SZHIGH}
};     
     
 


// CRegZone implementation.

CRegZone::CRegZone()
{
    // defaults
    m_dwZoneId  =  ZONEID_INVALID;
    m_dwZoneFlags = ZAFLAGS_ADD_SITES;  // BUGBUG: what is the right default here. 
    m_lpZoneName = NULL;
    m_lpZonePath = NULL;

    m_bStandard = TRUE;    
    m_bZoneLockOut = FALSE;
    m_bHKLMOnly = TRUE;
}     

CRegZone::~CRegZone()
{
    LocalFree((HLOCAL)m_lpZoneName);    
    LocalFree((HLOCAL)m_lpZonePath);
}

// Sets up the CRegZone object a given string. 
// If the setting is in the Zones key the string passed in is the actual
// zone index. Otherwise it is one of the "High", "Medium", "Low" strings which indicates
// a template policy. 

BOOL CRegZone::Init(LPCWSTR lpwStr, BOOL bUseHKLMOnly, REGZONEUSE regZoneUse, BOOL bCreate /*=TRUE*/)
{
    TransAssert(lpwStr != NULL);
    if (lpwStr == NULL)
    {
        return FALSE;
    }

    m_bHKLMOnly = bUseHKLMOnly;
    m_regZoneUse = regZoneUse;

    TCHAR szTemp[MAX_REGZONE_ROOT + MAX_ZONE_NAME];

    StrCpyW(szTemp, (regZoneUse == REGZONEUSEZONES? SZZONES : SZTEMPLATE));
    StrCatW(szTemp, lpwStr);

    m_lpZonePath = StrDup(szTemp);
    if(!m_lpZonePath)
    {
        return FALSE;
    }
    m_lpZoneName = StrDup(lpwStr);
    if(!m_lpZoneName)
    {
        return FALSE;
    }

    CRegKey regKey(bUseHKLMOnly);

    if (regKey.Open(NULL, m_lpZonePath, KEY_READ) != ERROR_SUCCESS) 
    {
        // BUGBUG:: We have to be able to deal with this. situation and not just bail.
        // Possibilities: Setup defaults here if we can create and write to the key
        return FALSE;
    }


    // Add code here to 
    DWORD dwZoneId = ZONEID_INVALID;

    // Get the Zone Index.
    if ( regZoneUse == REGZONEUSEZONES )
    {
        // The Zone Id for the string is the same as the key name.
        // Just convert the string 
        m_dwZoneId = StrToInt(m_lpZoneName);
    }
    else if (regZoneUse == REGZONEUSETEMPLATE )
    {
        if (regKey.QueryValue(&dwZoneId, SZTEMPLATEINDEX) == ERROR_SUCCESS)
            m_dwZoneId = dwZoneId;
        else
        {
            // Could happen if the registry is messed up. 
            TransAssert(FALSE);
        }
    }
    else 
    {
        TransAssert(FALSE);
    }       

    // Get the zone flags
    if (regKey.QueryValue(&m_dwZoneFlags, SZFLAGS) != ERROR_SUCCESS)
    {
        m_dwZoneFlags = ZAFLAGS_ADD_SITES;      // What is the right value here.
    }            
    else
    {
        // return value from UpdateZoneMapFlags ignored.  
        UpdateZoneMapFlags( );
    }                
    // Check and make sure the zone Id's are within range.             
    // Assert that the zone ID's are in the appropriate user or standard range.
                    
    return TRUE;
}

// This updates the flags in the ZoneMap part of the registry which correspond to the 
// ZAFLAGS_. For convenience the UI will only update the ZAFLAGS.


BOOL CRegZone::UpdateZoneMapFlags( )
{
    // ProxyByPass is current controlled by the ProxyByPass flag, not the zoneAttrib.
    if (m_dwZoneId == URLZONE_INTRANET)
    {
        // If we are updating zonemap flags we have to invalidate any url to zone caches
        CSecurityManager::IncrementGlobalCounter( );
                
        CRegKey regZoneMap;
        if (ERROR_SUCCESS == regZoneMap.Open(NULL, SZZONEMAP, KEY_READ | KEY_WRITE))
        {
            if (m_dwZoneFlags & ZAFLAGS_INCLUDE_PROXY_OVERRIDE)
            {
                // We will succeed even if this fails.
                regZoneMap.SetValue(m_dwZoneId, SZPROXYBYPASS);
            }
            else 
            {
                regZoneMap.DeleteValue(SZPROXYBYPASS);
            }

            if (m_dwZoneFlags & ZAFLAGS_INCLUDE_INTRANET_SITES)
            {
                // We will succeed even if this fails.
                regZoneMap.SetValue(m_dwZoneId, SZINTRANETNAME);
            }
            else 
            {
                regZoneMap.DeleteValue(SZINTRANETNAME);
            }

            DWORD dwUncAsIntranet = (m_dwZoneFlags & ZAFLAGS_UNC_AS_INTRANET) ? 1 : 0 ;
            regZoneMap.SetValue(dwUncAsIntranet, SZUNCASINTRANET);

        }
    }
    return TRUE;
}

// Static functions.

VOID
CRegZone::IncrementGlobalCounter( )
{
    CRegZone::CRegZoneCache::IncrementGlobalCounter( );
}

BOOL CRegZone::IsAttributeName(LPCTSTR psz)
{
    DWORD dwMaxIndex = sizeof(rgszAttributeNames)/sizeof(rgszAttributeNames[0]);

    for ( DWORD dwIndex = 0 ; dwIndex < dwMaxIndex ; dwIndex++ )
    {
#ifndef UNIX
        if (0 == StrCmpW(psz, rgszAttributeNames[dwIndex]))
#else
        if (0 == lstrcmpi(psz, rgszAttributeNames[dwIndex]))
#endif
            return TRUE;
    }

    return FALSE;
}


LPCTSTR CRegZone::GetTemplateNameFromIndex(URLTEMPLATE urlTemplateIndex)
{
    DWORD dwMaxIndex = sizeof(TemplateNameIdxMap) / sizeof(TemplateNameIdxMap[0]);

    for (DWORD dwIndex = 0 ; dwIndex < dwMaxIndex ; dwIndex++ )
    {
        if (TemplateNameIdxMap[dwIndex].index == urlTemplateIndex)
            return TemplateNameIdxMap[dwIndex].pszName;
    }
    
    return NULL;
}
             
// These are static functions to deal with aggregate policies. 

// Because of the discrepancy between the UI and the actions defined,
// there are cases where the security manager munges the policies for certain actions.

inline void CRegZone::KludgeMapAggregatePolicy(DWORD dwAction, LPDWORD pdwPolicy)
{
    TransAssert(pdwPolicy != NULL);

    switch (dwAction)
    {
        case URLACTION_ACTIVEX_OVERRIDE_DATA_SAFETY:
        case URLACTION_ACTIVEX_OVERRIDE_SCRIPT_SAFETY:
        case URLACTION_SCRIPT_OVERRIDE_SAFETY:
        {
            if (GetUrlPolicyPermissions(*pdwPolicy) == URLPOLICY_QUERY)
                SetUrlPolicyPermissions(*pdwPolicy, URLPOLICY_DISALLOW);
            break;
        }
    }
}
             

// Call this function to determine if an action is aggregated by some
// other action. 
// RETURNS : TRUE if there is an aggregate action corr to dwAction. 
//           also returns the action in pdwAggregate.
//           FALSE: if this action is not aggregated by some other action.
//           pdwAggregate is unchanged in this case.

inline BOOL CRegZone::GetAggregateAction(DWORD dwAction, LPDWORD pdwAggregate)
{
    DWORD dwAggregate = 0;
    BOOL bReturn = FALSE;
       
    TransAssert(dwAction >= URLACTION_MIN);
    
    switch(dwAction)
    {
        case URLACTION_ACTIVEX_OVERRIDE_DATA_SAFETY:
        case URLACTION_ACTIVEX_OVERRIDE_SCRIPT_SAFETY:
        case URLACTION_ACTIVEX_CONFIRM_NOOBJECTSAFETY:
        case URLACTION_SCRIPT_OVERRIDE_SAFETY:
            bReturn = TRUE;
            dwAggregate = URLACTION_ACTIVEX_OVERRIDE_OBJECT_SAFETY;
            break;
        case URLACTION_HTML_SUBMIT_FORMS_FROM:
        case URLACTION_HTML_SUBMIT_FORMS_TO:
            bReturn = TRUE;
            dwAggregate = URLACTION_HTML_SUBMIT_FORMS;
            break;
    }

    if (bReturn && pdwAggregate)
        *pdwAggregate = dwAggregate;

    return bReturn;
}


// Functions corresponding to IInternetZoneManager functionality. 
STDMETHODIMP CRegZone::GetZoneAttributes(ZONEATTRIBUTES& zoneAttrib)
{
    if (!IsValid())
    {
        return E_FAIL;
    }

    CRegKey regKey(m_bHKLMOnly);

    if (regKey.Open(NULL, m_lpZonePath, KEY_READ) != ERROR_SUCCESS) 
    {
        // BUGBUG:: We have to be able to deal with this. situation and not just bail.
        // Possibilities: Setup defaults here if we can create and write to the key
        return E_FAIL;
    }

    // Since this is the first rev, we should have enough memory 
    // to fill in the ZONEATTRIBUTES structure. If we need to extend
    // the structure this code will have to be modified.
    TransAssert(zoneAttrib.cbSize >= sizeof(ZONEATTRIBUTES));

    // Amount of information we will copy.
    zoneAttrib.cbSize = sizeof(ZONEATTRIBUTES);

    TransAssert(regKey!= NULL);

    DWORD dwCount;
    LONG lRet;

    // BUGBUG deal with values exceeding size limit. 
    // We would have to allocate memory ourself and 
    // truncate the resulting string down.   

    // Read DisplayName.
    dwCount = sizeof(zoneAttrib.szDisplayName);
    lRet = regKey.QueryValue(zoneAttrib.szDisplayName, SZDISPLAYNAME, &dwCount);   
    TransAssert(ERROR_MORE_DATA != lRet);

    if (NO_ERROR != lRet)
        zoneAttrib.szDisplayName[0] = __TEXT('\0');    

    // Read Description
    dwCount = sizeof(zoneAttrib.szDescription);
    regKey.QueryValue(zoneAttrib.szDescription, SZDESCRIPTION, &dwCount);
    TransAssert(ERROR_MORE_DATA != lRet);

    if (NO_ERROR != lRet)
        zoneAttrib.szDescription[0] = __TEXT('\0');
    
    // Read Icon. 
    dwCount = sizeof(zoneAttrib.szIconPath);
    regKey.QueryValue(zoneAttrib.szIconPath, SZICON, &dwCount);
    TransAssert(ERROR_MORE_DATA != lRet);

    if (NO_ERROR != lRet)
        zoneAttrib.szIconPath[0] = __TEXT('\0');

    // Read Current, Recommended and Min Settings. 
    QueryTemplatePolicyIndex(regKey, SZMINLEVEL, &zoneAttrib.dwTemplateMinLevel);
    QueryTemplatePolicyIndex(regKey, SZRECLEVEL, &zoneAttrib.dwTemplateRecommended);
    QueryTemplatePolicyIndex(regKey, SZCURRLEVEL, &zoneAttrib.dwTemplateCurrentLevel);

    // Re-read the flags in case someone else updated it in an independent process. 
    DWORD dwZoneFlags;
    if (regKey.QueryValue(&dwZoneFlags, SZFLAGS) == ERROR_SUCCESS)
    {
        m_dwZoneFlags = dwZoneFlags;
        UpdateZoneMapFlags();
    }

    zoneAttrib.dwFlags = m_dwZoneFlags;

    return S_OK;
}     
      
STDMETHODIMP CRegZone::SetZoneAttributes(const ZONEATTRIBUTES& zoneAttrib)
{
    if (!IsValid())
    {
        return E_FAIL;
    }

    // Check if the attributes we are trying to set are valid.

    if (!IsValidTemplateIndex(zoneAttrib.dwTemplateMinLevel) ||
        !IsValidTemplateIndex(zoneAttrib.dwTemplateCurrentLevel) ||
        !IsValidTemplateIndex(zoneAttrib.dwTemplateRecommended))
    {
        return E_INVALIDARG;
    }

    CRegKey regKey(m_bHKLMOnly);

    if (regKey.Open(NULL, m_lpZonePath, KEY_WRITE | KEY_READ) != ERROR_SUCCESS) 
    {
        // BUGBUG:: We have to be able to deal with this. situation and not just bail.
        // Possibilities: Setup defaults here if we can create and write to the key
        return E_FAIL;
    }

    
    // Write the descriptive strings. 
    // These should almost never be changed by this call.   
    if (zoneAttrib.szDisplayName[0] != TEXT('\0'))
        regKey.SetValue(zoneAttrib.szDisplayName, SZDISPLAYNAME);   

    if (zoneAttrib.szDescription[0] != TEXT('\0'))
        regKey.SetValue(zoneAttrib.szDescription, SZDESCRIPTION);

    if (zoneAttrib.szIconPath[0] != TEXT('\0'))
        regKey.SetValue(zoneAttrib.szIconPath, SZICON);

    // Write the Template Indicies. 
    SetTemplatePolicyIndex(regKey, SZMINLEVEL, zoneAttrib.dwTemplateMinLevel);
    SetTemplatePolicyIndex(regKey, SZRECLEVEL, zoneAttrib.dwTemplateRecommended);

    DWORD dwTemplateCurrentLevel;

    // When the caller is setting the "CurrentLevel" to "Custom" it is assumed
    // that the caller has already changed the underlying policies. 
    if (zoneAttrib.dwTemplateCurrentLevel == URLTEMPLATE_CUSTOM)
    {
        SetTemplatePolicyIndex(regKey, SZCURRLEVEL, zoneAttrib.dwTemplateCurrentLevel);
    }
    else 
    {
        CopyTemplatePolicies(zoneAttrib.dwTemplateCurrentLevel);
    }


    // Finally write the flags value.
    regKey.SetValue(zoneAttrib.dwFlags, SZFLAGS);
    m_dwZoneFlags = zoneAttrib.dwFlags;
    UpdateZoneMapFlags();

    IncrementGlobalCounter();   // increment the count to invalidate the zone policy cache
    
    return S_OK;
}


STDMETHODIMP CRegZone::GetActionPolicy(DWORD dwAction, URLZONEREG urlZoneReg, DWORD& dwPolicy) const 
{
    if (!IsValid())
        return E_FAIL;

    DWORD dwActionUse;

    // If the action is aggregated by some other action, then we should 
    // actually check the policy for the aggregate action. If the function 
    if (!GetAggregateAction(dwAction, &dwActionUse))
        dwActionUse = dwAction;

    // If it is a hard-coded zone get the policy from internal tables.
    // Don't look up the registry for these.
    if (IsHardCodedZone() && GetHardCodedZonePolicy(dwActionUse, dwPolicy))
    {
        // dwPolicy should have the policy now.
    }
    else
    {
        if(!s_rzcache.Lookup(m_dwZoneId, m_lpZonePath, dwActionUse, UseHKLM(urlZoneReg), &dwPolicy))
        {
            return E_FAIL;
        }

        // For some special aggregate policies we have to modify the policy value.
        KludgeMapAggregatePolicy(dwAction, &dwPolicy);
    }

    return S_OK;
}                                     

STDMETHODIMP CRegZone::SetActionPolicy(DWORD dwAction, URLZONEREG urlZoneReg, DWORD dwPolicy)
{
    if (!IsValid())
        return E_FAIL;

    CRegKey regKey(UseHKLM(urlZoneReg));

    if (regKey.Open(NULL, m_lpZonePath, KEY_WRITE) != ERROR_SUCCESS) 
    {
        // BUGBUG:: We have to be able to deal with this. situation and not just bail.
        // Possibilities: Setup defaults here if we can create and write to the key
        return E_FAIL;
    }

    // Policies cannot be set on Actions that are aggregate's.
    // They can be only be set on the aggregator policy.

    if (IsHardCodedZone())
    {
        TransAssert(FALSE);
        return E_FAIL;
    }
            
    DWORD dwActionUse;

    // If the action is aggregated by some other action, then we should 
    // actually use the policy for the aggregate action. 
    if (!GetAggregateAction(dwAction, &dwActionUse))
        dwActionUse = dwAction;

    // Convert the Action to a string. 
#ifndef unix
    TCHAR wsz[9];  // FFFFFFFF\0
#else
    TCHAR wsz[(sizeof(DWORD)+1)*sizeof(WCHAR)];
#endif /* unix */
    if (!DwToWchar(dwActionUse, wsz, 16))
    {
        TransAssert(FALSE);
        return E_UNEXPECTED;
    }

    regKey.SetValue(dwPolicy, wsz);

    s_rzcache.Add(m_dwZoneId, dwActionUse, UseHKLM(urlZoneReg), dwPolicy, URLZONE_FINDCACHEENTRY);

    return S_OK;
}    

STDMETHODIMP  CRegZone::GetCustomPolicy (REFGUID guid, URLZONEREG urlZoneReg, BYTE** ppByte, DWORD *pcb) const 
{
    if (!IsValid())
        return E_FAIL;


    CRegKey regKey(UseHKLM(urlZoneReg));

    if (regKey.Open(NULL, m_lpZonePath, KEY_READ) != ERROR_SUCCESS) 
    {
        // BUGBUG:: We have to be able to deal with this. situation and not just bail.
        // Possibilities: Setup defaults here if we can create and write to the key
        return E_FAIL;
    }

    // Convert the Action to a string. 
    TCHAR sz[40];  // {8CC49940-3146-11CF-97A1-00AA00424A9F}\0

    SHStringFromGUID(guid, sz, sizeof(sz));

    *pcb = 0;
    // First figure out the amount of memory required.
    if (regKey.QueryBinaryValue(NULL, sz, pcb) != ERROR_SUCCESS)
    {
        return HRESULT_FROM_WIN32(ERROR_NOT_FOUND);
    }

    // Memory will be freed by caller.
    *ppByte = (BYTE *)CoTaskMemAlloc(*pcb);

    if ( *ppByte == NULL)
    {
        return E_OUTOFMEMORY;
    }

    // Actually query the registry for the value.
    if (regKey.QueryBinaryValue(*ppByte, sz, pcb) != ERROR_SUCCESS)
    {
        return HRESULT_FROM_WIN32(ERROR_NOT_FOUND);
    }

    return S_OK;
}

STDMETHODIMP  CRegZone::SetCustomPolicy (REFGUID guid, URLZONEREG urlZoneReg, BYTE* pByte, DWORD cb)
{
    if (!IsValid())
        return E_FAIL;

    CRegKey regKey(UseHKLM(urlZoneReg));

    if (regKey.Open(NULL, m_lpZonePath, KEY_WRITE) != ERROR_SUCCESS) 
    {
        // BUGBUG:: We have to be able to deal with this. situation and not just bail.
        // Possibilities: Setup defaults here if we can create and write to the key
        return E_FAIL;
    }

    // Convert the Action to a string. 
    TCHAR sz[40];  // {8CC49940-3146-11CF-97A1-00AA00424A9F}\0

    SHStringFromGUID(guid, sz, sizeof(sz));

    DWORD dwError = ERROR_SUCCESS;
    if ((dwError = regKey.SetBinaryValue(pByte, sz, cb)) != ERROR_SUCCESS)
    {
        return HRESULT_FROM_WIN32(dwError);
    }

    return S_OK;
}


STDMETHODIMP CRegZone::CopyTemplatePolicies(DWORD dwTemplate)
// Copy the policies from a predefined template into the current zone
{
    HRESULT hr = E_FAIL;

    // First check if we can get a name back for the template.
    LPCTSTR szTemplateName = GetTemplateNameFromIndex((URLTEMPLATE)dwTemplate);

    if (NULL == szTemplateName )
        return E_INVALIDARG;

    // Create a CRegZone for the template.
    CRegZone regTemplate;


    if (regTemplate.Init(szTemplateName, TRUE /* templates are stored in HKLM only */, REGZONEUSETEMPLATE))
    {
        CRegKey regZoneKey(m_bHKLMOnly);
        CRegKey regTemplateKey(TRUE);

        if ((NO_ERROR == regTemplateKey.Open(NULL, regTemplate.m_lpZonePath, KEY_READ)) &&
            (NO_ERROR == regZoneKey.Open(NULL, m_lpZonePath, KEY_WRITE)))
        {
            TCHAR szValueName[MAX_VALUE_NAME];
            DWORD dwNameLen = sizeof(szValueName)/sizeof(TCHAR);
            DWORD dwBufLen = 2048;
            DWORD dwActualLen = 2048;
            BYTE * buffer = new BYTE[dwBufLen];
            DWORD dwEnumIndex = 0;
            DWORD dwType;
            LONG lRet;

            while ((lRet = regTemplateKey.EnumValue (dwEnumIndex, szValueName, &dwNameLen, &dwType, buffer, &dwActualLen))
                      != ERROR_NO_MORE_ITEMS)
            {
                // Need more memory, allocate and re-try.
                if (lRet == ERROR_MORE_DATA && dwActualLen > dwBufLen)
                {
                    dwBufLen = dwActualLen;
                    delete [] buffer;
                    buffer = new BYTE[dwBufLen];

                    dwNameLen = sizeof(szValueName)/sizeof(TCHAR);
                                    
                    // Try with the bigger buffer.
                    lRet = regTemplateKey.EnumValue(dwEnumIndex, szValueName, &dwNameLen, &dwType, buffer, &dwActualLen);
                }                                            
                    
                // dwActualLen contains the actual size of the data to be written. 
                if (lRet == NO_ERROR && !IsAttributeName(szValueName))
                {
                    // Copy the value over.
                    regZoneKey.SetValueOfType(buffer, szValueName, dwActualLen, dwType);
                }

                dwEnumIndex++;
                dwActualLen = dwBufLen;
                dwNameLen = sizeof(szValueName)/sizeof(TCHAR);
            }
            
            // Set the "CurrentLevel" value to the Template Index.
            if (regZoneKey.SetValue(dwTemplate, SZCURRLEVEL) == NO_ERROR)
                hr = S_OK;

            delete [] buffer;
        }
    }

    return hr;
}
                    
                         
// CRegZoneContainer methods.


CRegZoneContainer::CRegZoneContainer()
{
    m_ppRegZones = NULL;
    m_cZones = 0;
    m_bHKLMOnly = FALSE;

    m_pZoneEnumList = NULL;
    m_dwNextEnum = 0;
    InitializeCriticalSection(&m_csect);
}

CRegZoneContainer::~CRegZoneContainer()
{
    Detach();
    DeleteCriticalSection(&m_csect);
};

// This functions goes through the registry and creates the CRegZone objects corresponding 
// to the zones currently in the registry.


BOOL CRegZoneContainer::Attach(BOOL bUseHKLM, REGZONEUSE regZoneUse /* = REGZONEUSEZONES */)                                        
{
    // If this assert fires you probably forgot to call Detach.
    TransAssert(m_cZones == 0);
    TransAssert(m_ppRegZones == NULL);
    // recover if we are messed up.
    Detach();

    m_bHKLMOnly = bUseHKLM ;


    TCHAR sz[MAX_REGZONE_ROOT];
    StrCpyW(sz, (regZoneUse == REGZONEUSEZONES ? SZZONES : SZTEMPLATE )); 

    // Make sure we have the minimal set of zones required and we self-heal if there is a problem.
    // even if self-heal fails we ignore the error code and try to initialize the zones anyway.
    if (regZoneUse == REGZONEUSEZONES )
        SelfHeal(bUseHKLM);


    CRegKey regKey(m_bHKLMOnly);
    
    if (regKey.Open(NULL, sz, KEY_READ) != ERROR_SUCCESS)
    {
        // Hosed setup right defaults here. 
        return FALSE;
    }
        

    TransAssert(regKey.m_hKey != NULL);

    // For each entry in the registry
    DWORD dwIndex = 0;
    DWORD dwCount = 0;
    DWORD lRes;
    TCHAR szZoneName[MAX_ZONE_NAME];
    DWORD dwSize = MAX_ZONE_NAME;    

    CRegListElem *pElemStart = NULL;

    for (; (lRes = regKey.EnumKey(dwIndex, szZoneName, &dwSize)) != ERROR_NO_MORE_ITEMS; dwIndex++)
    {
        if (lRes != ERROR_SUCCESS)
        {
            break;
        }
        
        dwSize = MAX_ZONE_NAME;

        CRegZone *pRegZone = new CRegZone();
        
        if (pRegZone == NULL)
        {
            m_cZones = 0;
            // Out of memory -- change all error codes to return HRESULT's
            break;
        }
        
        if (!pRegZone->Init(szZoneName, m_bHKLMOnly))
        {
            continue;   // can't create the zone for some reason.
        }

        m_cZones++;
        
        CRegListElem * pRegListElem = new CRegListElem();
        if ( pRegListElem == NULL)
        {
            m_cZones = 0;
            break;  // Out of memory.
        }

        pRegListElem->pRegZone = pRegZone;
        pRegListElem->dwZoneIndex = pRegZone->GetZoneId();

        // Insert list into sorted position.
        if (pElemStart == NULL)
        {
            pElemStart = pRegListElem;
            pRegListElem->next = NULL;
        }
        else if (pElemStart->dwZoneIndex > pRegListElem->dwZoneIndex)
        {
            // Insert to the head of the list.
            pRegListElem->next = pElemStart;
            pElemStart = pRegListElem;
        }
        else 
        {
            // Insert in the correct position. 
            CRegListElem *pElemCurr = pElemStart;
            
            while (pElemCurr->next != NULL &&
                 pElemCurr->next->dwZoneIndex < pRegListElem->dwZoneIndex )
            {
                pElemCurr = pElemCurr->next;
            }

            TransAssert(pElemCurr != NULL);
            pRegListElem->next = pElemCurr->next;
            pElemCurr->next = pRegListElem;
        }
    }

    // Now that we have all the RegZones collected we will just store them in 
    // sorted order in an array.

    if (m_cZones)
        m_ppRegZones = new LPREGZONE[m_cZones];
    else
        m_ppRegZones = NULL;

    if (m_ppRegZones == NULL)
    {
        // Out of memory
        m_cZones = 0;
        return FALSE;
    }

    for (dwIndex = 0; dwIndex < m_cZones ; dwIndex++)
    {
        TransAssert(pElemStart != NULL);

        m_ppRegZones[dwIndex] = pElemStart->pRegZone;
        CRegListElem * pElemDelete = pElemStart;
        pElemStart = pElemStart->next;
        delete pElemDelete;
    }

    return TRUE;

}

BOOL CRegZoneContainer::Detach()
{
    // First free all the CRegZone entries we are holding on to.
    DWORD dwIndex = 0;

    for (; dwIndex < m_cZones; dwIndex++)
    {
        delete m_ppRegZones[dwIndex];
    }

    delete [] m_ppRegZones;
    m_ppRegZones = NULL;
    m_cZones = 0;
    m_bHKLMOnly = TRUE;

    // Zone enumerator cleanup.
    // This ASSERT will fire if you forget to call DestroyZoneEnumerator before 
    // freeing the object.
    TransAssert(m_pZoneEnumList == NULL);
    CZoneEnumList * pNextEnum = m_pZoneEnumList;
    while (pNextEnum != NULL)
    {
        CZoneEnumList * pEnumListDelete = pNextEnum;
        pNextEnum = pNextEnum->next;
        delete pEnumListDelete;
    }

    return TRUE;
}

// This function makes sure that the minimal set of zones are in the registry If things are missing
// it calls the self-registration entry point and re-creates the zone key.

#define WIN2KSETUP  TEXT("System\\Setup")
#define INPROGRESS  TEXT("SystemSetupInProgress")

BOOL CRegZoneContainer::SelfHeal(BOOL bUseHKLM)
{
 
    HKEY hKeyZones = NULL;

    if (IsInGUIModeSetup())
    {
        // ignore SelfHeal if we're in GUI-mode setup
        return TRUE;
    }

    if (RegOpenKeyEx((bUseHKLM ? HKEY_LOCAL_MACHINE : HKEY_CURRENT_USER), SZZONES, 0, KEY_READ, &hKeyZones)
            == ERROR_SUCCESS)
    {
                     
        // Strings corresponding to the five pre-defined zones.
        TCHAR * rgszZones[] = { TEXT("0"), TEXT("1"), TEXT("2"), TEXT("3"), TEXT("4") };
        
        int i;
        for (i = 0 ; i < ARRAYSIZE(rgszZones) ; i++ )
        {
            HKEY hKey;

            DWORD dwError = RegOpenKeyEx(hKeyZones, rgszZones[i], 0, KEY_READ, &hKey);
            
            if (dwError != ERROR_SUCCESS)
                break;
            else
                RegCloseKey(hKey);
        }

        RegCloseKey(hKeyZones);    

        // If we succesfully opened all the zones.
        if (i == ARRAYSIZE(rgszZones))
        {
            return TRUE;
        }

    }


    // If we reached here we were not able to open atleast one of the keys.
    // Note that we use L"" because ZonesDllInstall takes a LPCWSTR  
    BOOL bRet;
    HRESULT hr = ZonesDllInstall(TRUE, bUseHKLM ? L"HKLM" : L"HKCU");
    
    if (SUCCEEDED(hr))
    {
        CRegKey regKey(bUseHKLM);

        // Keep track of how many times we self heal for diagnostic purposes..
        DWORD dwSelfHealCount;
        TCHAR *pszSelfHealCount = TEXT("SelfHealCount");

        if (regKey.Open(NULL, SZZONES, KEY_READ | KEY_WRITE) == ERROR_SUCCESS)
        {
            if (regKey.QueryValue(&dwSelfHealCount, pszSelfHealCount) != ERROR_SUCCESS)
                dwSelfHealCount = 0;

            dwSelfHealCount++;
            regKey.SetValue(dwSelfHealCount, pszSelfHealCount);
        }

        bRet = TRUE;
    }
    else
        bRet = FALSE;

    return bRet;
}

CRegZone * CRegZoneContainer::GetRegZoneByName(LPCTSTR lpName) const
{
    DWORD dwIndex = 0;
    CRegZone *pRegZone = NULL;

    for ( ; dwIndex < m_cZones; dwIndex++ )
    {
        pRegZone = m_ppRegZones[dwIndex] ;

        if (pRegZone && StrCmpIW(pRegZone->GetZoneName(), lpName) == 0)
            break;
    }

    return pRegZone;
}

CRegZone * CRegZoneContainer::GetRegZoneById(DWORD dwZoneId) const
{
    DWORD dwIndex = 0;
    CRegZone * pReturnZone = NULL;

    for (; dwIndex < m_cZones ; dwIndex++ )
    {
        CRegZone * pRegZone = m_ppRegZones[dwIndex];

        
        if (pRegZone == NULL)       
        {
            // This shouldn't happen but a safety check doesn't hurt.
            break;
        }
        else if (pRegZone->GetZoneId() == dwZoneId)
        {
            pReturnZone = pRegZone;
            break;      // Got it
        }
        else if (pRegZone->GetZoneId() > dwZoneId)
        {
            break;
        }
    }

    return pReturnZone;
}

// Zone Enumeration functions. 
BOOL CRegZoneContainer::VerifyZoneEnum(DWORD dwEnum ) const
{
    BOOL bFound = FALSE;

    CZoneEnumList *pNext = m_pZoneEnumList;
    while (pNext)
    {
        if (pNext->dwEnum == dwEnum)
        {
            bFound = TRUE;
            break;
        }

        pNext = pNext->next;
    }
    
    return bFound;
}
          


STDMETHODIMP CRegZoneContainer::CreateZoneEnumerator(DWORD* pdwEnum,  DWORD *pdwCount)
{
    if (pdwEnum == NULL || pdwCount == NULL)
        return E_INVALIDARG;

    if (m_cZones == 0)
    {
        return E_FAIL;
    }

    CZoneEnumList *pEnumListElem = new CZoneEnumList;
    if (pEnumListElem == NULL)
        return E_OUTOFMEMORY;

    pEnumListElem->dwEnum = m_dwNextEnum++;

    EnterCriticalSection(&m_csect);

    if (m_pZoneEnumList == NULL)
    {
        pEnumListElem->next = NULL;
        m_pZoneEnumList = pEnumListElem;
    }
    else 
    {
        pEnumListElem->next = m_pZoneEnumList;
        m_pZoneEnumList = pEnumListElem;
    }

    *pdwEnum = m_pZoneEnumList->dwEnum;
    *pdwCount = m_cZones;
        
    TransAssert(VerifyZoneEnum(*pdwEnum));
    
    LeaveCriticalSection(&m_csect);
        
    return S_OK;
}


STDMETHODIMP CRegZoneContainer::GetZoneAt(DWORD dwEnum, DWORD dwIndex, DWORD *pdwZone)
{
    if (!VerifyZoneEnum(dwEnum) || dwIndex >= m_cZones)
    {
        return E_INVALIDARG;
    }

    if (m_ppRegZones && m_ppRegZones[dwIndex])
    {
        *pdwZone = m_ppRegZones[dwIndex]->GetZoneId();
        return S_OK;
    }
    else
    {
        return E_OUTOFMEMORY;
    }
}

STDMETHODIMP CRegZoneContainer::DestroyZoneEnumerator(DWORD dwEnum)
{
    HRESULT hr = S_OK;
    CZoneEnumList *pDelete = NULL;

    EnterCriticalSection(&m_csect);
    if (m_pZoneEnumList == NULL)
    {
    }
    else if (m_pZoneEnumList->dwEnum == dwEnum)
    {
        pDelete = m_pZoneEnumList;
        m_pZoneEnumList = pDelete->next;
    }
    else {
        CZoneEnumList *pCurr = m_pZoneEnumList;

        while (pCurr != NULL)
        {
            if (pCurr->next && pCurr->next->dwEnum == dwEnum)
            {
                pDelete = pCurr->next;
                pCurr->next = pDelete->next;
                break;
            }
            pCurr = pCurr->next;
        }
    }

    if (pDelete == NULL)
    {
        // Didn't find the entry must be an invalid Enumerator.
        hr = E_INVALIDARG;
    }
    else 
    {
        delete pDelete;
        hr = S_OK;
    }
    LeaveCriticalSection(&m_csect);
    return hr;
}

//=============================================================================
// CRegZoneCache methods
//=============================================================================
CRegZone::CRegZoneCache::CRegZoneCache(void)
{
    InitializeCriticalSection(&m_csectZoneCache);
    
    // single static object, so this only gets inited once per
    // process.
    s_hMutexCounter = CreateMutexA(NULL, FALSE, "ZonesCacheCounterMutex");
    m_iAdd = 0;
}

CRegZone::CRegZoneCache::~CRegZoneCache(void)
{
    Flush();
    DeleteCriticalSection(&m_csectZoneCache) ; 

    CloseHandle(s_hMutexCounter);
}

BOOL
CRegZone::CRegZoneCache::Lookup(DWORD dwZone, LPTSTR lpZonePath, DWORD dwAction, BOOL fUseHKLM, DWORD *pdwPolicy)
{
    BOOL fFound = FALSE;
    int iEntry = URLZONE_FINDCACHEENTRY;

    TransAssert(iEntry < MAX_REG_ZONE_CACHE);

    EnterCriticalSection(&m_csectZoneCache);

    if ( !IsCounterEqual() )
        Flush();
    
    fFound = FindCacheEntry(dwZone, dwAction, fUseHKLM, iEntry );
    if (fFound)
    {
        if (pdwPolicy)
        {
            *pdwPolicy = m_arzce[iEntry].m_dwPolicy;
        }
    }
    else
    {
        // Convert the Action to a string. 
#ifndef unix
        TCHAR wsz[9];  // FFFFFFFF\0
#else
        TCHAR wsz[(sizeof(DWORD)+1)*sizeof(WCHAR)];
#endif /* unix */

        if (DwToWchar(dwAction, wsz, 16))
        {
            CRegKey regKey(fUseHKLM);

            if (regKey.Open(NULL, lpZonePath, KEY_READ) == ERROR_SUCCESS) 
            {
                if (regKey.QueryValue(pdwPolicy, wsz) == ERROR_SUCCESS)
                {
                    fFound = TRUE;
                    Add(dwZone, dwAction, fUseHKLM, *pdwPolicy, iEntry);
                }
            }
            else
            {
                // BUGBUG:: We have to be able to deal with this situation and not just bail.
                // Possibilities: Setup defaults here if we can create and write to the key
                TransAssert(FALSE);
            }
        }
        else
        {
            TransAssert(FALSE);
        }
    }

    LeaveCriticalSection(&m_csectZoneCache);

    return fFound;
}

void 
CRegZone::CRegZoneCache::Add(DWORD dwZone, DWORD dwAction, BOOL fUseHKLM, DWORD dwPolicy, int iEntry)
{
    BOOL    fFound;

    TransAssert(iEntry < MAX_REG_ZONE_CACHE);
    
    EnterCriticalSection(&m_csectZoneCache);

    if ( !IsCounterEqual() )
        Flush();

    if(iEntry == URLZONE_FINDCACHEENTRY)  // using optional param that indicates the entry we want to add so don't bother doing a find.
        fFound = FindCacheEntry(dwZone, dwAction, fUseHKLM, iEntry ); // found or not, iEntry will be the right place to set it.

    m_arzce[iEntry].Set(dwZone, dwAction, fUseHKLM, dwPolicy);

    SetToCurrentCounter(); // validate this cache.

    LeaveCriticalSection(&m_csectZoneCache);
}

void 
CRegZone::CRegZoneCache::Flush(void)
{
    int i;

    EnterCriticalSection(&m_csectZoneCache);

    for ( i = 0; i < MAX_REG_ZONE_CACHE; i++ )
        m_arzce[i].Flush();

    m_iAdd = 0;
    
    LeaveCriticalSection(&m_csectZoneCache);
}

// Is the counter we saved with the cache entry, equal to the current counter.
BOOL
CRegZone::CRegZoneCache::IsCounterEqual( ) const 
{
    CExclusiveLock lock(s_hMutexCounter);
    LPDWORD lpdwCounter = (LPDWORD)g_SharedMem.GetPtr(SM_REGZONECHANGE_COUNTER);
    // If we couldn't create the shared memory for some reason, we just assume our cache is up to date.
    if (lpdwCounter == NULL)
        return TRUE;

    return (m_dwPrevCounter == *lpdwCounter);
}

VOID
CRegZone::CRegZoneCache::SetToCurrentCounter( ) 
{
    CExclusiveLock lock(s_hMutexCounter);
    LPDWORD lpdwCounter = (LPDWORD)g_SharedMem.GetPtr(SM_REGZONECHANGE_COUNTER);
    if (lpdwCounter == NULL)
        return;

    m_dwPrevCounter = *lpdwCounter;
}

VOID
CRegZone::CRegZoneCache::IncrementGlobalCounter( )
{
    CExclusiveLock lock(s_hMutexCounter);
    LPDWORD lpdwCounter = (LPDWORD)g_SharedMem.GetPtr(SM_REGZONECHANGE_COUNTER);
    if (lpdwCounter == NULL)
        return;

    (*lpdwCounter)++;
}

BOOL
CRegZone::CRegZoneCache::FindCacheEntry(DWORD dwZone, DWORD dwAction, BOOL fUseHKLM, int& riEntry )
{
    BOOL fFound = FALSE;

    for ( riEntry = 0; (m_arzce[riEntry].m_dwZone != ZONEID_INVALID) && (riEntry < MAX_REG_ZONE_CACHE); riEntry++ )
    {
        if ( m_arzce[riEntry].m_dwZone == dwZone &&
             m_arzce[riEntry].m_dwAction == dwAction &&
             m_arzce[riEntry].m_fUseHKLM == fUseHKLM )
        {
            fFound = TRUE;
            break;
        }
    }

    if(!fFound)
    {
        riEntry = m_iAdd;
        m_iAdd = (m_iAdd + 1) % MAX_REG_ZONE_CACHE;    // next index to add an entry that's not found
    }
    
    return fFound;
}
  
void 
CRegZone::CRegZoneCache::CRegZoneCacheEntry::Set(DWORD dwZone, DWORD dwAction, BOOL fUseHKLM, DWORD dwPolicy)
{
    m_dwZone = dwZone;    
    m_dwAction = dwAction;
    m_fUseHKLM = fUseHKLM;
    m_dwPolicy = dwPolicy;
}

void 
CRegZone::CRegZoneCache::CRegZoneCacheEntry::Flush(void)
{
    m_dwZone = ZONEID_INVALID;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\urlmon\wcheckcb\status.cxx ===
#include "Status.h"
#include "..\\inc\\urlmon.hxx"

#define TIMEOUT 600000 // 10 minutes

/******************************************************************************

    Constructor and destructor and helper functions

******************************************************************************/

CSilentCodeDLSink::CSilentCodeDLSink()
{
    m_cRef = 1;
    m_pBinding = NULL;
    m_hOnStopBindingEvt = CreateEvent(NULL, TRUE, FALSE, NULL);
    m_fAbort = FALSE;
}

CSilentCodeDLSink::~CSilentCodeDLSink()
{
    if(m_hOnStopBindingEvt)
		CloseHandle(m_hOnStopBindingEvt);	
}

VOID CSilentCodeDLSink::Abort()
{
    m_fAbort = TRUE;
}

HRESULT CSilentCodeDLSink::WaitTillNotified()
{
    if (m_hOnStopBindingEvt == NULL)
        return E_FAIL;

    HRESULT hr = E_FAIL;
    DWORD dwResult = 0;
    const DWORD MORE_INPUT = WAIT_OBJECT_0 + 1;
    MSG msg;

    // Test state of event
    dwResult = WaitForSingleObject(m_hOnStopBindingEvt, 0);
    if (dwResult == WAIT_FAILED)
        return HRESULT_FROM_WIN32(GetLastError());

    // Note that MsgWaitForMultipleObjects doesn't return 
    // if there was previously unread input of the specified 
    // type in the queue. It only wakes up when input arrives. 

    for (dwResult = MORE_INPUT; dwResult == MORE_INPUT; ) 
    {
        if (dwResult == MORE_INPUT)
        {
            // more input in queue
            while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
            {
                TranslateMessage(&msg);
                DispatchMessage(&msg);
            }
        }
        else if (dwResult == WAIT_OBJECT_0)
        {
            // event has been signaled
            hr = S_OK;
        }
        else if (dwResult == 0xFFFFFFFF)
        {
            // error has occurred
            hr = HRESULT_FROM_WIN32(GetLastError());
        }
        else
        {
            // timeout or wait abondaned
            hr = E_FAIL;
        }
        
        dwResult = MsgWaitForMultipleObjects(
                                  1, &m_hOnStopBindingEvt, 
                                  FALSE, TIMEOUT, QS_ALLINPUT);
    }

    if (FAILED(hr))
        Abort();

    return hr;
}

/******************************************************************************

    IUnknown Methods

******************************************************************************/

STDMETHODIMP CSilentCodeDLSink::QueryInterface(REFIID riid, void **ppv)
{
   *ppv = NULL;

    if (riid == IID_IUnknown || riid == IID_IBindStatusCallback)
	{
        *ppv = (IBindStatusCallback*)this;
	}
	else if (riid == IID_ICodeInstall)
	{
		*ppv = (ICodeInstall*)this;
	}
	else if (riid == IID_IWindowForBindingUI)
	{
		*ppv = (IWindowForBindingUI*)this;
	}

	if (*ppv != NULL)
	{
	    ((IUnknown*)*ppv)->AddRef();
    	return S_OK;
	}

	return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CSilentCodeDLSink::AddRef()
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG) CSilentCodeDLSink::Release()
{
    if (--m_cRef)
        return m_cRef;

    delete this;
    return 0;   
}

/******************************************************************************

    IBindStatusCallback Methods

******************************************************************************/

STDMETHODIMP CSilentCodeDLSink::OnStartBinding(DWORD grfBSCOption, IBinding *pib)
{
	if (m_pBinding != NULL)
        m_pBinding->Release();

    m_pBinding = pib;
	if (m_pBinding != NULL)
        m_pBinding->AddRef();

	if (m_fAbort)
		m_pBinding->Abort();

    return S_OK;
}

STDMETHODIMP CSilentCodeDLSink::GetPriority(LONG *pnPriority)
{
	if (m_fAbort)
		m_pBinding->Abort();

    return S_OK;
}

STDMETHODIMP CSilentCodeDLSink::OnLowResource(DWORD reserved)
{
	if (m_fAbort)
		m_pBinding->Abort();

    return S_OK;
}

STDMETHODIMP CSilentCodeDLSink::OnProgress(
                                    ULONG ulProgress,
                                    ULONG ulProgressMax,
                                    ULONG ulStatusCode,
                                    LPCWSTR szStatusText)
{
	if (m_fAbort)
		m_pBinding->Abort();

    return S_OK;
}

STDMETHODIMP CSilentCodeDLSink::OnStopBinding(
                                    HRESULT hresult, 
                                    LPCWSTR szError)
{
	if (m_pBinding)
    {
        m_pBinding->Release();
	    m_pBinding = NULL;
    }

    if(m_hOnStopBindingEvt)
		SetEvent(m_hOnStopBindingEvt);

    return S_OK;
}

STDMETHODIMP CSilentCodeDLSink::GetBindInfo(
                                    DWORD* pgrfBINDF, 
                                    BINDINFO* pbindInfo)
{
    if (!pgrfBINDF || !pbindInfo || !pbindInfo->cbSize)
        return E_INVALIDARG;

    *pgrfBINDF = BINDF_ASYNCHRONOUS|BINDF_SILENTOPERATION;

    // clear BINDINFO but keep its size
    DWORD cbSize = pbindInfo->cbSize;
    ZeroMemory( pbindInfo, cbSize );
    pbindInfo->cbSize = cbSize;

    return S_OK;
}

STDMETHODIMP CSilentCodeDLSink::OnDataAvailable(
                                        DWORD grfBSCF, 
                                        DWORD dwSize,
                                        FORMATETC *pformatetc,
                                        STGMEDIUM *pstgmed)
{
	if (m_fAbort)
		m_pBinding->Abort();

    return S_OK;
}

STDMETHODIMP CSilentCodeDLSink::OnObjectAvailable(
                                            REFIID riid,
                                            IUnknown *punk)
{
    return S_OK;
}

/******************************************************************************

    ICodeInstall Methods

******************************************************************************/

STDMETHODIMP CSilentCodeDLSink::GetWindow(
                                    REFGUID rguidReason, 
                                    HWND *phwnd)
{
    *phwnd = (HWND)INVALID_HANDLE_VALUE;

	if (m_fAbort)
		m_pBinding->Abort();

    return S_FALSE;
}

STDMETHODIMP CSilentCodeDLSink::OnCodeInstallProblem(
                                           ULONG ulStatusCode, 
                                           LPCWSTR szDestination, 
                                           LPCWSTR szSource, 
                                           DWORD dwReserved)
{
	switch (ulStatusCode)
	{
		case CIP_ACCESS_DENIED:
		case CIP_DISK_FULL:
			return E_ABORT;

		case CIP_OLDER_VERSION_EXISTS:
			return S_OK; // always update

		case CIP_NEWER_VERSION_EXISTS:
			return S_FALSE; // don't update

		case CIP_NAME_CONFLICT:
			return E_ABORT;

		case CIP_EXE_SELF_REGISTERATION_TIMEOUT:
			return S_OK;

		case CIP_TRUST_VERIFICATION_COMPONENT_MISSING:
			return E_ABORT; 

		case CIP_UNSAFE_TO_ABORT:
			return S_OK;

		default:
			return E_ABORT;
    }

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\urlmon\wcheckcb\wcheckcb.cxx ===
#include <urlmon.h>
#include <htmlguid.h>
#include <ocidl.h>
#include "..\\inc\\urlint.h"
#include "..\\inc\\wcheckcb.h"
#include "..\\inc\\debug.h"
#include "..\\download\\cdl.h"
#include "Status.h"

// {5DFE9E81-46E4-11d0-94E8-00AA0059CE02}
const CLSID CLSID_ControlRefreshCallback = {
                                0x5dfe9e81, 0x46e4, 0x11d0, 
                                0x94, 0xe8, 0x0, 0xaa, 0x0, 
                                0x59, 0xce, 0x2
                                };

const static TCHAR *g_pszUpdateInfo = TEXT("UpdateInfo");
const static TCHAR *g_pszNewControlInCache = TEXT("NewControlInCache");

#define CLSID_MAX_LENGTH 50
#define CONTENT_MAX_LENGTH 1024

/******************************************************************************
    Constructor, Destructor and helper methods
******************************************************************************/

CControlRefreshCallback::CControlRefreshCallback()
{
    DllAddRef();
    m_cRef = 1;
    m_clsidCtrl = CLSID_NULL;
    m_wszURL[0] = '\0';
}

CControlRefreshCallback::~CControlRefreshCallback()
{
    Assert(m_cRef == 0);
    DllRelease();
}

// Give this object information such as the clsid and url of the control
// it's dealing with 
STDMETHODIMP CControlRefreshCallback::SetInfo(
                                        REFCLSID rclsidControl,
                                        LPCWSTR lpwszURL)
{
    m_clsidCtrl = rclsidControl;

    // copy wide strings
#ifdef UNICODE
    lstrcpyW(m_wszURL, lpwszURL);   // only works in Win32 mode
                                    // fails on Win95
#else
    INT i = 0;
    for(; lpwszURL[i]; i++)
        m_wszURL[i] = lpwszURL[i];
    m_wszURL[i] = '\0';
#endif

    Assert(lstrlenW(m_wszURL) == lstrlenW(lpwszURL));

    return S_OK;
}

/*
HRESULT CControlRefreshCallback::UpdateControlInCacheFlag(
                                               SCODE scReason) const
{
    // update flag in registry so that IE initiates a new
    // download when the control is visited.

    LONG lResult = ERROR_SUCCESS;
    TCHAR szKey[MAX_PATH];
    LPOLESTR pwcsClsid = NULL;
    BOOL fChanged = (scReason == S_OK);

    lstrcpy(szKey, TEXT("CLSID\\"));

    if (SUCCEEDED(::StringFromCLSID(m_clsidCtrl, &pwcsClsid)))
    {
        HKEY hKey = NULL;
        int nLen = lstrlen(szKey);

        if (WideCharToMultiByte(
                           CP_ACP, 0, pwcsClsid, -1, szKey + nLen, 
                           MAX_PATH - nLen, NULL, NULL) > 0)
        {
            lstrcat(szKey, "\\");
            lstrcat(szKey, g_pszUpdateInfo);
            lResult = RegOpenKeyEx(
                              HKEY_CLASSES_ROOT, szKey, 0, 
                              KEY_ALL_ACCESS, &hKey); 

            if (lResult == ERROR_SUCCESS)
            {
                DWORD dwKeySet = 0;
                DWORD dwSize = sizeof(DWORD);
                lResult = RegQueryValueEx(
                                    hKey, g_pszNewControlInCache, NULL, NULL,
                                    (LPBYTE)&dwKeySet, &dwSize);

                if (lResult != ERROR_SUCCESS || (dwKeySet == 0 && fChanged))
                {
                    dwKeySet = (fChanged ? 1 : 0);
                    lResult = RegSetValueEx(
                                    hKey, g_pszNewControlInCache, 0, 
                                    REG_DWORD, (LPBYTE)&dwKeySet, sizeof(DWORD));
                }
                RegCloseKey(hKey);
            }
        }

        delete pwcsClsid;
    }

    return (lResult == ERROR_SUCCESS ? S_OK : HRESULT_FROM_WIN32(lResult));
}
*/

HRESULT CControlRefreshCallback::DownloadControl() const
{
    HRESULT hr = S_OK;
    CSilentCodeDLSink *pscdls = NULL;
    LPBC pbc = NULL;

    Assert(lstrlenW(m_wszURL) > 0);
    Assert(m_clsidCtrl != CLSID_NULL);

    pscdls = new CSilentCodeDLSink;
    if (pscdls == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    hr = CreateBindCtx(0, &pbc);
    if (SUCCEEDED(hr))
        hr = RegisterBindStatusCallback(pbc, pscdls, NULL, 0);

    if (FAILED(hr))
        goto Exit;

    hr = AsyncGetClassBits(
                       m_clsidCtrl, NULL, NULL, 
                       (DWORD)-1, (DWORD)-1, m_wszURL,
                       pbc, CLSCTX_INPROC_SERVER|CLSCTX_INPROC_HANDLER, 
                       NULL, IID_IClassFactory, 0);

    if (hr == MK_S_ASYNCHRONOUS)
        hr = pscdls->WaitTillNotified();

    RevokeBindStatusCallback(pbc, pscdls);

Exit:

    if (pbc)
        pbc->Release();

    if (pscdls)
        pscdls->Release();

    return hr;
}

/******************************************************************************
    IUnknown Methods
******************************************************************************/

STDMETHODIMP CControlRefreshCallback::QueryInterface(
                                                REFIID iid, 
                                                void** ppvObject)
{
    *ppvObject = NULL;

    if (iid == IID_IUnknown)
    {
        *ppvObject = (void*)this;
    }
    else if (iid == IID_IPersistStream)
    {
        *ppvObject = (void*)(IPersistStream*)this;
    }
    else if (iid == IID_IWebCheckAdviseSink)
    {
        *ppvObject = (void*)(IWebCheckAdviseSink*)this;
    }

    if (*ppvObject) 
    {
        ((LPUNKNOWN)*ppvObject)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CControlRefreshCallback::AddRef()
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG) CControlRefreshCallback::Release()
{
    if (--m_cRef)
        return m_cRef;

    delete this;
    return 0;   
}


/******************************************************************************
    IPersistStream Methods
******************************************************************************/

STDMETHODIMP CControlRefreshCallback::GetClassID(CLSID* pClsssID)
{
    *pClsssID = CLSID_ControlRefreshCallback;
    return S_OK;
}

STDMETHODIMP CControlRefreshCallback::IsDirty(void)
{
    Assert(m_clsidCtrl != CLSID_NULL);
    return (m_clsidCtrl != CLSID_NULL ? S_OK : S_FALSE);
}

STDMETHODIMP CControlRefreshCallback::Load(IStream* pStm)
{
    DWORD dwLen = 0;

    ULONG cb = sizeof(CLSID);
    ULONG cbRead = 0;
    pStm->Read((void*)&m_clsidCtrl, cb, &cbRead);
    Assert(cb == cbRead);
    if (cb != cbRead)
        goto Exit;

    cb = sizeof(DWORD);
    cbRead = 0;
    pStm->Read((void*)&dwLen, cb, &cbRead);
    Assert(cb == cbRead);
    if (cb != cbRead)
        goto Exit;

    cb = dwLen * sizeof(WCHAR);
    cbRead = 0;
    pStm->Read((void*)&m_wszURL, cb, &cbRead);
    Assert(cb == cbRead);

    Assert((DWORD)lstrlenW(m_wszURL) == dwLen - 1);

Exit:

    return (cbRead == cb ? S_OK : E_FAIL);
}

STDMETHODIMP CControlRefreshCallback::Save(IStream* pStm, BOOL fClearDirty)
{
    DWORD dwLen = lstrlenW(m_wszURL) + 1;    // add 1 for NULL char

    ULONG cb = sizeof(CLSID);
    ULONG cbSaved = 0;
    pStm->Write((void*)&m_clsidCtrl, cb, &cbSaved);
    Assert(cb == cbSaved);
    if (cb != cbSaved)
        goto Exit;

    cb = sizeof(DWORD);
    cbSaved = 0;
    pStm->Write((void*)&dwLen, cb, &cbSaved);
    Assert(cb == cbSaved);
    if (cb != cbSaved)
        goto Exit;

    cb = dwLen * sizeof(WCHAR);
    cbSaved = 0;
    pStm->Write((void*)m_wszURL, cb, &cbSaved);
    Assert(cb == cbSaved);

Exit:

    return (cbSaved == cb ? S_OK : E_FAIL);
}

STDMETHODIMP CControlRefreshCallback::GetSizeMax(ULARGE_INTEGER* pcbSize)
{
    pcbSize->QuadPart = sizeof(CLSID) + sizeof(DWORD) + sizeof(m_wszURL);
    return S_OK;
}


/******************************************************************************
    IWebCheckAdviseSink Methods
******************************************************************************/

STDMETHODIMP CControlRefreshCallback::UpdateBegin(
                                              long lCookie, 
                                              SCODE scReason, 
                                              BSTR lpURL)
{
    return S_OK;
}

// scReason -- S_OK means changed, S_FALSE means no changes
STDMETHODIMP CControlRefreshCallback::UpdateEnd(
                                            long lCookie, 
                                            SCODE scReason)
{
    Assert(m_clsidCtrl != CLSID_NULL);
    LONG lResult = ERROR_SUCCESS;

    if (scReason == S_OK)
    {
        DownloadControl();
//        UpdateControlInCacheFlag(scReason);
    }

    return S_OK;
}

STDMETHODIMP CControlRefreshCallback::UpdateProgress(
                                                 long lCookie, 
                                                 long lCurrent, 
                                                 long lMax)
{
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\urlmon\zones\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by zones.rc
//
#define IDD_WARN_ALERT                  114
#define IDI_SECURITY1                   116
#define IDI_SECURITY2                   118
#define IDI_SECURITY3                   119
#define IDC_DONT_WANT_WARNING           1001
#define IDC_ZONEALERTTEXT               1032
#define IDD_WARN_ON_POST                1175
#define IDS_WARN_SHELL_FILE_DL          2012
#define IDS_ACTION_DL_SIGNED_JAVA       2013
#define IDS_ACTION_FORMS_POST           2013
#define IDS_ACTION_DL_JAVA              2014
#define IDS_ACTION_POST_FROM            2014
#define IDS_ACTION_DL_ACTIVE_CODE       2015
#define IDS_ACTION_AX_OVERRIDE_SAFETY   2016
#define IDS_ACTION_AX_CONFIRM_NOSAFETY  2017
#define IDS_ACTION_SCRIPT_RUN           2018
#define IDS_ACTION_SCRIPT_JAVA          2019
#define IDS_ACTION_HTML_FORMS           2022
#define IDS_ACTION_HTML_FONT_DL         2023
#define IDS_ACTION_HTML_JAVA            2024
#define IDS_ACTION_SHELL_DRAG_DTCOMP    2025
#define IDS_ACTION_SHELL_INSTALL_DTITEMS 2025
#define IDS_ACTION_SHELL_DRAG_FILE      2026
#define IDS_ACTION_SHELL_MOVE_OR_COPY   2026
#define IDS_ACTION_SHELL_FILE_DL        2027
#define IDS_ACTION_SHELL_VERB           2028
#define IDS_ACTION_NW_CREDENTIALS       2029
#define IDS_ACTION_NW_AUTH_CLIENT       2030
#define IDS_ACTION_DL_SIGNED_ACTIVEX    2031
#define IDS_ACTION_AX_RUN               2032
#define IDS_ACTION_UNKNOWN              2033
#define IDS_ACTION_AX_OVERRIDE_DATA_SAFETY 2034
#define IDS_ACTION_AX_OVERRIDE_SCRIPT_SAFETY 2035
#define IDS_ACTION_SCRIPT_OVERRIDE_SAFETY 2036
#define IDS_ACTION_DL_ACTIVEX           2037
#define IDS_WARN_SHELL_DRAG_DTCOMP      2038
#define IDS_WARN_SHELL_INSTALL_DTITEMS  2038
#define IDS_ACTION_SHELL_DRAG           2039
#define IDS_WARN_SHELL_DRAG_FILE        2040
#define IDS_WARN_SHELL_MOVE_OR_COPY     2040
#define IDS_WARN_SHELL_VERB             2041
#define IDS_WARN_HTML_FORMS             2042
#define IDS_WARN_UNKNOWN                2043
#define IDS_ACTION_SCRIPT_SAFE_ACTIVEX  2044
#define IDS_ACTION_SHELL_WEBVIEW_VERB   2045
#define IDS_WARN_SHELL_WEBVIEW_VERB     2046
#define IDS_ACTION_CROSS_DOMAIN_DATA    2047
#define IDS_ACTION_NW_COOKIES           2048
#define IDS_ACTION_NW_COOKIES_SESSION   2051
#define IDS_ACTION_HTML_USERDATA        2052
#define IDS_ACTION_SCRIPT_PASTE         2053
#define IDS_ACTION_HTML_SUBFRAME_NAVIGATE    2054
#define IDS_ACTION_NW_CLIENT_CERT_PROMPT    2055
#define IDS_ACTION_NW_COOKIES_THIRD_PARTY           2056
#define IDS_ACTION_NW_COOKIES_SESSION_THIRD_PARTY   2057
#define IDS_ACTION_HTML_META_REFRESH                2058
#define IDS_ACTION_HTML_MIXED_CONTENT               2059
#define IDD_ZONE_ALERT                  4006

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        115
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1034
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\urlmon\zones\regzone.h ===
//  File:       regzone.h
//
//  Contents:   Registry management for a single zone. 
//
//  Classes:    CRegZone
//
//  Functions:
//
//  History: 
//
//----------------------------------------------------------------------------

#ifndef _REGZONE_H_
#define _REGZONE_H_

// Constants corresponding to the registry.
#define MAX_REG_ZONE_CACHE      20
#define URLZONE_INVALID         URLZONE_USER_MAX+1

#define MAX_ZONE_NAME           240
#define MAX_ZONE_PATH           256    // This is "Standard\\ZoneName"
#define MAX_VALUE_NAME          256

#define ZONEID_INVALID          0xFFFFFFFF
#define URLZONE_FINDCACHEENTRY  0xFFFFFFFF

// There are two registry keys under which the information is copied. 
// One of them is "Zones" which holds the actual information and the other
// one is "TemplatePolicies" which holds the high medium and low policies. 
// This enumeration indicates which part of the registry to read. 

enum REGZONEUSE { REGZONEUSEZONES, REGZONEUSETEMPLATE };

class CRegZone 
{
public:
    CRegZone();
    // Seperate init function to allow for failure on return. 
    BOOL Init(LPCTSTR lpStr, BOOL bCreate = TRUE, REGZONEUSE regZoneUse = REGZONEUSEZONES, BOOL bSystem = TRUE);

    ~CRegZone();

    // Attributes
    DWORD GetZoneId() const  { return m_dwZoneId; }
    LPTSTR GetZoneName() const { return m_lpZoneName; }

    // Returns NULL terminated string, free using CoTaskFree
    STDMETHODIMP  GetZoneAttributes (ZONEATTRIBUTES& zoneAttrib);
    STDMETHODIMP  SetZoneAttributes (const ZONEATTRIBUTES& zoneAttrib);

    STDMETHODIMP  GetActionPolicy (DWORD dwAction, URLZONEREG urlZone, DWORD& dwPolicy) const;
    STDMETHODIMP  SetActionPolicy (DWORD dwAction, URLZONEREG urlZone, DWORD dwPolicy);

    STDMETHODIMP  GetCustomPolicy (REFGUID guid, URLZONEREG urlZone, BYTE** ppByte, DWORD *pcb) const; 
    STDMETHODIMP  SetCustomPolicy (REFGUID guid, URLZONEREG urlZone, BYTE* pByte, DWORD cb);

    STDMETHODIMP  CopyTemplatePolicies(DWORD dwTemplateIndex);

    BOOL  UpdateZoneMapFlags( );

    // Should we display this zone in the UI. 
    // Note that Zones not displayed in UI are not included in the zone enumeration.
    inline BOOL IsUIZone() const;
   
protected:
    inline IsValid() const { return (m_dwZoneId != ZONEID_INVALID); }
    inline BOOL UseHKLM(URLZONEREG urlZoneReg) const;
 
    // Helper functions
    inline BOOL IsHardCodedZone() const { return FALSE; }
    inline BOOL GetHardCodedZonePolicy(DWORD dwAction, DWORD& dwPolicy) const;


    inline BOOL  QueryTemplatePolicyIndex(CRegKey& regKey, LPCTSTR psz, LPDWORD pdw) const;
    inline BOOL  SetTemplatePolicyIndex(CRegKey& regKey, LPCTSTR psz, DWORD dw);
        
    static BOOL     IsAttributeName(LPCTSTR psz);
    static LPCTSTR  GetTemplateNameFromIndex ( URLTEMPLATE urlTemplateIndex);
    inline static BOOL     IsValidTemplateIndex( DWORD dwTemplateIndex ); 
    static BOOL     GetAggregateAction(DWORD dwAction, LPDWORD dwAggregateAction);
    static void     KludgeMapAggregatePolicy(DWORD dwAction, LPDWORD pdwAction);
    static VOID     IncrementGlobalCounter( );

// Methods/members to support caching
protected:

    class CRegZoneCache {
    public:
        CRegZoneCache(void);
        ~CRegZoneCache(void);

        BOOL Lookup(DWORD dwZone, LPTSTR lpZonePath, DWORD dwAction, BOOL fUseHKLM, DWORD *pdwPolicy);
        void Add(DWORD dwZone, DWORD dwAction, BOOL fUseHKLM, DWORD dwPolicy, int iEntry = URLZONE_FINDCACHEENTRY);
        void Flush(void);

        static VOID IncrementGlobalCounter( );

    protected:

        // Counters to flag cross-process cache invalidation.
        DWORD         m_dwPrevCounter ; // Global counter so we can correctly invalidate the cache if 
                                        // user changes options.
        static HANDLE s_hMutexCounter;  // mutex controlling access to shared memory counter.
 
        BOOL IsCounterEqual() const;
        VOID SetToCurrentCounter();

        // The body of the cache is this array of cache entries.
        // Cross-thread access control for the array is by critical section.

        CRITICAL_SECTION m_csectZoneCache; // assumes only one, static instance of the cache 


        struct CRegZoneCacheEntry {
            CRegZoneCacheEntry(void) :
                m_dwZone(ZONEID_INVALID),
                m_dwAction(0),
                m_fUseHKLM(FALSE),
                m_dwPolicy(0) {};
            ~CRegZoneCacheEntry(void) { Flush(); };

            void Set(DWORD dwZone, DWORD dwAction, BOOL fUseHKLM, DWORD dwPolicy);
            void Flush(void);
            
            DWORD      m_dwZone;
            DWORD      m_dwAction;
            BOOL       m_fUseHKLM;
            DWORD      m_dwPolicy;
        }; // CRegZoneCacheEntry

        CRegZoneCacheEntry   m_arzce[MAX_REG_ZONE_CACHE];
        int                  m_iAdd;

        BOOL FindCacheEntry(DWORD dwZone, DWORD dwAction, BOOL fUseHKLM, int& riEntry ); // must be called under critical section.

    }; // CRegZoneCache

    static CRegZoneCache s_rzcache;

private:

    DWORD  m_dwZoneId;
    DWORD  m_dwZoneFlags;
    LPTSTR m_lpZoneName;
    LPTSTR m_lpZonePath;

    BOOL m_bHKLMOnly;
    BOOL m_bStandard;         
    BOOL m_bZoneLockOut;         // Is the whole zone locked out. 
    REGZONEUSE m_regZoneUse;
};

typedef CRegZone *LPREGZONE;

BOOL CRegZone::UseHKLM(URLZONEREG urlZoneReg) const
{
    BOOL bReturn;

    switch(urlZoneReg)
    {
        case URLZONEREG_HKLM:
            bReturn = TRUE;
            break;
        case URLZONEREG_HKCU:
            bReturn = FALSE;
            break;
        case URLZONEREG_DEFAULT:
            bReturn = m_bHKLMOnly;
            break;
        default:
            TransAssert(FALSE);
    }

    return bReturn;
}

BOOL CRegZone::IsValidTemplateIndex(DWORD dwTemplateIndex)
{
    BOOL bReturn = FALSE;

    switch (dwTemplateIndex)    
    {
        case URLTEMPLATE_CUSTOM:
        case URLTEMPLATE_LOW:
        case URLTEMPLATE_MEDLOW:
        case URLTEMPLATE_MEDIUM:
        case URLTEMPLATE_HIGH:
            bReturn = TRUE;
            break;
    }
    return bReturn;
}

BOOL CRegZone::QueryTemplatePolicyIndex(CRegKey& regKey, LPCTSTR psz, LPDWORD pdw) const
{
    LONG lRet;

    lRet = regKey.QueryValue(pdw, psz);

    if (NO_ERROR != lRet)
    {
        *pdw = URLTEMPLATE_CUSTOM;
    }
    else if (*pdw < URLTEMPLATE_PREDEFINED_MIN || *pdw > URLTEMPLATE_PREDEFINED_MAX)
    {
        // Invalid value, just return back default.
        *pdw = URLTEMPLATE_CUSTOM;
    }

    return TRUE;
}

BOOL CRegZone::SetTemplatePolicyIndex(CRegKey& regKey, LPCTSTR psz, DWORD dwIndex)
{   
    // Write this only if it is a valid template index. 
    if (IsValidTemplateIndex(dwIndex))
    {
        if (regKey.SetValue(dwIndex, psz) == NO_ERROR)
            return TRUE;
    }
    else 
    {
        TransAssert(FALSE); 
    }

    return FALSE;
}


BOOL CRegZone::GetHardCodedZonePolicy(DWORD dwAction, DWORD& dwPolicy) const
{
    TransAssert(IsHardCodedZone());

    if (!IsHardCodedZone())
        return FALSE;

    switch(dwAction)
    {
        case URLACTION_JAVA_PERMISSIONS:
            dwPolicy = URLPOLICY_JAVA_HIGH;
            break;
        case URLACTION_CREDENTIALS_USE:
            dwPolicy = URLPOLICY_CREDENTIALS_SILENT_LOGON_OK;
            break;
        case URLACTION_AUTHENTICATE_CLIENT:
            dwPolicy = URLPOLICY_AUTHENTICATE_CLEARTEXT_OK;
            break; 
        case URLACTION_ACTIVEX_OVERRIDE_OBJECT_SAFETY:
            dwPolicy = URLPOLICY_QUERY;
            break;          
        default:
            dwPolicy = 0;
            break;
    }

    return TRUE;
}

BOOL CRegZone::IsUIZone() const
{
    return (m_dwZoneFlags & ZAFLAGS_NO_UI) ? FALSE : TRUE;
}

// This is the class that maintains the list of the RegZones currently in action

class CRegZoneContainer
{
public:

    CRegZoneContainer();
    ~CRegZoneContainer();

public:
    BOOL Attach(BOOL bUseHKLM, REGZONEUSE regZoneUse = REGZONEUSEZONES);
    BOOL Detach();
    BOOL SelfHeal(BOOL bUseHKLM);

    CRegZone * GetRegZoneByName(LPCTSTR lpszZoneName) const;
    CRegZone * GetRegZoneById(DWORD dwZoneId) const;
    DWORD  GetZoneCount() const { return m_cZones; };

    STDMETHODIMP CreateZoneEnumerator(DWORD *pdwEnum, DWORD *pdwCount);
    STDMETHODIMP GetZoneAt(DWORD dwEnum, DWORD dwIndex, DWORD *pdwZone);
    STDMETHODIMP DestroyZoneEnumerator(DWORD dwEnum);

protected:
   // Used internally only.
   struct CRegListElem {
        CRegListElem * next;
        CRegZone     * pRegZone;
        DWORD   dwZoneIndex;
    };

    struct CZoneEnumList {
        DWORD dwEnum;   // Cookie indicating which enum this corresponds to.
        CZoneEnumList * next;
    };

    CZoneEnumList * m_pZoneEnumList;
    DWORD m_dwNextEnum;

    // Is this enumerator a valid enumerator.
    BOOL VerifyZoneEnum(DWORD dwEnum) const;

private:

    CRegZone**  m_ppRegZones;        // Array of RegZones.
    DWORD       m_cZones;             // # of Zones.
    BOOL        m_bHKLMOnly;
    CRITICAL_SECTION m_csect;
};
                                    
#endif  // _REGZONE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\urlmon\zones\secmgr.h ===
//  File:       secmgr.h
//
//  Contents:   The object that implements the base IInternetSecurityManager interface
//
//  Classes:    CSecurityManager
//
//  Functions:
//
//  History: 
//
//----------------------------------------------------------------------------

#ifndef _SECMGR_H_
#define _SECMGR_H_

#pragma warning(disable:4200)

#define MAX_SEC_MGR_CACHE   4
#define URLZONE_INVALID     URLZONE_USER_MAX+1

#define MUTZ_NOCACHE    0x80000000  // start private flags from high end

struct ZONEMAP_COMPONENTS;

struct RANGE_ITEM
{
    BYTE  bLow[4];    // high byte values for range
    BYTE  bHigh[4];   // low byte values for range
    TCHAR szName[1];  // actually variable length
};

class CSecurityManager : public IInternetSecurityManager
{
public:
    // IUnknown methods
    STDMETHODIMP QueryInterface(REFIID iid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    STDMETHODIMP MapUrlToZone( 
        /* [in] */ LPCWSTR pwszUrl,
        /* [out] */ DWORD *pdwZone,
        /* [in] */ DWORD dwReserved);

    STDMETHODIMP GetSecurityId( 
        /* [in] */ LPCWSTR pwszUrl,
        /* [size_is][out] */ BYTE* pbSecurityId,
        /* [out][in] */ DWORD *pcbSecurityId,
        /* [in] */ DWORD_PTR dwReserved);
        
    STDMETHODIMP ProcessUrlAction( 
        /* [in] */ LPCWSTR pwszUrl,
        /* [in] */ DWORD dwAction,
        /* [size_is][out] */ BYTE *pPolicy,
        /* [in] */ DWORD cbPolicy,
        /* [in] */ BYTE *pContext,
        /* [in] */ DWORD cbContext,
        /* [in] */ DWORD dwFlags,
        /* [in] */ DWORD dwReserved);
        
    STDMETHODIMP QueryCustomPolicy(
        /* [in] */ LPCWSTR     pwszUrl,
        /* [in] */ REFGUID     guidKey,
        /* [size_is][size_is][out] */ BYTE **ppPolicy,
        /* [out] */ DWORD *pcbPolicy,
        /* [in] */ BYTE *pContext,
        /* [in] */ DWORD cbContext,
        /* [in] */ DWORD dwReserved
    );

    STDMETHODIMP SetSecuritySite(
        /* [in] */  IInternetSecurityMgrSite *pSite
    );

    STDMETHODIMP GetSecuritySite(
        /* [out] */  IInternetSecurityMgrSite **ppSite
    );

    STDMETHODIMP SetZoneMapping( 
        /* [in] */ DWORD dwZone,
        /* [in] */ LPCWSTR lpszPattern,
        /* [in] */ DWORD dwFlags);
    
    STDMETHODIMP GetZoneMappings( 
        /* [in] */ DWORD dwZone,
        /* [out] */ IEnumString **ppEnumString,
        /* [in] */ DWORD dwFlags);

// Constructors/destructors
public:
    CSecurityManager(IUnknown *pUnkOuter, IUnknown **ppUnkInner);
    virtual ~CSecurityManager();

    static BOOL GlobalInit( ) ;
            
    static BOOL GlobalCleanup( );


// Aggregation and RefCount support.
protected:
    CRefCount m_ref;
        
    class CPrivUnknown : public IUnknown
    {
    public:
        STDMETHOD(QueryInterface) ( REFIID riid, LPVOID FAR* ppvObj);
        STDMETHOD_(ULONG,AddRef) (void);
        STDMETHOD_(ULONG,Release) (void);

        ~CPrivUnknown() {}
        CPrivUnknown() : m_ref () {}

    private:
        CRefCount   m_ref;          // the total refcount of this object
    };

    friend class CPrivUnknown;
    CPrivUnknown m_Unknown;

    IUnknown*   m_pUnkOuter;

    STDMETHODIMP_(ULONG) PrivAddRef()
    {
        return m_Unknown.AddRef();
    }
    STDMETHODIMP_(ULONG) PrivRelease()
    {
        return m_Unknown.Release();
    }

protected:

    BOOL EnsureZoneManager();
    VOID PickZCString(ZONEMAP_COMPONENTS *pzc, LPCWSTR *ppwsz, DWORD *pcch, LPCWSTR pwszDocDomain);

    // Helper methods to deal with IP Rules
    HRESULT ReadAllIPRules( );
    HRESULT AddDeleteIPRule(ZONEMAP_COMPONENTS *pzc, DWORD dwZone, DWORD dwFlags);

    // helper methods to do GetZoneMappings.
    HRESULT AddUrlsToEnum(CRegKey *pRegKey, DWORD dwZone, LPCTSTR lpsz, int cch, BOOL bAddWildCard, CEnumString *);
    HRESULT AddIPRulesToEnum(DWORD dwZone, CEnumString *);

    static HRESULT ComposeUrlSansProtocol(LPCTSTR pszDomain, int cchDomain, LPCTSTR pszSite, int cchSite,
                                        LPTSTR * ppszRet, int * cchRet);
    static HRESULT ComposeUrl(LPCTSTR pszUrlSansProt, int cchUrlSansProt, LPCTSTR pszProt, int cchProt, BOOL bAddWildCard,
                                LPTSTR * ppszRet, int * cchRet);

protected:  // UI related definitions.

    enum    { MAX_ALERT_SIZE = 256 };
    // Return values from DialogProc's
    enum  {  ZALERT_NO = 0 /* should be 0*/ , ZALERT_YES, ZALERT_YESPERSIST };

    // This structure is used to exchange data between the security manager 
    // and the dialog proc's.
    struct DlgData 
    {
        DWORD dwAction;
        DWORD dwZone;
        LPWSTR pstr;
        DWORD dwFlags;
    };

    typedef DlgData * LPDLGDATA;
                            
    // helper methods to display generic UI.
    static DWORD GetAlertIdForAction(DWORD dwAction);
    static DWORD GetWarnIdForAction(DWORD dwAction);

    // Dialog proc's etc.
    static INT_PTR ZonesAlertDialogProc(HWND hDlg, UINT iMsg, WPARAM wParam, LPARAM lParam); 
    static INT_PTR ZonesWarnDialogProc(HWND hDlg, UINT iMsg, WPARAM wParam, LPARAM lParam); 

    static inline BOOL IsFormsSubmitAction(DWORD dwAction);

    static INT_PTR FormsAlertDialogProc(HWND hDlg, UINT iMsg, WPARAM wParam, LPARAM lParam);
                
    INT CSecurityManager::ShowFormsAlertDialog(HWND hwndParent, LPDLGDATA lpDlgData);

protected: 
    // Methods to help Map a URL to a zone. 

    HRESULT MapUrlToZone
        (ZONEMAP_COMPONENTS* pzc, DWORD* pdwZone, DWORD dwFlags, BOOL *pfMarked = NULL, LPWSTR *ppszURLMark = NULL);

    HRESULT WrapMapUrlToZone(LPCWSTR pwszSecUrl, ZONEMAP_COMPONENTS* pzc, DWORD* pdwZone, DWORD dwFlags,
                                BOOL *pfMarked, LPWSTR *ppszMarkURL);

    HRESULT CheckAddressAgainstRanges
        (ZONEMAP_COMPONENTS* pzc, DWORD* pdwZone, LPCTSTR pszProt);

    HRESULT CheckSiteAndDomainMappings
        (ZONEMAP_COMPONENTS* pzc, DWORD* pdwZone, LPCTSTR pszProt);

    HRESULT CheckUNCAsIntranet
        (ZONEMAP_COMPONENTS* pzc, DWORD* pdwZone, LPCTSTR pszProt);

    HRESULT CheckIntranetName
        (ZONEMAP_COMPONENTS* pzc, DWORD* pdwZone, LPCTSTR pszProt);

    HRESULT CheckProxyBypassRule
        (ZONEMAP_COMPONENTS* pzc, DWORD* pdwZone, LPCTSTR pszProt);

    HRESULT CheckMKURL
        (ZONEMAP_COMPONENTS* pzc, DWORD* pdwZone, LPCTSTR pszProt);

protected:
    // Class to remember persistent actions.
    class CPersistAnswers 
    {
    public:
            CPersistAnswers( ) : m_pAnswerEntry(NULL) { };
            ~CPersistAnswers( );

    public:
       BOOL GetPrevAnswer(LPCWSTR pszUrl, DWORD dwAction, INT* piAnswer);
        VOID RememberAnswer(LPCWSTR pszUrl, DWORD dwAction, INT iAnswer);
        static inline BOOL IsPersistentAnswerAction(DWORD dwAction);

    private:                            
        struct CAnswerEntry 
        {
            // Construction
            CAnswerEntry(LPCWSTR pszUrl, DWORD dwAction, INT iAnswer);
            ~CAnswerEntry( );

            // Methods.
            BOOL MatchEntry (LPCWSTR pszUrl, DWORD dwAction);
            INT GetAnswer( ) const { return m_iAnswer; }
            LPCWSTR GetUrl( ) const { return m_pszUrl; }
            CAnswerEntry * GetNext( ) const { return m_pNext; }
            VOID SetNext(CAnswerEntry * pNext) { m_pNext = pNext; }

            private:
            CAnswerEntry * m_pNext;
            LPWSTR m_pszUrl;
            DWORD  m_dwAction;
            INT    m_iAnswer;
        };

        CAnswerEntry* m_pAnswerEntry;
    };

    CPersistAnswers m_persistAnswers;

// Methods/members to support caching so we optimize MapUrlToZone, etc.
protected:

    class CSecMgrCache {
    public:
        CSecMgrCache(void);
        ~CSecMgrCache(void);

        BOOL Lookup(LPCWSTR pwszURL,
                    DWORD *pdwZone = NULL,
                    BOOL *pfMarked = NULL,
                    BYTE *pbSecurityID = NULL,
                    DWORD *pcbSecurityID = NULL, 
                    LPCWSTR pwszDocDomain = NULL);
        void Add(LPCWSTR pwszURL,
                 DWORD dwZone,
                 BOOL fMarked,
                 const BYTE *pbSecurityID = NULL,
                 DWORD cbSecurityID = NULL,
                 LPCWSTR pwszDocDomain = NULL );
        void Flush(void);

        static VOID IncrementGlobalCounter( );

    protected:

        // Counters to flag cross-process cache invalidation.
        DWORD         m_dwPrevCounter ; // Global counter so we can correctly invalidate the cache if 
                                        // user changes options.
        static HANDLE s_hMutexCounter;  // mutex controlling access to shared memory counter 
 
        BOOL IsCounterEqual() const;
        VOID SetToCurrentCounter();

        // The body of the cache is this array of cache entries.
        // Cross-thread access control for the array is by critical section.

        CRITICAL_SECTION m_csectZoneCache; // assumes only one, static instance of the cache 


        struct CSecMgrCacheEntry {
            CSecMgrCacheEntry(void) :
                m_pwszURL(NULL),
                m_pbSecurityID(NULL),
                m_cbSecurityID(NULL),
                m_dwZone(URLZONE_INVALID),
                m_fMarked(FALSE),
                m_pwszDocDomain(NULL) {};
            ~CSecMgrCacheEntry(void) { Flush(); };

            void Set(LPCWSTR pwszURL, DWORD dwZone, BOOL fMarked, 
                    const BYTE *pbSecurityID, DWORD cbSecurityID, LPCWSTR pwszDocDomain);
            void Flush(void);
            
            LPWSTR  m_pwszURL;
            BYTE*   m_pbSecurityID;
            DWORD   m_cbSecurityID;
            DWORD   m_dwZone;
            BOOL    m_fMarked;
            LPWSTR  m_pwszDocDomain;
        }; // CSecMgrCacheEntry

        CSecMgrCacheEntry   m_asmce[MAX_SEC_MGR_CACHE];
        int                 m_iAdd;         // index in m_asmce to add the next element

        BOOL FindCacheEntry( LPCWSTR pwszURL, int& riEntry ); // must be called under critical section.

    }; // CSecMgrCache

    static CSecMgrCache s_smcache;

protected:
    // Methods to manage List of Allowed ActiveX controls

    static BOOL EnsureListReady(BOOL bForce = FALSE);
    static void IntializeAllowedControls();
    static HRESULT GetControlPermissions(BYTE * raw_CLSID, DWORD & dwPerm);

    // Get the final decision on the whether to run a CLSID (for this zone, etc)
    static HRESULT GetActiveXRunPermissions(BYTE * raw_CLSID, DWORD & dwPerm);

public:
    static VOID IncrementGlobalCounter( );

private:
    IInternetSecurityMgrSite*   m_pSite;
    IInternetZoneManager* m_pZoneManager;
    IInternetSecurityManager* m_pDelegateSecMgr;

    CRegKey m_regZoneMap;


    // Static members to do remember the correct IP Ranges.
    static BOOL   s_bIPInit;     // have we read the IP ranges. 
    static BYTE*  s_pRanges;     // array of range items
    static DWORD  s_cNumRanges;  // number of range items
    static DWORD  s_cbRangeItem; // size of each range item
    static DWORD  s_dwNextRangeIndex; // Next index to use to add numbers in the range entry.

    static CRITICAL_SECTION s_csectIP; // crit section to protect it all. 
    static BOOL s_bcsectInit;
    static CLSID * s_clsidAllowedList;
    static CRITICAL_SECTION s_csectAList;
    static DWORD s_dwNumAllowedControls;
};

#pragma warning(default:4200)

#endif // _SECMGR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\urlmon\zones\zonepch.h ===
//  File:       zonepch.h
//
//  Contents:   Standard header files included by every file in this directory
//
//  
//  Functions://
//  History: 
//
//----------------------------------------------------------------------------

#ifndef _ZONEPCH_H_
#define _ZONEPCH_H_

// NOTE: This directory only supports Unicode currently

// Include this first since urlmon.hxx redefines malloc, free etc.
#include <malloc.h> // required for alloca prototype. 

#include "urlmon.hxx"
#include "shlwapi.h"
#include "shlwapip.h"
#include "winineti.h"

#include "zoneutil.h"
#include "urlenum.h"
#include "regzone.h"
#include "zonemgr.h"
#include "secmgr.h"

#include "resource.h"
// Unix: may not need to include unaligned.hpp if building with Apogee
//       Need it for Solaris CC compiler
#include <unaligned.hpp>

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\urlmon\zones\urlenum.h ===
#ifndef _URLENUM_H_
#define _URLENUM_H



class CEnumString : public IEnumString
{
public:
    //////////////////////////////////////////////////////
    // Public Interfaces
    //////////////////////////////////////////////////////
    
    // *** IUnknown ***
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);

    // *** IEnumString ***
    virtual STDMETHODIMP Next(ULONG celt, LPOLESTR *rgelt, ULONG *pceltFetched);
    virtual STDMETHODIMP Skip(ULONG celt);
    virtual STDMETHODIMP Reset(void);
    virtual STDMETHODIMP Clone(IEnumString **ppenum);

public:
    // Constructor-destructor, don't create this on the stack. 
    CEnumString();
    ~CEnumString();

    // This is a very simple class where all the strings should be added
    // before any enumeration occurs. 
    HRESULT AddString(LPCWSTR lpsz);

private:
    CRefCount m_ref;

    struct ListStr 
    {
        LPTSTR lpsz;
        ListStr * pListNext;
    };

    ListStr * pFirst;
    ListStr * pLast;
    ListStr * pCurrent;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\urlmon\zones\urlenum.cxx ===
// Implementation of the CEnumString classs

#include "zonepch.h"


// Constructor - destructor.

CEnumString::CEnumString() : m_ref() 
{
    pFirst = NULL;
    pLast = NULL;
    pCurrent = NULL;
}


CEnumString::~CEnumString( )
{
    // Delete all the strings we created.
    ListStr * pNext = pFirst;
    
    while (pNext != NULL)
    {
        ListStr * pDelete = pNext;
        pNext = pNext->pListNext;

        LocalFree(pDelete->lpsz);
        delete pDelete;
    }
}

HRESULT CEnumString::AddString(LPCWSTR lpsz)
{
    // First create the element.
    ListStr *pListStr = new ListStr;
    if (pListStr == NULL)
        return E_OUTOFMEMORY;

    pListStr->lpsz = StrDup(lpsz);
    if (pListStr->lpsz == NULL)
    {
        delete pListStr;
        return E_OUTOFMEMORY;
    }

    pListStr->pListNext = NULL;

    if (pFirst == NULL)
    {
        TransAssert(pCurrent == NULL);
        TransAssert(pLast == NULL);
        pFirst = pCurrent = pLast = pListStr;
    }
    else 
    {
        TransAssert(pLast != NULL);
        // We don't support adding strings while an enumeration is on.
        TransAssert(pFirst == pCurrent);
        
        pLast->pListNext = pListStr;
        pLast = pListStr;
    }

    return S_OK;
}
                
// IUnknown methods.

STDMETHODIMP_(ULONG) CEnumString::AddRef( )
{
    LONG lRet = ++m_ref;
    
    return lRet;
}

STDMETHODIMP_(ULONG) CEnumString::Release( )
{

    LONG lRet =  --m_ref;
    
    if (m_ref == 0)
    {
        delete this;
    }

    return lRet;
}

STDMETHODIMP  CEnumString::QueryInterface(REFIID riid, LPVOID * ppvObj)
{
    HRESULT hr = NOERROR;   
    
    if ( (riid == IID_IUnknown) || (riid == IID_IEnumString))
    { 
        *ppvObj = this;       
        AddRef();
    }
    else 
    {
        *ppvObj = NULL;
        hr  = E_NOINTERFACE;
    }

    return hr;
}


// IEnumString methods.


STDMETHODIMP
CEnumString::Next(ULONG celt, LPOLESTR *rgelt, ULONG *pceltFetched)
{
    HRESULT hr = NOERROR;
    ULONG cFound = 0;

    // Check the arguments first.     
    if (celt == 0)
        return S_OK;
             
    if (!rgelt)
        return E_INVALIDARG;

    do 
    {
        if (pCurrent == NULL)
            break;
            
        DWORD cChars = lstrlenW(pCurrent->lpsz) + 1;
        rgelt[cFound] = (LPOLESTR)CoTaskMemAlloc(cChars * sizeof(OLECHAR));

        // If we don't have enough memory don't return anything. 
        if (rgelt[cFound] == NULL)
        {
            hr = E_OUTOFMEMORY;
            for (DWORD dwIndex = 0 ; dwIndex < cFound ; dwIndex++ )
            {
                CoTaskMemFree(rgelt[dwIndex]);
                rgelt[dwIndex] = 0;
            }
        } 
        
        StrCpyW(rgelt[cFound], pCurrent->lpsz);
        
        pCurrent = pCurrent->pListNext;
        
        cFound++;
    } while ( cFound < celt );
    
    if (hr == NOERROR)
    {
        if (pceltFetched)
            *pceltFetched = cFound;
            
        hr = (cFound == celt) ?  NOERROR : S_FALSE;
    }
    
    return hr;
}                                      

                    
    
STDMETHODIMP
CEnumString::Skip(ULONG celt)
{
    return E_NOTIMPL;
}


STDMETHODIMP
CEnumString::Reset( )
{
    pCurrent = pFirst;

    return S_OK;
}

STDMETHODIMP
CEnumString::Clone(IEnumString **ppEnumString)
{
    // This should be easy to implement if we do a deep copy.
    // However we should be able to seperate the list from the 
    // current pointer and do a much more efficient job.
    // Not impl for code complete.

    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\urlmon\zones\secmgr.cxx ===
//  File:       secmgr.cxx
//
//  Contents:   This file implements the base IInternetSecurityManager interface
//
//  Classes:    CSecurityManager
//
//  Functions:
//
//  History: 
//
//----------------------------------------------------------------------------

#include "zonepch.h" // PCH HEADER FILE, DON'T INCLUDE ANYTHING ABOVE 
#include <commctrl.h>
#include "shfusion.h"

PerfDbgTag(tagCSecurityManager, "Urlmon", "Log Security Mgr", DEB_SESSION)
PerfDbgTag(tagZONEMAP_COMPONENTS, "Urlmon", "Log Security URL parser", DEB_SESSION)

#define PRIVATE static

#define ZERO        TEXT('0')
#define NINE        TEXT('9')
#define DOT         TEXT('.')
#define SLASH       TEXT('/')
#define BACKSLASH   TEXT('\\')
#define COLON       TEXT(':')
#define WILDCARD    TEXT('*')
#define SPACE       TEXT(' ')
#define HYPHEN      TEXT('-')
#define BAR         TEXT('|')
#define AT          TEXT('@')
#define PERCENT     TEXT('%')

extern const LPWSTR RtlpWin32NtRoot         = L"\\\\?";
extern const LPWSTR RtlpWin32NtUncRoot      = L"\\\\?\\UNC";

#define MAX_IPRANGE 32

extern BOOL g_bUseImprovedZoneCheck;

BOOL  CSecurityManager::s_bIPInit = FALSE;
BYTE * CSecurityManager::s_pRanges = NULL;
DWORD CSecurityManager::s_cNumRanges = 0;
DWORD CSecurityManager::s_cbRangeItem = 0;
DWORD CSecurityManager::s_dwNextRangeIndex = 0;

PRIVATE TCHAR chWildCard = WILDCARD;

CSecurityManager::CSecMgrCache CSecurityManager::s_smcache;

BOOL  CSecurityManager::s_bcsectInit = FALSE;
CRITICAL_SECTION CSecurityManager::s_csectIP; 
HANDLE CSecurityManager::CSecMgrCache::s_hMutexCounter;

CLSID * CSecurityManager::s_clsidAllowedList = NULL;
CRITICAL_SECTION CSecurityManager::s_csectAList;
DWORD CSecurityManager::s_dwNumAllowedControls;


// HACK: See assert below.  We have to parse '*' as a valid scheme for wildcarding purposes.
// The big number is to avoid collisions with the pre-defined URL_SCHEME_* numbers that start 
// at 0 and go up sequentially. 
#define URL_SCHEME_WILDCARD (0x0000FFFF)
#define SAFEREGOPERATION(dw, r) \
    dw = r; \
    if(dw == ERROR_KEY_DELETED) \
    {\
        dw = m_regZoneMap.Open (NULL, SZZONEMAP, KEY_READ); \
        if( dw == ERROR_SUCCESS) \
            dw = r; \
    } 

#ifndef ARRAY_ELEMENTS
#define ARRAY_ELEMENTS(array) \
    (sizeof(array)/sizeof((array)[0]))
#endif

typedef DWORD (APIENTRY *WNETGETCONNECTION) (LPSTR, LPSTR, LPDWORD);


// Simple class to force freeing of memory pointer.
class CFreeStrPtr 
{
public:
    CFreeStrPtr(LPWSTR pwsz) { m_pwsz = pwsz; }
    ~CFreeStrPtr()  { delete [] m_pwsz; }
private:
    LPWSTR m_pwsz;
};

#ifdef UNICODE
#define IsSpace IsCharSpaceW
#else
#define IsSpace isspace
#endif

// Scans a string for number from 0 to 255 inclusive.
PRIVATE BOOL ScanByte (LPCTSTR& psz, BYTE *bOut)
{
    DWORD dw;
    
    // first char
    if (*psz < ZERO || *psz > NINE)
        return FALSE;
    dw = *psz++ - ZERO;

    // second char
    if (*psz < ZERO || *psz > NINE)
        goto done;
    dw = 10 * dw + *psz++ - ZERO;

    // third char
    if (*psz < ZERO || *psz > NINE)
        goto done;
    dw = 10 * dw + *psz++ - ZERO;
    if (dw > 255)
        return FALSE;

done:
    *bOut = (BYTE) dw;
    return TRUE;
}

// Scans a string for a range, wrapping ScanByte
PRIVATE BOOL ScanRange (LPCTSTR& psz, BYTE* pbLow, BYTE* pbHigh)
{
    if (*psz == WILDCARD)
    {
        *pbLow  = 0;
        *pbHigh = 255;
        psz++; // move past *
        return TRUE;
    }

    if (!ScanByte (psz, pbLow))
        return FALSE;

    while (*psz == SPACE)
        psz++; // trim whitespace
    if (*psz != HYPHEN)
    {
        *pbHigh = *pbLow;
        return TRUE;
    }
    else
    {
        psz++; // move past -
        while (*psz == SPACE)
            psz++; // trim whitespace
        return ScanByte (psz, pbHigh);
    }
}


PRIVATE BOOL ReadIPRule (LPCTSTR psz, BYTE *pbLow, BYTE *pbHigh)
{
    // Note: ScanRange first param passed by reference.
    return
       (    ScanRange (psz, pbLow++, pbHigh++)
        &&  *psz++ == DOT
        &&  ScanRange (psz, pbLow++, pbHigh++)
        &&  *psz++ == DOT
        &&  ScanRange (psz, pbLow++, pbHigh++)
        &&  *psz++ == DOT
        &&  ScanRange (psz, pbLow++, pbHigh++)
       );
}


// This function is copied here from the network stack code because we don't want to 
// link urlmon with winsock. Urlmon is pulled in by the shell even in cases where there
// is no network connection.

/*
 * Internet address interpretation routine.
 * All the network library routines call this
 * routine to interpret entries in the data bases
 * which are expected to be an address.
 * The value returned is in network order.
 */
PRIVATE ULONG 
inet_addr(
    IN const TCHAR *cp
    )

/*++

Routine Description:

    This function interprets the character string specified by the cp
    parameter.  This string represents a numeric Internet address
    expressed in the Internet standard ".'' notation.  The value
    returned is a number suitable for use as an Internet address.  All
    Internet addresses are returned in network order (bytes ordered from
    left to right).

    Internet Addresses

    Values specified using the "." notation take one of the following
    forms:

    a.b.c.d   a.b.c     a.b  a

    When four parts are specified, each is interpreted as a byte of data
    and assigned, from left to right, to the four bytes of an Internet
    address.  Note that when an Internet address is viewed as a 32-bit
    integer quantity on the Intel architecture, the bytes referred to
    above appear as "d.c.b.a''.  That is, the bytes on an Intel
    processor are ordered from right to left.

    Note: The following notations are only used by Berkeley, and nowhere
    else on the Internet.  In the interests of compatibility with their
    software, they are supported as specified.

    When a three part address is specified, the last part is interpreted
    as a 16-bit quantity and placed in the right most two bytes of the
    network address.  This makes the three part address format
    convenient for specifying Class B network addresses as
    "128.net.host''.

    When a two part address is specified, the last part is interpreted
    as a 24-bit quantity and placed in the right most three bytes of the
    network address.  This makes the two part address format convenient
    for specifying Class A network addresses as "net.host''.

    When only one part is given, the value is stored directly in the
    network address without any byte rearrangement.

Arguments:

    cp - A character string representing a number expressed in the
        Internet standard "." notation.

Return Value:

    If no error occurs, inet_addr() returns an in_addr structure
    containing a suitable binary representation of the Internet address
    given.  Otherwise, it returns the value INADDR_NONE.

--*/

{
        register unsigned long val, base, n;
        register TCHAR c;
        unsigned long parts[4], *pp = parts;
        const unsigned long INADDR_NONE = -1;


again:
        /*
         * Collect number up to ``.''.
         * Values are specified as for C:
         * 0x=hex, 0=octal, other=decimal.
         */
        val = 0; base = 10;
        if (*cp == '0') {
            base = 8, cp++;
            if (*cp == 'x' || *cp == 'X')
                base = 16, cp++;
        }

        while (c = *cp) {
                // If it is a decimal digit..
                if (c <= NINE && c >= ZERO) {
                        val = (val * base) + (c - '0');
                        cp++;
                        continue;
                }
                // If we are base 16 and it is a hex digit...
                if ( base == 16 && 
                     ( (c >= TEXT('a') && c <= TEXT('f')) ||
                       (c >= TEXT('A') && c <= TEXT('F'))
                     )
                   )
                {
                        val = (val << 4) + (c + 10 - (islower(c) ? TEXT('a') : TEXT('A')));
                        cp++;
                        continue;
                }
                break;
        }
        if (*cp == '.') {
                /*
                 * Internet format:
                 *      a.b.c.d
                 *      a.b.c   (with c treated as 16-bits)
                 *      a.b     (with b treated as 24 bits)
                 */
                /* GSS - next line was corrected on 8/5/89, was 'parts + 4' */
                if (pp >= parts + 3) {
                        return ((unsigned long) -1);
                }
                *pp++ = val, cp++;
                goto again;
        }
        /*
         * Check for trailing characters.
         */
        if (*cp && !IsSpace(*cp)) {
                return (INADDR_NONE);
        }
        *pp++ = val;
        /*
         * Concoct the address according to
         * the number of parts specified.
         */
        n = (unsigned long)(pp-parts);
        switch ((int) n) {

        case 1:                         /* a -- 32 bits */
                val = parts[0];
                break;

        case 2:                         /* a.b -- 8.24 bits */
                if ((parts[0] > 0xff) || (parts[1] > 0xffffff)) {
                    return(INADDR_NONE);
                }
                val = (parts[0] << 24) | (parts[1] & 0xffffff);
                break;

        case 3:                         /* a.b.c -- 8.8.16 bits */
                if ((parts[0] > 0xff) || (parts[1] > 0xff) ||
                    (parts[2] > 0xffff)) {
                    return(INADDR_NONE);
                }
                val = (parts[0] << 24) | ((parts[1] & 0xff) << 16) |
                        (parts[2] & 0xffff);
                break;

        case 4:                         /* a.b.c.d -- 8.8.8.8 bits */
                if ((parts[0] > 0xff) || (parts[1] > 0xff) ||
                    (parts[2] > 0xff) || (parts[3] > 0xff)) {
                    return(INADDR_NONE);
                }
                val = (parts[0] << 24) | ((parts[1] & 0xff) << 16) |
                      ((parts[2] & 0xff) << 8) | (parts[3] & 0xff);
                break;

        default:
                return (INADDR_NONE);
        }

#if defined(UNIX) && defined(BIG_ENDIAN)
//  IEUNIX: Dont swap on BIG_ENDIAN Unix m/c.
        return (val);
#else
        val = (val & 0xff000000) >> 24 |
              (val & 0x00ff0000) >> 8  |
              (val & 0x0000ff00) << 8  |
              (val & 0x000000ff) << 24;
        return (val);
#endif
}


// Checks if site is in form of IP address.
PRIVATE BOOL ReadAddress (LPCTSTR pwszSite, BYTE *pb)
{
    ULONG ipaddr = inet_addr(pwszSite);

    if (ipaddr != -1)
    {
#ifndef UNIX
        *(ULONG*)pb = ipaddr;
#else
        memcpy(pb, &ipaddr, sizeof(ULONG));
#endif /* UNIX */
        return TRUE;
    }
    return FALSE;
}

const TCHAR cszFileProt[] = TEXT("file");

struct ZONEMAP_COMPONENTS
{
    // pointers into buffer passed to Crack
    LPCTSTR  pszProtocol, pszSite, pszDomain; 
    DWORD    cchProtocol, cchSite, cchDomain; 

    DWORD    nScheme;   // One of URL_SCHEME_* 
    BOOL     fAddr:1;    // whether name is in form of IP address
    BOOL     fIPRange:1; // whether name is in form of an IP Range.
    BYTE     bAddr[4];  // if IP address, components of IP address
    RANGE_ITEM rangeItem; // If IP Range, components of IP Range.

    BOOL     fDrive; // URL corresponds to a drive letter that couldn't be mapped to a network share name.
    DWORD    dwDriveType; // if so, drive type

    TCHAR    szProtBuf[INTERNET_MAX_SCHEME_LENGTH];
    TCHAR    szSiteBuf[MAX_PATH]; // used for remote drives
    TCHAR    szIPAddr[16];   // room for 255.255.255.255 + NULL
    
    HRESULT Crack (LPCTSTR pwszUrl, DWORD dwFlags, BOOL bIPRange = FALSE);

    BOOL SetUNC (LPSTR pszUNC);
};


BOOL ZONEMAP_COMPONENTS::SetUNC (LPSTR pszUNC)
{
    PerfDbgLog(tagZONEMAP_COMPONENTS, this, "+ZONEMAP_COMPONENTS::SetUNC");

    // Verify and strip leading backslashes.
    if (pszUNC[0] != '\\' || pszUNC[1] != '\\')
        return FALSE;
    pszUNC += 2;

    // Strip the share name from the host.
    LPSTR pszSlash = StrChrA (pszUNC, '\\');
    if (!pszSlash)
        return FALSE;
    *pszSlash = 0;
    DWORD cchUNC = (DWORD) (pszSlash - pszUNC);

    // Convert back to unicode.
    cchSite = MultiByteToWideChar
        (CP_ACP, 0, pszUNC, cchUNC, szSiteBuf, MAX_PATH);
    szSiteBuf[cchSite] = 0;
    pszSite = szSiteBuf;

    PerfDbgLog(tagZONEMAP_COMPONENTS, this, "-ZONEMAP_COMPONENTS::SetUNC");
    return TRUE;        
}


// Helper functions to help with URL cracking.

inline BOOL IsDosPath(LPCTSTR p)
{
#ifndef unix
    return (*p == BACKSLASH 
                || 
            /* it starts with "x:" where x is from the English alphabet */
                ( (*p) && 
                  ((*p >= TEXT('a') && *p <= TEXT('z')) || (*p >= TEXT('A') && *p <= TEXT('Z'))) && 
                  p[1] == COLON) );
#else
    return (*p == SLASH);
#endif /* unix */
}
    
inline BOOL IsDrive(LPCTSTR p)
{
#ifndef unix
    return (*p && (p[1] == COLON || p[1] == BAR));
#else
    return (*p == SLASH);
#endif /* unix */
}

inline BOOL IsWildcardScheme(LPCTSTR p, BOOL &bImplicit)
{
    BOOL bRet = FALSE;
    if ( p && *p )
    {
        if (*p == WILDCARD && p[1] == COLON)
        {
            bRet = TRUE;
            bImplicit = FALSE;
        }
        else if (StrChr(p, COLON) == NULL) 
        {
            // If there is no Colon in the string the user didn't specify a scheme
            // and we will assume it is a wildcard.
            // i.e *:*.microsoft.com is treated the same as *.microsoft.com

            bRet = TRUE;
            bImplicit = TRUE;
        }
    }
    return bRet;
}

// A scheme is opaque if we cannot interpret the URL after the scheme.
inline BOOL IsOpaqueScheme(DWORD dwScheme)
{
    return (dwScheme != URL_SCHEME_FILE && dwScheme != URL_SCHEME_WILDCARD && !IsHierarchicalScheme(dwScheme));
}


// Global Init functions.

BOOL CSecurityManager::GlobalInit( )
{
    InitializeCriticalSection(&s_csectIP);
    InitializeCriticalSection(&s_csectAList);
     
    CSecurityManager::s_bcsectInit = TRUE;
    return TRUE;
}
        
BOOL CSecurityManager::GlobalCleanup( )
{
    delete [] s_pRanges; 
    s_pRanges = NULL;

    if(s_clsidAllowedList)
    {
        delete [] s_clsidAllowedList;
        s_clsidAllowedList = NULL;
    }
    

    if ( s_bcsectInit )
    {
        DeleteCriticalSection(&s_csectIP) ; 
        DeleteCriticalSection(&s_csectAList);
    }

    return TRUE; 
}

VOID CSecurityManager::IncrementGlobalCounter( )
{
    CSecurityManager::CSecMgrCache::IncrementGlobalCounter( );
}

// Helper functions to deal with caching MapUrlToZone results.
    
HRESULT ZONEMAP_COMPONENTS::Crack (LPCTSTR pszScan, DWORD dwFlags, BOOL bIPRange /* = FALSE*/)
{
    PerfDbgLog(tagZONEMAP_COMPONENTS, this, "+ZONEMAP_COMPONENTS::Crack");
    fDrive = FALSE;
    fAddr = FALSE;
    fIPRange = FALSE;

    nScheme = URL_SCHEME_INVALID;
        
    if (IsDosPath(pszScan))
        dwFlags |= PUAF_ISFILE;
    
    if (dwFlags & PUAF_ISFILE)
    {
        pszProtocol = cszFileProt;
        cchProtocol = CSTRLENW(cszFileProt);
        nScheme = URL_SCHEME_FILE;
    }
    else
    {
        PARSEDURL pu;
        pu.cbSize = sizeof(pu);

        BOOL bImplicit = FALSE;        
        if ( (dwFlags & PUAF_ACCEPT_WILDCARD_SCHEME) && 
             IsWildcardScheme(pszScan, bImplicit)
           )
        {
            nScheme = URL_SCHEME_WILDCARD;
            pszProtocol = &chWildCard;
            cchProtocol = 1;
            // Skip over the *: if the user entered this explicity.
            if (!bImplicit)
                pszScan += 2;
        }
        else
        {
            HRESULT hr = ParseURL(pszScan, &pu);

            if (SUCCEEDED(hr))
            {
                nScheme = pu.nScheme;
                pszProtocol = pu.pszProtocol;

                cchProtocol = pu.cchProtocol;
                pszScan = pu.pszSuffix;
            }
            else
            {
                return hr;
            }

        }

        // Copy protocol to null terminate it.
        if (cchProtocol >= INTERNET_MAX_SCHEME_LENGTH)
            return E_INVALIDARG;
        else
        {
            memcpy (szProtBuf, pszProtocol, sizeof(TCHAR) * cchProtocol);
            szProtBuf[cchProtocol] = 0;
            pszProtocol = szProtBuf;
        }
    }
    

    // Opaque URLs - We cannot interpret anything besides the scheme. 
    // Just Treat the rest of the string as the Site.
    if (IsOpaqueScheme(nScheme))
    {
        pszSite = pszScan;
        cchSite = lstrlen(pszSite);
        pszDomain = NULL;
        cchDomain = 0;
    }
    else 
    {
#ifndef unix
        if(nScheme == URL_SCHEME_FILE)
        {
            const TCHAR UncRoot1[] = TEXT("\\\\?\\");
            const TCHAR UncRoot2[] = TEXT("\\\\.\\");
            const TCHAR szUnc[]    = TEXT("UNC\\");
            if (0 == StrCmpNICW(pszScan, UncRoot1, ARRAYSIZE(UncRoot1)-1) || 
                0 == StrCmpNICW(pszScan, UncRoot2, ARRAYSIZE(UncRoot2)-1))
            {
                // If the url starts with \\?\ or \\.\ .
                pszScan += ARRAYSIZE(UncRoot1) - 1;
                // First check if it is in the form of \\?\c:. If it is, don't move pszScan
                if (pszScan[0] == 0)
                    return E_INVALIDARG;
                else if (pszScan[1] != TEXT(':'))
                {
                    if (0 == StrCmpNICW(pszScan, szUnc, ARRAYSIZE(szUnc) - 1))
                        pszScan += ARRAYSIZE(szUnc) - 1;
                    else
                        return E_INVALIDARG;
                }
            }
        }

        // Scan past leading '/' and '\' before site.
        while (*pszScan == SLASH || *pszScan == BACKSLASH)
            pszScan++;
#endif /* unix */ 
        pszSite = pszScan;

        // Is this a drive letter. If so we need to figure out whether it is local or remote.
        if (nScheme == URL_SCHEME_FILE && pszSite[0] != WILDCARD && IsDrive(pszSite))
        {
            fDrive = TRUE;

            char szDriveRoot[4];
            szDriveRoot[0] = (BYTE) pszSite[0];
#ifndef unix
            szDriveRoot[1] = ':';
            szDriveRoot[2] = '\\';
            szDriveRoot[3] = 0;
#else
        szDriveRoot[1] = 0;
#endif /* unix */

            dwDriveType = GetDriveTypeFromCacheA (szDriveRoot);

            if (dwDriveType == DRIVE_REMOTE)
            {
                // Strip the trailing backslash.
                szDriveRoot[2] = 0;
            
                char szUNC[MAX_PATH];
                DWORD cchUNC;
                cchUNC = MAX_PATH;

                if (NO_ERROR == WNetGetConnectionA(szDriveRoot, szUNC, &cchUNC))
                {
                    fDrive = FALSE;
                    SetUNC (szUNC);
                }
            }
        }
        
        // SetUNC might have come back with a new site. 
        
        pszScan = pszSite;

        if (fDrive)
        {
            // Just start using the drive as is. 
            cchSite = lstrlen(pszSite);
            cchDomain = 0;
            pszDomain = NULL;
        }
        else
        {
                    
            // Scan for characters which delimit site.
            while (1)
            {
                switch (*pszScan)
                {
                    case 0:        
                    case SLASH:    
                    case BACKSLASH:
                        break;
                
                    case TEXT('@'):
                        // This happens with custom protocols. Remove assert.
                        // TransAssert(FALSE);
                    default:
                        pszScan++;
                        continue;
                }
                break;        
            }

 
            cchSite = (DWORD) (pszScan - pszSite);

            pszDomain = NULL;
            cchDomain = 0;

            // Check for IP ranges if we are asked to first. 
            if (bIPRange)
            {
                fIPRange = ReadIPRule(pszSite, rangeItem.bLow, rangeItem.bHigh);
                if (fIPRange)
                    return S_OK;
            }

            // Windows Bug# 553626:
            // Note: IP address can be expressed in octal or hex, but we don't support them:
            if(cchSite < ( sizeof(szIPAddr) / sizeof(TCHAR) ))
            {
                StrCpyNW(szIPAddr, pszSite, cchSite + 1);
                // Check for names that are form of an IP address.
                fAddr = ReadAddress (szIPAddr, bAddr);
                if (fAddr)
                {
                    cchSite = wnsprintf(szIPAddr, ARRAYSIZE(szIPAddr), TEXT("%d.%d.%d.%d"), bAddr[0], bAddr[1], bAddr[2], bAddr[3]);
                    pszSite = szIPAddr;
                    return S_OK;
                }
            }

            // Scan backward for second '.' indicating domain,
            // ignoring two-char int'l domains like "co.uk" etc.

            DWORD cDot = 0;
            LPCTSTR pszDot = NULL;

            while (pszScan > pszSite)
            {
                if ( (*pszScan == DOT) && (pszScan < pszSite + cchSite - 2) )
                {
                    ++cDot;
                    if (cDot == 1)
                    {
                        pszDot = pszScan;
                    }
                    else if (   cDot == 2
                             && pszDot    // Non-null only the 1st time
                             && pszDot == pszSite + cchSite - 3   // Only check .?? ending
                             && pszScan + 3 >= pszDot)   // Check distance between the dots
                    {
                        // The distance between the 2 dots is less than 3 chars (.?? or smaller),
                        // so don't count this as a dot and don't check again.
                        --cDot;
                        pszDot = NULL;
                    }
                    else
                    {
                        pszDomain = pszScan + 1;
                        cchDomain = (DWORD) (pszSite + cchSite - pszDomain); 
                        cchSite = (DWORD) (pszScan - pszSite);
                        break;
                    }
                }
                pszScan--;
            }
        }
    }

    PerfDbgLog(tagZONEMAP_COMPONENTS, this, "-ZONEMAP_COMPONENTS::Crack");

    return S_OK;
}
    


// Function to get a new IInternetSecurityManager from outside. We might replace this
// with a standard class factory eventually.

STDAPI 
InternetCreateSecurityManager
(
    IUnknown * pUnkOuter,
    REFIID  riid,
    void **ppvObj,
    DWORD dwReserved
)
{
    PerfDbgLog(tagCSecurityManager, NULL, "+InternetCreateSecurityManager");
   
    HRESULT hr = S_OK;      
    *ppvObj = NULL;

    if ( !IsZonesInitialized() )
        return E_UNEXPECTED;

    if (dwReserved != 0 || !ppvObj || (pUnkOuter && riid != IID_IUnknown))
    {
        // If the object has to be aggregated the caller can only ask
        // for an IUnknown back.
        hr = E_INVALIDARG;
    }
    else 
    {
        CSecurityManager * pSecMgr = new CSecurityManager(pUnkOuter, (IUnknown **)ppvObj);

        if ( pSecMgr )
        {

            if (riid == IID_IUnknown || riid == IID_IInternetSecurityManager)
            {
                // The correct pointer is in ppvObj
                *ppvObj = (IInternetSecurityManager *)pSecMgr;
            }
            else 
            {
                hr = E_NOINTERFACE;
            }
        }
        else 
        {
            hr = E_OUTOFMEMORY;
        }
    }

    PerfDbgLog1(tagCSecurityManager, NULL, "-InternetCreateSecurityManager (hr:%lx)", hr);

    return hr;
}


// Class Initialization-Destruction.


CSecurityManager::CSecurityManager(IUnknown *pUnkOuter, IUnknown** ppUnkInner)
{
    PerfDbgLog(tagCSecurityManager, this, "+CSecurityManager::CSecurityManager");

    DllAddRef();

    m_pSite = NULL;
    m_pDelegateSecMgr = NULL;

    m_pZoneManager = NULL;
    
    if (!pUnkOuter)
    {
        pUnkOuter = &m_Unknown;
    }
    else
    {
        TransAssert(ppUnkInner);
        if (ppUnkInner)
        {
            *ppUnkInner = &m_Unknown;
            m_ref = 0;
        }
    }

    m_pUnkOuter = pUnkOuter;

    if (ERROR_SUCCESS != m_regZoneMap.Open (NULL, SZZONEMAP, KEY_READ))
        goto done;

    EnterCriticalSection(&s_csectIP);
    if (!s_bIPInit)
    {
        ReadAllIPRules();
        s_bIPInit = TRUE;
    }
    LeaveCriticalSection(&s_csectIP);
    
done:
    PerfDbgLog(tagCSecurityManager, this, "-CSecurityManager::CSecurityManager");
    return;
}


CSecurityManager::~CSecurityManager()
{
    // Due to a circular dependency between wininet and urlmon, this function 
    // could get called after the dlls global uninit has happened. PerfDbgLog depends on
    // some global Mutext objects and fails because of this reason.
    // PerfDbgLog(tagCSecurityManager, this, "+~CSecurityManager::CSecurityManager");

    if (m_pZoneManager != NULL)
        m_pZoneManager->Release();

    if (m_pSite != NULL)
        m_pSite->Release();

    if (m_pDelegateSecMgr != NULL)
        m_pDelegateSecMgr->Release();
    
    DllRelease();

    // PerfDbgLog(tagCSecurityManager, this, "-~CSecurityManager::CSecurityManager");
}

BOOL CSecurityManager::EnsureZoneManager()
{
    if (m_pZoneManager == NULL)
    {
        if (SUCCEEDED(InternetCreateZoneManager(NULL, 
                          IID_IInternetZoneManager, (void **)&m_pZoneManager, NULL)))
        {
            TransAssert(m_pZoneManager != NULL);
        }
    }
    
    return (m_pZoneManager != NULL);
}
                                
STDMETHODIMP CSecurityManager::CPrivUnknown::QueryInterface(REFIID riid, void** ppvObj)
{

    HRESULT hr = S_OK;
    
    *ppvObj = NULL;

    CSecurityManager * pSecurityManager = GETPPARENT(this, CSecurityManager, m_Unknown);
        
    if (riid == IID_IUnknown || riid == IID_IInternetSecurityManager)
    {
        *ppvObj = (IInternetSecurityManager *)pSecurityManager;
        pSecurityManager->AddRef();
    }
    else 
    {
        hr = E_NOINTERFACE;
    }

    
    return hr;
}
                
STDMETHODIMP_(ULONG) CSecurityManager::CPrivUnknown::AddRef()
{
    LONG lRet = ++m_ref;

    return lRet;
}

STDMETHODIMP_(ULONG) CSecurityManager::CPrivUnknown::Release()
{

    CSecurityManager *pSecurityManager = GETPPARENT(this, CSecurityManager, m_Unknown);

    LONG lRet = --m_ref;

    if (lRet == 0)
    {
        delete pSecurityManager;
    }

    return lRet;
}

HRESULT ReduceUrl(LPWSTR pwszSecUrl)
{
	HRESULT hr = S_OK;

	 // Reduce the URL here.  Need to do this up to two times.
        for (int i = 1; i <= 2; i++)
        {
            if (StrChr(pwszSecUrl, PERCENT))
            {
                DWORD dwSecUrl = lstrlenW(pwszSecUrl) + 1;
                UrlUnescapeW(pwszSecUrl, NULL, 0, URL_UNESCAPE_INPLACE);

                if (g_bUseImprovedZoneCheck
                    && (i == 1)
                    && (!StrCmpNIW(pwszSecUrl, L"http:", 5)
                        || !StrCmpNIW(pwszSecUrl, L"https:", 6)))
                 {
                    //For Windows 546559
                    //Imitate wininet behavior
                    DWORD cchIn = dwSecUrl +2; //two for the "//"
                    LPWSTR pwzTemp = new WCHAR[cchIn];
                    if (!pwzTemp)
                    {
                        hr = E_OUTOFMEMORY;
                        goto quit;
                    }

                    CFreeStrPtr freeStr(pwzTemp);

                    WCHAR ch;
                    int j=0;

                    do
                    {
                        ch = (pwzTemp[j] = pwszSecUrl[j]);
                        ++j;
                    }
                    while (ch != L':');

                    if (StrCmpNIW(pwszSecUrl+j, L"//", 2))
                        StrCpyNW(pwzTemp+j, L"//", cchIn-j);
                    else
                        pwzTemp[j] = L'\0';
                    StrCatBuffW(pwzTemp, pwszSecUrl+j, cchIn);                                
                    HRESULT hrLocal = UrlGetPartW(pwzTemp, pwszSecUrl, &dwSecUrl, URL_PART_HOSTNAME, URL_PARTFLAG_KEEPSCHEME);

                    DEBUG_PRINT(19,
                        INFO,
                        ("called UrlGetPartW %.100wq, %.100wq, hrLocal=0x%x\n",
                        pwzTemp, pwszSecUrl, hrLocal
                        ));

                    if (FAILED(hrLocal))
                    {
                        hr = hrLocal;
                        goto quit;
                    }
                }
            }
            else
                break;
        }

quit:
	return hr;
}

HRESULT CSecurityManager::WrapMapUrlToZone(LPCWSTR pwszSecUrl, ZONEMAP_COMPONENTS* pzc, DWORD* pdwZone, DWORD dwFlags,
                                BOOL *pfMarked, LPWSTR *ppszMarkURL)
{
    DEBUG_ENTER((DBG_API,
                Hresult,
                "CSecurityManager::WrapMapUrlToZone",
                "%.100wq, %#x, *pdwZone=%#x, dwFlags=%#x",
                pwszSecUrl, (pdwZone ? *pdwZone: 0), dwFlags
                ));

    HRESULT hr = S_OK;

    TransAssert (hr == S_OK);
    if (g_bUseImprovedZoneCheck
        && StrChr(pwszSecUrl, PERCENT)
        && (!StrCmpNIW(pwszSecUrl, L"http:", 5)
            || !StrCmpNIW(pwszSecUrl, L"https:", 6)))
    {
        //NOTICE: Windows 555438
        //Find the zone of twice unescaped url
        //to prevent zone inconsistencies,
        //between this and MapUrlToZone codepath
        ZONEMAP_COMPONENTS zc2;
        LPWSTR pwszRedSecUrl;
        DWORD dwSecUrl = lstrlenW(pwszSecUrl);
        pwszRedSecUrl = new WCHAR[dwSecUrl+1];
        StrCpyW(pwszRedSecUrl, pwszSecUrl);
        if (!pwszRedSecUrl)
        {
            DEBUG_LEAVE(E_OUTOFMEMORY);
            return E_OUTOFMEMORY;
        }
        CFreeStrPtr freeStr(pwszRedSecUrl);

        hr = ReduceUrl(pwszRedSecUrl);

        if (FAILED(hr))
        {
            DEBUG_LEAVE(hr);
            return hr;
        }

        hr = zc2.Crack(pwszRedSecUrl, dwFlags);

        if (FAILED(hr))
        {
            //consistent with behavior in GetSecurityId.
            DEBUG_LEAVE(E_INVALIDARG);
            return E_INVALIDARG;
        }

        hr = MapUrlToZone (&zc2, pdwZone, dwFlags, pfMarked, ppszMarkURL);

        TransAssert (hr == S_OK);
    }
    else
    {
        hr = MapUrlToZone (pzc, pdwZone, dwFlags, pfMarked, ppszMarkURL);

        TransAssert (hr == S_OK);
    }

    DEBUG_LEAVE(((hr == S_OK) ? *pdwZone : hr));
    return hr;
}

// IUnknown methods
STDMETHODIMP CSecurityManager::QueryInterface(REFIID riid, void **ppvObj)
{
    PerfDbgLog(tagCSecurityManager, this, "+CSecurityManager::QueryInterface");
    HRESULT hr = E_NOINTERFACE;

    *ppvObj = NULL;

    if (riid == IID_IUnknown || riid == IID_IInternetSecurityManager)
    {
        *ppvObj = (IInternetSecurityManager *)this;
    }

    if (*ppvObj != NULL)
    {
        ((IUnknown *)*ppvObj)->AddRef();
        hr = S_OK;
    }

    PerfDbgLog1(tagCSecurityManager, this, "-CSecurityManager::QueryInterface (hr:%lx)", hr);
    return hr;
}

STDMETHODIMP_(ULONG) CSecurityManager::AddRef()
{
    LONG lRet = m_pUnkOuter->AddRef();

    return lRet;
}

STDMETHODIMP_(ULONG) CSecurityManager::Release()
{                            
    LONG lRet = m_pUnkOuter->Release();

    // Controlling Unknown will delete the object if reqd.
        
    return lRet;
}

// IInternetSecurityManager methods

STDMETHODIMP 
CSecurityManager::MapUrlToZone
(
    LPCWSTR pwszUrl,
    DWORD *pdwZone,
    DWORD dwFlags
)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CSecurityManager::MapUrlToZone",
                "%.100wq, %#x, *pdwZone=%#x, dwFlags=%#x",
                pwszUrl, (pdwZone ? *pdwZone: 0), dwFlags
                ));
                
    PerfDbgLog(tagCSecurityManager, this, "+CSecurityManager::MapUrlToZone");
    HRESULT hr = INET_E_DEFAULT_ACTION;

    if (m_pDelegateSecMgr)
    {
        hr = m_pDelegateSecMgr->MapUrlToZone(pwszUrl, pdwZone, dwFlags);
    }

    // Check the cache to see if we already know the answer.
    /* BUGBUG - why are we stomping the delegate's result if we have a cache value?
    if ((NULL != m_pszPrevUrl) && (0 == StrCmpI(m_pszPrevUrl, pwszUrl)) && IsCounterEqual())
    { 
        hr = S_OK;
        *pdwZone = m_dwPrevZone;
    }
    */
            
    if (hr == INET_E_DEFAULT_ACTION)
    {
        LPWSTR pwszSecUrl = NULL;

        if (pdwZone == NULL || pwszUrl == NULL)
        {
            hr = E_INVALIDARG;
        }

        if (dwFlags & MUTZ_ENFORCERESTRICTED)
        {
            *pdwZone = URLZONE_UNTRUSTED;
            hr = S_OK;
        }
        else if (!s_smcache.Lookup(pwszUrl, pdwZone))
        {
            hr =  CoInternetGetSecurityUrl(pwszUrl, &pwszSecUrl, PSU_DEFAULT, 0);

            if (SUCCEEDED(hr))
            {
                TransAssert(pwszSecUrl);
                CFreeStrPtr freeStr(pwszSecUrl);

                hr = ReduceUrl(pwszSecUrl);

                if (FAILED(hr))
                {
                	goto quit;
                }

                ZONEMAP_COMPONENTS zc;
                if (SUCCEEDED(hr = zc.Crack (pwszSecUrl, dwFlags)))
                {
                    BOOL fMarked;

                    hr = MapUrlToZone (&zc, pdwZone, dwFlags, &fMarked);

                    if (hr == S_OK && !(dwFlags & MUTZ_NOCACHE))
                    {
                        s_smcache.Add(pwszUrl, *pdwZone, fMarked ); 
                    }
                }
            }
        }
        else 
        {
            hr = S_OK;
        }
    }

quit:
    PerfDbgLog1(tagCSecurityManager, this, "-CSecurityManager::MapUrlToZone (hr:%lx)", hr);

    DEBUG_LEAVE( (SUCCEEDED(hr) ? *pdwZone : hr));
    return hr;
}    

VOID 
CSecurityManager::PickZCString(ZONEMAP_COMPONENTS *pzc, LPCWSTR *ppwsz, DWORD *pcch, LPCWSTR pwszDocDomain)
{
    if (pzc->cchDomain)
    {
        TransAssert (!pzc->fDrive);
        // We should use the whole site even if we were able to get the
        // primary domain. i.e. security id for http://www.microsoft.com 
        // should be http:www.microsoft.com and NOT http:microsoft.com
        // We will use the fact that the domain and site are actually
        // pointing into one contiguous string to get back at the 
        // whole string.
        TransAssert((pzc->cchSite + 1) == (DWORD)(pzc->pszDomain - pzc->pszSite));
        TransAssert(pzc->pszSite[pzc->cchSite] == DOT);
        *ppwsz = pzc->pszSite;
        *pcch = pzc->cchSite + pzc->cchDomain + 1;
    }
    else if (pzc->fDrive && pzc->dwDriveType != DRIVE_REMOTE)
    {
        *ppwsz = TEXT("");
        *pcch = 0;
    }
    else if (pzc->nScheme == URL_SCHEME_FILE)
    {
        // For URL's of the nature \\server\sharename we want to include both the server and sharename in 
        // the security ID. This permits me from looking at \\server\private by putting up a page on 
        // \\server\public  At thuis point pzc->pszSite should point to the string "server\private\foo.htm"

        LPCTSTR lpszCurr = pzc->pszSite;
        BOOL bFoundFirstSlash = FALSE;
        
        for (; *lpszCurr != NULL ; lpszCurr++)
        {
            if (*lpszCurr == SLASH || *lpszCurr == BACKSLASH)
            {
                if (bFoundFirstSlash)
                {
                    // This is the second slash we are done.
                    break;
                }
                else
                {
                    bFoundFirstSlash = TRUE;
                }
            }
        }
                                        
        *ppwsz = pzc->pszSite;

        if (lpszCurr != NULL)
        {
            *pcch = (DWORD)(lpszCurr - pzc->pszSite);
        }
        else
        {
            TransAssert(FALSE);
            *pcch = pzc->cchSite;
        }
    }
    else
    {
        TransAssert (!pzc->pszDomain && !pzc->cchDomain);
        *ppwsz = pzc->pszSite;
        *pcch = pzc->cchSite;
    }

    // If the domain string passed is a suffix of the site string we will 
    // use that string instead.
    if (*pcch && pwszDocDomain != 0)
    {
        DWORD cchDocDomain = lstrlenW(pwszDocDomain);

        if (*pcch > cchDocDomain && 
            (0 == StrCmpNICW(pwszDocDomain, &((*ppwsz)[*pcch - cchDocDomain]), cchDocDomain)))
        {
            *ppwsz = pwszDocDomain;
            *pcch = cchDocDomain;
        }
    }   
}

STDMETHODIMP
CSecurityManager::GetSecurityId
(
        /* [in] */ LPCWSTR pwszUrl,
        /* [size_is][out] */ BYTE* pbSecurityId,
        /* [out][in] */ DWORD *pcbSecurityId,
        /* [in] */ DWORD_PTR dwReserved
)
{
    DEBUG_ENTER((DBG_API,
                Hresult,
                "CSecurityManager::GetSecurityId",
                "%.100wq",
                pwszUrl
                ));

    PerfDbgLog(tagCSecurityManager, this, "Called CSecurityManager::GetSecurityId");
    HRESULT hr = INET_E_DEFAULT_ACTION;
    DWORD       dwZone;

    // Check args ...
    if (pwszUrl == NULL || !pwszUrl[0] || !pcbSecurityId )
    {
        DEBUG_LEAVE(E_INVALIDARG);
        return E_INVALIDARG;
    }

    if (m_pDelegateSecMgr)
    {
        hr = m_pDelegateSecMgr->GetSecurityId(pwszUrl, pbSecurityId, pcbSecurityId, dwReserved);
    }

    if (hr == INET_E_DEFAULT_ACTION)
    {
        BOOL fFoundInCache;
        BOOL        fMarked = FALSE;
        DWORD       cbSecurityID = *pcbSecurityId;

        fFoundInCache = s_smcache.Lookup(pwszUrl, &dwZone, &fMarked, pbSecurityId, &cbSecurityID, (LPCWSTR)dwReserved);

        // if it wasn't in the cache, or the url and zone were there, but not the security ID,
        // then we still need to do some work.
        if ( !fFoundInCache || cbSecurityID == 0 )
        {
            LPWSTR pwszSecUrl = NULL;
            DWORD dwFlags = 0;

            hr = CoInternetGetSecurityUrl(pwszUrl, &pwszSecUrl, PSU_DEFAULT, 0);

            if (SUCCEEDED(hr))
            {
                TransAssert(pwszSecUrl != NULL);
                CFreeStrPtr freeStr(pwszSecUrl);

                // Crack the URL.
                ZONEMAP_COMPONENTS zc;
                LPWSTR pwszMarkURL = NULL;
                LPWSTR pwszSecUrl2 = NULL;

                if (S_OK != zc.Crack (pwszSecUrl, dwFlags))
                {
                    DEBUG_LEAVE(E_INVALIDARG);
                    return E_INVALIDARG;
                }
                
                // Select middle portion of Id.
                LPCWSTR psz2;
                DWORD  cch2;

                PickZCString(&zc, &psz2, &cch2, (LPCWSTR)dwReserved);
                // Identify the zone and determine if the ID will bear the 
                // Mark of the Web.
                
                // if the url was found in the cache, the an earlier MapUrlToZone
                // put it there with its zone and Marked flag, 
                if (!fFoundInCache || fMarked)
                {
                    hr = WrapMapUrlToZone (pwszSecUrl, &zc, &dwZone, 0, &fMarked, &pwszMarkURL);

                    if (hr != S_OK)
                    {
                        DEBUG_LEAVE(hr);
                        return hr;
                    }
                    // If the Mark of the Web is present, then take the Mark URL
                    // and substitute it for the original one in the zc, this will
                    // allow us to create a security ID that embodies the original
                    // domain, which in turn allows us to recreate the cross-domain
                    // frame security. The '*' we add to the end will prevent a
                    // potentially compromised page on the user's disk from accessing
                    // frames of the live, original site if the two should wind up
                    // in the same frameset.
                    if (fMarked)
                    {
                        TransAssert(pwszMarkURL != NULL);

                        hr = CoInternetGetSecurityUrl(pwszMarkURL, &pwszSecUrl2, PSU_DEFAULT, 0);

                        if (SUCCEEDED(hr))
                        {
                            TransAssert(pwszSecUrl2 != NULL);

                            if(SUCCEEDED(zc.Crack (pwszSecUrl2, dwFlags)))
                                PickZCString(&zc, &psz2, &cch2, (LPCWSTR)dwReserved);
                            else
                            {
                                if (pwszSecUrl2)  delete [] pwszSecUrl2;
                                if (pwszMarkURL)  LocalFree(pwszMarkURL);

                                DEBUG_LEAVE(E_INVALIDARG);
                                return E_INVALIDARG;
                            }
                        }
                    }
                }

                // Calculate required size of buffer.
                DWORD cbTail = sizeof(DWORD) + ((fMarked)? sizeof(CHAR) : 0);
                DWORD cbSite = 0;

                if (cch2 != 0)
                {
                    cbSite = WideCharToMultiByte(CP_ACP, 0, psz2, cch2,
                            NULL, 0, NULL, NULL);
                    if (cbSite == 0)
                    {
                        hr = HRESULT_FROM_WIN32(GetLastError());
                        DEBUG_LEAVE(hr);
                        return hr;
                    }
                }

                DWORD cbRequired = zc.cchProtocol + 1 + cbSite + cbTail;

                if (*pcbSecurityId < cbRequired)
                {
                    *pcbSecurityId = cbRequired;
                    hr = HRESULT_FROM_WIN32 (ERROR_INSUFFICIENT_BUFFER);
                    DEBUG_LEAVE(hr);
                    return hr;
                }

                // Emit the protocol in ANSI.
                DWORD cbOut;
                cbOut = WideCharToMultiByte (CP_ACP, 0, zc.pszProtocol, zc.cchProtocol,
                    (LPSTR) pbSecurityId, *pcbSecurityId, NULL, NULL);
                if (cbOut != zc.cchProtocol)
                {
                    DEBUG_LEAVE(E_INVALIDARG);
                    return E_INVALIDARG; // non-ascii chars illegal in URL scheme
                }
                pbSecurityId[cbOut++] = ':';

                // Emit the site/domain in ANSI.
                if (cch2 != 0)
                {
                    cbSite = WideCharToMultiByte (CP_ACP, 0, psz2, cch2,
                        (LPSTR) pbSecurityId + cbOut, *pcbSecurityId - cbOut, NULL, NULL);
                }


                // HACK: Need to figure out a better way to fix this. 
                // File: url's can come in with slashes and backslashes as seperators.
                // To prevent things from breaking we replace any slashes in the 
                // pbSecurityId with a backslash.
                if (zc.nScheme == URL_SCHEME_FILE && cch2 != 0)
                {
                    LPSTR lpszStart = (LPSTR)pbSecurityId + cbOut;
                    LPSTR lpsz = lpszStart;

                    while (lpsz < lpszStart + cbSite)
                    {
                        if (*lpsz == '/')
                            *lpsz = '\\';

                        lpsz = CharNextA(lpsz);
                    }
                }

                cbOut += cbSite;

                // Downcase the buffer.
                pbSecurityId[cbOut] = 0;
                CharLowerA ((LPSTR) pbSecurityId);

                // Add the zone.
                memcpy(pbSecurityId + cbOut, &dwZone, sizeof(DWORD));

                if (fMarked)
                {
                    CHAR chMark = WILDCARD;
                    memcpy(pbSecurityId + cbOut + sizeof(DWORD), &chMark, sizeof(CHAR));
                }

                // Report the output data size.
                *pcbSecurityId = cbRequired;

                // Now that we have all the pieces, (re)add it to the cache
                s_smcache.Add(pwszUrl, dwZone, fMarked, pbSecurityId, cbRequired, (LPCWSTR)dwReserved);

                if (pwszSecUrl2)
                    delete [] pwszSecUrl2 ;

                if (pwszMarkURL)
                    LocalFree(pwszMarkURL);

            } // got security URL 
            
        } // got security URL
        else
        {
            // Got it from the cache.
            *pcbSecurityId = cbSecurityID;
            hr = S_OK;
        }
    } // delegate missing or wants us to do the work

    DEBUG_LEAVE(((hr == S_OK)? dwZone : hr));
    return hr;
}


// Helper functions to do generic UI from within ProcessUrlAction.

struct ActionStrIDMap 
{
    DWORD dwAction;
    DWORD dwStrID;
};

ActionStrIDMap actionAlertIDMap [ ]  = 
{
    { URLACTION_DOWNLOAD_SIGNED_ACTIVEX,            IDS_ACTION_DL_SIGNED_ACTIVEX        },
    { URLACTION_DOWNLOAD_UNSIGNED_ACTIVEX,          IDS_ACTION_DL_ACTIVEX               },

    { URLACTION_ACTIVEX_RUN,                        IDS_ACTION_AX_RUN                   },
    { URLACTION_ACTIVEX_OVERRIDE_OBJECT_SAFETY,     IDS_ACTION_AX_OVERRIDE_SAFETY       },
    { URLACTION_ACTIVEX_OVERRIDE_DATA_SAFETY,       IDS_ACTION_AX_OVERRIDE_DATA_SAFETY  },
    { URLACTION_ACTIVEX_OVERRIDE_SCRIPT_SAFETY,     IDS_ACTION_AX_OVERRIDE_SCRIPT_SAFETY},
    { URLACTION_ACTIVEX_CONFIRM_NOOBJECTSAFETY,     IDS_ACTION_AX_CONFIRM_NOSAFETY      },

    { URLACTION_SCRIPT_RUN,                         IDS_ACTION_SCRIPT_RUN               },
    { URLACTION_SCRIPT_OVERRIDE_SAFETY,             IDS_ACTION_SCRIPT_OVERRIDE_SAFETY   },
    { URLACTION_SCRIPT_JAVA_USE,                    IDS_ACTION_SCRIPT_JAVA              },
    { URLACTION_SCRIPT_SAFE_ACTIVEX,                IDS_ACTION_SCRIPT_SAFE_ACTIVEX      },
    { URLACTION_CROSS_DOMAIN_DATA,                  IDS_ACTION_CROSS_DOMAIN_DATA        },
    { URLACTION_SCRIPT_PASTE,                       IDS_ACTION_SCRIPT_PASTE             },

    { URLACTION_HTML_SUBMIT_FORMS,                  IDS_ACTION_HTML_FORMS               },
    { URLACTION_HTML_SUBMIT_FORMS_FROM,             IDS_ACTION_HTML_FORMS               },
    { URLACTION_HTML_SUBMIT_FORMS_TO,               IDS_ACTION_HTML_FORMS               },
    { URLACTION_HTML_FONT_DOWNLOAD,                 IDS_ACTION_HTML_FONT_DL             },
    { URLACTION_HTML_JAVA_RUN,                      IDS_ACTION_HTML_JAVA                },
    { URLACTION_HTML_USERDATA_SAVE,                 IDS_ACTION_HTML_USERDATA            },
    { URLACTION_HTML_SUBFRAME_NAVIGATE,             IDS_ACTION_HTML_SUBFRAME_NAVIGATE   },
    { URLACTION_HTML_META_REFRESH,                  IDS_ACTION_HTML_META_REFRESH        },
    { URLACTION_HTML_MIXED_CONTENT,                 IDS_ACTION_HTML_MIXED_CONTENT            },

    { URLACTION_SHELL_INSTALL_DTITEMS,              IDS_ACTION_SHELL_INSTALL_DTITEMS    }, 
    { URLACTION_SHELL_MOVE_OR_COPY,                 IDS_ACTION_SHELL_MOVE_OR_COPY       },
    { URLACTION_SHELL_FILE_DOWNLOAD,                IDS_ACTION_SHELL_FILE_DL            },
    { URLACTION_SHELL_VERB,                         IDS_ACTION_SHELL_VERB               },
    { URLACTION_SHELL_WEBVIEW_VERB,                 IDS_ACTION_SHELL_WEBVIEW_VERB       },

    { URLACTION_CREDENTIALS_USE,                    IDS_ACTION_NW_CREDENTIALS           },
    { URLACTION_AUTHENTICATE_CLIENT,                IDS_ACTION_NW_AUTH_CLIENT           },
    { URLACTION_COOKIES,                            IDS_ACTION_NW_COOKIES               },
    { URLACTION_COOKIES_SESSION,                    IDS_ACTION_NW_COOKIES_SESSION       },
    { URLACTION_CLIENT_CERT_PROMPT,                 IDS_ACTION_NW_CLIENT_CERT_PROMPT    },
    { URLACTION_COOKIES_THIRD_PARTY,                IDS_ACTION_NW_COOKIES_THIRD_PARTY   },
    { URLACTION_COOKIES_SESSION_THIRD_PARTY,        IDS_ACTION_NW_COOKIES_SESSION_THIRD_PARTY },
};

ActionStrIDMap actionWarnIDMap [ ]  = 
{
    { URLACTION_SHELL_INSTALL_DTITEMS,              IDS_WARN_SHELL_INSTALL_DTITEMS      }, 
    { URLACTION_SHELL_MOVE_OR_COPY,                 IDS_WARN_SHELL_MOVE_OR_COPY         },
    { URLACTION_SHELL_FILE_DOWNLOAD,                IDS_WARN_SHELL_FILE_DL              },
    { URLACTION_SHELL_VERB,                         IDS_WARN_SHELL_VERB                 },
    { URLACTION_SHELL_WEBVIEW_VERB,                 IDS_WARN_SHELL_WEBVIEW_VERB         },

    { URLACTION_HTML_SUBMIT_FORMS,                  IDS_WARN_HTML_FORMS                 },
    { URLACTION_HTML_SUBMIT_FORMS_FROM,             IDS_WARN_HTML_FORMS                 },
    { URLACTION_HTML_SUBMIT_FORMS_TO,               IDS_WARN_HTML_FORMS                 },
};   

STDMETHODIMP_(DWORD)
CSecurityManager::GetAlertIdForAction(DWORD dwAction)
{
    // The action should exist in our map.
    int count = ARRAYSIZE(actionAlertIDMap);

    for ( int i = 0 ; i < count ; i++ )
    {
        if (actionAlertIDMap[i].dwAction == dwAction)
        {
            return actionAlertIDMap[i].dwStrID;
        }
    }

    // If we get here the Action was invalid or we are missing an
    // entry in the map.
    TransAssert(FALSE);

    return IDS_ACTION_UNKNOWN;
}

STDMETHODIMP_(DWORD)
CSecurityManager::GetWarnIdForAction(DWORD dwAction)
{
    // The action should exist in our map.
    int count = ARRAYSIZE(actionWarnIDMap);

    for ( int i = 0 ; i < count ; i++ )
    {
        if (actionWarnIDMap[i].dwAction == dwAction)
        {
            return actionWarnIDMap[i].dwStrID;
        }
    }

    // If we get here the Action was invalid or we are missing an
    // entry in the map.
    TransAssert(FALSE);

    return IDS_WARN_UNKNOWN;
}

// INFRASTRUCTURE FOR REMEMBERING ANSWERS.
 
// Are the answers for this action supposed to persist. i.e. if the user says 'Yes' or 'No' for 
// these actions we will not requery them for the same URL for the duration of the security 
// manager.  

BOOL
CSecurityManager::CPersistAnswers::IsPersistentAnswerAction(DWORD dwAction)
{
    switch (dwAction)
    {
        case URLACTION_ACTIVEX_RUN:
        // This shouldn't happen because it is an aggregator
        case URLACTION_ACTIVEX_OVERRIDE_OBJECT_SAFETY:
        // These should never get called because of KludgeMapAggregatePolicy
        case URLACTION_ACTIVEX_OVERRIDE_DATA_SAFETY:
        case URLACTION_ACTIVEX_OVERRIDE_SCRIPT_SAFETY:
        case URLACTION_SCRIPT_OVERRIDE_SAFETY:

        case URLACTION_ACTIVEX_CONFIRM_NOOBJECTSAFETY:
        case URLACTION_SCRIPT_RUN:
        case URLACTION_SCRIPT_JAVA_USE:
        case URLACTION_HTML_FONT_DOWNLOAD:
        case URLACTION_SCRIPT_SAFE_ACTIVEX:
        case URLACTION_CROSS_DOMAIN_DATA:
            return TRUE;
        default:
            return FALSE;
    }
}

// CAnswerEntry methods. 

CSecurityManager::CPersistAnswers::CAnswerEntry::CAnswerEntry(LPCWSTR pszUrl, DWORD dwAction, BOOL iAnswer)
{
    m_pNext = NULL;
    m_dwAction = dwAction;
    m_iAnswer = iAnswer;
    m_pszUrl = StrDup(pszUrl);
}

CSecurityManager::CPersistAnswers::CAnswerEntry::~CAnswerEntry( )
{
    if (m_pszUrl)
        LocalFree(m_pszUrl);           
}

BOOL CSecurityManager::CPersistAnswers::CAnswerEntry::MatchEntry(LPCWSTR pszUrl, DWORD dwAction)
{
    return (dwAction == m_dwAction && (0 == StrCmp(pszUrl, m_pszUrl)));
}

// CPersistAnswers methods.
CSecurityManager::CPersistAnswers::~CPersistAnswers( )
{
    // go through the CAnswerEntries and free them up. 
    CAnswerEntry * pEntry = m_pAnswerEntry;

    while ( pEntry )
    {
        CAnswerEntry * pDelete = pEntry;
        pEntry = pEntry->GetNext( );
        delete pDelete;
    }
}                    

// Returns TRUE if the user already answered this questions. FALSE otherwise.
// 
BOOL CSecurityManager::CPersistAnswers::GetPrevAnswer(LPCWSTR pszUrl, DWORD dwAction, INT* piAnswer)
{
    BOOL bReturn = FALSE;
    CAnswerEntry * pAnswerEntry;

    if (!IsPersistentAnswerAction(dwAction))
        return FALSE;
                 
    for (pAnswerEntry = m_pAnswerEntry ; pAnswerEntry != NULL; pAnswerEntry = pAnswerEntry->GetNext())
    {
        if (pAnswerEntry->MatchEntry(pszUrl, dwAction))
        {
            if (piAnswer)
                *piAnswer = pAnswerEntry->GetAnswer( );

            bReturn = TRUE;
            break;
        }
    }

    return bReturn;
}

VOID CSecurityManager::CPersistAnswers::RememberAnswer(LPCWSTR pszUrl, DWORD dwAction, BOOL iAnswer)
{
    // Nothing to do if we are not supposed to be persisted. 
    if (!IsPersistentAnswerAction(dwAction))
        return;

    TransAssert(!GetPrevAnswer(pszUrl, dwAction, NULL));

    CAnswerEntry * pNew = new CAnswerEntry(pszUrl, dwAction, iAnswer);
    // Just don't persist answers if we don't have memory. 
    if (pNew == NULL || pNew->GetUrl() == NULL)
        return;

    pNew->SetNext(m_pAnswerEntry);
    m_pAnswerEntry = pNew;
    return;
}

// This is the dialog proc for the generic Zones Alert dialog. 
// IMPORTANT: This is an ANSI function in an otherwise unicode world.
// BE EXTREMELY CAREFUL WHEN CALLING WINDOWS API FUNCTIONS.

INT_PTR
CSecurityManager::ZonesAlertDialogProc(HWND hDlg, UINT iMsg, WPARAM wParam, LPARAM lParam)
{
    switch (iMsg)
    {
        case WM_INITDIALOG:
        {
            WCHAR  rgszAlert[MAX_ALERT_SIZE];
            LPDLGDATA lpDlgData = (LPDLGDATA)lParam;
            TransAssert(lpDlgData != NULL);

            DWORD dwStrId = GetAlertIdForAction(lpDlgData->dwAction);


            if (::LoadStringWrapW(g_hInst, dwStrId, rgszAlert, MAX_ALERT_SIZE) == 0)
            {
                TransAssert(FALSE);
                ::LoadStringWrapW(g_hInst, IDS_ACTION_UNKNOWN, rgszAlert, MAX_ALERT_SIZE);
            }

            HWND hwndAlertText = ::GetDlgItem(hDlg, IDC_ZONEALERTTEXT);

            TransAssert(hwndAlertText != NULL);
            ::SetWindowTextWrapW(hwndAlertText, rgszAlert);

            if (lpDlgData->dwFlags & PUAF_FORCEUI_FOREGROUND)
            {
                SetForegroundWindow(hDlg);
            }

            // ensure that this window is topmost
            SetWindowPos(hDlg, HWND_TOPMOST, 0, 0, 0, 0, SWP_NOSIZE | SWP_NOMOVE);

            return TRUE;
        }
        case WM_COMMAND:
            switch (LOWORD(wParam))
            {
                case IDOK:
                    EndDialog(hDlg, ZALERT_YES);
                    return TRUE;
                case IDCANCEL:
                    EndDialog(hDlg, ZALERT_NO);
                    return TRUE;
            }

            break;
    }  /* end switch */

    return FALSE;
}

// This is the dialog proc for the Alert displayed when information is posted over the net.
// This is a special case, since it is the only dialog where we let the user persist their change. 
// DO NOT START ADDING OTHER SPECIAL CASES TO THIS. IF YOU NEED TO, CONSIDER CHANGING THE 
// THE TEMPLATE POLICY FOR THE ZONE TO BE "CUSTOM" BECAUSE THE ZONE WILL START DIVERGING FROM
// THE TEMPLATE IT IS SUPPOSED TO BE BASED ON.

BOOL
CSecurityManager::IsFormsSubmitAction(DWORD dwAction)
{
    return (dwAction == URLACTION_HTML_SUBMIT_FORMS ||
            dwAction == URLACTION_HTML_SUBMIT_FORMS_FROM || 
            dwAction == URLACTION_HTML_SUBMIT_FORMS_TO
           );
}
            
INT_PTR
CSecurityManager::FormsAlertDialogProc(HWND hDlg, UINT iMsg, WPARAM wParam, LPARAM lParam)
{
    switch (iMsg)
    {
        case WM_INITDIALOG:
        {
            LPDLGDATA lpDlgData = (LPDLGDATA)lParam;
            TransAssert(lpDlgData != NULL);
            LPWSTR pstr = lpDlgData->pstr;
            
            if (pstr != NULL)
            {
                HWND hwnd = ::GetDlgItem(hDlg, IDC_ZONEALERTTEXT);
                TransAssert(hwnd != NULL);
                ::SetWindowTextWrapW(hwnd, pstr);
            }  
              
            if (lpDlgData->dwFlags & PUAF_FORCEUI_FOREGROUND)
            {
                SetForegroundWindow(hDlg);
            }

            if(!(lpDlgData->dwFlags & PUAF_DONTCHECKBOXINDIALOG))
            {
                CheckDlgButton(hDlg, IDC_DONT_WANT_WARNING, BST_CHECKED);
            }
            return TRUE;
        }
        case WM_COMMAND:
            switch (LOWORD(wParam))
            {
                case IDOK:
                case IDYES:
                {
                    DWORD dwRet;
                    if (IsDlgButtonChecked(hDlg, IDC_DONT_WANT_WARNING) == BST_CHECKED)
                        dwRet = ZALERT_YESPERSIST;
                    else 
                        dwRet = ZALERT_YES;

                    EndDialog(hDlg, dwRet);
                    return TRUE;
                }

                case IDCANCEL:
                case IDNO:
                    EndDialog(hDlg, ZALERT_NO);
                    return TRUE;
            }

            break;
    }  /* end switch */

    return FALSE;
}

INT 
CSecurityManager::ShowFormsAlertDialog(HWND hwndParent, LPDLGDATA lpDlgData )
{
    int nRet;
    TransAssert(lpDlgData != NULL);
    TransAssert(IsFormsSubmitAction(lpDlgData->dwAction));

    // Compose the dialog string.
    LPWSTR pstr = NULL;
    WCHAR rgch[MAX_ALERT_SIZE]; 

    ZONEATTRIBUTES zc;
    zc.cbSize = sizeof(zc);
    if (SUCCEEDED(m_pZoneManager->GetZoneAttributes(lpDlgData->dwZone, &zc)))
    {
        WCHAR rgchStr[MAX_ALERT_SIZE];
        UINT uID = (lpDlgData->dwAction == URLACTION_HTML_SUBMIT_FORMS_FROM) ? IDS_ACTION_POST_FROM : IDS_ACTION_FORMS_POST;

        if (::LoadStringWrapW(g_hInst, uID, rgchStr, MAX_ALERT_SIZE) != 0)
        {
            if (wnsprintfW(rgch, MAX_ALERT_SIZE, rgchStr, zc.szDisplayName) != 0)
                pstr = rgch;
        }
    }

    lpDlgData->pstr = pstr;
    ULONG_PTR uCookie = 0;
    SHActivateContext(&uCookie);
    nRet =  (int) ::DialogBoxParamWrapW (
                        g_hInst,
                        MAKEINTRESOURCEW(IDD_WARN_ON_POST),
                        hwndParent,
                        CSecurityManager::FormsAlertDialogProc,
                        (LPARAM)lpDlgData
                    );
    if (uCookie)
    {
        SHDeactivateContext(uCookie);
    }

    return nRet;
}
    
INT_PTR
CSecurityManager::ZonesWarnDialogProc(HWND hDlg, UINT iMsg, WPARAM wParam, LPARAM lParam)
{
    switch (iMsg)
    {
        case WM_INITDIALOG:
        {
            WCHAR  rgszWarn[MAX_ALERT_SIZE];
            LPDLGDATA lpDlgData = (LPDLGDATA)lParam;
            TransAssert(lpDlgData != NULL);
            DWORD dwAction = lpDlgData->dwAction;
            DWORD dwStrId = GetWarnIdForAction(dwAction);

            if (::LoadStringWrapW(g_hInst, dwStrId, rgszWarn, MAX_ALERT_SIZE) == 0)
            {
                TransAssert(FALSE);
                ::LoadStringWrapW(g_hInst, IDS_WARN_UNKNOWN, rgszWarn, MAX_ALERT_SIZE);
            }

            HWND hwndWarnText = ::GetDlgItem(hDlg, IDC_ZONEALERTTEXT);

            TransAssert(hwndWarnText != NULL);
            ::SetWindowTextWrapW(hwndWarnText, rgszWarn);

            if (lpDlgData->dwFlags & PUAF_FORCEUI_FOREGROUND)
            {
                SetForegroundWindow(hDlg);
            }

            return TRUE;
        }
        case WM_COMMAND:
            switch (LOWORD(wParam))
            {
                case IDOK:
                case IDCANCEL:
                    EndDialog(hDlg, ZALERT_YES);
                    return TRUE;
            }

            break;
    }  /* end switch */

    return FALSE;
}
            


STDMETHODIMP
CSecurityManager::ProcessUrlAction
(
    LPCWSTR pwszUrl,
    DWORD dwAction,
    BYTE * pPolicy,
    DWORD cbPolicy,
    BYTE * pContext,
    DWORD cbContext,
    DWORD dwFlags,
    DWORD dwReserved
)
{
    DEBUG_ENTER((DBG_API,
                Hresult,
                "CSecurityManager::ProcessUrlAction",
                "%.100wq, %#x, dwFlags=%#x, dwReserved=%#x",
                pwszUrl, dwAction, dwFlags, dwReserved
                ));
                    
    PerfDbgLog(tagCSecurityManager, this, "+CSecurityManager::ProcessUrlAction");
    HRESULT hr = INET_E_DEFAULT_ACTION;
    DWORD dwZone = ZONEID_INVALID;


// First check if the delegation interface wants to handle this.
    if (m_pDelegateSecMgr)
    {
        hr = m_pDelegateSecMgr->ProcessUrlAction(pwszUrl, dwAction, pPolicy, cbPolicy, pContext, cbContext, dwFlags, dwReserved);
    }

    if (hr != INET_E_DEFAULT_ACTION)
    {
        // Delegation interface processed the request.
        DEBUG_LEAVE(hr);
        return hr;
    }

    if (!EnsureZoneManager())
    {
        DEBUG_LEAVE(E_UNEXPECTED);
        return E_UNEXPECTED;
    }

    // Increment our refcount so we don't get destroyed for the duration of this 
    // function.
    AddRef();

    if (dwFlags & PUAF_ENFORCERESTRICTED)
    {
        dwZone = URLZONE_UNTRUSTED;
        hr = S_OK;
    }        
    else
    {
        hr = MapUrlToZone(pwszUrl, &dwZone, dwFlags);
    }        

     
    if (SUCCEEDED(hr))
    {
        DWORD dwPolicy;

        hr = m_pZoneManager->GetZoneActionPolicy(dwZone, dwAction, (BYTE *)&dwPolicy, sizeof(dwPolicy), URLZONEREG_DEFAULT);        

        if (SUCCEEDED(hr))
        {
            DWORD dwPermissions = GetUrlPolicyPermissions(dwPolicy);

            // Are we supposed to be showing any UI here?
            if ( (( dwPermissions == URLPOLICY_QUERY && ( dwFlags & PUAF_NOUI) == 0 ) || 
                  ( dwPermissions == URLPOLICY_DISALLOW && ( dwFlags & PUAF_WARN_IF_DENIED) != 0))
                 && HIWORD(dwPolicy) == 0)
            {
                HWND hwndParent = NULL;
                // Show UI unless the host indicates otherwise.
                BOOL bShowUI = TRUE;
                if  (m_pSite != NULL)
                {
                    HRESULT hrGetWnd = m_pSite->GetWindow(&hwndParent);

                    // Host doesn't want us to show UI.
                    if (hrGetWnd == S_FALSE && hwndParent == INVALID_HANDLE_VALUE)
                        bShowUI = FALSE;
                    else if (FAILED(hrGetWnd))
                        hwndParent = NULL;

                    // Disable any modeless dialog boxes
                    m_pSite->EnableModeless(FALSE);
                }

                int nRet = -1;
                BOOL fRememberAnswer = FALSE;

                // structure used to pass information to the dialog proc's.
                DlgData dlgData;
                dlgData.dwAction = dwAction;
                dlgData.dwZone = dwZone;
                dlgData.pstr = NULL;
                dlgData.dwFlags = dwFlags | ((dwPolicy & URLPOLICY_DONTCHECKDLGBOX) ? PUAF_DONTCHECKBOXINDIALOG : 0);
                dwPolicy = dwPolicy & ~URLPOLICY_DONTCHECKDLGBOX; 
                if ( dwPermissions == URLPOLICY_QUERY )
                { 
                    // First check to see if the user already answered this question once.                
                    if (!m_persistAnswers.GetPrevAnswer(pwszUrl, dwAction, &nRet))
                    {

                        fRememberAnswer = TRUE;

                        if (!bShowUI)
                        {
                            // If we can't show UI just act as if the user said No.
                            nRet = ZALERT_NO;   
                        }
                        else if (IsFormsSubmitAction(dwAction))
                        {
                            nRet = ShowFormsAlertDialog(hwndParent, &dlgData);
                        }
                        else
                        {
                            ULONG_PTR uCookie = 0;
                            SHActivateContext(&uCookie);
                            nRet = (int) ::DialogBoxParamWrapW (
                                            g_hInst,
                                            MAKEINTRESOURCEW(IDD_ZONE_ALERT),
                                            hwndParent,
                                            CSecurityManager::ZonesAlertDialogProc,
                                            (LPARAM)&dlgData
                                        );
                            if (uCookie)
                            {
                                SHDeactivateContext(uCookie);
                            }
                        }
                    }
                }
                else 
                {
                    TransAssert(dwPermissions == URLPOLICY_DISALLOW);
                    if (bShowUI)
                    {
                        ULONG_PTR uCookie = 0;
                        SHActivateContext(&uCookie);
                        nRet = (int) ::DialogBoxParamWrapW (
                                        g_hInst,
                                        MAKEINTRESOURCEW(IDD_WARN_ALERT),
                                        hwndParent,
                                        CSecurityManager::ZonesWarnDialogProc,
                                        (LPARAM)&dlgData
                                    );
                        if (uCookie)
                        {
                            SHDeactivateContext(uCookie);
                        }
                    }
                }



                // If we failed to show the dialog we should just return
                // the policies unmodified.
                if (dwPermissions == URLPOLICY_QUERY && nRet != -1 )
                {
                    // Change the policy to reflect the users choice.
                    DWORD dwYesOnlyPolicy;
                    dwYesOnlyPolicy = dwPolicy | URLPOLICY_DONTCHECKDLGBOX; // copy old policy before it is changed  
                    
                    SetUrlPolicyPermissions(dwPolicy, nRet ? URLPOLICY_ALLOW : URLPOLICY_DISALLOW);
                   

                    if (fRememberAnswer)
                        m_persistAnswers.RememberAnswer(pwszUrl, dwAction, nRet);

                    // The only case where we should change the policy is we have a checkbox on the dialog
                    // we popped up that says "Don't ask me again". Today the only thing that does that is 
                    // the forms submit form. 
                    // TODO: create a more generic category name "CanDlgChangePolicy" or something like that
                    // instead of the specific IsFormsSubmitAction.

                    if (IsFormsSubmitAction(dwAction) && ((nRet == ZALERT_YESPERSIST) || (nRet == ZALERT_YES)))
                    {
                        
                        m_pZoneManager->SetZoneActionPolicy(dwZone, dwAction, 
                                                            (BYTE *)((nRet == ZALERT_YESPERSIST) ?  &dwPolicy : &dwYesOnlyPolicy), 
                                                            sizeof(dwPolicy), URLZONEREG_DEFAULT);                                 
                    }
                }
                                     
                if (m_pSite != NULL)
                {
                    m_pSite->EnableModeless(TRUE);
                }
            }
            
            TransAssert(cbPolicy == 0 || cbPolicy >= sizeof(DWORD));

            if (cbPolicy >= sizeof(DWORD) && pPolicy != NULL)                        
                *(DWORD *)pPolicy = dwPolicy;


            // Code to check for allowed list of directx objects 
            // for URLACTION_ACTIVEX_RUN
            if(dwAction == URLACTION_ACTIVEX_RUN &&
                dwPolicy == URLPOLICY_ACTIVEX_CHECK_LIST)
            {
                DWORD dwValue = 0;
                hr = CSecurityManager::GetActiveXRunPermissions(pContext, dwValue);
                *(DWORD *)pPolicy = dwValue;
            }            
            // normal allowed permissions            
            else if(GetUrlPolicyPermissions(dwPolicy) == URLPOLICY_ALLOW)
            {
                hr = S_OK ;
            }
            else
            {
                hr = S_FALSE;
            }
        
        }
    }

    Release();

    DEBUG_LEAVE( (SUCCEEDED(hr) ? *((DWORD*)pPolicy) : hr) );
    return hr;                 
}

STDMETHODIMP
CSecurityManager::QueryCustomPolicy
(
    LPCWSTR pwszUrl,
    REFGUID guidKey,
    BYTE **ppPolicy,
    DWORD *pcbPolicy,
    BYTE *pContext,
    DWORD cbContext,
    DWORD dwReserved
)
{
    PerfDbgLog(tagCSecurityManager, this, "+CSecurityManager::QueryCustomPolicy");
    HRESULT hr = INET_E_DEFAULT_ACTION;
    DWORD dwZone = ZONEID_INVALID;
   
    if (m_pDelegateSecMgr)
    {
        hr = m_pDelegateSecMgr->QueryCustomPolicy(pwszUrl, guidKey, ppPolicy, pcbPolicy, pContext, cbContext, dwReserved);
    }

    if (hr == INET_E_DEFAULT_ACTION)
    {
        if (!EnsureZoneManager())
        {
            return E_UNEXPECTED;
        }

        if (SUCCEEDED(hr = MapUrlToZone(pwszUrl, &dwZone, NULL)))
        {
            hr = m_pZoneManager->GetZoneCustomPolicy(dwZone, guidKey, ppPolicy, pcbPolicy, URLZONEREG_DEFAULT);        
        }
        else 
        {
            hr = E_UNEXPECTED;
        }
    }

    return hr;                 
}


STDMETHODIMP
CSecurityManager::GetSecuritySite
(
    IInternetSecurityMgrSite **ppSite
)
{
    if (ppSite)
    {
        if (m_pSite)
            m_pSite->AddRef();

        *ppSite = m_pSite;
    }
    return S_OK;
}

STDMETHODIMP
CSecurityManager::SetSecuritySite
(
    IInternetSecurityMgrSite *pSite
)
{
    if (m_pSite)
    {
        m_pSite->Release();
    }

    if (m_pDelegateSecMgr)
    {
        m_pDelegateSecMgr->Release();
        m_pDelegateSecMgr = NULL;
    }

    m_pSite = pSite;

    if (m_pSite)
    {
        m_pSite->AddRef();

        IServiceProvider * pServiceProvider = NULL;

        if (SUCCEEDED(m_pSite->QueryInterface(IID_IServiceProvider, (void **)&pServiceProvider)))
        {
            TransAssert(pServiceProvider != NULL);

            if (SUCCEEDED(pServiceProvider->QueryService(
                                SID_SInternetSecurityManager, 
                                IID_IInternetSecurityManager,
                                (void **)&m_pDelegateSecMgr)))
            {
                TransAssert(m_pDelegateSecMgr != NULL);
            }
            else
            {
                m_pDelegateSecMgr = NULL;
            }
            pServiceProvider->Release();
        }
    }

    return S_OK;
}

    
// Mapping related functions

HRESULT
CSecurityManager::SetZoneMapping
(
    DWORD   dwZone,
    LPCWSTR pszPattern,
    DWORD   dwFlags
)
{
    PerfDbgLog(tagCSecurityManager, this, "+CSecurityManager::SetZoneMapping");
    HRESULT hr = INET_E_DEFAULT_ACTION;

    // Increment the counter so any cached url to zone mappings are invalidated.
    IncrementGlobalCounter( );

    if (m_pDelegateSecMgr)
    {
        hr = m_pDelegateSecMgr->SetZoneMapping(dwZone, pszPattern, dwFlags);
    }

    if (hr == INET_E_DEFAULT_ACTION)
    {
        LPWSTR pwszSecPattern = NULL;
        hr = CoInternetGetSecurityUrl(pszPattern, &pwszSecPattern, PSU_DEFAULT, 0);

        if (SUCCEEDED(hr))
        {
            CFreeStrPtr freeStr(pwszSecPattern);

            ZONEMAP_COMPONENTS zc;
            hr = zc.Crack (pwszSecPattern, PUAF_ACCEPT_WILDCARD_SCHEME, TRUE);
            if (hr != S_OK)
                return hr;

            ZONEATTRIBUTES za;
            za.cbSize = sizeof(za);

            if (!EnsureZoneManager())
                return E_OUTOFMEMORY;

            // Don't allow adding not https entries if the zone requires server verification.
            if (!(dwFlags & SZM_DELETE) && SUCCEEDED(m_pZoneManager->GetZoneAttributes(dwZone, &za)))
            {
                if (za.dwFlags & ZAFLAGS_REQUIRE_VERIFICATION)
                {
                    if (zc.nScheme != URL_SCHEME_HTTPS)
                    {
                        return E_ACCESSDENIED ;
                    }
                }
            }                           
                                
            if (zc.fIPRange)
            {
                hr = AddDeleteIPRule(&zc, dwZone, dwFlags);
                return hr;
            }
                                                                                         
            // Zone mappings for drive letters are hardcoded
            if (zc.fDrive)
                return E_INVALIDARG;        

            // Guard against buffer overflow.
            if (CSTRLENW(SZDOMAINS) + zc.cchDomain + 1 + zc.cchSite + 1 >= MAX_PATH)
                return E_INVALIDARG;

            TCHAR szKeyName[MAX_PATH];
            DWORD cchKeyName = CSTRLENW(SZDOMAINS);
            memcpy (szKeyName, SZDOMAINS, sizeof(TCHAR) * cchKeyName);

            if ((zc.cchDomain == 0 && zc.cchSite == 0) || (zc.cchProtocol == 0))
            {
                return E_INVALIDARG;
            }

            if (zc.pszDomain)
            {
                memcpy (szKeyName + cchKeyName,
                    zc.pszDomain, sizeof(TCHAR) * zc.cchDomain);
                // Null terminate for strchr.
                szKeyName[cchKeyName + zc.cchDomain] = TEXT('\0');
                if (StrChr(szKeyName + cchKeyName, WILDCARD) != NULL)
                    return E_INVALIDARG;

                cchKeyName += zc.cchDomain;
            }
            else
            {
                /*We need to catch the following here:
                 1. *.com
                 2. www.*
                 3. www.*.*
                 4. *.co.uk

                 All these show up if zc.pszDomain is NULL.
                 */

                 if (StrChr(zc.pszSite, WILDCARD) != NULL)
                    return E_INVALIDARG;
            }     
                 

            // Check for the simple wildcard case.
            // patterns such as *.microsoft.com where the only thing
            // after a * is the second-level domain.            
            if (zc.pszSite[0] == WILDCARD && zc.cchSite == 1)
            {
                if (!zc.pszDomain)
                    return E_INVALIDARG;
            }
            else
            {
                // Wildcards are only permitted at the begining of pattern.
                // So patterns such as *.foo.*.microsoft.com are invalid.

                if (zc.pszSite[0] == WILDCARD)
                {
                    // We already know that zc.cchSite is greater than 1
                    // because we would have caught it in the outer 'if' clause 
                    // otherwise.
                    if (zc.pszSite[1] != DOT)
                    {
                        return E_INVALIDARG;
                    }

                    // Skip over the leading *. and make sure there are no 
                    // other *'s in the string. 
                    if (StrRChr(zc.pszSite + 2, zc.pszSite + zc.cchSite, WILDCARD) != NULL)
                    {
                        return E_INVALIDARG;
                    }
                }

                if (zc.pszDomain)  // Add seperator only if we added a domain name.
                { 
                    szKeyName[cchKeyName++] = BACKSLASH;
                }
                else if (!IsOpaqueScheme(zc.nScheme) && 
                          (zc.pszSite[zc.cchSite - 1] == DOT || 
                           zc.pszSite[0] == DOT)
                        )

                {
                    // Catches invalid cases such as http://ohserv. or http://.inetsdk.
                    return E_INVALIDARG;
                }

                memcpy (szKeyName + cchKeyName,
                    zc.pszSite, sizeof(TCHAR) * zc.cchSite);

                if (!IsOpaqueScheme(zc.nScheme))
                { 
                    szKeyName[cchKeyName + zc.cchSite] = TEXT('\0');
                }
                cchKeyName += zc.cchSite;
            }
            szKeyName[cchKeyName] = 0;

            CRegKey regMap;

            DWORD dwErr;
    
            if (dwFlags & SZM_DELETE)
            {
                // Delete mapping if one exists.
                if (ERROR_FILE_NOT_FOUND == regMap.Open (m_regZoneMap, szKeyName, KEY_WRITE))
                    return S_OK; // nothing to delete
                if ((dwErr = regMap.DeleteValue (zc.pszProtocol)) == ERROR_SUCCESS)
                {
                    // Try reclaiming any registry key's which might be empty. 
                    regMap.Close();
                    m_regZoneMap.DeleteEmptyKey(szKeyName); 
                    if (zc.pszDomain)
                    {
                        DWORD cch = CSTRLENW(SZDOMAINS) + zc.cchDomain;
                        szKeyName[cch] = TEXT('\0');
                        m_regZoneMap.DeleteEmptyKey(szKeyName);
                    }                               
                    return S_OK;
                }
                else 
                {
                    hr = HRESULT_FROM_WIN32(dwErr);
                }
            }
            else
            {
                // Creates new mapping.
                if ((dwErr = regMap.Create (m_regZoneMap, szKeyName, KEY_READ | KEY_WRITE)) == ERROR_SUCCESS)
                {
                    DWORD dwZoneEntry;
                    if (regMap.QueryValue(&dwZoneEntry, zc.pszProtocol) == ERROR_SUCCESS)
                    {
                        hr = HRESULT_FROM_WIN32(ERROR_FILE_EXISTS);
                    }
                    else if ((dwErr = regMap.SetValue (dwZone, zc.pszProtocol)) == ERROR_SUCCESS)
                    {
                        return S_OK;
                    }
                    else 
                    {
                        hr = HRESULT_FROM_WIN32(dwErr);
                    }
                }
                else 
                {
                    hr = HRESULT_FROM_WIN32(dwErr);
                }
            }
        }
    }

    return hr;
}

// Helper functions for GetZoneMappings

// Given a site name and a domain name composes the string 
// site.domain.com

HRESULT
CSecurityManager::ComposeUrlSansProtocol
(
    LPCTSTR pszDomain,
    int     cchDomain,
    LPCTSTR pszSite,
    int     cchSite,
    LPTSTR  *ppszRet,
    int     *pcchUrlSansProtocol
)
{

    if (ppszRet == NULL)
    {
       return E_INVALIDARG;
    }

    int cchUrlSansProtocol = cchSite + 1 /* . */ + cchDomain ;

    // Create the part of the string without the protocol 
    LPTSTR szUrlSansProtocol = new TCHAR [cchUrlSansProtocol + 1];


    if ( szUrlSansProtocol == NULL )            
    {
        *ppszRet = NULL;

        if (pcchUrlSansProtocol)
            *pcchUrlSansProtocol = 0;

        return E_OUTOFMEMORY;
    }

    LPTSTR szCurrent = szUrlSansProtocol;

    // Copy over the specific parts of the name. 
    if (pszSite != NULL)
    {
        memcpy(szCurrent, pszSite, cchSite * sizeof(TCHAR));
        szCurrent += cchSite;
        memcpy(szCurrent, TEXT("."), 1 * sizeof(TCHAR));
        szCurrent += 1;
    }

    memcpy(szCurrent, pszDomain, cchDomain * sizeof(TCHAR));
    szCurrent += cchDomain;

    // Finally copy over the trailing zero.
    szCurrent[0] = TEXT('\0');

    *ppszRet = szUrlSansProtocol;

    if (pcchUrlSansProtocol)
        *pcchUrlSansProtocol = cchUrlSansProtocol;

    return S_OK;
}
    

HRESULT
CSecurityManager::ComposeUrl
(
    LPCTSTR pszUrlSansProt,
    int cchUrlSansProt,
    LPCTSTR pszProtocol,
    int cchProtocol,
    BOOL bAddWildCard,
    LPTSTR * ppszUrl,
    int *pcchUrl
)
{
    if (ppszUrl == NULL)
    {
        return E_INVALIDARG;
    }

    BOOL bWildCardScheme = FALSE;
    BOOL bOpaqueScheme   = FALSE;

    if (cchProtocol == 1 && pszProtocol[0] == WILDCARD)
    {
        bWildCardScheme = TRUE;
        bOpaqueScheme = FALSE;
    }
    else
    {
        // Figure out if this is an an opaque scheme. 
        LPWSTR pszTemp = (LPWSTR)_alloca((cchProtocol + 2) * sizeof(TCHAR));
        memcpy(pszTemp, pszProtocol, cchProtocol * sizeof(TCHAR));
        pszTemp[cchProtocol] = TEXT(':');
        pszTemp[cchProtocol + 1] = TEXT('\0');

        PARSEDURL pu; 
        pu.cbSize = sizeof(pu);

        HRESULT hr = ParseURL(pszTemp, &pu);

        if (SUCCEEDED(hr))
        {
            bOpaqueScheme = IsOpaqueScheme(pu.nScheme);
        }
        else
        {
            bOpaqueScheme = TRUE;
        }
    }

    // cchUrl will have the eventual length of the string we will send out                    
    int cchUrl = cchUrlSansProt; 
                 
    
    if (bOpaqueScheme)
    {
        cchUrl += cchProtocol + 1;    // we have to add prot: to the URL
    }
    else if (bWildCardScheme)
    {
        // If the scheme is a wildcard we don't add it to the eventual display.
    }
    else
    {
       cchUrl += cchProtocol + 3;  // we have to add prot:// to the url.
    }

    // If we are not an opaque schema, we might need to add a wildcard character as well.
    if (!bOpaqueScheme && bAddWildCard)
    {
        cchUrl += 2; /* for *. */
    }

    LPTSTR szUrl = new TCHAR [cchUrl + 1];
    
    if (szUrl == NULL)
    {
        *ppszUrl = NULL;

        if (pcchUrl)
            *pcchUrl = 0;

        return E_OUTOFMEMORY;
    }

    LPTSTR szCurrent = szUrl;

    // if the scheme is wildcard we don't want to display the scheme at all.
    // i.e we will show *.microsoft.com and *:*.microsoft.com
    if (bWildCardScheme)
    {
        if (bAddWildCard)
        {
            memcpy(szCurrent, TEXT("*."), 2 * sizeof(TCHAR));
            szCurrent += 2;
        }
    }
    else
    {
        memcpy(szCurrent, pszProtocol, cchProtocol * sizeof(TCHAR));
        szCurrent += cchProtocol;

        if (bOpaqueScheme)
        {
            memcpy(szCurrent, TEXT(":"), 1 * sizeof(TCHAR));
            szCurrent += 1;
        }
        else
        {
            memcpy(szCurrent, TEXT("://"), 3 * sizeof(TCHAR));
            szCurrent += 3;
            if (bAddWildCard)
            {
                memcpy(szCurrent, TEXT("*."), 2 * sizeof(TCHAR));
                szCurrent += 2;
            }
        }           
    }

    memcpy(szCurrent, pszUrlSansProt, cchUrlSansProt * sizeof(TCHAR));
    szCurrent += cchUrlSansProt;

    szCurrent[0] = TEXT('\0');

    *ppszUrl = szUrl;
    if (pcchUrl)
        *pcchUrl = cchUrl;

    return S_OK;
}

HRESULT
CSecurityManager::AddIPRulesToEnum
(
    DWORD dwZone,
    CEnumString *pEnumString
)
{
    HRESULT hr = NOERROR;

    if ((HUSKEY)m_regZoneMap == NULL)
        return E_UNEXPECTED;

    CRegKey regRanges;
    DWORD cNumRanges = 0;

    if (   ERROR_SUCCESS != regRanges.Open(m_regZoneMap, SZRANGES, KEY_READ)
        || ERROR_SUCCESS != regRanges.QuerySubKeyInfo(&cNumRanges, NULL, NULL)
       )
    {
        return S_OK;  // Nothing to add if we can't open the key.       
    }
    
    if (cNumRanges == 0)
        return S_OK;

    DWORD cchMaxKey = 20;
    TCHAR szKeyName[20];
    TCHAR rgchSansProtocol[MAX_PATH];
    DWORD iItem;

    for (iItem = 0 ; iItem < cNumRanges ; iItem++ )
    {
        DWORD cbName, cbRange;
        CRegKey regItem;
        cbName = cchMaxKey;
        cbRange = sizeof(rgchSansProtocol) - 3 * sizeof(TCHAR); 
                
        if  (  ERROR_SUCCESS == regRanges.EnumKey(iItem, szKeyName, &cbName)
            && ERROR_SUCCESS == regItem.Open(regRanges, szKeyName, KEY_READ)
            && ERROR_SUCCESS == regItem.QueryValue(rgchSansProtocol, SZRANGE, &cbRange) 
            )
        {
            LONG lRetProtocol = NOERROR;
            TCHAR rgchProtocol[MAX_PATH]; 
            DWORD dwZoneRead = ZONEID_INVALID;
            DWORD dwType;
            
            for ( DWORD dwIdxProt = 0 , cchP = ARRAYSIZE(rgchProtocol), dwSizeZoneId = sizeof(dwZoneRead);
                  (((lRetProtocol = regItem.EnumValue(dwIdxProt, rgchProtocol, &cchP, &dwType, &dwZoneRead, &dwSizeZoneId)) != ERROR_NO_MORE_ITEMS)
                   && (hr == NOERROR));
                   dwIdxProt++, cchP = ARRAYSIZE(rgchProtocol), dwSizeZoneId = sizeof(dwZoneRead), dwZoneRead = ZONEID_INVALID
                )
            {
#ifdef unix
                if (lRetProtocol == ERROR_MORE_DATA)
                    continue;
#endif /* unix */

                if (lRetProtocol != NOERROR)
                    break;
                
                if (dwSizeZoneId == 0 || cchP == 0 || rgchProtocol[0] == TEXT('\0')
                    || dwType != REG_DWORD || dwZoneRead == ZONEID_INVALID)
                    continue;
                                                         
                if (dwZone == dwZoneRead)
                {
                    int cchProtocol = lstrlen(rgchProtocol);
                    int cchRange = lstrlen(rgchSansProtocol);                    

                    LPTSTR szUrl = NULL;

                    if ( (SUCCEEDED(ComposeUrl(rgchSansProtocol, cchRange, rgchProtocol, cchProtocol, FALSE, &szUrl, NULL)))
                         && (SUCCEEDED(pEnumString->AddString(szUrl))))
                    {
                        if (szUrl != NULL)
                            delete [] szUrl;
                    }
                    else
                    {
                        if (szUrl != NULL)
                            delete [] szUrl;
                            
                        hr = E_OUTOFMEMORY;
                        break;
                    }
                }
            } /* for each protocol */
        } 
    } /* for each range entry */

    return hr;
}

                                                                     
// Given a Registry key and a part to the URL, this function looks through the 
// 'values' in the registry looking for a zone match. When it finds one it adds the 
// strings to the CEnumString class that is passed in. 

HRESULT
CSecurityManager::AddUrlsToEnum
(
    CRegKey * pRegKey,
    DWORD dwZone, 
    LPCTSTR pszUrlSansProt,
    int cchUrlSansProt,
    BOOL bAddWildCard,
    CEnumString *pEnumString
)
{
    HRESULT hr = NOERROR;
    // Iterate over the values and make up the strings we need.
    LONG lRetProtocol = NOERROR;
    TCHAR rgszProtocol[MAX_PATH];
    DWORD dwZoneRead = ZONEID_INVALID;
    DWORD dwType;
                
    for ( DWORD dwIdxProt = 0 , cchP = sizeof(rgszProtocol)/sizeof(TCHAR), dwSizeZoneId = sizeof(dwZoneRead);
          (((lRetProtocol = pRegKey->EnumValue(dwIdxProt, rgszProtocol, &cchP, &dwType, &dwZoneRead, &dwSizeZoneId)) != ERROR_NO_MORE_ITEMS)
           && (hr == NOERROR));
           dwIdxProt++, cchP = sizeof(rgszProtocol)/sizeof(TCHAR), dwSizeZoneId = sizeof(dwZoneRead), dwZoneRead = ZONEID_INVALID
        )
    {
        if (lRetProtocol != NO_ERROR)
        {
            // Break out of this loop but keep trying other sites.
            break;
        }

        if (  dwSizeZoneId == 0 || cchP == 0 || rgszProtocol[0] == TEXT('\0') 
                || dwType != REG_DWORD || dwZoneRead == ZONEID_INVALID)
            continue;                       

        // Yippeee, finally found a match.
        if (dwZone == dwZoneRead)
        {
            int cchProtocol = lstrlen(rgszProtocol);

            LPTSTR szUrl = NULL;

            // Compose the name of the URL.
            if ( (SUCCEEDED(ComposeUrl(pszUrlSansProt, cchUrlSansProt, rgszProtocol, cchProtocol, bAddWildCard, &szUrl, NULL)))
                 && (SUCCEEDED(pEnumString->AddString(szUrl))))
            {
                // Both succeeded we have added this string to the enumeration. 
                // Just free up the memory and move on.
                if (szUrl != NULL)
                    delete [] szUrl;
            }
            else
            {
                if (szUrl != NULL)
                    delete [] szUrl;
                hr = E_OUTOFMEMORY;
                break;
            }
        }           
    }  /* for each protocol */

    return hr;
}

                       
HRESULT
CSecurityManager::GetZoneMappings
(
    DWORD dwZone,
    IEnumString **ppEnumString,
    DWORD dwFlags
)
{
    PerfDbgLog(tagCSecurityManager, this, "+CSecurityManager::GetZoneMappings");

    HRESULT hr = NOERROR;

    CEnumString *pEnumString = NULL;

    pEnumString = new CEnumString( );
    
    if (pEnumString == NULL)
        return E_OUTOFMEMORY;

    CRegKey regDomainRoot;


    // We setup three loops below.
    // 
    //      for each domain name
    //          for each site
    //              for each protocol. 
    // The one twist is that for each domain we also have to enumerate the sites
    // to deal with wildcards such as http://*.microsoft.com
    // 
    // BUGBUG: MAX_PATH is a safe assumption, but we should change this to get the 
    // memory dynamically.

    TCHAR rgszDomain[MAX_PATH]; 
    TCHAR rgszSite[MAX_PATH];
    TCHAR rgszProtocol[MAX_PATH];
    LONG lRetDomain = NOERROR;
        
    if ( ((HUSKEY)m_regZoneMap != NULL) && 
         (regDomainRoot.Open(m_regZoneMap, SZDOMAINS, KEY_READ) == NOERROR)
       )
    {
        // If we couldn't open the root, then no rules exist for any zone.
        // Return an empty enumerator
        for ( DWORD dwIdxDomain = 0, cchD = sizeof(rgszDomain)/sizeof(TCHAR) ;
              (((lRetDomain = regDomainRoot.EnumKey(dwIdxDomain, rgszDomain, &cchD)) != ERROR_NO_MORE_ITEMS)
               && (hr == NOERROR));
              dwIdxDomain++ , cchD = sizeof(rgszDomain)/sizeof(TCHAR)
            )
        {
            if (lRetDomain != NOERROR)
            {
                TransAssert(lRetDomain != ERROR_MORE_DATA);
                break;
            }
        
            TCHAR rgszSite[MAX_PATH];
            LONG lRetSite = NOERROR;
        
            // Open the key to the domain.
            CRegKey regDomain;

            if (regDomain.Open(regDomainRoot, rgszDomain, KEY_READ) != NOERROR )
            {
                // We couldn't open this domain for some reason, but we will
                // keep trying the other domains.  
                continue;
            }

            int cchDomain = lstrlen(rgszDomain);

            TransAssert((HUSKEY)regDomain != NULL);

            for ( DWORD dwIdxSite = 0 , cchS = sizeof(rgszSite)/sizeof(TCHAR) ;
                  (((lRetSite = regDomain.EnumKey(dwIdxSite, rgszSite, &cchS)) != ERROR_NO_MORE_ITEMS)
                    && (hr == NOERROR));
                  dwIdxSite++ , cchS = sizeof(rgszSite)/sizeof(TCHAR)
                )
            {
                if (lRetSite != NOERROR)
                {
                    TransAssert(lRetSite !=  ERROR_MORE_DATA);
                    break;      // We will break out of this loop but keep trying other domains.
                }
            
                CRegKey regSite;

                if (regSite.Open(regDomain, rgszSite, KEY_READ) != NOERROR )
                {
                    // Couldn't open the site but try other sites anyway.
                    continue;
                }

                int cchSite = lstrlen(rgszSite);

                LPTSTR szUrlSansProtocol = NULL;
                int cchUrlSansProtocol = 0;

                // Get everything about the name figured out 
                if ((FAILED(ComposeUrlSansProtocol(rgszDomain, cchDomain, rgszSite, cchSite, &szUrlSansProtocol, &cchUrlSansProtocol)))
                     || szUrlSansProtocol == NULL  )
                {
                    hr = E_OUTOFMEMORY;
                    break;
                }
            
                TransAssert(cchUrlSansProtocol != 0);

                hr = AddUrlsToEnum(&regSite, dwZone, szUrlSansProtocol, cchUrlSansProtocol, FALSE, pEnumString);

                // Free up the memory we just allocated. 
                delete [] szUrlSansProtocol;

            } /* for each site */ 
                                                                     
            // At the domain level we need to look for any protocol defaults
            // An example string would look like http://*.microsoft.com
            LPTSTR szSiteWildCard = NULL;
            int cchSiteWildCard = 0;

            // If the string doesn't contain any .'s we didn't break it out as a domain/site 
            // in the first place. We shouldn't add a *. wildcard in this case. 
            BOOL bAddWildCard = (StrChr(rgszDomain, DOT) != NULL);

            if ((FAILED(ComposeUrlSansProtocol(rgszDomain, cchDomain, NULL, 0, &szSiteWildCard, &cchSiteWildCard)))
                  || szSiteWildCard == NULL)
            {
                hr = E_OUTOFMEMORY;
                break;
            }

            TransAssert(cchSiteWildCard != 0);

            hr = AddUrlsToEnum(&regDomain, dwZone, szSiteWildCard, cchSiteWildCard, bAddWildCard, pEnumString);

            delete [] szSiteWildCard;
        }
    }// opened domains root key

    // Finally add all the IP range entries to the structure.
    if (hr == NOERROR)    
    {
        hr = AddIPRulesToEnum(dwZone, pEnumString);
    }

    // Finally call the strings              
    if ( hr == NOERROR )
    {
        // Pass back the Enumeration to the caller. 
        if (ppEnumString)
            *ppEnumString = pEnumString;
    }
    else
    {
        // We need to free the object and return NULL to the caller. 
        if (ppEnumString)
            *ppEnumString = NULL;

        delete pEnumString;
    }
    
    return hr;        
                                                
}                       

//
// MapUrlToZone helper methods return S_OK if match found
//
// RETURN value is ONLY S_OK.
// Be careful about returning anything else since some calling functions assume this is the only return value.

HRESULT
CSecurityManager::MapUrlToZone (ZONEMAP_COMPONENTS* pzc, DWORD* pdwZone, DWORD dwFlags,
                                BOOL *pfMarked, LPWSTR *ppszMarkURL)
{
    HRESULT hr;
    CRegKey regProtocols;
    BOOL    fMarked = FALSE;

    if (dwFlags & MUTZ_ENFORCERESTRICTED)
    {
        *pdwZone = URLZONE_UNTRUSTED;
        hr = S_OK;
        goto done;
    }

    // Guard against buffer overflow.
    if (CSTRLENW(SZDOMAINS) + pzc->cchDomain + 1 + pzc->cchSite + 1 >= MAX_PATH)
        goto default_zone;

    if (pzc->fDrive)
    {
        switch (pzc->dwDriveType)
        {
            case DRIVE_UNKNOWN:
            case DRIVE_NO_ROOT_DIR:
                break;
            case DRIVE_REMOTE:
                TransAssert(FALSE);
                *pdwZone = URLZONE_INTRANET;
                goto done;
            default:
            {
                BOOL bCacheFile = IsFileInCacheDir(pzc->pszSite);

                *pdwZone = bCacheFile ? URLZONE_INTERNET : URLZONE_LOCAL_MACHINE;
                if(bCacheFile)
                    goto done;

                bCacheFile = IsFileInCookieDir(pzc->pszSite);

                *pdwZone = bCacheFile ? URLZONE_UNTRUSTED : URLZONE_LOCAL_MACHINE;
                if(bCacheFile)
                    goto done;

                // do the Mark of the Web stuff, if we have a local non-cache file:
                LPWSTR pwszMarkURL = NULL;
                TCHAR  *pszExt = PathFindExtension(pzc->pszSite);
                LPCTSTR pszPath = pzc->pszSite;

                // Don't look for the mark if flags say not to.
                // We only want to pursue the Mark of the Web for htm(l) files.
                // If Marked, we want to be sure we're not chasing our tail recursively.
                if ( !(dwFlags & MUTZ_NOSAVEDFILECHECK) &&
                     (StrCmpI(pszExt,TEXT(".htm")) == 0 || StrCmpI(pszExt,TEXT(".html")) == 0) &&
                     FileBearsMarkOfTheWeb(pszPath, &pwszMarkURL) &&
                     StrCmp(pszPath, pwszMarkURL) != 0)
                {
                    MapUrlToZone( pwszMarkURL, pdwZone, dwFlags | MUTZ_NOSAVEDFILECHECK | MUTZ_NOCACHE );

                    fMarked = TRUE;
                    if (ppszMarkURL)
                    {
                        *ppszMarkURL = pwszMarkURL;
                        pwszMarkURL = NULL; // give mark string to caller, don't free
                    }
                }

                if (pwszMarkURL)
                    LocalFree(pwszMarkURL);

                goto done;
            }
        }
    }
    else if (IsOpaqueScheme(pzc->nScheme))
    {
        if (S_OK == CheckSiteAndDomainMappings (pzc, pdwZone, pzc->pszProtocol))
            goto done;

        if (S_OK == CheckMKURL(pzc, pdwZone, pzc->pszProtocol))
            goto done;
    }
    else 
    {
        if (pzc->fAddr)
        {
            // Check name in form of IP address against range rules.
            if (S_OK == CheckAddressAgainstRanges (pzc, pdwZone, pzc->pszProtocol))
                goto done;
        }                

        if ((HUSKEY) m_regZoneMap)
        {
            // Check for a mapping for the site (or domain, if applicable)
            if (S_OK == CheckSiteAndDomainMappings (pzc, pdwZone, pzc->pszProtocol))
                goto done;

            if (S_OK == CheckUNCAsIntranet(pzc, pdwZone, pzc->pszProtocol))
                goto done;

            // Check for Local Intranet name rules.
            if (S_OK == CheckIntranetName (pzc, pdwZone, pzc->pszProtocol))
                goto done;
                          
            // Check for proxy bypass rule.
            if (S_OK == CheckProxyBypassRule (pzc, pdwZone, pzc->pszProtocol))
                goto done;
        }
    }        

    // Check for protocol defaults.
    if (    ERROR_SUCCESS == regProtocols.Open (m_regZoneMap, SZPROTOCOLS, KEY_READ)
        &&  ERROR_SUCCESS == regProtocols.QueryValueOrWild (pdwZone, pzc->pszProtocol)
       )
    {       
        goto done;
    }

default_zone:
        *pdwZone = URLZONE_INTERNET;
done:   
        if (pfMarked)
            *pfMarked = fMarked;

        hr = S_OK; 
        return hr;
}

HRESULT
CSecurityManager::ReadAllIPRules( )
{
    DWORD* pdwIndexes = NULL;

    EnterCriticalSection(&s_csectIP);
    if (s_pRanges != NULL)
    {
        delete [] s_pRanges;
        s_pRanges = NULL;
        s_cNumRanges = 0;
    }

    // We always start with the key "Range1" if nothing is found.
    s_dwNextRangeIndex = 1;  

    CRegKey regRanges, regItem;

    if ((HUSKEY)m_regZoneMap == NULL)
    {
        if (ERROR_SUCCESS != m_regZoneMap.Open (NULL, SZZONEMAP, KEY_READ))
            goto done;
    }

    DWORD cchMaxKey;

    // Read in ranges from registry.
    if (   ERROR_SUCCESS != regRanges.Open (m_regZoneMap, SZRANGES, KEY_READ)
        || ERROR_SUCCESS != regRanges.QuerySubKeyInfo (&s_cNumRanges, &cchMaxKey, NULL)
        || 0 == s_cNumRanges
       )
    {
        goto done;
    }

    // BUGBUG: TODO: Figure out why QuerySubKeyInfo is returning the wrong information. 
    cchMaxKey = 20; 
    // Calculate size of range item and allocate array (no alignment padding)
    s_cbRangeItem = sizeof(RANGE_ITEM) + sizeof(TCHAR) * (cchMaxKey + 1);
    s_pRanges = new BYTE [s_cbRangeItem * s_cNumRanges];
    pdwIndexes = new DWORD[s_cNumRanges];
        
    if (!s_pRanges || !pdwIndexes)
    {
        s_cNumRanges = 0;
        goto done;
    }

    // Loop through the ranges.
    TCHAR szRange[MAX_IPRANGE]; // 4x "###-###."
    RANGE_ITEM* pItem;
    DWORD iItem, cItem;

    pItem = (RANGE_ITEM *) s_pRanges;
    cItem = s_cNumRanges;
    s_cNumRanges = 0;
    
    for (iItem = 0; iItem < cItem; iItem++)
    {
        // Reset output buffer sizes.
        DWORD cbName, cbRange;
        cbName = cchMaxKey;
        cbRange = sizeof(szRange);
                
        // Get range from next key.
        if (  ERROR_SUCCESS != regRanges.EnumKey (iItem, pItem->szName, &cbName)
           || ERROR_SUCCESS != regItem.Open (regRanges, pItem->szName, KEY_READ)
           || ERROR_SUCCESS != regItem.QueryValue (szRange, SZRANGE, &cbRange)
           )
        {
            break;
        }

        // Figure out the index for the named Range entry. Ignore it is not of the 
        // form Range followed by Number. Range####
        DWORD chRange = lstrlen(SZRANGEPREFIX);

        if (0 == StrCmpNI(pItem->szName, SZRANGEPREFIX, chRange))
        {
            pdwIndexes[iItem] = StrToInt(pItem->szName + chRange);            
        }

        if (!ReadIPRule (szRange, pItem->bLow, pItem->bHigh))
            continue;
        
        // Advance to next range item in array.
        pItem = (RANGE_ITEM*) (((LPBYTE) pItem) + s_cbRangeItem);
        s_cNumRanges++;
    }

    // Find an empty slot or if we don't find one
    for (s_dwNextRangeIndex = 1 ; s_dwNextRangeIndex <= cItem; s_dwNextRangeIndex++)    
    {
        DWORD i;
        // Go through the entries and see if the index exists.
        for (i = 0; i < cItem ; i++ )
        {
            if (pdwIndexes[i] == s_dwNextRangeIndex)
                break;
        }

        if (i == cItem) // This range item is available.
            break;
    }

    TransAssert(s_dwNextRangeIndex >= 1 && s_dwNextRangeIndex <= (cItem + 1));
    delete [] pdwIndexes;
                     
done:
    LeaveCriticalSection(&s_csectIP);
    return S_OK;
}

HRESULT
CSecurityManager::AddDeleteIPRule
    (ZONEMAP_COMPONENTS* pzc, DWORD dwZone, DWORD dwFlags)
{
    HRESULT hr = S_OK;
    DWORD dwError = ERROR_SUCCESS;
    BOOL bFoundItem = FALSE;
    TCHAR szItemName[MAX_PATH];

    TransAssert(s_dwNextRangeIndex != 0);
    TransAssert(pzc->fIPRange);

    if (s_dwNextRangeIndex == 0)
        return E_UNEXPECTED;

    EnterCriticalSection(&s_csectIP);

    RANGE_ITEM *pItem = (RANGE_ITEM *)s_pRanges;

    // First figure out if this item already exists in our list. 
    // This is useful in both the delete and add case.
    for (DWORD iRange = 0; 
               iRange < s_cNumRanges ; 
               iRange++, pItem = (RANGE_ITEM*) (((LPBYTE) pItem) + s_cbRangeItem))
    {
        if  ( ( 0 == memcmp(pItem->bLow, pzc->rangeItem.bLow, sizeof(pItem->bLow)))
              && (0 == memcmp(pItem->bHigh, pzc->rangeItem.bHigh, sizeof(pItem->bHigh)))
            )
        {
            break;
        }
    }

    // If we have a valid "named" entry in the registry.        
    if (iRange < s_cNumRanges && pItem->szName[0] != TEXT('\0'))
    {
        bFoundItem = TRUE;
        StrCpy(szItemName, SZRANGES);
        StrCat(szItemName, pItem->szName);
    }
    else 
    {
        bFoundItem = FALSE;
        pItem = NULL;
    }

    // Are we trying to do an add or a delete.
    if  (dwFlags & SZM_DELETE)
    {
        // If we have a valid "named" entry in the registry delete it now.        
        if (bFoundItem)
        { 
            TransAssert(pItem != NULL);
            
            CRegKey regItem;        
            if ((dwError = regItem.Open(m_regZoneMap, szItemName, KEY_READ | KEY_WRITE)) != ERROR_SUCCESS)
            {
                hr = HRESULT_FROM_WIN32(dwError);
            }
            else 
            {
                // Get the protocol name and delete the protocol related value.
                if ((dwError = regItem.DeleteValue (pzc->pszProtocol)) == ERROR_SUCCESS)
                {
                    DWORD dwNumValues = 0;

                    // Is this the last entry for this range? If so delete the range & nuke the key.
                    if (ERROR_SUCCESS == regItem.QuerySubKeyInfo(NULL, NULL, &dwNumValues) &&
                        dwNumValues == 1 &&
                        ERROR_SUCCESS == regItem.DeleteValue(SZRANGE)
                       )
                    {
                        regItem.Close();
                        m_regZoneMap.DeleteEmptyKey(szItemName);
                    }
                }
                else 
                {
                    hr = HRESULT_FROM_WIN32(dwError);
                }
            }
        }
        else 
        {
            hr =  HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
        }
    }
    else
    {
        if (bFoundItem)
        {
            TransAssert(pItem != NULL);            
            // See if an entry with the given name already
            CRegKey regItem;                        

            if ((dwError = regItem.Open(m_regZoneMap, szItemName, KEY_READ | KEY_WRITE)) != ERROR_SUCCESS)
            {
                hr = HRESULT_FROM_WIN32(dwError);
            }
            else 
            {
                DWORD dwZoneExists;
                // If we were able to read the value, fail because entry already exists.  
                if (regItem.QueryValue(&dwZoneExists, pzc->pszProtocol) == ERROR_SUCCESS)
                {
                    hr = HRESULT_FROM_WIN32(ERROR_FILE_EXISTS);
                }
            }
        }
        else 
        {
            // Create the new item name. 
            StrCpy(szItemName, SZRANGES);
            StrCat(szItemName, SZRANGEPREFIX);            
            if (!DwToWchar(s_dwNextRangeIndex, szItemName + lstrlen(SZRANGES) + lstrlen(SZRANGEPREFIX), 10))
            {
                TransAssert(FALSE);
                hr = E_UNEXPECTED;
            }
        }
            
        // Okay to go ahead and create the entry.
        if (SUCCEEDED(hr))
        {
            TCHAR szIPRule[MAX_IPRANGE];
            // We shouldn't have any domain part for IP Rules.
            TransAssert(pzc->pszDomain == NULL);
            memcpy(szIPRule, pzc->pszSite, sizeof(TCHAR) * pzc->cchSite);
            szIPRule[pzc->cchSite] = TEXT('\0');

            CRegKey regMap;
                                    
            // Now add the entry to the registry.
            if ( ((dwError = regMap.Create(m_regZoneMap, szItemName, KEY_WRITE)) == ERROR_SUCCESS) &&
                 ((dwError = regMap.SetValue(dwZone, pzc->pszProtocol)) == ERROR_SUCCESS) &&
                 ((dwError = regMap.SetValue(szIPRule, SZRANGE)) == ERROR_SUCCESS)
               ) 
            {
                hr = S_OK;
            }
            else
            { 
                hr = HRESULT_FROM_WIN32(dwError);                                     
            }
        }
    }

    if (SUCCEEDED(hr))
    {
        hr = ReadAllIPRules();
    }

    LeaveCriticalSection(&s_csectIP);

    return hr;
}
            
HRESULT 
CSecurityManager::CheckAddressAgainstRanges
    (ZONEMAP_COMPONENTS* pzc, DWORD* pdwZone, LPCTSTR pszProt)
{
    TCHAR szKeyName[MAX_PATH];
    const DWORD cchRanges = CSTRLENW(SZRANGES);
    memcpy (szKeyName, SZRANGES, sizeof(TCHAR) * cchRanges);

    CRegKey regItem;

    EnterCriticalSection(&s_csectIP);
    RANGE_ITEM* pItem = (RANGE_ITEM *) s_pRanges;

    for (DWORD iRange=0; iRange < s_cNumRanges; iRange++)
    {
        for (DWORD iByte=0; iByte<4; iByte++)
        {
            if (   pzc->bAddr[iByte] < pItem->bLow[iByte]
                || pzc->bAddr[iByte] > pItem->bHigh[iByte]
               )
            {
                goto next_range; // much cleaner than a break and test
            }
        }

        StrCpyW (szKeyName + cchRanges, pItem->szName);
        
        if (    ERROR_SUCCESS == regItem.Open (m_regZoneMap, szKeyName, KEY_READ)
            &&  ERROR_SUCCESS == regItem.QueryValueOrWild (pdwZone, pszProt)
           )
        {
            LeaveCriticalSection(&s_csectIP);
            return S_OK;
        }

next_range:
        pItem = (RANGE_ITEM*) (((LPBYTE) pItem) + s_cbRangeItem);
    }

    LeaveCriticalSection(&s_csectIP);
    return S_FALSE;
}


HRESULT CSecurityManager::CheckSiteAndDomainMappings
    (ZONEMAP_COMPONENTS* pzc, DWORD* pdwZone, LPCTSTR pszProt)
{
    CRegKey regDomain, regSite;
    DWORD dwRegErr;

    TCHAR szKeyName[MAX_PATH];
    const DWORD cchKeyName = CSTRLENW(SZDOMAINS);
    memcpy (szKeyName, SZDOMAINS, sizeof(TCHAR) * cchKeyName);

    TransAssert(!pzc->fDrive);

    if (pzc->pszDomain)
    {
        // First, look for domain rule.
        memcpy (szKeyName + cchKeyName, pzc->pszDomain, sizeof(TCHAR) * pzc->cchDomain);
        szKeyName[cchKeyName + pzc->cchDomain] = 0;
        SAFEREGOPERATION(dwRegErr, regDomain.Open (m_regZoneMap, szKeyName, KEY_READ));

        if ((dwRegErr != ERROR_SUCCESS)
            && (szKeyName[cchKeyName + pzc->cchDomain -1] == DOT)//check if this is a terminal-dotted-site
            && ((pzc->nScheme == URL_SCHEME_HTTP)
                || (pzc->nScheme == URL_SCHEME_HTTPS)
                || (pzc->nScheme == URL_SCHEME_FILE)))
        {
                szKeyName[cchKeyName + pzc->cchDomain -1] = 0;
                dwRegErr = regDomain.Open(m_regZoneMap, szKeyName, KEY_READ);
        }

        if(dwRegErr != ERROR_SUCCESS)
            return S_FALSE;
            
        // Now add the site.
        memcpy (szKeyName, pzc->pszSite, sizeof(TCHAR) * pzc->cchSite);
        szKeyName[pzc->cchSite] = 0;
        dwRegErr = regSite.Open (regDomain, szKeyName, KEY_READ);

        // For IE5.0 we support wildcard's beyond the second level domain.
        // For example if you had an intranet address www.internal.mycorp.com
        // you can specify a zone mapping for *.internal.mycorp.com.
        // In IE4 we would have flagged this as an error because we allowed
        // wildcards only at the second level domain.
        //  IE5 since we lifted this restriction, we have to search the sub-keys 
        // and look for strings such as "*.internal" under the mycorp.com key. 
        // If we find one we see if the wildcard pattern matches the site whose
        // zone we are trying to determine.
        
        if (dwRegErr != ERROR_SUCCESS)
        {
            TCHAR rgchSubKeyName[MAX_PATH];
            LONG lRet = NOERROR;
            
            for ( DWORD dwIndex = 0 , cchSubKey = ARRAYSIZE(rgchSubKeyName) ;
                   ((lRet = regDomain.EnumKey(dwIndex, rgchSubKeyName, &cchSubKey)) != ERROR_NO_MORE_ITEMS) ;
                   dwIndex++ , cchSubKey = ARRAYSIZE(rgchSubKeyName)
                )
            {
                if (lRet != NOERROR)                   
                {
                    TransAssert(lRet != ERROR_MORE_DATA);
                    break;
                }

                // For patterns that finish with a *. we will do a suffix 
                // match to see if the wildcard sequence is valid.                
                if (cchSubKey > 2 && rgchSubKeyName[0] == WILDCARD && rgchSubKeyName[1] == DOT)
                {
                    // First condition
                    //    for xyz.foo.microsoft.com to match *.foo.microsoft.com
                    //        www.foo has to be greater than or equal to foo.microsoft.com
                    //        note that we allow just foo.microsoft.com as well.
                    // Second condition
                    //     cchSubkey is the length of *.foo, therefore the last 
                    //     cchSubKey - 2 characters of the two strings should match.
                    if (pzc->cchSite >= (cchSubKey - 2) &&
                        ( StrCmpNI (rgchSubKeyName + 2, /* skip *. */
                                    pzc->pszSite + pzc->cchSite - cchSubKey + 2,
                                    cchSubKey - 2 
                                   )  == 0
                         )
                       )
                    {
                        dwRegErr = regSite.Open(regDomain, rgchSubKeyName, KEY_READ);
                        break;
                    }
                }
            }
        }                                    
    }
    else
    {
        // There was no domain.  Look for a site rule.
        memcpy (szKeyName + cchKeyName, pzc->pszSite, sizeof(TCHAR) * pzc->cchSite);
        szKeyName[cchKeyName + pzc->cchSite] = 0;
        SAFEREGOPERATION(dwRegErr, regSite.Open (m_regZoneMap, szKeyName, KEY_READ));

        if ((dwRegErr != ERROR_SUCCESS)
            && (szKeyName[cchKeyName + pzc->cchSite -1] == DOT) //check if this is a terminal-dotted-site
            && ((pzc->nScheme == URL_SCHEME_HTTP)
                || (pzc->nScheme == URL_SCHEME_HTTPS)
                || (pzc->nScheme == URL_SCHEME_FILE)))
        {
                szKeyName[cchKeyName + pzc->cchSite -1] = 0;
                dwRegErr = regSite.Open(m_regZoneMap, szKeyName, KEY_READ);
        }
    }

    // Look for matching protocols under site key.
    if (    ERROR_SUCCESS == dwRegErr
        &&  ERROR_SUCCESS == regSite.QueryValueOrWild (pdwZone, pszProt)
       )
    {           
        return S_OK;
    }

    // Now fall back to domain if there was one.
    else if (   pzc->pszDomain
            &&  ERROR_SUCCESS == regDomain.QueryValueOrWild (pdwZone, pszProt)
       )
    {            
        return S_OK;
    }

    else return S_FALSE;
}


HRESULT CSecurityManager::CheckUNCAsIntranet
    (ZONEMAP_COMPONENTS* pzc, DWORD* pdwZone, LPCTSTR pszProt)
{
    HRESULT hr = S_FALSE;
    DWORD dwUNCAsIntranet;
    DWORD dwRegErr;

    TransAssert(!pzc->fDrive);
    TransAssert(!pzc->fIPRange);

    if (pzc->fAddr || pzc->nScheme != URL_SCHEME_FILE)
        return hr;

    SAFEREGOPERATION(dwRegErr, m_regZoneMap.QueryValue(&dwUNCAsIntranet, SZUNCASINTRANET));
    
    if(ERROR_SUCCESS != dwRegErr)
        return hr;

    if (dwUNCAsIntranet == 0)
    {
        hr = S_OK;
        if (pdwZone)
            *pdwZone = URLZONE_INTERNET;
    }

    return hr;
}

HRESULT CSecurityManager::CheckIntranetName
    (ZONEMAP_COMPONENTS* pzc, DWORD* pdwZone, LPCTSTR pszProt)
{
    HRESULT hr = S_FALSE;
    DWORD dwZone = ZONEID_INVALID;
    DWORD dwRegErr;

    TransAssert(!pzc->fDrive);
    TransAssert(!pzc->fIPRange);

    if (pzc->fAddr)
        return hr;

    // Check if there is a local intranet rule.
    SAFEREGOPERATION(dwRegErr, m_regZoneMap.QueryValue(&dwZone, SZINTRANETNAME));
    
    if(ERROR_SUCCESS != dwRegErr)
        return hr;

    if (dwZone != URLZONE_INTRANET)
    {
        TransAssert(FALSE);
        dwZone = URLZONE_INTRANET;
    }

        
    if (pzc->pszSite && !pzc->pszDomain)
    {
        BOOL bFoundDot = FALSE;

        for (DWORD dwIndex = 0 ; dwIndex < pzc->cchSite ; dwIndex++ )
        {
            if (pzc->pszSite[dwIndex] == DOT)
            {
                bFoundDot = TRUE;
                break;
            }
        }

        hr = bFoundDot ? S_FALSE : S_OK;
    }

    if (hr == S_OK && pdwZone)
        *pdwZone = dwZone;

    return hr;
}            


HRESULT CSecurityManager::CheckProxyBypassRule
    (ZONEMAP_COMPONENTS* pzc, DWORD* pdwZone, LPCTSTR pszProt)
{    
    TransAssert(!pzc->fDrive);
    DWORD dwRegErr;

    // Check if there is a proxy bypass rule.
    SAFEREGOPERATION(dwRegErr, m_regZoneMap.QueryValue(pdwZone, SZPROXYBYPASS));
 
    if(ERROR_SUCCESS != dwRegErr)
        return S_FALSE;

        
    // Calculate length of hostname = site (+ . + domain)
    DWORD cchTotal;
    cchTotal = pzc->cchSite;
    if (pzc->cchDomain)
        cchTotal += 1 + pzc->cchDomain;

    // Convert from unicode to ansi.
    char szHost[MAX_PATH];
    DWORD cbHost;
    cbHost = WideCharToMultiByte
        (CP_ACP, 0, pzc->pszSite, cchTotal, szHost, sizeof(szHost), NULL, NULL);
    if (!cbHost)
        return S_FALSE;
        
    // WideCharToMultiByte won't null terminate szHost,
    // IsHostInProxyBypassList shouldn't need it,
    // but just do it anyway to play it safe.
    szHost[cbHost] = 0;
    INTERNET_SCHEME tScheme;
    BOOL bCheckByPassRules = TRUE;
    switch(pzc->nScheme)
    {
        case URL_SCHEME_HTTP:
            tScheme = INTERNET_SCHEME_HTTP;
            break;
        case URL_SCHEME_HTTPS:
            tScheme = INTERNET_SCHEME_HTTPS;
            break;
        case URL_SCHEME_GOPHER:
            tScheme = INTERNET_SCHEME_GOPHER;
            break;
        case URL_SCHEME_FTP:
            tScheme = INTERNET_SCHEME_FTP;
            break;
        default:
            bCheckByPassRules = FALSE;
            break;
    }

    return bCheckByPassRules && IsHostInProxyBypassList (tScheme, szHost, cbHost) ? S_OK : S_FALSE;
}

HRESULT CSecurityManager::CheckMKURL
    (ZONEMAP_COMPONENTS* pzc, DWORD* pdwZone, LPCTSTR pszProt)
{
    HRESULT hr = S_FALSE;
    DWORD dwZone = ZONEID_INVALID;    
    TransAssert(!pzc->fDrive);

    // First check if it looks like a valid mk: string. 
    if (pzc->nScheme == URL_SCHEME_MK && 
        pzc->pszDomain == NULL && 
        pzc->pszSite != NULL && 
        pzc->pszSite[0] == AT)
    {
        // look for a : in the domain string.
        LPTSTR pszColon = StrChr(pzc->pszSite, COLON);
        if ( pszColon != NULL)
        {
            CRegKey regProtocols;
            *pszColon = TEXT('\0'); // Temporarily overwrite the colon.
            if ((ERROR_SUCCESS == regProtocols.Open(m_regZoneMap, SZPROTOCOLS, KEY_READ)) &&
                (ERROR_SUCCESS == regProtocols.QueryValue(&dwZone, pzc->pszSite))
               )
            {
                *pdwZone = dwZone;
                hr = S_OK;
            }
            *pszColon = COLON;     // Set the domain string back to its original state.
        }
    }
    
    return hr;
}          


CSecurityManager::CSecMgrCache::CSecMgrCache(void)
{
    InitializeCriticalSection(&m_csectZoneCache);
    
    // single static object, so this only gets inited once per
    // process.
    s_hMutexCounter = CreateMutexA(NULL, FALSE, "ZonesCounterMutex");

    m_iAdd = 0;
}


CSecurityManager::CSecMgrCache::~CSecMgrCache(void)
{
    Flush();
    DeleteCriticalSection(&m_csectZoneCache) ; 

    CloseHandle(s_hMutexCounter);
}

BOOL
CSecurityManager::CSecMgrCache::Lookup(LPCWSTR pwszURL,
                                       DWORD *pdwZone,
                                       BOOL *pfMarked,
                                       BYTE* pbSecurityID,
                                       DWORD *pcbSecurityID,
                                       LPCWSTR pwszDocDomain)
{
    BOOL fFound = FALSE;

    EnterCriticalSection(&m_csectZoneCache);

    if ( !IsCounterEqual() )
    {
        Flush();
    }
    else
    {
        int i;

        fFound = FindCacheEntry( pwszURL, i );
        if (fFound)
        {
            if ( pbSecurityID )
            {
                TransAssert(pcbSecurityID);
                if ( m_asmce[i].m_pbSecurityID && 
                     (  (m_asmce[i].m_pwszDocDomain == NULL && pwszDocDomain == NULL) || /* both are NULL */
                        (   m_asmce[i].m_pwszDocDomain && pwszDocDomain &&
                            (0 == StrCmpW(m_asmce[i].m_pwszDocDomain, pwszDocDomain))  /* the strings match */
                        )
                     ) &&
                     m_asmce[i].m_cbSecurityID <= *pcbSecurityID)
                {

                    memcpy( pbSecurityID, m_asmce[i].m_pbSecurityID, m_asmce[i].m_cbSecurityID  );
                    *pcbSecurityID = m_asmce[i].m_cbSecurityID;
                }
                else 
                    *pcbSecurityID = 0;
            }

            if (pdwZone)
            {
                *pdwZone = m_asmce[i].m_dwZone;

                if (pfMarked)
                    *pfMarked = m_asmce[i].m_fMarked;
            }
        }
    }

    LeaveCriticalSection(&m_csectZoneCache);

    return fFound;
}

void 
CSecurityManager::CSecMgrCache::Add(LPCWSTR pwszURL,
                                    DWORD dwZone,
                                    BOOL fMarked,
                                    const BYTE *pbSecurityID,
                                    const DWORD cbSecurityID, 
                                    LPCWSTR pwszDocDomain)
{
    int     i;
    BOOL    fFound;

    EnterCriticalSection(&m_csectZoneCache);

    if ( !IsCounterEqual() )
        Flush();

    fFound = FindCacheEntry( pwszURL, i ); // found or not, i will be the right place to set it.
    m_asmce[i].Set(pwszURL, dwZone, fMarked, pbSecurityID, cbSecurityID, pwszDocDomain);
    if (!fFound)
        m_iAdd = (m_iAdd + 1) % MAX_SEC_MGR_CACHE;

    SetToCurrentCounter(); // validate this cache.

    LeaveCriticalSection(&m_csectZoneCache);
}

void 
CSecurityManager::CSecMgrCache::Flush(void)
{
    int i;

    EnterCriticalSection(&m_csectZoneCache);

    for ( i = 0; i < MAX_SEC_MGR_CACHE; i++ )
        m_asmce[i].Flush();

    m_iAdd = 0;

    LeaveCriticalSection(&m_csectZoneCache);
}

// Is the counter we saved with the cache entry, equal to the current counter.
BOOL
CSecurityManager::CSecMgrCache::IsCounterEqual( ) const 
{
    CExclusiveLock lock(s_hMutexCounter);
    LPDWORD lpdwCounter = (LPDWORD) g_SharedMem.GetPtr(SM_SECMGRCHANGE_COUNTER);
    // If we couldn't create the shared memory for some reason, we just assume our cache is up to date.
    if (lpdwCounter == NULL)
        return TRUE;

    return (m_dwPrevCounter == *lpdwCounter);
}

VOID
CSecurityManager::CSecMgrCache::SetToCurrentCounter( ) 
{
    CExclusiveLock lock(s_hMutexCounter);
    LPDWORD lpdwCounter = (LPDWORD) g_SharedMem.GetPtr(SM_SECMGRCHANGE_COUNTER);
    if (lpdwCounter == NULL)
        return;

    m_dwPrevCounter = *lpdwCounter;
}

VOID
CSecurityManager::CSecMgrCache::IncrementGlobalCounter( )
{
    CExclusiveLock lock(s_hMutexCounter);
    LPDWORD lpdwCounter = (LPDWORD) g_SharedMem.GetPtr(SM_SECMGRCHANGE_COUNTER);
    if (lpdwCounter == NULL)
        return;

    (*lpdwCounter)++;
}

BOOL
CSecurityManager::CSecMgrCache::FindCacheEntry( LPCWSTR pwszURL, int& riEntry )
{
    BOOL fFound = FALSE;
    riEntry = m_iAdd - 1 % MAX_SEC_MGR_CACHE;

    // our cache is a circular buffer. We scan it from the last entry
    // we added backwards to the next slot to add to, createing a quasi-
    // MRU.
    if ( riEntry < 0 )
        riEntry = MAX_SEC_MGR_CACHE + riEntry;

    // check below us, starting with the most recent addition, if any.
    for ( ; riEntry >= 0; riEntry-- )
    {
        if ( m_asmce[riEntry].m_pwszURL &&
             StrCmpW( m_asmce[riEntry].m_pwszURL, pwszURL ) == 0 )
        {
            fFound = TRUE;
            break;
        }
    }

    if (!fFound)
    {
        for ( riEntry = MAX_SEC_MGR_CACHE - 1; riEntry >= m_iAdd; riEntry-- )
        {
            if (m_asmce[riEntry].m_pwszURL == NULL)
                break; // hasn't been used yet.
            else if ( m_asmce[riEntry].m_pwszURL &&
                      StrCmpW( m_asmce[riEntry].m_pwszURL, pwszURL ) == 0 )
            {
                fFound = TRUE;
                break;
            }
        }
    }

    if (!fFound)
        riEntry = m_iAdd;

    return fFound;
}
  
void 
CSecurityManager::CSecMgrCache::CSecMgrCacheEntry::Set(LPCWSTR pwszURL,
                                                       DWORD dwZone,
                                                       BOOL fMarked,
                                                       const BYTE *pbSecurityID,
                                                       DWORD cbSecurityID,
                                                       LPCWSTR pwszDocDomain)
{
    if ( pwszURL )
    {
        // Only replace if the string has changed.
        // We may see the same string if the entry is
        // set by MapUrlToZone before GetSecurityID is called.
        if (m_pwszURL && StrCmpW(pwszURL, m_pwszURL))
        {
            delete [] m_pwszURL;
            m_pwszURL = NULL;
        }

        if (!m_pwszURL)
        {
            int cchURL = lstrlenW( pwszURL );

            m_pwszURL = new WCHAR[cchURL+1];
            if ( m_pwszURL )
                StrCpyW( m_pwszURL, pwszURL );
            else
                return;
        }
    }

    // We always set the url zone mark first, then come back later and
    // add the security ID, than means that on any set operation, we're
    // either changing the url or adding the security ID. Either way, if
    // we have a security ID, its invalid now, so flush it.
    if (m_pbSecurityID)
    {
        delete [] m_pbSecurityID;
        m_pbSecurityID = NULL;
        m_cbSecurityID = 0;
    }

    if (m_pwszDocDomain)
    {
        delete [] m_pwszDocDomain;
        m_pwszDocDomain = NULL;
    }

    if ( pbSecurityID )
    {
        m_pbSecurityID = new BYTE[cbSecurityID];
        if ( m_pbSecurityID )
        {
            memcpy( m_pbSecurityID, pbSecurityID, cbSecurityID  );
            if (pwszDocDomain)
            {
                m_pwszDocDomain = new WCHAR[lstrlenW(pwszDocDomain) + 1];
                if (m_pwszDocDomain != NULL)
                {
                    StrCpyW(m_pwszDocDomain, pwszDocDomain);
                }
                else
                {
                    // If we don't have memory for the Document's domain property
                    // we better not remember the security ID either.
                    delete [] m_pbSecurityID;
                    m_pbSecurityID = NULL;
                    cbSecurityID = 0;
                }
            }
        }
        else
        {
            cbSecurityID = 0;
        }

        m_cbSecurityID = cbSecurityID;
    }

    if (dwZone != URLZONE_INVALID)
    {
        m_dwZone = dwZone;
        m_fMarked = fMarked;
    }
}

void 
CSecurityManager::CSecMgrCache::CSecMgrCacheEntry::Flush(void)
{
    if (m_pwszURL)
        delete[] m_pwszURL;
    m_pwszURL = NULL;

    if (m_pbSecurityID)
        delete[] m_pbSecurityID;
    m_pbSecurityID = NULL;
    
    m_cbSecurityID = 0;

    if (m_pwszDocDomain)
    {
        delete [] m_pwszDocDomain;
        m_pwszDocDomain = NULL;
    }

    m_dwZone = URLZONE_INVALID;
    m_fMarked = FALSE;
}
          
BOOL
CSecurityManager::EnsureListReady(BOOL bForce)
// Make sure the list of allowed controls is ready
// Returns whether or not the list had to be made
// bForce is whether to force a reinitialization
{
    if(CSecurityManager::s_clsidAllowedList == NULL || bForce == TRUE)
    {
        CSecurityManager::IntializeAllowedControls();
        return TRUE;
    }
    else
        return FALSE;
}

void 
CSecurityManager::IntializeAllowedControls()
{
    DWORD i = 0;
    DWORD dwNumKeys=0;
    DWORD dwMaxLen=0;
    DWORD dwNumValues=0;
    // this buffer size should be long enough to hold a string-form
    // CLSID, plus the two end braces, plus a null terminator
    TCHAR szValueName[40];
    DWORD dwNameLength = 40;
    DWORD dwType = 0;
    DWORD dwData = 0;
    DWORD dwDataLength = sizeof(DWORD);

    // In case we somehow get multiply initialized
    if(CSecurityManager::s_clsidAllowedList != NULL)
    {
        delete [] CSecurityManager::s_clsidAllowedList;
        CSecurityManager::s_clsidAllowedList = NULL;
    }
    CSecurityManager::s_dwNumAllowedControls = 0;


    //open key
    // look at HKLM only, first
    CRegKey * prkey_AllowedControls;
    CRegKey rkey_AllowedControls(TRUE);
    CRegKey rkey_AllowedControlsCU(FALSE);

    LONG lRes = rkey_AllowedControls.Open(NULL, ALLOWED_CONTROLS_KEY, KEY_READ);
    if(lRes != ERROR_SUCCESS)
    {
        // List not found in HKLM, check HKCU
        
        lRes = rkey_AllowedControlsCU.Open(NULL, ALLOWED_CONTROLS_KEY, KEY_READ);

        if(lRes != ERROR_SUCCESS)
        {
            // AllowedControls Key not able to be opened
            return;
        }
        else
        {
            prkey_AllowedControls = &rkey_AllowedControlsCU;
        }
    }
    else
    {
        prkey_AllowedControls = &rkey_AllowedControls;
    }


    lRes = prkey_AllowedControls->QuerySubKeyInfo(&dwNumKeys, &dwMaxLen, &dwNumValues);
    if(lRes != ERROR_SUCCESS)
        return;

    // prepare space in data structure
    // array will not need to be resized, since the maximum number of allowed
    // CLSIDs is the number of values in the key
    CSecurityManager::s_clsidAllowedList = new CLSID[dwNumValues];
    if(CSecurityManager::s_clsidAllowedList == NULL) // new failed
        return;

        // loop through all values in the key
    for(i = 0; i < dwNumValues; i++)
    {
        // at every loop, these values get changed and must be reset to the 
        // length of the name and data buffers, respectively
        dwNameLength = ARRAYSIZE(szValueName);
        dwDataLength = sizeof(DWORD);

        // Get the (DWORD) value for the current value name     
        LONG lResult = prkey_AllowedControls->EnumValue(i, szValueName, &dwNameLength, 
                                                 &dwType, &dwData, &dwDataLength);

        if(lResult == ERROR_SUCCESS && dwType == REG_DWORD
            && GetUrlPolicyPermissions(dwData) == URLPOLICY_ALLOW)
        {
                // found a value for the CLSID given, and it is set to allow the CLSID
            // add the CLSID to the list
            CLSID * p_id = CSecurityManager::s_clsidAllowedList +   //pointer + 
                           CSecurityManager::s_dwNumAllowedControls;//offset
            HRESULT hr = CLSIDFromString(szValueName, p_id);
            if(hr != NOERROR)
                continue;

            CSecurityManager::s_dwNumAllowedControls++;
        }
    }
}

HRESULT 
CSecurityManager::GetControlPermissions(BYTE * raw_CLSID, DWORD & dwPerm)
{
    CLSID * id = (CLSID *)(raw_CLSID);
    dwPerm = 0;

    // If the list is not initialized (something's wrong) leave function
    if(CSecurityManager::s_clsidAllowedList == NULL)
    {
        return E_UNEXPECTED;
    }


    DWORD index = 0;
    // Search for the given CLSID in the list of allowed Controls
    for(index = 0; index < CSecurityManager::s_dwNumAllowedControls; index++)
    {
        if(*id == (CSecurityManager::s_clsidAllowedList[index]))
        {
            dwPerm = URLPOLICY_ALLOW; // not necesarry, since currently only allowed controls
                                      // are in the list, but this may change later
            return S_OK;
        }
    }
    
    // Not found, return false to indicate not in list
    return S_FALSE;
}

HRESULT
CSecurityManager::GetActiveXRunPermissions(BYTE * raw_CLSID, DWORD & dwPerm)
{
    HRESULT hr = S_FALSE;
    DWORD dwValue;

    EnterCriticalSection(&s_csectAList);
    // Initialize the Allowed Controls list if it is not already
    CSecurityManager::EnsureListReady(FALSE);    
    // get the list permission for pContext, if it is in the list
    HRESULT permHR = CSecurityManager::GetControlPermissions(raw_CLSID,dwValue);
    LeaveCriticalSection(&s_csectAList);

    // interpret results, (zone dependent interpretation not yet implemented)
    if(SUCCEEDED(permHR))
    {
        if(permHR == S_OK) // found in list
        {
            if(dwValue == URLPOLICY_ALLOW)
            {
                hr = S_OK;
                dwPerm = URLPOLICY_ALLOW;
            }
            else
            {
                hr = S_FALSE;
                dwPerm = URLPOLICY_DISALLOW;
            }
        }
        else  // not in list; default is to disallow
        {
            hr = S_FALSE;
            dwPerm = URLPOLICY_DISALLOW;
        }
    }
    else // Unknown error.  Disallow by default
    {
        hr = S_FALSE;
        dwPerm = URLPOLICY_DISALLOW;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\urlmon\zones\zonemgr.h ===
//  File:       zonemgr.h
//
//  Contents:   This file defines the class that implements the base IInternetZoneManager
//
//  Classes:    CUrlZoneManager
//
//  Functions:
//
//  History: 
//
//----------------------------------------------------------------------------

#ifndef _ZONEMGR_H_
#define _ZONEMGR_H_

class CUrlZoneManager : public IInternetZoneManager
{
public:
    // IUnknown methods
    STDMETHODIMP QueryInterface(REFIID iid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);



    // IInternetZoneManager overrides
       
    STDMETHODIMP GetZoneAttributes( 
        /* [in] */ DWORD dwZone,
        /* [unique][out][in] */ ZONEATTRIBUTES *pZoneAttributes);
    
    STDMETHODIMP SetZoneAttributes( 
        /* [in] */ DWORD dwZone,
        /* [in] */ ZONEATTRIBUTES *pZoneAttributes);
    
    STDMETHODIMP GetZoneCustomPolicy( 
        /* [in] */ DWORD dwZone,
        /* [in] */ REFGUID guidKey,
        /* [size_is][size_is][out] */ BYTE **ppPolicy,
        /* [out] */ DWORD *pcbPolicy,
        /* [in] */ URLZONEREG urlZoneReg);
    
    STDMETHODIMP SetZoneCustomPolicy( 
        /* [in] */ DWORD dwZone,
        /* [in] */ REFGUID guidKey,
        /* [size_is][in] */ BYTE *pPolicy,
        /* [in] */ DWORD cbPolicy,
        /* [in] */ URLZONEREG urlZoneReg);
    
    STDMETHODIMP GetZoneActionPolicy( 
        /* [in] */ DWORD dwZone,
        /* [in] */ DWORD dwAction,
        /* [size_is][out] */ BYTE *pPolicy,
        /* [in] */ DWORD cbPolicy,
        /* [in] */ URLZONEREG urlZoneReg);
    
    STDMETHODIMP SetZoneActionPolicy( 
        /* [in] */ DWORD dwZone,
        /* [in] */ DWORD dwAction,
        /* [size_is][in] */ BYTE *pPolicy,
        /* [in] */ DWORD cbPolicy,
        /* [in] */ URLZONEREG urlZoneReg);
    
    STDMETHODIMP PromptAction( 
        /* [in] */ DWORD dwAction,
        /* [in] */ HWND hwndParent,
        /* [in] */ LPCWSTR pwszUrl,
        /* [in] */ LPCWSTR pwszText,
        /* [in] */ DWORD dwPromptFlags);
    
    STDMETHODIMP LogAction( 
        /* [in] */ DWORD dwAction,
        /* [in] */ LPCWSTR pwszUrl,
        /* [in] */ LPCWSTR pwszText,
        /* [in] */ DWORD dwLogFlags);
    
    STDMETHODIMP CreateZoneEnumerator( 
        /* [out] */ DWORD *pdwEnum,
        /* [out] */ DWORD *pdwCount,
        /* [in] */ DWORD dwFlags);
    
    STDMETHODIMP GetZoneAt( 
        /* [in] */ DWORD dwEnum,
        /* [in] */ DWORD dwIndex,
        /* [out] */ DWORD *pdwZone);
    
    STDMETHODIMP DestroyZoneEnumerator( 
        /* [in] */ DWORD dwEnum);
    
    STDMETHODIMP CopyTemplatePoliciesToZone( 
        /* [in] */ DWORD dwTemplate,
        /* [in] */ DWORD dwZone,
        /* [in] */ DWORD dwReserved);
    

public:
    CUrlZoneManager(IUnknown *pUnkOuter, IUnknown** ppUnkInner );
    virtual ~CUrlZoneManager();
    virtual BOOL Initialize();  

    static inline BOOL Cleanup ( )
    {   delete s_pRegZoneContainer ;  
        if ( s_bcsectInit ) DeleteCriticalSection(&s_csect) ; 
        return TRUE;
    }



    static CRITICAL_SECTION s_csect;
    static BOOL s_bcsectInit;

// Aggregation and RefCount support.
protected:
    CRefCount m_ref;
        
    class CPrivUnknown : public IUnknown
    {
    public:
        STDMETHOD(QueryInterface) ( REFIID riid, LPVOID FAR* ppvObj);
        STDMETHOD_(ULONG,AddRef) (void);
        STDMETHOD_(ULONG,Release) (void);

        ~CPrivUnknown() {}
        CPrivUnknown() : m_ref () {}

    private:
        CRefCount   m_ref;          // the total refcount of this object
    };

    friend class CPrivUnknown;
    CPrivUnknown m_Unknown;

    IUnknown*   m_pUnkOuter;

    STDMETHODIMP_(ULONG) PrivAddRef()
    {
        return m_Unknown.AddRef();
    }
    STDMETHODIMP_(ULONG) PrivRelease()
    {
        return m_Unknown.Release();
    }


protected:
    static CRegZoneContainer* s_pRegZoneContainer;
    static inline CRegZone * GetRegZoneById(DWORD dw) 
        { return s_pRegZoneContainer->GetRegZoneById(dw); }

private:
    IServiceProvider *m_pSP;    
};

#endif // _ZONEMGR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\urlmon\zones\zoneutil.cxx ===
//  File:       util.cxx
//
//  Contents:   Utility classes.
//
//  Classes:    CRefCount, CRegKey
//
//  Functions://
//  History: 
//
//----------------------------------------------------------------------------

#include "zonepch.h"
#include "advpub.h"
#ifdef UNIX
#include <platform.h>
#endif /* UNIX */
#include "shfolder.h"

// Misc utility functions and declarations.
#define DRIVE_UNINIT    0xFFFF  // Indicates that we haven't called GetDriveType yet.  
DWORD rgdwDriveTypeCache[26]; // one for each drive letter. 

BOOL g_bInit = FALSE;
BOOL g_bUseHKLMOnly = FALSE;

static LPWSTR s_pwzCacheDir;
static HRESULT GetCacheDirectory( ); 
static LPWSTR s_pwzCookieDir = NULL;

static CHAR *s_szMarkPrefix = "<!-- saved from url=(%04d)";
static CHAR *s_szMarkSuffix = " -->\r\n";

CSharedMem g_SharedMem;

static CRITICAL_SECTION g_csect_GetCacheDir;

BOOL IsZonesInitialized( )
{
    return g_bInit;
}     


BOOL ZonesInit( )
{
    if (!g_bInit)
    {
        DWORD dwType;
        DWORD dwSize = sizeof(DWORD);
        DWORD dwDefault = FALSE ; // If no entry found default is use HKCU.

        g_bInit = TRUE;

        // Call the shlwapi wrapper function that directly reads in a value for us.
        // Note that if the call fails we have the right value in g_bHKLMOnly already.
        SHRegGetUSValue(SZPOLICIES, SZHKLMONLY, &dwType, &g_bUseHKLMOnly,
                &dwSize, TRUE, &dwDefault, sizeof(dwDefault));

        InitializeCriticalSection(&CUrlZoneManager::s_csect);
        CUrlZoneManager::s_bcsectInit = TRUE;

        CSecurityManager::GlobalInit();

        // Initialize the drive type cache.
        for ( int i = 0 ; i < ARRAYSIZE(rgdwDriveTypeCache) ; i++ )
            rgdwDriveTypeCache[i] = DRIVE_UNINIT;

        //initialize critical section for GetCacheDirectory()
        InitializeCriticalSection(&g_csect_GetCacheDir);
    }

    return TRUE;
}                          

VOID ZonesUnInit ( )
{
    CUrlZoneManager::Cleanup( );
    CSecurityManager::GlobalCleanup( );
    g_SharedMem.Release();

    // Free any memory allocated for the cache directory.
    delete [] s_pwzCacheDir;

    if(s_pwzCookieDir)
        delete [] s_pwzCookieDir;

    // Destroy the GetCacheDirectory() critsec.
    DeleteCriticalSection(&g_csect_GetCacheDir);
}

// IEAK calls this function so force us to re-read the global settings for 
// HKLM vs HKCU.
STDAPI ZonesReInit(DWORD /* dwReserved */)
{          
    DWORD dwType;
    DWORD dwDefault = g_bUseHKLMOnly;
    DWORD dwSize = sizeof(DWORD);

    DWORD dwError = SHRegGetUSValue(SZPOLICIES, SZHKLMONLY, &dwType, &g_bUseHKLMOnly,
                        &dwSize, TRUE, &dwDefault, sizeof(dwDefault));

    return HRESULT_FROM_WIN32(dwError);
}

// SHDOCVW calls this during Thicket save to get the comment to flag the
// saved file as 
STDAPI GetMarkOfTheWeb(LPCSTR pszURL, LPCSTR pszFile, DWORD dwFlags, LPSTR *ppszMark)
{
    HRESULT hr = S_OK;
    int  cchURL = lstrlenA(pszURL);

    // Note - the code assumes that lstrlen(IDS_MARK_PREFIX)
    // equals wsprintf(IDS_MARK_PREFIX, lstrlen(url)

    *ppszMark = (LPSTR)LocalAlloc( LMEM_FIXED, (lstrlenA(s_szMarkPrefix) +
                                                cchURL +
                                                lstrlenA(s_szMarkSuffix) +
                                                1) * sizeof(CHAR) );
    if ( *ppszMark )
    {
        wsprintfA( *ppszMark, s_szMarkPrefix, cchURL );
        lstrcatA( *ppszMark, pszURL );
        lstrcatA( *ppszMark, s_szMarkSuffix );
    }
    else
        hr = E_OUTOFMEMORY;

    return hr;
}


// The security manager calls this to sniff a file: URL for the Mark of the Web
BOOL FileBearsMarkOfTheWeb(LPCTSTR pszFile, LPWSTR *ppszURLMark)
{
    BOOL              fMarked = FALSE;
    HANDLE            hFile;
    CHAR              szMarkPrefix[MARK_PREFIX_SIZE];
    CHAR              szMarkSuffix[MARK_SUFFIX_SIZE];
    WCHAR             wzMarkPrefix[MARK_PREFIX_SIZE];
    WCHAR             wzMarkSuffix[MARK_SUFFIX_SIZE];
    BOOL              fIsInUnicode = FALSE;
    DWORD             cchReadBufLen = 0;
    DWORD             cchURL;
    CHAR             *szMarkHead = NULL;
    WCHAR            *wzMarkHead = NULL;
    CHAR             *szMarkSuf = NULL;
    WCHAR            *wzMarkSuf = NULL;
    CHAR             *pszURLMark = NULL;
    DWORD             cchReadLen = 0;
    char             *pszTmp = NULL;
    char             *szReadBuf = NULL;
    int               iIteration = 1;

    lstrcpyA(szMarkPrefix, s_szMarkPrefix);
    lstrcpyA(szMarkSuffix, s_szMarkSuffix);

    hFile = CreateFile( pszFile, GENERIC_READ, FILE_SHARE_READ ,
                        NULL, OPEN_EXISTING, 
                        FILE_ATTRIBUTE_NORMAL, NULL );

    if ( hFile != INVALID_HANDLE_VALUE )
    {
        DWORD   cchPrefix = lstrlenA(szMarkPrefix);
        DWORD   dwRead;
        CHAR    szHeader[UNICODE_HEADER_SIZE];
        DWORD   cchHeader = UNICODE_HEADER_SIZE;

        if (ReadFile(hFile, szHeader, cchHeader, &dwRead, NULL) &&
                     cchHeader == dwRead)
        {
            if ((BYTE)szHeader[0] == (BYTE)0xFF && (BYTE)szHeader[1] == (BYTE)0xFE)
            {
                fIsInUnicode = TRUE;
            }
            else
            {
                fIsInUnicode = FALSE;
                SetFilePointer(hFile, 0, NULL, FILE_BEGIN);
                TransAssert(GetLastError() == NO_ERROR);
            }
        }
        else
        {
            // Unable to sniff for header
            goto Exit;
        }

        // File pointer is not at "real" beginning of file, regardless of
        // whether we are reading a UNICODE or ANSI file.

        szReadBuf = NULL;
        cchReadBufLen = 0;
        iIteration = 1;

        // Anchor NULL to make szMarkPrefix: <!-- saved from url=
        szMarkPrefix[cchPrefix-6] = '\0';

        if (fIsInUnicode)
        {
            if (!MultiByteToWideChar(CP_ACP, 0, szMarkPrefix, -1,
                                     wzMarkPrefix, MARK_PREFIX_SIZE))
            {
                goto Exit;
            }

            if (!MultiByteToWideChar(CP_ACP, 0, szMarkSuffix, -1,
                                     wzMarkSuffix, MARK_SUFFIX_SIZE))
            {
                goto Exit;
            }
        }

        for (;;)
        {
            cchReadBufLen = INTERNET_MAX_URL_LENGTH +
                            EXTRA_BUFFER_SIZE * iIteration + 1;

            if (fIsInUnicode)
            {
                cchReadBufLen *= 2;
            }
                            
            szReadBuf = new char[cchReadBufLen];

            if (!szReadBuf)
            {
                goto Exit;
            }

            
            cchReadLen = (fIsInUnicode) ? (cchReadBufLen - 2) : (cchReadBufLen - 1);
    
            if (ReadFile(hFile, szReadBuf, cchReadLen, &dwRead, NULL))
            {
                // look for mark of the web
                if (fIsInUnicode)
                {
                    szReadBuf[dwRead] = L'\0';
                    wzMarkHead = StrStrW((WCHAR *)szReadBuf, wzMarkPrefix);

                    if (wzMarkHead)
                    {
                        // Look for mark of the web suffix. If we don't
                        // have it, that means that we didn't have enough
                        // space for the buffer, and we need to try again
                        // with more space.

                        wzMarkSuf = StrStrW(wzMarkHead, wzMarkSuffix);

                        if (wzMarkSuf)
                        {
                            // Found suffix. We're done.
                            break;
                        }
                        else
                        {
                            if (dwRead < cchReadLen)
                            {
                                // We've already read everything, and
                                // we didn't find the suffix!
                                goto Exit;
                            }


                            // Didn't find suffix because buffer was too
                            // small. Try it again

                            delete [] szReadBuf;
                            szReadBuf = NULL;
                            iIteration++;

                            SetFilePointer(hFile, 2, 0, FILE_BEGIN);
                            TransAssert(GetLastError() == NO_ERROR);

                            continue;
                        }
                    }
                    else
                    {
                        // Can't find the mark head! Must find it on
                        // first iteration, or we give up.
                        goto Exit;
                    }
                }
                else
                {
                    // We are dealing with ANSI
                    szReadBuf[dwRead] = '\0';
                    szMarkHead = StrStrA(szReadBuf, szMarkPrefix);

                    if (szMarkHead)
                    {
                        // Look for mark of the web suffix. If we don't
                        // have it, that means that we didn't have enough
                        // space for the buffer, and we need to try again
                        // with more space.

                        szMarkSuf = StrStrA(szMarkHead, szMarkSuffix);

                        if (szMarkSuf)
                        {
                            // Found suffix. We're done.
                            break;
                        }
                        else
                        {
                            if (dwRead < cchReadLen)
                            {
                                // We've already read everything, and
                                // we didn't find the suffix!
                                goto Exit;
                            }

                            // Didn't find suffix because buffer was too
                            // small. Try it again

                            delete [] szReadBuf;
                            szReadBuf = NULL;
                            iIteration++;

                            SetFilePointer(hFile, 0, 0, FILE_BEGIN);
                            TransAssert(GetLastError() == NO_ERROR);

                            continue;
                        }
                    }
                    else
                    {
                        // Can't find the mark head! Must find it on
                        // first iteration, or we give up.
                        goto Exit;
                    }
                }
            }
            else
            {
                // Read failure!
                TransAssert(0);
            }
        }

        // now wzMarkHead or szMarkHead points to beginning of the mark
        // of the web, and wzMarkSuf or szMarkSuf point to the mark suffix

        if (fIsInUnicode)
        {
            DWORD     cchURL = 0;
            LPWSTR    wzPtr = StrStrW(wzMarkHead, L"=(");

            if (!wzPtr) goto Exit;

            wzPtr += 2;       // skip to beginning of length
            
            TransAssert((wzMarkSuf >= wzPtr));           
            wzPtr[4] = L'\0'; // anchor NULL

            cchURL = StrToIntW(wzPtr);
            if (cchURL > INTERNET_MAX_URL_LENGTH)
            {
                cchURL = INTERNET_MAX_URL_LENGTH;
            }

            //the string length of the url should be greater than or equal to cchURL.
            //else abort the allocation.
            if ((wzMarkSuf-(wzPtr+5)) < (INT)cchURL)
                goto Exit;
                
            *ppszURLMark = (WCHAR*)LocalAlloc(LMEM_FIXED, (cchURL+1) * sizeof(WCHAR));

            if (!*ppszURLMark)
            {
                goto Exit;
            }

            // StrCpyN length includes NULL terminator
            StrCpyNW(*ppszURLMark, wzPtr + 5, cchURL + 1);
        }
        else
        {
            DWORD     cchURL = 0;
            LPSTR     szPtr = StrStrA(szMarkHead, "=(");

            if (!szPtr) goto Exit;

            szPtr += 2; // skip to beginning of length
            
            TransAssert((szMarkSuf >= szPtr));
            szPtr[4] = '\0'; // anchor NULL

            cchURL = StrToIntA(szPtr);
            if (cchURL > INTERNET_MAX_URL_LENGTH)
            {
                cchURL = INTERNET_MAX_URL_LENGTH;
            }

            //the string length of the url should be greater than or equal to cchURL.
            //else abort the allocation.
            if ((szMarkSuf-(szPtr+5)) < (INT)cchURL)
                goto Exit;
                
            pszTmp = new char[cchURL + 1];

            if (!pszTmp)
            {
                goto Exit;
            }

            *ppszURLMark = (WCHAR*)LocalAlloc(LMEM_FIXED, (cchURL+1) * sizeof(WCHAR));

            if (!*ppszURLMark)
            {
                goto Exit;
            }

            // StrCpyN length includes NULL terminator
            StrCpyNA(pszTmp, szPtr + 5, cchURL + 1);
            MultiByteToWideChar(CP_ACP, 0, pszTmp, -1, *ppszURLMark, cchURL);
            (*ppszURLMark)[cchURL] = '\0';

        }

        if (szReadBuf)
        {
            delete [] szReadBuf;
            szReadBuf = NULL;
        }
    }
    else
    {
        // CreateFile failure
        goto Exit;
    }

    fMarked = TRUE;

Exit:

    if (hFile != INVALID_HANDLE_VALUE)
    {
        CloseHandle(hFile);
    }

    if (szReadBuf)
    {
        delete [] szReadBuf;
    }

    if (pszURLMark)
    {
        delete [] pszURLMark;
    }

    if (pszTmp) {
        delete [] pszTmp;
    }

    return fMarked;
}

//This function may now be called by one or more threads from IsFileInCacheDir() ( since we've moved invocation out of
//ZonesInit ( to prevent LoadLibrary() being called during DllMain execution ) ).
//Hence, we need a critsec for mutual exclusion..
//This also means that if for some reason, this function fails the first time, it may be called mutliple times by different
//threads, whereas earlier if it failed during ZonesInit(), it was never tried again.
HRESULT GetCacheDirectory( )
{
    HRESULT hr = E_FAIL;
    HMODULE hModShell=NULL;
    HMODULE hModShfolder=NULL;
    PFNSHGETFOLDERPATH pfnGetFolderPath;

	EnterCriticalSection(&g_csect_GetCacheDir);

    // If another thread managed to get this while this thread was waiting, bail out with success.
    // Optionally, if we want this code to execute only once, we can use a static boolean check.
    if (s_pwzCacheDir != NULL && s_pwzCookieDir != NULL)
    {
        hr = S_OK;
        goto Cleanup;
    }

    hModShell = LoadLibrary(TEXT("shell32.dll"));
    if (NULL == hModShell)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());  
        goto Cleanup;
    }

#ifdef UNICODE
    pfnGetFolderPath = (PFNSHGETFOLDERPATHW)GetProcAddress(hModShell, "SHGetFolderPathW");
#else
    pfnGetFolderPath = (PFNSHGETFOLDERPATHA)GetProcAddress(hModShell, "SHGetFolderPathA");
#endif

    if (pfnGetFolderPath == NULL)
    {
        hModShfolder = LoadLibrary(TEXT("shfolder.dll"));
        if (hModShfolder == NULL)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto Cleanup;
        }
        
#ifdef UNICODE
        pfnGetFolderPath = (PFNSHGETFOLDERPATHW)GetProcAddress(hModShfolder, "SHGetFolderPathW");
#else
        pfnGetFolderPath = (PFNSHGETFOLDERPATHA)GetProcAddress(hModShfolder, "SHGetFolderPathA");
#endif
    }

    if (pfnGetFolderPath == NULL)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }
    else 
    {
        TCHAR rgchCachePath[MAX_PATH];

        hr = pfnGetFolderPath(NULL, CSIDL_INTERNET_CACHE, NULL, 0, rgchCachePath);

        if (rgchCachePath[0] == TEXT('\0'))
            hr = E_FAIL;
       
        if (SUCCEEDED(hr))
        {
            if (s_pwzCacheDir != NULL)
            {
                delete [] s_pwzCacheDir;
                s_pwzCacheDir = NULL;
            }
            // Allocate memory for the new location.
            s_pwzCacheDir = new TCHAR[lstrlen(rgchCachePath) + 1];
            if (s_pwzCacheDir != NULL)
            {
                StrCpy(s_pwzCacheDir, rgchCachePath);
                hr = S_OK;
            }
            else
            {
                hr = E_OUTOFMEMORY;
                goto Cleanup;
            }
        }


        hr = pfnGetFolderPath(NULL, CSIDL_COOKIES, NULL, 0, rgchCachePath);

        if (rgchCachePath[0] == TEXT('\0'))
            hr = E_FAIL;
       
        if (SUCCEEDED(hr))
        {
            if (s_pwzCookieDir != NULL)
            {
                delete [] s_pwzCookieDir;
                s_pwzCookieDir = NULL;
            }
            // Allocate memory for the new location.
            s_pwzCookieDir = new TCHAR[lstrlen(rgchCachePath) + 1];
            if (s_pwzCookieDir != NULL)
            {
                StrCpy(s_pwzCookieDir, rgchCachePath);
                hr = S_OK;
            }
            else
                hr = E_OUTOFMEMORY;
        }

    }

Cleanup:
    if (hModShfolder)
        FreeLibrary(hModShfolder);

    if (hModShell)
        FreeLibrary(hModShell);

    LeaveCriticalSection(&g_csect_GetCacheDir);
   	
    return hr;
}


#if NOTUSED // Keep this code around in the unlikely event that we resurrect the Unix port. 
// This function gets the location of the cache directory.
HRESULT GetCacheDirectory( ) 
{
    DWORD dwType;

    // First figure out if we are using per-user cache or per-machine cache. 
    // This decides which registry key to look at for the cache value.
    BOOL fPerUserCache = TRUE;
#ifndef UNIX
    OSVERSIONINFOA osvi = {0};
    osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFOA);

    GetVersionExA(&osvi);
    if (osvi.dwPlatformId == VER_PLATFORM_WIN32_NT)
    {
        fPerUserCache = TRUE;
    }
    else
    { 
       DWORD dwUserProfile = 0;
       DWORD dwSize = sizeof(dwUserProfile);

        // Determine if user profiles are enabled.
        if ((ERROR_SUCCESS == SHGetValue(HKEY_LOCAL_MACHINE, SZLOGON, SZUSERPROFILES, &dwType, &dwUserProfile, &dwSize))
            && (dwUserProfile != 0 ))
        {
            fPerUserCache = TRUE;
            // Look for the exceptional case where User Profiles are enabled but the cache is still
            // global.
            dwSize = sizeof(dwUserProfile);

            if ((ERROR_SUCCESS == SHGetValue(HKEY_LOCAL_MACHINE, SZCACHE, SZUSERPROFILES, &dwType, &dwUserProfile, &dwSize))
                && (dwUserProfile == 0))
            {
                fPerUserCache = FALSE;
            }
        }
        else
        {
            fPerUserCache = FALSE;
        }
    }
#endif /* !UNIX */

    HRESULT hr = S_OK;
#ifdef UNIX
    WCHAR wszIE5Dir[] = L"ie5/"; 
    DWORD cchPath = MAX_PATH + sizeof(wszIE5Dir)/sizeof(WCHAR);
#else
    DWORD cchPath = MAX_PATH;
#endif /* !UNIX */
    s_pwzCacheDir = new WCHAR[cchPath];
    DWORD dwError = NOERROR;

    // First figure out if we are using per-user cache or per-machine cache. 
    // This decides which registry key to look at for the cache value.
    if (s_pwzCacheDir != NULL)
    {
        LPCWSTR pwzKey = fPerUserCache ? SZSHELLFOLDER : SZCACHECONTENT;
        LPCWSTR pwzValue = fPerUserCache ? SZTIFS : SZCACHEPATH ;
        HKEY hKey = fPerUserCache ? HKEY_CURRENT_USER : HKEY_LOCAL_MACHINE;

        dwError = SHGetValueW(hKey, pwzKey, pwzValue, &dwType, s_pwzCacheDir, &cchPath);
    }
    else 
    {
        dwError = ERROR_NOT_ENOUGH_MEMORY;
    }

    if (dwError != NOERROR)    
    {
        delete [] s_pwzCacheDir;
        s_pwzCacheDir = NULL;
        hr = HRESULT_FROM_WIN32(dwError);
    }
    else 
    {
        TransAssert(s_pwzCacheDir != NULL);
        PathRemoveBackslashW(s_pwzCacheDir);
#ifdef UNIX
        {
           int   ccPath, index;
           int   lenIE5Dir  = lstrlen(wszIE5Dir);

           ccPath = lstrlen(s_pwzCacheDir);
           index  = ccPath - 1;

           while(index >= 0 && s_pwzCacheDir[index] != FILENAME_SEPARATOR_W)
                index--;

           index++;
           memmove(&s_pwzCacheDir[index+lenIE5Dir],&s_pwzCacheDir[index],(ccPath-index+1)*sizeof(TCHAR));
           memcpy(&s_pwzCacheDir[index], wszIE5Dir, lenIE5Dir*sizeof(TCHAR));
        }
#endif /* UNIX */
        hr = S_OK;
    }
    return hr;
}                                                        
#endif // NOTUSED

BOOL IsFileInCacheDir(LPCWSTR pwzFile) 
{
    BOOL bReturn = FALSE;
    TCHAR szLongPath[MAX_PATH];

    if(!GetLongPathNameWrapW(pwzFile, szLongPath, sizeof(szLongPath)/sizeof(TCHAR)))
    {
        goto exit;
    }

    if (s_pwzCacheDir == NULL || s_pwzCookieDir == NULL)
    {
        if (! (SUCCEEDED(GetCacheDirectory())) )
            goto exit;
    }

    if(PathIsPrefixW(s_pwzCacheDir, szLongPath))
    {
        bReturn = TRUE;
    }

exit:
    return bReturn;
}

BOOL IsFileInCookieDir(LPCWSTR pwzFile) 
{
    BOOL bReturn = FALSE;
    TCHAR szLongPath[MAX_PATH];

    if(!GetLongPathNameWrapW(pwzFile, szLongPath, sizeof(szLongPath)/sizeof(TCHAR)))
    {
        goto exit;
    }

    if (s_pwzCacheDir == NULL || s_pwzCookieDir == NULL)
    {
        if (! (SUCCEEDED(GetCacheDirectory())) )
            goto exit;
    }

    if(PathIsPrefixW(s_pwzCookieDir, szLongPath))
    {
        bReturn = TRUE;
    }

exit:
    return bReturn;
}

// This function takes a DWORD and returns a wide char string
// in hex. There is no leading 0x and the leading 0's are stripped off
// This is to avoid pulling in the general wsprintfW into wininet which is 
// pretty big. You have to pass in enough memory to write the resulting string 
// into ( i.e >= 9 chars)

BOOL DwToWchar(DWORD dw, LPWSTR pwz, int radix)
{
    char sz[9];
    LPSTR psz = sz;
    LPSTR pszTemp = (LPSTR)pwz;
    char rgFormatHex[] = "%lX";
    char rgFormatDecimal[] = "%ld";
    char *pszFormat;
        
    if (radix == 16)
        pszFormat = rgFormatHex;
    else if (radix == 10)
        pszFormat = rgFormatDecimal;
    else
    {
        TransAssert(FALSE);
        return FALSE;
    }
                        
    if (wsprintfA(sz, pszFormat, dw) == 0)
    {
        return FALSE;
    }
#ifndef unix
    // Everything in the string sz is ANSI.
    while (*psz != 0) 
    {
        *pszTemp++ = *psz++;
        *pszTemp++ = '\0';
    }

    // Put the trailing NULL to the wide-char string.
    *pszTemp++ = '\0';
    *pszTemp++ = '\0';
#else
    while(*psz != 0)
        *pwz++ = (WCHAR)(DWORD)*psz++;
    *pwz++ = 0;
#endif /* unix */
    return TRUE;
}

// Drive type caching function.
//
DWORD GetDriveTypeFromCacheA(LPCSTR lpsz) 
{
    // NOTE: The retail version doesn't do any paramater validation to determine if this path is 
    // a valid one. So something like CTHISISGARBAGE will return the drive type for C:. 
    // This is just meant to be used inside the security manager so we can bypass these
    // checks. 
        
    TransAssert(lstrlenA(lpsz) >= 3);   // c:\ for example
    TransAssert(lpsz[1] == ':' && lpsz[2] == '\\');
#ifndef unix
    CHAR ch = (CHAR)CharLowerA((LPSTR)lpsz[0]);
#else
    CHAR *pch = CharLowerA((LPSTR)lpsz);
    CHAR ch = *pch;
#endif /* unix */

#ifndef UNIX 
    if (ch >= 'a' && ch <= 'z')
    {
        // First check the cache to see if the entry already exists.
        int index = ch - 'a';
        if (rgdwDriveTypeCache[index] == DRIVE_UNINIT)
        {
            rgdwDriveTypeCache[index] = GetDriveTypeA(lpsz);
        }

        TransAssert(rgdwDriveTypeCache[index] != DRIVE_UNINIT);
        return rgdwDriveTypeCache[index];
    }
#else
    if (ch == '/')
    {
        // IEUNIX - On unix we have only one drive "/" which is of type fixed
        // This was causing a wrong zone to be calculated for unix paths.
        return DRIVE_FIXED;
    }
#endif
    else 
    {
        return DRIVE_UNKNOWN;
    }
}
                        

// Helper to determine if we're currently loaded during GUI mode setup
BOOL IsInGUIModeSetup()
{
    static DWORD s_dwSystemSetupInProgress = 42;

    if (42 == s_dwSystemSetupInProgress)
    {
        // Rule is that this value will exist and be equal to 1 if in GUI mode setup.
        // Default to NO, and only do this for upgrades because this is potentially
        // needed for unattended clean installs.
        s_dwSystemSetupInProgress = 0;

        HKEY hKeySetup = NULL;

        if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                          TEXT("System\\Setup"),
                                          0,
                                          KEY_READ,
                                          &hKeySetup))
        {
            DWORD dwSize = sizeof(s_dwSystemSetupInProgress);

            if (ERROR_SUCCESS != RegQueryValueEx (hKeySetup,
                                                  TEXT("SystemSetupInProgress"),
                                                  NULL,
                                                  NULL,
                                                  (LPBYTE) &s_dwSystemSetupInProgress,
                                                  &dwSize))
            {
                s_dwSystemSetupInProgress = 0;
            }
            else
            {
                dwSize = sizeof(s_dwSystemSetupInProgress);
                if (s_dwSystemSetupInProgress &&
                    ERROR_SUCCESS != RegQueryValueEx (hKeySetup,
                                                      TEXT("UpgradeInProgress"),
                                                      NULL,
                                                      NULL,
                                                      (LPBYTE) &s_dwSystemSetupInProgress,
                                                      &dwSize))
                {
                    s_dwSystemSetupInProgress = 0;
                }
            }

            RegCloseKey(hKeySetup);
        }
    }
    return s_dwSystemSetupInProgress ? TRUE : FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CRegKey

LONG CRegKey::Close()
{
    LONG lRes = ERROR_SUCCESS;
    if (m_hKey != NULL)
    {
        lRes = SHRegCloseUSKey(m_hKey);
        m_hKey = NULL;
    }
    return lRes;
}

LONG CRegKey::Create(HUSKEY hKeyParent, LPCTSTR lpszKeyName, REGSAM samDesired)
{
    HUSKEY hKey = NULL;
    // BUGBUG : Is this the correct flag to call this function with?
    DWORD dwFlags = m_bHKLMOnly ? SHREGSET_FORCE_HKLM : SHREGSET_FORCE_HKCU;

    LONG lRes = SHRegCreateUSKey(lpszKeyName, samDesired, hKeyParent, &hKey, dwFlags); 

    if (lRes == ERROR_SUCCESS)
    {
        lRes = Close();
        m_hKey = hKey;
    }
    return lRes;
}

LONG CRegKey::Open(HUSKEY hKeyParent, LPCTSTR lpszKeyName, REGSAM samDesired)
{
    HUSKEY hKey = NULL;

    LONG lRes = SHRegOpenUSKey(lpszKeyName, samDesired, hKeyParent, &hKey, m_bHKLMOnly);

    if (lRes == ERROR_SUCCESS)
    {
        lRes = Close();
        TransAssert(lRes == ERROR_SUCCESS);
        m_hKey = hKey;
    }
    return lRes;
}

LONG CRegKey::QueryValue(DWORD* pdwValue, LPCTSTR lpszValueName)
{
    DWORD dwType = NULL;
    DWORD dwCount = sizeof(DWORD);
    LONG lRes = SHRegQueryUSValue(m_hKey, lpszValueName, &dwType,
        pdwValue, &dwCount, m_bHKLMOnly, NULL, 0);
    TransAssert((lRes!=ERROR_SUCCESS) || (dwType == REG_DWORD));
    TransAssert((lRes!=ERROR_SUCCESS) || (dwCount == sizeof(DWORD)));
    return lRes;
}

LONG CRegKey::QueryValue(LPTSTR szValue, LPCTSTR lpszValueName, DWORD* pdwCount)
{
    TransAssert(pdwCount != NULL);
    DWORD dwType = 0;
    LONG lRes = SHRegQueryUSValue(m_hKey, lpszValueName, &dwType,
        szValue, pdwCount, m_bHKLMOnly, NULL, 0);
    TransAssert((lRes!=ERROR_SUCCESS) || (dwType == REG_SZ) ||
             (dwType == REG_MULTI_SZ) || (dwType == REG_EXPAND_SZ));
    return lRes;
}

LONG CRegKey::QueryBinaryValue(LPBYTE pb, LPCTSTR lpszValueName, DWORD* pdwCount)
{
    TransAssert(pdwCount != NULL);
    DWORD dwType = NULL;
    LONG lRes = SHRegQueryUSValue(m_hKey, lpszValueName, &dwType,
        pb, pdwCount, m_bHKLMOnly, NULL, 0);
    TransAssert((lRes!=ERROR_SUCCESS) || (dwType == REG_BINARY));
    return lRes;
}


LONG WINAPI CRegKey::SetValue(HUSKEY hKeyParent, LPCTSTR lpszKeyName, LPCTSTR lpszValue, LPCTSTR lpszValueName, BOOL bHKLMOnly)
{
    TransAssert(lpszValue != NULL);
    CRegKey key(bHKLMOnly);
    LONG lRes = key.Create(hKeyParent, lpszKeyName, KEY_WRITE);
    if (lRes == ERROR_SUCCESS)
        lRes = key.SetValue(lpszValue, lpszValueName);
    return lRes;
}

LONG CRegKey::SetKeyValue(LPCTSTR lpszKeyName, LPCTSTR lpszValue, LPCTSTR lpszValueName)
{
    TransAssert(lpszValue != NULL);
    CRegKey key(m_bHKLMOnly);
    LONG lRes = key.Create(m_hKey, lpszKeyName, KEY_WRITE);
    if (lRes == ERROR_SUCCESS)
        lRes = key.SetValue(lpszValue, lpszValueName);
    return lRes;
}


//////////////////////////////////////////////////////////////////////////
//
// Autoregistration entry points
//
//////////////////////////////////////////////////////////////////////////

HRESULT CallRegInstall(LPSTR szSection)
{
    HRESULT hr = E_FAIL;
    HINSTANCE hinstAdvPack = LoadLibraryA("ADVPACK.DLL");

    if (hinstAdvPack)
    {
        REGINSTALL pfnri = (REGINSTALL)GetProcAddress(hinstAdvPack, achREGINSTALL);

        if (pfnri)
        {
            hr = pfnri(g_hInst, szSection, NULL);
        }

        FreeLibrary(hinstAdvPack);
    }

    return hr;
}

/*
 * We want to show the inetcpl settings as "Custom" in case of an upgrade only.
 *
 * We detect an upgrade using an HKCU key which only urlmon selfreg. code can set
 * Earlier we used the "Zones" key.
 *
 * In Whistler, the problem is some other module ( Office maybe ) registers this key,
 * so that even on a fresh install, we assume it's Custom.
 * Fix is to change the key we check for.
 *
 * On Millenium, there was a problem with double registration - in this case, the fix
 * would be to also put in the version key and check both for existence of a known key
 * and to match version to avoid slamming "Custom" in if there's a version match.
 */
BOOL
ShouldSetCustom()
{

#define SZPATH_ZONES_LOCAL_A  "Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\Zones\\0\\"

    BOOL fUpgrade = FALSE;
    HKEY hKeyZones;

    LONG dwResult = RegOpenKeyExA(
        HKEY_CURRENT_USER,
        SZPATH_ZONES_LOCAL_A, 
        0, 
        KEY_READ,
        &hKeyZones);

    if (dwResult == ERROR_SUCCESS)
    {
        //key exists, not an upgrade
        RegCloseKey(hKeyZones);
        fUpgrade = TRUE;
    }
    
    return fUpgrade;
}

STDAPI
ZonesDllInstall
(
    IN BOOL      bInstall,   // Install or Uninstall
    IN LPCWSTR    pwStr
)
{
    TransAssert(pwStr != NULL);

    HRESULT hr = S_OK;
    BOOL bUseHKLM = TRUE;

    if (pwStr && (0 == StrCmpIW(pwStr, L"HKCU")))
    {
        // Don't write to HKCU during GUI mode setup.  Otherwise,
        // the values may get slammed into all profiles during an upgrade.
        if (IsInGUIModeSetup())
            return hr;

        bUseHKLM = FALSE;
    }

    if ( bInstall )
    {
        BOOL fSetHKCUToCustom = FALSE; //Default to no-upgrade to avoid overwriting default zone settings.
        
        if (!bUseHKLM)
        {
            fSetHKCUToCustom = ShouldSetCustom();
        }

        // Backup IE3 user agent string, but don't do ever do these during
        // GUI mode setup
        if (!IsInGUIModeSetup())
        {
            CallRegInstall("BackupUserAgent");
            CallRegInstall("BackupConnectionSettings");
        }
        CallRegInstall(bUseHKLM ? "Backup.HKLM" : "Backup.HKCU");
        hr = CallRegInstall(bUseHKLM ? "Reg.HKLM" : "Reg.HKCU");

        if (!bUseHKLM)
        {
// Bug # 19514: To appease the press, we need to change the default for scripting unsafe activex
// controls to "disable" instead of "prompt". But at install time we can't blindly overwrite
// the existing value. We have to check if the users Intranet/Internet zones are at medium
// security from the previous install. To avoid instantiating the zone manager at registration
// time we also hardcode the registry values here.
#define  SZINTRANET  SZZONES TEXT("1")
#define  SZTRUSTED   SZZONES TEXT("2")
#define  SZINTERNET  SZZONES TEXT("3")
#define  SZUNTRUSTED SZZONES TEXT("4")
            TransAssert(URLZONE_INTRANET  == 1);
            TransAssert(URLZONE_TRUSTED   == 2);
            TransAssert(URLZONE_INTERNET  == 3);
            TransAssert(URLZONE_UNTRUSTED == 4);

            DWORD dwCurrentLevel ;

            CRegKey regKeyIntranet(FALSE);
            if ((regKeyIntranet.Open(NULL, SZINTRANET, KEY_READ) == ERROR_SUCCESS) &&
                (regKeyIntranet.QueryValue(&dwCurrentLevel, SZCURRLEVEL) == NOERROR) &&
                (dwCurrentLevel == URLTEMPLATE_MEDIUM)
               )
            {
                CallRegInstall("Intranet.HackActiveX");
            }

            CRegKey regKeyInternet(FALSE);
            if ((regKeyInternet.Open(NULL, SZINTERNET, KEY_READ) == ERROR_SUCCESS) &&
                (regKeyInternet.QueryValue(&dwCurrentLevel, SZCURRLEVEL) == NOERROR) &&
                (dwCurrentLevel == URLTEMPLATE_MEDIUM)
               )
            {
                CallRegInstall("Internet.HackActiveX");
            }

            if (fSetHKCUToCustom)
            {
            //108298/104506  We want to preserve the settings prior to an upgrade, but at
            // the same time, we dont want to show a security level inconsistent with the
            // actual policies ( which is what will happen if templates change or default
            // policy values change.  So set all templates to CUSTOM on install.
                CRegKey regKeyIntranet(FALSE);
                if(regKeyIntranet.Open(NULL, SZINTRANET, KEY_WRITE) == ERROR_SUCCESS)
                    regKeyIntranet.SetValue(URLTEMPLATE_CUSTOM, SZCURRLEVEL);

                CRegKey regKeyTrusted(FALSE);
                if(regKeyTrusted.Open(NULL, SZTRUSTED, KEY_WRITE) == ERROR_SUCCESS)
                    regKeyTrusted.SetValue(URLTEMPLATE_CUSTOM, SZCURRLEVEL);

                CRegKey regKeyInternet(FALSE);
                if(regKeyInternet.Open(NULL, SZINTERNET, KEY_WRITE) == ERROR_SUCCESS)
                    regKeyInternet.SetValue(URLTEMPLATE_CUSTOM, SZCURRLEVEL);

                CRegKey regKeyUntrusted(FALSE);
                if(regKeyUntrusted.Open(NULL, SZUNTRUSTED, KEY_WRITE) == ERROR_SUCCESS)
                    regKeyUntrusted.SetValue(URLTEMPLATE_CUSTOM, SZCURRLEVEL);
            }
        }
                                                  
    }
    else
    {
        // Restore IE3 user agent string.
        CallRegInstall("RestoreUserAgent");
        CallRegInstall("RestoreConnectionSettings");
        hr = CallRegInstall(bUseHKLM ? "Unreg.HKLM" : "UnReg.HKCU");

        if (bUseHKLM)
            hr = CallRegInstall("Restore.HKLM");

    }

    return hr;
}



// CSharedMem member functions.

BOOL CSharedMem::Init(LPCSTR pszNamePrefix, DWORD dwSize)
{
    // Note that this function is in ANSI, because we don't have Unicode wrappers 
    // for the file-mapping functions on Win9x and these need to work on Win9x.

    // Create the name for the file mapping object. 
    // We want this name to be unique per logged in user.
    // We will choose a name of the form ZonesSM_"UserName" for systems prior to NT5
    // BUGBUG: On Terminal server should we use Global\ in the name. If a user is logged on in multiple
    // sessions this seems desirable, but not sure if registry changes get reflected in the other 
    // session anyway.

    DWORD cchPrefix = lstrlenA(pszNamePrefix);
    LPSTR pszHandleName = (LPSTR) _alloca(cchPrefix + MAX_PATH);
    if (pszHandleName == NULL)
        return FALSE;

    memcpy(pszHandleName, pszNamePrefix, cchPrefix);

    // Move pointer to after the fixed part of the string.
    LPSTR psz = pszHandleName + cchPrefix;

    // Technically the max username possible is UNLEN which is less than MAX_PATH.
    // We use MAX_PATH to not pull in another random header into the build.
    DWORD dwMaxNameSize = MAX_PATH;

    if (GetUserNameA(psz, &dwMaxNameSize)) 
    { 
        // If succeeded, rgchHandleName now contains the exact same thing.
    }
    else
    {
        TransAssert(GetLastError() != ERROR_INSUFFICIENT_BUFFER);
        // if it fails, we will assume no logged on user and just use a global shared memory
        // section of the base name
    }

    m_dwSize = dwSize ;

    // First try to see if the shared memory section already exists.
    m_hFileMapping = CreateFileMappingA(INVALID_HANDLE_VALUE,
                                       NULL,
                                       PAGE_READWRITE,
                                       0,
                                       m_dwSize,
                                       pszHandleName) ;
    if (m_hFileMapping != NULL)
    {
        m_lpVoidShared = MapViewOfFile(m_hFileMapping, FILE_MAP_WRITE, 0, 0, 0);
    }

    return (m_hFileMapping != NULL && m_lpVoidShared != NULL);
}

VOID CSharedMem::Release()
{
    if (m_lpVoidShared != NULL)
    {
        UnmapViewOfFile(m_lpVoidShared);
        m_lpVoidShared = NULL;
    }

    if (m_hFileMapping != NULL)
    {
        CloseHandle(m_hFileMapping);
        m_hFileMapping = NULL;
    }

    m_dwSize = 0;

}

// This function will return NULL if either we couldn not initialize the shared memory
// for some reason or the offset specified is not in range. The offset should be specified
// in number of bytes.

LPVOID CSharedMem::GetPtr(DWORD dwOffset)
{
    if (m_lpVoidShared == NULL)
        return NULL;

    if (dwOffset >= m_dwSize)
        return NULL;

    return (BYTE *)m_lpVoidShared + dwOffset;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\urlmon\zones\zonemgr.cxx ===
//  File:      zonemgr.cxx
//
//  Contents:  Implementation of the IInternetZoneManager interface for basic (i.e. not
//             pluggable protocols with weird Urls)              
//
//  Classes:    CUrlZoneManager
//
//  Functions:
//
//  History: 
//
//----------------------------------------------------------------------------

#include "zonepch.h"


CRegZoneContainer*  CUrlZoneManager::s_pRegZoneContainer = NULL;
CRITICAL_SECTION    CUrlZoneManager::s_csect;
BOOL                CUrlZoneManager::s_bcsectInit = FALSE;

STDAPI 
InternetCreateZoneManager
(
    IUnknown * pUnkOuter,
    REFIID  riid,
    void **ppvObj,
    DWORD dwReserved
)
{   
    HRESULT hr = S_OK;      
    *ppvObj = NULL;

    if ( !IsZonesInitialized() )
        return E_UNEXPECTED;

    if (dwReserved != 0 || !ppvObj || (pUnkOuter && riid != IID_IUnknown))
    {
        // If the object has to be aggregated the caller can only ask
        // for an IUnknown back.
        hr = E_INVALIDARG;
    }
    else 
    {
        CUrlZoneManager * pZoneMgr = new CUrlZoneManager(pUnkOuter, (IUnknown **)ppvObj);

        if ( pZoneMgr )
        {

            if (!pZoneMgr->Initialize())
            {
                hr = E_UNEXPECTED;
            }
            else 
            {
                if (riid == IID_IUnknown || riid == IID_IInternetZoneManager)
                {
                    // The correct pointer is in ppvObj
                    *ppvObj = (IInternetZoneManager *)pZoneMgr;
                }
                else 
                {
                    hr = E_NOINTERFACE;
                }
            }
        }
        else 
        {
            hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}


CUrlZoneManager::CUrlZoneManager(IUnknown *pUnkOuter, IUnknown **ppUnkInner)
{
    DllAddRef();

    m_pSP = NULL;


    if (!pUnkOuter)
    {
        pUnkOuter = &m_Unknown;
    }
    else
    {
        TransAssert(ppUnkInner);
        if (ppUnkInner)
        {
            *ppUnkInner = &m_Unknown;
            m_ref = 0;
        }
    }

    m_pUnkOuter = pUnkOuter;
}


CUrlZoneManager::~CUrlZoneManager()
{
    DllRelease();
}


BOOL CUrlZoneManager::Initialize()
{
    BOOL bReturn = TRUE;
    
    EnterCriticalSection(&s_csect);

    if (s_pRegZoneContainer == NULL)
    {
        // We want to defer the initialization of the shared memory section.
        // This is a convenient place since it is already guarded by a critical 
        // section and this code has to be run before any caching related operations
        // happen. This should be done before the reg zones themselves are initialized
        // since they can call into the shared memory sections.

        g_SharedMem.Init(SM_SECTION_NAME, SM_SECTION_SIZE);

        // InitializeCriticalSection in the CRegZoneContainer constructor
        // can raise a STATUS_NO_MEMORY exception:
        __try 
        {
            s_pRegZoneContainer = new CRegZoneContainer();
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            s_pRegZoneContainer = NULL; // Just in case
        }

        if (s_pRegZoneContainer == NULL )
        {
            bReturn = FALSE;   // We are hosed.
        }
        else if (!s_pRegZoneContainer->Attach(g_bUseHKLMOnly))
        {
            bReturn = FALSE;
        }

    }

    LeaveCriticalSection(&s_csect);

    return bReturn;        
}

STDMETHODIMP CUrlZoneManager::CPrivUnknown::QueryInterface(REFIID riid, void** ppvObj)
{
    HRESULT hr = S_OK;
    
    *ppvObj = NULL;

    CUrlZoneManager * pUrlZoneManager = GETPPARENT(this, CUrlZoneManager, m_Unknown);
        
    if (riid == IID_IUnknown || riid == IID_IInternetZoneManager)
    {
        *ppvObj = (IInternetZoneManager *)pUrlZoneManager;
        pUrlZoneManager->AddRef();
    }
    else 
    {
        hr = E_NOINTERFACE;
    }
    
    return hr;
}
                
STDMETHODIMP_(ULONG) CUrlZoneManager::CPrivUnknown::AddRef()
{
    LONG lRet = ++m_ref;

    return lRet;
}

STDMETHODIMP_(ULONG) CUrlZoneManager::CPrivUnknown::Release()
{

    CUrlZoneManager *pUrlZoneManager = GETPPARENT(this, CUrlZoneManager, m_Unknown);

    LONG lRet = --m_ref;

    if (lRet == 0)
    {
        delete pUrlZoneManager;
    }

    return lRet;
}

// IUnknown methods.
STDMETHODIMP CUrlZoneManager::QueryInterface(REFIID riid, void **ppvObj)
{
    *ppvObj = NULL;

    if (riid == IID_IUnknown || riid == IID_IInternetZoneManager)
    {
        *ppvObj = (IInternetZoneManager *)this;
    }

    if (*ppvObj != NULL)
    {
        ((IUnknown *)*ppvObj)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CUrlZoneManager::AddRef()
{
    LONG lRet = m_pUnkOuter->AddRef();

    return lRet;
}

STDMETHODIMP_(ULONG) CUrlZoneManager::Release()
{                            
    LONG lRet = m_pUnkOuter->Release();

    // Controlling Unknown will delete the object if reqd.
        
    return lRet;
}


// The IInternetZoneManager methods

HRESULT
CUrlZoneManager::GetZoneAttributes
(
    DWORD dwZone,
    ZONEATTRIBUTES *pZoneAttributes
)
{
    if (pZoneAttributes == NULL /* || !IsZoneValid(dwZone) */)
    {
        return E_INVALIDARG;
    }

    CRegZone *pRegZone = GetRegZoneById(dwZone);
    if (pRegZone != NULL)
    {
        return pRegZone->GetZoneAttributes(*pZoneAttributes);
    }

    return E_FAIL;
}

HRESULT
CUrlZoneManager::SetZoneAttributes
(
    DWORD dwZone,
    ZONEATTRIBUTES *pZoneAttributes
)
{
    if (pZoneAttributes == NULL /* || !IsZoneValid(dwZone) */) 
    {
        return E_INVALIDARG;
    }
    
    CRegZone *pRegZone = GetRegZoneById(dwZone);
    if (pRegZone != NULL)
    {
        return (pRegZone->SetZoneAttributes(*pZoneAttributes));
    }

    return E_FAIL;
}


HRESULT
CUrlZoneManager::GetZoneCustomPolicy
(
    DWORD dwZone,
    REFGUID guidKey,
    BYTE **ppPolicy,
    DWORD *pcbPolicy,
    URLZONEREG urlZoneReg
)
{
    if (ppPolicy == NULL || pcbPolicy == NULL)
    {
        return E_INVALIDARG;
    }

    CRegZone *pRegZone = GetRegZoneById(dwZone);
    if (pRegZone == NULL)
    {
        return E_INVALIDARG; // Could be messed up registry here. 
    }

    return (pRegZone->GetCustomPolicy(guidKey, urlZoneReg, ppPolicy, pcbPolicy));
}

HRESULT
CUrlZoneManager::SetZoneCustomPolicy
(
    DWORD dwZone,
    REFGUID guidKey,
    BYTE *pPolicy,
    DWORD cbPolicy,
    URLZONEREG urlZoneReg
)
{
    if (pPolicy == NULL )
    {
        return E_INVALIDARG;
    }

    CRegZone *pRegZone = GetRegZoneById(dwZone);
    if (pRegZone == NULL)
    {
        return E_INVALIDARG;
    }

    return (pRegZone->SetCustomPolicy(guidKey, urlZoneReg, pPolicy, cbPolicy));
}


HRESULT
CUrlZoneManager::GetZoneActionPolicy
(
    DWORD dwZone,
    DWORD dwAction,
    BYTE* pPolicy,
    DWORD cbPolicy,
    URLZONEREG urlZoneReg
)
{
    if (pPolicy == NULL || cbPolicy < sizeof(DWORD))
    {
        return E_INVALIDARG;
    }

        
    CRegZone *pRegZone = GetRegZoneById(dwZone);
    if (pRegZone == NULL)
    {
        return E_INVALIDARG; // Could be messed up registry here. 
    }

    return (pRegZone->GetActionPolicy(dwAction, urlZoneReg, *((DWORD *)pPolicy)));
}
         

HRESULT 
CUrlZoneManager::SetZoneActionPolicy
(
    DWORD dwZone,
    DWORD dwAction,
    BYTE* pPolicy,
    DWORD cbPolicy,
    URLZONEREG urlZoneReg
)
{
    if (pPolicy == NULL || cbPolicy != sizeof(DWORD))
    {
        return E_INVALIDARG;
    }
        
    CRegZone *pRegZone = GetRegZoneById(dwZone);
    if (pRegZone == NULL)
    {
        return E_INVALIDARG; // Could be messed up registry here. 
    }

    return (pRegZone->SetActionPolicy(dwAction, urlZoneReg, *((DWORD *)pPolicy)));
}



// Actions that are actually carried out by the Zone Manager.


HRESULT
CUrlZoneManager::PromptAction
(
    DWORD dwAction,
    HWND hwndParent,
    LPCWSTR pwszUrl,
    LPCWSTR pwszText,
    DWORD dwPromptFlags
)
{
    return E_NOTIMPL;
}


HRESULT
CUrlZoneManager::LogAction
(
    DWORD dwAction,
    LPCWSTR pwszUrl,
    LPCWSTR pwszText,
    DWORD dwLogFlags
)
{
    return E_NOTIMPL;
}


// Zone enumerations
// This is really convoluted. These functions don't belong to the CUrlZoneManager but 
// really to the collection of zones. To support this we remember the pointer to the container
// that created us and delegate these functions on. 

HRESULT
CUrlZoneManager::CreateZoneEnumerator
(
    DWORD* pdwEnum,
    DWORD* pdwCount,
    DWORD  dwFlags   
)
{
    if (dwFlags != 0)
        return E_INVALIDARG;

    if (s_pRegZoneContainer != NULL)
    {
        return s_pRegZoneContainer->CreateZoneEnumerator(pdwEnum, pdwCount);
    }
    else
    {
        TransAssert(FALSE);
        return E_FAIL;
    }
}

HRESULT
CUrlZoneManager::GetZoneAt
(
    DWORD dwEnum,
    DWORD dwIndex,
    DWORD *pdwZone
)
{
    if (s_pRegZoneContainer != NULL)
    {
        return s_pRegZoneContainer->GetZoneAt(dwEnum, dwIndex, pdwZone);
    }
    else
    {
        TransAssert(FALSE);
        return E_FAIL;
    }
}

HRESULT
CUrlZoneManager::DestroyZoneEnumerator
(
    DWORD dwEnum
)
{
    if (s_pRegZoneContainer != NULL)
    {
        return s_pRegZoneContainer->DestroyZoneEnumerator(dwEnum);
    }
    else
    {
        TransAssert(FALSE);
        return E_FAIL;
    }
}



HRESULT
CUrlZoneManager::CopyTemplatePoliciesToZone
(
    DWORD dwTemplate,
    DWORD dwZone,
    DWORD dwReserved
)
{

    if (URLTEMPLATE_PREDEFINED_MIN > dwTemplate || URLTEMPLATE_PREDEFINED_MAX < dwTemplate)
        return E_INVALIDARG;
        
    CRegZone *pRegZone = GetRegZoneById(dwZone);
    if (pRegZone == NULL)
    {
        return E_INVALIDARG; // Could be messed up registry here. 
    }

    return (pRegZone->CopyTemplatePolicies(dwTemplate));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\urlmon\zones\zoneutil.h ===
//  File:       util.h
//
//  Contents:   Utility classes.
//
//  Classes:    CRefCount
//
//  Functions://
//  History: 
//
//----------------------------------------------------------------------------

#ifndef _URLZONE_UTIL_H_
#define _URLZONE_UTIL_H_

// Declarations for global variables.
extern BOOL g_bUseHKLMOnly;
extern BOOL g_bInit;

extern BOOL IsZonesInitialized();
extern HINSTANCE g_hInst;

// Cache of drive letter to drive type.
extern DWORD GetDriveTypeFromCacheA(LPCSTR psz);

// Is this file under the Cache directory.
extern BOOL IsFileInCacheDir(LPCWSTR pszFile);

// Is this file under the Cookie directory.
extern BOOL IsFileInCookieDir(LPCWSTR pszFile);

// Is urlmon currently loaded in GUI-mode setup?
extern BOOL IsInGUIModeSetup();

// Replacement for ultoa, works with wide-chars.
extern BOOL DwToWchar (DWORD dw, LPWSTR lpwsz, int radix);

#ifdef unix
#undef offsetof
#endif /* unix */
#define offsetof(s,m) ( (SIZE_T) &( ((s*)NULL)->m) )
#define GETPPARENT(pmemb, struc, membname) ((struc*)(((char*)(pmemb))-offsetof(struc, membname)))

// Does this file bear the Mark of the Web
extern BOOL FileBearsMarkOfTheWeb(LPCTSTR pszFile, LPWSTR *ppszURLMark);

EXTERN_C HRESULT ZonesDllInstall(BOOL bInstall, LPCWSTR pwStr);

/////////////////////////////////////////////////////////////////////////////
// CRegKey

class CRegKey
{
public:
    CRegKey(BOOL bHKLMOnly);
    CRegKey();      
    ~CRegKey();

// Attributes
public:
    operator HUSKEY() const;
    HUSKEY m_hKey;
    BOOL m_bHKLMOnly;

// Operations
public:
    LONG SetValue(DWORD dwValue, LPCTSTR lpszValueName);                // DWORD
    LONG SetValue(LPCTSTR lpszValue, LPCTSTR lpszValueName = NULL);     // STRING
    LONG SetBinaryValue(const BYTE *pb, LPCTSTR lpszValueName, DWORD dwCount);        // BINARY
    LONG SetValueOfType(const BYTE *pb, LPCTSTR lpszValueName, DWORD dwCount, DWORD dwType); // ANY TYPE

    LONG QueryValue(DWORD* pdwValue, LPCTSTR lpszValueName);
    LONG QueryValue(LPTSTR szValue, LPCTSTR lpszValueName, DWORD* pdwCount);
    LONG QueryBinaryValue(LPBYTE pb, LPCTSTR lpszValueName, DWORD *pdwCount);
    
    LONG QueryValueOrWild (DWORD* pdwValue, LPCTSTR lpszValueName)
    {
        if (ERROR_SUCCESS == QueryValue (pdwValue, lpszValueName))
            return ERROR_SUCCESS;
        else
            return QueryValue (pdwValue, TEXT("*"));
    }

    LONG SetKeyValue(LPCTSTR lpszKeyName, LPCTSTR lpszValue, LPCTSTR lpszValueName = NULL);
    static LONG WINAPI SetValue(HUSKEY hKeyParent, LPCTSTR lpszKeyName,
        LPCTSTR lpszValue, LPCTSTR lpszValueName = NULL, BOOL bHKLMOnly = FALSE);

    inline LONG QuerySubKeyInfo (DWORD* pdwNumKeys, DWORD* pdwMaxLen, DWORD *pdwNumValues);

    LONG EnumKey(DWORD dwIndex, LPTSTR lpszName, DWORD* pcchName);
    LONG EnumValue(DWORD dwIndex, LPTSTR pszValueName, LPDWORD pcchValueNameLen, 
                    LPDWORD pdwType, LPVOID pvData, LPDWORD pcbData);

    LONG Create(
        HUSKEY hKeyParent, // OPTIONAL
        LPCTSTR lpszKeyName,
        REGSAM samDesired);
        
    LONG Open(
        HUSKEY hKeyParent,  // OPTIONAL
        LPCTSTR lpszKeyName,
        REGSAM samDesired);
        
    LONG Close();
    HUSKEY Detach();
    void Attach(HUSKEY hKey);
    LONG DeleteValue(LPCTSTR lpszValue);
    LONG DeleteEmptyKey(LPCTSTR pszSubKey);

private:
    inline DWORD RegSetFlags() const 
    { return m_bHKLMOnly ? SHREGSET_FORCE_HKLM : SHREGSET_FORCE_HKCU; } 

    inline SHREGDEL_FLAGS RegDelFlags() const
    { return m_bHKLMOnly ? SHREGDEL_HKLM : SHREGDEL_HKCU; } 

    inline SHREGENUM_FLAGS RegEnumFlags() const
    { return m_bHKLMOnly ? SHREGENUM_HKLM : SHREGENUM_DEFAULT; }
};

inline CRegKey::CRegKey(BOOL bHKLMOnly)
{m_hKey = NULL; m_bHKLMOnly = bHKLMOnly;}

inline CRegKey::CRegKey()
{
    TransAssert(g_bInit);
    m_bHKLMOnly = g_bUseHKLMOnly;
    m_hKey = NULL;
}

inline CRegKey::~CRegKey()
{Close();}

inline CRegKey::operator HUSKEY() const
{return m_hKey;}

inline LONG CRegKey::SetValue(DWORD dwValue, LPCTSTR lpszValueName)
{
    TransAssert(m_hKey != NULL);

    return SHRegWriteUSValue(m_hKey, lpszValueName, REG_DWORD,
        (LPVOID)&dwValue, sizeof(DWORD), RegSetFlags());
}

inline LONG CRegKey::SetValue(LPCTSTR lpszValue, LPCTSTR lpszValueName)
{
    TransAssert(lpszValue != NULL);
    TransAssert(m_hKey != NULL);

    return SHRegWriteUSValue(m_hKey, lpszValueName, REG_SZ,
        (LPVOID)lpszValue, (lstrlen(lpszValue)+1)*sizeof(TCHAR), RegSetFlags());
}

inline LONG CRegKey::SetBinaryValue(const BYTE *pb, LPCTSTR lpszValueName, DWORD dwCount)
{
    TransAssert(pb != NULL);
    TransAssert(m_hKey != NULL);
    return SHRegWriteUSValue(m_hKey, lpszValueName, REG_BINARY,
        (LPVOID)pb, dwCount, RegSetFlags());
}

inline LONG CRegKey::SetValueOfType(const BYTE *pb, LPCTSTR lpszValueName, DWORD dwCount, DWORD dwType)
{
    TransAssert(pb != NULL);
    TransAssert(m_hKey != NULL);

    return SHRegWriteUSValue(m_hKey, lpszValueName, dwType,
        (LPVOID)pb, dwCount, RegSetFlags());
}

inline LONG CRegKey::EnumKey(DWORD dwIndex, LPTSTR lpszName, LPDWORD pcchName)
{
    TransAssert(pcchName != NULL);

    return SHRegEnumUSKey(m_hKey, dwIndex, lpszName, pcchName, RegEnumFlags());
}

inline LONG CRegKey::EnumValue(DWORD dwIndex, LPTSTR pszValueName, LPDWORD pcchValueNameLen, 
                                  LPDWORD pdwType, LPVOID pvData, LPDWORD pcbData)
{
    // If these counts are all NULL, you will not get anything useful back.
    TransAssert(pcchValueNameLen != NULL || pdwType != NULL || pcbData != NULL);

    return SHRegEnumUSValue(m_hKey, dwIndex, pszValueName, pcchValueNameLen, pdwType,
                                pvData, pcbData, RegEnumFlags());
}

inline LONG CRegKey::QuerySubKeyInfo(DWORD *pdwNumKeys, DWORD *pdwMaxLen, DWORD *pdwNumValues)
{
    return SHRegQueryInfoUSKey (m_hKey, pdwNumKeys, pdwMaxLen,
        pdwNumValues, NULL, RegEnumFlags());
}
       
inline HUSKEY CRegKey::Detach()
{
    HUSKEY hKey = m_hKey;
    m_hKey = NULL;
    return hKey;
}

inline void CRegKey::Attach(HUSKEY hKey)
{
    TransAssert(m_hKey == NULL);
    m_hKey = hKey;
}

inline LONG CRegKey::DeleteValue(LPCTSTR lpszValue)
{
    TransAssert(m_hKey != NULL);
    return SHRegDeleteUSValue(m_hKey, lpszValue, RegDelFlags());
}

inline LONG CRegKey::DeleteEmptyKey(LPCTSTR pszSubKey)
{
    TransAssert(m_hKey != NULL);
    return SHRegDeleteEmptyUSKey(m_hKey, pszSubKey, RegDelFlags());
}

// Simple helper class to get an exclusive lock for the duration of a function. 
// WILL NOT BLOCK IF THE HANDLE PASSED IS NULL OR INVALID.

class CExclusiveLock 
{
public:
    CExclusiveLock(HANDLE hMutex);  // pass in a handle to a mutex.
    ~CExclusiveLock();
private:
    HANDLE m_hMutex;
    BOOL fOk;
};

inline CExclusiveLock::CExclusiveLock( HANDLE hMutex )
{
    fOk = FALSE;
    if ( hMutex )
    {
        m_hMutex = hMutex;
        DWORD dw = WaitForSingleObject(hMutex, INFINITE);
        if ( (dw == WAIT_OBJECT_0) || (dw == WAIT_ABANDONED) )
        {
            // fix IE bug 18152
            fOk = TRUE;
        }
        else
        {
            TransAssert(FALSE); //shouldn't be anything else
        }
    }
}

inline CExclusiveLock::~CExclusiveLock( )
{
    if ( fOk )
    {
        ReleaseMutex(m_hMutex);
    }
}
                

// Helper class to create a shared memory object to share between processes. 

class CSharedMem
{
public:
    CSharedMem() { m_hFileMapping = NULL; m_lpVoidShared = NULL ; m_dwSize = 0; };
    ~CSharedMem( ) { Release( ); }
    BOOL Init(LPCSTR pszNamePrefix, DWORD dwSize);
    VOID Release( );
    // Offset into the shared memory section.
    // Always check return value since this can return NULL.
    LPVOID GetPtr (DWORD dwOffset); 

private:
    HANDLE m_hFileMapping ; 
    LPVOID m_lpVoidShared; 
    DWORD m_dwSize;
};

extern CSharedMem g_SharedMem;

// Shared memory related constants
#define SM_REGZONECHANGE_COUNTER    0   // Dword at offset 0
#define SM_SECMGRCHANGE_COUNTER     4   // Dword at offset 4

#define SM_SECTION_SIZE             8   // Total size of shared memory section.
#define SM_SECTION_NAME             "UrlZonesSM_"

// registry key paths - absolute
#define SZROOT          TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\")
#define SZZONES         SZROOT TEXT("Zones\\")
#define SZTEMPLATE      SZROOT TEXT("TemplatePolicies\\")
#define SZZONEMAP       SZROOT TEXT("ZoneMap\\")
#define SZCACHE         SZROOT TEXT("Cache")

#define SZPOLICIES      TEXT("Software\\Policies\\Microsoft\\Windows\\CurrentVersion\\Internet Settings")
#define SZHKLMONLY      TEXT("Security_HKLM_only")

// Entries to figure out if per user cache is allowed.
#define SZLOGON         TEXT("Network\\Logon")
#define SZUSERPROFILES  TEXT("UserProfiles")

// Cache location if per user cache is allowed.
#define SZSHELLFOLDER   TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders")
#define SZTIFS          TEXT("Cache")

// cache location if global
#define SZCACHECONTENT  SZROOT TEXT("Cache\\Content")
#define SZCACHEPATH     TEXT("CachePath")


// registry key paths - relative to SZZONES
#define SZZONESTANDARD      TEXT("Standard\\")
#define SZZONEUSERDEFINED   TEXT("User-Defined\\")

// registry key paths - relative to SZZONEMAP
#define SZDOMAINS           TEXT("Domains\\")
#define SZRANGES            TEXT("Ranges\\")
#define SZPROTOCOLS         TEXT("ProtocolDefaults\\")

// registry value names
#define SZINTRANETNAME      TEXT("IntranetName")
#define SZUNCASINTRANET     TEXT("UNCAsIntranet")
#define SZPROXYBYPASS       TEXT("ProxyBypass")
#define SZRANGE             TEXT(":Range")
#define SZRANGEPREFIX       TEXT("Range")

// Attributes to deal with "High", "Med", "Low" template policies
#define SZMINLEVEL              __TEXT("MinLevel")
#define SZRECLEVEL              __TEXT("RecommendedLevel")
#define SZCURRLEVEL             __TEXT("CurrentLevel")

// registry key path for allowed activex controls list; relative to HKEY_LOCAL_MACHINE _or_ HKEY_CURRENT_USER
#define ALLOWED_CONTROLS_KEY  TEXT("SOFTWARE\\Policies\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\AllowedControls")


#define CSTRLENW(str)       (sizeof(str)/sizeof(TCHAR) - 1)

#define MARK_PREFIX_SIZE                30
#define MARK_SUFFIX_SIZE                10
#define EXTRA_BUFFER_SIZE               1024
#define UNICODE_HEADER_SIZE             2

#endif // _URLZONE_UTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\proxycfg\proxycfg.cxx ===
// ===========================================================================
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//
// Copyright 2000 Microsoft Corporation.  All Rights Reserved.
// ===========================================================================
#include <windows.h>
#include <stdlib.h>
#include <stdio.h>
#include <fcntl.h>
#include <stdlib.h>
#include <io.h>
#include <wininet.h>
#include <proxreg.h>

//
// private macros
//

#define ALLOCATE_FIXED_MEMORY(Size) LocalAlloc(LMEM_FIXED, Size)

#define FREE_FIXED_MEMORY(hLocal)   LocalFree((HLOCAL)(hLocal))

#define REGOPENKEY(a, b, c)         RegOpenKey((a), (b), (c))

#define REGOPENKEYEX(a, b, c, d, e) RegOpenKeyEx((a), (b), (c), (d), (e))

#define REGCREATEKEYEX(a, b, c, d, e, f, g, h, i) \
    RegCreateKeyEx((a), (b), (c), (d), (e), (f), (g), (h), (i))

#define REGCLOSEKEY(a)              RegCloseKey(a)

#define CASE_OF(constant)   case constant: return # constant


//
// private prototypes
//

LPSTR InternetMapError(DWORD Error);


/*
    usage:

    proxyconfig -?  : to view help information

    proxyconfig     : to view current proxy settings under HKLM.

    proxyconfig [-d] [-p <server-name> [<bypass-list>]]

        -d : enable PROXY_TYPE_DIRECT
        -p : enable PROXY_TYPE_PROXY, with given proxy name and optional bypass list

 */


enum ARGTYPE
{
    ARGS_HELP,
    ARGS_SET_PROXY_SETTINGS,
    ARGS_VIEW_PROXY_SETTINGS,
    ARGS_INITIALIZE_PROXY_SETTINGS, // updates from HKCU only if never init
    ARGS_MIGRATE_PROXY_SETTINGS     // forces update from HKCU
};


struct ARGS
{
    ARGTYPE Command;

    DWORD   Flags;
    char *  ProxyServer;
    char *  BypassList;
};

#define INTERNET_SETTINGS_KEY         "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Internet Settings"

static const CHAR szRegPathConnections[] = INTERNET_SETTINGS_KEY "\\Connections";


void ParseArguments(int argc, char ** argv, ARGS * Args)
{
    Args->Command = ARGS_VIEW_PROXY_SETTINGS;
    Args->Flags = PROXY_TYPE_DIRECT;
    Args->ProxyServer = NULL;
    Args->BypassList = NULL;

    if (argc == 0)
        return;

    for (;;)
    {
        if ((argv[0][0] != '-') || (lstrlen(argv[0]) != 2))
        {
            Args->Command = ARGS_HELP;
            goto Exit;
        }

        switch (tolower(argv[0][1]))
        {
        default:
            Args->Command = ARGS_HELP;
            goto Exit;

        case 'd':
            Args->Command = ARGS_SET_PROXY_SETTINGS;
            Args->Flags   = PROXY_TYPE_DIRECT;

            argc--;
            argv++; 

            if (argc == 0)
                goto Exit;

            continue;

        case 'i':
            Args->Command = ARGS_INITIALIZE_PROXY_SETTINGS;
            goto Exit;
            
        case 'p':
            argc--;
            argv++;

            if (argc == 0)
            {
                // error: no proxy specified
                Args->Command = ARGS_HELP;
            }
            else
            {
                Args->Command = ARGS_SET_PROXY_SETTINGS;
                Args->Flags  |= PROXY_TYPE_PROXY;

                Args->ProxyServer = argv[0];

                argc--;
                argv++;

                if (argc >= 1)
                {
                    Args->BypassList = argv[0];
                }
            }
            goto Exit;

        case 'u':
            Args->Command = ARGS_MIGRATE_PROXY_SETTINGS;
            goto Exit;
            
        }
       
    }

Exit:
    return;
}


DWORD WriteProxySettings(INTERNET_PROXY_INFO_EX * pInfo)
{
    CRegBlob    r(TRUE);
    DWORD       error = ERROR_SUCCESS;
    long        lRes;

    // verify pInfo
    if(NULL == pInfo || pInfo->dwStructSize != sizeof(INTERNET_PROXY_INFO_EX))
    {
        return ERROR_INVALID_PARAMETER;
    }

    // init blob
    lRes = r.Init(HKEY_LOCAL_MACHINE, szRegPathConnections, "WinHttpSettings");
    if (lRes)
    {
        error = lRes;
        goto quit;
    }

    if (r.WriteBytes(&pInfo->dwStructSize, sizeof(DWORD)) == 0
        || r.WriteBytes(&pInfo->dwCurrentSettingsVersion, sizeof(DWORD)) == 0
        || r.WriteBytes(&pInfo->dwFlags, sizeof(DWORD)) == 0
        || r.WriteString(pInfo->lpszProxy) == 0
        || r.WriteString(pInfo->lpszProxyBypass) == 0)
    {
        error = ERROR_NOT_ENOUGH_MEMORY;
        r.Abandon();
        goto quit;
    }

    lRes = r.Commit();
    if (lRes)
    {
        error = lRes;
        goto quit;
    }

quit:
    return error;
}


void SetProxySettings(DWORD Flags, char * ProxyServer, char * BypassList)
{
    INTERNET_PROXY_INFO_EX  Info;
    DWORD                   error;

    // initialize structure
    memset(&Info, 0, sizeof(Info));
    Info.dwStructSize = sizeof(Info);
    Info.lpszConnectionName = "WinHttpSettings";
    Info.dwFlags = Flags;
    Info.dwCurrentSettingsVersion = 0;
    Info.lpszProxy = ProxyServer;
    Info.lpszProxyBypass = BypassList;

    error = WriteProxySettings(&Info);

    if (error)
    {
        fprintf(stderr, "Error (%s) writing proxy settings.\n", InternetMapError(error));
    }
    else
    {
        fprintf(stderr, "Updating proxy settings\n");
    }
}


DWORD MigrateProxySettings (void)
{
    INTERNET_PER_CONN_OPTION_LIST list;
    DWORD dwBufSize = sizeof(list);
    DWORD dwErr = ERROR_SUCCESS;
    
    // fill out list struct
    list.dwSize = sizeof(list);
    list.pszConnection = NULL;      // NULL == LAN, otherwise connectoid name
    list.dwOptionCount = 3;         // get three options
    list.pOptions = new INTERNET_PER_CONN_OPTION[3];
    if(NULL == list.pOptions)
        return ERROR_NOT_ENOUGH_MEMORY;
        
    list.pOptions[0].dwOption = INTERNET_PER_CONN_FLAGS;
    list.pOptions[1].dwOption = INTERNET_PER_CONN_PROXY_SERVER;
    list.pOptions[2].dwOption = INTERNET_PER_CONN_PROXY_BYPASS;

    // ask wininet
    BOOL fRet = InternetQueryOption (NULL,
        INTERNET_OPTION_PER_CONNECTION_OPTION,
        &list,
        &dwBufSize);

// TODO: what if there is no manual proxy setting?

    if (!fRet)
    {
        dwErr = GetLastError();
        goto cleanup;
    }
    else
    {
        SetProxySettings(
             list.pOptions[0].Value.dwValue,
             list.pOptions[1].Value.pszValue,
             list.pOptions[2].Value.pszValue
             );
    }
    
cleanup:

    GlobalFree (list.pOptions[1].Value.pszValue);
    GlobalFree (list.pOptions[2].Value.pszValue);
    delete [] list.pOptions;

    if (dwErr == ERROR_INTERNET_INVALID_OPTION)
    {
        fprintf (stderr, "proxycfg: requires IE 5.01\n");
    }
    return dwErr;
}

DWORD ReadProxySettings(INTERNET_PROXY_INFO_EX * pInfo)
{
    CRegBlob    r(FALSE);
    DWORD       error = ERROR_SUCCESS;
    long        lRes;

    // verify pInfo
    if(NULL == pInfo || pInfo->dwStructSize != sizeof(INTERNET_PROXY_INFO_EX))
    {
        return ERROR_INVALID_PARAMETER;
    }

    // initialize structure
    memset(pInfo, 0, sizeof(*pInfo));
    pInfo->dwStructSize = sizeof(*pInfo);
    pInfo->lpszConnectionName = "WinHttpSettings";
    pInfo->dwFlags = PROXY_TYPE_DIRECT;

    // init blob
    lRes = r.Init(HKEY_LOCAL_MACHINE, szRegPathConnections, "WinHttpSettings");
    if (lRes)
    {
        error = (lRes == ERROR_FILE_NOT_FOUND) ? ERROR_SUCCESS : lRes;
        goto quit;
    }

    // read fields from blob
    if(0 == r.ReadBytes(&pInfo->dwStructSize, sizeof(DWORD)) ||
         (pInfo->dwStructSize < sizeof(*pInfo)))
    {
        // blob didn't exist or in correct format - set default values
        pInfo->dwStructSize = sizeof(*pInfo);
    }
    else
    {
        // read the rest of the blob
        r.ReadBytes(&pInfo->dwCurrentSettingsVersion, sizeof(DWORD));
        r.ReadBytes(&pInfo->dwFlags, sizeof(DWORD));
        r.ReadString(&pInfo->lpszProxy);
        r.ReadString(&pInfo->lpszProxyBypass);
    }

    //
    // WinHttpX does not support proxy autodection or autoconfig URL's,
    // so make sure those PROXY_TYPE flags are turned off.
    //
    pInfo->dwFlags &= ~(PROXY_TYPE_AUTO_DETECT | PROXY_TYPE_AUTO_PROXY_URL);

quit:
    return error;
}


void ViewProxySettings()
{
    INTERNET_PROXY_INFO_EX  Info;
    DWORD                   error;
    char *                  szFlags;

    Info.dwStructSize = sizeof(Info);

    error = ReadProxySettings(&Info);

    if (error)
    {
        fprintf(stderr, "\nError (%s) reading proxy settings.\n", InternetMapError(error));
        return;
    }

    fprintf(stdout, "\nCurrent WinHTTP proxy settings under\n\n  HKEY_LOCAL_MACHINE\\\n    %s\\\n      WinHttpSettings :\n\n", szRegPathConnections);

    switch (Info.dwFlags)
    {
    case PROXY_TYPE_DIRECT:                     szFlags = "PROXY_TYPE_DIRECT";  break;
    case PROXY_TYPE_PROXY:                      szFlags = "PROXY_TYPE_PROXY";   break;
    case PROXY_TYPE_DIRECT | PROXY_TYPE_PROXY:  szFlags = "PROXY_TYPE_DIRECT | PROXY_TYPE_PROXY"; break;
    default:    szFlags = "-error-";
    }

    fprintf(stdout, "    Flags        = %s\n", szFlags);

    fprintf(stdout, "    Proxy Server = %s\n", Info.lpszProxy ? Info.lpszProxy : "-not set-");

    fprintf(stdout, "    Bypass List  = %s\n\n", Info.lpszProxyBypass ? Info.lpszProxyBypass : "-not set-");
}


int __cdecl main (int argc, char **argv)
{
    ARGS    Args;
    DWORD dwErr;
    
    // Discard program arg.
    argv++;
    argc--;

    ParseArguments(argc, argv, &Args);

    switch (Args.Command)
    {
    
    case ARGS_HELP:
    default:
        fprintf (stderr,
            "\nWinHTTP Proxy Configuration Tool\n\n"
            "usage:\n\n"
            "    proxycfg -?  : to view help information\n\n"
            "    proxycfg     : to view current winhttp proxy settings (in HKLM)\n\n"
            "    proxycfg [-d] [-p <server-name> [<bypass-list>]]\n\n"
            "        -d : set PROXY_TYPE_DIRECT\n"
            "        -p : set PROXY_TYPE_PROXY, proxy server, and optional bypass list\n\n"
            "    proxycfg -u  : to set winhttp proxy settings\n"
            "                   from current user's manual setting (in HKCU)\n"
            "\n");
        break;

    case ARGS_SET_PROXY_SETTINGS:

        SetProxySettings(Args.Flags, Args.ProxyServer, Args.BypassList);
        ViewProxySettings();
        break;

    case ARGS_INITIALIZE_PROXY_SETTINGS:

        // First make sure the proxy settings have never been set before.
        INTERNET_PROXY_INFO_EX Info;
        Info.dwStructSize = sizeof(Info);
        dwErr = ReadProxySettings (&Info);
        if (dwErr != ERROR_FILE_NOT_FOUND)
        {
            fprintf (stderr, "proxycfg: WinHTTP proxy settings already set.\n");
            fprintf (stderr, "proxycfg: Use -u to force update from current user.\n");
            break;
        }
        // else intentional fall through
    
    case ARGS_MIGRATE_PROXY_SETTINGS:
    
        dwErr = MigrateProxySettings();
        if (dwErr != ERROR_SUCCESS)
        {
            fprintf (stderr, "proxycfg: failed with err %d\n", dwErr);
            exit (dwErr);
        }
        ViewProxySettings();
        break;

    case ARGS_VIEW_PROXY_SETTINGS:
    
        ViewProxySettings();
        break;
    }

    return 0;
}        




///////////////////////////////////////////////////////////////////////////
//
// CRegBlob implementation - copied from dll\proxreg.cxx
//
///////////////////////////////////////////////////////////////////////////

CRegBlob::CRegBlob(
    BOOL fWrite
    )
{
    // initialize members
    _fWrite = fWrite;
    _fCommit = TRUE;
    _dwOffset = 0;
    _pBuffer = NULL;
    _dwBufferLimit = 0;
    _hkey = NULL;
}


CRegBlob::~CRegBlob(
    )
{
    if(_hkey)
        REGCLOSEKEY(_hkey);

    if(_pBuffer)
        FREE_FIXED_MEMORY(_pBuffer);

    // caller owns _pszValue pointer
}


DWORD
CRegBlob::Init(
    HKEY hBaseKey,
    LPCSTR pszSubKey,
    LPCSTR pszValue
    )
{
    long lRes;
    REGSAM  regsam = KEY_QUERY_VALUE;
    DWORD dwDisposition;

    // If we're writing, save reg value name and set access
    if(_fWrite)
    {
        _pszValue = pszValue;
        regsam = KEY_SET_VALUE;

        lRes = REGCREATEKEYEX(hBaseKey, pszSubKey, 0, "", 0,
                    regsam, NULL, &_hkey, &dwDisposition);
    }
    else
    {
        // Use RegOpenKeyEx instead if not writing.
        lRes = REGOPENKEYEX(hBaseKey, pszSubKey, 0, regsam, &_hkey);
    }

    if(lRes != ERROR_SUCCESS)
    {
        return lRes;
    }

    // figure out buffer size
    _dwBufferLimit = BLOB_BUFF_GRANULARITY;
    if(FALSE == _fWrite)
    {
        // get size of registry blob
        lRes = RegQueryValueEx(_hkey, pszValue, NULL, NULL, NULL, &_dwBufferLimit);
        if(lRes != ERROR_SUCCESS)
        {
            if (_fWrite)
            {
                // nothing there - make zero size buffer
                _dwBufferLimit = 0;
            }
            else
            {
                return lRes;
            }
        }
    }

    // allocate buffer if necessary
    if(_dwBufferLimit)
    {
        _pBuffer = (BYTE *)ALLOCATE_FIXED_MEMORY(_dwBufferLimit);
        if(NULL == _pBuffer)
            return GetLastError();
    }

    // if we're reading, fill in buffer
    if(FALSE == _fWrite && _dwBufferLimit)
    {
        // read reg key
        DWORD dwSize = _dwBufferLimit;
        lRes = RegQueryValueEx(_hkey, pszValue, NULL, NULL, _pBuffer, &dwSize);
        if(lRes != ERROR_SUCCESS)
        {
            return lRes;
        }
    }

    // reset pointer to beginning of blob
    _dwOffset = 0;

    return 0;
}

DWORD
CRegBlob::Abandon(
    VOID
    )
{
    // don't commit changes when the time comes
    _fCommit = FALSE;

    return 0;
}

DWORD
CRegBlob::Commit(
    )
{
    long lres = 0;

    if(_fCommit && _fWrite && _pszValue && _pBuffer)
    {
        // save blob to reg key
        lres = RegSetValueEx(_hkey, _pszValue, 0, REG_BINARY, _pBuffer, _dwOffset);
    }

    return lres;
}


DWORD
CRegBlob::Encrpyt(
    )
{
    return 0;
}


DWORD
CRegBlob::Decrypt(
    )
{
    return 0;
}


DWORD
CRegBlob::WriteString(
    LPCSTR pszString
    )
{
    DWORD dwBytes, dwLen = 0;

    if(pszString)
    {
        dwLen = lstrlen(pszString);
    }

    dwBytes = WriteBytes(&dwLen, sizeof(DWORD));
    if(dwLen && dwBytes == sizeof(DWORD))
        dwBytes = WriteBytes(pszString, dwLen);

    return dwBytes;
}



DWORD
CRegBlob::ReadString(
    LPCSTR * ppszString
    )
{
    DWORD dwLen, dwBytes = 0;
    LPSTR lpszTemp = NULL;

    dwBytes = ReadBytes(&dwLen, sizeof(DWORD));
    if(dwBytes == sizeof(DWORD))
    {
        if(dwLen)
        {
            lpszTemp = (LPSTR)GlobalAlloc(GPTR, dwLen + 1);
            if(lpszTemp)
            {
                dwBytes = ReadBytes(lpszTemp, dwLen);
                lpszTemp[dwBytes] = 0;
            }
        }
    }

    *ppszString = lpszTemp;
    return dwBytes;
}


DWORD
CRegBlob::WriteBytes(
    LPCVOID pBytes,
    DWORD dwByteCount
    )
{
    BYTE * pNewBuffer;

    // can only do this on write blob
    if(FALSE == _fWrite)
        return 0;

    // grow buffer if necessary
    if(_dwBufferLimit - _dwOffset < dwByteCount)
    {
        DWORD dw = ((dwByteCount / BLOB_BUFF_GRANULARITY)+1)*BLOB_BUFF_GRANULARITY;
        pNewBuffer = (BYTE *)ALLOCATE_FIXED_MEMORY(dw);
        if(NULL == pNewBuffer)
        {
            // failed to get more memory
            return 0;
        }

        memset(pNewBuffer, 0, dw);
        memcpy(pNewBuffer, _pBuffer, _dwBufferLimit);
        FREE_FIXED_MEMORY(_pBuffer);
        _pBuffer = pNewBuffer;
        _dwBufferLimit = dw;
    }

    // copy callers data to buffer
    memcpy(_pBuffer + _dwOffset, pBytes, dwByteCount);
    _dwOffset += dwByteCount;

    // tell caller how much we wrote
    return dwByteCount;
}



DWORD
CRegBlob::ReadBytes(
    LPVOID pBytes,
    DWORD dwByteCount
    )
{
    DWORD   dwActual = _dwBufferLimit - _dwOffset;

    // can only do this on read blob
    if(_fWrite)
        return 0;

    // don't read past end of blob
    if(dwByteCount < dwActual)
        dwActual = dwByteCount;

    // copy bytes and increment offset
    if(dwActual > 0)
    {
        memcpy(pBytes, _pBuffer + _dwOffset, dwActual);
        _dwOffset += dwActual;
    }

    // tell caller how much we actually read
    return dwActual;
}


LPSTR InternetMapError(DWORD Error)

/*++

Routine Description:

    Map error code to string. Try to get all errors that might ever be returned
    by an Internet function

Arguments:

    Error   - code to map

Return Value:

    LPSTR - pointer to symbolic error name

--*/

{
    switch (Error)
    {
    //
    // WINERROR errors
    //

    CASE_OF(ERROR_SUCCESS);
    CASE_OF(ERROR_INVALID_FUNCTION);
    CASE_OF(ERROR_FILE_NOT_FOUND);
    CASE_OF(ERROR_PATH_NOT_FOUND);
    CASE_OF(ERROR_TOO_MANY_OPEN_FILES);
    CASE_OF(ERROR_ACCESS_DENIED);
    CASE_OF(ERROR_INVALID_HANDLE);
    CASE_OF(ERROR_ARENA_TRASHED);
    CASE_OF(ERROR_NOT_ENOUGH_MEMORY);
    CASE_OF(ERROR_INVALID_BLOCK);
    CASE_OF(ERROR_BAD_ENVIRONMENT);
    CASE_OF(ERROR_BAD_FORMAT);
    CASE_OF(ERROR_INVALID_ACCESS);
    CASE_OF(ERROR_INVALID_DATA);
    CASE_OF(ERROR_OUTOFMEMORY);
    CASE_OF(ERROR_INVALID_DRIVE);
    CASE_OF(ERROR_CURRENT_DIRECTORY);
    CASE_OF(ERROR_NOT_SAME_DEVICE);
    CASE_OF(ERROR_NO_MORE_FILES);
    CASE_OF(ERROR_WRITE_PROTECT);
    CASE_OF(ERROR_BAD_UNIT);
    CASE_OF(ERROR_NOT_READY);
    CASE_OF(ERROR_BAD_COMMAND);
    CASE_OF(ERROR_CRC);
    CASE_OF(ERROR_BAD_LENGTH);
    CASE_OF(ERROR_SEEK);
    CASE_OF(ERROR_NOT_DOS_DISK);
    CASE_OF(ERROR_SECTOR_NOT_FOUND);
    CASE_OF(ERROR_OUT_OF_PAPER);
    CASE_OF(ERROR_WRITE_FAULT);
    CASE_OF(ERROR_READ_FAULT);
    CASE_OF(ERROR_GEN_FAILURE);
    CASE_OF(ERROR_SHARING_VIOLATION);
    CASE_OF(ERROR_LOCK_VIOLATION);
    CASE_OF(ERROR_WRONG_DISK);
    CASE_OF(ERROR_SHARING_BUFFER_EXCEEDED);
    CASE_OF(ERROR_HANDLE_EOF);
    CASE_OF(ERROR_HANDLE_DISK_FULL);
    CASE_OF(ERROR_NOT_SUPPORTED);
    CASE_OF(ERROR_REM_NOT_LIST);
    CASE_OF(ERROR_DUP_NAME);
    CASE_OF(ERROR_BAD_NETPATH);
    CASE_OF(ERROR_NETWORK_BUSY);
    CASE_OF(ERROR_DEV_NOT_EXIST);
    CASE_OF(ERROR_TOO_MANY_CMDS);
    CASE_OF(ERROR_ADAP_HDW_ERR);
    CASE_OF(ERROR_BAD_NET_RESP);
    CASE_OF(ERROR_UNEXP_NET_ERR);
    CASE_OF(ERROR_BAD_REM_ADAP);
    CASE_OF(ERROR_PRINTQ_FULL);
    CASE_OF(ERROR_NO_SPOOL_SPACE);
    CASE_OF(ERROR_PRINT_CANCELLED);
    CASE_OF(ERROR_NETNAME_DELETED);
    CASE_OF(ERROR_NETWORK_ACCESS_DENIED);
    CASE_OF(ERROR_BAD_DEV_TYPE);
    CASE_OF(ERROR_BAD_NET_NAME);
    CASE_OF(ERROR_TOO_MANY_NAMES);
    CASE_OF(ERROR_TOO_MANY_SESS);
    CASE_OF(ERROR_SHARING_PAUSED);
    CASE_OF(ERROR_REQ_NOT_ACCEP);
    CASE_OF(ERROR_REDIR_PAUSED);
    CASE_OF(ERROR_FILE_EXISTS);
    CASE_OF(ERROR_CANNOT_MAKE);
    CASE_OF(ERROR_FAIL_I24);
    CASE_OF(ERROR_OUT_OF_STRUCTURES);
    CASE_OF(ERROR_ALREADY_ASSIGNED);
    CASE_OF(ERROR_INVALID_PASSWORD);
    CASE_OF(ERROR_INVALID_PARAMETER);
    CASE_OF(ERROR_NET_WRITE_FAULT);
    CASE_OF(ERROR_NO_PROC_SLOTS);
    CASE_OF(ERROR_TOO_MANY_SEMAPHORES);
    CASE_OF(ERROR_EXCL_SEM_ALREADY_OWNED);
    CASE_OF(ERROR_SEM_IS_SET);
    CASE_OF(ERROR_TOO_MANY_SEM_REQUESTS);
    CASE_OF(ERROR_INVALID_AT_INTERRUPT_TIME);
    CASE_OF(ERROR_SEM_OWNER_DIED);
    CASE_OF(ERROR_SEM_USER_LIMIT);
    CASE_OF(ERROR_DISK_CHANGE);
    CASE_OF(ERROR_DRIVE_LOCKED);
    CASE_OF(ERROR_BROKEN_PIPE);
    CASE_OF(ERROR_OPEN_FAILED);
    CASE_OF(ERROR_BUFFER_OVERFLOW);
    CASE_OF(ERROR_DISK_FULL);
    CASE_OF(ERROR_NO_MORE_SEARCH_HANDLES);
    CASE_OF(ERROR_INVALID_TARGET_HANDLE);
    CASE_OF(ERROR_INVALID_CATEGORY);
    CASE_OF(ERROR_INVALID_VERIFY_SWITCH);
    CASE_OF(ERROR_BAD_DRIVER_LEVEL);
    CASE_OF(ERROR_CALL_NOT_IMPLEMENTED);
    CASE_OF(ERROR_SEM_TIMEOUT);
    CASE_OF(ERROR_INSUFFICIENT_BUFFER);
    CASE_OF(ERROR_INVALID_NAME);
    CASE_OF(ERROR_INVALID_LEVEL);
    CASE_OF(ERROR_NO_VOLUME_LABEL);
    CASE_OF(ERROR_MOD_NOT_FOUND);
    CASE_OF(ERROR_PROC_NOT_FOUND);
    CASE_OF(ERROR_WAIT_NO_CHILDREN);
    CASE_OF(ERROR_CHILD_NOT_COMPLETE);
    CASE_OF(ERROR_DIRECT_ACCESS_HANDLE);
    CASE_OF(ERROR_NEGATIVE_SEEK);
    CASE_OF(ERROR_SEEK_ON_DEVICE);
    CASE_OF(ERROR_DIR_NOT_ROOT);
    CASE_OF(ERROR_DIR_NOT_EMPTY);
    CASE_OF(ERROR_PATH_BUSY);
    CASE_OF(ERROR_SYSTEM_TRACE);
    CASE_OF(ERROR_INVALID_EVENT_COUNT);
    CASE_OF(ERROR_TOO_MANY_MUXWAITERS);
    CASE_OF(ERROR_INVALID_LIST_FORMAT);
    CASE_OF(ERROR_BAD_ARGUMENTS);
    CASE_OF(ERROR_BAD_PATHNAME);
    CASE_OF(ERROR_BUSY);
    CASE_OF(ERROR_CANCEL_VIOLATION);
    CASE_OF(ERROR_ALREADY_EXISTS);
    CASE_OF(ERROR_FILENAME_EXCED_RANGE);
    CASE_OF(ERROR_LOCKED);
    CASE_OF(ERROR_NESTING_NOT_ALLOWED);
    CASE_OF(ERROR_BAD_PIPE);
    CASE_OF(ERROR_PIPE_BUSY);
    CASE_OF(ERROR_NO_DATA);
    CASE_OF(ERROR_PIPE_NOT_CONNECTED);
    CASE_OF(ERROR_MORE_DATA);
    CASE_OF(ERROR_NO_MORE_ITEMS);
    CASE_OF(ERROR_NOT_OWNER);
    CASE_OF(ERROR_PARTIAL_COPY);
    CASE_OF(ERROR_MR_MID_NOT_FOUND);
    CASE_OF(ERROR_INVALID_ADDRESS);
    CASE_OF(ERROR_PIPE_CONNECTED);
    CASE_OF(ERROR_PIPE_LISTENING);
    CASE_OF(ERROR_OPERATION_ABORTED);
    CASE_OF(ERROR_IO_INCOMPLETE);
    CASE_OF(ERROR_IO_PENDING);
    CASE_OF(ERROR_NOACCESS);
    CASE_OF(ERROR_STACK_OVERFLOW);
    CASE_OF(ERROR_INVALID_FLAGS);
    CASE_OF(ERROR_NO_TOKEN);
    CASE_OF(ERROR_BADDB);
    CASE_OF(ERROR_BADKEY);
    CASE_OF(ERROR_CANTOPEN);
    CASE_OF(ERROR_CANTREAD);
    CASE_OF(ERROR_CANTWRITE);
    CASE_OF(ERROR_REGISTRY_RECOVERED);
    CASE_OF(ERROR_REGISTRY_CORRUPT);
    CASE_OF(ERROR_REGISTRY_IO_FAILED);
    CASE_OF(ERROR_NOT_REGISTRY_FILE);
    CASE_OF(ERROR_KEY_DELETED);
    CASE_OF(ERROR_CIRCULAR_DEPENDENCY);
    CASE_OF(ERROR_SERVICE_NOT_ACTIVE);
    CASE_OF(ERROR_DLL_INIT_FAILED);
    CASE_OF(ERROR_CANCELLED);
    CASE_OF(ERROR_BAD_USERNAME);
    CASE_OF(ERROR_LOGON_FAILURE);

    CASE_OF(WAIT_FAILED);
    //CASE_OF(WAIT_ABANDONED_0);
    CASE_OF(WAIT_TIMEOUT);
    CASE_OF(WAIT_IO_COMPLETION);
    //CASE_OF(STILL_ACTIVE);

    CASE_OF(RPC_S_INVALID_STRING_BINDING);
    CASE_OF(RPC_S_WRONG_KIND_OF_BINDING);
    CASE_OF(RPC_S_INVALID_BINDING);
    CASE_OF(RPC_S_PROTSEQ_NOT_SUPPORTED);
    CASE_OF(RPC_S_INVALID_RPC_PROTSEQ);
    CASE_OF(RPC_S_INVALID_STRING_UUID);
    CASE_OF(RPC_S_INVALID_ENDPOINT_FORMAT);
    CASE_OF(RPC_S_INVALID_NET_ADDR);
    CASE_OF(RPC_S_NO_ENDPOINT_FOUND);
    CASE_OF(RPC_S_INVALID_TIMEOUT);
    CASE_OF(RPC_S_OBJECT_NOT_FOUND);
    CASE_OF(RPC_S_ALREADY_REGISTERED);
    CASE_OF(RPC_S_TYPE_ALREADY_REGISTERED);
    CASE_OF(RPC_S_ALREADY_LISTENING);
    CASE_OF(RPC_S_NO_PROTSEQS_REGISTERED);
    CASE_OF(RPC_S_NOT_LISTENING);
    CASE_OF(RPC_S_UNKNOWN_MGR_TYPE);
    CASE_OF(RPC_S_UNKNOWN_IF);
    CASE_OF(RPC_S_NO_BINDINGS);
    CASE_OF(RPC_S_NO_PROTSEQS);
    CASE_OF(RPC_S_CANT_CREATE_ENDPOINT);
    CASE_OF(RPC_S_OUT_OF_RESOURCES);
    CASE_OF(RPC_S_SERVER_UNAVAILABLE);
    CASE_OF(RPC_S_SERVER_TOO_BUSY);
    CASE_OF(RPC_S_INVALID_NETWORK_OPTIONS);
    CASE_OF(RPC_S_NO_CALL_ACTIVE);
    CASE_OF(RPC_S_CALL_FAILED);
    CASE_OF(RPC_S_CALL_FAILED_DNE);
    CASE_OF(RPC_S_PROTOCOL_ERROR);
    CASE_OF(RPC_S_UNSUPPORTED_TRANS_SYN);
    CASE_OF(RPC_S_UNSUPPORTED_TYPE);
    CASE_OF(RPC_S_INVALID_TAG);
    CASE_OF(RPC_S_INVALID_BOUND);
    CASE_OF(RPC_S_NO_ENTRY_NAME);
    CASE_OF(RPC_S_INVALID_NAME_SYNTAX);
    CASE_OF(RPC_S_UNSUPPORTED_NAME_SYNTAX);
    CASE_OF(RPC_S_UUID_NO_ADDRESS);
    CASE_OF(RPC_S_DUPLICATE_ENDPOINT);
    CASE_OF(RPC_S_UNKNOWN_AUTHN_TYPE);
    CASE_OF(RPC_S_MAX_CALLS_TOO_SMALL);
    CASE_OF(RPC_S_STRING_TOO_LONG);
    CASE_OF(RPC_S_PROTSEQ_NOT_FOUND);
    CASE_OF(RPC_S_PROCNUM_OUT_OF_RANGE);
    CASE_OF(RPC_S_BINDING_HAS_NO_AUTH);
    CASE_OF(RPC_S_UNKNOWN_AUTHN_SERVICE);
    CASE_OF(RPC_S_UNKNOWN_AUTHN_LEVEL);
    CASE_OF(RPC_S_INVALID_AUTH_IDENTITY);
    CASE_OF(RPC_S_UNKNOWN_AUTHZ_SERVICE);
    CASE_OF(EPT_S_INVALID_ENTRY);
    CASE_OF(EPT_S_CANT_PERFORM_OP);
    CASE_OF(EPT_S_NOT_REGISTERED);
    CASE_OF(RPC_S_NOTHING_TO_EXPORT);
    CASE_OF(RPC_S_INCOMPLETE_NAME);
    CASE_OF(RPC_S_INVALID_VERS_OPTION);
    CASE_OF(RPC_S_NO_MORE_MEMBERS);
    CASE_OF(RPC_S_NOT_ALL_OBJS_UNEXPORTED);
    CASE_OF(RPC_S_INTERFACE_NOT_FOUND);
    CASE_OF(RPC_S_ENTRY_ALREADY_EXISTS);
    CASE_OF(RPC_S_ENTRY_NOT_FOUND);
    CASE_OF(RPC_S_NAME_SERVICE_UNAVAILABLE);
    CASE_OF(RPC_S_INVALID_NAF_ID);
    CASE_OF(RPC_S_CANNOT_SUPPORT);
    CASE_OF(RPC_S_NO_CONTEXT_AVAILABLE);
    CASE_OF(RPC_S_INTERNAL_ERROR);
    CASE_OF(RPC_S_ZERO_DIVIDE);
    CASE_OF(RPC_S_ADDRESS_ERROR);
    CASE_OF(RPC_S_FP_DIV_ZERO);
    CASE_OF(RPC_S_FP_UNDERFLOW);
    CASE_OF(RPC_S_FP_OVERFLOW);
    CASE_OF(RPC_X_NO_MORE_ENTRIES);
    CASE_OF(RPC_X_SS_CHAR_TRANS_OPEN_FAIL);
    CASE_OF(RPC_X_SS_CHAR_TRANS_SHORT_FILE);
    CASE_OF(RPC_X_SS_IN_NULL_CONTEXT);
    CASE_OF(RPC_X_SS_CONTEXT_DAMAGED);
    CASE_OF(RPC_X_SS_HANDLES_MISMATCH);
    CASE_OF(RPC_X_SS_CANNOT_GET_CALL_HANDLE);
    CASE_OF(RPC_X_NULL_REF_POINTER);
    CASE_OF(RPC_X_ENUM_VALUE_OUT_OF_RANGE);
    CASE_OF(RPC_X_BYTE_COUNT_TOO_SMALL);
    CASE_OF(RPC_X_BAD_STUB_DATA);


    //
    // WININET errors
    //

    CASE_OF(ERROR_INTERNET_OUT_OF_HANDLES);
    CASE_OF(ERROR_INTERNET_TIMEOUT);
    CASE_OF(ERROR_INTERNET_EXTENDED_ERROR);
    CASE_OF(ERROR_INTERNET_INTERNAL_ERROR);
    CASE_OF(ERROR_INTERNET_INVALID_URL);
    CASE_OF(ERROR_INTERNET_UNRECOGNIZED_SCHEME);
    CASE_OF(ERROR_INTERNET_NAME_NOT_RESOLVED);
    CASE_OF(ERROR_INTERNET_PROTOCOL_NOT_FOUND);
    CASE_OF(ERROR_INTERNET_INVALID_OPTION);
    CASE_OF(ERROR_INTERNET_BAD_OPTION_LENGTH);
    CASE_OF(ERROR_INTERNET_OPTION_NOT_SETTABLE);
    CASE_OF(ERROR_INTERNET_SHUTDOWN);
    CASE_OF(ERROR_INTERNET_INCORRECT_USER_NAME);
    CASE_OF(ERROR_INTERNET_INCORRECT_PASSWORD);
    CASE_OF(ERROR_INTERNET_LOGIN_FAILURE);
    CASE_OF(ERROR_INTERNET_INVALID_OPERATION);
    CASE_OF(ERROR_INTERNET_OPERATION_CANCELLED);
    CASE_OF(ERROR_INTERNET_INCORRECT_HANDLE_TYPE);
    CASE_OF(ERROR_INTERNET_INCORRECT_HANDLE_STATE);
    CASE_OF(ERROR_INTERNET_NOT_PROXY_REQUEST);
    CASE_OF(ERROR_INTERNET_REGISTRY_VALUE_NOT_FOUND);
    CASE_OF(ERROR_INTERNET_BAD_REGISTRY_PARAMETER);
    CASE_OF(ERROR_INTERNET_NO_DIRECT_ACCESS);
    CASE_OF(ERROR_INTERNET_NO_CONTEXT);
    CASE_OF(ERROR_INTERNET_NO_CALLBACK);
    CASE_OF(ERROR_INTERNET_REQUEST_PENDING);
    CASE_OF(ERROR_INTERNET_INCORRECT_FORMAT);
    CASE_OF(ERROR_INTERNET_ITEM_NOT_FOUND);
    CASE_OF(ERROR_INTERNET_CANNOT_CONNECT);
    CASE_OF(ERROR_INTERNET_CONNECTION_ABORTED);
    CASE_OF(ERROR_INTERNET_CONNECTION_RESET);
    CASE_OF(ERROR_INTERNET_FORCE_RETRY);
    CASE_OF(ERROR_INTERNET_INVALID_PROXY_REQUEST);
    CASE_OF(ERROR_INTERNET_NEED_UI);
    CASE_OF(ERROR_INTERNET_HANDLE_EXISTS);
    CASE_OF(ERROR_INTERNET_SEC_CERT_DATE_INVALID);
    CASE_OF(ERROR_INTERNET_SEC_CERT_CN_INVALID);
    CASE_OF(ERROR_INTERNET_HTTP_TO_HTTPS_ON_REDIR);
    CASE_OF(ERROR_INTERNET_HTTPS_TO_HTTP_ON_REDIR);
    CASE_OF(ERROR_INTERNET_MIXED_SECURITY);
    CASE_OF(ERROR_INTERNET_CHG_POST_IS_NON_SECURE);
    CASE_OF(ERROR_INTERNET_POST_IS_NON_SECURE);
    CASE_OF(ERROR_INTERNET_CLIENT_AUTH_CERT_NEEDED);
    CASE_OF(ERROR_INTERNET_INVALID_CA);
    CASE_OF(ERROR_INTERNET_CLIENT_AUTH_NOT_SETUP);
    CASE_OF(ERROR_INTERNET_ASYNC_THREAD_FAILED);
    CASE_OF(ERROR_INTERNET_REDIRECT_SCHEME_CHANGE);
    CASE_OF(ERROR_INTERNET_DIALOG_PENDING);
    CASE_OF(ERROR_INTERNET_RETRY_DIALOG);
    CASE_OF(ERROR_INTERNET_HTTPS_HTTP_SUBMIT_REDIR);
    CASE_OF(ERROR_INTERNET_INSERT_CDROM);
    CASE_OF(ERROR_INTERNET_FORTEZZA_LOGIN_NEEDED);
    CASE_OF(ERROR_INTERNET_SEC_CERT_ERRORS);
    CASE_OF(ERROR_INTERNET_SECURITY_CHANNEL_ERROR);
    CASE_OF(ERROR_INTERNET_UNABLE_TO_CACHE_FILE);
    CASE_OF(ERROR_INTERNET_TCPIP_NOT_INSTALLED);
    CASE_OF(ERROR_INTERNET_SERVER_UNREACHABLE);
    CASE_OF(ERROR_INTERNET_PROXY_SERVER_UNREACHABLE);
    CASE_OF(ERROR_INTERNET_BAD_AUTO_PROXY_SCRIPT);
    CASE_OF(ERROR_INTERNET_UNABLE_TO_DOWNLOAD_SCRIPT);
    CASE_OF(ERROR_INTERNET_SEC_INVALID_CERT);
    CASE_OF(ERROR_INTERNET_SEC_CERT_REVOKED);
    CASE_OF(ERROR_INTERNET_FAILED_DUETOSECURITYCHECK);
    CASE_OF(ERROR_INTERNET_NOT_INITIALIZED);

    CASE_OF(ERROR_HTTP_HEADER_NOT_FOUND);
    CASE_OF(ERROR_HTTP_DOWNLEVEL_SERVER);
    CASE_OF(ERROR_HTTP_INVALID_SERVER_RESPONSE);
    CASE_OF(ERROR_HTTP_INVALID_HEADER);
    CASE_OF(ERROR_HTTP_INVALID_QUERY_REQUEST);
    CASE_OF(ERROR_HTTP_HEADER_ALREADY_EXISTS);
    CASE_OF(ERROR_HTTP_REDIRECT_FAILED);
    CASE_OF(ERROR_HTTP_NOT_REDIRECTED);
    CASE_OF(ERROR_HTTP_COOKIE_NEEDS_CONFIRMATION);
    CASE_OF(ERROR_HTTP_COOKIE_DECLINED);
    CASE_OF(ERROR_HTTP_REDIRECT_NEEDS_CONFIRMATION);

    //
    // SSPI errors
    //

    CASE_OF(SEC_E_INSUFFICIENT_MEMORY);
    CASE_OF(SEC_E_INVALID_HANDLE);
    CASE_OF(SEC_E_UNSUPPORTED_FUNCTION);
    CASE_OF(SEC_E_TARGET_UNKNOWN);
    CASE_OF(SEC_E_INTERNAL_ERROR);
    CASE_OF(SEC_E_SECPKG_NOT_FOUND);
    CASE_OF(SEC_E_NOT_OWNER);
    CASE_OF(SEC_E_CANNOT_INSTALL);
    CASE_OF(SEC_E_INVALID_TOKEN);
    CASE_OF(SEC_E_CANNOT_PACK);
    CASE_OF(SEC_E_QOP_NOT_SUPPORTED);
    CASE_OF(SEC_E_NO_IMPERSONATION);
    CASE_OF(SEC_E_LOGON_DENIED);
    CASE_OF(SEC_E_UNKNOWN_CREDENTIALS);
    CASE_OF(SEC_E_NO_CREDENTIALS);
    CASE_OF(SEC_E_MESSAGE_ALTERED);
    CASE_OF(SEC_E_OUT_OF_SEQUENCE);
    CASE_OF(SEC_E_NO_AUTHENTICATING_AUTHORITY);
    CASE_OF(SEC_I_CONTINUE_NEEDED);
    CASE_OF(SEC_I_COMPLETE_NEEDED);
    CASE_OF(SEC_I_COMPLETE_AND_CONTINUE);
    CASE_OF(SEC_I_LOCAL_LOGON);
    CASE_OF(SEC_E_BAD_PKGID);
    CASE_OF(SEC_E_CONTEXT_EXPIRED);
    CASE_OF(SEC_E_INCOMPLETE_MESSAGE);


    //
    // WINSOCK errors
    //

    CASE_OF(WSAEINTR);
    CASE_OF(WSAEBADF);
    CASE_OF(WSAEACCES);
    CASE_OF(WSAEFAULT);
    CASE_OF(WSAEINVAL);
    CASE_OF(WSAEMFILE);
    CASE_OF(WSAEWOULDBLOCK);
    CASE_OF(WSAEINPROGRESS);
    CASE_OF(WSAEALREADY);
    CASE_OF(WSAENOTSOCK);
    CASE_OF(WSAEDESTADDRREQ);
    CASE_OF(WSAEMSGSIZE);
    CASE_OF(WSAEPROTOTYPE);
    CASE_OF(WSAENOPROTOOPT);
    CASE_OF(WSAEPROTONOSUPPORT);
    CASE_OF(WSAESOCKTNOSUPPORT);
    CASE_OF(WSAEOPNOTSUPP);
    CASE_OF(WSAEPFNOSUPPORT);
    CASE_OF(WSAEAFNOSUPPORT);
    CASE_OF(WSAEADDRINUSE);
    CASE_OF(WSAEADDRNOTAVAIL);
    CASE_OF(WSAENETDOWN);
    CASE_OF(WSAENETUNREACH);
    CASE_OF(WSAENETRESET);
    CASE_OF(WSAECONNABORTED);
    CASE_OF(WSAECONNRESET);
    CASE_OF(WSAENOBUFS);
    CASE_OF(WSAEISCONN);
    CASE_OF(WSAENOTCONN);
    CASE_OF(WSAESHUTDOWN);
    CASE_OF(WSAETOOMANYREFS);
    CASE_OF(WSAETIMEDOUT);
    CASE_OF(WSAECONNREFUSED);
    CASE_OF(WSAELOOP);
    CASE_OF(WSAENAMETOOLONG);
    CASE_OF(WSAEHOSTDOWN);
    CASE_OF(WSAEHOSTUNREACH);
    CASE_OF(WSAENOTEMPTY);
    CASE_OF(WSAEPROCLIM);
    CASE_OF(WSAEUSERS);
    CASE_OF(WSAEDQUOT);
    CASE_OF(WSAESTALE);
    CASE_OF(WSAEREMOTE);
    CASE_OF(WSAEDISCON);
    CASE_OF(WSASYSNOTREADY);
    CASE_OF(WSAVERNOTSUPPORTED);
    CASE_OF(WSANOTINITIALISED);
    CASE_OF(WSAHOST_NOT_FOUND);
    CASE_OF(WSATRY_AGAIN);
    CASE_OF(WSANO_RECOVERY);
    CASE_OF(WSANO_DATA);

    default:
        return "?";
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\webcontrols\src\tbar\toolbar.cs ===
//------------------------------------------------------------------------------
/// <copyright from='2000' to='2001' company='Microsoft Corporation'>           
///    Copyright (c) Microsoft Corporation. All Rights Reserved.                
///    Information Contained Herein is Proprietary and Confidential.            
/// </copyright>                                                                
//------------------------------------------------------------------------------

using System;
using System.Collections;
using System.Web;
using System.Web.UI;
using System.Web.UI.WebControls;

namespace ToolbarControls
{

    /// <summary>
    ///    <para>Base class for the toolbar control to handle browser versions and copying expandos.</para>
    /// </summary>
    public class ToolbarControlBase : WebControl
    {
        private string minBrowser = "ie";
        private int minMajorVersion = 5;
        private double minMinorVersion = 0.5;

        protected bool IsUpLevelBrowser()
        {
            HttpBrowserCapabilities browser = Context.Request.Browser;

            return ((browser.Browser.ToLower() == minBrowser) && 
                    ((browser.MajorVersion > minMajorVersion) ||
                     ((browser.MajorVersion == minMajorVersion) && (browser.MinorVersion >= minMinorVersion))
                    ));
        }

        protected virtual void RenderUpLevel(HtmlTextWriter writer)
        {
        }

        protected virtual void RenderDownLevel(HtmlTextWriter writer)
        {
        }

        protected override void Render(HtmlTextWriter writer)
        {
            if (IsUpLevelBrowser())
            {
                RenderUpLevel(writer);
            }
            else
            {
                RenderDownLevel(writer);
            }
        }
    }

    /// <summary>
    ///    <para>Represents a toolbar item.</para>
    /// </summary>
    /// <remarks>
    /// <para>Renders the necessary attributes and tags to render a toolbar item.</para>
    /// </remarks>
    public class ToolbarItem : ToolbarControlBase
    {
        protected int _nIndex;
        protected string _szGroupName;
        protected string _szType;

        public int _InternalIndex
        {
            get { return _nIndex; }
            set { _nIndex = value; }
        }

        public string Type
        {
            get { return _szType; }
            set { _szType = value.ToLower(); }
        }

        public string GroupName
        {
            get { return _szGroupName; }
            set { _szGroupName = value; }
        }

        public bool Selected
        {
            get
            {
                if (State["selected"] == null)
                {
                    return false;
                }

                return (bool)State["selected"];
            }

            set
            {
                State["selected"] = value;
            }
        }

        protected Toolbar GetParentToolbar()
        {
            Control parent = Parent;
            while ((parent != null) && !typeof(Toolbar).IsInstanceOfType(parent))
            {
                parent = parent.Parent;
            }

            return (Toolbar)parent;
        }

        protected override void RenderUpLevel(HtmlTextWriter writer)
        {
            AddAttributesToRender(writer);
            writer.AddAttribute("type", Type);

            if (Type == "checkbutton")
            {
                writer.AddAttribute("groupname", GroupName);
                writer.AddAttribute("selected", Selected.ToString());
            }

            writer.RenderBeginTag("TOOLBARNS:TOOLBARITEM");
            RenderContents(writer);
            writer.RenderEndTag();
        }

        protected override void RenderDownLevel(HtmlTextWriter writer)
        {
            AddAttributesToRender(writer);
            writer.AddAttribute("NOWRAP", "");
            writer.AddAttribute("VALIGN", "bottom");
            writer.RenderBeginTag("TD");

            if ((Type == "button") || (Type == "checkbutton"))
            {
                Toolbar tbParent = GetParentToolbar();

                if (tbParent != null)
                {
                    bool bSelected = ((Type == "checkbutton") && Selected);
                    if (bSelected)
                    {
                        writer.RenderBeginTag("B");
                    }

                    string szEvent = "onclick," + _InternalIndex + "," + (!Selected).ToString();
                    writer.AddAttribute("HREF", "javascript:" +
                        Page.GetPostBackEventReference(tbParent, szEvent));


                    writer.RenderBeginTag("A");
                    RenderContents(writer);
                    writer.RenderEndTag();

                    if (bSelected)
                    {
                        writer.RenderEndTag();
                    }
                }
            }
            else if (Type == "separator")
            {
                writer.Write("&nbsp");
            }
            else
            {
                RenderContents(writer);
            }

            writer.RenderEndTag();
        }
    }

    /// <summary>
    ///    <para>Represents the event when a toolbar item is clicked.</para>
    /// </summary>
    /// <remarks>
    /// <para>Holds the source node's index and the ID (if available).</para>
    /// </remarks>
    public class ToolbarClickEventArgs : EventArgs
    {
        protected string _szSrcNodeID;
        protected int _nSrcNodeIndex;

        public string SrcNodeID
        {
            get { return _szSrcNodeID; }
            set { _szSrcNodeID = value; }
        }

        public int SrcNodeIndex
        {
            get { return _nSrcNodeIndex; }
            set { _nSrcNodeIndex = value; }
        }
    }

    /// <summary>
    ///    <para>Represents a toolbar.</para>
    /// </summary>
    /// <remarks>
    /// <para>Renders the necessary tags to display a toolbar and handles the onclick event.</para>
    /// </remarks>
    public class Toolbar : ToolbarControlBase, IPostBackEventHandler
    {
        private EventHandler _onServerClick;
        private Hashtable _Items = new Hashtable();

        public void AddOnServerClick(EventHandler handler)
        {
            if (handler != null)
            {
                _onServerClick = (EventHandler)Delegate.Combine(_onServerClick, handler);
            }
        }

        public virtual void RemoveOnServerClick(EventHandler handler)
        {
            if (handler != null)
            {
                _onServerClick = (EventHandler)Delegate.Remove(_onServerClick, handler);
            }
        }

        protected virtual void OnServerClick(EventArgs e)
        {
            if (_onServerClick != null)
            {
                _onServerClick(this, e);   // call the delegate if non-null
            }
        }

        public void RaisePostBackEvent(String eventArgument)
        {
            DoIndexing();

            int nIndex;
            int[] sep = new int[4];

            sep[0] = 0;
            for (nIndex = 1; nIndex < (sep.Length - 1); nIndex++)
            {
                sep[nIndex] = eventArgument.IndexOf(',', sep[nIndex - 1]) + 1;
                if (sep[nIndex] == 0)
                    return;
            }
            sep[sep.Length - 1] = eventArgument.Length + 1;

            string[] args = new string[sep.Length - 1];
            for (nIndex = 0; nIndex < args.Length; nIndex++)
            {
                args[nIndex] = eventArgument.Substring(sep[nIndex], sep[nIndex + 1] - sep[nIndex] - 1);
                if (args[nIndex] == null)
                    return;
            }

            string szEvent = args[0];
            if (szEvent.CompareTo("onclick") == 0)
            {
                int nSrcIndex = args[1].ToInt32();

                bool bSelected = args[2].ToLower() == "true" ? true : false;
                SelectCheckButton(nSrcIndex, bSelected);

                // Do the event
                ToolbarClickEventArgs eventArgs = new ToolbarClickEventArgs();
                eventArgs.SrcNodeIndex = nSrcIndex;
                eventArgs.SrcNodeID = ((ToolbarItem)_Items[nSrcIndex]).ID;
                OnServerClick(eventArgs);
            }
        }

        protected void SelectCheckButton(int nSelectedIndex, bool bSelected)
        {
            ToolbarItem tbItem = (ToolbarItem)_Items[nSelectedIndex];
            if ((tbItem == null) || (tbItem.Type != "checkbutton"))
                return;

            string szSelGroupName = tbItem.GroupName;

            if ((szSelGroupName != null) && bSelected)
            {
                int nIndex;
                for (nIndex = 0; nIndex < _Items.Count; nIndex++)
                {
                    if (nIndex != nSelectedIndex)
                    {
                        ToolbarItem item = (ToolbarItem)_Items[nIndex];
                        string szGroupName = item.GroupName;
                        if ((szGroupName != null) && (szGroupName == szSelGroupName))
                        {
                            item.Selected = false;
                        }
                    }
                }
            }

            if ((szSelGroupName == null) || bSelected)
            {
                tbItem.Selected = bSelected;
            }
        }

        protected void VerifyCheckButtons()
        {
            int nIndex;
            for (nIndex = 0; nIndex < _Items.Count; nIndex++)
            {
                ToolbarItem item = (ToolbarItem)_Items[nIndex];
                if ((item.Type == "checkbutton") && item.Selected)
                {
                    SelectCheckButton(nIndex, true);
                }
            }
        }

        protected void DoIndexing()
        {
            _Items.Clear();
            IndexToolbarItems(this, 0);
        }

        protected int IndexToolbarItems(Control parent, int nIndex)
        {
            bool bDownLevel = !IsUpLevelBrowser();

            for (int i = 0; i < parent.Controls.Size; i++)
            {
                Control cntrl = parent.Controls[i];
                if (typeof(ToolbarItem).IsInstanceOfType(cntrl))
                {
                    ToolbarItem tbItem = (ToolbarItem)cntrl;
                    tbItem._InternalIndex = nIndex;

                    _Items.Add(nIndex, tbItem);

                    nIndex++;
                }

                nIndex = IndexToolbarItems(cntrl, nIndex);
            }

            return nIndex;
        }

        protected override void PreRender()
        {
            DoIndexing();
            VerifyCheckButtons();

            if (Page != null)
            {
                Page.RegisterPostBackScript();

                if (IsUpLevelBrowser())
                {
                    string szEvent = "onclick,'+event.srcIndex+','+((event.srcNode.type.toLowerCase() == 'checkbutton') ? event.srcNode.selected : 'false') +'";
                    SetAttribute("onclick", "javascript:" + 
                        Page.GetPostBackEventReference(this, szEvent));
                }
            }
        }

        protected override void RenderUpLevel(HtmlTextWriter writer)
        {
            writer.Write("<?XML:NAMESPACE PREFIX=TOOLBARNS /><?IMPORT NAMESPACE=\"TOOLBARNS\" IMPLEMENTATION=\"toolbar.htc\">");
            AddAttributesToRender(writer);
            writer.RenderBeginTag("TOOLBARNS:TOOLBAR");
            RenderContents(writer);
            writer.RenderEndTag();
        }

        protected override void RenderDownLevel(HtmlTextWriter writer)
        {
            AddAttributesToRender(writer);
            writer.AddAttribute("BORDER", "1");
            writer.AddAttribute("CELLSPACING", "0");
            writer.RenderBeginTag("TABLE");
            writer.RenderBeginTag("TR");
            RenderContents(writer);
            writer.RenderEndTag();
            writer.RenderEndTag();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\test\httpasync.cxx ===
// ===========================================================================
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//
// Copyright 1996 Microsoft Corporation.  All Rights Reserved.
// ===========================================================================
#include <windows.h>
#include <stdlib.h>
#include <stdio.h>
#include <fcntl.h>
#include <stdlib.h>
#include <io.h>
#include <winhttp.h>
#define _UNICODE 
#include <tchar.h>

//==============================================================================
//#define GLOBAL_SESSION 1

#ifdef GLOBAL_SESSION
HINTERNET g_hInternet = NULL;
#endif

#ifndef ASSERT
#define ASSERT( exp ) \
    ((!(exp)) ? \
        DebugBreak() : \
        ((void)0))
#endif

typedef enum
{
    HTTP_INIT = 0,
    HTTP_OPEN = 1,
    HTTP_SEND = 2,
    HTTP_QDA  = 3,
    HTTP_READ = 4,
    HTTP_READ_PASS_SYNC  = 5,
    HTTP_READ_PASS_ASYNC = 6,
    HTTP_READ_FAIL_SYNC  = 7,
    HTTP_READ_FAIL_ASYNC = 8,
    HTTP_SEND_FAIL_SYNC  = 9,
    HTTP_SEND_FAIL_ASYNC = 10
} HTTP_STATE;

typedef struct
{
    HTTP_STATE state;
    BOOL bQDA;
    DWORD dwTotal;
    DWORD_PTR dwResult;
    DWORD dwError;
    HANDLE hEvent;
    DWORD dwSignature;
    BOOL bCallbackDelete;
} TestContext;

VOID CALLBACK Callback(IN HINTERNET hInternet, IN DWORD_PTR dwContext,
                           IN DWORD dwStatus, IN LPVOID pvInfo, IN DWORD dwStatusLen)
{
#if 0
    fprintf(stderr, "callback!!!!!! dwStatus %d\n", dwStatus);
#endif

    TestContext* pContext = (TestContext*)dwContext;
    if ((dwStatus == WINHTTP_CALLBACK_STATUS_REQUEST_COMPLETE) && pContext)
    {
        ASSERT (pContext->dwSignature == 0);
        if (pContext->bCallbackDelete)
        {
            delete pContext;
            goto end;
        }
        
        DWORD_PTR dwResult = ((LPWINHTTP_ASYNC_RESULT)(pvInfo))->dwResult;
        DWORD dwError = ((LPWINHTTP_ASYNC_RESULT) (pvInfo) )->dwError;

        pContext->dwResult = dwResult;
        pContext->dwError = dwError;
        SetEvent(pContext->hEvent);
#if 0
        OutputDebugString("\n\tWINHTTP_CALLBACK_STATUS_REQUEST_COMPLETE for QDA\n");
		fprintf(stderr, "\n\tWINHTTP_CALLBACK_STATUS_REQUEST_COMPLETE for QDA with %d result and %d error.\n", dwResult, dwBytes);
#endif
    }

end:
    return;
}

#define CHECK_ERROR(cond, err) if (!(cond)) {pszErr=(err); goto done;}

//==============================================================================
int RequestLoop (int argc, char **argv)
{
#ifndef GLOBAL_SESSION
    HINTERNET g_hInternet = NULL;
#endif
    HINTERNET hConnect  = NULL;
    HINTERNET hRequest  = NULL;

    DWORD   dwAccessType   = WINHTTP_ACCESS_TYPE_DEFAULT_PROXY;
    WCHAR   szProxyServer[256];
    WCHAR   szProxyBypass[256];

    DWORD dwConnectFlags = 0;
    BOOL fPreAuth = FALSE;

    PSTR pPostData = NULL;
    DWORD cbPostData = 0;
    
    PSTR pszErr = NULL;
    BOOL fRet;
    DWORD dwErr = ERROR_SUCCESS;

    DWORD dwTarget = WINHTTP_AUTH_TARGET_SERVER;
    LPVOID pAuthParams = NULL;

    DWORD option = WINHTTP_OPTION_RESOLVE_TIMEOUT;
    DWORD dwTimeout = 1000;
    HANDLE hEvent = NULL;

    PSTR pszObject   = NULL;
    PSTR pszPostFile = NULL;
    char pszHost[128];
    PSTR pszColon    = NULL;
    BOOL bDeleteContext = TRUE;

    TestContext* pContext = new TestContext();
    CHECK_ERROR(pContext, "new TestContext");
    
    memset(pContext, 0, sizeof(TestContext));
    
    // Parse options.
    while (argc && argv[0][0] == '-')
    {
        switch (tolower(argv[0][1]))
        {
            case 'p':
                dwAccessType = WINHTTP_ACCESS_TYPE_NAMED_PROXY;
                dwTarget = WINHTTP_AUTH_TARGET_PROXY;
                ::MultiByteToWideChar(CP_ACP, 0, argv[1],   -1, &szProxyServer[0], 256);
                // pszProxyServer = argv[1];
                ::MultiByteToWideChar(CP_ACP, 0, "<local>", -1, &szProxyBypass[0], 256);
                // pszProxyBypass = "<local>";
                argv++;
                argc--;
                break;

            case 's':
                dwConnectFlags = WINHTTP_FLAG_SECURE;
                break;

            case 'a':
                fPreAuth = TRUE;
                break;

            default:
                fprintf (stderr, "\nUsage: httpauth [-p <proxy>] [-s] <server> [<object> [<user> [<pass> [<POST-file>]]]]");
                fprintf (stderr, "\n  -s: Secure connection (ssl or pct)");
                fprintf (stderr, "\n  -p: specify proxy server. (\"<local>\" assumed for bypass.)");
                exit (1);
        }
        
        argv++;
        argc--;
    }

    // Parse host:port
    {
        int nlen = strlen(argv[0]);
        if (nlen > sizeof(pszHost))
            goto done;
        strcpy(pszHost, argv[0]);
    }
    
    DWORD dwPort;
    pszColon = strchr(pszHost, ':');
    if (!pszColon)
        dwPort = INTERNET_DEFAULT_PORT;
    else
    {
        *pszColon++ = 0;
        dwPort = atol (pszColon);
    }

    pszObject   = argc >= 2 ? argv[1] : "/";
    pszPostFile = argc >= 3 ? argv[2] : NULL;

    // Read any POST data into a buffer.
    if (pszPostFile)
    {
        HANDLE hf =
            CreateFile
            (
                pszPostFile,
                GENERIC_READ,
                FILE_SHARE_READ,
                NULL,
                OPEN_EXISTING,
                FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN,
                NULL
            );
        if (hf != INVALID_HANDLE_VALUE)
        {
            cbPostData = GetFileSize (hf, NULL);
            pPostData = (PSTR) LocalAlloc (LMEM_FIXED, cbPostData + 1);
            if (pPostData)
                ReadFile (hf, pPostData, cbPostData, &cbPostData, NULL);
            pPostData[cbPostData] = 0;
            CloseHandle (hf);
        }
    }

    // Initialize wininet.
#ifdef GLOBAL_SESSION
    if (!g_hInternet)
#endif
        g_hInternet = WinHttpOpen
        (
            _T("HttpAuth Sample"),            // user agent
            // "Mozilla/4.0 (compatible; MSIE 4.0b2; Windows 95",
            dwAccessType,                 // access type
            szProxyServer,               // proxy server
            szProxyBypass,               // proxy bypass
            WINHTTP_FLAG_ASYNC          // flags
        );
    CHECK_ERROR (g_hInternet, "WinHttpOpen");


    WCHAR szHost[256];
    ::MultiByteToWideChar(CP_ACP, 0, pszHost,   -1, &szHost[0], 256);

    WinHttpSetStatusCallback(g_hInternet, Callback, WINHTTP_CALLBACK_FLAG_ALL_NOTIFICATIONS, NULL);
    
    dwTimeout = 1000;
    WinHttpSetOption(
        g_hInternet,
        WINHTTP_OPTION_RESOLVE_TIMEOUT,
        (LPVOID)&dwTimeout,
        sizeof(DWORD)
    );

    dwTimeout = 1000;
    WinHttpSetOption(
        g_hInternet,
        WINHTTP_OPTION_CONNECT_TIMEOUT,
        (LPVOID)&dwTimeout,
        sizeof(DWORD)
    );
    
    dwTimeout = 100;
    WinHttpSetOption(
        g_hInternet,
        WINHTTP_OPTION_SEND_TIMEOUT,
        (LPVOID)&dwTimeout,
        sizeof(DWORD)
    );
    
    dwTimeout = 100;
    WinHttpSetOption(
        g_hInternet,
        WINHTTP_OPTION_RECEIVE_TIMEOUT,
        (LPVOID)&dwTimeout,
        sizeof(DWORD)
    );
    
    hEvent = CreateEvent(NULL, FALSE /*want auto-reset*/, FALSE /*non-signaled init.*/, NULL);

    CHECK_ERROR(hEvent, "CreateEvent");

    pContext->hEvent = hEvent;
  
    // Connect to host.
    hConnect = WinHttpConnect
    (
        g_hInternet,                    // session handle,
        szHost,                      // host
        (INTERNET_PORT) dwPort,       // port
        dwConnectFlags                // flags
    );
    CHECK_ERROR (hConnect, "WinHttpConnect");

    WCHAR szObject[256];
    ::MultiByteToWideChar(CP_ACP, 0, pszObject,   -1, &szObject[0], 256);

    // Create request.
    
    pContext->state = HTTP_OPEN;
    hRequest = WinHttpOpenRequest
    (
        hConnect,                     // connect handle
        pszPostFile? _T("POST") : _T("GET"),  // request method
        szObject,                    // object name
        NULL,                         // version
        NULL,                         // referer
        NULL,                         // accept types
        dwConnectFlags                // flags
    );
    CHECK_ERROR (hRequest, "WinHttpOpenRequest");

    // Send request.
    pContext->state = HTTP_SEND;
    fRet = WinHttpSendRequest
    (
        hRequest,                     // request handle
        _T(""),                       // header string
        0,                            // header length
        pPostData,                    // post data
        cbPostData,                   // post data length
        cbPostData,                   // total post length
        (DWORD_PTR)pContext             // context
    );

    if (!fRet)
    {
        dwErr = GetLastError();
        switch (dwErr)
        {
            case ERROR_WINHTTP_CLIENT_AUTH_CERT_NEEDED:
                break;

            case ERROR_IO_PENDING:
                fRet = WinHttpReceiveResponse(hRequest, NULL);
                if (!fRet)
                {
                    dwErr = GetLastError();
                    if (dwErr != ERROR_IO_PENDING)
                    {
                        fprintf (stderr, "WinHttpReceiveResponse failed err=%d\n", dwErr);
                        break;
                    }
                }
                goto async;
                
            default:
                fprintf (stderr, "HttpSendRequest failed err=%d\n", dwErr);
        }
        pContext->state = HTTP_SEND_FAIL_SYNC;
        goto done;
    }
    else
    {
        fRet = WinHttpReceiveResponse(hRequest, NULL);
        if (!fRet)
        {
            dwErr = GetLastError();
            fprintf (stderr, "WinHttpReceiveResponse failed err=%d\n", dwErr);
            pContext->state = HTTP_SEND_FAIL_SYNC;
        }
        goto sync;
    }

async:
#if 0
    fprintf(stderr, "\nERROR_IO_PENDING on HSR...\n");
#endif
    WaitForSingleObject(hEvent, INFINITE);

    ASSERT( pContext->state == HTTP_SEND );
    if (! (pContext->dwResult) )
    {
        pContext->state = HTTP_SEND_FAIL_ASYNC;
        SetLastError (pContext->dwError);
        goto done;
    }
sync:
    
    // Get status code.
    DWORD dwStatus, cbStatus;
    cbStatus = sizeof(dwStatus);
    WinHttpQueryHeaders
    (
        hRequest,
        WINHTTP_QUERY_FLAG_NUMBER | WINHTTP_QUERY_STATUS_CODE,
        NULL,
        &dwStatus,
        &cbStatus,
        NULL
    );
    fprintf (stderr, "Status: %d\n", dwStatus);

    // Dump some bytes.
    BYTE bBuf[1024];
    DWORD cbBuf;

#define QDA 1
#ifdef QDA
    while (TRUE)
    {
        BOOL bAsyncRead = FALSE;
        pContext->state = HTTP_QDA;
        fRet = WinHttpQueryDataAvailable (hRequest, &(pContext->dwError));
        
        if (!fRet)
        {
            if (GetLastError() == ERROR_IO_PENDING)
            {
#if 0
                OutputDebugString("\nERROR_IO_PENDING on QDA\n");
                fprintf(stderr, "\nERROR_IO_PENDING on QDA...\n");
#endif
                WaitForSingleObject(hEvent, INFINITE);
                
                ASSERT (pContext->state = HTTP_QDA);
                if (!(pContext->dwResult))
                {
                    // Done
                    pContext->state = HTTP_READ_FAIL_ASYNC;
                    SetLastError(pContext->dwError);
                    goto done;
                }
                else if (!(pContext->dwError))
                {
                    pContext->state = HTTP_READ_PASS_ASYNC;
                    goto done;
                }
                bAsyncRead = TRUE;
            }
            else
            {
                pContext->state = HTTP_READ_FAIL_SYNC;
                goto done;
            }
        }
        else if (!(pContext->dwError))
        {
            //Done sync
            pContext->state = HTTP_READ_PASS_SYNC;
            goto done;
        }
            
        DWORD dwRead = pContext->dwError;
        DWORD dwActuallyRead = 0;
        while (dwRead > 0)
        {
            cbBuf = (dwRead > sizeof(bBuf)) ? sizeof(bBuf) : dwRead;
            pContext->state = HTTP_READ;
            fRet = WinHttpReadData(hRequest, bBuf, cbBuf, &dwActuallyRead);

            if (!fRet)
            {
                ASSERT ( GetLastError() != ERROR_IO_PENDING );
                fprintf(stderr, "\nError in WinHttpReadData = %d\n", GetLastError());
                goto done;
            }
            ASSERT((cbBuf == dwActuallyRead));
#if 0
            ASSERT(fRet);
            fwrite (bBuf, 1, dwActuallyRead, stdout);
#endif
            pContext->dwTotal += dwActuallyRead;
            dwRead -= dwActuallyRead;
        }    
    }
#else
    cbBuf = sizeof(bBuf);
    while (WinHttpReadData (hRequest, bBuf, cbBuf, &(pContext->dwRead)) && pContext->dwRead)
        fwrite (bBuf, 1, pContext->dwRead, stdout);
#endif

done: // Clean up.

    if (pszErr)
        fprintf (stderr, "Failed on %s, last error %d\n", pszErr, GetLastError());
    if (hRequest)
        WinHttpCloseHandle (hRequest);
    if (hConnect)
        WinHttpCloseHandle (hConnect);
        
#ifndef GLOBAL_SESSION
    if (g_hInternet)
        WinHttpCloseHandle (g_hInternet);
#endif

    if (pPostData)
        LocalFree (pPostData);
    if (hEvent)
        CloseHandle(hEvent);
    if (pContext && bDeleteContext)
    {
        pContext->dwSignature = 0x41414141;
        delete pContext;
    }
        
    return 0;
}

//==============================================================================
void ParseArguments 
(
    LPSTR  InBuffer,
    LPSTR* CArgv,
    DWORD* CArgc
)
{
    LPSTR CurrentPtr = InBuffer;
    DWORD i = 0;
    DWORD Cnt = 0;

    for ( ;; ) {

        //
        // skip blanks.
        //

        while( *CurrentPtr == ' ' ) {
            CurrentPtr++;
        }

        if( *CurrentPtr == '\0' ) {
            break;
        }

        CArgv[i++] = CurrentPtr;

        //
        // go to next space.
        //

        while(  (*CurrentPtr != '\0') &&
                (*CurrentPtr != '\n') ) {
            if( *CurrentPtr == '"' ) {      // Deal with simple quoted args
                if( Cnt == 0 )
                    CArgv[i-1] = ++CurrentPtr;  // Set arg to after quote
                else
                    *CurrentPtr = '\0';     // Remove end quote
                Cnt = !Cnt;
            }
            if( (Cnt == 0) && (*CurrentPtr == ' ') ||   // If we hit a space and no quotes yet we are done with this arg
                (*CurrentPtr == '\0') )
                break;
            CurrentPtr++;
        }

        if( *CurrentPtr == '\0' ) {
            break;
        }

        *CurrentPtr++ = '\0';
    }

    *CArgc = i;
    return;
}


DWORD WINAPI WorkThread1(LPVOID lpParameter)
{
    int nCount = 0;
    char* pargv[] = {"dennisch", "venkatk/large.html", 0};

    while (nCount++ < 500000)
    {
        fprintf (stderr, "\nLARGE Iteration #%d\n", nCount);
        RequestLoop( 2, pargv);
    }

    fprintf (stderr, "\nLARGE DONE!\n");

    return 0;
}
DWORD WINAPI WorkThread2(LPVOID lpParameter)
{
    int nCount = 0;
    char* pargv[] = {"dennisch", "venkatk/small.html", 0};

    while (nCount++ < 3000000)
    {
        fprintf (stderr, "\nSMALL Iteration #%d\n", nCount);
        RequestLoop( 2, pargv);
    }

    fprintf (stderr, "\nSMALL DONE!\n");

    return 0;
}
DWORD WINAPI WorkThread3(LPVOID lpParameter)
{
    int nCount = 0;
    char* pargv[] = {"venkatk:180", 0};

    while (nCount++ < 10000)
    {
        fprintf (stderr, "\n180 Iteration #%d\n", nCount);
        RequestLoop( 1, pargv);
    }

    fprintf (stderr, "\n180 DONE!\n");

    return 0;
}

//==============================================================================
int __cdecl main (int argc, char **argv)
{
	char * port;
	int nCount = 0;
	// Discard program arg.
    argv++;
    argc--;

    
#if 1
    DWORD dwThreadId;    
    HANDLE hThread1 = CreateThread(NULL, 0, &WorkThread1,
    					NULL, 0, &dwThreadId);
    Sleep(1000);
    HANDLE hThread2 = CreateThread(NULL, 0, &WorkThread2,
    					NULL, 0, &dwThreadId);
    HANDLE hThread3 = CreateThread(NULL, 0, &WorkThread3,
    					NULL, 0, &dwThreadId);

    {
        char* pargv[] = {"pmidge", 0};

        while (nCount++ < 2000000)
        {
            fprintf (stderr, "\nPMIDGE Iteration #%d\n", nCount);
            RequestLoop( 1, pargv);
        }

        fprintf (stderr, "\n180 DONE!\n");
    }

    WaitForSingleObject( hThread1, INFINITE );
    WaitForSingleObject( hThread2, INFINITE );
    WaitForSingleObject( hThread3, INFINITE );
#endif

#if 0
    char* argv_large[] = {"dennisch", "venkatk/large.html", 0};
    char* argv_small[] = {"dennisch", "venkatk/small.html", 0};
    char* argv_delay[] = {"venkatk:180", 0};

    while(nCount++ < 30)
    {
        RequestLoop( 1, argv_delay );
    }
    
    while(nCount++ < 100)
    {
#if 0
        fprintf (stderr, "\nIteration #%d\n", nCount);
#endif
        RequestLoop( 2, argv_large);
        RequestLoop( 2, argv_small);
        RequestLoop( 1, argv_delay);
    }
#endif
    fprintf (stderr, "\nIteration #%d\n", nCount);

#if 0
    if (argc)
        RequestLoop (argc, argv);
        
    else // Enter command prompt loop
    {
        fprintf (stderr, "\nUsage: [-p <proxy>] [-s] <host>[:port] [<object> [<POST-file>]]");
        fprintf (stderr, "\n  -s: use secure sockets layer");
        fprintf (stderr, "\n  -p: specify proxy server. (\"<local>\" assumed for bypass.)");
        fprintf (stderr, "\nTo exit input loop, enter no params");

        while (1)
        {
            char szIn[1024];
            DWORD argcIn;
            LPSTR argvIn[10];

            fprintf (stderr, "\nhttpauth> ");
            gets (szIn);
            
            argcIn = 0;
            ParseArguments (szIn, argvIn, &argcIn);
            if (!argcIn)
                break;
            RequestLoop (argcIn, argvIn);
            //g_cbRead=0;
        }                
    }
#endif

#ifdef GLOBAL_SESSION
    if (g_hInternet)
        WinHttpCloseHandle (g_hInternet);
    g_hInternet = NULL;
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\webcontrols\src\treeview\treeview.cs ===
using System;
using System.Web;
using System.Web.UI;
using System.Web.UI.WebControls;

namespace IEWebControls {

	public class TreeNode : WebControl
	{
		// Properties
		
		public string Text
		{
			get {
				object str = State["Text"];
				return ((str == null) ? String.Empty : (string)str);
			}
			set {
				State["Text"] = value;
			}
		}

		public string ImageUrl
		{
			get {
				object str = State["ImageUrl"];
				return ((str == null) ? String.Empty : (string)str);
			}
			set {
				State["ImageUrl"] = value;
			}
		}

		public string SelectedImageUrl
		{
			get {
				object str = State["SelectedImageUrl"];
				return ((str == null) ? String.Empty : (string)str);
			}
			set {
				State["SelectedImageUrl"] = value;
			}
		}

		public string ExpandedImageUrl
		{
			get {
				object str = State["ExpandedImageUrl"];
				return ((str == null) ? String.Empty : (string)str);
			}
			set {
				State["ExpandedImageUrl"] = value;
			}
		}

		public string NavigateUrl
		{
			get {
				object str = State["NavigateUrl"];
				return ((str == null) ? String.Empty : (string)str);
			}
			set {
				State["NavigateUrl"] = value;
			}
		}

		public string Target
		{
			get {
				object str = State["Target"];
				return ((str == null) ? String.Empty : (string)str);
			}
			set {
				State["Target"] = value;
			}
		}

		public string BubbleCommand
		{
			get {
				object str = State["BubbleCommand"];
				return ((str == null) ? String.Empty : (string)str);
			}
			set {
				State["BubbleCommand"] = value;
			}
		}

		public string BubbleArgument
		{
			get {
				object str = State["BubbleArgument"];
				return ((str == null) ? String.Empty : (string)str);
			}
			set {
				State["BubbleArgument"] = value;
			}
		}

		public string DataFieldText
		{
			get {
				object str = State["DataFieldText"];
				return ((str == null) ? String.Empty : (string)str);
			}
			set {
				State["DataFieldText"] = value;
			}
		}

		public string DataFieldValue
		{
			get {
				object str = State["DataFieldValue"];
				return ((str == null) ? String.Empty : (string)str);
			}
			set {
				State["DataFieldValue"] = value;
			}
		}

		public bool Expanded
		{
			get {
				object b = State["Expanded"];
				return ((b == null) ? false : (bool)b);
			}
			set {
				State["Expanded"] = value;
			}
		}

		public bool Selected
		{
			get {
				object b = State["Selected"];
				return ((b == null) ? false : (bool)b);
			}
			set {
				State["Selected"] = value;
			}
		}

		public bool AutoPostBack
		{
			get {
				object b = State["AutoPostBack"];
				return ((b == null) ? false : (bool)b);
			}
			set {
				State["AutoPostBack"] = value;
			}
		}
		
		protected void OnClick(EventArgs e)
		{
		}

		protected void OnExpand(EventArgs e)
		{
		}
		
		protected void OnCollapse(EventArgs e)
		{
		}

		protected void onHover(EventArgs e)
		{
		}

		public void AddOnClick(EventHandler handler)
		{
		}

		public void RemoveOnClick(EventHandler handler)
		{
		}

		public void AddOnExpand(EventHandler handler)
		{
		}

		public void RemoveOnExpand(EventHandler handler)
		{
		}

		public void AddOnCollapse(EventHandler handler)
		{
		}

		public void RemoveOnCollapse(EventHandler handler)
		{
		}

		public void AddOnHover(EventHandler handler)
		{
		}

		public void RemoveOnHover(EventHandler handler)
		{
		}

	}

    public class TreeView : WebControl {

		public string collapsedImage
		{
			get {
				object str = State["collapsedImage"];
				return ((str == null) ? String.Empty : (string)str);
			}
			set {
				State["collapsedImage"] = value;
			}
		}

		public string expandedImage
		{
			get {
				object str = State["expandedImage"];
				return ((str == null) ? String.Empty : (string)str);
			}
			set {
				State["expandedImage"] = value;
			}
		}

		public string leafImage
		{
			get {
				object str = State["leafImage"];
				return ((str == null) ? String.Empty : (string)str);
			}
			set {
				State["leafImage"] = value;
			}
		}

		protected override void Render(HtmlTextWriter output) {
			output.Write("<?XML:NAMESPACE PREFIX=ie />\n<?IMPORT NAMESPACE=ie IMPLEMENTATION=treeview.htc />\n");
			
			// Write treeview tag
			output.WriteBeginTag("ie:treeview");
			output.WriteAttribute("expandedImage", expandedImage);
			output.WriteAttribute("collapsedImage", collapsedImage);
			output.WriteAttribute("leafImage", leafImage);
			output.WriteAttribute("id", this.ClientID);
			output.Write(">");

			// Write inner content
			if ( (HasControls()) && (Controls[0] is LiteralControl) ) {
				output.Write(((LiteralControl) Controls[0]).Text);
			}          

			// Close treeview tag
			output.WriteEndTag("ie:treeview");

		}
    }    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\test\httpsimple.cxx ===
// ===========================================================================
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//
// Copyright 1996 Microsoft Corporation.  All Rights Reserved.
// ===========================================================================
#include <windows.h>
#include <stdlib.h>
#include <stdio.h>
#include <fcntl.h>
#include <stdlib.h>
#include <io.h>
#include <winhttp.h>
#define _UNICODE 
#include <tchar.h>

//==============================================================================
#define GLOBAL_SESSION 1

#ifdef GLOBAL_SESSION
HINTERNET g_hInternet = NULL;
#endif

#ifndef ASSERT
#define ASSERT( exp ) \
    ((!(exp)) ? \
        DebugBreak() : \
        ((void)0))
#endif

typedef enum
{
    HTTP_INIT = 0,
    HTTP_OPEN = 1,
    HTTP_SEND = 2,
    HTTP_QDA  = 3,
    HTTP_READ = 4,
    HTTP_READ_PASS_SYNC  = 5,
    HTTP_READ_PASS_ASYNC = 6,
    HTTP_READ_FAIL_SYNC  = 7,
    HTTP_READ_FAIL_ASYNC = 8,
    HTTP_SEND_FAIL_SYNC  = 9,
    HTTP_SEND_FAIL_ASYNC = 10
} HTTP_STATE;

typedef struct
{
    HTTP_STATE state;
    BOOL bQDA;
    DWORD dwTotal;
    DWORD_PTR dwResult;
    DWORD dwError;
    HANDLE hEvent;
    DWORD dwSignature;
    BOOL bCallbackDelete;
    DWORD dwRead; //for non-QDA i.e. plain WinHttpReadData
} TestContext;

VOID CALLBACK Callback(IN HINTERNET hInternet, IN DWORD_PTR dwContext,
                           IN DWORD dwStatus, IN LPVOID pvInfo, IN DWORD dwStatusLen)
{
#if 0
    fprintf(stderr, "callback!!!!!! dwStatus %d\n", dwStatus);
#endif

    TestContext* pContext = (TestContext*)dwContext;
    if ((dwStatus == WINHTTP_CALLBACK_STATUS_REQUEST_COMPLETE) && pContext)
    {
        ASSERT (pContext->dwSignature == 0);
        if (pContext->bCallbackDelete)
        {
            delete pContext;
            goto end;
        }
        
        DWORD_PTR dwResult = ((LPWINHTTP_ASYNC_RESULT)(pvInfo))->dwResult;
        DWORD dwError = ((LPWINHTTP_ASYNC_RESULT) (pvInfo) )->dwError;

        pContext->dwResult = dwResult;
        pContext->dwError = dwError;
        SetEvent(pContext->hEvent);
#if 0
        OutputDebugString("\n\tWINHTTP_CALLBACK_STATUS_REQUEST_COMPLETE for QDA\n");
		fprintf(stderr, "\n\tWINHTTP_CALLBACK_STATUS_REQUEST_COMPLETE for QDA with %d result and %d error.\n", dwResult, dwBytes);
#endif
    }

end:
    return;
}

#define CHECK_ERROR(cond, err) if (!(cond)) {pszErr=(err); goto done;}

//==============================================================================
int RequestLoop (int argc, char **argv)
{
#ifndef GLOBAL_SESSION
    HINTERNET g_hInternet = NULL;
#endif
    HINTERNET hConnect  = NULL;
    HINTERNET hRequest  = NULL;

    DWORD   dwAccessType   = WINHTTP_ACCESS_TYPE_DEFAULT_PROXY;
    WCHAR   szProxyServer[256];
    WCHAR   szProxyBypass[256];

    DWORD dwConnectFlags = 0;
    BOOL fPreAuth = FALSE;

    PSTR pPostData = NULL;
    DWORD cbPostData = 0;
    
    PSTR pszErr = NULL;
    BOOL fRet;
    DWORD dwErr = ERROR_SUCCESS;

    DWORD dwTarget = WINHTTP_AUTH_TARGET_SERVER;
    LPVOID pAuthParams = NULL;

    DWORD option = WINHTTP_OPTION_RESOLVE_TIMEOUT;
    DWORD dwTimeout = 10000;
    HANDLE hEvent = NULL;

    PSTR pszObject   = NULL;
    PSTR pszPostFile = NULL;
    char pszHost[128];
    PSTR pszColon    = NULL;
    BOOL bDeleteContext = TRUE;

    TestContext* pContext = new TestContext();
    CHECK_ERROR(pContext, "new TestContext");
    
    memset(pContext, 0, sizeof(TestContext));
    
    // Parse options.
    while (argc && argv[0][0] == '-')
    {
        switch (tolower(argv[0][1]))
        {
            case 'p':
                dwAccessType = WINHTTP_ACCESS_TYPE_NAMED_PROXY;
                dwTarget = WINHTTP_AUTH_TARGET_PROXY;
                ::MultiByteToWideChar(CP_ACP, 0, argv[1],   -1, &szProxyServer[0], 256);
                // pszProxyServer = argv[1];
                ::MultiByteToWideChar(CP_ACP, 0, "<local>", -1, &szProxyBypass[0], 256);
                // pszProxyBypass = "<local>";
                argv++;
                argc--;
                break;

            case 's':
                dwConnectFlags = WINHTTP_FLAG_SECURE;
                break;

            case 'a':
                fPreAuth = TRUE;
                break;

            default:
                fprintf (stderr, "\nUsage: httpauth [-p <proxy>] [-s] <server> [<object> [<user> [<pass> [<POST-file>]]]]");
                fprintf (stderr, "\n  -s: Secure connection (ssl or pct)");
                fprintf (stderr, "\n  -p: specify proxy server. (\"<local>\" assumed for bypass.)");
                exit (1);
        }
        
        argv++;
        argc--;
    }

    // Parse host:port
    {
        int nlen = strlen(argv[0]);
        if (nlen > sizeof(pszHost))
            goto done;
        strcpy(pszHost, argv[0]);
    }
    
    DWORD dwPort;
    pszColon = strchr(pszHost, ':');
    if (!pszColon)
        dwPort = INTERNET_DEFAULT_PORT;
    else
    {
        *pszColon++ = 0;
        dwPort = atol (pszColon);
    }

    pszObject   = argc >= 2 ? argv[1] : "/";
    pszPostFile = argc >= 3 ? argv[2] : NULL;

    // Read any POST data into a buffer.
    if (pszPostFile)
    {
        HANDLE hf =
            CreateFile
            (
                pszPostFile,
                GENERIC_READ,
                FILE_SHARE_READ,
                NULL,
                OPEN_EXISTING,
                FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN,
                NULL
            );
        if (hf != INVALID_HANDLE_VALUE)
        {
            cbPostData = GetFileSize (hf, NULL);
            pPostData = (PSTR) LocalAlloc (LMEM_FIXED, cbPostData + 1);
            if (pPostData)
                ReadFile (hf, pPostData, cbPostData, &cbPostData, NULL);
            pPostData[cbPostData] = 0;
            CloseHandle (hf);
        }
    }

    // Initialize wininet.
#ifdef GLOBAL_SESSION
    if (!g_hInternet)
#endif
        g_hInternet = WinHttpOpen
        (
            _T("HttpAuth Sample"),            // user agent
            // "Mozilla/4.0 (compatible; MSIE 4.0b2; Windows 95",
            dwAccessType,                 // access type
            szProxyServer,               // proxy server
            szProxyBypass,               // proxy bypass
            WINHTTP_FLAG_ASYNC          // flags
        );
    CHECK_ERROR (g_hInternet, "WinHttpOpen");


    WCHAR szHost[256];
    ::MultiByteToWideChar(CP_ACP, 0, pszHost,   -1, &szHost[0], 256);

    WinHttpSetStatusCallback(g_hInternet, Callback, WINHTTP_CALLBACK_FLAG_ALL_NOTIFICATIONS, NULL);
    
    WinHttpSetOption(
        g_hInternet,
        option,
        (LPVOID)&dwTimeout,
        sizeof(DWORD)
    );

    dwTimeout = 10000;
    WinHttpSetOption(
        g_hInternet,
        WINHTTP_OPTION_SEND_TIMEOUT,
        (LPVOID)&dwTimeout,
        sizeof(DWORD)
    );
    
    dwTimeout = 10000;
    WinHttpSetOption(
        g_hInternet,
        WINHTTP_OPTION_RECEIVE_TIMEOUT,
        (LPVOID)&dwTimeout,
        sizeof(DWORD)
    );
    
    hEvent = CreateEvent(NULL, FALSE /*want auto-reset*/, FALSE /*non-signaled init.*/, NULL);

    CHECK_ERROR(hEvent, "CreateEvent");

    pContext->hEvent = hEvent;
  
    // Connect to host.
    hConnect = WinHttpConnect
    (
        g_hInternet,                    // session handle,
        szHost,                      // host
        (INTERNET_PORT) dwPort,       // port
        dwConnectFlags                // flags
    );
    CHECK_ERROR (hConnect, "WinHttpConnect");

    WCHAR szObject[256];
    ::MultiByteToWideChar(CP_ACP, 0, pszObject,   -1, &szObject[0], 256);

    // Create request.
    
    pContext->state = HTTP_OPEN;
    hRequest = WinHttpOpenRequest
    (
        hConnect,                     // connect handle
        pszPostFile? _T("POST") : _T("GET"),  // request method
        szObject,                    // object name
        NULL,                         // version
        NULL,                         // referer
        NULL,                         // accept types
        dwConnectFlags                // flags
    );
    CHECK_ERROR (hRequest, "WinHttpOpenRequest");

    // Send request.
    pContext->state = HTTP_SEND;
    fRet = WinHttpSendRequest
    (
        hRequest,                     // request handle
        _T(""),                       // header string
        0,                            // header length
        pPostData,                    // post data
        cbPostData,                   // post data length
        cbPostData,                   // total post length
        (DWORD_PTR)pContext             // context
    );

    if (!fRet)
    {
        dwErr = GetLastError();
        switch (dwErr)
        {
            case ERROR_WINHTTP_CLIENT_AUTH_CERT_NEEDED:
                break;

            case ERROR_IO_PENDING:
                fRet = WinHttpReceiveResponse(hRequest, NULL);
                if (!fRet)
                {
                    dwErr = GetLastError();
                    fprintf (stderr, "WinHttpReceiveResponse failed err=%d\n", dwErr);
                    break;
                }
                goto async;
                
            default:
                fprintf (stderr, "HttpSendRequest failed err=%d\n", dwErr);
        }
        pContext->state = HTTP_SEND_FAIL_SYNC;
        goto done;
    }
    else
    {
        fRet = WinHttpReceiveResponse(hRequest, NULL);
        if (!fRet)
        {
            dwErr = GetLastError();
            fprintf (stderr, "WinHttpReceiveResponse failed err=%d\n", dwErr);
            pContext->state = HTTP_SEND_FAIL_SYNC;
        }
        goto sync;
    }

async:
#if 0
    fprintf(stderr, "\nERROR_IO_PENDING on HSR...\n");
#endif
    WaitForSingleObject(hEvent, INFINITE);

    ASSERT( pContext->state == HTTP_SEND );
    if (! (pContext->dwResult) )
    {
        pContext->state = HTTP_SEND_FAIL_ASYNC;
        SetLastError (pContext->dwError);
        goto done;
    }
sync:
    
    // Get status code.
    DWORD dwStatus, cbStatus;
    cbStatus = sizeof(dwStatus);
    WinHttpQueryHeaders
    (
        hRequest,
        WINHTTP_QUERY_FLAG_NUMBER | WINHTTP_QUERY_STATUS_CODE,
        NULL,
        &dwStatus,
        &cbStatus,
        NULL
    );
    fprintf (stderr, "Status: %d\n", dwStatus);

    // Dump some bytes.
    BYTE bBuf[1024];
    DWORD cbBuf;

//#define QDA 1
#ifdef QDA
    while (TRUE)
    {
        BOOL bAsyncRead = FALSE;
        pContext->state = HTTP_QDA;
        fRet = WinHttpQueryDataAvailable (hRequest, &(pContext->dwError));//(DWORD_PTR)pContext);
        
        if (!fRet)
        {
            if (GetLastError() == ERROR_IO_PENDING)
            {
#if 0
                OutputDebugString("\nERROR_IO_PENDING on QDA\n");
                fprintf(stderr, "\nERROR_IO_PENDING on QDA...\n");
#endif
                WaitForSingleObject(hEvent, INFINITE);
                
                ASSERT (pContext->state = HTTP_QDA);
                if (!(pContext->dwResult))
                {
                    // Done
                    pContext->state = HTTP_READ_FAIL_ASYNC;
                    SetLastError(pContext->dwError);
                    goto done;
                }
                else if (!(pContext->dwError))
                {
                    pContext->state = HTTP_READ_PASS_ASYNC;
                    goto done;
                }
                bAsyncRead = TRUE;
            }
            else
            {
                pContext->state = HTTP_READ_FAIL_SYNC;
                goto done;
            }
        }
        else if (!(pContext->dwError))
        {
            //Done sync
            pContext->state = HTTP_READ_PASS_SYNC;
            goto done;
        }
            
        DWORD dwRead = pContext->dwError;
        DWORD dwActuallyRead = 0;
        while (dwRead > 0)
        {
            cbBuf = (dwRead > sizeof(bBuf)) ? sizeof(bBuf) : dwRead;
            pContext->state = HTTP_READ;
            fRet = WinHttpReadData(hRequest, bBuf, cbBuf, &dwActuallyRead);

            if (!fRet)
            {
                ASSERT ( GetLastError() != ERROR_IO_PENDING );
                fprintf(stderr, "\nError in WinHttpReadData = %d\n", GetLastError());
                goto done;
            }
            ASSERT((cbBuf == dwActuallyRead));
#if 0
            ASSERT(fRet);
            fwrite (bBuf, 1, dwActuallyRead, stdout);
#endif
            pContext->dwTotal += dwActuallyRead;
            dwRead -= dwActuallyRead;
        }    
    }
#else
/*
    cbBuf = sizeof(bBuf);
    while (WinHttpReadData (hRequest, bBuf, cbBuf, &(pContext->dwRead)) && pContext->dwRead)
        fwrite (bBuf, 1, pContext->dwRead, stdout);
 */
    cbBuf = sizeof(bBuf);

    while (TRUE)
    {
        pContext->state = HTTP_READ;
        fRet = WinHttpReadData (hRequest, bBuf, cbBuf, &(pContext->dwRead));
        
        if (!fRet)
        {
            if (GetLastError() == ERROR_IO_PENDING)
            {
#if 0
                OutputDebugString("\nERROR_IO_PENDING on READ\n");
                fprintf(stderr, "\nERROR_IO_PENDING on RD...\n");
#endif
                WaitForSingleObject(hEvent, INFINITE);
                
                ASSERT (pContext->state = HTTP_READ);
                if (!(pContext->dwResult))
                {
                    // Done
                    pContext->state = HTTP_READ_FAIL_ASYNC;
                    SetLastError(pContext->dwError);
                    goto done;
                }
                else if (!(pContext->dwRead))
                {
                    pContext->state = HTTP_READ_PASS_ASYNC;
                    goto done;
                }
                pContext->dwTotal += pContext->dwRead;
                //bAsyncRead = TRUE;
            }
            else
            {
                pContext->state = HTTP_READ_FAIL_SYNC;
                goto done;
            }
        }
        else if (!(pContext->dwError))
        {
            //Done sync
            pContext->dwTotal += pContext->dwRead;
            pContext->state = HTTP_READ_PASS_SYNC;
            goto done;
        }
        else
        {
            //finished this call sync but not done.
            pContext->dwTotal += pContext->dwRead;
        }
    }
#endif

done: // Clean up.
    if (pContext && TRUE)
    {
        fprintf (stderr, "EndOfRequest: pContext=0x%x\n\t:State: %d\n\t:Result: 0x%x\n"
                         "\t:Error: 0x%x [%d]\n\t:Total: 0x%x [%d]\n",
                         pContext,
                         pContext->state,
                         pContext->dwResult,
                         pContext->dwError, pContext->dwError,
                         pContext->dwTotal, pContext->dwTotal
                );
    }
    if (pszErr)
        fprintf (stderr, "Failed on %s, last error %d\n", pszErr, GetLastError());
    if (hRequest)
        WinHttpCloseHandle (hRequest);
    if (hConnect)
        WinHttpCloseHandle (hConnect);
        
#ifndef GLOBAL_SESSION
    if (g_hInternet)
        WinHttpCloseHandle (g_hInternet);
#endif

    if (pPostData)
        LocalFree (pPostData);
    if (hEvent)
        CloseHandle(hEvent);
    if (pContext && bDeleteContext)
    {
        pContext->dwSignature = 0x41414141;
        delete pContext;
    }
        
    return 0;
}

//==============================================================================
void ParseArguments 
(
    LPSTR  InBuffer,
    LPSTR* CArgv,
    DWORD* CArgc
)
{
    LPSTR CurrentPtr = InBuffer;
    DWORD i = 0;
    DWORD Cnt = 0;

    for ( ;; ) {

        //
        // skip blanks.
        //

        while( *CurrentPtr == ' ' ) {
            CurrentPtr++;
        }

        if( *CurrentPtr == '\0' ) {
            break;
        }

        CArgv[i++] = CurrentPtr;

        //
        // go to next space.
        //

        while(  (*CurrentPtr != '\0') &&
                (*CurrentPtr != '\n') ) {
            if( *CurrentPtr == '"' ) {      // Deal with simple quoted args
                if( Cnt == 0 )
                    CArgv[i-1] = ++CurrentPtr;  // Set arg to after quote
                else
                    *CurrentPtr = '\0';     // Remove end quote
                Cnt = !Cnt;
            }
            if( (Cnt == 0) && (*CurrentPtr == ' ') ||   // If we hit a space and no quotes yet we are done with this arg
                (*CurrentPtr == '\0') )
                break;
            CurrentPtr++;
        }

        if( *CurrentPtr == '\0' ) {
            break;
        }

        *CurrentPtr++ = '\0';
    }

    *CArgc = i;
    return;
}



//==============================================================================
int __cdecl main (int argc, char **argv)
{
	char * port;
	int nCount = 0;
	// Discard program arg.
    argv++;
    argc--;

    char* argv_large[] = {"dennisch", "venkatk/large.html", 0};
    char* argv_small[] = {"dennisch", "venkatk/small.html", 0};
    char* argv_delay[] = {"venkatk:180", 0};

    while(nCount++ < 1)
    {
        RequestLoop( 2, argv_large );
    }
    
    fprintf (stderr, "\nDone\n", nCount);

#if 0
    if (argc)
        RequestLoop (argc, argv);
        
    else // Enter command prompt loop
    {
        fprintf (stderr, "\nUsage: [-p <proxy>] [-s] <host>[:port] [<object> [<POST-file>]]");
        fprintf (stderr, "\n  -s: use secure sockets layer");
        fprintf (stderr, "\n  -p: specify proxy server. (\"<local>\" assumed for bypass.)");
        fprintf (stderr, "\nTo exit input loop, enter no params");

        while (1)
        {
            char szIn[1024];
            DWORD argcIn;
            LPSTR argvIn[10];

            fprintf (stderr, "\nhttpauth> ");
            gets (szIn);
            
            argcIn = 0;
            ParseArguments (szIn, argvIn, &argcIn);
            if (!argcIn)
                break;
            RequestLoop (argcIn, argvIn);
            //g_cbRead=0;
        }                
    }
#endif

#ifdef GLOBAL_SESSION
    if (g_hInternet)
        WinHttpCloseHandle (g_hInternet);
    g_hInternet = NULL;
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\test\httpauth.cxx ===
// ===========================================================================
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//
// Copyright 1996 Microsoft Corporation.  All Rights Reserved.
// ===========================================================================
#include <windows.h>
#include <stdlib.h>
#include <stdio.h>
#include <fcntl.h>
#include <stdlib.h>
#include <io.h>
#include <winhttp.h>
#define _UNICODE 
#include <tchar.h>

//==============================================================================
BOOL NeedAuth (HINTERNET hRequest, DWORD dwStatus)
{
    // Look for 401 or 407.
    DWORD dwFlags;
    switch (dwStatus)
    {
        case HTTP_STATUS_DENIED:
            dwFlags = WINHTTP_QUERY_WWW_AUTHENTICATE;
            break;
        case HTTP_STATUS_PROXY_AUTH_REQ:
            dwFlags = WINHTTP_QUERY_PROXY_AUTHENTICATE;
            break;            
        default:
            return FALSE;
    }

    // Enumerate the authentication types.
    BOOL fRet;
    char szScheme[64];
    DWORD dwIndex = 0;
    do
    {
        DWORD cbScheme = sizeof(szScheme);
        fRet = WinHttpQueryHeaders
            (hRequest, dwFlags, NULL, szScheme, &cbScheme, &dwIndex);
        if (fRet)
            fprintf (stderr, "Found auth scheme: %s\n", szScheme);
    }
        while (fRet);

    return TRUE;
}

//==============================================================================
BOOL PromptForCreds (HINTERNET hRequest, DWORD dwTarget, LPVOID pAuthParams)
{
    DWORD dwScheme = 0;
    
    char szScheme[16];
    
    fprintf (stderr, "Enter Scheme : ");
    if (!fscanf (stdin, "%s", szScheme))
        return FALSE;
    if (!_stricmp(szScheme, "Basic"))
    {
        dwScheme = WINHTTP_AUTH_SCHEME_BASIC;
    }
    else if (!_stricmp(szScheme, "Digest"))
    {
        dwScheme = WINHTTP_AUTH_SCHEME_DIGEST;
    }
    else if (!_stricmp(szScheme, "NTLM"))
    {
        dwScheme = WINHTTP_AUTH_SCHEME_NTLM;
    }
    else if (!_stricmp(szScheme, "Negotiate"))
    {
        dwScheme = WINHTTP_AUTH_SCHEME_NEGOTIATE;
    }
    else if (!_stricmp(szScheme, "Passport1.4"))
    {
        dwScheme = WINHTTP_AUTH_SCHEME_PASSPORT;
    }
    else
    {
        return FALSE;
    }
    
    // Prompt username and password.
    
	char szUser[64], szPass[64];
	PWCHAR pwszUser = NULL;
    WCHAR wszUser[128];
	PWCHAR pwszPass = NULL;
    WCHAR wszPass[128];
    
	fprintf (stderr, "Enter Username: ");
    if (!fscanf (stdin, "%s", szUser))
        return FALSE;

	if (_stricmp(szUser, "default"))
    {
		::MultiByteToWideChar(CP_ACP, 0, szUser,   -1, &wszUser[0], 128);
		pwszUser = &wszUser[0];
		
		fprintf (stderr, "Enter Password: ");
		if (!fscanf (stdin, "%s", szPass))
			return FALSE;
	
		::MultiByteToWideChar(CP_ACP, 0, szPass,   -1, &wszPass[0], 128);
		pwszPass = &wszPass[0];
	}


    DWORD dw_ret = WinHttpSetCredentials(hRequest, 
                                            dwTarget, dwScheme, 
                                            pwszUser, pwszPass, pAuthParams);

    return dw_ret;
}

//==============================================================================
DWORD DoCustomUI (HINTERNET hRequest, BOOL fProxy)
{
    // Prompt for username and password.
    char  szUser[64], szPass[64];
    fprintf (stderr, "Enter Username: ");
    if (!fscanf (stdin, "%s", szUser))
        return ERROR_WINHTTP_LOGIN_FAILURE;
    
	if (!_stricmp(szUser, "default"))
    {
		return ERROR_WINHTTP_RESEND_REQUEST;
	}
	
	fprintf (stderr, "Enter Password: ");
    if (!fscanf (stdin, "%s", szPass))
        return ERROR_WINHTTP_LOGIN_FAILURE;

    WCHAR  wszUser[128], wszPass[128];
    ::MultiByteToWideChar(CP_ACP, 0, szUser,   -1, &wszUser[0], 128);
    ::MultiByteToWideChar(CP_ACP, 0, szPass,   -1, &wszPass[0], 128);

    // Set the values in the handle.
    if (fProxy)
    {
        WinHttpSetOption
            (hRequest, WINHTTP_OPTION_PROXY_USERNAME, wszUser, sizeof(wszUser));
        WinHttpSetOption
            (hRequest, WINHTTP_OPTION_PROXY_PASSWORD, wszPass, sizeof(wszPass));
    }
    else
    {
        WinHttpSetOption
            (hRequest, WINHTTP_OPTION_USERNAME, wszUser, sizeof(wszUser));
        WinHttpSetOption
            (hRequest, WINHTTP_OPTION_PASSWORD, wszPass, sizeof(wszPass));
    }
    
    return ERROR_WINHTTP_RESEND_REQUEST;
}


//==============================================================================
int RequestLoop (int argc, char **argv)
{
    HINTERNET hInternet = NULL;
    HINTERNET hConnect  = NULL;
    HINTERNET hRequest  = NULL;

    DWORD   dwAccessType   = WINHTTP_ACCESS_TYPE_DEFAULT_PROXY;
    WCHAR   szProxyServer[256];
    WCHAR   szProxyBypass[256];

    DWORD dwConnectFlags = 0;
    BOOL fPreAuth = FALSE;

    PSTR pPostData = NULL;
    DWORD cbPostData = 0;
    
    PSTR pszErr = NULL;
    BOOL fRet;
    DWORD dwErr = ERROR_SUCCESS;

    DWORD dwTarget = WINHTTP_AUTH_TARGET_SERVER;
    LPVOID pAuthParams = NULL;

    
#define CHECK_ERROR(cond, err) if (!(cond)) {pszErr=(err); goto done;}

    // Parse options.
    while (argc && argv[0][0] == '-')
    {
        switch (tolower(argv[0][1]))
        {
            case 'p':
                dwAccessType = WINHTTP_ACCESS_TYPE_NAMED_PROXY;
                dwTarget = WINHTTP_AUTH_TARGET_PROXY;
                ::MultiByteToWideChar(CP_ACP, 0, argv[1],   -1, &szProxyServer[0], 256);
                // pszProxyServer = argv[1];
                ::MultiByteToWideChar(CP_ACP, 0, "<local>", -1, &szProxyBypass[0], 256);
                // pszProxyBypass = "<local>";
                argv++;
                argc--;
                break;

            case 's':
                dwConnectFlags = WINHTTP_FLAG_SECURE;
                break;

            case 'a':
                fPreAuth = TRUE;
                break;

            default:
                fprintf (stderr, "\nUsage: httpauth [-p <proxy>] [-s] <server> [<object> [<user> [<pass> [<POST-file>]]]]");
                fprintf (stderr, "\n  -s: Secure connection (ssl or pct)");
                fprintf (stderr, "\n  -p: specify proxy server. (\"<local>\" assumed for bypass.)");
                exit (1);
        }
        
        argv++;
        argc--;
    }

    // Parse host:port
    PSTR pszHost     = argv[0];
    DWORD dwPort;
    PSTR pszColon = strchr(pszHost, ':');
    if (!pszColon)
        dwPort = INTERNET_DEFAULT_PORT;
    else
    {
        *pszColon++ = 0;
        dwPort = atol (pszColon);
    }

    PSTR pszObject   = argc >= 2 ? argv[1] : "/";
    PSTR pszPostFile = argc >= 3 ? argv[2] : NULL;

    // Read any POST data into a buffer.
    if (pszPostFile)
    {
        HANDLE hf =
            CreateFile
            (
                pszPostFile,
                GENERIC_READ,
                FILE_SHARE_READ,
                NULL,
                OPEN_EXISTING,
                FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN,
                NULL
            );
        if (hf != INVALID_HANDLE_VALUE)
        {
            cbPostData = GetFileSize (hf, NULL);
            pPostData = (PSTR) LocalAlloc (LMEM_FIXED, cbPostData + 1);
            if (pPostData)
                ReadFile (hf, pPostData, cbPostData, &cbPostData, NULL);
            pPostData[cbPostData] = 0;
            CloseHandle (hf);
        }
    }

    // Initialize wininet.
    hInternet = WinHttpOpen
    (
        _T("HttpAuth Sample"),            // user agent
        // "Mozilla/4.0 (compatible; MSIE 4.0b2; Windows 95",
        dwAccessType,                 // access type
        NULL, // szProxyServer,               // proxy server
        NULL, // szProxyBypass,               // proxy bypass
        0                             // flags
    );
    CHECK_ERROR (hInternet, "WinHttpOpen");


    WCHAR szHost[256];
    ::MultiByteToWideChar(CP_ACP, 0, pszHost,   -1, &szHost[0], 256);

    // Connect to host.
    hConnect = WinHttpConnect
    (
        hInternet,                    // session handle,
        szHost,                      // host
        (INTERNET_PORT) dwPort,       // port
        0                // flags
    );
    CHECK_ERROR (hConnect, "WinHttpConnect");

    WCHAR szObject[256];
    ::MultiByteToWideChar(CP_ACP, 0, pszObject,   -1, &szObject[0], 256);

    // Create request.
    hRequest = WinHttpOpenRequest
    (
        hConnect,                     // connect handle
        pszPostFile? _T("POST") : _T("GET"),  // request method
        szObject,                    // object name
        NULL,                         // version
        NULL,                         // referer
        NULL,                         // accept types
        dwConnectFlags                // flags
    );
    CHECK_ERROR (hRequest, "WinHttpOpenRequest");
    
    if (fPreAuth)
    {
        fprintf (stderr, "Pre Authenticating...\n"); 
        fprintf (stderr, "(Scheme = Basic, Digest, NTLM, Negotiate, or Passport1.4)\n"); 
        PromptForCreds(hRequest, dwTarget, pAuthParams);
    }

resend:

    // Send request.
    fRet = WinHttpSendRequest
    (
        hRequest,                     // request handle
        _T(""),                       // header string
        0,                            // header length
        pPostData,                    // post data
        cbPostData,                   // post data length
        cbPostData,                   // total post length
        0                             // context
    );

    if (!fRet)
    {
        dwErr = GetLastError();
        switch (dwErr)
        {
            case ERROR_WINHTTP_CLIENT_AUTH_CERT_NEEDED:
                break;
                
            default:
                printf ("HttpSendRequest failed err=%d\n", dwErr);
        }
        goto done;
    }
    else
    {
        fRet = WinHttpReceiveResponse(hRequest, NULL);
        if (!fRet)
        {
            dwErr = GetLastError();
            fprintf (stderr, "WinHttpReceiveResponse failed err=%d\n", dwErr);
            // pContext->state = HTTP_SEND_FAIL_SYNC;
        }
        // goto sync;
    }

    // Get status code.
    DWORD dwStatus, cbStatus;
    cbStatus = sizeof(dwStatus);
    WinHttpQueryHeaders
    (
        hRequest,
        WINHTTP_QUERY_FLAG_NUMBER | WINHTTP_QUERY_STATUS_CODE,
        WINHTTP_HEADER_NAME_BY_INDEX,
        &dwStatus,
        &cbStatus,
        NULL
    );
    fprintf (stderr, "Status: %d\n", dwStatus);

    // Check if the status code is 401 or 407
    if (NeedAuth (hRequest, dwStatus))
    {
        char szChoice[16];

        fprintf (stderr, "Set Credentials or Set Options? (C/O): ");
        if (!fscanf (stdin, "%s", szChoice))
            return FALSE;

        if (!_stricmp(szChoice, "C"))
        {
            DWORD AllSchemes;
            DWORD GoodScheme;
            DWORD AuthTarget;
            if (WinHttpQueryAuthSchemes(hRequest, &AllSchemes, &GoodScheme, &AuthTarget) != FALSE)
            {
                fprintf (stderr, "Proposed Schemes -> ");
                if (AllSchemes & WINHTTP_AUTH_SCHEME_BASIC)
                {
                    fprintf (stderr, "Basic ");
                }
                if (AllSchemes & WINHTTP_AUTH_SCHEME_DIGEST)
                {
                    fprintf (stderr, "Digest ");
                }
                if (AllSchemes & WINHTTP_AUTH_SCHEME_NTLM)
                {
                    fprintf (stderr, "NTLM ");
                }
                if (AllSchemes & WINHTTP_AUTH_SCHEME_NEGOTIATE)
                {
                    fprintf (stderr, "Negotiate ");
                }
                if (AllSchemes & WINHTTP_AUTH_SCHEME_PASSPORT)
                {
                    fprintf (stderr, "Passport1.4 ");
                }
            
                fprintf (stderr, "\n");
            
                fprintf (stderr, "Preferred Schemes -> ");
                if (GoodScheme == WINHTTP_AUTH_SCHEME_BASIC)
                {
                    fprintf (stderr, "Basic ");
                }
                else if (GoodScheme == WINHTTP_AUTH_SCHEME_DIGEST)
                {
                    fprintf (stderr, "Digest ");
                }
                else if (GoodScheme == WINHTTP_AUTH_SCHEME_NTLM)
                {
                    fprintf (stderr, "NTLM ");
                }
                else if (GoodScheme == WINHTTP_AUTH_SCHEME_NEGOTIATE)
                {
                    fprintf (stderr, "Negotiate ");
                }
                else if (GoodScheme == WINHTTP_AUTH_SCHEME_PASSPORT)
                {
                    fprintf (stderr, "Passport1.4 ");
                }
                else
                {
                    fprintf (stderr, "*Unknown* ");
                }
            
                fprintf (stderr, "\n");

                fprintf (stderr, "Auth Target -> ");
                if (AuthTarget == WINHTTP_AUTH_TARGET_PROXY)
                {
                    fprintf (stderr, "Proxy ");
                }
                else if (AuthTarget == WINHTTP_AUTH_TARGET_SERVER)
                {
                    fprintf (stderr, "Server ");
                }
                else
                {
                    fprintf (stderr, "*Unknown* ");
                }
            
                fprintf (stderr, "\n");

                // WinHttpQueryAuthParams(hRequest, GoodScheme, &pAuthParams);

                if (PromptForCreds(hRequest, AuthTarget, pAuthParams) != FALSE)
                    goto resend;
            }
        }
        else
        {
            fprintf (stderr, "*You are using legacy WinHttp functionalities!*\n");
            
            // Prompt for username and password.
            if (DoCustomUI (hRequest, dwStatus != HTTP_STATUS_DENIED))
                goto resend;
        }
    }

    // Dump some bytes.
    BYTE bBuf[1024];
    DWORD cbBuf;
    DWORD cbRead;
    _setmode( _fileno( stdout ), _O_BINARY );

// #define QDA
#ifdef QDA
    while (WinHttpQueryDataAvailable (hRequest, &cbRead) && cbRead)
    {
        cbBuf = cbRead > sizeof(bBuf)? sizeof(bBuf) : cbRead;
        WinHttpReadData(hRequest, bBuf, cbRead, &cbRead);
        fwrite (bBuf, 1, cbRead, stdout);
    }
#else
    cbBuf = sizeof(bBuf);
    while (WinHttpReadData (hRequest, bBuf, cbBuf, &cbRead) && cbRead)
        fwrite (bBuf, 1, cbRead, stdout);
#endif

done: // Clean up.

    if (pszErr)
        fprintf (stderr, "Failed on %s, last error %d\n", pszErr, GetLastError());
    if (hRequest)
        WinHttpCloseHandle (hRequest);
    if (hConnect)
        WinHttpCloseHandle (hConnect);
    if (hInternet)
        WinHttpCloseHandle (hInternet);
    if (pPostData)
        LocalFree (pPostData);
    return 0;
}

//==============================================================================
void ParseArguments 
(
    LPSTR  InBuffer,
    LPSTR* CArgv,
    DWORD* CArgc
)
{
    LPSTR CurrentPtr = InBuffer;
    DWORD i = 0;
    DWORD Cnt = 0;

    for ( ;; ) {

        //
        // skip blanks.
        //

        while( *CurrentPtr == ' ' ) {
            CurrentPtr++;
        }

        if( *CurrentPtr == '\0' ) {
            break;
        }

        CArgv[i++] = CurrentPtr;

        //
        // go to next space.
        //

        while(  (*CurrentPtr != '\0') &&
                (*CurrentPtr != '\n') ) {
            if( *CurrentPtr == '"' ) {      // Deal with simple quoted args
                if( Cnt == 0 )
                    CArgv[i-1] = ++CurrentPtr;  // Set arg to after quote
                else
                    *CurrentPtr = '\0';     // Remove end quote
                Cnt = !Cnt;
            }
            if( (Cnt == 0) && (*CurrentPtr == ' ') ||   // If we hit a space and no quotes yet we are done with this arg
                (*CurrentPtr == '\0') )
                break;
            CurrentPtr++;
        }

        if( *CurrentPtr == '\0' ) {
            break;
        }

        *CurrentPtr++ = '\0';
    }

    *CArgc = i;
    return;
}

//==============================================================================
int __cdecl main (int argc, char **argv)
{
	char * port    ;
	// Discard program arg.
    argv++;
    argc--;

    if (argc)
        RequestLoop (argc, argv);
        
    else // Enter command prompt loop
    {
        fprintf (stderr, "\nUsage: [-p <proxy>] [-s] <host>[:port] [<object> [<POST-file>]]");
        fprintf (stderr, "\n  -s: use secure sockets layer");
        fprintf (stderr, "\n  -p: specify proxy server. (\"<local>\" assumed for bypass.)");
        fprintf (stderr, "\nTo exit input loop, enter no params");

        while (1)
        {
            char szIn[1024];
            DWORD argcIn;
            LPSTR argvIn[10];

            fprintf (stderr, "\nhttpauth> ");
            gets (szIn);
            
            argcIn = 0;
            ParseArguments (szIn, argvIn, &argcIn);
            if (!argcIn)
                break;
            RequestLoop (argcIn, argvIn);
        }                
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\tools\spork\exe\entry.cxx ===
/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Copyright (c) 2001  Microsoft Corporation

Module Name:

    entry.cxx

Abstract:

    Application entrypoint for spork.exe.
    
Author:

    Paul M Midgen (pmidge) 22-February-2001


Revision History:

    22-February-2001 pmidge
        Created

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/


#include "common.h"


int
WINAPI
WinMain(
  HINSTANCE hInstance,
  HINSTANCE hPrevInstance,
  PSTR      szCmdLine,
  int       iCmdShow
  )
{
  HRESULT hr = S_OK;
  PSPORK  ps = NULL;

  if( !IsRunningOnNT() )
  {
    Alert(
      TRUE,
      L"Spork is currently not supported on Win9x.\r\n\r\n" \
      L"If you have an urgent need for Win9x support\r\n" \
      L"please contact pmidge@microsoft.com."
      );

    return 0L;
  }

  hr = LogInitialize();

    if( FAILED(hr) )
      goto quit;

  DEBUG_TRACE((L"*** THIS DEBUG BUILD BROUGHT TO YOU BY THE LETTER \'D\'! ***"));

  hr = SPORK::Create(hInstance, &ps);

    if( FAILED(hr) )
      goto quit;

  if( !GlobalInitialize(ps, szCmdLine) )
  {
    hr = E_FAIL;
    goto quit;
  }

  hr = ps->Run();

quit:

  SAFEDELETE(ps);
  GlobalUninitialize();
  return (DWORD) hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\test\httprequest.cxx ===
// ===========================================================================
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//
// Copyright 1996 Microsoft Corporation.  All Rights Reserved.
// ===========================================================================
#include <windows.h>
#include <stdlib.h>
#include <stdio.h>
#include <fcntl.h>
#include <stdlib.h>
#include <io.h>

#include <ocidl.h>
#include <httprequest.h>



typedef HRESULT (__stdcall * PFNINTERNETCREATEHTTPREQUESTCOMPONENT)(REFIID riid, void ** ppvObject);

PFNINTERNETCREATEHTTPREQUESTCOMPONENT g_pfnInternetCreateHttpRequestComponent;


/**
 * Helper to create a char safearray from a string
 */
HRESULT
CreateVector(VARIANT * pVar, const BYTE * pData, LONG cElems)
{
    HRESULT hr;
    BYTE * pB;

    SAFEARRAY * psa = SafeArrayCreateVector(VT_UI1, 0, (unsigned int)cElems);
    if (!psa)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = SafeArrayAccessData(psa, (void **)&pB);
    if (hr)
        goto Error;

    memcpy(pB, pData, cElems);

    SafeArrayUnaccessData(psa);
    V_ARRAY(pVar) = psa;
    pVar->vt = VT_ARRAY | VT_UI1;

Cleanup:
    return hr;

Error:
    if (psa)
        SafeArrayDestroy(psa);
    goto Cleanup;
}

/*
 *  AsciiToBSTR
 *
 *  Purpose:
 *      Convert an ascii string to a BSTR
 *
 */

HRESULT 
AsciiToBSTR(BSTR * pbstr, char * sz, int cch)
{
    int cwch;

    // Determine how big the ascii string will be
    cwch = MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, sz, cch,
                                NULL, 0);

    *pbstr = SysAllocStringLen(NULL, cwch);

    if (!*pbstr)
        return E_OUTOFMEMORY;

    cch = MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, sz, cch,
                                *pbstr, cwch);

    return S_OK;
}


//==============================================================================
int RequestLoop (int argc, char **argv)
{
    IWinHttpRequest *  pIWinHttpRequest = NULL;

    BSTR            bstrMethod = NULL;
    BSTR            bstrUrl = NULL;
    BSTR            bstrStatus = NULL;
    BSTR            bstrResponse = NULL;
    VARIANT         varFalse;
    VARIANT         varEmpty;
    VARIANT         varPostData;
    long            lStatus;
    
    HRESULT         hr = NOERROR;
    CLSID           clsid;

    PSTR            pPostData = NULL;
    DWORD           cbPostData = 0;
    
    VariantInit(&varFalse);
    V_VT(&varFalse)   = VT_BOOL;
    V_BOOL(&varFalse) = VARIANT_FALSE;

    VariantInit(&varEmpty);
    V_VT(&varEmpty) = VT_ERROR;

    VariantInit(&varPostData);

    // Get host:port
    PSTR pszHostAndObject = argv[0];
    PSTR pszObject   = argc >= 2 ? argv[1] : "/";
    PSTR pszPostFile = argc >= 3 ? argv[2] : NULL;

    // Read any POST data into a buffer.
    if (pszPostFile)
    {
        HANDLE hf =
            CreateFile
            (
                pszPostFile,
                GENERIC_READ,
                FILE_SHARE_READ,
                NULL,
                OPEN_EXISTING,
                FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN,
                NULL
            );
        if (hf != INVALID_HANDLE_VALUE)
        {
            cbPostData = GetFileSize (hf, NULL);
            pPostData = (PSTR) LocalAlloc (LMEM_FIXED, cbPostData + 1);
            if (pPostData)
                ReadFile (hf, pPostData, cbPostData, &cbPostData, NULL);
            pPostData[cbPostData] = 0;
            CloseHandle (hf);

            hr = CreateVector(&varPostData, (const BYTE *)pPostData, cbPostData);
        }
    }

    bstrMethod = SysAllocString(pszPostFile? L"POST" : L"GET");

    if (!bstrMethod)
        goto Exit;

    hr = AsciiToBSTR(&bstrUrl, pszHostAndObject, strlen(pszHostAndObject));

    if (SUCCEEDED(hr))
    {
        hr = CLSIDFromProgID(L"WinHttp.WinHttpRequest.5", &clsid);
    }

    if (SUCCEEDED(hr))
    {
        hr = CoCreateInstance(clsid, NULL, CLSCTX_INPROC_SERVER, IID_IWinHttpRequest, (void **)&pIWinHttpRequest);

    }

    if (SUCCEEDED(hr))
    {
        hr = pIWinHttpRequest->SetProxy(HTTPREQUEST_PROXYSETTING_PRECONFIG, varEmpty, varEmpty);
    }

    if (SUCCEEDED(hr))
    {
        hr = pIWinHttpRequest->Open(bstrMethod, bstrUrl);
    }

    if (SUCCEEDED(hr))
    {
        hr = pIWinHttpRequest->Send(varPostData);
    }


    if (SUCCEEDED(hr))
    {
        hr = pIWinHttpRequest->get_Status(&lStatus);
    }

    if (SUCCEEDED(hr))
    {
        hr = pIWinHttpRequest->get_StatusText(&bstrStatus);
    }

    if (SUCCEEDED(hr))
    {
        fwprintf (stderr, L"Status: %d %s\n", lStatus, bstrStatus);

        hr = pIWinHttpRequest->get_ResponseText(&bstrResponse);
    }

    if (SUCCEEDED(hr))
    {
        fputws (bstrResponse, stdout);
    }
    
Exit:
    VariantClear(&varPostData);

    if (pPostData)
        LocalFree (pPostData);

    if (pIWinHttpRequest)
        pIWinHttpRequest->Release();

    if (bstrMethod)
        SysFreeString(bstrMethod);
    if (bstrUrl)
        SysFreeString(bstrUrl);
    if (bstrStatus)
        SysFreeString(bstrStatus);
    if (bstrResponse)
        SysFreeString(bstrResponse);

    return 0;
}

//==============================================================================
void ParseArguments 
(
    LPSTR  InBuffer,
    LPSTR* CArgv,
    DWORD* CArgc
)
{
    LPSTR CurrentPtr = InBuffer;
    DWORD i = 0;
    DWORD Cnt = 0;

    for ( ;; ) {

        //
        // skip blanks.
        //

        while( *CurrentPtr == ' ' ) {
            CurrentPtr++;
        }

        if( *CurrentPtr == '\0' ) {
            break;
        }

        CArgv[i++] = CurrentPtr;

        //
        // go to next space.
        //

        while(  (*CurrentPtr != '\0') &&
                (*CurrentPtr != '\n') ) {
            if( *CurrentPtr == '"' ) {      // Deal with simple quoted args
                if( Cnt == 0 )
                    CArgv[i-1] = ++CurrentPtr;  // Set arg to after quote
                else
                    *CurrentPtr = '\0';     // Remove end quote
                Cnt = !Cnt;
            }
            if( (Cnt == 0) && (*CurrentPtr == ' ') ||   // If we hit a space and no quotes yet we are done with this arg
                (*CurrentPtr == '\0') )
                break;
            CurrentPtr++;
        }

        if( *CurrentPtr == '\0' ) {
            break;
        }

        *CurrentPtr++ = '\0';
    }

    *CArgc = i;
    return;
}

//==============================================================================
int __cdecl main (int argc, char **argv)
{
    char * port;

    // Discard program arg.
    argv++;
    argc--;

    HRESULT hr = CoInitialize(0);

    if (FAILED(hr))
        return 0;

    if (argc)
        RequestLoop (argc, argv);
        
    else // Enter command prompt loop
    {
        fprintf (stderr, "\nUsage: <host>[:port]/[<object>] [<POST-file>]]");
//        fprintf (stderr, "\n  -s: use secure sockets layer");
//        fprintf (stderr, "\n  -p: specify proxy server. (\"<local>\" assumed for bypass.)");
        fprintf (stderr, "\nTo exit input loop, enter no params");

        while (1)
        {
            char szIn[1024];
            DWORD argcIn;
            LPSTR argvIn[10];

            fprintf (stderr, "\nhttprequest> ");
            gets (szIn);
            
            argcIn = 0;
            ParseArguments (szIn, argvIn, &argcIn);
            if (!argcIn)
                break;
            RequestLoop (argcIn, argvIn);
        }                
    }

    CoUninitialize();

    return 0;
}        



// Need this for IWinHttpRequest guids...

extern "C" {

#include <httprequest_i.c>

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\tools\spork\spork.inc ===
!IF 0

Copyright (c) 2001  Microsoft Corporation

!ENDIF

!IFNDEF SDKINC
SDKINC=$(SDK_INC_PATH)
!ENDIF

!IFDEF LIBDIR
!ERROR LIBDIR already defined - choose new name
!ENDIF

ROOT=$(SDXROOT)\inetcore\winhttp\tools\spork
LIBDIR=$(ROOT)\lib\$(_OBJ_DIR)
PROJECTINC=$(ROOT)\inc

#
# if TARGETPATH is not defined (in the paths that build libraries) then this
# is the default target path
#
!IFNDEF TARGETPATH
TARGETPATH=$(LIBDIR)
TARGETTYPE=LIBRARY
!ENDIF

#
# what it is that we're building
#
MAJORCOMP=spork
USE_NOLIBS=1
NO_NTDLL=1
BINPLACE_PLACEFILE=$(ROOT)\binplace.txt

#
# Linker flags
#
WIN32_WINNT_VERSION=0x0500
#WIN32_WIN95_VERSION=0x0400

#
# compiler warning flags
#
MSC_WARNING_LEVEL=/W3 /WX

#
# enable exception handling
#
USE_NATIVE_EH=1

#
# compiler definitions
#
C_DEFINES=$(C_DEFINES) -DWIN32

CLEANINF = cleaninf.exe $(CLEANINF_FLAGS)

#
# Set debugging level
#
!IF "$(NTDEBUG)" != "" && "$(NTDEBUG)" != "retail" && "$(NTDEBUG)" != "ntsdnodbg"
C_DEFINES=$(C_DEFINES) -D_DEBUG

!IF "$(_DEBUG_REFCOUNT)" != ""
C_DEFINES=$(C_DEFINES) -D_DEBUG_REFCOUNT
!ENDIF

!ENDIF


!IFNDEF BUILD_PCH
PRECOMPILED_OPTION=/Fp$(ROOT)\inc\$(_OBJ_DIR)\*\common.pch /Yucommon.h
PRECOMPILED_CXX=1
!ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\test\httpcert.cxx ===
// ===========================================================================
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//
// Copyright 1996 Microsoft Corporation.  All Rights Reserved.
// ===========================================================================
#include <windows.h>
#include <stdlib.h>
#include <stdio.h>
#include <fcntl.h>
#include <stdlib.h>
#include <io.h>
#include <winhttp.h>
#include <wincrypt.h>
#define _UNICODE 
#include <tchar.h>

//==============================================================================
//#define GLOBAL_SESSION 1

#ifdef GLOBAL_SESSION
HINTERNET g_hInternet = NULL;
#endif

BOOL g_fCloseOnSSLFailure = FALSE;

#ifndef ASSERT
#define ASSERT( exp ) \
    ((!(exp)) ? \
        DebugBreak() : \
        ((void)0))
#endif

typedef enum
{
    HTTP_INIT = 0,
    HTTP_OPEN = 1,
    HTTP_SEND = 2,
    HTTP_QDA  = 3,
    HTTP_READ = 4,
    HTTP_READ_PASS_SYNC  = 5,
    HTTP_READ_PASS_ASYNC = 6,
    HTTP_READ_FAIL_SYNC  = 7,
    HTTP_READ_FAIL_ASYNC = 8,
    HTTP_SEND_FAIL_SYNC  = 9,
    HTTP_SEND_FAIL_ASYNC = 10
} HTTP_STATE;

typedef struct
{
    HTTP_STATE state;
    BOOL bQDA;
    DWORD dwTotal;
    DWORD_PTR dwResult;
    DWORD dwError;
    HANDLE hEvent;
    DWORD dwSignature;
    BOOL bCallbackDelete;
    BOOL fCallbackClose;
} TestContext;

VOID CALLBACK Callback(IN HINTERNET hInternet, IN DWORD_PTR dwContext,
                           IN DWORD dwStatus, IN LPVOID pvInfo, IN DWORD dwStatusLen)
{
#if 0
    fprintf(stderr, "callback!!!!!! dwStatus %d\n", dwStatus);
#endif

    TestContext* pContext = (TestContext*)dwContext;
    if ((dwStatus == WINHTTP_CALLBACK_STATUS_SECURE_FAILURE) && pContext)
    {
        fprintf(stderr, "\n\tWINHTTP_CALLBACK_STATUS_SECURE_FAILURE, StatusFlags=%x\n", *((LPDWORD) pvInfo));
        if (g_fCloseOnSSLFailure)
        {
            WinHttpCloseHandle(hInternet);
            pContext->fCallbackClose = TRUE;
        }
    }
    else if ((dwStatus == WINHTTP_CALLBACK_STATUS_REQUEST_COMPLETE) && pContext)
    {
        ASSERT (pContext->dwSignature == 0);
        if (pContext->bCallbackDelete)
        {
            delete pContext;
            goto end;
        }
        
        DWORD_PTR dwResult = ((LPWINHTTP_ASYNC_RESULT)(pvInfo))->dwResult;
        DWORD dwError = ((LPWINHTTP_ASYNC_RESULT) (pvInfo) )->dwError;

        pContext->dwResult = dwResult;
        pContext->dwError = dwError;
        SetEvent(pContext->hEvent);
#if 0
        OutputDebugString("\n\tWINHTTP_STATUS_REQUEST_COMPLETE for QDA\n");
		fprintf(stderr, "\n\tWINHTTP_STATUS_REQUEST_COMPLETE for QDA with %d result and %d error.\n", dwResult, dwBytes);
#endif
    }
    else if ((dwStatus == WINHTTP_CALLBACK_STATUS_HANDLE_CLOSING) && pContext)
    {
        // We aborted the connection due to an SSL failure.
        // Time to wake up.
        SetEvent(pContext->hEvent);
    }

end:
    return;
}

#define CHECK_ERROR(cond, err) if (!(cond)) {pszErr=(err); goto done;}

//==============================================================================
int RequestLoop (int argc, char **argv)
{
#ifndef GLOBAL_SESSION
    HINTERNET g_hInternet = NULL;
#endif
    HINTERNET hConnect  = NULL;
    HINTERNET hRequest  = NULL;

    DWORD   dwAccessType   = WINHTTP_ACCESS_TYPE_DEFAULT_PROXY;
    WCHAR   szProxyServer[256];
    WCHAR   szProxyBypass[256];

    DWORD dwConnectFlags = 0;
    BOOL fPreAuth = FALSE;
    BOOL fEnableRevocation = FALSE;
    DWORD dwEnableFlags = WINHTTP_ENABLE_SSL_REVOCATION;

    PSTR pPostData = NULL;
    DWORD cbPostData = 0;
    
    PSTR pszErr = NULL;
    BOOL fRet;
    DWORD dwErr = ERROR_SUCCESS;

    DWORD dwTarget = WINHTTP_AUTH_TARGET_SERVER;
    LPVOID pAuthParams = NULL;

    DWORD option = WINHTTP_OPTION_RESOLVE_TIMEOUT;
    DWORD dwTimeout = 1000;
    HANDLE hEvent = NULL;

    PSTR pszObject   = NULL;
    PSTR pszPostFile = NULL;
    char pszHost[128];
    PSTR pszColon    = NULL;
    BOOL bDeleteContext = TRUE;

    HCERTSTORE hMyStore = NULL;
    PCCERT_CONTEXT pCertContext = NULL;
    WCHAR szCertName[256];
    DWORD dwErrorMask;
    
    szCertName[0] = L'\0';

    TestContext* pContext = new TestContext();
    CHECK_ERROR(pContext, "new TestContext");
    
    memset(pContext, 0, sizeof(TestContext));

    g_fCloseOnSSLFailure = FALSE;
    
    // Parse options.
    while (argc && argv[0][0] == '-')
    {
        switch (tolower(argv[0][1]))
        {
            case 'p':
                dwAccessType = WINHTTP_ACCESS_TYPE_NAMED_PROXY;
                dwTarget = WINHTTP_AUTH_TARGET_PROXY;
                ::MultiByteToWideChar(CP_ACP, 0, argv[1],   -1, &szProxyServer[0], 256);
                // pszProxyServer = argv[1];
                ::MultiByteToWideChar(CP_ACP, 0, "<local>", -1, &szProxyBypass[0], 256);
                // pszProxyBypass = "<local>";
                argv++;
                argc--;
                break;

            case 'c':
                ::MultiByteToWideChar(CP_ACP, 0, argv[1],  -1, &szCertName[0], 256);
                argv++;
                argc--;
                break;

            case 's':
                dwConnectFlags = WINHTTP_FLAG_SECURE;
                break;

            case 'r':
                fEnableRevocation = TRUE;
                break;

            case 'd':
                g_fCloseOnSSLFailure = TRUE;
                break;

            case 'a':
                fPreAuth = TRUE;
                break;

            default:
                fprintf (stderr, "\nUsage: [-p <proxy>] [-s] [-c CERT_FIND_SUBJECT_STR] <host>[:port] [<object> [<POST-file>]]");
                fprintf (stderr, "\n   -s: use secure sockets layer");
                fprintf (stderr, "\n   -p: specify proxy server. (\"<local>\" assumed for bypass.)");
                fprintf (stderr, "\n   -c: Use CERT_FIND_SUBJECT_STR to find cert context when client auth needed");
                fprintf (stderr, "\n   -r: Enable certificate revocation checking");
                fprintf (stderr, "\n   -d: CloseHandle on SSL failure");
                exit (1);
        }
        
        argv++;
        argc--;
    }

    // Parse host:port
    {
        int nlen = strlen(argv[0]);
        if (nlen > sizeof(pszHost))
            goto done;
        strcpy(pszHost, argv[0]);
    }
    
    DWORD dwPort;
    pszColon = strchr(pszHost, ':');
    if (!pszColon)
        dwPort = INTERNET_DEFAULT_PORT;
    else
    {
        *pszColon++ = 0;
        dwPort = atol (pszColon);
    }

    pszObject   = argc >= 2 ? argv[1] : "/";
    pszPostFile = argc >= 3 ? argv[2] : NULL;

    // Read any POST data into a buffer.
    if (pszPostFile)
    {
        HANDLE hf =
            CreateFile
            (
                pszPostFile,
                GENERIC_READ,
                FILE_SHARE_READ,
                NULL,
                OPEN_EXISTING,
                FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN,
                NULL
            );
        if (hf != INVALID_HANDLE_VALUE)
        {
            cbPostData = GetFileSize (hf, NULL);
            pPostData = (PSTR) LocalAlloc (LMEM_FIXED, cbPostData + 1);
            if (pPostData)
                ReadFile (hf, pPostData, cbPostData, &cbPostData, NULL);
            pPostData[cbPostData] = 0;
            CloseHandle (hf);
        }
    }

    // Initialize wininet.
#ifdef GLOBAL_SESSION
    if (!g_hInternet)
#endif
        g_hInternet = WinHttpOpen
        (
            _T("HttpAuth Sample"),            // user agent
            // "Mozilla/4.0 (compatible; MSIE 4.0b2; Windows 95",
            dwAccessType,                 // access type
            dwAccessType == WINHTTP_ACCESS_TYPE_NAMED_PROXY ? szProxyServer : NULL, // proxy server
            dwAccessType == WINHTTP_ACCESS_TYPE_NAMED_PROXY ? szProxyBypass : NULL, // proxy bypass
            WINHTTP_FLAG_ASYNC          // flags
        );
    CHECK_ERROR (g_hInternet, "WinHttpOpen");


    WCHAR szHost[256];
    ::MultiByteToWideChar(CP_ACP, 0, pszHost,   -1, &szHost[0], 256);

    WinHttpSetStatusCallback(g_hInternet, Callback, WINHTTP_CALLBACK_FLAG_ALL_NOTIFICATIONS, NULL);

    dwTimeout = 1000;
    WinHttpSetOption(
        g_hInternet,
        WINHTTP_OPTION_RESOLVE_TIMEOUT,
        (LPVOID)&dwTimeout,
        sizeof(DWORD)
    );

    dwTimeout = 1000;
    WinHttpSetOption(
        g_hInternet,
        WINHTTP_OPTION_CONNECT_TIMEOUT,
        (LPVOID)&dwTimeout,
        sizeof(DWORD)
    );

    dwTimeout = 100;
    WinHttpSetOption(
        g_hInternet,
        WINHTTP_OPTION_SEND_TIMEOUT,
        (LPVOID)&dwTimeout,
        sizeof(DWORD)
    );
    
    dwTimeout = 10000;
    WinHttpSetOption(
        g_hInternet,
        WINHTTP_OPTION_RECEIVE_TIMEOUT,
        (LPVOID)&dwTimeout,
        sizeof(DWORD)
    );

    hEvent = CreateEvent(NULL, FALSE /*want auto-reset*/, FALSE /*non-signaled init.*/, NULL);

    CHECK_ERROR(hEvent, "CreateEvent");

    pContext->hEvent = hEvent;
  
    // Connect to host.
    hConnect = WinHttpConnect
    (
        g_hInternet,                    // session handle,
        szHost,                      // host
        (INTERNET_PORT) dwPort,       // port
        0                // flags
    );
    CHECK_ERROR (hConnect, "WinHttpConnect");

    WCHAR szObject[256];
    ::MultiByteToWideChar(CP_ACP, 0, pszObject,   -1, &szObject[0], 256);

    // Create request.
    
    pContext->state = HTTP_OPEN;
    hRequest = WinHttpOpenRequest
    (
        hConnect,                     // connect handle
        pszPostFile? _T("POST") : _T("GET"),  // request method
        szObject,                    // object name
        NULL,                         // version
        NULL,                         // referer
        NULL,                         // accept types
        dwConnectFlags                // flags
    );
    CHECK_ERROR (hRequest, "WinHttpOpenRequest");

    if (fEnableRevocation)
    {
        WinHttpSetOption(hRequest,
                         WINHTTP_OPTION_ENABLE_FEATURE,
                         (LPVOID)&dwEnableFlags,
                         sizeof(dwEnableFlags));
    }

try_again:
    // Send request.
    pContext->state = HTTP_SEND;
    fRet = WinHttpSendRequest
    (
        hRequest,                     // request handle
        _T(""),                       // header string
        0,                            // header length
        pPostData,                    // post data
        cbPostData,                   // post data length
        cbPostData,                   // total post length
        (DWORD_PTR) pContext          // flags
    );

    if (!fRet)
    {
        dwErr = GetLastError();
        switch (dwErr)
        {
            case ERROR_WINHTTP_CLIENT_AUTH_CERT_NEEDED:
                break;

            case ERROR_IO_PENDING:
                fRet = WinHttpReceiveResponse(hRequest, NULL);
                if (!fRet)
                {
                    dwErr = GetLastError();
                    if (dwErr != ERROR_IO_PENDING)
                    {
                        fprintf (stderr, "WinHttpReceiveResponse failed err=%d\n", dwErr);
                        break;
                    }
                }
                goto async;
                
            default:
                fprintf (stderr, "HttpSendRequest failed err=%d\n", dwErr);
        }
        pContext->state = HTTP_SEND_FAIL_SYNC;
        goto done;
    }
    else
    {
        fRet = WinHttpReceiveResponse(hRequest, NULL);
        if (!fRet)
        {
            dwErr = GetLastError();
            fprintf (stderr, "WinHttpReceiveResponse failed err=%d\n", dwErr);
            pContext->state = HTTP_SEND_FAIL_SYNC;
        }
        goto sync;
    }

async:
    fRet = WinHttpReceiveResponse(hRequest, NULL);

    if (!fRet)
    {
        DWORD dwErr = GetLastError();

        if (dwErr != ERROR_IO_PENDING)
        {
            fprintf(stderr, "WinHttpReceiveResponse failed err=%d\n", dwErr);
            pContext->state = HTTP_SEND_FAIL_SYNC;
            goto done;
        }
    }

#if 0
    fprintf(stderr, "\nERROR_IO_PENDING on HSR...\n");
#endif
    WaitForSingleObject(hEvent, INFINITE);

    ASSERT( pContext->state == HTTP_SEND );

    if (pContext->dwError == ERROR_WINHTTP_CLIENT_AUTH_CERT_NEEDED)
    {
        if (szCertName[0])
        {
            hMyStore = CertOpenSystemStore(0, TEXT("MY"));
            if (hMyStore)
            {
                pCertContext = CertFindCertificateInStore(hMyStore,
                                                          X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                                                          0,
                                                          CERT_FIND_SUBJECT_STR,
                                                          (LPVOID) szCertName,
                                                          NULL);
                if (pCertContext)
                {
                    WinHttpSetOption(hRequest,
                                     WINHTTP_OPTION_CLIENT_CERT_CONTEXT,
                                     (LPVOID) pCertContext,
                                     sizeof(CERT_CONTEXT));
                    CertFreeCertificateContext(pCertContext);
                }
                CertCloseStore(hMyStore, 0);
                goto try_again;
            }
        }
    }

    if (! (pContext->dwResult) )
    {
        pContext->state = HTTP_SEND_FAIL_ASYNC;
        SetLastError (pContext->dwError);
        goto done;
    }

sync:
    
    fRet = WinHttpReceiveResponse(hRequest, NULL);

    if (!fRet)
    {
        DWORD dwErr = GetLastError();

        if (dwErr != ERROR_IO_PENDING)
        {
            fprintf(stderr, "WinHttpReceiveResponse failed err=%d\n", dwErr);
            pContext->state = HTTP_SEND_FAIL_SYNC;
            goto done;
        }
    }
    // Get status code.
    DWORD dwStatus, cbStatus;
    cbStatus = sizeof(dwStatus);
    WinHttpQueryHeaders
    (
        hRequest,
        WINHTTP_QUERY_FLAG_NUMBER | WINHTTP_QUERY_STATUS_CODE,
        NULL,
        &dwStatus,
        &cbStatus,
        NULL
    );
    fprintf (stderr, "Status: %d\n", dwStatus);

    // Dump some bytes.
    BYTE bBuf[1024];
    DWORD cbBuf;

#define QDA 1
#ifdef QDA
    while (TRUE)
    {
        BOOL bAsyncRead = FALSE;
        pContext->state = HTTP_QDA;
        fRet = WinHttpQueryDataAvailable (hRequest, &(pContext->dwError));
        
        if (!fRet)
        {
            if (GetLastError() == ERROR_IO_PENDING)
            {
#if 0
                OutputDebugString("\nERROR_IO_PENDING on QDA\n");
                fprintf(stderr, "\nERROR_IO_PENDING on QDA...\n");
#endif
                WaitForSingleObject(hEvent, INFINITE);
                
                ASSERT (pContext->state = HTTP_QDA);
                if (!(pContext->dwResult))
                {
                    // Done
                    pContext->state = HTTP_READ_FAIL_ASYNC;
                    SetLastError(pContext->dwError);
                    goto done;
                }
                else if (!(pContext->dwError))
                {
                    pContext->state = HTTP_READ_PASS_ASYNC;
                    goto done;
                }
                bAsyncRead = TRUE;
            }
            else
            {
                pContext->state = HTTP_READ_FAIL_SYNC;
                goto done;
            }
        }
        else if (!(pContext->dwError))
        {
            //Done sync
            pContext->state = HTTP_READ_PASS_SYNC;
            goto done;
        }
            
        DWORD dwRead = pContext->dwError;
        DWORD dwActuallyRead = 0;
        while (dwRead > 0)
        {
            cbBuf = (dwRead > sizeof(bBuf)) ? sizeof(bBuf) : dwRead;
            pContext->state = HTTP_READ;
            fRet = WinHttpReadData(hRequest, bBuf, cbBuf, &dwActuallyRead);

            if (!fRet)
            {
                ASSERT ( GetLastError() != ERROR_IO_PENDING );
                fprintf(stderr, "\nError in WinHttpReadData = %d\n", GetLastError());
                goto done;
            }
            ASSERT((cbBuf == dwActuallyRead));
#if 0
            ASSERT(fRet);
            fwrite (bBuf, 1, dwActuallyRead, stdout);
#endif
            pContext->dwTotal += dwActuallyRead;
            dwRead -= dwActuallyRead;
        }    
    }
#else
    cbBuf = sizeof(bBuf);
    while (WinHttpReadData (hRequest, bBuf, cbBuf, &(pContext->dwRead)) && pContext->dwRead)
        fwrite (bBuf, 1, pContext->dwRead, stdout);
#endif

done: // Clean up.

    if (pszErr)
        fprintf (stderr, "Failed on %s, last error %d\n", pszErr, GetLastError());
    if (hRequest)
        WinHttpCloseHandle (hRequest);
    if (hConnect)
        WinHttpCloseHandle (hConnect);
        
#ifndef GLOBAL_SESSION
    if (g_hInternet)
        WinHttpCloseHandle (g_hInternet);
#endif

    if (pPostData)
        LocalFree (pPostData);
    if (hEvent)
        CloseHandle(hEvent);
    if (pContext && bDeleteContext)
    {
        pContext->dwSignature = 0x41414141;
        delete pContext;
    }
        
    return 0;
}

//==============================================================================
void ParseArguments 
(
    LPSTR  InBuffer,
    LPSTR* CArgv,
    DWORD* CArgc
)
{
    LPSTR CurrentPtr = InBuffer;
    DWORD i = 0;
    DWORD Cnt = 0;

    for ( ;; ) {

        //
        // skip blanks.
        //

        while( *CurrentPtr == ' ' ) {
            CurrentPtr++;
        }

        if( *CurrentPtr == '\0' ) {
            break;
        }

        CArgv[i++] = CurrentPtr;

        //
        // go to next space.
        //

        while(  (*CurrentPtr != '\0') &&
                (*CurrentPtr != '\n') ) {
            if( *CurrentPtr == '"' ) {      // Deal with simple quoted args
                if( Cnt == 0 )
                    CArgv[i-1] = ++CurrentPtr;  // Set arg to after quote
                else
                    *CurrentPtr = '\0';     // Remove end quote
                Cnt = !Cnt;
            }
            if( (Cnt == 0) && (*CurrentPtr == ' ') ||   // If we hit a space and no quotes yet we are done with this arg
                (*CurrentPtr == '\0') )
                break;
            CurrentPtr++;
        }

        if( *CurrentPtr == '\0' ) {
            break;
        }

        *CurrentPtr++ = '\0';
    }

    *CArgc = i;
    return;
}


DWORD WINAPI WorkThread1(LPVOID lpParameter)
{
    int nCount = 0;
    char* pargv[] = {"dennisch", "venkatk/large.html", 0};

    while (nCount++ < 500000)
    {
        fprintf (stderr, "\nLARGE Iteration #%d\n", nCount);
        RequestLoop( 2, pargv);
    }

    fprintf (stderr, "\nLARGE DONE!\n");

    return 0;
}
DWORD WINAPI WorkThread2(LPVOID lpParameter)
{
    int nCount = 0;
    char* pargv[] = {"dennisch", "venkatk/small.html", 0};

    while (nCount++ < 1000000)
    {
        fprintf (stderr, "\nSMALL Iteration #%d\n", nCount);
        RequestLoop( 2, pargv);
    }

    fprintf (stderr, "\nSMALL DONE!\n");

    return 0;
}
DWORD WINAPI WorkThread3(LPVOID lpParameter)
{
    int nCount = 0;
    char* pargv[] = {"venkatk:180", 0};

    while (nCount++ < 1000)
    {
        fprintf (stderr, "\n180 Iteration #%d\n", nCount);
        RequestLoop( 1, pargv);
    }

    fprintf (stderr, "\n180 DONE!\n");

    return 0;
}

//==============================================================================
int __cdecl main (int argc, char **argv)
{
    char * port;
    int nCount = 0;
    // Discard program arg.
    argv++;
    argc--;


/*
#if 1
    DWORD dwThreadId;    
    HANDLE hThread1 = CreateThread(NULL, 0, &WorkThread1,
                                   NULL, 0, &dwThreadId);
    Sleep(1000);
    HANDLE hThread2 = CreateThread(NULL, 0, &WorkThread2,
                                   NULL, 0, &dwThreadId);
    HANDLE hThread3 = CreateThread(NULL, 0, &WorkThread3,
                                   NULL, 0, &dwThreadId);

    {
        char* pargv[] = {"pmidge", 0};

        while (nCount++ < 1000000)
        {
            fprintf (stderr, "\nPMIDGE Iteration #%d\n", nCount);
            RequestLoop( 1, pargv);
        }

        fprintf (stderr, "\n180 DONE!\n");
    }

    WaitForSingleObject( hThread1, INFINITE );
    WaitForSingleObject( hThread2, INFINITE );
    WaitForSingleObject( hThread3, INFINITE );
#endif

#if 0
    char* argv_large[] = {"dennisch", "venkatk/large.html", 0};
    char* argv_small[] = {"dennisch", "venkatk/small.html", 0};
    char* argv_delay[] = {"venkatk:180", 0};

    while(nCount++ < 30)
    {
        RequestLoop( 1, argv_delay );
    }
    
    while(nCount++ < 100)
    {
#if 0
        fprintf (stderr, "\nIteration #%d\n", nCount);
#endif
        RequestLoop( 2, argv_large);
        RequestLoop( 2, argv_small);
        RequestLoop( 1, argv_delay);
    }
#endif
    fprintf (stderr, "\nIteration #%d\n", nCount);

*/
    if (argc)
        RequestLoop (argc, argv);
        
    else // Enter command prompt loop
    {
        fprintf (stderr, "\nUsage: [-p <proxy>] [-s] [-c CERT_FIND_SUBJECT_STR] <host>[:port] [<object> [<POST-file>]]");
        fprintf (stderr, "\n   -s: use secure sockets layer");
        fprintf (stderr, "\n   -p: specify proxy server. (\"<local>\" assumed for bypass.)");
        fprintf (stderr, "\n   -c: Use CERT_FIND_SUBJECT_STR to find cert context when client auth needed");
        fprintf (stderr, "\n   -r: Enable certificate revocation checking");
        fprintf (stderr, "\n   -d: CloseHandle on SSL failure");
        fprintf (stderr, "\nTo exit input loop, enter no params");

        while (1)
        {
            char szIn[1024];
            DWORD argcIn;
            LPSTR argvIn[10];

            fprintf (stderr, "\nhttpauth> ");
            gets (szIn);
            
            argcIn = 0;
            ParseArguments (szIn, argvIn, &argcIn);
            if (!argcIn)
                break;
            RequestLoop (argcIn, argvIn);
            //g_cbRead=0;
        }                
    }

#ifdef GLOBAL_SESSION
    if (g_hInternet)
        WinHttpCloseHandle (g_hInternet);
    g_hInternet = NULL;
#endif

    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\tools\spork\inc\dispids.h ===
/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Copyright (c) 2001  Microsoft Corporation

Module Name:

    dispids.h

Abstract:

    DISPIDs used by the dual-interface components.
    
Author:

    Paul M Midgen (pmidge) 22-February-2001


Revision History:

    22-February-2001 pmidge
        Created

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/

#ifndef __DISPIDS_H__
#define __DISPIDS_H__

#define SCRRUN_DISPID_BASE           100

#define DISPID_SCRRUN_CREATEOBJECT   (SCRRUN_DISPID_BASE + 1)
#define DISPID_SCRRUN_CREATEFORK     (SCRRUN_DISPID_BASE + 2)
#define DISPID_SCRRUN_PUTVALUE       (SCRRUN_DISPID_BASE + 3)
#define DISPID_SCRRUN_GETVALUE       (SCRRUN_DISPID_BASE + 4)
#define DISPID_SCRRUN_VBCREATEOBJECT (SCRRUN_DISPID_BASE + 5)
#define DISPID_SCRRUN_SETUSERID      (SCRRUN_DISPID_BASE + 6)

#endif /* __DISPIDS_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\tools\spork\exe\globals.cxx ===
/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Copyright (c) 2001  Microsoft Corporation

Module Name:

    globals.cxx

Abstract:

    Contains environment config functions for Spork.

    NOTE: I thought long and hard about whether to use globals at all. In
          the end, it's cleaner to parse the command-line and store some
          global config info in one place rather than carry it around by
          passing params hither and yon. The global data is accessed only
          through the functions in this file.
    
Author:

    Paul M Midgen (pmidge) 22-February-2001


Revision History:

    22-February-2001 pmidge
        Created

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/


#include <common.h>


//-----------------------------------------------------------------------------
// global vars (note, there are NO 'extern' references anywhere in the code)
//-----------------------------------------------------------------------------
LPWSTR g_wszScriptFile = NULL;
LPWSTR g_wszProfile    = NULL;
BOOL   g_bSilentMode   = FALSE;
BOOL   g_bDebugOut     = FALSE;


//-----------------------------------------------------------------------------
// private
//-----------------------------------------------------------------------------
BOOL   ParseCommandLine(PSPORK pSpork, LPSTR szCmdLine);
LPWSTR GetStringToken(LPSTR* ppsz);
BOOL   StoreEnvironmentVariable(PSPORK pSpork, LPWSTR nvpair);
BOOL   nvpairhelper(PSPORK pSpork, LPWSTR name, LPWSTR value);


//-----------------------------------------------------------------------------
// global functions
//-----------------------------------------------------------------------------
BOOL
GlobalInitialize(
  PSPORK pSpork,
  LPSTR  szCmdLine
  )
{
  BOOL     bInit = FALSE;
  LPWSTR   wide  = NULL;
  VARIANT* pvr   = NULL;

  if( ParseCommandLine(pSpork, szCmdLine) )
  {
    ManageRootKey(TRUE);
    ToggleDebugOutput(g_bDebugOut);

    if( wide = __ansitowide(szCmdLine) )
    {
      nvpairhelper(pSpork, L"cmdline", wide);
      SAFEDELETEBUF(wide);
    }

    if( SUCCEEDED(CoInitializeEx(NULL, COINIT_MULTITHREADED)) )
    {
      bInit = TRUE;
    }
  }
  else
  {
    LogTrace(L"invalid commandline argument in \"%S\"", szCmdLine);
  }

  return bInit;
}


void
GlobalUninitialize(void)
{
  LogTerminate();
  ManageRootKey(FALSE);
  CoUninitialize();
  SAFEDELETEBUF(g_wszScriptFile);
}


LPWSTR
GlobalGetScriptName(void)
{
  return g_wszScriptFile ? StrDup(g_wszScriptFile) : NULL;
}


LPWSTR
GlobalGetProfileName(void)
{
  return g_wszProfile ? StrDup(g_wszProfile) : NULL;
}


BOOL
GlobalIsSilentModeEnabled(void)
{
  return g_bSilentMode;
}


BOOL
GlobalIsDebugOutputEnabled(void)
{
  return g_bDebugOut;
}


//-----------------------------------------------------------------------------
// command line parser
//-----------------------------------------------------------------------------
BOOL
ParseCommandLine(
  PSPORK pSpork,
  LPSTR  szCmdLine
  )
{
  BOOL  bRet    = TRUE;
  CHAR  token   = NULL;
  LPSTR cmdline = NULL;
  LPSTR tmp     = NULL;

  if( !szCmdLine )
    goto quit;

  cmdline = StrDupA(szCmdLine);
  tmp     = cmdline;

  while( *tmp )
  {
    switch( *tmp )
    {
      // eat whitespace
      case ' ' :
        {
          ++tmp;
        }
        continue;

      // locate a command token
      case '-' :
      case '/' :
        {
          if( !token )
          {
            ++tmp;
          }
          else
          {
            // we have an unprocessed command token, this is an error.
            bRet = FALSE;
            goto quit;
          }
        }
        continue;

      default :
        {
          // store the command token and if we're not at the end
          // of the command line, continue processing whitespace
          if( !token )
          {
            token = *tmp++;

            while( *tmp == ' ' )
              ++tmp;
          }

          if( token == '?' )
          {
            Alert(
              FALSE,
              L"SPORK.EXE Command Line Syntax\r\n\r\n" \
              L"-f <scriptname>\r\n"   \
              L"-p <profilename>\r\n"  \
              L"-s <silentmode>\r\n"   \
              L"-d <debugmonitor>\r\n" \
              L"-v <name=value>\r\n"
              );

            bRet = FALSE;
            goto quit;
          }              

          // process the command token
          switch( ((char) (token & 0xdf)) )
          {
            case 'F' : // specify a script to run
              {
                g_wszScriptFile = GetStringToken(&tmp);

                if( !g_wszScriptFile )
                {
                  bRet = FALSE;
                  goto quit;
                }
                else
                {
                  LogTrace(L"using script %s", g_wszScriptFile);
                }
              }
              break;

            case 'P' : // specify the profile to use
              {
                g_wszProfile = GetStringToken(&tmp);

                if( !g_wszProfile )
                {
                  bRet = FALSE;
                  goto quit;
                }
                else
                {
                  LogTrace(L"using profile %s", g_wszProfile);
                }
              }
              break;

            case 'S' : // enable silent mode
              {
                g_bSilentMode = TRUE;
                LogTrace(L"silent mode is enabled");
              }
              break;

            case 'D' : // enable output to a debug monitor
              {
                g_bDebugOut = TRUE;
                LogTrace(L"debug logging is enabled");
              }
              break;

            case 'V' : // set an environment variable
              {
                LPWSTR wtmp = GetStringToken(&tmp);

                if( wtmp )
                {
                  bRet = StoreEnvironmentVariable(pSpork, wtmp);
                  SAFEDELETEBUF(wtmp);

                  if( !bRet )
                    goto quit;
                }
              }
              break;

            default : bRet = FALSE; goto quit;
          }

          token = NULL;
        }
    }
  }

quit:

  SAFEDELETEBUF(cmdline);
  return bRet;
}


//-----------------------------------------------------------------------------
// helper functions
//-----------------------------------------------------------------------------
LPWSTR
GetStringToken(
  LPSTR* ppsz
  )
{
  LPSTR  tmp   = NULL;
  LPWSTR token = NULL;

  if( *(tmp = (*ppsz + StrCSpnA(*ppsz, "-/"))) )
  {
    *tmp = '\0';

    StrTrimA(*ppsz, " ");

    token = __ansitowide(*ppsz);
    *ppsz = tmp+1;
  }
  else
  {
    token  = __ansitowide(*ppsz);
    *ppsz += strlen(*ppsz);
  }

  return token;
}


BOOL
StoreEnvironmentVariable(
  PSPORK pSpork,
  LPWSTR nvpair
  )
{
  BOOL   bStored = FALSE;
  LPWSTR token   = NULL;

  if( nvpair )
  {
    token = StrChr(nvpair, L'=');

    if( token )
    {
      *token  = L'\0';
      bStored = nvpairhelper(pSpork, nvpair, token+1);
    }
  }

  return bStored;
}


BOOL
nvpairhelper(
  PSPORK pSpork,
  LPWSTR name,
  LPWSTR value
  )
{
  VARIANT* pvr = NULL;

  if( value )
  {
    pvr = new VARIANT;

    if( pvr )
    {
      V_VT(pvr)   = VT_BSTR;
      V_BSTR(pvr) = __widetobstr(value);

      pSpork->PropertyBag(name, &pvr, STORE);

      VariantClear(pvr);
      SAFEDELETE(pvr);

      LogTrace(L"stored environment var \"%s\" with value \"%s\"", name, value);

      return TRUE;
    }
  }

  return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\tools\spork\inc\common.h ===
/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Copyright (c) 2001  Microsoft Corporation

Module Name:

    common.h

Abstract:

    Generates the precompiled header.
    
Author:

    Paul M Midgen (pmidge) 22-February-2001


Revision History:

    22-February-2001 pmidge
        Created

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/


#ifndef _COMMON_H_
#define _COMMON_H_


#define _WIN32_WINNT 0x0500
#define _UNICODE
#define UNICODE


//-----------------------------------------------------------------------------
// os includes
//-----------------------------------------------------------------------------
#if defined(__cplusplus)
extern "C" {
#endif

#include <windows.h>
#include <commdlg.h>
#include <advpub.h>
#include <oleauto.h>
#include <objbase.h>
#include <ocidl.h>
#include <olectl.h>
#include <activscp.h>
#include <activdbg.h>
#include <commctrl.h>

#define NO_SHLWAPI_GDI
#define NO_SHLWAPI_STREAM
#define NO_SHLWAPI_REG

#include <shlwapi.h>

#if defined(__cplusplus)
}
#endif


//-----------------------------------------------------------------------------
// project includes
//-----------------------------------------------------------------------------
#include <dispids.h>
#include <scrrun.h>     // generated
#include <resources.h>
#include <hashtable.h>
#include <utils.h>
#include <log.h>
#include <scrobj.h>
#include <spork.h>


//-----------------------------------------------------------------------------
// global functions
//-----------------------------------------------------------------------------
BOOL   GlobalInitialize(PSPORK pSpork, LPSTR szCmdLine);
void   GlobalUninitialize(void);
LPWSTR GlobalGetScriptName(void);
LPWSTR GlobalGetProfileName(void);
BOOL   GlobalIsSilentModeEnabled(void);
BOOL   GlobalIsDebugOutputEnabled(void);


#endif /* _COMMON_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\tools\spork\inc\hashtable.h ===
/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Copyright (c) 2000  Microsoft Corporation

Module Name:

    hashtable.cxx

Abstract:

    Simple hash table implementation.


Author:

    Paul M Midgen (pmidge) 14-August-2000


Revision History:

    14-August-2000 pmidge
        Created

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/

#include <common.h>

/*++===========================================================================

    An array is separated into N buckets that     +---+
    each contain a pointer to a binary search     | 0 |------> O
    tree. The tree's nodes are indexed by a       +---+       / \
    DWORD identifier to enable speedy traversals. | 1 |      O   O
    The array buckets are indexed by the values   +---+     / \   \
    generated by the hashing function supplied    | 2 |    O   O   O
    by a derived class.                           +---+        
                                                  | N |

    Clients derive a class from the hashtable ADT and specialize it for a 
    given data type. Any data type can be used. The only function the client
    must implement is the GetHashAndBucket function, and their class must
    provide the number of buckets the ADT needs to support. This is usually
    some number that is modulo'd against the generated hashes to yield the
    bucket number.

===========================================================================--*/

#define HT_COMPARE_LARGER  0x00000001
#define HT_COMPARE_SMALLER 0x00000002
#define HT_COMPARE_EQUAL   0x00000003

#define HT_TREE_ROOT       0x00000004
#define HT_TREE_RHSUBTREE  0x00000005
#define HT_TREE_LHSUBTREE  0x00000006

typedef struct _NODE
{
  DWORD  hash;
  DWORD  bucket;
  LPVOID data;
  _NODE* parent;
  _NODE* rh_child;
  _NODE* lh_child;
  BOOL   isLeft;
}
NODE, *PNODE;

typedef VOID (*PFNCLEARFUNC)(LPVOID* ppv);

template <class T> class CHashTable
{
  public:
    CHashTable(DWORD buckets)
    {
      pfnClear  = NULL;
      cBuckets  = buckets;
      arBuckets = new PNODE[buckets];
      InitializeCriticalSection(&csTable);
    }

   ~CHashTable()
    {
      SAFEDELETEBUF(arBuckets);
      DeleteCriticalSection(&csTable);
    }

    virtual void GetHashAndBucket(T id, LPDWORD lpHash, LPDWORD lpBucket) =0;

    DWORD Insert(T id, LPVOID pv);
    DWORD Get(T id, LPVOID* ppv);
    DWORD Delete(T id, LPVOID* ppv);

    void  Clear(void);
    void  SetClearFunction(PFNCLEARFUNC pfn) { pfnClear = pfn; }

  private:
    void  _Get(DWORD hash, PNODE& proot, PNODE& pnode);
    DWORD _Insert(PNODE& proot, PNODE pnew);
    void  _Remove(DWORD hash, PNODE& proot, PNODE& pnode);

    PNODE _NewNode(T id, LPVOID pv);
    DWORD _CompareNodes(DWORD hash_target, DWORD hash_tree);

    BOOL  _HasChildren(PNODE pnode);
    void  _PostTraverseAndDelete(PNODE proot);
    void  _Lock(void)   { EnterCriticalSection(&csTable); }
    void  _Unlock(void) { LeaveCriticalSection(&csTable); }

    PNODE*           arBuckets;
    DWORD            cBuckets;
    CRITICAL_SECTION csTable;
    PFNCLEARFUNC     pfnClear;
};

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------

template <class T> DWORD CHashTable<T>::Insert(T id, LPVOID pv)
{
  DWORD ret = ERROR_SUCCESS;
  PNODE pn  = _NewNode(id, pv);

  _Lock();

    if( pn )
    {
      ret = _Insert(arBuckets[pn->bucket], pn);
    }
    else
    {
      ret = ERROR_OUTOFMEMORY;
    }

  _Unlock();

  return ret;
}

template <class T> DWORD CHashTable<T>::Get(T id, LPVOID* ppv)
{
  DWORD ret    = ERROR_SUCCESS;
  DWORD hash   = 0L;
  DWORD bucket = 0L;
  PNODE pnode  = NULL;

  GetHashAndBucket(id, &hash, &bucket);

  _Lock();

    _Get(hash, arBuckets[bucket], pnode);

    if( pnode )
    {
      *ppv = (void*) pnode->data;
    }
    else
    {
      *ppv = NULL;
      ret  = ERROR_NOT_FOUND;
    }

  _Unlock();

  return ret;
}

template <class T> DWORD CHashTable<T>::Delete(T id, LPVOID* ppv)
{
  DWORD ret   = ERROR_SUCCESS;
  DWORD hash   = 0L;
  DWORD bucket = 0L;
  PNODE pnode = NULL;

  GetHashAndBucket(id, &hash, &bucket);

  _Lock();

    _Remove(hash, arBuckets[bucket], pnode);

    if( pnode )
    {
      if( ppv )
      {
        *ppv = pnode->data;
      }
      else
      {
        if( pfnClear )
        {
          pfnClear(&pnode->data);
        }
      }

      delete pnode;
    }
    else
    {
      ret = ERROR_NOT_FOUND;

      if( ppv )
      {
        *ppv = NULL;
      }
    }

  _Unlock();

  return ret;
}

template <class T> void CHashTable<T>::Clear(void)
{
  _Lock();

    for(DWORD n=0; n < cBuckets; n++)
    {
      if( arBuckets[n] )
      {
        _PostTraverseAndDelete(arBuckets[n]);
        arBuckets[n] = NULL;
      }
    }

  _Unlock();
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------

template <class T> DWORD CHashTable<T>::_Insert(PNODE& proot, PNODE pnew)
{
  DWORD ret = ERROR_SUCCESS;

  if( pnew )
  {
    if( !proot )
    {
      proot = pnew;
    }
    else
    {
      switch( _CompareNodes(pnew->hash, proot->hash) )
      {
        case HT_COMPARE_SMALLER :
          {
            pnew->isLeft = TRUE;
            pnew->parent = proot;
            ret = _Insert(proot->lh_child, pnew);
          }
          break;

        case HT_COMPARE_LARGER :
          {
            pnew->isLeft = FALSE;
            pnew->parent = proot;
            ret = _Insert(proot->rh_child, pnew);
          }
          break;

        case HT_COMPARE_EQUAL :
          {
            if( pfnClear )
            {
              pfnClear(&proot->data);
            }

            ret         = ERROR_DUP_NAME;
            proot->data = pnew->data;
            delete pnew;
          }
          break;
      }
    }
  }

  return ret;
}

template <class T> void CHashTable<T>::_Get(DWORD hash, PNODE& proot, PNODE& pnode)
{
  if( proot )
  {
    switch( _CompareNodes(hash, proot->hash) )
    {
      case HT_COMPARE_SMALLER :
        {
          _Get(hash, proot->lh_child, pnode);
        }
        break;

      case HT_COMPARE_LARGER :
        {
          _Get(hash, proot->rh_child, pnode);
        }
        break;

      case HT_COMPARE_EQUAL :
        {
          pnode = proot;
        }
        break;
    }
  }
  else
  {
    pnode = NULL;
  }
}

template <class T> void CHashTable<T>::_Remove(DWORD hash, PNODE& proot, PNODE& pnode)
{
  if( proot )
  {
    switch( _CompareNodes(hash, proot->hash) )
    {
      case HT_COMPARE_SMALLER :
        {
          _Remove(hash, proot->lh_child, pnode);
        }
        break;

      case HT_COMPARE_LARGER :
        {
          _Remove(hash, proot->rh_child, pnode);
        }
        break;

      case HT_COMPARE_EQUAL :
        {
          pnode = proot;

          //
          // if proot has no parent it is the tree's root node
          //
          //   - if it has children, promote the left child to root
          //     and insert the right child in the new tree. after
          //     inserting, make sure the new root has no parent.
          //
          //   - if it has no children the tree is empty, set the root
          //     to null
          //

          if( !proot->parent )
          {
            if( _HasChildren(proot) )
            {
              proot = proot->lh_child;
              _Insert(proot, pnode->rh_child);
              proot->parent = NULL;
            }
            else
            {
              proot = NULL;
            }
          }
          else
          {
            if( proot->isLeft )
            {
              proot->parent->lh_child = NULL;
            }
            else
            {
              proot->parent->rh_child = NULL;
            }

            _Insert(pnode->parent, pnode->lh_child);
            _Insert(pnode->parent, pnode->rh_child);
          }
        }
        break;
    }
  }
  else
  {
    pnode = NULL;
  }
}

template <class T> void CHashTable<T>::_PostTraverseAndDelete(PNODE proot)
{
  if( proot )
  {
    _PostTraverseAndDelete(proot->lh_child);
    _PostTraverseAndDelete(proot->rh_child);

    if( pfnClear )
    {
      pfnClear(&proot->data);
    }

    delete proot;
    proot = NULL;
  }
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------

template <class T> DWORD CHashTable<T>::_CompareNodes(DWORD hash_target, DWORD hash_tree)
{
  if( hash_target == hash_tree )
  {
    return HT_COMPARE_EQUAL;
  }
  else if( hash_target < hash_tree )
  {
    return HT_COMPARE_SMALLER;
  }
  else
  {
    return HT_COMPARE_LARGER;
  }
}

template <class T> PNODE CHashTable<T>::_NewNode(T id, LPVOID pv)
{
  PNODE pn = new NODE;

  if( pn )
  {
    GetHashAndBucket(id, &pn->hash, &pn->bucket);
    pn->data = pv;
  }

  return pn;
}

template <class T> BOOL CHashTable<T>::_HasChildren(PNODE pnode)
{
  if( pnode )
  {
    return (pnode->lh_child || pnode->rh_child);
  }
  else
  {
    return FALSE;
  }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\tools\spork\inc\pch.cxx ===
#include "common.h"

void foobar(void);

void foobar(void)
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\tools\spork\inc\log.h ===
/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Copyright (c) 2001  Microsoft Corporation

Module Name:

    log.h

Abstract:

    Declaration of the session logging routines used by Spork.
    
Author:

    Paul M Midgen (pmidge) 21-February-2001


Revision History:

    21-February-2001 pmidge
        Created

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/


#include <common.h>


#ifndef __LOG_H__
#define __LOG_H__


//-----------------------------------------------------------------------------
// types internal to the logging routines
//-----------------------------------------------------------------------------
typedef enum _rettype
{
  rt_void,
  rt_bool,
  rt_dword,
  rt_hresult,
  rt_string
}
RETTYPE, *LPRETTYPE;

enum DEPTH
{
  INCREMENT,
  DECREMENT,
  MAINTAIN
};

typedef struct _callinfo
{
  struct _callinfo* next;
  struct _callinfo* last;
  LPCWSTR           fname;
  RETTYPE           rettype;
}
CALLINFO, *LPCALLINFO;

typedef struct _threadinfo
{
  DWORD      threadid;
  DWORD      depth;
  LPCALLINFO stack;
}
THREADINFO, *LPTHREADINFO;


//-----------------------------------------------------------------------------
// public functions
//-----------------------------------------------------------------------------
HRESULT LogInitialize(void);
void    LogTerminate(void);
void    LogEnterFunction(LPCWSTR function, RETTYPE rt, LPCWSTR format, ...);
void    LogLeaveFunction(INT_PTR retval);
void    LogTrace(LPCWSTR format, ...);

void    ToggleDebugOutput(BOOL bEnable);

LPWSTR  MapHResultToString(HRESULT hr);
LPWSTR  MapErrorToString(INT_PTR error);


#ifdef _DEBUG
//-----------------------------------------------------------------------------
// _DEBUG build only logging macros
//-----------------------------------------------------------------------------
#define DEVTRACE(x) OutputDebugString(L##x##L"\r\n");

#define DEBUG_ENTER(parameters) \
              LogEnterFunction parameters

#define DEBUG_LEAVE(retval) \
              LogLeaveFunction(retval)

#define DEBUG_TRACE(parameters) \
              LogTrace parameters

#define DEBUG_FINALRELEASE(objname) \
              LogTrace(L"%s [%#x] final release!", objname, this)

#ifdef _DEBUG_REFCOUNT
#define DEBUG_ADDREF(objname, refcount) \
              LogTrace(L"%s [%#x] addref: %d", objname, this, refcount)

#define DEBUG_RELEASE(objname, refcount) \
              LogTrace(L"%s [%#x] release: %d", objname, this, refcount)
#else
#pragma warning( disable : 4002 )
#pragma warning( disable : 4003 )

#define DEBUG_ADDREF(x)
#define DEBUG_RELEASE(x)
#endif /* _DEBUG_REFCOUNT */

#else

// we will get rebuked for the bogus 
// arglists in the debug macros
#pragma warning( disable : 4002 )
#pragma warning( disable : 4003 )

#define DEBUG_ENTER(x)
#define DEBUG_LEAVE(x)
#define DEBUG_TRACE(x)
#define DEBUG_ADDREF(x)
#define DEBUG_RELEASE(x)
#define DEBUG_FINALRELEASE(x)

#endif /* _DEBUG */

#endif /* __LOG_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\tools\spork\inc\utils.h ===
/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Copyright (c) 2001  Microsoft Corporation

Module Name:

    utils.h

Abstract:

    Utility functions used by the probject.
    
Author:

    Paul M Midgen (pmidge) 22-February-2001


Revision History:

    22-February-2001 pmidge
        Created

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/

#ifndef _UTILS_H_
#define _UTILS_H_

void* __cdecl operator new(size_t size);
void  __cdecl operator delete(void* pv);

// general utility
void    Alert(BOOL bFatal, LPCWSTR format, ...);
INT_PTR GetUserInput(HINSTANCE Instance, HWND Parent, LPCWSTR DialogTitle);
BOOL    IsRunningOnNT(void);
HRESULT GetTypeInfoFromName(LPCOLESTR name, ITypeLib* ptl, ITypeInfo** ppti);
DISPID  GetDispidFromName(PDISPIDTABLEENTRY pdt, DWORD cEntries, LPWSTR name);
HRESULT HandleDispatchError(LPWSTR id, EXCEPINFO* pei, HRESULT hr);
void    AddRichErrorInfo(EXCEPINFO* pei, LPWSTR source, LPWSTR description, HRESULT error);
DWORD   GetHash(LPWSTR name);
HRESULT DispGetOptionalParam(DISPPARAMS* pdp, UINT pos, VARTYPE vt, VARIANT* pvr, UINT* pae);
HRESULT ValidateDispatchArgs(REFIID riid, DISPPARAMS* pdp, VARIANT* pvr, UINT* pae);
HRESULT ValidateInvokeFlags(WORD flags, WORD accesstype, BOOL bNotMethod);
HRESULT ValidateArgCount(DISPPARAMS* pdp, DWORD needed, BOOL bHasOptionalArgs, DWORD optional);

// registry
BOOL  ManageRootKey(BOOL fOpen);
DWORD GetNumberOfSubKeysFromKey(LPCWSTR wszKeyName);
BOOL  SetRootRegValue(LPCWSTR wszValueName, DWORD dwType, LPVOID pvData, DWORD dwSize);
BOOL  GetRootRegValue(LPCWSTR wszValueName, DWORD dwType, LPVOID* ppvData);
BOOL  SetRegValueInKey(LPCWSTR wszKeyName, LPCWSTR wszValueName, DWORD dwType, LPVOID pvData, DWORD dwSize);
BOOL  GetRegValueFromKey(LPCWSTR wszKeyName, LPCWSTR wszValueName, DWORD dwType, LPVOID* ppvData);
BOOL  SetRegKey(LPCWSTR wszPath, LPCWSTR wszKeyName);
BOOL  EnumerateSubKeysFromKey(LPCWSTR wszKeyName, LPWSTR* ppwszSubKeyName);
BOOL  EnumerateRegValuesFromKey(LPCWSTR wszKeyName, LPWSTR* ppwszValueName, LPDWORD pdwType, LPVOID* ppvData);

// user interface
LRESULT ListBox_GetItemCount(HWND hwndLB);
LPWSTR  ListBox_GetItemText(HWND hwndLB, INT_PTR iItem);
void    ListBox_ResetContent(HWND hwndLB);
BOOL    ListBox_InsertString(HWND hwndLB, INT_PTR iItem, LPWSTR wszString);
LRESULT ListBox_GetSelectionIndex(HWND hwndLB);
LPWSTR  ListBox_GetSelectionText(HWND hwndLB);
LPVOID  ListBox_GetItemData(HWND hwndLB, INT_PTR iItem);
BOOL    ListBox_SetItemData(HWND hwndLB, INT_PTR iItem, LPVOID pvData);
BOOL    ListBox_SetCurrentSelection(HWND hwndLB, INT_PTR iItem);

// string handling
CHAR*  __widetoansi(const WCHAR* pwsz);
WCHAR* __ansitowide(const char* psz);
BOOL   __isempty(VARIANT* var);
BOOL   __mangle(LPWSTR src, LPWSTR* ppdest);
LPWSTR __decorate(LPWSTR src, DWORD_PTR decor);
BSTR   __ansitobstr(LPCSTR src);
BSTR   __widetobstr(LPCWSTR wsrc);
char*  __unescape(char* str);

#endif /* _UTILS_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\tools\spork\inc\scrobj.h ===
/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Copyright (c) 2001  Microsoft Corporation

Module Name:

    scrobj.h

Abstract:

    Declaration of the ScriptObject class. Implementation is
    in ..\src\scrobj.
    
Author:

    Paul M Midgen (pmidge) 22-February-2001


Revision History:

    22-February-2001 pmidge
        Created

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/


#include <common.h>


#ifndef __SCROBJ_H__
#define __SCROBJ_H__


DWORD WINAPI ScriptThread(LPVOID pv);


class ScriptObject : public IScriptRuntime,
                     public IActiveScriptSite,
                     public IActiveScriptSiteDebug,
                     public IProvideClassInfo
{
  public:
    DECLAREIUNKNOWN();
    DECLAREIDISPATCH();

    // IScriptRuntime
    HRESULT __stdcall CreateObject(
                        BSTR     ProgId,
                        VARIANT* Name,
                        VARIANT* Mode,
                        VARIANT* Object
                        );

    HRESULT __stdcall CreateFork(
                        BSTR     ScriptFile,
                        VARIANT  Threads,
                        BSTR     ChildParams,
                        VARIANT* ChildResult
                        );

    HRESULT __stdcall PutValue(
                        BSTR     Name,
                        VARIANT* Value,
                        VARIANT* Status
                        );

    HRESULT __stdcall GetValue(
                        BSTR     Name,
                        VARIANT* Value
                        );

    HRESULT __stdcall SetUserId(
                        VARIANT  Username,
                        VARIANT  Password,
                        VARIANT* Domain,
                        VARIANT* Status
                        );

    DECLAREIACTIVESCRIPTSITE();
    DECLAREIACTIVESCRIPTSITEDEBUG();
    DECLAREIPROVIDECLASSINFO();

  public:
    ScriptObject();
   ~ScriptObject();

    static HRESULT Create(PSCRIPTINFO psi, PSCRIPTOBJ* ppscrobj);

    HRESULT Run(void);
    HRESULT Terminate(void);

  private:
    HRESULT        _Initialize(PSCRIPTINFO psi);
    LPWSTR         _LoadScript(void);
    HRESULT        _LoadScriptDebugger(void);
    BOOL           _PreprocessScript(HANDLE* phScript);
    BOOL           _RunPreprocessor(void);
    BOOL           _IsDotINewer(LPCWSTR wszDotI);
    BOOL           _IsUnicodeScript(LPVOID pBuf, DWORD cBuf);
    SCRIPTTYPE     _GetScriptType(void);
    HRESULT        _CreateObject(LPWSTR wszProgId, IDispatch** ppdisp);

  private:
    LONG               m_cRefs;
    PSCRIPTINFO        m_psi;
    LPCWSTR            m_wszScriptFile;
    IActiveScript*     m_pScriptEngine;
    IDebugApplication* m_pDebugApplication;
    HTREEITEM          m_htThis;
    DBGOPTIONS         m_DebugOptions;
};

#endif /* __SCROBJ_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\tools\spork\inc\spork.h ===
/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Copyright (c) 2001  Microsoft Corporation

Module Name:

    spork.h

Abstract:

    Declaration of the Spork class. Implementation is in ..\src\spobj.
    
Author:

    Paul M Midgen (pmidge) 22-February-2001


Revision History:

    22-February-2001 pmidge
        Created

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/


#ifndef __SPORK_H__
#define __SPORK_H__


typedef class CObjectCache  OBJCACHE;
typedef class CObjectCache* POBJCACHE;
typedef class CPropertyBag  PROPERTYBAG;
typedef class CPropertyBag* PPROPERTYBAG;

class MultiListView;

void ObjectKiller(LPVOID* ppv);
void VariantKiller(LPVOID* ppv);

typedef class CHashTable<LPWSTR> _WSZTABLE;

class CObjectCache : public _WSZTABLE
{
  public:
    CObjectCache() : _WSZTABLE(10) {}
   ~CObjectCache() {}

    void GetHashAndBucket(LPWSTR id, LPDWORD lpHash, LPDWORD lpBucket);
};


class CPropertyBag : public _WSZTABLE
{
  public:
    CPropertyBag() : _WSZTABLE(10) {}
   ~CPropertyBag() {}

    void GetHashAndBucket(LPWSTR id, LPDWORD lpHash, LPDWORD lpBucket);
};


class Spork
{
  public:
    HRESULT CreateScriptThread(
              PSCRIPTINFO pScriptInfo,
              HANDLE*     pThreadHandle
              );

    HRESULT GetScriptEngine(
              SCRIPTTYPE      st,
              IActiveScript** ppias
              );

    HRESULT GetTypeLib(
              ITypeLib** pptl
              );

    HRESULT GetNamedProfileItem(
              LPWSTR  wszItemName,
              LPVOID* ppvItem
              );

    HRESULT GetProfileDebugOptions(
              PDBGOPTIONS pdbo
              );

    HRESULT ObjectCache(
              LPWSTR       wszObjectName,
              PCACHEENTRY* ppCacheEntry,
              ACTION       action
              );

    HRESULT PropertyBag(
              LPWSTR    wszPropertyName,
              VARIANT** ppvarValue,
              ACTION    action
              );

    HRESULT NotifyUI(
              BOOL       bInsert,
              LPCWSTR    wszName,
              PSCRIPTOBJ pScriptObject,
              HTREEITEM  htParent,
              HTREEITEM* phtItem
              );
    
    friend INT_PTR CALLBACK DlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    friend INT_PTR CALLBACK ProfilePropPageProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    friend INT_PTR CALLBACK DebugPropPageProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

    Spork();
   ~Spork();

    static HRESULT Create(HINSTANCE hInst, PSPORK* pps);
    HRESULT Run(void);

  private:
    HRESULT    _Initialize(HINSTANCE hInst);
    HRESULT    _InitializeScriptDebugger(DBGOPTIONS dbo);
    BOOL       _InitializeUI(void);
    HRESULT    _LaunchUI(void);

    INT_PTR    _DlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    BOOL       _BrowseForScriptFile(void);
    INT_PTR    _RunClicked(void);
    INT_PTR    _ConfigClicked(void);

    INT_PTR    _DebugPropPageProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    BOOL       _LoadDebugOptions(void);
    BOOL       _SaveDebugOptions(HWND dialog);

    INT_PTR    _ProfilePropPageProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    INT_PTR    _InitProfileSupport(HWND hwndDialog, LPWSTR wszProfile);
    BOOL       _InitProfileSelection(void);
    BOOL       _LoadProfiles(void);
    BOOL       _SaveProfiles(void);
    BOOL       _LoadProfileEntries(INT_PTR dwProfileId, LPWSTR wszProfileName);
    LPWSTR     _GetCurrentProfilePath(void);
    BOOL       _NewProfile(HWND hwnd);
    
  private:
    HINSTANCE          m_hInst;
    DLGWINDOWS         m_DlgWindows;
    ITypeLib*          m_pTypeLib;
    IActiveScript*     m_pScriptEngine[2];
    LPWSTR             m_wszScriptFile;
    LPWSTR             m_wszProfile;
    BOOL               m_bProfilesLoaded;
    POBJCACHE          m_pObjectCache;
    PPROPERTYBAG       m_pPropertyBag;
    MultiListView*     m_pMLV;
};


class MultiListView
{
  public:
    MultiListView() {};
   ~MultiListView();

    BOOL InitializeData(
           DWORD cListViews
           );

    BOOL InitializeDisplay(
           HINSTANCE hInstance,
           HWND      hwndParent,
           POINT*    pptOrigin,
           DWORD     dwWidth,
           DWORD     dwHeight
           );

    BOOL TerminateDisplay(void);

    BOOL AddItem(
           INT_PTR    iListView,
           LPWSTR wszName,
           DWORD  dwType,
           LPVOID pvData
           );

    BOOL GetItem(
           INT_PTR     iListView,
           INT_PTR     iItem,
           LPWSTR* ppwszName,
           LPDWORD pdwType,
           LPVOID* ppvData
           );

    BOOL GetItemByName(
           INT_PTR     iListView,
           LPWSTR  wszName,
           LPDWORD pdwType,
           LPVOID* ppvData
           );

    BOOL ModifyItem(
           INT_PTR    iListView,
           INT_PTR    iItem,
           LPWSTR wszName,
           DWORD  dwType,
           LPVOID pvData
           );

    BOOL EnumItems(
           INT_PTR     iListView,
           LPWSTR* ppwszName,
           LPDWORD pdwType,
           LPVOID* ppvData
           );

    BOOL EnumListViewNames(
           LPWSTR* ppwszName
           );

    BOOL RefreshListView(
           INT_PTR iListView
           );

    BOOL GetListViewName(
           INT_PTR     iListView,
           LPWSTR* ppwszName
           );

    BOOL SetListViewName(
           INT_PTR    iListView,
           LPWSTR wszName
           );

    BOOL ActivateListViewByIndex(
           INT_PTR iListView
           );

    BOOL ActivateListViewByName(
           LPWSTR wszName
           );

    INT_PTR GetActiveIndex(void);

    BOOL InPlaceEdit(
           LPNMITEMACTIVATE pnmia
           );

    BOOL ResizeColumns(
           INT_PTR iListView
           );

    BOOL IsModified(
           INT_PTR iListView
           );

    BOOL IsListViewName(
           LPWSTR wszName
           );
    
    BOOL IsDisplayEnabled(void) { return (m_hwndParent ? TRUE : FALSE); }

    BOOL GetDisplayInfo(
           LPLVITEM plvi
           );

    BOOL GetDebugOptions(
           PDBGOPTIONS pdbo
           );

    BOOL SetDebugOptions(
           DBGOPTIONS dbo
           );

    friend LRESULT ListViewSubclassProc(
                     HWND   hwnd,
                     UINT   uMsg,
                     WPARAM wParam,
                     LPARAM lParam
                     );

  private:
    void    _AddItemToListView(
              INT_PTR iListView,
              INT_PTR iItem
              );

    BOOL    _UpdateItem(
              HWND hwndEdit,
              INT_PTR  iItem
              );

    LRESULT _ListViewSubclassProc(
              HWND   hwnd,
              UINT   uMsg,
              WPARAM wParam,
              LPARAM lParam
              );
  
  private:
    HINSTANCE m_hInstance;
    HWND      m_hwndParent;
    DWORD_PTR m_dwActive;
    DWORD_PTR m_cListViews;
    PMLVINFO  m_arListViews;
};


#endif /* __SPORK_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\tools\spork\inc\resources.h ===
/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Copyright (c) 2001  Microsoft Corporation

Module Name:

    resources.h

Abstract:

    Shared macros, typedefs, etc. used by the project.
    
Author:

    Paul M Midgen (pmidge) 22-February-2001


Revision History:

    22-February-2001 pmidge
        Created

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/

#ifndef __RESOURCES_H__
#define __RESOURCES_H__

#define ERROR_FAILURE        0xFFFFF666

#define IDC_UNUSED            -1

#define IDD_SPORK            100
#define IDD_PROPPAGE_DEBUG   101
#define IDD_PROPPAGE_PROFILE 102
#define IDD_USERINPUT        103

#define IDI_DEFAULT          200
#define IDI_SCRIPT           201
#define IDI_DBGOUT           202
#define IDI_PROFILE          203
#define IDI_DEBUG            204

#define IDB_QUIT             300
#define IDB_RUN              301
#define IDB_BROWSE           302
#define IDB_CONFIG           303
#define IDB_ENABLEDEBUG      304
#define IDB_DBGBREAK         305
#define IDB_ENABLEDBGOUT     306
#define IDB_NEWPROFILE       307
#define IDB_DELPROFILE       308

#define IDT_TITLE            400
#define IDT_SCRIPTPATH       401
#define IDT_DBGTXT           402
#define IDT_DBGOUTTXT        403

#define IDC_SCRIPTTREE       500
#define IDC_PROFILELIST      501
#define IDC_PROFILEITEMS     502
#define IDC_EDIT             503

#define DECLAREIUNKNOWN() \
    HRESULT __stdcall QueryInterface(REFIID riid, void** ppv); \
    ULONG   __stdcall AddRef(void); \
    ULONG   __stdcall Release(void); 

#define DECLAREICLASSFACTORY() \
    HRESULT __stdcall CreateInstance(IUnknown* outer, REFIID riid, void** ppv); \
    HRESULT __stdcall LockServer(BOOL lock);

#define DECLAREIDISPATCH() \
    HRESULT __stdcall GetTypeInfoCount(UINT* pctinfo);  \
    HRESULT __stdcall GetTypeInfo(UINT index, LCID lcid, ITypeInfo** ppti); \
    HRESULT __stdcall GetIDsOfNames(REFIID riid, LPOLESTR* arNames, UINT cNames, LCID lcid, DISPID* arDispId); \
    HRESULT __stdcall Invoke(DISPID dispid, REFIID riid, LCID lcid, WORD flags, DISPPARAMS* pdp, VARIANT* pvr, EXCEPINFO* pei, UINT* pae);

#define DECLAREIACTIVESCRIPTSITE() \
    HRESULT __stdcall GetLCID(LCID* plcid); \
    HRESULT __stdcall GetItemInfo(LPCOLESTR pstrName, DWORD dwReturnMask, IUnknown** ppunk, ITypeInfo** ppti); \
    HRESULT __stdcall GetDocVersionString(BSTR* pbstrVersion); \
    HRESULT __stdcall OnScriptTerminate(const VARIANT* pvarResult, const EXCEPINFO* pei); \
    HRESULT __stdcall OnStateChange(SCRIPTSTATE ss); \
    HRESULT __stdcall OnScriptError(IActiveScriptError* piase); \
    HRESULT __stdcall OnEnterScript(void); \
    HRESULT __stdcall OnLeaveScript(void);

#define DECLAREIACTIVESCRIPTSITEDEBUG() \
    HRESULT __stdcall GetDocumentContextFromPosition(DWORD dwSourceContext, ULONG uCharacterOffset, ULONG uNumChars, IDebugDocumentContext** ppdc); \
    HRESULT __stdcall GetApplication(IDebugApplication** ppda); \
    HRESULT __stdcall GetRootApplicationNode(IDebugApplicationNode** ppdan); \
    HRESULT __stdcall OnScriptErrorDebug(IActiveScriptErrorDebug* pErrorDebug, LPBOOL pfEnterDebugger, LPBOOL pfCallOnScriptErrorWhenContinuing);

#define DECLAREIPROVIDECLASSINFO() \
    HRESULT __stdcall GetClassInfo(ITypeInfo** ppti);

#define DECLAREIOBJECTWITHSITE() \
    HRESULT __stdcall SetSite(IUnknown* pUnkSite); \
    HRESULT __stdcall GetSite(REFIID riid, void** ppvSite);


#define SAFECLOSE(x) if((x!=INVALID_HANDLE_VALUE) && (x!=NULL)) { CloseHandle(x); x=NULL; }
#define SAFEDELETE(x) if(x) { delete x; x=NULL; }
#define SAFEDELETEBUF(x) if(DWORD_PTR(x)) {delete [] x; x=NULL;}
#define SAFERELEASE(x) if(x) { x->Release(); x=NULL; }
#define SAFEDELETEBSTR(x) if(x) { SysFreeString(x); x=NULL; }
#define VALIDDISPID(x) ((x!=DISPID_UNKNOWN) ? TRUE : FALSE)
#define NEWVARIANT(x) VARIANT x; memset(&x, 0, sizeof(VARIANT)); VariantInit(&x);

#ifdef IA64
#define ITOW(val, buf, radix) _i64tow(val, buf, radix);
#else
#define ITOW(val, buf, radix) _itow(val, buf, radix);
#endif

#define THROWMEMALERT(x) LogTrace(L"*** WARNING: failed to allocate \'%s\' near line %d of %S", x, __LINE__, __FILE__)

#define TF(x) (x?L"TRUE":L"FALSE")
#define VTF(x) ((V_BOOL(x) == VARIANT_TRUE)?L"TRUE":L"FALSE")

#define VPF(x) ((V_BOOL(x) == VARIANT_TRUE)?L"PASS":L"FAIL")

#define ENABLED(x)    (x?L"enabled":L"disabled")
#define SUCCESSFUL(x) (SUCCEEDED(x) ? L"successful" : L"unsuccessful")

#define STRING(x)     (x?x:L"null")

#define CASE_OF(constant) case constant: return L#constant
#define CASE_OF_MUTATE(val, name) case val: return L#name
#define CASE_IID(riid, iid) if(IsEqualIID(riid, iid)) return L#iid

typedef BY_HANDLE_FILE_INFORMATION   BHFI;
typedef LPBY_HANDLE_FILE_INFORMATION LPBHFI;
typedef WIN32_FILE_ATTRIBUTE_DATA    W32FAD;
typedef WIN32_FILE_ATTRIBUTE_DATA*   PW32FAD;
typedef CRITICAL_SECTION             CRITSEC;
typedef LPCRITICAL_SECTION           PCRITSEC;

typedef class Spork         SPORK;
typedef class Spork*        PSPORK;
typedef class ScriptObject  SCRIPTOBJ;
typedef class ScriptObject* PSCRIPTOBJ;

typedef struct _dbgoptions
{
  BOOL bEnableDebug;
  BOOL bBreakOnScriptStart;
  BOOL bEnableDebugWindow;
}
DBGOPTIONS, *PDBGOPTIONS;

typedef struct _tagItemInfo
{
  LPWSTR        wszName;
  DWORD         dwType;
  LPWSTR        wszValue;
  DWORD         dwValue;
  _tagItemInfo* pNext;
}
ITEMINFO, *PITEMINFO;

typedef struct _tagListViewInfo
{
  LPWSTR     name;
  HWND       hwnd;
  WNDPROC    wndproc;
  BOOL       modified;
  PITEMINFO  items;
  DBGOPTIONS dbgopts;
  DWORD      currentid;
}
MLVINFO, *PMLVINFO;

#define MLV_RETAIN 0xF00DD00D
#define MLV_STRING REG_SZ
#define MLV_DWORD  REG_DWORD

typedef struct _dispidtableentry
{
  DWORD  hash;
  DISPID dispid;
  LPWSTR name;
}
DISPIDTABLEENTRY, *PDISPIDTABLEENTRY;

typedef struct _scriptinfo
{
  PSPORK    pSpork;
  LPCWSTR   wszScriptFile;
  BOOL      bIsFork;
  BSTR      bstrChildParams;
  HTREEITEM htParent;
}
SCRIPTINFO, *PSCRIPTINFO;

typedef struct _dlgwindows
{
  HWND Dialog;
  HWND ScriptFile;
  HWND TreeView;
}
DLGWINDOWS, *PDLGWINDOWS;

typedef enum SCRIPTTYPE
{
  JSCRIPT = 0,
  VBSCRIPT,
  UNKNOWN
}
SCRIPTTYPE;

typedef struct _cacheentry
{
  IDispatch* pDispObject;
  DWORD      dwObjectFlags;
  BOOL       bStoreOnly;
}
CACHEENTRY, *PCACHEENTRY;

typedef enum ACTION
{
  STORE,
  RETRIEVE,
  REMOVE
}
ACTION;

#endif /* __RESOURCES_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\tools\spork\sporklets\testlog\inc\common.h ===
/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Copyright (c) 2001  Microsoft Corporation

Module Name:

    common.h

Abstract:

    Generates the precompiled header.
    
Author:

    Paul M Midgen (pmidge) 20-March-2001


Revision History:

    20-March-2001 pmidge
        Created

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/


#ifndef __COMMON_H__
#define __COMMON_H__

#define _WIN32_WINNT 0x0500
#define _UNICODE
#define UNICODE

#if defined(__cplusplus)
extern "C" {
#endif

#include <windows.h>
#include <advpub.h>
#include <oleauto.h>
#include <objbase.h>
#include <ocidl.h>
#include <olectl.h>

#define NO_SHLWAPI_GDI
#define NO_SHLWAPI_STREAM
#define NO_SHLWAPI_REG

#include <shlwapi.h>

#if defined(__cplusplus)
}
#endif

#include "ifaces.h"
#include "dispids.h"
#include "istatus.h"
#include "utils.h"
#include "testlog.h"

#endif /* __COMMON_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\tools\spork\sporklets\testlog\testlog.inc ===
!IF 0

Copyright (c) 1994  Microsoft Corporation

!ENDIF

!IFNDEF SDKINC
SDKINC=$(SDK_INC_PATH)
!ENDIF

!IFDEF LIBDIR
!ERROR LIBDIR already defined - choose new name
!ENDIF

ROOT=$(SDXROOT)\inetcore\winhttp\tools\spork\sporklets\testlog
LIBDIR=$(ROOT)\dll\$(_OBJ_DIR)
PROJINC=$(ROOT)\inc

#
# if TARGETPATH is not defined (in the paths that build libraries) then this
# is the default target path
#
!IFNDEF TARGETPATH
TARGETPATH=$(LIBDIR)
TARGETTYPE=LIBRARY
!ENDIF

#
# what it is that we're building
#
MAJORCOMP=testlog

USE_NOLIBS=1
NO_NTDLL=1
BINPLACE_PLACEFILE=..\binplace.txt

#
# Linker flags
#
WIN32_WINNT_VERSION=0x0500
#WIN32_WIN95_VERSION=0x0400

#
# compiler warning flags
#
MSC_WARNING_LEVEL=/W3 /WX

#
# enable exception handling
#
#USE_NATIVE_EH=1

#
# compiler definitions
#
C_DEFINES=$(C_DEFINES) -DWIN32

#
# Set debugging level
#
!IF "$(NTDEBUG)" != "" && "$(NTDEBUG)" != "retail" && "$(NTDEBUG)" != "ntsdnodbg"
C_DEFINES=$(C_DEFINES) -D_DEBUG
!ENDIF

!IFNDEF BUILD_PCH
PRECOMPILED_OPTION=/Fp$(ROOT)\inc\$(_OBJ_DIR)\*\common.pch /Yucommon.h
PRECOMPILED_CXX=1
!ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\tools\spork\sporklets\testlog\inc\dispids.h ===
#ifndef __DISPIDS_H__
#define __DISPIDS_H__

#define TESTLOG_DISPID_BASE            100

#define DISPID_TESTLOG_OPEN            (TESTLOG_DISPID_BASE + 1)
#define DISPID_TESTLOG_CLOSE           (TESTLOG_DISPID_BASE + 2)
#define DISPID_TESTLOG_ENTERFUNCTION   (TESTLOG_DISPID_BASE + 3)
#define DISPID_TESTLOG_LEAVEFUNCTION   (TESTLOG_DISPID_BASE + 4)
#define DISPID_TESTLOG_TRACE           (TESTLOG_DISPID_BASE + 5)
#define DISPID_TESTLOG_BEGINTEST       (TESTLOG_DISPID_BASE + 6)
#define DISPID_TESTLOG_ENDTEST         (TESTLOG_DISPID_BASE + 7)
#define DISPID_TESTLOG_FINALRESULT     (TESTLOG_DISPID_BASE + 8)

#endif /* __DISPIDS_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\tools\spork\sporklets\testlog\dll\dllentry.cxx ===
#define UNICODE
#define _UNICODE

#include "common.h"

HINSTANCE  g_hGlobalDllInstance = NULL;
LPCSTR     g_szAdvPackDll       = "advpack.dll";
LPCSTR     g_szInstallSection   = "install";
LPCSTR     g_szUninstallSection = "uninstall";

HRESULT    RegisterServer(BOOL fMode);
HRESULT    RegisterTypeLibrary(BOOL fMode);

//-----------------------------------------------------------------------------
// DLL Entry Point
//-----------------------------------------------------------------------------
BOOL
WINAPI
DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID pvReserved)
{
  BOOL bRet = TRUE;

  switch( dwReason )
  {
    case DLL_PROCESS_ATTACH :
      {
        g_hGlobalDllInstance = hInstance;
      }
      break;

    case DLL_PROCESS_DETACH:
    case DLL_THREAD_DETACH:
    case DLL_THREAD_ATTACH:
      break;
  }
  
  return bRet;
}


//-----------------------------------------------------------------------------
// COM Entry Points
//-----------------------------------------------------------------------------
STDAPI
DllRegisterServer(void)
{
  return RegisterServer(TRUE);
}


STDAPI
DllUnregisterServer(void)
{
  return RegisterServer(FALSE);
}


STDAPI
DllGetClassObject(REFIID clsid, REFIID riid, void** ppv)
{
  return CLSFACTORY::Create(clsid, riid, ppv);
}


//-----------------------------------------------------------------------------
// SelfRegistration helper routines
//-----------------------------------------------------------------------------
HRESULT
RegisterServer(BOOL fMode)
{
  HRESULT    hr      = S_OK;
  HINSTANCE  advpack = NULL;
  REGINSTALL pfnri   = NULL;

  advpack = LoadLibraryA(g_szAdvPackDll);

    if( !advpack )
    {
      hr = E_FAIL;
      goto quit;
    }

  pfnri = (REGINSTALL) GetProcAddress(advpack, achREGINSTALL);

    if( !pfnri )
    {
      hr = E_FAIL;
      goto quit;
    }

  hr = pfnri(
        g_hGlobalDllInstance,
        fMode ? g_szInstallSection : g_szUninstallSection,
        NULL
        );

  FreeLibrary(advpack);

  hr = RegisterTypeLibrary(fMode);

quit:

  return hr;
}


HRESULT
RegisterTypeLibrary(BOOL fMode)
{
  ITypeLib* ptl  = NULL;
  TLIBATTR* pta  = NULL;
  CHAR*     pbuf = NULL;
  WCHAR*    wbuf = NULL;
  HRESULT   hr   = S_OK;

  if( (pbuf = new CHAR[MAX_PATH]) )
  {
    GetModuleFileNameA(g_hGlobalDllInstance, pbuf, MAX_PATH);
  }
  else
  {
    hr = E_OUTOFMEMORY;
    goto quit;
  }

  if( !(wbuf = __ansitowide(pbuf)) )
  {
    hr = E_OUTOFMEMORY;
    goto quit;
  }

  hr = LoadTypeLib(wbuf, &ptl);

  if( SUCCEEDED(hr) )
  {
    if( fMode )
    {
      hr = RegisterTypeLib(ptl, wbuf, NULL);
    }
    else
    {
      hr = ptl->GetLibAttr(&pta);

        if( SUCCEEDED(hr) )
        {
          hr = UnRegisterTypeLib(
                pta->guid,
                pta->wMajorVerNum,
                pta->wMinorVerNum,
                pta->lcid,
                pta->syskind
                );

          ptl->ReleaseTLibAttr(pta);
        }
        else
        {
          goto quit;
        }
    }
    
    ptl->Release();
  }

quit:

  SAFEDELETEBUF(pbuf);
  SAFEDELETEBUF(wbuf);

  return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\tools\spork\sporklets\testlog\inc\pch.cxx ===
/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Copyright (c) 1999  Microsoft Corporation

Module Name:

    pch.cxx

Abstract:

    Need this so the precompiled header will, umm, compile.
    
Author:

    Paul M Midgen (pmidge) 24-July-2000


Revision History:

    24-July-2000 pmidge
        Created

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/

#include "common.h"

void foobar(void);

void foobar(void)
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\tools\spork\sporklets\testlog\inc\istatus.h ===
//==============================================================================
// Microsoft Corporation
// Copyright (C) Microsoft Corporation, 1999-2000
//
//
//  File:       IStatus.h
//
//  Synopsis:   Definition of IStatus, IID_IStatus, CLSID_IStatus
//
//  Classes:    IStatus
//
//  History:    benchr      10/19/99    Created
//
//==============================================================================

#ifndef ISTATUS_DEFINED
#define ISTATUS_DEFINED

interface IStatus : IDispatch
{
    STDMETHOD(OutputStatus)(/*[in]*/ BSTR bstrSrc, /*[in]*/ BSTR bstrText, /*[in]*/ long lLevel);
    STDMETHOD(get_Global)(/*[in]*/ BSTR bstrName, /*[out,retval]*/ VARIANT *var);
    STDMETHOD(put_Global)(/*[in]*/ BSTR bstrName, /*[in]*/ VARIANT var);
    STDMETHOD(get_Property)(/*[in]*/ BSTR bstrName, /*[out,retval]*/ VARIANT *var); 
    STDMETHOD(put_Property)(/*[in]*/ BSTR bstrName, /*[in]*/ VARIANT var);
    STDMETHOD(RegisterDialog)(/*[in]*/ BSTR bstrTest, /*[in]*/ BSTR bstrResponse);
    STDMETHOD(MonitorPID)(/*[in]*/ long lPID);
    STDMETHOD(MonitorPIDwithoutTerminate)(/*[in]*/ long lPID);
    STDMETHOD(LogOtherTest)(/*[in]*/ long lID, /*[in]*/ long lResult, /*[in]*/ BSTR bstrComment, /*[in, optional]*/ VARIANT vAssociateBugID);
    STDMETHOD(get_Result)(/*[out,retval]*/ VARIANT *var); 
    STDMETHOD(put_Result)(/*[in]*/ VARIANT var);
};

const IID IID_IStatus = {0xC6396797,0x10B4,0x4078,{0x83,0xDF,0xBB,0x3F,0x4B,0x3A,0x44,0x1D}};
const CLSID CLSID_Status = {0xB91D58D9,0x68EC,0x4015,{0xB6,0x7F,0xF1,0x9D,0x73,0x44,0x83,0xE2}};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\tools\spork\sporklets\testlog\src\classfactory.cxx ===
#include "common.h"

//-----------------------------------------------------------------------------
// ClassFactory methods
//-----------------------------------------------------------------------------
ClassFactory::ClassFactory():
  m_cRefs(0),
  m_cLocks(0)
{
}


ClassFactory::~ClassFactory()
{
}


HRESULT
ClassFactory::Create(REFIID clsid, REFIID riid, void** ppv)
{
  HRESULT     hr  = S_OK;
  PCLSFACTORY pcf = NULL;

  if( !ppv )
  {
    hr = E_POINTER;
    goto quit;
  }

  if( !IsEqualIID(clsid, CLSID_TestLog) )
  {
    hr   = CLASS_E_CLASSNOTAVAILABLE;
    *ppv = NULL;
    goto quit;
  }

  if( pcf = new CLSFACTORY )
  {
    hr = pcf->QueryInterface(riid, ppv);

    if( FAILED(hr) )
    {
      delete pcf;
    }
  }
  else
  {
    hr = E_OUTOFMEMORY;
  }

quit:

  return hr;
}


//-----------------------------------------------------------------------------
// IUnknown methods
//-----------------------------------------------------------------------------
HRESULT
__stdcall
ClassFactory::QueryInterface(REFIID riid, void** ppv)
{
  HRESULT hr = S_OK;

    if( ppv )
    {
      if( IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_IClassFactory) )
      {
        *ppv = static_cast<IClassFactory*>(this);
      }
      else
      {
        *ppv = NULL;
        hr   = E_NOINTERFACE;
      }
    }
    else
    {
      hr = E_POINTER;
    }

    if( SUCCEEDED(hr) )
    {
      reinterpret_cast<IUnknown*>(*ppv)->AddRef();
    }

  return hr;
}


ULONG
__stdcall
ClassFactory::AddRef(void)
{
  InterlockedIncrement(&m_cRefs);
  return m_cRefs;
}


ULONG
__stdcall
ClassFactory::Release(void)
{
  InterlockedDecrement(&m_cRefs);

  if( (m_cRefs == 0) && (m_cLocks == 0) )
  {
    delete this;
    return 0;
  }

  return m_cRefs;
}


//-----------------------------------------------------------------------------
// IClassFactory methods
//-----------------------------------------------------------------------------
HRESULT
__stdcall
ClassFactory::CreateInstance(IUnknown* outer, REFIID riid, void** ppv)
{
  HRESULT hr = S_OK;

  if( !ppv )
  {
    hr = E_POINTER;
    goto quit;
  }

  if( outer )
  {
    hr   = CLASS_E_NOAGGREGATION;
    *ppv = NULL;
    goto quit;
  }

  hr = TESTLOG::Create(riid, ppv);

quit:

  return hr;
}


HRESULT
__stdcall
ClassFactory::LockServer(BOOL lock)
{
  HRESULT hr = S_OK;

  lock ? InterlockedIncrement(&m_cLocks) : InterlockedDecrement(&m_cLocks);

  if( (m_cRefs == 0) && (m_cLocks == 0) )
  {
    delete this;
    return hr;
  }

  return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\tools\spork\sporklets\testlog\inc\testlog.h ===
/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Copyright (c) 2001  Microsoft Corporation

Module Name:

    testlog.h

Abstract:

    Declaration of the TestLog class. Implementation is
    in ..\src\testlog.
    
Author:

    Paul M Midgen (pmidge) 21-February-2001


Revision History:

    21-February-2001 pmidge
        Created

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/


#include <common.h>


#ifndef __TESTLOG_H__
#define __TESTLOG_H__


#define TESTLOG_MODE_FLAG_USEDEFAULTS  0x00000000

#define TESTLOG_MODE_FLAG_NOLOCALFILE  0x00000001
#define TESTLOG_MODE_FLAG_NOPIPERLOG   0x00000002
#define TESTLOG_MODE_FLAG_OUTPUTTODBG  0x00000004
#define TESTLOG_MODE_FLAG_NOAUTOMATION 0x00000008

#define TESTLOG_MODE_FLAG_ALL          ( TESTLOG_MODE_FLAG_NOLOCALFILE  \
                                       | TESTLOG_MODE_FLAG_NOPIPERLOG   \
                                       | TESTLOG_MODE_FLAG_OUTPUTTODBG  \
                                       | TESTLOG_MODE_FLAG_NOAUTOMATION )


// ERRORLEVEL and PASSFAIL from cpiper.h -- see ananthk
enum ERRORLEVEL
{
    LEVEL_FATAL     = 0,  // Critical Failure info: updates Logs(DB), updates display window, updates log file
    LEVEL_FAILURE   = 1,  // Failure info: updates Logs(DB), updates display window, updates log file
    LEVEL_LOGINFO   = 2,  // Any info: updates Logs(DB), updates display window, updates log file
    LEVEL_STATUS    = 3,  // Any info: updates display window, updates Log File
    LEVEL_DEBUGGING = 4   // Any info: updates Log File
};

enum PASSFAIL
{
    FAIL = 0,
    PASS = 1
};


typedef enum _rettype
{
  rt_void,
  rt_bool,
  rt_dword,
  rt_error,
  rt_hresult,
  rt_string
}
RETTYPE, *LPRETTYPE;

enum DEPTH
{
  INCREMENT,
  DECREMENT,
  MAINTAIN
};

typedef struct _callinfo
{
  struct _callinfo* next;
  struct _callinfo* last;
  LPCWSTR           fname;
  RETTYPE           rettype;
}
CALLINFO, *LPCALLINFO;


typedef class ClassFactory  CLSFACTORY;
typedef class ClassFactory* PCLSFACTORY;
typedef class TestLog       TESTLOG;
typedef class TestLog*      PTESTLOG;


class ClassFactory : public IClassFactory
{
  public:
    DECLAREIUNKNOWN();
    DECLAREICLASSFACTORY();

    ClassFactory();
   ~ClassFactory();

    static HRESULT Create(REFIID clsid, REFIID riid, void** ppv);

  private:
    LONG m_cRefs;
    LONG m_cLocks;
};


class TestLog : public ITestLog,
                public IProvideClassInfo
{
  public:
    DECLAREIUNKNOWN();
    DECLAREIDISPATCH();

    // ITestLog
    HRESULT __stdcall Open(
                        BSTR     filename,
                        BSTR     title,
                        VARIANT* mode,
                        VARIANT* success
                        );
        
    HRESULT __stdcall Close(void);

    HRESULT __stdcall BeginTest(
                        BSTR    testname,
                        VARIANT testid
                        );

    HRESULT __stdcall EndTest(void);

    HRESULT __stdcall FinalResult(
                        VARIANT status,
                        VARIANT reason
                        );

    HRESULT __stdcall EnterFunction(
                        BSTR    name,
                        VARIANT params,
                        VARIANT returntype
                        );

    HRESULT __stdcall LeaveFunction(
                        VARIANT returnvalue
                        );

    HRESULT __stdcall Trace(
                        BSTR message
                        );

    DECLAREIPROVIDECLASSINFO();

  public:
    TestLog();
   ~TestLog();

    static HRESULT Create(REFIID riid, void** ppv);

  private:
    HRESULT    _Initialize(LPCWSTR wszFilename, LPCWSTR wszTitle, int iMode);
    HRESULT    _InitPiperSupport(void);

    void       _Terminate(void);
    void       _EnterFunction(LPCWSTR function, RETTYPE rt, LPCWSTR format, ...);
    void       _LeaveFunction(VARIANT retval);
    void       _Trace(LPCWSTR format, ...);
    void       _BeginTest(LPCWSTR casename, DWORD caseid);
    void       _EndTest(void);
    void       _SetMode(int iMode, BOOL bReset);


    void       _WriteLog(BOOL fRaw, BOOL fTrace, DEPTH depth, LPCWSTR format, ...);
    void       _DeleteCallInfo(LPCALLINFO pci);
    LPCALLINFO _PushCallInfo(LPCWSTR function, RETTYPE rt);
    LPCALLINFO _PopCallInfo(void);
    LPWSTR     _FormatCallReturnString(LPCALLINFO pci, VARIANT retval);
    LPWSTR     _GetTimeStamp(void);
    LPWSTR     _GetWhiteSpace(int spaces);
    LPWSTR     _MapErrorToString(int error);
    LPWSTR     _MapHResultToString(HRESULT hr);  

  private:
    LONG       m_cRefs;
    LONG       m_cScriptRefs;
    BOOL       m_bOpened;
    BOOL       m_bResult;
    BSTR       m_bstrReason;
    DWORD      m_dwStackDepth;
    ITypeInfo* m_pTypeInfo;
    IStatus*   m_pStatus;
    HANDLE     m_hLogFile;
    LPCALLINFO m_pStack;
    CRITSEC    m_csLogFile;
    int        m_iMode;
};

#endif /* __TESTLOG_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\tools\spork\sporklets\testlog\src\itestlog.cxx ===
/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Copyright (c) 2001  Microsoft Corporation

Module Name:

    itestlog.cxx

Abstract:

    Implements the ITestLog, IUnknown, IDispatch and IProvideClassInfo
    interfaces for the TestLog object.
    
Author:

    Paul M Midgen (pmidge) 20-March-2001


Revision History:

    20-March-2001 pmidge
        Created

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/


#include "common.h"


//
// WARNING: do not modify these values. use disphash.exe to generate
//          new values.
//
DISPIDTABLEENTRY g_TestLogDisptable[] =
{
  0x00008504,   DISPID_TESTLOG_OPEN,          L"open",
  0x00010203,   DISPID_TESTLOG_CLOSE,         L"close",
  0x01086d76,   DISPID_TESTLOG_ENTERFUNCTION, L"enterfunction",
  0x010740c9,   DISPID_TESTLOG_LEAVEFUNCTION, L"leavefunction",
  0x00011446,   DISPID_TESTLOG_TRACE,         L"trace",
  0x000fc278,   DISPID_TESTLOG_BEGINTEST,     L"begintest",
  0x000417bc,   DISPID_TESTLOG_ENDTEST,       L"endtest",
  0x00410312,   DISPID_TESTLOG_FINALRESULT,   L"finalresult"
};

DWORD g_cTestLogDisptable = (sizeof(g_TestLogDisptable) / sizeof(DISPIDTABLEENTRY));


//-----------------------------------------------------------------------------
// ITestLog methods
//-----------------------------------------------------------------------------
HRESULT
__stdcall
TestLog::Open(
  BSTR     filename,
  BSTR     title,
  VARIANT* mode,
  VARIANT* success
  )
{
  HRESULT hr = S_OK;

  //
  // a script can be opened only once. we track the number of attempts to call
  // open so we know how many consumers are using us.
  //

  ++m_cScriptRefs;
  
  if( !m_bOpened )
  {
    hr = _Initialize(filename, title, V_I4(mode));

    if( SUCCEEDED(hr) )
    {
      m_bOpened = TRUE;
    }
  }

  if( success )
  {
    V_VT(success)   = VT_BOOL;
    V_BOOL(success) = SUCCEEDED(hr) ? VARIANT_TRUE : VARIANT_FALSE;
  }

  return hr;
}


HRESULT
__stdcall
TestLog::Close(void)
{
  if( !m_bOpened )
    return E_UNEXPECTED;

  //
  // the only time we really will close the log and terminate the object
  // is when the script refcount drops to 0.
  //
  if( --m_cScriptRefs == 0)
  {
    _Terminate();
  }

  return S_OK;
}


HRESULT
__stdcall
TestLog::BeginTest(
  BSTR    testname,
  VARIANT testid
  )
{
  if( !m_bOpened )
    return E_UNEXPECTED;

  _BeginTest(
    testname,
    V_I4(&testid)
    );

  return S_OK;
}


HRESULT
__stdcall
TestLog::EndTest(void)
{
  if( !m_bOpened )
    return E_UNEXPECTED;

  _EndTest();
  return S_OK;
}


HRESULT
__stdcall
TestLog::FinalResult(
  VARIANT status,
  VARIANT reason
  )
{
  if( !m_bOpened )
    return E_UNEXPECTED;

  HRESULT    hr       = S_OK;
  BSTR       property = NULL;
  BSTR       _reason  = (__isempty(&reason) ? L"no reason given" : V_BSTR(&reason));
  LPCALLINFO pci      = _PopCallInfo();
  NEWVARIANT(var);

  //
  // we may get several FinalResult()'s over the course of running a linked model.
  // if ever a subcase reports false, the whole test fails. TestLog inits this
  // overall result to TRUE, so we set up the trap below to trigger one time
  // only.
  //
  if( m_bResult && (V_BOOL(&status) == VARIANT_FALSE) )
  {
    m_bResult    = FALSE;
    m_bstrReason = SysAllocString(_reason);
  }

  _Trace(
    L"\"%s\" status is %s [%s]",
    (pci ? pci->fname : L"unknown test"),
    VPF(&status),
    _reason
    );


  // only report final result status if this is the base case
  if( m_cScriptRefs == 1 )
  {
    _Trace(
      L"\"%s\" final result is %s [%s]",
      (pci ? pci->fname : L"unknown test"),
      (m_bResult ? L"PASS" : L"FAIL"),
      (m_bstrReason ? m_bstrReason : _reason)
      );

    if( !(m_iMode & TESTLOG_MODE_FLAG_NOPIPERLOG) )
    {
      // write pass/fail information to piper
      V_VT(&var) = VT_I4;
      V_I4(&var) = m_bResult ? PASS : FAIL;
      property   = __widetobstr(L"RESULT");
      hr         = m_pStatus->put_Property(property, var);

      SAFEDELETEBSTR(property);

      // write the reason for failure
      V_VT(&var)   = VT_BSTR;
      V_BSTR(&var) = SysAllocString((m_bstrReason ? m_bstrReason : _reason));
      property     = __widetobstr(L"RESULT_REASON");
      hr           = m_pStatus->put_Property(property, var);

      VariantClear(&var);
      SAFEDELETEBSTR(property);
    }
  }

  return hr;
}


HRESULT
__stdcall
TestLog::EnterFunction(
  BSTR    name,
  VARIANT params,
  VARIANT returntype
  )
{
  if( !m_bOpened )
    return E_UNEXPECTED;

  _EnterFunction(
    name,
    (RETTYPE) V_I4(&returntype),
    V_BSTR(&params)
    );

  return S_OK;
}


HRESULT
__stdcall
TestLog::LeaveFunction(
  VARIANT returnvalue
  )
{
  if( !m_bOpened )
    return E_UNEXPECTED;

  _LeaveFunction(
    returnvalue
    );

  return S_OK;
}


HRESULT
__stdcall
TestLog::Trace(
  BSTR message
  )
{
  if( !m_bOpened )
    return E_UNEXPECTED;

  _Trace(
    L"%s",
    message
    );

  return S_OK;
}


//-----------------------------------------------------------------------------
// IUnknown methods
//-----------------------------------------------------------------------------
HRESULT
__stdcall
TestLog::QueryInterface(
  REFIID riid,
  void** ppv
  )
{
  HRESULT hr = S_OK;

    if( ppv )
    {
      if(
        IsEqualIID(riid, IID_IUnknown)       ||
        IsEqualIID(riid, IID_IDispatch)      ||
        IsEqualIID(riid, IID_ITestLog)
        )
      {
        *ppv = static_cast<ITestLog*>(this);
      }
      else if( IsEqualIID(riid, IID_IProvideClassInfo) )
      {
        *ppv = static_cast<IProvideClassInfo*>(this);
      }
      else
      {
        *ppv = NULL;
        hr   = E_NOINTERFACE;
      }
    }
    else
    {
      hr = E_POINTER;
    }

    if( SUCCEEDED(hr) )
    {
      reinterpret_cast<IUnknown*>(*ppv)->AddRef();
    }

  return hr;
}


ULONG
__stdcall
TestLog::AddRef(void)
{
  InterlockedIncrement(&m_cRefs);
  return m_cRefs;
}


ULONG
__stdcall
TestLog::Release(void)
{
  InterlockedDecrement(&m_cRefs);

  if( m_cRefs == 0 )
  {
    delete this;
    return 0;
  }

  return m_cRefs;
}


//-----------------------------------------------------------------------------
// IProvideClassInfo methods
//-----------------------------------------------------------------------------
HRESULT
__stdcall
TestLog::GetClassInfo(
  ITypeInfo** ppti
  )
{
  HRESULT hr = S_OK;

    if( ppti )
    {
      m_pTypeInfo->AddRef();
      *ppti = m_pTypeInfo;
    }
    else
    {
      hr = E_POINTER;
    }

  return hr;
}


//-----------------------------------------------------------------------------
// IDispatch methods
//-----------------------------------------------------------------------------
HRESULT
__stdcall
TestLog::GetTypeInfoCount(
  UINT* pctinfo
  )
{
  HRESULT hr = S_OK;

    if( !pctinfo )
    {
      hr = E_POINTER;
    }
    else
    {
      *pctinfo = 1;
    }

  return hr;
}


HRESULT
__stdcall
TestLog::GetTypeInfo(
  UINT        index,
  LCID        lcid,
  ITypeInfo** ppti
  )
{
  HRESULT hr   = S_OK;

  if( !ppti )
  {
    hr = E_POINTER;
  }
  else
  {
    if( index != 0 )
    {
      hr    = DISP_E_BADINDEX;
      *ppti = NULL;
    }
    else
    {
      hr = GetClassInfo(ppti);
    }
  }

  return hr;
}


HRESULT
__stdcall
TestLog::GetIDsOfNames(
  REFIID    riid,
  LPOLESTR* arNames,
  UINT      cNames,
  LCID      lcid,
  DISPID*   arDispId
  )
{
  HRESULT hr = S_OK;
  UINT    n  = 0L;

  if( !IsEqualIID(riid, IID_NULL) )
  {
    hr = E_INVALIDARG;
    goto quit;
  }

  while( n < cNames )
  {
    arDispId[n] = GetDispidFromName(g_TestLogDisptable, g_cTestLogDisptable, arNames[n]);
    ++n;
  }

quit:

  return hr;
}


HRESULT
__stdcall
TestLog::Invoke(
  DISPID      dispid,
  REFIID      riid,
  LCID        lcid,
  WORD        flags,
  DISPPARAMS* pdp,
  VARIANT*    pvr, 
  EXCEPINFO*  pei,
  UINT*       pae
  )
{
  HRESULT hr = S_OK;

  hr = ValidateDispatchArgs(riid, pdp, pvr, pae);

    if( FAILED(hr) )
      goto quit;

  switch( dispid )
  {
    case DISPID_VALUE :
      {
        V_VT(pvr) = VT_DISPATCH;
        hr        = QueryInterface(IID_IDispatch, (void**) &V_DISPATCH(pvr));
      }
      break;

    case DISPID_TESTLOG_OPEN :
      {
        hr = ValidateInvokeFlags(flags, DISPATCH_METHOD, TRUE);

        if( SUCCEEDED(hr) )
        {
          hr = ValidateArgCount(pdp, 2, TRUE, 1);

          if( SUCCEEDED(hr) )
          {
            NEWVARIANT(logname);
            NEWVARIANT(logtitle);
            NEWVARIANT(logmode);

            hr = DispGetParam(pdp, 0, VT_BSTR, &logname,  pae);

            if( SUCCEEDED(hr) )
            {
              hr = DispGetParam(pdp, 1, VT_BSTR, &logtitle, pae);
            }

            if( SUCCEEDED(hr) )
            {
              hr = DispGetOptionalParam(pdp, 2, VT_I4, &logmode, pae);
            }
                        
              hr = Open(
                     V_BSTR(&logname),
                     V_BSTR(&logtitle),
                     &logmode,
                     pvr
                     );

            VariantClear(&logname);
            VariantClear(&logtitle);
            VariantClear(&logmode);
          }
        }
      }
      break;

    case DISPID_TESTLOG_CLOSE :
      {
        hr = ValidateInvokeFlags(flags, DISPATCH_METHOD, TRUE);

        if( SUCCEEDED(hr) )
        {
          hr = ValidateArgCount(pdp, 0, FALSE, 0);

          if( SUCCEEDED(hr) )
          {
            hr = Close();
          }
        }
      }
      break;

    case DISPID_TESTLOG_BEGINTEST :
      {
        hr = ValidateInvokeFlags(flags, DISPATCH_METHOD, TRUE);

        if( SUCCEEDED(hr) )
        {
          hr = ValidateArgCount(pdp, 2, FALSE, 0);

          if( SUCCEEDED(hr) )
          {
            NEWVARIANT(testname);
            NEWVARIANT(testid);

            hr = DispGetParam(pdp, 0, VT_BSTR, &testname, pae);

            if( SUCCEEDED(hr) )
            {
              hr = DispGetParam(pdp, 1, VT_I4, &testid, pae);
            }

            if( SUCCEEDED(hr) )
            {
              hr = BeginTest(
                     V_BSTR(&testname),
                     testid
                     );
            }

            VariantClear(&testname);
            VariantClear(&testid);
          }
        }
      }
      break;

    case DISPID_TESTLOG_ENDTEST :
      {
        hr = ValidateInvokeFlags(flags, DISPATCH_METHOD, TRUE);

        if( SUCCEEDED(hr) )
        {
          hr = ValidateArgCount(pdp, 0, FALSE, 0);

          if( SUCCEEDED(hr) )
          {
            hr = EndTest();
          }
        }
      }
      break;

    case DISPID_TESTLOG_FINALRESULT :
      {
        hr = ValidateInvokeFlags(flags, DISPATCH_METHOD, TRUE);

        if( SUCCEEDED(hr) )
        {
          hr = ValidateArgCount(pdp, 1, TRUE, 1);

          if( SUCCEEDED(hr) )
          {
            NEWVARIANT(reason);
            NEWVARIANT(status);

            DispGetParam(pdp, 0, VT_BOOL, &status, pae);
            DispGetParam(pdp, 1, VT_BSTR, &reason, pae);
            
              hr = FinalResult(
                     status,
                     reason
                     );

            VariantClear(&reason);
            VariantClear(&status);
          }
        }
      }
      break;

    case DISPID_TESTLOG_ENTERFUNCTION :
      {
        hr = ValidateInvokeFlags(flags, DISPATCH_METHOD, TRUE);

        if( SUCCEEDED(hr) )
        {
          hr = ValidateArgCount(pdp, 1, TRUE, 2);

          if( SUCCEEDED(hr) )
          {
            NEWVARIANT(name);
            NEWVARIANT(params);
            NEWVARIANT(rettype);

            hr = DispGetParam(pdp, 0, VT_BSTR, &name, pae);

            if( SUCCEEDED(hr) )
            {
              hr = DispGetOptionalParam(pdp, 1, VT_BSTR, &params, pae);
            }

            if( SUCCEEDED(hr) )
            {
              hr = DispGetOptionalParam(pdp, 2, VT_I4, &rettype, pae);
            }

            if( SUCCEEDED(hr) )
            {
              hr = EnterFunction(
                     V_BSTR(&name),
                     params,
                     rettype
                     );
            }

            VariantClear(&name);
            VariantClear(&params);
            VariantClear(&rettype);
          }
        }
      }
      break;

    case DISPID_TESTLOG_LEAVEFUNCTION :
      {
        hr = ValidateInvokeFlags(flags, DISPATCH_METHOD, TRUE);

        if( SUCCEEDED(hr) )
        {
          hr = ValidateArgCount(pdp, 0, TRUE, 1);

          if( SUCCEEDED(hr) )
          {
            NEWVARIANT(retval);

            if( pdp->cArgs )
            {
              VariantCopy(&retval, &pdp->rgvarg[0]);
            }

            hr = LeaveFunction(
                   retval
                   );

            VariantClear(&retval);
          }
        }
      }
      break;

    case DISPID_TESTLOG_TRACE :
      {
        hr = ValidateInvokeFlags(flags, DISPATCH_METHOD, TRUE);

        if( SUCCEEDED(hr) )
        {
          hr = ValidateArgCount(pdp, 1, FALSE, 0);

          if( SUCCEEDED(hr) )
          {
            NEWVARIANT(message);

            hr = DispGetParam(pdp, 0, VT_BSTR, &message, pae);

            if( SUCCEEDED(hr) )
            {
              hr = Trace(
                     V_BSTR(&pdp->rgvarg[0])
                     );
            }

            VariantClear(&message);
          }
        }
      }
      break;

    default : hr = DISP_E_MEMBERNOTFOUND;
  }

quit:

  if( FAILED(hr) )
  {
    hr = HandleDispatchError(L"TestLog", pei, hr);
  }

  return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\tools\spork\sporklets\testlog\inc\utils.h ===
/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Copyright (c) 2001  Microsoft Corporation

Module Name:

    utils.h

Abstract:

    Utility functions used by the probject.
    
Author:

    Paul M Midgen (pmidge) 22-February-2001


Revision History:

    22-February-2001 pmidge
        Created

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/

#ifndef __UTILS_H__
#define __UTILS_H__

void* __cdecl operator new(size_t size);
void  __cdecl operator delete(void* pv);

typedef BY_HANDLE_FILE_INFORMATION   BHFI;
typedef LPBY_HANDLE_FILE_INFORMATION LPBHFI;
typedef WIN32_FILE_ATTRIBUTE_DATA    W32FAD;
typedef WIN32_FILE_ATTRIBUTE_DATA*   PW32FAD;
typedef CRITICAL_SECTION             CRITSEC;
typedef LPCRITICAL_SECTION           PCRITSEC;

typedef struct _dispidtableentry
{
  DWORD  hash;
  DISPID dispid;
  LPWSTR name;
}
DISPIDTABLEENTRY, *PDISPIDTABLEENTRY;

// general utility
HRESULT GetTypeInfoFromName(LPCOLESTR name, ITypeLib* ptl, ITypeInfo** ppti);
DISPID  GetDispidFromName(PDISPIDTABLEENTRY pdt, DWORD cEntries, LPWSTR name);
HRESULT HandleDispatchError(LPWSTR id, EXCEPINFO* pei, HRESULT hr);
void    AddRichErrorInfo(EXCEPINFO* pei, LPWSTR source, LPWSTR description, HRESULT error);
DWORD   GetHash(LPWSTR name);
HRESULT DispGetOptionalParam(DISPPARAMS* pdp, UINT pos, VARTYPE vt, VARIANT* pvr, UINT* pae);
HRESULT ValidateDispatchArgs(REFIID riid, DISPPARAMS* pdp, VARIANT* pvr, UINT* pae);
HRESULT ValidateInvokeFlags(WORD flags, WORD accesstype, BOOL bNotMethod);
HRESULT ValidateArgCount(DISPPARAMS* pdp, DWORD needed, BOOL bHasOptionalArgs, DWORD optional);

// string handling
CHAR*  __widetoansi(const WCHAR* pwsz);
WCHAR* __ansitowide(const char* psz);
BOOL   __isempty(VARIANT* var);
BOOL   __mangle(LPWSTR src, LPWSTR* ppdest);
BSTR   __ansitobstr(LPCSTR src);
BSTR   __widetobstr(LPCWSTR wsrc);
char*  __unescape(char* str);

// miscellaneous
#define DECLAREIUNKNOWN() \
    HRESULT __stdcall QueryInterface(REFIID riid, void** ppv); \
    ULONG   __stdcall AddRef(void); \
    ULONG   __stdcall Release(void); 

#define DECLAREICLASSFACTORY() \
    HRESULT __stdcall CreateInstance(IUnknown* outer, REFIID riid, void** ppv); \
    HRESULT __stdcall LockServer(BOOL lock);

#define DECLAREIDISPATCH() \
    HRESULT __stdcall GetTypeInfoCount(UINT* pctinfo);  \
    HRESULT __stdcall GetTypeInfo(UINT index, LCID lcid, ITypeInfo** ppti); \
    HRESULT __stdcall GetIDsOfNames(REFIID riid, LPOLESTR* arNames, UINT cNames, LCID lcid, DISPID* arDispId); \
    HRESULT __stdcall Invoke(DISPID dispid, REFIID riid, LCID lcid, WORD flags, DISPPARAMS* pdp, VARIANT* pvr, EXCEPINFO* pei, UINT* pae);

#define DECLAREIACTIVESCRIPTSITE() \
    HRESULT __stdcall GetLCID(LCID* plcid); \
    HRESULT __stdcall GetItemInfo(LPCOLESTR pstrName, DWORD dwReturnMask, IUnknown** ppunk, ITypeInfo** ppti); \
    HRESULT __stdcall GetDocVersionString(BSTR* pbstrVersion); \
    HRESULT __stdcall OnScriptTerminate(const VARIANT* pvarResult, const EXCEPINFO* pei); \
    HRESULT __stdcall OnStateChange(SCRIPTSTATE ss); \
    HRESULT __stdcall OnScriptError(IActiveScriptError* piase); \
    HRESULT __stdcall OnEnterScript(void); \
    HRESULT __stdcall OnLeaveScript(void);

#define DECLAREIPROVIDECLASSINFO() \
  HRESULT __stdcall GetClassInfo(ITypeInfo** ppti);

#define DECLAREIOBJECTWITHSITE() \
    HRESULT __stdcall SetSite(IUnknown* pUnkSite); \
    HRESULT __stdcall GetSite(REFIID riid, void** ppvSite);

#define SAFECLOSE(x) if((x!=INVALID_HANDLE_VALUE) && (x!=NULL)) { CloseHandle(x); x=NULL; }
#define SAFEDELETE(x) if(x) { delete x; x=NULL; }
#define SAFEDELETEBUF(x) if(DWORD_PTR(x)) {delete [] x; x=NULL;}
#define SAFERELEASE(x) if(x) { x->Release(); x=NULL; }
#define SAFEDELETEBSTR(x) if(x) { SysFreeString(x); x=NULL; }
#define VALIDDISPID(x) ((x!=DISPID_UNKNOWN) ? TRUE : FALSE)
#define NEWVARIANT(x) VARIANT x; memset(&x, 0, sizeof(VARIANT)); VariantInit(&x);

#define TF(x) (x?L"TRUE":L"FALSE")
#define VTF(x) ((V_BOOL(x) == VARIANT_TRUE)?L"TRUE":L"FALSE")

#define VPF(x) ((V_BOOL(x) == VARIANT_TRUE)?L"PASS":L"FAIL")

#define ENABLED(x)    (x?L"enabled":L"disabled")
#define SUCCESSFUL(x) (SUCCEEDED(x) ? L"successful" : L"unsuccessful")

#define STRING(x)     (x?x:L"null")

#define CASE_OF(constant) case constant: return L#constant
#define CASE_OF_MUTATE(val, name) case val: return L#name
#define CASE_IID(riid, iid) if(IsEqualIID(riid, iid)) return L#iid

#endif /* __UTILS_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\tools\spork\sporklets\testlog\src\testlog.cxx ===
/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Copyright (c) 2001  Microsoft Corporation

Module Name:

    testlog.cxx

Abstract:

    Implements the non-interface class members of the TestLog object.
    
Author:

    Paul M Midgen (pmidge) 30-March-2001


Revision History:

    30-March-2001 pmidge
        Created

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/


#include "common.h"


//-----------------------------------------------------------------------------
// Class members
//-----------------------------------------------------------------------------
TestLog::TestLog():
  m_cRefs(0),
  m_cScriptRefs(0),
  m_bOpened(FALSE),
  m_bResult(TRUE),
  m_bstrReason(NULL),
  m_dwStackDepth(0),
  m_pTypeInfo(NULL),
  m_pStatus(NULL),
  m_hLogFile(INVALID_HANDLE_VALUE),
  m_pStack(NULL),
  m_iMode(0)
{
}


TestLog::~TestLog()
{
}


HRESULT
TestLog::Create(
  REFIID riid,
  void** ppv
  )
{
  HRESULT  hr  = S_OK;
  PTESTLOG ptl = NULL;

  if( !ppv )
  {
    hr = E_POINTER;
    goto quit;
  }

  if( (ptl = new TESTLOG) )
  {
    hr = ptl->QueryInterface(riid, ppv);

    if( FAILED(hr) )
    {
      ptl->_Terminate();
      SAFEDELETE(ptl);
    }
  }
  else
  {
    hr = E_OUTOFMEMORY;
  }

quit:

  return hr;
}


HRESULT
TestLog::_Initialize(
  LPCWSTR wszFilename,
  LPCWSTR wszTitle,
  int     iMode
  )
{
  HRESULT   hr   = S_OK;
  LPWSTR    time = _GetTimeStamp();
  LPWSTR    path = NULL;
  ITypeLib* ptl  = NULL;

  if( !wszFilename || !wszTitle )
  {
    hr = E_INVALIDARG;
    goto quit;
  }

  __try
  {
    InitializeCriticalSection(&m_csLogFile);
  }
  __except(EXCEPTION_EXECUTE_HANDLER)
  {
    hr = E_OUTOFMEMORY;
    goto quit;
  }

  _SetMode(iMode, TRUE);

  //
  // if TESTLOG_MODE_FLAG_NOAUTOMATION is not set, we will load typeinfo
  // for the TestLog component in case script engines or other automation
  // controllers ask for it. failure is considered critical since certain
  // automation controllers may outright fail if typeinfo isn't available.
  //
  if( !(m_iMode & TESTLOG_MODE_FLAG_NOAUTOMATION) )
  {
    if( (path = new WCHAR[MAX_PATH]) )
    {
      GetModuleFileName(GetModuleHandle(L"testlog.dll"), path, MAX_PATH);
      
      hr = LoadTypeLib(path, &ptl);

        if( FAILED(hr) )
          goto quit;

      hr = GetTypeInfoFromName(L"TestLog", ptl, &m_pTypeInfo);

        if( FAILED(hr) )
          goto quit;
    }
    else
    {
      hr = E_OUTOFMEMORY;
      goto quit;
    }
  }

  //
  // if TESTLOG_MODE_FLAG_NOLOCALFILE is not set, we create a local file
  // using the name provided in the wszFilename parameter. failure is
  // not considered fatal. in the failure case we enable logging to a
  // debug console.
  //
  if( !(m_iMode & TESTLOG_MODE_FLAG_NOLOCALFILE) )
  {
    m_hLogFile = CreateFile(
                   wszFilename,
                   GENERIC_WRITE,
                   FILE_SHARE_READ,
                   NULL,
                   CREATE_ALWAYS,
                   FILE_ATTRIBUTE_NORMAL,
                   NULL
                   );
    
      if( !m_hLogFile )
      {
        _SetMode(TESTLOG_MODE_FLAG_NOLOCALFILE | TESTLOG_MODE_FLAG_OUTPUTTODBG, FALSE);
      }
  }

  //
  // if TESTLOG_MODE_FLAG_NOPIPERLOG is not set, we attempt to obtain Piper's
  // IStatus interface. failure is considered critical, since test cases may
  // fail to get logged if the root problem isn't sorted out.
  //
  if( !(m_iMode & TESTLOG_MODE_FLAG_NOPIPERLOG) )
  {
    hr = _InitPiperSupport();

    if( FAILED(hr) )
    {
      _SetMode(TESTLOG_MODE_FLAG_NOPIPERLOG | TESTLOG_MODE_FLAG_OUTPUTTODBG, FALSE);
    }
  }

quit:

  _WriteLog(TRUE, FALSE, MAINTAIN, L"%s\r\n\r\nlog opened: %s\r\n", wszTitle, time);

  SAFEDELETEBUF(path);
  SAFERELEASE(ptl);
  SAFEDELETEBUF(time);

  return hr;
}


void
TestLog::_Terminate(
  void
  )
{
  LPWSTR time = _GetTimeStamp();

  _WriteLog(TRUE, FALSE, MAINTAIN, L"\r\nlog closed: %s", time);

  DeleteCriticalSection(&m_csLogFile);
  SAFERELEASE(m_pStatus);
  SAFECLOSE(m_hLogFile);
  SAFERELEASE(m_pTypeInfo);
  SAFEDELETEBUF(time);

  m_bOpened = FALSE;
  SAFEDELETEBSTR(m_bstrReason);
}


HRESULT
TestLog::_InitPiperSupport(
  void
  )
{
  HRESULT   hr     = S_OK;
  IUnknown* punk   = NULL;
  CLSID     clsid  = {0};
  BSTR      progid = NULL;

  progid = SysAllocString(L"piper.status");
  hr     = CLSIDFromProgID(progid, &clsid);

    if( FAILED(hr) )
      goto quit;

  hr = GetActiveObject(clsid, NULL, &punk);

    if( FAILED(hr) )
      goto quit;

  hr = punk->QueryInterface(IID_IStatus, (void**) &m_pStatus);

quit:

  SAFERELEASE(punk);
  SAFEDELETEBSTR(progid);

  return hr;
}


void
TestLog::_SetMode(int iMode, BOOL bReset)
{
  if( bReset )
  {
    if( iMode & ~TESTLOG_MODE_FLAG_ALL )
    {
      m_iMode = TESTLOG_MODE_FLAG_USEDEFAULTS;
    }
    else
    {
      m_iMode = iMode;
    }
  }
  else
  {
    if( !(iMode & ~TESTLOG_MODE_FLAG_ALL) )
    {
      m_iMode |= iMode;
    }
  }
}


void
TestLog::_EnterFunction(
  LPCWSTR function,
  RETTYPE rt,
  LPCWSTR format,
  ...
  )
{
  _PushCallInfo(function, rt);

  if( format )
  {
    WCHAR   buf[1024];
    va_list arg_list;

    va_start(arg_list, format);

      wvnsprintf(buf, 1024, format, arg_list);
      _WriteLog(FALSE, FALSE, INCREMENT, L"%s(%s)", function, buf);

    va_end(arg_list);
  }
  else
  {
    _WriteLog(FALSE, FALSE, INCREMENT, L"%s()", function);
  }
}


void
TestLog::_LeaveFunction(
  VARIANT retval
  )
{
  LPCALLINFO pci = _PopCallInfo();
  LPWSTR     buf = _FormatCallReturnString(pci, retval);

  _WriteLog(FALSE, FALSE, DECREMENT, buf);
  _DeleteCallInfo(pci);

  SAFEDELETEBUF(buf);
}


void
TestLog::_BeginTest(
  LPCWSTR testname,
  DWORD   testid
  )
{
  WCHAR buf[1024];

  wnsprintf(buf, 1024, L"Test #%d", testid);
  _PushCallInfo(buf, rt_void);

  // suppress output if not the base test
  if( m_cScriptRefs == 1 )
  {
    _WriteLog(FALSE, FALSE, INCREMENT, L"Begin%s [%s]", buf, testname);
  }
}


void
TestLog::_EndTest(void)
{
  LPCALLINFO pci = _PopCallInfo();
  WCHAR      buf[1024];

  // suppress output if not the base test
  if( m_cScriptRefs == 1 )
  {
    wnsprintf(buf, 1024, L"End%s", pci->fname);
    _WriteLog(FALSE, FALSE, DECREMENT, buf);
  }

  _DeleteCallInfo(pci);
}


void
TestLog::_Trace(
  LPCWSTR format,
  ...
  )
{
  WCHAR   buf[1024];
  va_list arg_list;

  va_start(arg_list, format);

    wvnsprintf(buf, 1024, format, arg_list);
    _WriteLog(FALSE, TRUE, MAINTAIN, buf);

  va_end(arg_list);
}


void
TestLog::_WriteLog(
  BOOL    fRaw,
  BOOL    fTrace,
  DEPTH   depth,
  LPCWSTR format,
  ...
  )
{
  LPSTR    ansi   = NULL;
  DWORD    offset = 0L;
  LPWSTR   buffer = new WCHAR[2048];
  LPWSTR   tmp    = NULL;
  DWORD    indent = 0L;
  va_list  arg_list;

  if( buffer )
  {
    if( !fRaw )
    {
      if( depth == INCREMENT )
      {
        ++m_dwStackDepth;
        indent = m_dwStackDepth;
      }
      else if( depth == DECREMENT )
      {
        indent = m_dwStackDepth;
        --m_dwStackDepth;
      }
      else
      {
        indent = m_dwStackDepth;
      }

      tmp     = _GetTimeStamp();
      offset  = wnsprintf(buffer, 2048, L"%s ", tmp);
      SAFEDELETEBUF(tmp);

      offset += wnsprintf(buffer+offset, 2048-offset, L"%0.8x:%0.3d ", GetCurrentThreadId(), indent);
      tmp     = _GetWhiteSpace((fTrace ? indent+1 : indent));
      offset += wnsprintf(buffer+offset, 2048-offset, L"%s", tmp);
      SAFEDELETEBUF(tmp);
    }

    if( format )
    {
      va_start(arg_list, format);
    
        offset += wvnsprintf(buffer+offset, 2048-offset, format, arg_list);
        wnsprintf(buffer+offset, 2048-offset, L"\r\n");
    
      va_end(arg_list);
    }

    if( !(m_iMode & TESTLOG_MODE_FLAG_NOLOCALFILE) )
    {
      ansi   = __widetoansi(buffer);
      offset = 0;

        EnterCriticalSection(&m_csLogFile);

          WriteFile(
            m_hLogFile,
            ansi,
            strlen(ansi),
            &offset,
            NULL
            );

        LeaveCriticalSection(&m_csLogFile);

      SAFEDELETEBUF(ansi);
    }

    if( !(m_iMode & TESTLOG_MODE_FLAG_NOPIPERLOG) )
    {
      HRESULT hr   = S_OK;
      BSTR    text = __widetobstr(buffer);
      BSTR    src  = __widetobstr(L"Spork");

       hr = m_pStatus->OutputStatus(src, text, LEVEL_STATUS);

      SAFEDELETEBSTR(text);
      SAFEDELETEBSTR(src);
    }

    if( m_iMode & TESTLOG_MODE_FLAG_OUTPUTTODBG )
    {
      OutputDebugString(buffer);
    }

    SAFEDELETEBUF(buffer);
  }
}


LPCALLINFO
TestLog::_PushCallInfo(
  LPCWSTR function,
  RETTYPE rt
  )
{
  LPCALLINFO pci   = NULL;
  LPCALLINFO plast = NULL;

  for( pci = m_pStack; pci; pci = pci->next )
  {
    plast = pci;
  }

  if( !pci )
  {
    pci          = new CALLINFO;
    pci->fname   = StrDup(function);
    pci->rettype = rt;
    pci->last    = plast;
    pci->next    = NULL;

    if( !m_pStack )
    {
      m_pStack = pci;
    }
    else
    {
      plast->next = pci;
    }
  }

  return pci;
}


LPCALLINFO
TestLog::_PopCallInfo(
  void
  )
{
  LPCALLINFO pci = NULL;

  if( m_pStack )
  {
    for(pci = m_pStack; pci->next; pci = pci->next);
  }

  return pci;
}


void
TestLog::_DeleteCallInfo(
  LPCALLINFO pci
  )
{
  if( pci->last )
  {
    pci->last->next = NULL;
  }

  if( m_pStack == pci )
  {
    m_pStack = NULL;
  }

  SAFEDELETEBUF(pci->fname);
  SAFEDELETE(pci);
}


LPWSTR
TestLog::_FormatCallReturnString(
  LPCALLINFO pci,
  VARIANT    retval
  )
{
  LPWSTR buffer = new WCHAR[256];
  int    offset = 0;

  if( buffer )
  {
    offset = wnsprintf(buffer, 256, L"%s() returned ", pci->fname);

    switch( pci->rettype )
    {
      case rt_void :
        {
          wnsprintf(buffer+offset, 256-offset, L"<void>");
        }
        break;

      case rt_bool :
        {
          wnsprintf(buffer+offset, 256-offset, L"%s", VTF(&retval));
        }
        break;

      case rt_dword :
        {
          wnsprintf(buffer+offset, 256-offset, L"%d", V_I4(&retval));
        }
        break;

      case rt_error :
        {
          wnsprintf(buffer+offset, 256-offset, L"%d [%s]", V_I4(&retval), _MapErrorToString(V_I4(&retval)));
        }
        break;

      case rt_hresult :
        {
          wnsprintf(buffer+offset, 256-offset, L"%x [%s]", V_I4(&retval), _MapHResultToString(V_I4(&retval)));
        }
        break;

      case rt_string :
        {
          wnsprintf(buffer+offset, 256-offset, L"%.16s", V_BSTR(&retval));
        }
        break;

      default:
        {
          wnsprintf(buffer+offset, 256-offset, L"?");
        }
    }
  }

  return buffer;
}


//-----------------------------------------------------------------------------
// Utility functions
//-----------------------------------------------------------------------------
LPWSTR
TestLog::_GetWhiteSpace(
  int spaces
  )
{
  int    n   = 0;
  LPWSTR buf = new WCHAR[(spaces * 2) + 1];

  if( buf )
  {
    while(n<(spaces*2)) buf[n++] = L' ';
    buf[n] = L'\0';
  }

  return buf;
}


LPWSTR
TestLog::_GetTimeStamp(
  void
  )
{
  SYSTEMTIME st;
  LPWSTR     buf = new WCHAR[256];
  
  if( buf )
  {
    GetLocalTime(&st);

    wnsprintf(
      buf,
      256,
      L"%0.2d:%0.2d:%0.2d.%0.3d",
      st.wHour,
      st.wMinute,
      st.wSecond,
      st.wMilliseconds
      );
  }

  return buf;
}


//-----------------------------------------------------------------------------
// Mapping functions
//-----------------------------------------------------------------------------
LPWSTR
TestLog::_MapHResultToString(
  HRESULT hr
  )
{
  switch(hr)
  {
    CASE_OF(S_OK);
    CASE_OF(E_NOINTERFACE);
    CASE_OF(E_POINTER);
    CASE_OF(E_UNEXPECTED);
    CASE_OF(E_INVALIDARG);
    CASE_OF(E_OUTOFMEMORY);
    CASE_OF(E_FAIL);
    CASE_OF(E_NOTIMPL);
    CASE_OF(E_PENDING);
    CASE_OF(E_ACCESSDENIED);
    CASE_OF(CLASS_E_NOAGGREGATION);
    CASE_OF(TYPE_E_IOERROR);
    CASE_OF(TYPE_E_REGISTRYACCESS);
    CASE_OF(TYPE_E_INVALIDSTATE);
    CASE_OF(TYPE_E_BUFFERTOOSMALL);
    CASE_OF(TYPE_E_FIELDNOTFOUND);
    CASE_OF(TYPE_E_ELEMENTNOTFOUND);
    CASE_OF(TYPE_E_AMBIGUOUSNAME);
    CASE_OF(TYPE_E_UNKNOWNLCID);
    CASE_OF(TYPE_E_BADMODULEKIND);
    CASE_OF(TYPE_E_CANTLOADLIBRARY);
    CASE_OF(TYPE_E_INCONSISTENTPROPFUNCS);
    CASE_OF(CONNECT_E_NOCONNECTION);
    CASE_OF(CONNECT_E_ADVISELIMIT);
    CASE_OF(CO_E_OBJNOTREG);
    CASE_OF(DISP_E_BADPARAMCOUNT);
    CASE_OF(DISP_E_BADVARTYPE);
    CASE_OF(DISP_E_EXCEPTION);
    CASE_OF(DISP_E_MEMBERNOTFOUND);
    CASE_OF(DISP_E_NONAMEDARGS);
    CASE_OF(DISP_E_OVERFLOW);
    CASE_OF(DISP_E_PARAMNOTFOUND);
    CASE_OF(DISP_E_TYPEMISMATCH);
    CASE_OF(DISP_E_UNKNOWNINTERFACE);
    CASE_OF(DISP_E_UNKNOWNLCID);
    CASE_OF(DISP_E_PARAMNOTOPTIONAL);
    CASE_OF(DISP_E_UNKNOWNNAME);

    default : return L"?";
  }
}


LPWSTR
TestLog::_MapErrorToString(
  int error
  )
{
  switch(error)
  {
    CASE_OF(ERROR_SUCCESS);
    CASE_OF(ERROR_INVALID_FUNCTION);
    CASE_OF(ERROR_FILE_NOT_FOUND);
    CASE_OF(ERROR_PATH_NOT_FOUND);
    CASE_OF(ERROR_TOO_MANY_OPEN_FILES);
    CASE_OF(ERROR_ACCESS_DENIED);
    CASE_OF(ERROR_INVALID_HANDLE);
    CASE_OF(ERROR_ARENA_TRASHED);
    CASE_OF(ERROR_NOT_ENOUGH_MEMORY);
    CASE_OF(ERROR_INVALID_BLOCK);
    CASE_OF(ERROR_BAD_ENVIRONMENT);
    CASE_OF(ERROR_BAD_FORMAT);
    CASE_OF(ERROR_INVALID_ACCESS);
    CASE_OF(ERROR_INVALID_DATA);
    CASE_OF(ERROR_OUTOFMEMORY);
    CASE_OF(ERROR_INVALID_DRIVE);
    CASE_OF(ERROR_CURRENT_DIRECTORY);
    CASE_OF(ERROR_NOT_SAME_DEVICE);
    CASE_OF(ERROR_NO_MORE_FILES);
    CASE_OF(ERROR_WRITE_PROTECT);
    CASE_OF(ERROR_BAD_UNIT);
    CASE_OF(ERROR_NOT_READY);
    CASE_OF(ERROR_BAD_COMMAND);
    CASE_OF(ERROR_CRC);
    CASE_OF(ERROR_BAD_LENGTH);
    CASE_OF(ERROR_SEEK);
    CASE_OF(ERROR_NOT_DOS_DISK);
    CASE_OF(ERROR_SECTOR_NOT_FOUND);
    CASE_OF(ERROR_OUT_OF_PAPER);
    CASE_OF(ERROR_WRITE_FAULT);
    CASE_OF(ERROR_READ_FAULT);
    CASE_OF(ERROR_GEN_FAILURE);
    CASE_OF(ERROR_SHARING_VIOLATION);
    CASE_OF(ERROR_LOCK_VIOLATION);
    CASE_OF(ERROR_WRONG_DISK);
    CASE_OF(ERROR_SHARING_BUFFER_EXCEEDED);
    CASE_OF(ERROR_HANDLE_EOF);
    CASE_OF(ERROR_HANDLE_DISK_FULL);
    CASE_OF(ERROR_NOT_SUPPORTED);
    CASE_OF(ERROR_REM_NOT_LIST);
    CASE_OF(ERROR_DUP_NAME);
    CASE_OF(ERROR_BAD_NETPATH);
    CASE_OF(ERROR_NETWORK_BUSY);
    CASE_OF(ERROR_DEV_NOT_EXIST);
    CASE_OF(ERROR_TOO_MANY_CMDS);
    CASE_OF(ERROR_ADAP_HDW_ERR);
    CASE_OF(ERROR_BAD_NET_RESP);
    CASE_OF(ERROR_UNEXP_NET_ERR);
    CASE_OF(ERROR_BAD_REM_ADAP);
    CASE_OF(ERROR_PRINTQ_FULL);
    CASE_OF(ERROR_NO_SPOOL_SPACE);
    CASE_OF(ERROR_PRINT_CANCELLED);
    CASE_OF(ERROR_NETNAME_DELETED);
    CASE_OF(ERROR_NETWORK_ACCESS_DENIED);
    CASE_OF(ERROR_BAD_DEV_TYPE);
    CASE_OF(ERROR_BAD_NET_NAME);
    CASE_OF(ERROR_TOO_MANY_NAMES);
    CASE_OF(ERROR_TOO_MANY_SESS);
    CASE_OF(ERROR_SHARING_PAUSED);
    CASE_OF(ERROR_REQ_NOT_ACCEP);
    CASE_OF(ERROR_REDIR_PAUSED);
    CASE_OF(ERROR_FILE_EXISTS);
    CASE_OF(ERROR_CANNOT_MAKE);
    CASE_OF(ERROR_FAIL_I24);
    CASE_OF(ERROR_OUT_OF_STRUCTURES);
    CASE_OF(ERROR_ALREADY_ASSIGNED);
    CASE_OF(ERROR_INVALID_PASSWORD);
    CASE_OF(ERROR_INVALID_PARAMETER);
    CASE_OF(ERROR_NET_WRITE_FAULT);
    CASE_OF(ERROR_NO_PROC_SLOTS);
    CASE_OF(ERROR_TOO_MANY_SEMAPHORES);
    CASE_OF(ERROR_EXCL_SEM_ALREADY_OWNED);
    CASE_OF(ERROR_SEM_IS_SET);
    CASE_OF(ERROR_TOO_MANY_SEM_REQUESTS);
    CASE_OF(ERROR_INVALID_AT_INTERRUPT_TIME);
    CASE_OF(ERROR_SEM_OWNER_DIED);
    CASE_OF(ERROR_SEM_USER_LIMIT);
    CASE_OF(ERROR_DISK_CHANGE);
    CASE_OF(ERROR_DRIVE_LOCKED);
    CASE_OF(ERROR_BROKEN_PIPE);
    CASE_OF(ERROR_OPEN_FAILED);
    CASE_OF(ERROR_BUFFER_OVERFLOW);
    CASE_OF(ERROR_DISK_FULL);
    CASE_OF(ERROR_NO_MORE_SEARCH_HANDLES);
    CASE_OF(ERROR_INVALID_TARGET_HANDLE);
    CASE_OF(ERROR_INVALID_CATEGORY);
    CASE_OF(ERROR_INVALID_VERIFY_SWITCH);
    CASE_OF(ERROR_BAD_DRIVER_LEVEL);
    CASE_OF(ERROR_CALL_NOT_IMPLEMENTED);
    CASE_OF(ERROR_SEM_TIMEOUT);
    CASE_OF(ERROR_INSUFFICIENT_BUFFER);
    CASE_OF(ERROR_INVALID_NAME);
    CASE_OF(ERROR_INVALID_LEVEL);
    CASE_OF(ERROR_NO_VOLUME_LABEL);
    CASE_OF(ERROR_MOD_NOT_FOUND);
    CASE_OF(ERROR_PROC_NOT_FOUND);
    CASE_OF(ERROR_WAIT_NO_CHILDREN);
    CASE_OF(ERROR_CHILD_NOT_COMPLETE);
    CASE_OF(ERROR_DIRECT_ACCESS_HANDLE);
    CASE_OF(ERROR_NEGATIVE_SEEK);
    CASE_OF(ERROR_SEEK_ON_DEVICE);
    CASE_OF(ERROR_DIR_NOT_ROOT);
    CASE_OF(ERROR_DIR_NOT_EMPTY);
    CASE_OF(ERROR_PATH_BUSY);
    CASE_OF(ERROR_SYSTEM_TRACE);
    CASE_OF(ERROR_INVALID_EVENT_COUNT);
    CASE_OF(ERROR_TOO_MANY_MUXWAITERS);
    CASE_OF(ERROR_INVALID_LIST_FORMAT);
    CASE_OF(ERROR_BAD_ARGUMENTS);
    CASE_OF(ERROR_BAD_PATHNAME);
    CASE_OF(ERROR_BUSY);
    CASE_OF(ERROR_CANCEL_VIOLATION);
    CASE_OF(ERROR_ALREADY_EXISTS);
    CASE_OF(ERROR_FILENAME_EXCED_RANGE);
    CASE_OF(ERROR_LOCKED);
    CASE_OF(ERROR_NESTING_NOT_ALLOWED);
    CASE_OF(ERROR_BAD_PIPE);
    CASE_OF(ERROR_PIPE_BUSY);
    CASE_OF(ERROR_NO_DATA);
    CASE_OF(ERROR_PIPE_NOT_CONNECTED);
    CASE_OF(ERROR_MORE_DATA);
    CASE_OF(ERROR_NO_MORE_ITEMS);
    CASE_OF(ERROR_NOT_OWNER);
    CASE_OF(ERROR_PARTIAL_COPY);
    CASE_OF(ERROR_MR_MID_NOT_FOUND);
    CASE_OF(ERROR_INVALID_ADDRESS);
    CASE_OF(ERROR_PIPE_CONNECTED);
    CASE_OF(ERROR_PIPE_LISTENING);
    CASE_OF(ERROR_OPERATION_ABORTED);
    CASE_OF(ERROR_IO_INCOMPLETE);
    CASE_OF(ERROR_IO_PENDING);
    CASE_OF(ERROR_NOACCESS);
    CASE_OF(ERROR_STACK_OVERFLOW);
    CASE_OF(ERROR_INVALID_FLAGS);
    CASE_OF(ERROR_NO_TOKEN);
    CASE_OF(ERROR_BADDB);
    CASE_OF(ERROR_BADKEY);
    CASE_OF(ERROR_CANTOPEN);
    CASE_OF(ERROR_CANTREAD);
    CASE_OF(ERROR_CANTWRITE);
    CASE_OF(ERROR_REGISTRY_RECOVERED);
    CASE_OF(ERROR_REGISTRY_CORRUPT);
    CASE_OF(ERROR_REGISTRY_IO_FAILED);
    CASE_OF(ERROR_NOT_REGISTRY_FILE);
    CASE_OF(ERROR_KEY_DELETED);
    CASE_OF(ERROR_CIRCULAR_DEPENDENCY);
    CASE_OF(ERROR_SERVICE_NOT_ACTIVE);
    CASE_OF(ERROR_DLL_INIT_FAILED);
    CASE_OF(ERROR_CANCELLED);
    CASE_OF(ERROR_BAD_USERNAME);
    CASE_OF(ERROR_LOGON_FAILURE);

    CASE_OF(WAIT_FAILED);
    CASE_OF(WAIT_TIMEOUT);
    CASE_OF(WAIT_IO_COMPLETION);

    CASE_OF(EXCEPTION_ACCESS_VIOLATION);
    CASE_OF(EXCEPTION_DATATYPE_MISALIGNMENT);
    CASE_OF(EXCEPTION_BREAKPOINT);
    CASE_OF(EXCEPTION_SINGLE_STEP);
    CASE_OF(EXCEPTION_ARRAY_BOUNDS_EXCEEDED);
    CASE_OF(EXCEPTION_FLT_DENORMAL_OPERAND);
    CASE_OF(EXCEPTION_FLT_DIVIDE_BY_ZERO);
    CASE_OF(EXCEPTION_FLT_INEXACT_RESULT);
    CASE_OF(EXCEPTION_FLT_INVALID_OPERATION);
    CASE_OF(EXCEPTION_FLT_OVERFLOW);
    CASE_OF(EXCEPTION_FLT_STACK_CHECK);
    CASE_OF(EXCEPTION_FLT_UNDERFLOW);
    CASE_OF(EXCEPTION_INT_DIVIDE_BY_ZERO);
    CASE_OF(EXCEPTION_INT_OVERFLOW);
    CASE_OF(EXCEPTION_PRIV_INSTRUCTION);
    CASE_OF(EXCEPTION_IN_PAGE_ERROR);
    CASE_OF(EXCEPTION_ILLEGAL_INSTRUCTION);
    CASE_OF(EXCEPTION_NONCONTINUABLE_EXCEPTION);
    CASE_OF(EXCEPTION_STACK_OVERFLOW);
    CASE_OF(EXCEPTION_INVALID_DISPOSITION);
    CASE_OF(EXCEPTION_GUARD_PAGE);
    CASE_OF(EXCEPTION_INVALID_HANDLE);

    CASE_OF(RPC_S_INVALID_STRING_BINDING);
    CASE_OF(RPC_S_WRONG_KIND_OF_BINDING);
    CASE_OF(RPC_S_INVALID_BINDING);
    CASE_OF(RPC_S_PROTSEQ_NOT_SUPPORTED);
    CASE_OF(RPC_S_INVALID_RPC_PROTSEQ);
    CASE_OF(RPC_S_INVALID_STRING_UUID);
    CASE_OF(RPC_S_INVALID_ENDPOINT_FORMAT);
    CASE_OF(RPC_S_INVALID_NET_ADDR);
    CASE_OF(RPC_S_NO_ENDPOINT_FOUND);
    CASE_OF(RPC_S_INVALID_TIMEOUT);
    CASE_OF(RPC_S_OBJECT_NOT_FOUND);
    CASE_OF(RPC_S_ALREADY_REGISTERED);
    CASE_OF(RPC_S_TYPE_ALREADY_REGISTERED);
    CASE_OF(RPC_S_ALREADY_LISTENING);
    CASE_OF(RPC_S_NO_PROTSEQS_REGISTERED);
    CASE_OF(RPC_S_NOT_LISTENING);
    CASE_OF(RPC_S_UNKNOWN_MGR_TYPE);
    CASE_OF(RPC_S_UNKNOWN_IF);
    CASE_OF(RPC_S_NO_BINDINGS);
    CASE_OF(RPC_S_NO_PROTSEQS);
    CASE_OF(RPC_S_CANT_CREATE_ENDPOINT);
    CASE_OF(RPC_S_OUT_OF_RESOURCES);
    CASE_OF(RPC_S_SERVER_UNAVAILABLE);
    CASE_OF(RPC_S_SERVER_TOO_BUSY);
    CASE_OF(RPC_S_INVALID_NETWORK_OPTIONS);
    CASE_OF(RPC_S_NO_CALL_ACTIVE);
    CASE_OF(RPC_S_CALL_FAILED);
    CASE_OF(RPC_S_CALL_FAILED_DNE);
    CASE_OF(RPC_S_PROTOCOL_ERROR);
    CASE_OF(RPC_S_UNSUPPORTED_TRANS_SYN);
    CASE_OF(RPC_S_UNSUPPORTED_TYPE);
    CASE_OF(RPC_S_INVALID_TAG);
    CASE_OF(RPC_S_INVALID_BOUND);
    CASE_OF(RPC_S_NO_ENTRY_NAME);
    CASE_OF(RPC_S_INVALID_NAME_SYNTAX);
    CASE_OF(RPC_S_UNSUPPORTED_NAME_SYNTAX);
    CASE_OF(RPC_S_UUID_NO_ADDRESS);
    CASE_OF(RPC_S_DUPLICATE_ENDPOINT);
    CASE_OF(RPC_S_UNKNOWN_AUTHN_TYPE);
    CASE_OF(RPC_S_MAX_CALLS_TOO_SMALL);
    CASE_OF(RPC_S_STRING_TOO_LONG);
    CASE_OF(RPC_S_PROTSEQ_NOT_FOUND);
    CASE_OF(RPC_S_PROCNUM_OUT_OF_RANGE);
    CASE_OF(RPC_S_BINDING_HAS_NO_AUTH);
    CASE_OF(RPC_S_UNKNOWN_AUTHN_SERVICE);
    CASE_OF(RPC_S_UNKNOWN_AUTHN_LEVEL);
    CASE_OF(RPC_S_INVALID_AUTH_IDENTITY);
    CASE_OF(RPC_S_UNKNOWN_AUTHZ_SERVICE);
    CASE_OF(EPT_S_INVALID_ENTRY);
    CASE_OF(EPT_S_CANT_PERFORM_OP);
    CASE_OF(EPT_S_NOT_REGISTERED);
    CASE_OF(RPC_S_NOTHING_TO_EXPORT);
    CASE_OF(RPC_S_INCOMPLETE_NAME);
    CASE_OF(RPC_S_INVALID_VERS_OPTION);
    CASE_OF(RPC_S_NO_MORE_MEMBERS);
    CASE_OF(RPC_S_NOT_ALL_OBJS_UNEXPORTED);
    CASE_OF(RPC_S_INTERFACE_NOT_FOUND);
    CASE_OF(RPC_S_ENTRY_ALREADY_EXISTS);
    CASE_OF(RPC_S_ENTRY_NOT_FOUND);
    CASE_OF(RPC_S_NAME_SERVICE_UNAVAILABLE);
    CASE_OF(RPC_S_INVALID_NAF_ID);
    CASE_OF(RPC_S_CANNOT_SUPPORT);
    CASE_OF(RPC_S_NO_CONTEXT_AVAILABLE);
    CASE_OF(RPC_S_INTERNAL_ERROR);
    CASE_OF(RPC_S_ZERO_DIVIDE);
    CASE_OF(RPC_S_ADDRESS_ERROR);
    CASE_OF(RPC_S_FP_DIV_ZERO);
    CASE_OF(RPC_S_FP_UNDERFLOW);
    CASE_OF(RPC_S_FP_OVERFLOW);
    CASE_OF(RPC_X_NO_MORE_ENTRIES);
    CASE_OF(RPC_X_SS_CHAR_TRANS_OPEN_FAIL);
    CASE_OF(RPC_X_SS_CHAR_TRANS_SHORT_FILE);
    CASE_OF(RPC_X_SS_IN_NULL_CONTEXT);
    CASE_OF(RPC_X_SS_CONTEXT_DAMAGED);
    CASE_OF(RPC_X_SS_HANDLES_MISMATCH);
    CASE_OF(RPC_X_SS_CANNOT_GET_CALL_HANDLE);
    CASE_OF(RPC_X_NULL_REF_POINTER);
    CASE_OF(RPC_X_ENUM_VALUE_OUT_OF_RANGE);
    CASE_OF(RPC_X_BYTE_COUNT_TOO_SMALL);
    CASE_OF(RPC_X_BAD_STUB_DATA);

    CASE_OF(WSAEINTR);
    CASE_OF(WSAEBADF);
    CASE_OF(WSAEACCES);
    CASE_OF(WSAEFAULT);
    CASE_OF(WSAEINVAL);
    CASE_OF(WSAEMFILE);
    CASE_OF(WSAEWOULDBLOCK);
    CASE_OF(WSAEINPROGRESS);
    CASE_OF(WSAEALREADY);
    CASE_OF(WSAENOTSOCK);
    CASE_OF(WSAEDESTADDRREQ);
    CASE_OF(WSAEMSGSIZE);
    CASE_OF(WSAEPROTOTYPE);
    CASE_OF(WSAENOPROTOOPT);
    CASE_OF(WSAEPROTONOSUPPORT);
    CASE_OF(WSAESOCKTNOSUPPORT);
    CASE_OF(WSAEOPNOTSUPP);
    CASE_OF(WSAEPFNOSUPPORT);
    CASE_OF(WSAEAFNOSUPPORT);
    CASE_OF(WSAEADDRINUSE);
    CASE_OF(WSAEADDRNOTAVAIL);
    CASE_OF(WSAENETDOWN);
    CASE_OF(WSAENETUNREACH);
    CASE_OF(WSAENETRESET);
    CASE_OF(WSAECONNABORTED);
    CASE_OF(WSAECONNRESET);
    CASE_OF(WSAENOBUFS);
    CASE_OF(WSAEISCONN);
    CASE_OF(WSAENOTCONN);
    CASE_OF(WSAESHUTDOWN);
    CASE_OF(WSAETOOMANYREFS);
    CASE_OF(WSAETIMEDOUT);
    CASE_OF(WSAECONNREFUSED);
    CASE_OF(WSAELOOP);
    CASE_OF(WSAENAMETOOLONG);
    CASE_OF(WSAEHOSTDOWN);
    CASE_OF(WSAEHOSTUNREACH);
    CASE_OF(WSAENOTEMPTY);
    CASE_OF(WSAEPROCLIM);
    CASE_OF(WSAEUSERS);
    CASE_OF(WSAEDQUOT);
    CASE_OF(WSAESTALE);
    CASE_OF(WSAEREMOTE);
    CASE_OF(WSAEDISCON);
    CASE_OF(WSASYSNOTREADY);
    CASE_OF(WSAVERNOTSUPPORTED);
    CASE_OF(WSANOTINITIALISED);
    CASE_OF(WSAHOST_NOT_FOUND);
    CASE_OF(WSATRY_AGAIN);
    CASE_OF(WSANO_RECOVERY);
    CASE_OF(WSANO_DATA);

    default : return L"?";
  }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\tools\spork\sporklets\testlog\src\utils.cxx ===
/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Copyright (c) 2001  Microsoft Corporation

Module Name:

    utils.cxx

Abstract:

    Utility functions used by the project.
    
Author:

    Paul M Midgen (pmidge) 22-February-2001


Revision History:

    22-February-2001 pmidge
        Created

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/


#include <common.h>


//-----------------------------------------------------------------------------
// new & delete
//-----------------------------------------------------------------------------
void* __cdecl operator new(size_t size)
{
  return (void*) LocalAlloc(
#ifdef NO_ZEROINIT
    NONZEROLPTR,
#else
    LPTR,
#endif
    size);
}

void __cdecl operator delete(void* pv)
{
  LocalFree(pv);
}

//-----------------------------------------------------------------------------
// general utility functions
//-----------------------------------------------------------------------------
HRESULT
GetTypeInfoFromName(LPCOLESTR name, ITypeLib* ptl, ITypeInfo** ppti)
{
  HRESULT  hr     = S_OK;
  BOOL     bFound = FALSE;
  USHORT   cf     = 1L;
  ULONG    hash   = 0L;
  LONG     id     = 0L;
  LPOLESTR pstr   = NULL;

  if( !name || ! ptl )
  {
    hr = E_INVALIDARG;
    goto quit;
  }

  if( !ppti )
  {
    hr = E_POINTER;
    goto quit;
  }

  *ppti = NULL;
  pstr  = StrDup(name);

    ptl->IsName(pstr, 0L, &bFound);

      if( !bFound )
      {
        hr = TYPE_E_ELEMENTNOTFOUND;
        goto quit;
      }

    hash = LHashValOfNameSys(
             SYS_WIN32,
             MAKELCID(MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL), SORT_DEFAULT),
             pstr
             );

    hr = ptl->FindName(pstr, hash, ppti, &id, &cf);

quit:

  SAFEDELETEBUF(pstr);
  return hr;
}

DISPID
GetDispidFromName(PDISPIDTABLEENTRY pdt, DWORD cEntries, LPWSTR name)
{
  DWORD  n      = 0L;
  DWORD  hash   = GetHash(name);
  DISPID dispid = DISPID_UNKNOWN;

  while( n < cEntries )
  {
    if( pdt[n].hash != hash )
    {
      ++n;
    }
    else
    {
      dispid = pdt[n].dispid;
      break;
    }
  }

  return dispid;
}

void
AddRichErrorInfo(EXCEPINFO* pei, LPWSTR source, LPWSTR description, HRESULT error)
{
  if( pei )
  {
    pei->bstrSource      = __widetobstr((source ? source : L"unknown source"));
    pei->bstrDescription = __widetobstr((description ? description : L"no description"));
    pei->scode           = error;
  }
}

DWORD
GetHash(LPWSTR name)
{
  DWORD hash   = 0L;
  DWORD n      = 0L;
  DWORD len    = 0L;
  LPSTR string = NULL;

  string = __widetoansi(name);

  if( string )
  {
    _strlwr(string);

    for(n=0, len=strlen(string); n<=len; n++)
    {
      hash += __toascii(string[len-n]) * ((10<<n)^n);
    }
  }

  SAFEDELETEBUF(string);
  return hash;
}

HRESULT
DispGetOptionalParam(DISPPARAMS* pdp, UINT pos, VARTYPE vt, VARIANT* pvr, UINT* pae)
{
  HRESULT hr = DispGetParam(pdp, pos, vt, pvr, pae);

  //
  // if DispGetParam failed due to a type mismatch, it was likely deliberate on
  // the part of the dispatch code. i pass in VT_VARIANT when i have no idea
  // what the controller is sending me, all i know is that i need a copy, maybe.
  //
  if( hr == DISP_E_TYPEMISMATCH )
  {
    hr = VariantCopy(pvr, &pdp->rgvarg[((pdp->cArgs-1)-pos)]);
  }

  return (hr == DISP_E_PARAMNOTFOUND) ? S_OK : hr;
}

HRESULT
ValidateDispatchArgs(REFIID riid, DISPPARAMS* pdp, VARIANT* pvr, UINT* pae)
{
  HRESULT hr = S_OK;

    if( !IsEqualIID(riid, IID_NULL) )
    {
      hr = DISP_E_UNKNOWNINTERFACE;
      goto quit;
    }

    if( !pdp )
    {
      hr = E_INVALIDARG;
      goto quit;
    }

    if( pae )
    {
      *pae = 0;
    }

    if( pvr )
    {
      VariantInit(pvr);
    }

quit:

  return hr;
}

HRESULT
ValidateInvokeFlags(WORD flags, WORD accesstype, BOOL bMethod)
{
  HRESULT hr = S_OK;

    if( (flags & ~(DISPATCH_METHOD | DISPATCH_PROPERTYGET | DISPATCH_PROPERTYPUT)) )
    {
      hr = E_INVALIDARG;
    }
    else
    {
      if( !bMethod )
      {
        if( flags & DISPATCH_METHOD )
        {
          hr = E_NOINTERFACE;
        }
        else
        {
          if( (flags & DISPATCH_PROPERTYPUT) && !(accesstype & DISPATCH_PROPERTYPUT) )
          {
            hr = E_ACCESSDENIED;
          }
          else
          {
            if( !(flags & accesstype) )
            {
              hr = E_FAIL;
            }
          }
        }
      }
      else
      {
        if( flags & ~(DISPATCH_METHOD | DISPATCH_PROPERTYGET) )
        {
          hr = E_NOINTERFACE;
        }
      }
    }

  return hr;
}

HRESULT
ValidateArgCount(DISPPARAMS* pdp, DWORD needed, BOOL bHasOptionalArgs, DWORD optional)
{
  HRESULT hr = S_OK;

    if( bHasOptionalArgs )
    {
      if( (pdp->cArgs > needed+optional) || (pdp->cArgs < needed) )
      {
        hr = DISP_E_BADPARAMCOUNT;
      }
    }
    else
    {
      if( (!needed && pdp->cArgs) || (needed < pdp->cArgs) )
      {
        hr = DISP_E_BADPARAMCOUNT;
      }
      else
      {
        hr = (pdp->cArgs == needed) ? S_OK : DISP_E_PARAMNOTOPTIONAL;
      }
    }

  return hr;
}

HRESULT
HandleDispatchError(LPWSTR id, EXCEPINFO* pei, HRESULT hr)
{
  LPWSTR msg = NULL;

  switch( hr )
  {
    case E_POINTER      : msg = L"a return pointer parameter was missing";                          break;
    case E_ACCESSDENIED : msg = L"an attempt to modify a property failed because it is read-only";  break;
    case E_FAIL         : msg = L"an unhandled error occurred";                                     break;
    case E_INVALIDARG   : msg = L"an argument passed to a property or method was invalid";          break;
    case E_NOINTERFACE  : msg = L"a property or method was accessed incorrectly";                   break;
    case E_UNEXPECTED   : msg = L"a call to open() must precede any attempt to use the log object"; break;
    default             : return hr;
  }

  AddRichErrorInfo(pei, id, msg, hr);

  return DISP_E_EXCEPTION;
}

//-----------------------------------------------------------------------------
// string & type manipulation
//-----------------------------------------------------------------------------
WCHAR*
__ansitowide(const char* psz)
{
  WCHAR* wide = NULL;
  int    len  = 0L;

  if( psz )
  {
    len = strlen(psz);

    if( len )
    {
      wide      = new WCHAR[len+1];
      wide[len] = L'\0';

      MultiByteToWideChar(
        CP_ACP, 0,
        psz,  len,
        wide, len
        );
    }
  }

  return wide;
}

CHAR*
__widetoansi(const WCHAR* pwsz)
{
  CHAR* ansi = NULL;
  int   len  = 0L;
  BOOL  def  = FALSE;

  if( pwsz )
  {
    len = wcslen(pwsz);

    if( len )
    {
      ansi      = new CHAR[len+1];
      ansi[len] = '\0';

      WideCharToMultiByte(
        CP_ACP, 0,
        pwsz, len,
        ansi, len,
        "?", &def
        );
    }
  }

  return ansi;
}

BSTR
__ansitobstr(LPCSTR src)
{
  BSTR   ret = NULL;
  LPWSTR wsz = NULL;

  if( src )
  {
    wsz = __ansitowide(src);
    ret = SysAllocString(wsz);
    SAFEDELETEBUF(wsz);
  }

  return ret;
}

BSTR
__widetobstr(LPCWSTR wsrc)
{
  return (wsrc ? SysAllocString(wsrc) : NULL);
}

BOOL
__isempty(VARIANT* var)
{
  BOOL isempty = FALSE;

  if( var )
  {
    if(
        ((V_VT(var) == VT_EMPTY) || (V_VT(var) == VT_NULL) || (V_VT(var) == VT_ERROR)) ||
        ((V_VT(var) == VT_BSTR) && (SysStringLen(V_BSTR(var)) == 0))
      )
    {
      isempty = TRUE;
    }
  }
  else
  {
    isempty = TRUE;
  }

  return isempty;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\tools\spork\src\common\registry.cxx ===
/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Copyright (c) 2000  Microsoft Corporation

Module Name:

    registry.cpp

Abstract:

    Registry functions.
    
Author:

    Paul M Midgen (pmidge) 23-May-2000


Revision History:

    23-May-2000 pmidge
        Created

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/


#include "common.h"


#define MAX_LENGTH (MAX_PATH+1)


LPCWSTR g_wszAppRootKeyName = L"Software\\Spork";
HKEY    g_hkAppRoot         = NULL;


DWORD
GetNumberOfSubKeysFromKey(LPCWSTR wszKeyName)
{
  BOOL   bStatus   = FALSE;
  DWORD  dwRet     = 0L;
  DWORD  dwSubKeys = 0L;
  HKEY   hKey      = NULL;


  dwRet = RegOpenKeyEx(
            g_hkAppRoot,
            wszKeyName, 0,
            KEY_READ,
            &hKey
            );

    if( dwRet )
    {
      SetLastError(dwRet);
      goto quit;
    }

  dwRet = RegQueryInfoKey(
            hKey,
            NULL,
            NULL,
            NULL,
            &dwSubKeys,
            NULL,
            NULL,
            NULL,
            NULL,
            NULL,
            NULL,
            NULL
            );

  RegCloseKey(hKey);

quit:

  return dwSubKeys;
}


/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

  GetRegValue()

  WHAT      : Reads the value of a REG_DWORD or REG_SZ registry value. The
              caller must free the value returned through ppvData.

  ARGS      : szValueName - the value to look up
              dwType      - can be REG_SZ or REG_DWORD
              ppvData     - address of a pointer to initialize to the data
                            read from the registry

  RETURNS   : True if the lookup succeeded, false if there was an error. The
              caller can call GetLastError() to determine the type of error.
              Possible values returned by GetLastError() are:

              ERROR_NOT_ENOUGH_MEMORY - failed to allocate storage for the
                                        requested key

              ERROR_INVALID_PARAMETER - unsupported type in dwType

              If registry lookups fail we set last error to the retcode
              from the registry api we called.

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/
BOOL
GetRootRegValue(
  LPCWSTR wszValueName,
  DWORD   dwType,
  LPVOID* ppvData
  )
{
  BOOL   bStatus = FALSE;
  DWORD  dwRet   = 0L;
  LPBYTE lpData  = NULL;
  DWORD  cbData  = 0L;

  switch( dwType )
  {
    case REG_DWORD :
      {
        cbData = sizeof(DWORD);
        lpData = new BYTE[cbData];

        if( !lpData )
        {
          SetLastError(ERROR_NOT_ENOUGH_MEMORY);
          goto quit;
        }
      }
      break;

    case REG_SZ :
      {
        // get required buffer size
        dwRet = RegQueryValueEx(
                  g_hkAppRoot, wszValueName, 0L,
                  &dwType, lpData, &cbData
                  );

          if( dwRet )
          {
            SetLastError(dwRet);
            goto quit;
          }

        lpData = new BYTE[cbData];

          if( !lpData )
          {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            goto quit;
          }
      }
      break;

    default :
      {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto quit;
      }
      break;
  }

  //
  // do the lookup
  //
  dwRet = RegQueryValueEx(
            g_hkAppRoot, wszValueName, 0L,
            &dwType, lpData, &cbData
            );
    
    if( dwRet )
    {
      SAFEDELETEBUF(lpData);
      SetLastError(dwRet);
      goto quit;
    }

  bStatus  = TRUE;
  *ppvData = (LPVOID) lpData;

quit:

  return bStatus;
}


BOOL
GetRegValueFromKey(
  LPCWSTR wszKeyName,
  LPCWSTR wszValueName,
  DWORD   dwType,
  LPVOID* ppvData
  )
{
  BOOL   bStatus = FALSE;
  DWORD  dwRet   = 0L;
  HKEY   hkey    = NULL;
  LPBYTE lpData  = NULL;
  DWORD  cbData  = 0L;


  dwRet = RegOpenKeyEx(
            g_hkAppRoot,
            wszKeyName, 0,
            KEY_READ,
            &hkey
            );

  if( dwRet )
  {
    SetLastError(dwRet);
    return bStatus;
  }

  switch( dwType )
  {
    case REG_DWORD :
      {
        cbData = sizeof(DWORD);
        lpData = new BYTE[cbData];

        if( !lpData )
        {
          SetLastError(ERROR_NOT_ENOUGH_MEMORY);
          goto quit;
        }
      }
      break;

    case REG_SZ :
      {
        // get required buffer size
        dwRet = RegQueryValueEx(
                  hkey, wszValueName, 0L,
                  &dwType, lpData, &cbData
                  );

          if( dwRet )
          {
            SetLastError(dwRet);
            goto quit;
          }

        lpData = new BYTE[cbData];

          if( !lpData )
          {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            goto quit;
          }
      }
      break;

    default :
      {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto quit;
      }
      break;
  }

  //
  // do the lookup
  //
  dwRet = RegQueryValueEx(
            hkey, wszValueName, 0L,
            &dwType, lpData, &cbData
            );
    
    if( dwRet )
    {
      SAFEDELETEBUF(lpData);
      SetLastError(dwRet);
      goto quit;
    }

  bStatus  = TRUE;
  *ppvData = (LPVOID) lpData;

quit:

  RegCloseKey(hkey);
  return bStatus;
}


BOOL
EnumerateSubKeysFromKey(
  LPCWSTR wszKeyName,
  LPWSTR* ppwszSubKeyName
  )
{
  static HKEY  hKey    = NULL;
  static DWORD dwIndex = 0L;

  BOOL   bStatus = FALSE;
  DWORD  dwRet   = 0L;
  LPWSTR lpName  = NULL;
  DWORD  cbName  = 0L;

  if( wszKeyName )
  {
    if( hKey )
    {
      RegCloseKey(hKey);
      hKey    = NULL;
      dwIndex = 0L;
    }

    dwRet = RegOpenKeyEx(
              g_hkAppRoot,
              wszKeyName, 0,
              KEY_READ,
              &hKey
              );

    if( dwRet )
    {
      SetLastError(dwRet);
      goto quit;
    }
  }
  else
  {
    if( !hKey )
      goto quit;
  }

  lpName = new WCHAR[MAX_LENGTH];
  cbName = MAX_LENGTH;

  dwRet = RegEnumKey(
            hKey,
            dwIndex++,
            lpName,
            cbName
            );

  if( dwRet == ERROR_SUCCESS )
  {
    *ppwszSubKeyName = StrDup(lpName);
    bStatus          = TRUE;
  }
  else
  {
    RegCloseKey(hKey);
    hKey    = NULL;
    dwIndex = 0L;
  }

quit:

  SAFEDELETEBUF(lpName);

  return bStatus;
}


BOOL
EnumerateRegValuesFromKey(
  LPCWSTR  wszKeyName,
  LPWSTR*  ppwszValueName,
  LPDWORD  pdwType,
  LPVOID*  ppvData
  )
{
  static HKEY  hKey    = NULL;
  static DWORD dwIndex = 0L;

  BOOL   bStatus = FALSE;
  DWORD  dwRet   = 0L;
  LPWSTR lpName  = NULL;
  DWORD  cbName  = 0L;
  LPBYTE lpData  = NULL;
  DWORD  cbData  = 0L;
  DWORD  dwType  = 0L;

  if( wszKeyName )
  {
    if( hKey )
    {
      RegCloseKey(hKey);
      hKey    = NULL;
      dwIndex = 0L;
    }

    dwRet = RegOpenKeyEx(
              g_hkAppRoot,
              wszKeyName, 0,
              KEY_READ,
              &hKey
              );

    if( dwRet )
    {
      SetLastError(dwRet);
      goto quit;
    }
  }
  else
  {
    if( !hKey )
      goto quit;
  }

  lpName = new WCHAR[MAX_LENGTH];
  cbName = MAX_LENGTH;

  dwRet = RegEnumValue(
            hKey,
            dwIndex++,
            lpName,
            &cbName,
            NULL,
            &dwType,
            NULL,
            &cbData
            );

  if( dwRet == ERROR_SUCCESS )
  {
    lpData = new BYTE[cbData];

    dwRet = RegQueryValueEx(
              hKey,
              lpName,
              0L,
              &dwType,
              lpData,
              &cbData
              );
    
    if( dwRet == ERROR_SUCCESS )
    {
      *ppwszValueName = StrDup(lpName);
      *pdwType        = dwType;
      *ppvData        = lpData;
      bStatus         = TRUE;
    }
    else
    {
      SAFEDELETEBUF(lpData);
      SetLastError(dwRet);
      goto quit;
    }
  }
  else
  {
    RegCloseKey(hKey);
    hKey    = NULL;
    dwIndex = 0L;
  }

quit:

  SAFEDELETEBUF(lpName);

  return bStatus;
}


/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

  SetRegValue()

  WHAT      : Writes a value under the application registry key.

  ARGS      : szValueName - the name of the regkey to write to
              dwType      - type of the regkey to write
              pvData      - regkey data
              dwSize      - bytecount of data to write

  RETURNS   : True if the write succeeded, false if otherwise.

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/
BOOL
SetRootRegValue(
  LPCWSTR wszValueName,
  DWORD   dwType,
  LPVOID  pvData,
  DWORD   dwSize
  )
{
  BOOL  bStatus = FALSE;
  DWORD dwRet   = 0L;

    if( !dwSize && pvData )
      dwSize = strlen((LPSTR)pvData);

    dwRet = RegSetValueEx(
              g_hkAppRoot, wszValueName, 0L,
              dwType, (LPBYTE)pvData, dwSize
              );

    if( dwRet != ERROR_SUCCESS )
      SetLastError(dwRet);
    else
      bStatus = TRUE;      

  return bStatus;
}


BOOL
SetRegKey(
  LPCWSTR wszPath,
  LPCWSTR wszKeyName
  )
{
  HKEY  hKeyPath = NULL;
  HKEY  hKeyNew  = NULL;
  BOOL  bStatus  = FALSE;
  DWORD dwRet    = 0L;

  dwRet = RegCreateKeyEx(
            g_hkAppRoot,
            wszPath, 0,
            NULL, 0,
            KEY_ALL_ACCESS,
            NULL,
            &hKeyPath,
            NULL
            );

  if( dwRet == ERROR_SUCCESS )
  {
    bStatus = TRUE;
  }
  else
  {
    goto quit;
  }

  if( wszKeyName )
  {
    dwRet = RegCreateKeyEx(
              hKeyPath,
              wszKeyName, 0,
              NULL, 0,
              KEY_ALL_ACCESS,
              NULL,
              &hKeyNew,
              NULL
              );

    if( dwRet == ERROR_SUCCESS )
    {
      RegCloseKey(hKeyNew);
      bStatus = TRUE;
    }
    else
    {
      bStatus = FALSE;
    }
  }

  RegCloseKey(hKeyPath);

quit:

  return bStatus;
}


BOOL
SetRegValueInKey(
  LPCWSTR wszKeyName,
  LPCWSTR wszValueName,
  DWORD   dwType,
  LPVOID  pvData,
  DWORD   dwSize
  )
{
  HKEY  hKey    = NULL;
  BOOL  bStatus = FALSE;
  DWORD dwRet   = 0L;

  dwRet = RegOpenKeyEx(
            g_hkAppRoot,
            wszKeyName, 0,
            KEY_WRITE,
            &hKey
            );

  if( dwRet )
  {
    SetLastError(dwRet);
    return bStatus;
  }

  if( !dwSize && pvData )
  {
    if( dwType == REG_SZ )
    {
      dwSize = (wcslen((LPWSTR) pvData) * sizeof(WCHAR));
    }
    else if( dwType == REG_DWORD )
    {
      dwSize = sizeof(DWORD);
    }
    else
    {
      dwRet = ERROR_INVALID_PARAMETER;
      goto quit;
    }
  }

  dwRet = RegSetValueEx(
            hKey, wszValueName,
            0L, dwType,
            (LPBYTE) pvData, dwSize
            );

  if( dwRet )
  {
    SetLastError(dwRet);
    goto quit;
  }

  bStatus = TRUE;

quit:

  RegCloseKey(hKey);
  return bStatus;
}

/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

  ManageRootKey()

  WHAT      : Opens or closes the application's root regkey.

  ARGS      : fOpen - open or close the key.

  RETURNS   : True on success

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/
BOOL
ManageRootKey(
  BOOL fOpen
  )
{
  DWORD disp = 0;
  DWORD ret  = ERROR_SUCCESS;

  if( fOpen )
  {
    if( !g_hkAppRoot )
    {
      ret = RegCreateKeyEx(
              HKEY_CURRENT_USER,
              g_wszAppRootKeyName,
              0,
              NULL,
              REG_OPTION_NON_VOLATILE,
              KEY_ALL_ACCESS,
              NULL,
              &g_hkAppRoot,
              &disp
              );
    }
  }
  else
  {
    if( g_hkAppRoot )
    {
      RegCloseKey(g_hkAppRoot);
      g_hkAppRoot = NULL;
    }
  }

  return (ret == ERROR_SUCCESS) ? TRUE : FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\tools\spork\src\scrobj\iactivescriptsite.cxx ===
/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Copyright (c) 2001  Microsoft Corporation

Module Name:

    iactivescriptsite.cxx

Abstract:

    Implements the IActiveScriptSite interface for the ScriptObject class.
    
Author:

    Paul M Midgen (pmidge) 22-February-2001


Revision History:

    22-February-2001 pmidge
        Created

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/


#include <common.h>


//-----------------------------------------------------------------------------
// IActiveScriptSite
//-----------------------------------------------------------------------------
HRESULT
__stdcall
ScriptObject::GetLCID(
  LCID* plcid
  )
{
  HRESULT hr = S_OK;

    if( !plcid )
    {
      hr = E_POINTER;
    }
    else
    {
      *plcid = MAKELCID(
                 MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL),
                 SORT_DEFAULT
                 );
    }

  return hr;
}


HRESULT
__stdcall
ScriptObject::GetItemInfo(
  LPCOLESTR   pstrName,
  DWORD       dwReturnMask,
  IUnknown**  ppunk,
  ITypeInfo** ppti
  )
{
  HRESULT     hr  = S_OK;
  ITypeLib*   ptl = NULL;
  PCACHEENTRY pce = NULL;

  if( !pstrName )
  {
    hr = E_INVALIDARG;
    goto quit;
  }

  if( dwReturnMask & SCRIPTINFO_IUNKNOWN )
  {
    if( !_wcsicmp(pstrName, L"ScriptRuntime") )
    {
      hr = QueryInterface(IID_IUnknown, (void**) ppunk);
    }
    else
    {
      //
      // If the object the script engine is attempting to resolve isn't part of the
      // script runtime object, then we try to resolve the name with the object
      // cache.
      //

      //
      // first check for a globally cached instance...
      //
      hr = m_psi->pSpork->ObjectCache(
                            (LPWSTR) pstrName,
                            &pce,
                            RETRIEVE
                            );
      
      if( FAILED(hr) )
      {
        //
        // ...failing that, check for a per-script instance
        //
        LPWSTR name_decorated = __decorate((LPWSTR) pstrName, (DWORD_PTR) this);

        hr = m_psi->pSpork->ObjectCache(
                              name_decorated,
                              &pce,
                              RETRIEVE
                              );

        SAFEDELETEBUF(name_decorated);
      }

      if( pce )
      {
        pce->pDispObject->QueryInterface(IID_IUnknown, (void**) ppunk);
        pce->pDispObject->Release();
      }
      else
      {
        hr     = E_FAIL;
        *ppunk = NULL;
      }
    }
  }
  else if( dwReturnMask & SCRIPTINFO_ITYPEINFO )
  {
    //
    // BUGBUG: This could fail when we're asked to get type information for
    //         an object not exposed by Spork, e.g. named objects added via
    //         the 'createobject' method.
    //
    //         NOTE: The JS and VBS engines were tested and work fine for
    //               objects that don't expose event interfaces. Objects
    //               with events were not tested.
    //

    hr = m_psi->pSpork->GetTypeLib(&ptl);

    if( SUCCEEDED(hr) )
    {
      hr = GetTypeInfoFromName(pstrName, ptl, ppti);
      
      if( FAILED(hr) )
      {
        *ppti = NULL;
      }
    }
  }

quit:

  SAFERELEASE(ptl);
  return hr;
}


HRESULT
__stdcall
ScriptObject::GetDocVersionString(
  BSTR* pbstrVersion
  )
{
  return E_NOTIMPL;
}


HRESULT
__stdcall
ScriptObject::OnScriptTerminate(
  const VARIANT*   pvarResult,
  const EXCEPINFO* pei
  )
{
  return E_NOTIMPL;
}


HRESULT
__stdcall
ScriptObject::OnStateChange(
  SCRIPTSTATE ss
  )
{
  return E_NOTIMPL;
}


HRESULT
__stdcall
ScriptObject::OnScriptError(
  IActiveScriptError* piase
  )
{
  HRESULT   hr     = S_OK;
  DWORD     n      = 0L;
  DWORD     cookie = 0L;
  ULONG     line   = 0L;
  LONG      pos    = 0L;
  EXCEPINFO ex;

  piase->GetExceptionInfo(&ex);
  piase->GetSourcePosition(&cookie, &line, &pos);

  Alert(
    FALSE,
    L"A runtime error in script %s occurred.\r\n" \
    L"Check spork.log for more information.\r\n\r\n" \
    L"source\t: %s\r\n" \
    L"error\t: %s\r\n",
    m_wszScriptFile,
    STRING(ex.bstrSource),
    STRING(ex.bstrDescription)
    );

  LogTrace(L"********* SCRIPT ERROR *********");
  LogTrace(L" script : %s", m_wszScriptFile);
  LogTrace(L" cookie : %x", cookie);
  LogTrace(L" line # : %d", line);
  LogTrace(L" char # : %d", pos);
  LogTrace(L" source : %s", STRING(ex.bstrSource));
  LogTrace(L" error  : %s", STRING(ex.bstrDescription));
  LogTrace(L" hresult: 0x%0.8X", ex.scode);
  LogTrace(L"********************************");

  return hr;
}


HRESULT
__stdcall
ScriptObject::OnEnterScript(
  void
  )
{
  LogEnterFunction(L"SCRIPTCODE", rt_void, NULL);
  return E_NOTIMPL;
}


HRESULT
__stdcall
ScriptObject::OnLeaveScript(
  void
  )
{
  LogLeaveFunction(0);
  return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\tools\spork\src\scrobj\iactivescriptsitedebug.cxx ===
/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Copyright (c) 2001  Microsoft Corporation

Module Name:

    iactivescriptsitedebug.cxx

Abstract:

    Implements the IActiveScriptSiteDebug interface for the ScriptObject class.
    
Author:

    Paul M Midgen (pmidge) 20-April-2001


Revision History:

    20-April-2001 pmidge
        Created

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/


#include <common.h>


//-----------------------------------------------------------------------------
// ScriptObject script debugging methods
//-----------------------------------------------------------------------------
HRESULT
ScriptObject::_LoadScriptDebugger(void)
{
  HRESULT               hr   = S_OK;
  IProcessDebugManager* pdbm = NULL;

  if( !m_pDebugApplication )
  {
    hr = CoCreateInstance(
           CLSID_ProcessDebugManager,
           NULL,
           CLSCTX_INPROC_SERVER | CLSCTX_INPROC_HANDLER | CLSCTX_LOCAL_SERVER,
           IID_IProcessDebugManager,
           (void**) &pdbm
           );

    if( SUCCEEDED(hr) )
    {
      hr = pdbm->GetDefaultApplication(&m_pDebugApplication);

      if( SUCCEEDED(hr) )
      {
        hr = m_pDebugApplication->SetName(L"Spork");
      }
    }
  
    SAFERELEASE(pdbm);
  }

  return hr;
}


//-----------------------------------------------------------------------------
// IActiveScriptSiteDebug
//-----------------------------------------------------------------------------
HRESULT
__stdcall
ScriptObject::GetDocumentContextFromPosition(
  DWORD dwSourceContext,
  ULONG uCharacterOffset,
  ULONG uNumChars,
  IDebugDocumentContext** ppdc
  )
{
  return E_NOTIMPL;
}


HRESULT
__stdcall
ScriptObject::GetApplication(
  IDebugApplication** ppda
  )
{
  HRESULT hr = S_OK;

  if( m_DebugOptions.bEnableDebug )
  {
    *ppda = m_pDebugApplication;
    (*ppda)->AddRef();
  }
  else
  {
    *ppda = NULL;
    hr    = E_FAIL;
  }

  return hr;
}


HRESULT
__stdcall
ScriptObject::GetRootApplicationNode(
  IDebugApplicationNode** ppdan
  )
{
  return E_NOTIMPL;
}


HRESULT
__stdcall
ScriptObject::OnScriptErrorDebug(
  IActiveScriptErrorDebug* pErrorDebug,
  LPBOOL pfEnterDebugger,
  LPBOOL pfCallOnScriptErrorWhenContinuing
  )
{
  DEBUG_ENTER((
    L"ScriptObject::OnScriptErrorDebug",
    rt_hresult,
    L"this=%#x; pErrorDebug=%#x; pfEnterDebugger=%#x; pfCallOnScriptErrorWhenContinuing=%#x",
    this,
    pErrorDebug,
    pfEnterDebugger,
    pfCallOnScriptErrorWhenContinuing
    ));

  HRESULT             hr    = S_OK;
  IActiveScriptError* piase = NULL;

  if( m_DebugOptions.bEnableDebug )
  {
    LogTrace(L"launching script debugger");

    *pfEnterDebugger                   = TRUE;
    *pfCallOnScriptErrorWhenContinuing = FALSE;
  }
  else
  {
    hr = pErrorDebug->QueryInterface(IID_IActiveScriptError, (void**) &piase);

    DEBUG_TRACE((L"delegating to OnScriptError"));

    if( SUCCEEDED(hr) )
    {
      *pfEnterDebugger                   = FALSE;
      *pfCallOnScriptErrorWhenContinuing = FALSE;

      hr = OnScriptError(piase);

      SAFERELEASE(piase);
    }
    else
    {
      *pfEnterDebugger                   = FALSE;
      *pfCallOnScriptErrorWhenContinuing = TRUE;
    }
  }

  DEBUG_LEAVE(hr);
  return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\tools\spork\src\log\log.cxx ===
/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Copyright (c) 2001  Microsoft Corporation

Module Name:

    log.cxx

Abstract:

    Implementation of the session logging routines for Spork.
    
Author:

    Paul M Midgen (pmidge) 22-February-2001


Revision History:

    22-February-2001 pmidge
        Created

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/


#include "common.h"


//-----------------------------------------------------------------------------
// Logging variables
//-----------------------------------------------------------------------------
HANDLE     g_hLogFile     = INVALID_HANDLE_VALUE;
DWORD      g_dwTlsIndex   = 0L;
BOOL       g_bOutputToDbg = TRUE;
CRITSEC    g_csLogFile;


//-----------------------------------------------------------------------------
// Private
//-----------------------------------------------------------------------------
void         WriteToLog(LPTHREADINFO pti, BOOL fTrace, DEPTH depth, LPCWSTR format, ...);
LPTHREADINFO GetThreadInfo(void);
LPCALLINFO   PushCallInfo(LPTHREADINFO pti, LPCWSTR function, RETTYPE rt);
LPCALLINFO   PopCallInfo(LPTHREADINFO pti);
void         DeleteCallInfo(LPCALLINFO pci);
void         AcquireFileLock(void);
void         ReleaseFileLock(void);
LPWSTR       FormatCallReturnString(LPCALLINFO pci, INT_PTR retval);
LPWSTR       GetWhiteSpace(int spaces);
LPWSTR       GetTimeStamp(void);


//-----------------------------------------------------------------------------
// Logging functions
//-----------------------------------------------------------------------------
void
ToggleDebugOutput(
  BOOL bEnable
  )
{
  if( !bEnable )
  {
    LogTrace(L"debugger output disabled (specify -d to enable)");
  }

  g_bOutputToDbg = bEnable;
}


HRESULT
LogInitialize(void)
{
  HRESULT hr   = S_OK;
  LPWSTR  time = GetTimeStamp();

  if( (g_dwTlsIndex = TlsAlloc()) == 0xFFFFFFFF )
  {
    hr = E_FAIL;
    goto quit;
  }

  __try
  {
    InitializeCriticalSection(&g_csLogFile);
  }
  __except(EXCEPTION_EXECUTE_HANDLER)
  {
    hr = E_OUTOFMEMORY;
    goto quit;
  }

  g_hLogFile = CreateFile(
                 L"spork.log",
                 GENERIC_WRITE,
                 FILE_SHARE_READ,
                 NULL,
                 CREATE_ALWAYS,
                 FILE_ATTRIBUTE_NORMAL,
                 NULL
                 );
    
      if( !g_hLogFile )
      {
        hr = E_FAIL;
        goto quit;
      }

  WriteToLog(NULL, FALSE, MAINTAIN, L"Spork Session Log\r\n\r\nopened: %s\r\n", time);

quit:

  SAFEDELETEBUF(time);
  return hr;
}


void
LogTerminate(void)
{
  LPWSTR  time   = GetTimeStamp();
  LPDWORD pdepth = (LPDWORD) TlsGetValue(g_dwTlsIndex);

  WriteToLog(NULL, FALSE, MAINTAIN, L"\r\nclosed: %s", time);

  TlsFree(g_dwTlsIndex);
  DeleteCriticalSection(&g_csLogFile);
  SAFECLOSE(g_hLogFile);
  SAFEDELETE(pdepth);
  SAFEDELETEBUF(time);
}


void
LogEnterFunction(
  LPCWSTR function,
  RETTYPE rt,
  LPCWSTR format,
  ...
  )
{
  LPTHREADINFO pti = GetThreadInfo();

  PushCallInfo(pti, function, rt);

  if( format )
  {
    WCHAR   buf[1024];
    va_list arg_list;

    va_start(arg_list, format);

      wvnsprintf(buf, 1024, format, arg_list);
      WriteToLog(pti, FALSE, INCREMENT, L"%s(%s)", function, buf);

    va_end(arg_list);
  }
  else
  {
    WriteToLog(pti, FALSE, INCREMENT, L"%s()", function);
  }
}


void
LogLeaveFunction(
  INT_PTR retval
  )
{
  LPTHREADINFO pti = GetThreadInfo();
  LPCALLINFO   pci = PopCallInfo(pti);
  LPWSTR       buf = FormatCallReturnString(pci, retval);

  WriteToLog(pti, FALSE, DECREMENT, buf);
  DeleteCallInfo(pci);

  SAFEDELETEBUF(buf);
}


void
LogTrace(
  LPCWSTR format,
  ...
  )
{
  WCHAR   buf[1024];
  va_list arg_list;

  va_start(arg_list, format);

    wvnsprintf(buf, 1024, format, arg_list);
    WriteToLog(GetThreadInfo(), TRUE, MAINTAIN, buf);

  va_end(arg_list);
}


void
WriteToLog(
  LPTHREADINFO pti,
  BOOL         fTrace,
  DEPTH        depth,
  LPCWSTR      format,
  ...
  )
{
  LPSTR   ansi       = NULL;
  DWORD   offset     = 0;
  LPWSTR  tmp        = NULL;
  LPWSTR  buffer     = new WCHAR[2048];
  DWORD   call_depth = 0;
  va_list arg_list;

  if( !buffer )
    goto quit;

  //
  // pti will only be null in cases where WriteToLog is called directly. enter/leave/trace make
  // sure a pti has been allocated.
  //
  if( pti )
  {
    if( depth == INCREMENT )
    {
      ++pti->depth;
      call_depth = pti->depth;
    }
    else if( depth == DECREMENT )
    {
      call_depth = pti->depth;
      --pti->depth;
    }
    else
    {
      call_depth = pti->depth;
    }

    tmp     = GetTimeStamp();
    offset  = wnsprintf(buffer, 2048, L"%s ", tmp);
    SAFEDELETEBUF(tmp);

    offset += wnsprintf(buffer+offset, 2048-offset, L"%0.8x:%0.3d ", pti->threadid, call_depth);
    tmp     = GetWhiteSpace((fTrace ? call_depth+1 : call_depth));
    offset += wnsprintf(buffer+offset, 2048-offset, L"%s", tmp);
    SAFEDELETEBUF(tmp);
  }

  if( format )
  {
    va_start(arg_list, format);
    
      offset += wvnsprintf(buffer+offset, 2048-offset, format, arg_list);
      wnsprintf(buffer+offset, 2048-offset, L"\r\n");
    
    va_end(arg_list);
  }

  ansi   = __widetoansi(buffer);
  offset = 0;

  EnterCriticalSection(&g_csLogFile);
  
      WriteFile(
        g_hLogFile,
        ansi,
        strlen(ansi),
        &offset,
        NULL
        );

  LeaveCriticalSection(&g_csLogFile);

  SAFEDELETEBUF(ansi);

  if( g_bOutputToDbg )
  {
    OutputDebugString(buffer);
  }

quit:

  SAFEDELETEBUF(buffer);
}


LPTHREADINFO
GetThreadInfo(void)
{
  LPTHREADINFO pti = (LPTHREADINFO) TlsGetValue(g_dwTlsIndex);

    if( !pti )
    {
      pti = new THREADINFO;

      pti->threadid  = GetCurrentThreadId();
      pti->depth     = 0;
      pti->stack     = NULL;

      TlsSetValue(g_dwTlsIndex, (LPVOID) pti);
    }

  return pti;
}


LPCALLINFO
PushCallInfo(
  LPTHREADINFO pti,
  LPCWSTR      function,
  RETTYPE      rt
  )
{
  LPCALLINFO pci   = NULL;
  LPCALLINFO plast = NULL;

  for( pci = pti->stack; pci; pci = pci->next )
  {
    plast = pci;
  }

  if( !pci )
  {
    pci          = new CALLINFO;
    pci->fname   = StrDup(function);
    pci->rettype = rt;
    pci->last    = plast;
    pci->next    = NULL;

    if( !pti->stack )
    {
      pti->stack = pci;
    }
    else
    {
      plast->next = pci;
    }
  }

  return pci;
}


LPCALLINFO
PopCallInfo(
  LPTHREADINFO pti
  )
{
  LPCALLINFO pci = NULL;

  if( pti->stack )
  {
    for(pci = pti->stack; pci->next; pci = pci->next);
  }

  return pci;
}


void
DeleteCallInfo(
  LPCALLINFO pci
  )
{
  LPTHREADINFO pti = GetThreadInfo();

  if( pci->last )
  {
    pci->last->next = NULL;
  }
  else
  {
    // when the last record is gone, whack the threadinfo
    SAFEDELETE(pti);
    TlsSetValue(g_dwTlsIndex, NULL);
  }

  SAFEDELETEBUF(pci->fname);
  SAFEDELETE(pci);
}


LPWSTR
FormatCallReturnString(
  LPCALLINFO pci,
  INT_PTR    retval
  )
{
  LPWSTR buffer = new WCHAR[256];
  int    offset = 0;

  if( buffer )
  {
    offset = wnsprintf(buffer, 256, L"%s() returned ", pci->fname);

    switch( pci->rettype )
    {
      case rt_void :
        {
          wnsprintf(buffer+offset, 256-offset, L"<void>");
        }
        break;

      case rt_bool :
        {
          wnsprintf(buffer+offset, 256-offset, L"%s", TF(retval));
        }
        break;

      case rt_dword :
        {
          wnsprintf(buffer+offset, 256-offset, L"%d [%s]", retval, MapErrorToString(retval));
        }
        break;

      case rt_hresult :
        {
          wnsprintf(buffer+offset, 256-offset, L"%x [%s]", retval, MapHResultToString((HRESULT) retval));
        }
        break;

      case rt_string :
        {
          wnsprintf(buffer+offset, 256-offset, L"%.16s", (LPWSTR) retval);
        }
        break;

      default:
        {
          wnsprintf(buffer+offset, 256-offset, L"?");
        }
    }
  }

  return buffer;
}


//-----------------------------------------------------------------------------
// Utility functions
//-----------------------------------------------------------------------------
LPWSTR
GetWhiteSpace(
  int spaces
  )
{
  int    n   = 0;
  LPWSTR buf = new WCHAR[(spaces * 2) + 1];

  if( buf )
  {
    while(n<(spaces*2)) buf[n++] = L' ';
    buf[n] = L'\0';
  }

  return buf;
}


LPWSTR
GetTimeStamp(void)
{
  SYSTEMTIME st;
  LPWSTR     buf = new WCHAR[256];
  
  if( buf )
  {
    GetLocalTime(&st);

    wnsprintf(
      buf,
      256,
      L"%0.2d:%0.2d:%0.2d.%0.3d",
      st.wHour,
      st.wMinute,
      st.wSecond,
      st.wMilliseconds
      );
  }

  return buf;
}


//-----------------------------------------------------------------------------
// Mapping functions
//-----------------------------------------------------------------------------
LPWSTR
MapHResultToString(HRESULT hr)
{
  switch(hr)
  {
    CASE_OF(S_OK);
    CASE_OF(E_NOINTERFACE);
    CASE_OF(E_POINTER);
    CASE_OF(E_UNEXPECTED);
    CASE_OF(E_INVALIDARG);
    CASE_OF(E_OUTOFMEMORY);
    CASE_OF(E_FAIL);
    CASE_OF(E_NOTIMPL);
    CASE_OF(E_PENDING);
    CASE_OF(E_ACCESSDENIED);
    CASE_OF(CLASS_E_NOAGGREGATION);
    CASE_OF(TYPE_E_IOERROR);
    CASE_OF(TYPE_E_REGISTRYACCESS);
    CASE_OF(TYPE_E_INVALIDSTATE);
    CASE_OF(TYPE_E_BUFFERTOOSMALL);
    CASE_OF(TYPE_E_FIELDNOTFOUND);
    CASE_OF(TYPE_E_ELEMENTNOTFOUND);
    CASE_OF(TYPE_E_AMBIGUOUSNAME);
    CASE_OF(TYPE_E_UNKNOWNLCID);
    CASE_OF(TYPE_E_BADMODULEKIND);
    CASE_OF(TYPE_E_CANTLOADLIBRARY);
    CASE_OF(TYPE_E_INCONSISTENTPROPFUNCS);
    CASE_OF(CONNECT_E_NOCONNECTION);
    CASE_OF(CONNECT_E_ADVISELIMIT);
    CASE_OF(CO_E_OBJNOTREG);
    CASE_OF(DISP_E_BADPARAMCOUNT);
    CASE_OF(DISP_E_BADVARTYPE);
    CASE_OF(DISP_E_EXCEPTION);
    CASE_OF(DISP_E_MEMBERNOTFOUND);
    CASE_OF(DISP_E_NONAMEDARGS);
    CASE_OF(DISP_E_OVERFLOW);
    CASE_OF(DISP_E_PARAMNOTFOUND);
    CASE_OF(DISP_E_TYPEMISMATCH);
    CASE_OF(DISP_E_UNKNOWNINTERFACE);
    CASE_OF(DISP_E_UNKNOWNLCID);
    CASE_OF(DISP_E_PARAMNOTOPTIONAL);
    CASE_OF(DISP_E_UNKNOWNNAME);

    default : return L"?";
  }
}


LPWSTR
MapErrorToString(INT_PTR error)
{
  switch(error)
  {
    CASE_OF(ERROR_SUCCESS);
    CASE_OF(ERROR_INVALID_FUNCTION);
    CASE_OF(ERROR_FILE_NOT_FOUND);
    CASE_OF(ERROR_PATH_NOT_FOUND);
    CASE_OF(ERROR_TOO_MANY_OPEN_FILES);
    CASE_OF(ERROR_ACCESS_DENIED);
    CASE_OF(ERROR_INVALID_HANDLE);
    CASE_OF(ERROR_ARENA_TRASHED);
    CASE_OF(ERROR_NOT_ENOUGH_MEMORY);
    CASE_OF(ERROR_INVALID_BLOCK);
    CASE_OF(ERROR_BAD_ENVIRONMENT);
    CASE_OF(ERROR_BAD_FORMAT);
    CASE_OF(ERROR_INVALID_ACCESS);
    CASE_OF(ERROR_INVALID_DATA);
    CASE_OF(ERROR_OUTOFMEMORY);
    CASE_OF(ERROR_INVALID_DRIVE);
    CASE_OF(ERROR_CURRENT_DIRECTORY);
    CASE_OF(ERROR_NOT_SAME_DEVICE);
    CASE_OF(ERROR_NO_MORE_FILES);
    CASE_OF(ERROR_WRITE_PROTECT);
    CASE_OF(ERROR_BAD_UNIT);
    CASE_OF(ERROR_NOT_READY);
    CASE_OF(ERROR_BAD_COMMAND);
    CASE_OF(ERROR_CRC);
    CASE_OF(ERROR_BAD_LENGTH);
    CASE_OF(ERROR_SEEK);
    CASE_OF(ERROR_NOT_DOS_DISK);
    CASE_OF(ERROR_SECTOR_NOT_FOUND);
    CASE_OF(ERROR_OUT_OF_PAPER);
    CASE_OF(ERROR_WRITE_FAULT);
    CASE_OF(ERROR_READ_FAULT);
    CASE_OF(ERROR_GEN_FAILURE);
    CASE_OF(ERROR_SHARING_VIOLATION);
    CASE_OF(ERROR_LOCK_VIOLATION);
    CASE_OF(ERROR_WRONG_DISK);
    CASE_OF(ERROR_SHARING_BUFFER_EXCEEDED);
    CASE_OF(ERROR_HANDLE_EOF);
    CASE_OF(ERROR_HANDLE_DISK_FULL);
    CASE_OF(ERROR_NOT_SUPPORTED);
    CASE_OF(ERROR_REM_NOT_LIST);
    CASE_OF(ERROR_DUP_NAME);
    CASE_OF(ERROR_BAD_NETPATH);
    CASE_OF(ERROR_NETWORK_BUSY);
    CASE_OF(ERROR_DEV_NOT_EXIST);
    CASE_OF(ERROR_TOO_MANY_CMDS);
    CASE_OF(ERROR_ADAP_HDW_ERR);
    CASE_OF(ERROR_BAD_NET_RESP);
    CASE_OF(ERROR_UNEXP_NET_ERR);
    CASE_OF(ERROR_BAD_REM_ADAP);
    CASE_OF(ERROR_PRINTQ_FULL);
    CASE_OF(ERROR_NO_SPOOL_SPACE);
    CASE_OF(ERROR_PRINT_CANCELLED);
    CASE_OF(ERROR_NETNAME_DELETED);
    CASE_OF(ERROR_NETWORK_ACCESS_DENIED);
    CASE_OF(ERROR_BAD_DEV_TYPE);
    CASE_OF(ERROR_BAD_NET_NAME);
    CASE_OF(ERROR_TOO_MANY_NAMES);
    CASE_OF(ERROR_TOO_MANY_SESS);
    CASE_OF(ERROR_SHARING_PAUSED);
    CASE_OF(ERROR_REQ_NOT_ACCEP);
    CASE_OF(ERROR_REDIR_PAUSED);
    CASE_OF(ERROR_FILE_EXISTS);
    CASE_OF(ERROR_CANNOT_MAKE);
    CASE_OF(ERROR_FAIL_I24);
    CASE_OF(ERROR_OUT_OF_STRUCTURES);
    CASE_OF(ERROR_ALREADY_ASSIGNED);
    CASE_OF(ERROR_INVALID_PASSWORD);
    CASE_OF(ERROR_INVALID_PARAMETER);
    CASE_OF(ERROR_NET_WRITE_FAULT);
    CASE_OF(ERROR_NO_PROC_SLOTS);
    CASE_OF(ERROR_TOO_MANY_SEMAPHORES);
    CASE_OF(ERROR_EXCL_SEM_ALREADY_OWNED);
    CASE_OF(ERROR_SEM_IS_SET);
    CASE_OF(ERROR_TOO_MANY_SEM_REQUESTS);
    CASE_OF(ERROR_INVALID_AT_INTERRUPT_TIME);
    CASE_OF(ERROR_SEM_OWNER_DIED);
    CASE_OF(ERROR_SEM_USER_LIMIT);
    CASE_OF(ERROR_DISK_CHANGE);
    CASE_OF(ERROR_DRIVE_LOCKED);
    CASE_OF(ERROR_BROKEN_PIPE);
    CASE_OF(ERROR_OPEN_FAILED);
    CASE_OF(ERROR_BUFFER_OVERFLOW);
    CASE_OF(ERROR_DISK_FULL);
    CASE_OF(ERROR_NO_MORE_SEARCH_HANDLES);
    CASE_OF(ERROR_INVALID_TARGET_HANDLE);
    CASE_OF(ERROR_INVALID_CATEGORY);
    CASE_OF(ERROR_INVALID_VERIFY_SWITCH);
    CASE_OF(ERROR_BAD_DRIVER_LEVEL);
    CASE_OF(ERROR_CALL_NOT_IMPLEMENTED);
    CASE_OF(ERROR_SEM_TIMEOUT);
    CASE_OF(ERROR_INSUFFICIENT_BUFFER);
    CASE_OF(ERROR_INVALID_NAME);
    CASE_OF(ERROR_INVALID_LEVEL);
    CASE_OF(ERROR_NO_VOLUME_LABEL);
    CASE_OF(ERROR_MOD_NOT_FOUND);
    CASE_OF(ERROR_PROC_NOT_FOUND);
    CASE_OF(ERROR_WAIT_NO_CHILDREN);
    CASE_OF(ERROR_CHILD_NOT_COMPLETE);
    CASE_OF(ERROR_DIRECT_ACCESS_HANDLE);
    CASE_OF(ERROR_NEGATIVE_SEEK);
    CASE_OF(ERROR_SEEK_ON_DEVICE);
    CASE_OF(ERROR_DIR_NOT_ROOT);
    CASE_OF(ERROR_DIR_NOT_EMPTY);
    CASE_OF(ERROR_PATH_BUSY);
    CASE_OF(ERROR_SYSTEM_TRACE);
    CASE_OF(ERROR_INVALID_EVENT_COUNT);
    CASE_OF(ERROR_TOO_MANY_MUXWAITERS);
    CASE_OF(ERROR_INVALID_LIST_FORMAT);
    CASE_OF(ERROR_BAD_ARGUMENTS);
    CASE_OF(ERROR_BAD_PATHNAME);
    CASE_OF(ERROR_BUSY);
    CASE_OF(ERROR_CANCEL_VIOLATION);
    CASE_OF(ERROR_ALREADY_EXISTS);
    CASE_OF(ERROR_FILENAME_EXCED_RANGE);
    CASE_OF(ERROR_LOCKED);
    CASE_OF(ERROR_NESTING_NOT_ALLOWED);
    CASE_OF(ERROR_BAD_PIPE);
    CASE_OF(ERROR_PIPE_BUSY);
    CASE_OF(ERROR_NO_DATA);
    CASE_OF(ERROR_PIPE_NOT_CONNECTED);
    CASE_OF(ERROR_MORE_DATA);
    CASE_OF(ERROR_NO_MORE_ITEMS);
    CASE_OF(ERROR_NOT_OWNER);
    CASE_OF(ERROR_PARTIAL_COPY);
    CASE_OF(ERROR_MR_MID_NOT_FOUND);
    CASE_OF(ERROR_INVALID_ADDRESS);
    CASE_OF(ERROR_PIPE_CONNECTED);
    CASE_OF(ERROR_PIPE_LISTENING);
    CASE_OF(ERROR_OPERATION_ABORTED);
    CASE_OF(ERROR_IO_INCOMPLETE);
    CASE_OF(ERROR_IO_PENDING);
    CASE_OF(ERROR_NOACCESS);
    CASE_OF(ERROR_STACK_OVERFLOW);
    CASE_OF(ERROR_INVALID_FLAGS);
    CASE_OF(ERROR_NO_TOKEN);
    CASE_OF(ERROR_BADDB);
    CASE_OF(ERROR_BADKEY);
    CASE_OF(ERROR_CANTOPEN);
    CASE_OF(ERROR_CANTREAD);
    CASE_OF(ERROR_CANTWRITE);
    CASE_OF(ERROR_REGISTRY_RECOVERED);
    CASE_OF(ERROR_REGISTRY_CORRUPT);
    CASE_OF(ERROR_REGISTRY_IO_FAILED);
    CASE_OF(ERROR_NOT_REGISTRY_FILE);
    CASE_OF(ERROR_KEY_DELETED);
    CASE_OF(ERROR_CIRCULAR_DEPENDENCY);
    CASE_OF(ERROR_SERVICE_NOT_ACTIVE);
    CASE_OF(ERROR_DLL_INIT_FAILED);
    CASE_OF(ERROR_CANCELLED);
    CASE_OF(ERROR_BAD_USERNAME);
    CASE_OF(ERROR_LOGON_FAILURE);

    CASE_OF(WAIT_FAILED);
    CASE_OF(WAIT_TIMEOUT);
    CASE_OF(WAIT_IO_COMPLETION);

    CASE_OF(EXCEPTION_ACCESS_VIOLATION);
    CASE_OF(EXCEPTION_DATATYPE_MISALIGNMENT);
    CASE_OF(EXCEPTION_BREAKPOINT);
    CASE_OF(EXCEPTION_SINGLE_STEP);
    CASE_OF(EXCEPTION_ARRAY_BOUNDS_EXCEEDED);
    CASE_OF(EXCEPTION_FLT_DENORMAL_OPERAND);
    CASE_OF(EXCEPTION_FLT_DIVIDE_BY_ZERO);
    CASE_OF(EXCEPTION_FLT_INEXACT_RESULT);
    CASE_OF(EXCEPTION_FLT_INVALID_OPERATION);
    CASE_OF(EXCEPTION_FLT_OVERFLOW);
    CASE_OF(EXCEPTION_FLT_STACK_CHECK);
    CASE_OF(EXCEPTION_FLT_UNDERFLOW);
    CASE_OF(EXCEPTION_INT_DIVIDE_BY_ZERO);
    CASE_OF(EXCEPTION_INT_OVERFLOW);
    CASE_OF(EXCEPTION_PRIV_INSTRUCTION);
    CASE_OF(EXCEPTION_IN_PAGE_ERROR);
    CASE_OF(EXCEPTION_ILLEGAL_INSTRUCTION);
    CASE_OF(EXCEPTION_NONCONTINUABLE_EXCEPTION);
    CASE_OF(EXCEPTION_STACK_OVERFLOW);
    CASE_OF(EXCEPTION_INVALID_DISPOSITION);
    CASE_OF(EXCEPTION_GUARD_PAGE);
    CASE_OF(EXCEPTION_INVALID_HANDLE);

    CASE_OF(RPC_S_INVALID_STRING_BINDING);
    CASE_OF(RPC_S_WRONG_KIND_OF_BINDING);
    CASE_OF(RPC_S_INVALID_BINDING);
    CASE_OF(RPC_S_PROTSEQ_NOT_SUPPORTED);
    CASE_OF(RPC_S_INVALID_RPC_PROTSEQ);
    CASE_OF(RPC_S_INVALID_STRING_UUID);
    CASE_OF(RPC_S_INVALID_ENDPOINT_FORMAT);
    CASE_OF(RPC_S_INVALID_NET_ADDR);
    CASE_OF(RPC_S_NO_ENDPOINT_FOUND);
    CASE_OF(RPC_S_INVALID_TIMEOUT);
    CASE_OF(RPC_S_OBJECT_NOT_FOUND);
    CASE_OF(RPC_S_ALREADY_REGISTERED);
    CASE_OF(RPC_S_TYPE_ALREADY_REGISTERED);
    CASE_OF(RPC_S_ALREADY_LISTENING);
    CASE_OF(RPC_S_NO_PROTSEQS_REGISTERED);
    CASE_OF(RPC_S_NOT_LISTENING);
    CASE_OF(RPC_S_UNKNOWN_MGR_TYPE);
    CASE_OF(RPC_S_UNKNOWN_IF);
    CASE_OF(RPC_S_NO_BINDINGS);
    CASE_OF(RPC_S_NO_PROTSEQS);
    CASE_OF(RPC_S_CANT_CREATE_ENDPOINT);
    CASE_OF(RPC_S_OUT_OF_RESOURCES);
    CASE_OF(RPC_S_SERVER_UNAVAILABLE);
    CASE_OF(RPC_S_SERVER_TOO_BUSY);
    CASE_OF(RPC_S_INVALID_NETWORK_OPTIONS);
    CASE_OF(RPC_S_NO_CALL_ACTIVE);
    CASE_OF(RPC_S_CALL_FAILED);
    CASE_OF(RPC_S_CALL_FAILED_DNE);
    CASE_OF(RPC_S_PROTOCOL_ERROR);
    CASE_OF(RPC_S_UNSUPPORTED_TRANS_SYN);
    CASE_OF(RPC_S_UNSUPPORTED_TYPE);
    CASE_OF(RPC_S_INVALID_TAG);
    CASE_OF(RPC_S_INVALID_BOUND);
    CASE_OF(RPC_S_NO_ENTRY_NAME);
    CASE_OF(RPC_S_INVALID_NAME_SYNTAX);
    CASE_OF(RPC_S_UNSUPPORTED_NAME_SYNTAX);
    CASE_OF(RPC_S_UUID_NO_ADDRESS);
    CASE_OF(RPC_S_DUPLICATE_ENDPOINT);
    CASE_OF(RPC_S_UNKNOWN_AUTHN_TYPE);
    CASE_OF(RPC_S_MAX_CALLS_TOO_SMALL);
    CASE_OF(RPC_S_STRING_TOO_LONG);
    CASE_OF(RPC_S_PROTSEQ_NOT_FOUND);
    CASE_OF(RPC_S_PROCNUM_OUT_OF_RANGE);
    CASE_OF(RPC_S_BINDING_HAS_NO_AUTH);
    CASE_OF(RPC_S_UNKNOWN_AUTHN_SERVICE);
    CASE_OF(RPC_S_UNKNOWN_AUTHN_LEVEL);
    CASE_OF(RPC_S_INVALID_AUTH_IDENTITY);
    CASE_OF(RPC_S_UNKNOWN_AUTHZ_SERVICE);
    CASE_OF(EPT_S_INVALID_ENTRY);
    CASE_OF(EPT_S_CANT_PERFORM_OP);
    CASE_OF(EPT_S_NOT_REGISTERED);
    CASE_OF(RPC_S_NOTHING_TO_EXPORT);
    CASE_OF(RPC_S_INCOMPLETE_NAME);
    CASE_OF(RPC_S_INVALID_VERS_OPTION);
    CASE_OF(RPC_S_NO_MORE_MEMBERS);
    CASE_OF(RPC_S_NOT_ALL_OBJS_UNEXPORTED);
    CASE_OF(RPC_S_INTERFACE_NOT_FOUND);
    CASE_OF(RPC_S_ENTRY_ALREADY_EXISTS);
    CASE_OF(RPC_S_ENTRY_NOT_FOUND);
    CASE_OF(RPC_S_NAME_SERVICE_UNAVAILABLE);
    CASE_OF(RPC_S_INVALID_NAF_ID);
    CASE_OF(RPC_S_CANNOT_SUPPORT);
    CASE_OF(RPC_S_NO_CONTEXT_AVAILABLE);
    CASE_OF(RPC_S_INTERNAL_ERROR);
    CASE_OF(RPC_S_ZERO_DIVIDE);
    CASE_OF(RPC_S_ADDRESS_ERROR);
    CASE_OF(RPC_S_FP_DIV_ZERO);
    CASE_OF(RPC_S_FP_UNDERFLOW);
    CASE_OF(RPC_S_FP_OVERFLOW);
    CASE_OF(RPC_X_NO_MORE_ENTRIES);
    CASE_OF(RPC_X_SS_CHAR_TRANS_OPEN_FAIL);
    CASE_OF(RPC_X_SS_CHAR_TRANS_SHORT_FILE);
    CASE_OF(RPC_X_SS_IN_NULL_CONTEXT);
    CASE_OF(RPC_X_SS_CONTEXT_DAMAGED);
    CASE_OF(RPC_X_SS_HANDLES_MISMATCH);
    CASE_OF(RPC_X_SS_CANNOT_GET_CALL_HANDLE);
    CASE_OF(RPC_X_NULL_REF_POINTER);
    CASE_OF(RPC_X_ENUM_VALUE_OUT_OF_RANGE);
    CASE_OF(RPC_X_BYTE_COUNT_TOO_SMALL);
    CASE_OF(RPC_X_BAD_STUB_DATA);

    CASE_OF(WSAEINTR);
    CASE_OF(WSAEBADF);
    CASE_OF(WSAEACCES);
    CASE_OF(WSAEFAULT);
    CASE_OF(WSAEINVAL);
    CASE_OF(WSAEMFILE);
    CASE_OF(WSAEWOULDBLOCK);
    CASE_OF(WSAEINPROGRESS);
    CASE_OF(WSAEALREADY);
    CASE_OF(WSAENOTSOCK);
    CASE_OF(WSAEDESTADDRREQ);
    CASE_OF(WSAEMSGSIZE);
    CASE_OF(WSAEPROTOTYPE);
    CASE_OF(WSAENOPROTOOPT);
    CASE_OF(WSAEPROTONOSUPPORT);
    CASE_OF(WSAESOCKTNOSUPPORT);
    CASE_OF(WSAEOPNOTSUPP);
    CASE_OF(WSAEPFNOSUPPORT);
    CASE_OF(WSAEAFNOSUPPORT);
    CASE_OF(WSAEADDRINUSE);
    CASE_OF(WSAEADDRNOTAVAIL);
    CASE_OF(WSAENETDOWN);
    CASE_OF(WSAENETUNREACH);
    CASE_OF(WSAENETRESET);
    CASE_OF(WSAECONNABORTED);
    CASE_OF(WSAECONNRESET);
    CASE_OF(WSAENOBUFS);
    CASE_OF(WSAEISCONN);
    CASE_OF(WSAENOTCONN);
    CASE_OF(WSAESHUTDOWN);
    CASE_OF(WSAETOOMANYREFS);
    CASE_OF(WSAETIMEDOUT);
    CASE_OF(WSAECONNREFUSED);
    CASE_OF(WSAELOOP);
    CASE_OF(WSAENAMETOOLONG);
    CASE_OF(WSAEHOSTDOWN);
    CASE_OF(WSAEHOSTUNREACH);
    CASE_OF(WSAENOTEMPTY);
    CASE_OF(WSAEPROCLIM);
    CASE_OF(WSAEUSERS);
    CASE_OF(WSAEDQUOT);
    CASE_OF(WSAESTALE);
    CASE_OF(WSAEREMOTE);
    CASE_OF(WSAEDISCON);
    CASE_OF(WSASYSNOTREADY);
    CASE_OF(WSAVERNOTSUPPORTED);
    CASE_OF(WSANOTINITIALISED);
    CASE_OF(WSAHOST_NOT_FOUND);
    CASE_OF(WSATRY_AGAIN);
    CASE_OF(WSANO_RECOVERY);
    CASE_OF(WSANO_DATA);

    CASE_OF(ERROR_FAILURE);
    CASE_OF(ERROR_INVALID_STATE);

    default : return L"?";
  }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\tools\spork\src\common\utils.cxx ===
/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Copyright (c) 2001  Microsoft Corporation

Module Name:

    utils.cxx

Abstract:

    Utility functions used by the project.
    
Author:

    Paul M Midgen (pmidge) 22-February-2001


Revision History:

    22-February-2001 pmidge
        Created

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/


#include <common.h>


//-----------------------------------------------------------------------------
// new & delete
//-----------------------------------------------------------------------------
void* __cdecl operator new(size_t size)
{
  return (void*) LocalAlloc(
#ifdef NO_ZEROINIT
    NONZEROLPTR,
#else
    LPTR,
#endif
    size);
}

void __cdecl operator delete(void* pv)
{
  LocalFree(pv);
}


//-----------------------------------------------------------------------------
// platform checking
//-----------------------------------------------------------------------------
BOOL
IsRunningOnNT(void)
{
  OSVERSIONINFO osvi = {0};

  osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);

  if( GetVersionEx(&osvi) )
  {
    if( osvi.dwPlatformId == VER_PLATFORM_WIN32_NT )
    {
      return TRUE;
    }
  }
    
  return FALSE;
}


//-----------------------------------------------------------------------------
// user interface
//-----------------------------------------------------------------------------
LRESULT
ListBox_GetItemCount(HWND hwndLB)
{
  return SendMessage(hwndLB, LB_GETCOUNT, (WPARAM) 0L, (LPARAM) 0L);
}

void
ListBox_ResetContent(HWND hwndLB)
{
  SendMessage(hwndLB, LB_RESETCONTENT, (WPARAM) 0L, (LPARAM) 0L);
}

BOOL
ListBox_InsertString(HWND hwndLB, INT_PTR iItem, LPWSTR wszString)
{
  LRESULT retval = SendMessage(hwndLB, LB_INSERTSTRING, (WPARAM) iItem, (LPARAM) wszString);

  return ((retval != LB_ERR) && (retval != LB_ERRSPACE));
}

LRESULT
ListBox_GetSelectionIndex(HWND hwndLB)
{
  return SendMessage(
           hwndLB,
           LB_GETCARETINDEX,
           (WPARAM) 0L,
           (LPARAM) 0L
           );
}

LPWSTR
ListBox_GetSelectionText(HWND hwndLB)
{
  DWORD_PTR  iItem = 0L;
  DWORD_PTR  cb    = 0L;
  LPWSTR     wsz   = NULL;

  iItem = ListBox_GetSelectionIndex(hwndLB);  

  if( LB_ERR != (cb = SendMessage(hwndLB, LB_GETTEXTLEN, iItem, (LPARAM) 0L)) )
  {
    if( (wsz = new WCHAR[cb+1]) )
    {
      if( LB_ERR == SendMessage(hwndLB, LB_GETTEXT, iItem, (LPARAM) wsz) )
      {
        SAFEDELETEBUF(wsz);
      }
    }
  }

  return wsz;
}

LPWSTR
ListBox_GetItemText(HWND hwndLB, INT_PTR iItem)
{
  DWORD_PTR  cb  = 0L;
  LPWSTR     wsz = NULL;

  if( LB_ERR != (cb = SendMessage(hwndLB, LB_GETTEXTLEN, iItem, (LPARAM) 0L)) )
  {
    if( (wsz = new WCHAR[cb+1]) )
    {
      if( LB_ERR == SendMessage(hwndLB, LB_GETTEXT, iItem, (LPARAM) wsz) )
      {
        SAFEDELETEBUF(wsz);
      }
    }
  }

  return wsz;
}

LPVOID
ListBox_GetItemData(HWND hwndLB, INT_PTR iItem)
{
  return (LPVOID) SendMessage(hwndLB, LB_GETITEMDATA, iItem, (LPARAM) 0L);
}

BOOL
ListBox_SetItemData(HWND hwndLB, INT_PTR iItem, LPVOID pvData)
{
  return (SendMessage(hwndLB, LB_SETITEMDATA, iItem, (LPARAM) pvData) != LB_ERR);
}

BOOL
ListBox_SetCurrentSelection(HWND hwndLB, INT_PTR iItem)
{
  return (SendMessage(hwndLB, LB_SETCURSEL, (WPARAM) iItem, (LPARAM) 0L) != LB_ERR);
}

//-----------------------------------------------------------------------------
// general utility functions
//-----------------------------------------------------------------------------
void
Alert(BOOL bFatal, LPCWSTR format, ...)
{
  if( !GlobalIsSilentModeEnabled() )
  {
    DWORD   offset = 0L;
    WCHAR   buffer[2048];
    va_list arg_list;

    va_start(arg_list, format);

      offset = wvnsprintf(buffer, 2048, format, arg_list);

    va_end(arg_list);

    MessageBoxEx(
      NULL,
      buffer,
      L"Spork",
      MB_OK | \
      (bFatal ? MB_ICONSTOP : MB_ICONEXCLAMATION) | \
      MB_TASKMODAL,
      MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL)
      );
  }
}

HRESULT
GetTypeInfoFromName(LPCOLESTR name, ITypeLib* ptl, ITypeInfo** ppti)
{
  HRESULT  hr     = S_OK;
  BOOL     bFound = FALSE;
  USHORT   cf     = 1L;
  ULONG    hash   = 0L;
  LONG     id     = 0L;
  LPOLESTR pstr   = NULL;

  if( !name || ! ptl )
  {
    hr = E_INVALIDARG;
    goto quit;
  }

  if( !ppti )
  {
    hr = E_POINTER;
    goto quit;
  }

  *ppti = NULL;
  pstr  = StrDup(name);

    ptl->IsName(pstr, 0L, &bFound);

      if( !bFound )
      {
        hr = TYPE_E_ELEMENTNOTFOUND;
        goto quit;
      }

    hash = LHashValOfNameSys(
             SYS_WIN32,
             MAKELCID(MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL), SORT_DEFAULT),
             pstr
             );

    hr = ptl->FindName(pstr, hash, ppti, &id, &cf);

quit:

  SAFEDELETEBUF(pstr);
  return hr;
}

DISPID
GetDispidFromName(PDISPIDTABLEENTRY pdt, DWORD cEntries, LPWSTR name)
{
  DWORD  n      = 0L;
  DWORD  hash   = GetHash(name);
  DISPID dispid = DISPID_UNKNOWN;

  while( n < cEntries )
  {
    if( pdt[n].hash != hash )
    {
      ++n;
    }
    else
    {
      dispid = pdt[n].dispid;
      break;
    }
  }

  return dispid;
}

void
AddRichErrorInfo(EXCEPINFO* pei, LPWSTR source, LPWSTR description, HRESULT error)
{
  if( pei )
  {
    pei->bstrSource      = __widetobstr((source ? source : L"unknown source"));
    pei->bstrDescription = __widetobstr((description ? description : L"no description"));
    pei->scode           = error;
  }
}

DWORD
GetHash(LPWSTR name)
{
  DWORD hash   = 0L;
  DWORD n      = 0L;
  DWORD len    = 0L;
  LPSTR string = NULL;

  string = __widetoansi(name);

  if( string )
  {
    _strlwr(string);

    for(n=0, len=strlen(string); n<=len; n++)
    {
      hash += __toascii(string[len-n]) * ((10<<n)^n);
    }
  }

  SAFEDELETEBUF(string);
  return hash;
}

HRESULT
DispGetOptionalParam(DISPPARAMS* pdp, UINT pos, VARTYPE vt, VARIANT* pvr, UINT* pae)
{
  HRESULT hr = DispGetParam(pdp, pos, vt, pvr, pae);

  //
  // if DispGetParam failed due to a type mismatch, it was likely deliberate on
  // the part of the dispatch code. i pass in VT_VARIANT when i have no idea
  // what the controller is sending me, all i know is that i need a copy, maybe.
  //
  if( hr == DISP_E_TYPEMISMATCH )
  {
    hr = VariantCopy(pvr, &pdp->rgvarg[((pdp->cArgs-1)-pos)]);
  }

  return (hr == DISP_E_PARAMNOTFOUND) ? S_OK : hr;
}

HRESULT
ValidateDispatchArgs(REFIID riid, DISPPARAMS* pdp, VARIANT* pvr, UINT* pae)
{
  HRESULT hr = S_OK;

    if( !IsEqualIID(riid, IID_NULL) )
    {
      hr = DISP_E_UNKNOWNINTERFACE;
      goto quit;
    }

    if( !pdp )
    {
      hr = E_INVALIDARG;
      goto quit;
    }

    if( pae )
    {
      *pae = 0;
    }

    if( pvr )
    {
      VariantInit(pvr);
    }

quit:

  return hr;
}

HRESULT
ValidateInvokeFlags(WORD flags, WORD accesstype, BOOL bMethod)
{
  HRESULT hr = S_OK;

    if( (flags & ~(DISPATCH_METHOD | DISPATCH_PROPERTYGET | DISPATCH_PROPERTYPUT)) )
    {
      hr = E_INVALIDARG;
    }
    else
    {
      if( !bMethod )
      {
        if( flags & DISPATCH_METHOD )
        {
          hr = E_NOINTERFACE;
        }
        else
        {
          if( (flags & DISPATCH_PROPERTYPUT) && !(accesstype & DISPATCH_PROPERTYPUT) )
          {
            hr = E_ACCESSDENIED;
          }
          else
          {
            if( !(flags & accesstype) )
            {
              hr = E_FAIL;
            }
          }
        }
      }
      else
      {
        if( flags & ~(DISPATCH_METHOD | DISPATCH_PROPERTYGET) )
        {
          hr = E_NOINTERFACE;
        }
      }
    }

  return hr;
}

HRESULT
ValidateArgCount(DISPPARAMS* pdp, DWORD needed, BOOL bHasOptionalArgs, DWORD optional)
{
  HRESULT hr = S_OK;

    if( bHasOptionalArgs )
    {
      if( (pdp->cArgs > needed+optional) || (pdp->cArgs < needed) )
      {
        hr = DISP_E_BADPARAMCOUNT;
      }
    }
    else
    {
      if( (!needed && pdp->cArgs) || (needed < pdp->cArgs) )
      {
        hr = DISP_E_BADPARAMCOUNT;
      }
      else
      {
        hr = (pdp->cArgs == needed) ? S_OK : DISP_E_PARAMNOTOPTIONAL;
      }
    }

  return hr;
}

HRESULT
HandleDispatchError(LPWSTR id, EXCEPINFO* pei, HRESULT hr)
{
  LPWSTR msg = NULL;

  switch( hr )
  {
    case E_POINTER      : msg = L"a return pointer parameter was missing";                         break;
    case E_ACCESSDENIED : msg = L"an attempt to modify a property failed because it is read-only"; break;
    case E_FAIL         : msg = L"an unhandled error occurred";                                    break;
    case E_INVALIDARG   : msg = L"an argument passed to a property or method was invalid";         break;
    case E_NOINTERFACE  : msg = L"a property or method was accessed incorrectly";                  break;
    default             : return hr;
  }

  AddRichErrorInfo(pei, id, msg, hr);

  return DISP_E_EXCEPTION;
}

//-----------------------------------------------------------------------------
// string & type manipulation
//-----------------------------------------------------------------------------
WCHAR*
__ansitowide(const char* psz)
{
  WCHAR* wide = NULL;
  int    len  = 0L;

  if( psz )
  {
    len = strlen(psz);

    if( len )
    {
      wide      = new WCHAR[len+1];
      wide[len] = L'\0';

      MultiByteToWideChar(
        CP_ACP, 0,
        psz,  len,
        wide, len
        );
    }
  }

  return wide;
}

CHAR*
__widetoansi(const WCHAR* pwsz)
{
  CHAR* ansi = NULL;
  int   len  = 0L;
  BOOL  def  = FALSE;

  if( pwsz )
  {
    len = wcslen(pwsz);

    if( len )
    {
      ansi      = new CHAR[len+1];
      ansi[len] = '\0';

      WideCharToMultiByte(
        CP_ACP, 0,
        pwsz, len,
        ansi, len,
        "?", &def
        );
    }
  }

  return ansi;
}

BSTR
__ansitobstr(LPCSTR src)
{
  BSTR   ret = NULL;
  LPWSTR wsz = NULL;

  if( src )
  {
    wsz = __ansitowide(src);
    ret = SysAllocString(wsz);
    SAFEDELETEBUF(wsz);
  }

  return ret;
}

BSTR
__widetobstr(LPCWSTR wsrc)
{
  return (wsrc ? SysAllocString(wsrc) : NULL);
}

BOOL
__isempty(VARIANT* var)
{
  BOOL isempty = FALSE;

  if( var )
  {
    if(
        ((V_VT(var) == VT_EMPTY) || (V_VT(var) == VT_NULL) || (V_VT(var) == VT_ERROR)) ||
        ((V_VT(var) == VT_BSTR) && (SysStringLen(V_BSTR(var)) == 0))
      )
    {
      isempty = TRUE;
    }
  }
  else
  {
    isempty = TRUE;
  }

  return isempty;
}

BOOL
__mangle(LPWSTR src, LPWSTR* ppdest)
{
  BOOL   bMangled = FALSE;
  LPWSTR wszDot   = NULL;

  if( src && ppdest )
  {
    *ppdest = StrDup(src);

    while( wszDot = StrChr(*ppdest, L'.') )
    {
      *wszDot = L'_';
    }

    bMangled = TRUE;
  }

  return bMangled;
}

LPWSTR
__decorate(LPWSTR src, DWORD_PTR decor)
{
  WCHAR  buf[32];
  LPWSTR decorated = NULL;

  if( src )
  {
    memset(buf, 0, 32);
    ITOW(decor, buf, 16);
    decorated = new WCHAR[wcslen(src)+wcslen(buf)+1];

    if( decorated )
    {
      StrCpy(decorated, src);
      StrCat(decorated, buf);
    }
  }

  return decorated;
}


//-----------------------------------------------------------------------------
// user input dialog
//-----------------------------------------------------------------------------
INT_PTR GetUserInputProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);


INT_PTR
GetUserInput(HINSTANCE Instance, HWND Parent, LPCWSTR DialogTitle)
{
  return DialogBoxParam(Instance, MAKEINTRESOURCE(IDD_USERINPUT), Parent, GetUserInputProc, (LPARAM) DialogTitle);
}


INT_PTR
GetUserInputProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam) 
{
  switch( uMsg )
  {
    case WM_INITDIALOG :
      {
        SetWindowText(hwnd, (LPWSTR) lParam);
        SetFocus(GetDlgItem(hwnd, IDC_EDIT));
      }
      return 0L;

    case WM_COMMAND :
      {
        switch( LOWORD(wParam) )
        {
          case IDOK :
            {
              HWND   edit = GetDlgItem(hwnd, IDC_EDIT);
              WORD   cb   = 0L;
              LPWSTR text = NULL;

              if( SendMessage(edit, EM_GETMODIFY, (WPARAM) 0L, (LPARAM) 0L) )
              {
                cb   = (WORD) SendMessage(edit, EM_GETLIMITTEXT, (WPARAM) 0L, (LPARAM) 0L);
                text = new WCHAR[cb];

                if( text )
                {
                  *text = cb;
                  SendMessage(edit, EM_GETLINE, (WPARAM) 0L, (LPARAM) text);
                }
              }

              EndDialog(hwnd, (INT_PTR) text);
            }
            break;

          case IDCANCEL :
            {
              EndDialog(hwnd, 0);
            }
            break;
        }
      }
      break;

    default : return 0L;
  }

  return 0L;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\tools\spork\src\scrobj\scrobj.cxx ===
/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Copyright (c) 2001  Microsoft Corporation

Module Name:

   scrobj.cxx

Abstract:

    Implementation of the ScriptObject class member functions.
    
Author:

    Paul M Midgen (pmidge) 22-February-2001


Revision History:

    22-February-2001 pmidge
        Created

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/


#include <common.h>


//-----------------------------------------------------------------------------
// Class members
//-----------------------------------------------------------------------------
ScriptObject::ScriptObject():
  m_cRefs(1),
  m_psi(NULL),
  m_wszScriptFile(NULL),
  m_pDebugApplication(NULL),
  m_pScriptEngine(NULL),
  m_htThis(NULL)
{
  DEBUG_TRACE((L"ScriptObject [%#x] created", this));
}


ScriptObject::~ScriptObject()
{
  SAFEDELETEBUF(m_wszScriptFile);
  SAFERELEASE(m_pDebugApplication);
  SAFERELEASE(m_pScriptEngine);

  DEBUG_TRACE((L"ScriptObject [%#x] deleted", this));
}


HRESULT
ScriptObject::Create(
  PSCRIPTINFO psi,
  PSCRIPTOBJ* ppscrobj
  )
{
  HRESULT    hr      = S_OK;
  PSCRIPTOBJ pscrobj = NULL;

  if( !psi )
  {
    hr = E_INVALIDARG;
    goto quit;
  }

  if( !ppscrobj )
  {
    hr = E_POINTER;
    goto quit;
  }

  if( (pscrobj = new SCRIPTOBJ) )
  {
    hr = pscrobj->_Initialize(psi);

    if( SUCCEEDED(hr) )
    {
      *ppscrobj = pscrobj;
    }
    else
    {
      *ppscrobj = NULL;
      pscrobj->Release();

      //SAFEDELETE(pscrobj);
    }
  }
  else
  {
    hr = E_OUTOFMEMORY;
  }

quit:

  return hr;
}


HRESULT
ScriptObject::_Initialize(
  PSCRIPTINFO psi
  )
{
  HRESULT             hr        = S_OK;
  LPWSTR              wszScript = NULL;
  IActiveScriptParse* parse     = NULL;
  EXCEPINFO           excepinfo = {0};

  m_psi           = psi;
  m_wszScriptFile = StrDup(m_psi->wszScriptFile);
  wszScript       = _LoadScript();

    if( wszScript )
    {
      m_psi->pSpork->GetProfileDebugOptions(&m_DebugOptions);

      if( m_DebugOptions.bEnableDebug )
      {
        hr = _LoadScriptDebugger();
        
        if( SUCCEEDED(hr) )
        {
          if( m_DebugOptions.bBreakOnScriptStart )
          {
            m_pDebugApplication->CauseBreak();
          }
        }
      }

      hr = m_psi->pSpork->GetScriptEngine(_GetScriptType(), &m_pScriptEngine);

        if( FAILED(hr) )
          goto quit;

      hr = m_pScriptEngine->QueryInterface(IID_IActiveScriptParse, (void**) &parse);

        if( FAILED(hr) )
          goto quit;

      hr = parse->InitNew();

        if( FAILED(hr) )
          goto quit;

      hr = m_pScriptEngine->SetScriptSite(dynamic_cast<IActiveScriptSite*>(this));

        if( FAILED(hr) )
          goto quit;

      hr = m_pScriptEngine->AddNamedItem(
                              L"ScriptRuntime",
                              SCRIPTITEM_ISPERSISTENT | SCRIPTITEM_ISVISIBLE | SCRIPTITEM_GLOBALMEMBERS
                              );

        if( FAILED(hr) )
          goto quit;

      hr = parse->ParseScriptText(
                    wszScript,
                    NULL,
                    NULL,
                    NULL,
                    (DWORD) ((DWORD_PTR) this), // IA64: this is just a cookie value, we never use the pointer
                    0,
                    SCRIPTTEXT_ISPERSISTENT | SCRIPTTEXT_ISVISIBLE,
                    NULL,
                    &excepinfo
                    );

        if( FAILED(hr) )
        {
          m_pScriptEngine->Close();
          goto quit;
        }

      hr = m_pScriptEngine->SetScriptState(SCRIPTSTATE_STARTED);
    }
    else
    {
      hr = E_FAIL;
    }

quit:

  if( SUCCEEDED(hr) )
  {
    m_psi->pSpork->NotifyUI(
                     TRUE,
                     m_wszScriptFile,
                     this,
                     m_psi->htParent,
                     &m_htThis
                     );
  }

  SAFERELEASE(parse);
  SAFEDELETEBUF(wszScript);

  return hr;
}


HRESULT
ScriptObject::Run(void)
{
  HRESULT    hr         = S_OK;
  IDispatch* psd        = NULL;
  DISPID     testid     = 0L;
  LPWSTR     entrypoint = NULL;
  UINT       argerr     = 0L;
  EXCEPINFO  ei         = {0};
  DISPPARAMS dp         = {0};

  hr = m_pScriptEngine->GetScriptDispatch(NULL, &psd);

  if( SUCCEEDED(hr) )
  {
    entrypoint = (m_psi->bIsFork ? L"SPORK_OnCreateFork" : L"SPORK_Main");

    hr = psd->GetIDsOfNames(
                IID_NULL,
                &entrypoint, 1,
                MAKELCID(MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL), SORT_DEFAULT),
                &testid
                );

    if( SUCCEEDED(hr) )
    {
      if( m_psi->bIsFork )
      {
        dp.cArgs          = 1;
        dp.rgvarg         = new VARIANT;
        V_VT(dp.rgvarg)   = VT_BSTR;
        V_BSTR(dp.rgvarg) = m_psi->bstrChildParams;
      }

        hr = psd->Invoke(
                    testid,
                    IID_NULL,
                    MAKELCID(MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL), SORT_DEFAULT),
                    DISPATCH_METHOD,
                    &dp,
                    NULL,
                    &ei,
                    &argerr
                    );

      if( FAILED(hr) )
      {
        LogTrace(L"error invoking %s: %s", entrypoint, MapHResultToString(hr));
      }

      SAFEDELETE(dp.rgvarg);
    }
    else
    {
      LogTrace(L"%s not present, cannot run script", entrypoint);
    }

    SAFERELEASE(psd);
  }
  
  return hr;
}


HRESULT
ScriptObject::Terminate(void)
{
  HRESULT hr = S_OK;

    hr = m_pScriptEngine->Close();

    m_psi->pSpork->NotifyUI(
                     FALSE, 
                     m_wszScriptFile,
                     this,
                     m_psi->htParent,
                     &m_htThis
                     );

  return hr;
}


LPWSTR
ScriptObject::_LoadScript(void)
{
  HANDLE hFile  = INVALID_HANDLE_VALUE;
  DWORD  dwLen  = 0L;
  DWORD  dwRead = 0L;
  PBYTE  pBuf   = NULL;
  LPWSTR wide   = NULL;

  _PreprocessScript(&hFile);

  if( hFile != INVALID_HANDLE_VALUE )
  {
    dwLen = GetFileSize(hFile, NULL);

    // we don't know yet if the script is unicode, assume we need a 16-bit NULL.
    pBuf = new BYTE[dwLen+2];

    if( pBuf )
    {
      if( ReadFile(hFile, (void*) pBuf, dwLen, &dwRead, NULL) )
      {
        if( _IsUnicodeScript((void*) pBuf, dwRead) )
        {
          *(pBuf+dwLen) = L'\0';

          //
          // the first two bytes of the buffer will be a Unicode byte ordering mark (BOM),
          // which has no meaning whatsoever in a wide string, so we need to remove it or
          // else the script parser will choke.
          //
          wide = StrDup((LPWSTR) (pBuf+2));
        }
        else
        {
          *(pBuf+dwLen) = '\0';
          wide          = __ansitowide((LPSTR) pBuf);
        }
      }
      
      SAFEDELETEBUF(pBuf);
    }

    SAFECLOSE(hFile);
  }

  if( !wide )
  {
    LogTrace(L"failed to load script file");
  }

  return wide;
}


BOOL
ScriptObject::_PreprocessScript(
  HANDLE* phScript
  )
{
  BOOL   bRet    = TRUE;
  LPWSTR wszDotI = StrDup(PathFindFileName(m_wszScriptFile));

  if( wszDotI )
  {
    StrCpyN(StrStr(wszDotI, L"."), L".i\0", 3);

#ifdef CONDITIONAL_PRECOMPILE
    if( !_IsDotINewer(wszDotI) )
    {
#endif

      bRet = _RunPreprocessor();

      if( !bRet )
      {
        Alert(
          FALSE,
          L"An error occurred preprocessing %s, please check spork.log for more information",
          m_wszScriptFile
          );
      }

#ifdef CONDITIONAL_PRECOMPILE
    }
#endif

    if( bRet )
    {
      *phScript = CreateFile(
                    wszDotI,
                    GENERIC_READ,
                    FILE_SHARE_READ,
                    NULL,
                    OPEN_EXISTING,
                    FILE_ATTRIBUTE_NORMAL,
                    NULL
                    );

      if( *phScript == INVALID_HANDLE_VALUE )
      {
        DEBUG_TRACE((L"failed to open .i file: %s", MapErrorToString(GetLastError())));
        bRet = FALSE;
      }
    }

    SAFEDELETEBUF(wszDotI);
  }
  else
  {
    DEBUG_TRACE((L"StrDup failed to duplicate scriptname"));
    bRet = FALSE;
  }

  return bRet;
}


LPWSTR g_wszPreprocCmdLine = L"cl.exe /Tc %s /EP /P /I. /I%s /nologo";
LPWSTR g_wszPreprocDefault = L"cl.exe /Tc %s /EP /P /I. /Iinclude /nologo";


BOOL
ScriptObject::_RunPreprocessor(void)
{
  BOOL                bRet    = FALSE;
  DWORD               dwRet   = 0L;
  LPWSTR              cmdline = NULL;
  LPWSTR              include = NULL;
  STARTUPINFO         si      = {0};
  PROCESS_INFORMATION pi      = {0};

  si.cb      = sizeof(STARTUPINFO);
  si.dwFlags = STARTF_USESTDHANDLES;

  cmdline = new WCHAR[MAX_PATH];

  if( cmdline )
  {
    // check to see if there's a profile loaded, and if so does it provide
    // an include path we should use
    if( SUCCEEDED(m_psi->pSpork->GetNamedProfileItem(L"include", (LPVOID*) &include)) )
    {
      wnsprintf(cmdline, MAX_PATH, g_wszPreprocCmdLine, m_wszScriptFile, include);
    }
    else
    {
      wnsprintf(cmdline, MAX_PATH, g_wszPreprocDefault, m_wszScriptFile);
    }

    LogTrace(L"preprocessor command-line: \"%s\"", cmdline);

    bRet = CreateProcess(
             NULL,
             cmdline,
             NULL,
             NULL,
             FALSE,
             CREATE_NO_WINDOW | NORMAL_PRIORITY_CLASS,
             NULL,
             NULL,
             &si,
             &pi
             );

    if( bRet )
    {
      WaitForSingleObject(pi.hProcess, INFINITE);
      GetExitCodeProcess(pi.hProcess, &dwRet);

      if( dwRet )
      {
        LogTrace(L"failed to preprocess %s, please run the logged command-line", m_wszScriptFile);
        bRet = FALSE;
      }
    }

    SAFEDELETEBUF(include);
  }

  SAFEDELETEBUF(cmdline);
  SAFECLOSE(pi.hThread);
  SAFECLOSE(pi.hProcess);

  return bRet;
}


SCRIPTTYPE
ScriptObject::_GetScriptType(void)
{
  if( StrStr(m_wszScriptFile, L".js") )
  {
    return JSCRIPT;
  }
  else if( StrStr(m_wszScriptFile, L".vbs") )
  {
    return VBSCRIPT;
  }
  else
  {
    return UNKNOWN;
  }
}


BOOL
ScriptObject::_IsDotINewer(
  LPCWSTR wszDotI
  )
{
  BOOL   bNewer = FALSE;
  W32FAD script = {0};
  W32FAD doti   = {0};

  if( GetFileAttributesEx(wszDotI, GetFileExInfoStandard, (void*) &doti) )
  {
    if( GetFileAttributesEx(m_wszScriptFile, GetFileExInfoStandard, (void*) &script) )
    {
      bNewer = (CompareFileTime(&doti.ftLastWriteTime, &script.ftLastWriteTime) == 1);
    }
  }  

  return bNewer;
}


BOOL
ScriptObject::_IsUnicodeScript(
  LPVOID pBuf,
  DWORD  cBuf
  )
{
  DWORD dwRet  = 0L;
  INT   iFlags = 0L;
  
  iFlags = IS_TEXT_UNICODE_SIGNATURE  | \
           IS_TEXT_UNICODE_ODD_LENGTH | \
           IS_TEXT_UNICODE_NULL_BYTES;

  dwRet  = IsTextUnicode(pBuf, cBuf, &iFlags);

  DEBUG_TRACE(
    (L"script is %s", (dwRet ? L"unicode" : L"ansi"))
    );

  return (BOOL) dwRet;
}


HRESULT
ScriptObject::_CreateObject(LPWSTR wszProgId, IDispatch** ppdisp)
{
  DEBUG_ENTER((
    L"ScriptObject::_CreateObject",
    rt_hresult,
    L"this=%#x; wszProgId=%s; ppdisp=%#x",
    this,
    wszProgId,
    ppdisp
    ));

  HRESULT hr    = S_OK;
  CLSID   clsid = {0};

  hr = CLSIDFromProgID(wszProgId, &clsid);

  if( SUCCEEDED(hr) )
  {
    hr = CoCreateInstance(
           clsid,
           NULL,
           CLSCTX_INPROC_SERVER,
           IID_IDispatch,
           (void**) ppdisp
           );

    if( FAILED(hr) )
    {
      LogTrace(L"failed to create component, error %s", MapHResultToString(hr));
    }
  }
  else
  {
    if( FAILED(hr) )
    {
      LogTrace(L"progid \"%s\" could not be found, error %s", wszProgId, MapHResultToString(hr));
    }
  }

  DEBUG_LEAVE(hr);
  return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\tools\spork\src\scrobj\thread.cxx ===
/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Copyright (c) 2001  Microsoft Corporation

Module Name:

    thread.cxx

Abstract:

    Thread function that executes a script.
    
Author:

    Paul M Midgen (pmidge) 23-February-2001


Revision History:

    23-February-2001 pmidge
        Created

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/


#include <common.h>


//-----------------------------------------------------------------------------
// the mighty script thread... all ye unwashed bow down.
//-----------------------------------------------------------------------------
DWORD
WINAPI
ScriptThread(LPVOID pv)
{
  HRESULT     hr  = S_OK;
  PSCRIPTINFO psi = (PSCRIPTINFO) pv;
  PSCRIPTOBJ  pso = NULL;

  LogEnterFunction(
    L"ScriptThread",
    rt_hresult,
    L"parentid=%#x; script=%s; spork=%#x",
    psi->htParent,
    psi->wszScriptFile,
    psi->pSpork
    );

  hr = SCRIPTOBJ::Create(psi, &pso);

  if( SUCCEEDED(hr) )
  {
    pso->Run();
    pso->Terminate();

    RevertToSelf();
  }

  SAFERELEASE(pso);
  SAFEDELETE(psi);

  LogLeaveFunction(hr);
  return (DWORD) hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\tools\spork\src\scrobj\iscriptruntime.cxx ===
/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Copyright (c) 2001  Microsoft Corporation

Module Name:

    iscriptruntime.cxx

Abstract:

    Implements the IScriptRuntime, IUnknown, IDispatch and IProvideClassInfo
    interfaces for the ScriptObject class.
    
Author:

    Paul M Midgen (pmidge) 22-February-2001


Revision History:

    22-February-2001 pmidge
        Created

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/


#include <common.h>
#include <lmcons.h>


//
// WARNING: do not modify these values. use disphash.exe to generate
//          new values.
//
DISPIDTABLEENTRY g_ScriptObjectDisptable[] =
{
  0x00818735,   DISPID_SCRRUN_CREATEOBJECT,   L"createobject",
  0x022312a3,   DISPID_SCRRUN_VBCREATEOBJECT, L"vbcreateobject",
  0x00206a70,   DISPID_SCRRUN_CREATEFORK,     L"createfork",
  0x0008e6dc,   DISPID_SCRRUN_PUTVALUE,       L"putvalue",
  0x00083c24,   DISPID_SCRRUN_GETVALUE,       L"getvalue",
  0x001174b4,   DISPID_SCRRUN_SETUSERID,      L"setuserid"
};

DWORD g_cScriptObjectDisptable = (sizeof(g_ScriptObjectDisptable) / sizeof(DISPIDTABLEENTRY));


//-----------------------------------------------------------------------------
// IScriptRuntime
//-----------------------------------------------------------------------------
HRESULT
__stdcall
ScriptObject::CreateObject(
  BSTR     ProgId,
  VARIANT* Name,
  VARIANT* Mode,
  VARIANT* Object
  )
{
  DEBUG_ENTER((
    L"ScriptObject::CreateObject",
    rt_hresult,
    L"this=%#x; ProgId=%s; Name=%s; Mode=%#x; Object=%#x",
    this,
    ProgId,
    STRING(V_BSTR(Name)),
    V_I4(Mode),
    Object
    ));

  HRESULT     hr     = S_OK;
  LPWSTR      name   = NULL;
  PCACHEENTRY pce    = NULL;
  BOOL        cached = FALSE;

  if( !ProgId )
  {
    hr = E_INVALIDARG;
    goto exit;
  }

  if( !Object )
  {
    hr = DISP_E_PARAMNOTOPTIONAL;
    goto exit;
  }


  //
  // The local variable 'name' is used when adding an object to the cache or to the
  // script namespace. ProgIds can be unsuitable, especially if they contain a dot.
  // If the caller doesn't supply a name, we mangle the ProgId into a suitable form
  // by replacing any existing dots with '_'.
  //
  if( !__isempty(Name) )
  {
    name = StrDup(V_BSTR(Name));
  }
  else
  {
    __mangle(ProgId, &name);
  }


  //
  // when CO_MODE_CREATENEW is specified, we bypass the cache and attempt to 
  // create the object. otherwise we attempt a cache lookup. if the lookup fails
  // or the cache entry is marked 'store only', then we attempt to create a new
  // object.
  //
  if( V_I4(Mode) & CO_MODE_CREATENEW )
  {
    hr = _CreateObject(ProgId, &V_DISPATCH(Object));

      if( FAILED(hr) )
        goto quit;

    LogTrace(L"created new object");
  }
  else
  {
    hr = m_psi->pSpork->ObjectCache(name, &pce, RETRIEVE);

    if( SUCCEEDED(hr) )
    {
      if( pce->bStoreOnly )
      {
        pce->pDispObject->Release();
        pce = NULL;
        hr  = _CreateObject(ProgId, &V_DISPATCH(Object));
        
          if( FAILED(hr) )
            goto quit;

        LogTrace(L"created new object");
      }
      else
      {
        V_DISPATCH(Object) = pce->pDispObject;
        cached             = TRUE;
        
        LogTrace(L"reusing cached object");
      }
    }
    else
    {
      hr = _CreateObject(ProgId, &V_DISPATCH(Object));
      
        if( FAILED(hr) )
          goto quit;
        
      LogTrace(L"created new object");
    }
  }


  LogTrace(L"object name is %s", name);


  //
  // if pce is non-null, we know we have a previously cached instance of the object
  // that can be reused (isn't 'store only').
  //
  // if pce is null we allocate a new cache entry and populate it with the new object.
  // we then default to adding a named object and caching it for reuse. both behaviors
  // can be suppressed.
  //
  if( !pce )
  {
    if( pce = new CACHEENTRY )
    {
      pce->dwObjectFlags = V_I4(Mode);
      pce->pDispObject   = V_DISPATCH(Object);

      if( !(V_I4(Mode) & CO_MODE_DONTCACHE) )
      {
        LogTrace(L"caching new object for reuse");

        pce->bStoreOnly = FALSE;
        cached          = TRUE;
        hr              = m_psi->pSpork->ObjectCache(name, &pce, STORE);
      }

      if( !(V_I4(Mode) & CO_MODE_NONAMEDOBJECT) )
      {
        LogTrace(L"adding new object to script namespace");

        if( !cached )
        {
          //
          // the object is being cached for this script only, for reference.
          // uniquely decorate the name.
          //          

          LPWSTR name_decorated = __decorate(name, (DWORD_PTR) this);

          if( name_decorated )
          {
            LogTrace(L"caching new object using per-script id %s", name_decorated);

            cached          = TRUE;
            pce->bStoreOnly = TRUE;
            hr              = m_psi->pSpork->ObjectCache(name_decorated, &pce, STORE);
            
            SAFEDELETEBUF(name_decorated);
          }
        }

        if( SUCCEEDED(hr) )
        {
          hr = m_pScriptEngine->AddNamedItem(name, SCRIPTITEM_ISPERSISTENT | SCRIPTITEM_ISVISIBLE);
        }
      }
    }
    else
    {
      hr = E_OUTOFMEMORY;
    }
  }
  else
  {
    if( !(pce->dwObjectFlags & CO_MODE_NONAMEDOBJECT) )
    {
      LogTrace(L"adding reused object to script namespace");

      hr = m_pScriptEngine->AddNamedItem(name, SCRIPTITEM_ISPERSISTENT | SCRIPTITEM_ISVISIBLE);
    }
  }

quit:

  if( SUCCEEDED(hr) )
  {
    V_VT(Object) = VT_DISPATCH;
  }
  else
  {
    V_VT(Object) = VT_NULL;
    SAFERELEASE(V_DISPATCH(Object));
  }

  if( !cached )
  {
    SAFEDELETE(pce);
  }

  SAFEDELETE(name);

exit:

  DEBUG_LEAVE(hr);  
  return hr;
}


HRESULT
__stdcall
ScriptObject::CreateFork(
  BSTR     ScriptFile,
  VARIANT  Threads,
  BSTR     ChildParams,
  VARIANT* ChildResult
  )
{
  HRESULT     hr        = S_OK;
  PSCRIPTINFO psi       = NULL;
  DWORD       dwThreads = 0L;
  HANDLE      hThread   = NULL;

  //
  // TODO: unused parameters
  //
  //       we don't do anything with the ChildResult parameter.
  //       we should provide a way for the child to report some kind of
  //       non-test related result information. perhaps thru the runtime.
  //

  psi = new SCRIPTINFO;

    if( !psi )
    {
      hr = E_OUTOFMEMORY;
      goto quit;
    }

  dwThreads            = V_I4(&Threads);
  psi->wszScriptFile   = ScriptFile;
  psi->bIsFork         = TRUE;
  psi->bstrChildParams = ChildParams;
  psi->htParent        = m_htThis;
  psi->pSpork          = m_psi->pSpork;

  // if dwThreads is 0, we execute the new script on the same thread
  if( dwThreads == 0 )
  {
    ScriptThread((LPVOID) psi);
  }
  else
  {
    hr = m_psi->pSpork->CreateScriptThread(psi, &hThread);

      if( FAILED(hr) )
      {
        SAFEDELETE(psi);
        goto quit;
      }

    WaitForSingleObject(hThread, INFINITE);
    SAFECLOSE(hThread);
  }

quit:

  return hr;
}


HRESULT
__stdcall
ScriptObject::PutValue(
  BSTR     Name,
  VARIANT* Value,
  VARIANT* Status
  )
{
  HRESULT hr = S_OK;

  if( !Name )
  {
    hr = E_INVALIDARG;
    goto quit;
  }

  hr = m_psi->pSpork->PropertyBag(
                        Name,
                        &Value,
                        (!__isempty(Value) ? STORE : REMOVE)
                        );
quit:

  if( Status )
  {
    V_VT(Status)   = VT_BOOL;
    V_BOOL(Status) = (SUCCEEDED(hr) ? VARIANT_TRUE : VARIANT_FALSE);
  }

  return hr;
}


HRESULT
__stdcall
ScriptObject::GetValue(
  BSTR     Name,
  VARIANT* Value
  )
{
  HRESULT hr = S_OK;

  if( !Name || !Value )
  {
    hr = E_INVALIDARG;
    goto quit;
  }

  hr = m_psi->pSpork->PropertyBag(Name, &Value, RETRIEVE);

quit:

  return hr;
}


HRESULT
__stdcall
ScriptObject::SetUserId(
  VARIANT  Username,
  VARIANT  Password,
  VARIANT* Domain,
  VARIANT* Status
  )
{
  HRESULT hr = E_NOTIMPL;

  //
  // TODO: implementation
  //

  return hr;
}


//-----------------------------------------------------------------------------
// IUnknown methods
//-----------------------------------------------------------------------------
HRESULT
__stdcall
ScriptObject::QueryInterface(
  REFIID riid,
  void** ppv
  )
{
  HRESULT hr = S_OK;

    if( ppv )
    {
      if(
        IsEqualIID(riid, IID_IUnknown)  ||
        IsEqualIID(riid, IID_IDispatch) ||
        IsEqualIID(riid, IID_IScriptRuntime)
        )
      {
        *ppv = static_cast<IScriptRuntime*>(this);
      }
      else if( IsEqualIID(riid, IID_IActiveScriptSite) )
      {
        *ppv = static_cast<IActiveScriptSite*>(this);
      }
      else if( IsEqualIID(riid, IID_IActiveScriptSiteDebug) )
      {
        *ppv = static_cast<IActiveScriptSiteDebug*>(this);
      }
      else if( IsEqualIID(riid, IID_IProvideClassInfo) )
      {
        *ppv = static_cast<IProvideClassInfo*>(this);
      }
      else
      {
        *ppv = NULL;
        hr   = E_NOINTERFACE;
      }
    }
    else
    {
      hr = E_POINTER;
    }

    if( SUCCEEDED(hr) )
    {
      reinterpret_cast<IUnknown*>(*ppv)->AddRef();
    }

  return hr;
}


ULONG
__stdcall
ScriptObject::AddRef(
  void
  )
{
  InterlockedIncrement(&m_cRefs);
  DEBUG_ADDREF(L"ScriptObject", m_cRefs);
  return m_cRefs;
}


ULONG
__stdcall
ScriptObject::Release(
  void
  )
{
  InterlockedDecrement(&m_cRefs);
  DEBUG_RELEASE(L"ScriptObject", m_cRefs);

  if( m_cRefs == 0 )
  {
    DEBUG_FINALRELEASE(L"ScriptObject");
    delete this;
    return 0;
  }

  return m_cRefs;
}


//-----------------------------------------------------------------------------
// IProvideClassInfo methods
//-----------------------------------------------------------------------------
HRESULT
__stdcall
ScriptObject::GetClassInfo(
  ITypeInfo** ppti
  )
{
  HRESULT   hr  = S_OK;
  ITypeLib* ptl = NULL;

    if( ppti )
    {
      if( SUCCEEDED(m_psi->pSpork->GetTypeLib(&ptl)) )
      {
        hr = GetTypeInfoFromName(L"ScriptRuntime", ptl, ppti);
        SAFERELEASE(ptl);
      }
    }
    else
    {
      hr = E_POINTER;
    }

  return hr;
}


//-----------------------------------------------------------------------------
// IDispatch methods
//-----------------------------------------------------------------------------
HRESULT
__stdcall
ScriptObject::GetTypeInfoCount(
  UINT* pctinfo
  )
{
  HRESULT hr = S_OK;

    if( !pctinfo )
    {
      hr = E_POINTER;
    }
    else
    {
      *pctinfo = 1;
    }

  return hr;
}


HRESULT
__stdcall
ScriptObject::GetTypeInfo(
  UINT        index,
  LCID        lcid,
  ITypeInfo** ppti
  )
{
  HRESULT hr = S_OK;

  if( !ppti )
  {
    hr = E_POINTER;
  }
  else
  {
    if( index != 0 )
    {
      hr    = DISP_E_BADINDEX;
      *ppti = NULL;
    }
    else
    {
      hr = GetClassInfo(ppti);
    }
  }

  return hr;
}


HRESULT
__stdcall
ScriptObject::GetIDsOfNames(
  REFIID    riid,
  LPOLESTR* arNames,
  UINT      cNames,
  LCID      lcid,
  DISPID*   arDispId
  )
{
  HRESULT hr = S_OK;
  UINT    n  = 0L;

  if( !IsEqualIID(riid, IID_NULL) )
  {
    hr = E_INVALIDARG;
    goto quit;
  }

  while( n < cNames )
  {
    arDispId[n] = GetDispidFromName(g_ScriptObjectDisptable, g_cScriptObjectDisptable, arNames[n]);
    ++n;
  }

quit:

  return hr;
}


HRESULT
__stdcall
ScriptObject::Invoke(
  DISPID      dispid,
  REFIID      riid,
  LCID        lcid,
  WORD        flags,
  DISPPARAMS* pdp,
  VARIANT*    pvr,
  EXCEPINFO*  pei,
  UINT*       pae
  )
{
  HRESULT hr = S_OK;

  hr = ValidateDispatchArgs(riid, pdp, pvr, pae);

    if( FAILED(hr) )
      goto quit;

  switch( dispid )
  {
    case DISPID_SCRRUN_CREATEOBJECT :
    case DISPID_SCRRUN_VBCREATEOBJECT :
      {
        hr = ValidateInvokeFlags(flags, DISPATCH_METHOD, TRUE);

        if( SUCCEEDED(hr) )
        {
          hr = ValidateArgCount(pdp, 1, TRUE, 2);

          if( SUCCEEDED(hr) )
          {
            NEWVARIANT(progid);
            NEWVARIANT(name);
            NEWVARIANT(mode);

            hr = DispGetParam(pdp, 0, VT_BSTR, &progid, pae);

            if( SUCCEEDED(hr) )
            {
              hr = DispGetOptionalParam(pdp, 1, VT_BSTR, &name, pae);
            }

            if( SUCCEEDED(hr) )
            {
              hr = DispGetOptionalParam(pdp, 2, VT_I4, &mode, pae);
            }

            if( SUCCEEDED(hr) )
            {
              hr = CreateObject(
                     V_BSTR(&progid),
                     &name,
                     &mode,
                     pvr
                     );
            }

            VariantClear(&progid);
            VariantClear(&name);
            VariantClear(&mode);
          }
        }
      }
      break;

    case DISPID_SCRRUN_CREATEFORK :
      {
        hr = ValidateInvokeFlags(flags, DISPATCH_METHOD, TRUE);

        if( SUCCEEDED(hr) )
        {
          hr = ValidateArgCount(pdp, 3, FALSE, 0);

          if( SUCCEEDED(hr) )
          {
            NEWVARIANT(script);
            NEWVARIANT(threads);
            NEWVARIANT(params);

            hr = DispGetParam(pdp, 0, VT_BSTR, &script,  pae);

            if( SUCCEEDED(hr) )
            {
              hr = DispGetParam(pdp, 1, VT_I4,   &threads, pae);
            }

            if( SUCCEEDED(hr) )
            {
              hr = DispGetParam(pdp, 2, VT_BSTR, &params,  pae);
            }

            if( SUCCEEDED(hr) )
            {
              hr = CreateFork(
                     V_BSTR(&script),
                     threads,
                     V_BSTR(&params),
                     pvr
                     );
            }

            VariantClear(&script);
            VariantClear(&threads);
            VariantClear(&params);
          }
        }
      }
      break;

    case DISPID_SCRRUN_PUTVALUE :
      {
        hr = ValidateInvokeFlags(flags, DISPATCH_METHOD, TRUE);

        if( SUCCEEDED(hr) )
        {
          hr = ValidateArgCount(pdp, 1, TRUE, 1);

          if( SUCCEEDED(hr) )
          {
            NEWVARIANT(name);
            NEWVARIANT(value);

            hr = DispGetParam(pdp, 0, VT_BSTR, &name, pae);

            if( SUCCEEDED(hr) )
            {
              hr = DispGetOptionalParam(pdp, 1, VT_VARIANT, &value, pae);
            }

            if( SUCCEEDED(hr) )
            {

              hr = PutValue(
                     V_BSTR(&name),
                     &value,
                     pvr
                     );
            }

            VariantClear(&name);
            VariantClear(&value);
          }
        }
      }
      break;

    case DISPID_SCRRUN_GETVALUE :
      {
        hr = ValidateInvokeFlags(flags, DISPATCH_METHOD, TRUE);

        if( SUCCEEDED(hr) )
        {
          hr = ValidateArgCount(pdp, 1, FALSE, 0);

          if( SUCCEEDED(hr) )
          {
            hr = GetValue(
                   V_BSTR(&pdp->rgvarg[0]),
                   pvr
                   );
          }
        }
      }
      break;

    case DISPID_SCRRUN_SETUSERID :
      {
        hr = ValidateInvokeFlags(flags, DISPATCH_METHOD, TRUE);

        if( SUCCEEDED(hr) )
        {
          hr = ValidateArgCount(pdp, 2, TRUE, 1);

          if( SUCCEEDED(hr) )
          {
            NEWVARIANT(user);
            NEWVARIANT(password);
            NEWVARIANT(domain);

            hr = DispGetParam(pdp, 0, VT_BSTR, &user, pae);

            if( SUCCEEDED(hr) )
            {
              hr = DispGetParam(pdp, 1, VT_BSTR, &password, pae);
            }

            if( SUCCEEDED(hr) )
            {
              hr = DispGetOptionalParam(pdp, 2, VT_BSTR, &domain, pae);
            }

            if( SUCCEEDED(hr) )
            {
              if( __isempty(&domain) )
              {
                V_VT(&domain)   = VT_BSTR;
                V_BSTR(&domain) = SysAllocString(L".");
              }

              hr = SetUserId(
                     user,
                     password,
                     &domain,
                     pvr
                     );
            }

            VariantClear(&user);
            VariantClear(&password);
            VariantClear(&domain);
          }
        }
      }
      break;

    default : hr = DISP_E_MEMBERNOTFOUND;
  }

quit:

  if( FAILED(hr) )
  {
    hr = HandleDispatchError(L"ScriptObject", pei, hr);
  }

  return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\tools\spork\src\spobj\debugpage.cxx ===
/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Copyright (c) 2001  Microsoft Corporation

Module Name:

    debugpage.cxx

Abstract:

    Implements the debug options property page.
    
Author:

    Paul M Midgen (pmidge) 22-February-2001


Revision History:

    22-February-2001 pmidge
        Created

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/


#include <common.h>


LPCWSTR g_wszEnableDebug        = L"_EnableDebug";
LPCWSTR g_wszBreakOnScriptStart = L"_BreakOnScriptStart";
LPCWSTR g_wszEnableDebugWindow  = L"_EnableDebugWindow";


//-----------------------------------------------------------------------------
// dialog window procedures
//-----------------------------------------------------------------------------
INT_PTR
Spork::_DebugPropPageProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
  switch( uMsg )
  {
    case WM_INITDIALOG :
      {
        _LoadDebugOptions();
      }
      break;

    case WM_NOTIFY :
      {
        switch( ((NMHDR*) lParam)->code )
        {
          case PSN_SETACTIVE :
            {
              DBGOPTIONS dbo = {0};

              if( m_pMLV )
                m_pMLV->GetDebugOptions(&dbo);

              CheckDlgButton(
                hwnd,
                IDB_ENABLEDEBUG,
                (dbo.bEnableDebug ? BST_CHECKED : BST_UNCHECKED)
                );

              EnableWindow(
                GetDlgItem(hwnd, IDB_DBGBREAK),
                (IsDlgButtonChecked(hwnd, IDB_ENABLEDEBUG) == BST_CHECKED)
                );

              CheckDlgButton(
                hwnd,
                IDB_DBGBREAK,
                (dbo.bBreakOnScriptStart ? BST_CHECKED : BST_UNCHECKED)
                );

              CheckDlgButton(
                hwnd,
                IDB_ENABLEDBGOUT,
                (dbo.bEnableDebugWindow ? BST_CHECKED : BST_UNCHECKED)
                );
            }
            break;

          case PSN_KILLACTIVE :
            {
              SetWindowLongPtr(hwnd, DWLP_MSGRESULT, (LONG_PTR) FALSE);
            }
            return 1L;

          case PSN_APPLY :
            {
              _SaveDebugOptions(hwnd);
              SetWindowLongPtr(hwnd, DWLP_MSGRESULT, PSNRET_NOERROR);
            }
            return 1L;
        }
      }

    case WM_COMMAND :
      {
        BOOL bPageChanged = FALSE;

        switch( LOWORD(wParam) )
        {
          case IDB_ENABLEDEBUG :
            {
              EnableWindow(
                GetDlgItem(hwnd, IDB_DBGBREAK),
                (IsDlgButtonChecked(hwnd, LOWORD(wParam)) == BST_CHECKED)
                );

              bPageChanged = TRUE;
            }
            break;

          case IDB_DBGBREAK :
          case IDB_ENABLEDBGOUT :
            {
              bPageChanged = TRUE;
            }
            break;
        }

        if( bPageChanged )
        {
          PropSheet_Changed(GetParent(hwnd), hwnd);
        }
      }
      break;

    default : return 0L;
  }

  return 0L;
}


//-----------------------------------------------------------------------------
// handlers for dialog events
//-----------------------------------------------------------------------------
BOOL
Spork::_LoadDebugOptions(void)
{
  LPWSTR     wszProfilePath = _GetCurrentProfilePath();
  LPVOID     pvData         = NULL;
  DBGOPTIONS dbo            = {0}; // defaults to all debugging support off

  if( wszProfilePath )
  {
    if( GetRegValueFromKey(wszProfilePath, g_wszEnableDebug, REG_DWORD, &pvData) )
    {
      dbo.bEnableDebug = (BOOL) *((LPDWORD) pvData);
      SAFEDELETEBUF(pvData);
    }

    if( GetRegValueFromKey(wszProfilePath, g_wszBreakOnScriptStart, REG_DWORD, &pvData) )
    {
      dbo.bBreakOnScriptStart = *((LPDWORD) pvData);
      SAFEDELETEBUF(pvData);
    }

    if( GetRegValueFromKey(wszProfilePath, g_wszEnableDebugWindow, REG_DWORD, &pvData) )
    {
      dbo.bEnableDebugWindow = *((LPDWORD) pvData);
      SAFEDELETEBUF(pvData);
    }

    SAFEDELETEBUF(wszProfilePath);

    m_pMLV->SetDebugOptions(dbo);
  }

  return TRUE;
}


BOOL
Spork::_SaveDebugOptions(HWND dialog)
{
  LPWSTR     wszProfilePath = _GetCurrentProfilePath();
  DBGOPTIONS dbo            = {0};

  dbo.bEnableDebug        = (IsDlgButtonChecked(dialog, IDB_ENABLEDEBUG)  == BST_CHECKED);
  dbo.bBreakOnScriptStart = (IsDlgButtonChecked(dialog, IDB_DBGBREAK)     == BST_CHECKED);
  dbo.bEnableDebugWindow  = (IsDlgButtonChecked(dialog, IDB_ENABLEDBGOUT) == BST_CHECKED);

  if( wszProfilePath )
  {
    SetRegValueInKey(wszProfilePath, g_wszEnableDebug,        REG_DWORD, (LPVOID) &dbo.bEnableDebug,        sizeof(DWORD));
    SetRegValueInKey(wszProfilePath, g_wszBreakOnScriptStart, REG_DWORD, (LPVOID) &dbo.bBreakOnScriptStart, sizeof(DWORD));
    SetRegValueInKey(wszProfilePath, g_wszEnableDebugWindow,  REG_DWORD, (LPVOID) &dbo.bEnableDebugWindow,  sizeof(DWORD));

    m_pMLV->SetDebugOptions(dbo);

    SAFEDELETEBUF(wszProfilePath);
  }

  return TRUE;
}


//-----------------------------------------------------------------------------
// friend window procs, delegate to private class members
//-----------------------------------------------------------------------------
INT_PTR
CALLBACK
DebugPropPageProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
  static PSPORK ps = NULL;

  if( !ps )
  {
    switch( uMsg )
    {
      case WM_INITDIALOG :
        {
          ps = (PSPORK) ((LPPROPSHEETPAGE) lParam)->lParam;
        }
        break;
      
      default : return FALSE;
    }
  }

  return ps->_DebugPropPageProc(hwnd, uMsg, wParam, lParam);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\tools\spork\src\spobj\multilistview.cxx ===
/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Copyright (c) 2001  Microsoft Corporation

Module Name:

    multilistview.cxx

Abstract:

    Implements the MultiListView control.
    
Author:

    Paul M Midgen (pmidge) 22-February-2001


Revision History:

    22-February-2001 pmidge
        Created

Notes:

    This object implements a pseudo-control based on the Win32 ListView and
    a data store to track the items displayed in the ListView(s). The
    Initialize function has two modes: init display or init data. If it is
    called with a NULL hwndParent, it will only initialize the data store
    portion of the control. It can be called again to initialize UI to display
    the ListViews that show the data.

    Many places in the code are wrapped in if( m_hwndParent ) { ... } constructs,
    please beware if making changes around them, you must make not whether your
    change depends on the UI being available or not.

    In all methods except EnumItems, an iListView value of -1 means "use the
    currently active ListView", the index of which is stored in m_dwActive.

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/


#include <common.h>


MultiListView::~MultiListView()
{
  PITEMINFO pCurrent = NULL;
  PITEMINFO pNext    = NULL;

  for(DWORD n=0; n<m_cListViews; n++)
  {
    if( pCurrent = m_arListViews[n].items )
    {
      do
      {
        pNext = pCurrent->pNext;

        SAFEDELETEBUF(pCurrent->wszName);
        SAFEDELETEBUF(pCurrent->wszValue);
        SAFEDELETE(pCurrent);
        pCurrent = pNext;
      }
      while( pNext );
    }
    
    SAFEDELETEBUF(m_arListViews[n].name);
  }

  SAFEDELETEBUF(m_arListViews);
}


BOOL
MultiListView::InitializeData(
  DWORD cListViews
  )
{
  if( !cListViews )
    return FALSE;

  m_dwActive    = 0L;
  m_cListViews  = cListViews;
  m_arListViews = new MLVINFO[m_cListViews];

  if( !m_arListViews )
    return FALSE;

  return TRUE;
}


BOOL
MultiListView::InitializeDisplay(
  HINSTANCE hInstance,
  HWND      hwndParent,
  POINT*    pptOrigin,
  DWORD     dwWidth,
  DWORD     dwHeight
  )
{
  LVCOLUMN lvc;

  m_hInstance  = hInstance;
  m_hwndParent = hwndParent;

  // set column info
  lvc.mask = LVCF_FMT | LVCF_TEXT | LVCF_SUBITEM;
  lvc.fmt  = LVCFMT_LEFT;

  for(DWORD n=0; n<m_cListViews; n++)
  {
    // create the listview windows
    m_arListViews[n].hwnd =
      CreateWindowEx(
        WS_EX_CLIENTEDGE,
        WC_LISTVIEW,
        NULL,
        LVS_REPORT | WS_BORDER | WS_CHILD,
        pptOrigin->x,
        pptOrigin->y,
        dwWidth,
        dwHeight,
        m_hwndParent,
        NULL,
        m_hInstance,
        0
        );
    
    // enable gridlines
    ListView_SetExtendedListViewStyle(m_arListViews[n].hwnd, LVS_EX_GRIDLINES);

    // create the listview columns
    lvc.pszText    = L"name";
    lvc.iSubItem   = 0;
    ListView_InsertColumn(m_arListViews[n].hwnd, 0, &lvc);

    lvc.pszText    = L"value";
    lvc.iSubItem   = 1;
    ListView_InsertColumn(m_arListViews[n].hwnd, 1, &lvc);

    // provide a backpointer to this class for the window subclass proc
    SetWindowLongPtr(
      m_arListViews[n].hwnd,
      GWLP_USERDATA,
      (LONG_PTR) this
      );

    // store a pointer to the original listview proc
    m_arListViews[n].wndproc =
      (WNDPROC) SetWindowLongPtr(
                  m_arListViews[n].hwnd,
                  GWLP_WNDPROC,
                  (LONG_PTR) ListViewSubclassProc
                  );
  }

  ShowWindow(
    m_arListViews[m_dwActive].hwnd,
    SW_NORMAL
    );

  return TRUE;
}


BOOL
MultiListView::TerminateDisplay(void)
{
  for(DWORD n=0; n<m_cListViews; n++)
  {
    DestroyWindow(m_arListViews[n].hwnd);
  }

  return TRUE;
}


BOOL
MultiListView::AddItem(
  INT_PTR iListView,
  LPWSTR  wszName,
  DWORD   dwType,
  LPVOID  pvData
  )
{
  PITEMINFO pInsert = NULL;
  PITEMINFO pItem   = NULL;

  if( iListView >= (INT_PTR) m_cListViews )
    return FALSE;

  if( !wszName )
    return FALSE;

  if( iListView == -1 )
  {
    iListView = m_dwActive;
  }

  //
  // only insert into a listview if we're displayed; if not, the client
  // will need to call RefreshListView to get the active LV to poll
  // the client for display data (which should be delegated back to us
  // via GetDisplayInfo).
  //
  if( m_hwndParent )
  {
    _AddItemToListView(iListView, m_arListViews[iListView].currentid);
  }

  // advance the current item count
  ++m_arListViews[iListView].currentid;

  if( pItem = new ITEMINFO )
  {
    // find a suitable place to insert the new item
    if( !(pInsert = m_arListViews[iListView].items) )
    {
      m_arListViews[iListView].items = pItem;
    }
    else
    {
      while( pInsert->pNext )
        pInsert = pInsert->pNext;

      pInsert->pNext = pItem;
    }

    pItem->wszName = StrDup(wszName);
    pItem->dwType  = dwType;

    if( dwType == MLV_STRING )
    {
      pItem->wszValue = StrDup((LPWSTR) pvData);
    }
    else
    {
      pItem->dwValue  = *((LPDWORD) pvData);
      pItem->wszValue = new WCHAR[32];
      _itow(pItem->dwValue, pItem->wszValue, 10);
    }
  }

  return TRUE;
}


BOOL
MultiListView::GetItem(
  INT_PTR iListView,
  INT_PTR iItem,
  LPWSTR* ppwszName,
  LPDWORD pdwType,
  LPVOID* ppvData
  )
{
  PITEMINFO pItem = NULL;

  if( iListView >= (INT_PTR) m_cListViews )
    return FALSE;

  //
  // BUGBUG: need to validate iItem. can this fn and ModifyItem share code?
  //

  if( iListView == -1 )
  {
    pItem = m_arListViews[m_dwActive].items;
  }
  else
  {
    pItem = m_arListViews[iListView].items;
  }

  for(INT_PTR n=0; n<iItem; n++)
  {
    pItem = pItem->pNext;
  }

  if( ppwszName )
  {
    *ppwszName = pItem->wszName;
  }

  if( pdwType )
  {
    *pdwType = pItem->dwType;
  }

  if( ppvData )
  {
    if( pItem->dwType == MLV_STRING )
    {
      *ppvData = pItem->wszValue;
    }
    else
    {
      *ppvData = (LPVOID) ((DWORD_PTR) pItem->dwValue);
    }
  }

  return TRUE;
}


BOOL
MultiListView::GetItemByName(
  INT_PTR iListView,
  LPWSTR  wszName,
  LPDWORD pdwType,
  LPVOID* ppvData
  )
{
  PITEMINFO pItem = NULL;

  if( iListView >= (INT_PTR) m_cListViews )
    return FALSE;

  if( iListView == -1 )
  {
    iListView = m_dwActive;
  }
  
  pItem = m_arListViews[m_dwActive].items;

  while( pItem )
  {
    if( !StrCmpI(wszName, pItem->wszName) )
    {
      if( pdwType )
      {
        *pdwType = pItem->dwType;
      }

      if( ppvData )
      {
        if( pItem->dwType == MLV_STRING )
        {
          *ppvData = pItem->wszValue;
        }
        else
        {
          *ppvData = (LPVOID) ((DWORD_PTR) pItem->dwValue);
        }
      }

      return TRUE;
    }

    pItem = pItem->pNext;
  }

  return FALSE;
}


BOOL
MultiListView::ModifyItem(
  INT_PTR iListView,
  INT_PTR iItem,
  LPWSTR  wszName,
  DWORD   dwType,
  LPVOID  pvData
  )
{
  PITEMINFO pItem = NULL;

  if( iListView >= (INT_PTR) m_cListViews )
    return FALSE;

  pItem = m_arListViews[iListView].items;

  //
  // BUGBUG: need to validate iItem before doing anything
  //

  // locate the item we're to modify
  for(INT_PTR n=0; n<iItem; n++)
  {
    pItem = pItem->pNext;
  }

  if( wszName )
  {
    SAFEDELETEBUF(pItem->wszName);
    pItem->wszName = StrDup(wszName);

    if( m_hwndParent )
    {
      ListView_SetItemText(
        m_arListViews[iListView].hwnd,
        iItem, 0,
        pItem->wszName
        );
    }
  }

  if( dwType )
  {
    if( dwType != MLV_RETAIN )
    {
      pItem->dwType = dwType;
    }
  }

  if( pvData )
  {
    SAFEDELETEBUF(pItem->wszValue);

    if( pItem->dwType == MLV_STRING )
    {
      pItem->wszValue = StrDup((LPWSTR) pvData);
    }
    else
    {
      pItem->dwValue  = *((LPDWORD) pvData);
      pItem->wszValue = new WCHAR[32];
      _itow(pItem->dwValue, pItem->wszValue, 10);
    }

    if( m_hwndParent )
    {
      ListView_SetItemText(
        m_arListViews[iListView].hwnd,
        iItem, 1,
        pItem->wszValue
        );
    }
  }

  return TRUE;
}


BOOL
MultiListView::EnumItems(
  INT_PTR iListView,
  LPWSTR* ppwszName,
  LPDWORD pdwType,
  LPVOID* ppvData
  )
{
  static PITEMINFO pItem = NULL;

  if( iListView >= (INT_PTR) m_cListViews )
    return FALSE;

  // if the caller specifies the listview to use, get the first item
  // in that listview's list, otherwise continue where we left off.
  if( iListView != -1 )
  {
    pItem = m_arListViews[iListView].items;
  }
  else
  {
    pItem = pItem->pNext;
  }

  // assign references to the data, don't copy it. when there
  // are no more entries, return false.
  if( pItem )
  {
    *ppwszName = pItem->wszName;
    *pdwType   = pItem->dwType;

    if( pItem->dwType == MLV_STRING )
    {
      *ppvData = (LPVOID) pItem->wszValue;
    }
    else
    {
      *ppvData = (LPVOID) ((DWORD_PTR) pItem->dwValue);
    }
  }
  else
  {
    return FALSE;
  }

  return TRUE;
}


BOOL
MultiListView::InPlaceEdit(
  LPNMITEMACTIVATE pnmia
  )
{
  HWND            editctl  = NULL;
  LPLVHITTESTINFO plvhti   = new LVHITTESTINFO;
  RECT            rectItem;
  WCHAR           wsz[256];

  if( !plvhti )
    return FALSE;

  // check to see if the double-click was really on a subitem
  plvhti->pt = pnmia->ptAction;
  ListView_SubItemHitTest(m_arListViews[m_dwActive].hwnd, plvhti);

  if( plvhti->flags & LVHT_ONITEM )
  {
    // get the rectangle containing the selected subitem
    ListView_GetSubItemRect(
      m_arListViews[m_dwActive].hwnd,
      plvhti->iItem, 1,
      LVIR_BOUNDS,
      &rectItem
      );

    // snap a copy of the current text
    ListView_GetItemText(
      m_arListViews[m_dwActive].hwnd,
      plvhti->iItem, 1,
      wsz,
      256
      );

    // create an edit control positioned over the subitem
    // we want to edit
    editctl = CreateWindowEx(
                WS_EX_WINDOWEDGE,
                WC_EDIT,
                wsz,
                ES_AUTOHSCROLL | WS_CHILD,
                rectItem.left+1,
                rectItem.top,
                ListView_GetColumnWidth(m_arListViews[m_dwActive].hwnd, 1),
                rectItem.bottom-rectItem.top-1,
                m_arListViews[m_dwActive].hwnd,
                NULL,
                m_hInstance,
                0
                );

    // store the hittest information in the control's userdata
    // so the listview subclass procedure can apply any changes
    // to the correct listview item
    SetWindowLongPtr(editctl, GWLP_USERDATA, (LONG_PTR) plvhti);

    // set the edit control's font to that of the parent listview
    SendMessage(
      editctl,
      WM_SETFONT,
      (WPARAM) SendMessage(m_arListViews[m_dwActive].hwnd, WM_GETFONT, 0, 0),
      (LPARAM) TRUE
      );

    // set input focus, select all text and show the control
    SetFocus(editctl);
    SendMessage(editctl, EM_SETSEL, 0, -1);
    ShowWindow(editctl, SW_SHOW);

    return TRUE;
  }
  else
  {
    SAFEDELETE(plvhti);
    return FALSE;
  }
}


BOOL
MultiListView::GetDisplayInfo(
  LPLVITEM plvi
  )
{
  DWORD_PTR iListView = plvi->lParam;
  PITEMINFO pItem     = NULL;

  if( plvi->iItem >= (INT_PTR) m_arListViews[iListView].currentid )
    return FALSE;

  pItem = m_arListViews[iListView].items;

  for(INT_PTR n=0; n<plvi->iItem; n++)
  {
    pItem = pItem->pNext;
  }

  plvi->mask    |= LVIF_DI_SETITEM;
  plvi->pszText  = (plvi->iSubItem ? pItem->wszValue : pItem->wszName);

  return TRUE;
}


BOOL
MultiListView::RefreshListView(
  INT_PTR iListView
  )
{
  if( iListView >= (INT_PTR) m_cListViews )
    return FALSE;

  DWORD_PTR i = 0;
  INT_PTR   n = 0;

  if( iListView == -1 )
  {
    for(i=0; i<m_cListViews; i++)
    {
      ListView_DeleteAllItems(m_arListViews[i].hwnd);

        for(n=0; n<(INT_PTR) m_arListViews[i].currentid; n++)
        {
          _AddItemToListView(i, n);
        }
      
      ResizeColumns(i);
    }
  }
  else
  {
    ListView_DeleteAllItems(m_arListViews[iListView].hwnd);

      for(n=0; n<(INT_PTR) m_arListViews[iListView].currentid; n++)
      {
        _AddItemToListView(iListView, n);
      }
    
    ResizeColumns(i);
  }

  return TRUE;
}


BOOL
MultiListView::ActivateListViewByIndex(
  INT_PTR iListView
  )
{
  if( iListView >= (INT_PTR) m_cListViews )
    return FALSE;

  if( IsDisplayEnabled() )
  {
    ShowWindow(m_arListViews[m_dwActive].hwnd, SW_HIDE);
    ShowWindow(m_arListViews[iListView].hwnd, SW_NORMAL);
  }

  m_dwActive = iListView;

  return TRUE;
}


BOOL
MultiListView::ActivateListViewByName(
  LPWSTR wszName
  )
{
  DWORD dwListView = 0L;

  while( dwListView < m_cListViews )
  {
    if( !StrCmpI(wszName, m_arListViews[dwListView].name) )
    {
      return ActivateListViewByIndex(dwListView);
    }

    ++dwListView;
  }

  return FALSE;
}


INT_PTR
MultiListView::GetActiveIndex(void)
{
  return (INT_PTR) m_dwActive;
}


BOOL
MultiListView::GetListViewName(
  INT_PTR     iListView,
  LPWSTR* ppwszName
  )
{
  if( iListView >= (INT_PTR) m_cListViews )
    return FALSE;

  if( iListView == -1 )
  {
    iListView = m_dwActive;
  }

  *ppwszName = StrDup(m_arListViews[iListView].name);

  if( *ppwszName )
    return TRUE;

  return FALSE;
}


BOOL
MultiListView::SetListViewName(
  INT_PTR    iListView,
  LPWSTR wszName
  )
{
  if( (iListView == -1) || (iListView >= (INT_PTR) m_cListViews) )
    return FALSE;

  if( !wszName )
    return FALSE;

  return (m_arListViews[iListView].name = StrDup(wszName)) ? TRUE : FALSE;
}


BOOL
MultiListView::EnumListViewNames(
  LPWSTR* ppwszName
  )
{
  static DWORD dwCurrent = 0L;

  if( dwCurrent < m_cListViews )
  {
    *ppwszName = StrDup(m_arListViews[dwCurrent++].name);
    return TRUE;
  }
  else
  {
    dwCurrent  = 0L;
    *ppwszName = NULL;
    return FALSE;
  }
}


BOOL
MultiListView::ResizeColumns(
  INT_PTR iListView
  )
{
  if( iListView >= (INT_PTR) m_cListViews )
    return FALSE;

  if( iListView == -1 )
  {
    iListView = m_dwActive;
  }

  if( m_hwndParent )
  {
    ListView_SetColumnWidth(m_arListViews[iListView].hwnd, 0, LVSCW_AUTOSIZE_USEHEADER);
    ListView_SetColumnWidth(m_arListViews[iListView].hwnd, 1, LVSCW_AUTOSIZE_USEHEADER);
  }

  return TRUE;
}


BOOL
MultiListView::IsListViewName(
  LPWSTR wszName
  )
{
  DWORD dwListView = 0L;

  while( dwListView < m_cListViews )
  {
    if( !StrCmpI(wszName, m_arListViews[dwListView].name) )
    {
      return TRUE;
    }

    ++dwListView;
  }

  return FALSE;
}


BOOL
MultiListView::IsModified(
  INT_PTR iListView
  )
{
  if( iListView >= (INT_PTR) m_cListViews )
    return FALSE;
  
  if( iListView == -1 )
  {
    iListView = m_dwActive;
  }

  return m_arListViews[iListView].modified;
}


BOOL
MultiListView::GetDebugOptions(
  PDBGOPTIONS pdbo
  )
{
  if( !pdbo )
    return FALSE;

  *pdbo = m_arListViews[m_dwActive].dbgopts;

  return TRUE;
}


BOOL
MultiListView::SetDebugOptions(
  DBGOPTIONS dbo
  )
{
  m_arListViews[m_dwActive].dbgopts = dbo;
  return TRUE;
}


void
MultiListView::_AddItemToListView(
  INT_PTR iListView,
  INT_PTR iItem
  )
{
  LVITEM lvitem  = {0};

  lvitem.mask     = LVIF_TEXT | LVIF_PARAM;
  lvitem.lParam   = iListView;
  lvitem.iItem    = (int) iItem;
  lvitem.pszText  = LPSTR_TEXTCALLBACK;

  ListView_InsertItem(m_arListViews[iListView].hwnd, &lvitem);

  lvitem.iSubItem = 1;

  ListView_SetItem(m_arListViews[iListView].hwnd, &lvitem);
}


BOOL
MultiListView::_UpdateItem(
  HWND    hwndEdit,
  INT_PTR iItem
  )
{
  BOOL  bUpdated = FALSE;
  DWORD dwType;
  WCHAR edited[256];

  if( SendMessage(hwndEdit, EM_GETMODIFY, 0, 0) )
  {
    GetWindowText(hwndEdit, edited, 256);

    if( GetItem(m_dwActive, iItem, NULL, &dwType, NULL) )
    {
      ModifyItem(
        m_dwActive,
        iItem,
        NULL,
        MLV_RETAIN,
        ((dwType == MLV_DWORD) ? ((dwType = _wtoi(edited)), (LPVOID) &dwType) : (LPVOID) edited)
        );

      bUpdated = TRUE;
    }
  }

  return bUpdated;
}


//-----------------------------------------------------------------------------
// listview subclass procedure
//-----------------------------------------------------------------------------
LRESULT
MultiListView::_ListViewSubclassProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
  switch( uMsg )
  {
    case WM_COMMAND :
      {
        switch( HIWORD(wParam) )
        {
          case EN_KILLFOCUS :
            {
              LPLVHITTESTINFO plvhti = (LPLVHITTESTINFO) GetWindowLongPtr((HWND) lParam, GWLP_USERDATA);

              if( plvhti )
              {
                if( _UpdateItem((HWND) lParam, plvhti->iItem) )
                {
                  // notify the propertysheet that something changed
                  PropSheet_Changed(GetParent(m_hwndParent), m_hwndParent);

                  // mark this listview as user-modified
                  m_arListViews[m_dwActive].modified = TRUE;

                  // if this message was posted during VK_RETURN processing in the
                  // propsheetpage proc, we will get a duplicate EN_KILLFOCUS. to
                  // avoid dorking ourselves, clear the window userdata.
                  SetWindowLongPtr((HWND) lParam, GWLP_USERDATA, (LONG) 0L);
                }

                SAFEDELETE(plvhti);
                DestroyWindow((HWND) lParam);
              }
            }
            return 0L;
        }
      }
      break;
  }

  return CallWindowProc(
            m_arListViews[m_dwActive].wndproc,
            hwnd,
            uMsg,
            wParam,
            lParam
            );
}


//-----------------------------------------------------------------------------
// friend window proc
//-----------------------------------------------------------------------------
LRESULT
CALLBACK
ListViewSubclassProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
  return ((MultiListView*) GetWindowLongPtr(hwnd, GWLP_USERDATA))->_ListViewSubclassProc(hwnd, uMsg, wParam, lParam);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\tools\stress\memstats.cpp ===
///////////////////////////////////////////////////////////////////////////
// File:  MemStats.cpp
//
// Copyright (c) 2001 Microsoft Corporation.  All Rights Reserved.
//
// Purpose:
//	MemStats.cpp: Helper functions that get's the system memory info.
//	Borrowed from EricI's memstats app.
//
// History:
//	03/21/01	DennisCh	Created
//
//////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////
// Includes
//////////////////////////////////////////////////////////////////////


//
// WIN32 headers
//

//
// Project headers
//
#include "MemStats.h"
#include "NetworkTools.h"


//////////////////////////////////////////////////////////////////////
//
// Globals and statics
//
//////////////////////////////////////////////////////////////////////
BOOL (WINAPI *g_lpfnOpenProcessToken)(HANDLE,DWORD,PHANDLE);
BOOL (WINAPI *g_lpfnLookupPrivilegeValueA)(LPCSTR,LPCSTR,PLUID);
BOOL (WINAPI *g_lpfnAdjustTokenPrivileges)(HANDLE,BOOL,PTOKEN_PRIVILEGES,DWORD,PTOKEN_PRIVILEGES,PDWORD);

PDH_STATUS (WINAPI *g_lpfnPdhOpenQuery)(LPCSTR, DWORD_PTR, HQUERY *);
PDH_STATUS (WINAPI *g_lpfnPdhAddCounter)(HQUERY, LPCSTR, DWORD_PTR, HCOUNTER *);
PDH_STATUS (WINAPI *g_lpfnPdhCollectQueryData)(HQUERY);
PDH_STATUS (WINAPI *g_lpfnPdhGetFormattedCounterValue)(HCOUNTER, DWORD, LPDWORD, PPDH_FMT_COUNTERVALUE);
PDH_STATUS (WINAPI *g_lpfnPdhRemoveCounter)(HCOUNTER);
PDH_STATUS (WINAPI *g_lpfnPdhCloseQuery)(HQUERY);



////////////////////////////////////////////////////////////
// Function:  InitPdhLibrary()
//
// Purpose:
//	Loads and returns a pointer to the PDH module.
//
////////////////////////////////////////////////////////////
BOOL
InitPdhLibrary(
	HMODULE	*phPdhLib	// [OUT] Pointer to the PDH.DLL module.
)
{ 
    BOOL    bRet = FALSE;

    *phPdhLib = LoadLibraryA("pdh.dll");

    if(!*phPdhLib)
    {
        goto exit;
    }

	if(!(g_lpfnPdhOpenQuery = (PDH_STATUS (WINAPI *)(LPCSTR, DWORD_PTR, HQUERY *))GetProcAddress(*phPdhLib,"PdhOpenQueryA") ))
	{
		goto exit;
	}
	if(!(g_lpfnPdhAddCounter = (PDH_STATUS (WINAPI *)(HQUERY, LPCSTR, DWORD_PTR, HCOUNTER *))GetProcAddress(*phPdhLib,"PdhAddCounterA") ))
	{
		goto exit;
	}
	if(!(g_lpfnPdhCollectQueryData = (PDH_STATUS (WINAPI *)(HQUERY))GetProcAddress(*phPdhLib,"PdhCollectQueryData") ))
	{
		goto exit;
	}
	if(!(g_lpfnPdhGetFormattedCounterValue = (PDH_STATUS (WINAPI *)(HCOUNTER, DWORD, LPDWORD, PPDH_FMT_COUNTERVALUE))GetProcAddress(*phPdhLib,"PdhGetFormattedCounterValue") ))
	{
		goto exit;
	}
	if(!(g_lpfnPdhRemoveCounter = (PDH_STATUS (WINAPI *)(HCOUNTER))GetProcAddress(*phPdhLib,"PdhRemoveCounter") ))
	{
		goto exit;
	}
	if(!(g_lpfnPdhCloseQuery = (PDH_STATUS (WINAPI *)(HQUERY))GetProcAddress(*phPdhLib,"PdhCloseQuery") ))
	{
		goto exit;
	}
	
    bRet = TRUE;

exit:

    return bRet;
}


////////////////////////////////////////////////////////////
// Function:  GetProcCntrs(PROC_CNTRS, INT, CHAR)
//
// Purpose:
//	Gets and returns the memory info for a given process.
//
////////////////////////////////////////////////////////////
BOOL
GetProcCntrs(
	PROC_CNTRS	*pProcCntrs,	// [OUT]	process memory counters
	INT			nIndex,			// [IN]		The index of the process if there's more than one.
	CHAR		*szProcess		// [IN]		Name of the process. ex "iexplore", "explorer"
)
{
	BOOL						bRet = FALSE;
	INT							n;
	HQUERY						hQuery = 0;
    HCOUNTER					aryHCounter [PROCCOUNTERS] = {0};
	PDH_FMT_COUNTERVALUE		cntVal;
	CHAR						myProcessCntrs[PROCCOUNTERS][1024];
	DWORD						dwPathSize = MAX_PATH;

	sprintf(myProcessCntrs[0],"\\Process(%s#%d)\\ID Process",szProcess,nIndex);
	sprintf(myProcessCntrs[1],"\\Process(%s#%d)\\Private bytes",szProcess,nIndex);
	sprintf(myProcessCntrs[2],"\\Process(%s#%d)\\Handle count",szProcess,nIndex);
	sprintf(myProcessCntrs[3],"\\Process(%s#%d)\\Thread count",szProcess,nIndex);


	if(!(ERROR_SUCCESS == g_lpfnPdhOpenQuery (0, 0, &hQuery)))
	   goto exit;

	for (n = 0; n < PROCCOUNTERS; n++) 
	{ 
		if(!(ERROR_SUCCESS == g_lpfnPdhAddCounter (hQuery,  myProcessCntrs[n], 0, &aryHCounter[n])))
			goto exit;
	}

	if(!(ERROR_SUCCESS == g_lpfnPdhCollectQueryData(hQuery)))
		goto exit;

	for (n=0; n < PROCCOUNTERS; n++) 
	{ 
		if(!(ERROR_SUCCESS == g_lpfnPdhGetFormattedCounterValue (aryHCounter[n],PDH_FMT_LONG,0,&cntVal)))
			goto exit;
        *((ULONG*)pProcCntrs+n) = cntVal.longValue;
	} 

	bRet = TRUE;

exit:
	for(n=0;n<PROCCOUNTERS;n++)
		if(aryHCounter[n])
			g_lpfnPdhRemoveCounter(aryHCounter[n]);

	if(hQuery)
		g_lpfnPdhCloseQuery(hQuery);

	return bRet;
}


////////////////////////////////////////////////////////////
// Function:  GetInfoForPID(PROC_CNTRS, ULONG, CHAR)
//
// Purpose:
//	Gets and returns the memory info for a given process.
//	We do this by going through every process with the same
//	name and comparing the PIDs.
//
////////////////////////////////////////////////////////////
BOOL
GetInfoForPID(
	PROC_CNTRS	*pc,		// [OUT]	Process memory counters for the PID
	ULONG		lPID,		// [IN]		PID for the process to query
	CHAR		*szProcess	// [IN]		Process name of the PID to query. ex. "explore", "iexplore". Don't include the extension
)
{
	BOOL	bRet = TRUE;
	INT		n = 0;
	
	while(bRet)
	{
		bRet = GetProcCntrs(pc,n,szProcess);
		if(lPID == pc->lPID)
			break;

		n++;
	}

	return bRet;
}



////////////////////////////////////////////////////////////
// Function:  GetMemoryCounters(MEM_CNTRS)
//
// Purpose:
//	Gets and returns the memory info for the system.
//
////////////////////////////////////////////////////////////
BOOL
GetMemoryCounters(
	MEM_CNTRS *pMemCounters	// [OUT] Memory counters for the current machine
)
{
	BOOL						bRet                        = FALSE;
	HQUERY						hQuery                      = 0;
    HCOUNTER					aryHCounter[MEMCOUNTERS]    = {0};
	DWORD						dwPathSize                  = MAX_PATH;
	int							n;
	PDH_FMT_COUNTERVALUE		cntVal;
	char						szAryMemoryCntrs[MEMCOUNTERS][1024];

	sprintf(szAryMemoryCntrs[0],"\\Memory\\Committed Bytes");
	sprintf(szAryMemoryCntrs[1],"\\Memory\\Commit Limit");
	sprintf(szAryMemoryCntrs[2],"\\Memory\\System Code Total Bytes");
	sprintf(szAryMemoryCntrs[3],"\\Memory\\System Driver Total Bytes");
	sprintf(szAryMemoryCntrs[4],"\\Memory\\Pool Nonpaged Bytes");
	sprintf(szAryMemoryCntrs[5],"\\Memory\\Pool Paged Bytes");
	sprintf(szAryMemoryCntrs[6],"\\Memory\\Available Bytes");
	sprintf(szAryMemoryCntrs[7],"\\Memory\\Cache Bytes");
	sprintf(szAryMemoryCntrs[8],"\\Memory\\Free System Page Table Entries");


	if(!(ERROR_SUCCESS == g_lpfnPdhOpenQuery (0, 0, &hQuery)))
	   goto exit;

	for (n = 0; n < MEMCOUNTERS; n++) 
	{ 
		if(!(ERROR_SUCCESS == g_lpfnPdhAddCounter (hQuery,  szAryMemoryCntrs[n], 0, &aryHCounter[n])))
        {
			goto exit;
        }
	}

	if(!(ERROR_SUCCESS == g_lpfnPdhCollectQueryData(hQuery)))
		goto exit;

	for (n=0; n < MEMCOUNTERS; n++) 
	{ 
		if(!(ERROR_SUCCESS == g_lpfnPdhGetFormattedCounterValue (aryHCounter[n],PDH_FMT_LONG,0,&cntVal)))
        {
			goto exit;
        }
        *((ULONG*)pMemCounters+n) = cntVal.longValue;
	} 

	bRet = TRUE;

exit:
	for(n=0;n<MEMCOUNTERS;n++)
    {
		if(aryHCounter[n])
        {
			g_lpfnPdhRemoveCounter(aryHCounter[n]);
        }
    }

	if(hQuery)
		g_lpfnPdhCloseQuery(hQuery);

	return bRet;
}


////////////////////////////////////////////////////////////
// Function:  GetAvailableSystemDriveSpace(long)
//
// Purpose:
//	Gets and returns the disk space available on the system drive.
//
////////////////////////////////////////////////////////////
BOOL 
GetAvailableSystemDriveSpace(
	long	*lAvail		// [OUT] Buffer containing the space on the system drive
)
{
    BOOL                bRet    = FALSE;
    char                szSystemPath[MAX_PATH];
    ULARGE_INTEGER      FreeBytesAvailable;         // bytes available to caller
    ULARGE_INTEGER      TotalNumberOfBytes;         // bytes on disk
    ULARGE_INTEGER      TotalNumberOfFreeBytes;     // free bytes on disk
    int                 i;
    DWORD               dwFoo = 0;

    if(!GetSystemDirectoryA(szSystemPath,sizeof(szSystemPath)))
    {
        goto exit;
    }

    //We only want the drive letter
    for(i=0; i<1+lstrlenA(szSystemPath); i++)
    {
        if(szSystemPath[i] == 0)
        {
            goto exit;
        }

        if(szSystemPath[i] == '\\')
        {
            szSystemPath[i+1] = 0;
            break;
        }
    }

    if(GetDiskFreeSpaceExA(szSystemPath,&FreeBytesAvailable,&TotalNumberOfBytes,&TotalNumberOfFreeBytes))
    {
        *lAvail = __int32(TotalNumberOfFreeBytes.QuadPart / 1024 / 1000);
        bRet = TRUE;
    }

exit:
    return bRet;
}


////////////////////////////////////////////////////////////
// Function:  MemStats__SendSystemMemoryLog(LPSTR, DWORD, DWORD)
//
// Purpose:
//	Sends a memory log to the Command Server.
//	Sends the stressInstance ID and client machine name as part of the POST request.
//
////////////////////////////////////////////////////////////
BOOL
MemStats__SendSystemMemoryLog(
	LPSTR szExeName,			// [IN] Name of the process. ex. "explorer", "iexplorer". No extension.
	DWORD dwPID,				// [IN] PID for the above process
	DWORD dwStressInstanceID	// [IN] The stress instanceID
)
{
    BOOL            bRet        = FALSE;
    HMODULE         hPdhLib     = NULL;
    MEM_CNTRS       mc          = {0};
    long			lAvailDriveSpace	= 0;

	DWORD			dwPostDataSize	= MAX_PATH*10;
	DWORD			dwDataFieldSize	= 100;
	LPSTR			szPostData	= new CHAR[dwPostDataSize];
	LPSTR			szDataField	= new CHAR[dwDataFieldSize];
	LPSTR			szFileName	= new CHAR[MAX_PATH];
	PROC_CNTRS		pc;


    if(!InitPdhLibrary(&hPdhLib) || !szExeName)
    {
        goto exit;
    }
	
	// Remove the extension from the filename if there is one
	ZeroMemory(szFileName, MAX_PATH);
	strncpy(szFileName, szExeName, MAX_PATH);
	PathRemoveExtensionA(szFileName);


	ZeroMemory(szPostData,	dwPostDataSize);
	ZeroMemory(szDataField,	dwDataFieldSize);


	// *** !!! need this because NetworkTools__SendLog(...) sends szPost data as fieldname "LogText="
	// so we need an & to delimit memory info fields from "real" log text.
	strcat(szPostData, "&");

	// *************************
	// *************************
	// ** Get process info
	// **
	if (szFileName && GetInfoForPID(&pc, dwPID, szFileName))
	{
		sprintf(szDataField, FIELDNAME__STRESSEXE_HANDLECOUNT,		pc.lHandles);
		strcat(szPostData, szDataField);
		strcat(szPostData, "&");

		sprintf(szDataField, FIELDNAME__STRESSEXE_THREADCOUNT,		pc.lThreads);
		strcat(szPostData, szDataField);
		strcat(szPostData, "&");

		sprintf(szDataField, FIELDNAME__STRESSEXE_PRIVATEBYTES,		pc.lPrivBytes);
		strcat(szPostData, szDataField);
		strcat(szPostData, "&");
	}

	// *************************
	// *************************
	// ** Get system memory info
	// **
	if (GetMemoryCounters(&mc))
    {
		sprintf(szDataField, FIELDNAME__MEMORY_COMMITTEDPAGEFILETOTAL,		mc.lCommittedBytes/1024);
		strcat(szPostData, szDataField);
		strcat(szPostData, "&");

		sprintf(szDataField, FIELDNAME__MEMORY_AVAILABLEPAGEFILETOTAL,		(mc.lCommitLimit - mc.lCommittedBytes)/1024);
		strcat(szPostData, szDataField);
		strcat(szPostData, "&");
		
		sprintf(szDataField, FIELDNAME__MEMORY_SYSTEMCODETOTAL,				mc.lSystemCodeTotalBytes/1024);
		strcat(szPostData, szDataField);
		strcat(szPostData, "&");
		
		sprintf(szDataField, FIELDNAME__MEMORY_SYSTEMDRIVERTOTAL,			mc.lSystemDriverTotalBytes/1024);
		strcat(szPostData, szDataField);
		strcat(szPostData, "&");
		
		sprintf(szDataField, FIELDNAME__MEMORY_NONPAGEDPOOLTOTAL,			mc.lPoolNonpagedBytes/1024);
		strcat(szPostData, szDataField);
		strcat(szPostData, "&");
		
		sprintf(szDataField, FIELDNAME__MEMORY_PAGEDPOOLTOTAL,				mc.lPoolPagedBytes/1024);
		strcat(szPostData, szDataField);
		strcat(szPostData, "&");
		
		sprintf(szDataField, FIELDNAME__MEMORY_PHYSICAL_MEMORY_AVAILABLE,	mc.lAvailableBytes/1024);
		strcat(szPostData, szDataField);
		strcat(szPostData, "&");
		
		sprintf(szDataField, FIELDNAME__MEMORY_SYSTEMCACHETOTAL,			mc.lCacheBytes/1024);
		strcat(szPostData, szDataField);
		strcat(szPostData, "&");
		
		sprintf(szDataField, FIELDNAME__MEMORY_FREESYSTEM_PAGETABLE_ENTRIES,mc.lFreeSystemPageTableEntries);
		strcat(szPostData, szDataField);
		strcat(szPostData, "&");
    }


	// *************************
	// *************************
	// ** Get disk space info
	// **
    if (GetAvailableSystemDriveSpace(&lAvailDriveSpace))
	{
		sprintf(szDataField, FIELDNAME__MEMORY_DISK_SPACE_AVAILABLE, lAvailDriveSpace);
		strcat(szPostData, szDataField);
		strcat(szPostData, "&");
	}

	NetworkTools__SendLog(FIELDNAME__LOGTYPE_MEMORY_INFORMATION, szPostData, NULL, dwStressInstanceID);

exit:

	// FYI: Recent Whistler main build deadlocks in unload of the PDH library
    if(hPdhLib)
    {
        FreeLibrary(hPdhLib);
    }

	delete [] szPostData;
	delete [] szDataField;
	delete [] szFileName;

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\tools\spork\src\spobj\ui.cxx ===
/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Copyright (c) 2001  Microsoft Corporation

Module Name:

    ui.cxx

Abstract:

    Implements the Spork object's UI routines.
    
Author:

    Paul M Midgen (pmidge) 22-February-2001


Revision History:

    22-February-2001 pmidge
        Created

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/


#include <common.h>


HRESULT
Spork::_LaunchUI(void)
{
  HRESULT hr      = S_OK;
  int     nResult = 1;
  MSG     msg     = {0};

  if( _InitializeUI() )
  {
    LogTrace(L"launching ui");

    while( (nResult != 0) && (nResult != -1) )
    {
      nResult = GetMessage(&msg, NULL, 0,0);

      if( !IsDialogMessage(m_DlgWindows.Dialog, &msg) )
      {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
      }
    }
  }
  else
  {
    LogTrace(L"ui initialization failed");
    hr = E_FAIL;
  }

  return hr;
}


BOOL
Spork::_InitializeUI(void)
{
  BOOL                 bRet = FALSE;
  RECT                 rDialog;
  RECT                 rScreen;
  INITCOMMONCONTROLSEX icex;

  icex.dwSize = sizeof(INITCOMMONCONTROLSEX);
  icex.dwICC  = ICC_TREEVIEW_CLASSES | ICC_LISTVIEW_CLASSES;

  if( InitCommonControlsEx(&icex) )
  {
    m_DlgWindows.Dialog = CreateDialogParam(
                            m_hInst,
                            MAKEINTRESOURCE(IDD_SPORK),
                            0,
                            DlgProc,
                            (LPARAM) this
                            );
    
    if( m_DlgWindows.Dialog )
    {
      GetWindowRect(GetDesktopWindow(), &rScreen);
      GetWindowRect(m_DlgWindows.Dialog, &rDialog);

      MoveWindow(
        m_DlgWindows.Dialog,
        ((rScreen.right / 2) - (rDialog.right / 2)),
        ((rScreen.bottom / 2) - (rDialog.bottom /2)),
        rDialog.right,
        rDialog.bottom,
        FALSE
        );

      ShowWindow(m_DlgWindows.Dialog, SW_SHOWDEFAULT);
      bRet = TRUE;
    }
  }
  
  return bRet;
}


BOOL
Spork::_BrowseForScriptFile(void)
{
  BOOL         bSelected = FALSE;
  OPENFILENAME ofn       = {0};

  // if we're running on win9x, we need to use a top-secret, super-special
  // value for the struct size. *yawn*
  if( IsRunningOnNT() )
  {
    ofn.lStructSize = sizeof(OPENFILENAME);
  }
  else
  {
    ofn.lStructSize = OPENFILENAME_SIZE_VERSION_400;
  }

  ofn.hwndOwner    = m_DlgWindows.Dialog;
  ofn.lpstrFile    = new WCHAR[MAX_PATH];
  ofn.nMaxFile     = MAX_PATH;
  ofn.lpstrFilter  = L"Script Files (js, vbs)\0*.js;*.vbs\0All Files\0*.*\0\0\0";
  ofn.nFilterIndex = 1;
  ofn.Flags        = OFN_DONTADDTORECENT | OFN_FILEMUSTEXIST | OFN_PATHMUSTEXIST;

  if( ofn.lpstrFile )
  {
    *ofn.lpstrFile = L'\0';

    if( GetOpenFileName(&ofn) )
    {
      SAFEDELETEBUF(m_wszScriptFile);
      m_wszScriptFile = ofn.lpstrFile;
      bSelected = TRUE;
    }
    else
    {
      SAFEDELETEBUF(ofn.lpstrFile);
    }
  }

  return bSelected;
}


//-----------------------------------------------------------------------------
// dialog window procedure
//-----------------------------------------------------------------------------
INT_PTR
Spork::_DlgProc(
  HWND   hwnd,
  UINT   uMsg,
  WPARAM wParam,
  LPARAM lParam
  )
{
  switch( uMsg )
  {
    case WM_INITDIALOG :
      {
        m_DlgWindows.ScriptFile = GetDlgItem(hwnd, IDT_SCRIPTPATH);
        m_DlgWindows.TreeView   = GetDlgItem(hwnd, IDC_SCRIPTTREE);

        if( m_wszScriptFile )
        {
          SetWindowText(
            m_DlgWindows.ScriptFile,
            m_wszScriptFile
            );

          SetFocus(
            GetDlgItem(hwnd, IDB_RUN)
            );
        }
        else
        {
          SetFocus(m_DlgWindows.ScriptFile);
        }
      }
      return 0L;

    case WM_CLOSE :
      {
        wParam = IDB_QUIT;
      }

    case WM_COMMAND :
      {
        switch( LOWORD(wParam) )
        {
          case IDB_BROWSE :
            {
              if( _BrowseForScriptFile() )
              {
                SetWindowText(
                  m_DlgWindows.ScriptFile,
                  m_wszScriptFile
                  );

                SendMessage(
                  m_DlgWindows.ScriptFile,
                  EM_SETMODIFY,
                  (WPARAM) FALSE,
                  (LPARAM) 0
                  );
              }
            }
            break;

          case IDB_RUN :
            {
              _RunClicked();
            }
            break;

          case IDB_CONFIG :
            {
              _ConfigClicked();
            }
            break;

          case IDB_QUIT :
            {
              DestroyWindow(m_DlgWindows.Dialog);
              PostQuitMessage(0);
              m_DlgWindows.Dialog = NULL;
            }
            return 1L;
        }
      }
      return 0L;

    default : return 0L;
  }
}


//-----------------------------------------------------------------------------
// handlers for dialog events
//-----------------------------------------------------------------------------
INT_PTR
Spork::_RunClicked(void)
{
  HRESULT     hr      = S_OK;
  HANDLE      hThread = NULL;
  PSCRIPTINFO psi     = NULL;

  //
  // first check to see if someone updated the script path manually.
  //
  if( SendMessage(m_DlgWindows.ScriptFile, EM_GETMODIFY, (WPARAM) 0, (LPARAM) 0) )
  {
    SAFEDELETEBUF(m_wszScriptFile);

    m_wszScriptFile = new WCHAR[MAX_PATH];

    if( m_wszScriptFile )
    {
      GetWindowText(m_DlgWindows.ScriptFile, m_wszScriptFile, MAX_PATH);

      if( !wcslen(m_wszScriptFile) )
      {
        SAFEDELETEBUF(m_wszScriptFile);
      }
    }
    else
    {
      THROWMEMALERT(L"WCHAR[MAX_PATH]");
    }
  }

  //
  // now run the script, if one has been selected.
  //
  if( m_wszScriptFile )
  {
    psi = new SCRIPTINFO;

    if( psi )
    {
      psi->bIsFork         = FALSE;
      psi->bstrChildParams = NULL;
      psi->htParent        = TVI_ROOT;
      psi->pSpork          = this;
      hr                   = CreateScriptThread(psi, &hThread);

      if( SUCCEEDED(hr) )
      {        
        SAFECLOSE(hThread);
      }
      else
      {
        SAFEDELETE(psi);
      }
    }
    else
    {
      THROWMEMALERT(L"SCRIPTINFO");
    }
  }
  else
  {
    Alert(FALSE, L"Please select a script to run.");
  }

  return 0L;
}


INT_PTR
Spork::_ConfigClicked(void)
{
  DWORD           error = ERROR_SUCCESS;
  PROPSHEETHEADER psh   = {0};
  PROPSHEETPAGE   psp[2];

  memset(&psp, 0, sizeof(PROPSHEETPAGE) * 2);

  // initialize the propertysheet struct
  psh.dwSize     = sizeof(PROPSHEETHEADER);
  psh.dwFlags    = PSH_NOCONTEXTHELP | PSH_PROPSHEETPAGE | PSH_USEICONID;
  psh.hwndParent = m_DlgWindows.Dialog;
  psh.hInstance  = m_hInst;
  psh.pszIcon    = MAKEINTRESOURCE(IDI_PROFILE);
  psh.pszCaption = L"Spork Configuration";
  psh.nPages     = (sizeof(psp) / sizeof(PROPSHEETPAGE));
  psh.nStartPage = 0;
  psh.ppsp       = (LPCPROPSHEETPAGE) &psp;

  // initialize the "profiles" page
  psp[0].dwSize      = sizeof(PROPSHEETPAGE);
  psp[0].pszTemplate = MAKEINTRESOURCE(IDD_PROPPAGE_PROFILE);
  psp[0].hInstance   = m_hInst;
  psp[0].pfnDlgProc  = ProfilePropPageProc;
  psp[0].lParam      = (LPARAM) this;

  // initialize the "debug" page
  psp[1].dwSize      = sizeof(PROPSHEETPAGE);
  psp[1].pszTemplate = MAKEINTRESOURCE(IDD_PROPPAGE_DEBUG);
  psp[1].hInstance   = m_hInst;
  psp[1].pfnDlgProc  = DebugPropPageProc;
  psp[1].lParam      = (LPARAM) this;

  if( !PropertySheet(&psh) )
  {
    error = GetLastError();
  }

  return error;
}


//-----------------------------------------------------------------------------
// friend dialog proc, delegates to private class member
//-----------------------------------------------------------------------------
INT_PTR
CALLBACK
DlgProc(
  HWND   hwnd,
  UINT   uMsg,
  WPARAM wParam,
  LPARAM lParam
  )
{
  static PSPORK ps = NULL;

  if( !ps )
  {
    switch( uMsg )
    {
      case WM_INITDIALOG :
        {
          ps = (PSPORK) lParam;
        }
        break;
      
      default : return FALSE;
    }
  }

  return ps->_DlgProc(hwnd, uMsg, wParam, lParam);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\tools\spork\src\spobj\spork.cxx ===
/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Copyright (c) 2001  Microsoft Corporation

Module Name:

    spork.cxx

Abstract:

    Implements the non-interface class members of the Spork object.
    
Author:

    Paul M Midgen (pmidge) 22-February-2001


Revision History:

    22-February-2001 pmidge
        Created

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/


#include <common.h>


//-----------------------------------------------------------------------------
// Class members
//-----------------------------------------------------------------------------
Spork::Spork():
  m_hInst(NULL),
  m_pTypeLib(NULL),
  m_wszScriptFile(NULL),
  m_wszProfile(NULL),
  m_bProfilesLoaded(FALSE),
  m_pObjectCache(NULL),
  m_pPropertyBag(NULL),
  m_pMLV(NULL)
{
  DEBUG_TRACE((L"Spork [%#x] created", this));
}


Spork::~Spork()
{
  if( m_pObjectCache )
  {
    m_pObjectCache->Clear();
    SAFEDELETE(m_pObjectCache);
  }

  if( m_pPropertyBag )
  {
    m_pPropertyBag->Clear();
    SAFEDELETE(m_pPropertyBag);
  }

  SAFEDELETE(m_pMLV);
  SAFERELEASE(m_pScriptEngine[JSCRIPT]);
  SAFERELEASE(m_pScriptEngine[VBSCRIPT]);
  SAFERELEASE(m_pTypeLib);
  SAFEDELETEBUF(m_wszScriptFile);
  SAFEDELETEBUF(m_wszProfile);

  DEBUG_TRACE((L"Spork [%#x] deleted", this));
}


HRESULT
Spork::Create(
  HINSTANCE hInst,
  PSPORK*   pps
  )
{
  HRESULT hr = S_OK;
  PSPORK  ps = NULL;

  if( !pps )
  {
    hr = E_POINTER;
    goto quit;
  }

  if( ps = new SPORK )
  {
    hr = ps->_Initialize(hInst);

    if( SUCCEEDED(hr) )
    {
      LogTrace(L"spork initialized");
      *pps = ps;
    }
    else
    {
      SAFEDELETE(ps);
    }
  }
  else
  {
    hr = E_OUTOFMEMORY;
  }

quit:

  return hr;
}


HRESULT
Spork::_Initialize(
  HINSTANCE hInst
  )
{
  HRESULT hr   = S_OK;
  LPWSTR  path = NULL;

  m_hInst = hInst;

  m_pObjectCache = new OBJCACHE;

    if( !m_pObjectCache )
    {
      hr = E_OUTOFMEMORY;
      goto quit;
    }

  m_pPropertyBag = new PROPERTYBAG;

    if( !m_pPropertyBag )
    {
      hr = E_OUTOFMEMORY;
      goto quit;
    }

  m_pObjectCache->SetClearFunction(ObjectKiller);
  m_pPropertyBag->SetClearFunction(VariantKiller);

  path = new WCHAR[MAX_PATH];

    if( !path )
    {
      hr = E_OUTOFMEMORY;
      goto quit;
    }

  if( GetModuleFileName(NULL, path, MAX_PATH) )
  {
    hr = LoadTypeLib(path, &m_pTypeLib);
  }
  else
  {
    LogTrace(L"spork failed to load its typeinfo");
    hr = E_FAIL;
  }
  
  SAFEDELETEBUF(path);

quit:

  return hr;
}


HRESULT
Spork::Run(void)
{
  HRESULT     hr      = S_OK;
  HANDLE      hThread = NULL;
  PSCRIPTINFO psi     = NULL;
  DBGOPTIONS  dbo;

  m_wszScriptFile = GlobalGetScriptName();
  m_wszProfile    = GlobalGetProfileName();

  if( !m_wszProfile )
  {
    m_wszProfile = StrDup(L"default");
  }

  if( !_InitProfileSupport(NULL, m_wszProfile) )
  {
    LogTrace(L"failed to init profile support");
  }

  if( GlobalIsSilentModeEnabled() )
  {
    if( !m_wszScriptFile )
    {
      LogTrace(L"no script to run, exiting");
      goto quit;
    }

    psi = new SCRIPTINFO;

      if( !psi )
      {
        hr = E_OUTOFMEMORY;
        goto quit;
      }

    psi->bIsFork         = FALSE;
    psi->bstrChildParams = NULL;
    psi->htParent        = TVI_ROOT;
    psi->pSpork          = this;
    hr                   = CreateScriptThread(psi, &hThread);

      if( FAILED(hr) )
      {
        SAFEDELETE(psi);
        goto quit;
      }

    WaitForSingleObject(hThread, INFINITE);
    SAFECLOSE(hThread);
  }
  else
  {
    hr = _LaunchUI();
  }
  
quit:

  return hr;
}


//-----------------------------------------------------------------------------
// 'Service interface' methods
//-----------------------------------------------------------------------------
HRESULT
Spork::CreateScriptThread(
  PSCRIPTINFO pScriptInfo,
  HANDLE*     pThreadHandle
  )
{
  HRESULT hr         = S_OK;
  DWORD   dwThreadId = 0L;

  if( pScriptInfo )
  {
    //
    // default behavior: if the caller's scriptinfo doesn't name a script,
    // we use the last script selected into the spork object.
    //
    if( !pScriptInfo->wszScriptFile )
    {
      pScriptInfo->wszScriptFile = m_wszScriptFile;
    }

    LogTrace(L"running script %s", pScriptInfo->wszScriptFile);

    *pThreadHandle = CreateThread(
                       NULL,
                       0L,
                       ScriptThread,
                       (LPVOID) pScriptInfo,
                       0L,
                       &dwThreadId
                       );

    if( !(*pThreadHandle) )
    {
      LogTrace(L"failed to create script thread");
      hr = E_FAIL;
    }
  }
  else
  {
    hr = E_INVALIDARG;
  }

  return hr;
}


HRESULT
Spork::GetScriptEngine(
  SCRIPTTYPE      st,
  IActiveScript** ppias
  )
{
  HRESULT        hr     = S_OK;
  IActiveScript* pias   = NULL;
  CLSID          clsid  = {0};
  LPWSTR         progid = NULL;

  if( st == UNKNOWN )
  {
    LogTrace(L"the script type is unknown, aborting");
    hr = E_FAIL;
    goto quit;
  }

  if( m_pScriptEngine[st] )
  {
    pias = m_pScriptEngine[st];
  }
  else
  {
    switch( st )
    {
      case JSCRIPT  : progid = L"JScript";   break;
      case VBSCRIPT : progid = L"VBScript";  break;
      default       : hr     = E_INVALIDARG; goto quit;
    }

    LogTrace(L"loading %s engine", progid);

    hr = CLSIDFromProgID(progid, &clsid);

      if( FAILED(hr) )
        goto quit;

    hr = CoCreateInstance(
           clsid,
           NULL,
           CLSCTX_INPROC_SERVER,
           IID_IActiveScript,
           (void**) &m_pScriptEngine[st]
           );

      if( FAILED(hr) )
      {
        LogTrace(L"load failed: %s", MapHResultToString(hr));
        goto quit;
      }
        
    pias = m_pScriptEngine[st];
  }

  hr = pias->Clone(ppias);

quit:

  return hr;
}


HRESULT
Spork::GetTypeLib(
  ITypeLib** pptl
  )
{
  return m_pTypeLib->QueryInterface(IID_ITypeLib, (void**) pptl);
}


HRESULT
Spork::GetNamedProfileItem(
  LPWSTR  wszItemName,
  LPVOID* ppvItem
  )
{
  HRESULT hr     = E_FAIL;
  BOOL    bRet   = FALSE;
  DWORD   dwType = 0L;
  LPVOID  pvData = NULL;

  if( m_bProfilesLoaded )
  {
    bRet = m_pMLV->GetItemByName(
                     -1,
                     wszItemName,
                     &dwType,
                     &pvData
                     );

    if( bRet )
    {
      if( dwType == MLV_STRING )
      {
        *ppvItem = (LPVOID) StrDup((LPWSTR) pvData);
      }
      else
      {
        *ppvItem              = (LPVOID) new DWORD;
        *((DWORD_PTR*) *ppvItem) = (DWORD_PTR) pvData;
      }

      hr = S_OK;
    }
  }

  return hr;
}


HRESULT
Spork::GetProfileDebugOptions(
  PDBGOPTIONS pdbo
  )
{
  if( m_bProfilesLoaded )
  {
    m_pMLV->GetDebugOptions(pdbo);
  }
  else
  {
    pdbo->bEnableDebug        = FALSE;
    pdbo->bBreakOnScriptStart = FALSE;
    pdbo->bEnableDebugWindow  = FALSE;
  }
  
  return S_OK;
}


HRESULT
Spork::ObjectCache(
  LPWSTR       wszObjectName,
  PCACHEENTRY* ppCacheEntry,
  ACTION       action
  )
{
  HRESULT hr = S_OK;

  switch( action )
  {
    case STORE :
      {
        (*ppCacheEntry)->pDispObject->AddRef();
        m_pObjectCache->Insert(wszObjectName, (void*) *ppCacheEntry);
      }
      break;

    case RETRIEVE :
      {
        if( m_pObjectCache->Get(wszObjectName, (void**) ppCacheEntry) == ERROR_SUCCESS )
        {
          (*ppCacheEntry)->pDispObject->AddRef();
        }
        else
        {
          hr = E_FAIL;
        }
      }
      break;

    case REMOVE :
      {
        m_pObjectCache->Delete(wszObjectName, NULL);
      }
      break;
  }

  return hr;
}


HRESULT
Spork::PropertyBag(
  LPWSTR    wszPropertyName,
  VARIANT** ppvarValue,
  ACTION    action
  )
{
  HRESULT  hr  = S_OK;
  VARIANT* pvr = NULL;

  switch( action )
  {
    case STORE :
      {
        pvr = new VARIANT;
        VariantInit(pvr);

        hr = VariantCopy(pvr, *ppvarValue);

        if( SUCCEEDED(hr) )
        {
          m_pPropertyBag->Insert(wszPropertyName, (void*) pvr);
        }
      }
      break;

    case RETRIEVE :
      {
        if( m_pPropertyBag->Get(wszPropertyName, (void**) &pvr) == ERROR_SUCCESS )
        {
          hr = VariantCopy(*ppvarValue, pvr);
        }
        else
        {
          V_VT(*ppvarValue) = VT_NULL;
        }
      }
      break;

    case REMOVE :
      {
        m_pPropertyBag->Delete(wszPropertyName, NULL);
      }
      break;
  }

  return hr;
}


HRESULT
Spork::NotifyUI(
  BOOL       bInsert,
  LPCWSTR    wszName,
  PSCRIPTOBJ pScriptObject,
  HTREEITEM  htParent,
  HTREEITEM* phtItem
  )
{
  HRESULT        hr = S_OK;
  HTREEITEM      ht = NULL;
  TVINSERTSTRUCT tvins;
  TVITEM         item;

  if( bInsert )
  {
    item.mask       = TVIF_TEXT | TVIF_PARAM;
    item.pszText    = (LPWSTR) wszName;
    item.cchTextMax = wcslen(wszName);
    item.lParam     = (LPARAM) pScriptObject;

    tvins.item      = item;
    tvins.hParent   = htParent;

    *phtItem = (HTREEITEM) TreeView_InsertItem(m_DlgWindows.TreeView, &tvins);
    TreeView_EnsureVisible(m_DlgWindows.TreeView, *phtItem);

    if( htParent == TVI_ROOT )
    {
      EnableWindow(GetDlgItem(m_DlgWindows.Dialog, IDB_RUN), FALSE);
    }
  }
  else
  {
    TreeView_DeleteItem(m_DlgWindows.TreeView, *phtItem);

    if( htParent == TVI_ROOT )
    {
      EnableWindow(GetDlgItem(m_DlgWindows.Dialog, IDB_RUN), TRUE);
    }
    else
    {
      TreeView_EnsureVisible(m_DlgWindows.TreeView, htParent);
    }
  }

  return hr;
}


//-----------------------------------------------------------------------------
// hashtable support functions
//-----------------------------------------------------------------------------
void
CObjectCache::GetHashAndBucket(LPWSTR id, LPDWORD lpHash, LPDWORD lpBucket)
{
  *lpHash   = GetHash(id);
  *lpBucket = (*lpHash) % 10;
}


void
CPropertyBag::GetHashAndBucket(LPWSTR id, LPDWORD lpHash, LPDWORD lpBucket)
{
  *lpHash   = GetHash(id);
  *lpBucket = (*lpHash) % 10;
}


void
ObjectKiller(LPVOID* ppv)
{
  PCACHEENTRY pce = (PCACHEENTRY) *ppv;

  if( pce )
  {
    pce->pDispObject->Release();
    SAFEDELETE(pce);
  }
}


void
VariantKiller(LPVOID* ppv)
{
  VARIANT** ppvr = (VARIANT**) ppv;

  VariantClear(*ppvr);
  SAFEDELETE(*ppvr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\tools\stress\memstats.h ===
///////////////////////////////////////////////////////////////////////////
// File:  MemStats.h
//
// Copyright (c) 2001 Microsoft Corporation.  All Rights Reserved.
//
// Purpose:
//	MemStats.h: Helper functions that get's the system memory info.
//	Borrowed from EricI's memstats app.
//
// History:
//	03/21/01	DennisCh	Created
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_MEMSTATS_H__D91043CB_5CB3_47C9_944F_B9FAA9BD26C4__INCLUDED_)
#define AFX_MEMSTATS_H__D91043CB_5CB3_47C9_944F_B9FAA9BD26C4__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000


//////////////////////////////////////////////////////////////////////
// Includes
//////////////////////////////////////////////////////////////////////

#define UNICODE
#define _UNICODE

//
// WIN32 headers
//
#include <windows.h>
#include <pdh.h>
#include <shlwapi.h>

//
// Project headers
//
#include "WinHttpStressScheduler.h"
#include "ServerCommands.h"


//////////////////////////////////////////////////////////////////////
// Constants
//////////////////////////////////////////////////////////////////////


// struct for process memory stats
#define PROCCOUNTERS    4
struct PROC_CNTRS {
	ULONG lPID;
	ULONG lPrivBytes;
	ULONG lHandles;
	ULONG lThreads;
};

// struct for system wide memory stats
#define MEMCOUNTERS     9
struct MEM_CNTRS {
    ULONG lCommittedBytes;
    ULONG lCommitLimit;
    ULONG lSystemCodeTotalBytes;
    ULONG lSystemDriverTotalBytes;
    ULONG lPoolNonpagedBytes;
    ULONG lPoolPagedBytes;
    ULONG lAvailableBytes;
    ULONG lCacheBytes;
    ULONG lFreeSystemPageTableEntries;
};


BOOL MemStats__SendSystemMemoryLog(LPSTR, DWORD, DWORD);


#endif // !defined(AFX_MEMSTATS_H__D91043CB_5CB3_47C9_944F_B9FAA9BD26C4__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\tools\spork\src\spobj\profpage.cxx ===
/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Copyright (c) 2001  Microsoft Corporation

Module Name:

    profpage.cxx

Abstract:

    Implements the profile options property page.
    
Author:

    Paul M Midgen (pmidge) 22-February-2001


Revision History:

    22-February-2001 pmidge
        Created

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/


#include <common.h>


HWND g_hwndListBox = NULL;


//-----------------------------------------------------------------------------
// dialog window procedures
//-----------------------------------------------------------------------------
INT_PTR
Spork::_ProfilePropPageProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam) 
{
  switch( uMsg )
  {
    case WM_INITDIALOG :
      {
        g_hwndListBox = GetDlgItem(hwnd, IDC_PROFILELIST);

        // disable delete profile button. notimpl.
        EnableWindow(GetDlgItem(hwnd, IDB_DELPROFILE), FALSE);

        _InitProfileSupport(hwnd, NULL);
      }
      return 0L;

    case WM_NOTIFY :
      {
        switch( ((NMHDR*) lParam)->code )
        {
          case PSN_APPLY :
            {
              _SaveProfiles();
              SetWindowLongPtr(hwnd, DWLP_MSGRESULT, (LONG_PTR) PSNRET_NOERROR);
            }
            return 1L;

          case PSN_KILLACTIVE :
            {
              SetWindowLongPtr(hwnd, DWLP_MSGRESULT, (LONG_PTR) FALSE);
            }
            return 1L;

          case LVN_GETDISPINFO :
            {
              m_pMLV->GetDisplayInfo(&(((NMLVDISPINFO*) lParam)->item));
            }
            break;

          case NM_DBLCLK :
            {
              if( ((LPNMITEMACTIVATE) lParam)->iItem == 0xFFFFFFFF )
              {
                m_pMLV->InPlaceEdit((LPNMITEMACTIVATE) lParam);
              }
            }
            break;

          case PSN_TRANSLATEACCELERATOR :
            {
              HWND  hwndCtl = NULL;
              LPMSG pm      = (LPMSG) ((LPPSHNOTIFY) lParam)->lParam;
              WCHAR buf[64];

              switch( pm->message )
              {
                case WM_KEYDOWN : 
                  {
                    if( pm->wParam == VK_RETURN )
                    {
                      hwndCtl = WindowFromPoint(pm->pt);

                      if( hwndCtl )
                      {
                        GetClassName(hwndCtl, buf, 64);

                        if( !StrCmpI(buf, L"edit") )
                        {
                          SendMessage(
                            GetParent(hwndCtl),
                            WM_COMMAND,
                            MAKEWPARAM(0, EN_KILLFOCUS),
                            (LPARAM) hwndCtl
                            );

                          SetWindowLongPtr(hwnd, DWLP_MSGRESULT, PSNRET_MESSAGEHANDLED);
                        }
                        else
                        {
                          SetWindowLongPtr(hwnd, DWLP_MSGRESULT, PSNRET_NOERROR);
                        }
                      }

                      return 1L;
                    }
                  }
                  break;
              }
            }
            break;
        }
      }

    case WM_COMMAND :
      {
        switch( LOWORD(wParam) )
        {
          case IDB_NEWPROFILE :
            {
              _NewProfile(hwnd);
            }
            break;

          case IDB_DELPROFILE :
            {
              // notimpl
            }
            break;

          default :
            {
              switch( HIWORD(wParam) )
              {
                case LBN_DBLCLK :
                  {
                    m_pMLV->ActivateListViewByIndex(
                              ListBox_GetSelectionIndex(g_hwndListBox)
                              );
                  }
                  break;
              }
            }
            break;
        }
      }
      break;

    default : return 0L;
  }

  return 0L;
}


//-----------------------------------------------------------------------------
// handlers for dialog events
//-----------------------------------------------------------------------------
INT_PTR
Spork::_InitProfileSupport(HWND hwndDialog, LPWSTR wszProfile)
{
  BOOL  bSuccess = FALSE;
  POINT pt;
  RECT  rcDlg;
  RECT  rcCtl;

  if( !m_pMLV )
  {
    if( !(m_pMLV = new MultiListView) )
      goto quit;

    if( m_pMLV->InitializeData(GetNumberOfSubKeysFromKey(L"Profiles")) )
    {
      m_bProfilesLoaded = _LoadProfiles();
      bSuccess          = m_bProfilesLoaded;
    }
    else
    {
      SAFEDELETE(m_pMLV);
      goto quit;
    }
  }

  if( wszProfile )
  {
    bSuccess = m_pMLV->ActivateListViewByName(wszProfile);
  }

  if( hwndDialog )
  {
    GetWindowRect(hwndDialog, &rcDlg);
    GetWindowRect(GetDlgItem(hwndDialog, IDC_PROFILEITEMS), &rcCtl);

    pt.x = rcCtl.left - rcDlg.left;
    pt.y = rcCtl.top  - rcDlg.top;

    bSuccess = m_pMLV->InitializeDisplay(
                         m_hInst,
                         hwndDialog,
                         &pt,
                         rcCtl.right  - rcCtl.left,
                         rcCtl.bottom - rcCtl.top
                         );

      if( !bSuccess )
        goto quit;

    bSuccess = m_pMLV->RefreshListView(-1);

      if( !bSuccess )
        goto quit;

    bSuccess = _InitProfileSelection();

      if( !bSuccess )
        goto quit;

    ListBox_SetCurrentSelection(g_hwndListBox, m_pMLV->GetActiveIndex());
    m_pMLV->ActivateListViewByIndex(m_pMLV->GetActiveIndex());
  }

quit:

  return (INT_PTR) bSuccess;
}


BOOL
Spork::_InitProfileSelection(void)
{
  LPWSTR wszName = NULL;
  
  ListBox_ResetContent(g_hwndListBox);

  while( m_pMLV->EnumListViewNames(&wszName) )
  {
    ListBox_InsertString(g_hwndListBox, -1, wszName);
    SAFEDELETEBUF(wszName);
  }

  return TRUE;
}


BOOL
Spork::_LoadProfiles(void)
{
  BOOL   bSuccess    = FALSE;
  BOOL   bEntry      = FALSE;
  LPWSTR wszSubKey   = NULL;
  DWORD  dwProfileId = 0L;

  if( !m_bProfilesLoaded )
  {
    bEntry = EnumerateSubKeysFromKey(L"Profiles", &wszSubKey);

    while( bEntry )
    {
      _LoadProfileEntries(dwProfileId, wszSubKey);

      SAFEDELETEBUF(wszSubKey);
      ++dwProfileId;

      // we loaded at least a single profile, so we're good to go
      bSuccess = TRUE;
      bEntry   = EnumerateSubKeysFromKey(NULL, &wszSubKey);
    }

    _LoadDebugOptions();
  }

  return bSuccess;
}


BOOL
Spork::_SaveProfiles(void)
{
  INT_PTR cProfiles = ListBox_GetItemCount(g_hwndListBox);

  for(INT_PTR n=0; n<cProfiles; n++)
  {
    if( m_pMLV->IsModified(n) )
    {
      BOOL   bEntry         = FALSE;
      LPWSTR wszProfileName = ListBox_GetItemText(g_hwndListBox, n);
      LPWSTR wszProfileKey  = new WCHAR[MAX_PATH+1];
      LPWSTR wszValueName   = NULL;
      LPVOID pvData         = NULL;
      DWORD  dwType         = 0L;

      StrCpyN(
        (StrCpy(wszProfileKey, L"Profiles\\") + wcslen(L"Profiles\\")),
        wszProfileName,
        MAX_PATH+1
        );

      bEntry = m_pMLV->EnumItems(n, &wszValueName, &dwType, &pvData);

      while( bEntry )
      {
        SetRegValueInKey(
          wszProfileKey,
          wszValueName,
          dwType,
          (dwType == REG_DWORD ? &pvData : pvData),
          0L
          );

        bEntry = m_pMLV->EnumItems(-1, &wszValueName, &dwType, &pvData);
      }

      SAFEDELETEBUF(wszProfileName);
      SAFEDELETEBUF(wszProfileKey);
    }
  }

  return TRUE;
}


BOOL
Spork::_LoadProfileEntries(INT_PTR dwProfileId, LPWSTR wszProfileName)
{
  BOOL   bSuccess      = FALSE;
  BOOL   bEntry        = FALSE;
  LPWSTR wszProfileKey = NULL;
  LPWSTR wszValueName  = NULL;
  LPVOID pvValueData   = NULL;
  DWORD  dwType        = 0L;

  m_pMLV->SetListViewName(dwProfileId, wszProfileName);

  wszProfileKey = new WCHAR[MAX_PATH+1];

  StrCpyN(
    (StrCpy(wszProfileKey, L"Profiles\\") + wcslen(L"Profiles\\")),
    wszProfileName,
    MAX_PATH+1
    );

  bEntry = EnumerateRegValuesFromKey(wszProfileKey, &wszValueName, &dwType, &pvValueData);

    while( bEntry )
    {
      // we read at least one profile item, so we can return success
      bSuccess = TRUE;

      // items prefixed with an underscore are used by other property pages
      if( *wszValueName != L'_' )
      {
        m_pMLV->AddItem(dwProfileId, wszValueName, dwType, pvValueData);
      }

      SAFEDELETEBUF(wszValueName);
      SAFEDELETEBUF(pvValueData);

      // get next value
      bEntry = EnumerateRegValuesFromKey(NULL, &wszValueName, &dwType, &pvValueData);
    }

  SAFEDELETEBUF(wszProfileKey);
  return bSuccess;
}


LPWSTR
Spork::_GetCurrentProfilePath(void)
{
  LPWSTR wszProfileKey  = NULL;
  LPWSTR wszProfileName = NULL;

  if( m_pMLV )
  {
    if( m_pMLV->GetListViewName(-1, &wszProfileName) )
    {
      wszProfileKey = new WCHAR[MAX_PATH+1];

      if( wszProfileKey )
      {
        StrCpyN(
          (StrCpy(wszProfileKey, L"Profiles\\") + wcslen(L"Profiles\\")),
          wszProfileName,
          MAX_PATH+1
          );
      }

      SAFEDELETEBUF(wszProfileName);
    }
  }

  return wszProfileKey;
}


BOOL
Spork::_NewProfile(HWND hwnd)
{
  BOOL   bStatus     = FALSE;
  LPWSTR NewProfile  = NULL;
  LPWSTR ProfilePath = NULL;
  LPWSTR DefInclude  = NULL;

  NewProfile = (LPWSTR) GetUserInput(m_hInst, hwnd, L"Create Profile");

  if( NewProfile )
  {
    ProfilePath = new WCHAR[MAX_PATH];

    if( ProfilePath )
    {
      wnsprintf(
        ProfilePath,
        MAX_PATH,
        L"%s\\%s",
        L"Profiles",
        NewProfile
        );

      if( SetRegKey(ProfilePath, NULL) )
      {
        if( GetRootRegValue(L"InstallDir", REG_SZ, (void**) &DefInclude) )
        {
          if( SetRegValueInKey(ProfilePath, L"include", REG_SZ, (void*) DefInclude, 0) )
          {
            if( m_pMLV )
            {
              m_pMLV->TerminateDisplay();
              SAFEDELETE(m_pMLV);
              m_bProfilesLoaded = FALSE;
            }
          
            _InitProfileSupport(hwnd, NewProfile);
            bStatus = TRUE;
          }

          SAFEDELETEBUF(DefInclude);
        }
      }

      SAFEDELETEBUF(ProfilePath);
    }

    SAFEDELETEBUF(NewProfile);
  }

  return bStatus;
}


INT_PTR
CALLBACK
ProfilePropPageProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
  static PSPORK ps = NULL;

  if( !ps )
  {
    switch( uMsg )
    {
      case WM_INITDIALOG :
        {
          ps = (PSPORK) ((LPPROPSHEETPAGE) lParam)->lParam;
        }
        break;
      
      default : return FALSE;
    }
  }

  return ps->_ProfilePropPageProc(hwnd, uMsg, wParam, lParam);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\tools\stress\stressinstance.cpp ===
//////////////////////////////////////////////////////////////////////
// File:  StressInstance.cpp
//
// Copyright (c) 2001 Microsoft Corporation.  All Rights Reserved.
//
// Purpose:
//	StressInstance.cpp: interface for the StressInstance class.
//	This class is used spawn and monitor instances of the stressEXE app
//
// History:
//	02/15/01	DennisCh	Created
//
//////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////
//
// Includes
//
//////////////////////////////////////////////////////////////////////

//
// Win32 headers
//

//
// Project headers
//
#include "StressInstance.h"
#include "ServerCommands.h"
#include "NetworkTools.h"
#include "MemStats.h"
#include "debugger.h"

//////////////////////////////////////////////////////////////////////
//
// Globals and statics
//
//////////////////////////////////////////////////////////////////////

extern ServerCommands	g_objServerCommands;	// Declared in WinHttpStressScheduler.cpp
extern HWND				g_hWnd;					// Declared in WinHttpStressScheduler.cpp

StressInstance			*g_hThis;				// the current StressInstance object. Used only in (friend) StressExe_TimerProc.
UINT_PTR				g_uiStressExeTimerID;	// ID for the timer that monitors the stressExe when it's spawned

// Forward function definitions

VOID
CALLBACK
StressExe_TimerProc(
	HWND hwnd,         // [IN] handle to window
	UINT uMsg,         // [IN] WM_TIMER message
	UINT_PTR idEvent,  // [IN] timer identifier
	DWORD dwTime       // [IN] current system time
);

DWORD
DebuggerCallbackProc(
	DWORD	dwFlags,
	LPVOID	lpIn,
	LPTSTR	lpszFutureString,
	LPVOID	lpFuturePointer
);


//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////


StressInstance::StressInstance()
{
	m_szStressExe_URL					= new TCHAR[MAX_STRESS_URL];
	m_szStressExe_PDB_URL				= new TCHAR[MAX_STRESS_URL];
	m_szStressExe_SYM_URL				= new TCHAR[MAX_STRESS_URL];
	m_szStressExe_FilePath				= new TCHAR[MAX_STRESS_URL];
	m_szStressExe_FileName				= new TCHAR[MAX_STRESS_URL];
	m_szStressExe_FilePathAndName		= new TCHAR[MAX_STRESS_URL];
	m_szStressExe_PageHeapCommandLine	= new TCHAR[MAX_PATH];
	m_szStressExe_UMDHCommandLine		= new TCHAR[MAX_PATH];
	m_szStressExe_MemDumpPath			= new TCHAR[MAX_PATH];

	ZeroMemory(m_szStressExe_URL,					MAX_STRESS_URL);
	ZeroMemory(m_szStressExe_PDB_URL,				MAX_STRESS_URL);
	ZeroMemory(m_szStressExe_SYM_URL,				MAX_STRESS_URL);
	ZeroMemory(m_szStressExe_FilePath,				MAX_STRESS_URL);
	ZeroMemory(m_szStressExe_FileName,				MAX_STRESS_URL);
	ZeroMemory(m_szStressExe_FilePathAndName,		MAX_STRESS_URL);
	ZeroMemory(m_szStressExe_PageHeapCommandLine,	MAX_PATH);
	ZeroMemory(m_szStressExe_UMDHCommandLine,		MAX_PATH);
	ZeroMemory(m_szStressExe_MemDumpPath,			MAX_PATH);
	
	ZeroMemory(&m_piStressExeProcess, sizeof(PROCESS_INFORMATION));

	m_hStressExe_ProcessExitEvent	= NULL;
	g_uiStressExeTimerID			= 0;

	m_objDebugger	= NULL;

	g_hThis			= this;
}


StressInstance::~StressInstance()
{
	// End any running tests
	if (IsRunning(STRESSINSTANCE_STRESS_EXE_CLOSE_TIMEOUT))
		StressInstance::End();

	delete [] m_szStressExe_URL;
	delete [] m_szStressExe_PDB_URL;
	delete [] m_szStressExe_SYM_URL;
	delete [] m_szStressExe_FilePath;
	delete [] m_szStressExe_FileName;
	delete [] m_szStressExe_FilePathAndName;
	delete [] m_szStressExe_PageHeapCommandLine;
	delete [] m_szStressExe_UMDHCommandLine;
	delete [] m_szStressExe_MemDumpPath;
	

	m_szStressExe_URL					= NULL;
	m_szStressExe_PDB_URL				= NULL;
	m_szStressExe_SYM_URL				= NULL;
	m_szStressExe_FilePath				= NULL;
	m_szStressExe_FileName				= NULL;
	m_szStressExe_FilePathAndName		= NULL;
	m_szStressExe_PageHeapCommandLine	= NULL;
	m_szStressExe_UMDHCommandLine		= NULL;
	m_szStressExe_MemDumpPath			= NULL;

	// close stressExe process handles
	if (m_piStressExeProcess.hThread)
		CloseHandle(m_piStressExeProcess.hThread);

	if (m_piStressExeProcess.hProcess)
		CloseHandle(m_piStressExeProcess.hProcess);

	if (m_hStressExe_ProcessExitEvent)
		CloseHandle(m_hStressExe_ProcessExitEvent);

	m_piStressExeProcess.hThread	= NULL;
	m_piStressExeProcess.hProcess	= NULL;
	m_hStressExe_ProcessExitEvent	= NULL;

	// free debugger object
	if (m_objDebugger)
	{
		delete m_objDebugger;
		m_objDebugger = NULL;
	}

	g_hThis = NULL;
}


////////////////////////////////////////////////////////////
// Function:  StressInstance::Begin()
//
// Purpose:
//	This method begins stress by downloading the stress EXE from
//	m_szStressExe_URL and starts it in CDB.
//
////////////////////////////////////////////////////////////
BOOL
StressInstance::Begin()
{
	BOOL			bResult					= TRUE;
	LPTSTR			szCommandLine			= new TCHAR[MAX_STRESS_URL*4];
	LPTSTR			szFileNameAndPath		= new TCHAR[MAX_STRESS_URL*2];
	DWORD			dwCommandLineSize		= MAX_STRESS_URL*4;
	DWORD			dwFileNameAndPathSize	= MAX_STRESS_URL*2;
	LPSTARTUPINFO	pStartUpInfo			= new STARTUPINFO;


	// don't start if stress is already running or we don't have a FileName or Path.
	if (IsRunning(5000) ||
		0 >= _tcslen(m_szStressExe_FilePath) ||
		0 >= _tcslen(m_szStressExe_FileName))
		goto Exit;


	// ********************************
	// ********************************
	// ** Download the stressExe and symbols.
	// **
	if (!DownloadStressExe())
	{
		bResult = FALSE;
		goto Exit;
	}


	// ********************************
	// ********************************
	// ** Enable pageheap if needed
	// **
	if (0 < _tcsclen(m_szStressExe_PageHeapCommandLine))
	{
		if (!NetworkTools__PageHeap(TRUE, m_szStressExe_FileName, m_szStressExe_PageHeapCommandLine))
		{
			NetworkTools__SendLog(FIELDNAME__LOGTYPE_ERROR, "Pageheap failed when trying to enable.", NULL, Get_ID());
			bResult = FALSE;
			// goto Exit; don't need to exit when pageheap fails
		}
		else
			NetworkTools__SendLog(FIELDNAME__LOGTYPE_SUCCESS, "Pageheap successfully enabled.", NULL, Get_ID());
	}


	// ********************************
	// ********************************
	// ** Create the stressExe process
	// **

	// build Remote/CDB/stressExe path
	ZeroMemory(szCommandLine, dwCommandLineSize);
	_stprintf(szCommandLine, STRESSINSTANCE_DEBUG_COMMANDLINE, m_szStressExe_FilePathAndName);

	// startupInfo
	ZeroMemory(pStartUpInfo, sizeof(STARTUPINFO));
	pStartUpInfo->cb				= sizeof(STARTUPINFO);
	pStartUpInfo->dwFillAttribute	= FOREGROUND_RED| BACKGROUND_RED| BACKGROUND_GREEN| BACKGROUND_BLUE; // red text on white background
	pStartUpInfo->dwFlags			= STARTF_USESHOWWINDOW;
	pStartUpInfo->wShowWindow		= SW_MINIMIZE;


	// Create the stressExe process
	bResult =
	CreateProcess(
		NULL,
		m_szStressExe_FilePathAndName,
		NULL, 
		NULL,
		TRUE,
		CREATE_NEW_CONSOLE | CREATE_SEPARATE_WOW_VDM | NORMAL_PRIORITY_CLASS | CREATE_NEW_PROCESS_GROUP | CREATE_SUSPENDED,
		NULL,
		NULL,
		pStartUpInfo,
		&m_piStressExeProcess);


	if (!bResult)
	{
		// stressExe failed to start 
		goto Exit;
	}


	// ********************************
	// ********************************
	// ** Attach debugger to the process only if there isn't one
	// **

	// remove debugger if there is one
	if (m_objDebugger)
	{
		delete m_objDebugger;
		m_objDebugger = NULL;
	}

	// attach new debugger
	Sleep(2000);
	m_objDebugger = new Debugger(m_piStressExeProcess.dwProcessId, DebuggerCallbackProc);
	m_objDebugger->Go();

	ResumeThread(m_piStressExeProcess.hThread);

	
	// ********************************
	// ********************************
	// ** Initialize dynamically named event objects.
	// ** Set object access to ALL.
	// **

	// Create event object that'll be inherited by the stressExe process.
	// StressScheduler will signal when it's time to close stressExe.
	SECURITY_ATTRIBUTES		securityAttributes;
	PSECURITY_DESCRIPTOR	pSD;

	pSD = new SECURITY_DESCRIPTOR;

	// Set a NULL security descriptor. This gives full access to handles when inherited
	InitializeSecurityDescriptor(pSD, SECURITY_DESCRIPTOR_REVISION);
	SetSecurityDescriptorDacl(pSD, TRUE, (PACL) NULL, FALSE);

	securityAttributes.bInheritHandle		= TRUE;
	securityAttributes.lpSecurityDescriptor	= pSD;
	securityAttributes.nLength				= sizeof(securityAttributes);


	// The named event object names have the PID of the process appended to the end of the constants
	// These strings are also created in the stressExe dynamically.
	LPTSTR szExitProcessName;
	LPTSTR szPID;

	szExitProcessName		= new TCHAR[MAX_PATH];
	szPID					= new TCHAR[16];

	// Get the processID string
	_itot(m_piStressExeProcess.dwProcessId, szPID, 10);

	// build ExitProcess event object name
	_tcscpy(szExitProcessName, STRESSINSTANCE_STRESS_EXE_EVENT_EXITPROCESS);
	_tcscat(szExitProcessName, szPID);

	if (m_hStressExe_ProcessExitEvent)
		CloseHandle(m_hStressExe_ProcessExitEvent);

	// this event is sent by us to stressExe when we want it to exit
	// Signaled = tell stressExe to exit; Not-Signaled = stressExe can continue running
	m_hStressExe_ProcessExitEvent = CreateEvent(
		&securityAttributes,
		FALSE,	// manual reset
		FALSE,
		szExitProcessName);


	delete [] szExitProcessName;
	delete [] szPID;
	delete [] pSD;


	// ********************************
	// ********************************
	// ** Begin the stressExe memory monitoring timerproc
	// **
	if (g_uiStressExeTimerID)
	{
		// there shouldn't be a timer already going. If so, nuke it.
		KillTimer(NULL, g_uiStressExeTimerID);
		g_uiStressExeTimerID = 0;
	}

	// create a new timer object
	g_uiStressExeTimerID =
	SetTimer(
		NULL,
		0,
		STRESSINSTANCE_MONITOR_EXE_TIME,
		(TIMERPROC) StressExe_TimerProc);



	// Notify the Command Server that stress has started
	NetworkTools__SendLog(FIELDNAME__LOGTYPE_BEGIN, "This stressInstance has begun.", NULL, Get_ID());

Exit:
	delete [] szCommandLine;
	delete [] szFileNameAndPath;
	delete [] pStartUpInfo;

	return bResult;
}


////////////////////////////////////////////////////////////
// Function:  StressInstance::End()
//
// Purpose:
//	This method ends stress by sending a message
//
////////////////////////////////////////////////////////////
VOID
StressInstance::End()
{
	// ******************************
	// ******************************
	// ** End the stressExe monitoring timerproc
	if (g_uiStressExeTimerID)
		KillTimer(NULL, g_uiStressExeTimerID);


	// ******************************
	// ******************************
	// ** Tell stressExe to shut down.
	SetEvent(m_hStressExe_ProcessExitEvent);

	// give time for the stressExe to exit
	Sleep(2000);

	// close stressExe process handles
	if (m_piStressExeProcess.hThread)
		CloseHandle(m_piStressExeProcess.hThread);

	if (m_piStressExeProcess.hProcess)
		CloseHandle(m_piStressExeProcess.hProcess);

	if (m_hStressExe_ProcessExitEvent)
		CloseHandle(m_hStressExe_ProcessExitEvent);

	m_piStressExeProcess.hThread	= NULL;
	m_piStressExeProcess.hProcess	= NULL;
	m_hStressExe_ProcessExitEvent	= NULL;


	// stop stressExe if it's still running
	if (IsRunning(STRESSINSTANCE_STRESS_EXE_CLOSE_TIMEOUT))
	{
		// stressExe failed to signal that it exited.
		// Bad stressExe, terminate the process.
		BOOL temp = TerminateProcess(m_piStressExeProcess.hProcess, 0);
	}


	// ********************************
	// ********************************
	// ** Detach the debugger object
	// **

	// detaching the debugger will (read: should) stop the stressExe
	if (m_objDebugger)
	{
		// ********************************
		// ********************************
		// ** Disable pageheap if needed
		// **
		NetworkTools__PageHeap(FALSE, m_szStressExe_FileName, NULL);

		// let the Command Server know that stressExe has ended
		// we send the message here because ServerCommands.cpp calls this too - even when
		// there isn't a running test case.
		// When the debugger object is valid, then we send the message - because it ensures that Begin() was called.
		NetworkTools__SendLog(FIELDNAME__LOGTYPE_END, "This stressInstance has ended.", NULL, Get_ID());

		delete m_objDebugger;
		m_objDebugger	= NULL;
	}

	ZeroMemory(&m_piStressExeProcess, sizeof(PROCESS_INFORMATION));
}


////////////////////////////////////////////////////////////
// Function:  StressInstance::Get_StressExeID()
//
// Purpose:
//	Returns the stress instance's ID receivedfrom the server
//
////////////////////////////////////////////////////////////
DWORD
StressInstance::Get_ID()
{
	return m_dwStressExe_ID;
}


////////////////////////////////////////////////////////////
// Function:  StressInstance::Get_StressExeMemoryDumpPath()
//
// Purpose:
//	Sets the URL of the memory dump path
//
////////////////////////////////////////////////////////////
LPTSTR
StressInstance::Get_StressExeMemoryDumpPath()
{
	return m_szStressExe_MemDumpPath;
}


////////////////////////////////////////////////////////////
// Function:  StressInstance::Set_StressExeMemoryDumpPath()
//
// Purpose:
//	Sets the URL of the memory dump path
//
////////////////////////////////////////////////////////////
VOID
StressInstance::Set_StressExeMemoryDumpPath(
	LPTSTR szPath
)
{
	_tcsncpy(m_szStressExe_MemDumpPath, szPath, MAX_PATH);
}


////////////////////////////////////////////////////////////
// Function:  StressInstance::Set_StressExeURL(LPTSTR)
//
// Purpose:
//	Sets the URL to download the stress EXE for this object.
//
////////////////////////////////////////////////////////////
VOID
StressInstance::Set_StressExeURL(
	LPTSTR szBuffer	// [IN] Buffer containing the URL to download the stressExe app
)
{
	if (!szBuffer || (0 >= _tcslen(szBuffer)))
		return;

	_tcscpy(m_szStressExe_URL, szBuffer);

	// Set the stressExe's filename
	NetworkTools__GetFileNameFromURL(m_szStressExe_URL, m_szStressExe_FileName, MAX_STRESS_URL);

	// Set the stressExe's default path to download to with trailing slash
	GetCurrentDirectory(MAX_STRESS_URL, m_szStressExe_FilePath);
	_tcscat(m_szStressExe_FilePath, _T("\\") STRESSINSTANCE_STRESS_EXE_DOWNLOAD_DIR _T("\\"));

	// Set the full stressExe path + exe
	_tcscpy(m_szStressExe_FilePathAndName, m_szStressExe_FilePath);
	_tcscat(m_szStressExe_FilePathAndName, m_szStressExe_FileName);
}


////////////////////////////////////////////////////////////
// Function:  StressInstance::Set_StressExePdbURL(LPTSTR)
//
// Purpose:
//	Sets the URL to download the stress EXE's PDB file.
//
////////////////////////////////////////////////////////////
VOID
StressInstance::Set_StressExePdbURL(
	LPTSTR szBuffer	// [IN] Buffer containing the URL
)
{
	if (!szBuffer || (0 >= _tcslen(szBuffer)))
		return;

	_tcscpy(m_szStressExe_PDB_URL, szBuffer);
}


////////////////////////////////////////////////////////////
// Function:  StressInstance::Set_StressExeSymURL(LPTSTR)
//
// Purpose:
//	Sets the URL to download the stress EXE's SYM file.
//
////////////////////////////////////////////////////////////
VOID
StressInstance::Set_StressExeSymURL(
	LPTSTR szBuffer	// [IN] Buffer containing the URL
)
{
	if (!szBuffer || (0 >= _tcslen(szBuffer)))
		return;

	_tcscpy(m_szStressExe_SYM_URL, szBuffer);
}


////////////////////////////////////////////////////////////
// Function:  StressInstance::Set_StressExeID(DWORD)
//
// Purpose:
//	Sets the URL to download the stress EXE for this object.
//
////////////////////////////////////////////////////////////
VOID
StressInstance::Set_StressExeID(
	DWORD dwID	// [IN] ID from the stressAdmin DB uniquely identifying this stress EXE. 
)
{
	m_dwStressExe_ID = dwID;
}


////////////////////////////////////////////////////////////
// Function:  StressInstance::Set_PageHeapCommands(LPCTSTR)
//
// Purpose:
//	Sets the pageheap command line.
//
////////////////////////////////////////////////////////////
VOID
StressInstance::Set_PageHeapCommands(
	LPCTSTR szCommandLine	// [IN] Extra command line params for pageheap.
)
{
	ZeroMemory(m_szStressExe_PageHeapCommandLine, MAX_PATH);
	_tcsncpy(m_szStressExe_PageHeapCommandLine, szCommandLine, MAX_PATH-1);
}


////////////////////////////////////////////////////////////
// Function:  StressInstance::Set_UMDHCommands(LPCTSTR)
//
// Purpose:
//	Sets the UMDH command line.
//
////////////////////////////////////////////////////////////
VOID
StressInstance::Set_UMDHCommands(
	LPCTSTR szCommandLine	// [IN] Extra command line params for UMDH.
)
{
	ZeroMemory(m_szStressExe_UMDHCommandLine, MAX_PATH);
	_tcsncpy(m_szStressExe_UMDHCommandLine, szCommandLine, MAX_PATH-1);
}


////////////////////////////////////////////////////////////
// Function:  StressInstance::DownloadStressExe()
//
// Purpose:
//	Downloads the stressExe app to the local machine.
//	We create a directory of the stress exe name. For example,
//	"http://hairball/files/stress1.exe" will be put in "stress1\stress1.exe"
//	on the local machine. If the file is already there, it'll try to overwrite it.
//
////////////////////////////////////////////////////////////
BOOL
StressInstance::DownloadStressExe()
{
	BOOL	bResult		= TRUE;
	LPTSTR	szFileName	= new TCHAR[MAX_PATH];

	// Download the stressExe file
	if (NetworkTools__URLDownloadToFile(m_szStressExe_URL, STRESSINSTANCE_STRESS_EXE_DOWNLOAD_DIR, m_szStressExe_FileName))
		NetworkTools__SendLog(FIELDNAME__LOGTYPE_SUCCESS, "stress EXE file downloaded successfully.", NULL, Get_ID());
	else
	{
		NetworkTools__SendLog(FIELDNAME__LOGTYPE_ERROR, "stress EXE file not downloaded.", NULL, Get_ID());
		bResult = FALSE;
	}

	// Download PDB symbol file if there is one
	if (NetworkTools__GetFileNameFromURL(m_szStressExe_PDB_URL, szFileName, MAX_PATH))
	{
		NetworkTools__URLDownloadToFile(m_szStressExe_PDB_URL, STRESSINSTANCE_STRESS_EXE_DOWNLOAD_DIR, szFileName);
		NetworkTools__SendLog(FIELDNAME__LOGTYPE_SUCCESS, "stress PDB file downloaded successfully.", NULL, Get_ID());
	}
	else
		NetworkTools__SendLog(FIELDNAME__LOGTYPE_ERROR, "stress PDB file not downloaded.", NULL, Get_ID());

	// Download SYM symbol file if there is one
	if (NetworkTools__GetFileNameFromURL(m_szStressExe_SYM_URL, szFileName, MAX_PATH))
	{
		NetworkTools__SendLog(FIELDNAME__LOGTYPE_SUCCESS, "stress SYM file downloaded successfully.", NULL, Get_ID());
		NetworkTools__URLDownloadToFile(m_szStressExe_SYM_URL, STRESSINSTANCE_STRESS_EXE_DOWNLOAD_DIR, szFileName);
	}
	else
		NetworkTools__SendLog(FIELDNAME__LOGTYPE_ERROR, "streses SYM file not downloaded.", NULL, Get_ID());

	delete [] szFileName;
	return bResult;
}


////////////////////////////////////////////////////////////
// Function:  StressInstance::IsRunning()
//
// Purpose:
//	Returns TRUE if this stressinstance is running. FALSE if not.
//
////////////////////////////////////////////////////////////
BOOL StressInstance::IsRunning(DWORD dwTimeOut)
{
	BOOL	bResult		= FALSE;
	HANDLE	hStressExe	= NULL;

	hStressExe = OpenProcess(PROCESS_ALL_ACCESS, FALSE, m_piStressExeProcess.dwProcessId);

	if (!hStressExe)
		bResult = FALSE;
	else
	{
		bResult = TRUE;
		CloseHandle(hStressExe);
	}

	return bResult;
}


////////////////////////////////////////////////////////////
// Function:  StressExe_TimerProc(HWND, UINT, UINT_PTR, DWORD)
//
// Purpose:
//	When this is called, we will check on the status of the
//	stressExe process send the command server it's memory info
//
////////////////////////////////////////////////////////////
VOID
CALLBACK
StressExe_TimerProc(
	HWND hwnd,         // [IN] handle to window - should be NULL since we didn't specify one
	UINT uMsg,         // [IN] WM_TIMER message
	UINT_PTR idEvent,  // [IN] timer identifier
	DWORD dwTime       // [IN] current system time
)
{
	// build directory to copy dump file
	LPSTR	szExeName = new CHAR[MAX_STRESS_URL];


	if (!g_hThis)
		goto Exit;

	// ***********************************
	// ***********************************
	// ** Check that the stressExe is still running. If it isn't end this instance.
	// **
	if (!g_hThis->IsRunning(STRESSINSTANCE_STRESS_EXE_CLOSE_TIMEOUT))
	{
		NetworkTools__SendLog(FIELDNAME__LOGTYPE_INFORMATION, "This stress instance has exited prematurely.", NULL, g_hThis->Get_ID());
		g_hThis->End();
		goto Exit;
	}


	ZeroMemory(szExeName, MAX_STRESS_URL); 

	// ******************************
	// ** Remove the file extension of the stressExe name and send the system and process
	// ** memory log to the command server
	WideCharToMultiByte(
		CP_ACP,
		NULL,
		g_hThis->m_szStressExe_FileName,
		-1,
		szExeName,
		MAX_STRESS_URL,
		NULL,
		NULL);

	MemStats__SendSystemMemoryLog(szExeName, g_hThis->m_piStressExeProcess.dwProcessId, g_hThis->Get_ID());

Exit:
	delete [] szExeName;

	return;
}


////////////////////////////////////////////////////////////
// Function:  DebuggerCallbackProc(DWORD, LPVOID, LPTSTR, LPVOID)
//
// Purpose:
//	Creates a memory dump on second change exceptions
//
////////////////////////////////////////////////////////////
DWORD DebuggerCallbackProc(
	DWORD	dwFlags,
	LPVOID	lpIn,
	LPTSTR	lpszFutureString,
	LPVOID	lpFuturePointer
)
{
	//test callback for debugger lib
	DWORD dwContinue = 0;


	// ***********************************
	// ***********************************
	// ** Check that the stressExe is still running.
	// **
	if (!g_hThis || !g_hThis->IsRunning(STRESSINSTANCE_STRESS_EXE_CLOSE_TIMEOUT))
	{
		dwContinue = DEBUGGER_CONTINUE_STOP_DEBUGGING;
		goto Exit;
	}


	switch (dwFlags)
	{
		case DEBUGGER_FIRST_CHANCE_EXCEPTION:
			NetworkTools__SendLog(FIELDNAME__LOGTYPE_INFORMATION, "FIRST_CHANCE_EXCEPTION detected.", NULL, g_hThis->Get_ID());
			//must use this to pass on first chance exceptions to the system
			dwContinue = DEBUGGER_CONTINUE_UNHANDLED;
			break;

		case DEBUGGER_SECOND_CHANCE_EXCEPTION:
			NetworkTools__SendLog(FIELDNAME__LOGTYPE_INFORMATION, "SECOND_CHANCE_EXCEPTION detected.", NULL, g_hThis->Get_ID());

			// build directory to copy dump file
			LPTSTR szPath;
			LPTSTR szNum;
			LPTSTR szMachineName;
			
			szPath			= new TCHAR[MAX_PATH * 2];
			szNum			= new TCHAR[100];
			szMachineName	= new TCHAR[MAX_PATH];

			// ******************************
			// create the directory STRESSINSTANCE_MEMORY_DUMP_PATH\<MachineName>
			MultiByteToWideChar(
				CP_ACP,
				MB_PRECOMPOSED,
				g_objServerCommands.Get_ClientMachineName(),
				-1,
				szMachineName,
				MAX_PATH);

			// if the server sent a vaild path then use it, else use the default memory dump path
			if (0 < _tcslen(g_hThis->Get_StressExeMemoryDumpPath()))
				_tcscpy(szPath, g_hThis->Get_StressExeMemoryDumpPath());
			else
				_tcscpy(szPath, STRESSINSTANCE_DEFAULT_MEMORY_DUMP_PATH);

			// add the machine name to the end of the directory
			_tcscat(szPath, szMachineName);

			CreateDirectory(szPath, NULL);

			// ******************************
			// create the filename in form "<stressExeFileName>-<stressInstanceID>-<PID>.dmp"
			_tcscat(szPath, _T("\\"));

			_tcscat(szPath, g_hThis->m_szStressExe_FileName);
			_tcscat(szPath, _T("-"));

			_itot(g_hThis->Get_ID(), szNum, 10);
			_tcscat(szPath, szNum);
			_tcscat(szPath, _T("-"));

			_itot(g_hThis->m_piStressExeProcess.dwProcessId, szNum, 10);
			_tcscat(szPath, szNum);
			_tcscat(szPath, _T(".dmp"));

			//this creates a full user dump
			g_hThis->m_objDebugger->CreateMiniDump(szPath, _T("This is a full user dump created by debugger.lib"), DEBUGGER_CREATE_FULL_MINI_DUMP);

			delete [] szPath;
			delete [] szNum;
			delete [] szMachineName;


			// let the Command Server know a dump file was created
			NetworkTools__SendLog(FIELDNAME__LOGTYPE_DUMPFILE_CREATED, "User dump file was created.", NULL, g_hThis->Get_ID());

			// stop the debugger
			dwContinue = DEBUGGER_CONTINUE_STOP_DEBUGGING;
			break;

		case DEBUGGER_EXIT_PROCESS:
			dwContinue = DEBUGGER_CONTINUE_STOP_DEBUGGING;
			break;

		default:
			// let the Command Server know a dump file was created
			break;
	}


Exit:
	return dwContinue;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\tools\stress\networktools.h ===
///////////////////////////////////////////////////////////////////////////
// File:  NetworkTools.h
//
// Copyright (c) 2001 Microsoft Corporation.  All Rights Reserved.
//
// Purpose:
//	NetworkTools.h: Helper functions that send/receive data.
//
// History:
//	02/22/01	DennisCh	Created
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_NETWORKTOOLS_H__4243AA4D_B243_4A0E_B729_243F260FC4F4__INCLUDED_)
#define AFX_NETWORKTOOLS_H__4243AA4D_B243_4A0E_B729_243F260FC4F4__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000


//////////////////////////////////////////////////////////////////////
// Includes
//////////////////////////////////////////////////////////////////////

//
// WIN32 headers
//
#define UNICODE
#define _UNICODE

#include <stdio.h>
#include <windows.h>
#include <tchar.h>
#include <winhttp.h>
#include <shlwapi.h>

//
// Project headers
//


//////////////////////////////////////////////////////////////////////
// Constants
//////////////////////////////////////////////////////////////////////

#define		DEBUGGER_TOOLS_PATH		_T("c:\\debuggers\\")

BOOL	NetworkTools__POSTResponse(LPTSTR, LPSTR, LPTSTR);
BOOL	NetworkTools__SendLog(LPSTR, LPSTR, LPTSTR, DWORD);
BOOL	NetworkTools__URLDownloadToFile(LPCTSTR, LPCTSTR, LPCTSTR);
BOOL	NetworkTools__GetFileNameFromURL(LPTSTR, LPTSTR, DWORD);
BOOL	NetworkTools__CopyFile(LPCTSTR, LPCTSTR);
BOOL	NetworkTools__PageHeap(BOOL, LPCTSTR, LPCTSTR);
BOOL	NetworkTools__UMDH(BOOL, LPCTSTR, LPCTSTR, LPCTSTR, DWORD);
BOOL	NetworkTools__GetDllVersion(LPTSTR, LPSTR, DWORD);

#endif // !defined(AFX_NETWORKTOOLS_H__4243AA4D_B243_4A0E_B729_243F260FC4F4__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\tools\stress\stressinstance.h ===
//////////////////////////////////////////////////////////////////////
// File:  StressInstance.h
//
// Copyright (c) 2001 Microsoft Corporation.  All Rights Reserved.
//
// Purpose:
//	StressInstance.h: interface for the StressInstance class.
//	This class is used spawn and monitor instances of the stressEXE app.
//
// History:
//	02/15/01	DennisCh	Created
//
//////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////
// Includes
//////////////////////////////////////////////////////////////////////

//
// WIN32 headers
//
#define UNICODE
#define _UNICODE

#include <stdio.h>
#include <windows.h>
#include <tchar.h>
#include <winhttp.h>

//
// Project headers
//
#include <debugger.h>

//////////////////////////////////////////////////////////////////////
// Constants
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_STRESSINSTANCE_H__806226FB_2170_4FE3_ACCA_EF8952E6A524__INCLUDED_)
#define AFX_STRESSINSTANCE_H__806226FB_2170_4FE3_ACCA_EF8952E6A524__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000


#define	RESPONSE_HEADER__STRESS_BEGIN			_T("WinHttpStress_Begin: Begin Stress")
#define	RESPONSE_HEADER__STRESS_END				_T("WinHttpStress_End: End Stress")


// ***************************
// ** max string URL length
#define MAX_STRESS_URL							MAX_PATH * 2


// ***************************
// ** time to check the stress exe in milliseconds
#define STRESSINSTANCE_MONITOR_EXE_TIME			1200000	// 20 minutes

// ***************************
// ** Command line CreateProcess will use. Takes two params: the path+filename of the stressExe and CDB pipe name
//#define STRESSINSTANCE_DEBUG_COMMANDLINE		_T("c:\\debuggers\\remote.exe /s \"c:\\debuggers\\cdb.exe -g -G \"%s\"\" %s")
#define STRESSINSTANCE_DEBUG_COMMANDLINE		_T("\"%s\"")

// ***************************
// ** Memory dump path
#define	STRESSINSTANCE_DEFAULT_MEMORY_DUMP_PATH	_T("\\\\hairball\\dump$\\")

// ***************************
// ** relative path to the directory where the stressExe files will be downloaded to.
#define STRESSINSTANCE_STRESS_EXE_DOWNLOAD_DIR	_T("stressExe")

// ***************************
// ** Time to wait for stressExe to close after telling it
#define STRESSINSTANCE_STRESS_EXE_CLOSE_TIMEOUT	100

// ***************************
// ** Cross process event object names. We append the PID of the process to the end to prevent name collisions.
#define STRESSINSTANCE_STRESS_EXE_EVENT_EXITPROCESS			_T("ExitProcessEvent")


class StressInstance  
{
public:
				StressInstance();
	virtual		~StressInstance();

	BOOL		Begin();
	VOID		End();
	BOOL		IsRunning(DWORD);

	DWORD		Get_ID();
	LPTSTR		Get_StressExeMemoryDumpPath();

	VOID		Set_StressExeMemoryDumpPath(LPTSTR);
	VOID		Set_StressExeURL(LPTSTR);
	VOID		Set_StressExePdbURL(LPTSTR);
	VOID		Set_StressExeSymURL(LPTSTR);
	VOID		Set_StressExeID(DWORD);
	VOID		Set_PageHeapCommands(LPCTSTR);
	VOID		Set_UMDHCommands(LPCTSTR);

	BOOL		DownloadStressExe();

				// This is the timer callback proc that monitors the stressExe process.
	friend		VOID CALLBACK StressExe_TimerProc(HWND, UINT, UINT_PTR, DWORD);

				// This is the timer callback proc for the debugger object
	friend		DWORD DebuggerCallbackProc(DWORD, LPVOID, LPTSTR, LPVOID);

private:
	DWORD		m_dwStressExe_ID;					// ID from the stressAdmin DB uniquely identifying this stress EXE.
	LPTSTR		m_szStressExe_URL;					// URL to the stress app
	LPTSTR		m_szStressExe_PDB_URL;				// URL to the stress app's pdb file
	LPTSTR		m_szStressExe_SYM_URL;				// URL to the stress app's sym file
	LPTSTR		m_szStressExe_FilePath;				// Local relative path of the downloaded stress EXE
	LPTSTR		m_szStressExe_FileName;				// Local filename of the downloaded stress EXE
	LPTSTR		m_szStressExe_FilePathAndName;		// Path and filename to the local stressExe downloaded
	LPTSTR		m_szStressExe_PageHeapCommandLine;	// Command line params when enabling pageheap.
	LPTSTR		m_szStressExe_UMDHCommandLine;		// Command line params when enabling UMDH.

	LPTSTR		m_szStressExe_MemDumpPath;			// path that the minidump will dump to

	Debugger	*m_objDebugger;						// the debughelp debugger object

	PROCESS_INFORMATION 	m_piStressExeProcess;	// stuct containing info on the stressExe process
	HANDLE					m_hStressExe_ProcessExitEvent;	// Cross process event we send stressExe to tell it to exit
};


#endif // !defined(AFX_STRESSINSTANCE_H__806226FB_2170_4FE3_ACCA_EF8952E6A524__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\tools\stress\networktools.cpp ===
//////////////////////////////////////////////////////////////////////
// File:  NetworkTools.cpp
//
// Copyright (c) 2001 Microsoft Corporation.  All Rights Reserved.
//
// Purpose:
//	NetworkTools.cpp: Helper functions that send/receive data.
//
// History:
//	02/22/01	DennisCh	Created
//
//////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////
//
// Includes
//
//////////////////////////////////////////////////////////////////////

//
// Project headers
//
#include "NetworkTools.h"
#include "ServerCommands.h"

//
// Win32 headers
//


//////////////////////////////////////////////////////////////////////
//
// Globals and statics
//
//////////////////////////////////////////////////////////////////////
extern ServerCommands	g_objServerCommands;	// Declared in WinHttpStressScheduler.cpp
extern HWND				g_hWnd;					// Declared in WinHttpStressScheduler.cpp


////////////////////////////////////////////////////////////
// Function:  NetworkTools__GetFileNameFromURL(LPTSTR)
//
// Purpose:
//	Returns the filename requested from an URL without a querystring.
//	For example, if szURL="http://dennisch/files/test.exe" we return "test.exe"
//
////////////////////////////////////////////////////////////
BOOL
NetworkTools__GetFileNameFromURL(
	LPTSTR	szURL,			// [IN]		Full URL containing the file
	LPTSTR	szBuffer,		// [OUT]	Buffer to store the filename from the URL
	DWORD	dwBufferSize	// [IN]		Size of buffer szFileName
)
{
	TCHAR	*pLastSlash;
	INT		iCharToLookFor;

	if (0 >= _tcslen(szURL))
		return FALSE;

	ZeroMemory(szBuffer, dwBufferSize);

	pLastSlash		= NULL;
	iCharToLookFor	= _T('/');

	// get the last instance of '/'
	pLastSlash = _tcsrchr(szURL, iCharToLookFor);

	// skip the last '/'
	pLastSlash++;

	if (!pLastSlash)
		return FALSE;

	// copy the filename.extension to the buffer
	_tcscpy(szBuffer, pLastSlash);

	return TRUE;
}


////////////////////////////////////////////////////////////
// Function:  NetworkTools__SendResponse(LPTSTR, LPTSTR, LPTSTR)
//
// Purpose:
//	Sends a message to the Command Server results page 
//	via header/headervalue and/or POST data.
//
////////////////////////////////////////////////////////////
BOOL
NetworkTools__POSTResponse(
	LPTSTR	szURL,		// [IN] string containing URL to POST to
	LPSTR	szPostData,	// [IN] string containing POST data to send. can be NULL
	LPTSTR	szHeader	// [IN] string containing header(s) to send. can be NULL
)
{
	BOOL			bResult		= TRUE;
	HINTERNET		hRoot		= NULL;
	HINTERNET		hSession	= NULL;
	HINTERNET		hRequest	= NULL;
	URL_COMPONENTSW	urlComponents;


	// Allocate space for URL components
	ZeroMemory(&urlComponents, sizeof(urlComponents));

	urlComponents.dwSchemeLength	= MAX_PATH;
	urlComponents.lpszScheme		= new TCHAR[MAX_PATH];

	urlComponents.dwHostNameLength  = MAX_PATH;
	urlComponents.lpszHostName		= new TCHAR[MAX_PATH];

	urlComponents.dwUrlPathLength	= MAX_PATH;
	urlComponents.lpszUrlPath		= new TCHAR[MAX_PATH];

	urlComponents.dwExtraInfoLength = MAX_PATH;
	urlComponents.lpszExtraInfo		= new TCHAR[MAX_PATH];
	
	urlComponents.dwUserNameLength	= MAX_PATH;
	urlComponents.lpszUserName		= new TCHAR[MAX_PATH];

	urlComponents.dwPasswordLength	= MAX_PATH;
	urlComponents.lpszPassword		= new TCHAR[MAX_PATH];
	
	urlComponents.nPort				= 0;

	urlComponents.dwStructSize		= sizeof(URL_COMPONENTSW);


	// crack the Command Server URL to be used later
	if (!WinHttpCrackUrl(
			szURL,
			_tcslen(szURL),
			ICU_ESCAPE,
			&urlComponents)
		)
	{
		bResult = FALSE;
		goto Exit;
	}

	hRoot = WinHttpOpen(
		STRESS_SCHEDULER_USER_AGENT,
		WINHTTP_ACCESS_TYPE_NO_PROXY,
		NULL,
		NULL,
		0);

	if (!hRoot)
	{
		bResult = FALSE;
		goto Exit;
	}

	hSession = WinHttpConnect(
		hRoot,
		urlComponents.lpszHostName,
		// If the URL in urlComponents uses standard HTTP or HTTPS ports then use INTERNET_DEFAULT_PORT. Otherwise use the non-standard port gleaned from the URL.
		((urlComponents.nPort == 80) || (urlComponents.nPort == 443)) ? INTERNET_DEFAULT_PORT : urlComponents.nPort,
		0);
	
	if (!hSession)
	{
		bResult = FALSE;
		goto Exit;
	}


	// Build a full URL with path and querystring
	TCHAR szFullPath[MAX_PATH*2];

	_tcsncpy(szFullPath, urlComponents.lpszUrlPath, urlComponents.dwUrlPathLength);
	szFullPath[urlComponents.dwUrlPathLength] = _T('\0');
	_tcsncat(szFullPath, urlComponents.lpszExtraInfo, urlComponents.dwExtraInfoLength);

	hRequest = WinHttpOpenRequest(
		hSession,
		_T("POST"),
		szFullPath,
		NULL,
		NULL,
		NULL,
		// if the URL in urlComponents uses HTTPS then pass in WINHTTP_FLAG_SECURE to this param. Otherwise, 0.
		(0 == _tcsnicmp(urlComponents.lpszScheme, _T("https"), 5)) ? WINHTTP_FLAG_SECURE : 0);

	if (!hRequest)
	{
		bResult = FALSE;
		goto Exit;
	}


	// Set reasonable timeouts just in case
	if (!WinHttpSetTimeouts(hRequest, 5000, 5000, 5000, 5000))
	{
		bResult = FALSE;
		goto Exit;
	}

	// Set result header if not NULL
	if (szHeader)
	{
		if (!WinHttpAddRequestHeaders(
				hRequest,
				szHeader,
				_tcsclen(szHeader),
				WINHTTP_ADDREQ_FLAG_ADD))
		{
			bResult = FALSE;
			goto Exit;
		}
	}


	bResult = WinHttpSendRequest(
		hRequest,
		_T("Content-Type: application/x-www-form-urlencoded"),
		-1L, 
		szPostData,
		strlen(szPostData),
		strlen(szPostData),
		0);

	if (!WinHttpReceiveResponse(hRequest, NULL))
	{
		bResult = FALSE;
		goto Exit;
	}


Exit:
	if (hRequest)
		WinHttpCloseHandle(hRequest);

	if (hSession)
		WinHttpCloseHandle(hSession);

	if (hRoot)
		WinHttpCloseHandle(hRoot);

	delete [] urlComponents.lpszScheme;
	delete [] urlComponents.lpszHostName;
	delete [] urlComponents.lpszUrlPath;
	delete [] urlComponents.lpszExtraInfo;
	delete [] urlComponents.lpszPassword;
	delete [] urlComponents.lpszUserName;

	return bResult;
}


////////////////////////////////////////////////////////////
// Function:  NetworkTools__URLDownloadToFile(LPCTSTR, LPCTSTR, LPCTSTR)
//
// Purpose:
//	Downloads a file pointed to by the URL. Returns TRUE if succesfully downloaded.
//  FALSE if not. If the file is in use (ERROR_SHARING_VIOLATION) then we'll
//	return TRUE because the file is already on the system and is valid.
//
////////////////////////////////////////////////////////////
BOOL
NetworkTools__URLDownloadToFile(
LPCTSTR szURL,			// [IN] Fully qualified URL pointing to the file to download
LPCTSTR szTargetDir,	// [IN] A relative path to the directory to put szTargetFile in. If NULL, then it'll be put in the app's current dir.
LPCTSTR szTargetFile	// [IN] Name of the file to download to. Can be NULL. File will be placed in szTargetDir. If it already exists, then we'll try to overwrite it.
)
{
	HANDLE			hFile		= NULL;
	BOOL			bResult		= TRUE;
	HINTERNET		hRoot		= NULL;
	HINTERNET		hSession	= NULL;
	HINTERNET		hRequest	= NULL;
	URL_COMPONENTSW	urlComponents;


	// Allocate space for URL components
	ZeroMemory(&urlComponents, sizeof(urlComponents));

	urlComponents.dwSchemeLength	= MAX_PATH;
	urlComponents.lpszScheme		= new TCHAR[MAX_PATH];

	urlComponents.dwHostNameLength  = MAX_PATH;
	urlComponents.lpszHostName		= new TCHAR[MAX_PATH];

	urlComponents.dwUrlPathLength	= MAX_PATH;
	urlComponents.lpszUrlPath		= new TCHAR[MAX_PATH];

	urlComponents.dwExtraInfoLength = MAX_PATH;
	urlComponents.lpszExtraInfo		= new TCHAR[MAX_PATH];
	
	urlComponents.dwUserNameLength	= MAX_PATH;
	urlComponents.lpszUserName		= new TCHAR[MAX_PATH];

	urlComponents.dwPasswordLength	= MAX_PATH;
	urlComponents.lpszPassword		= new TCHAR[MAX_PATH];
	
	urlComponents.nPort				= 0;

	urlComponents.dwStructSize		= sizeof(URL_COMPONENTSW);


	// crack the Command Server URL to be used later
	if (!WinHttpCrackUrl(
			szURL,
			_tcslen(szURL),
			ICU_ESCAPE,
			&urlComponents)
		)
	{
		bResult = FALSE;
		goto Exit;
	}

	hRoot = WinHttpOpen(
		STRESS_SCHEDULER_USER_AGENT,
		WINHTTP_ACCESS_TYPE_NO_PROXY,
		NULL,
		NULL,
		0);

	if (!hRoot)
	{
		bResult = FALSE;
		goto Exit;
	}

	hSession = WinHttpConnect(
		hRoot,
		urlComponents.lpszHostName,
		// If the URL in urlComponents uses standard HTTP or HTTPS ports then use INTERNET_DEFAULT_PORT. Otherwise use the non-standard port gleaned from the URL.
		((urlComponents.nPort == 80) || (urlComponents.nPort == 443)) ? INTERNET_DEFAULT_PORT : urlComponents.nPort,
		0);
	
	if (!hSession)
	{
		bResult = FALSE;
		goto Exit;
	}


	// Build a full URL with path and querystring
	TCHAR szFullPath[MAX_PATH*2];

	_tcsncpy(szFullPath, urlComponents.lpszUrlPath, urlComponents.dwUrlPathLength);
	szFullPath[urlComponents.dwUrlPathLength] = _T('\0');
	_tcsncat(szFullPath, urlComponents.lpszExtraInfo, urlComponents.dwExtraInfoLength);

	hRequest = WinHttpOpenRequest(
		hSession,
		_T("GET"),
		szFullPath,
		NULL,
		NULL,
		NULL,
		// if the URL in urlComponents uses HTTPS then pass in WINHTTP_FLAG_SECURE to this param. Otherwise, 0.
		(0 == _tcsnicmp(urlComponents.lpszScheme, _T("https"), 5)) ? WINHTTP_FLAG_SECURE : 0);

	if (!hRequest)
	{
		bResult = FALSE;
		goto Exit;
	}


	// Set reasonable timeouts just in case
	if (!WinHttpSetTimeouts(hRequest, 5000, 5000, 5000, 5000))
	{
		bResult = FALSE;
		goto Exit;
	}


	bResult = WinHttpSendRequest(
		hRequest,
		NULL,
		0, 
		NULL,
		0,
		0,
		0);

	if (!WinHttpReceiveResponse(hRequest, NULL))
	{
		bResult = FALSE;
		goto Exit;
	}


	// **********************************
	// **********************************
	// ** Get the filename and extenstion
	// ** from the URL
	// **
	TCHAR	szFileName[MAX_PATH];		// name of the new file to write to. will be created in szCurrentDir

	ZeroMemory(szFileName, sizeof(szFileName));

	// check to see if the user provided a filename to write to
	if (szTargetFile)
		_tcsncpy(szFileName, szTargetFile, MAX_PATH);
	else
	{
		// user did not specify a filename to write to, so we use the original one from the URL
		if (!NetworkTools__GetFileNameFromURL(urlComponents.lpszUrlPath, szFileName, sizeof(szFileName)))
		{
			bResult = FALSE;
			goto Exit;
		}
	}


	// **********************************
	// **********************************
	// ** Create the directory where the file will reside and set it as the current directory
	// **
	
	// if user specified NULL, then we put the file in the current dir.
	// else we set the current directory as the one specified
	if (szTargetDir)
	{
		// create the dir. don't care if it fails because it already exists...
		CreateDirectory(szTargetDir, NULL);
		SetCurrentDirectory(szTargetDir);
	}


	// create the file to download to.
	hFile = CreateFile(
		// if the user doesn't specify the filename to write to, use the one from the URL
		szFileName,
		GENERIC_WRITE,
		0,
		NULL,
		CREATE_ALWAYS,
		FILE_ATTRIBUTE_NORMAL | FILE_FLAG_WRITE_THROUGH,
		NULL);


	if ((hFile == INVALID_HANDLE_VALUE) || !hFile)
	{
		// We won't return FALSE if the file is in use. This means the file is valid.
		if (ERROR_SHARING_VIOLATION == GetLastError())
		{
			// File is in use that means winhttp is ok. we'll stress the old version
			bResult = TRUE;
			goto Exit;
		}
		else
		{
			bResult = FALSE;
			goto Exit;
		}
	}

	// **********************************
	// **********************************
	// ** Read data from net to file.
	// **
	LPVOID	lpBuffer;
	DWORD	dwBytesToRead, dwBytesRead;

	// read 64K chunks at a time
	lpBuffer		= NULL;
	lpBuffer		= new LPVOID[65536];
	ZeroMemory(lpBuffer, 65536);
	dwBytesToRead	= 65536;
	dwBytesRead		= 65536;

	while (WinHttpReadData(hRequest, lpBuffer, dwBytesToRead, &dwBytesRead) && (0 != dwBytesRead))
	{
		WriteFile(hFile, lpBuffer, dwBytesRead, &dwBytesRead, NULL);

		dwBytesRead = 0;
		ZeroMemory(lpBuffer, sizeof(lpBuffer));
	}

	delete [] lpBuffer;

Exit:
	if (hRequest)
		WinHttpCloseHandle(hRequest);

	if (hSession)
		WinHttpCloseHandle(hSession);

	if (hRoot)
		WinHttpCloseHandle(hRoot);

	if (hFile && (hFile != INVALID_HANDLE_VALUE))
		CloseHandle(hFile);

	// restore the current directory from the one that we created the new file in.
	SetCurrentDirectory(g_objServerCommands.Get_CurrentWorkingDirectory());

	delete [] urlComponents.lpszScheme;
	delete [] urlComponents.lpszHostName;
	delete [] urlComponents.lpszUrlPath;
	delete [] urlComponents.lpszExtraInfo;
	delete [] urlComponents.lpszPassword;
	delete [] urlComponents.lpszUserName;

	return bResult;
}


////////////////////////////////////////////////////////////
// Function:  NetworkTools__CopyFile(LPCTSTR, LPCTSTR)
//
// Purpose:
//	Wrapper for CopyFile. Copies file szSource to szDestination.
//	We'll always overwite the file if it already exists.
//
////////////////////////////////////////////////////////////
BOOL
NetworkTools__CopyFile(
	LPCTSTR szSource,
	LPCTSTR szDestination
)
{
	BOOL bResult = TRUE;
	
	if (!szSource || !szDestination)
	{
		bResult = FALSE;
		goto Exit;
	}

	bResult = CopyFile(szSource, szDestination, TRUE);

Exit:
	return bResult;
}


////////////////////////////////////////////////////////////
// Function:  NetworkTools__PageHeap(BOOL, LPCTSTR)
//
// Purpose:
//	Enables/Disables pageheap.
//
////////////////////////////////////////////////////////////
BOOL
NetworkTools__PageHeap(
	BOOL	bEnable,		// [IN] Enables/Disables pageheap.
	LPCTSTR	szAppName,		// [IN] The executable to enable or disable.
	LPCTSTR	szCommandLine	// [IN] Command line for pageheap.
)
{
	BOOL		bResult	= TRUE;
	HINSTANCE	hExe	= NULL;
	LPTSTR		szPHCommand = new TCHAR[MAX_PATH];

	if (bEnable)
	{
		hExe = ShellExecute(g_hWnd, _T("open"), _T("pageheap.exe"), szCommandLine, NULL, SW_SHOWMINIMIZED);
	}
	else
	{
		ZeroMemory(szPHCommand, MAX_PATH);
		_tcscpy(szPHCommand, _T("/disable "));
		_tcscat(szPHCommand, szAppName);
		hExe = ShellExecute(g_hWnd, _T("open"), _T("pageheap.exe"), szPHCommand, NULL, SW_SHOWMINIMIZED);
	}

	// Error if HINSTANCE <= 32.
	if (32 >= (INT) hExe)
		bResult = FALSE;

	delete [] szPHCommand;

	return bResult;
}


////////////////////////////////////////////////////////////
// Function:  NetworkTools__UMDH(LPCTSTR, DWORD, LPCTSTR)
//
// Purpose:
//	Enables/Disables UMDH.
//
////////////////////////////////////////////////////////////
BOOL
NetworkTools__UMDH(
	BOOL	bEnable,		// [IN] Enables/Disables UMDH.
	LPCTSTR	szAppName,		// [IN] The executable to dump.
	LPCTSTR	szCommandLine,	// [IN] Command line for UMDH.
	LPCTSTR szLogFile,		// [IN] Logfile to create
	DWORD	dwPID			// [IN] The PID of the process to dump
)
{
	BOOL		bResult	= TRUE;
	HINSTANCE	hExe	= NULL;
	LPTSTR		szCommand = new TCHAR[MAX_PATH];

	// build command line and run: "GFLAGS -i <stressExe name> +ust"
	ZeroMemory(szCommand, MAX_PATH);
	_tcscpy(szCommand, _T("-i "));
	_tcscat(szCommand, szAppName);
	_tcscat(szCommand, _T(" +ust"));
	hExe = ShellExecute(g_hWnd, _T("open"), DEBUGGER_TOOLS_PATH _T("gflags.exe"), szCommand, NULL, SW_SHOWMINIMIZED);


	// build the UMDH command line
	ZeroMemory(szCommand, MAX_PATH);
	_tcscpy(szCommand, _T("-f:stuff.log"));

	hExe = ShellExecute(g_hWnd, _T("open"), DEBUGGER_TOOLS_PATH _T("umdh.exe"), szCommand, NULL, SW_SHOWMINIMIZED);

	// Error if HINSTANCE <= 32.
	if (32 >= (INT) hExe)
		bResult = FALSE;

	delete [] szCommand;

	return bResult;
}


////////////////////////////////////////////////////////////
// Function:  NetworkTools__SendLog(LPSTR, LPSTR, LPTSTR, DWORD)
//
// Purpose:
//	Sends a log to the Command Server. Takes the log type string and log string.
//	Sends the stressInstance ID and client machine name as part of the POST request.
//	If this is a general message, then the stressInstanceID should be set to zero. Otherwise
//	if and ID is supplied, then stressAdmin will log this to the stressInstanceLog table.
//	You can also add headers too.
//
////////////////////////////////////////////////////////////
BOOL
NetworkTools__SendLog(
	LPSTR	szLogType,
	LPSTR	szLogText,
	LPTSTR	szExtraHeaders,
	DWORD	dwStressInstanceID
)
{
	BOOL	bResult				= TRUE;
	LPSTR	szPostLogData		= NULL;
	CHAR	szStressInstanceID[10];
	LPSTR	szDllVersion		= new CHAR[MAX_PATH];
	LPSTR	szNumber			= new CHAR[10];
	DWORD	dwPostLogDataSize	= 0;

	if (!szLogType || !szLogText || !g_objServerCommands.Get_ClientMachineName())
	{
		OutputDebugStringA("NetworkTools__SendLog: ERROR: szLogType, szLogText, or g_objServerCommands.Get_ClientMachineName() is NULL.");
		bResult = FALSE;
		goto Exit;
	}

	dwPostLogDataSize	=	sizeof(FIELDNAME__STRESSINSTANCE_ID) + MAX_PATH;
	dwPostLogDataSize	+=	sizeof(FIELDNAME__LOG_TEXT) + strlen(szLogText);
	dwPostLogDataSize	+=	sizeof(FIELDNAME__USERINFO_MACHINENAME) + strlen(g_objServerCommands.Get_ClientMachineName());
	dwPostLogDataSize	+=	strlen(szLogType);
	dwPostLogDataSize	+=	sizeof(FIELDNAME__TESTINFO_TEST_DLL_VERSION) + MAX_PATH;

	szPostLogData		= new CHAR[dwPostLogDataSize];

	ZeroMemory(szPostLogData, dwPostLogDataSize);

	// ***************************
	// ** add the client's machine name
	strcpy(szPostLogData, FIELDNAME__USERINFO_MACHINENAME);
	strcat(szPostLogData, g_objServerCommands.Get_ClientMachineName());


	// ***************************
	// ** add the stressInstance ID if valid
	if (0 < dwStressInstanceID)
	{
		strcat(szPostLogData, "&" FIELDNAME__STRESSINSTANCE_ID);
		strcat(szPostLogData, _itoa(dwStressInstanceID, szStressInstanceID, 10));
	}


	// ***************************
	// ** add the log type data
	strcat(szPostLogData, "&");
	strcat(szPostLogData, szLogType);


	// ***************************
	// ** add the test dll version info
	if (
		g_objServerCommands.Get_TestDllFileName() &&
		NetworkTools__GetDllVersion(g_objServerCommands.Get_TestDllFileName(), szDllVersion, MAX_PATH)
		)
	{
		strcat(szPostLogData, "&" FIELDNAME__TESTINFO_TEST_DLL_VERSION);
		strcat(szPostLogData, szDllVersion);
	}


	// ***************************
	// ** add the log text data
	strcat(szPostLogData, "&" FIELDNAME__LOG_TEXT);
	strcat(szPostLogData, szLogText);


	// ***************************
	// ** Send the data
	bResult = NetworkTools__POSTResponse(STRESS_COMMAND_SERVER_LOGURL, szPostLogData, szExtraHeaders);
	//OutputDebugStringA(szPostLogData);

Exit:
	if (szPostLogData)
		delete [] szPostLogData;

	delete [] szDllVersion;
	delete [] szNumber;

	return bResult;
}


////////////////////////////////////////////////////////////
// Function:  NetworkTools__GetDllVersion(LPTSTR, LPSTR, DWORD)
//
// Purpose:
//	Takes a DLL name and return the version as an ASCII string.
//
////////////////////////////////////////////////////////////
BOOL
NetworkTools__GetDllVersion(
	LPTSTR	lpszDllName,
	LPSTR	szVersionBuffer,
	DWORD	dwVersionBufferSize
)
{
	BOOL	bResult			= TRUE;
	DWORD	dwHandle;
	DWORD	dwVersionSize;
	LPSTR	szVersionInfo	= NULL;
	LPSTR	szVersionOutput	= NULL;
	UINT	uiLength;


	ZeroMemory(szVersionBuffer, dwVersionBufferSize);

	dwVersionSize	= GetFileVersionInfoSize(lpszDllName, &dwHandle);
	
	if (0 >= dwVersionSize)
	{
		bResult = FALSE;
		goto Exit;
	}

	// allocate new buffer for the query
	szVersionInfo = new CHAR[dwVersionSize];

	ZeroMemory(szVersionInfo, dwVersionSize);
	if (!GetFileVersionInfo(lpszDllName, NULL, dwVersionSize, szVersionInfo))
	{
		bResult = FALSE;
		goto Exit;
	}


	// *****************************
	// ** build the version info query string

	struct LANGANDCODEPAGE {
	  WORD wLanguage;
	  WORD wCodePage;
	} *lpTranslate;


	CHAR szVersionQuery[200];
	ZeroMemory(szVersionQuery, 200);

	// Read the list of languages and code pages.
	VerQueryValueA(szVersionInfo, 
				  "\\VarFileInfo\\Translation",
				  (LPVOID*)&lpTranslate,
				  &uiLength);

	// build the ver info query string that contains the language bits
	sprintf(szVersionQuery, "\\StringFileInfo\\%04x%04x\\ProductVersion", lpTranslate->wLanguage, lpTranslate->wCodePage);


	// *****************************
	// ** Get the version and copy to buffer
	uiLength = 0;
	if (!VerQueryValueA(szVersionInfo, szVersionQuery, (VOID **) &szVersionOutput, &uiLength))
	{
		bResult = FALSE;
		goto Exit;
	}

	// copy the version info string to the buffer
	strncpy(szVersionBuffer, (LPSTR) szVersionOutput, dwVersionBufferSize-1);


Exit:
	if (szVersionInfo)
		delete [] szVersionInfo;

	return bResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\tools\stress\winhttpstressscheduler.h ===
///////////////////////////////////////////////////////////////////////////
// File:  WinHttpStressScheduler.h
//
// Copyright (c) 2001 Microsoft Corporation.  All Rights Reserved.
//
// Purpose:
//	Global types and interfaces for the WinHttpStressScheduler project.
//
// History:
//	02/01/01	DennisCh	Created
///////////////////////////////////////////////////////////////////////////


#if !defined INC__WINHTTPSTRESSSCHEDULER_H
	#define  INC__WINHTTPSTRESSSCHEDULER_H


//////////////////////////////////////////////////////////////////////
// Constants
//////////////////////////////////////////////////////////////////////
#define _UNICODE

#define WINHTTP_STRESS_SCHEDULER__NAME	"WinHttp stressScheduler"
#define WINHTTP_WINHTTP_HOME_URL		"http://winhttp"
#define WINHTTP_STRESSADMIN_URL			"http://hairball/stressAdmin/configure-client.asp"

// used to notify the tray icon
#define MYWM_NOTIFYICON	(WM_APP+100)


//////////////////////////////////////////////////////////////////////
// Includes
//////////////////////////////////////////////////////////////////////

//
// WIN32 headers
//
#include <windows.h>
#include <tchar.h>

//
// Project headers
//
#include "res\resource.h"

#endif // defined INC__WINHTTPSTRESSSCHEDULER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\tools\stress\servercommands.cpp ===
///////////////////////////////////////////////////////////////////////////
// File:  WinHttpStressScheduler.cpp
//
// Copyright (c) 2001 Microsoft Corporation.  All Rights Reserved.
//
// Purpose:
//	ServerCommands.cpp: implementation of the ServerCommands class.
//	This class is used to retrieve and act on command from the server.
//
// History:
//	02/08/01	DennisCh	Created
//
//////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////
// Includes
//////////////////////////////////////////////////////////////////////

//
// WIN32 headers
//

//
// Project headers
//
#include "ServerCommands.h"
#include "NetworkTools.h"


//////////////////////////////////////////////////////////////////////
// Globals and statics
//////////////////////////////////////////////////////////////////////

HANDLE				g_hQueryServerForCommands;	// Handle for the thread that queries the server for commands
CRITICAL_SECTION	g_csServerCommandsVars;		// For protecting CommandServer private member vars. Used in the QueryServerForCommands_ThreadProc.

extern ServerCommands g_objServerCommands;		// Declared in WinHttpStressScheduler.cpp


////////////////////////////////////////////////////////////
// Function:  QueryServerForCommands_ThreadProc(LPVOID)
//
// Purpose:
//	This method sends a request to the command server for instructions
//	and saves them in the public vars of ServerCommands.
//
////////////////////////////////////////////////////////////
DWORD
WINAPI
QueryServerForCommands_ThreadProc(
	LPVOID lpParam	// [IN] thread proc param
)
{
	BOOL			bResult		= TRUE;
	HINTERNET		hRoot		= NULL;
	HINTERNET		hSession	= NULL;
	HINTERNET		hRequest	= NULL;
	URL_COMPONENTSW	urlComponents;

	// Allocate space for URL components
	ZeroMemory(&urlComponents, sizeof(urlComponents));

	urlComponents.dwSchemeLength	= MAX_PATH;
	urlComponents.lpszScheme		= new TCHAR[MAX_PATH];

	urlComponents.dwHostNameLength  = MAX_PATH;
	urlComponents.lpszHostName		= new TCHAR[MAX_PATH];

	urlComponents.dwUrlPathLength	= MAX_PATH;
	urlComponents.lpszUrlPath		= new TCHAR[MAX_PATH];

	urlComponents.dwExtraInfoLength = MAX_PATH;
	urlComponents.lpszExtraInfo		= new TCHAR[MAX_PATH];
	
	urlComponents.dwUserNameLength	= MAX_PATH;
	urlComponents.lpszUserName		= new TCHAR[MAX_PATH];

	urlComponents.dwPasswordLength	= MAX_PATH;
	urlComponents.lpszPassword		= new TCHAR[MAX_PATH];
	
	urlComponents.nPort				= 0;

	urlComponents.dwStructSize		= sizeof(URL_COMPONENTSW);


	// crack the Command Server URL to be used later
	if (!WinHttpCrackUrl(
			g_objServerCommands.Get_CommandServerURL(),
			_tcslen(g_objServerCommands.Get_CommandServerURL()),
			ICU_ESCAPE,
			&urlComponents)
		)
	{
		bResult = FALSE;
		goto Exit;
	}

	hRoot = WinHttpOpen(
		STRESS_SCHEDULER_USER_AGENT,
		WINHTTP_ACCESS_TYPE_NO_PROXY,
		NULL,
		NULL,
		0);

	if (!hRoot)
	{
		bResult = FALSE;
		goto Exit;
	}

	hSession = WinHttpConnect(
		hRoot,
		urlComponents.lpszHostName,
		// If the URL in urlComponents uses standard HTTP or HTTPS ports then use INTERNET_DEFAULT_PORT. Otherwise use the non-standard port gleaned from the URL.
		((urlComponents.nPort == 80) || (urlComponents.nPort == 443)) ? INTERNET_DEFAULT_PORT : urlComponents.nPort,
		0);
	
	if (!hSession)
	{
		bResult = FALSE;
		goto Exit;
	}


	// Build a full URL with path and querystring
	TCHAR szFullPath[MAX_PATH*2];

	ZeroMemory(szFullPath, sizeof(szFullPath));
	_tcsncpy(szFullPath, urlComponents.lpszUrlPath, urlComponents.dwUrlPathLength);
	//szFullPath[urlComponents.dwUrlPathLength] = _T('\0');
	_tcsncat(szFullPath, urlComponents.lpszExtraInfo, urlComponents.dwExtraInfoLength);

	hRequest = WinHttpOpenRequest(
		hSession,
		_T("POST"),
		szFullPath,
		NULL,
		NULL,
		NULL,
		// if the URL in urlComponents uses HTTPS then pass in WINHTTP_FLAG_SECURE to this param. Otherwise, 0.
		(0 == _tcsnicmp(urlComponents.lpszScheme, _T("https"), 5)) ? WINHTTP_FLAG_SECURE : 0);

	if (!hRequest)
	{
		bResult = FALSE;
		goto Exit;
	}


	// Set reasonable timeouts just in case
	if (!WinHttpSetTimeouts(hRequest, 5000, 5000, 5000, 5000))
	{
		bResult = FALSE;
		goto Exit;
	}

	// Get the computer name and send it in a POST request
	LPSTR	szPost, szMachineName;
	
	szPost			= new CHAR[MAX_PATH];
	szMachineName	= new CHAR[MAX_PATH];


	GetEnvironmentVariableA("COMPUTERNAME", szMachineName, MAX_PATH);
	strcpy(szPost, FIELDNAME__USERINFO_MACHINENAME);
	strcat(szPost, szMachineName);

	bResult = WinHttpSendRequest(
		hRequest,
		_T("Content-Type: application/x-www-form-urlencoded"),
		-1L, 
		szPost,
		strlen(szPost),
		strlen(szPost),
		0);


	delete [] szPost;
	delete [] szMachineName;
	szPost			= NULL;
	szMachineName	= NULL;

	if (!WinHttpReceiveResponse(hRequest, NULL))
	{
		bResult = FALSE;
		goto Exit;
	}



	TCHAR	szBuffer[MAX_URL];
	DWORD	dwBufferSize, dwIndex;


	// get all command headers that we're interested in.
	// make sure there are no pending operations on member vars (pServerCommands->Set_* functions)
	EnterCriticalSection(&g_csServerCommandsVars);


	// *********************************
	// **** COMMANDHEADER__EXIT: Exit if header is present, else continue.
	dwIndex			= 0;
	dwBufferSize	= MAX_URL;
	ZeroMemory(szBuffer, sizeof(szBuffer));
	if (WinHttpQueryHeaders(hRequest, WINHTTP_QUERY_CUSTOM, COMMANDHEADER__EXIT, szBuffer, &dwBufferSize, &dwIndex))
		g_objServerCommands.Set_ExitStress(TRUE);
	else
		g_objServerCommands.Set_ExitStress(FALSE);


	// *********************************
	// **** COMMANDHEADER__WINHTTP_DLL_URL: valid values: Valid URL
	dwIndex			= 0;
	dwBufferSize	= MAX_URL;
	ZeroMemory(szBuffer, sizeof(szBuffer));
	if (WinHttpQueryHeaders(hRequest, WINHTTP_QUERY_CUSTOM, COMMANDHEADER__WINHTTP_DLL_URL, szBuffer, &dwBufferSize, &dwIndex))
		g_objServerCommands.Set_WinHttpDllURL(szBuffer, dwBufferSize);
	else
		bResult = FALSE;


	// *********************************
	// **** COMMANDHEADER__WINHTTP_PDB_URL: valid values: Valid URL
	dwIndex			= 0;
	dwBufferSize	= MAX_URL;
	ZeroMemory(szBuffer, sizeof(szBuffer));
	if (WinHttpQueryHeaders(hRequest, WINHTTP_QUERY_CUSTOM, COMMANDHEADER__WINHTTP_PDB_URL, szBuffer, &dwBufferSize, &dwIndex))
		g_objServerCommands.Set_WinHttpPDBURL(szBuffer, dwBufferSize);
	else
		bResult = FALSE;


	// *********************************
	// **** COMMANDHEADER__WINHTTP_SYM_URL: valid values: Valid URL
	dwIndex			= 0;
	dwBufferSize	= MAX_URL;
	ZeroMemory(szBuffer, sizeof(szBuffer));
	if (WinHttpQueryHeaders(hRequest, WINHTTP_QUERY_CUSTOM, COMMANDHEADER__WINHTTP_SYM_URL, szBuffer, &dwBufferSize, &dwIndex))
		g_objServerCommands.Set_WinHttpSYMURL(szBuffer, dwBufferSize);
	else
		bResult = FALSE;


	// *********************************
	// **** COMMANDHEADER__COMMANDSERVER_URL: valid values: Valid URL
	dwIndex			= 0;
	dwBufferSize	= MAX_URL;
	ZeroMemory(szBuffer, sizeof(szBuffer));
	if (WinHttpQueryHeaders(hRequest, WINHTTP_QUERY_CUSTOM, COMMANDHEADER__COMMANDSERVER_URL, szBuffer, &dwBufferSize, &dwIndex))
		g_objServerCommands.Set_CommandServerURL(szBuffer, dwBufferSize);
	else
		bResult = FALSE;


	// *********************************
	// **** COMMANDHEADER__BEGIN_TIME_HOUR: valid values: Valid string from 0-23
	dwIndex			= 0;
	dwBufferSize	= MAX_URL;
	ZeroMemory(szBuffer, sizeof(szBuffer));
	if (WinHttpQueryHeaders(hRequest, WINHTTP_QUERY_CUSTOM, COMMANDHEADER__BEGIN_TIME_HOUR, szBuffer, &dwBufferSize, &dwIndex))
		g_objServerCommands.Set_TimeStressBegins(szBuffer, NULL);
	else
		bResult = FALSE;


	// *********************************
	// **** COMMANDHEADER__BEGIN_TIME_MINUTE: valid values: Valid string from 0-59
	dwIndex			= 0;
	dwBufferSize	= MAX_URL;
	ZeroMemory(szBuffer, sizeof(szBuffer));
	if (WinHttpQueryHeaders(hRequest, WINHTTP_QUERY_CUSTOM, COMMANDHEADER__BEGIN_TIME_MINUTE, szBuffer, &dwBufferSize, &dwIndex))
		g_objServerCommands.Set_TimeStressBegins(NULL, szBuffer);
	else
		bResult = FALSE;


	// *********************************
	// **** COMMANDHEADER__END_TIME_HOUR: valid values: Valid string from 0-23
	dwIndex			= 0;
	dwBufferSize	= MAX_URL;
	ZeroMemory(szBuffer, sizeof(szBuffer));
	if (WinHttpQueryHeaders(hRequest, WINHTTP_QUERY_CUSTOM, COMMANDHEADER__END_TIME_HOUR, szBuffer, &dwBufferSize, &dwIndex))
		g_objServerCommands.Set_TimeStressEnds(szBuffer, NULL);
	else
		bResult = FALSE;


	// *********************************
	// **** COMMANDHEADER__END_TIME_MINUTE: valid values: Valid string from 0-59
	dwIndex			= 0;
	dwBufferSize	= MAX_URL;
	ZeroMemory(szBuffer, sizeof(szBuffer));
	if (WinHttpQueryHeaders(hRequest, WINHTTP_QUERY_CUSTOM, COMMANDHEADER__END_TIME_MINUTE, szBuffer, &dwBufferSize, &dwIndex))
		g_objServerCommands.Set_TimeStressEnds(NULL, szBuffer);
	else
		bResult = FALSE;


	// *********************************
	// **** COMMANDHEADER__RUN_FOREVER: valid values: doesn't matter. As long as header is present it gets sent
	dwIndex			= 0;
	dwBufferSize	= MAX_URL;
	ZeroMemory(szBuffer, sizeof(szBuffer));
	if (WinHttpQueryHeaders(hRequest, WINHTTP_QUERY_CUSTOM, COMMANDHEADER__RUN_FOREVER, szBuffer, &dwBufferSize, &dwIndex))
		g_objServerCommands.Set_RunForever(TRUE);
	else
		g_objServerCommands.Set_RunForever(FALSE);


	// *********************************
	// **** COMMANDHEADER__UPDATE_INTERVAL: valid values: Valid string in INTERNET_RFC1123 format
	DWORD			dwTimeOut;
	dwTimeOut		= 0;
	dwIndex			= 0;
	dwBufferSize	= sizeof(DWORD);
	ZeroMemory(szBuffer, sizeof(szBuffer));
	if (WinHttpQueryHeaders(hRequest, WINHTTP_QUERY_CUSTOM | WINHTTP_QUERY_FLAG_NUMBER, COMMANDHEADER__UPDATE_INTERVAL, &dwTimeOut, &dwBufferSize, &dwIndex))
		g_objServerCommands.Set_CommandServerUpdateInterval(dwTimeOut);
	else
		bResult = FALSE;



	// *********************************
	// *********************************
	// **** Query commands for building stress Instance objects
	// ****
	// **** COMMANDHEADER__STRESS_EXE_URL: valid values: Valid URL
	DWORD	dwStressExeID;
	DWORD	dwPageHeapCommandIndex,
			dwUMDHCommandIndex,
			dwStressPDBIndex,
			dwStressSYMIndex,
			dwStressMemDmpPathIndex,
			dwStressExeIDIndex;
	LPTSTR	szPageheapCommand,
			szUMDHCommand,
			szStressPDB_URL,
			szStressSYM_URL,
			szStressMemDmpPath,
			szStressExeID;

	szPageheapCommand	= new TCHAR[MAX_PATH];
	szUMDHCommand		= new TCHAR[MAX_PATH];
	szStressPDB_URL		= new TCHAR[MAX_STRESS_URL];
	szStressSYM_URL		= new TCHAR[MAX_STRESS_URL];
	szStressMemDmpPath	= new TCHAR[MAX_PATH];
	szStressExeID		= new TCHAR[MAX_PATH];

	if (!g_objServerCommands.IsStressRunning())
	{
		// free all old StressExeURLs first - we're replacing it with new URLs anyway
		g_objServerCommands.Clear_StressExeURLs();

		dwIndex					= 0;
		dwStressExeIDIndex		= 0;
		dwPageHeapCommandIndex	= 0;
		dwUMDHCommandIndex		= 0;
		dwStressPDBIndex		= 0;
		dwStressSYMIndex		= 0;
		dwStressMemDmpPathIndex	= 0;
		dwBufferSize			= MAX_URL;
		ZeroMemory(szBuffer, sizeof(szBuffer));

		while (WinHttpQueryHeaders(hRequest, WINHTTP_QUERY_CUSTOM, COMMANDHEADER__STRESS_EXE_URL, szBuffer, &dwBufferSize, &dwIndex))
		{
			// *************************************
			// *************************************
			// ** COMMANDHEADER__MEMORY_DUMP_PATH: A valid path
			ZeroMemory(szStressMemDmpPath, MAX_PATH);
			dwBufferSize	= MAX_PATH;
			WinHttpQueryHeaders(hRequest, WINHTTP_QUERY_CUSTOM, COMMANDHEADER__MEMORY_DUMP_PATH, szStressMemDmpPath, &dwBufferSize, &dwStressMemDmpPathIndex);


			// *************************************
			// *************************************
			// ** Get COMMANDHEADER__STRESS_PDB_URL if there is one
			// **
			ZeroMemory(szStressPDB_URL, MAX_STRESS_URL);
			dwBufferSize	= MAX_STRESS_URL;
			WinHttpQueryHeaders(hRequest, WINHTTP_QUERY_CUSTOM, COMMANDHEADER__STRESS_PDB_URL, szStressPDB_URL, &dwBufferSize, &dwStressPDBIndex);


			// *************************************
			// *************************************
			// ** Get COMMANDHEADER__STRESS_SYM_URL if there is one
			// **
			ZeroMemory(szStressSYM_URL, MAX_STRESS_URL);
			dwBufferSize	= MAX_STRESS_URL;
			WinHttpQueryHeaders(hRequest, WINHTTP_QUERY_CUSTOM, COMMANDHEADER__STRESS_SYM_URL, szStressSYM_URL, &dwBufferSize, &dwStressSYMIndex);


			// *************************************
			// *************************************
			// ** Get COMMANDHEADER__STRESS_EXE_PAGEHEAP if there is one
			// **
			ZeroMemory(szPageheapCommand, MAX_PATH);
			dwBufferSize	= MAX_PATH;
			WinHttpQueryHeaders(hRequest, WINHTTP_QUERY_CUSTOM, COMMANDHEADER__STRESS_EXE_PAGEHEAP, szPageheapCommand, &dwBufferSize, &dwPageHeapCommandIndex);

			// *************************************
			// *************************************
			// ** Get COMMANDHEADER__STRESS_EXE_UMDH if there is one
			// **
			ZeroMemory(szUMDHCommand, MAX_PATH);
			dwBufferSize	= MAX_PATH;
			WinHttpQueryHeaders(hRequest, WINHTTP_QUERY_CUSTOM, COMMANDHEADER__STRESS_EXE_UMDH, szUMDHCommand, &dwBufferSize, &dwUMDHCommandIndex);
			

			// *************************************
			// *************************************
			// ** Get COMMANDHEADER__STRESS_EXE_INSTANCEID
			// For each COMMANDHEADER__STRESS_EXE_URL, there must be an index for the stress instance from the StressADMIN DB table.
			// This identifies the stressinstance run. The test case (stressinstance) WILL NOT be added and run without an ID number.
			ZeroMemory(szStressExeID, MAX_PATH);
			dwBufferSize	= MAX_PATH;

			if (WinHttpQueryHeaders(hRequest, WINHTTP_QUERY_CUSTOM, COMMANDHEADER__STRESS_EXE_INSTANCEID, szStressExeID, &dwBufferSize, &dwStressExeIDIndex))
			{
				// convert header ID string to a DWORD
				dwStressExeID = _ttol(szStressExeID);

				// only add valid stressInstances with valid ID's
				if (0 < dwStressExeID)
				{
					g_objServerCommands.Create_StressInstance(
						dwStressExeID,
						szPageheapCommand,
						szUMDHCommand,
						szStressPDB_URL,
						szStressSYM_URL,
						szStressMemDmpPath,
						szBuffer);

					dwBufferSize = MAX_URL;
					ZeroMemory(szBuffer, MAX_URL);
				}
			}
		}
	}

	delete [] szPageheapCommand;
	delete [] szUMDHCommand;
	delete [] szStressMemDmpPath;
	delete [] szStressPDB_URL;
	delete [] szStressSYM_URL;
	delete [] szStressExeID;


	// *********************************
	// **** COMMANDHEADER__ABORT: Abort the stress instance running specified by this header.
	dwIndex			= 0;
	dwBufferSize	= MAX_URL;
	ZeroMemory(szBuffer, sizeof(szBuffer));
	while (WinHttpQueryHeaders(hRequest, WINHTTP_QUERY_CUSTOM, COMMANDHEADER__ABORT, szBuffer, &dwBufferSize, &dwIndex))
		g_objServerCommands.AbortStressInstance(_ttol(szBuffer));


	LeaveCriticalSection(&g_csServerCommandsVars);


Exit:
	if (hRequest)
		WinHttpCloseHandle(hRequest);

	if (hSession)
		WinHttpCloseHandle(hSession);

	if (hRoot)
		WinHttpCloseHandle(hRoot);

	delete [] urlComponents.lpszScheme;
	delete [] urlComponents.lpszHostName;
	delete [] urlComponents.lpszUrlPath;
	delete [] urlComponents.lpszExtraInfo;
	delete [] urlComponents.lpszPassword;
	delete [] urlComponents.lpszUserName;

	ExitThread(bResult);
}




// *******************************************************************
// *******************************************************************
// ****
// **** ServerCommands class member functions
// ****

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

ServerCommands::ServerCommands()
{
	m_dwCommandServerUpdateInternval	= STRESS_COMMAND_SERVER_UPDATE_INTERVAL;
	m_bExit								= FALSE;
	m_dwStressInstanceIterator			= NULL;
	g_hQueryServerForCommands			= NULL;

	m_szCommandServerURL				= new TCHAR[MAX_STRESS_URL];
	m_szCommandServerResultsURL			= new TCHAR[MAX_STRESS_URL];
	m_szWinHttpDLL_DownloadURL			= new TCHAR[MAX_STRESS_URL];
	m_szWinHttpPDB_DownloadURL			= new TCHAR[MAX_STRESS_URL];
	m_szWinHttpSYM_DownloadURL			= new TCHAR[MAX_STRESS_URL];
	m_szWinHttpDLL_FileName				= new TCHAR[MAX_PATH];
	m_szStressSchedulerCurrentDirectory	= new TCHAR[MAX_PATH];
	m_szClientMachineName				= new CHAR[MAX_PATH];

	ZeroMemory(m_szCommandServerURL,				MAX_STRESS_URL);
	ZeroMemory(m_szCommandServerResultsURL,			MAX_STRESS_URL);
	ZeroMemory(m_szWinHttpDLL_DownloadURL,			MAX_STRESS_URL);
	ZeroMemory(m_szWinHttpPDB_DownloadURL,			MAX_STRESS_URL);
	ZeroMemory(m_szWinHttpSYM_DownloadURL,			MAX_STRESS_URL);
	ZeroMemory(m_szWinHttpDLL_FileName,				MAX_PATH);
	ZeroMemory(m_szStressSchedulerCurrentDirectory, MAX_PATH);
	ZeroMemory(m_szClientMachineName,				MAX_PATH);

	// initilize start/end times to -1 so we know that
	// there are not valid time and we'll skip the Begin/End stress time check
	// until we get real values from the command server
	m_iTimeStressBeginsHour		= -1;
	m_iTimeStressBeginsMinute	= -1;
	m_iTimeStressEndsHour		= -1;
	m_iTimeStressEndsMinute		= -1;
	m_bRunForever				= 0;

	// Set default URLs
	wcsncpy(m_szCommandServerURL, STRESS_COMMAND_SERVER_URL, sizeof(STRESS_COMMAND_SERVER_URL));
	wcsncpy(m_szCommandServerResultsURL, STRESS_COMMAND_SERVER_RESULTS_URL, sizeof(STRESS_COMMAND_SERVER_RESULTS_URL));

	// Get the current working directory
	GetCurrentDirectory(MAX_PATH, m_szStressSchedulerCurrentDirectory);

	// Get the client's machine name
	GetEnvironmentVariableA("COMPUTERNAME", m_szClientMachineName, MAX_PATH);

	InitializeCriticalSection(&g_csServerCommandsVars);

	// Tell the client that we are alive and also send system info
	RegisterClient();

}


ServerCommands::~ServerCommands()
{
	DWORD	dwThreadExitCode	= 0;

	// LOGLOG: stressScheduler has exited
	NetworkTools__SendLog(FIELDNAME__LOGTYPE_EXIT, "WinHttpStressScheduler has exited.", NULL, NULL);

	// Shut down QueryServer thread
	GetExitCodeThread(g_hQueryServerForCommands, &dwThreadExitCode);

	if (STILL_ACTIVE == dwThreadExitCode)
		WaitForSingleObject(g_hQueryServerForCommands, INFINITE);

	// free allocated memory for URLs
	Clear_StressExeURLs();

	// Free our handles
	CloseHandle(g_hQueryServerForCommands);
	DeleteCriticalSection(&g_csServerCommandsVars);

	delete [] m_szCommandServerURL;
	delete [] m_szCommandServerResultsURL;
	delete [] m_szWinHttpDLL_DownloadURL;
	delete [] m_szWinHttpPDB_DownloadURL;
	delete [] m_szWinHttpSYM_DownloadURL;
	delete [] m_szWinHttpDLL_FileName;
	delete [] m_szStressSchedulerCurrentDirectory;
	delete [] m_szClientMachineName;
}


////////////////////////////////////////////////////////////
// Function:  ServerCommands::GetCurrentWorkingDirectory()
//
// Purpose:
//	Returns string containing the current working directory for
//	this application.
//
////////////////////////////////////////////////////////////
LPTSTR
ServerCommands::Get_CurrentWorkingDirectory()
{
	return m_szStressSchedulerCurrentDirectory;
}


////////////////////////////////////////////////////////////
// Function:  ServerCommands::Get_ClientMachineName()
//
// Purpose:
//	Returns string containing the machine's NETBIOS name
//
////////////////////////////////////////////////////////////
LPSTR
ServerCommands::Get_ClientMachineName()
{
	return m_szClientMachineName;
}


////////////////////////////////////////////////////////////
// Function:  ServerCommands::QueryServerForCommands()
//
// Purpose:
//	This method sends a request to the command server for instructions
//	and saves them in our private vars. 
//
////////////////////////////////////////////////////////////
ServerCommands::QueryServerForCommands()
{
	BOOL	bResult				= TRUE;
	DWORD	dwThreadID			= 0;
	DWORD	dwTimeOut			= 0;
	DWORD	dwThreadExitCode	= 0;

	// See if thread is still active before spinning off a new one
	GetExitCodeThread(g_hQueryServerForCommands, &dwThreadExitCode);

	if (STILL_ACTIVE == dwThreadExitCode)
	{
		// wait for existing thread to finish
		dwTimeOut = 0;
		dwTimeOut = WaitForSingleObject(g_hQueryServerForCommands, 500);

		if (WAIT_TIMEOUT == dwTimeOut)
			bResult = FALSE;
	}
	else
	{
		// free handle for previous thread
		CloseHandle(g_hQueryServerForCommands);

		// spin off thread to query server
		g_hQueryServerForCommands = NULL;
		g_hQueryServerForCommands = CreateThread(NULL, 0, QueryServerForCommands_ThreadProc, (LPVOID) this, 0, &dwThreadID);

		if (!g_hQueryServerForCommands)
			bResult = FALSE;
	}

	return bResult;
}


////////////////////////////////////////////////////////////
// Function:  ServerCommands::Download_WinHttpDLL()
//
// Purpose:
//	Downloads the test DLL and symbols.
//
////////////////////////////////////////////////////////////
BOOL ServerCommands::Download_WinHttpDLL()
{
	BOOL	bResult				= TRUE;
	LPTSTR	szSymbolFileName	= new TCHAR[MAX_PATH];
	LPTSTR	szBuffer			= new TCHAR[MAX_PATH];


	// ************************
	// ************************
	// ** download the file to the system32 directory
	// **
	if (!GetSystemDirectory(szBuffer, MAX_PATH))
	{
		bResult = FALSE;
		goto Exit;
	}

	// download DLL if needed
	if (_tcsclen(m_szWinHttpDLL_DownloadURL) > 0)
		bResult = 
			NetworkTools__URLDownloadToFile(
			m_szWinHttpDLL_DownloadURL,
			szBuffer,
			m_szWinHttpDLL_FileName);

	if (bResult)
	{
		// download PDB file if needed
		if (_tcsclen(m_szWinHttpPDB_DownloadURL) > 0)
		{
			NetworkTools__GetFileNameFromURL(m_szWinHttpPDB_DownloadURL, szSymbolFileName, MAX_PATH);

			if (NetworkTools__URLDownloadToFile(m_szWinHttpPDB_DownloadURL, szBuffer, szSymbolFileName))
				NetworkTools__SendLog(FIELDNAME__LOGTYPE_SUCCESS, "PDB symbol file downloaded successfully.", NULL, 0);
			else
				NetworkTools__SendLog(FIELDNAME__LOGTYPE_ERROR, "PDB symbol file failed to downloaded.", NULL, 0);
		}


		// download sym file if needed
		if (_tcsclen(m_szWinHttpSYM_DownloadURL) > 0)
		{
			NetworkTools__GetFileNameFromURL(m_szWinHttpSYM_DownloadURL, szSymbolFileName, MAX_PATH);

			if (NetworkTools__URLDownloadToFile(m_szWinHttpSYM_DownloadURL, szBuffer, szSymbolFileName))
				NetworkTools__SendLog(FIELDNAME__LOGTYPE_SUCCESS, "SYM symbol file downloaded successfully.", NULL, 0);
			else
				NetworkTools__SendLog(FIELDNAME__LOGTYPE_ERROR, "SYM symbol file failed to downloaded.", NULL, 0);
		}
	}

	// if failed to download DLL, it's probably in use. We'll try to regsvr32 it anyways if it's there.

	// ************************
	// ************************
	// ** regsvr32'ed the dll just downloaded
	// **
	HINSTANCE hLib;
	
	hLib = LoadLibrary(m_szWinHttpDLL_FileName);

	if (hLib < (HINSTANCE)HINSTANCE_ERROR)
	{
		// unable to load the DLL;
		bResult = FALSE;
		goto Exit;
	}

	// **********************
	// **********************
	// ** Register the DLL
	typedef VOID (CALLBACK* LPFNDLLFUNC1)();
	LPFNDLLFUNC1 lpDllEntryPoint;

	// Find the entry point.
	(FARPROC&)lpDllEntryPoint = GetProcAddress(hLib, "DllRegisterServer");

	if (lpDllEntryPoint != NULL)
		(*lpDllEntryPoint)();
	else
	{
		//unable to locate entry point - regsvr failed
		bResult = FALSE;
	}


Exit:
	if (bResult)
		NetworkTools__SendLog(FIELDNAME__LOGTYPE_INFORMATION, "winhttp5.dll downloaded and registered successfully.", NULL, 0);

	delete [] szSymbolFileName;
	delete [] szBuffer;

	return bResult;
}


////////////////////////////////////////////////////////////
// Function:  ServerCommands::Set_RunForever(BOOL)
//
// Purpose:
//	Pass in TRUE to run forever ignoring begin/end time, FALSE not to.
//
// Called by: QueryServerForCommands_ThreadProc
//
////////////////////////////////////////////////////////////
VOID
ServerCommands::Set_RunForever(
	BOOL bRunForever	// [IN] TRUE to run forever ignoring begin/end time, FALSE not to.
)
{
	m_bRunForever = bRunForever;
}


////////////////////////////////////////////////////////////
// Function:  ServerCommands::Set_ExitStress(BOOL)
//
// Purpose:
//	Pass in TRUE to exit stress as soon as possible and FALSE
//	not to.
//
// Called by: QueryServerForCommands_ThreadProc
//
////////////////////////////////////////////////////////////
VOID
ServerCommands::Set_ExitStress(
	BOOL bExitStress	// [IN] TRUE to exit stress, FALSE not to.
)
{
	m_bExit = bExitStress;
}


////////////////////////////////////////////////////////////
// Function:  ServerCommands::Set_WinHttpDllURL(LPTSTR, DWORD)
//
// Purpose:
//	Pass in an URL and its size and to get the WinHttp DLL from.
//
// Called by: QueryServerForCommands_ThreadProc
//
////////////////////////////////////////////////////////////
VOID
ServerCommands::Set_WinHttpDllURL(
	LPTSTR szBuffer,	// [IN] string buffer containing URL to the WINHTTP DLL
	DWORD dwBufferSize	// [IN] size of the szBuffer in TCHARs
)
{
	_tcscpy(m_szWinHttpDLL_DownloadURL, szBuffer);

	// Get the full DLL filename from the URL
	NetworkTools__GetFileNameFromURL(m_szWinHttpDLL_DownloadURL, m_szWinHttpDLL_FileName, MAX_PATH);
}


////////////////////////////////////////////////////////////
// Function:  ServerCommands::Set_WinHttpPDBURL(LPTSTR, DWORD)
//
// Purpose:
//	Pass in an URL and its size and to get the WinHttp PDB file from.
//
// Called by: QueryServerForCommands_ThreadProc
//
////////////////////////////////////////////////////////////
VOID
ServerCommands::Set_WinHttpPDBURL(
	LPTSTR szBuffer,	// [IN] string buffer containing URL to the WINHTTP DLL
	DWORD dwBufferSize	// [IN] size of the szBuffer in TCHARs
)
{
	_tcscpy(m_szWinHttpPDB_DownloadURL, szBuffer);
}


////////////////////////////////////////////////////////////
// Function:  ServerCommands::Set_WinHttpSYMURL(LPTSTR, DWORD)
//
// Purpose:
//	Pass in an URL and its size and to get the WinHttp SYM file from.
//
// Called by: QueryServerForCommands_ThreadProc
//
////////////////////////////////////////////////////////////
VOID
ServerCommands::Set_WinHttpSYMURL(
	LPTSTR szBuffer,	// [IN] string buffer containing URL to the WINHTTP DLL
	DWORD dwBufferSize	// [IN] size of the szBuffer in TCHARs
)
{
	_tcscpy(m_szWinHttpSYM_DownloadURL, szBuffer);
}


////////////////////////////////////////////////////////////
// Function:  ServerCommands::Set_CommandServerURL(LPTSTR)
//
// Purpose:
//	Pass in a timeout value in milliseconds to query the 
//	Command Server for commands.
//
// Called by: QueryServerForCommands_ThreadProc
//
////////////////////////////////////////////////////////////
VOID
ServerCommands::Set_CommandServerURL(
	LPTSTR szBuffer,	// [IN] string buffer containing URL to the WINHTTP DLL
	DWORD dwBufferSize	// [IN] size of the szBuffer in TCHARs
)
{
	_tcscpy(m_szCommandServerURL, szBuffer);
}


////////////////////////////////////////////////////////////
// Function:  ServerCommands::Set_CommandServerUpdateInterval(DWORD)
//
// Purpose:
//	Pass in a timeout value in milliseconds to query the 
//	Command Server for commands.
//
// Called by: QueryServerForCommands_ThreadProc
//
////////////////////////////////////////////////////////////
VOID
ServerCommands::Set_CommandServerUpdateInterval(
	DWORD dwUpdateInterval	// [IN] time to wait before pinging the Command Server in milliseconds
)
{
	// server update interval must be at least greater than the minimum timeout
	if (STRESS_COMMAND_SERVER_MINIMUM_UPDATE_INTERVAL < dwUpdateInterval &&
		STRESS_COMMAND_SERVER_MAXIMUM_UPDATE_INTERVAL > dwUpdateInterval)
		m_dwCommandServerUpdateInternval = dwUpdateInterval;
}


////////////////////////////////////////////////////////////
// Function:  ServerCommands::Set_TimeStressBegins(DWORD, DWORD)
//
// Purpose:
//	Pass in a time string to begin stress in 24 hour time.
//	Takes two parameters to set the hour and minute. A parameter
//	will be ignored if NULL.
//
// Called by: QueryServerForCommands_ThreadProc
//
////////////////////////////////////////////////////////////
VOID
ServerCommands::Set_TimeStressBegins(
	LPTSTR szHour,	// [IN] 0-23 parameter ignored if < 0
	LPTSTR szMinute	// [IN] 0-59 parameter ignored if < 0
)
{
	if (szHour)
		m_iTimeStressBeginsHour = _ttoi(szHour);

	if (szMinute)
		m_iTimeStressBeginsMinute = _ttoi(szMinute);
}


////////////////////////////////////////////////////////////
// Function:  ServerCommands::Set_TimeStressEnds(DWORD, DWORD)
//
// Purpose:
//	Pass in a time string to end stress in 24 hour time.
//	Takes two parameters to set the hour and minute. A parameter
//	will be ignored if NULL.
//
// Called by: QueryServerForCommands_ThreadProc
//
////////////////////////////////////////////////////////////
VOID
ServerCommands::Set_TimeStressEnds(
	LPTSTR szHour,	// [IN] 0-23 parameter ignored if < 0
	LPTSTR szMinute	// [IN] 0-59 parameter ignored if < 0
)
{
	if (szHour)
		m_iTimeStressEndsHour = _ttoi(szHour);

	if (szMinute)
		m_iTimeStressEndsMinute = _ttoi(szMinute);
}


////////////////////////////////////////////////////////////
// Function:  ServerCommands::Create_StressInstance(LPTSTR)
//
// Purpose:
//	Pass in an URL and its size and it will be added to the 
//  m_arStressInstanceList list. There is no limit on the number of
//	URLs that can be added.
//
// Called by: QueryServerForCommands_ThreadProc
//
////////////////////////////////////////////////////////////
VOID
ServerCommands::Create_StressInstance(
	DWORD	dwStressInstanceID,	// [IN] ID from the stressAdmin DB identifying this stressInstance
	LPTSTR	szPageHeapCommand,	// [IN] string buffer containing the pageheap command line
	LPTSTR	szUMDHCommand,		// [IN] string buffer containing the UMDH command line
	LPTSTR	szPDB_URL,			// [IN] string buffer containing URL to the stress EXE's PDB file
	LPTSTR	szSYM_URL,			// [IN] string buffer containing URL to the stress EXE's SYM file
	LPTSTR	szMemDumpPath,		// [IN] string buffer containing path to create memory dump files
	LPTSTR	szEXE_URL			// [IN] string buffer containing URL to the stress EXE
)
{
	PSTRESSINSTANCE pStressInstance = NULL;

	// verify params just in case
	if (!szEXE_URL)
		return;

	// allocate memory for the object and put it in the list
	pStressInstance = new StressInstance;

	pStressInstance->Set_UMDHCommands(szUMDHCommand);
	pStressInstance->Set_PageHeapCommands(szPageHeapCommand);
	pStressInstance->Set_StressExeID(dwStressInstanceID);
	pStressInstance->Set_StressExeURL(szEXE_URL);
	pStressInstance->Set_StressExeMemoryDumpPath(szMemDumpPath);
	pStressInstance->Set_StressExePdbURL(szPDB_URL);
	pStressInstance->Set_StressExeSymURL(szSYM_URL);

	m_arStressInstanceList.push_back(pStressInstance);
	m_dwStressInstanceIterator = m_arStressInstanceList.begin();
}


////////////////////////////////////////////////////////////
// Function:  ServerCommands::Clear_StressExeURLs()
//
// Purpose:
//	Frees memory from the m_arStressExeList vector.
//
// Called by: QueryServerForCommands_ThreadProc and ~ServerCommands
//
////////////////////////////////////////////////////////////
VOID
ServerCommands::Clear_StressExeURLs()
{
	// don't want to delete StressInstances if it's still running
	if (IsStressRunning())
		return;

/*
	// walk the list and delete from the front to back
	while (!m_arStressInstanceList.empty())
		m_arStressInstanceList.erase(m_arStressInstanceList.begin());
*/

	StressInstance *pStressInstance = NULL;

	for (int iIndex=0; iIndex < m_arStressInstanceList.size(); iIndex++)
	{
		pStressInstance = m_arStressInstanceList[iIndex];
		m_arStressInstanceList.erase(&m_arStressInstanceList[iIndex]);
		delete [] pStressInstance;
	}

	m_dwStressInstanceIterator = NULL;
}


////////////////////////////////////////////////////////////
// Function:  ServerCommands::Get_CommandServerUpdateInterval()
//
// Purpose:
//	Returns the current setting for the Command Server Update
//	interval.
//
////////////////////////////////////////////////////////////
DWORD
ServerCommands::Get_CommandServerUpdateInterval()
{
	if (STRESS_COMMAND_SERVER_MINIMUM_UPDATE_INTERVAL < m_dwCommandServerUpdateInternval &&
		STRESS_COMMAND_SERVER_MAXIMUM_UPDATE_INTERVAL > m_dwCommandServerUpdateInternval)
		return m_dwCommandServerUpdateInternval;
	else
		return STRESS_COMMAND_SERVER_UPDATE_INTERVAL;
}


////////////////////////////////////////////////////////////
// Function:  ServerCommands::BeginStress()
//
// Purpose:
//	Queries for commands then starts the StressInstance objects.
//
////////////////////////////////////////////////////////////
void
ServerCommands::BeginStress()
{
	EnterCriticalSection(&g_csServerCommandsVars);

	if (!m_arStressInstanceList.empty() && !IsStressRunning())
	{
		// LOGLOG: Stress is beginning
		NetworkTools__SendLog(FIELDNAME__LOGTYPE_BEGIN_STRESS, "Stress is beginning.", NULL, NULL);

		// first download and regsvr32 the winhttp dll and symbols
		Download_WinHttpDLL();

		for(int iIndex = 0; iIndex < m_arStressInstanceList.size(); iIndex++)
			m_arStressInstanceList[iIndex]->Begin();
	}
	else
	{
		// ping Command Server for list of stress EXE URLs.
		QueryServerForCommands();
	}

	LeaveCriticalSection(&g_csServerCommandsVars);
}


////////////////////////////////////////////////////////////
// Function:  ServerCommands::EndStress()
//
// Purpose:
//	Ends stress and posts the results to the Command Server.
//
////////////////////////////////////////////////////////////
void
ServerCommands::EndStress()
{
	EnterCriticalSection(&g_csServerCommandsVars);

	if (!m_arStressInstanceList.empty())
	{
		if (IsStressRunning())
		{
			// LOGLOG: Stress is ending
			NetworkTools__SendLog(FIELDNAME__LOGTYPE_END_STRESS, "Stress is ending.", NULL, NULL);
		}

		for (int iIndex = 0; iIndex <  m_arStressInstanceList.size(); iIndex++)
			m_arStressInstanceList[iIndex]->End();
	}

	// Remove the stress objects that already finished
	Clear_StressExeURLs();

	LeaveCriticalSection(&g_csServerCommandsVars);
}


////////////////////////////////////////////////////////////
// Function:  ServerCommands::AbortStressInstance(DWORD)
//
// Purpose:
//	Aborts a all stress instances that recieved a server abort message.
//
// Called in:
//	QueryServerForCommands_ThreadProc
//
////////////////////////////////////////////////////////////
VOID
ServerCommands::AbortStressInstance(DWORD dwAbortID)
{
	// EnterCriticalSection(&g_csServerCommandsVars);

	if (!m_arStressInstanceList.empty())
	{
		for (int iIndex = 0; iIndex <  m_arStressInstanceList.size(); iIndex++)
		{
			if (m_arStressInstanceList[iIndex]->Get_ID() == dwAbortID)
				m_arStressInstanceList[iIndex]->End();
		}
	}

	//LeaveCriticalSection(&g_csServerCommandsVars);
}


////////////////////////////////////////////////////////////
// Function:  ServerCommands::IsStressRunning()
//
// Purpose:
//	Returns TRUE if any of the stressinstances is running. FALSE if not.
//
////////////////////////////////////////////////////////////
BOOL
ServerCommands::IsStressRunning()
{
	BOOL bIsRunning = FALSE;

	EnterCriticalSection(&g_csServerCommandsVars);

	if (!m_arStressInstanceList.empty())
	{
		for (int iIndex = 0; iIndex < m_arStressInstanceList.size(); iIndex++)
		{
			if (m_arStressInstanceList[iIndex]->IsRunning(STRESSINSTANCE_STRESS_EXE_CLOSE_TIMEOUT))
				bIsRunning = TRUE;
		}
	}

	LeaveCriticalSection(&g_csServerCommandsVars);

	return bIsRunning;
}


////////////////////////////////////////////////////////////
// Function:  ServerCommands::IsTimeToBeginStress()
//
// Purpose:
//	TRUE if it's time to begin stress based on the time returned
//	from the Command Server. Will return TRUE if m_sysTimeStressBegins
//	is current or in the future. FALSE if not.
//
////////////////////////////////////////////////////////////
BOOL
ServerCommands::IsTimeToBeginStress()
{
	SYSTEMTIME	stCurrent, stBeginStress, stEndStress;
	FILETIME	ftCurrent, ftBeginStress, ftEndStress;
	BOOL		bResult = FALSE;

	EnterCriticalSection(&g_csServerCommandsVars);

	// always run stress now if server tells us to
	if (m_bRunForever)
	{
		bResult = TRUE;
		goto Exit;
	}


	// check to see if valid time values have been received. If not, then we always fail.
	if (
		m_iTimeStressBeginsHour < 0 || m_iTimeStressBeginsMinute < 0 ||
		m_iTimeStressEndsHour < 0 || m_iTimeStressEndsMinute < 0
		)
	{
		bResult = FALSE;
		goto Exit;
	}

	GetLocalTime(&stCurrent);
	GetLocalTime(&stBeginStress);
	GetLocalTime(&stEndStress);

	// use the hour and minute time that we got from the command server
	stBeginStress.wHour		= m_iTimeStressBeginsHour;
	stBeginStress.wMinute	= m_iTimeStressBeginsMinute;

	stEndStress.wHour		= m_iTimeStressEndsHour;
	stEndStress.wMinute		= m_iTimeStressEndsMinute;

	// convert to file time so we can compare
	SystemTimeToFileTime(&stCurrent, &ftCurrent);
	SystemTimeToFileTime(&stBeginStress, &ftBeginStress);
	SystemTimeToFileTime(&stEndStress, &ftEndStress);


	// If EndTime < BeginTime, then it means stress is running for
	// over a day so we have to add 24 hours to the end time.
	ULARGE_INTEGER	ulEndStress;
	ULONGLONG		ullNanoSecondsInAFreakingDay;

	ulEndStress.LowPart		= ftEndStress.dwLowDateTime;
	ulEndStress.HighPart	= ftEndStress.dwHighDateTime;

	// stress runs across two days so we wrap around one day
	ullNanoSecondsInAFreakingDay = 24 * 60;		// minutes in a day
	ullNanoSecondsInAFreakingDay *= 60;			// seconds in a day
	ullNanoSecondsInAFreakingDay *= 1000000000;	// number of nanoseconds in a day. 10^9 NS in a second
	ullNanoSecondsInAFreakingDay /= 100;		// The FILETIME structure is a 64-bit value representing the number of 100-nanosecond intervals since January 1, 1601. 

	if (m_iTimeStressEndsHour < m_iTimeStressBeginsHour) 
	{
		// ********************
		// ********************
		// ** increase by 24 hours
		// **

		ulEndStress.QuadPart		 += ullNanoSecondsInAFreakingDay;

		// copy back to the original EndStress Date/Time
		ftEndStress.dwHighDateTime	= ulEndStress.HighPart;
		ftEndStress.dwLowDateTime	= ulEndStress.LowPart;

		FileTimeToSystemTime(&ftEndStress, &stEndStress);
	}
	else
	{
		// stress runs in the same day
		if ((m_iTimeStressEndsHour == m_iTimeStressBeginsHour) &&
			(m_iTimeStressEndsMinute <= m_iTimeStressBeginsMinute))
		{
			// if 7:30 to 7:20 - we wrap around one day.
			ulEndStress.QuadPart	+= ullNanoSecondsInAFreakingDay;

			// copy back to the original EndStress Date/Time
			ftEndStress.dwHighDateTime	= ulEndStress.HighPart;
			ftEndStress.dwLowDateTime	= ulEndStress.LowPart;

			FileTimeToSystemTime(&ftEndStress, &stEndStress);
		}
	}


	// Begin stress if:
	// (BeginTime <= CurrentTime <= EndTime)
	if ((0 <= CompareFileTime(&ftCurrent, &ftBeginStress)) && (0 <= CompareFileTime(&ftEndStress, &ftCurrent)))
		bResult = TRUE;
	else
		bResult = FALSE;

Exit:
	LeaveCriticalSection(&g_csServerCommandsVars);

	return bResult;
}


////////////////////////////////////////////////////////////
// Function:  ServerCommands::IsTimeToExitStress()
//
// Purpose:
//	TRUE if it's time to end stress based on the COMMANDHEADER__EXIT headers
//	from the Command Server exists. FALSE if not.
//
////////////////////////////////////////////////////////////
BOOL
ServerCommands::IsTimeToExitStress()
{
	return m_bExit;
}


////////////////////////////////////////////////////////////
// Function:  ServerCommands::Get_CommandServerURL()
//
// Purpose:
//	Returns the Command Server URL.
//
////////////////////////////////////////////////////////////
LPTSTR
ServerCommands::Get_CommandServerURL()
{
	return m_szCommandServerURL;
}


////////////////////////////////////////////////////////////
// Function:  ServerCommands::Get_CommandServerResultsURL()
//
// Purpose:
//	Returns the Command Server Results URL.
//
////////////////////////////////////////////////////////////
LPTSTR
ServerCommands::Get_CommandServerResultsURL()
{
	return m_szCommandServerResultsURL;
}


////////////////////////////////////////////////////////////
// Function:  ServerCommands::Get_NumberOfStressInstances()
//
// Purpose:
//	Returns the number of stressInstances running or pending.
//
////////////////////////////////////////////////////////////
DWORD
ServerCommands::Get_NumberOfStressInstances()
{
	return m_arStressInstanceList.size();
}


////////////////////////////////////////////////////////////
// Function:  ServerCommands::Get_TestDllFileName()
//
// Purpose:
//	Returns the name of the test DLL. ex. "winhttp5.dll"
//
////////////////////////////////////////////////////////////
LPTSTR
ServerCommands::Get_TestDllFileName()
{
	// m_szWinHttpDLL_FileName can be NULL in the case that a test DLL is not downloaded

	if (0 < _tcslen(m_szWinHttpDLL_FileName))
		return m_szWinHttpDLL_FileName;
	else
		return _T("winhttp5.dll");
}


////////////////////////////////////////////////////////////
// Function:  ServerCommands::RegisterClient()
//
// Purpose:
//	Sends the command server the system info on this client.
//	This lets the command server know that this client is alive.
//
//	NOTE: This only works in NT because we query
//	environment vars not present in Win9x
//
////////////////////////////////////////////////////////////
BOOL
ServerCommands::RegisterClient()
{
	OSVERSIONINFOA	osInfo;
	BOOL			bResult		= FALSE;
	DWORD			dwPostSize	= 5000;
	DWORD			dwTempSize	= MAX_PATH;
	DWORD			dwSizeSoFar	= 0;	// size of string written to szTemp so far.
	LPSTR			szPost		= new CHAR[dwPostSize];
	LPSTR			szTemp		= new CHAR[dwTempSize];


	ZeroMemory(szTemp, dwTempSize);
	ZeroMemory(szPost, dwPostSize);

	// *********************
	// *********************
	// ** Get windows version info
	osInfo.dwOSVersionInfoSize = sizeof(osInfo);
	if (!GetVersionExA(&osInfo))
		goto Exit;

	dwSizeSoFar += GetEnvironmentVariableA("OS", szTemp, dwTempSize);
	dwSizeSoFar += sizeof(FIELDNAME__OS_PLATFORM);
	strcat(szPost, FIELDNAME__OS_PLATFORM);
	strcat(szPost, szTemp);

	strcat(szPost, "&" FIELDNAME__OS_BUILD);
	strcat(szPost, _itoa(osInfo.dwBuildNumber, szTemp, 10));

	strcat(szPost, "&" FIELDNAME__OS_MAJORVERSION);
	strcat(szPost, _itoa(osInfo.dwMajorVersion, szTemp, 10));

	strcat(szPost, "&" FIELDNAME__OS_MINORVERSION);
	strcat(szPost, _itoa(osInfo.dwMinorVersion, szTemp, 10));

	strcat(szPost, "&" FIELDNAME__OS_EXTRAINFO);
	strcat(szPost, osInfo.szCSDVersion);


	// *********************
	// *********************
	// ** Get processor info
	GetEnvironmentVariableA("PROCESSOR_ARCHITECTURE", szTemp, dwTempSize);
	strcat(szPost, "&" FIELDNAME__SYSTEMINFO_PROCSSSOR_ARCHITECTURE);
	strcat(szPost, szTemp);

	GetEnvironmentVariableA("PROCESSOR_IDENTIFIER", szTemp, dwTempSize);
	strcat(szPost, "&" FIELDNAME__SYSTEMINFO_PROCSSSOR_ID);
	strcat(szPost, szTemp);

	GetEnvironmentVariableA("PROCESSOR_LEVEL", szTemp, dwTempSize);
	strcat(szPost, "&" FIELDNAME__SYSTEMINFO_PROCSSSOR_LEVEL);
	strcat(szPost, szTemp);

	GetEnvironmentVariableA("PROCESSOR_REVISION", szTemp, dwTempSize);
	strcat(szPost, "&" FIELDNAME__SYSTEMINFO_PROCSSSOR_REVISION);
	strcat(szPost, szTemp);

	GetEnvironmentVariableA("NUMBER_OF_PROCESSORS", szTemp, dwTempSize);
	strcat(szPost, "&" FIELDNAME__SYSTEMINFO_PROCSSSOR_NUMBER_OF);
	strcat(szPost, szTemp);


	// *********************
	// *********************
	// ** Get user info
	GetEnvironmentVariableA("USERNAME", szTemp, dwTempSize);
	strcat(szPost, "&" FIELDNAME__USERINFO_USERALIAS);
	strcat(szPost, szTemp);

	GetEnvironmentVariableA("USERDOMAIN", szTemp, dwTempSize);
	strcat(szPost, "&" FIELDNAME__USERINFO_USERDOMAIN);
	strcat(szPost, szTemp);

	// BUGBUG: someone needs to resolve the user alias to the real full name of the user
	// FIELDNAME__USERINFO_FULLNAME


	// get the client's machine name
	strcat(szPost, "&" FIELDNAME__USERINFO_MACHINENAME);
	strcat(szPost, m_szClientMachineName);


	// Let the Command Server know that this client is alive
	bResult = NetworkTools__POSTResponse(STRESS_COMMAND_SERVER_REGISTERCLIENT_URL, szPost, NULL);

	// LOGLOG: stressScheduler has started
	bResult = NetworkTools__SendLog(FIELDNAME__LOGTYPE_START_UP, "WinHttpStressScheduler has started.", NULL, NULL);

Exit:
	delete [] szPost;
	delete [] szTemp;

	return bResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\tools\stress\winhttpstressscheduler.cpp ===
///////////////////////////////////////////////////////////////////////////
// File:  WinHttpStressScheduler.cpp
//
// Copyright (c) 2001 Microsoft Corporation.  All Rights Reserved.
//
// Purpose:
//	Global interfaces for the WinHttpStressScheduler project.
//
// History:
//	02/05/01	DennisCh	Created
///////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////
//
// Includes
//
//////////////////////////////////////////////////////////////////////

//
// Win32 headers
//

//
// Project headers
//
#include "WinHttpStressScheduler.h"
#include "ServerCommands.h"
#include "NetworkTools.h"


//////////////////////////////////////////////////////////////////////
//
// Globals and statics
//
//////////////////////////////////////////////////////////////////////

HINSTANCE		g_hInstance;
HWND			g_hWnd;
ServerCommands	g_objServerCommands;

// Forward function definitions
LRESULT	CALLBACK	MainWndProc(HWND, UINT, WPARAM, LPARAM);
BOOL				SystemTray_UpdateIcon(HWND hwnd, DWORD dwMessage, UINT uID, HICON hIcon, PSTR pszTip);
BOOL				Show_IconShortCutMenu();
BOOL				OS_IsSupported();


////////////////////////////////////////////////////////////
// Function:  WinMain( HINSTANCE, HINSTANCE, LPWSTR, int )
//
// Purpose:
//	This is the entry-point into WinHttpStressScheduler.
//
// Called by:
//	[System]
////////////////////////////////////////////////////////////
int
WINAPI
WinMain
(
   HINSTANCE	hInstance,		// [IN] handle to the process instance
   HINSTANCE	hPrecInstance,	// [IN] handle to the previous instance
   LPTSTR		lpCmdLine,		// [IN] command line
   int			nShowCmd		// [IN] show command
)
{
	MSG				msg;
	WNDCLASSEX		wndClass;

	wndClass.cbSize			= sizeof(WNDCLASSEX); 
	wndClass.style			= CS_HREDRAW | CS_VREDRAW;
	wndClass.lpfnWndProc	= (WNDPROC) MainWndProc;
	wndClass.cbClsExtra		= 0;
	wndClass.cbWndExtra		= 0;
	wndClass.hInstance		= hInstance;
	wndClass.hIcon			= NULL;
	wndClass.hCursor		= NULL;
	wndClass.hbrBackground	= NULL;
	wndClass.lpszMenuName	= NULL;
	wndClass.lpszClassName	= WINHTTP_STRESS_SCHEDULER__NAME;
	wndClass.hIconSm		= NULL;

	RegisterClassEx(&wndClass);

	// cache our hInstance
	g_hInstance = hInstance;

    // Create window. 
	g_hWnd = NULL;
    g_hWnd = CreateWindow( 
        WINHTTP_STRESS_SCHEDULER__NAME,
        NULL,
        WS_OVERLAPPEDWINDOW,
        CW_USEDEFAULT,
        0,
        CW_USEDEFAULT,
        0,
        NULL,
        NULL,
        hInstance,
        NULL);

	if (!g_hWnd)
		return FALSE;

	// Verify that we're running a supported version of Windows
	if (!OS_IsSupported())
		return FALSE;

	// Add icon to the system tray icon
	if (!SystemTray_UpdateIcon(g_hWnd, NIM_ADD, 0, LoadIcon(g_hInstance, MAKEINTRESOURCE(IDI_MAIN_ICON)), WINHTTP_STRESS_SCHEDULER__NAME))
		return FALSE;

	// Create timer to ping the Command Server for commands
	SetTimer(g_hWnd, IDT_QUERY_COMMAND_SERVER, g_objServerCommands.Get_CommandServerUpdateInterval(), (TIMERPROC) NULL);

	// Message loop
	while (GetMessage(&msg, NULL, 0, 0))
	{
		TranslateMessage(&msg);
		DispatchMessage(&msg);
	}

	// remove the icon from the system tray
	if (WM_QUIT == msg.message)
		SystemTray_UpdateIcon(g_hWnd, NIM_DELETE, 0, NULL, NULL);

	return msg.wParam;
}


////////////////////////////////////////////////////////////
// Function:  MainWndProc( HWND, UINT, WPARAM, LPARAM)
//
// Purpose:
//	Window callback procedure for UI.
//
// Called by:
//	WinMain
////////////////////////////////////////////////////////////
LRESULT
CALLBACK
MainWndProc
(
	HWND	hwnd,	// [IN] Handle to current window
	UINT	iMsg,	// [IN] Incoming message
	WPARAM	wParam,	// [IN] Parameter
	LPARAM	lParam	// [IN] Parameter
)
{
	switch (iMsg)
	{
		case MYWM_NOTIFYICON:
			// Notifications sent for the System Tray icon
			switch (lParam)
			{
				case WM_LBUTTONDOWN:

				case WM_RBUTTONDOWN:
					Show_IconShortCutMenu();
					return 0;

				default:
					break;
			}
			return 0;

		case WM_COMMAND:

			// User clicked on the popup menu
			switch (LOWORD(wParam))
			{
				case IDM_BEGIN_STRESS:
					// begin stress only if it's time to
					if (g_objServerCommands.IsTimeToBeginStress())
						g_objServerCommands.BeginStress();
					else
						g_objServerCommands.QueryServerForCommands();
				break;

				case IDM_END_STRESS:
					// end stress only if it's time to.
					if (!g_objServerCommands.IsTimeToBeginStress())
						g_objServerCommands.EndStress();
				break;

				case IDM_WINHTTP_HOME:
					ShellExecute(g_hWnd, "open", WINHTTP_WINHTTP_HOME_URL, NULL, NULL, SW_SHOW);
				break;

				case IDM_OPENSTRESSADMIN:
					ShellExecute(g_hWnd, "open", WINHTTP_STRESSADMIN_URL, NULL, NULL, SW_SHOW);
				break;

				case IDM_EXIT:
					g_objServerCommands.EndStress();
					PostQuitMessage(0);
				break;
			}
			return 0;

		case WM_TIMER:
			switch (wParam)
			{
				case IDT_QUERY_COMMAND_SERVER:
					// Query the server for commands
					g_objServerCommands.QueryServerForCommands();

					// Update the timer timeout
					KillTimer(g_hWnd, IDT_QUERY_COMMAND_SERVER);
					SetTimer(
						g_hWnd,
						IDT_QUERY_COMMAND_SERVER,
						g_objServerCommands.Get_CommandServerUpdateInterval(),
						(TIMERPROC) NULL);

					// ***************************
					// ***************************
					// ** Act accordingly based on Command Server messages
					// **

					// *********************************
					// ** EXIT stressScheduler
					if (g_objServerCommands.IsTimeToExitStress())
					{
						g_objServerCommands.EndStress();

						// quit stressScehduler
						PostQuitMessage(0);
						return 0;
					}

					// *********************************
					// ** BEGIN/END stress
					// Begin/end stress if it's time
					if (g_objServerCommands.IsTimeToBeginStress())
						g_objServerCommands.BeginStress();
					else
						g_objServerCommands.EndStress();

					return 0;

				break;
			}
			return 0;

		case WM_CREATE:
			return 0;

		case WM_DESTROY:
			return 0;

		default:
			return DefWindowProc (hwnd, iMsg, wParam, lParam);
	}
}



////////////////////////////////////////////////////////////
// Function:  SystemTray_UpdateIcon(HWND hDlg, DWORD dwMessage, UINT uID, WORD wIconResource, PSTR pszTip)
//
// Purpose:
//	This add/modifies/removes an icon from the system tray.
//
// Called by:
//	WinMain
////////////////////////////////////////////////////////////
BOOL
SystemTray_UpdateIcon(
	HWND hwnd,			// [IN] handle to the window object
	DWORD dwMessage,	// [IN] option to apply to the icon
	UINT uID,			// [IN] ID of the icon
	HICON hIcon,		// [IN] handle to an icon if we're loading one
	PSTR pszTip			// [IN] string containing the tool tip text
)
{
    BOOL			bSuccess;
	NOTIFYICONDATA	tnd;

	tnd.cbSize				= sizeof(NOTIFYICONDATA);
	tnd.hWnd				= hwnd;
	tnd.uID					= uID;
	tnd.uFlags				= NIF_MESSAGE | NIF_ICON | NIF_TIP;
	tnd.uCallbackMessage	= MYWM_NOTIFYICON;
	tnd.hIcon				= hIcon;

	if (pszTip)
		lstrcpyn(tnd.szTip, pszTip, sizeof(tnd.szTip));
	else
		tnd.szTip[0] = '\0';

	bSuccess = Shell_NotifyIcon(dwMessage, &tnd);

	if (hIcon)
		DestroyIcon(hIcon);

	return bSuccess;
}



////////////////////////////////////////////////////////////
// Function:  Show_IconShortCutMenu()
//
// Purpose:
//	This will show the popup menu at the position of the mouse
//	pointer.
//
// Called by:
//	MainWndProc
////////////////////////////////////////////////////////////
BOOL
Show_IconShortCutMenu()
{
	POINT		ptMouse;
	HMENU		hPopUpMenu	= NULL;
	HMENU		hMenu		= NULL;
	MENUINFO	menuInfo;
	BOOL		bResult		= FALSE;

	// Get the current mouse position
	if (0 != GetCursorPos(&ptMouse))
	{
		// show the popup menu
		hMenu = LoadMenu(g_hInstance, MAKEINTRESOURCE(IDR_POPUPMENU));
		if (!hMenu)
			return FALSE;

		hPopUpMenu	= GetSubMenu(hMenu, 0);
		if (!hPopUpMenu)
			return FALSE;

		/*
		// Make the menu go away after mouseover
		ZeroMemory(&menuInfo, sizeof(MENUINFO));
		menuInfo.cbSize		= sizeof(MENUINFO);
		menuInfo.fMask		= MIM_APPLYTOSUBMENUS | MIM_STYLE;
		menuInfo.dwStyle	= MNS_AUTODISMISS;

		BOOL temp = SetMenuInfo(hPopUpMenu, &menuInfo);
		*/
		bResult = 
			TrackPopupMenuEx(
			hPopUpMenu,
			TPM_RIGHTALIGN | TPM_BOTTOMALIGN,
			ptMouse.x,
			ptMouse.y,
			g_hWnd,
			NULL);
	}

	DestroyMenu(hMenu);

	return bResult;
}


////////////////////////////////////////////////////////////
// Function:  OS_IsSupported()
//
// Purpose:
//	Returns TRUE if this APP is supported in the OS and FALSE if not.
//	As of now, winhttp is only supported on NT platforms. NT4, Win2k, and WinXP.
//
// Called by:
//	MainWndProc
////////////////////////////////////////////////////////////
BOOL
OS_IsSupported()
{
	BOOL			bSupported = TRUE;
	OSVERSIONINFO	osVI;

	osVI.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);

	if (GetVersionEx(&osVI))
	{
		if (VER_PLATFORM_WIN32_NT == osVI.dwPlatformId)
			bSupported = TRUE;
		else
			bSupported = FALSE;
	}
	else
		bSupported = FALSE;

	return bSupported;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\tools\stress\servercommands.h ===
//////////////////////////////////////////////////////////////////////
// File:  WinHttpStressScheduler.h
//
// Copyright (c) 2001 Microsoft Corporation.  All Rights Reserved.
//
// Purpose:
//	ServerCommands.h: interface for the ServerCommands class.
//	This class is used to retrieve and act on command from the server.
//
// History:
//	02/08/01	DennisCh	Created
//
//////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////
// Includes
//////////////////////////////////////////////////////////////////////

//
// WIN32 headers
//
#define UNICODE
#define _UNICODE

#include <stdio.h>
#include <shlwapi.h>
#include <windows.h>
#include <tchar.h>
#include <winhttp.h>
#include <vector>

//
// Project headers
//
#include "StressInstance.h"


//////////////////////////////////////////////////////////////////////
// Constants
//////////////////////////////////////////////////////////////////////
#if !defined(AFX_SERVERCOMMANDS_H__6B84102D_2F79_4FE0_A936_ED4F043AC75E__INCLUDED_)
#define AFX_SERVERCOMMANDS_H__6B84102D_2F79_4FE0_A936_ED4F043AC75E__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRESS_SCHEDULER_USER_AGENT						_T("WinHttp Stress Scheduler")

//#define STRESS_COMMAND_SERVER_URL						_T("http://hairball/api/Stress/set-response-header.asp?name=WinHttpStress_Quit&value=")
#define STRESS_COMMAND_SERVER_URL						_T("http://hairball/stressAdmin/stressCommand.asp")
#define STRESS_COMMAND_SERVER_RESULTS_URL				_T("http://hairball/api/Stress/set-response-header.asp")

// When we first start up, we report our client stats and post them to this page to let the server know that we're alive
#define STRESS_COMMAND_SERVER_REGISTERCLIENT_URL		_T("http://hairball/stressAdmin/registerClient.asp")
#define STRESS_COMMAND_SERVER_LOGURL					_T("http://hairball/stressAdmin/logStress.asp")

#define STRESS_COMMAND_SERVER_UPDATE_INTERVAL			4000		// 4 second default timeout
#define STRESS_COMMAND_SERVER_MINIMUM_UPDATE_INTERVAL	2000		// 2 second minimum timeout. Don't want to flood the network.
#define STRESS_COMMAND_SERVER_MAXIMUM_UPDATE_INTERVAL	300000		// 5 minute maximum timeout. Don't want to lose you!


#define MAX_URL											MAX_PATH * 2

// Timer related definitions
#define IDT_QUERY_COMMAND_SERVER						1			// timer identifier for pinging the command server


// List of URLs for the stress EXE's that we need to download
using namespace std;

typedef StressInstance			*PSTRESSINSTANCE;
typedef vector<PSTRESSINSTANCE>	PSTRESSINSTANCE_LIST;

// *****************************************************
// *****************************************************
// *** List of headers that the command server can send us.
// *** 
#define COMMANDHEADER__EXIT						_T("WinHttpStress_Exit")					// valid values: None. If the header is present, then assume we want to exit.
#define COMMANDHEADER__WINHTTP_DLL_URL			_T("WinHttpStress_WinHttpDllURL")			// valid values: Valid URL
#define COMMANDHEADER__WINHTTP_PDB_URL			_T("WinHttpStress_WinHttpPDBURL")			// valid values: Valid URL
#define COMMANDHEADER__WINHTTP_SYM_URL			_T("WinHttpStress_WinHttpSYMURL")			// valid values: Valid URL
#define COMMANDHEADER__ABORT					_T("WinHttpStress_Abort")					// valid values: ID of a stressInstance from the DB that needs to be aborted
#define COMMANDHEADER__MEMORY_DUMP_PATH			_T("WinHttpStress_MemoryDumpPath")			// valid values: Valid path
#define COMMANDHEADER__STRESS_EXE_URL			_T("WinHttpStress_StressExeURL")			// valid values: Valid URL
#define COMMANDHEADER__STRESS_PDB_URL			_T("WinHttpStress_StressPDBURL")			// valid values: Valid URL
#define COMMANDHEADER__STRESS_SYM_URL			_T("WinHttpStress_StressSYMURL")			// valid values: Valid URL
#define COMMANDHEADER__STRESS_EXE_INSTANCEID	_T("WinHttpStress_StressExeInstanceID")		// valid values: Valid ID from the stressAdmin DB table identifying the stressInstance. This is how stressScheduler tells stressAdmin the status of each stressInstance.
#define COMMANDHEADER__STRESS_EXE_PAGEHEAP		_T("WinHttpStress_PageHeapCommand")			// valid values: pageheap command line. will not use pageheap if missing
#define COMMANDHEADER__STRESS_EXE_UMDH			_T("WinHttpStress_UMDHCommand")				// valid values: UMDH command line. will not use UMDH if missing
#define COMMANDHEADER__COMMANDSERVER_URL		_T("WinHttpStress_CommandServerURL")		// valid values: Valid URL
#define COMMANDHEADER__BEGIN_TIME_HOUR			_T("WinHttpStress_BeginTimeHour")			// valid values: 0-23
#define COMMANDHEADER__BEGIN_TIME_MINUTE		_T("WinHttpStress_BeginTimeMinute")			// valid values: 0-59
#define COMMANDHEADER__END_TIME_HOUR			_T("WinHttpStress_EndTimeHour")				// valid values: 0-23
#define COMMANDHEADER__END_TIME_MINUTE			_T("WinHttpStress_EndTimeMinute")			// valid values: 0-59
#define COMMANDHEADER__RUN_FOREVER				_T("WinHttpStress_RunForever")				// valid values: 0 or 1
#define COMMANDHEADER__UPDATE_INTERVAL			_T("WinHttpStress_UpdateInterval")			// valid values: Time to wait to ping the command server in milliseconds.

// *****************************************************
// *****************************************************
// *** List of form names and values that we send back to the command server
// *** 

// **********************
// ** Logging POST fields
#define FIELDNAME__LOGTYPE						"LogType="
#define FIELDNAME__LOGTYPE_INFORMATION			FIELDNAME__LOGTYPE "INFORMATION"
#define FIELDNAME__LOGTYPE_START_UP				FIELDNAME__LOGTYPE "STRESSSECHDULER_START_UP"
#define FIELDNAME__LOGTYPE_EXIT					FIELDNAME__LOGTYPE "STRESSSECHDULER_EXIT"
#define FIELDNAME__LOGTYPE_MEMORY_INFORMATION	FIELDNAME__LOGTYPE "MEMORY_INFORMATION"
#define FIELDNAME__LOGTYPE_DUMPFILE_CREATED		FIELDNAME__LOGTYPE "DUMP_FILE_CREATED"
#define FIELDNAME__LOGTYPE_ERROR				FIELDNAME__LOGTYPE "ERROR"
#define FIELDNAME__LOGTYPE_SUCCESS				FIELDNAME__LOGTYPE "SUCCESS"
#define FIELDNAME__LOGTYPE_BEGIN_STRESS			FIELDNAME__LOGTYPE "BEGIN_STRESS"
#define FIELDNAME__LOGTYPE_END_STRESS			FIELDNAME__LOGTYPE "END_STRESS"
#define FIELDNAME__LOGTYPE_BEGIN				FIELDNAME__LOGTYPE "BEGIN_STRESS_INSTANCE"
#define FIELDNAME__LOGTYPE_END					FIELDNAME__LOGTYPE "END_STRESS_INSTANCE"

#define FIELDNAME__LOG_TEXT				"LogText="
#define FIELDNAME__STRESSINSTANCE_ID	"StressInstanceID="


// **********************
// ** System information for registering the client POST fields.

// StressExe process return values
#define FIELDNAME__STRESSEXE_PRIVATEBYTES		"StressExe_PrivateBytes=%d"
#define FIELDNAME__STRESSEXE_HANDLECOUNT		"StressExe_HandleCount=%d"
#define FIELDNAME__STRESSEXE_THREADCOUNT		"StressExe_ThreadCount=%d"

// System Memory Info
#define FIELDNAME__MEMORY_HANDLES						"System_Handles=%d"
#define FIELDNAME__MEMORY_THREADS						"System_Threads=%d"
#define FIELDNAME__MEMORY_VMSIZE						"System_VMSize=%d"
#define FIELDNAME__MEMORY_COMMITTEDPAGEFILETOTAL		"System_CommittedPageFileTotal=%d"
#define FIELDNAME__MEMORY_AVAILABLEPAGEFILETOTAL		"System_AvailablePageFileTotal=%d"
#define FIELDNAME__MEMORY_SYSTEMCODETOTAL				"System_SystemCodeTotal=%d"
#define FIELDNAME__MEMORY_SYSTEMDRIVERTOTAL				"System_SystemDriverTotal=%d"
#define FIELDNAME__MEMORY_NONPAGEDPOOLTOTAL				"System_NonPagedPoolTotal=%d"
#define FIELDNAME__MEMORY_PAGEDPOOLTOTAL				"System_PagedPoolTotal=%d"
#define FIELDNAME__MEMORY_PHYSICAL_MEMORY_AVAILABLE		"System_PhysicalMemoryAvailable=%d"
#define FIELDNAME__MEMORY_SYSTEMCACHETOTAL				"System_SystemCacheTotal=%d"
#define FIELDNAME__MEMORY_FREESYSTEM_PAGETABLE_ENTRIES	"System_FreeSystemPageTableEntries=%d"
#define FIELDNAME__MEMORY_DISK_SPACE_AVAILABLE			"System_DiskSpaceAvailable=%d"

// Processor Info
#define FIELDNAME__SYSTEMINFO_PROCSSSOR_ARCHITECTURE	"StressExeSystemInfo_ProcessorArchitecture="
#define FIELDNAME__SYSTEMINFO_PROCSSSOR_ID				"StressExeSystemInfo_ProcessorID="
#define FIELDNAME__SYSTEMINFO_PROCSSSOR_LEVEL			"StressExeSystemInfo_ProcessorLevel="
#define FIELDNAME__SYSTEMINFO_PROCSSSOR_REVISION		"StressExeSystemInfo_ProcessorRevision="
#define FIELDNAME__SYSTEMINFO_PROCSSSOR_NUMBER_OF		"StressExeSystemInfo_ProcessorNumberOf="

// OS Info
#define FIELDNAME__OS_PLATFORM		"StressExeOSInfo_Platform="
#define FIELDNAME__OS_BUILD			"StressExeOSInfo_Build="
#define FIELDNAME__OS_MAJORVERSION	"StressExeOSInfo_MajorVersion="
#define FIELDNAME__OS_MINORVERSION	"StressExeOSInfo_MinorVersion="
#define FIELDNAME__OS_EXTRAINFO		"StressExeOSInfo_ExtraInfo="

// User Info
#define FIELDNAME__USERINFO_USERALIAS		"StressExeUserInfo_Alias="
#define FIELDNAME__USERINFO_USERDOMAIN		"StressExeUserInfo_Domain="
#define FIELDNAME__USERINFO_FULLNAME		"StressExeUserInfo_FullName="
#define FIELDNAME__USERINFO_MACHINENAME		"StressExeUserInfo_MachineName="

// Test info
#define FIELDNAME__TESTINFO_TEST_DLL_VERSION	"StressExeTestInfo_TestDLLVersion="


class ServerCommands  
{
public:

	// *****************************************************
	// *****************************************************
	// ** Public ServerCommands methods
	// ** 
			ServerCommands();
	virtual	~ServerCommands();

	BOOL	QueryServerForCommands();

	BOOL	IsStressRunning();
	BOOL	IsTimeToBeginStress();
	BOOL	IsTimeToExitStress();

	BOOL	Download_WinHttpDLL();

	VOID	Clear_StressExeURLs();

	LPSTR	Get_ClientMachineName();
	DWORD	Get_CommandServerUpdateInterval();
	LPTSTR	Get_CommandServerResultsURL();
	LPTSTR	Get_CommandServerURL();
	LPTSTR	Get_CurrentWorkingDirectory();
	DWORD	Get_NumberOfStressInstances();
	LPTSTR	Get_TestDllFileName();

	VOID	Create_StressInstance(DWORD, LPTSTR, LPTSTR, LPTSTR, LPTSTR, LPTSTR, LPTSTR);

	BOOL	RegisterClient();

	VOID	Set_WinHttpDllURL(LPTSTR, DWORD);
	VOID	Set_WinHttpPDBURL(LPTSTR, DWORD);
	VOID	Set_WinHttpSYMURL(LPTSTR, DWORD);
	VOID	Set_CommandServerURL(LPTSTR, DWORD);
	VOID	Set_CommandServerUpdateInterval(DWORD);
	VOID	Set_TimeStressBegins(LPTSTR, LPTSTR);
	VOID	Set_TimeStressEnds(LPTSTR, LPTSTR);
	VOID	Set_RunForever(BOOL);
	VOID	Set_ExitStress(BOOL);

	VOID	BeginStress();
	VOID	EndStress();
	VOID	AbortStressInstance(DWORD);


private:
	// *****************************************************
	// *****************************************************
	// ** These vars contain commands(headers) from the command server
	// **
	LPTSTR		m_szCommandServerURL;					// Command server URL to request commands from
	LPTSTR		m_szCommandServerResultsURL;			// Command server URL where the results will be posted

	DWORD		m_dwCommandServerUpdateInternval;		// Time to wait to ping the server for commands in milliseconds.

	LPTSTR		m_szWinHttpDLL_DownloadURL;				// Where to get the latest WinHttp from
	LPTSTR		m_szWinHttpPDB_DownloadURL;				// Where winhttp's PDB symbol file from
	LPTSTR		m_szWinHttpSYM_DownloadURL;				// Where winhttp's SYM symbol file from
	LPTSTR		m_szWinHttpDLL_FileName;				// Filename of the WinHttp DLL.

	LPSTR		m_szClientMachineName;					// Computer name of the client
	LPTSTR		m_szStressSchedulerCurrentDirectory;	// stressScheduler's current directory.

	INT			m_iTimeStressBeginsHour;				// 0-23
	INT			m_iTimeStressBeginsMinute;				// 0-59
	INT			m_iTimeStressEndsHour;					// 0-23
	INT			m_iTimeStressEndsMinute;				// 0-59

	BOOL		m_bRunForever;							// 1 to run stress until stopped and 0 to rely on begin/end times

	BOOL		m_bExit;								// Quit signal from server to exit the app
	BOOL		m_bStressHasStarted;					// TRUE = started; FALSE = inactive

	PSTRESSINSTANCE_LIST			m_arStressInstanceList;		// List of URLs for the stress EXEs to download
	PSTRESSINSTANCE_LIST::iterator	m_dwStressInstanceIterator;	// Iterator for m_arszStressExeList
};

#endif // !defined(AFX_SERVERCOMMANDS_H__6B84102D_2F79_4FE0_A936_ED4F043AC75E__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\tools\stress\res\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by resource.rc
//
#define IDI_MAIN_ICON                   101
#define IDR_POPUPMENU                   107
#define IDM_BEGIN_STRESS                40007
#define IDM_END_STRESS                  40008
#define IDM_EXIT                        40009
#define IDM_OPENSTRESSADMIN             40012
#define IDM_WINHTTP_HOME                40014

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        120
#define _APS_NEXT_COMMAND_VALUE         40015
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\tools\stress\stressapps\stressapps.inc ===
!IF 0

Copyright (c) 2001  Microsoft Corporation

!ENDIF

#
# if TARGETPATH is not defined (in the paths that build libraries) then this
# is the default target path
#
!IFNDEF TARGETPATH
TARGETPATH=obj
TARGETTYPE=UMAPPL_NOLIB
!ENDIF

#
# define some macros that subprojects can use
#
ROOT=$(SDXROOT)\inetcore\winhttp\tools\stress
STRESSINC=$(ROOT)\stressapps\core
WINHTTPLIB=$(SDXROOT)\inetcore\winhttp\v5\dll\obj\i386
WINHTTPINC=$(SDXROOT)\inetcore\winhttp\v5\inc

#
# what it is that we're building
#
MAJORCOMP=stressapps
USE_NOLIBS=1
NO_NTDLL=1

#
# Linker flags
#
WIN32_WINNT_VERSION=0x0500
#WIN32_WIN95_VERSION=0x0400

#
# compiler warning flags
#
MSC_WARNING_LEVEL=/W3 /WX

#
# enable exception handling
#
USE_NATIVE_EH=1

#
# compiler definitions
#
C_DEFINES=$(C_DEFINES) -DWIN32

#
# Set debugging level
#
!IF "$(NTDEBUG)" != "" && "$(NTDEBUG)" != "retail" && "$(NTDEBUG)" != "ntsdnodbg"
C_DEFINES=$(C_DEFINES) -D_DEBUG
!ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\tools\stress\stressapps\asyncwebcrawler\stresstesttemplate.cpp ===
//////////////////////////////////////////////////////////////////////
// File:  stressTest.cpp
//
// Copyright (c) 2001 Microsoft Corporation.  All Rights Reserved.
//
// Purpose:
//		<Description>
//
// History:
//	05/24/2001	pmidge		Created
//
//////////////////////////////////////////////////////////////////////


#include "crawler.h"


LPSTR	    g_szStressTestName = "AsyncWebCrawler";
LPWSTR    g_szDictPath       = L"http://mildew/stress/xmldict/5000.xml";
HINTERNET g_hSession         = NULL;
PXMLDICT  g_pDictionary      = NULL;
HANDLE    g_hIOCP            = NULL;
HANDLE    g_evtMoreUrls      = NULL;
HANDLE    g_evtQuit          = NULL;
HANDLE    g_arThreads[WORKER_THREADS];

LONG      g_lRefCount        = 0L;
LONG      g_lUrlObjsAlloc    = 0L;
LONG      g_lUrlObjsFreed    = 0L;

DWORD WINAPI WorkerThread(LPVOID pv);


#define CALLBACK_FLAGS ( WINHTTP_CALLBACK_STATUS_SENDREQUEST_COMPLETE \
                       | WINHTTP_CALLBACK_STATUS_REDIRECT             \
                       | WINHTTP_CALLBACK_STATUS_REQUEST_ERROR        \
                       | WINHTTP_CALLBACK_STATUS_HEADERS_AVAILABLE    \
                       | WINHTTP_CALLBACK_STATUS_DATA_AVAILABLE       \
                       | WINHTTP_CALLBACK_STATUS_READ_COMPLETE        \
                       | WINHTTP_CALLBACK_STATUS_HANDLE_CLOSING       \
                       | WINHTTP_CALLBACK_STATUS_CONNECTION_CLOSED    )



void
AddRef(void)
{
  InterlockedIncrement(&g_lRefCount);
}


void
Release(void)
{
  InterlockedDecrement(&g_lRefCount);

  if( g_lRefCount == 0 )
    SetEvent(g_evtQuit);
}


class Url
{
  public:
    Url(LPSTR host, LPSTR object, USHORT port)
    {
      this->host    = __ansitowide(host);
      this->object  = __ansitowide(object);
      this->port    = port;
      connect       = NULL;
      request       = NULL;
      bytes         = 0L;
      read          = 0L;
      closed        = FALSE;
      buffer        = NULL;
      qda           = FALSE;
      pending       = FALSE;

      InterlockedIncrement(&g_lUrlObjsAlloc);
    }
    
    ~Url()
    {
      if( !HandlesClosed() )
      {
        if( connect )
        {
          WinHttpSetStatusCallback(
            connect,
            NULL,
            CALLBACK_FLAGS,
            NULL
            );
        }

        if( request )
        {
          WinHttpSetStatusCallback(
            request,
            NULL,
            CALLBACK_FLAGS,
            NULL
            );
        }
        
        CloseHandles();
      }

      if( connect )
        Release();

      if( request )
        Release();

      delete [] host;
      delete [] object;

      if( buffer )
        delete [] buffer;

      InterlockedIncrement(&g_lUrlObjsFreed);
    }

  public:
    LPWSTR    Host(void)                        { return host; }
    LPWSTR    Object(void)                      { return object; }
    USHORT    Port(void)                        { return port; }
    void      Connect(HINTERNET hConnect)       { AddRef(); connect = hConnect; }
    void      Request(HINTERNET hRequest)       { AddRef(); request = hRequest; }
    HINTERNET Connect(void)                     { return connect; }
    HINTERNET Request(void)                     { return request; }
    void      Read(DWORD cbData);
    void      CloseHandles(void)                { closed=TRUE; WinHttpCloseHandle(request); WinHttpCloseHandle(connect); }
    BOOL      HandlesClosed(void)               { return closed; }
    BOOL      IsConnect(HINTERNET hInternet)    { return (hInternet == connect); }
    BOOL      IsPending(void)                   { return pending; }

  private:
    LPWSTR    host;
    LPWSTR    object;
    USHORT    port;
    HINTERNET connect;
    HINTERNET request;
    LPBYTE    buffer;
    DWORD     bytes;
    DWORD     read;
    BOOL      qda;
    BOOL      pending;
    BOOL      closed;
};


typedef class Url  URL;
typedef class Url* PURL;


BOOL  Initialize(void);
void  Cleanup(void);
BOOL  NavigateAsync(PURL pUrl);
void  DumpHeaders(PURL pUrl);
DWORD GetContentLength(PURL pUrl);


// main function
BOOL
WinHttp_StressTest()
{
	BOOL  bContinueStress = TRUE;
  BOOL  bContinue       = TRUE;
  BSTR  bsWord          = NULL;
  PURL  pUrl            = NULL;
  CHAR  url[MAX_PATH];

  if( !Initialize() )
  {
    LogText("[tid=%#0.8x] failed to initialize, exiting", GetCurrentThreadId());
    bContinueStress = FALSE;
    goto exit;
  }

  while( bContinue && !IsTimeToExitStress() )
  {
    LogText("[tid=%#0.8x] processing urls...", GetCurrentThreadId());

    for(int n=0; n < 100; n++)
    {
      if( bsWord = g_pDictionary->GetWord() )
      {
        wsprintf(url, "www.%S.com", bsWord);

        if( pUrl = new URL(url, "/", 80) )
          PostQueuedCompletionStatus(g_hIOCP, 0L, (ULONG_PTR) pUrl,  NULL);

        /*
        if( pUrl = new URL(url, "/", 443) )
          PostQueuedCompletionStatus(g_hIOCP, 0L, (ULONG_PTR) pUrl, NULL);
        */

        SysFreeString(bsWord);
      }
      else
      {
        LogText("[tid=%#0.8x] urls exhausted, signaling workers to exit", GetCurrentThreadId());
        //bContinueStress = FALSE; // DEBUGONLY
        bContinue = FALSE;
        break;
      }
    }
    
    WaitForSingleObject(g_evtMoreUrls, 120000);
    LogText("[tid=%#0.8x] url object stats: alloc=%d; freed=%d", GetCurrentThreadId(), g_lUrlObjsAlloc, g_lUrlObjsFreed);
  }

  //
  // post quit messages and wait
  //

  LogText("[tid=%#0.8x] waiting for threads to exit...", GetCurrentThreadId());

  for(int n=0; n < WORKER_THREADS; n++)
  {
    PostQueuedCompletionStatus(g_hIOCP, 0L, CK_QUIT_THREAD, NULL);
  }

  WaitForMultipleObjects(WORKER_THREADS, g_arThreads, TRUE, INFINITE);

  for(int n=0; n < WORKER_THREADS; n++)
  {
    CloseHandle(g_arThreads[n]);
    g_arThreads[n] = NULL;
  }

  while( g_lRefCount > 0 )
  {
    LogText("[tid=%#0.8x] waiting for %d internet handles...", GetCurrentThreadId(), g_lRefCount);
    WaitForSingleObject(g_evtQuit, 5000);
  }

exit:

  Cleanup();

  LogText("[tid=%#0.8x] final url object stats: alloc=%d; freed=%d", GetCurrentThreadId(), g_lUrlObjsAlloc, g_lUrlObjsFreed);

	return bContinueStress;
}


DWORD
WINAPI
WorkerThread(LPVOID pv)
{
  DWORD        bytes = 0L;
  ULONG_PTR    key   = 0L;
  LPOVERLAPPED lpo   = NULL;
  PURL         pUrl  = NULL;
  BOOL         bQuit = FALSE;

  while( !bQuit )
  {
    if( !GetQueuedCompletionStatus(g_hIOCP, &bytes, &key, &lpo, 7000) )
    {
      if( GetLastError() == WAIT_TIMEOUT )
      {
        SetEvent(g_evtMoreUrls);
        continue;
      }
    }
    else
    {
      switch( key )
      {
        case CK_QUIT_THREAD :
          {
            bQuit = TRUE;
          }
          break;

        case NULL :
          {
            LogText("[tid=%#0.8x] ERROR! NULL pUrl dequeued!", GetCurrentThreadId());
          }
          break;

        default :
          {
            pUrl = (PURL) key;
            NavigateAsync(pUrl);
          }
          break;
      }
    }
  }

  LogText("[tid=%#0.8x] exiting", GetCurrentThreadId());
  return 1L;
}


BOOL
NavigateAsync(PURL pUrl)
{
  BOOL      bRet            = FALSE;
  DWORD     dwError         = ERROR_SUCCESS;
  HINTERNET hConnect        = NULL;
  HINTERNET hRequest        = NULL;
  LPCWSTR   arAcceptTypes[] = {L"*/*",L"image/*",L"text/*",NULL};


  //-------------------------------------------------------------------------------------
  // open connect handle
  //-------------------------------------------------------------------------------------
  hConnect = WinHttpConnect(
               g_hSession,
               pUrl->Host(),
               pUrl->Port(),
               0L
               );

    if( hConnect )
    {
      pUrl->Connect(hConnect);
    }
    else
    {
      dwError = GetLastError();

      LogText(
        "[tid=%#0.8x] WinHttpConnect failed for servername %S, error %d [%s]",
        GetCurrentThreadId(),
        pUrl->Host(),
        dwError,
        MapErrorToString(dwError)
        );

      goto quit;
    }


  //-------------------------------------------------------------------------------------
  // set the callback
  //-------------------------------------------------------------------------------------
  WinHttpSetStatusCallback(
    pUrl->Connect(),
    MyStatusCallback,
    CALLBACK_FLAGS,
    NULL
    );


  //-------------------------------------------------------------------------------------
  // open request handle
  //-------------------------------------------------------------------------------------
  hRequest = WinHttpOpenRequest(
               pUrl->Connect(),
               L"GET",
               pUrl->Object(),
               NULL,
               NULL,
               arAcceptTypes,
               ((pUrl->Port() == 80) ? 0L : WINHTTP_FLAG_SECURE)
               );

    if( hRequest )
    {
      pUrl->Request(hRequest);
    }
    else
    {
      dwError = GetLastError();

      LogText(
        "[tid=%#0.8x] WinHttpOpenRequest failed for %S, error %d [%s]",
        GetCurrentThreadId(),
        pUrl->Object(),
        dwError,
        MapErrorToString(dwError)
        );

      goto quit;
    }


  //-------------------------------------------------------------------------------------
  // send the request - this is the first opportunity for a call to go async
  //-------------------------------------------------------------------------------------
  if( !WinHttpSendRequest(pUrl->Request(), NULL, 0L, NULL, 0L, 0L, (DWORD_PTR) pUrl) )
  {
    dwError = GetLastError();

    if( dwError == ERROR_IO_PENDING )
    {
#if 0
      LogText(
        "[tid=%#0.8x; con=%#0.8x; req=%#0.8x] %s://%S%S request went async...",
        GetCurrentThreadId(),
        hConnect,
        hRequest,
        ((pUrl->Port() == 80) ? "http" : "https"),
        pUrl->Host(),
        pUrl->Object()
        );
#endif
    }
    else
    {
      LogText(
        "[tid=%#0.8x; con=%#0.8x; req=%#0.8x] %s://%S%S request failed: %d [%s]!",
        GetCurrentThreadId(),
        hConnect,
        hRequest,
        ((pUrl->Port() == 80) ? "http" : "https"),
        pUrl->Host(),
        pUrl->Object(),
        dwError,
        MapErrorToString(dwError)
        );

      goto quit;
    }
  }
  else
  {
    LogText("[tid=%#0.8x] ERROR! WinHttpSendRequest returned TRUE in async mode!!!", GetCurrentThreadId());
    goto quit;
  }


  //-------------------------------------------------------------------------------------
  // if we get here, we've succeeded in our mission, set exit code to true
  //-------------------------------------------------------------------------------------
  bRet = TRUE;


quit:

  //-------------------------------------------------------------------------------------
  // handle errors and exit
  //-------------------------------------------------------------------------------------
  if( !bRet )
    delete pUrl;

  return bRet;
}



VOID
CALLBACK
MyStatusCallback(
  HINTERNET	hInternet,
  DWORD_PTR dwContext,
  DWORD		  dwInternetStatus,
  LPVOID    lpvStatusInformation,
  DWORD	  	dwStatusInformationLength
  )
{
  PURL pUrl = (PURL) dwContext;

#if 0
  LogText(
    "[tid=%#0.8x; con=%#0.8x; req=%#0.8x] %s://%S%S in %s",
    GetCurrentThreadId(),
    pUrl->Connect(),
    pUrl->Request(),
    ((pUrl->Port() == 80) ? "http" : "https"),
    pUrl->Host(),
    pUrl->Object(),
    MapCallbackToString(dwInternetStatus)
    );
#endif


	switch(dwInternetStatus)
	{
    case WINHTTP_CALLBACK_STATUS_SENDREQUEST_COMPLETE :
      {
        //
        // a WHSR call is completing
        //
        WinHttpReceiveResponse(pUrl->Request(), NULL);
      }
      break;

    case WINHTTP_CALLBACK_STATUS_REDIRECT :
      {
        pUrl->CloseHandles();
      }
      break;

    case WINHTTP_CALLBACK_STATUS_HEADERS_AVAILABLE :
      {
        //
        // a WHRR call is completing
        //
        pUrl->Read(GetContentLength(pUrl));
        //pUrl->Read(0);
      }
      break;

    case WINHTTP_CALLBACK_STATUS_DATA_AVAILABLE :
      {
        //
        // a WHQDA call is completing
        //
        pUrl->Read(dwStatusInformationLength);
      }
      break;

    case WINHTTP_CALLBACK_STATUS_READ_COMPLETE :
      {
        //
        // a WHRD call is completing
        //

#if 0
        DataDump((LPBYTE) lpvStatusInformation, dwStatusInformationLength);
#endif

        pUrl->Read(dwStatusInformationLength);
      }
      break;

    case WINHTTP_CALLBACK_STATUS_CONNECTION_CLOSED :
      {
        if( !pUrl->IsPending() )
        {
          if( !pUrl->HandlesClosed() )
          {
            pUrl->CloseHandles();
          }
        }
      }
      break;

    case WINHTTP_CALLBACK_STATUS_HANDLE_CLOSING :
      {
        //
        // we're done with this particular URL
        //

        if( pUrl->IsConnect(hInternet) )
          delete pUrl;
      }
      break;

    case WINHTTP_CALLBACK_STATUS_REQUEST_ERROR :
      {
#if 0
        WINHTTP_ASYNC_RESULT* pwar = (WINHTTP_ASYNC_RESULT*) lpvStatusInformation;

        LogText(
          "[tid=%#0.8x; hInternet=%#0.8x] async api error: dwResult=%d; dwError=%s",
          GetCurrentThreadId(),
          hInternet,
          pwar->dwResult,
          MapAsyncErrorToString(pwar->dwError)
          );
#endif
        pUrl->CloseHandles();
      }
      break;
  }
}


void
Url::Read(DWORD cbData)
{
  BOOL  bSuccess = FALSE;
  DWORD dwError  = ERROR_SUCCESS;

query_data:

  // if a read is pending, we know that we're handling a READ_COMPLETE callback
  if( !pending )
  {
    // if we haven't recently called WHQDA, do so and handle errors
    if( !qda && !(bytes = cbData) )
    {
      bSuccess = WinHttpQueryDataAvailable(request, &bytes);
      dwError  = GetLastError();

      if( !bSuccess )
      {
        if( dwError != ERROR_IO_PENDING )
        {
          CloseHandles();
        }
        else
        {
          qda = TRUE;
        }
        
        return;
      }
    }

    // we got here, so there must be some data to read, reset the QDA flag and read data.
    qda      = FALSE;
    buffer   = new BYTE[bytes];
    bSuccess = WinHttpReadData(request, (LPVOID) buffer, bytes, &read);
    dwError  = GetLastError();

    if( bSuccess && (read == 0) )
    {
      CloseHandles();
    }
    else
    {
      if( dwError == ERROR_IO_PENDING )
      {
        pending = TRUE;
      }
      else
      {
        CloseHandles();
      }
    }
  }
  else
  {
    // an async read has completed, did we read anything? if not, close handles and return,
    // otherwise free the old buffer and reset our internal state. then, to keep things
    // rolling, loop back up and call WHQDA.
    if( cbData == 0 )
    {
      pending = FALSE;
      CloseHandles();
    }
    else
    {
      delete [] buffer;

      buffer  = NULL;
      bytes   = 0;
      read    = 0;
      cbData  = 0;
      pending = FALSE;

      goto query_data;
    }
  }
}





DWORD
GetContentLength(PURL pUrl)
{
  DWORD dwCL   = 0L;
  DWORD cbData = sizeof(DWORD);

  WinHttpQueryHeaders(
    pUrl->Request(),
    WINHTTP_QUERY_CONTENT_LENGTH + WINHTTP_QUERY_FLAG_NUMBER,
    NULL,
    &dwCL,
    &cbData,
    NULL
    );

  SetLastError(0);

  return dwCL;
}


BOOL
Initialize(void)
{
  BOOL  bRet    = FALSE;
  DWORD dwError = 0L;

  if( FAILED(CoInitializeEx(NULL, COINIT_MULTITHREADED)) )
  {
    LogText("failed to initialize COM");
    goto exit;
  }


  //-------------------------------------------------------------------------------------
  // open dictionary file
  //-------------------------------------------------------------------------------------
  if( !g_pDictionary )
  {    
    g_pDictionary = new XMLDICT(g_szDictPath);

      if( !g_pDictionary )
      {
        goto exit;
      }

      if( g_pDictionary->IsLoaded() )
      {
        LogText("dictionary loaded.");
      }
      else
      {
        goto exit;
      }
  }


  //-------------------------------------------------------------------------------------
  // create completion port
  //-------------------------------------------------------------------------------------
  g_hIOCP = CreateIoCompletionPort(INVALID_HANDLE_VALUE, NULL, 0L, MAX_CONCURRENT);

    if( !g_hIOCP )
    {
      dwError = GetLastError();
      LogText("failed to open completion port, error %d [%s]", dwError, MapErrorToString(dwError));
      goto exit;
    }


  //-------------------------------------------------------------------------------------
  // create worker threads
  //-------------------------------------------------------------------------------------
  for(int n=0; n < WORKER_THREADS; n++)
  {
    g_arThreads[n] = CreateThread(
                       NULL,
                       0L,
                       WorkerThread,
                       NULL,
                       0L,
                       NULL
                       );

    if( !g_arThreads[n] )
    {
      dwError = GetLastError();
      LogText("failed to create thread %d, error %d [%s]", n, dwError, MapErrorToString(dwError));
      goto exit;
    }
  }


  //-------------------------------------------------------------------------------------
  // create 'no more urls' event
  //-------------------------------------------------------------------------------------
  g_evtMoreUrls = CreateEvent(NULL, FALSE, FALSE, NULL);

    if( !g_evtMoreUrls )
    {
      dwError = GetLastError();
      LogText("failed to create url event, error %d [%s]", dwError, MapErrorToString(dwError));
      goto exit;
    }


  //-------------------------------------------------------------------------------------
  // create 'all requests complete' event
  //-------------------------------------------------------------------------------------
  g_evtQuit = CreateEvent(NULL, FALSE, FALSE, NULL);

    if( !g_evtQuit )
    {
      dwError = GetLastError();
      LogText("failed to create quit event, error %d [%s]", dwError, MapErrorToString(dwError));
      goto exit;
    }


  //-------------------------------------------------------------------------------------
  // open shared session handle
  //-------------------------------------------------------------------------------------
  g_hSession = WinHttpOpen(
                 L"foo",
                 WINHTTP_ACCESS_TYPE_NAMED_PROXY,
                 L"itgproxy",
                 L"<local>",
                 WINHTTP_FLAG_ASYNC
                 );

    if( !g_hSession )
    {
      dwError = GetLastError();
      LogText("failed to open winhttp, error %d [%s]", dwError, MapErrorToString(dwError));
      goto exit;
    }


  //-------------------------------------------------------------------------------------
  // set global timeouts
  //-------------------------------------------------------------------------------------
  bRet = WinHttpSetTimeouts(
           g_hSession,
           60000, // resolve
           10000, // connect
           5000,  // send
           5000   // receive
           );

    if( !bRet )
    {
      dwError = GetLastError();
      LogText("failed to set timeouts, error %d [%s]", dwError, MapErrorToString(dwError));
    }

exit:

  return bRet;
}


void
Cleanup(void)
{
  if( g_pDictionary )
  {
    //g_pDictionary->Reset();

    delete g_pDictionary;
    g_pDictionary = NULL;
  }

  if( g_hIOCP != NULL )
  {
    CloseHandle(g_hIOCP);
    g_hIOCP = NULL;
  }

  if( g_evtMoreUrls != NULL )
  {
    CloseHandle(g_evtMoreUrls);
    g_evtMoreUrls = NULL;
  }

  if( g_evtQuit != NULL )
  {
    CloseHandle(g_evtQuit);
    g_evtQuit = NULL;
  }

  if( g_hSession )
  {
    WinHttpCloseHandle(g_hSession);
    g_hSession = NULL;
  }

  CoUninitialize();
}


XMLDict::XMLDict(LPWSTR dictname)
{
  HRESULT      hr       = S_OK;
  BSTR         tag      = NULL;
  VARIANT_BOOL bSuccess = VARIANT_FALSE;
  VARIANT      doc;

  LogText("loading dictionary...");

  hr = CoCreateInstance(
         CLSID_DOMDocument,
         NULL,
         CLSCTX_INPROC_SERVER,
         IID_IXMLDOMDocument,
         (void**) &pDoc
         );

  if( SUCCEEDED(hr) )
  {
    hr = pDoc->put_async(bSuccess);

    VariantInit(&doc);

    V_VT(&doc)   = VT_BSTR;
    V_BSTR(&doc) = SysAllocString(dictname);

    hr = pDoc->load(doc, &bSuccess);

      if( FAILED(hr) || (bSuccess == VARIANT_FALSE) )
      {
        LogText("failed to load xml dictionary");
        goto quit;
      }

    hr = pDoc->get_documentElement(&pRoot);

      if( FAILED(hr) )
      {
        LogText("couldn\'t find root node!");
        goto quit;
      }

    tag = SysAllocString(L"keyphrase");
    hr  = pDoc->getElementsByTagName(tag, &pList);

      if( FAILED(hr) )
      {
        LogText("couldn\'t find any words!");
        goto quit;
      }

    hr = pList->get_length(&lWords);

      if( FAILED(hr) )
      {
        LogText("couldn\'t determine the number of words in the list!");
      }

    szPattern    = SysAllocString(L"string");
    lCurrentWord = 0L;
  }

quit:
  
  VariantClear(&doc);

  if( tag )
  {
    SysFreeString(tag);
  }
}


XMLDict::~XMLDict()
{
  LogText("unloading dictionary...");

  if( szPattern )
  {
    SysFreeString(szPattern);
  }

  if( pList )
  {
    pList->Release();
  }

  if( pRoot )
  {
    pRoot->Release();
  }

  if( pDoc )
  {
    pDoc->Release();
  }
}


BOOL
XMLDict::IsLoaded(void)
{
  LONG state = 0L;

  if( pDoc )
  {
    pDoc->get_readyState(&state);
  }
  else
  {
    return state;
  }

  return (state == 4);
}


BSTR
XMLDict::GetWord(void)
{
  HRESULT      hr     = S_OK;
  IXMLDOMNode* pEntry = NULL; 
  IXMLDOMNode* pWord  = NULL; 
  BSTR         bsWord = NULL;

do_over:

  hr = pList->get_item(lCurrentWord, &pEntry);

    if( FAILED(hr) || !pEntry )
      goto quit;

  ++lCurrentWord;

  hr = pEntry->selectSingleNode(szPattern, &pWord);

    if( FAILED(hr) || !pWord )
      goto quit;

  hr = pWord->get_text(&bsWord);

    if( FAILED(hr) )
      goto quit;

  // some of the words in the dictionary have apostrophes. urls can't have
  // apostrophes, so we strip them out.
  if( wcschr(bsWord, L'\'') )
  {
    SysFreeString(bsWord);
    bsWord = NULL;
    pEntry->Release();
    pWord->Release();
    goto do_over;
  }

quit:

  if( pEntry )
    pEntry->Release();

  if( pWord )
    pWord->Release();

  return bsWord;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\tools\stress\stressapps\asyncwebcrawler\crawler.h ===
// crawler test app header file
#include "stressMain.h"
#include <msxml.h>
#include <oleauto.h>

#define CASE_OF(constant) case constant: return # constant

#define WORKER_THREADS 4
#define MAX_CONCURRENT 4
#define CK_QUIT_THREAD 0xFFFFFFFF

CHAR*  __widetoansi(const WCHAR* pwsz);
WCHAR* __ansitowide(const char* psz);
int    DataDumpFormat(LPSTR buffer, LPBYTE data, DWORD len);
void   DataDump(LPBYTE data, DWORD len);
LPSTR  MapErrorToString(int error);
LPSTR  MapCallbackToString(DWORD callback);
LPSTR  MapAsyncErrorToString(DWORD error);

VOID CALLBACK MyStatusCallback(
    HINTERNET	hInternet,
    DWORD_PTR		dwContext,
    DWORD		dwInternetStatus,
    LPVOID		lpvStatusInformation,
    DWORD		dwStatusInformationLength
);

class XMLDict
{
  public:
    XMLDict(LPWSTR dictname);
    ~XMLDict();

  public:
    BOOL IsLoaded(void);
    BSTR GetWord(void);
    void Reset(void) { lCurrentWord = 0L; }

  private:
    IXMLDOMDocument* pDoc;
    IXMLDOMElement*  pRoot;
    IXMLDOMNodeList* pList;
    BSTR             szPattern;
    LONG             lWords;
    LONG             lCurrentWord;
};

typedef class XMLDict  XMLDICT;
typedef class XMLDict* PXMLDICT;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\tools\stress\stressapps\asynchttpspost-basicserver_ntlmproxy_sc\asynchttpspost-basicserver_ntlmproxy_sc.cpp ===
//////////////////////////////////////////////////////////////////////
// File:  AsyncHTTPSPost-BasicServer_NTLMProxy_SC.cpp
//
// Copyright (c) 2001 Microsoft Corporation.  All Rights Reserved.
//
// Purpose:
//		This file contains your implementation of the stress test function
//		WinHttp_StressTest() that is called in stressMain.cpp.
//
//		Steps:
//			- Set your test case name in g_szStressTestName.
//			- Add your test code to WinHttp_StressTest(). 
//
// History:
//	04/02/01	adamb	Created
//
//////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////
// Includes
//////////////////////////////////////////////////////////////////////
#include "stressMain.h"

//////////////////////////////////////////////////////////////////////
// Globals and constants
//////////////////////////////////////////////////////////////////////

// ************************************
// ************************************
// ** Fill in your test case name below
// ** 
LPSTR	g_szStressTestName = "Basic auth to https over NTLM auth proxy tunnel, set creds using WinHttpSetCredentials, Asynchronous";

VOID CALLBACK MyStatusCallback(
    HINTERNET	hInternet,
    DWORD		dwContext,
    DWORD		dwInternetStatus,
    LPVOID		lpvStatusInformation,
    DWORD		dwStatusInformationLength
);

DWORD g_dwContext = 0;
HINTERNET hOpen = NULL;
HINTERNET hConnect = NULL;
HINTERNET hRequest = NULL;

BOOL WinHttp_StressTest(void);

//post stuff
LPSTR	pPostData = NULL;
DWORD	dwPostDataLength = 0;

//WinHttpSetStatusCallback
WINHTTP_STATUS_CALLBACK iscCallback; 	

//WinHttpReadData
DWORD dwSize = 0, dwDownloaded=0, nCounter;
LPSTR lpszData;

DWORD	Count = 0, dwAccessType = WINHTTP_ACCESS_TYPE_NO_PROXY,
		dwAuthScheme=0,dwAuthTargets=0,dwOtherScheme=0,dwOpenRequestFlags=0,
		dwStatus=0, cbStatus=0;

LPWSTR	wszHost=NULL, wszUri=NULL, wszUserName=NULL, wszPassword=NULL,
		wszProxy = NULL, wszProxyUserName = NULL, wszProxyPassword = NULL,
		wszVerb=L"GET";

INTERNET_PORT	nPort = INTERNET_DEFAULT_HTTP_PORT;

////////////////////////////////////////////////////////////
// Function:  MyStatusCallback(HINTERNET, DWORD, DWORD, LPVOID, DWORD)
//
// Purpose:
//		Status callback proc for WinHttp.
//
////////////////////////////////////////////////////////////
VOID CALLBACK MyStatusCallback(
    HINTERNET	hInternet,
    DWORD		dwContext,
    DWORD		dwInternetStatus,
    LPVOID		lpvStatusInformation,
    DWORD		dwStatusInformationLength
)
{
	switch(dwInternetStatus)
	{
		case WINHTTP_CALLBACK_STATUS_RESOLVING_NAME:
			LogText("\t[ WINHTTP_CALLBACK_STATUS_RESOLVING_NAME ]");
			break;
		case WINHTTP_CALLBACK_STATUS_NAME_RESOLVED:	
			LogText("\t[ WINHTTP_CALLBACK_STATUS_NAME_RESOLVED ]");
			break;
		case WINHTTP_CALLBACK_STATUS_CONNECTING_TO_SERVER:
			LogText("\t[ WINHTTP_CALLBACK_STATUS_CONNECTING_TO_SERVER ]");
			break;
		case WINHTTP_CALLBACK_STATUS_CONNECTED_TO_SERVER:
			LogText("\t[ WINHTTP_CALLBACK_STATUS_CONNECTED_TO_SERVER ]");
			break;
		case WINHTTP_CALLBACK_STATUS_SENDING_REQUEST:
			LogText("\t[ WINHTTP_CALLBACK_STATUS_SENDING_REQUEST ]");
			break;
		case WINHTTP_CALLBACK_STATUS_REQUEST_SENT:
			LogText("\t[ WINHTTP_CALLBACK_STATUS_REQUEST_SENT ]");
			break;
		case WINHTTP_CALLBACK_STATUS_RECEIVING_RESPONSE:
			LogText("\t[ WINHTTP_CALLBACK_STATUS_RECEIVING_RESPONSE ]");
			break;
		case WINHTTP_CALLBACK_STATUS_RESPONSE_RECEIVED:	
			LogText("\t[ WINHTTP_CALLBACK_STATUS_RESPONSE_RECEIVED ]");
			break;
		case WINHTTP_CALLBACK_STATUS_CLOSING_CONNECTION:
			LogText("\t[ WINHTTP_CALLBACK_STATUS_CLOSING_CONNECTION ]");
			break;
		case WINHTTP_CALLBACK_STATUS_CONNECTION_CLOSED:	
			LogText("\t[ WINHTTP_CALLBACK_STATUS_CONNECTION_CLOSED ]");
			break;
		case WINHTTP_CALLBACK_STATUS_HANDLE_CREATED:
			LogText("\t[ WINHTTP_CALLBACK_STATUS_HANDLE_CREATED ]");
			break;
		case WINHTTP_CALLBACK_STATUS_HANDLE_CLOSING:
			LogText("\t[ WINHTTP_CALLBACK_STATUS_HANDLE_CLOSING ]");
			break;
		case WINHTTP_CALLBACK_STATUS_DETECTING_PROXY:
			LogText("\t[ WINHTTP_CALLBACK_STATUS_DETECTING_PROXY ]");
			break;
		case WINHTTP_CALLBACK_STATUS_REDIRECT:
			LogText("\t[ WINHTTP_CALLBACK_STATUS_REDIRECT ]");
			break;
		case WINHTTP_CALLBACK_STATUS_INTERMEDIATE_RESPONSE:
			LogText("\t[ WINHTTP_CALLBACK_STATUS_INTERMEDIATE_RESPONSE ]");
			break;
		case WINHTTP_CALLBACK_STATUS_REQUEST_COMPLETE:
			LogText("\t[ WINHTTP_CALLBACK_STATUS_REQUEST_COMPLETE ]");
			break;
		default:
			LogText("\t[ INVALID status callack %u ]", dwInternetStatus);
			break;
	}
}


////////////////////////////////////////////////////////////
// Function:  WinHttp_StressTest()
//
// Purpose:
////////////////////////////////////////////////////////////

BOOL
WinHttp_StressTest()
{
	BOOL bContinueStress = TRUE;

	wszVerb=L"POST";
	pPostData = "If you smelllllllll what THE ROCK is cooking??? <people's eyebrow>";
	dwPostDataLength = strlen(pPostData);

	nPort = INTERNET_DEFAULT_HTTPS_PORT;
	dwOpenRequestFlags = WINHTTP_FLAG_SECURE;

	wszProxy = L"xfluke";
	wszProxyUserName = L"xfluke\\proxyuser";
	wszProxyPassword = L"password";
	dwAccessType = WINHTTP_ACCESS_TYPE_NAMED_PROXY;


	//using this you can specify setcredentials or setoption for setting creds
	//also, 0->3 for the switch specifies which auth scheme to use
	LPSTR CredType = "SC";

	switch(0)
	{
	case 0: //basic
		wszHost = L"wiredbvt";
		wszUri = L"/api/Auth/Basic/echo-post-data.asp";
		wszUserName = L"ApiAuth";
		wszPassword = L"test1234!";
		break;
	case 1: //digest
		wszHost = L"kerby2";
		wszUri = L"/digest/echo-post-data.asp";
		wszUserName = L"authdigest";
		wszPassword = L"digest";
		break;
	case 2: //negotiate
		wszHost = L"kerby2";
		wszUri = L"/ie/negotiate/echo-post-data.asp";
		wszUserName = L"kerby2\\authnego";
		wszPassword = L"nego";
		break;
	case 3: //ntlm
		wszHost = L"clapton";
		wszUri = L"/test/ntlm/echo-post-data.asp";
		wszUserName = L"clapton\\ntlmtest";
		wszPassword = L"ntlm";
		break;
	}

	// ***********************************
	// ** WinHttpOpen
	// **

	LogText("WinHttpOpen: calling.");
	hOpen = WinHttpOpen
	(
		L"Stress Test",
		dwAccessType,
		wszProxy,
		NULL,
		WINHTTP_FLAG_ASYNC
	);

	if(hOpen == NULL)
	{
		LogText("WinHttpOpen failed with error %u.", GetLastError());
		goto Exit;
	}
	else
		LogText("WinHttpOpen: called.");

	iscCallback = WinHttpSetStatusCallback(
		hOpen,
		(WINHTTP_STATUS_CALLBACK)MyStatusCallback,
		WINHTTP_CALLBACK_FLAG_ALL_NOTIFICATIONS,
		NULL);

	// ***********************************
	// ** WinHttpConnect
	// **
	
	LogText("WinHttpConnect: calling.");	
	hConnect = WinHttpConnect
	(
		hOpen,
		wszHost,
		nPort,
		0
	);

	if(hConnect==NULL)
	{
		LogText("WinHttpConnect failed with error %u.", GetLastError());
		goto Exit;
	}
	else
		LogText("WinHttpConnect: called.");

	LogText("WinHttpOpenRequest: calling.");
	hRequest = WinHttpOpenRequest
	(
		hConnect,
		wszVerb,
		wszUri,
		NULL,
		NULL,
		NULL,
		dwOpenRequestFlags
	);

	if(hRequest==NULL)
	{
		LogText("WinHttpOpenRequest failed with error %u.", GetLastError());
		goto Exit;
	}
	else
		LogText("WinHttpOpenRequest: called.");


Resend:
/*
	if( Count++>10) // making sure that we don't have infinite looping
	{
		bContinueStress=FALSE;
		goto Exit;
	}
*/
	LogText("WinHttpSendRequest: calling.");
	// Send request.
	if(!WinHttpSendRequest
	(
		hRequest,					// request handle
		NULL,						// header string
		0,							// header length
		(PVOID) pPostData,			// post data
		dwPostDataLength,			// post data length
		dwPostDataLength*2,			// total post length
		g_dwContext					// flags
	))
	{
		LogText("WinHttpSendRequest failed with error %u.", GetLastError());
		if ( GetLastError() != ERROR_IO_PENDING )
			goto Exit;
	}
	else
		LogText("WinHttpSendRequest: called.");

	LogText("WinHttpReceiveResponse: calling.");
	if (!WinHttpReceiveResponse(hRequest, NULL))
	{
		LogText("WinHttpReceiveResponse failed with error %u.", GetLastError());
		if ( GetLastError() != ERROR_IO_PENDING )
			goto Exit;
	}
	else
	{
		LogText("WinHttpReceiveResponse: called.");
	}

	do
	{
try_again:
		LogText("WinHttpQueryDataAvailable: calling.");
		if (!WinHttpQueryDataAvailable(hRequest,&dwSize))
		{
			if (GetLastError()== ERROR_IO_PENDING)
			{
				nCounter = 0;
				
				while(GetLastError()==ERROR_IO_PENDING)
				{
					if (nCounter++==2000)
						break;
					LogText("WinHttpQueryDataAvailable: calling.");
					WinHttpQueryDataAvailable(hRequest,&dwSize);
					LogText("WinHttpQueryDataAvailable: called.");
				}
				goto try_again;
			}
			else
			{
				LogText("WinHttpQueryDataAvailable failed with error %u.", GetLastError());
				goto Exit;
			}
		}
		else
		{
			LogText("WinHttpQueryDataAvailable: called.");
			// Allocates a buffer of the size returned by WinHttpQueryDataAvailable
			lpszData = new char[dwSize+1];

			// Reads the data from the handle.
			LogText("WinHttpReadData: calling.");
			if(!WinHttpReadData(hRequest,(LPVOID)lpszData,dwSize,&dwDownloaded))
			{
				if (GetLastError()== ERROR_IO_PENDING)
				{
					nCounter = 0;
					
					while(GetLastError()==ERROR_IO_PENDING)
					{
						if (nCounter++==2000)
						{
							delete[] lpszData;
							break;
						}
						else
						{
							LogText("WinHttpReadData: calling.");
							WinHttpReadData(hRequest,(LPVOID)lpszData,dwSize,&dwDownloaded);
							LogText("WinHttpReadData: called.");
						}
					}
					goto keep_going;
				}
				else
				{
					LogText("WinHttpReadData failed with error %u.", GetLastError());
					delete[] lpszData;
					goto Exit;
				}	
			}
			else
			{
				LogText("WinHttpReadData: called.");
keep_going:
				delete[] lpszData;

				// Check the size of the remaining data.  If it is zero, break.
				if (dwDownloaded == 0)
					break;
			}
		}
	}while(1);

	LogText("WinHttpQueryHeaders: calling.");
	cbStatus = sizeof(dwStatus);
	if(!WinHttpQueryHeaders
	(
		hRequest,
		WINHTTP_QUERY_FLAG_NUMBER | WINHTTP_QUERY_STATUS_CODE,
		NULL,
		&dwStatus,
		&cbStatus,
		NULL
	))
		LogText("WinHttpQueryHeaders failed with error %u.", GetLastError());
	else
		LogText("WinHttpQueryHeaders: called.");

	switch( dwStatus )
	{
	case 200:
		LogText("Status = 200");
		break;
	case 401:
		LogText("Status = 401");
		if(strcmp(CredType, "SC"))
		{
			LogText("WinHttpQueryAuthSchemes: calling.");
			if(!WinHttpQueryAuthSchemes
			(
				hRequest,
				&dwOtherScheme,
				&dwAuthScheme,
				&dwAuthTargets
			))
			{
				LogText("WinHttpQueryAuthSchemes failed with error %u.", GetLastError());
				goto Exit;
			}
			else
				LogText("WinHttpQueryAuthSchemes: called.");

			LogText("WinHttpSetCredentials: calling.");
			if(!WinHttpSetCredentials
			(
				hRequest,
				dwAuthTargets,
				dwAuthScheme,
				wszUserName,
				wszPassword,
				(PVOID) NULL
			))
			{
				LogText("WinHttpSetCredentials failed with error %u.", GetLastError());
				goto Exit;
			}
			else
				LogText("WinHttpSetCredentials: called.");
		}
		else
		{
			LogText("WinHttpSetOption: calling.");
			if(!WinHttpSetOption
			(
				hRequest,
				WINHTTP_OPTION_USERNAME,
				(PVOID) wszUserName,
				wcslen(wszUserName)
			))
			{
				LogText("WinHttpSetOption failed with error %u.", GetLastError());
				goto Exit;
			}
			else
				LogText("WinHttpSetOption: called.");

			LogText("WinHttpSetOption: calling.");
			if(!WinHttpSetOption
			(
				hRequest,
				WINHTTP_OPTION_PASSWORD,
				(PVOID) wszPassword,
				wcslen(wszPassword)
			))
			{
				LogText("WinHttpSetOption failed with error %u.", GetLastError());
				goto Exit;
			}
			else
				LogText("WinHttpSetOption: called.");
		}
		goto Resend;
	break;

	case 407:
		LogText("Status = 407");
		if(strcmp(CredType, "SC"))
		{
			LogText("WinHttpQueryAuthSchemes: calling.");
			if(!WinHttpQueryAuthSchemes
			(
				hRequest,
				&dwOtherScheme,
				&dwAuthScheme,
				&dwAuthTargets
			))
			{
				LogText("WinHttpQueryAuthSchemes failed with error %u.", GetLastError());
				goto Exit;
			}
			else
				LogText("WinHttpQueryAuthSchemes: called.");

			LogText("WinHttpSetCredentials: calling.");
			if(!WinHttpSetCredentials
			(
				hRequest,
				dwAuthTargets,
				dwAuthScheme,
				wszProxyUserName,
				wszProxyPassword,
				(PVOID) NULL
			))
			{
				LogText("WinHttpSetCredentials failed with error %u.", GetLastError());
				goto Exit;
			}
			else
				LogText("WinHttpSetCredentials: called.");
		}
		else
		{
			LogText("WinHttpSetOption: calling.");
			if(!WinHttpSetOption
			(
				hRequest,
				WINHTTP_OPTION_PROXY_USERNAME,
				(PVOID) wszProxyUserName,
				wcslen(wszProxyUserName)
			))
			{
				LogText("WinHttpSetOption failed with error %u.", GetLastError());
				goto Exit;
			}
			else
				LogText("WinHttpSetOption: called.");

			LogText("WinHttpSetOption: calling.");
			if(!WinHttpSetOption
			(
				hRequest,
				WINHTTP_OPTION_PROXY_PASSWORD,
				(PVOID) wszProxyPassword,
				wcslen(wszProxyPassword)
			))
			{
				LogText("WinHttpSetOption failed with error %u.", GetLastError());
				goto Exit;
			}
			else
				LogText("WinHttpSetOption: called.");
		}

		goto Resend;
	default:
		LogText("Status = %u", dwStatus);
	break;

	} //end of switch (status code)

Exit:

	if( hRequest != NULL )
	{
		WinHttpCloseHandle(hRequest);
		hRequest = NULL;
	}

	if( hConnect != NULL )
	{
		WinHttpCloseHandle(hConnect);
		hConnect = NULL;
	}

	if( hOpen != NULL )
	{
		WinHttpCloseHandle(hOpen);
		hOpen = NULL;
	}


	return bContinueStress;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\tools\stress\stressapps\core\stressmain.h ===
//////////////////////////////////////////////////////////////////////
// File:  stressMain.h
//
// Copyright (c) 2001 Microsoft Corporation.  All Rights Reserved.
//
// Purpose:
//		This is an empty template for WinHttp stressScheduler stress apps.
//		The stress test lives in WinHttp_StressTest() and will be called
//		repeatedly in the main function.
//
// History:
//	03/30/01	DennisCh	Created
//
//////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////
// Constants
//////////////////////////////////////////////////////////////////////

#define	EXIT_PROCESS_EVENT_NAME	"ExitProcessEvent"
#define WIN32_LEAN_AND_MEAN 1


//////////////////////////////////////////////////////////////////////
// Includes
//////////////////////////////////////////////////////////////////////

// Win32 headers
#include <windows.h>
#include <winhttp.h>
#include <shlwapi.h>
#include <stdlib.h>
#include <stdio.h>
#include <process.h>


//////////////////////////////////////////////////////////////////////
// Globals
//////////////////////////////////////////////////////////////////////
extern BOOL	IsTimeToExitStress();
extern VOID	LogText(LPCSTR,	...);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\tools\stress\stressapps\core\stressmain.cpp ===
//////////////////////////////////////////////////////////////////////
// File:  stressMain.cpp
//
// Copyright (c) 2001 Microsoft Corporation.  All Rights Reserved.
//
// Purpose:
//		This is an empty template for WinHttp stressScheduler stress apps.
//		The stress test lives in WinHttp_StressTest() and will be called
//		repeatedly in the main function.
//
//		This process will inherit a named event handle from 
//		stressScheduler in the form: "ExitProcessEvent" + <PID of this process>.
//		When the stressScheduler sets the object state to signaled, then
//		the stress test application must exit immediately.
//
//		If this app is running without the stressScheduler, use the
//		"/s" switch to run the standalone mode. The app will exit when the user
//		sends a break message (CTRL-C).
//
//		This stress test will continue to run if:
//
//			When not using any switches:
//			- The "ExitProcessEvent" object inherited from stressScheduler is in the un-signaled state
//			- WinHttp_StressTest() returns true
//
//			When using the "/s" standalone switch:
//			- WinHttp_StressTest() returns true
//
// History:
//	03/30/01	DennisCh	Created
//
//////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////
// Includes
//////////////////////////////////////////////////////////////////////

// Project headers
#include "stressMain.h"


//////////////////////////////////////////////////////////////////////
// Globals and statics
//////////////////////////////////////////////////////////////////////

// ****************************
// ** The name of the stress test and your stress test function
// ** should be declared in a seperate file.
extern	LPSTR	g_szStressTestName;
extern	BOOL	WinHttp_StressTest();

// ****************************
// ** hande to the name exit event object inherited from the stressScheduler
HANDLE	g_hExitEvent		= NULL;

// ****************************
// ** FALSE = run with stressScheduler, TRUE = run without stressScheduler
BOOL	g_bStandAloneMode	= FALSE;


////////////////////////////////////////////////////////////
// Function:  LogText(DWORD, LPCSTR)
//
// Purpose:
//	Prints text.
//
////////////////////////////////////////////////////////////
VOID
LogText(
	LPCSTR	szLogText,
	...
)
{
    CHAR	szBuffer[1024] = {0};
    va_list	vaList;

	if (!szLogText)
		return;

    va_start( vaList, szLogText );
    _vsnprintf( szBuffer, sizeof(szBuffer), szLogText, vaList );

    printf("%s\n", szBuffer);

    va_end(vaList);
}


////////////////////////////////////////////////////////////
// Function:  GetExitEventHandle()
//
// Purpose:
//	This opens a named event object inherited from the stressScheduler.
//	The object is in the form: "ExitProcessEvent" + <PID of current process>
//	By default this is in the unsignaled state. When the stressScheduler
//	sets it to signaled, then it's time for the stress App to exit.
//
////////////////////////////////////////////////////////////
HANDLE
GetExitEventHandle()
{
	CHAR	szPID[32];
	CHAR	szExitProcessName[sizeof(EXIT_PROCESS_EVENT_NAME) + sizeof(szPID)];
	HANDLE	hExitEvent			= NULL;

	// if user used the "/S" switch, we run without the stressScheduler and exit when user
	// tells us to instead. No need to get inherited event object from stressScheduler
	if (g_bStandAloneMode)
		return NULL;

	// wait for the stressScheduler to create the event object before trying to obtain it.
	Sleep(4000);

	// Get the processID string
	_itoa(_getpid(), szPID, 10);

	// build ExitProcess event object name
	ZeroMemory(szExitProcessName, sizeof(szExitProcessName));
	strcpy(szExitProcessName, EXIT_PROCESS_EVENT_NAME);
	strcat(szExitProcessName, szPID);

	LogText("\n[ Opening inherited named event object \"%s\". ]", szExitProcessName);

	hExitEvent = OpenEvent(EVENT_ALL_ACCESS, FALSE, szExitProcessName);

	if (!hExitEvent)
		LogText("[ ERROR: OpenEvent() failed to open object \"%s\". GetLastError() = %u ]\n", szExitProcessName, GetLastError());
	else
		LogText("[ OpenEvent() opened object \"%s\". ] \n", szExitProcessName);

	return hExitEvent;
}


////////////////////////////////////////////////////////////
// Function:  IsTimeToExitStress()
//
// Purpose:
//	Returns TRUE if the exit event object is signaled or NULL. FALSE if not.
//	The object is in the form: "ExitProcessEvent" + <PID of current process>
//	By default this is in the unsignaled state. When the stressScheduler
//	sets it to signaled, then it's time for the stress App to exit.
//
////////////////////////////////////////////////////////////
BOOL
IsTimeToExitStress()
{
	BOOL bResult = FALSE;

	// if user used the "/S" switch, we run without the stressScheduler and exit when user
	// tells us to instead.
	if (g_bStandAloneMode)
		return FALSE;

	if (!g_hExitEvent)
	{
		bResult = TRUE;
		goto Exit;
	}

	if (WAIT_OBJECT_0 == WaitForSingleObject(g_hExitEvent, 0))
		bResult = TRUE;

Exit:
	return bResult;
}


////////////////////////////////////////////////////////////
// Function:  main(INT, LPSTR)
//
// Purpose:
//	Program entry point.
//
////////////////////////////////////////////////////////////
INT
__cdecl
main(
	INT		argc,
	LPSTR	argv[]
)
{
	DWORD	dwIndex		= 0;

	// **************************
	// **************************
	// ** Parse command line arguments
	// **
    if (argc >= 2)
    {
		// print out options
		if (0 == StrCmpI(argv[1], "/?") || 0 == StrCmpI(argv[1], "-?"))
		{
	        LogText("USAGE: '/S' to run in standalone mode with the stressScheduler.\n\n");
		    goto Exit;
		}

		// run in standalone mode without stressScheduler
		if (0 == StrCmpI(argv[1], "/S") || 0 == StrCmpI(argv[1], "-S"))
		{
			LogText("[ Running in standalone mode. \"/S\" switch used. ]\n\n");
			g_bStandAloneMode = TRUE;
		}
    }


	// **************************
	// **************************
	// ** open the exit event object inherited from WinHttpStressScheduler
	// **
	g_hExitEvent	= GetExitEventHandle();
	if (!g_bStandAloneMode && !g_hExitEvent)
		goto Exit;


	// **************************
	// **************************
	// ** run the stress test until stressScheduler tells us to exit or the stress app does
	// **
	while (!IsTimeToExitStress() && WinHttp_StressTest())
		LogText("[ Running stressExe \"%s\" iteration #%u ]\n", g_szStressTestName, ++dwIndex);

Exit:
	if (g_hExitEvent)
		CloseHandle(g_hExitEvent);

	LogText("[ Exiting test case \"%s\" ]", g_szStressTestName);

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\tools\stress\stressscheduler\res\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by resource.rc
//
#define IDI_MAIN_ICON                   101
#define IDR_POPUPMENU                   107
#define IDM_BEGIN_STRESS                40007
#define IDM_END_STRESS                  40008
#define IDM_EXIT                        40009
#define IDM_OPENSTRESSADMIN             40012
#define IDM_WINHTTP_HOME                40014

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        120
#define _APS_NEXT_COMMAND_VALUE         40015
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\tools\stress\stressscheduler\src\memstats.h ===
///////////////////////////////////////////////////////////////////////////
// File:  MemStats.h
//
// Copyright (c) 2001 Microsoft Corporation.  All Rights Reserved.
//
// Purpose:
//	MemStats.h: Helper functions that get's the system memory info.
//	Borrowed from EricI's memstats app.
//
// History:
//	03/21/01	DennisCh	Created
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_MEMSTATS_H__D91043CB_5CB3_47C9_944F_B9FAA9BD26C4__INCLUDED_)
#define AFX_MEMSTATS_H__D91043CB_5CB3_47C9_944F_B9FAA9BD26C4__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000


//////////////////////////////////////////////////////////////////////
// Includes
//////////////////////////////////////////////////////////////////////

#define UNICODE
#define _UNICODE

//
// WIN32 headers
//
#include <windows.h>
#include <pdh.h>
#include <shlwapi.h>

//
// Project headers
//
#include "WinHttpStressScheduler.h"
#include "ServerCommands.h"


//////////////////////////////////////////////////////////////////////
// Constants
//////////////////////////////////////////////////////////////////////


// struct for process memory stats
#define PROCCOUNTERS    4
struct PROC_CNTRS {
	ULONG lPID;
	ULONG lPrivBytes;
	ULONG lHandles;
	ULONG lThreads;
};

// struct for system wide memory stats
#define MEMCOUNTERS     9
struct MEM_CNTRS {
    ULONG lCommittedBytes;
    ULONG lCommitLimit;
    ULONG lSystemCodeTotalBytes;
    ULONG lSystemDriverTotalBytes;
    ULONG lPoolNonpagedBytes;
    ULONG lPoolPagedBytes;
    ULONG lAvailableBytes;
    ULONG lCacheBytes;
    ULONG lFreeSystemPageTableEntries;
};


BOOL MemStats__SendSystemMemoryLog(LPSTR, DWORD, DWORD);


#endif // !defined(AFX_MEMSTATS_H__D91043CB_5CB3_47C9_944F_B9FAA9BD26C4__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\tools\stress\stressapps\sync-http-get-random\stresstesttemplate.cpp ===
//////////////////////////////////////////////////////////////////////
// File:  stressTest.cpp
//
// Copyright (c) 2001 Microsoft Corporation.  All Rights Reserved.
//
// Purpose:
//		Synchronous HTTP GET to http://nithins_bld/stability/random/default.asp
//		that redirects to a random internet URL.
//
// History:
//	04/06/01	DennisCh	Created
//
//////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////
// Includes
//////////////////////////////////////////////////////////////////////
#include "stressMain.h"


//////////////////////////////////////////////////////////////////////
// Globals and constants
//////////////////////////////////////////////////////////////////////

// ************************************
// ************************************
// ** Fill in your test case name below
// ** 
LPSTR	g_szStressTestName = "Synchronous HTTP GET to http://nithins_bld/stability/random/default.asp that redirects to a random internet URL.";


// Foward function definitions
VOID CALLBACK MyStatusCallback(
    HINTERNET	hInternet,
    DWORD		dwContext,
    DWORD		dwInternetStatus,
    LPVOID		lpvStatusInformation,
    DWORD		dwStatusInformationLength
);

DWORD g_dwContext = 0;
////////////////////////////////////////////////////////////
// Function:  WinHttp_StressTest()
//
// Purpose:
//	The stress test function. Insert your test code here.
//	Returning TRUE will cause main() to call this function again.
//	Otherwise, returning FALSE will cause the app to exit.
//
//	If you plan to loop within this function, be sure to 
//	use IsTimeToExitStress() as one of your exit conditions.
//
//	This must be done because the stressScheduler will notify
//	a this stress app when to exit based on the state of the
//	inherited event object that IsTimeToExitStress() checks for.
//	IsTimeToExitStress() will return TRUE when it's time to exit.
//
////////////////////////////////////////////////////////////
BOOL
WinHttp_StressTest()
{
	BOOL		bContinueStress = TRUE;
	HINTERNET	hOpen			= NULL;
	HINTERNET	hConnect		= NULL;
	HINTERNET	hRequest		= NULL;


	// ***********************
	// ** WinHttpOpen
	hOpen = WinHttpOpen(
		L"StressTest",
		WINHTTP_ACCESS_TYPE_NAMED_PROXY,
		L"itgproxy",
		L"<local>",
		0);

	if (!hOpen)
	{
		LogText("WinHttpOpen failed with error %u.", GetLastError());
		goto Exit;
	}


	// ***********************
	// ** WinHttpConnect
	hConnect = WinHttpConnect(
		hOpen,
		L"nithins_bld",
		INTERNET_DEFAULT_HTTP_PORT,
		0);

	if (!hConnect)
	{
		LogText("WinHttpConnect failed with error %u.", GetLastError());
		goto Exit;
	}
		

	// ***********************
	// ** WinHttpOpenRequest
	hRequest = WinHttpOpenRequest(
		hConnect,
		L"GET",
		L"/stability/random/default.asp",
		NULL,
		NULL,
		NULL,
		0);


	if (!hRequest)
	{
		LogText("WinHttpOpenRequest failed with error %u.", GetLastError());
		goto Exit;
	}


	DWORD dwContext, dwDataAvailable;

	// ***********************
	// ** WinHttpSendRequest
	dwContext		= 0;
	dwDataAvailable	= 0;

	if (!WinHttpSendRequest(hRequest, NULL, 0, NULL, 0, 0, g_dwContext++))
		LogText("WinHttpSendRequest failed with error %u", GetLastError());

	// ***********************
	// ** WinHttpReceiveResponse
	if (!WinHttpReceiveResponse(hRequest, NULL))
		LogText("WinHttpReceiveResponse failed with error %u", GetLastError());

	// ***********************
	// ** WinHttpQueryDataAvailable
	if (!WinHttpQueryDataAvailable(hRequest, &dwDataAvailable))
		LogText("WinHttpQueryDataAvailable failed with error %u", GetLastError());


	WCHAR	szBuffer[1024];
	DWORD	dwStatus, dwBytesRead, dwBytesTotal, dwBufferLength, dwIndex;

	// ***********************
	// ** WinHttpQueryOption
	dwBufferLength	= sizeof(szBuffer)/sizeof(WCHAR) - 1;
	if (!WinHttpQueryOption(hRequest, WINHTTP_OPTION_URL, szBuffer, &dwBufferLength))
		LogText("WinHttpQueryOption failed with error %u", GetLastError());
	else
		wprintf(L"Redirected to: \"%s\"\n", szBuffer);


	// ***********************
	// ** WinHttpQueryHeaders
	dwBufferLength	= sizeof(dwStatus);
	dwStatus		= 0;
	dwIndex			= 0;
	if (!WinHttpQueryHeaders(hRequest, WINHTTP_QUERY_STATUS_CODE | WINHTTP_QUERY_FLAG_NUMBER, NULL, &dwStatus, &dwBufferLength, &dwIndex))
		LogText("WinHttpQueryHeaders failed with error %u", GetLastError());
	else
		LogText("Status = %u", dwStatus);


	// ***********************
	// ** WinHttpReadData
	dwBytesRead		= 0;
	dwBytesTotal	= 0;
	dwBufferLength	= sizeof(szBuffer) - 1;

	while (WinHttpReadData(hRequest, szBuffer, dwBufferLength, &dwBytesRead) && (dwBytesRead != 0))
		dwBytesTotal += dwBytesRead;

	LogText("WinHttpReadData: Got total of %u bytes.\n", dwBytesTotal);

Exit:
	if (hRequest &&	!WinHttpCloseHandle(hRequest))
		LogText("WinHttpCloseHandle(hRequest) failed with error %u", GetLastError());

	if (hConnect && !WinHttpCloseHandle(hConnect))
		LogText("WinHttpCloseHandle(hConnect) failed with error %u", GetLastError());

	if (hOpen && !WinHttpCloseHandle(hOpen))
		LogText("WinHttpCloseHandle failed(hOpen) with error %u", GetLastError());

	return bContinueStress;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\tools\stress\stressapps\asynchttppost-winhttpquerydataavailable\asynchttppost-winhttpquerydataavailable.cpp ===
//////////////////////////////////////////////////////////////////////
// File:  stressTest.cpp
//
// Copyright (c) 2001 Microsoft Corporation.  All Rights Reserved.
//
// Purpose:
//		Sends a HTTP POST request asynchronously and then calls
//		WinHttpReceiveResponse and WinHttpQueryDataAvailable in a loop.
//
// History:
//	04/03/01	DennisCh	Created
//
//////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////
// Includes
//////////////////////////////////////////////////////////////////////
#include "stressMain.h"


//////////////////////////////////////////////////////////////////////
// Globals and constants
//////////////////////////////////////////////////////////////////////

// ************************************
// ************************************
// ** Fill in your test case name below
// ** 
LPSTR	g_szStressTestName = "HTTP POST then calls WinHttpQueryDataAvailable in a loop.";


// Foward function definitions
VOID CALLBACK MyStatusCallback(
    HINTERNET	hInternet,
    DWORD		dwContext,
    DWORD		dwInternetStatus,
    LPVOID		lpvStatusInformation,
    DWORD		dwStatusInformationLength
);


////////////////////////////////////////////////////////////
// Function:  WinHttp_StressTest()
//
// Purpose:
//	The stress test function. Insert your test code here.
//	Returning TRUE will cause main() to call this function again.
//	Otherwise, returning FALSE will cause the app to exit.
//
//	If you plan to loop within this function, be sure to 
//	use IsTimeToExitStress() as one of your exit conditions.
//
//	This must be done because the stressScheduler will notify
//	a this stress app when to exit based on the state of the
//	inherited event object that IsTimeToExitStress() checks for.
//	IsTimeToExitStress() will return TRUE when it's time to exit.
//
////////////////////////////////////////////////////////////
BOOL
WinHttp_StressTest()
{
	BOOL		bContinueStress = TRUE;
	HINTERNET	hOpen			= NULL;
	HINTERNET	hConnect		= NULL;
	HINTERNET	hRequest		= NULL;


	// ***********************
	// ** WinHttpOpen
	hOpen = WinHttpOpen(
		L"StressTest",
		WINHTTP_ACCESS_TYPE_NO_PROXY,
		NULL,
		NULL,
		WINHTTP_FLAG_ASYNC);

	if (!hOpen)
	{
		LogText("WinHttpOpen failed with error %u.", GetLastError());
		goto Exit;
	}


	// ***********************
	// ** WinHttpConnect
	hConnect = WinHttpConnect(
		hOpen,
		L"hairball",
		INTERNET_DEFAULT_HTTP_PORT,
		0);

	if (!hConnect)
	{
		LogText("WinHttpConnect failed with error %u.", GetLastError());
		goto Exit;
	}
		

	// ***********************
	// ** WinHttpOpenRequest
	hRequest = WinHttpOpenRequest(
		hConnect,
		L"GET",
		L"/",
		NULL,
		NULL,
		NULL,
		0);


	if (!hRequest)
	{
		LogText("WinHttpOpenRequest failed with error %u.", GetLastError());
		goto Exit;
	}


	DWORD dwIndex, dwContext, dwDataAvailable;

	// ***********************
	// ** WinHttpSendRequest
	dwContext = 0;
	if (!WinHttpSendRequest(hRequest, NULL, 0, NULL, 0, 0, dwContext))
		LogText("WinHttpSendRequest failed with error %u", GetLastError());


	for (dwIndex=0; (dwIndex < 100000); dwIndex++)
	{
		// ***********************
		// ** WinHttpReceiveResponse
		if (!WinHttpReceiveResponse(hRequest, NULL))
			LogText("WinHttpReceiveResponse failed with error %u", GetLastError());

		// ***********************
		// ** WinHttpQueryDataAvailable
		if (!WinHttpQueryDataAvailable(hRequest, &dwDataAvailable))
			LogText("WinHttpQueryDataAvailable failed with error %u", GetLastError());
	}

Exit:
	if (hOpen && !WinHttpCloseHandle(hOpen))
		LogText("WinHttpCloseHandle failed(hOpen) with error %u", GetLastError());

	if (hConnect && !WinHttpCloseHandle(hConnect))
		LogText("WinHttpCloseHandle(hConnect) failed with error %u", GetLastError());

	if (hRequest &&	!WinHttpCloseHandle(hRequest))
		LogText("WinHttpCloseHandle(hRequest) failed with error %u", GetLastError());

	return bContinueStress;
}


////////////////////////////////////////////////////////////
// Function:  MyStatusCallback(HINTERNET, DWORD, DWORD, LPVOID, DWORD)
//
// Purpose:
//		Status callback proc for WinHttp.
//
////////////////////////////////////////////////////////////
VOID CALLBACK MyStatusCallback(
    HINTERNET	hInternet,
    DWORD		dwContext,
    DWORD		dwInternetStatus,
    LPVOID		lpvStatusInformation,
    DWORD		dwStatusInformationLength
)
{
	switch(dwInternetStatus)
	{
		case WINHTTP_CALLBACK_STATUS_RESOLVING_NAME:
			LogText("\t[ WINHTTP_CALLBACK_STATUS_RESOLVING_NAME ]");
			break;
		case WINHTTP_CALLBACK_STATUS_NAME_RESOLVED:	
			LogText("\t[ WINHTTP_CALLBACK_STATUS_NAME_RESOLVED ]");
			break;
		case WINHTTP_CALLBACK_STATUS_CONNECTING_TO_SERVER:
			LogText("\t[ WINHTTP_CALLBACK_STATUS_CONNECTING_TO_SERVER ]");
			break;
		case WINHTTP_CALLBACK_STATUS_CONNECTED_TO_SERVER:
			LogText("\t[ WINHTTP_CALLBACK_STATUS_CONNECTED_TO_SERVER ]");
			break;
		case WINHTTP_CALLBACK_STATUS_SENDING_REQUEST:	
			LogText("\t[ WINHTTP_CALLBACK_STATUS_SENDING_REQUEST ]");
			break;
		case WINHTTP_CALLBACK_STATUS_REQUEST_SENT:	
			LogText("\t[ WINHTTP_CALLBACK_STATUS_REQUEST_SENT ]");
			break;
		case WINHTTP_CALLBACK_STATUS_RECEIVING_RESPONSE:
			LogText("\t[ WINHTTP_CALLBACK_STATUS_RECEIVING_RESPONSE ]");
			break;
		case WINHTTP_CALLBACK_STATUS_RESPONSE_RECEIVED:	
			LogText("\t[ WINHTTP_CALLBACK_STATUS_RESPONSE_RECEIVED ]");
			break;
		case WINHTTP_CALLBACK_STATUS_CLOSING_CONNECTION:
			LogText("\t[ WINHTTP_CALLBACK_STATUS_CLOSING_CONNECTION ]");
			break;
		case WINHTTP_CALLBACK_STATUS_CONNECTION_CLOSED:	
			LogText("\t[ WINHTTP_CALLBACK_STATUS_CONNECTION_CLOSED ]");
			break;
		case WINHTTP_CALLBACK_STATUS_HANDLE_CREATED:
			LogText("\t[ WINHTTP_CALLBACK_STATUS_HANDLE_CREATED ]");
			break;
		case WINHTTP_CALLBACK_STATUS_HANDLE_CLOSING:
			LogText("\t[ WINHTTP_CALLBACK_STATUS_HANDLE_CLOSING ]");
			break;
		case WINHTTP_CALLBACK_STATUS_DETECTING_PROXY:
			LogText("\t[ WINHTTP_CALLBACK_STATUS_DETECTING_PROXY ]");
			break;
		case WINHTTP_CALLBACK_STATUS_REDIRECT:
			LogText("\t[ WINHTTP_CALLBACK_STATUS_REDIRECT ]");
			break;
		case WINHTTP_CALLBACK_STATUS_INTERMEDIATE_RESPONSE:
			LogText("\t[ WINHTTP_CALLBACK_STATUS_INTERMEDIATE_RESPONSE ]");
			break;
		case WINHTTP_CALLBACK_STATUS_REQUEST_COMPLETE:
			LogText("\t[ WINHTTP_CALLBACK_STATUS_REQUEST_COMPLETE ]");
			break;
		default:
			LogText("\t[ INVALID status callack %u ]", dwInternetStatus);
			break;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\tools\stress\stressscheduler\inc\dbghelp.h ===
/*++ BUILD Version: 0001     Increment this if a change has global effects

Copyright (c) 1990-2000  Microsoft Corporation

Module Name:

    dbghelp.h

Abstract:

    This module defines the prototypes and constants required for the image
    help routines.

    Contains debugging support routines that are redistributable.

Revision History:

--*/

#ifndef _DBGHELP_
#define _DBGHELP_

#if _MSC_VER > 1020
#pragma once
#endif


#ifdef _WIN64
#ifndef _IMAGEHLP64
#define _IMAGEHLP64
#endif
#endif


#ifdef __cplusplus
extern "C" {
#endif

#ifdef _IMAGEHLP_SOURCE_
#define IMAGEAPI __stdcall
#else
#define IMAGEAPI DECLSPEC_IMPORT __stdcall
#endif

#define IMAGE_SEPARATION (64*1024)

typedef struct _LOADED_IMAGE {
    PSTR                  ModuleName;
    HANDLE                hFile;
    PUCHAR                MappedAddress;
#ifdef _IMAGEHLP64
    PIMAGE_NT_HEADERS64   FileHeader;
#else
    PIMAGE_NT_HEADERS32   FileHeader;
#endif
    PIMAGE_SECTION_HEADER LastRvaSection;
    ULONG                 NumberOfSections;
    PIMAGE_SECTION_HEADER Sections;
    ULONG                 Characteristics;
    BOOLEAN               fSystemImage;
    BOOLEAN               fDOSImage;
    LIST_ENTRY            Links;
    ULONG                 SizeOfImage;
} LOADED_IMAGE, *PLOADED_IMAGE;



HANDLE
IMAGEAPI
FindDebugInfoFile (
    PSTR FileName,
    PSTR SymbolPath,
    PSTR DebugFilePath
    );

typedef BOOL
(CALLBACK *PFIND_DEBUG_FILE_CALLBACK)(
    HANDLE FileHandle,
    PSTR FileName,
    PVOID CallerData
    );

HANDLE
IMAGEAPI
FindDebugInfoFileEx (
    PSTR FileName,
    PSTR SymbolPath,
    PSTR DebugFilePath,
    PFIND_DEBUG_FILE_CALLBACK Callback,
    PVOID CallerData
    );

typedef BOOL
(CALLBACK *PFINDFILEINPATHCALLBACK)(
    PSTR  filename,
    PVOID context
    );

BOOL
IMAGEAPI
SymFindFileInPath(
    HANDLE hprocess,
    LPSTR  SearchPath,
    LPSTR  FileName,
    PVOID  id,
    DWORD  two,
    DWORD  three,
    DWORD  flags,
    LPSTR  FilePath,
    PFINDFILEINPATHCALLBACK callback,
    PVOID  context
    );

// FindFileInPath exists only for backwards compatibility
// with a pre-release version documented in an MSDN release.
// You should use SymFindFileInPath if you want to maintain
// future compatibility.

BOOL
IMAGEAPI
FindFileInPath(
    HANDLE hprocess,
    LPSTR  SearchPath,
    LPSTR  FileName,
    PVOID  id,
    DWORD  two,
    DWORD  three,
    DWORD  flags,
    LPSTR  FilePath
    );

BOOL
IMAGEAPI
FindFileInSearchPath(
    HANDLE hprocess,
    LPSTR  SearchPath,
    LPSTR  FileName,
    DWORD  one,
    DWORD  two,
    DWORD  three,
    LPSTR  FilePath
    );

HANDLE
IMAGEAPI
FindExecutableImage(
    PSTR FileName,
    PSTR SymbolPath,
    PSTR ImageFilePath
    );

typedef BOOL
(CALLBACK *PFIND_EXE_FILE_CALLBACK)(
    HANDLE FileHandle,
    PSTR FileName,
    PVOID CallerData
    );

HANDLE
IMAGEAPI
FindExecutableImageEx(
    PSTR FileName,
    PSTR SymbolPath,
    PSTR ImageFilePath,
    PFIND_EXE_FILE_CALLBACK Callback,
    PVOID CallerData
    );

PIMAGE_NT_HEADERS
IMAGEAPI
ImageNtHeader (
    IN PVOID Base
    );

PVOID
IMAGEAPI
ImageDirectoryEntryToDataEx (
    IN PVOID Base,
    IN BOOLEAN MappedAsImage,
    IN USHORT DirectoryEntry,
    OUT PULONG Size,
    OUT PIMAGE_SECTION_HEADER *FoundHeader OPTIONAL
    );

PVOID
IMAGEAPI
ImageDirectoryEntryToData (
    IN PVOID Base,
    IN BOOLEAN MappedAsImage,
    IN USHORT DirectoryEntry,
    OUT PULONG Size
    );

PIMAGE_SECTION_HEADER
IMAGEAPI
ImageRvaToSection(
    IN PIMAGE_NT_HEADERS NtHeaders,
    IN PVOID Base,
    IN ULONG Rva
    );

PVOID
IMAGEAPI
ImageRvaToVa(
    IN PIMAGE_NT_HEADERS NtHeaders,
    IN PVOID Base,
    IN ULONG Rva,
    IN OUT PIMAGE_SECTION_HEADER *LastRvaSection
    );

// Symbol server exports

typedef BOOL (*PSYMBOLSERVERPROC)(LPCSTR, LPCSTR, PVOID, DWORD, DWORD, LPSTR);
typedef BOOL (*PSYMBOLSERVEROPENPROC)(VOID);
typedef BOOL (*PSYMBOLSERVERCLOSEPROC)(VOID);
typedef BOOL (*PSYMBOLSERVERSETOPTIONSPROC)(UINT_PTR, ULONG64);
typedef BOOL (CALLBACK *PSYMBOLSERVERCALLBACKPROC)(UINT_PTR action, ULONG64 data, ULONG64 context);
typedef UINT_PTR (*PSYMBOLSERVERGETOPTIONSPROC)();

#define SSRVOPT_CALLBACK  0x1
#define SSRVOPT_DWORD     0x2
#define SSRVOPT_DWORDPTR  0x4
#define SSRVOPT_GUIDPTR   0x8
#define SSRVOPT_RESET    ((ULONG_PTR)-1)

#define SSRVACTION_TRACE 1


#ifndef _WIN64
// This api won't be ported to Win64 - Fix your code.

typedef struct _IMAGE_DEBUG_INFORMATION {
    LIST_ENTRY List;
    DWORD ReservedSize;
    PVOID ReservedMappedBase;
    USHORT ReservedMachine;
    USHORT ReservedCharacteristics;
    DWORD ReservedCheckSum;
    DWORD ImageBase;
    DWORD SizeOfImage;

    DWORD ReservedNumberOfSections;
    PIMAGE_SECTION_HEADER ReservedSections;

    DWORD ReservedExportedNamesSize;
    PSTR ReservedExportedNames;

    DWORD ReservedNumberOfFunctionTableEntries;
    PIMAGE_FUNCTION_ENTRY ReservedFunctionTableEntries;
    DWORD ReservedLowestFunctionStartingAddress;
    DWORD ReservedHighestFunctionEndingAddress;

    DWORD ReservedNumberOfFpoTableEntries;
    PFPO_DATA ReservedFpoTableEntries;

    DWORD SizeOfCoffSymbols;
    PIMAGE_COFF_SYMBOLS_HEADER CoffSymbols;

    DWORD ReservedSizeOfCodeViewSymbols;
    PVOID ReservedCodeViewSymbols;

    PSTR ImageFilePath;
    PSTR ImageFileName;
    PSTR ReservedDebugFilePath;

    DWORD ReservedTimeDateStamp;

    BOOL  ReservedRomImage;
    PIMAGE_DEBUG_DIRECTORY ReservedDebugDirectory;
    DWORD ReservedNumberOfDebugDirectories;

    DWORD ReservedOriginalFunctionTableBaseAddress;

    DWORD Reserved[ 2 ];

} IMAGE_DEBUG_INFORMATION, *PIMAGE_DEBUG_INFORMATION;


PIMAGE_DEBUG_INFORMATION
IMAGEAPI
MapDebugInformation(
    HANDLE FileHandle,
    PSTR FileName,
    PSTR SymbolPath,
    DWORD ImageBase
    );

BOOL
IMAGEAPI
UnmapDebugInformation(
    PIMAGE_DEBUG_INFORMATION DebugInfo
    );

#endif

BOOL
IMAGEAPI
SearchTreeForFile(
    PSTR RootPath,
    PSTR InputPathName,
    PSTR OutputPathBuffer
    );

BOOL
IMAGEAPI
MakeSureDirectoryPathExists(
    PCSTR DirPath
    );

//
// UnDecorateSymbolName Flags
//

#define UNDNAME_COMPLETE                 (0x0000)  // Enable full undecoration
#define UNDNAME_NO_LEADING_UNDERSCORES   (0x0001)  // Remove leading underscores from MS extended keywords
#define UNDNAME_NO_MS_KEYWORDS           (0x0002)  // Disable expansion of MS extended keywords
#define UNDNAME_NO_FUNCTION_RETURNS      (0x0004)  // Disable expansion of return type for primary declaration
#define UNDNAME_NO_ALLOCATION_MODEL      (0x0008)  // Disable expansion of the declaration model
#define UNDNAME_NO_ALLOCATION_LANGUAGE   (0x0010)  // Disable expansion of the declaration language specifier
#define UNDNAME_NO_MS_THISTYPE           (0x0020)  // NYI Disable expansion of MS keywords on the 'this' type for primary declaration
#define UNDNAME_NO_CV_THISTYPE           (0x0040)  // NYI Disable expansion of CV modifiers on the 'this' type for primary declaration
#define UNDNAME_NO_THISTYPE              (0x0060)  // Disable all modifiers on the 'this' type
#define UNDNAME_NO_ACCESS_SPECIFIERS     (0x0080)  // Disable expansion of access specifiers for members
#define UNDNAME_NO_THROW_SIGNATURES      (0x0100)  // Disable expansion of 'throw-signatures' for functions and pointers to functions
#define UNDNAME_NO_MEMBER_TYPE           (0x0200)  // Disable expansion of 'static' or 'virtual'ness of members
#define UNDNAME_NO_RETURN_UDT_MODEL      (0x0400)  // Disable expansion of MS model for UDT returns
#define UNDNAME_32_BIT_DECODE            (0x0800)  // Undecorate 32-bit decorated names
#define UNDNAME_NAME_ONLY                (0x1000)  // Crack only the name for primary declaration;
                                                                                                   //  return just [scope::]name.  Does expand template params
#define UNDNAME_NO_ARGUMENTS             (0x2000)  // Don't undecorate arguments to function
#define UNDNAME_NO_SPECIAL_SYMS          (0x4000)  // Don't undecorate special names (v-table, vcall, vector xxx, metatype, etc)

DWORD
IMAGEAPI
WINAPI
UnDecorateSymbolName(
    PCSTR   DecoratedName,         // Name to undecorate
    PSTR    UnDecoratedName,       // If NULL, it will be allocated
    DWORD    UndecoratedLength,     // The maximym length
    DWORD    Flags                  // See above.
    );

//
// StackWalking API
//

typedef enum {
    AddrMode1616,
    AddrMode1632,
    AddrModeReal,
    AddrModeFlat
} ADDRESS_MODE;

typedef struct _tagADDRESS64 {
    DWORD64       Offset;
    WORD          Segment;
    ADDRESS_MODE  Mode;
} ADDRESS64, *LPADDRESS64;

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define ADDRESS ADDRESS64
#define LPADDRESS LPADDRESS64
#else
typedef struct _tagADDRESS {
    DWORD         Offset;
    WORD          Segment;
    ADDRESS_MODE  Mode;
} ADDRESS, *LPADDRESS;

__inline
void
Address32To64(
    LPADDRESS a32,
    LPADDRESS64 a64
    )
{
    a64->Offset = (ULONG64)(LONG64)(LONG)a32->Offset;
    a64->Segment = a32->Segment;
    a64->Mode = a32->Mode;
}

__inline
void
Address64To32(
    LPADDRESS64 a64,
    LPADDRESS a32
    )
{
    a32->Offset = (ULONG)a64->Offset;
    a32->Segment = a64->Segment;
    a32->Mode = a64->Mode;
}
#endif

//
// This structure is included in the STACKFRAME structure,
// and is used to trace through usermode callbacks in a thread's
// kernel stack.  The values must be copied by the kernel debugger
// from the DBGKD_GET_VERSION and WAIT_STATE_CHANGE packets.
//

//
// New KDHELP structure for 64 bit system support.
// This structure is preferred in new code.
//
typedef struct _KDHELP64 {

    //
    // address of kernel thread object, as provided in the
    // WAIT_STATE_CHANGE packet.
    //
    DWORD64   Thread;

    //
    // offset in thread object to pointer to the current callback frame
    // in kernel stack.
    //
    DWORD   ThCallbackStack;

    //
    // offset in thread object to pointer to the current callback backing
    // store frame in kernel stack.
    //
    DWORD   ThCallbackBStore;

    //
    // offsets to values in frame:
    //
    // address of next callback frame
    DWORD   NextCallback;

    // address of saved frame pointer (if applicable)
    DWORD   FramePointer;


    //
    // Address of the kernel function that calls out to user mode
    //
    DWORD64   KiCallUserMode;

    //
    // Address of the user mode dispatcher function
    //
    DWORD64   KeUserCallbackDispatcher;

    //
    // Lowest kernel mode address
    //
    DWORD64   SystemRangeStart;

    DWORD64  Reserved[8];

} KDHELP64, *PKDHELP64;

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define KDHELP KDHELP64
#define PKDHELP PKDHELP64
#else
typedef struct _KDHELP {

    //
    // address of kernel thread object, as provided in the
    // WAIT_STATE_CHANGE packet.
    //
    DWORD   Thread;

    //
    // offset in thread object to pointer to the current callback frame
    // in kernel stack.
    //
    DWORD   ThCallbackStack;

    //
    // offsets to values in frame:
    //
    // address of next callback frame
    DWORD   NextCallback;

    // address of saved frame pointer (if applicable)
    DWORD   FramePointer;

    //
    // Address of the kernel function that calls out to user mode
    //
    DWORD   KiCallUserMode;

    //
    // Address of the user mode dispatcher function
    //
    DWORD   KeUserCallbackDispatcher;

    //
    // Lowest kernel mode address
    //
    DWORD   SystemRangeStart;

    //
    // offset in thread object to pointer to the current callback backing
    // store frame in kernel stack.
    //
    DWORD   ThCallbackBStore;

    DWORD  Reserved[8];

} KDHELP, *PKDHELP;

__inline
void
KdHelp32To64(
    PKDHELP p32,
    PKDHELP64 p64
    )
{
    p64->Thread = p32->Thread;
    p64->ThCallbackStack = p32->ThCallbackStack;
    p64->NextCallback = p32->NextCallback;
    p64->FramePointer = p32->FramePointer;
    p64->KiCallUserMode = p32->KiCallUserMode;
    p64->KeUserCallbackDispatcher = p32->KeUserCallbackDispatcher;
    p64->SystemRangeStart = p32->SystemRangeStart;
}
#endif

typedef struct _tagSTACKFRAME64 {
    ADDRESS64   AddrPC;               // program counter
    ADDRESS64   AddrReturn;           // return address
    ADDRESS64   AddrFrame;            // frame pointer
    ADDRESS64   AddrStack;            // stack pointer
    ADDRESS64   AddrBStore;           // backing store pointer
    PVOID       FuncTableEntry;       // pointer to pdata/fpo or NULL
    DWORD64     Params[4];            // possible arguments to the function
    BOOL        Far;                  // WOW far call
    BOOL        Virtual;              // is this a virtual frame?
    DWORD64     Reserved[3];
    KDHELP64    KdHelp;
} STACKFRAME64, *LPSTACKFRAME64;

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define STACKFRAME STACKFRAME64
#define LPSTACKFRAME LPSTACKFRAME64
#else
typedef struct _tagSTACKFRAME {
    ADDRESS     AddrPC;               // program counter
    ADDRESS     AddrReturn;           // return address
    ADDRESS     AddrFrame;            // frame pointer
    ADDRESS     AddrStack;            // stack pointer
    PVOID       FuncTableEntry;       // pointer to pdata/fpo or NULL
    DWORD       Params[4];            // possible arguments to the function
    BOOL        Far;                  // WOW far call
    BOOL        Virtual;              // is this a virtual frame?
    DWORD       Reserved[3];
    KDHELP      KdHelp;
    ADDRESS     AddrBStore;           // backing store pointer
} STACKFRAME, *LPSTACKFRAME;
#endif


typedef
BOOL
(__stdcall *PREAD_PROCESS_MEMORY_ROUTINE64)(
    HANDLE      hProcess,
    DWORD64     qwBaseAddress,
    PVOID       lpBuffer,
    DWORD       nSize,
    LPDWORD     lpNumberOfBytesRead
    );

typedef
PVOID
(__stdcall *PFUNCTION_TABLE_ACCESS_ROUTINE64)(
    HANDLE  hProcess,
    DWORD64 AddrBase
    );

typedef
DWORD64
(__stdcall *PGET_MODULE_BASE_ROUTINE64)(
    HANDLE  hProcess,
    DWORD64 Address
    );

typedef
DWORD64
(__stdcall *PTRANSLATE_ADDRESS_ROUTINE64)(
    HANDLE    hProcess,
    HANDLE    hThread,
    LPADDRESS64 lpaddr
    );

BOOL
IMAGEAPI
StackWalk64(
    DWORD                             MachineType,
    HANDLE                            hProcess,
    HANDLE                            hThread,
    LPSTACKFRAME64                    StackFrame,
    PVOID                             ContextRecord,
    PREAD_PROCESS_MEMORY_ROUTINE64    ReadMemoryRoutine,
    PFUNCTION_TABLE_ACCESS_ROUTINE64  FunctionTableAccessRoutine,
    PGET_MODULE_BASE_ROUTINE64        GetModuleBaseRoutine,
    PTRANSLATE_ADDRESS_ROUTINE64      TranslateAddress
    );

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)

#define PREAD_PROCESS_MEMORY_ROUTINE PREAD_PROCESS_MEMORY_ROUTINE64
#define PFUNCTION_TABLE_ACCESS_ROUTINE PFUNCTION_TABLE_ACCESS_ROUTINE64
#define PGET_MODULE_BASE_ROUTINE PGET_MODULE_BASE_ROUTINE64
#define PTRANSLATE_ADDRESS_ROUTINE PTRANSLATE_ADDRESS_ROUTINE64

#define StackWalk StackWalk64

#else

typedef
BOOL
(__stdcall *PREAD_PROCESS_MEMORY_ROUTINE)(
    HANDLE  hProcess,
    DWORD   lpBaseAddress,
    PVOID   lpBuffer,
    DWORD   nSize,
    PDWORD  lpNumberOfBytesRead
    );

typedef
PVOID
(__stdcall *PFUNCTION_TABLE_ACCESS_ROUTINE)(
    HANDLE  hProcess,
    DWORD   AddrBase
    );

typedef
DWORD
(__stdcall *PGET_MODULE_BASE_ROUTINE)(
    HANDLE  hProcess,
    DWORD   Address
    );

typedef
DWORD
(__stdcall *PTRANSLATE_ADDRESS_ROUTINE)(
    HANDLE    hProcess,
    HANDLE    hThread,
    LPADDRESS lpaddr
    );

BOOL
IMAGEAPI
StackWalk(
    DWORD                             MachineType,
    HANDLE                            hProcess,
    HANDLE                            hThread,
    LPSTACKFRAME                      StackFrame,
    PVOID                             ContextRecord,
    PREAD_PROCESS_MEMORY_ROUTINE      ReadMemoryRoutine,
    PFUNCTION_TABLE_ACCESS_ROUTINE    FunctionTableAccessRoutine,
    PGET_MODULE_BASE_ROUTINE          GetModuleBaseRoutine,
    PTRANSLATE_ADDRESS_ROUTINE        TranslateAddress
    );

#endif


#define API_VERSION_NUMBER 9

typedef struct API_VERSION {
    USHORT  MajorVersion;
    USHORT  MinorVersion;
    USHORT  Revision;
    USHORT  Reserved;
} API_VERSION, *LPAPI_VERSION;

LPAPI_VERSION
IMAGEAPI
ImagehlpApiVersion(
    VOID
    );

LPAPI_VERSION
IMAGEAPI
ImagehlpApiVersionEx(
    LPAPI_VERSION AppVersion
    );

DWORD
IMAGEAPI
GetTimestampForLoadedLibrary(
    HMODULE Module
    );

//
// typedefs for function pointers
//
typedef BOOL
(CALLBACK *PSYM_ENUMMODULES_CALLBACK64)(
    PSTR ModuleName,
    DWORD64 BaseOfDll,
    PVOID UserContext
    );

typedef BOOL
(CALLBACK *PSYM_ENUMSYMBOLS_CALLBACK64)(
    PSTR SymbolName,
    DWORD64 SymbolAddress,
    ULONG SymbolSize,
    PVOID UserContext
    );

typedef BOOL
(CALLBACK *PSYM_ENUMSYMBOLS_CALLBACK64W)(
    PWSTR SymbolName,
    DWORD64 SymbolAddress,
    ULONG SymbolSize,
    PVOID UserContext
    );

typedef BOOL
(CALLBACK *PENUMLOADED_MODULES_CALLBACK64)(
    PSTR ModuleName,
    DWORD64 ModuleBase,
    ULONG ModuleSize,
    PVOID UserContext
    );

typedef BOOL
(CALLBACK *PSYMBOL_REGISTERED_CALLBACK64)(
    HANDLE  hProcess,
    ULONG   ActionCode,
    ULONG64 CallbackData,
    ULONG64 UserContext
    );

typedef
PVOID
(CALLBACK *PSYMBOL_FUNCENTRY_CALLBACK)(
    HANDLE  hProcess,
    DWORD   AddrBase,
    PVOID   UserContext
    );

typedef
PVOID
(CALLBACK *PSYMBOL_FUNCENTRY_CALLBACK64)(
    HANDLE  hProcess,
    ULONG64 AddrBase,
    ULONG64 UserContext
    );

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)

#define PSYM_ENUMMODULES_CALLBACK PSYM_ENUMMODULES_CALLBACK64
#define PSYM_ENUMSYMBOLS_CALLBACK PSYM_ENUMSYMBOLS_CALLBACK64
#define PSYM_ENUMSYMBOLS_CALLBACKW PSYM_ENUMSYMBOLS_CALLBACK64W
#define PENUMLOADED_MODULES_CALLBACK PENUMLOADED_MODULES_CALLBACK64
#define PSYMBOL_REGISTERED_CALLBACK PSYMBOL_REGISTERED_CALLBACK64
#define PSYMBOL_FUNCENTRY_CALLBACK PSYMBOL_FUNCENTRY_CALLBACK64

#else

typedef BOOL
(CALLBACK *PSYM_ENUMMODULES_CALLBACK)(
    PSTR  ModuleName,
    ULONG BaseOfDll,
    PVOID UserContext
    );

typedef BOOL
(CALLBACK *PSYM_ENUMSYMBOLS_CALLBACK)(
    PSTR  SymbolName,
    ULONG SymbolAddress,
    ULONG SymbolSize,
    PVOID UserContext
    );

typedef BOOL
(CALLBACK *PSYM_ENUMSYMBOLS_CALLBACKW)(
    PWSTR  SymbolName,
    ULONG SymbolAddress,
    ULONG SymbolSize,
    PVOID UserContext
    );

typedef BOOL
(CALLBACK *PENUMLOADED_MODULES_CALLBACK)(
    PSTR  ModuleName,
    ULONG ModuleBase,
    ULONG ModuleSize,
    PVOID UserContext
    );

typedef BOOL
(CALLBACK *PSYMBOL_REGISTERED_CALLBACK)(
    HANDLE  hProcess,
    ULONG   ActionCode,
    PVOID   CallbackData,
    PVOID   UserContext
    );

#endif


//
// symbol flags
//

#define SYMF_OMAP_GENERATED   0x00000001
#define SYMF_OMAP_MODIFIED    0x00000002
#ifndef _DBGHELP_USER_GENERATED_SYMBOLS_NOTSUPPORTED
#define SYMF_USER_GENERATED   0x00000004
#endif // !_DBGHELP_USER_GENERATED_SYMBOLS_NOTSUPPORTED
#define SYMF_REGISTER         0x00000008
#define SYMF_REGREL           0x00000010
#define SYMF_FRAMEREL         0x00000020
#define SYMF_PARAMETER        0x00000040
#define SYMF_LOCAL            0x00000080
//
// symbol type enumeration
//
typedef enum {
    SymNone = 0,
    SymCoff,
    SymCv,
    SymPdb,
    SymExport,
    SymDeferred,
    SymSym,       // .sym file
    SymDia,
    NumSymTypes
} SYM_TYPE;

//
// symbol data structure
//

typedef struct _IMAGEHLP_SYMBOL64 {
    DWORD                       SizeOfStruct;           // set to sizeof(IMAGEHLP_SYMBOL64)
    DWORD64                     Address;                // virtual address including dll base address
    DWORD                       Size;                   // estimated size of symbol, can be zero
    DWORD                       Flags;                  // info about the symbols, see the SYMF defines
    DWORD                       MaxNameLength;          // maximum size of symbol name in 'Name'
    CHAR                        Name[1];                // symbol name (null terminated string)
} IMAGEHLP_SYMBOL64, *PIMAGEHLP_SYMBOL64;

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define IMAGEHLP_SYMBOL IMAGEHLP_SYMBOL64
#define PIMAGEHLP_SYMBOL PIMAGEHLP_SYMBOL64
#else
typedef struct _IMAGEHLP_SYMBOL {
    DWORD                       SizeOfStruct;           // set to sizeof(IMAGEHLP_SYMBOL)
    DWORD                       Address;                // virtual address including dll base address
    DWORD                       Size;                   // estimated size of symbol, can be zero
    DWORD                       Flags;                  // info about the symbols, see the SYMF defines
    DWORD                       MaxNameLength;          // maximum size of symbol name in 'Name'
    CHAR                        Name[1];                // symbol name (null terminated string)
} IMAGEHLP_SYMBOL, *PIMAGEHLP_SYMBOL;
#endif

//
// module data structure
//

typedef struct _IMAGEHLP_MODULE64 {
    DWORD                       SizeOfStruct;           // set to sizeof(IMAGEHLP_MODULE64)
    DWORD64                     BaseOfImage;            // base load address of module
    DWORD                       ImageSize;              // virtual size of the loaded module
    DWORD                       TimeDateStamp;          // date/time stamp from pe header
    DWORD                       CheckSum;               // checksum from the pe header
    DWORD                       NumSyms;                // number of symbols in the symbol table
    SYM_TYPE                    SymType;                // type of symbols loaded
    CHAR                        ModuleName[32];         // module name
    CHAR                        ImageName[256];         // image name
    CHAR                        LoadedImageName[256];   // symbol file name
} IMAGEHLP_MODULE64, *PIMAGEHLP_MODULE64;

typedef struct _IMAGEHLP_MODULE64W {
    DWORD                       SizeOfStruct;           // set to sizeof(IMAGEHLP_MODULE64)
    DWORD64                     BaseOfImage;            // base load address of module
    DWORD                       ImageSize;              // virtual size of the loaded module
    DWORD                       TimeDateStamp;          // date/time stamp from pe header
    DWORD                       CheckSum;               // checksum from the pe header
    DWORD                       NumSyms;                // number of symbols in the symbol table
    SYM_TYPE                    SymType;                // type of symbols loaded
    WCHAR                       ModuleName[32];         // module name
    WCHAR                       ImageName[256];         // image name
    WCHAR                       LoadedImageName[256];   // symbol file name
} IMAGEHLP_MODULEW64, *PIMAGEHLP_MODULEW64;

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define IMAGEHLP_MODULE IMAGEHLP_MODULE64
#define PIMAGEHLP_MODULE PIMAGEHLP_MODULE64
#define IMAGEHLP_MODULEW IMAGEHLP_MODULEW64
#define PIMAGEHLP_MODULEW PIMAGEHLP_MODULEW64
#else
typedef struct _IMAGEHLP_MODULE {
    DWORD                       SizeOfStruct;           // set to sizeof(IMAGEHLP_MODULE)
    DWORD                       BaseOfImage;            // base load address of module
    DWORD                       ImageSize;              // virtual size of the loaded module
    DWORD                       TimeDateStamp;          // date/time stamp from pe header
    DWORD                       CheckSum;               // checksum from the pe header
    DWORD                       NumSyms;                // number of symbols in the symbol table
    SYM_TYPE                    SymType;                // type of symbols loaded
    CHAR                        ModuleName[32];         // module name
    CHAR                        ImageName[256];         // image name
    CHAR                        LoadedImageName[256];   // symbol file name
} IMAGEHLP_MODULE, *PIMAGEHLP_MODULE;

typedef struct _IMAGEHLP_MODULEW {
    DWORD                       SizeOfStruct;           // set to sizeof(IMAGEHLP_MODULE)
    DWORD                       BaseOfImage;            // base load address of module
    DWORD                       ImageSize;              // virtual size of the loaded module
    DWORD                       TimeDateStamp;          // date/time stamp from pe header
    DWORD                       CheckSum;               // checksum from the pe header
    DWORD                       NumSyms;                // number of symbols in the symbol table
    SYM_TYPE                    SymType;                // type of symbols loaded
    WCHAR                       ModuleName[32];         // module name
    WCHAR                       ImageName[256];         // image name
    WCHAR                       LoadedImageName[256];   // symbol file name
} IMAGEHLP_MODULEW, *PIMAGEHLP_MODULEW;
#endif

//
// source file line data structure
//

typedef struct _IMAGEHLP_LINE64 {
    DWORD                       SizeOfStruct;           // set to sizeof(IMAGEHLP_LINE64)
    PVOID                       Key;                    // internal
    DWORD                       LineNumber;             // line number in file
    PCHAR                       FileName;               // full filename
    DWORD64                     Address;                // first instruction of line
} IMAGEHLP_LINE64, *PIMAGEHLP_LINE64;

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define IMAGEHLP_LINE IMAGEHLP_LINE64
#define PIMAGEHLP_LINE PIMAGEHLP_LINE64
#else
typedef struct _IMAGEHLP_LINE {
    DWORD                       SizeOfStruct;           // set to sizeof(IMAGEHLP_LINE)
    PVOID                       Key;                    // internal
    DWORD                       LineNumber;             // line number in file
    PCHAR                       FileName;               // full filename
    DWORD                       Address;                // first instruction of line
} IMAGEHLP_LINE, *PIMAGEHLP_LINE;
#endif

//
// data structures used for registered symbol callbacks
//

#define CBA_DEFERRED_SYMBOL_LOAD_START          0x00000001
#define CBA_DEFERRED_SYMBOL_LOAD_COMPLETE       0x00000002
#define CBA_DEFERRED_SYMBOL_LOAD_FAILURE        0x00000003
#define CBA_SYMBOLS_UNLOADED                    0x00000004
#define CBA_DUPLICATE_SYMBOL                    0x00000005
#define CBA_READ_MEMORY                         0x00000006
#define CBA_DEFERRED_SYMBOL_LOAD_CANCEL         0x00000007
#define CBA_SET_OPTIONS                         0x00000008
#define CBA_DEBUG_INFO                          0x10000000

typedef struct _IMAGEHLP_CBA_READ_MEMORY {
    DWORD64   addr;                                     // address to read from
    PVOID     buf;                                      // buffer to read to
    DWORD     bytes;                                    // amount of bytes to read
    DWORD    *bytesread;                                // pointer to store amount of bytes read
} IMAGEHLP_CBA_READ_MEMORY, *PIMAGEHLP_CBA_READ_MEMORY;

typedef struct _IMAGEHLP_DEFERRED_SYMBOL_LOAD64 {
    DWORD                       SizeOfStruct;           // set to sizeof(IMAGEHLP_DEFERRED_SYMBOL_LOAD64)
    DWORD64                     BaseOfImage;            // base load address of module
    DWORD                       CheckSum;               // checksum from the pe header
    DWORD                       TimeDateStamp;          // date/time stamp from pe header
    CHAR                        FileName[MAX_PATH];     // symbols file or image name
    BOOLEAN                     Reparse;                // load failure reparse
} IMAGEHLP_DEFERRED_SYMBOL_LOAD64, *PIMAGEHLP_DEFERRED_SYMBOL_LOAD64;

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define IMAGEHLP_DEFERRED_SYMBOL_LOAD IMAGEHLP_DEFERRED_SYMBOL_LOAD64
#define PIMAGEHLP_DEFERRED_SYMBOL_LOAD PIMAGEHLP_DEFERRED_SYMBOL_LOAD64
#else
typedef struct _IMAGEHLP_DEFERRED_SYMBOL_LOAD {
    DWORD                       SizeOfStruct;           // set to sizeof(IMAGEHLP_DEFERRED_SYMBOL_LOAD)
    DWORD                       BaseOfImage;            // base load address of module
    DWORD                       CheckSum;               // checksum from the pe header
    DWORD                       TimeDateStamp;          // date/time stamp from pe header
    CHAR                        FileName[MAX_PATH];     // symbols file or image name
    BOOLEAN                     Reparse;                // load failure reparse
} IMAGEHLP_DEFERRED_SYMBOL_LOAD, *PIMAGEHLP_DEFERRED_SYMBOL_LOAD;
#endif

typedef struct _IMAGEHLP_DUPLICATE_SYMBOL64 {
    DWORD                       SizeOfStruct;           // set to sizeof(IMAGEHLP_DUPLICATE_SYMBOL64)
    DWORD                       NumberOfDups;           // number of duplicates in the Symbol array
    PIMAGEHLP_SYMBOL64          Symbol;                 // array of duplicate symbols
    DWORD                       SelectedSymbol;         // symbol selected (-1 to start)
} IMAGEHLP_DUPLICATE_SYMBOL64, *PIMAGEHLP_DUPLICATE_SYMBOL64;

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define IMAGEHLP_DUPLICATE_SYMBOL IMAGEHLP_DUPLICATE_SYMBOL64
#define PIMAGEHLP_DUPLICATE_SYMBOL PIMAGEHLP_DUPLICATE_SYMBOL64
#else
typedef struct _IMAGEHLP_DUPLICATE_SYMBOL {
    DWORD                       SizeOfStruct;           // set to sizeof(IMAGEHLP_DUPLICATE_SYMBOL)
    DWORD                       NumberOfDups;           // number of duplicates in the Symbol array
    PIMAGEHLP_SYMBOL            Symbol;                 // array of duplicate symbols
    DWORD                       SelectedSymbol;         // symbol selected (-1 to start)
} IMAGEHLP_DUPLICATE_SYMBOL, *PIMAGEHLP_DUPLICATE_SYMBOL;
#endif


//
// options that are set/returned by SymSetOptions() & SymGetOptions()
// these are used as a mask
//
#define SYMOPT_CASE_INSENSITIVE     0x00000001
#define SYMOPT_UNDNAME              0x00000002
#define SYMOPT_DEFERRED_LOADS       0x00000004
#define SYMOPT_NO_CPP               0x00000008
#define SYMOPT_LOAD_LINES           0x00000010
#define SYMOPT_OMAP_FIND_NEAREST    0x00000020
#define SYMOPT_LOAD_ANYTHING        0x00000040
#define SYMOPT_IGNORE_CVREC         0x00000080
#define SYMOPT_NO_UNQUALIFIED_LOADS 0x00000100
#define SYMOPT_FAIL_CRITICAL_ERRORS 0x00000200
#define SYMOPT_EXACT_SYMBOLS        0x00000400
#define SYMOPT_DEBUG                0x80000000


DWORD
IMAGEAPI
SymSetOptions(
    IN DWORD   SymOptions
    );

DWORD
IMAGEAPI
SymGetOptions(
    VOID
    );

BOOL
IMAGEAPI
SymCleanup(
    IN HANDLE hProcess
    );

BOOL
IMAGEAPI
SymEnumerateModules64(
    IN HANDLE                       hProcess,
    IN PSYM_ENUMMODULES_CALLBACK64  EnumModulesCallback,
    IN PVOID                        UserContext
    );

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymEnumerateModules SymEnumerateModules64
#else
BOOL
IMAGEAPI
SymEnumerateModules(
    IN HANDLE                     hProcess,
    IN PSYM_ENUMMODULES_CALLBACK  EnumModulesCallback,
    IN PVOID                      UserContext
    );
#endif

BOOL
IMAGEAPI
SymEnumerateSymbols64(
    IN HANDLE                       hProcess,
    IN DWORD64                      BaseOfDll,
    IN PSYM_ENUMSYMBOLS_CALLBACK64  EnumSymbolsCallback,
    IN PVOID                        UserContext
    );

BOOL
IMAGEAPI
SymEnumerateSymbolsW64(
    IN HANDLE                       hProcess,
    IN DWORD64                      BaseOfDll,
    IN PSYM_ENUMSYMBOLS_CALLBACK64W EnumSymbolsCallback,
    IN PVOID                        UserContext
    );

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymEnumerateSymbols SymEnumerateSymbols64
#define SymEnumerateSymbolsW SymEnumerateSymbolsW64
#else
BOOL
IMAGEAPI
SymEnumerateSymbols(
    IN HANDLE                     hProcess,
    IN DWORD                      BaseOfDll,
    IN PSYM_ENUMSYMBOLS_CALLBACK  EnumSymbolsCallback,
    IN PVOID                      UserContext
    );

BOOL
IMAGEAPI
SymEnumerateSymbolsW(
    IN HANDLE                       hProcess,
    IN DWORD                        BaseOfDll,
    IN PSYM_ENUMSYMBOLS_CALLBACKW   EnumSymbolsCallback,
    IN PVOID                        UserContext
    );
#endif

BOOL
IMAGEAPI
EnumerateLoadedModules64(
    IN HANDLE                           hProcess,
    IN PENUMLOADED_MODULES_CALLBACK64   EnumLoadedModulesCallback,
    IN PVOID                            UserContext
    );

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define EnumerateLoadedModules EnumerateLoadedModules64
#else
BOOL
IMAGEAPI
EnumerateLoadedModules(
    IN HANDLE                         hProcess,
    IN PENUMLOADED_MODULES_CALLBACK   EnumLoadedModulesCallback,
    IN PVOID                          UserContext
    );
#endif

PVOID
IMAGEAPI
SymFunctionTableAccess64(
    HANDLE  hProcess,
    DWORD64 AddrBase
    );

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymFunctionTableAccess SymFunctionTableAccess64
#else
PVOID
IMAGEAPI
SymFunctionTableAccess(
    HANDLE  hProcess,
    DWORD   AddrBase
    );
#endif

BOOL
IMAGEAPI
SymGetModuleInfo64(
    IN  HANDLE                  hProcess,
    IN  DWORD64                 qwAddr,
    OUT PIMAGEHLP_MODULE64      ModuleInfo
    );

BOOL
IMAGEAPI
SymGetModuleInfoW64(
    IN  HANDLE                  hProcess,
    IN  DWORD64                 qwAddr,
    OUT PIMAGEHLP_MODULEW64     ModuleInfo
    );

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymGetModuleInfo   SymGetModuleInfo64
#define SymGetModuleInfoW  SymGetModuleInfoW64
#else
BOOL
IMAGEAPI
SymGetModuleInfo(
    IN  HANDLE              hProcess,
    IN  DWORD               dwAddr,
    OUT PIMAGEHLP_MODULE  ModuleInfo
    );

BOOL
IMAGEAPI
SymGetModuleInfoW(
    IN  HANDLE              hProcess,
    IN  DWORD               dwAddr,
    OUT PIMAGEHLP_MODULEW  ModuleInfo
    );
#endif

DWORD64
IMAGEAPI
SymGetModuleBase64(
    IN  HANDLE              hProcess,
    IN  DWORD64             qwAddr
    );

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymGetModuleBase SymGetModuleBase64
#else
DWORD
IMAGEAPI
SymGetModuleBase(
    IN  HANDLE              hProcess,
    IN  DWORD               dwAddr
    );
#endif

BOOL
IMAGEAPI
SymGetSymFromAddr64(
    IN  HANDLE              hProcess,
    IN  DWORD64             qwAddr,
    OUT PDWORD64            pdwDisplacement,
    OUT PIMAGEHLP_SYMBOL64  Symbol
    );

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymGetSymFromAddr SymGetSymFromAddr64
#else
BOOL
IMAGEAPI
SymGetSymFromAddr(
    IN  HANDLE            hProcess,
    IN  DWORD             dwAddr,
    OUT PDWORD            pdwDisplacement,
    OUT PIMAGEHLP_SYMBOL  Symbol
    );
#endif

BOOL
IMAGEAPI
SymGetSymFromName64(
    IN  HANDLE              hProcess,
    IN  PSTR                Name,
    OUT PIMAGEHLP_SYMBOL64  Symbol
    );

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymGetSymFromName SymGetSymFromName64
#else
BOOL
IMAGEAPI
SymGetSymFromName(
    IN  HANDLE            hProcess,
    IN  PSTR              Name,
    OUT PIMAGEHLP_SYMBOL  Symbol
    );
#endif

BOOL
IMAGEAPI
SymGetSymNext64(
    IN     HANDLE              hProcess,
    IN OUT PIMAGEHLP_SYMBOL64  Symbol
    );

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymGetSymNext SymGetSymNext64
#else
BOOL
IMAGEAPI
SymGetSymNext(
    IN     HANDLE            hProcess,
    IN OUT PIMAGEHLP_SYMBOL  Symbol
    );
#endif

BOOL
IMAGEAPI
SymGetSymPrev64(
    IN     HANDLE              hProcess,
    IN OUT PIMAGEHLP_SYMBOL64  Symbol
    );

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymGetSymPrev SymGetSymPrev64
#else
BOOL
IMAGEAPI
SymGetSymPrev(
    IN     HANDLE            hProcess,
    IN OUT PIMAGEHLP_SYMBOL  Symbol
    );
#endif

BOOL
IMAGEAPI
SymGetLineFromAddr64(
    IN  HANDLE                  hProcess,
    IN  DWORD64                 qwAddr,
    OUT PDWORD                  pdwDisplacement,
    OUT PIMAGEHLP_LINE64        Line
    );

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymGetLineFromAddr SymGetLineFromAddr64
#else
BOOL
IMAGEAPI
SymGetLineFromAddr(
    IN  HANDLE                hProcess,
    IN  DWORD                 dwAddr,
    OUT PDWORD                pdwDisplacement,
    OUT PIMAGEHLP_LINE        Line
    );
#endif

BOOL
IMAGEAPI
SymGetLineFromName64(
    IN     HANDLE               hProcess,
    IN     PSTR                 ModuleName,
    IN     PSTR                 FileName,
    IN     DWORD                dwLineNumber,
       OUT PLONG                plDisplacement,
    IN OUT PIMAGEHLP_LINE64     Line
    );

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymGetLineFromName SymGetLineFromName64
#else
BOOL
IMAGEAPI
SymGetLineFromName(
    IN     HANDLE             hProcess,
    IN     PSTR               ModuleName,
    IN     PSTR               FileName,
    IN     DWORD              dwLineNumber,
       OUT PLONG              plDisplacement,
    IN OUT PIMAGEHLP_LINE     Line
    );
#endif

BOOL
IMAGEAPI
SymGetLineNext64(
    IN     HANDLE               hProcess,
    IN OUT PIMAGEHLP_LINE64     Line
    );

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymGetLineNext SymGetLineNext64
#else
BOOL
IMAGEAPI
SymGetLineNext(
    IN     HANDLE             hProcess,
    IN OUT PIMAGEHLP_LINE     Line
    );
#endif

BOOL
IMAGEAPI
SymGetLinePrev64(
    IN     HANDLE               hProcess,
    IN OUT PIMAGEHLP_LINE64     Line
    );

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymGetLinePrev SymGetLinePrev64
#else
BOOL
IMAGEAPI
SymGetLinePrev(
    IN     HANDLE             hProcess,
    IN OUT PIMAGEHLP_LINE     Line
    );
#endif

BOOL
IMAGEAPI
SymMatchFileName(
    IN  PSTR  FileName,
    IN  PSTR  Match,
    OUT PSTR *FileNameStop,
    OUT PSTR *MatchStop
    );

BOOL
IMAGEAPI
SymInitialize(
    IN HANDLE   hProcess,
    IN PSTR     UserSearchPath,
    IN BOOL     fInvadeProcess
    );

BOOL
IMAGEAPI
SymGetSearchPath(
    IN  HANDLE          hProcess,
    OUT PSTR            SearchPath,
    IN  DWORD           SearchPathLength
    );

BOOL
IMAGEAPI
SymSetSearchPath(
    IN HANDLE           hProcess,
    IN PSTR             SearchPath
    );

DWORD64
IMAGEAPI
SymLoadModule64(
    IN  HANDLE          hProcess,
    IN  HANDLE          hFile,
    IN  PSTR            ImageName,
    IN  PSTR            ModuleName,
    IN  DWORD64         BaseOfDll,
    IN  DWORD           SizeOfDll
    );

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymLoadModule SymLoadModule64
#else
DWORD
IMAGEAPI
SymLoadModule(
    IN  HANDLE          hProcess,
    IN  HANDLE          hFile,
    IN  PSTR            ImageName,
    IN  PSTR            ModuleName,
    IN  DWORD           BaseOfDll,
    IN  DWORD           SizeOfDll
    );
#endif

BOOL
IMAGEAPI
SymUnloadModule64(
    IN  HANDLE          hProcess,
    IN  DWORD64         BaseOfDll
    );

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymUnloadModule SymUnloadModule64
#else
BOOL
IMAGEAPI
SymUnloadModule(
    IN  HANDLE          hProcess,
    IN  DWORD           BaseOfDll
    );
#endif

BOOL
IMAGEAPI
SymUnDName64(
    IN  PIMAGEHLP_SYMBOL64 sym,               // Symbol to undecorate
    OUT PSTR               UnDecName,         // Buffer to store undecorated name in
    IN  DWORD              UnDecNameLength    // Size of the buffer
    );

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymUnDName SymUnDName64
#else
BOOL
IMAGEAPI
SymUnDName(
    IN  PIMAGEHLP_SYMBOL sym,               // Symbol to undecorate
    OUT PSTR             UnDecName,         // Buffer to store undecorated name in
    IN  DWORD            UnDecNameLength    // Size of the buffer
    );
#endif

BOOL
IMAGEAPI
SymRegisterCallback64(
    IN HANDLE                        hProcess,
    IN PSYMBOL_REGISTERED_CALLBACK64 CallbackFunction,
    IN ULONG64                       UserContext
    );

BOOL
IMAGEAPI
SymRegisterFunctionEntryCallback64(
    IN HANDLE                       hProcess,
    IN PSYMBOL_FUNCENTRY_CALLBACK64 CallbackFunction,
    IN ULONG64                      UserContext
    );

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymRegisterCallback SymRegisterCallback64
#define SymRegisterFunctionEntryCallback SymRegisterFunctionEntryCallback64
#else
BOOL
IMAGEAPI
SymRegisterCallback(
    IN HANDLE                      hProcess,
    IN PSYMBOL_REGISTERED_CALLBACK CallbackFunction,
    IN PVOID                       UserContext
    );

BOOL
IMAGEAPI
SymRegisterFunctionEntryCallback(
    IN HANDLE                     hProcess,
    IN PSYMBOL_FUNCENTRY_CALLBACK CallbackFunction,
    IN PVOID                      UserContext
    );
#endif


// Structure types
typedef enum IMAGEHLP_TYPES {
   IMAGEHLP_TYPEID_INDEX = 1,
   IMAGEHLP_TYPEID_NAME,
   IMAGEHLP_TYPEID_IMAGEHLP_SYMBOL,
   IMAGEHLP_TYPEID_IMAGEHLP_SYMBOL64,
   IMAGEHLP_TYPEID_MODULE_TYPE_INFO,
   IMAGEHLP_TYPEID_TYPE_ENUM_INFO,
   IMAGEHLP_TYPEID_ADDR,
   IMAGEHLP_TYPEID_ADDR_ENUM,
   IMAGEHLP_TYPEID_SYMBOL_SRC
} IMAGEHLP_TYPES;

typedef struct _IMAGEHLP_SYMBOL_SRC {
    DWORD sizeofstruct;
    DWORD type;
    char  file[MAX_PATH];
} IMAGEHLP_SYMBOL_SRC, *PIMAGEHLP_SYMBOL_SRC;

typedef struct _MODULE_TYPE_INFO { // AKA TYPTYP
    USHORT      dataLength;
    USHORT      leaf;
    BYTE        data[1];
} MODULE_TYPE_INFO, *PMODULE_TYPE_INFO;

#define IMAGEHLP_SYMBOL_INFO_VALUEPRESENT          1
#define IMAGEHLP_SYMBOL_INFO_REGISTER              SYMF_REGISTER        // 0x08
#define IMAGEHLP_SYMBOL_INFO_REGRELATIVE           SYMF_REGREL          // 0x10
#define IMAGEHLP_SYMBOL_INFO_FRAMERELATIVE         SYMF_FRAMEREL        // 0x20
#define IMAGEHLP_SYMBOL_INFO_PARAMETER             SYMF_PARAMETER       // 0x40
#define IMAGEHLP_SYMBOL_INFO_LOCAL                 SYMF_LOCAL           // 0x80

typedef struct _SYMBOL_INFO {
    ULONG       SizeOfStruct;
    ULONG       TypeIndex;        // Type Index of symbol
    ULONG64     Reserved[2];
    ULONG       Reserved2;
    ULONG       Size;
    ULONG64     ModBase;          // Base Address of module comtaining this symbol
    ULONG       Flags;
    ULONG64     Value;            // Value of symbol, ValuePresent should be 1
    ULONG64     Address;          // Address of symbol including base address of module
    ULONG       Register;         // register holding value or pointer to value
    ULONG       Scope;            // scope of the symbol
    ULONG       Tag;              // pdb classification
    ULONG       NameLen;          // Actual length of name
    ULONG       MaxNameLen;
    CHAR        Name[1];          // Name of symbol
} SYMBOL_INFO, *PSYMBOL_INFO;

typedef BOOL
(CALLBACK *PSYMBOL_TYPE_NAME_CALLBACK)(
    PSTR  MatchedName,
    ULONG typeIndex,
    PVOID CallerData
    );

typedef BOOL
(CALLBACK *PSYMBOL_TYPE_NAME_ADDR_CALLBACK)(
    PSTR    MatchedName,
    ULONG   typeIndex,
    ULONG64 symAddress,
    PVOID   CallerData
    );

typedef struct _IMAGEHLP_STACK_FRAME
{
    ULONG64 InstructionOffset;
    ULONG64 ReturnOffset;
    ULONG64 FrameOffset;
    ULONG64 StackOffset;
    ULONG64 BackingStoreOffset;
    ULONG64 FuncTableEntry;
    ULONG64 Params[4];
    ULONG64 Reserved[5];
    BOOL    Virtual;
    ULONG   Reserved2;
} IMAGEHLP_STACK_FRAME, *PIMAGEHLP_STACK_FRAME;

typedef VOID IMAGEHLP_CONTEXT, *PIMAGEHLP_CONTEXT;


ULONG
SymSetContext(
    HANDLE hProcess,
    PIMAGEHLP_STACK_FRAME StackFrame,
    PIMAGEHLP_CONTEXT Context
    );

//
// Full user-mode dump creation.
//

typedef BOOL (WINAPI *PDBGHELP_CREATE_USER_DUMP_CALLBACK)(
    DWORD       DataType,
    PVOID*      Data,
    LPDWORD     DataLength,
    PVOID       UserData
    );

BOOL
WINAPI
DbgHelpCreateUserDump(
    IN LPSTR                              FileName,
    IN PDBGHELP_CREATE_USER_DUMP_CALLBACK Callback,
    IN PVOID                              UserData
    );

BOOL
WINAPI
DbgHelpCreateUserDumpW(
    IN LPWSTR                             FileName,
    IN PDBGHELP_CREATE_USER_DUMP_CALLBACK Callback,
    IN PVOID                              UserData
    );

typedef BOOL
(CALLBACK *PSYM_ENUMERATESYMBOLS_CALLBACK)(
    PSYMBOL_INFO  pSymInfo,
    ULONG         SymbolSize,
    PVOID         UserContext
    );
BOOL
IMAGEAPI
SymFromAddr(
    IN  HANDLE              hProcess,
    IN  DWORD64             Address,
    OUT PDWORD64            Displacement,
    IN OUT PSYMBOL_INFO     Symbol
    );

BOOL
IMAGEAPI
SymFromName(
    IN  HANDLE              hProcess,
    IN  LPSTR               Name,
    OUT PSYMBOL_INFO        Symbol
    );

BOOL
IMAGEAPI
SymEnumSym(
    IN HANDLE                       hProcess,
    IN ULONG64                      BaseOfDll,
    IN PSYM_ENUMERATESYMBOLS_CALLBACK    EnumSymbolsCallback,
    IN PVOID                        UserContext
    );

BOOL
IMAGEAPI
SymEnumSymbols(
    IN HANDLE                       hProcess,
    IN ULONG64                      BaseOfDll,
    IN PCSTR                        Mask,
    IN PSYM_ENUMERATESYMBOLS_CALLBACK    EnumSymbolsCallback,
    IN PVOID                        UserContext
    );

typedef enum _IMAGEHLP_SYMBOL_TYPE_INFO {
    TI_GET_SYMTAG,
    TI_GET_SYMNAME,
    TI_GET_LENGTH,
    TI_GET_TYPE,
    TI_GET_TYPEID,
    TI_GET_BASETYPE,
    TI_GET_ARRAYINDEXTYPEID,
    TI_FINDCHILDREN,
    TI_GET_DATAKIND,
    TI_GET_ADDRESSOFFSET,
    TI_GET_OFFSET,
    TI_GET_VALUE,
    TI_GET_COUNT,
    TI_GET_CHILDRENCOUNT,
    TI_GET_BITPOSITION,
    TI_GET_VIRTUALBASECLASS,
    TI_GET_VIRTUALTABLESHAPEID,
    TI_GET_VIRTUALBASEPOINTEROFFSET,
    TI_GET_CLASSPARENTID,
    TI_GET_NESTED,
    TI_GET_SYMINDEX,
    TI_GET_LEXICALPARENT,
    TI_GET_ADDRESS,
} IMAGEHLP_SYMBOL_TYPE_INFO;

typedef struct _TI_FINDCHILDREN_PARAMS {
    ULONG Count;
    ULONG Start;
    ULONG ChildId[1];
} TI_FINDCHILDREN_PARAMS;

BOOL
IMAGEAPI
SymGetTypeInfo(
    IN  HANDLE          hProcess,
    IN  DWORD64         ModBase,
    IN  ULONG           TypeId,
    IN  IMAGEHLP_SYMBOL_TYPE_INFO GetType,
    OUT PVOID           pInfo
    );

typedef enum IMAGEHLP_ENUM_LISTS {
    IMG_ENUM_SYMBOLS,
    IMG_ENUM_LINES,
    IMG_ENUM_TABLES,
    IMG_ENUM_SEGMENTS,
} IMAGEHLP_ENUM_LISTS;

HRESULT
IMAGEAPI
SymGetNextEnumListMember(
    IN HANDLE               hProcess,
    IN DWORD64              ModBase,
    IN PVOID                pEnumList,
    IN IMAGEHLP_ENUM_LISTS  ListTag,
    OUT PVOID               pNext
    );

BOOL
IMAGEAPI
SymEnumTypes(
    IN HANDLE                       hProcess,
    IN ULONG64                      BaseOfDll,
    IN PSYM_ENUMERATESYMBOLS_CALLBACK    EnumSymbolsCallback,
    IN PVOID                        UserContext
    );

BOOL
IMAGEAPI
SymGetTypeFromName(
    IN  HANDLE              hProcess,
    IN  ULONG64             BaseOfDll,
    IN  LPSTR               Name,
    OUT PSYMBOL_INFO        Symbol
    );


#include <pshpack4.h>

#pragma warning(disable:4200) // Zero length array


#define MINIDUMP_SIGNATURE ('PMDM')
#define MINIDUMP_VERSION   (42899)
typedef DWORD RVA;
typedef ULONG64 RVA64;

typedef struct _MINIDUMP_LOCATION_DESCRIPTOR {
    ULONG32 DataSize;
    RVA Rva;
} MINIDUMP_LOCATION_DESCRIPTOR;

typedef struct _MINIDUMP_LOCATION_DESCRIPTOR64 {
    ULONG64 DataSize;
    RVA64 Rva;
} MINIDUMP_LOCATION_DESCRIPTOR64;


typedef struct _MINIDUMP_MEMORY_DESCRIPTOR {
    ULONG64 StartOfMemoryRange;
    MINIDUMP_LOCATION_DESCRIPTOR Memory;
} MINIDUMP_MEMORY_DESCRIPTOR, *PMINIDUMP_MEMORY_DESCRIPTOR;

// DESCRIPTOR64 is used for full-memory minidumps where
// all of the raw memory is laid out sequentially at the
// end of the dump.  There is no need for individual RVAs
// as the RVA is the base RVA plus the sum of the preceeding
// data blocks.
typedef struct _MINIDUMP_MEMORY_DESCRIPTOR64 {
    ULONG64 StartOfMemoryRange;
    ULONG64 DataSize;
} MINIDUMP_MEMORY_DESCRIPTOR64, *PMINIDUMP_MEMORY_DESCRIPTOR64;


typedef struct _MINIDUMP_HEADER {
    ULONG32 Signature;
    ULONG32 Version;
    ULONG32 NumberOfStreams;
    RVA StreamDirectoryRva;
    ULONG32 CheckSum;
    union {
        ULONG32 Reserved;
        ULONG32 TimeDateStamp;
    };
    ULONG64 Flags;
} MINIDUMP_HEADER, *PMINIDUMP_HEADER;

//
// The MINIDUMP_HEADER field StreamDirectoryRva points to 
// an array of MINIDUMP_DIRECTORY structures.
//

typedef struct _MINIDUMP_DIRECTORY {
    ULONG32 StreamType;
    MINIDUMP_LOCATION_DESCRIPTOR Location;
} MINIDUMP_DIRECTORY, *PMINIDUMP_DIRECTORY;


typedef struct _MINIDUMP_STRING {
    ULONG32 Length;         // Length in bytes of the string
    WCHAR   Buffer [0];     // Variable size buffer
} MINIDUMP_STRING, *PMINIDUMP_STRING;



//
// The MINIDUMP_DIRECTORY field StreamType may be one of the following types.
// Types will be added in the future, so if a program reading the minidump
// header encounters a stream type it does not understand it should ignore
// the data altogether. Any tag above LastReservedStream will not be used by
// the system and is reserved for program-specific information.
//

typedef enum _MINIDUMP_STREAM_TYPE {

    UnusedStream                = 0,
    ReservedStream0             = 1,
    ReservedStream1             = 2,
    ThreadListStream            = 3,
    ModuleListStream            = 4,
    MemoryListStream            = 5,
    ExceptionStream             = 6,
    SystemInfoStream            = 7,
    ThreadExListStream          = 8,
    Memory64ListStream          = 9,
    CommentStreamA              = 10,
    CommentStreamW              = 11,
    HandleDataStream            = 12,

    LastReservedStream          = 0xffff

} MINIDUMP_STREAM_TYPE;


//
// The minidump system information contains processor and
// Operating System specific information.
// 
    
typedef struct _MINIDUMP_SYSTEM_INFO {

    //
    // ProcessorArchitecture, ProcessorLevel and ProcessorRevision are all
    // taken from the SYSTEM_INFO structure obtained by GetSystemInfo( ).
    //
    
    USHORT ProcessorArchitecture;
    USHORT ProcessorLevel;
    USHORT ProcessorRevision;

    USHORT Reserved0;              // Reserved for future use. Must be zero.

    //
    // MajorVersion, MinorVersion, BuildNumber, PlatformId and
    // CSDVersion are all taken from the OSVERSIONINFO structure
    // returned by GetVersionEx( ).
    //
    
    ULONG32 MajorVersion;
    ULONG32 MinorVersion;
    ULONG32 BuildNumber;
    ULONG32 PlatformId;

    //
    // RVA to a CSDVersion string in the string table.
    //
    
    RVA CSDVersionRva;

    ULONG32 Reserved1;             // Reserved for future use.

    //
    // CPU information is obtained from one of two places.
    //
    //  1) On x86 computers, CPU_INFORMATION is obtained from the CPUID
    //     instruction. You must use the X86 portion of the union for X86
    //     computers.
    //
    //  2) On non-x86 architectures, CPU_INFORMATION is obtained by calling
    //     IsProcessorFeatureSupported().
    //
    
    union _CPU_INFORMATION {

        //
        // X86 platforms use CPUID function to obtain processor information.
        //
        
        struct {

            //
            // CPUID Subfunction 0, register EAX (VendorId [0]),
            // EBX (VendorId [1]) and ECX (VendorId [2]).
            //
            
            ULONG32 VendorId [ 3 ];
            
            //
            // CPUID Subfunction 1, register EAX
            //
            
            ULONG32 VersionInformation;

            //
            // CPUID Subfunction 1, register EDX
            //
            
            ULONG32 FeatureInformation;
            

            //
            // CPUID, Subfunction 80000001, register EBX. This will only
            // be obtained if the vendor id is "AuthenticAMD".
            //
            
            ULONG32 AMDExtendedCpuFeatures;
    
        } X86CpuInfo;

        //
        // Non-x86 platforms use processor feature flags.
        //
        
        struct {

            ULONG64 ProcessorFeatures [ 2 ];
            
        } OtherCpuInfo;
        
    } Cpu;

} MINIDUMP_SYSTEM_INFO, *PMINIDUMP_SYSTEM_INFO;

typedef union _CPU_INFORMATION CPU_INFORMATION, *PCPU_INFORMATION;


//
// The minidump thread contains standard thread
// information plus an RVA to the memory for this 
// thread and an RVA to the CONTEXT structure for
// this thread.
//


//
// ThreadId must be 4 bytes on all architectures.
//

C_ASSERT (sizeof ( ((PPROCESS_INFORMATION)0)->dwThreadId ) == 4);

typedef struct _MINIDUMP_THREAD {
    ULONG32 ThreadId;
    ULONG32 SuspendCount;
    ULONG32 PriorityClass;
    ULONG32 Priority;
    ULONG64 Teb;
    MINIDUMP_MEMORY_DESCRIPTOR Stack;
    MINIDUMP_LOCATION_DESCRIPTOR ThreadContext;
} MINIDUMP_THREAD, *PMINIDUMP_THREAD;

//
// The thread list is a container of threads.
//

typedef struct _MINIDUMP_THREAD_LIST {
    ULONG32 NumberOfThreads;
    MINIDUMP_THREAD Threads [0];
} MINIDUMP_THREAD_LIST, *PMINIDUMP_THREAD_LIST;


typedef struct _MINIDUMP_THREAD_EX {
    ULONG32 ThreadId;
    ULONG32 SuspendCount;
    ULONG32 PriorityClass;
    ULONG32 Priority;
    ULONG64 Teb;
    MINIDUMP_MEMORY_DESCRIPTOR Stack;
    MINIDUMP_LOCATION_DESCRIPTOR ThreadContext;
    MINIDUMP_MEMORY_DESCRIPTOR BackingStore;
} MINIDUMP_THREAD_EX, *PMINIDUMP_THREAD_EX;

//
// The thread list is a container of threads.
//

typedef struct _MINIDUMP_THREAD_EX_LIST {
    ULONG32 NumberOfThreads;
    MINIDUMP_THREAD_EX Threads [0];
} MINIDUMP_THREAD_EX_LIST, *PMINIDUMP_THREAD_EX_LIST;


//
// The MINIDUMP_EXCEPTION is the same as EXCEPTION on Win64.
//

typedef struct _MINIDUMP_EXCEPTION  {
    ULONG32 ExceptionCode;
    ULONG32 ExceptionFlags;
    ULONG64 ExceptionRecord;
    ULONG64 ExceptionAddress;
    ULONG32 NumberParameters;
    ULONG32 __unusedAlignment;
    ULONG64 ExceptionInformation [ EXCEPTION_MAXIMUM_PARAMETERS ];
} MINIDUMP_EXCEPTION, *PMINIDUMP_EXCEPTION;


//
// The exception information stream contains the id of the thread that caused
// the exception (ThreadId), the exception record for the exception
// (ExceptionRecord) and an RVA to the thread context where the exception
// occured.
//

typedef struct MINIDUMP_EXCEPTION_STREAM {
    ULONG32 ThreadId;
    ULONG32  __alignment;
    MINIDUMP_EXCEPTION ExceptionRecord;
    MINIDUMP_LOCATION_DESCRIPTOR ThreadContext;
} MINIDUMP_EXCEPTION_STREAM, *PMINIDUMP_EXCEPTION_STREAM;


//
// The MINIDUMP_MODULE contains information about a
// a specific module. It includes the CheckSum and
// the TimeDateStamp for the module so the module
// can be reloaded during the analysis phase.
//

typedef struct _MINIDUMP_MODULE {
    ULONG64 BaseOfImage;
    ULONG32 SizeOfImage;
    ULONG32 CheckSum;
    ULONG32 TimeDateStamp;
    RVA ModuleNameRva;
    VS_FIXEDFILEINFO VersionInfo;
    MINIDUMP_LOCATION_DESCRIPTOR CvRecord;
    MINIDUMP_LOCATION_DESCRIPTOR MiscRecord;
    ULONG64 Reserved0;                          // Reserved for future use.
    ULONG64 Reserved1;                          // Reserved for future use.
} MINIDUMP_MODULE, *PMINIDUMP_MODULE;   


//
// The minidump module list is a container for modules.
//

typedef struct _MINIDUMP_MODULE_LIST {
    ULONG32 NumberOfModules;
    MINIDUMP_MODULE Modules [ 0 ];
} MINIDUMP_MODULE_LIST, *PMINIDUMP_MODULE_LIST;


//
// Memory Ranges
//

typedef struct _MINIDUMP_MEMORY_LIST {
    ULONG32 NumberOfMemoryRanges;
    MINIDUMP_MEMORY_DESCRIPTOR MemoryRanges [0];
} MINIDUMP_MEMORY_LIST, *PMINIDUMP_MEMORY_LIST;

typedef struct _MINIDUMP_MEMORY64_LIST {
    ULONG64 NumberOfMemoryRanges;
    RVA64 BaseRva;
    MINIDUMP_MEMORY_DESCRIPTOR64 MemoryRanges [0];
} MINIDUMP_MEMORY64_LIST, *PMINIDUMP_MEMORY64_LIST;


//
// Support for user supplied exception information.
//

typedef struct _MINIDUMP_EXCEPTION_INFORMATION {
    DWORD ThreadId;
    PEXCEPTION_POINTERS ExceptionPointers;
    BOOL ClientPointers;
} MINIDUMP_EXCEPTION_INFORMATION, *PMINIDUMP_EXCEPTION_INFORMATION;


//
// Support for capturing system handle state at the time of the dump.
//

typedef struct _MINIDUMP_HANDLE_DESCRIPTOR {
    ULONG64 Handle;
    RVA TypeNameRva;
    RVA ObjectNameRva;
    ULONG Attributes;
    ULONG GrantedAccess;
    ULONG HandleCount;
    ULONG PointerCount;
} MINIDUMP_HANDLE_DESCRIPTOR, *PMINIDUMP_HANDLE_DESCRIPTOR;

typedef struct _MINIDUMP_HANDLE_DATA_STREAM {
    ULONG SizeOfHeader;
    ULONG SizeOfDescriptor;
    ULONG NumberOfDescriptors;
    ULONG Reserved;
} MINIDUMP_HANDLE_DATA_STREAM, *PMINIDUMP_HANDLE_DATA_STREAM;


//
// Support for arbitrary user-defined information.
//

typedef struct _MINIDUMP_USER_RECORD {
    ULONG32 Type;
    MINIDUMP_LOCATION_DESCRIPTOR Memory;
} MINIDUMP_USER_RECORD, *PMINIDUMP_USER_RECORD;


typedef struct _MINIDUMP_USER_STREAM {
    ULONG32 Type;
    ULONG BufferSize;
    PVOID Buffer;

} MINIDUMP_USER_STREAM, *PMINIDUMP_USER_STREAM;


typedef struct _MINIDUMP_USER_STREAM_INFORMATION {
    ULONG UserStreamCount;
    PMINIDUMP_USER_STREAM UserStreamArray;
} MINIDUMP_USER_STREAM_INFORMATION, *PMINIDUMP_USER_STREAM_INFORMATION;

//
// Callback support.
//

typedef enum _MINIDUMP_CALLBACK_TYPE {
    ModuleCallback,
    ThreadCallback,
    ThreadExCallback
} MINIDUMP_CALLBACK_TYPE;


typedef struct _MINIDUMP_THREAD_CALLBACK {
    ULONG ThreadId;
    HANDLE ThreadHandle;
    CONTEXT Context;
    ULONG SizeOfContext;
    ULONG64 StackBase;
    ULONG64 StackEnd;
} MINIDUMP_THREAD_CALLBACK, *PMINIDUMP_THREAD_CALLBACK;


typedef struct _MINIDUMP_THREAD_EX_CALLBACK {
    ULONG ThreadId;
    HANDLE ThreadHandle;
    CONTEXT Context;
    ULONG SizeOfContext;
    ULONG64 StackBase;
    ULONG64 StackEnd;
    ULONG64 BackingStoreBase;
    ULONG64 BackingStoreEnd;
} MINIDUMP_THREAD_EX_CALLBACK, *PMINIDUMP_THREAD_EX_CALLBACK;


typedef enum _THREAD_WRITE_FLAGS {
    ThreadWriteThread            = 0x0001,
    ThreadWriteStack             = 0x0002,
    ThreadWriteContext           = 0x0004,
    ThreadWriteBackingStore      = 0x0008,
    ThreadWriteInstructionWindow = 0x0010
} THREAD_WRITE_FLAGS;

typedef struct _MINIDUMP_MODULE_CALLBACK {
    PWCHAR FullPath;
    ULONG64 BaseOfImage;
    ULONG SizeOfImage;
    ULONG CheckSum;
    ULONG TimeDateStamp;
    VS_FIXEDFILEINFO VersionInfo;
    PVOID CvRecord; 
    ULONG SizeOfCvRecord;
    PVOID MiscRecord;
    ULONG SizeOfMiscRecord;
} MINIDUMP_MODULE_CALLBACK, *PMINIDUMP_MODULE_CALLBACK;


typedef enum _MODULE_WRITE_FLAGS {
    ModuleWriteModule       = 0x0001,
    ModuleWriteDataSeg      = 0x0002,
    ModuleWriteMiscRecord   = 0x0004
} MODULE_WRITE_FLAGS;


typedef struct _MINIDUMP_CALLBACK_INPUT {
    ULONG ProcessId;
    HANDLE ProcessHandle;
    ULONG CallbackType;
    union {
        MINIDUMP_THREAD_CALLBACK Thread;
        MINIDUMP_THREAD_EX_CALLBACK ThreadEx;
        MINIDUMP_MODULE_CALLBACK Module;
    };
} MINIDUMP_CALLBACK_INPUT, *PMINIDUMP_CALLBACK_INPUT;

typedef struct _MINIDUMP_CALLBACK_OUTPUT {
    union {
        ULONG ModuleWriteFlags;
        ULONG ThreadWriteFlags;
    };
} MINIDUMP_CALLBACK_OUTPUT, *PMINIDUMP_CALLBACK_OUTPUT;

        
//
// A normal minidump contains just the information
// necessary to capture stack traces for all of the
// existing threads in a process.
//
// A minidump with data segments includes all of the data
// sections from loaded modules in order to capture
// global variable contents.  This can make the dump much
// larger if many modules have global data.
//
// A minidump with full memory includes all of the accessible
// memory in the process and can be very large.  A minidump
// with full memory always has the raw memory data at the end
// of the dump so that the initial structures in the dump can
// be mapped directly without having to include the raw
// memory information.
//

typedef enum _MINIDUMP_TYPE {
    MiniDumpNormal         = 0x0000,
    MiniDumpWithDataSegs   = 0x0001,
    MiniDumpWithFullMemory = 0x0002,
    MiniDumpWithHandleData = 0x0004,
} MINIDUMP_TYPE;


//
// The minidump callback should modify the FieldsToWrite parameter to reflect
// what portions of the specified thread or module should be written to the
// file.
//

typedef
BOOL
(WINAPI * MINIDUMP_CALLBACK_ROUTINE) (
    IN PVOID CallbackParam,
    IN CONST PMINIDUMP_CALLBACK_INPUT CallbackInput,
    IN OUT PMINIDUMP_CALLBACK_OUTPUT CallbackOutput
    );

typedef struct _MINIDUMP_CALLBACK_INFORMATION {
    MINIDUMP_CALLBACK_ROUTINE CallbackRoutine;
    PVOID CallbackParam;
} MINIDUMP_CALLBACK_INFORMATION, *PMINIDUMP_CALLBACK_INFORMATION;



//++
//
// PVOID
// RVA_TO_ADDR(
//     PVOID Mapping,
//     ULONG Rva
//     )
//
// Routine Description:
//
//     Map an RVA that is contained within a mapped file to it's associated
//     flat address.
//
// Arguments:
//
//     Mapping - Base address of mapped file containing the RVA.
//
//     Rva - An Rva to fixup.
//
// Return Values:
//
//     A pointer to the desired data.
//
//--

#define RVA_TO_ADDR(Mapping,Rva) ((PVOID)(((ULONG_PTR) (Mapping)) + (Rva)))

BOOL
WINAPI
MiniDumpWriteDump(
    IN HANDLE hProcess,
    IN DWORD ProcessId,
    IN HANDLE hFile,
    IN MINIDUMP_TYPE DumpType,
    IN CONST PMINIDUMP_EXCEPTION_INFORMATION ExceptionParam, OPTIONAL
    IN CONST PMINIDUMP_USER_STREAM_INFORMATION UserStreamParam, OPTIONAL
    IN CONST PMINIDUMP_CALLBACK_INFORMATION CallbackParam OPTIONAL
    );

BOOL
WINAPI
MiniDumpReadDumpStream(
    IN PVOID BaseOfDump,
    IN ULONG StreamNumber,
    OUT PMINIDUMP_DIRECTORY * Dir, OPTIONAL
    OUT PVOID * StreamPointer, OPTIONAL
    OUT ULONG * StreamSize OPTIONAL
    );

#include <poppack.h>

#ifdef __cplusplus
}
#endif


#endif // _DBGHELP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\tools\stress\stressscheduler\inc\debugger.h ===
#ifndef DEBUGGER_H
#define DEBUGGER_H

#define UNICODE
#define _UNICODE

#include <stdio.h>
#include <windows.h>
#include <tchar.h>
#include <dbghelp.h>

//Flags used for the call back function
//Used as input for call back

//Exceptions
#define DEBUGGER_FIRST_CHANCE_EXCEPTION		0x00000001
#define DEBUGGER_SECOND_CHANCE_EXCEPTION	0x00000002

//Other
#define DEBUGGER_FAILED_ATTACH				0x00000000
#define DEBUGGER_CREATE_THREAD				0x00000004
#define DEBUGGER_CREATE_PROCESS				0x00000008
#define DEBUGGER_EXIT_THREAD				0x00000010
#define DEBUGGER_EXIT_PROCESS				0x00000020
#define DEBUGGER_LOAD_DLL					0x00000040
#define DEBUGGER_UNLOAD_DLL					0x00000080
#define DEBUGGER_OUTPUT_DEBUG_STRING		0x00000100
#define DEBUGGER_RIP_EVENT					0x00000200

//Used as output for call back
#define DEBUGGER_CONTINUE_NORMAL			0x00100000
#define DEBUGGER_CONTINUE_UNHANDLED			0x00200000
#define DEBUGGER_CONTINUE_STOP_DEBUGGING	0x00400000

//Used for CreateMiniDump
#define DEBUGGER_CREATE_MINI_DUMP			0x00010000
#define DEBUGGER_CREATE_FULL_MINI_DUMP		0x00020000


//////////////////////////////////////////////////////////////////////////////////////////
//The call back function that will be passed into the constructor.
//
//	Parameters:
//		DWORD dwFlags	-- Flags that define what the debugger is reporting.  See above for definitions.
//		LPVOID lpIn		-- An object that the debugger passes back.  BUGBUG: Document what is passed back for each event.
//		LPTSTR lpszFutureString		-- For future use.
//		LPVOID lpFuturePointer		-- For future use.
//
//	Return Value:
//		The call back is expected to return one of the flags marked for output above.
///////////////////////////////////////////////////////////////////////////////////////////
//DWORD (*_pfnCallback)(DWORD dwFlags, LPVOID lpIn, LPTSTR lpszFutureString, LPVOID lpFuturePointer);


//////////////////////////////////////////////////////////////////////////////////////////
// Structures used internally in the Debugger Class
//////////////////////////////////////////////////////////////////////////////////////////
struct THREAD_HANDLE_ID
{
	HANDLE		hThread;
	DWORD		dwThreadID;
	DWORD_PTR	pNext;
};
///////////////////////////////////////////////////////////////////////////////////////////
//Debugger Class
//	Constructor take a dwPID (process pid) and a pointer to a callback function.
//
//	public functions:
//
//		BOOL __cdecl Go()			--	Attaches to the process and starts the debuging.
//		BOOL __cdecl CreateMiniDump	--	Creates a mini or full user dump of the process.
//		BOOL __cdecl IsActive		--	Returns true if the debugger is attached and running.
//
///////////////////////////////////////////////////////////////////////////////////////////
class Debugger
{
	public:
		Debugger(DWORD dwPID, LPVOID pfnCallback);

		Debugger::Debugger(	LPTSTR lptszProgram, 
							DWORD dwCreateProcessFlags, 
							LPSTARTUPINFO lpStartupInfo, 
							PROCESS_INFORMATION* pProcessInfo, 
							VOID *pfnCallback);

		~Debugger();

		HANDLE __cdecl Go();

		BOOL __cdecl Debugger::CreateMiniDump(LPTSTR lptszDumpFile, LPTSTR lptszComment, DWORD dwType);

		BOOL __cdecl IsActive() { return _bDebuggerActive; }


	private:
		//Private Functions
		friend DWORD WINAPI DebugProcess(LPVOID lpParameter);
		friend BOOL __cdecl DebugString(Debugger *debuggerObject, LPTSTR lptszDebugString);

		VOID __cdecl Initialize(DWORD dwPID, VOID *pfnCallback);
		VOID __cdecl Debugger::Initialize(DWORD dwPid);
		
		VOID __cdecl EnableDebugPrivileges();
		BOOL __cdecl InitTokenAdjustmentFunctions(HMODULE *phAdvapi32);

		HANDLE __cdecl GetThreadHandleFromThreadIDList(THREAD_HANDLE_ID *pNewThreadHandleIDStruct);
		HANDLE __cdecl GetThreadHandleFromThreadID(DWORD dwThreadID);
		VOID __cdecl AddNodeToThreadHandleIDList(THREAD_HANDLE_ID *pNewThreadHandleIDStruct);
		VOID __cdecl CleanUpThreadHandleIDList();

		//NT Only Functions
		BOOL (WINAPI *g_lpfnOpenProcessToken)(HANDLE,DWORD,PHANDLE);
		BOOL (WINAPI *g_lpfnLookupPrivilegeValueA)(LPCTSTR,LPCTSTR,PLUID);
		BOOL (WINAPI *g_lpfnAdjustTokenPrivileges)(HANDLE,BOOL,PTOKEN_PRIVILEGES,DWORD,PTOKEN_PRIVILEGES,PDWORD);


		//Private Variables
		DWORD_PTR				_pThreadInfoList;				//linked list of thread information
		THREAD_HANDLE_ID*		_pThreadHandleIDStruct;			//used for storing thread info in linked list
		LPDEBUG_EVENT			_lpDebugEvent;					//current debug event
		BOOL					_bFirstDebugBreak;				//ignores the first break point set by DebugActiveProcess
		DWORD					_dwDebugAction;					//specifies what to do when a debug even occurs
		DWORD					_dwPID;							//pid of process being debugged
		HANDLE					_hProcess;						//handle of proces being debugged
		HANDLE					_hThread;						//current thread
		CONTEXT					_Context;						//last set context
		DWORD					_dwDebugThreadID;				//thread id of the debugger
		HANDLE					_hDebugThreadHandle;			//handle to the debugger thread
		BOOL					_bDebuggerActive;				//flag to determine whether the debugger is active

		LPTSTR					_lptszProgram;					//program to run
		DWORD					_dwCreateProcessFlags;			//flags to use for CreateProcess
		LPSTARTUPINFO			_lpStartupInfo;					//startup info for CreateProcess
		PROCESS_INFORMATION*	_pProcessInfo;					//process info for CreateProcess
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\tools\stress\stressscheduler\src\memstats.cpp ===
///////////////////////////////////////////////////////////////////////////
// File:  MemStats.cpp
//
// Copyright (c) 2001 Microsoft Corporation.  All Rights Reserved.
//
// Purpose:
//	MemStats.cpp: Helper functions that get's the system memory info.
//	Borrowed from EricI's memstats app.
//
// History:
//	03/21/01	DennisCh	Created
//
//////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////
// Includes
//////////////////////////////////////////////////////////////////////


//
// WIN32 headers
//

//
// Project headers
//
#include "MemStats.h"
#include "NetworkTools.h"


//////////////////////////////////////////////////////////////////////
//
// Globals and statics
//
//////////////////////////////////////////////////////////////////////

PDH_STATUS (WINAPI *g_lpfnPdhOpenQuery)(LPCSTR, DWORD_PTR, HQUERY *);
PDH_STATUS (WINAPI *g_lpfnPdhAddCounter)(HQUERY, LPCSTR, DWORD_PTR, HCOUNTER *);
PDH_STATUS (WINAPI *g_lpfnPdhCollectQueryData)(HQUERY);
PDH_STATUS (WINAPI *g_lpfnPdhGetFormattedCounterValue)(HCOUNTER, DWORD, LPDWORD, PPDH_FMT_COUNTERVALUE);
PDH_STATUS (WINAPI *g_lpfnPdhRemoveCounter)(HCOUNTER);
PDH_STATUS (WINAPI *g_lpfnPdhCloseQuery)(HQUERY);


////////////////////////////////////////////////////////////////////////////
//
BOOL InitPdhLibrary(HMODULE *phPdhLib)
{ 
    BOOL    bRet = FALSE;

    *phPdhLib = LoadLibrary(_T("pdh.dll"));

    if(!*phPdhLib)
    {
        goto exit;
    }

	if(!(g_lpfnPdhOpenQuery = (PDH_STATUS (WINAPI *)(LPCSTR, DWORD_PTR, HQUERY *))GetProcAddress(*phPdhLib,"PdhOpenQueryA") ))
	{
		// LogString(LOG_BOTH,"missing export: PdhOpenQueryA\n");
		goto exit;
	}
	if(!(g_lpfnPdhAddCounter = (PDH_STATUS (WINAPI *)(HQUERY, LPCSTR, DWORD_PTR, HCOUNTER *))GetProcAddress(*phPdhLib,"PdhAddCounterA") ))
	{
		// LogString(LOG_BOTH,"missing export: PdhAddCounterA\n");
		goto exit;
	}
	if(!(g_lpfnPdhCollectQueryData = (PDH_STATUS (WINAPI *)(HQUERY))GetProcAddress(*phPdhLib,"PdhCollectQueryData") ))
	{
		// LogString(LOG_BOTH,"missing export: PdhCollectQueryData\n");
		goto exit;
	}
	if(!(g_lpfnPdhGetFormattedCounterValue = (PDH_STATUS (WINAPI *)(HCOUNTER, DWORD, LPDWORD, PPDH_FMT_COUNTERVALUE))GetProcAddress(*phPdhLib,"PdhGetFormattedCounterValue") ))
	{
		// LogString(LOG_BOTH,"missing export: PdhGetFormattedCounterValue\n");
		goto exit;
	}
	if(!(g_lpfnPdhRemoveCounter = (PDH_STATUS (WINAPI *)(HCOUNTER))GetProcAddress(*phPdhLib,"PdhRemoveCounter") ))
	{
		// LogString(LOG_BOTH,"missing export: PdhRemoveCounter\n");
		goto exit;
	}
	if(!(g_lpfnPdhCloseQuery = (PDH_STATUS (WINAPI *)(HQUERY))GetProcAddress(*phPdhLib,"PdhCloseQuery") ))
	{
		// LogString(LOG_BOTH,"missing export: PdhCloseQuery\n");
		goto exit;
	}
	
    bRet = TRUE;

exit:

    return bRet;
}


////////////////////////////////////////////////////////////
// Function:  EnableDebugPrivileges()
//
// Purpose:
//	Allows access to all processes.
//
////////////////////////////////////////////////////////////
void EnableDebugPrivileges()
{
    PTOKEN_PRIVILEGES   NewPrivileges   = NULL;
    HANDLE              hToken          = NULL;
    BYTE                OldPriv[1024];
    PBYTE               pbOldPriv;
    ULONG               cbNeeded;
    LUID                LuidPrivilege;


  //
    // Make sure we have access to adjust and to get the old token privileges
    //
    if(!OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &hToken)) 
    {
        // LogString(LOG_BOTH,"OpenProcessToken failed in EnableDebugPrivileges");
        goto exit;
    }

    cbNeeded = 0;

    //
    // Initialize the privilege adjustment structure
    //
	LookupPrivilegeValue(NULL,SE_DEBUG_NAME,&LuidPrivilege );

    NewPrivileges = (PTOKEN_PRIVILEGES)LocalAlloc(LMEM_ZEROINIT,sizeof(TOKEN_PRIVILEGES) + (1 - ANYSIZE_ARRAY) * sizeof(LUID_AND_ATTRIBUTES));
 
    if(!NewPrivileges) 
    {
        //  LogString(LOG_BOTH,"LocalAlloc failed in EnableDebugPrivileges");
        goto exit;
    }

    NewPrivileges->PrivilegeCount = 1;
    NewPrivileges->Privileges[0].Luid = LuidPrivilege;
    NewPrivileges->Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

    pbOldPriv = OldPriv;

    //
    // Enable the privilege
    //
    if(!AdjustTokenPrivileges(hToken,FALSE,NewPrivileges,1024,(PTOKEN_PRIVILEGES)pbOldPriv,&cbNeeded))
    {
        // LogString(LOG_BOTH,"AdjustTokenPrivileges #1 failed in EnableDebugPrivileges");

        //
        // If the stack was too small to hold the privileges then allocate off the heap
        //
        if(GetLastError() == ERROR_INSUFFICIENT_BUFFER)
        {
            pbOldPriv = (PBYTE) LocalAlloc(LMEM_FIXED, cbNeeded);

            if(!pbOldPriv) 
            {
                // LogString(LOG_BOTH,"LocalAlloc failed in EnableDebugPrivileges");
                goto exit;
            }

            if(!AdjustTokenPrivileges(hToken,FALSE,NewPrivileges,cbNeeded,(PTOKEN_PRIVILEGES)pbOldPriv, &cbNeeded ))
                // LogString(LOG_BOTH,"AdjustTokenPrivileges #2 failed in EnableDebugPrivileges");

            LocalFree(pbOldPriv);
        }
    }


exit:

    if(NewPrivileges)
        LocalFree(NewPrivileges);

    if(hToken)
        CloseHandle(hToken);

    return;
}


////////////////////////////////////////////////////////////
// Function:  GetProcCntrs(PROC_CNTRS, INT, CHAR)
//
// Purpose:
//	Gets and returns the memory info for a given process.
//
////////////////////////////////////////////////////////////
BOOL
GetProcCntrs(
	PROC_CNTRS	*pProcCntrs,	// [OUT]	process memory counters
	INT			nIndex,			// [IN]		The index of the process if there's more than one.
	CHAR		*szProcess		// [IN]		Name of the process. ex "iexplore", "explorer"
)
{
	BOOL						bRet = FALSE;
	INT							n;
	HQUERY						hQuery = 0;
    HCOUNTER					aryHCounter [PROCCOUNTERS] = {0};
	PDH_FMT_COUNTERVALUE		cntVal;
	CHAR						myProcessCntrs[PROCCOUNTERS][1024];
	DWORD						dwPathSize = MAX_PATH;

	sprintf(myProcessCntrs[0],"\\Process(%s#%d)\\ID Process",szProcess,nIndex);
	sprintf(myProcessCntrs[1],"\\Process(%s#%d)\\Private bytes",szProcess,nIndex);
	sprintf(myProcessCntrs[2],"\\Process(%s#%d)\\Handle count",szProcess,nIndex);
	sprintf(myProcessCntrs[3],"\\Process(%s#%d)\\Thread count",szProcess,nIndex);


	if(!(ERROR_SUCCESS == g_lpfnPdhOpenQuery(0, 0, &hQuery)))
	   goto exit;

	for (n = 0; n < PROCCOUNTERS; n++) 
	{ 
		if(!(ERROR_SUCCESS == g_lpfnPdhAddCounter(hQuery,  myProcessCntrs[n], 0, &aryHCounter[n])))
			goto exit;
	}

	if(!(ERROR_SUCCESS == g_lpfnPdhCollectQueryData(hQuery)))
		goto exit;

	for (n=0; n < PROCCOUNTERS; n++) 
	{ 
		if(!(ERROR_SUCCESS == g_lpfnPdhGetFormattedCounterValue (aryHCounter[n],PDH_FMT_LONG,0,&cntVal)))
			goto exit;
        *((ULONG*)pProcCntrs+n) = cntVal.longValue;
	} 

	bRet = TRUE;

exit:
	for(n=0;n<PROCCOUNTERS;n++)
		if(aryHCounter[n])
			g_lpfnPdhRemoveCounter(aryHCounter[n]);

	if(hQuery)
		g_lpfnPdhCloseQuery(hQuery);

	return bRet;
}


////////////////////////////////////////////////////////////
// Function:  GetInfoForPID(PROC_CNTRS, ULONG, CHAR)
//
// Purpose:
//	Gets and returns the memory info for a given process.
//	We do this by going through every process with the same
//	name and comparing the PIDs.
//
////////////////////////////////////////////////////////////
BOOL
GetInfoForPID(
	PROC_CNTRS	*pc,		// [OUT]	Process memory counters for the PID
	ULONG		lPID,		// [IN]		PID for the process to query
	CHAR		*szProcess	// [IN]		Process name of the PID to query. ex. "explore", "iexplore". Don't include the extension
)
{
	BOOL	bRet = TRUE;
	INT		n = 0;
	
	while(bRet)
	{
		bRet = GetProcCntrs(pc,n,szProcess);
		if(lPID == pc->lPID)
			break;

		n++;
	}

	return bRet;
}



////////////////////////////////////////////////////////////
// Function:  GetMemoryCounters(MEM_CNTRS)
//
// Purpose:
//	Gets and returns the memory info for the system.
//
////////////////////////////////////////////////////////////
BOOL
GetMemoryCounters(
	MEM_CNTRS *pMemCounters	// [OUT] Memory counters for the current machine
)
{
	BOOL						bRet                        = FALSE;
	HQUERY						hQuery                      = 0;
    HCOUNTER					aryHCounter[MEMCOUNTERS]    = {0};
	DWORD						dwPathSize                  = MAX_PATH;
	int							n;
	PDH_FMT_COUNTERVALUE		cntVal;
	char						szAryMemoryCntrs[MEMCOUNTERS][1024];

	sprintf(szAryMemoryCntrs[0],"\\Memory\\Committed Bytes");
	sprintf(szAryMemoryCntrs[1],"\\Memory\\Commit Limit");
	sprintf(szAryMemoryCntrs[2],"\\Memory\\System Code Total Bytes");
	sprintf(szAryMemoryCntrs[3],"\\Memory\\System Driver Total Bytes");
	sprintf(szAryMemoryCntrs[4],"\\Memory\\Pool Nonpaged Bytes");
	sprintf(szAryMemoryCntrs[5],"\\Memory\\Pool Paged Bytes");
	sprintf(szAryMemoryCntrs[6],"\\Memory\\Available Bytes");
	sprintf(szAryMemoryCntrs[7],"\\Memory\\Cache Bytes");
	sprintf(szAryMemoryCntrs[8],"\\Memory\\Free System Page Table Entries");


	if(!(ERROR_SUCCESS == g_lpfnPdhOpenQuery (0, 0, &hQuery)))
	   goto exit;

	for (n = 0; n < MEMCOUNTERS; n++) 
	{ 
		if(!(ERROR_SUCCESS == g_lpfnPdhAddCounter (hQuery,  szAryMemoryCntrs[n], 0, &aryHCounter[n])))
        {
			goto exit;
        }
	}

	if(!(ERROR_SUCCESS == g_lpfnPdhCollectQueryData(hQuery)))
		goto exit;

	for (n=0; n < MEMCOUNTERS; n++) 
	{ 
		if(!(ERROR_SUCCESS == g_lpfnPdhGetFormattedCounterValue (aryHCounter[n],PDH_FMT_LONG,0,&cntVal)))
        {
			goto exit;
        }
        *((ULONG*)pMemCounters+n) = cntVal.longValue;
	} 

	bRet = TRUE;

exit:
	for(n=0;n<MEMCOUNTERS;n++)
    {
		if(aryHCounter[n])
        {
			g_lpfnPdhRemoveCounter(aryHCounter[n]);
        }
    }

	if(hQuery)
		g_lpfnPdhCloseQuery(hQuery);

	return bRet;
}


////////////////////////////////////////////////////////////
// Function:  GetAvailableSystemDriveSpace(long)
//
// Purpose:
//	Gets and returns the disk space available on the system drive.
//
////////////////////////////////////////////////////////////
BOOL 
GetAvailableSystemDriveSpace(
	long	*lAvail		// [OUT] Buffer containing the space on the system drive
)
{
    BOOL                bRet    = FALSE;
    char                szSystemPath[MAX_PATH];
    ULARGE_INTEGER      FreeBytesAvailable;         // bytes available to caller
    ULARGE_INTEGER      TotalNumberOfBytes;         // bytes on disk
    ULARGE_INTEGER      TotalNumberOfFreeBytes;     // free bytes on disk
    int                 i;
    DWORD               dwFoo = 0;

    if(!GetSystemDirectoryA(szSystemPath,sizeof(szSystemPath)))
    {
        goto exit;
    }

    //We only want the drive letter
    for(i=0; i<1+lstrlenA(szSystemPath); i++)
    {
        if(szSystemPath[i] == 0)
        {
            goto exit;
        }

        if(szSystemPath[i] == '\\')
        {
            szSystemPath[i+1] = 0;
            break;
        }
    }

    if(GetDiskFreeSpaceExA(szSystemPath,&FreeBytesAvailable,&TotalNumberOfBytes,&TotalNumberOfFreeBytes))
    {
        *lAvail = __int32(TotalNumberOfFreeBytes.QuadPart / 1024 / 1000);
        bRet = TRUE;
    }

exit:
    return bRet;
}


////////////////////////////////////////////////////////////
// Function:  MemStats__SendSystemMemoryLog(LPSTR, DWORD, DWORD)
//
// Purpose:
//	Sends a memory log to the Command Server.
//	Sends the stressInstance ID and client machine name as part of the POST request.
//
////////////////////////////////////////////////////////////
BOOL
MemStats__SendSystemMemoryLog(
	LPSTR szExeName,			// [IN] Name of the process. ex. "explorer", "iexplorer". No extension.
	DWORD dwPID,				// [IN] PID for the above process
	DWORD dwStressInstanceID	// [IN] The stress instanceID
)
{
    BOOL            bResult				= TRUE;
    MEM_CNTRS       mc					= {0};
    long			lAvailDriveSpace	= 0;
	HMODULE         hPdhLib				= NULL;
	DWORD			dwPostDataSize		= MAX_PATH*10;
	DWORD			dwDataFieldSize		= 100;
	LPSTR			szPostData			= NULL;
	LPSTR			szDataField			= NULL;
	LPSTR			szFileName			= NULL;
	PROC_CNTRS		pc;

	szPostData			= new CHAR[dwPostDataSize];
	szDataField			= new CHAR[dwDataFieldSize];
	szFileName			= new CHAR[MAX_PATH];
	if (!szPostData || !szDataField || !szFileName)
		goto Exit;

	// Remove the extension from the filename if there is one
	ZeroMemory(szFileName, MAX_PATH);
	strncpy(szFileName, szExeName, MAX_PATH);
	PathRemoveExtensionA(szFileName);


	ZeroMemory(szPostData,	dwPostDataSize);
	ZeroMemory(szDataField,	dwDataFieldSize);


	// *** !!! need this because NetworkTools__SendLog(...) sends szPost data as fieldname "LogText="
	// so we need an & to delimit memory info fields from "real" log text.
	strcat(szPostData, "&");

	// *************************
	// *************************
	// ** Get process info
	// **
    if(!InitPdhLibrary(&hPdhLib))
	{
		OutputDebugString(_T("MemStats__SendSystemMemoryLog: Could not load PDH.DLL. Exiting..."));
		bResult = FALSE;
        goto Exit;
	}


	EnableDebugPrivileges();

	if (szFileName && GetInfoForPID(&pc, dwPID, szFileName))
	{
		sprintf(szDataField, FIELDNAME__STRESSEXE_HANDLECOUNT,		pc.lHandles);
		strcat(szPostData, szDataField);
		strcat(szPostData, "&");

		sprintf(szDataField, FIELDNAME__STRESSEXE_THREADCOUNT,		pc.lThreads);
		strcat(szPostData, szDataField);
		strcat(szPostData, "&");

		sprintf(szDataField, FIELDNAME__STRESSEXE_PRIVATEBYTES,		pc.lPrivBytes);
		strcat(szPostData, szDataField);
		strcat(szPostData, "&");
	}

	// *************************
	// *************************
	// ** Get system memory info
	// **
	if (GetMemoryCounters(&mc))
    {
		sprintf(szDataField, FIELDNAME__MEMORY_COMMITTEDPAGEFILETOTAL,		mc.lCommittedBytes/1024);
		strcat(szPostData, szDataField);
		strcat(szPostData, "&");

		sprintf(szDataField, FIELDNAME__MEMORY_AVAILABLEPAGEFILETOTAL,		(mc.lCommitLimit - mc.lCommittedBytes)/1024);
		strcat(szPostData, szDataField);
		strcat(szPostData, "&");
		
		sprintf(szDataField, FIELDNAME__MEMORY_SYSTEMCODETOTAL,				mc.lSystemCodeTotalBytes/1024);
		strcat(szPostData, szDataField);
		strcat(szPostData, "&");
		
		sprintf(szDataField, FIELDNAME__MEMORY_SYSTEMDRIVERTOTAL,			mc.lSystemDriverTotalBytes/1024);
		strcat(szPostData, szDataField);
		strcat(szPostData, "&");
		
		sprintf(szDataField, FIELDNAME__MEMORY_NONPAGEDPOOLTOTAL,			mc.lPoolNonpagedBytes/1024);
		strcat(szPostData, szDataField);
		strcat(szPostData, "&");
		
		sprintf(szDataField, FIELDNAME__MEMORY_PAGEDPOOLTOTAL,				mc.lPoolPagedBytes/1024);
		strcat(szPostData, szDataField);
		strcat(szPostData, "&");
		
		sprintf(szDataField, FIELDNAME__MEMORY_PHYSICAL_MEMORY_AVAILABLE,	mc.lAvailableBytes/1024);
		strcat(szPostData, szDataField);
		strcat(szPostData, "&");
		
		sprintf(szDataField, FIELDNAME__MEMORY_SYSTEMCACHETOTAL,			mc.lCacheBytes/1024);
		strcat(szPostData, szDataField);
		strcat(szPostData, "&");
		
		sprintf(szDataField, FIELDNAME__MEMORY_FREESYSTEM_PAGETABLE_ENTRIES,mc.lFreeSystemPageTableEntries);
		strcat(szPostData, szDataField);
		strcat(szPostData, "&");
    }


	// *************************
	// *************************
	// ** Get disk space info
	// **
    if (GetAvailableSystemDriveSpace(&lAvailDriveSpace))
	{
		sprintf(szDataField, FIELDNAME__MEMORY_DISK_SPACE_AVAILABLE, lAvailDriveSpace);
		strcat(szPostData, szDataField);
		strcat(szPostData, "&");
	}

	NetworkTools__SendLog(FIELDNAME__LOGTYPE_MEMORY_INFORMATION, szPostData, NULL, dwStressInstanceID);


Exit:
	if(hPdhLib)
        FreeLibrary(hPdhLib);

	if (szPostData)
		delete [] szPostData;

	if (szDataField)
		delete [] szDataField;

	if (szFileName)
		delete [] szFileName;

    return bResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\tools\stress\stressapps\asyncwebcrawler\utils.cpp ===
// utility/miscellaneous functions for the crawler test app

#include "crawler.h"

WCHAR*
__ansitowide(const char* psz)
{
  WCHAR* wide = NULL;
  int    len  = 0L;

  if( psz )
  {
    len = strlen(psz);

    if( len )
    {
      wide = new WCHAR[len+1];

      if( !wide )
        return NULL;

      wide[len] = L'\0';

      MultiByteToWideChar(
        CP_ACP, 0,
        psz,  len,
        wide, len
        );
    }
  }

  return wide;
}

CHAR*
__widetoansi(const WCHAR* pwsz)
{
  CHAR* ansi = NULL;
  int   len  = 0L;
  BOOL  def  = FALSE;

  if( pwsz )
  {
    len = wcslen(pwsz);

    if( len )
    {
      ansi = new CHAR[len+1];

      if( !ansi )
        return NULL;

      ansi[len] = '\0';

      WideCharToMultiByte(
        CP_ACP, 0,
        pwsz, len,
        ansi, len,
        "?", &def
        );
    }
  }

  return ansi;
}

int
DataDumpFormat(LPSTR buffer, LPBYTE data, DWORD len)
{
  static char spaces[] = "                                               ";

  DWORD n      = 0L;
  DWORD bytes  = 0L;
  DWORD offset = 0L;
  DWORD byte   = 0L;
  CHAR  ch;

  bytes  = min(len, 16);
  offset = wsprintfA(buffer, "[tid=%#0.8x] %08x  ", GetCurrentThreadId(), data);

  for(n=0; n<bytes; n++)
  {
    byte    = data[n] & 0xFF;

    offset += wsprintfA(
                buffer+offset,
                ((n & 15) == 7 ? "%02.2x-" : "%02.2x "),
                byte                
                );
  }

  memcpy(buffer+offset, spaces, (16-bytes) * 3 + 2);
  offset += (16-bytes) * 3 + 2;

  for(n=0; n<bytes; n++)
  {
    ch = data[n];
    buffer[offset + n] =  (((ch < 32) || (ch > 127)) || ch == '%') ? '.' : ch;
  }

  buffer[offset + n] = '\0';

  return bytes;
}


void
DataDump(LPBYTE data, DWORD len)
{
  DWORD n      = 0L;
  DWORD offset = 0L;
  CHAR* buf    = NULL;

  buf = new CHAR[256];

    while( len )
    {
      n = DataDumpFormat(buf, data, len);

      printf("%s\r\n", buf);

      data += n;
      len  -= n;
    }

  delete [] buf;
}


LPSTR
MapErrorToString(int error)
{
  switch(error)
  {
    CASE_OF(ERROR_WINHTTP_OUT_OF_HANDLES);
    CASE_OF(ERROR_WINHTTP_TIMEOUT);
    CASE_OF(ERROR_WINHTTP_INTERNAL_ERROR);
    CASE_OF(ERROR_WINHTTP_INVALID_URL);
    CASE_OF(ERROR_WINHTTP_UNRECOGNIZED_SCHEME);
    CASE_OF(ERROR_WINHTTP_NAME_NOT_RESOLVED);
    CASE_OF(ERROR_WINHTTP_INVALID_OPTION);
    CASE_OF(ERROR_WINHTTP_OPTION_NOT_SETTABLE);
    CASE_OF(ERROR_WINHTTP_SHUTDOWN);
    CASE_OF(ERROR_WINHTTP_LOGIN_FAILURE);
    CASE_OF(ERROR_WINHTTP_OPERATION_CANCELLED);
    CASE_OF(ERROR_WINHTTP_INCORRECT_HANDLE_TYPE);
    CASE_OF(ERROR_WINHTTP_INCORRECT_HANDLE_STATE);
    CASE_OF(ERROR_WINHTTP_CANNOT_CONNECT);
    CASE_OF(ERROR_WINHTTP_CONNECTION_ERROR);
    CASE_OF(ERROR_WINHTTP_RESEND_REQUEST);
    CASE_OF(ERROR_WINHTTP_CLIENT_AUTH_CERT_NEEDED);
    CASE_OF(ERROR_WINHTTP_HEADER_NOT_FOUND);
    CASE_OF(ERROR_WINHTTP_INVALID_SERVER_RESPONSE);
    CASE_OF(ERROR_WINHTTP_INVALID_QUERY_REQUEST);
    CASE_OF(ERROR_WINHTTP_HEADER_ALREADY_EXISTS);
    CASE_OF(ERROR_WINHTTP_REDIRECT_FAILED);
    CASE_OF(ERROR_WINHTTP_NOT_INITIALIZED);
    CASE_OF(ERROR_WINHTTP_SECURE_FAILURE);

    CASE_OF(ERROR_SUCCESS);
    CASE_OF(ERROR_INVALID_FUNCTION);
    CASE_OF(ERROR_FILE_NOT_FOUND);
    CASE_OF(ERROR_PATH_NOT_FOUND);
    CASE_OF(ERROR_TOO_MANY_OPEN_FILES);
    CASE_OF(ERROR_ACCESS_DENIED);
    CASE_OF(ERROR_INVALID_HANDLE);
    CASE_OF(ERROR_ARENA_TRASHED);
    CASE_OF(ERROR_NOT_ENOUGH_MEMORY);
    CASE_OF(ERROR_INVALID_BLOCK);
    CASE_OF(ERROR_BAD_ENVIRONMENT);
    CASE_OF(ERROR_BAD_FORMAT);
    CASE_OF(ERROR_INVALID_ACCESS);
    CASE_OF(ERROR_INVALID_DATA);
    CASE_OF(ERROR_OUTOFMEMORY);
    CASE_OF(ERROR_INVALID_DRIVE);
    CASE_OF(ERROR_CURRENT_DIRECTORY);
    CASE_OF(ERROR_NOT_SAME_DEVICE);
    CASE_OF(ERROR_NO_MORE_FILES);
    CASE_OF(ERROR_WRITE_PROTECT);
    CASE_OF(ERROR_BAD_UNIT);
    CASE_OF(ERROR_NOT_READY);
    CASE_OF(ERROR_BAD_COMMAND);
    CASE_OF(ERROR_CRC);
    CASE_OF(ERROR_BAD_LENGTH);
    CASE_OF(ERROR_SEEK);
    CASE_OF(ERROR_NOT_DOS_DISK);
    CASE_OF(ERROR_SECTOR_NOT_FOUND);
    CASE_OF(ERROR_OUT_OF_PAPER);
    CASE_OF(ERROR_WRITE_FAULT);
    CASE_OF(ERROR_READ_FAULT);
    CASE_OF(ERROR_GEN_FAILURE);
    CASE_OF(ERROR_SHARING_VIOLATION);
    CASE_OF(ERROR_LOCK_VIOLATION);
    CASE_OF(ERROR_WRONG_DISK);
    CASE_OF(ERROR_SHARING_BUFFER_EXCEEDED);
    CASE_OF(ERROR_HANDLE_EOF);
    CASE_OF(ERROR_HANDLE_DISK_FULL);
    CASE_OF(ERROR_NOT_SUPPORTED);
    CASE_OF(ERROR_REM_NOT_LIST);
    CASE_OF(ERROR_DUP_NAME);
    CASE_OF(ERROR_BAD_NETPATH);
    CASE_OF(ERROR_NETWORK_BUSY);
    CASE_OF(ERROR_DEV_NOT_EXIST);
    CASE_OF(ERROR_TOO_MANY_CMDS);
    CASE_OF(ERROR_ADAP_HDW_ERR);
    CASE_OF(ERROR_BAD_NET_RESP);
    CASE_OF(ERROR_UNEXP_NET_ERR);
    CASE_OF(ERROR_BAD_REM_ADAP);
    CASE_OF(ERROR_PRINTQ_FULL);
    CASE_OF(ERROR_NO_SPOOL_SPACE);
    CASE_OF(ERROR_PRINT_CANCELLED);
    CASE_OF(ERROR_NETNAME_DELETED);
    CASE_OF(ERROR_NETWORK_ACCESS_DENIED);
    CASE_OF(ERROR_BAD_DEV_TYPE);
    CASE_OF(ERROR_BAD_NET_NAME);
    CASE_OF(ERROR_TOO_MANY_NAMES);
    CASE_OF(ERROR_TOO_MANY_SESS);
    CASE_OF(ERROR_SHARING_PAUSED);
    CASE_OF(ERROR_REQ_NOT_ACCEP);
    CASE_OF(ERROR_REDIR_PAUSED);
    CASE_OF(ERROR_FILE_EXISTS);
    CASE_OF(ERROR_CANNOT_MAKE);
    CASE_OF(ERROR_FAIL_I24);
    CASE_OF(ERROR_OUT_OF_STRUCTURES);
    CASE_OF(ERROR_ALREADY_ASSIGNED);
    CASE_OF(ERROR_INVALID_PASSWORD);
    CASE_OF(ERROR_INVALID_PARAMETER);
    CASE_OF(ERROR_NET_WRITE_FAULT);
    CASE_OF(ERROR_NO_PROC_SLOTS);
    CASE_OF(ERROR_TOO_MANY_SEMAPHORES);
    CASE_OF(ERROR_EXCL_SEM_ALREADY_OWNED);
    CASE_OF(ERROR_SEM_IS_SET);
    CASE_OF(ERROR_TOO_MANY_SEM_REQUESTS);
    CASE_OF(ERROR_INVALID_AT_INTERRUPT_TIME);
    CASE_OF(ERROR_SEM_OWNER_DIED);
    CASE_OF(ERROR_SEM_USER_LIMIT);
    CASE_OF(ERROR_DISK_CHANGE);
    CASE_OF(ERROR_DRIVE_LOCKED);
    CASE_OF(ERROR_BROKEN_PIPE);
    CASE_OF(ERROR_OPEN_FAILED);
    CASE_OF(ERROR_BUFFER_OVERFLOW);
    CASE_OF(ERROR_DISK_FULL);
    CASE_OF(ERROR_NO_MORE_SEARCH_HANDLES);
    CASE_OF(ERROR_INVALID_TARGET_HANDLE);
    CASE_OF(ERROR_INVALID_CATEGORY);
    CASE_OF(ERROR_INVALID_VERIFY_SWITCH);
    CASE_OF(ERROR_BAD_DRIVER_LEVEL);
    CASE_OF(ERROR_CALL_NOT_IMPLEMENTED);
    CASE_OF(ERROR_SEM_TIMEOUT);
    CASE_OF(ERROR_INSUFFICIENT_BUFFER);
    CASE_OF(ERROR_INVALID_NAME);
    CASE_OF(ERROR_INVALID_LEVEL);
    CASE_OF(ERROR_NO_VOLUME_LABEL);
    CASE_OF(ERROR_MOD_NOT_FOUND);
    CASE_OF(ERROR_PROC_NOT_FOUND);
    CASE_OF(ERROR_WAIT_NO_CHILDREN);
    CASE_OF(ERROR_CHILD_NOT_COMPLETE);
    CASE_OF(ERROR_DIRECT_ACCESS_HANDLE);
    CASE_OF(ERROR_NEGATIVE_SEEK);
    CASE_OF(ERROR_SEEK_ON_DEVICE);
    CASE_OF(ERROR_DIR_NOT_ROOT);
    CASE_OF(ERROR_DIR_NOT_EMPTY);
    CASE_OF(ERROR_PATH_BUSY);
    CASE_OF(ERROR_SYSTEM_TRACE);
    CASE_OF(ERROR_INVALID_EVENT_COUNT);
    CASE_OF(ERROR_TOO_MANY_MUXWAITERS);
    CASE_OF(ERROR_INVALID_LIST_FORMAT);
    CASE_OF(ERROR_BAD_ARGUMENTS);
    CASE_OF(ERROR_BAD_PATHNAME);
    CASE_OF(ERROR_BUSY);
    CASE_OF(ERROR_CANCEL_VIOLATION);
    CASE_OF(ERROR_ALREADY_EXISTS);
    CASE_OF(ERROR_FILENAME_EXCED_RANGE);
    CASE_OF(ERROR_LOCKED);
    CASE_OF(ERROR_NESTING_NOT_ALLOWED);
    CASE_OF(ERROR_BAD_PIPE);
    CASE_OF(ERROR_PIPE_BUSY);
    CASE_OF(ERROR_NO_DATA);
    CASE_OF(ERROR_PIPE_NOT_CONNECTED);
    CASE_OF(ERROR_MORE_DATA);
    CASE_OF(ERROR_NO_MORE_ITEMS);
    CASE_OF(ERROR_NOT_OWNER);
    CASE_OF(ERROR_PARTIAL_COPY);
    CASE_OF(ERROR_MR_MID_NOT_FOUND);
    CASE_OF(ERROR_INVALID_ADDRESS);
    CASE_OF(ERROR_PIPE_CONNECTED);
    CASE_OF(ERROR_PIPE_LISTENING);
    CASE_OF(ERROR_OPERATION_ABORTED);
    CASE_OF(ERROR_IO_INCOMPLETE);
    CASE_OF(ERROR_IO_PENDING);
    CASE_OF(ERROR_NOACCESS);
    CASE_OF(ERROR_STACK_OVERFLOW);
    CASE_OF(ERROR_INVALID_FLAGS);
    CASE_OF(ERROR_NO_TOKEN);
    CASE_OF(ERROR_BADDB);
    CASE_OF(ERROR_BADKEY);
    CASE_OF(ERROR_CANTOPEN);
    CASE_OF(ERROR_CANTREAD);
    CASE_OF(ERROR_CANTWRITE);
    CASE_OF(ERROR_REGISTRY_RECOVERED);
    CASE_OF(ERROR_REGISTRY_CORRUPT);
    CASE_OF(ERROR_REGISTRY_IO_FAILED);
    CASE_OF(ERROR_NOT_REGISTRY_FILE);
    CASE_OF(ERROR_KEY_DELETED);
    CASE_OF(ERROR_CIRCULAR_DEPENDENCY);
    CASE_OF(ERROR_SERVICE_NOT_ACTIVE);
    CASE_OF(ERROR_DLL_INIT_FAILED);
    CASE_OF(ERROR_CANCELLED);
    CASE_OF(ERROR_BAD_USERNAME);
    CASE_OF(ERROR_LOGON_FAILURE);

    CASE_OF(WAIT_FAILED);
    CASE_OF(WAIT_TIMEOUT);
    CASE_OF(WAIT_IO_COMPLETION);

    CASE_OF(EXCEPTION_ACCESS_VIOLATION);
    CASE_OF(EXCEPTION_DATATYPE_MISALIGNMENT);
    CASE_OF(EXCEPTION_BREAKPOINT);
    CASE_OF(EXCEPTION_SINGLE_STEP);
    CASE_OF(EXCEPTION_ARRAY_BOUNDS_EXCEEDED);
    CASE_OF(EXCEPTION_FLT_DENORMAL_OPERAND);
    CASE_OF(EXCEPTION_FLT_DIVIDE_BY_ZERO);
    CASE_OF(EXCEPTION_FLT_INEXACT_RESULT);
    CASE_OF(EXCEPTION_FLT_INVALID_OPERATION);
    CASE_OF(EXCEPTION_FLT_OVERFLOW);
    CASE_OF(EXCEPTION_FLT_STACK_CHECK);
    CASE_OF(EXCEPTION_FLT_UNDERFLOW);
    CASE_OF(EXCEPTION_INT_DIVIDE_BY_ZERO);
    CASE_OF(EXCEPTION_INT_OVERFLOW);
    CASE_OF(EXCEPTION_PRIV_INSTRUCTION);
    CASE_OF(EXCEPTION_IN_PAGE_ERROR);
    CASE_OF(EXCEPTION_ILLEGAL_INSTRUCTION);
    CASE_OF(EXCEPTION_NONCONTINUABLE_EXCEPTION);
    CASE_OF(EXCEPTION_STACK_OVERFLOW);
    CASE_OF(EXCEPTION_INVALID_DISPOSITION);
    CASE_OF(EXCEPTION_GUARD_PAGE);
    CASE_OF(EXCEPTION_INVALID_HANDLE);

    CASE_OF(RPC_S_INVALID_STRING_BINDING);
    CASE_OF(RPC_S_WRONG_KIND_OF_BINDING);
    CASE_OF(RPC_S_INVALID_BINDING);
    CASE_OF(RPC_S_PROTSEQ_NOT_SUPPORTED);
    CASE_OF(RPC_S_INVALID_RPC_PROTSEQ);
    CASE_OF(RPC_S_INVALID_STRING_UUID);
    CASE_OF(RPC_S_INVALID_ENDPOINT_FORMAT);
    CASE_OF(RPC_S_INVALID_NET_ADDR);
    CASE_OF(RPC_S_NO_ENDPOINT_FOUND);
    CASE_OF(RPC_S_INVALID_TIMEOUT);
    CASE_OF(RPC_S_OBJECT_NOT_FOUND);
    CASE_OF(RPC_S_ALREADY_REGISTERED);
    CASE_OF(RPC_S_TYPE_ALREADY_REGISTERED);
    CASE_OF(RPC_S_ALREADY_LISTENING);
    CASE_OF(RPC_S_NO_PROTSEQS_REGISTERED);
    CASE_OF(RPC_S_NOT_LISTENING);
    CASE_OF(RPC_S_UNKNOWN_MGR_TYPE);
    CASE_OF(RPC_S_UNKNOWN_IF);
    CASE_OF(RPC_S_NO_BINDINGS);
    CASE_OF(RPC_S_NO_PROTSEQS);
    CASE_OF(RPC_S_CANT_CREATE_ENDPOINT);
    CASE_OF(RPC_S_OUT_OF_RESOURCES);
    CASE_OF(RPC_S_SERVER_UNAVAILABLE);
    CASE_OF(RPC_S_SERVER_TOO_BUSY);
    CASE_OF(RPC_S_INVALID_NETWORK_OPTIONS);
    CASE_OF(RPC_S_NO_CALL_ACTIVE);
    CASE_OF(RPC_S_CALL_FAILED);
    CASE_OF(RPC_S_CALL_FAILED_DNE);
    CASE_OF(RPC_S_PROTOCOL_ERROR);
    CASE_OF(RPC_S_UNSUPPORTED_TRANS_SYN);
    CASE_OF(RPC_S_UNSUPPORTED_TYPE);
    CASE_OF(RPC_S_INVALID_TAG);
    CASE_OF(RPC_S_INVALID_BOUND);
    CASE_OF(RPC_S_NO_ENTRY_NAME);
    CASE_OF(RPC_S_INVALID_NAME_SYNTAX);
    CASE_OF(RPC_S_UNSUPPORTED_NAME_SYNTAX);
    CASE_OF(RPC_S_UUID_NO_ADDRESS);
    CASE_OF(RPC_S_DUPLICATE_ENDPOINT);
    CASE_OF(RPC_S_UNKNOWN_AUTHN_TYPE);
    CASE_OF(RPC_S_MAX_CALLS_TOO_SMALL);
    CASE_OF(RPC_S_STRING_TOO_LONG);
    CASE_OF(RPC_S_PROTSEQ_NOT_FOUND);
    CASE_OF(RPC_S_PROCNUM_OUT_OF_RANGE);
    CASE_OF(RPC_S_BINDING_HAS_NO_AUTH);
    CASE_OF(RPC_S_UNKNOWN_AUTHN_SERVICE);
    CASE_OF(RPC_S_UNKNOWN_AUTHN_LEVEL);
    CASE_OF(RPC_S_INVALID_AUTH_IDENTITY);
    CASE_OF(RPC_S_UNKNOWN_AUTHZ_SERVICE);
    CASE_OF(EPT_S_INVALID_ENTRY);
    CASE_OF(EPT_S_CANT_PERFORM_OP);
    CASE_OF(EPT_S_NOT_REGISTERED);
    CASE_OF(RPC_S_NOTHING_TO_EXPORT);
    CASE_OF(RPC_S_INCOMPLETE_NAME);
    CASE_OF(RPC_S_INVALID_VERS_OPTION);
    CASE_OF(RPC_S_NO_MORE_MEMBERS);
    CASE_OF(RPC_S_NOT_ALL_OBJS_UNEXPORTED);
    CASE_OF(RPC_S_INTERFACE_NOT_FOUND);
    CASE_OF(RPC_S_ENTRY_ALREADY_EXISTS);
    CASE_OF(RPC_S_ENTRY_NOT_FOUND);
    CASE_OF(RPC_S_NAME_SERVICE_UNAVAILABLE);
    CASE_OF(RPC_S_INVALID_NAF_ID);
    CASE_OF(RPC_S_CANNOT_SUPPORT);
    CASE_OF(RPC_S_NO_CONTEXT_AVAILABLE);
    CASE_OF(RPC_S_INTERNAL_ERROR);
    CASE_OF(RPC_S_ZERO_DIVIDE);
    CASE_OF(RPC_S_ADDRESS_ERROR);
    CASE_OF(RPC_S_FP_DIV_ZERO);
    CASE_OF(RPC_S_FP_UNDERFLOW);
    CASE_OF(RPC_S_FP_OVERFLOW);
    CASE_OF(RPC_X_NO_MORE_ENTRIES);
    CASE_OF(RPC_X_SS_CHAR_TRANS_OPEN_FAIL);
    CASE_OF(RPC_X_SS_CHAR_TRANS_SHORT_FILE);
    CASE_OF(RPC_X_SS_IN_NULL_CONTEXT);
    CASE_OF(RPC_X_SS_CONTEXT_DAMAGED);
    CASE_OF(RPC_X_SS_HANDLES_MISMATCH);
    CASE_OF(RPC_X_SS_CANNOT_GET_CALL_HANDLE);
    CASE_OF(RPC_X_NULL_REF_POINTER);
    CASE_OF(RPC_X_ENUM_VALUE_OUT_OF_RANGE);
    CASE_OF(RPC_X_BYTE_COUNT_TOO_SMALL);
    CASE_OF(RPC_X_BAD_STUB_DATA);

    CASE_OF(WSAEINTR);
    CASE_OF(WSAEBADF);
    CASE_OF(WSAEACCES);
    CASE_OF(WSAEFAULT);
    CASE_OF(WSAEINVAL);
    CASE_OF(WSAEMFILE);
    CASE_OF(WSAEWOULDBLOCK);
    CASE_OF(WSAEINPROGRESS);
    CASE_OF(WSAEALREADY);
    CASE_OF(WSAENOTSOCK);
    CASE_OF(WSAEDESTADDRREQ);
    CASE_OF(WSAEMSGSIZE);
    CASE_OF(WSAEPROTOTYPE);
    CASE_OF(WSAENOPROTOOPT);
    CASE_OF(WSAEPROTONOSUPPORT);
    CASE_OF(WSAESOCKTNOSUPPORT);
    CASE_OF(WSAEOPNOTSUPP);
    CASE_OF(WSAEPFNOSUPPORT);
    CASE_OF(WSAEAFNOSUPPORT);
    CASE_OF(WSAEADDRINUSE);
    CASE_OF(WSAEADDRNOTAVAIL);
    CASE_OF(WSAENETDOWN);
    CASE_OF(WSAENETUNREACH);
    CASE_OF(WSAENETRESET);
    CASE_OF(WSAECONNABORTED);
    CASE_OF(WSAECONNRESET);
    CASE_OF(WSAENOBUFS);
    CASE_OF(WSAEISCONN);
    CASE_OF(WSAENOTCONN);
    CASE_OF(WSAESHUTDOWN);
    CASE_OF(WSAETOOMANYREFS);
    CASE_OF(WSAETIMEDOUT);
    CASE_OF(WSAECONNREFUSED);
    CASE_OF(WSAELOOP);
    CASE_OF(WSAENAMETOOLONG);
    CASE_OF(WSAEHOSTDOWN);
    CASE_OF(WSAEHOSTUNREACH);
    CASE_OF(WSAENOTEMPTY);
    CASE_OF(WSAEPROCLIM);
    CASE_OF(WSAEUSERS);
    CASE_OF(WSAEDQUOT);
    CASE_OF(WSAESTALE);
    CASE_OF(WSAEREMOTE);
    CASE_OF(WSAEDISCON);
    CASE_OF(WSASYSNOTREADY);
    CASE_OF(WSAVERNOTSUPPORTED);
    CASE_OF(WSANOTINITIALISED);
    CASE_OF(WSAHOST_NOT_FOUND);
    CASE_OF(WSATRY_AGAIN);
    CASE_OF(WSANO_RECOVERY);
    CASE_OF(WSANO_DATA);

    default : return "?";
  }
}

LPSTR
MapCallbackToString(DWORD callback)
{
  switch(callback)
  {
    CASE_OF(WINHTTP_CALLBACK_STATUS_RESOLVING_NAME);
    CASE_OF(WINHTTP_CALLBACK_STATUS_NAME_RESOLVED);
    CASE_OF(WINHTTP_CALLBACK_STATUS_CONNECTING_TO_SERVER);
    CASE_OF(WINHTTP_CALLBACK_STATUS_CONNECTED_TO_SERVER);
    CASE_OF(WINHTTP_CALLBACK_STATUS_SENDING_REQUEST);
    CASE_OF(WINHTTP_CALLBACK_STATUS_REQUEST_SENT);
    CASE_OF(WINHTTP_CALLBACK_STATUS_RECEIVING_RESPONSE);
    CASE_OF(WINHTTP_CALLBACK_STATUS_RESPONSE_RECEIVED);
    CASE_OF(WINHTTP_CALLBACK_STATUS_CLOSING_CONNECTION);
    CASE_OF(WINHTTP_CALLBACK_STATUS_CONNECTION_CLOSED);
    CASE_OF(WINHTTP_CALLBACK_STATUS_HANDLE_CREATED);
    CASE_OF(WINHTTP_CALLBACK_STATUS_HANDLE_CLOSING);
    CASE_OF(WINHTTP_CALLBACK_STATUS_DETECTING_PROXY);
    CASE_OF(WINHTTP_CALLBACK_STATUS_REQUEST_COMPLETE);
    CASE_OF(WINHTTP_CALLBACK_STATUS_REDIRECT);
    CASE_OF(WINHTTP_CALLBACK_STATUS_INTERMEDIATE_RESPONSE);
    CASE_OF(WINHTTP_CALLBACK_STATUS_SECURE_FAILURE);
    CASE_OF(WINHTTP_CALLBACK_STATUS_HEADERS_AVAILABLE);
    CASE_OF(WINHTTP_CALLBACK_STATUS_DATA_AVAILABLE);
    CASE_OF(WINHTTP_CALLBACK_STATUS_READ_COMPLETE);
    CASE_OF(WINHTTP_CALLBACK_STATUS_WRITE_COMPLETE);
    CASE_OF(WINHTTP_CALLBACK_STATUS_REQUEST_ERROR);
    CASE_OF(WINHTTP_CALLBACK_STATUS_SENDREQUEST_COMPLETE);
  }

  return "unknown callback";
}

LPSTR
MapAsyncErrorToString(DWORD error)
{
  switch(error)
  {
    CASE_OF(API_RECEIVE_RESPONSE);
    CASE_OF(API_QUERY_DATA_AVAILABLE);
    CASE_OF(API_READ_DATA);
    CASE_OF(API_WRITE_DATA);
    CASE_OF(API_SEND_REQUEST);
    CASE_OF(API_UNKNOWN);
  }

  return MapErrorToString((INT)error);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\tools\stress\stressscheduler\src\networktools.h ===
///////////////////////////////////////////////////////////////////////////
// File:  NetworkTools.h
//
// Copyright (c) 2001 Microsoft Corporation.  All Rights Reserved.
//
// Purpose:
//	NetworkTools.h: Helper functions that send/receive data.
//
// History:
//	02/22/01	DennisCh	Created
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_NETWORKTOOLS_H__4243AA4D_B243_4A0E_B729_243F260FC4F4__INCLUDED_)
#define AFX_NETWORKTOOLS_H__4243AA4D_B243_4A0E_B729_243F260FC4F4__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000


//////////////////////////////////////////////////////////////////////
// Includes
//////////////////////////////////////////////////////////////////////

//
// WIN32 headers
//
#define UNICODE
#define _UNICODE

#include <stdio.h>
#include <windows.h>
#include <tchar.h>
#include <winhttp.h>
#include <shlwapi.h>

//
// Project headers
//


//////////////////////////////////////////////////////////////////////
// Constants
//////////////////////////////////////////////////////////////////////

#define		DEBUGGER_TOOLS_PATH		_T("c:\\debuggers\\")

BOOL	NetworkTools__CopyFile(LPCTSTR, LPCTSTR);
BOOL	NetworkTools__GetDllVersion(LPTSTR, LPTSTR, LPSTR, DWORD);
BOOL	NetworkTools__GetFileNameFromURL(LPTSTR, LPTSTR, DWORD);
BOOL	NetworkTools__GetHeaderValue(LPTSTR, LPSTR, LPTSTR, DWORD, LPVOID, LPDWORD);
BOOL	NetworkTools__LogDumpFileInfo(LPTSTR, DWORD);
BOOL	NetworkTools__PageHeap(BOOL, LPCTSTR, LPCTSTR);
BOOL	NetworkTools__POSTResponse(LPTSTR, LPSTR, LPTSTR);
BOOL	NetworkTools__SendLog(LPSTR, LPSTR, LPTSTR, DWORD);
BOOL	NetworkTools__UMDH(BOOL, LPCTSTR, LPCTSTR, LPCTSTR, DWORD);
BOOL	NetworkTools__URLDownloadToFile(LPCTSTR, LPCTSTR, LPCTSTR);


#endif // !defined(AFX_NETWORKTOOLS_H__4243AA4D_B243_4A0E_B729_243F260FC4F4__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\tools\stress\stressscheduler\src\networktools.cpp ===
//////////////////////////////////////////////////////////////////////
// File:  NetworkTools.cpp
//
// Copyright (c) 2001 Microsoft Corporation.  All Rights Reserved.
//
// Purpose:
//	NetworkTools.cpp: Helper functions that send/receive data.
//
// History:
//	02/22/01	DennisCh	Created
//
//////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////
//
// Includes
//
//////////////////////////////////////////////////////////////////////

//
// Project headers
//
#include "NetworkTools.h"
#include "ServerCommands.h"

//
// Win32 headers
//


//////////////////////////////////////////////////////////////////////
//
// Globals and statics
//
//////////////////////////////////////////////////////////////////////
extern ServerCommands	g_objServerCommands;	// Declared in WinHttpStressScheduler.cpp
extern HWND				g_hWnd;					// Declared in WinHttpStressScheduler.cpp


////////////////////////////////////////////////////////////
// Function:  NetworkTools__GetFileNameFromURL(LPTSTR)
//
// Purpose:
//	Returns the filename requested from an URL without a querystring.
//	For example, if szURL="http://dennisch/files/test.exe" we return "test.exe"
//
////////////////////////////////////////////////////////////
BOOL
NetworkTools__GetFileNameFromURL(
	LPTSTR	szURL,			// [IN]		Full URL containing the file
	LPTSTR	szBuffer,		// [OUT]	Buffer to store the filename from the URL
	DWORD	dwBufferSize	// [IN]		Size of buffer szFileName
)
{
	TCHAR	*pLastSlash;
	INT		iCharToLookFor;

	if (0 >= _tcslen(szURL))
		return FALSE;

	ZeroMemory(szBuffer, dwBufferSize);

	pLastSlash		= NULL;
	iCharToLookFor	= _T('/');

	// get the last instance of '/'
	pLastSlash = _tcsrchr(szURL, iCharToLookFor);

	// skip the last '/'
	pLastSlash++;

	if (!pLastSlash)
		return FALSE;

	// copy the filename.extension to the buffer
	_tcscpy(szBuffer, pLastSlash);

	return TRUE;
}


////////////////////////////////////////////////////////////
// Function:  NetworkTools__POSTResponse(LPTSTR, LPTSTR, LPTSTR)
//
// Purpose:
//	Sends a message to the Command Server results page 
//	via header/headervalue and/or POST data.
//
////////////////////////////////////////////////////////////
BOOL
NetworkTools__POSTResponse(
	LPTSTR	szURL,		// [IN] string containing URL to POST to
	LPSTR	szPostData,	// [IN] string containing POST data to send. can be NULL
	LPTSTR	szHeader	// [IN] string containing header(s) to send. can be NULL
)
{
	BOOL			bResult		= TRUE;
	HINTERNET		hRoot		= NULL;
	HINTERNET		hSession	= NULL;
	HINTERNET		hRequest	= NULL;
	URL_COMPONENTSW	urlComponents;


	// Allocate space for URL components
	ZeroMemory(&urlComponents, sizeof(urlComponents));

	urlComponents.dwSchemeLength	= MAX_PATH;
	urlComponents.lpszScheme		= new TCHAR[MAX_PATH];

	urlComponents.dwHostNameLength  = MAX_PATH;
	urlComponents.lpszHostName		= new TCHAR[MAX_PATH];

	urlComponents.dwUrlPathLength	= MAX_PATH;
	urlComponents.lpszUrlPath		= new TCHAR[MAX_PATH];

	urlComponents.dwExtraInfoLength = MAX_PATH;
	urlComponents.lpszExtraInfo		= new TCHAR[MAX_PATH];
	
	urlComponents.dwUserNameLength	= MAX_PATH;
	urlComponents.lpszUserName		= new TCHAR[MAX_PATH];

	urlComponents.dwPasswordLength	= MAX_PATH;
	urlComponents.lpszPassword		= new TCHAR[MAX_PATH];
	
	urlComponents.nPort				= 0;

	urlComponents.dwStructSize		= sizeof(URL_COMPONENTSW);

	if (!urlComponents.lpszScheme	|| !urlComponents.lpszHostName	||
		!urlComponents.lpszUrlPath	|| !urlComponents.lpszExtraInfo	||
		!urlComponents.lpszUserName	|| !urlComponents.lpszPassword)
	{
		goto Exit;
	}


	// crack the Command Server URL to be used later
	if (!WinHttpCrackUrl(
			szURL,
			_tcslen(szURL),
			ICU_ESCAPE,
			&urlComponents)
		)
	{
		bResult = FALSE;
		goto Exit;
	}

	hRoot = WinHttpOpen(
		STRESS_SCHEDULER_USER_AGENT,
		WINHTTP_ACCESS_TYPE_NO_PROXY,
		NULL,
		NULL,
		0);

	if (!hRoot)
	{
		bResult = FALSE;
		goto Exit;
	}

	hSession = WinHttpConnect(
		hRoot,
		urlComponents.lpszHostName,
		// If the URL in urlComponents uses standard HTTP or HTTPS ports then use INTERNET_DEFAULT_PORT. Otherwise use the non-standard port gleaned from the URL.
		((urlComponents.nPort == 80) || (urlComponents.nPort == 443)) ? INTERNET_DEFAULT_PORT : urlComponents.nPort,
		0);
	
	if (!hSession)
	{
		bResult = FALSE;
		goto Exit;
	}


	// Build a full URL with path and querystring
	TCHAR szFullPath[MAX_PATH*2];

	_tcsncpy(szFullPath, urlComponents.lpszUrlPath, urlComponents.dwUrlPathLength);
	szFullPath[urlComponents.dwUrlPathLength] = _T('\0');
	_tcsncat(szFullPath, urlComponents.lpszExtraInfo, urlComponents.dwExtraInfoLength);

	hRequest = WinHttpOpenRequest(
		hSession,
		_T("POST"),
		szFullPath,
		NULL,
		NULL,
		NULL,
		// if the URL in urlComponents uses HTTPS then pass in WINHTTP_FLAG_SECURE to this param. Otherwise, 0.
		(0 == _tcsnicmp(urlComponents.lpszScheme, _T("https"), 5)) ? WINHTTP_FLAG_SECURE : 0);

	if (!hRequest)
	{
		bResult = FALSE;
		goto Exit;
	}


	// Set reasonable timeouts just in case
	if (!WinHttpSetTimeouts(hRequest, 5000, 5000, 5000, 5000))
	{
		bResult = FALSE;
		goto Exit;
	}

	// Set result header if not NULL
	if (szHeader)
	{
		if (!WinHttpAddRequestHeaders(
				hRequest,
				szHeader,
				_tcsclen(szHeader),
				WINHTTP_ADDREQ_FLAG_ADD))
		{
			bResult = FALSE;
			goto Exit;
		}
	}


	bResult = WinHttpSendRequest(
		hRequest,
		_T("Content-Type: application/x-www-form-urlencoded"),
		-1L, 
		szPostData,
		strlen(szPostData),
		strlen(szPostData),
		0);

	if (!WinHttpReceiveResponse(hRequest, NULL))
	{
		bResult = FALSE;
		goto Exit;
	}


Exit:
	if (hRequest)
		WinHttpCloseHandle(hRequest);

	if (hSession)
		WinHttpCloseHandle(hSession);

	if (hRoot)
		WinHttpCloseHandle(hRoot);

	if (urlComponents.lpszScheme)
		delete [] urlComponents.lpszScheme;

	if (urlComponents.lpszHostName)
		delete [] urlComponents.lpszHostName;

	if (urlComponents.lpszUrlPath)
		delete [] urlComponents.lpszUrlPath;

	if (urlComponents.lpszExtraInfo)
		delete [] urlComponents.lpszExtraInfo;

	if (urlComponents.lpszPassword)
		delete [] urlComponents.lpszPassword;

	if (urlComponents.lpszUserName)
		delete [] urlComponents.lpszUserName;

	return bResult;
}


////////////////////////////////////////////////////////////
// Function:  NetworkTools__URLDownloadToFile(LPCTSTR, LPCTSTR, LPCTSTR)
//
// Purpose:
//	Downloads a file pointed to by the URL. Returns TRUE if succesfully downloaded.
//  FALSE if not. If the file is in use (ERROR_SHARING_VIOLATION) then we'll
//	return TRUE because the file is already on the system and is valid.
//
////////////////////////////////////////////////////////////
BOOL
NetworkTools__URLDownloadToFile(
LPCTSTR szURL,			// [IN] Fully qualified URL pointing to the file to download
LPCTSTR szTargetDir,	// [IN] A relative path to the directory to put szTargetFile in. If NULL, then it'll be put in the app's current dir.
LPCTSTR szTargetFile	// [IN] Name of the file to download to. Can be NULL. File will be placed in szTargetDir. If it already exists, then we'll try to overwrite it.
)
{
	HANDLE			hFile		= NULL;
	BOOL			bResult		= TRUE;
	HINTERNET		hRoot		= NULL;
	HINTERNET		hSession	= NULL;
	HINTERNET		hRequest	= NULL;
	URL_COMPONENTSW	urlComponents;
	LPVOID			lpBuffer	= NULL;
	DWORD			dwBytesToRead, dwBytesRead;


	// Allocate space for URL components
	ZeroMemory(&urlComponents, sizeof(urlComponents));

	urlComponents.dwSchemeLength	= MAX_PATH;
	urlComponents.lpszScheme		= new TCHAR[MAX_PATH];

	urlComponents.dwHostNameLength  = MAX_PATH;
	urlComponents.lpszHostName		= new TCHAR[MAX_PATH];

	urlComponents.dwUrlPathLength	= MAX_PATH;
	urlComponents.lpszUrlPath		= new TCHAR[MAX_PATH];

	urlComponents.dwExtraInfoLength = MAX_PATH;
	urlComponents.lpszExtraInfo		= new TCHAR[MAX_PATH];
	
	urlComponents.dwUserNameLength	= MAX_PATH;
	urlComponents.lpszUserName		= new TCHAR[MAX_PATH];

	urlComponents.dwPasswordLength	= MAX_PATH;
	urlComponents.lpszPassword		= new TCHAR[MAX_PATH];
	
	urlComponents.nPort				= 0;

	urlComponents.dwStructSize		= sizeof(URL_COMPONENTSW);


	if (!urlComponents.lpszScheme	|| !urlComponents.lpszHostName	||
		!urlComponents.lpszUrlPath	|| !urlComponents.lpszExtraInfo	||
		!urlComponents.lpszUserName	|| !urlComponents.lpszPassword)
	{
		goto Exit;
	}

	// crack the Command Server URL to be used later
	if (!WinHttpCrackUrl(
			szURL,
			_tcslen(szURL),
			ICU_ESCAPE,
			&urlComponents)
		)
	{
		bResult = FALSE;
		goto Exit;
	}

	hRoot = WinHttpOpen(
		STRESS_SCHEDULER_USER_AGENT,
		WINHTTP_ACCESS_TYPE_NO_PROXY,
		NULL,
		NULL,
		0);

	if (!hRoot)
	{
		bResult = FALSE;
		goto Exit;
	}

	hSession = WinHttpConnect(
		hRoot,
		urlComponents.lpszHostName,
		// If the URL in urlComponents uses standard HTTP or HTTPS ports then use INTERNET_DEFAULT_PORT. Otherwise use the non-standard port gleaned from the URL.
		((urlComponents.nPort == 80) || (urlComponents.nPort == 443)) ? INTERNET_DEFAULT_PORT : urlComponents.nPort,
		0);
	
	if (!hSession)
	{
		bResult = FALSE;
		goto Exit;
	}


	// Build a full URL with path and querystring
	TCHAR szFullPath[MAX_PATH*2];

	_tcsncpy(szFullPath, urlComponents.lpszUrlPath, urlComponents.dwUrlPathLength);
	szFullPath[urlComponents.dwUrlPathLength] = _T('\0');
	_tcsncat(szFullPath, urlComponents.lpszExtraInfo, urlComponents.dwExtraInfoLength);

	hRequest = WinHttpOpenRequest(
		hSession,
		_T("GET"),
		szFullPath,
		NULL,
		NULL,
		NULL,
		// if the URL in urlComponents uses HTTPS then pass in WINHTTP_FLAG_SECURE to this param. Otherwise, 0.
		(0 == _tcsnicmp(urlComponents.lpszScheme, _T("https"), 5)) ? WINHTTP_FLAG_SECURE : 0);

	if (!hRequest)
	{
		bResult = FALSE;
		goto Exit;
	}


	// Set reasonable timeouts just in case
	if (!WinHttpSetTimeouts(hRequest, 5000, 5000, 5000, 5000))
	{
		bResult = FALSE;
		goto Exit;
	}


	bResult = WinHttpSendRequest(
		hRequest,
		NULL,
		0, 
		NULL,
		0,
		0,
		0);

	if (!WinHttpReceiveResponse(hRequest, NULL))
	{
		bResult = FALSE;
		goto Exit;
	}


	// **********************************
	// **********************************
	// ** WinHttpQueryHeaders - make sure status is 200 before writing the file to disk.
	// **

	DWORD dwStatus, dwBufferSize;

	dwStatus		= 0;
	dwBufferSize	= sizeof(DWORD);
	if (!WinHttpQueryHeaders(hRequest, WINHTTP_QUERY_STATUS_CODE | WINHTTP_QUERY_FLAG_NUMBER , NULL, &dwStatus, &dwBufferSize, NULL) ||
		(dwStatus != 200)
		)
	{
		OutputDebugString(_T("ERROR: NetworkTools__URLDownloadToFile: WinHttpQueryHeaders failed or dwStatus != 200"));

		bResult = FALSE;
		goto Exit;
	}


	// **********************************
	// **********************************
	// ** Get the filename and extenstion
	// ** from the URL
	// **
	TCHAR	szFileName[MAX_PATH];		// name of the new file to write to. will be created in szCurrentDir

	ZeroMemory(szFileName, sizeof(szFileName));

	// check to see if the user provided a filename to write to
	if (szTargetFile)
		_tcsncpy(szFileName, szTargetFile, MAX_PATH);
	else
	{
		// user did not specify a filename to write to, so we use the original one from the URL
		if (!NetworkTools__GetFileNameFromURL(urlComponents.lpszUrlPath, szFileName, sizeof(szFileName)))
		{
			bResult = FALSE;
			goto Exit;
		}
	}


	// **********************************
	// **********************************
	// ** Create the directory where the file will reside and set it as the current directory
	// **
	
	// if user specified NULL, then we put the file in the current dir.
	// else we set the current directory as the one specified
	if (szTargetDir)
	{
		// create the dir. don't care if it fails because it already exists...
		CreateDirectory(szTargetDir, NULL);
		SetCurrentDirectory(szTargetDir);
	}


	// create the file to download to.
	hFile = CreateFile(
		// if the user doesn't specify the filename to write to, use the one from the URL
		szFileName,
		GENERIC_WRITE,
		0,
		NULL,
		CREATE_ALWAYS,
		FILE_ATTRIBUTE_NORMAL | FILE_FLAG_WRITE_THROUGH,
		NULL);


	if ((hFile == INVALID_HANDLE_VALUE) || !hFile)
	{
		// We won't return FALSE if the file is in use. This means the file is valid.
		if (ERROR_SHARING_VIOLATION == GetLastError())
		{
			// File is in use that means winhttp is ok. we'll stress the old version
			bResult = TRUE;
			goto Exit;
		}
		else
		{
			bResult = FALSE;
			goto Exit;
		}
	}

	// **********************************
	// **********************************
	// ** Read data from net to file.
	// **
	// read 64K chunks at a time
	lpBuffer		= new LPVOID[65536];

	if (!lpBuffer)
		goto Exit;

	ZeroMemory(lpBuffer, 65536);
	dwBytesToRead	= 65536;
	dwBytesRead		= 65536;

	while (WinHttpReadData(hRequest, lpBuffer, dwBytesToRead, &dwBytesRead) && (0 != dwBytesRead))
	{
		WriteFile(hFile, lpBuffer, dwBytesRead, &dwBytesRead, NULL);

		dwBytesRead = 0;
		ZeroMemory(lpBuffer, 65536);
	}

Exit:
	if (hRequest)
		WinHttpCloseHandle(hRequest);

	if (hSession)
		WinHttpCloseHandle(hSession);

	if (hRoot)
		WinHttpCloseHandle(hRoot);

	if (hFile && (hFile != INVALID_HANDLE_VALUE))
		CloseHandle(hFile);

	if (lpBuffer)
		delete [] lpBuffer;

	// restore the current directory from the one that we created the new file in.
	SetCurrentDirectory(g_objServerCommands.Get_CurrentWorkingDirectory());

	delete [] urlComponents.lpszScheme;
	delete [] urlComponents.lpszHostName;
	delete [] urlComponents.lpszUrlPath;
	delete [] urlComponents.lpszExtraInfo;
	delete [] urlComponents.lpszPassword;
	delete [] urlComponents.lpszUserName;

	return bResult;
}


////////////////////////////////////////////////////////////
// Function:  NetworkTools__CopyFile(LPCTSTR, LPCTSTR)
//
// Purpose:
//	Wrapper for CopyFile. Copies file szSource to szDestination.
//	We'll always overwite the file if it already exists.
//
////////////////////////////////////////////////////////////
BOOL
NetworkTools__CopyFile(
	LPCTSTR szSource,
	LPCTSTR szDestination
)
{
	BOOL bResult = TRUE;
	
	if (!szSource || !szDestination)
	{
		bResult = FALSE;
		goto Exit;
	}

	bResult = CopyFile(szSource, szDestination, TRUE);

Exit:
	return bResult;
}


////////////////////////////////////////////////////////////
// Function:  NetworkTools__PageHeap(BOOL, LPCTSTR)
//
// Purpose:
//	Enables/Disables pageheap.
//
////////////////////////////////////////////////////////////
BOOL
NetworkTools__PageHeap(
	BOOL	bEnable,		// [IN] Enables/Disables pageheap.
	LPCTSTR	szAppName,		// [IN] The executable to enable or disable.
	LPCTSTR	szCommandLine	// [IN] Command line for pageheap.
)
{
	BOOL		bResult		= TRUE;
	HINSTANCE	hExe		= NULL;
	LPTSTR		szPHCommand = NULL;

	szPHCommand = new TCHAR[MAX_PATH];

	if (!szPHCommand)
		return FALSE;


	if (bEnable)
	{
		hExe = ShellExecute(g_hWnd, _T("open"), _T("pageheap.exe"), szCommandLine, NULL, SW_SHOWMINIMIZED);
	}
	else
	{
		ZeroMemory(szPHCommand, MAX_PATH);
		_tcscpy(szPHCommand, _T("/disable "));
		_tcscat(szPHCommand, szAppName);
		hExe = ShellExecute(g_hWnd, _T("open"), _T("pageheap.exe"), szPHCommand, NULL, SW_SHOWMINIMIZED);
	}

	// Error if HINSTANCE <= 32.
	if (32 >= (INT) hExe)
		bResult = FALSE;

	if (szPHCommand)
		delete [] szPHCommand;

	return bResult;
}


////////////////////////////////////////////////////////////
// Function:  NetworkTools__UMDH(LPCTSTR, DWORD, LPCTSTR)
//
// Purpose:
//	Enables/Disables UMDH.
//
////////////////////////////////////////////////////////////
BOOL
NetworkTools__UMDH(
	BOOL	bEnable,		// [IN] Enables/Disables UMDH.
	LPCTSTR	szAppName,		// [IN] The executable to dump.
	LPCTSTR	szCommandLine,	// [IN] Command line for UMDH.
	LPCTSTR szLogFile,		// [IN] Logfile to create
	DWORD	dwPID			// [IN] The PID of the process to dump
)
{
	BOOL		bResult		= TRUE;
	HINSTANCE	hExe		= NULL;
	LPTSTR		szCommand	= NULL;

	szCommand = new TCHAR[MAX_PATH];

	// build command line and run: "GFLAGS -i <stressExe name> +ust"
	ZeroMemory(szCommand, MAX_PATH);
	_tcscpy(szCommand, _T("-i "));
	_tcscat(szCommand, szAppName);
	_tcscat(szCommand, _T(" +ust"));
	hExe = ShellExecute(g_hWnd, _T("open"), DEBUGGER_TOOLS_PATH _T("gflags.exe"), szCommand, NULL, SW_SHOWMINIMIZED);


	// build the UMDH command line
	ZeroMemory(szCommand, MAX_PATH);
	_tcscpy(szCommand, _T("-f:stuff.log"));

	hExe = ShellExecute(g_hWnd, _T("open"), DEBUGGER_TOOLS_PATH _T("umdh.exe"), szCommand, NULL, SW_SHOWMINIMIZED);

	// Error if HINSTANCE <= 32.
	if (32 >= (INT) hExe)
		bResult = FALSE;

	if (szCommand)
		delete [] szCommand;

	return bResult;
}


////////////////////////////////////////////////////////////
// Function:  NetworkTools__SendLog(LPSTR, LPSTR, LPTSTR, DWORD)
//
// Purpose:
//	Sends a log to the Command Server. Takes the log type string and log string.
//	Sends the stressInstance ID and client machine name as part of the POST request.
//	If this is a general message, then the stressInstanceID should be set to zero. Otherwise
//	if and ID is supplied, then stressAdmin will log this to the stressInstanceLog table.
//	You can also add headers too.
//
////////////////////////////////////////////////////////////
BOOL
NetworkTools__SendLog(
	LPSTR	szLogType,
	LPSTR	szLogText,
	LPTSTR	szExtraHeaders,
	DWORD	dwStressInstanceID
)
{
	BOOL	bResult				= TRUE;
	LPSTR	szPostLogData		= NULL;
	CHAR	szStressInstanceID[10];
	LPSTR	szDllVersion		= NULL;
	LPSTR	szNumber			= NULL;
	DWORD	dwPostLogDataSize	= 0;

	szDllVersion	= new CHAR[MAX_PATH];
	szNumber		= new CHAR[10];

	if (!szDllVersion || !szNumber)
		goto Exit;

	if (!szLogType || !szLogText || !g_objServerCommands.Get_ClientMachineName())
	{
		OutputDebugStringA("NetworkTools__SendLog: ERROR: szLogType, szLogText, or g_objServerCommands.Get_ClientMachineName() is NULL.");
		bResult = FALSE;
		goto Exit;
	}

	dwPostLogDataSize	=	sizeof(FIELDNAME__STRESSINSTANCE_ID) + MAX_PATH;
	dwPostLogDataSize	+=	sizeof(FIELDNAME__LOG_TEXT) + strlen(szLogText);
	dwPostLogDataSize	+=	sizeof(FIELDNAME__USERINFO_MACHINENAME) + strlen(g_objServerCommands.Get_ClientMachineName());
	dwPostLogDataSize	+=	strlen(szLogType);
	dwPostLogDataSize	+=	sizeof(FIELDNAME__TESTINFO_TEST_DLL_VERSION) + MAX_PATH;

	szPostLogData		= new CHAR[dwPostLogDataSize];
	if (!szPostLogData)
		goto Exit;

	ZeroMemory(szPostLogData, dwPostLogDataSize);

	// ***************************
	// ** add the client's machine name
	strcpy(szPostLogData, FIELDNAME__USERINFO_MACHINENAME);
	strcat(szPostLogData, g_objServerCommands.Get_ClientMachineName());


	// ***************************
	// ** add the stressInstance ID if valid
	if (0 < dwStressInstanceID)
	{
		strcat(szPostLogData, "&" FIELDNAME__STRESSINSTANCE_ID);
		strcat(szPostLogData, _itoa(dwStressInstanceID, szStressInstanceID, 10));
	}


	// ***************************
	// ** add the log type data
	strcat(szPostLogData, "&");
	strcat(szPostLogData, szLogType);


	// ***************************
	// ** add the test dll version info
	if (
		g_objServerCommands.Get_TestDllFileName() &&
		NetworkTools__GetDllVersion(g_objServerCommands.Get_TestDllFileName(), g_objServerCommands.Get_CurrentWorkingDirectory(), szDllVersion, MAX_PATH)
		)
	{
		strcat(szPostLogData, "&" FIELDNAME__TESTINFO_TEST_DLL_VERSION);
		strcat(szPostLogData, szDllVersion);
	}


	// ***************************
	// ** add the log text data
	strcat(szPostLogData, "&" FIELDNAME__LOG_TEXT);
	strcat(szPostLogData, szLogText);


	// ***************************
	// ** Send the data
	bResult = NetworkTools__POSTResponse(STRESS_COMMAND_SERVER_LOGURL, szPostLogData, szExtraHeaders);
	OutputDebugStringA(szPostLogData);

Exit:
	if (szPostLogData)
		delete [] szPostLogData;

	if (szDllVersion)
		delete [] szDllVersion;

	if (szNumber)
		delete [] szNumber;

	return bResult;
}


////////////////////////////////////////////////////////////
// Function:  NetworkTools__GetHeaderValue(LPTSTR, LPTSTR, DWORD, LPVOID, DWORD)
//
// Purpose:
//	Sends a POST to an URL and retrieves a header for that URL.
//	This is used in getting numeric ID's such as clientID and stressInstanceRunID.
//
////////////////////////////////////////////////////////////
BOOL
NetworkTools__GetHeaderValue(
	LPTSTR	szURL,			// [IN]			The command server URL to get commands from
	LPSTR	szPostData,		// [IN]			string containing POST data to send. can be NULL
	LPTSTR	szHeaderName,	// [IN]			Name of the header to get the value for
	DWORD	dwInfoLevel,	// [IN]			Flags to pass to WinHttpQueryHeaders
	LPVOID	lpBuffer,		// [OUT]		Buffer to put the header value in
	LPDWORD	lpdwBufferSize	// [IN][OUT]	Size of the buffer. Returns # of bytes read.
)
{
	BOOL			bResult		= TRUE;
	HINTERNET		hRoot		= NULL;
	HINTERNET		hSession	= NULL;
	HINTERNET		hRequest	= NULL;
	URL_COMPONENTSW	urlComponents;


	// Allocate space for URL components
	ZeroMemory(&urlComponents, sizeof(urlComponents));

	urlComponents.dwSchemeLength	= MAX_PATH;
	urlComponents.lpszScheme		= new TCHAR[MAX_PATH];

	urlComponents.dwHostNameLength  = MAX_PATH;
	urlComponents.lpszHostName		= new TCHAR[MAX_PATH];

	urlComponents.dwUrlPathLength	= MAX_PATH;
	urlComponents.lpszUrlPath		= new TCHAR[MAX_PATH];

	urlComponents.dwExtraInfoLength = MAX_PATH;
	urlComponents.lpszExtraInfo		= new TCHAR[MAX_PATH];
	
	urlComponents.dwUserNameLength	= MAX_PATH;
	urlComponents.lpszUserName		= new TCHAR[MAX_PATH];

	urlComponents.dwPasswordLength	= MAX_PATH;
	urlComponents.lpszPassword		= new TCHAR[MAX_PATH];
	
	urlComponents.nPort				= 0;

	urlComponents.dwStructSize		= sizeof(URL_COMPONENTSW);


	if (!urlComponents.lpszScheme	|| !urlComponents.lpszHostName	||
		!urlComponents.lpszUrlPath	|| !urlComponents.lpszExtraInfo	||
		!urlComponents.lpszUserName	|| !urlComponents.lpszPassword)
	{
		goto Exit;
	}


	// crack the Command Server URL to be used later
	if (!WinHttpCrackUrl(
			szURL,
			_tcslen(szURL),
			ICU_ESCAPE,
			&urlComponents)
		)
	{
		bResult = FALSE;
		goto Exit;
	}

	hRoot = WinHttpOpen(
		STRESS_SCHEDULER_USER_AGENT,
		WINHTTP_ACCESS_TYPE_NO_PROXY,
		NULL,
		NULL,
		0);

	if (!hRoot)
	{
		bResult = FALSE;
		goto Exit;
	}

	hSession = WinHttpConnect(
		hRoot,
		urlComponents.lpszHostName,
		// If the URL in urlComponents uses standard HTTP or HTTPS ports then use INTERNET_DEFAULT_PORT. Otherwise use the non-standard port gleaned from the URL.
		((urlComponents.nPort == 80) || (urlComponents.nPort == 443)) ? INTERNET_DEFAULT_PORT : urlComponents.nPort,
		0);
	
	if (!hSession)
	{
		bResult = FALSE;
		goto Exit;
	}


	// Build a full URL with path and querystring
	TCHAR szFullPath[MAX_PATH*2];

	_tcsncpy(szFullPath, urlComponents.lpszUrlPath, urlComponents.dwUrlPathLength);
	szFullPath[urlComponents.dwUrlPathLength] = _T('\0');
	_tcsncat(szFullPath, urlComponents.lpszExtraInfo, urlComponents.dwExtraInfoLength);

	hRequest = WinHttpOpenRequest(
		hSession,
		_T("POST"),
		szFullPath,
		NULL,
		NULL,
		NULL,
		// if the URL in urlComponents uses HTTPS then pass in WINHTTP_FLAG_SECURE to this param. Otherwise, 0.
		(0 == _tcsnicmp(urlComponents.lpszScheme, _T("https"), 5)) ? WINHTTP_FLAG_SECURE : 0);

	if (!hRequest)
	{
		bResult = FALSE;
		goto Exit;
	}


	// Set reasonable timeouts just in case
	if (!WinHttpSetTimeouts(hRequest, 5000, 5000, 5000, 5000))
	{
		bResult = FALSE;
		goto Exit;
	}

	bResult = WinHttpSendRequest(
		hRequest,
		_T("Content-Type: application/x-www-form-urlencoded"),
		-1L, 
		szPostData,
		strlen(szPostData),
		strlen(szPostData),
		0);

	if (!WinHttpReceiveResponse(hRequest, NULL))
	{
		bResult = FALSE;
		goto Exit;
	}


	// ***************************
	// ** WinHttpQueryHeaders - get the first instance of the header the client requested
	DWORD dwIndex;

	dwIndex = 0;
	if (!WinHttpQueryHeaders(hRequest, dwInfoLevel, szHeaderName, lpBuffer, lpdwBufferSize, &dwIndex))
		bResult = FALSE;

Exit:
	if (hRequest)
		WinHttpCloseHandle(hRequest);

	if (hSession)
		WinHttpCloseHandle(hSession);

	if (hRoot)
		WinHttpCloseHandle(hRoot);

	if (urlComponents.lpszScheme)
		delete [] urlComponents.lpszScheme;

	if (urlComponents.lpszHostName)
		delete [] urlComponents.lpszHostName;

	if (urlComponents.lpszUrlPath)
		delete [] urlComponents.lpszUrlPath;

	if (urlComponents.lpszExtraInfo)
		delete [] urlComponents.lpszExtraInfo;

	if (urlComponents.lpszPassword)
		delete [] urlComponents.lpszPassword;

	if (urlComponents.lpszUserName)
		delete [] urlComponents.lpszUserName;

	return bResult;
}



////////////////////////////////////////////////////////////
// Function:  NetworkTools__GetDllVersion(LPTSTR, LPSTR, DWORD)
//
// Purpose:
//	Takes a DLL name and return the version as an ASCII string.
//	Looks the stressExe directory then in the system search path since
//	that's the version the stress app will be using.
//
////////////////////////////////////////////////////////////
BOOL
NetworkTools__GetDllVersion(
	LPTSTR	lpszDllName,
	LPTSTR	lpszDllPath,
	LPSTR	szVersionBuffer,
	DWORD	dwVersionBufferSize
)
{
	BOOL	bResult			= TRUE;
	DWORD	dwHandle;
	DWORD	dwVersionSize;
	LPSTR	szVersionInfo	= NULL;
	LPSTR	szVersionOutput	= NULL;
	LPTSTR	szTargetDLL		= NULL;
	UINT	uiLength;

	szTargetDLL = new TCHAR[MAX_PATH * 5 + 1 + sizeof(STRESSINSTANCE_STRESS_EXE_DOWNLOAD_DIR) + 1 + MAX_PATH];
	if (!szTargetDLL)
		goto Exit;

	ZeroMemory(szVersionBuffer, dwVersionBufferSize);
	ZeroMemory(szTargetDLL, MAX_PATH * 5);

	// all stressExe's run in c:\winhttpstress\stresexe so check that dir for winhttp5.dll first
	_tcscpy(szTargetDLL, lpszDllPath);
	_tcscat(szTargetDLL, _T("\\"));
	_tcscat(szTargetDLL, STRESSINSTANCE_STRESS_EXE_DOWNLOAD_DIR);
	_tcscat(szTargetDLL, _T("\\"));
	_tcscat(szTargetDLL, lpszDllName);

	dwVersionSize	= GetFileVersionInfoSize(szTargetDLL, &dwHandle);
	
	// try to get the path+dll name that was supplied
	if (0 >= dwVersionSize)
	{
		// DLL doesn't exit in that path so just do the DLL name and it'll use the system search path be default
		_tcscpy(szTargetDLL, lpszDllName);
		dwVersionSize	= GetFileVersionInfoSize(szTargetDLL, &dwHandle);

		if (0 >= dwVersionSize)
		{
			bResult = FALSE;
			goto Exit;
		}
	}

	// allocate new buffer for the query
	szVersionInfo = new CHAR[dwVersionSize];
	if (!szVersionInfo)
		goto Exit;


	ZeroMemory(szVersionInfo, dwVersionSize);
	if (!GetFileVersionInfo(szTargetDLL, NULL, dwVersionSize, szVersionInfo))
	{
		bResult = FALSE;
		goto Exit;
	}


	// *****************************
	// ** build the version info query string

	struct LANGANDCODEPAGE {
	  WORD wLanguage;
	  WORD wCodePage;
	} *lpTranslate;


	CHAR szVersionQuery[200];
	ZeroMemory(szVersionQuery, 200);

	// Read the list of languages and code pages.
	VerQueryValueA(szVersionInfo, 
				  "\\VarFileInfo\\Translation",
				  (LPVOID*)&lpTranslate,
				  &uiLength);

	// build the ver info query string that contains the language bits
	sprintf(szVersionQuery, "\\StringFileInfo\\%04x%04x\\ProductVersion", lpTranslate->wLanguage, lpTranslate->wCodePage);


	// *****************************
	// ** Get the version and copy to buffer
	uiLength = 0;
	if (!VerQueryValueA(szVersionInfo, szVersionQuery, (VOID **) &szVersionOutput, &uiLength))
	{
		bResult = FALSE;
		goto Exit;
	}

	// copy the version info string to the buffer
	strncpy(szVersionBuffer, (LPSTR) szVersionOutput, dwVersionBufferSize-1);


Exit:
	if (szTargetDLL)
		delete [] szTargetDLL;

	if (szVersionInfo)
		delete [] szVersionInfo;

	return bResult;
}



////////////////////////////////////////////////////////////
// Function:  NetworkTools__LogDumpFileInfo(LPTSTR, DWORD)
//
// Purpose:
//	Takes a string containing memory dump path name stressInstanceID
//	to log to the database. For now, we use LorAgent that does this for us.
//	It logs to their database.
//
//	The file "loragent.exe", "lordll.dll", and "stressme.ini" must be present
//	in the current directory, else we copy the files from \\control\stressme
//
////////////////////////////////////////////////////////////
BOOL
NetworkTools__LogDumpFileInfo(
	LPTSTR	szMemoryDumpPath,		// [IN] String containing memory dump path
	DWORD	dwStressInstanceRunID	// [IN] StressInstanceRunID
)
{
	BOOL		bResult				= TRUE;
	HINSTANCE	hExe				= NULL;
	LPTSTR		szCommandLine		= NULL;
	DWORD		dwCommandLineSize	= 0;

	if (!szMemoryDumpPath)
	{
		bResult = FALSE;
		goto Exit;
	}

	
	//	copy the "loragent.exe", "lordll.dll", and "stressme.ini" from \\control\stressme to current directory where stressScheduler lives
	NetworkTools__CopyFile(STRESSINSTANCE_LORAGENT_FILES_PATH _T("loragent.exe"),	_T("loragent.exe"));
	NetworkTools__CopyFile(STRESSINSTANCE_LORAGENT_FILES_PATH _T("lordll.dll"),		_T("lordll.dll"));
	NetworkTools__CopyFile(STRESSINSTANCE_LORAGENT_FILES_PATH _T("stressme.ini"),	_T("stressme.ini"));


	// build command line string
	dwCommandLineSize	= sizeof(STRESSINSTANCE_LOG_DUMP_COMMANDLINE) + _tcsclen(szMemoryDumpPath) + MAX_PATH;
	szCommandLine		= new TCHAR[dwCommandLineSize];

	if (!szCommandLine)
		goto Exit;

	ZeroMemory(szCommandLine, dwCommandLineSize);
	_stprintf(szCommandLine, STRESSINSTANCE_LOG_DUMP_COMMANDLINE, szMemoryDumpPath, dwStressInstanceRunID);

	hExe = ShellExecute(g_hWnd, _T("open"), _T("loragent.exe"), szCommandLine, NULL, SW_SHOWMINIMIZED);

	// wait for logging to complete before returning
	Sleep(4000);

	// Error if HINSTANCE <= 32.
	if (32 >= (INT) hExe)
		bResult = FALSE;

Exit:
	if (szCommandLine)
		delete [] szCommandLine;

	return bResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\tools\stress\stressscheduler\src\servercommands.cpp ===
///////////////////////////////////////////////////////////////////////////
// File:  WinHttpStressScheduler.cpp
//
// Copyright (c) 2001 Microsoft Corporation.  All Rights Reserved.
//
// Purpose:
//	ServerCommands.cpp: implementation of the ServerCommands class.
//	This class is used to retrieve and act on command from the server.
//
// History:
//	02/08/01	DennisCh	Created
//
//////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////
// Includes
//////////////////////////////////////////////////////////////////////

//
// WIN32 headers
//

//
// Project headers
//
#include "ServerCommands.h"
#include "NetworkTools.h"


//////////////////////////////////////////////////////////////////////
// Globals and statics
//////////////////////////////////////////////////////////////////////

HANDLE				g_hQueryServerForCommands;	// Handle for the thread that queries the server for commands
CRITICAL_SECTION	g_csServerCommandsVars;		// For protecting CommandServer private member vars. Used in the QueryServerForCommands_ThreadProc.

extern ServerCommands g_objServerCommands;		// Declared in WinHttpStressScheduler.cpp


////////////////////////////////////////////////////////////
// Function:  QueryServerForCommands_ThreadProc(LPVOID)
//
// Purpose:
//	This method sends a request to the command server for instructions
//	and saves them in the public vars of ServerCommands.
//
////////////////////////////////////////////////////////////
DWORD
WINAPI
QueryServerForCommands_ThreadProc(
	LPVOID lpParam	// [IN] thread proc param
)
{
	BOOL			bResult		= TRUE;
	HINTERNET		hRoot		= NULL;
	HINTERNET		hSession	= NULL;
	HINTERNET		hRequest	= NULL;
	URL_COMPONENTSW	urlComponents;

	DWORD	dwStressInstanceID;
	DWORD	dwPageHeapCommandIndex,
			dwUMDHCommandIndex,
			dwStressPDBIndex,
			dwStressSYMIndex,
			dwStressMemDmpPathIndex,
			dwStressInstanceIDIndex;
	LPTSTR	szPageheapCommand,
			szUMDHCommand,
			szStressPDB_URL,
			szStressSYM_URL,
			szStressMemDmpPath,
			szStressInstanceID;
	LPSTR	szPost;

	szPost				= NULL;
	szPageheapCommand	= NULL;
	szUMDHCommand		= NULL;
	szStressPDB_URL		= NULL;
	szStressSYM_URL		= NULL;
	szStressMemDmpPath	= NULL;
	szStressInstanceID	= NULL;


	// Allocate space for URL components
	ZeroMemory(&urlComponents, sizeof(urlComponents));

	__try
	{
		urlComponents.dwSchemeLength	= MAX_PATH;
		urlComponents.lpszScheme		= new TCHAR[MAX_PATH];

		urlComponents.dwHostNameLength  = MAX_PATH;
		urlComponents.lpszHostName		= new TCHAR[MAX_PATH];

		urlComponents.dwUrlPathLength	= MAX_PATH;
		urlComponents.lpszUrlPath		= new TCHAR[MAX_PATH];

		urlComponents.dwExtraInfoLength = MAX_PATH;
		urlComponents.lpszExtraInfo		= new TCHAR[MAX_PATH];
		
		urlComponents.dwUserNameLength	= MAX_PATH;
		urlComponents.lpszUserName		= new TCHAR[MAX_PATH];

		urlComponents.dwPasswordLength	= MAX_PATH;
		urlComponents.lpszPassword		= new TCHAR[MAX_PATH];
		
		urlComponents.nPort				= 0;

		urlComponents.dwStructSize		= sizeof(URL_COMPONENTSW);
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		goto Exit;
	}

	if (!urlComponents.lpszScheme	|| !urlComponents.lpszHostName	||
		!urlComponents.lpszUrlPath	|| !urlComponents.lpszExtraInfo	||
		!urlComponents.lpszUserName	|| !urlComponents.lpszPassword)
	{
		goto Exit;
	}

	// crack the Command Server URL to be used later
	if (!WinHttpCrackUrl(
			g_objServerCommands.Get_CommandServerURL(),
			_tcslen(g_objServerCommands.Get_CommandServerURL()),
			ICU_ESCAPE,
			&urlComponents)
		)
	{
		bResult = FALSE;
		goto Exit;
	}

	hRoot = WinHttpOpen(
		STRESS_SCHEDULER_USER_AGENT,
		WINHTTP_ACCESS_TYPE_NO_PROXY,
		NULL,
		NULL,
		0);

	if (!hRoot)
	{
		bResult = FALSE;
		goto Exit;
	}

	hSession = WinHttpConnect(
		hRoot,
		urlComponents.lpszHostName,
		// If the URL in urlComponents uses standard HTTP or HTTPS ports then use INTERNET_DEFAULT_PORT. Otherwise use the non-standard port gleaned from the URL.
		((urlComponents.nPort == 80) || (urlComponents.nPort == 443)) ? INTERNET_DEFAULT_PORT : urlComponents.nPort,
		0);
	
	if (!hSession)
	{
		bResult = FALSE;
		goto Exit;
	}


	// Build a full URL with path and querystring
	TCHAR szFullPath[MAX_PATH*2];

	ZeroMemory(szFullPath, sizeof(szFullPath));
	_tcsncpy(szFullPath, urlComponents.lpszUrlPath, urlComponents.dwUrlPathLength);
	//szFullPath[urlComponents.dwUrlPathLength] = _T('\0');
	_tcsncat(szFullPath, urlComponents.lpszExtraInfo, urlComponents.dwExtraInfoLength);

	hRequest = WinHttpOpenRequest(
		hSession,
		_T("POST"),
		szFullPath,
		NULL,
		NULL,
		NULL,
		// if the URL in urlComponents uses HTTPS then pass in WINHTTP_FLAG_SECURE to this param. Otherwise, 0.
		(0 == _tcsnicmp(urlComponents.lpszScheme, _T("https"), 5)) ? WINHTTP_FLAG_SECURE : 0);

	if (!hRequest)
	{
		bResult = FALSE;
		goto Exit;
	}


	// Set reasonable timeouts just in case
	if (!WinHttpSetTimeouts(hRequest, 5000, 5000, 5000, 5000))
	{
		bResult = FALSE;
		goto Exit;
	}

	// Get the computer name and send it in a POST request
	__try
	{
		szPost			= new CHAR[MAX_PATH*2];
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		szPost = NULL;
		goto Exit;
	}

	if (!szPost)
		goto Exit;

	ZeroMemory(szPost, MAX_PATH*2);
	sprintf(szPost, "%s%u", FIELDNAME__CLIENT_ID, g_objServerCommands.Get_ClientID());

	bResult = WinHttpSendRequest(
		hRequest,
		_T("Content-Type: application/x-www-form-urlencoded"),
		-1L, 
		szPost,
		strlen(szPost),
		strlen(szPost),
		0);

	if (szPost)
	{
		delete [] szPost;
		szPost	= NULL;
	}


	if (!WinHttpReceiveResponse(hRequest, NULL))
	{
		bResult = FALSE;
		goto Exit;
	}



	TCHAR	szBuffer[MAX_URL];
	DWORD	dwBufferSize, dwIndex;


	// get all command headers that we're interested in.
	// make sure there are no pending operations on member vars (pServerCommands->Set_* functions)
	EnterCriticalSection(&g_csServerCommandsVars);


	// *********************************
	// **** COMMANDHEADER__EXIT: Exit if header is present, else continue.
	dwIndex			= 0;
	dwBufferSize	= MAX_URL;
	ZeroMemory(szBuffer, sizeof(szBuffer));
	if (WinHttpQueryHeaders(hRequest, WINHTTP_QUERY_CUSTOM, COMMANDHEADER__EXIT, szBuffer, &dwBufferSize, &dwIndex))
		g_objServerCommands.Set_ExitStress(TRUE);
	else
		g_objServerCommands.Set_ExitStress(FALSE);


	// *********************************
	// **** COMMANDHEADER__WINHTTP_DLL_URL: valid values: Valid URL
	dwIndex			= 0;
	dwBufferSize	= MAX_URL;
	ZeroMemory(szBuffer, sizeof(szBuffer));
	if (WinHttpQueryHeaders(hRequest, WINHTTP_QUERY_CUSTOM, COMMANDHEADER__WINHTTP_DLL_URL, szBuffer, &dwBufferSize, &dwIndex))
		g_objServerCommands.Set_WinHttpDllURL(szBuffer, dwBufferSize);
	else
		bResult = FALSE;


	// *********************************
	// **** COMMANDHEADER__WINHTTP_PDB_URL: valid values: Valid URL
	dwIndex			= 0;
	dwBufferSize	= MAX_URL;
	ZeroMemory(szBuffer, sizeof(szBuffer));
	if (WinHttpQueryHeaders(hRequest, WINHTTP_QUERY_CUSTOM, COMMANDHEADER__WINHTTP_PDB_URL, szBuffer, &dwBufferSize, &dwIndex))
		g_objServerCommands.Set_WinHttpPDBURL(szBuffer, dwBufferSize);
	else
		bResult = FALSE;


	// *********************************
	// **** COMMANDHEADER__WINHTTP_SYM_URL: valid values: Valid URL
	dwIndex			= 0;
	dwBufferSize	= MAX_URL;
	ZeroMemory(szBuffer, sizeof(szBuffer));
	if (WinHttpQueryHeaders(hRequest, WINHTTP_QUERY_CUSTOM, COMMANDHEADER__WINHTTP_SYM_URL, szBuffer, &dwBufferSize, &dwIndex))
		g_objServerCommands.Set_WinHttpSYMURL(szBuffer, dwBufferSize);
	else
		bResult = FALSE;


	// *********************************
	// **** COMMANDHEADER__COMMANDSERVER_URL: valid values: Valid URL
	dwIndex			= 0;
	dwBufferSize	= MAX_URL;
	ZeroMemory(szBuffer, sizeof(szBuffer));
	if (WinHttpQueryHeaders(hRequest, WINHTTP_QUERY_CUSTOM, COMMANDHEADER__COMMANDSERVER_URL, szBuffer, &dwBufferSize, &dwIndex))
		g_objServerCommands.Set_CommandServerURL(szBuffer, dwBufferSize);
	else
		bResult = FALSE;


	// *********************************
	// **** COMMANDHEADER__BEGIN_TIME_HOUR: valid values: Valid string from 0-23
	dwIndex			= 0;
	dwBufferSize	= MAX_URL;
	ZeroMemory(szBuffer, sizeof(szBuffer));
	if (WinHttpQueryHeaders(hRequest, WINHTTP_QUERY_CUSTOM, COMMANDHEADER__BEGIN_TIME_HOUR, szBuffer, &dwBufferSize, &dwIndex))
		g_objServerCommands.Set_TimeStressBegins(szBuffer, NULL);
	else
		bResult = FALSE;


	// *********************************
	// **** COMMANDHEADER__BEGIN_TIME_MINUTE: valid values: Valid string from 0-59
	dwIndex			= 0;
	dwBufferSize	= MAX_URL;
	ZeroMemory(szBuffer, sizeof(szBuffer));
	if (WinHttpQueryHeaders(hRequest, WINHTTP_QUERY_CUSTOM, COMMANDHEADER__BEGIN_TIME_MINUTE, szBuffer, &dwBufferSize, &dwIndex))
		g_objServerCommands.Set_TimeStressBegins(NULL, szBuffer);
	else
		bResult = FALSE;


	// *********************************
	// **** COMMANDHEADER__END_TIME_HOUR: valid values: Valid string from 0-23
	dwIndex			= 0;
	dwBufferSize	= MAX_URL;
	ZeroMemory(szBuffer, sizeof(szBuffer));
	if (WinHttpQueryHeaders(hRequest, WINHTTP_QUERY_CUSTOM, COMMANDHEADER__END_TIME_HOUR, szBuffer, &dwBufferSize, &dwIndex))
		g_objServerCommands.Set_TimeStressEnds(szBuffer, NULL);
	else
		bResult = FALSE;


	// *********************************
	// **** COMMANDHEADER__END_TIME_MINUTE: valid values: Valid string from 0-59
	dwIndex			= 0;
	dwBufferSize	= MAX_URL;
	ZeroMemory(szBuffer, sizeof(szBuffer));
	if (WinHttpQueryHeaders(hRequest, WINHTTP_QUERY_CUSTOM, COMMANDHEADER__END_TIME_MINUTE, szBuffer, &dwBufferSize, &dwIndex))
		g_objServerCommands.Set_TimeStressEnds(NULL, szBuffer);
	else
		bResult = FALSE;


	// *********************************
	// **** COMMANDHEADER__RUN_FOREVER: valid values: doesn't matter. As long as header is present it gets sent
	dwIndex			= 0;
	dwBufferSize	= MAX_URL;
	ZeroMemory(szBuffer, sizeof(szBuffer));
	if (WinHttpQueryHeaders(hRequest, WINHTTP_QUERY_CUSTOM, COMMANDHEADER__RUN_FOREVER, szBuffer, &dwBufferSize, &dwIndex))
		g_objServerCommands.Set_RunForever(TRUE);


	// *********************************
	// **** COMMANDHEADER__DO_NOT_RUN_FOREVER: valid values: doesn't matter. As long as header is present it gets sent
	dwIndex			= 0;
	dwBufferSize	= MAX_URL;
	ZeroMemory(szBuffer, sizeof(szBuffer));
	if (WinHttpQueryHeaders(hRequest, WINHTTP_QUERY_CUSTOM, COMMANDHEADER__DO_NOT_RUN_FOREVER, szBuffer, &dwBufferSize, &dwIndex))
		g_objServerCommands.Set_RunForever(FALSE);


	// *********************************
	// **** COMMANDHEADER__UPDATE_INTERVAL: valid values: Valid string in INTERNET_RFC1123 format
	DWORD			dwTimeOut;
	dwTimeOut		= 0;
	dwIndex			= 0;
	dwBufferSize	= sizeof(DWORD);
	ZeroMemory(szBuffer, sizeof(szBuffer));
	if (WinHttpQueryHeaders(hRequest, WINHTTP_QUERY_CUSTOM | WINHTTP_QUERY_FLAG_NUMBER, COMMANDHEADER__UPDATE_INTERVAL, &dwTimeOut, &dwBufferSize, &dwIndex))
		g_objServerCommands.Set_CommandServerUpdateInterval(dwTimeOut);
	else
		bResult = FALSE;



	// *********************************
	// *********************************
	// **** Query commands for building stress Instance objects
	// ****
	// **** COMMANDHEADER__STRESS_EXE_URL: valid values: Valid URL
	__try
	{
		szPageheapCommand	= new TCHAR[MAX_PATH];
		szUMDHCommand		= new TCHAR[MAX_PATH];
		szStressPDB_URL		= new TCHAR[MAX_STRESS_URL];
		szStressSYM_URL		= new TCHAR[MAX_STRESS_URL];
		szStressMemDmpPath	= new TCHAR[MAX_PATH];
		szStressInstanceID	= new TCHAR[MAX_PATH];
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		goto Exit;
	}

	if (!szPageheapCommand	|| !szUMDHCommand	||
		!szStressPDB_URL	|| !szStressSYM_URL	||
		!szStressMemDmpPath	|| !szStressInstanceID)
	{
		goto Exit;
	}

	if (!g_objServerCommands.IsStressRunning())
	{
		// free all old StressExeURLs first - we're replacing it with new URLs anyway
		g_objServerCommands.Clear_StressExeURLs();

		dwIndex					= 0;
		dwStressInstanceIDIndex	= 0;
		dwPageHeapCommandIndex	= 0;
		dwUMDHCommandIndex		= 0;
		dwStressPDBIndex		= 0;
		dwStressSYMIndex		= 0;
		dwStressMemDmpPathIndex	= 0;
		dwBufferSize			= MAX_URL;
		ZeroMemory(szBuffer, sizeof(szBuffer));

		while (WinHttpQueryHeaders(hRequest, WINHTTP_QUERY_CUSTOM, COMMANDHEADER__STRESS_EXE_URL, szBuffer, &dwBufferSize, &dwIndex))
		{
			// *************************************
			// *************************************
			// ** COMMANDHEADER__MEMORY_DUMP_PATH: A valid path
			ZeroMemory(szStressMemDmpPath, MAX_PATH);
			dwBufferSize	= MAX_PATH;
			WinHttpQueryHeaders(hRequest, WINHTTP_QUERY_CUSTOM, COMMANDHEADER__MEMORY_DUMP_PATH, szStressMemDmpPath, &dwBufferSize, &dwStressMemDmpPathIndex);


			// *************************************
			// *************************************
			// ** Get COMMANDHEADER__STRESS_PDB_URL if there is one
			// **
			ZeroMemory(szStressPDB_URL, MAX_STRESS_URL);
			dwBufferSize	= MAX_STRESS_URL;
			WinHttpQueryHeaders(hRequest, WINHTTP_QUERY_CUSTOM, COMMANDHEADER__STRESS_PDB_URL, szStressPDB_URL, &dwBufferSize, &dwStressPDBIndex);


			// *************************************
			// *************************************
			// ** Get COMMANDHEADER__STRESS_SYM_URL if there is one
			// **
			ZeroMemory(szStressSYM_URL, MAX_STRESS_URL);
			dwBufferSize	= MAX_STRESS_URL;
			WinHttpQueryHeaders(hRequest, WINHTTP_QUERY_CUSTOM, COMMANDHEADER__STRESS_SYM_URL, szStressSYM_URL, &dwBufferSize, &dwStressSYMIndex);


			// *************************************
			// *************************************
			// ** Get COMMANDHEADER__STRESS_EXE_PAGEHEAP if there is one
			// **
			ZeroMemory(szPageheapCommand, MAX_PATH);
			dwBufferSize	= MAX_PATH;
			WinHttpQueryHeaders(hRequest, WINHTTP_QUERY_CUSTOM, COMMANDHEADER__STRESS_EXE_PAGEHEAP, szPageheapCommand, &dwBufferSize, &dwPageHeapCommandIndex);

			// *************************************
			// *************************************
			// ** Get COMMANDHEADER__STRESS_EXE_UMDH if there is one
			// **
			ZeroMemory(szUMDHCommand, MAX_PATH);
			dwBufferSize	= MAX_PATH;
			WinHttpQueryHeaders(hRequest, WINHTTP_QUERY_CUSTOM, COMMANDHEADER__STRESS_EXE_UMDH, szUMDHCommand, &dwBufferSize, &dwUMDHCommandIndex);
			

			// *************************************
			// *************************************
			// ** Get COMMANDHEADER__STRESS_EXE_INSTANCEID
			// For each COMMANDHEADER__STRESS_EXE_URL, there must be an index for the stress instance from the StressADMIN DB table.
			// This identifies the stressinstance run. The test case (stressinstance) WILL NOT be added and run without an ID number.
			ZeroMemory(szStressInstanceID, MAX_PATH);
			dwBufferSize	= MAX_PATH;

			if (WinHttpQueryHeaders(hRequest, WINHTTP_QUERY_CUSTOM, COMMANDHEADER__STRESS_EXE_INSTANCEID, szStressInstanceID, &dwBufferSize, &dwStressInstanceIDIndex))
			{
				// convert header ID string to a DWORD
				dwStressInstanceID = _ttol(szStressInstanceID);

				// only add valid stressInstances with valid ID's
				if (0 < dwStressInstanceID)
				{
					g_objServerCommands.Create_StressInstance(
						dwStressInstanceID,
						szPageheapCommand,
						szUMDHCommand,
						szStressPDB_URL,
						szStressSYM_URL,
						szStressMemDmpPath,
						szBuffer);

					dwBufferSize = MAX_URL;
					ZeroMemory(szBuffer, MAX_URL);
				}
			}
		}
	}


	// *********************************
	// **** COMMANDHEADER__ABORT: Abort the stress instance running specified by this header.
	dwIndex			= 0;
	dwBufferSize	= MAX_URL;
	ZeroMemory(szBuffer, sizeof(szBuffer));
	while (WinHttpQueryHeaders(hRequest, WINHTTP_QUERY_CUSTOM, COMMANDHEADER__ABORT, szBuffer, &dwBufferSize, &dwIndex))
		g_objServerCommands.AbortStressInstance(_ttol(szBuffer));


Exit:
	LeaveCriticalSection(&g_csServerCommandsVars);

	if (hRequest)
		WinHttpCloseHandle(hRequest);

	if (hSession)
		WinHttpCloseHandle(hSession);

	if (hRoot)
		WinHttpCloseHandle(hRoot);

	// free memory if allocs succeeded
	if (urlComponents.lpszScheme)
		delete [] urlComponents.lpszScheme;

	if (urlComponents.lpszHostName)
		delete [] urlComponents.lpszHostName;

	if (urlComponents.lpszUrlPath)
		delete [] urlComponents.lpszUrlPath;

	if (urlComponents.lpszExtraInfo)
		delete [] urlComponents.lpszExtraInfo;

	if (urlComponents.lpszUserName)
		delete [] urlComponents.lpszUserName;

	if (urlComponents.lpszPassword)
		delete [] urlComponents.lpszPassword;

	// more to go
	if (szPageheapCommand)
		delete [] szPageheapCommand;

	if (szUMDHCommand)
		delete [] szUMDHCommand;

	if (szStressPDB_URL)
		delete [] szStressPDB_URL;

	if (szStressSYM_URL)
		delete [] szStressSYM_URL;

	if (szStressMemDmpPath)
		delete [] szStressMemDmpPath;

	if (szStressInstanceID)
		delete [] szStressInstanceID;

	if (szPost)
		delete [] szPost;
	
	ExitThread(bResult);
}




// *******************************************************************
// *******************************************************************
// ****
// **** ServerCommands class member functions
// ****

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

ServerCommands::ServerCommands()
{
	m_dwCommandServerUpdateInternval	= STRESS_COMMAND_SERVER_UPDATE_INTERVAL;
	m_bExit								= FALSE;
	m_dwStressInstanceIterator			= NULL;
	g_hQueryServerForCommands			= NULL;

	m_szCommandServerURL				= new TCHAR[MAX_STRESS_URL];
	m_szWinHttpDLL_DownloadURL			= new TCHAR[MAX_STRESS_URL];
	m_szWinHttpPDB_DownloadURL			= new TCHAR[MAX_STRESS_URL];
	m_szWinHttpSYM_DownloadURL			= new TCHAR[MAX_STRESS_URL];
	m_szWinHttpDLL_FileName				= new TCHAR[MAX_PATH];
	m_szStressSchedulerCurrentDirectory	= new TCHAR[MAX_PATH];
	m_szClientMachineName				= new CHAR[MAX_PATH];

	ZeroMemory(m_szCommandServerURL,				MAX_STRESS_URL);
	ZeroMemory(m_szWinHttpDLL_DownloadURL,			MAX_STRESS_URL);
	ZeroMemory(m_szWinHttpPDB_DownloadURL,			MAX_STRESS_URL);
	ZeroMemory(m_szWinHttpSYM_DownloadURL,			MAX_STRESS_URL);
	ZeroMemory(m_szWinHttpDLL_FileName,				MAX_PATH);
	ZeroMemory(m_szStressSchedulerCurrentDirectory, MAX_PATH);
	ZeroMemory(m_szClientMachineName,				MAX_PATH);

	// initilize start/end times to -1 so we know that
	// there are not valid time and we'll skip the Begin/End stress time check
	// until we get real values from the command server
	m_iTimeStressBeginsHour		= -1;
	m_iTimeStressBeginsMinute	= -1;
	m_iTimeStressEndsHour		= -1;
	m_iTimeStressEndsMinute		= -1;
	m_bRunForever				= 0;

	m_dwClientID				= 0;


	// Set default URLs
	wcsncpy(m_szCommandServerURL, STRESS_COMMAND_SERVER_URL, sizeof(STRESS_COMMAND_SERVER_URL));

	// Get the current working directory
	GetCurrentDirectory(MAX_PATH, m_szStressSchedulerCurrentDirectory);

	// Get the client's machine name
	GetEnvironmentVariableA("COMPUTERNAME", m_szClientMachineName, MAX_PATH);

	InitializeCriticalSection(&g_csServerCommandsVars);
}


ServerCommands::~ServerCommands()
{
	DWORD	dwThreadExitCode	= 0;

	// Shut down QueryServer thread
	GetExitCodeThread(g_hQueryServerForCommands, &dwThreadExitCode);

	if (STILL_ACTIVE == dwThreadExitCode)
		WaitForSingleObject(g_hQueryServerForCommands, INFINITE);

	// free allocated memory for URLs
	Clear_StressExeURLs();

	// Free our handles
	CloseHandle(g_hQueryServerForCommands);
	DeleteCriticalSection(&g_csServerCommandsVars);


	if (m_szCommandServerURL)
		delete [] m_szCommandServerURL;

	if (m_szWinHttpDLL_DownloadURL)
		delete [] m_szWinHttpDLL_DownloadURL;

	if (m_szWinHttpPDB_DownloadURL)
		delete [] m_szWinHttpPDB_DownloadURL;

	if (m_szWinHttpSYM_DownloadURL)
		delete [] m_szWinHttpSYM_DownloadURL;

	if (m_szWinHttpDLL_FileName)
		delete [] m_szWinHttpDLL_FileName;

	if (m_szStressSchedulerCurrentDirectory)
		delete [] m_szStressSchedulerCurrentDirectory;

	if (m_szClientMachineName)
		delete [] m_szClientMachineName;
}


////////////////////////////////////////////////////////////
// Function:  ServerCommands::GetCurrentWorkingDirectory()
//
// Purpose:
//	Returns string containing the current working directory for
//	this application.
//
////////////////////////////////////////////////////////////
LPTSTR
ServerCommands::Get_CurrentWorkingDirectory()
{
	return m_szStressSchedulerCurrentDirectory;
}


////////////////////////////////////////////////////////////
// Function:  ServerCommands::Get_ClientMachineName()
//
// Purpose:
//	Returns string containing the machine's NETBIOS name
//
////////////////////////////////////////////////////////////
LPSTR
ServerCommands::Get_ClientMachineName()
{
	return m_szClientMachineName;
}


////////////////////////////////////////////////////////////
// Function:  ServerCommands::QueryServerForCommands()
//
// Purpose:
//	This method sends a request to the command server for instructions
//	and saves them in our private vars. 
//
////////////////////////////////////////////////////////////
ServerCommands::QueryServerForCommands()
{
	BOOL	bResult				= TRUE;
	DWORD	dwThreadID			= 0;
	DWORD	dwTimeOut			= 0;
	DWORD	dwThreadExitCode	= 0;

	// See if thread is still active before spinning off a new one
	GetExitCodeThread(g_hQueryServerForCommands, &dwThreadExitCode);

	if (STILL_ACTIVE == dwThreadExitCode)
	{
		// wait for existing thread to finish
		dwTimeOut = 0;
		dwTimeOut = WaitForSingleObject(g_hQueryServerForCommands, 500);

		if (WAIT_TIMEOUT == dwTimeOut)
			bResult = FALSE;
	}
	else
	{
		// free handle for previous thread
		CloseHandle(g_hQueryServerForCommands);

		// spin off thread to query server
		g_hQueryServerForCommands = NULL;
		g_hQueryServerForCommands = CreateThread(NULL, 0, QueryServerForCommands_ThreadProc, (LPVOID) this, 0, &dwThreadID);

		if (!g_hQueryServerForCommands)
			bResult = FALSE;
	}

	return bResult;
}


////////////////////////////////////////////////////////////
// Function:  ServerCommands::Download_WinHttpDLL()
//
// Purpose:
//	Downloads the test DLL and symbols to the c:\winhttpstress\stressEXE dir
//	if this fails then we try to regsvr "winhttp5.dll" in the system search
//	path. If that fails, then we fail. We want ANY version of winhttp available on
//	the system for use since we may not want to download a new version for every test.
//
////////////////////////////////////////////////////////////
BOOL ServerCommands::Download_WinHttpDLL()
{
	BOOL		bResult				= TRUE;
	LPTSTR		szSymbolFileName	= NULL;
	LPTSTR		szBuffer			= NULL;
	DWORD		dwBufferSize		= MAX_PATH * 8;
	HINSTANCE	hLib				= NULL;


	szSymbolFileName	= new TCHAR[MAX_PATH];
	szBuffer			= new TCHAR[dwBufferSize];

	if (!szSymbolFileName || !szBuffer)
		goto Exit;

	// ************************
	// ************************
	// ** download the file to stressExe directory
	// **
	_tcscpy(szBuffer, m_szStressSchedulerCurrentDirectory);
	_tcscat(szBuffer, _T("\\"));
	_tcscat(szBuffer, STRESSINSTANCE_STRESS_EXE_DOWNLOAD_DIR);

	// download DLL if needed
	if (_tcsclen(m_szWinHttpDLL_DownloadURL) > 0)
		bResult = 
			NetworkTools__URLDownloadToFile(
			m_szWinHttpDLL_DownloadURL,
			szBuffer,
			m_szWinHttpDLL_FileName);

	if (bResult)
	{
		// download PDB file if needed
		if (_tcsclen(m_szWinHttpPDB_DownloadURL) > 0)
		{
			NetworkTools__GetFileNameFromURL(m_szWinHttpPDB_DownloadURL, szSymbolFileName, MAX_PATH);

			if (!NetworkTools__URLDownloadToFile(m_szWinHttpPDB_DownloadURL, szBuffer, szSymbolFileName))
				NetworkTools__SendLog(FIELDNAME__LOGTYPE_ERROR, "PDB symbol file failed to downloaded.", NULL, 0);
		}


		// download sym file if needed
		if (_tcsclen(m_szWinHttpSYM_DownloadURL) > 0)
		{
			NetworkTools__GetFileNameFromURL(m_szWinHttpSYM_DownloadURL, szSymbolFileName, MAX_PATH);

			if (!NetworkTools__URLDownloadToFile(m_szWinHttpSYM_DownloadURL, szBuffer, szSymbolFileName))
				NetworkTools__SendLog(FIELDNAME__LOGTYPE_ERROR, "SYM symbol file failed to downloaded.", NULL, 0);
		}
	}

	// if failed to download DLL, it's probably in use. We'll try to regsvr32 it anyways if it's there.

	// ************************
	// ************************
	// ** regsvr32'ed the dll just downloaded in the stressExe dir
	// **
	_tcscat(szBuffer, _T("\\"));
	_tcscat(szBuffer, m_szWinHttpDLL_FileName);
	hLib = LoadLibrary(szBuffer);

	if (hLib < (HINSTANCE)HINSTANCE_ERROR)
	{
		// unable to load the DLL - so we try to load it the version from the system path
		hLib = LoadLibrary(_T("winhttp5.dll"));

		// if that doesn't exist then we fail since winhttp5.dll can be loaded by the stressApp
		if (hLib < (HINSTANCE)HINSTANCE_ERROR)
		{
			bResult = FALSE;
			goto Exit;
		}
	}

	// **********************
	// **********************
	// ** Register the DLL
	typedef VOID (CALLBACK* LPFNDLLFUNC1)();
	LPFNDLLFUNC1 lpDllEntryPoint;

	// Find the entry point.
	(FARPROC&)lpDllEntryPoint = GetProcAddress(hLib, "DllRegisterServer");

	if (lpDllEntryPoint != NULL)
		(*lpDllEntryPoint)();
	else
	{
		//unable to locate entry point - regsvr failed
		bResult = FALSE;
	}


Exit:
	// unload library only if valid
	if (hLib && (hLib >= (HINSTANCE)HINSTANCE_ERROR))
		FreeLibrary(hLib);

	if (bResult)
		NetworkTools__SendLog(FIELDNAME__LOGTYPE_INFORMATION, "winhttp5 DLL and symbols downloaded and registered successfully.", NULL, 0);
	else
		NetworkTools__SendLog(FIELDNAME__LOGTYPE_ERROR, "winhttp5 DLL or symbols failed to download or register successfully.", NULL, 0);

	if (szSymbolFileName)
		delete [] szSymbolFileName;

	if (szBuffer)
		delete [] szBuffer;

	return bResult;
}


////////////////////////////////////////////////////////////
// Function:  ServerCommands::Set_RunForever(BOOL)
//
// Purpose:
//	Pass in TRUE to run forever ignoring begin/end time, FALSE not to.
//
// Called by: QueryServerForCommands_ThreadProc
//
////////////////////////////////////////////////////////////
VOID
ServerCommands::Set_RunForever(
	BOOL bRunForever	// [IN] TRUE to run forever ignoring begin/end time, FALSE not to.
)
{
	m_bRunForever = bRunForever;
}


////////////////////////////////////////////////////////////
// Function:  ServerCommands::Set_ExitStress(BOOL)
//
// Purpose:
//	Pass in TRUE to exit stress as soon as possible and FALSE
//	not to.
//
// Called by: QueryServerForCommands_ThreadProc
//
////////////////////////////////////////////////////////////
VOID
ServerCommands::Set_ExitStress(
	BOOL bExitStress	// [IN] TRUE to exit stress, FALSE not to.
)
{
	m_bExit = bExitStress;
}


////////////////////////////////////////////////////////////
// Function:  ServerCommands::Set_WinHttpDllURL(LPTSTR, DWORD)
//
// Purpose:
//	Pass in an URL and its size and to get the WinHttp DLL from.
//
// Called by: QueryServerForCommands_ThreadProc
//
////////////////////////////////////////////////////////////
VOID
ServerCommands::Set_WinHttpDllURL(
	LPTSTR szBuffer,	// [IN] string buffer containing URL to the WINHTTP DLL
	DWORD dwBufferSize	// [IN] size of the szBuffer in TCHARs
)
{
	_tcscpy(m_szWinHttpDLL_DownloadURL, szBuffer);

	// Get the full DLL filename from the URL
	NetworkTools__GetFileNameFromURL(m_szWinHttpDLL_DownloadURL, m_szWinHttpDLL_FileName, MAX_PATH);
}


////////////////////////////////////////////////////////////
// Function:  ServerCommands::Set_WinHttpPDBURL(LPTSTR, DWORD)
//
// Purpose:
//	Pass in an URL and its size and to get the WinHttp PDB file from.
//
// Called by: QueryServerForCommands_ThreadProc
//
////////////////////////////////////////////////////////////
VOID
ServerCommands::Set_WinHttpPDBURL(
	LPTSTR szBuffer,	// [IN] string buffer containing URL to the WINHTTP DLL
	DWORD dwBufferSize	// [IN] size of the szBuffer in TCHARs
)
{
	_tcscpy(m_szWinHttpPDB_DownloadURL, szBuffer);
}


////////////////////////////////////////////////////////////
// Function:  ServerCommands::Set_WinHttpSYMURL(LPTSTR, DWORD)
//
// Purpose:
//	Pass in an URL and its size and to get the WinHttp SYM file from.
//
// Called by: QueryServerForCommands_ThreadProc
//
////////////////////////////////////////////////////////////
VOID
ServerCommands::Set_WinHttpSYMURL(
	LPTSTR szBuffer,	// [IN] string buffer containing URL to the WINHTTP DLL
	DWORD dwBufferSize	// [IN] size of the szBuffer in TCHARs
)
{
	_tcscpy(m_szWinHttpSYM_DownloadURL, szBuffer);
}


////////////////////////////////////////////////////////////
// Function:  ServerCommands::Set_CommandServerURL(LPTSTR)
//
// Purpose:
//	Pass in a timeout value in milliseconds to query the 
//	Command Server for commands.
//
// Called by: QueryServerForCommands_ThreadProc
//
////////////////////////////////////////////////////////////
VOID
ServerCommands::Set_CommandServerURL(
	LPTSTR szBuffer,	// [IN] string buffer containing URL to the WINHTTP DLL
	DWORD dwBufferSize	// [IN] size of the szBuffer in TCHARs
)
{
	_tcscpy(m_szCommandServerURL, szBuffer);
}


////////////////////////////////////////////////////////////
// Function:  ServerCommands::Set_CommandServerUpdateInterval(DWORD)
//
// Purpose:
//	Pass in a timeout value in milliseconds to query the 
//	Command Server for commands.
//
// Called by: QueryServerForCommands_ThreadProc
//
////////////////////////////////////////////////////////////
VOID
ServerCommands::Set_CommandServerUpdateInterval(
	DWORD dwUpdateInterval	// [IN] time to wait before pinging the Command Server in milliseconds
)
{
	// server update interval must be at least greater than the minimum timeout
	if (STRESS_COMMAND_SERVER_MINIMUM_UPDATE_INTERVAL < dwUpdateInterval &&
		STRESS_COMMAND_SERVER_MAXIMUM_UPDATE_INTERVAL > dwUpdateInterval)
		m_dwCommandServerUpdateInternval = dwUpdateInterval;
}


////////////////////////////////////////////////////////////
// Function:  ServerCommands::Set_TimeStressBegins(DWORD, DWORD)
//
// Purpose:
//	Pass in a time string to begin stress in 24 hour time.
//	Takes two parameters to set the hour and minute. A parameter
//	will be ignored if NULL.
//
// Called by: QueryServerForCommands_ThreadProc
//
////////////////////////////////////////////////////////////
VOID
ServerCommands::Set_TimeStressBegins(
	LPTSTR szHour,	// [IN] 0-23 parameter ignored if < 0
	LPTSTR szMinute	// [IN] 0-59 parameter ignored if < 0
)
{
	if (szHour)
		m_iTimeStressBeginsHour = _ttoi(szHour);

	if (szMinute)
		m_iTimeStressBeginsMinute = _ttoi(szMinute);
}


////////////////////////////////////////////////////////////
// Function:  ServerCommands::Set_TimeStressEnds(DWORD, DWORD)
//
// Purpose:
//	Pass in a time string to end stress in 24 hour time.
//	Takes two parameters to set the hour and minute. A parameter
//	will be ignored if NULL.
//
// Called by: QueryServerForCommands_ThreadProc
//
////////////////////////////////////////////////////////////
VOID
ServerCommands::Set_TimeStressEnds(
	LPTSTR szHour,	// [IN] 0-23 parameter ignored if < 0
	LPTSTR szMinute	// [IN] 0-59 parameter ignored if < 0
)
{
	if (szHour)
		m_iTimeStressEndsHour = _ttoi(szHour);

	if (szMinute)
		m_iTimeStressEndsMinute = _ttoi(szMinute);
}


////////////////////////////////////////////////////////////
// Function:  ServerCommands::Create_StressInstance(LPTSTR)
//
// Purpose:
//	Pass in an URL and its size and it will be added to the 
//  m_arStressInstanceList list. There is no limit on the number of
//	URLs that can be added.
//
// Called by: QueryServerForCommands_ThreadProc
//
////////////////////////////////////////////////////////////
VOID
ServerCommands::Create_StressInstance(
	DWORD	dwStressInstanceID,	// [IN] ID from the stressAdmin DB identifying this stressInstance
	LPTSTR	szPageHeapCommand,	// [IN] string buffer containing the pageheap command line
	LPTSTR	szUMDHCommand,		// [IN] string buffer containing the UMDH command line
	LPTSTR	szPDB_URL,			// [IN] string buffer containing URL to the stress EXE's PDB file
	LPTSTR	szSYM_URL,			// [IN] string buffer containing URL to the stress EXE's SYM file
	LPTSTR	szMemDumpPath,		// [IN] string buffer containing path to create memory dump files
	LPTSTR	szEXE_URL			// [IN] string buffer containing URL to the stress EXE
)
{
	PSTRESSINSTANCE pStressInstance = NULL;

	// verify params just in case
	if (!szEXE_URL)
		return;

	// allocate memory for the object and put it in the list if successful
	__try
	{
		pStressInstance = new StressInstance;
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		pStressInstance = NULL;
	}

	if (!pStressInstance)
		return;

	pStressInstance->Set_UMDHCommands(szUMDHCommand);
	pStressInstance->Set_PageHeapCommands(szPageHeapCommand);
	pStressInstance->Set_StressExeID(dwStressInstanceID);
	pStressInstance->Set_StressExeURL(szEXE_URL);
	pStressInstance->Set_StressExeMemoryDumpPath(szMemDumpPath);
	pStressInstance->Set_StressExePdbURL(szPDB_URL);
	pStressInstance->Set_StressExeSymURL(szSYM_URL);

	m_arStressInstanceList.push_back(pStressInstance);
	m_dwStressInstanceIterator = m_arStressInstanceList.begin();
}


////////////////////////////////////////////////////////////
// Function:  ServerCommands::Clear_StressExeURLs()
//
// Purpose:
//	Frees memory from the m_arStressExeList vector.
//
// Called by: QueryServerForCommands_ThreadProc and ~ServerCommands
//
////////////////////////////////////////////////////////////
VOID
ServerCommands::Clear_StressExeURLs()
{
	// don't want to delete StressInstances if it's still running
	if (IsStressRunning())
		return;

	StressInstance *pStressInstance = NULL;

	for (int iIndex=0; iIndex < m_arStressInstanceList.size(); iIndex++)
	{
		pStressInstance = m_arStressInstanceList[iIndex];
		m_arStressInstanceList.erase(&m_arStressInstanceList[iIndex]);

		if (pStressInstance)
		{
			__try
			{
				delete pStressInstance;
			}
			__except(EXCEPTION_EXECUTE_HANDLER)
			{
				// oh well, we tried...
				pStressInstance = NULL;
			}
		}
	}

	m_dwStressInstanceIterator = NULL;
}


////////////////////////////////////////////////////////////
// Function:  ServerCommands::Get_CommandServerUpdateInterval()
//
// Purpose:
//	Returns the current setting for the Command Server Update
//	interval.
//
////////////////////////////////////////////////////////////
DWORD
ServerCommands::Get_CommandServerUpdateInterval()
{
	if (STRESS_COMMAND_SERVER_MINIMUM_UPDATE_INTERVAL < m_dwCommandServerUpdateInternval &&
		STRESS_COMMAND_SERVER_MAXIMUM_UPDATE_INTERVAL > m_dwCommandServerUpdateInternval)
		return m_dwCommandServerUpdateInternval;
	else
		return STRESS_COMMAND_SERVER_UPDATE_INTERVAL;
}


////////////////////////////////////////////////////////////
// Function:  ServerCommands::BeginStress()
//
// Purpose:
//	Queries for commands then starts the StressInstance objects.
//
////////////////////////////////////////////////////////////
void
ServerCommands::BeginStress()
{
	EnterCriticalSection(&g_csServerCommandsVars);

	if (!m_arStressInstanceList.empty() && !IsStressRunning())
	{
		// LOGLOG: Stress is beginning
		NetworkTools__SendLog(FIELDNAME__LOGTYPE_BEGIN_STRESS, "Stress is beginning.", NULL, NULL);

		// first download and regsvr32 the winhttp dll and symbols
		Download_WinHttpDLL();

		for(int iIndex = 0; iIndex < m_arStressInstanceList.size(); iIndex++)
			m_arStressInstanceList[iIndex]->Begin();
	}
	else
	{
		// ping Command Server for list of stress EXE URLs.
		QueryServerForCommands();
	}

	LeaveCriticalSection(&g_csServerCommandsVars);
}


////////////////////////////////////////////////////////////
// Function:  ServerCommands::EndStress()
//
// Purpose:
//	Ends stress and posts the results to the Command Server.
//
////////////////////////////////////////////////////////////
VOID
ServerCommands::EndStress()
{
	EnterCriticalSection(&g_csServerCommandsVars);

	if (!m_arStressInstanceList.empty())
	{
		if (IsStressRunning())
		{
			// LOGLOG: Stress is ending
			NetworkTools__SendLog(FIELDNAME__LOGTYPE_END_STRESS, "Stress is ending.", NULL, NULL);
		}

		for (int iIndex = 0; iIndex <  m_arStressInstanceList.size(); iIndex++)
			m_arStressInstanceList[iIndex]->End();

		// Remove the stress objects that already finished
		Clear_StressExeURLs();
	}

	LeaveCriticalSection(&g_csServerCommandsVars);
}


////////////////////////////////////////////////////////////
// Function:  ServerCommands::AbortStressInstance(DWORD)
//
// Purpose:
//	Aborts a all stress instances that recieved a server abort message.
//
// Called in:
//	QueryServerForCommands_ThreadProc
//
////////////////////////////////////////////////////////////
VOID
ServerCommands::AbortStressInstance(DWORD dwAbortID)
{
	// EnterCriticalSection(&g_csServerCommandsVars);

	if (!m_arStressInstanceList.empty())
	{
		for (int iIndex = 0; iIndex <  m_arStressInstanceList.size(); iIndex++)
		{
			if (m_arStressInstanceList[iIndex]->Get_ID() == dwAbortID)
				m_arStressInstanceList[iIndex]->End();
		}
	}

	//LeaveCriticalSection(&g_csServerCommandsVars);
}


////////////////////////////////////////////////////////////
// Function:  ServerCommands::IsStressRunning()
//
// Purpose:
//	Returns TRUE if any of the stressinstances is running. FALSE if not.
//
////////////////////////////////////////////////////////////
BOOL
ServerCommands::IsStressRunning()
{
	BOOL bIsRunning = FALSE;

	EnterCriticalSection(&g_csServerCommandsVars);

	if (!m_arStressInstanceList.empty())
	{
		for (int iIndex = 0; iIndex < m_arStressInstanceList.size(); iIndex++)
		{
			if (m_arStressInstanceList[iIndex]->IsRunning(STRESSINSTANCE_STRESS_EXE_CLOSE_TIMEOUT))
				bIsRunning = TRUE;
		}
	}

	LeaveCriticalSection(&g_csServerCommandsVars);

	return bIsRunning;
}


////////////////////////////////////////////////////////////
// Function:  ServerCommands::IsTimeToBeginStress()
//
// Purpose:
//	TRUE if it's time to begin stress based on the time returned
//	from the Command Server. Will return TRUE if m_sysTimeStressBegins
//	is current or in the future. FALSE if not.
//
////////////////////////////////////////////////////////////
BOOL
ServerCommands::IsTimeToBeginStress()
{
	SYSTEMTIME	stCurrent, stBeginStress, stEndStress;
	FILETIME	ftCurrent, ftBeginStress, ftEndStress;
	BOOL		bResult = FALSE;

	EnterCriticalSection(&g_csServerCommandsVars);

	// always run stress now if server tells us to
	if (m_bRunForever)
	{
		bResult = TRUE;
		goto Exit;
	}


	// check to see if valid time values have been received. If not, then we always fail.
	if (
		m_iTimeStressBeginsHour < 0 || m_iTimeStressBeginsMinute < 0 ||
		m_iTimeStressEndsHour < 0 || m_iTimeStressEndsMinute < 0
		)
	{
		bResult = FALSE;
		goto Exit;
	}

	GetLocalTime(&stCurrent);
	GetLocalTime(&stBeginStress);
	GetLocalTime(&stEndStress);

	// use the hour and minute time that we got from the command server
	stBeginStress.wHour		= m_iTimeStressBeginsHour;
	stBeginStress.wMinute	= m_iTimeStressBeginsMinute;

	stEndStress.wHour		= m_iTimeStressEndsHour;
	stEndStress.wMinute		= m_iTimeStressEndsMinute;

	// convert to file time so we can compare
	SystemTimeToFileTime(&stCurrent, &ftCurrent);
	SystemTimeToFileTime(&stBeginStress, &ftBeginStress);
	SystemTimeToFileTime(&stEndStress, &ftEndStress);


	// If EndTime < BeginTime, then it means stress is running for
	// over a day so we have to add 24 hours to the end time.
	ULARGE_INTEGER	ulEndStress;
	ULONGLONG		ullNanoSecondsInAFreakingDay;

	ulEndStress.LowPart		= ftEndStress.dwLowDateTime;
	ulEndStress.HighPart	= ftEndStress.dwHighDateTime;

	// stress runs across two days so we wrap around one day
	ullNanoSecondsInAFreakingDay = 24 * 60;		// minutes in a day
	ullNanoSecondsInAFreakingDay *= 60;			// seconds in a day
	ullNanoSecondsInAFreakingDay *= 1000000000;	// number of nanoseconds in a day. 10^9 NS in a second
	ullNanoSecondsInAFreakingDay /= 100;		// The FILETIME structure is a 64-bit value representing the number of 100-nanosecond intervals since January 1, 1601. 

	if (m_iTimeStressEndsHour < m_iTimeStressBeginsHour) 
	{
		// ********************
		// ********************
		// ** increase by 24 hours
		// **

		ulEndStress.QuadPart		 += ullNanoSecondsInAFreakingDay;

		// copy back to the original EndStress Date/Time
		ftEndStress.dwHighDateTime	= ulEndStress.HighPart;
		ftEndStress.dwLowDateTime	= ulEndStress.LowPart;

		FileTimeToSystemTime(&ftEndStress, &stEndStress);
	}
	else
	{
		// stress runs in the same day
		if ((m_iTimeStressEndsHour == m_iTimeStressBeginsHour) &&
			(m_iTimeStressEndsMinute <= m_iTimeStressBeginsMinute))
		{
			// if 7:30 to 7:20 - we wrap around one day.
			ulEndStress.QuadPart	+= ullNanoSecondsInAFreakingDay;

			// copy back to the original EndStress Date/Time
			ftEndStress.dwHighDateTime	= ulEndStress.HighPart;
			ftEndStress.dwLowDateTime	= ulEndStress.LowPart;

			FileTimeToSystemTime(&ftEndStress, &stEndStress);
		}
	}


	// Begin stress if:
	// (BeginTime <= CurrentTime <= EndTime)
	if ((0 <= CompareFileTime(&ftCurrent, &ftBeginStress)) && (0 <= CompareFileTime(&ftEndStress, &ftCurrent)))
		bResult = TRUE;
	else
		bResult = FALSE;

Exit:
	LeaveCriticalSection(&g_csServerCommandsVars);

	return bResult;
}


////////////////////////////////////////////////////////////
// Function:  ServerCommands::IsTimeToExitStress()
//
// Purpose:
//	TRUE if it's time to end stress based on the COMMANDHEADER__EXIT headers
//	from the Command Server exists. FALSE if not.
//
////////////////////////////////////////////////////////////
BOOL
ServerCommands::IsTimeToExitStress()
{
	return m_bExit;
}


////////////////////////////////////////////////////////////
// Function:  ServerCommands::Get_CommandServerURL()
//
// Purpose:
//	Returns the Command Server URL.
//
////////////////////////////////////////////////////////////
LPTSTR
ServerCommands::Get_CommandServerURL()
{
	return m_szCommandServerURL;
}


////////////////////////////////////////////////////////////
// Function:  ServerCommands::Get_NumberOfStressInstances()
//
// Purpose:
//	Returns the number of stressInstances running or pending.
//
////////////////////////////////////////////////////////////
DWORD
ServerCommands::Get_NumberOfStressInstances()
{
	return m_arStressInstanceList.size();
}


////////////////////////////////////////////////////////////
// Function:  ServerCommands::Get_TestDllFileName()
//
// Purpose:
//	Returns the name of the test DLL. ex. "winhttp5.dll"
//
////////////////////////////////////////////////////////////
LPTSTR
ServerCommands::Get_TestDllFileName()
{
	// m_szWinHttpDLL_FileName can be NULL in the case that a test DLL is not downloaded

	if (0 < _tcslen(m_szWinHttpDLL_FileName))
		return m_szWinHttpDLL_FileName;
	else
		return _T("winhttp5.dll");
}


////////////////////////////////////////////////////////////
// Function:  ServerCommands::Get_ClientID()
//
// Purpose:
//	Returns the client ID of the machine if registered. Zero if unsuccessful.
//
////////////////////////////////////////////////////////////
DWORD
ServerCommands::Get_ClientID()
{
	DWORD	dwBufferSize		= sizeof(m_dwClientID);
	LPSTR	szPostData			= NULL;
	LPSTR	szUserAlias			= NULL;
	LPSTR	szUserDomain		= NULL;
	DWORD	dwUserAliasSize		= MAX_PATH * 2;
	DWORD	dwPostDomainSize	= MAX_PATH * 2;
	DWORD	dwPostDataSize		= sizeof(POSTSTRING__GET_CLIENT_ID) + dwUserAliasSize + dwPostDomainSize;

	// query for the clientID only if we don't already have it
	if (m_dwClientID <= 0)
	{
		szPostData		= new CHAR[dwPostDataSize];
		szUserAlias		= new CHAR[dwUserAliasSize];
		szUserDomain	= new CHAR[dwPostDomainSize];

		if (!szPostData || !szUserAlias || !szUserDomain)
			goto Exit;

		ZeroMemory(szPostData, dwPostDataSize);
		ZeroMemory(szUserAlias, dwUserAliasSize);
		ZeroMemory(szUserDomain, dwPostDomainSize);

		// *********************
		// *********************
		// ** Stuff user info into POST string
		GetEnvironmentVariableA("USERNAME",		szUserAlias,	dwUserAliasSize-1);
		GetEnvironmentVariableA("USERDOMAIN",	szUserDomain,	dwPostDomainSize-1);

		sprintf(szPostData, POSTSTRING__GET_CLIENT_ID, Get_ClientMachineName(), szUserAlias, szUserDomain);

		if (!NetworkTools__GetHeaderValue(
				STRESS_COMMAND_SERVER_URL,
				szPostData,
				COMMANDHEADER__CLIENT_ID,
				WINHTTP_QUERY_CUSTOM | WINHTTP_QUERY_FLAG_NUMBER,
				&m_dwClientID,
				&dwBufferSize))
		{
			m_dwClientID = 0;
		}
	}

Exit:
	if (szPostData)
		delete [] szPostData;

	if (szUserAlias)
		delete [] szUserAlias;

	if (szUserDomain)
		delete [] szUserDomain;

	return m_dwClientID;
}


////////////////////////////////////////////////////////////
// Function:  ServerCommands::RegisterClient()
//
// Purpose:
//	Sends the command server the system info on this client.
//	This lets the command server know that this client is alive.
//
//	NOTE: This only works in NT because we query
//	environment vars not present in Win9x
//
////////////////////////////////////////////////////////////
BOOL
ServerCommands::RegisterClient()
{
	OSVERSIONINFOA	osInfo;
	BOOL			bResult		= FALSE;
	DWORD			dwPostSize	= 5000;
	DWORD			dwTempSize	= MAX_PATH;
	DWORD			dwSizeSoFar	= 0;	// size of string written to szTemp so far.
	LPSTR			szPost		= NULL;
	LPSTR			szTemp		= NULL;


	szPost		= new CHAR[dwPostSize];
	szTemp		= new CHAR[dwTempSize];

	if (!szPost || !szTemp)
		goto Exit;

	ZeroMemory(szTemp, dwTempSize);
	ZeroMemory(szPost, dwPostSize);

	// *********************
	// *********************
	// ** Get windows version info
	osInfo.dwOSVersionInfoSize = sizeof(osInfo);
	if (!GetVersionExA(&osInfo))
		goto Exit;

	dwSizeSoFar += GetEnvironmentVariableA("OS", szTemp, dwTempSize);
	dwSizeSoFar += sizeof(FIELDNAME__OS_PLATFORM);
	strcat(szPost, FIELDNAME__OS_PLATFORM);
	strcat(szPost, szTemp);

	strcat(szPost, "&" FIELDNAME__OS_BUILD);
	strcat(szPost, _itoa(osInfo.dwBuildNumber, szTemp, 10));

	strcat(szPost, "&" FIELDNAME__OS_MAJORVERSION);
	strcat(szPost, _itoa(osInfo.dwMajorVersion, szTemp, 10));

	strcat(szPost, "&" FIELDNAME__OS_MINORVERSION);
	strcat(szPost, _itoa(osInfo.dwMinorVersion, szTemp, 10));

	strcat(szPost, "&" FIELDNAME__OS_EXTRAINFO);
	strcat(szPost, osInfo.szCSDVersion);


	// *********************
	// *********************
	// ** Get processor info
	GetEnvironmentVariableA("PROCESSOR_ARCHITECTURE", szTemp, dwTempSize);
	strcat(szPost, "&" FIELDNAME__SYSTEMINFO_PROCSSSOR_ARCHITECTURE);
	strcat(szPost, szTemp);

	GetEnvironmentVariableA("PROCESSOR_IDENTIFIER", szTemp, dwTempSize);
	strcat(szPost, "&" FIELDNAME__SYSTEMINFO_PROCSSSOR_ID);
	strcat(szPost, szTemp);

	GetEnvironmentVariableA("PROCESSOR_LEVEL", szTemp, dwTempSize);
	strcat(szPost, "&" FIELDNAME__SYSTEMINFO_PROCSSSOR_LEVEL);
	strcat(szPost, szTemp);

	GetEnvironmentVariableA("PROCESSOR_REVISION", szTemp, dwTempSize);
	strcat(szPost, "&" FIELDNAME__SYSTEMINFO_PROCSSSOR_REVISION);
	strcat(szPost, szTemp);

	GetEnvironmentVariableA("NUMBER_OF_PROCESSORS", szTemp, dwTempSize);
	strcat(szPost, "&" FIELDNAME__SYSTEMINFO_PROCSSSOR_NUMBER_OF);
	strcat(szPost, szTemp);


	// *********************
	// *********************
	// ** Get user info
	GetEnvironmentVariableA("USERNAME", szTemp, dwTempSize);
	strcat(szPost, "&" FIELDNAME__USERINFO_USERALIAS);
	strcat(szPost, szTemp);

	GetEnvironmentVariableA("USERDOMAIN", szTemp, dwTempSize);
	strcat(szPost, "&" FIELDNAME__USERINFO_USERDOMAIN);
	strcat(szPost, szTemp);

	// BUGBUG: someone needs to resolve the user alias to the real full name of the user
	// FIELDNAME__USERINFO_FULLNAME


	// get the client's machine name
	strcat(szPost, "&" FIELDNAME__USERINFO_MACHINENAME);
	strcat(szPost, m_szClientMachineName);


	// Let the Command Server know that this client is alive
	bResult = NetworkTools__POSTResponse(STRESS_COMMAND_SERVER_REGISTERCLIENT_URL, szPost, NULL);

	// LOGLOG: stressScheduler has started
	bResult = NetworkTools__SendLog(FIELDNAME__LOGTYPE_START_UP, "WinHttpStressScheduler has started.", NULL, NULL);


Exit:
	if (szPost)
		delete [] szPost;

	if (szTemp)
		delete [] szTemp;

	return bResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\tools\stress\stressscheduler\src\stressinstance.cpp ===
//////////////////////////////////////////////////////////////////////
// File:  StressInstance.cpp
//
// Copyright (c) 2001 Microsoft Corporation.  All Rights Reserved.
//
// Purpose:
//	StressInstance.cpp: interface for the StressInstance class.
//	This class is used spawn and monitor instances of the stressEXE app
//
// History:
//	02/15/01	DennisCh	Created
//
//////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////
//
// Includes
//
//////////////////////////////////////////////////////////////////////

//
// Win32 headers
//

//
// Project headers
//
#include "StressInstance.h"
#include "ServerCommands.h"
#include "NetworkTools.h"
#include "MemStats.h"
#include "debugger.h"

//////////////////////////////////////////////////////////////////////
//
// Globals and statics
//
//////////////////////////////////////////////////////////////////////

extern ServerCommands	g_objServerCommands;	// Declared in WinHttpStressScheduler.cpp
extern HWND				g_hWnd;					// Declared in WinHttpStressScheduler.cpp

// Forward function definitions

VOID
CALLBACK
StressExe_TimerProc(
	HWND hwnd,         // [IN] handle to window
	UINT uMsg,         // [IN] WM_TIMER message
	UINT_PTR idEvent,  // [IN] timer identifier
	DWORD dwTime       // [IN] current system time
);

DWORD
DebuggerCallbackProc(
	DWORD	dwFlags,
	LPVOID	lpIn,
	LPTSTR	lpszFutureString,
	LPVOID	lpFuturePointer
);


//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////


StressInstance::StressInstance()
{
	m_szStressExe_URL					= new TCHAR[MAX_STRESS_URL];
	m_szStressExe_PDB_URL				= new TCHAR[MAX_STRESS_URL];
	m_szStressExe_SYM_URL				= new TCHAR[MAX_STRESS_URL];
	m_szStressExe_FilePath				= new TCHAR[MAX_STRESS_URL];
	m_szStressExe_FileName				= new TCHAR[MAX_STRESS_URL];
	m_szStressExe_FilePathAndName		= new TCHAR[MAX_STRESS_URL];
	m_szStressExe_PageHeapCommandLine	= new TCHAR[MAX_PATH];
	m_szStressExe_UMDHCommandLine		= new TCHAR[MAX_PATH];
	m_szStressExe_MemDumpPath			= new TCHAR[MAX_PATH];

	if (!m_szStressExe_URL ||
		!m_szStressExe_PDB_URL ||
		!m_szStressExe_SYM_URL ||
		!m_szStressExe_FilePath	||
		!m_szStressExe_FilePathAndName ||
		!m_szStressExe_PageHeapCommandLine ||
		!m_szStressExe_UMDHCommandLine ||
		!m_szStressExe_MemDumpPath)
	{
		throw;
	}

	ZeroMemory(m_szStressExe_URL,					MAX_STRESS_URL);
	ZeroMemory(m_szStressExe_PDB_URL,				MAX_STRESS_URL);
	ZeroMemory(m_szStressExe_SYM_URL,				MAX_STRESS_URL);
	ZeroMemory(m_szStressExe_FilePath,				MAX_STRESS_URL);
	ZeroMemory(m_szStressExe_FileName,				MAX_STRESS_URL);
	ZeroMemory(m_szStressExe_FilePathAndName,		MAX_STRESS_URL);
	ZeroMemory(m_szStressExe_PageHeapCommandLine,	MAX_PATH);
	ZeroMemory(m_szStressExe_UMDHCommandLine,		MAX_PATH);
	ZeroMemory(m_szStressExe_MemDumpPath,			MAX_PATH);
	
	ZeroMemory(&m_piStressExeProcess, sizeof(PROCESS_INFORMATION));

	m_hStressExe_ProcessExitEvent	= NULL;
	m_uiStressExeTimerID			= 0;

	m_dwStressInstanceRunID			= 0;

	m_objDebugger	= NULL;
}


StressInstance::~StressInstance()
{
	// End any running tests
	if (IsRunning(STRESSINSTANCE_STRESS_EXE_CLOSE_TIMEOUT))
		StressInstance::End();

	// ******************************
	// ******************************
	// ** End the stressExe monitoring timerproc
	if (m_uiStressExeTimerID)
		KillTimer(NULL, m_uiStressExeTimerID);

	if (m_szStressExe_URL)
		delete [] m_szStressExe_URL;

	if (m_szStressExe_PDB_URL)
		delete [] m_szStressExe_PDB_URL;

	if (m_szStressExe_SYM_URL)
		delete [] m_szStressExe_SYM_URL;

	if (m_szStressExe_FilePath)
		delete [] m_szStressExe_FilePath;

	if (m_szStressExe_FileName)
		delete [] m_szStressExe_FileName;

	if (m_szStressExe_FilePathAndName)
		delete [] m_szStressExe_FilePathAndName;

	if (m_szStressExe_PageHeapCommandLine)
		delete [] m_szStressExe_PageHeapCommandLine;

	if (m_szStressExe_UMDHCommandLine)
		delete [] m_szStressExe_UMDHCommandLine;

	if (m_szStressExe_MemDumpPath)
		delete [] m_szStressExe_MemDumpPath;
	

	m_szStressExe_URL					= NULL;
	m_szStressExe_PDB_URL				= NULL;
	m_szStressExe_SYM_URL				= NULL;
	m_szStressExe_FilePath				= NULL;
	m_szStressExe_FileName				= NULL;
	m_szStressExe_FilePathAndName		= NULL;
	m_szStressExe_PageHeapCommandLine	= NULL;
	m_szStressExe_UMDHCommandLine		= NULL;
	m_szStressExe_MemDumpPath			= NULL;

	// close stressExe process handles
	if (m_piStressExeProcess.hThread)
		CloseHandle(m_piStressExeProcess.hThread);

	if (m_piStressExeProcess.hProcess)
		CloseHandle(m_piStressExeProcess.hProcess);

	if (m_hStressExe_ProcessExitEvent)
		CloseHandle(m_hStressExe_ProcessExitEvent);

	m_piStressExeProcess.hThread	= NULL;
	m_piStressExeProcess.hProcess	= NULL;
	m_hStressExe_ProcessExitEvent	= NULL;

	// free debugger object
	if (m_objDebugger)
	{
		delete m_objDebugger;
		m_objDebugger = NULL;
	}
}


////////////////////////////////////////////////////////////
// Function:  StressInstance::Begin()
//
// Purpose:
//	This method begins stress by downloading the stress EXE from
//	m_szStressExe_URL and starts it in CDB.
//
////////////////////////////////////////////////////////////
BOOL
StressInstance::Begin()
{
	BOOL					bResult					= TRUE;
	LPTSTR					szCommandLine			= NULL;
	LPTSTR					szFileNameAndPath		= NULL;
	LPTSTR					szExitProcessName		= NULL;
	LPTSTR					szPID					= NULL;
	DWORD					dwCommandLineSize		= MAX_STRESS_URL*4;
	DWORD					dwFileNameAndPathSize	= MAX_STRESS_URL*2;
	LPSTARTUPINFO			pStartUpInfo			= NULL;
	PSECURITY_DESCRIPTOR	pSD						= NULL;
	SECURITY_ATTRIBUTES		securityAttributes;


	// don't start if stress is already running or we don't have a FileName or Path.
	if (IsRunning(5000) ||
		0 >= _tcslen(m_szStressExe_FilePath) ||
		0 >= _tcslen(m_szStressExe_FileName))
		goto Exit;


	szCommandLine			= new TCHAR[MAX_STRESS_URL*4];
	szFileNameAndPath		= new TCHAR[MAX_STRESS_URL*2];
	pStartUpInfo			= new STARTUPINFO;

	if (!szCommandLine || !szFileNameAndPath || !pStartUpInfo)
		goto Exit;


	// Notify the Command Server that this stressinstance is beginning
	NetworkTools__SendLog(FIELDNAME__LOGTYPE_BEGIN, "This stressInstance is beginning.", NULL, Get_ID());

	// cache the stressInstanceRunID
	m_dwStressInstanceRunID = Get_StressInstanceRunID();

	// If we can't obtain this ID, this means the command server is down.
	// m_dwStressInstanceRunID is used only when logging a DMP file to LOR. Try again then if we can't get it now. 
	if (m_dwStressInstanceRunID <= 0)
		NetworkTools__SendLog(FIELDNAME__LOGTYPE_ERROR, "StressInstance::Begin() - Could not obtain stressInstanceRunID!", NULL, Get_ID());


	// ********************************
	// ********************************
	// ** Download the stressExe and symbols.
	// **
	if (!DownloadStressExe())
	{
		bResult = FALSE;
		goto Exit;
	}


	// ********************************
	// ********************************
	// ** Enable pageheap if needed
	// **
	if (0 < _tcsclen(m_szStressExe_PageHeapCommandLine))
	{
		if (!NetworkTools__PageHeap(TRUE, m_szStressExe_FileName, m_szStressExe_PageHeapCommandLine))
		{
			NetworkTools__SendLog(FIELDNAME__LOGTYPE_ERROR, "Pageheap failed when trying to enable.", NULL, Get_ID());
			bResult = FALSE;
			// goto Exit; don't need to exit when pageheap fails
		}
		else
			NetworkTools__SendLog(FIELDNAME__LOGTYPE_SUCCESS, "Pageheap successfully enabled.", NULL, Get_ID());
	}


	// ********************************
	// ********************************
	// ** Create the stressExe process
	// **

	// build command line for CreateProcess of our stress app
	ZeroMemory(szCommandLine, dwCommandLineSize);
	_stprintf(szCommandLine, STRESSINSTANCE_DEBUG_COMMANDLINE, m_szStressExe_FilePathAndName);

	// startupInfo
	ZeroMemory(pStartUpInfo, sizeof(STARTUPINFO));
	pStartUpInfo->cb				= sizeof(STARTUPINFO);
	pStartUpInfo->dwFillAttribute	= FOREGROUND_INTENSITY | FOREGROUND_GREEN | FOREGROUND_RED | BACKGROUND_RED | BACKGROUND_GREEN | BACKGROUND_BLUE;
	pStartUpInfo->dwFlags			= STARTF_USESHOWWINDOW | STARTF_USEFILLATTRIBUTE;
	pStartUpInfo->wShowWindow		= SW_MINIMIZE;


	// Create the stressExe process
	bResult =
	CreateProcess(
		NULL,
		m_szStressExe_FilePathAndName,
		NULL, 
		NULL,
		TRUE,
		CREATE_NEW_CONSOLE | CREATE_SEPARATE_WOW_VDM | NORMAL_PRIORITY_CLASS | CREATE_NEW_PROCESS_GROUP | CREATE_SUSPENDED,
		NULL,
		m_szStressExe_FilePath,
		pStartUpInfo,
		&m_piStressExeProcess);

	if (!bResult)
	{
		// stressExe failed to start 
		goto Exit;
	}


	// ********************************
	// ********************************
	// ** Attach debugger to the process only if there isn't one
	// **

	// remove debugger if there is one
	if (m_objDebugger)
	{
		delete m_objDebugger;
		m_objDebugger = NULL;
	}

	ResumeThread(m_piStressExeProcess.hThread);
	Sleep(1000);

	// attach new debugger
	m_objDebugger = new Debugger(m_piStressExeProcess.dwProcessId, DebuggerCallbackProc, (LPVOID)this);
	m_objDebugger->Go();

	
	// ********************************
	// ********************************
	// ** Initialize dynamically named event objects.
	// ** Set object access to ALL.
	// **

	// Create event object that'll be inherited by the stressExe process.
	// StressScheduler will signal when it's time to close stressExe.
	pSD = new SECURITY_DESCRIPTOR;

	if (!pSD)
		goto Exit;


	// Set a NULL security descriptor. This gives full access to handles when inherited
	InitializeSecurityDescriptor(pSD, SECURITY_DESCRIPTOR_REVISION);
	SetSecurityDescriptorDacl(pSD, TRUE, (PACL) NULL, FALSE);

	securityAttributes.bInheritHandle		= TRUE;
	securityAttributes.lpSecurityDescriptor	= pSD;
	securityAttributes.nLength				= sizeof(securityAttributes);


	// The named event object names have the PID of the process appended to the end of the constants
	// These strings are also created in the stressExe dynamically.
	szExitProcessName		= new TCHAR[MAX_PATH];
	szPID					= new TCHAR[16];

	if (!szExitProcessName || !szPID)
		goto Exit;


	// Get the processID string
	_itot(m_piStressExeProcess.dwProcessId, szPID, 10);

	// build ExitProcess event object name
	_tcscpy(szExitProcessName, STRESSINSTANCE_STRESS_EXE_EVENT_EXITPROCESS);
	_tcscat(szExitProcessName, szPID);

	if (m_hStressExe_ProcessExitEvent)
		CloseHandle(m_hStressExe_ProcessExitEvent);

	// this event is sent by us to stressExe when we want it to exit
	// Signaled = tell stressExe to exit; Not-Signaled = stressExe can continue running
	m_hStressExe_ProcessExitEvent = CreateEvent(
		&securityAttributes,
		FALSE,	// manual reset
		FALSE,
		szExitProcessName);


	// ********************************
	// ********************************
	// ** Begin the stressExe memory monitoring timerproc
	// **
	if (m_uiStressExeTimerID)
	{
		// there shouldn't be a timer already going. If so, nuke it.
		KillTimer(NULL, m_uiStressExeTimerID);
		m_uiStressExeTimerID = 0;
	}

	// create a new timer object and pass in the stressinstance pointer so we can use it later
	m_uiStressExeTimerID =
	SetTimer(
		g_hWnd,
		(UINT_PTR) this,
		STRESSINSTANCE_MONITOR_EXE_TIME,
		(TIMERPROC) StressExe_TimerProc);


	// Notify the Command Server that stress has started
	NetworkTools__SendLog(FIELDNAME__LOGTYPE_RUNNING, "This stressInstance has successfully started and is running.", NULL, Get_ID());

Exit:
	if (szCommandLine)
		delete [] szCommandLine;

	if (szFileNameAndPath)
		delete [] szFileNameAndPath;

	if (pStartUpInfo)
		delete [] pStartUpInfo;

	if (szExitProcessName)
		delete [] szExitProcessName;

	if (szPID)
		delete [] szPID;

	if (pSD)
		delete [] pSD;

	return bResult;
}


////////////////////////////////////////////////////////////
// Function:  StressInstance::End()
//
// Purpose:
//	This method ends stress by sending a message. If it doesn't
//	exit then we wait 30 seconds before detaching the debugger,
//	which will end the process.
//
////////////////////////////////////////////////////////////
VOID
StressInstance::End()
{
	// ******************************
	// ******************************
	// ** End the stressExe monitoring timerproc
	if (m_uiStressExeTimerID)
		KillTimer(NULL, m_uiStressExeTimerID);


	// ******************************
	// ******************************
	// ** Tell stressExe to shut down.
	SetEvent(m_hStressExe_ProcessExitEvent);

	// give time for the stressExe to exit
	/*
	if (IsRunning(STRESSINSTANCE_STRESS_EXE_CLOSE_TIMEOUT))
		Sleep(2000);
	*/


	// close stressExe process handles
	if (m_piStressExeProcess.hThread)
		CloseHandle(m_piStressExeProcess.hThread);

	if (m_piStressExeProcess.hProcess)
		CloseHandle(m_piStressExeProcess.hProcess);

	if (m_hStressExe_ProcessExitEvent)
		CloseHandle(m_hStressExe_ProcessExitEvent);

	m_piStressExeProcess.hThread	= NULL;
	m_piStressExeProcess.hProcess	= NULL;
	m_hStressExe_ProcessExitEvent	= NULL;


	// ********************************
	// ********************************
	// ** Detach the debugger object
	// **

	// detaching the debugger will (read: should) stop the stressExe
	if (m_objDebugger)
	{
		// ********************************
		// ********************************
		// ** Disable pageheap if needed
		// **
		NetworkTools__PageHeap(FALSE, m_szStressExe_FileName, NULL);

		// let the Command Server know that stressExe has ended
		// we send the message here because ServerCommands.cpp calls this too - even when
		// there isn't a running test case.
		// When the debugger object is valid, then we send the message - because it ensures that Begin() was called.
		NetworkTools__SendLog(FIELDNAME__LOGTYPE_END, "This stressInstance has ended.", NULL, Get_ID());

		delete m_objDebugger;
		m_objDebugger	= NULL;
	}

	ZeroMemory(&m_piStressExeProcess, sizeof(PROCESS_INFORMATION));
}


////////////////////////////////////////////////////////////
// Function:  StressInstance::Get_StressExeID()
//
// Purpose:
//	Returns the stress instance's ID receivedfrom the server
//
////////////////////////////////////////////////////////////
DWORD
StressInstance::Get_ID()
{
	return m_dwStressInstance_ID;
}


////////////////////////////////////////////////////////////
// Function:  StressInstance::Get_StressInstanceRunID()
//
// Purpose:
//	Gets the stressInstanceRunID generated by the DB that we
//	cache as soon as this instance starts.
//
////////////////////////////////////////////////////////////
DWORD
StressInstance::Get_StressInstanceRunID()
{
	DWORD	dwBufferSize		= sizeof(m_dwStressInstanceRunID);
	LPSTR	szPostData			= NULL;
	DWORD	dwPostDataSize		= sizeof(POSTSTRING__GET_CLIENT_ID) + MAX_PATH;

	// query for the clientID only if we don't already have it
	if (m_dwStressInstanceRunID <= 0)
	{
		szPostData		= new CHAR[dwPostDataSize];

		if (!szPostData)
			goto Exit;

		ZeroMemory(szPostData, dwPostDataSize);

		// *********************
		// *********************
		// ** Stuff user info into POST string
		sprintf(szPostData, POSTSTRING__GET_STRESSINSTANCERUN_ID, g_objServerCommands.Get_ClientID(), Get_ID());

		if (!NetworkTools__GetHeaderValue(
				STRESS_COMMAND_SERVER_URL,
				szPostData,
				COMMANDHEADER__STRESSINSTANCE_RUN_ID,
				WINHTTP_QUERY_CUSTOM | WINHTTP_QUERY_FLAG_NUMBER,
				&m_dwStressInstanceRunID,
				&dwBufferSize))
		{
			m_dwStressInstanceRunID = 0;
		}
	}

Exit:
	if (szPostData)
		delete [] szPostData;

	return m_dwStressInstanceRunID;
}



////////////////////////////////////////////////////////////
// Function:  StressInstance::Get_StressExeMemoryDumpPath()
//
// Purpose:
//	Sets the URL of the memory dump path
//
////////////////////////////////////////////////////////////
LPTSTR
StressInstance::Get_StressExeMemoryDumpPath()
{
	return m_szStressExe_MemDumpPath;
}


////////////////////////////////////////////////////////////
// Function:  StressInstance::Set_StressExeMemoryDumpPath()
//
// Purpose:
//	Sets the URL of the memory dump path
//
////////////////////////////////////////////////////////////
VOID
StressInstance::Set_StressExeMemoryDumpPath(
	LPTSTR szPath
)
{
	_tcsncpy(m_szStressExe_MemDumpPath, szPath, MAX_PATH);
}


////////////////////////////////////////////////////////////
// Function:  StressInstance::Set_StressExeURL(LPTSTR)
//
// Purpose:
//	Sets the URL to download the stress EXE for this object.
//
////////////////////////////////////////////////////////////
VOID
StressInstance::Set_StressExeURL(
	LPTSTR szBuffer	// [IN] Buffer containing the URL to download the stressExe app
)
{
	if (!szBuffer || (0 >= _tcslen(szBuffer)))
		return;

	_tcscpy(m_szStressExe_URL, szBuffer);

	// Set the stressExe's filename
	NetworkTools__GetFileNameFromURL(m_szStressExe_URL, m_szStressExe_FileName, MAX_STRESS_URL);

	// Set the stressExe's default path to download to with trailing slash
	GetCurrentDirectory(MAX_STRESS_URL, m_szStressExe_FilePath);
	_tcscat(m_szStressExe_FilePath, _T("\\") STRESSINSTANCE_STRESS_EXE_DOWNLOAD_DIR _T("\\"));

	// Set the full stressExe path + exe
	_tcscpy(m_szStressExe_FilePathAndName, m_szStressExe_FilePath);
	_tcscat(m_szStressExe_FilePathAndName, m_szStressExe_FileName);
}


////////////////////////////////////////////////////////////
// Function:  StressInstance::Set_StressExePdbURL(LPTSTR)
//
// Purpose:
//	Sets the URL to download the stress EXE's PDB file.
//
////////////////////////////////////////////////////////////
VOID
StressInstance::Set_StressExePdbURL(
	LPTSTR szBuffer	// [IN] Buffer containing the URL
)
{
	if (!szBuffer || (0 >= _tcslen(szBuffer)))
		return;

	_tcscpy(m_szStressExe_PDB_URL, szBuffer);
}


////////////////////////////////////////////////////////////
// Function:  StressInstance::Set_StressExeSymURL(LPTSTR)
//
// Purpose:
//	Sets the URL to download the stress EXE's SYM file.
//
////////////////////////////////////////////////////////////
VOID
StressInstance::Set_StressExeSymURL(
	LPTSTR szBuffer	// [IN] Buffer containing the URL
)
{
	if (!szBuffer || (0 >= _tcslen(szBuffer)))
		return;

	_tcscpy(m_szStressExe_SYM_URL, szBuffer);
}


////////////////////////////////////////////////////////////
// Function:  StressInstance::Set_StressExeID(DWORD)
//
// Purpose:
//	Sets the URL to download the stress EXE for this object.
//
////////////////////////////////////////////////////////////
VOID
StressInstance::Set_StressExeID(
	DWORD dwID	// [IN] ID from the stressAdmin DB uniquely identifying this stress EXE. 
)
{
	m_dwStressInstance_ID = dwID;
}


////////////////////////////////////////////////////////////
// Function:  StressInstance::Set_PageHeapCommands(LPCTSTR)
//
// Purpose:
//	Sets the pageheap command line.
//
////////////////////////////////////////////////////////////
VOID
StressInstance::Set_PageHeapCommands(
	LPCTSTR szCommandLine	// [IN] Extra command line params for pageheap.
)
{
	ZeroMemory(m_szStressExe_PageHeapCommandLine, MAX_PATH);
	_tcsncpy(m_szStressExe_PageHeapCommandLine, szCommandLine, MAX_PATH-1);
}


////////////////////////////////////////////////////////////
// Function:  StressInstance::Set_UMDHCommands(LPCTSTR)
//
// Purpose:
//	Sets the UMDH command line.
//
////////////////////////////////////////////////////////////
VOID
StressInstance::Set_UMDHCommands(
	LPCTSTR szCommandLine	// [IN] Extra command line params for UMDH.
)
{
	ZeroMemory(m_szStressExe_UMDHCommandLine, MAX_PATH);
	_tcsncpy(m_szStressExe_UMDHCommandLine, szCommandLine, MAX_PATH-1);
}


////////////////////////////////////////////////////////////
// Function:  StressInstance::DownloadStressExe()
//
// Purpose:
//	Downloads the stressExe app to the local machine.
//	We create a directory "stressExe" and put the file there. For example,
//	"http://hairball/files/stress1.exe" will be put in "stressExe\stress1.exe"
//	on the local machine. If the file is already there, it'll try to overwrite it.
//
////////////////////////////////////////////////////////////
BOOL
StressInstance::DownloadStressExe()
{
	BOOL	bResult		= TRUE;
	LPTSTR	szFileName	= NULL;

	szFileName	= new TCHAR[MAX_PATH];
	if (!szFileName)
		goto Exit;

	// Download the stressExe file
	if (!NetworkTools__URLDownloadToFile(m_szStressExe_URL, STRESSINSTANCE_STRESS_EXE_DOWNLOAD_DIR, m_szStressExe_FileName))
	{
		NetworkTools__SendLog(FIELDNAME__LOGTYPE_ERROR, "stress EXE file failed to downloaded.", NULL, Get_ID());
		bResult = FALSE;
	}

	// Download PDB symbol file if there is one
	if (NetworkTools__GetFileNameFromURL(m_szStressExe_PDB_URL, szFileName, MAX_PATH))
	{
		if (!NetworkTools__URLDownloadToFile(m_szStressExe_PDB_URL, STRESSINSTANCE_STRESS_EXE_DOWNLOAD_DIR, szFileName))
			NetworkTools__SendLog(FIELDNAME__LOGTYPE_ERROR, "stress PDB file failed to download.", NULL, Get_ID());
	}

	// Download SYM symbol file if there is one
	if (NetworkTools__GetFileNameFromURL(m_szStressExe_SYM_URL, szFileName, MAX_PATH))
	{
		if (!NetworkTools__URLDownloadToFile(m_szStressExe_SYM_URL, STRESSINSTANCE_STRESS_EXE_DOWNLOAD_DIR, szFileName))
			NetworkTools__SendLog(FIELDNAME__LOGTYPE_ERROR, "stress SYM file failed downloaded.", NULL, Get_ID());
	}

Exit:
	if (szFileName)
		delete [] szFileName;

	return bResult;
}


////////////////////////////////////////////////////////////
// Function:  StressInstance::IsRunning()
//
// Purpose:
//	Returns TRUE if this stressinstance is running. FALSE if not.
//
////////////////////////////////////////////////////////////
BOOL
StressInstance::IsRunning(
	DWORD	dwTimeOut	// [in] time to wait
)
{
	BOOL	bResult		= FALSE;
	HANDLE	hStressExe	= NULL;

	hStressExe = OpenProcess(PROCESS_QUERY_INFORMATION, FALSE, m_piStressExeProcess.dwProcessId);

	if (!hStressExe)
		bResult = FALSE;
	else
	{
		bResult = TRUE;
		CloseHandle(hStressExe);
	}

	return bResult;
}


////////////////////////////////////////////////////////////
// Function:  StressExe_TimerProc(HWND, UINT, UINT_PTR, DWORD)
//
// Purpose:
//	When this is called, we will check on the status of the
//	stressExe process send the command server it's memory info
//
////////////////////////////////////////////////////////////
VOID
CALLBACK
StressExe_TimerProc(
	HWND		hwnd,     // [IN] handle to window - should be NULL since we didn't specify one
	UINT		uMsg,     // [IN] WM_TIMER message
	UINT_PTR	idEvent,  // [IN] timer identifier - contains the pointer for the current StressInstance object
	DWORD		dwTime    // [IN] current system time
)
{
	// build directory to copy dump file
	LPSTR	szExeName = NULL;

	// make sure stress Instance object is valid
	StressInstance *pStressInstance = (StressInstance*) idEvent;

	if (!pStressInstance || IsBadCodePtr((FARPROC) pStressInstance))
		goto Exit;


	szExeName = new CHAR[MAX_STRESS_URL];
	if (!szExeName)
		goto Exit;


	// ***********************************
	// ***********************************
	// ** Check that the stressExe is still running. If it isn't end this instance.
	// **
	if (!pStressInstance->IsRunning(STRESSINSTANCE_STRESS_EXE_CLOSE_TIMEOUT))
	{
		NetworkTools__SendLog(FIELDNAME__LOGTYPE_INFORMATION, "This stress instance has exited prematurely.", NULL, pStressInstance->Get_ID());
		pStressInstance->End();
		goto Exit;
	}


	ZeroMemory(szExeName, MAX_STRESS_URL); 

	// ******************************
	// ** Remove the file extension of the stressExe name and send the system and process
	// ** memory log to the command server
	WideCharToMultiByte(
		CP_ACP,
		NULL,
		pStressInstance->m_szStressExe_FileName,
		-1,
		szExeName,
		MAX_STRESS_URL,
		NULL,
		NULL);

	MemStats__SendSystemMemoryLog(szExeName, pStressInstance->m_piStressExeProcess.dwProcessId, pStressInstance->Get_ID());

Exit:
	if (szExeName)
		delete [] szExeName;

	return;
}


////////////////////////////////////////////////////////////
// Function:  DebuggerCallbackProc(DWORD, LPVOID, LPTSTR, LPVOID)
//
// Purpose:
//	Creates a memory dump on second change exceptions
//
////////////////////////////////////////////////////////////
DWORD
DebuggerCallbackProc(
	DWORD	dwFlags,
	LPVOID	lpIn,
	LPTSTR	lpszFutureString,
	LPVOID	lpContext
)
{
	//test callback for debugger lib
	DWORD			dwContinue			= 0;
	LPSTR			szASCIIPath			= NULL;
	LPTSTR			szPath				= NULL;
	LPTSTR			szNum				= NULL;
	LPTSTR			szMachineName		= NULL;
	StressInstance	*pStressInstance	= (StressInstance*) lpContext;


	// ***********************************
	// ***********************************
	// ** Check that the stressExe is still running. Make sure lpFuturePointer (pointer to stressInstance that faulted) is valid
	// **
	if (!pStressInstance || !pStressInstance->IsRunning(STRESSINSTANCE_STRESS_EXE_CLOSE_TIMEOUT))
	{
		dwContinue = DEBUGGER_CONTINUE_STOP_DEBUGGING;
		goto Exit;
	}


	switch (dwFlags)
	{
		case DEBUGGER_FIRST_CHANCE_EXCEPTION:
			NetworkTools__SendLog(FIELDNAME__LOGTYPE_INFORMATION, "FIRST_CHANCE_EXCEPTION detected.", NULL, pStressInstance->Get_ID());
			//must use this to pass on first chance exceptions to the system
			dwContinue = DEBUGGER_CONTINUE_UNHANDLED;
			break;

		case DEBUGGER_SECOND_CHANCE_EXCEPTION:
			NetworkTools__SendLog(FIELDNAME__LOGTYPE_INFORMATION, "SECOND_CHANCE_EXCEPTION detected.", NULL, pStressInstance->Get_ID());

			// build directory to copy dump file
			DWORD	dwPathSize;

			dwPathSize		= MAX_PATH * 5;

			szASCIIPath		= new CHAR[dwPathSize];
			szPath			= new TCHAR[dwPathSize];
			szNum			= new TCHAR[100];
			szMachineName	= new TCHAR[MAX_PATH];

			if (!szASCIIPath || !szPath || !szNum || !szMachineName)
				goto Exit;


			// ******************************
			// create the directory STRESSINSTANCE_MEMORY_DUMP_PATH\<MachineName>
			//
			MultiByteToWideChar(
				CP_ACP,
				MB_PRECOMPOSED,
				g_objServerCommands.Get_ClientMachineName(),
				-1,
				szMachineName,
				MAX_PATH);

			// ******************************
			// ******************************
			// ** if the server sent a vaild path then use it, else use the default memory dump path
			// ** NOTE: we expect the dump path to already have a trailing slash.
			if (0 < _tcslen(pStressInstance->Get_StressExeMemoryDumpPath()))
				_tcscpy(szPath, pStressInstance->Get_StressExeMemoryDumpPath());
			else
				_tcscpy(szPath, STRESSINSTANCE_DEFAULT_MEMORY_DUMP_PATH);

			// add the machine name to the end of the directory
			_tcscat(szPath, szMachineName);

			CreateDirectory(szPath, NULL);

			// ******************************
			// create the filename in form "<stressExeFileName>-<stressInstanceID>-<PID>.dmp"
			_tcscat(szPath, _T("\\"));

			_tcscat(szPath, pStressInstance->m_szStressExe_FileName);
			_tcscat(szPath, _T("-"));

			_itot(pStressInstance->m_piStressExeProcess.dwProcessId, szNum, 10);
			_tcscat(szPath, szNum);
			_tcscat(szPath, _T("-"));

			_itot(pStressInstance->Get_StressInstanceRunID(), szNum, 10);
			_tcscat(szPath, szNum);
			_tcscat(szPath, _T(".dmp"));

			pStressInstance->m_objDebugger->CreateMiniDump(szPath, _T("This is a full user dump created by debugger.lib"), DEBUGGER_CREATE_FULL_MINI_DUMP);


			// ******************************
			// ** Convert to ansi so we can post it to the command server
			ZeroMemory(szASCIIPath, dwPathSize);
			WideCharToMultiByte(
				CP_ACP,
				NULL,
				szPath,
				-1,
				szASCIIPath,
				dwPathSize,
				NULL,
				NULL);

			// let the Command Server know a dump file was created
			NetworkTools__SendLog(FIELDNAME__LOGTYPE_DUMPFILE_CREATED, szASCIIPath, NULL, pStressInstance->Get_ID());


			// ******************************
			// ** Let the LOR server know that a DMP file was created so it can debug it
			NetworkTools__LogDumpFileInfo(szPath, pStressInstance->Get_StressInstanceRunID());

			// stop the debugger
			dwContinue = DEBUGGER_CONTINUE_STOP_DEBUGGING;
			break;

		case DEBUGGER_EXIT_PROCESS:
			dwContinue = DEBUGGER_CONTINUE_STOP_DEBUGGING;
			break;

		default:
			// let the Command Server know a dump file was created
			break;
	}


Exit:

	if (szASCIIPath)
		delete [] szASCIIPath;

	if (szPath)
		delete [] szPath;

	if (szNum)
		delete [] szNum;

	if (szMachineName)
		delete [] szMachineName;

	return dwContinue;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\tools\stress\stressapps\template\stresstesttemplate.cpp ===
//////////////////////////////////////////////////////////////////////
// File:  stressTest.cpp
//
// Copyright (c) 2001 Microsoft Corporation.  All Rights Reserved.
//
// Purpose:
//		<Description>
//
// History:
//	mm/dd/yy	<alias>		Created
//
//////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////
// Includes
//////////////////////////////////////////////////////////////////////
#include "stressMain.h"


//////////////////////////////////////////////////////////////////////
// Globals and constants
//////////////////////////////////////////////////////////////////////

// ************************************
// ************************************
// ** Fill in your test case name below
// ** 
LPSTR	g_szStressTestName = "<Your Test Case Name>";


// Foward function definitions
VOID CALLBACK MyStatusCallback(
    HINTERNET	hInternet,
    DWORD		dwContext,
    DWORD		dwInternetStatus,
    LPVOID		lpvStatusInformation,
    DWORD		dwStatusInformationLength
);


////////////////////////////////////////////////////////////
// Function:  WinHttp_StressTest()
//
// Purpose:
//	The stress test function. Insert your test code here.
//	Returning TRUE will cause main() to call this function again.
//	Otherwise, returning FALSE will cause the app to exit.
//
//	If you plan to loop within this function, be sure to 
//	use IsTimeToExitStress() as one of your exit conditions.
//
//	This must be done because the stressScheduler will notify
//	a this stress app when to exit based on the state of the
//	inherited event object that IsTimeToExitStress() checks for.
//	IsTimeToExitStress() will return TRUE when it's time to exit.
//
////////////////////////////////////////////////////////////
BOOL
WinHttp_StressTest()
{
	BOOL		bContinueStress = TRUE;

	// ************************************
	// ************************************
	// ** Add you test case code here
	// ** 

Exit:
	return bContinueStress;
}


////////////////////////////////////////////////////////////
// Function:  MyStatusCallback(HINTERNET, DWORD, DWORD, LPVOID, DWORD)
//
// Purpose:
//		Status callback proc for WinHttp.
//
////////////////////////////////////////////////////////////
VOID CALLBACK MyStatusCallback(
    HINTERNET	hInternet,
    DWORD		dwContext,
    DWORD		dwInternetStatus,
    LPVOID		lpvStatusInformation,
    DWORD		dwStatusInformationLength
)
{
	switch(dwInternetStatus)
	{
		case WINHTTP_CALLBACK_STATUS_RESOLVING_NAME:
			LogText("\t[ WINHTTP_CALLBACK_STATUS_RESOLVING_NAME ]");
			break;
		case WINHTTP_CALLBACK_STATUS_NAME_RESOLVED:	
			LogText("\t[ WINHTTP_CALLBACK_STATUS_NAME_RESOLVED ]");
			break;
		case WINHTTP_CALLBACK_STATUS_CONNECTING_TO_SERVER:
			LogText("\t[ WINHTTP_CALLBACK_STATUS_CONNECTING_TO_SERVER ]");
			break;
		case WINHTTP_CALLBACK_STATUS_CONNECTED_TO_SERVER:
			LogText("\t[ WINHTTP_CALLBACK_STATUS_CONNECTED_TO_SERVER ]");
			break;
		case WINHTTP_CALLBACK_STATUS_SENDING_REQUEST:	
			LogText("\t[ WINHTTP_CALLBACK_STATUS_SENDING_REQUEST ]");
			break;
		case WINHTTP_CALLBACK_STATUS_REQUEST_SENT:	
			LogText("\t[ WINHTTP_CALLBACK_STATUS_REQUEST_SENT ]");
			break;
		case WINHTTP_CALLBACK_STATUS_RECEIVING_RESPONSE:
			LogText("\t[ WINHTTP_CALLBACK_STATUS_RECEIVING_RESPONSE ]");
			break;
		case WINHTTP_CALLBACK_STATUS_RESPONSE_RECEIVED:	
			LogText("\t[ WINHTTP_CALLBACK_STATUS_RESPONSE_RECEIVED ]");
			break;
		case WINHTTP_CALLBACK_STATUS_CLOSING_CONNECTION:
			LogText("\t[ WINHTTP_CALLBACK_STATUS_CLOSING_CONNECTION ]");
			break;
		case WINHTTP_CALLBACK_STATUS_CONNECTION_CLOSED:	
			LogText("\t[ WINHTTP_CALLBACK_STATUS_CONNECTION_CLOSED ]");
			break;
		case WINHTTP_CALLBACK_STATUS_HANDLE_CREATED:
			LogText("\t[ WINHTTP_CALLBACK_STATUS_HANDLE_CREATED ]");
			break;
		case WINHTTP_CALLBACK_STATUS_HANDLE_CLOSING:
			LogText("\t[ WINHTTP_CALLBACK_STATUS_HANDLE_CLOSING ]");
			break;
		case WINHTTP_CALLBACK_STATUS_DETECTING_PROXY:
			LogText("\t[ WINHTTP_CALLBACK_STATUS_DETECTING_PROXY ]");
			break;
		case WINHTTP_CALLBACK_STATUS_REDIRECT:
			LogText("\t[ WINHTTP_CALLBACK_STATUS_REDIRECT ]");
			break;
		case WINHTTP_CALLBACK_STATUS_INTERMEDIATE_RESPONSE:
			LogText("\t[ WINHTTP_CALLBACK_STATUS_INTERMEDIATE_RESPONSE ]");
			break;
		case WINHTTP_CALLBACK_STATUS_REQUEST_COMPLETE:
			LogText("\t[ WINHTTP_CALLBACK_STATUS_REQUEST_COMPLETE ]");
			break;
		default:
			LogText("\t[ INVALID status callack %u ]", dwInternetStatus);
			break;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\tools\stress\stressscheduler\src\servercommands.h ===
//////////////////////////////////////////////////////////////////////
// File:  WinHttpStressScheduler.h
//
// Copyright (c) 2001 Microsoft Corporation.  All Rights Reserved.
//
// Purpose:
//	ServerCommands.h: interface for the ServerCommands class.
//	This class is used to retrieve and act on command from the server.
//
// History:
//	02/08/01	DennisCh	Created
//
//////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////
// Includes
//////////////////////////////////////////////////////////////////////

//
// WIN32 headers
//
#define UNICODE
#define _UNICODE

#include <stdio.h>
#include <shlwapi.h>
#include <windows.h>
#include <tchar.h>
#include <winhttp.h>
#include <vector>

//
// Project headers
//
#include "StressInstance.h"


//////////////////////////////////////////////////////////////////////
// Constants
//////////////////////////////////////////////////////////////////////
#if !defined(AFX_SERVERCOMMANDS_H__6B84102D_2F79_4FE0_A936_ED4F043AC75E__INCLUDED_)
#define AFX_SERVERCOMMANDS_H__6B84102D_2F79_4FE0_A936_ED4F043AC75E__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRESS_SCHEDULER_USER_AGENT						_T("WinHttp Stress Scheduler")

#define STRESS_COMMAND_SERVER_URL						_T("http://winhttp/stressAdmin/stressCommand.asp")

// When we first start up, we report our client stats and post them to this page to let the server know that we're alive
#define STRESS_COMMAND_SERVER_REGISTERCLIENT_URL		_T("http://winhttp/stressAdmin/registerClient.asp")
#define STRESS_COMMAND_SERVER_LOGURL					_T("http://winhttp/stressAdmin/logStress.asp")

#define STRESS_COMMAND_SERVER_UPDATE_INTERVAL			10000		// 10 second default timeout
#define STRESS_COMMAND_SERVER_MINIMUM_UPDATE_INTERVAL	2000		// 2 second minimum timeout. Don't want to flood the network.
#define STRESS_COMMAND_SERVER_MAXIMUM_UPDATE_INTERVAL	300000		// 5 minute maximum timeout. Don't want to lose you!


#define MAX_URL											MAX_PATH * 2

// Timer related definitions
#define IDT_QUERY_COMMAND_SERVER						1			// timer identifier for pinging the command server


// List of URLs for the stress EXE's that we need to download
using namespace std;

typedef StressInstance			*PSTRESSINSTANCE;
typedef vector<PSTRESSINSTANCE>	PSTRESSINSTANCE_LIST;

// *****************************************************
// *****************************************************
// *** List of headers that the command server can send us.
// *** 
#define COMMANDHEADER__EXIT						_T("WinHttpStress_Exit")					// valid values: None. If the header is present, then assume we want to exit.
#define COMMANDHEADER__WINHTTP_DLL_URL			_T("WinHttpStress_WinHttpDllURL")			// valid values: Valid URL
#define COMMANDHEADER__WINHTTP_PDB_URL			_T("WinHttpStress_WinHttpPDBURL")			// valid values: Valid URL
#define COMMANDHEADER__WINHTTP_SYM_URL			_T("WinHttpStress_WinHttpSYMURL")			// valid values: Valid URL
#define COMMANDHEADER__ABORT					_T("WinHttpStress_Abort")					// valid values: ID of a stressInstance from the DB that needs to be aborted
#define COMMANDHEADER__MEMORY_DUMP_PATH			_T("WinHttpStress_MemoryDumpPath")			// valid values: Valid path
#define COMMANDHEADER__STRESS_EXE_URL			_T("WinHttpStress_StressExeURL")			// valid values: Valid URL
#define COMMANDHEADER__STRESS_PDB_URL			_T("WinHttpStress_StressPDBURL")			// valid values: Valid URL
#define COMMANDHEADER__STRESS_SYM_URL			_T("WinHttpStress_StressSYMURL")			// valid values: Valid URL
#define COMMANDHEADER__STRESS_EXE_INSTANCEID	_T("WinHttpStress_StressExeInstanceID")		// valid values: Valid ID from the stressAdmin DB table identifying the stressInstance. This is how stressScheduler tells stressAdmin the status of each stressInstance.
#define COMMANDHEADER__STRESS_EXE_PAGEHEAP		_T("WinHttpStress_PageHeapCommand")			// valid values: pageheap command line. will not use pageheap if missing
#define COMMANDHEADER__STRESS_EXE_UMDH			_T("WinHttpStress_UMDHCommand")				// valid values: UMDH command line. will not use UMDH if missing
#define COMMANDHEADER__COMMANDSERVER_URL		_T("WinHttpStress_CommandServerURL")		// valid values: Valid URL
#define COMMANDHEADER__BEGIN_TIME_HOUR			_T("WinHttpStress_BeginTimeHour")			// valid values: 0-23
#define COMMANDHEADER__BEGIN_TIME_MINUTE		_T("WinHttpStress_BeginTimeMinute")			// valid values: 0-59
#define COMMANDHEADER__END_TIME_HOUR			_T("WinHttpStress_EndTimeHour")				// valid values: 0-23
#define COMMANDHEADER__END_TIME_MINUTE			_T("WinHttpStress_EndTimeMinute")			// valid values: 0-59
#define COMMANDHEADER__RUN_FOREVER				_T("WinHttpStress_RunForever")				// valid values: 0 or 1
#define COMMANDHEADER__DO_NOT_RUN_FOREVER		_T("WinHttpStress_DoNotRunForever")			// valid values: 0 or 1
#define COMMANDHEADER__UPDATE_INTERVAL			_T("WinHttpStress_UpdateInterval")			// valid values: Time to wait to ping the command server in milliseconds.
#define COMMANDHEADER__STRESSINSTANCE_RUN_ID	_T("WinHttpStress_StressInstanceRunID")		// valid values: A numeric ID
#define COMMANDHEADER__CLIENT_ID				_T("WinHttpStress_ClientID")				// valid values: A numeric ID


// *****************************************************
// *****************************************************
// *** List of form names and values that we send back to the command server
// *** 

// **********************
// ** Logging POST fields
#define FIELDNAME__LOGTYPE						"LogType="
#define FIELDNAME__LOGTYPE_INFORMATION			FIELDNAME__LOGTYPE "INFORMATION"
#define FIELDNAME__LOGTYPE_START_UP				FIELDNAME__LOGTYPE "STRESS_SCHEDULER_START_UP"
#define FIELDNAME__LOGTYPE_EXIT					FIELDNAME__LOGTYPE "STRESS_SCHEDULER_EXIT"
#define FIELDNAME__LOGTYPE_MEMORY_INFORMATION	FIELDNAME__LOGTYPE "MEMORY_INFORMATION"
#define FIELDNAME__LOGTYPE_DUMPFILE_CREATED		FIELDNAME__LOGTYPE "DUMP_FILE_CREATED"
#define FIELDNAME__LOGTYPE_ERROR				FIELDNAME__LOGTYPE "ERROR"
#define FIELDNAME__LOGTYPE_SUCCESS				FIELDNAME__LOGTYPE "SUCCESS"
#define FIELDNAME__LOGTYPE_BEGIN_STRESS			FIELDNAME__LOGTYPE "BEGIN_STRESS"
#define FIELDNAME__LOGTYPE_END_STRESS			FIELDNAME__LOGTYPE "END_STRESS"
#define FIELDNAME__LOGTYPE_BEGIN				FIELDNAME__LOGTYPE "BEGIN_STRESS_INSTANCE"
#define FIELDNAME__LOGTYPE_RUNNING				FIELDNAME__LOGTYPE "ISRUNNING_STRESS_INSTANCE"
#define FIELDNAME__LOGTYPE_END					FIELDNAME__LOGTYPE "END_STRESS_INSTANCE"

#define FIELDNAME__LOG_TEXT				"LogText="
#define FIELDNAME__STRESSINSTANCE_ID	"StressInstanceID="


// **********************
// ** System information for registering the client POST fields.

// StressExe process return values
#define FIELDNAME__STRESSEXE_PRIVATEBYTES		"StressExe_PrivateBytes=%d"
#define FIELDNAME__STRESSEXE_HANDLECOUNT		"StressExe_HandleCount=%d"
#define FIELDNAME__STRESSEXE_THREADCOUNT		"StressExe_ThreadCount=%d"

// System Memory Info
#define FIELDNAME__MEMORY_HANDLES						"System_Handles=%d"
#define FIELDNAME__MEMORY_THREADS						"System_Threads=%d"
#define FIELDNAME__MEMORY_VMSIZE						"System_VMSize=%d"
#define FIELDNAME__MEMORY_COMMITTEDPAGEFILETOTAL		"System_CommittedPageFileTotal=%d"
#define FIELDNAME__MEMORY_AVAILABLEPAGEFILETOTAL		"System_AvailablePageFileTotal=%d"
#define FIELDNAME__MEMORY_SYSTEMCODETOTAL				"System_SystemCodeTotal=%d"
#define FIELDNAME__MEMORY_SYSTEMDRIVERTOTAL				"System_SystemDriverTotal=%d"
#define FIELDNAME__MEMORY_NONPAGEDPOOLTOTAL				"System_NonPagedPoolTotal=%d"
#define FIELDNAME__MEMORY_PAGEDPOOLTOTAL				"System_PagedPoolTotal=%d"
#define FIELDNAME__MEMORY_PHYSICAL_MEMORY_AVAILABLE		"System_PhysicalMemoryAvailable=%d"
#define FIELDNAME__MEMORY_SYSTEMCACHETOTAL				"System_SystemCacheTotal=%d"
#define FIELDNAME__MEMORY_FREESYSTEM_PAGETABLE_ENTRIES	"System_FreeSystemPageTableEntries=%d"
#define FIELDNAME__MEMORY_DISK_SPACE_AVAILABLE			"System_DiskSpaceAvailable=%d"

// Processor Info
#define FIELDNAME__SYSTEMINFO_PROCSSSOR_ARCHITECTURE	"StressExeSystemInfo_ProcessorArchitecture="
#define FIELDNAME__SYSTEMINFO_PROCSSSOR_ID				"StressExeSystemInfo_ProcessorID="
#define FIELDNAME__SYSTEMINFO_PROCSSSOR_LEVEL			"StressExeSystemInfo_ProcessorLevel="
#define FIELDNAME__SYSTEMINFO_PROCSSSOR_REVISION		"StressExeSystemInfo_ProcessorRevision="
#define FIELDNAME__SYSTEMINFO_PROCSSSOR_NUMBER_OF		"StressExeSystemInfo_ProcessorNumberOf="

// OS Info
#define FIELDNAME__OS_PLATFORM		"StressExeOSInfo_Platform="
#define FIELDNAME__OS_BUILD			"StressExeOSInfo_Build="
#define FIELDNAME__OS_MAJORVERSION	"StressExeOSInfo_MajorVersion="
#define FIELDNAME__OS_MINORVERSION	"StressExeOSInfo_MinorVersion="
#define FIELDNAME__OS_EXTRAINFO		"StressExeOSInfo_ExtraInfo="

// User Info
#define FIELDNAME__USERINFO_USERALIAS		"StressExeUserInfo_Alias="
#define FIELDNAME__USERINFO_USERDOMAIN		"StressExeUserInfo_Domain="
#define FIELDNAME__USERINFO_FULLNAME		"StressExeUserInfo_FullName="
#define FIELDNAME__USERINFO_MACHINENAME		"StressExeUserInfo_MachineName="

// Test info
#define FIELDNAME__TESTINFO_TEST_DLL_VERSION	"StressExeTestInfo_TestDLLVersion="

// ID's
#define FIELDNAME__CLIENT_ID					"ClientID="
#define FIELDNAME__STRESSEXE_ID					"StressExeID="
#define FIELDNAME__STRESSINSTANCE_ID			"StressInstanceID="

// DataBase ID Query POST fields
#define	POSTSTRING__GET_STRESSINSTANCERUN_ID	"option=GetStressInstanceRunID&"	FIELDNAME__CLIENT_ID			"%u&" FIELDNAME__STRESSINSTANCE_ID "%u"
#define	POSTSTRING__GET_CLIENT_ID				"option=GetClientID&"				FIELDNAME__USERINFO_MACHINENAME "%s&" FIELDNAME__USERINFO_USERALIAS "%s&" FIELDNAME__USERINFO_USERDOMAIN "%s"



class ServerCommands  
{
public:

	// *****************************************************
	// *****************************************************
	// ** Public ServerCommands methods
	// ** 
			ServerCommands();
	virtual	~ServerCommands();

	BOOL	QueryServerForCommands();

	BOOL	IsStressRunning();
	BOOL	IsTimeToBeginStress();
	BOOL	IsTimeToExitStress();

	BOOL	Download_WinHttpDLL();

	VOID	Clear_StressExeURLs();

	DWORD	Get_ClientID();
	LPSTR	Get_ClientMachineName();
	DWORD	Get_CommandServerUpdateInterval();
	LPTSTR	Get_CommandServerURL();
	LPTSTR	Get_CurrentWorkingDirectory();
	DWORD	Get_NumberOfStressInstances();
	LPTSTR	Get_TestDllFileName();

	VOID	Create_StressInstance(DWORD, LPTSTR, LPTSTR, LPTSTR, LPTSTR, LPTSTR, LPTSTR);

	BOOL	RegisterClient();

	VOID	Set_WinHttpDllURL(LPTSTR, DWORD);
	VOID	Set_WinHttpPDBURL(LPTSTR, DWORD);
	VOID	Set_WinHttpSYMURL(LPTSTR, DWORD);
	VOID	Set_CommandServerURL(LPTSTR, DWORD);
	VOID	Set_CommandServerUpdateInterval(DWORD);
	VOID	Set_TimeStressBegins(LPTSTR, LPTSTR);
	VOID	Set_TimeStressEnds(LPTSTR, LPTSTR);
	VOID	Set_RunForever(BOOL);
	VOID	Set_ExitStress(BOOL);

	VOID	BeginStress();
	VOID	EndStress();
	VOID	AbortStressInstance(DWORD);


private:
	// *****************************************************
	// *****************************************************
	// ** These vars contain commands(headers) from the command server
	// **
	LPTSTR		m_szCommandServerURL;					// Command server URL to request commands from

	DWORD		m_dwCommandServerUpdateInternval;		// Time to wait to ping the server for commands in milliseconds.
	DWORD		m_dwClientID;							// a unique identifier generated by the DataBase given a MACHINENAME and DOMAIN\USERNAME pair

	LPTSTR		m_szWinHttpDLL_DownloadURL;				// Where to get the latest WinHttp from
	LPTSTR		m_szWinHttpPDB_DownloadURL;				// Where winhttp's PDB symbol file from
	LPTSTR		m_szWinHttpSYM_DownloadURL;				// Where winhttp's SYM symbol file from
	LPTSTR		m_szWinHttpDLL_FileName;				// Filename of the WinHttp DLL.

	LPSTR		m_szClientMachineName;					// Computer name of the client
	LPTSTR		m_szStressSchedulerCurrentDirectory;	// stressScheduler's current directory.

	INT			m_iTimeStressBeginsHour;				// 0-23
	INT			m_iTimeStressBeginsMinute;				// 0-59
	INT			m_iTimeStressEndsHour;					// 0-23
	INT			m_iTimeStressEndsMinute;				// 0-59

	BOOL		m_bRunForever;							// 1 to run stress until stopped and 0 to rely on begin/end times

	BOOL		m_bExit;								// Quit signal from server to exit the app
	BOOL		m_bStressHasStarted;					// TRUE = started; FALSE = inactive

	PSTRESSINSTANCE_LIST			m_arStressInstanceList;		// List of URLs for the stress EXEs to download
	PSTRESSINSTANCE_LIST::iterator	m_dwStressInstanceIterator;	// Iterator for m_arszStressExeList
};

#endif // !defined(AFX_SERVERCOMMANDS_H__6B84102D_2F79_4FE0_A936_ED4F043AC75E__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\tools\stress\stressscheduler\src\stressinstance.h ===
//////////////////////////////////////////////////////////////////////
// File:  StressInstance.h
//
// Copyright (c) 2001 Microsoft Corporation.  All Rights Reserved.
//
// Purpose:
//	StressInstance.h: interface for the StressInstance class.
//	This class is used spawn and monitor instances of the stressEXE app.
//
// History:
//	02/15/01	DennisCh	Created
//
//////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////
// Includes
//////////////////////////////////////////////////////////////////////

//
// WIN32 headers
//
#define UNICODE
#define _UNICODE

#include <stdio.h>
#include <windows.h>
#include <tchar.h>
#include <winhttp.h>

//
// Project headers
//
#include <debugger.h>

//////////////////////////////////////////////////////////////////////
// Constants
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_STRESSINSTANCE_H__806226FB_2170_4FE3_ACCA_EF8952E6A524__INCLUDED_)
#define AFX_STRESSINSTANCE_H__806226FB_2170_4FE3_ACCA_EF8952E6A524__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000


#define	RESPONSE_HEADER__STRESS_BEGIN			_T("WinHttpStress_Begin: Begin Stress")
#define	RESPONSE_HEADER__STRESS_END				_T("WinHttpStress_End: End Stress")


// ***************************
// ** max string URL length
#define MAX_STRESS_URL							MAX_PATH * 2


// ***************************
// ** time to check the stress exe in milliseconds
#define STRESSINSTANCE_MONITOR_EXE_TIME			600000	// 10 minutes

// ***************************
// ** Command line CreateProcess will use.
#define STRESSINSTANCE_DEBUG_COMMANDLINE		_T("\"%s\"")

// ***************************
// ** Command line CreateProcess will use for logging memory dump file info
/*
//	loragent switches
//				/d uncpathdumpfilename
//				/k kill switch 
//				/a addinfo1|addinfo2
//				/m WinHTTP Debug
//
//	Parameters we use:
//		/d <DUMP_FILE_PATH> /a <StressInstanceRunID>
*/
#define STRESSINSTANCE_LOG_DUMP_COMMANDLINE		_T("/d %s /a %u /m WinHttp_Stress")


// path to get loragent.exe, lordll.dll, and stressme.ini
// these files are used to enable dump file logging and auto-debugging of crashes
#define STRESSINSTANCE_LORAGENT_FILES_PATH		_T("\\\\control\\stressme\\")


// ***************************
// ** Memory dump path
#define	STRESSINSTANCE_DEFAULT_MEMORY_DUMP_PATH	_T("\\\\mildew\\stress\\")

// ***************************
// ** relative path to the directory where the stressExe files will be downloaded to.
#define STRESSINSTANCE_STRESS_EXE_DOWNLOAD_DIR	_T("stressExe")

// ***************************
// ** Time to wait for stressExe to close after telling it
#define STRESSINSTANCE_STRESS_EXE_CLOSE_TIMEOUT	100

// ***************************
// ** Cross process event object names. We append the PID of the process to the end to prevent name collisions.
#define STRESSINSTANCE_STRESS_EXE_EVENT_EXITPROCESS			_T("ExitProcessEvent")


class StressInstance  
{
public:
				StressInstance();
	virtual		~StressInstance();

	BOOL		Begin();
	VOID		End();
	BOOL		IsRunning(DWORD);

	DWORD		Get_ID();
	LPTSTR		Get_StressExeMemoryDumpPath();
	DWORD		Get_StressInstanceRunID();

	VOID		Set_StressExeMemoryDumpPath(LPTSTR);
	VOID		Set_StressExeURL(LPTSTR);
	VOID		Set_StressExePdbURL(LPTSTR);
	VOID		Set_StressExeSymURL(LPTSTR);
	VOID		Set_StressExeID(DWORD);
	VOID		Set_PageHeapCommands(LPCTSTR);
	VOID		Set_UMDHCommands(LPCTSTR);

	BOOL		DownloadStressExe();

				// This is the timer callback proc that monitors the stressExe process.
	friend		VOID CALLBACK StressExe_TimerProc(HWND, UINT, UINT_PTR, DWORD);

				// This is the timer callback proc for the debugger object
	friend		DWORD DebuggerCallbackProc(DWORD, LPVOID, LPTSTR, LPVOID);

private:
	LPTSTR		m_szStressExe_URL;					// URL to the stress app
	LPTSTR		m_szStressExe_PDB_URL;				// URL to the stress app's pdb file
	LPTSTR		m_szStressExe_SYM_URL;				// URL to the stress app's sym file
	LPTSTR		m_szStressExe_FilePath;				// Local relative path of the downloaded stress EXE
	LPTSTR		m_szStressExe_FileName;				// Local filename of the downloaded stress EXE
	LPTSTR		m_szStressExe_FilePathAndName;		// Path and filename to the local stressExe downloaded
	LPTSTR		m_szStressExe_PageHeapCommandLine;	// Command line params when enabling pageheap.
	LPTSTR		m_szStressExe_UMDHCommandLine;		// Command line params when enabling UMDH.

	DWORD		m_dwStressInstance_ID;				// ID from the stressAdmin DB uniquely identifying this test case.
	DWORD		m_dwStressInstanceRunID;			// the stressInstanceRunID generated by the DB that we cache as soon as this instance starts.

	LPTSTR		m_szStressExe_MemDumpPath;			// path that the minidump will dump to

	Debugger	*m_objDebugger;						// the debughelp debugger object

	PROCESS_INFORMATION 	m_piStressExeProcess;	// stuct containing info on the stressExe process
	HANDLE					m_hStressExe_ProcessExitEvent;	// Cross process event we send stressExe to tell it to exit

	UINT_PTR				m_uiStressExeTimerID;	// ID for the timer that monitors the stressExe when it's spawned
};


#endif // !defined(AFX_STRESSINSTANCE_H__806226FB_2170_4FE3_ACCA_EF8952E6A524__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\tools\w3spoof\w3spoof.inc ===
!IF 0

Copyright (c) 1994  Microsoft Corporation

Module Name:

    w3spoof.inc

Abstract:

    Common makefile contents for w3spoof project

!ENDIF

!IFNDEF SDKINC
SDKINC=$(SDK_INC_PATH)
!ENDIF

!IFDEF LIBDIR
!ERROR LIBDIR already defined - choose new name
!ENDIF

LIBDIR=..\lib\$(_OBJ_DIR)
W3SPOOFINC=..\inc

#
# if TARGETPATH is not defined (in the paths that build libraries) then this
# is the default target path
#
!IFNDEF TARGETPATH
TARGETPATH=$(LIBDIR)
TARGETTYPE=LIBRARY
!ENDIF

#
# what it is that we're building
#
MAJORCOMP=w3spoof

USE_NOLIBS=1
#USE_LIBCMT=0
NO_NTDLL=1
#NO_BINPLACE=0
BINPLACE_PLACEFILE=..\binplace.txt

#
# Linker flags
#
WIN32_WINNT_VERSION=0x0500
#WIN32_WIN95_VERSION=0x0400

#
# compiler warning flags
#
MSC_WARNING_LEVEL=/W3 /WX

#
# compiler definitions
#
C_DEFINES=$(C_DEFINES) -DWIN32

CLEANINF = cleaninf.exe $(CLEANINF_FLAGS)

#
# Set debugging level
#
!IF "$(NTDEBUG)" != "" && "$(NTDEBUG)" != "retail" && "$(NTDEBUG)" != "ntsdnodbg"
C_DEFINES=$(C_DEFINES) -D_DEBUG
!ENDIF

!IF "$(__FULL_DEBUG__)" != "" && "$(__RELEASE_DEBUG__)" == ""
C_DEFINES=$(C_DEFINES) -D__FULL_DEBUG__
!IF "$(__DBG_TO_CONSOLE__)" == "1"
C_DEFINES=$(C_DEFINES) -D__DBG_TO_CONSOLE__
!ENDIF
!ENDIF

!IF "$(__RELEASE_DEBUG__)" != "" && "$(__FULL_DEBUG__)" == ""
C_DEFINES=$(C_DEFINES) -D__RELEASE_DEBUG__
!ENDIF


!IFNDEF W3SPOOF_PCH
PRECOMPILED_OPTION=/Fp..\inc\$(_OBJ_DIR)\*\common.pch /Yucommon.h
PRECOMPILED_CXX=1
!ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\tools\stressexe\stresstesttemplate\stressmain.cpp ===
//////////////////////////////////////////////////////////////////////
// File:  stressMain.cpp
//
// Copyright (c) 2001 Microsoft Corporation.  All Rights Reserved.
//
// Purpose:
//		This is an empty template for WinHttp stressScheduler stress apps.
//		The stress test lives in WinHttp_StressTest() and will be called
//		repeatedly in the main function.
//
//		This process will inherit a named event handle from 
//		stressScheduler in the form: "ExitProcessEvent" + <PID of this process>.
//		When the stressScheduler sets the object state to signaled, then
//		the stress test application must exit immediately.
//
//		If this app is running without the stressScheduler, use the
//		"/s" switch to run the standalone mode. The app will exit when the user
//		sends a break message (CTRL-C).
//
//		This stress test will continue to run if:
//
//			When not using any switches:
//			- The "ExitProcessEvent" object inherited from stressScheduler is in the un-signaled state
//			- WinHttp_StressTest() returns true
//
//			When using the "/s" standalone switch:
//			- WinHttp_StressTest() returns true
//
// History:
//	03/30/01	DennisCh	Created
//
//////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////
// Includes
//////////////////////////////////////////////////////////////////////

// Project headers
#include "stressMain.h"


//////////////////////////////////////////////////////////////////////
// Globals and statics
//////////////////////////////////////////////////////////////////////

// ****************************
// ** The name of the stress test and your stress test function
// ** should be declared in a seperate file.
extern	LPSTR	g_szStressTestName;
extern	BOOL	WinHttp_StressTest();

// ****************************
// ** hande to the name exit event object inherited from the stressScheduler
HANDLE	g_hExitEvent		= NULL;

// ****************************
// ** FALSE = run with stressScheduler, TRUE = run without stressScheduler
BOOL	g_bStandAloneMode	= FALSE;


////////////////////////////////////////////////////////////
// Function:  LogText(DWORD, LPCSTR)
//
// Purpose:
//	Prints text.
//
////////////////////////////////////////////////////////////
VOID
LogText(
	LPCSTR	szLogText,
	...
)
{
    CHAR	szBuffer[1024] = {0};
    va_list	vaList;

	if (!szLogText)
		return;

    va_start( vaList, szLogText );
    _vsnprintf( szBuffer, sizeof(szBuffer), szLogText, vaList );

    printf("%s\n", szBuffer);

    va_end(vaList);
}


////////////////////////////////////////////////////////////
// Function:  GetExitEventHandle()
//
// Purpose:
//	This opens a named event object inherited from the stressScheduler.
//	The object is in the form: "ExitProcessEvent" + <PID of current process>
//	By default this is in the unsignaled state. When the stressScheduler
//	sets it to signaled, then it's time for the stress App to exit.
//
////////////////////////////////////////////////////////////
HANDLE
GetExitEventHandle()
{
	CHAR	szPID[32];
	CHAR	szExitProcessName[sizeof(EXIT_PROCESS_EVENT_NAME) + sizeof(szPID)];
	HANDLE	hExitEvent			= NULL;

	// if user used the "/S" switch, we run without the stressScheduler and exit when user
	// tells us to instead. No need to get inherited event object from stressScheduler
	if (g_bStandAloneMode)
		return NULL;

	// wait for the stressScheduler to create the event object before trying to obtain it.
	Sleep(4000);

	// Get the processID string
	_itoa(_getpid(), szPID, 10);

	// build ExitProcess event object name
	ZeroMemory(szExitProcessName, sizeof(szExitProcessName));
	strcpy(szExitProcessName, EXIT_PROCESS_EVENT_NAME);
	strcat(szExitProcessName, szPID);

	LogText("\n[ Opening inherited named event object \"%s\". ]", szExitProcessName);

	hExitEvent = OpenEvent(EVENT_ALL_ACCESS, FALSE, szExitProcessName);

	if (!hExitEvent)
		LogText("[ ERROR: OpenEvent() failed to open object \"%s\". GetLastError() = %u ]\n", szExitProcessName, GetLastError());
	else
		LogText("[ OpenEvent() opened object \"%s\". ] \n", szExitProcessName);

	return hExitEvent;
}


////////////////////////////////////////////////////////////
// Function:  IsTimeToExitStress()
//
// Purpose:
//	Returns TRUE if the exit event object is signaled or NULL. FALSE if not.
//	The object is in the form: "ExitProcessEvent" + <PID of current process>
//	By default this is in the unsignaled state. When the stressScheduler
//	sets it to signaled, then it's time for the stress App to exit.
//
////////////////////////////////////////////////////////////
BOOL
IsTimeToExitStress()
{
	BOOL bResult = FALSE;

	// if user used the "/S" switch, we run without the stressScheduler and exit when user
	// tells us to instead.
	if (g_bStandAloneMode)
		return FALSE;

	if (!g_hExitEvent)
	{
		bResult = TRUE;
		goto Exit;
	}

	if (WAIT_OBJECT_0 == WaitForSingleObject(g_hExitEvent, 0))
		bResult = TRUE;

Exit:
	return bResult;
}


////////////////////////////////////////////////////////////
// Function:  main(INT, LPSTR)
//
// Purpose:
//	Program entry point.
//
////////////////////////////////////////////////////////////
INT
main(
	INT		argc,
	LPSTR	argv[]
)
{
	DWORD	dwIndex		= 0;

	// **************************
	// **************************
	// ** Parse command line arguments
	// **
    if (argc >= 2)
    {
		// print out options
		if (0 == stricmp(argv[1], "/?") || 0 == stricmp(argv[1], "-?"))
		{
	        LogText("USAGE: '/S' to run in standalone mode with the stressScheduler.\n\n");
		    goto Exit;
		}

		// run in standalone mode without stressScheduler
		if (0 == stricmp(argv[1], "/S") || 0 == stricmp(argv[1], "-S"))
		{
			LogText("[ Running in standalone mode. \"/S\" switch used. ]\n\n");
			g_bStandAloneMode = TRUE;
		}
    }


	// **************************
	// **************************
	// ** open the exit event object inherited from WinHttpStressScheduler
	// **
	g_hExitEvent	= GetExitEventHandle();
	if (!g_bStandAloneMode && !g_hExitEvent)
		goto Exit;


	// **************************
	// **************************
	// ** run the stress test until stressScheduler tells us to exit or the stress app does
	// **
	while (!IsTimeToExitStress() && WinHttp_StressTest())
		LogText("[ Running stressExe \"%s\" iteration #%u ]\n", g_szStressTestName, ++dwIndex);

Exit:
	if (g_hExitEvent)
		CloseHandle(g_hExitEvent);

	LogText("[ Exiting test case \"%s\" ]", g_szStressTestName);

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\tools\stress\stressscheduler\src\winhttpstressscheduler.cpp ===
///////////////////////////////////////////////////////////////////////////
// File:  WinHttpStressScheduler.cpp
//
// Copyright (c) 2001 Microsoft Corporation.  All Rights Reserved.
//
// Purpose:
//	Global interfaces for the WinHttpStressScheduler project.
//
// History:
//	02/05/01	DennisCh	Created
///////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////
//
// Includes
//
//////////////////////////////////////////////////////////////////////

//
// Win32 headers
//

//
// Project headers
//
#include "WinHttpStressScheduler.h"
#include "ServerCommands.h"
#include "NetworkTools.h"


//////////////////////////////////////////////////////////////////////
//
// Globals and statics
//
//////////////////////////////////////////////////////////////////////

HINSTANCE		g_hInstance;
HWND			g_hWnd;

ServerCommands	g_objServerCommands;

// used to cache the current update interval for resetting the timer as needed
DWORD			g_dwCurrentUpdateInterval;

// handle to a named mutex. Used to detect duplicate instances of stressScheduler
HANDLE			g_hInstanceMutex = NULL;


// Forward function definitions
LRESULT	CALLBACK	MainWndProc(HWND, UINT, WPARAM, LPARAM);
BOOL				OS_IsSupported();
BOOL				Show_IconShortCutMenu();
BOOL				StressSchedulerIsAlreadyRunning(BOOL);
BOOL				SystemTray_UpdateIcon(HWND hwnd, DWORD dwMessage, UINT uID, HICON hIcon, PSTR pszTip);


////////////////////////////////////////////////////////////
// Function:  WinMain( HINSTANCE, HINSTANCE, LPWSTR, int )
//
// Purpose:
//	This is the entry-point into WinHttpStressScheduler.
//
// Called by:
//	[System]
////////////////////////////////////////////////////////////
int
WINAPI
WinMain
(
   HINSTANCE	hInstance,		// [IN] handle to the process instance
   HINSTANCE	hPrecInstance,	// [IN] handle to the previous instance
   LPTSTR		lpCmdLine,		// [IN] command line
   int			nShowCmd		// [IN] show command
)
{
	MSG				msg;
	WNDCLASSEX		wndClass;

	// Detect duplicate instances of stressScheduler and create named mutex to detect future instances if unique
	if (StressSchedulerIsAlreadyRunning(TRUE))
		return FALSE;

	wndClass.cbSize			= sizeof(WNDCLASSEX); 
	wndClass.style			= CS_HREDRAW | CS_VREDRAW;
	wndClass.lpfnWndProc	= (WNDPROC) MainWndProc;
	wndClass.cbClsExtra		= 0;
	wndClass.cbWndExtra		= 0;
	wndClass.hInstance		= hInstance;
	wndClass.hIcon			= NULL;
	wndClass.hCursor		= NULL;
	wndClass.hbrBackground	= NULL;
	wndClass.lpszMenuName	= NULL;
	wndClass.lpszClassName	= WINHTTP_STRESS_SCHEDULER__NAME;
	wndClass.hIconSm		= NULL;

	RegisterClassEx(&wndClass);

	// cache our hInstance
	g_hInstance = hInstance;

    // Create window. 
	g_hWnd = NULL;
    g_hWnd = CreateWindow( 
        WINHTTP_STRESS_SCHEDULER__NAME,
        NULL,
        WS_OVERLAPPEDWINDOW,
        CW_USEDEFAULT,
        0,
        CW_USEDEFAULT,
        0,
        NULL,
        NULL,
        hInstance,
        NULL);

	if (!g_hWnd)
		return FALSE;

	// Verify that we're running a supported version of Windows
	if (!OS_IsSupported())
		return FALSE;

	// Add icon to the system tray icon
	if (!SystemTray_UpdateIcon(g_hWnd, NIM_ADD, 0, LoadIcon(g_hInstance, MAKEINTRESOURCE(IDI_MAIN_ICON)), WINHTTP_STRESS_SCHEDULER__NAME))
		return FALSE;

	// *********************
	// ** Tell the client that we are alive and also send system info
	g_objServerCommands.RegisterClient();

	// *********************
	// ** Get the clientID for this machine so we can get commands for it later
	g_objServerCommands.Get_ClientID();


	// Create timer to ping the Command Server for commands
	g_dwCurrentUpdateInterval	= g_objServerCommands.Get_CommandServerUpdateInterval();
	SetTimer(g_hWnd, IDT_QUERY_COMMAND_SERVER, g_dwCurrentUpdateInterval, (TIMERPROC) NULL);

	// Message loop
	while (GetMessage(&msg, NULL, 0, 0))
	{
		TranslateMessage(&msg);
		DispatchMessage(&msg);
	}

	// remove the icon from the system tray
	if (WM_QUIT == msg.message)
		SystemTray_UpdateIcon(g_hWnd, NIM_DELETE, 0, NULL, NULL);

	// LOGLOG: stressScheduler has exited
	//NetworkTools__SendLog(FIELDNAME__LOGTYPE_EXIT, "WinHttpStressScheduler has exited.", NULL, NULL);

	// Close mutex handle
	StressSchedulerIsAlreadyRunning(FALSE);

	return msg.wParam;
}


////////////////////////////////////////////////////////////
// Function:  MainWndProc( HWND, UINT, WPARAM, LPARAM)
//
// Purpose:
//	Window callback procedure for UI.
//
// Called by:
//	WinMain
////////////////////////////////////////////////////////////
LRESULT
CALLBACK
MainWndProc
(
	HWND	hwnd,	// [IN] Handle to current window
	UINT	iMsg,	// [IN] Incoming message
	WPARAM	wParam,	// [IN] Parameter
	LPARAM	lParam	// [IN] Parameter
)
{
	switch (iMsg)
	{
		case MYWM_NOTIFYICON:
			// Notifications sent for the System Tray icon
			switch (lParam)
			{
				case WM_LBUTTONDOWN:

				case WM_RBUTTONDOWN:
					Show_IconShortCutMenu();
					return 0;

				default:
					break;
			}
			return 0;

		case WM_COMMAND:

			// User clicked on the popup menu
			switch (LOWORD(wParam))
			{
				case IDM_BEGIN_STRESS:
					// begin stress only if it's time to
					if (g_objServerCommands.IsTimeToBeginStress())
						g_objServerCommands.BeginStress();
					else
						g_objServerCommands.QueryServerForCommands();
				break;

				case IDM_END_STRESS:
					// end stress only if it's time to.
					if (!g_objServerCommands.IsTimeToBeginStress())
						g_objServerCommands.EndStress();
				break;

				case IDM_WINHTTP_HOME:
					ShellExecute(g_hWnd, "open", WINHTTP_WINHTTP_HOME_URL, NULL, NULL, SW_SHOW);
				break;

				case IDM_OPENSTRESSADMIN:
					// Open a IE window to configure-client.asp. needs to send a clientID
					DWORD	dwURLSize;
					LPSTR	szURL;

					dwURLSize	= sizeof(WINHTTP_STRESSADMIN_URL) + MAX_PATH;
					szURL		= NULL;
					szURL		= new CHAR[dwURLSize];

					if (!szURL)
						return 0;

					ZeroMemory(szURL, dwURLSize);
					sprintf(szURL, WINHTTP_STRESSADMIN_URL, g_objServerCommands.Get_ClientID());
					ShellExecute(g_hWnd, "open", szURL, NULL, NULL, SW_SHOW);

					if (szURL)
						delete [] szURL;
				break;

				case IDM_EXIT:
					g_objServerCommands.EndStress();
					PostQuitMessage(0);
				break;
			}
			return 0;

		case WM_TIMER:
			switch (wParam)
			{
				case IDT_QUERY_COMMAND_SERVER:
					// Query the server for commands
					g_objServerCommands.QueryServerForCommands();

					if (g_dwCurrentUpdateInterval != g_objServerCommands.Get_CommandServerUpdateInterval())
					{
						// cache the new update interval
						g_dwCurrentUpdateInterval = g_objServerCommands.Get_CommandServerUpdateInterval();

						// Update the timer timeout
						KillTimer(g_hWnd, IDT_QUERY_COMMAND_SERVER);
						SetTimer(
							g_hWnd,
							IDT_QUERY_COMMAND_SERVER,
							g_dwCurrentUpdateInterval,
							(TIMERPROC) NULL);
					}

					// ***************************
					// ***************************
					// ** Act accordingly based on Command Server messages
					// **

					// *********************************
					// ** EXIT stressScheduler
					if (g_objServerCommands.IsTimeToExitStress())
					{
						g_objServerCommands.EndStress();

						// quit stressScehduler
						PostQuitMessage(0);
						return 0;
					}

					// *********************************
					// ** BEGIN/END stress
					// Begin/end stress if it's time
					if (g_objServerCommands.IsTimeToBeginStress())
						g_objServerCommands.BeginStress();
					else
						g_objServerCommands.EndStress();

					return 0;

				break;
			}
			return 0;

		case WM_CREATE:
			return 0;

		case WM_DESTROY:
			return 0;

		default:
			return DefWindowProc (hwnd, iMsg, wParam, lParam);
	}
}



////////////////////////////////////////////////////////////
// Function:  SystemTray_UpdateIcon(HWND hDlg, DWORD dwMessage, UINT uID, WORD wIconResource, PSTR pszTip)
//
// Purpose:
//	This add/modifies/removes an icon from the system tray.
//
// Called by:
//	WinMain
////////////////////////////////////////////////////////////
BOOL
SystemTray_UpdateIcon(
	HWND hwnd,			// [IN] handle to the window object
	DWORD dwMessage,	// [IN] option to apply to the icon
	UINT uID,			// [IN] ID of the icon
	HICON hIcon,		// [IN] handle to an icon if we're loading one
	PSTR pszTip			// [IN] string containing the tool tip text
)
{
    BOOL			bSuccess;
	NOTIFYICONDATA	tnd;

	tnd.cbSize				= sizeof(NOTIFYICONDATA);
	tnd.hWnd				= hwnd;
	tnd.uID					= uID;
	tnd.uFlags				= NIF_MESSAGE | NIF_ICON | NIF_TIP;
	tnd.uCallbackMessage	= MYWM_NOTIFYICON;
	tnd.hIcon				= hIcon;

	if (pszTip)
		lstrcpyn(tnd.szTip, pszTip, sizeof(tnd.szTip));
	else
		tnd.szTip[0] = '\0';

	bSuccess = Shell_NotifyIcon(dwMessage, &tnd);

	if (hIcon)
		DestroyIcon(hIcon);

	return bSuccess;
}



////////////////////////////////////////////////////////////
// Function:  Show_IconShortCutMenu()
//
// Purpose:
//	This will show the popup menu at the position of the mouse
//	pointer.
//
// Called by:
//	MainWndProc
////////////////////////////////////////////////////////////
BOOL
Show_IconShortCutMenu()
{
	POINT		ptMouse;
	HMENU		hPopUpMenu	= NULL;
	HMENU		hMenu		= NULL;
	// MENUINFO	menuInfo;
	BOOL		bResult		= FALSE;

	// Get the current mouse position
	if (0 != GetCursorPos(&ptMouse))
	{
		// show the popup menu
		hMenu = LoadMenu(g_hInstance, MAKEINTRESOURCE(IDR_POPUPMENU));
		if (!hMenu)
			return FALSE;

		hPopUpMenu	= GetSubMenu(hMenu, 0);
		if (!hPopUpMenu)
			return FALSE;

		/*
		// Make the menu go away after mouseover
		ZeroMemory(&menuInfo, sizeof(MENUINFO));
		menuInfo.cbSize		= sizeof(MENUINFO);
		menuInfo.fMask		= MIM_APPLYTOSUBMENUS | MIM_STYLE;
		menuInfo.dwStyle	= MNS_AUTODISMISS;

		BOOL temp = SetMenuInfo(hPopUpMenu, &menuInfo);
		*/

		bResult = 
			TrackPopupMenuEx(
			hPopUpMenu,
			TPM_RIGHTALIGN | TPM_BOTTOMALIGN,
			ptMouse.x,
			ptMouse.y,
			g_hWnd,
			NULL);
	}

	DestroyMenu(hMenu);
	DestroyMenu(hPopUpMenu);

	return bResult;
}


////////////////////////////////////////////////////////////
// Function:  OS_IsSupported()
//
// Purpose:
//	Returns TRUE if this APP is supported in the OS and FALSE if not.
//	As of now, winhttp is only supported on NT platforms. NT4, Win2k, and WinXP.
//
// Called by:
//	MainWndProc
////////////////////////////////////////////////////////////
BOOL
OS_IsSupported()
{
	BOOL			bSupported = TRUE;
	OSVERSIONINFO	osVI;

	osVI.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);

	if (GetVersionEx(&osVI))
	{
		if (VER_PLATFORM_WIN32_NT == osVI.dwPlatformId)
			bSupported = TRUE;
		else
			bSupported = FALSE;
	}
	else
		bSupported = FALSE;

	return bSupported;
}


////////////////////////////////////////////////////////////
// Function:  SchedulerIsAlreadyRunning(BOOL)
//
// Purpose:
//	Returns TRUE if there is another instance of stressScheduler running.
//	When the param bCreateMutex is set to TRUE, then we create the mutex, else
//	we close one named WINHTTP_STRESS_SCHEDULER_MUTEX that already exists. 
//
// Called by:
//	MainWndProc
////////////////////////////////////////////////////////////
BOOL
StressSchedulerIsAlreadyRunning(BOOL bCreateMutex)
{
	if (!bCreateMutex && g_hInstanceMutex)
	{
		CloseHandle(g_hInstanceMutex);
		return FALSE;
	}

	g_hInstanceMutex = CreateMutex(NULL, FALSE, WINHTTP_STRESS_SCHEDULER_MUTEX);

	if (ERROR_ALREADY_EXISTS == GetLastError())
		return TRUE;
	else
		return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\tools\w3spoof\common\debug.cxx ===
/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Copyright (c) 2000  Microsoft Corporation

Module Name:

    debug.cpp

Abstract:

    Debug logging routines for W3spoof project.
    
Author:

    Paul M Midgen (pmidge) 15-May-2000


Revision History:

    15-May-2000 pmidge
        Created

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/

#include "common.h"


/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

  MapIIDToString()

  WHAT    : maps an IID to its string id. if the IID is unknown we
            emit a '?'.

  ARGS    : hr - the IID code to map

  RETURNS : pointer to the IID's string name

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/
LPSTR
MapIIDToString(REFIID riid)
{
  //
  // standard IIDs
  //
  CASE_IID(riid, IID_NULL);
  CASE_IID(riid, IID_IUnknown);
  CASE_IID(riid, IID_IClassFactory);
  CASE_IID(riid, IID_IDispatch);
  CASE_IID(riid, IID_IConnectionPointContainer);
  CASE_IID(riid, IID_IConnectionPoint);
  CASE_IID(riid, IID_IMarshal);
  CASE_IID(riid, IID_IStdMarshalInfo);
  CASE_IID(riid, IID_IExternalConnection);
  CASE_IID(riid, IID_IObjectWithSite);
  CASE_IID(riid, IID_IActiveScriptSite);
  CASE_IID(riid, IID_IProvideClassInfo);
  CASE_IID(riid, IID_IActiveScriptSiteInterruptPoll);
  CASE_IID(riid, IID_IActiveScriptSiteDebug);
//  CASE_IID(riid, IID_ICanHandleException); // dispex.h?
//  CASE_IID(riid, IID_IDispatchEx); // dispex.h?

  CASE_IID(riid, IID_IServiceProvider);

  //
  // app-defined IIDs
  //
  CASE_IID(riid, IID_IConfig);
  CASE_IID(riid, IID_IThreadPool);
  CASE_IID(riid, IID_IW3Spoof);
  CASE_IID(riid, IID_IW3SpoofClientSupport);
  CASE_IID(riid, IID_IW3SpoofEvents);
  CASE_IID(riid, IID_ISession);
  CASE_IID(riid, IID_ISocket);
  CASE_IID(riid, IID_IHeaders);
  CASE_IID(riid, IID_IEntity);
  CASE_IID(riid, IID_IUrl);
  CASE_IID(riid, IID_IRequest);
  CASE_IID(riid, IID_IResponse);
  CASE_IID(riid, IID_IW3SpoofRuntime);
  CASE_IID(riid, IID_IW3SpoofPropertyBag);
  CASE_IID(riid, IID_IW3SpoofFile);

  return "?";
}

LPSTR
MapIOTYPEToString(IOTYPE iot)
{
  switch(iot)
  {
    CASE_OF(IOCT_CONNECT);
    CASE_OF(IOCT_RECV);
    CASE_OF(IOCT_SEND);
    CASE_OF(IOCT_DUMMY);

    default : return "?";
  }
}

LPSTR
MapScriptDispidToString(SCRIPTDISPID sd)
{
  switch(sd)
  {
    CASE_OF(Global);
    CASE_OF(OnConnect);
    CASE_OF(OnDataAvailable);
    CASE_OF(OnRequest);
    CASE_OF(OnResponse);
    CASE_OF(OnClose);

    default : return "?";
  }
}

/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

  MapHResultToString()

  WHAT    : maps an HRESULT to its string id. if the HRESULT is unknown we
            emit a '?'.

  ARGS    : hr - the HRESULT code to map

  RETURNS : pointer to the HRESULT's string name

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/
LPSTR
MapHResultToString(HRESULT hr)
{
  switch(hr)
  {
    CASE_OF(S_OK);
    CASE_OF(E_NOINTERFACE);
    CASE_OF(E_POINTER);
    CASE_OF(E_UNEXPECTED);
    CASE_OF(E_INVALIDARG);
    CASE_OF(E_OUTOFMEMORY);
    CASE_OF(E_FAIL);
    CASE_OF(E_NOTIMPL);
    CASE_OF(E_PENDING);
    CASE_OF(E_ACCESSDENIED);
    CASE_OF(CLASS_E_NOAGGREGATION);
    CASE_OF(TYPE_E_IOERROR);
    CASE_OF(TYPE_E_REGISTRYACCESS);
    CASE_OF(TYPE_E_INVALIDSTATE);
    CASE_OF(TYPE_E_BUFFERTOOSMALL);
    CASE_OF(TYPE_E_FIELDNOTFOUND);
    CASE_OF(TYPE_E_ELEMENTNOTFOUND);
    CASE_OF(TYPE_E_AMBIGUOUSNAME);
    CASE_OF(TYPE_E_UNKNOWNLCID);
    CASE_OF(TYPE_E_BADMODULEKIND);
    CASE_OF(TYPE_E_CANTLOADLIBRARY);
    CASE_OF(TYPE_E_INCONSISTENTPROPFUNCS);
    CASE_OF(CONNECT_E_NOCONNECTION);
    CASE_OF(CONNECT_E_ADVISELIMIT);
    CASE_OF(CO_E_OBJNOTREG);
    CASE_OF(DISP_E_BADPARAMCOUNT);
    CASE_OF(DISP_E_BADVARTYPE);
    CASE_OF(DISP_E_EXCEPTION);
    CASE_OF(DISP_E_MEMBERNOTFOUND);
    CASE_OF(DISP_E_NONAMEDARGS);
    CASE_OF(DISP_E_OVERFLOW);
    CASE_OF(DISP_E_PARAMNOTFOUND);
    CASE_OF(DISP_E_TYPEMISMATCH);
    CASE_OF(DISP_E_UNKNOWNINTERFACE);
    CASE_OF(DISP_E_UNKNOWNLCID);
    CASE_OF(DISP_E_PARAMNOTOPTIONAL);
    CASE_OF(DISP_E_UNKNOWNNAME);

    default : return "?";
  }
}

/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

  MapStateToString()

  WHAT    : maps a STATE value to a string. if the state is unknown we
            emit a '?'.

  ARGS    : st - the STATE to map

  RETURNS : pointer to the STATE's string name

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/
LPSTR
MapStateToString(STATE st)
{
  switch(st)
  {
    CASE_OF(ST_CREATED);
    CASE_OF(ST_OPENING);
    CASE_OF(ST_OPEN);
    CASE_OF(ST_CLOSING);
    CASE_OF(ST_CLOSED);
    CASE_OF(ST_ERROR);

    default : return "?";
  }
}

/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

  MapIoStateToString()

  WHAT    : maps a SERVERSTATE value to a string. if the state is unknown we
            emit a '?'.

  ARGS    : st - the SERVERSTATE to map

  RETURNS : pointer to the SERVERSTATE's string name

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/
LPSTR
MapStateToString(SERVERSTATE st)
{
  switch(st)
  {
    CASE_OF(SS_START_STATE);
    CASE_OF(SS_SOCKET_CONNECTED);
    CASE_OF(SS_REQUEST_PENDING);
    CASE_OF(SS_REQUEST_COMPLETE);
    CASE_OF(SS_RESPONSE_PENDING);
    CASE_OF(SS_RESPONSE_COMPLETE);
    CASE_OF(SS_SOCKET_DISCONNECTED);

    default : return "?";
  }
}

/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

  MapStateToString()

  WHAT    : maps a script engine state to a string for the log file.

  ARGS    : st - the state

  RETURNS : string representation of the state

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/
LPSTR
MapStateToString(SCRIPTSTATE st)
{
  switch(st)
  {
    CASE_OF(SCRIPTSTATE_UNINITIALIZED);
    CASE_OF(SCRIPTSTATE_INITIALIZED);
    CASE_OF(SCRIPTSTATE_STARTED);
    CASE_OF(SCRIPTSTATE_CONNECTED);
    CASE_OF(SCRIPTSTATE_DISCONNECTED);
    CASE_OF(SCRIPTSTATE_CLOSED);

    default : return "?";
  }
}

/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

  MapTPOToString()

  WHAT    : maps a TPO_* (thread pool option) value to a string. if the option
            is unknown we emit a '?'.

  ARGS    : option - the option to map

  RETURNS : pointer to the options's string name

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/
LPSTR
MapTPOToString(DWORD option)
{
  switch(option)
  {
    CASE_OF(TPO_MAX_POOL_THREADS);
    CASE_OF(TPO_MAX_ACTIVE_THREADS);
    CASE_OF(TPO_SERVER_LISTEN_PORT);

    default : return "?";
  }
}

/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

  MapErrorToString()

  WHAT    : maps an error code to its string id. if the error is unknown we
            emit a '?'.

  ARGS    : error - the error code to map

  RETURNS : pointer to the error code's string name

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/
LPSTR
MapErrorToString(int error)
{
  switch(error)
  {
    CASE_OF(ERROR_SUCCESS);
    CASE_OF(ERROR_INVALID_FUNCTION);
    CASE_OF(ERROR_FILE_NOT_FOUND);
    CASE_OF(ERROR_PATH_NOT_FOUND);
    CASE_OF(ERROR_TOO_MANY_OPEN_FILES);
    CASE_OF(ERROR_ACCESS_DENIED);
    CASE_OF(ERROR_INVALID_HANDLE);
    CASE_OF(ERROR_ARENA_TRASHED);
    CASE_OF(ERROR_NOT_ENOUGH_MEMORY);
    CASE_OF(ERROR_INVALID_BLOCK);
    CASE_OF(ERROR_BAD_ENVIRONMENT);
    CASE_OF(ERROR_BAD_FORMAT);
    CASE_OF(ERROR_INVALID_ACCESS);
    CASE_OF(ERROR_INVALID_DATA);
    CASE_OF(ERROR_OUTOFMEMORY);
    CASE_OF(ERROR_INVALID_DRIVE);
    CASE_OF(ERROR_CURRENT_DIRECTORY);
    CASE_OF(ERROR_NOT_SAME_DEVICE);
    CASE_OF(ERROR_NO_MORE_FILES);
    CASE_OF(ERROR_WRITE_PROTECT);
    CASE_OF(ERROR_BAD_UNIT);
    CASE_OF(ERROR_NOT_READY);
    CASE_OF(ERROR_BAD_COMMAND);
    CASE_OF(ERROR_CRC);
    CASE_OF(ERROR_BAD_LENGTH);
    CASE_OF(ERROR_SEEK);
    CASE_OF(ERROR_NOT_DOS_DISK);
    CASE_OF(ERROR_SECTOR_NOT_FOUND);
    CASE_OF(ERROR_OUT_OF_PAPER);
    CASE_OF(ERROR_WRITE_FAULT);
    CASE_OF(ERROR_READ_FAULT);
    CASE_OF(ERROR_GEN_FAILURE);
    CASE_OF(ERROR_SHARING_VIOLATION);
    CASE_OF(ERROR_LOCK_VIOLATION);
    CASE_OF(ERROR_WRONG_DISK);
    CASE_OF(ERROR_SHARING_BUFFER_EXCEEDED);
    CASE_OF(ERROR_HANDLE_EOF);
    CASE_OF(ERROR_HANDLE_DISK_FULL);
    CASE_OF(ERROR_NOT_SUPPORTED);
    CASE_OF(ERROR_REM_NOT_LIST);
    CASE_OF(ERROR_DUP_NAME);
    CASE_OF(ERROR_BAD_NETPATH);
    CASE_OF(ERROR_NETWORK_BUSY);
    CASE_OF(ERROR_DEV_NOT_EXIST);
    CASE_OF(ERROR_TOO_MANY_CMDS);
    CASE_OF(ERROR_ADAP_HDW_ERR);
    CASE_OF(ERROR_BAD_NET_RESP);
    CASE_OF(ERROR_UNEXP_NET_ERR);
    CASE_OF(ERROR_BAD_REM_ADAP);
    CASE_OF(ERROR_PRINTQ_FULL);
    CASE_OF(ERROR_NO_SPOOL_SPACE);
    CASE_OF(ERROR_PRINT_CANCELLED);
    CASE_OF(ERROR_NETNAME_DELETED);
    CASE_OF(ERROR_NETWORK_ACCESS_DENIED);
    CASE_OF(ERROR_BAD_DEV_TYPE);
    CASE_OF(ERROR_BAD_NET_NAME);
    CASE_OF(ERROR_TOO_MANY_NAMES);
    CASE_OF(ERROR_TOO_MANY_SESS);
    CASE_OF(ERROR_SHARING_PAUSED);
    CASE_OF(ERROR_REQ_NOT_ACCEP);
    CASE_OF(ERROR_REDIR_PAUSED);
    CASE_OF(ERROR_FILE_EXISTS);
    CASE_OF(ERROR_CANNOT_MAKE);
    CASE_OF(ERROR_FAIL_I24);
    CASE_OF(ERROR_OUT_OF_STRUCTURES);
    CASE_OF(ERROR_ALREADY_ASSIGNED);
    CASE_OF(ERROR_INVALID_PASSWORD);
    CASE_OF(ERROR_INVALID_PARAMETER);
    CASE_OF(ERROR_NET_WRITE_FAULT);
    CASE_OF(ERROR_NO_PROC_SLOTS);
    CASE_OF(ERROR_TOO_MANY_SEMAPHORES);
    CASE_OF(ERROR_EXCL_SEM_ALREADY_OWNED);
    CASE_OF(ERROR_SEM_IS_SET);
    CASE_OF(ERROR_TOO_MANY_SEM_REQUESTS);
    CASE_OF(ERROR_INVALID_AT_INTERRUPT_TIME);
    CASE_OF(ERROR_SEM_OWNER_DIED);
    CASE_OF(ERROR_SEM_USER_LIMIT);
    CASE_OF(ERROR_DISK_CHANGE);
    CASE_OF(ERROR_DRIVE_LOCKED);
    CASE_OF(ERROR_BROKEN_PIPE);
    CASE_OF(ERROR_OPEN_FAILED);
    CASE_OF(ERROR_BUFFER_OVERFLOW);
    CASE_OF(ERROR_DISK_FULL);
    CASE_OF(ERROR_NO_MORE_SEARCH_HANDLES);
    CASE_OF(ERROR_INVALID_TARGET_HANDLE);
    CASE_OF(ERROR_INVALID_CATEGORY);
    CASE_OF(ERROR_INVALID_VERIFY_SWITCH);
    CASE_OF(ERROR_BAD_DRIVER_LEVEL);
    CASE_OF(ERROR_CALL_NOT_IMPLEMENTED);
    CASE_OF(ERROR_SEM_TIMEOUT);
    CASE_OF(ERROR_INSUFFICIENT_BUFFER);
    CASE_OF(ERROR_INVALID_NAME);
    CASE_OF(ERROR_INVALID_LEVEL);
    CASE_OF(ERROR_NO_VOLUME_LABEL);
    CASE_OF(ERROR_MOD_NOT_FOUND);
    CASE_OF(ERROR_PROC_NOT_FOUND);
    CASE_OF(ERROR_WAIT_NO_CHILDREN);
    CASE_OF(ERROR_CHILD_NOT_COMPLETE);
    CASE_OF(ERROR_DIRECT_ACCESS_HANDLE);
    CASE_OF(ERROR_NEGATIVE_SEEK);
    CASE_OF(ERROR_SEEK_ON_DEVICE);
    CASE_OF(ERROR_DIR_NOT_ROOT);
    CASE_OF(ERROR_DIR_NOT_EMPTY);
    CASE_OF(ERROR_PATH_BUSY);
    CASE_OF(ERROR_SYSTEM_TRACE);
    CASE_OF(ERROR_INVALID_EVENT_COUNT);
    CASE_OF(ERROR_TOO_MANY_MUXWAITERS);
    CASE_OF(ERROR_INVALID_LIST_FORMAT);
    CASE_OF(ERROR_BAD_ARGUMENTS);
    CASE_OF(ERROR_BAD_PATHNAME);
    CASE_OF(ERROR_BUSY);
    CASE_OF(ERROR_CANCEL_VIOLATION);
    CASE_OF(ERROR_ALREADY_EXISTS);
    CASE_OF(ERROR_FILENAME_EXCED_RANGE);
    CASE_OF(ERROR_LOCKED);
    CASE_OF(ERROR_NESTING_NOT_ALLOWED);
    CASE_OF(ERROR_BAD_PIPE);
    CASE_OF(ERROR_PIPE_BUSY);
    CASE_OF(ERROR_NO_DATA);
    CASE_OF(ERROR_PIPE_NOT_CONNECTED);
    CASE_OF(ERROR_MORE_DATA);
    CASE_OF(ERROR_NO_MORE_ITEMS);
    CASE_OF(ERROR_NOT_OWNER);
    CASE_OF(ERROR_PARTIAL_COPY);
    CASE_OF(ERROR_MR_MID_NOT_FOUND);
    CASE_OF(ERROR_INVALID_ADDRESS);
    CASE_OF(ERROR_PIPE_CONNECTED);
    CASE_OF(ERROR_PIPE_LISTENING);
    CASE_OF(ERROR_OPERATION_ABORTED);
    CASE_OF(ERROR_IO_INCOMPLETE);
    CASE_OF(ERROR_IO_PENDING);
    CASE_OF(ERROR_NOACCESS);
    CASE_OF(ERROR_STACK_OVERFLOW);
    CASE_OF(ERROR_INVALID_FLAGS);
    CASE_OF(ERROR_NO_TOKEN);
    CASE_OF(ERROR_BADDB);
    CASE_OF(ERROR_BADKEY);
    CASE_OF(ERROR_CANTOPEN);
    CASE_OF(ERROR_CANTREAD);
    CASE_OF(ERROR_CANTWRITE);
    CASE_OF(ERROR_REGISTRY_RECOVERED);
    CASE_OF(ERROR_REGISTRY_CORRUPT);
    CASE_OF(ERROR_REGISTRY_IO_FAILED);
    CASE_OF(ERROR_NOT_REGISTRY_FILE);
    CASE_OF(ERROR_KEY_DELETED);
    CASE_OF(ERROR_CIRCULAR_DEPENDENCY);
    CASE_OF(ERROR_SERVICE_NOT_ACTIVE);
    CASE_OF(ERROR_DLL_INIT_FAILED);
    CASE_OF(ERROR_CANCELLED);
    CASE_OF(ERROR_BAD_USERNAME);
    CASE_OF(ERROR_LOGON_FAILURE);

    CASE_OF(WAIT_FAILED);
    CASE_OF(WAIT_TIMEOUT);
    CASE_OF(WAIT_IO_COMPLETION);

    CASE_OF(RPC_S_INVALID_STRING_BINDING);
    CASE_OF(RPC_S_WRONG_KIND_OF_BINDING);
    CASE_OF(RPC_S_INVALID_BINDING);
    CASE_OF(RPC_S_PROTSEQ_NOT_SUPPORTED);
    CASE_OF(RPC_S_INVALID_RPC_PROTSEQ);
    CASE_OF(RPC_S_INVALID_STRING_UUID);
    CASE_OF(RPC_S_INVALID_ENDPOINT_FORMAT);
    CASE_OF(RPC_S_INVALID_NET_ADDR);
    CASE_OF(RPC_S_NO_ENDPOINT_FOUND);
    CASE_OF(RPC_S_INVALID_TIMEOUT);
    CASE_OF(RPC_S_OBJECT_NOT_FOUND);
    CASE_OF(RPC_S_ALREADY_REGISTERED);
    CASE_OF(RPC_S_TYPE_ALREADY_REGISTERED);
    CASE_OF(RPC_S_ALREADY_LISTENING);
    CASE_OF(RPC_S_NO_PROTSEQS_REGISTERED);
    CASE_OF(RPC_S_NOT_LISTENING);
    CASE_OF(RPC_S_UNKNOWN_MGR_TYPE);
    CASE_OF(RPC_S_UNKNOWN_IF);
    CASE_OF(RPC_S_NO_BINDINGS);
    CASE_OF(RPC_S_NO_PROTSEQS);
    CASE_OF(RPC_S_CANT_CREATE_ENDPOINT);
    CASE_OF(RPC_S_OUT_OF_RESOURCES);
    CASE_OF(RPC_S_SERVER_UNAVAILABLE);
    CASE_OF(RPC_S_SERVER_TOO_BUSY);
    CASE_OF(RPC_S_INVALID_NETWORK_OPTIONS);
    CASE_OF(RPC_S_NO_CALL_ACTIVE);
    CASE_OF(RPC_S_CALL_FAILED);
    CASE_OF(RPC_S_CALL_FAILED_DNE);
    CASE_OF(RPC_S_PROTOCOL_ERROR);
    CASE_OF(RPC_S_UNSUPPORTED_TRANS_SYN);
    CASE_OF(RPC_S_UNSUPPORTED_TYPE);
    CASE_OF(RPC_S_INVALID_TAG);
    CASE_OF(RPC_S_INVALID_BOUND);
    CASE_OF(RPC_S_NO_ENTRY_NAME);
    CASE_OF(RPC_S_INVALID_NAME_SYNTAX);
    CASE_OF(RPC_S_UNSUPPORTED_NAME_SYNTAX);
    CASE_OF(RPC_S_UUID_NO_ADDRESS);
    CASE_OF(RPC_S_DUPLICATE_ENDPOINT);
    CASE_OF(RPC_S_UNKNOWN_AUTHN_TYPE);
    CASE_OF(RPC_S_MAX_CALLS_TOO_SMALL);
    CASE_OF(RPC_S_STRING_TOO_LONG);
    CASE_OF(RPC_S_PROTSEQ_NOT_FOUND);
    CASE_OF(RPC_S_PROCNUM_OUT_OF_RANGE);
    CASE_OF(RPC_S_BINDING_HAS_NO_AUTH);
    CASE_OF(RPC_S_UNKNOWN_AUTHN_SERVICE);
    CASE_OF(RPC_S_UNKNOWN_AUTHN_LEVEL);
    CASE_OF(RPC_S_INVALID_AUTH_IDENTITY);
    CASE_OF(RPC_S_UNKNOWN_AUTHZ_SERVICE);
    CASE_OF(EPT_S_INVALID_ENTRY);
    CASE_OF(EPT_S_CANT_PERFORM_OP);
    CASE_OF(EPT_S_NOT_REGISTERED);
    CASE_OF(RPC_S_NOTHING_TO_EXPORT);
    CASE_OF(RPC_S_INCOMPLETE_NAME);
    CASE_OF(RPC_S_INVALID_VERS_OPTION);
    CASE_OF(RPC_S_NO_MORE_MEMBERS);
    CASE_OF(RPC_S_NOT_ALL_OBJS_UNEXPORTED);
    CASE_OF(RPC_S_INTERFACE_NOT_FOUND);
    CASE_OF(RPC_S_ENTRY_ALREADY_EXISTS);
    CASE_OF(RPC_S_ENTRY_NOT_FOUND);
    CASE_OF(RPC_S_NAME_SERVICE_UNAVAILABLE);
    CASE_OF(RPC_S_INVALID_NAF_ID);
    CASE_OF(RPC_S_CANNOT_SUPPORT);
    CASE_OF(RPC_S_NO_CONTEXT_AVAILABLE);
    CASE_OF(RPC_S_INTERNAL_ERROR);
    CASE_OF(RPC_S_ZERO_DIVIDE);
    CASE_OF(RPC_S_ADDRESS_ERROR);
    CASE_OF(RPC_S_FP_DIV_ZERO);
    CASE_OF(RPC_S_FP_UNDERFLOW);
    CASE_OF(RPC_S_FP_OVERFLOW);
    CASE_OF(RPC_X_NO_MORE_ENTRIES);
    CASE_OF(RPC_X_SS_CHAR_TRANS_OPEN_FAIL);
    CASE_OF(RPC_X_SS_CHAR_TRANS_SHORT_FILE);
    CASE_OF(RPC_X_SS_IN_NULL_CONTEXT);
    CASE_OF(RPC_X_SS_CONTEXT_DAMAGED);
    CASE_OF(RPC_X_SS_HANDLES_MISMATCH);
    CASE_OF(RPC_X_SS_CANNOT_GET_CALL_HANDLE);
    CASE_OF(RPC_X_NULL_REF_POINTER);
    CASE_OF(RPC_X_ENUM_VALUE_OUT_OF_RANGE);
    CASE_OF(RPC_X_BYTE_COUNT_TOO_SMALL);
    CASE_OF(RPC_X_BAD_STUB_DATA);

    CASE_OF(WSAEINTR);
    CASE_OF(WSAEBADF);
    CASE_OF(WSAEACCES);
    CASE_OF(WSAEFAULT);
    CASE_OF(WSAEINVAL);
    CASE_OF(WSAEMFILE);
    CASE_OF(WSAEWOULDBLOCK);
    CASE_OF(WSAEINPROGRESS);
    CASE_OF(WSAEALREADY);
    CASE_OF(WSAENOTSOCK);
    CASE_OF(WSAEDESTADDRREQ);
    CASE_OF(WSAEMSGSIZE);
    CASE_OF(WSAEPROTOTYPE);
    CASE_OF(WSAENOPROTOOPT);
    CASE_OF(WSAEPROTONOSUPPORT);
    CASE_OF(WSAESOCKTNOSUPPORT);
    CASE_OF(WSAEOPNOTSUPP);
    CASE_OF(WSAEPFNOSUPPORT);
    CASE_OF(WSAEAFNOSUPPORT);
    CASE_OF(WSAEADDRINUSE);
    CASE_OF(WSAEADDRNOTAVAIL);
    CASE_OF(WSAENETDOWN);
    CASE_OF(WSAENETUNREACH);
    CASE_OF(WSAENETRESET);
    CASE_OF(WSAECONNABORTED);
    CASE_OF(WSAECONNRESET);
    CASE_OF(WSAENOBUFS);
    CASE_OF(WSAEISCONN);
    CASE_OF(WSAENOTCONN);
    CASE_OF(WSAESHUTDOWN);
    CASE_OF(WSAETOOMANYREFS);
    CASE_OF(WSAETIMEDOUT);
    CASE_OF(WSAECONNREFUSED);
    CASE_OF(WSAELOOP);
    CASE_OF(WSAENAMETOOLONG);
    CASE_OF(WSAEHOSTDOWN);
    CASE_OF(WSAEHOSTUNREACH);
    CASE_OF(WSAENOTEMPTY);
    CASE_OF(WSAEPROCLIM);
    CASE_OF(WSAEUSERS);
    CASE_OF(WSAEDQUOT);
    CASE_OF(WSAESTALE);
    CASE_OF(WSAEREMOTE);
    CASE_OF(WSAEDISCON);
    CASE_OF(WSASYSNOTREADY);
    CASE_OF(WSAVERNOTSUPPORTED);
    CASE_OF(WSANOTINITIALISED);
    CASE_OF(WSAHOST_NOT_FOUND);
    CASE_OF(WSATRY_AGAIN);
    CASE_OF(WSANO_RECOVERY);
    CASE_OF(WSANO_DATA);

    CASE_OF(ERROR_FAILURE);
    CASE_OF(ERROR_INVALID_STATE);

    default : return "?";
  }
}

/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

  MapDispidToString()

  WHAT    : maps a dispid to a string for the log file.

  ARGS    : dispid - the dispid

  RETURNS : string representation of the dispid

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/
LPSTR
MapDispidToString(DISPID dispid)
{
  switch(dispid)
  {
    // special dispids
    CASE_OF(DISPID_VALUE);
    CASE_OF(DISPID_NEWENUM);
    CASE_OF(DISPID_EVALUATE);
    CASE_OF(DISPID_PROPERTYPUT);
    CASE_OF(DISPID_CONSTRUCTOR);
    CASE_OF(DISPID_DESTRUCTOR);
    CASE_OF(DISPID_UNKNOWN);
    CASE_OF(DISPID_COLLECT);

    // internal OM dispids
    CASE_OF(DISPID_SESSION_SOCKET);
    CASE_OF(DISPID_SESSION_REQUEST);
    CASE_OF(DISPID_SESSION_RESPONSE);
    CASE_OF(DISPID_SESSION_GETPROPERTYBAG);
    CASE_OF(DISPID_SESSION_KEEPALIVE);

    CASE_OF(DISPID_SOCKET_PARENT);
    CASE_OF(DISPID_SOCKET_SEND);
    CASE_OF(DISPID_SOCKET_RECV);
    CASE_OF(DISPID_SOCKET_OPTION);
    CASE_OF(DISPID_SOCKET_CLOSE);
    CASE_OF(DISPID_SOCKET_RESOLVE);
    CASE_OF(DISPID_SOCKET_LOCALNAME);
    CASE_OF(DISPID_SOCKET_LOCALADDRESS);
    CASE_OF(DISPID_SOCKET_LOCALPORT);
    CASE_OF(DISPID_SOCKET_REMOTENAME);
    CASE_OF(DISPID_SOCKET_REMOTEADDRESS);
    CASE_OF(DISPID_SOCKET_REMOTEPORT);

    CASE_OF(DISPID_HEADERS_PARENT);
    CASE_OF(DISPID_HEADERS_GET);
    CASE_OF(DISPID_HEADERS_SET);
    CASE_OF(DISPID_HEADERS_GETHEADER);
    CASE_OF(DISPID_HEADERS_SETHEADER);

    CASE_OF(DISPID_ENTITY_PARENT);
    CASE_OF(DISPID_ENTITY_GET);
    CASE_OF(DISPID_ENTITY_SET);
    CASE_OF(DISPID_ENTITY_COMPRESS);
    CASE_OF(DISPID_ENTITY_DECOMPRESS);

    CASE_OF(DISPID_URL_PARENT);
    CASE_OF(DISPID_URL_ENCODING);
    CASE_OF(DISPID_URL_SCHEME);
    CASE_OF(DISPID_URL_SERVER);
    CASE_OF(DISPID_URL_PORT);
    CASE_OF(DISPID_URL_PATH);
    CASE_OF(DISPID_URL_RESOURCE);
    CASE_OF(DISPID_URL_QUERY);
    CASE_OF(DISPID_URL_FRAGMENT);
    CASE_OF(DISPID_URL_ESCAPE);
    CASE_OF(DISPID_URL_UNESCAPE);
    CASE_OF(DISPID_URL_SET);
    CASE_OF(DISPID_URL_GET);

    CASE_OF(DISPID_REQUEST_PARENT);
    CASE_OF(DISPID_REQUEST_HEADERS);
    CASE_OF(DISPID_REQUEST_ENTITY);
    CASE_OF(DISPID_REQUEST_URL);
    CASE_OF(DISPID_REQUEST_VERB);
    CASE_OF(DISPID_REQUEST_HTTPVERSION);

    CASE_OF(DISPID_RESPONSE_PARENT);
    CASE_OF(DISPID_RESPONSE_HEADERS);
    CASE_OF(DISPID_RESPONSE_ENTITY);
    CASE_OF(DISPID_RESPONSE_STATUSCODE);
    CASE_OF(DISPID_RESPONSE_STATUSTEXT);

    CASE_OF(DISPID_W3SPOOF_REGISTERCLIENT);
    CASE_OF(DISPID_W3SPOOF_REVOKECLIENT);

    // internal runtime dispids
    CASE_OF(DISPID_RUNTIME_GETFILE);

    CASE_OF(DISPID_FILE_OPEN);
    CASE_OF(DISPID_FILE_CLOSE);
    CASE_OF(DISPID_FILE_WRITE);
    CASE_OF(DISPID_FILE_WRITELINE);
    CASE_OF(DISPID_FILE_WRITEBLANKLINE);
    CASE_OF(DISPID_FILE_READ);
    CASE_OF(DISPID_FILE_READALL);
    CASE_OF(DISPID_FILE_ATTRIBUTES);
    CASE_OF(DISPID_FILE_SIZE);
    CASE_OF(DISPID_FILE_TYPE);
    CASE_OF(DISPID_FILE_DATELASTMODIFIED);

    CASE_OF(DISPID_PROPERTYBAG_GET);
    CASE_OF(DISPID_PROPERTYBAG_SET);
    CASE_OF(DISPID_PROPERTYBAG_EXPIRES);
    CASE_OF(DISPID_PROPERTYBAG_FLUSH);

    default : return "?";
  }
}

LPSTR
MapVariantTypeToString(VARIANT* pvar)
{
  if( pvar )
  {
    switch( V_VT(pvar) )
    {
      CASE_OF(VT_ARRAY | VT_UI1);
      CASE_OF(VT_EMPTY);
      CASE_OF(VT_NULL);
      CASE_OF(VT_I2);
      CASE_OF(VT_I4);
      CASE_OF(VT_R4);
      CASE_OF(VT_R8);
      CASE_OF(VT_CY);
      CASE_OF(VT_DATE);
      CASE_OF(VT_BSTR);
      CASE_OF(VT_DISPATCH);
      CASE_OF(VT_ERROR);
      CASE_OF(VT_BOOL);
      CASE_OF(VT_VARIANT);
      CASE_OF(VT_DECIMAL);
      CASE_OF(VT_RECORD);
      CASE_OF(VT_UNKNOWN);
      CASE_OF(VT_I1);
      CASE_OF(VT_UI1);
      CASE_OF(VT_UI2);
      CASE_OF(VT_UI4);
      CASE_OF(VT_INT);
      CASE_OF(VT_UINT);
      CASE_OF(VT_ARRAY);
      CASE_OF(VT_BYREF);

      default : return "?";
    }
  }
  else
  {
    return "?";
  }
}

/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

  MapInvokeFlagsToString()

  WHAT    : maps invoke flags to a string for the log file.

  ARGS    : flags - the invoke flags

  RETURNS : string representation of the flags

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/
LPSTR
MapInvokeFlagsToString(WORD flags)
{
  return "NOT_IMPLEMENTED";
}


#ifdef _DEBUG

#define DEBUG_DEFAULT_DBGFILE L"W3SPOOF.LOG"
#define DEBUG_LOGFILE_MUTEX   L"W3Spoof_LogFile_Mutex"

//
// globals
//

DWORD    g_dwTlsIndex        = 0L;
DWORD    g_dwDebugFlags      = DBG_NO_DEBUG;
HANDLE   g_hDebugLogFile     = NULL;
HANDLE   g_mtxDebugLogFile   = NULL;
LPCWSTR  g_wszDebugFlags     = L"debugflags";
MEMUSAGE g_memusage          = {0};

/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

  DebugInitialize()

  WHAT    : initializes the debugging support for the application. allocates
            thread-local storage and opens a log file if necessary.

            on failure, the function sets the DBG_NO_DEBUG flag so other
            debug functions won't do anything to get us in trouble.

  ARGS    : none
  RETURNS : nothing

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/
void
DebugInitialize( void )
{
  LPDWORD pdw   = NULL;

  DebugMemInitialize();

  if( GetRegValue(g_wszDebugFlags, REG_DWORD, (void**) &pdw) )
  {
    g_dwDebugFlags = *pdw;
    delete pdw;
  }
  else
  {
    g_dwDebugFlags = DEBUG_DEFAULT_FLAGS;
  }

  if( DBG_THROWDBGALERT & g_dwDebugFlags )
    DebugThrowDbgAlert();

  if( !(g_dwDebugFlags & DBG_NO_DEBUG) )
  {
    //
    // allocate a TLS slot or else we can't
    // do call tracing
    //

    if( (g_dwTlsIndex = TlsAlloc()) == 0xFFFFFFFF )
      goto no_debug;

    //
    // if logging to file is enabled, open the log file
    // and create a mutex for log dumps, disable debug
    // logging on error
    //

    if( g_dwDebugFlags & DBG_TO_FILE )
    {
      if(
        !( _opendebugfile() &&
           (g_mtxDebugLogFile = CreateMutex(NULL, FALSE, DEBUG_LOGFILE_MUTEX))
         )
        )
        goto no_debug;
    }

    //
    // print the log banner
    //

    char* time = _gettimestamp();

    _debugout(
      NULL,
      TRUE,
      FALSE,
      "\r\nDebug W3SPOOF.EXE started at %s with flags: %x\r\n\r\n",
      time,
      g_dwDebugFlags
      );

    delete [] time;
    return;
  }
  else
  {
    DebugMemTerminate();
  }

no_debug:
  g_dwDebugFlags = DBG_NO_DEBUG;
}

/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

  DebugTerminate()

  WHAT    : terminates debugging support for the application. 

  ARGS    : none
  RETURNS : nothing.

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/
void
DebugTerminate( void )
{
  if( !(g_dwDebugFlags & DBG_NO_DEBUG) )
  {
    DebugMemTerminate();

    if( g_dwTlsIndex )
        TlsFree(g_dwTlsIndex);

    if( (g_dwDebugFlags & DBG_TO_FILE) && g_hDebugLogFile )
    {
      _closedebugfile();
      CloseHandle(g_mtxDebugLogFile);
      g_mtxDebugLogFile = NULL;
    }
  }
}

/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

  DebugMemInitialize()

  WHAT    : Initializes memory allocation tracking for the app.

  ARGS    : none.
  RETURNS : nothing.

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/
void
DebugMemInitialize(void)
{
  InitializeCriticalSection(&g_memusage.lock);
  g_memusage.total = 0;
}

/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

  DebugMemTerminate()

  WHAT    : Terminates memory allocation tracking and prints the final line
            in the logfile indicating how many bytes of memory were unallocated
            at process termination.

  ARGS    : none.
  RETURNS : nothing.

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/
void
DebugMemTerminate(void)
{
  if( g_dwDebugFlags & DBG_MEM )
    DebugTrace("*** unallocated memory: %d bytes", g_memusage.total);

  DeleteCriticalSection(&g_memusage.lock);
}

/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

  DebugMemAlloc()

  WHAT    : Increments our allocation tracking value by the number of bytes
            a given allocation maps to on the process heap.

  ARGS    : pv - pointer to allocated memory.

  RETURNS : nothing.

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/
void
DebugMemAlloc(void* pv)
{
  EnterCriticalSection(&g_memusage.lock);

    g_memusage.total += HeapSize(GetProcessHeap(), 0, pv);

  LeaveCriticalSection(&g_memusage.lock);
}

/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

  DebugMemFree()

  WHAT    : Decrements our allocation tracking value by the number of bytes an
            allocation uses on the heap.

  ARGS    : pv - pointer to allocated memory.

  RETURNS : nothing.

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/
void
DebugMemFree(void* pv)
{
  EnterCriticalSection(&g_memusage.lock);

    g_memusage.total -= HeapSize(GetProcessHeap(), 0, pv);    

  LeaveCriticalSection(&g_memusage.lock);
}

/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

  DebugThrowDbgAlert()

  WHAT    : Throws an alert dialog displaying the process PID so a debugger
            can be attached.

  ARGS    : none.
  RETURNS : nothing.

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/
void
DebugThrowDbgAlert(void)
{
  char buf[256];

  wsprintfA(
    buf,
    "pid=%d",
    GetCurrentProcessId()
    );

  MessageBoxA(NULL, buf, "Attach Debugger!", MB_OK | MB_ICONSTOP | MB_SERVICE_NOTIFICATION);
}

/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

  DebugEnter()

  WHAT    : called on api entry. prints a log entry resembling the following:

              CalledFunctionName(param1=value, etc.)

  ARGS    : category - the debugging category for the logged function
            rt       - lets us know what type the function returns
            function - the logged function's name
            format   - user-supplied format string containing function args
            ...      - optional parameter list

  RETURNS : nothing

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/
void
DebugEnter(int category, RETTYPE rt, LPCSTR function, const char* format, ...)
{
  LPTHREADINFO pti = NULL;
  LPCALLINFO   pci = NULL;

  if( !(g_dwDebugFlags & DBG_NO_DEBUG) )
  {
    pti = GetThreadInfo();
    pci = SetCallInfo(pti, category, rt, function);

    if( g_dwDebugFlags & category )
    {
      char*   buffer = new char[1024];
      va_list arg_list;

      pti->depth++;

      if( buffer )
      {
        //
        // if the user passed an arglist & some values,
        // we'll plug it in to the function entry listing
        // in the log. otherwise we just print empty parens
        //

        if( format )
        {
          va_start(arg_list, format);
          wvsprintfA(buffer, format, arg_list);

            _debugout(pti, FALSE, FALSE, "%s(%s)", function, buffer);

          va_end(arg_list);
        }
        else
        {
          _debugout(pti, FALSE, FALSE, "%s()", function);
        }
    
        delete [] buffer;
      }
    }
  }
}

/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

  DebugLeave()

  WHAT    : prints a log entry for the logged function displaying the return
            value.
            
  ARGS    : retval - the value the logged function will return
  RETURNS : nothing.

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/
void
DebugLeave(int retval)
{
  LPTHREADINFO pti = NULL;
  LPCALLINFO   pci = NULL;

  if( !(g_dwDebugFlags & DBG_NO_DEBUG) )
  {
    pti = GetThreadInfo();
    pci = GetCallInfo(pti);

    if( g_dwDebugFlags & pci->category )
    {
      char* buffer = FormatCallReturnString(pci, retval);

      _debugout(pti, FALSE, FALSE, buffer);
      pti->depth--;
      delete [] buffer;
    }

    DeleteCallInfo(pci);
  }
}

/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

  DebugTrace()

  WHAT    : prints a generic output line with the usual timestamp & thread id,
            etc.

  ARGS    : format - user-supplied format string
            ...    - optional parameter list

  RETURNS : nothing

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/
void
DebugTrace(const char* format, ...)
{
  va_list arg_list;
  char    buf[1024];

  if( !(g_dwDebugFlags & DBG_NO_DEBUG) )
  {
    va_start(arg_list, format);

      wvsprintfA(buf, format, arg_list);
      _debugout(GetThreadInfo(), FALSE, TRUE, buf);

    va_end(arg_list);
  }
}

/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

  DebugAssert()

  WHAT    : logs asserts to the selected outputs but doesn't break execution.

  ARGS    : condition - the stringized failure condition.
            file      - the file containing the assert
            line      - the line of code that asserted

  RETURNS : nothing

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/
void
DebugAssert(LPSTR condition, LPSTR file, int line)
{
  LPTHREADINFO pti = GetThreadInfo();
  LPCALLINFO   pci = NULL;

  _debugout(
    pti,
    TRUE,
    FALSE,
    "\r\n\r\n\t*******************************************\r\n" \
    "\t ASSERTION FAILED: \"%s\"\r\n" \
    "\t  %s (line %d)\r\n",
    condition,
    file,
    line
    );

  for(pci = pti->stack; pci; pci = pci->next)
  {
    _debugout(pti, TRUE, FALSE, "\t   %s", pci->fname);
  }

  _debugout(pti, TRUE, FALSE, "\r\n\t*******************************************\r\n");
}

/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

  DebugDataDump*()

  WHAT    : functions to dump a data buffer to the log file.

  ARGS    : title - a legend for the dump
            data  - the buffer
            len   - number of interesting bytes in the buffer

  RETURNS : nothing

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/
void
DebugDataDump(LPSTR title, LPBYTE data, DWORD len)
{
  DWORD n      = 0L;
  DWORD offset = 0L;
  CHAR* buf    = NULL;

  DebugTrace("%s (%#x bytes @ %#x)", title, len, data);

  buf = new CHAR[256];

    while( len )
    {
      n = DebugDataDumpFormat(buf, data, len);

      DebugTrace(buf);

      data += n;
      len  -= n;
    }

  delete [] buf;
}

int
DebugDataDumpFormat(LPSTR buffer, LPBYTE data, DWORD len)
{
  //
  // note - plagiarized from similar code in wininet.
  //

  static char spaces[] = "                                               ";

  DWORD n      = 0L;
  DWORD bytes  = 0L;
  DWORD offset = 0L;
  DWORD byte   = 0L;
  CHAR  ch;

  bytes  = min(len, 16);
  offset = wsprintfA(buffer, "%08x  ", data);

  for(n=0; n<bytes; n++)
  {
    byte    = data[n] & 0xFF;

    offset += wsprintfA(
                buffer+offset,
                ((n & 15) == 7 ? "%02.2x-" : "%02.2x "),
                byte                
                );
  }

  memcpy(buffer+offset, spaces, (16-bytes) * 3 + 2);
  offset += (16-bytes) * 3 + 2;

  for(n=0; n<bytes; n++)
  {
    ch = data[n];
    buffer[offset + n] =  (((ch < 32) || (ch > 127)) || ch == '%') ? '.' : ch;
  }

  buffer[offset + n] = '\0';

  return bytes;
}


/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

  AcquireDebugFileLock()

  WHAT    : synchronizes access to the log file handle.

  ARGS    : none
  RETURNS : nothing

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/
void
AcquireDebugFileLock(void)
{
  WaitForSingleObject(g_mtxDebugLogFile, INFINITE);
}

/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

  ReleaseDebugFileLock()

  WHAT    : releases a thread's lock on the log file handle

  ARGS    : none
  RETURNS : nothing

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/
void
ReleaseDebugFileLock(void)
{
  ReleaseMutex(g_mtxDebugLogFile);
}

/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

  GetThreadInfo()

  WHAT    : extracts a THREADINFO struct from TLS. if one does not exist,
            this function allocates one and returns it.

  ARGS    : none
  RETURNS : pointer to a THREADINFO struct.

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/
LPTHREADINFO
GetThreadInfo(void)
{
  LPTHREADINFO pti = (LPTHREADINFO) TlsGetValue(g_dwTlsIndex);

    if( !pti )
    {
      pti = new THREADINFO;

      pti->threadid  = GetCurrentThreadId();
      pti->threadcat = 0;
      pti->depth     = 0;
      pti->stack     = NULL;

      TlsSetValue(g_dwTlsIndex, (LPVOID) pti);
    }

  return pti;
}

/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

  SetCallInfo()

  WHAT    : allocates and pushes a CALLINFO struct onto the thread's internal
            call list.

  ARGS    : pti      - pointer to the thread's THREADINFO struct
            category - the debug category associated with the logged function
            rt       - return type used by the logged function
            function - the function name

  RETURNS : pointer to a newly allocated CALLINFO struct

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/
LPCALLINFO
SetCallInfo(LPTHREADINFO pti, DWORD category, RETTYPE rt, LPCSTR function)
{
  LPCALLINFO pci   = NULL;
  LPCALLINFO plast = NULL;

  //
  // walk the call stack to the last item,
  // store the next-to-last position
  //

  for( pci = pti->stack; pci; pci = pci->next )
  {
    plast = pci;
  }

  if( !pci )
  {
    pci = new CALLINFO;

    //
    // if this is the first call on this thread, set the thread
    // category id. this makes logging more understandable by
    // remembering where a thread was first created and what it
    // was used for. the old method changed the caller id based
    // on the function category, which was dumb.
    //

    if( !pti->threadcat )
      pti->threadcat = category;

    pci->category = category;
    pci->fname    = function;
    pci->rettype  = rt;
    pci->last     = plast;
    pci->next     = NULL;

    //
    // if this is the first element, insert it
    // at the head of the list, otherwise
    // link up with the last element
    //

    if( !pti->stack )
    {
      pti->stack = pci;
    }
    else
    {
      plast->next = pci;
    }
  }

  return pci;
}

/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

  GetCallInfo()

  WHAT    : retrieves the last THREADINFO struct from the threads call trace
            list.

  ARGS    : pti - pointer to the THREADINFO struct whose call list you want

  RETURNS : pointer to a CALLINFO struct

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/
LPCALLINFO
GetCallInfo(LPTHREADINFO pti)
{
  LPCALLINFO pci = NULL;

  if( pti->stack )
  {
    for( pci = pti->stack; pci->next; pci = pci->next );
  }

  return pci;
}

/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

  DeleteCallInfo()

  WHAT    : pops the specified CALLINFO struct off the thread's call list and
            deletes it. if we just popped & deleted the last call record, then
            delete the thread's THREADINFO struct.

  ARGS    : pci - the CALLINFO struct you wish to delete

  RETURNS : nothing

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/
void
DeleteCallInfo(LPCALLINFO pci)
{
  LPTHREADINFO pti = GetThreadInfo();

  //
  // if the call record we're dealing with isn't the top of the stack
  // then fix up the stack pointers
  //
  // if the current call record is the last then delete the THREADINFO
  // for this thread and NULL the TLS value
  //

  if( pci->last )
  {
    pci->last->next = NULL;
  }
  else
  {
    delete pti;
    TlsSetValue(g_dwTlsIndex, NULL);
  }

  //
  // for all cases, free the call record
  //

  delete pci;
}

/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

  FormatCallReturnString()

  WHAT    : examines the returning function's return type and formats a string
            containing the return value. in the case of known error codes, we
            include a string representation of the error (e.g. ERROR_SUCCESS).

  ARGS    : pci    - pointer to the CALLINFO struct for the returning function
            retval - the function's return value

  RETURNS : formatted character buffer

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/
LPSTR
FormatCallReturnString(LPCALLINFO pci, int retval)
{
  char* buffer = new char[256];
  int   offset = 0;

  if( buffer )
  {
    offset = wsprintfA(
               buffer,
               "%s() returned ",
               pci->fname
               );

    switch( pci->rettype )
    {
      case rt_void :
        {
          wsprintfA(buffer+offset, "<void>");
        }
        break;

      case rt_bool :
        {
          wsprintfA(buffer+offset, "%s", (retval ? "TRUE" : "FALSE"));
        }
        break;

      case rt_dword :
        {
          wsprintfA(buffer+offset, "%d [%s]", retval, MapErrorToString(retval));
        }
        break;

      case rt_hresult :
        {
          wsprintfA(buffer+offset, "%x [%s]", retval, MapHResultToString(retval));
        }
        break;

      case rt_string :
        {
          wsprintfA(buffer+offset, "%.16s", (LPSTR)retval);
        }
        break;

      default:
        {
          wsprintfA(buffer+offset, "?");
        }
    }
  }

  return buffer;
}

/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

  MapCategoryToString()

  WHAT    : maps a debug category to a string for the log file.

  ARGS    : category - the category id

  RETURNS : string representation of the category id

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/
LPSTR
MapCategoryToString(int category)
{
  switch(category)
  {
    case DBG_APP : return "app";
    case DBG_WORKER : return "---";

    default : return "???";
  }
}

/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

  MapCompKeyToString()

  WHAT    : maps a completion key to a string for the log file.

  ARGS    : key - the completion key

  RETURNS : string representation of the completion key

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/
LPSTR
MapCompKeyToString(int key)
{
  switch(key)
  {
    CASE_OF(CK_INVALID_KEY);
    CASE_OF(CK_NEW_CONNECTION);
    CASE_OF(CK_NORMAL);
    CASE_OF(CK_CANCEL_IO);
    CASE_OF(CK_TERMINATE_THREAD);

    default :
      {
        return "*** WARNING: Unrecognized completion key!! ***";
      }
  }
}

/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

  _debugout()

  WHAT    : the debug output workhorse. sloppy as jello in the Texas sun and
            i don't care.

  ARGS    : pti    - THREADINFO pointer
            fRaw   - skip debug info formatting
            fTrace - flag that causes us to do in-function indenting
            format - printf format string
            ...    - arglist

  RETURNS : nothing  

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/
void
_debugout(LPTHREADINFO pti, BOOL fRaw, BOOL fTrace, const char* format, ...)
{
  int        offset = 0;
  char*      buffer = new char[2048];
  va_list    arg_list;

  if( !buffer )
    goto quit;

    //
    // check if the user wants verbose debug info
    //

    if( !fRaw )
    {
      if( DBG_TIMESTAMP & g_dwDebugFlags )
      {
        char* timestamp = _gettimestamp();

        offset = wsprintfA(buffer, "%s ", timestamp);
        delete [] timestamp;
      }

      if( DBG_THREAD_INFO & g_dwDebugFlags )
      {
        offset += wsprintfA(buffer+offset, "%0.8x:%0.3d ", pti->threadid, pti->depth);
      }

      if( DBG_CALL_INFO & g_dwDebugFlags )
      {
        //
        // 260500 pmidge
        // changed this to use the thread category id instead of the caller's id.
        //

        offset += wsprintfA(buffer+offset, "<%s> ", MapCategoryToString(pti->threadcat));
      }

      if( DBG_NEST_CALLS & g_dwDebugFlags )
      {
        char* whitespace = _getwhitespace(
                              (fTrace ? pti->depth+1 : pti->depth)
                              );

        offset += wsprintfA(buffer+offset, "%s", whitespace);
        delete [] whitespace;
      }
    }


    //
    // plug in caller's goo if present
    //

    if( format )
    {
      va_start(arg_list, format);
      
        offset += wvsprintfA(buffer+offset, format, arg_list);
        wsprintfA(buffer+offset, "\r\n");
      
      va_end(arg_list);
    }


    //
    // dump to selected outputs
    //

    //
    // BUGBUG: this app only runs on W2K, need to
    //         investigate WMI support
    //

    if( DBG_TO_FILE & g_dwDebugFlags )
    {
      DWORD dw = 0;
    
      AcquireDebugFileLock();

        WriteFile(
          g_hDebugLogFile,
          buffer,
          strlen(buffer),
          &dw,
          NULL
          );
      
      ReleaseDebugFileLock();
    }

    if( DBG_TO_DEBUGGER & g_dwDebugFlags )
      OutputDebugStringA(buffer);

quit:
  delete [] buffer;
}

/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

  _gettimestamp( void )

  WHAT    : gets the current time, formats it, and returns it to the caller.
            the caller MUST free the return value when done.

  ARGS    : none
  RETURNS : pointer to formatted time string

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/
char*
_gettimestamp( void )
{
  SYSTEMTIME st;
  char*      buffer = new char[256];
  
  if( buffer )
  {
    GetLocalTime(&st);

    wsprintfA(
      buffer,
      "%0.2d:%0.2d:%0.2d.%0.3d",
      st.wHour,
      st.wMinute,
      st.wSecond,
      st.wMilliseconds
      );
  }

  return buffer;
}

/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

  _getwhitespace( int spaces )

  WHAT    : used to insert a number of spaces for indenting. caller must
            free return value.

  ARGS    : spaces - number of spaces to insert
  
  RETURNS : pointer to character buffer filled with spaces

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/
char*
_getwhitespace(int spaces)
{
  char* buffer = new char[(spaces * 2) + 1];

  if( buffer )
  {
    memset(buffer, ' ', (spaces * 2));
    buffer[(spaces * 2)] = '\0';
  }

  return buffer;
}

/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

  _opendebugfile( void )

  WHAT    : opens the debug log file. will stomp previous logs instead of
            appending.

  ARGS    : none

  RETURNS : true or false based on whether the file was opened.

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/
BOOL
_opendebugfile(void)
{
  if( !g_hDebugLogFile )
  {
    g_hDebugLogFile = CreateFile(
                        DEBUG_DEFAULT_DBGFILE,
                        GENERIC_READ | GENERIC_WRITE,
                        FILE_SHARE_READ,
                        NULL,
                        CREATE_ALWAYS,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL
                        );
  }
  
  return (g_hDebugLogFile ? TRUE : FALSE);
}

/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

  _closedebugfile( void )

  WHAT    : closes the debug log file.
  ARGS    : none
  RETURNS : nothing

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/
void
_closedebugfile(void)
{
  SAFECLOSE(g_hDebugLogFile);
}

#endif /* _DEBUG */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\tools\w3spoof\common\int_guids.c ===
/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Copyright (c) 2000  Microsoft Corporation

Module Name:

    int_guids.c

Abstract:

    Non-MIDL generated GUIDs used by internal COM calls
    
Author:

    Paul M Midgen (pmidge) 28-August-2000

Revision History:

    28-August-2000 pmidge
        Created

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifdef __cplusplus
extern "C" {
#endif

// {42965D97-C33A-4bc7-A101-54E4EC19ED10}
const IID IID_IConfig = 
{
  0x42965d97,
  0xc33a,
  0x4bc7,
  { 0xa1, 0x1, 0x54, 0xe4, 0xec, 0x19, 0xed, 0x10 }
};

// {8E4A89E3-18C9-482b-B2EC-89D1DF06C46E}
const IID IID_IW3Spoof =
{
  0x8e4a89e3,
  0x18c9,
  0x482b,
  { 0xb2, 0xec, 0x89, 0xd1, 0xdf, 0x6, 0xc4, 0x6e }
};

const IID IID_IW3SpoofEvents =
{
  0x64896c1c,
  0x7757,
  0x4858,
  { 0xbd, 0x08, 0x70, 0x7c, 0xd3, 0x4c, 0x1b, 0xc4 }
};

// {8BACDCBC-94AA-4401-95C6-894D7B54ACF5}
const IID IID_IThreadPool =
{
  0x8bacdcbc,
  0x94aa,
  0x4401,
  { 0x95, 0xc6, 0x89, 0x4d, 0x7b, 0x54, 0xac, 0xf5 }
};

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\tools\stress\stressscheduler\src\winhttpstressscheduler.h ===
///////////////////////////////////////////////////////////////////////////
// File:  WinHttpStressScheduler.h
//
// Copyright (c) 2001 Microsoft Corporation.  All Rights Reserved.
//
// Purpose:
//	Global types and interfaces for the WinHttpStressScheduler project.
//
// History:
//	02/01/01	DennisCh	Created
///////////////////////////////////////////////////////////////////////////


#if !defined INC__WINHTTPSTRESSSCHEDULER_H
	#define  INC__WINHTTPSTRESSSCHEDULER_H


//////////////////////////////////////////////////////////////////////
// Constants
//////////////////////////////////////////////////////////////////////
#define _UNICODE

#define WINHTTP_STRESS_SCHEDULER__NAME	"WinHttp stressScheduler"
#define WINHTTP_WINHTTP_HOME_URL		"http://winhttp"
#define WINHTTP_STRESSADMIN_URL			"http://winhttp/stressAdmin/configure-client.asp?" FIELDNAME__CLIENT_ID "%u"

// used to notify the tray icon
#define MYWM_NOTIFYICON	(WM_APP+100)

#define WINHTTP_STRESS_SCHEDULER_MUTEX	"WinHttpStressScheduler"


//////////////////////////////////////////////////////////////////////
// Includes
//////////////////////////////////////////////////////////////////////

//
// WIN32 headers
//
#include <windows.h>
#include <tchar.h>

//
// Project headers
//
#include "res\resource.h"

#endif // defined INC__WINHTTPSTRESSSCHEDULER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\tools\w3spoof\common\stores.cxx ===
/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Copyright (c) 2000  Microsoft Corporation

Module Name:

    stores.cxx

Abstract:

    Implementations of objects deriving from the hashtable & list ADTs that
    are used for stores of various data.
    
Author:

    Paul M Midgen (pmidge) 14-November-2000


Revision History:

    14-November-2000 pmidge
        Created

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/

#include "common.h"


VOID VariantKiller(LPVOID* ppv)
{
  VARIANT** ppvr = (VARIANT**) ppv;

  VariantClear(*ppvr);
  SAFEDELETE(*ppvr);
}


VOID PropertyBagKiller(LPVOID* ppv)
{
  PPROPERTYBAG* ppbag = (PPROPERTYBAG*) ppv;

  SAFETERMINATE((*ppbag));
}


VOID BSTRKiller(LPVOID* ppv)
{
  BSTR bstr = (BSTR) *ppv;
  SysFreeString(bstr);
}


void CHeaderList::GetHash(LPSTR id, LPDWORD lpHash)
{
  *lpHash = ::GetHash(id);
}


void CStringMap::GetHashAndBucket(LPWSTR id, LPDWORD lpHash, LPDWORD lpBucket)
{
  DWORD hash = GetHash(id);

  *lpHash   = hash;
  *lpBucket = hash % 100;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\tools\w3spoof\common\mem.cxx ===
/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Copyright (c) 1999  Microsoft Corporation

Module Name:

    mem.cpp

Abstract:

    Replacements for operators new & delete.

    Routines implemented in this module:

      _InitMem()
      operator new
      operator delete

    These routines delegate to HeapAlloc/HeapFree, and party on the process
    heap. This helps overcome the problem of using general-purpose allocation
    functions as well as using new/delete to deal with C++ objects.
    
    Rudimentary allocation tracking is enabled in debug builds that
    allows us to see (via the last line in the log file) how much memory
    went unallocated at process termination. This doesn't take into account
    kernel, gdi, or user objects.

    Memory deallocation routines are "safe" in the sense that you can pass
    NULL pointers (invalid pointers aren't detected).

Author:

    Paul M Midgen (pmidge) 01-June-2000


Revision History:

    01-June-2000 pmidge
        Created

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/

#include "common.h"
//#include "mem.h"

HANDLE g_hProcessHeap = NULL;

/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

  _InitMem()

  WHAT    : Sets the global process heap handle call this before any
            allocations occur or you'll fault. Pretty simple.

  ARGS    : none.
  RETURNS : nothing

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/
void _InitMem(void)
{
  g_hProcessHeap = GetProcessHeap();
}

/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

  operator new

  WHAT    : Replaces the global operator new. Same usage semantics. Allocates
            objects, makes implicit calls to their constructors.

  ARGS    : size - size in bytes of the object to be allocated. the compiler
                   pushes this argument on the stack automagically.

  RETURNS : void pointer to allocated memory.

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/
void* __cdecl operator new(size_t size)
{
  void* pv = NULL;

  if( !g_hProcessHeap )
    _InitMem();
  
    pv = HeapAlloc(g_hProcessHeap, HEAP_ZERO_MEMORY, size);
    DEBUG_ALLOC(pv);

  return pv;
}

/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

  operator delete

  WHAT    : Replaces the global operator delete. Same usage semantics. Deletes
            objects, makes implicit call to their destructors.

  ARGS    : pv - pointer to object to be freed. same compiler magic as with
                 operator new.

  RETURNS : nothing.

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/
void __cdecl operator delete(void* pv)
{
  if( !g_hProcessHeap )
    _InitMem();

  if( pv )
  {
    DEBUG_FREE(pv);
    HeapFree(g_hProcessHeap, 0, pv);
  }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\tools\w3spoof\common\registry.cxx ===
/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Copyright (c) 2000  Microsoft Corporation

Module Name:

    registry.cpp

Abstract:

    Registry functions.
    
Author:

    Paul M Midgen (pmidge) 23-May-2000


Revision History:

    23-May-2000 pmidge
        Created

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/

#include "common.h"
//#include "registry.h"

LPCWSTR g_wszAppRootKeyName = L"Software\\W3Spoof";

/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

  GetRegValue()

  WHAT      : Reads the value of a REG_DWORD or REG_SZ registry value. The
              caller must free the value returned through ppvData.

  ARGS      : szValueName - the value to look up
              dwType      - can be REG_SZ or REG_DWORD
              ppvData     - address of a pointer to initialize to the data
                            read from the registry

  RETURNS   : True if the lookup succeeded, false if there was an error. The
              caller can call GetLastError() to determine the type of error.
              Possible values returned by GetLastError() are:

              ERROR_NOT_ENOUGH_MEMORY - failed to allocate storage for the
                                        requested key

              ERROR_INVALID_PARAMETER - unsupported type in dwType

              If registry lookups fail we set last error to the retcode
              from the registry api we called.

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/
BOOL
GetRegValue(LPCWSTR wszValueName, DWORD dwType, LPVOID* ppvData)
{
  BOOL   bStatus   = FALSE;
  DWORD  dwRet     = 0L;
  LPBYTE lpData    = NULL;
  DWORD  cbData    = 0L;
  HKEY   hkAppRoot = _GetRootKey(TRUE);

  switch( dwType )
  {
    case REG_DWORD :
      {
        cbData = sizeof(DWORD);
        lpData = new BYTE[cbData];

        if( !lpData )
        {
          SetLastError(ERROR_NOT_ENOUGH_MEMORY);
          goto quit;
        }
      }
      break;

    case REG_SZ :
      {
        // get required buffer size
        dwRet = RegQueryValueEx(
                  hkAppRoot, wszValueName, 0L,
                  &dwType, lpData, &cbData
                  );

          if( dwRet )
          {
            //DEBUG_TRACE(REGISTRY, ("requested key (%s) doesn't exist", szValueName));
            SetLastError(dwRet);
            goto quit;
          }

        lpData = new BYTE[cbData];

          if( !lpData )
          {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            goto quit;
          }
      }
      break;

    default :
      {
        DEBUG_TRACE(REGISTRY, ("requested type not supported"));
        SetLastError(ERROR_INVALID_PARAMETER);
        goto quit;
      }
      break;
  }

  //
  // do the lookup
  //
  dwRet = RegQueryValueEx(
            hkAppRoot, wszValueName, 0L,
            &dwType, lpData, &cbData
            );
    
    if( dwRet )
    {
      delete [] lpData;
      SetLastError(dwRet);
      goto quit;
    }

  bStatus  = TRUE;
  *ppvData = (LPVOID) lpData;

#ifdef _DEBUG
    if( bStatus )
    {
      switch( dwType )
      {
        case REG_DWORD :
          DEBUG_TRACE(REGISTRY, ("lpData: %d; cbData: %d", (DWORD)*lpData, cbData));
          break;

        case REG_SZ :
          DEBUG_TRACE(REGISTRY, ("lpdata: %s; cbData: %d", (LPSTR)lpData, cbData));
          break;
      }
    }
#endif

quit:

  return bStatus;
}


/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

  SetRegValue()

  WHAT      : Writes a value under the application registry key.

  ARGS      : szValueName - the name of the regkey to write to
              dwType      - type of the regkey to write
              pvData      - regkey data
              dwSize      - bytecount of data to write

  RETURNS   : True if the write succeeded, false if otherwise.

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/
BOOL
SetRegValue(LPCWSTR wszValueName, DWORD dwType, LPVOID pvData, DWORD dwSize)
{
  BOOL  bStatus   = FALSE;
  DWORD dwRet     = 0L;
  HKEY  hkAppRoot = _GetRootKey(TRUE);

#ifdef _DEBUG
    switch( dwType )
    {
      case REG_DWORD :
        DEBUG_TRACE(REGISTRY, ("pvData: %d; dwSize: %d", (DWORD)*((LPDWORD)pvData), dwSize));
        break;

      case REG_SZ :
        DEBUG_TRACE(REGISTRY, ("pvData: %s; dwSize: %d", (LPSTR)pvData, dwSize));
        break;
    }
#endif

    if( !dwSize && pvData )
      dwSize = strlen((LPSTR)pvData);

    dwRet = RegSetValueEx(
              hkAppRoot, wszValueName, 0L,
              dwType, (LPBYTE)pvData, dwSize
              );

    if( dwRet != ERROR_SUCCESS )
      SetLastError(dwRet);
    else
      bStatus = TRUE;      

  return bStatus;
}

/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

  _GetRootKey()

  WHAT      : Creates/opens the root key used by the app. Remembers the key
              handle across calls, and can be called to release the key handle.

  ARGS      : fOpen - if true, open the regkey, if false, close it.

  RETURNS   : regkey handle.

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/
HKEY _GetRootKey(BOOL fOpen)
{
  DWORD       disp = 0;
  DWORD       ret  = 0;
  static HKEY root = NULL;

  if( fOpen )
  {
    if( !root )
    {
      ret = RegCreateKeyEx(
              HKEY_CURRENT_USER,
              g_wszAppRootKeyName,
              0,
              NULL,
              REG_OPTION_NON_VOLATILE,
              KEY_ALL_ACCESS,
              NULL,
              &root,
              &disp
              );
    }
  }
  else
  {
    if( root )
    {
      RegCloseKey(root);
      root = NULL;
    }
  }

  return root;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\tools\w3spoof\exe\entry.cxx ===
/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Copyright (c) 2000  Microsoft Corporation

Module Name:

    entry.c

Abstract:

    Implements the WinMain() application entry point.
    
Author:

    Paul M Midgen (pmidge) 07-June-2000


Revision History:

    07-June-2000 pmidge
        Created

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/

#include "common.h"

void _SetCurrentDirectory(void);
BOOL Initialize(void);
void Terminate(void);

int
WINAPI
WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, PSTR szCmdLine, int iCmdShow)
{
  _SetCurrentDirectory();

  DEBUG_INITIALIZE();

  DEBUG_ENTER((
    DBG_APP,
    rt_dword,
    "WinMain",
    "hInstance=%#x; hPrevInstance=%#x; cmdline=%s; cmdshow=%d",
    hInstance,
    hPrevInstance,
    szCmdLine,
    iCmdShow
    ));

  DWORD       dwRet = ERROR_SUCCESS;
  HRESULT     hr    = S_OK;
  CFactory*   pcf   = NULL;
  IW3Spoof*   pw3s  = NULL;

    if( Initialize() )
    {
      hr = CFactory::Create(&pcf);

        if( FAILED(hr) )
        {
          DEBUG_TRACE(APP, ("failed to create class factory"));
          goto quit;
        }

      hr = pcf->CreateInstance(NULL, IID_IW3Spoof, (void**) &pw3s);

        if( FAILED(hr) )
        {
          DEBUG_TRACE(APP, ("failed to create w3spoof interface"));
          goto quit;
        }

      if( szCmdLine && strstr(szCmdLine, "register") )
      {
        goto quit;
      }

      pcf->Activate();
      pw3s->WaitForUnload();
    }
    else
    {
      DEBUG_TRACE(APP, ("application init failed."));
    }

quit:

  DEBUG_TRACE(APP, ("starting final cleanup"));

  SAFETERMINATE(pcf);    
  SAFERELEASE(pw3s);

  Terminate();

  DEBUG_LEAVE(dwRet);
  DEBUG_TERMINATE();
  return dwRet;
}


void
_SetCurrentDirectory(void)
{
  WCHAR path[MAX_PATH+1];

  memset((void*) path, 0L, MAX_PATH+1);

  if( GetModuleFileName(NULL, path, MAX_PATH) )
  {
    *(wcsrchr(path, L'\\')) = L'\0';
    SetCurrentDirectory(path);
  }
}


BOOL
Initialize(void)
{
  BOOL    bRet  = TRUE;
  DWORD   dwRet = ERROR_SUCCESS;
  HRESULT hr    = S_OK;
  WSADATA wsd   = {0};

  hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);

    if( SUCCEEDED(hr) )
    {
      if( (dwRet = WSAStartup(0x0202, &wsd)) != ERROR_SUCCESS )
      {
        DEBUG_TRACE(APP, ("WSAStartup failed: %d [%s]", dwRet, MapErrorToString(dwRet)));
        bRet = FALSE;
      }
      else
      {
        DEBUG_DUMPWSOCKSTATS(wsd);
      }
    }
    else
    {
      DEBUG_TRACE(APP, ("CoInitialize failed: %d [%s]", hr, MapHResultToString(hr)));
      bRet = FALSE;
    }

  return bRet;
}


void
Terminate(void)
{
  _GetRootKey(FALSE);
  WSACleanup();
  CoUninitialize();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\tools\w3spoof\common\utils.cxx ===
/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Copyright (c) 2000  Microsoft Corporation

Module Name:

    utils.cxx

Abstract:

    Utility functions.
    
Author:

    Paul M Midgen (pmidge) 12-October-2000


Revision History:

    12-October-2000 pmidge
        Created

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/

#include "common.h"

#ifdef __cplusplus
extern "C" {
#endif

const IID IID_IWinHttpRequest =
{
  0x06f29373,
  0x5c5a,
  0x4b54,
  {0xb0,0x25,0x6e,0xf1,0xbf,0x8a,0xbf,0x0e}
};

#ifdef __cplusplus
}
#endif

//-----------------------------------------------------------------------------
// file retrieval
//-----------------------------------------------------------------------------
BOOL
__PathIsUNC(LPCWSTR path)
{
  BOOL   bIsUNC   = FALSE;
  WCHAR* embedded = NULL;

  // is the path a UNC share? e.g. \\foo\bar\baz.htm
  if( wcsstr(path, L"\\\\") )
  {
    embedded = wcsstr(path, L"\\");

    if( embedded && (wcslen(embedded) > 1) )
    {
      bIsUNC = TRUE;
    }
  }
  else // how about a filesystem path, e.g. z:\foo\bar.htm
  {
    embedded = wcsstr(path, L":");

    if( embedded && ((embedded-1) == path) )
    {
      bIsUNC = TRUE;
    }
  }

  return bIsUNC;
}

BOOL
__PathIsURL(LPCWSTR path)
{
  BOOL bIsURL = FALSE;

  if( wcsstr(path, L"http") )
  {
    bIsURL = TRUE;
  }

  return bIsURL;
}

BOOL
GetFile(LPCWSTR path, HANDLE* phUNC, IWinHttpRequest** ppWHR, DWORD mode, BOOL* bReadOnly)
{
  DEBUG_ENTER((
    DBG_UTILS,
    rt_bool,
    "GetFile",
    "path=%S; phUNC=%#x; ppWHR=%#x; mode=%#x; bReadOnly=%#x",
    path,
    phUNC,
    ppWHR,
    mode,
    bReadOnly
    ));

  BOOL bSuccess = FALSE;

  if( path )
  {
    if( phUNC )
    {
      *phUNC = __OpenFile(path, mode, bReadOnly);

      if( *phUNC != INVALID_HANDLE_VALUE )
      {
        bSuccess = TRUE;
      }
    }
    else if( ppWHR )
    {
      *ppWHR = __OpenUrl(path);

      if( *ppWHR )
      {
        *bReadOnly = TRUE;
        bSuccess   = TRUE;
      }
    }
  }

  DEBUG_LEAVE(bSuccess);
  return bSuccess;
}

HANDLE
__OpenFile(LPCWSTR path, DWORD mode, BOOL* bReadOnly)
{
  HANDLE hFile = INVALID_HANDLE_VALUE;
  DWORD  flags = GENERIC_READ | GENERIC_WRITE;

retry:

  hFile = CreateFile(
            path,
            flags,
            FILE_SHARE_READ,
            NULL,
            mode,
            FILE_ATTRIBUTE_NORMAL,
            NULL
            );

  if( hFile == INVALID_HANDLE_VALUE )
  {
    if( GetLastError() == ERROR_ACCESS_DENIED )
    {
      if( flags == (GENERIC_READ | GENERIC_WRITE) )
      {
        DEBUG_TRACE(UTILS, ("read/write open attempt failed, retrying for read-only access"));

        flags      = GENERIC_READ;
        *bReadOnly = TRUE;
        goto retry;
      }
    }

    DEBUG_TRACE(UTILS, ("error opening %S: %s", path, MapErrorToString(GetLastError())));
  }
  else
  {
    DEBUG_TRACE(UTILS, ("file opened"));
  }

  return hFile;
}

IWinHttpRequest*
__OpenUrl(LPCWSTR url)
{
  HRESULT          hr         = S_OK;
  IWinHttpRequest* pWHR       = NULL;
  BSTR             bstrVerb   = SysAllocString(L"GET");
  BSTR             bstrUrl    = SysAllocString(url);
  LONG             status     = 0L;
  CLSID            clsid;

  NEWVARIANT(var);
  NEWVARIANT(async);

  V_VT(&async)   = VT_BOOL;
  V_BOOL(&async) = FALSE;

  hr = CLSIDFromProgID(L"WinHttp.WinHttpRequest.5", &clsid);

    if( FAILED(hr) )
    {
      DEBUG_TRACE(UTILS, ("failed to get WinHttpRequest CLSID from registry (%s)", MapHResultToString(hr)));
      goto quit;
    }

  hr = CoCreateInstance(clsid, NULL, CLSCTX_INPROC_SERVER, IID_IWinHttpRequest, (void**) &pWHR);

    if( FAILED(hr) )
    {
      DEBUG_TRACE(UTILS, ("CoCreateInstance for IID_IWinHttpRequest failed (%s)", MapHResultToString(hr)));
      goto quit;
    }

  hr = pWHR->SetProxy(HTTPREQUEST_PROXYSETTING_PRECONFIG, var, var);

    if( FAILED(hr) )
    {
      DEBUG_TRACE(UTILS, ("failed to set proxy (%s)", MapHResultToString(hr)));
      goto quit;
    }

  hr = pWHR->Open(bstrVerb, bstrUrl, async);

    if( FAILED(hr) )
    {
      DEBUG_TRACE(UTILS, ("failed to open %S (%s)", bstrUrl, MapHResultToString(hr)));
      goto quit;
    }

  hr = pWHR->Send(var);

    if( FAILED(hr) )
    {
      DEBUG_TRACE(UTILS, ("failed to send request (%s)", MapHResultToString(hr)));
      goto quit;
    }

  hr = pWHR->get_Status(&status);

    if( SUCCEEDED(hr) )
    {
      DEBUG_TRACE(UTILS, ("response status %d", status));
      hr = (status == 200) ? S_OK : E_FAIL;
    }
    else
    {
      DEBUG_TRACE(UTILS, ("failed to get response status (%s)", MapHResultToString(hr)));
    }

quit:

  if( FAILED(hr) )
  {
    SAFERELEASE(pWHR);
  }

  SAFEDELETEBSTR(bstrVerb);
  SAFEDELETEBSTR(bstrUrl);
  VariantClear(&var);
  VariantClear(&async);

  return pWHR;
}

//-----------------------------------------------------------------------------
// general utility functions
//-----------------------------------------------------------------------------
HRESULT
GetTypeInfoFromName(LPCOLESTR name, ITypeLib* ptl, ITypeInfo** ppti)
{
  DEBUG_ENTER((
    DBG_UTILS,
    rt_hresult,
    "GetTypeInfoFromName",
    "name=%.16S; ptl=%#x; ppti=%#x",
    name,
    ptl,
    ppti
    ));

  HRESULT  hr     = S_OK;
  BOOL     bFound = FALSE;
  USHORT   cf     = 1L;
  ULONG    hash   = 0L;
  LONG     id     = 0L;
  LPOLESTR pstr   = NULL;

  if( !name || ! ptl )
  {
    hr = E_INVALIDARG;
    goto quit;
  }

  if( !ppti )
  {
    hr = E_POINTER;
    goto quit;
  }

  *ppti = NULL;
  pstr  = __wstrdup(name);

    ptl->IsName(pstr, 0L, &bFound);

      if( !bFound )
      {
        hr = TYPE_E_ELEMENTNOTFOUND;
        goto quit;
      }

    hash = LHashValOfNameSys(
             SYS_WIN32,
             MAKELCID(MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL), SORT_DEFAULT),
             pstr
             );

    hr = ptl->FindName(pstr, hash, ppti, &id, &cf);

    DEBUG_TRACE(UTILS, ("find name: pti=%#x; cf=%d", *ppti, cf));

quit:

  SAFEDELETEBUF(pstr);

  DEBUG_LEAVE(hr);
  return hr;
}

BOOL
GetJScriptCLSID(LPCLSID pclsid)
{
  DEBUG_ENTER((
    DBG_UTILS,
    rt_bool,
    "GetJScriptCLSID",
    "pclsid=%#x",
    pclsid
    ));

  BOOL   ret = FALSE;
  HKEY   hk  = NULL;
  LPBYTE buf = NULL;
  DWORD  cb  = 0L;
  DWORD  rt  = REG_SZ;

  if( RegOpenKey(HKEY_CLASSES_ROOT, L"JScript\\CLSID", &hk) == ERROR_SUCCESS )
  {
    if( RegQueryValueEx(hk, L"", NULL, &rt, NULL, &cb) == ERROR_SUCCESS )
    {
      buf = new BYTE[cb];

        RegQueryValueEx(hk, L"", NULL, &rt, buf, &cb);
        CLSIDFromString((LPOLESTR) buf, pclsid);
        ret = TRUE;

      SAFEDELETEBUF(buf);
    }
  }

  DEBUG_LEAVE(ret);
  return ret;
}

void
ParseSocketInfo(PIOCTX pi)
{
  PSOCKADDR_IN pLocal    = NULL;
  PSOCKADDR_IN pRemote   = NULL;
  int          cbLocal   = 0;
  int          cbRemote  = 0;
  char*        buf       = NULL;
  int          len       = 0;
  int          error     = 0;

  GetAcceptExSockaddrs(
    pi->sockbuf, 0,
    SOCKADDRBUFSIZE,
    SOCKADDRBUFSIZE,
    (PSOCKADDR*) &pLocal,  &cbLocal,
    (PSOCKADDR*) &pRemote, &cbRemote
    );

  pi->local  = new HOSTINFO;
  pi->remote = new HOSTINFO;

  GetHostname(pLocal->sin_addr, &pi->local->name);
  pi->local->addr = __strdup(inet_ntoa(pLocal->sin_addr));
  pi->local->port = ntohs(pLocal->sin_port);

  GetHostname(pRemote->sin_addr, &pi->remote->name);
  pi->remote->addr = __strdup(inet_ntoa(pRemote->sin_addr));
  pi->remote->port = ntohs(pRemote->sin_port);

  if( !pi->remote->name )
  {
    pi->remote->name = __strdup(pi->remote->addr);
  }

  len = strlen(pi->remote->name)+7; // ":" plus 5 port digits and a null
  buf = new char[len]; 

  strncpy(buf, pi->remote->name, len);
  strncat(buf, ":", sizeof(char));
  _itoa(pi->remote->port, (buf+strlen(buf)), 10);

  pi->clientid = __ansitowide(buf);

  SAFEDELETEBUF(buf);
}

void
GetHostname(struct in_addr ip, LPSTR* ppsz)
{
  HOSTENT* ph = NULL;

  ph = gethostbyaddr(
         (char*) &ip,
         sizeof(struct in_addr),
         AF_INET
         );

  if( ph )
  {
    *ppsz = __strdup(ph->h_name);
  }
  else
  {
    *ppsz = NULL;
  }
}

DISPID
GetDispidFromName(PDISPIDTABLEENTRY pdt, DWORD cEntries, LPWSTR name)
{
  DWORD  n      = 0L;
  DWORD  hash   = GetHash(name);
  DISPID dispid = DISPID_UNKNOWN;

  while( n < cEntries )
  {
    if( pdt[n].hash != hash )
    {
      ++n;
    }
    else
    {
      dispid = pdt[n].dispid;
      break;
    }
  }

  DEBUG_TRACE(DISPATCH, ("hash %#x is %s", hash, MapDispidToString(dispid)));
  return dispid;
}

void
AddRichErrorInfo(EXCEPINFO* pei, LPWSTR source, LPWSTR description, HRESULT error)
{
  if( pei )
  {
    pei->bstrSource      = __widetobstr((source ? source : L"unknown source"));
    pei->bstrDescription = __widetobstr((description ? description : L"no description"));
    pei->scode           = error;
  }
}

DWORD
GetHash(LPWSTR name)
{
  DWORD hash   = 0L;
  DWORD n      = 0L;
  DWORD len    = 0L;
  LPSTR string = NULL;

  string = __widetoansi(name);

  if( string )
  {
    _strlwr(string);

    for(n=0, len=strlen(string); n<=len; n++)
    {
      hash += __toascii(string[len-n]) * ((10<<n)^n);
    }

    DEBUG_TRACE(DISPATCH, ("name=%s; hash=%#x", string, hash));
  }

  SAFEDELETEBUF(string);
  return hash;
}

DWORD
GetHash(LPSTR name)
{
  DWORD hash   = 0L;
  DWORD n      = 0L;
  DWORD len    = 0L;
  LPSTR string = NULL;

  string = __strdup(name);

  if( string )
  {
    _strlwr(string);

    for(n=0, len=strlen(string); n<=len; n++)
    {
      hash += __toascii(string[len-n]) * ((10<<n)^n);
    }

    DEBUG_TRACE(DISPATCH, ("name=%s; hash=%#x", string, hash));
  }

  SAFEDELETEBUF(string);
  return hash;
}

HRESULT
ProcessVariant(VARIANT* pvar, LPBYTE* ppbuf, LPDWORD pcbuf, LPDWORD pbytes)
{
  DEBUG_ENTER((
    DBG_UTILS,
    rt_hresult,
    "ProcessVariant",
    "pvar=%#x; ppbuf=%#x; pcbuf=%#x; pbytes=%#x",
    pvar,
    ppbuf,
    pcbuf,
    pbytes
    ));
  
  HRESULT hr      = S_OK;
  LPBYTE  pbyte   = NULL;
  DWORD   len     = NULL;
  BOOL    bAlloc  = FALSE;
  BOOL    bBypass = FALSE;

  if( !ppbuf || !pcbuf )
  {
    hr = E_INVALIDARG;
    goto quit;
  }

  //
  // if the caller wants us to allocate storage, we don't need
  // the pbytes parameter. otherwise, we do in case the caller
  // needs to resize their buffer.
  //
  if( ((*ppbuf) && *pcbuf != 0) && !pbytes )
  {
    hr = E_INVALIDARG;
    goto quit;
  }

  if( !(*ppbuf) && *pcbuf == 0 )
  {
    DEBUG_TRACE(UTILS, ("will allocate storage for variant data"));
    bAlloc = TRUE;
  }

  DEBUG_TRACE(
    RUNTIME,
    ("variant type is %s", MapVariantTypeToString(pvar))
    );

    switch( V_VT(pvar) )
    {
      case VT_BSTR :
        {
          pbyte = (LPBYTE) __widetoansi(V_BSTR(pvar));
          len   = strlen((LPSTR) pbyte);
        }
        break;

      case VT_ARRAY | VT_UI1 :
        {
          SAFEARRAY* psa  = V_ARRAY(pvar);
          LPBYTE     ptmp = NULL;

          hr = SafeArrayAccessData(psa, (void**) &ptmp);

          if( SUCCEEDED(hr) )
          {
            SafeArrayGetUBound(psa, 1, (long*) &len);

              pbyte = new BYTE[len];
              memcpy(pbyte, ptmp, len);

            SafeArrayUnaccessData(psa);
          }
        }
        break;

      case VT_UNKNOWN :
        {
          hr      = ProcessObject(pvar->punkVal, ppbuf, pcbuf, pbytes);
          bBypass = TRUE;
        }
        break;

      case VT_DISPATCH :
        {
          IUnknown* punk = NULL;
          
            if( SUCCEEDED(pvar->pdispVal->QueryInterface(IID_IUnknown, (void**) &punk)) )
            {
              hr      = ProcessObject(punk, ppbuf, pcbuf, pbytes);
              bBypass = TRUE;
            }
            
          SAFERELEASE(punk);
        }
        break;

      default :
        {
          hr = E_INVALIDARG;
        }
    }

  //
  // bBypass is set when we make a call into ProcessObject(), which
  // always calls back into us to handle the unpacked non-object-type
  // variant. in that nested call the buffers & length variables are
  // set, so we bypass those operations when the outer call unwinds.
  //
  if( SUCCEEDED(hr) && !bBypass )
  {
    if( bAlloc )
    {
      *ppbuf  = pbyte;
      *pcbuf  = len;
    }
    else
    {
      if( *pcbuf >= len )
      {
        memcpy(*ppbuf, pbyte, len);
        *pbytes = len;
      }
      else
      {
        hr     = E_OUTOFMEMORY;
        *pcbuf = len;
      }
      
      SAFEDELETEBUF(pbyte);
    }
  }

quit:

  DEBUG_LEAVE(hr);
  return hr;
}

//
// WARNING: do not modify these values. use disphash.exe to generate
//          new values.
//
#define CLASS_HASH_URL     0x0000417f
#define CLASS_HASH_ENTITY  0x000213d4
#define CLASS_HASH_HEADERS 0x000401cd

HRESULT
ProcessObject(IUnknown* punk, LPBYTE* ppbuf, LPDWORD pcbuf, LPDWORD pbytes)
{
  DEBUG_ENTER((
    DBG_UTILS,
    rt_hresult,
    "ProcessObject",
    "punk=%#x",
    punk
    ));
  
  HRESULT            hr    = E_FAIL;
  IProvideClassInfo* pci   = NULL;
  IW3SpoofFile*      pfile = NULL;

  // first try to use class information to determine what was
  // passed in. all om objects support this method.

  //
  // BUGBUG: potential failure case is when objects are "torn off" from
  //         their parents (e.g. persisted through the runtime property bag).
  //         in that scenario the objects lose site information and therefore
  //         aren't able to look up their typeinfo. fix is to cache typeinfo
  //         during object creation.
  //
  //         workitem filed IEv6 #21277
  //
  hr = punk->QueryInterface(IID_IProvideClassInfo, (void**) &pci);

    if( SUCCEEDED(hr) )
    {
      ITypeInfo* pti      = NULL;
      IEntity*   pentity  = NULL;
      IHeaders*  pheaders = NULL;
      IUrl*      purl     = NULL;
      BSTR       name     = NULL;
      NEWVARIANT(tmp);
      
      if( SUCCEEDED(pci->GetClassInfo(&pti)) )
      {
        pti->GetDocumentation(MEMBERID_NIL, &name, NULL, NULL, NULL);

        DEBUG_TRACE(SOCKET, ("processing an %S object", name));

          switch( GetHash(name) )
          {
            case CLASS_HASH_URL :
              {
                if( SUCCEEDED(punk->QueryInterface(IID_IUrl, (void**) &purl)) )
                {
                  if( SUCCEEDED(purl->Get(&V_BSTR(&tmp))) )
                  {
                    V_VT(&tmp) = VT_BSTR;
                    hr         = ProcessVariant(&tmp, ppbuf, pcbuf, pbytes);
                  }
                }
              }
              break;

            case CLASS_HASH_HEADERS :
              {
                if( SUCCEEDED(punk->QueryInterface(IID_IHeaders, (void**) &pheaders)) )
                {
                  if( SUCCEEDED(pheaders->Get(&V_BSTR(&tmp))) )
                  {
                    V_VT(&tmp) = VT_BSTR;
                    hr         = ProcessVariant(&tmp, ppbuf, pcbuf, pbytes);
                  }
                }
              }
              break;

            case CLASS_HASH_ENTITY :
              {
                if( SUCCEEDED(punk->QueryInterface(IID_IEntity, (void**) &pentity)) )
                {
                  if( SUCCEEDED(pentity->Get(&tmp)) )
                  {
                    hr = ProcessVariant(&tmp, ppbuf, pcbuf, pbytes);
                  }
                }
              }
              break;
          }

        SAFERELEASE(pti);
        SAFERELEASE(purl);
        SAFERELEASE(pentity);
        SAFERELEASE(pheaders);
        SAFEDELETEBSTR(name);
        VariantClear(&tmp);
      }

      SAFERELEASE(pci);

      if( SUCCEEDED(hr) )
      {
        goto quit;
      }
    }

  // try IW3SpoofFile...
  hr = punk->QueryInterface(IID_IW3SpoofFile, (void**) &pfile);

    if( SUCCEEDED(hr) )
    {
      NEWVARIANT(tmp);

      DEBUG_TRACE(SOCKET, ("processing an IW3SpoofFile object"));

      hr = pfile->ReadAll(&tmp);

        if( SUCCEEDED(hr) )
        {
          hr = ProcessVariant(&tmp, ppbuf, pcbuf, pbytes);
        }
      
      SAFERELEASE(pfile);
      VariantClear(&tmp);
    }

quit:

  DEBUG_LEAVE(hr);
  return hr;
}

HRESULT
ValidateDispatchArgs(REFIID riid, DISPPARAMS* pdp, VARIANT* pvr, UINT* pae)
{
  HRESULT hr = S_OK;

    if( !IsEqualIID(riid, IID_NULL) )
    {
      hr = DISP_E_UNKNOWNINTERFACE;
      goto quit;
    }

    if( !pdp )
    {
      hr = E_INVALIDARG;
      goto quit;
    }

    if( pae )
    {
      *pae = 0;
    }

    if( pvr )
    {
      VariantInit(pvr);
    }

quit:

  return hr;
}

HRESULT
ValidateInvokeFlags(WORD flags, WORD accesstype, BOOL bNotMethod)
{
  HRESULT hr = S_OK;

    if( (flags & ~(DISPATCH_METHOD | DISPATCH_PROPERTYGET | DISPATCH_PROPERTYPUT)) )
    {
      hr = E_INVALIDARG;
    }
    else
    {
      if( bNotMethod )
      {
        if( flags & DISPATCH_METHOD )
        {
          hr = E_NOINTERFACE;
        }
        else
        {
          if( (flags & DISPATCH_PROPERTYPUT) && !(accesstype & DISPATCH_PROPERTYPUT) )
          {
            hr = E_ACCESSDENIED;
          }
          else
          {
            if( !(flags & accesstype) )
            {
              hr = E_FAIL;
            }
          }
        }
      }
      else
      {
        if( flags & ~(DISPATCH_METHOD | DISPATCH_PROPERTYGET) )
        {
          hr = E_NOINTERFACE;
        }
      }
    }

  return hr;
}

HRESULT
ValidateArgCount(DISPPARAMS* pdp, DWORD needed, BOOL bHasOptionalArgs, DWORD optional)
{
  HRESULT hr = S_OK;

    if( bHasOptionalArgs )
    {
      if( (pdp->cArgs > needed+optional) || (pdp->cArgs < needed) )
      {
        hr = DISP_E_BADPARAMCOUNT;
      }
    }
    else
    {
      if( (!needed && pdp->cArgs) || (needed < pdp->cArgs) )
      {
        hr = DISP_E_BADPARAMCOUNT;
      }
      else
      {
        hr = (pdp->cArgs == needed) ? S_OK : DISP_E_PARAMNOTOPTIONAL;
      }
    }

  return hr;
}

HRESULT
HandleDispatchError(LPWSTR id, EXCEPINFO* pei, HRESULT hr)
{
  LPWSTR msg = NULL;

  switch( hr )
  {
    case E_POINTER      : msg = L"a return pointer parameter was missing";                  break;
    case E_ACCESSDENIED : msg = L"attempt to modify object failed because it is read-only"; break;
    case E_FAIL         : msg = L"an unhandled error occurred";                             break;
    case E_INVALIDARG   : msg = L"an argument passed to a property or method was invalid";  break;
    case E_NOINTERFACE  : msg = L"a property or method was accessed incorrectly";           break;
    default             : return hr;
  }

  AddRichErrorInfo(pei, id, msg, hr);

  return DISP_E_EXCEPTION;
}

//-----------------------------------------------------------------------------
// string & type manipulation
//-----------------------------------------------------------------------------
char*
__strdup(const char* src)
{
  int   n   = 0;
  char* dup = NULL;

  if( src )
  {
    n   = strlen(src)+1;
    dup = new char[n];
    strncpy(dup, src, n);
  }

  return dup;
}

char*
__strndup(const char* src, int len)
{
  char* dup = NULL;

  if( src )
  {
    dup      = new char[len+1];
    dup[len] = '\0';
    strncpy(dup, src, len);
  }

  return dup;
}

WCHAR*
__wstrdup(const WCHAR* src)
{
  int    n   = 0;
  WCHAR* dup = NULL;

  if( src )
  {
    n   = wcslen(src)+1;
    dup = new WCHAR[n];
    wcsncpy(dup, src, n);
  }

  return dup;
}

WCHAR*
__wstrndup(const WCHAR* src, int len)
{
  WCHAR* dup = NULL;

  if( src )
  {
    dup      = new WCHAR[len+1];
    dup[len] = L'\0';
    wcsncpy(dup, src, len);
  }

  return dup;
}

WCHAR*
__ansitowide(const char* psz)
{
  WCHAR* wide = NULL;
  int    len  = 0L;

  if( psz )
  {
    len  = strlen(psz);

    if( len )
    {
      ++len;
      wide = new WCHAR[len];

      MultiByteToWideChar(
        CP_ACP,
        0,
        psz,
        len,
        wide,
        len
        );
    }
  }

  return wide;
}

CHAR*
__widetoansi(const WCHAR* pwsz)
{
  CHAR* ansi = NULL;
  int   len  = 0L;
  BOOL  def  = FALSE;

  if( pwsz )
  {
    len  = wcslen(pwsz);

    if( len )
    {
      ++len;
      ansi = new CHAR[len];

      WideCharToMultiByte(
        CP_ACP,
        0,
        pwsz,
        len,
        ansi,
        len,
        "?",
        &def
        );
    }
  }

  return ansi;
}

BSTR
__ansitobstr(LPCSTR src)
{
  BSTR   ret = NULL;
  LPWSTR wsz = NULL;

  if( src )
  {
    wsz = __ansitowide(src);
    ret = SysAllocString(wsz);
    SAFEDELETEBUF(wsz);
  }

  return ret;
}

BSTR
__widetobstr(LPCWSTR wsrc)
{
  return (wsrc ? SysAllocString(wsrc) : NULL);
}

BOOL
__isempty(VARIANT var)
{
  BOOL isempty = FALSE;

  if(
      ((V_VT(&var) == VT_EMPTY) || (V_VT(&var) == VT_NULL) || (V_VT(&var) == VT_ERROR)) ||
      ((V_VT(&var) == VT_BSTR) && (SysStringLen(V_BSTR(&var)) == 0))
    )
  {
    isempty = TRUE;
  }

  return isempty;
}

// private
char hex2char(char* hex)
{
  register char digit;
  
    digit  = (hex[0] >= 'A' ? ((hex[0] & 0xdf) - 'A')+10 : (hex[0] - '0'));
    digit *= 16;
    digit += (hex[1] >= 'A' ? ((hex[1] & 0xdf) - 'A')+10 : (hex[1] - '0'));

  return(digit);
}

char*
__unescape(char* str)
{
  register int x;
  register int y;
  char*        str2;

  str2 = __strdup(str);

  if( str2 )
  {    
    for(x=0, y=0; str2[y]; ++x, ++y)
    {
      if((str2[x] = str2[y]) == '%')
      {
        str2[x] = hex2char(&str2[y+1]);
        y += 2;
      }
    }
    
    str2[x] = '\0';
  }

  return str2;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\tools\stressexe\authsecureproxystress\authsecureproxystress.cpp ===
//////////////////////////////////////////////////////////////////////
// File:  AuthSecureProxyStress.cpp
//
// Copyright (c) 2001 Microsoft Corporation.  All Rights Reserved.
//
// Purpose:
//		This file contains your implementation of the stress test function
//		WinHttp_StressTest() that is called in stressMain.cpp.
//
//		Steps:
//			- Set your test case name in g_szStressTestName.
//			- Add your test code to WinHttp_StressTest(). 
//
// History:
//	04/02/01	adamb	Created
//
//////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////
// Includes
//////////////////////////////////////////////////////////////////////
#include "stressMain.h"

//////////////////////////////////////////////////////////////////////
// Globals and constants
//////////////////////////////////////////////////////////////////////

// ************************************
// ************************************
// ** Fill in your test case name below
// ** 
LPSTR	g_szStressTestName = "AuthSecureProxy Stressor";

//yup, they're all global
BOOL bPost = FALSE;
CHAR HttpType[10] = "HTTP";
BOOL bViaProxy = FALSE;
CHAR CredType[5] = "SC";

BOOL RunStress(BOOL bPost,CHAR HttpType[],BOOL bViaProxy,CHAR CredType[],int Scheme);

////////////////////////////////////////////////////////////
// Function:  WinHttp_StressTest()
//
// Purpose:
//	goes through all the ways of sending a request and 
//  picks one of those, then uses it in a request
//
//  yes, it does check for the signal before starting
//  runstress (one test per call).
////////////////////////////////////////////////////////////

BOOL
WinHttp_StressTest()
{
	for(int i=0; i<2; i++)
	{
		if(i==0)
			bPost = FALSE;
		else
			bPost = TRUE;
		for(int j=0; j<2; j++)
		{
			if(j==0)
				strcpy(HttpType, "HTTPS");
			else
				strcpy(HttpType, "HTTP");
			for(int k=0; k<2; k++)
			{
				if(k==0)
					bViaProxy = FALSE;
				else
					bViaProxy = TRUE;
				for(int l=0; l<2; l++)
				{
					if(l==0)
						strcpy(CredType, "SC");
					else
						strcpy(CredType, "SO");
					for(int m=0; m<4; m++)
					{
						if(!IsTimeToExitStress())
							RunStress(bPost,HttpType,bViaProxy,CredType,m);
						else
							return FALSE;
					}
				}
			}
		}
	}

	return TRUE;
}

////////////////////////////////////////////////////////////
// Function:  RunStress()
//
// Purpose:
//  this actually runs the tests given certain inputs.
//  this is called from WinHttp_StressTest.
//
////////////////////////////////////////////////////////////
	
BOOL RunStress(BOOL bPost,CHAR HttpType[],BOOL bViaProxy,CHAR CredType[],int Scheme)
{
	BOOL bContinueStress = TRUE;

	HINTERNET hOpen = NULL;
	HINTERNET hConnect = NULL;
	HINTERNET hRequest = NULL;

	DWORD	Count = 0, dwAccessType = WINHTTP_ACCESS_TYPE_NO_PROXY,
			dwAuthScheme=0,dwAuthTargets=0,dwOtherScheme=0,dwOpenRequestFlags=0,
			dwStatus=0, cbStatus=0;

	LPWSTR	wszHost=NULL, wszUri=NULL, wszUserName=NULL, wszPassword=NULL,
			wszProxy = NULL, wszProxyUserName = NULL, wszProxyPassword = NULL,
			wszVerb=L"GET";

	INTERNET_PORT	nPort = INTERNET_DEFAULT_HTTP_PORT;

	LPSTR	pPostData = NULL;
	DWORD	dwPostDataLength = 0;

	if(bPost)
	{
		wszVerb=L"POST";
		pPostData = "If you smelllllllll what THE ROCK is cooking??? <people's eyebrow>";
		dwPostDataLength = strlen(pPostData);
	}

	if(strcmp(HttpType, "HTTPS"))
	{
		nPort = INTERNET_DEFAULT_HTTPS_PORT;
		dwOpenRequestFlags = WINHTTP_FLAG_SECURE;
	}

	//if going via proxy, then ntlm/nego aren't valid, unless going over https
	if(bViaProxy && ((Scheme == 0 || Scheme == 1) || strcmp(HttpType, "HTTPS")) )
	{
		wszProxy = L"xfluke";
		wszProxyUserName = L"xfluke\\proxyuser";
		wszProxyPassword = L"password";
		dwAccessType = WINHTTP_ACCESS_TYPE_NAMED_PROXY;
	}

	switch(Scheme)
	{
	case 0: //basic
		wszHost = L"wiredbvt";
		wszUri = L"/api/Auth/Basic/echo-post-data.asp";
		wszUserName = L"ApiAuth";
		wszPassword = L"test1234!";
		break;
	case 1: //digest
		wszHost = L"kerby2";
		wszUri = L"/digest/echo-post-data.asp";
		wszUserName = L"authdigest";
		wszPassword = L"digest";
		break;
	case 2: //negotiate
		wszHost = L"kerby2";
		wszUri = L"/ie/negotiate/echo-post-data.asp";
		wszUserName = L"kerby2\\authnego";
		wszPassword = L"nego";
		break;
	case 3: //ntlm
		wszHost = L"clapton";
		wszUri = L"/test/ntlm/echo-post-data.asp";
		wszUserName = L"clapton\\ntlmtest";
		wszPassword = L"ntlm";
		break;
	}

	LogText("Post: %u, Proxy: %u, %s, %s, Scheme: %u", bPost, bViaProxy, HttpType, CredType, Scheme);

	// ***********************************
	// ** WinHttpOpen
	// **

	hOpen = WinHttpOpen
	(
		L"Stress Test",
		dwAccessType,
		wszProxy,
		NULL,
		0
	);

	if(hOpen == NULL)
	{
		LogText("WinHttpOpen failed with error %u.", GetLastError());
		goto Exit;
	}

	// ***********************************
	// ** WinHttpConnect
	// **
	
	hConnect = WinHttpConnect
	(
		hOpen,
		wszHost,
		nPort,
		0
	);

	if(hConnect==NULL)
	{
		LogText("WinHttpConnect failed with error %u.", GetLastError());
		goto Exit;
	}

	hRequest = WinHttpOpenRequest
	(
		hConnect,
		wszVerb,
		wszUri,
		NULL,
		NULL,
		NULL,
		dwOpenRequestFlags
	);

	if(hRequest==NULL)
	{
		LogText("WinHttpOpenRequest failed with error %u.", GetLastError());
		goto Exit;
	}


Resend:

	if( Count++>3) // making sure that we don't have infinite looping
	{
		bContinueStress=FALSE;
		goto Exit;
	}

	// Send request.
	if(!WinHttpSendRequest
	(
		hRequest,					// request handle
		NULL,						// header string
		0,							// header length
		(PVOID) pPostData,			// post data
		dwPostDataLength,			// post data length
		dwPostDataLength,			// total post length
		0							// flags
	))
	{
		LogText("WinHttpSendRequest failed with error %u.", GetLastError());
		goto Exit;
	}

	if (!WinHttpReceiveResponse(hRequest, NULL))
	{
		LogText("WinHttpReceiveResponse failed with error %u.", GetLastError());
		goto Exit;
	}

	cbStatus = sizeof(dwStatus);
	WinHttpQueryHeaders
	(
		hRequest,
		WINHTTP_QUERY_FLAG_NUMBER | WINHTTP_QUERY_STATUS_CODE,
		NULL,
		&dwStatus,
		&cbStatus,
		NULL
	);

	switch( dwStatus )
	{
	case 200:
		break;
	case 401:
		if(strcmp(CredType, "SC"))
		{
			if(!WinHttpQueryAuthSchemes
			(
				hRequest,
				&dwOtherScheme,
				&dwAuthScheme,
				&dwAuthTargets
			))
			{
				LogText("WinHttpQueryAuthSchemes failed with error %u.", GetLastError());
				goto Exit;
			}

			if(!WinHttpSetCredentials
			(
				hRequest,
				dwAuthTargets,
				dwAuthScheme,
				wszUserName,
				wszPassword,
				(PVOID) NULL
			))
			{
				LogText("WinHttpSetCredentials failed with error %u.", GetLastError());
				goto Exit;
			}
		}
		else
		{
			if(!WinHttpSetOption
			(
				hRequest,
				WINHTTP_OPTION_USERNAME,
				(PVOID) wszUserName,
				wcslen(wszUserName)
			))
			{
				LogText("WinHttpSetOption failed with error %u.", GetLastError());
				goto Exit;
			}

			if(!WinHttpSetOption
			(
				hRequest,
				WINHTTP_OPTION_PASSWORD,
				(PVOID) wszPassword,
				wcslen(wszPassword)
			))
			{
				LogText("WinHttpSetOption failed with error %u.", GetLastError());
				goto Exit;
			}
		}
		goto Resend;
	break;

	case 407:
		if(strcmp(CredType, "SC"))
		{
			if(!WinHttpQueryAuthSchemes
			(
				hRequest,
				&dwOtherScheme,
				&dwAuthScheme,
				&dwAuthTargets
			))
			{
				LogText("WinHttpQueryAuthSchemes failed with error %u.", GetLastError());
				goto Exit;
			}

			if(!WinHttpSetCredentials
			(
				hRequest,
				dwAuthTargets,
				dwAuthScheme,
				wszProxyUserName,
				wszProxyPassword,
				(PVOID) NULL
			))
			{
				LogText("WinHttpSetCredentials failed with error %u.", GetLastError());
				goto Exit;
			}
		}
		else
		{
			if(!WinHttpSetOption
			(
				hRequest,
				WINHTTP_OPTION_PROXY_USERNAME,
				(PVOID) wszProxyUserName,
				wcslen(wszProxyUserName)
			))
			{
				LogText("WinHttpSetOption failed with error %u.", GetLastError());
				goto Exit;
			}

			if(!WinHttpSetOption
			(
				hRequest,
				WINHTTP_OPTION_PROXY_PASSWORD,
				(PVOID) wszProxyPassword,
				wcslen(wszProxyPassword)
			))
			{
				LogText("WinHttpSetOption failed with error %u.", GetLastError());
				goto Exit;
			}
		}

		goto Resend;
	break;

	} //end of switch (status code)

Exit:

	if( hRequest != NULL )
	{
		WinHttpCloseHandle(hRequest);
		hRequest = NULL;
	}

	if( hConnect != NULL )
	{
		WinHttpCloseHandle(hConnect);
		hConnect = NULL;
	}

	if( hOpen != NULL )
	{
		WinHttpCloseHandle(hOpen);
		hOpen = NULL;
	}


	return bContinueStress;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\tools\w3spoof\inc\common.h ===
/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Copyright (c) 1999  Microsoft Corporation

Module Name:

    common.h

Abstract:

    Common includes used in the project. This file is built into a PCH.
    
Author:

    Paul M Midgen (pmidge) 15-May-2000


Revision History:

    15-May-2000 pmidge
        Created

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/

#ifndef _COMMON_H_
#define _COMMON_H_

#define _WIN32_WINNT 0x0500
#define _UNICODE
#define UNICODE

//
// OS includes
//

#if defined(__cplusplus)
extern "C" {
#endif

#include <windows.h>
#include <shellapi.h>
#include <advpub.h>
#include <oleauto.h>
#include <objbase.h>
#include <ocidl.h>
#include <olectl.h>
#include <activscp.h>
#include <activdbg.h>
#include <winsock2.h>
#include <mswsock.h>
#include <winhttp.h>
#include <httprequest.h>
#include <commctrl.h>

#if defined(__cplusplus)
}
#endif


//
// w3spoof includes
//

#pragma warning( disable : 4100 ) // unreferenced formal parameter

#include <resources.h>
#include <mem.h>
#include <utils.h>
#include <debug.h>
#include <hashtable.h>
#include <linklist.h>
#include <stores.h>
#include <dispids.h>
#include <om_ifaces.h> // generated
#include <w3srt.h>
#include <int_ifaces.h>
#include <registry.h>
#include <om.h>
#include <w3sobj.h>

#endif /* _COMMON_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\tools\w3spoof\inc\pch.cxx ===
/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Copyright (c) 1999  Microsoft Corporation

Module Name:

    pch.cxx

Abstract:

    Need this so the precompiled header will, umm, compile.
    
Author:

    Paul M Midgen (pmidge) 24-July-2000


Revision History:

    24-July-2000 pmidge
        Created

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/

#include "common.h"

void foobar(void);

void foobar(void)
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\tools\w3spoof\inc\debug.h ===
/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Copyright (c) 2000  Microsoft Corporation

Module Name:

    debug.h

Abstract:

    Debug logging routines for W3spoof project.
    
Author:

    Paul M Midgen (pmidge) 15-May-2000


Revision History:

    15-May-2000 pmidge
        Created

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/

#ifndef __DEBUG_H__
#define __DEBUG_H__

#include "common.h"

//
// always build this stuff.
//
#define CASE_OF(constant) case constant: return # constant
#define CASE_OF_MUTATE(val, name) case val: return # name
#define CASE_IID(riid, iid) if(IsEqualIID(riid, iid)) return # iid

LPSTR MapDispidToString(DISPID dispid);
LPSTR MapScriptDispidToString(SCRIPTDISPID sd);
LPSTR MapIOTYPEToString(IOTYPE iot);
LPSTR MapErrorToString(int error);
LPSTR MapTPOToString(DWORD option);
LPSTR MapHResultToString(HRESULT hr);
LPSTR MapStateToString(STATE st);
LPSTR MapStateToString(SERVERSTATE st);
LPSTR MapStateToString(SCRIPTSTATE st);
LPSTR MapIIDToString(REFIID riid);
LPSTR MapInvokeFlagsToString(WORD flags);
LPSTR MapVariantTypeToString(VARIANT* pvar);

int DebugDataDumpFormat(LPSTR buffer, LPBYTE data, DWORD len);

#ifdef _DEBUG

//
// manifests
//

#if defined(__DBG_TO_CONSOLE__)
#define OUTPUT_FLAGS DBG_TO_DEBUGGER
#else
#define OUTPUT_FLAGS DBG_TO_FILE
#endif

#if defined(__FULL_DEBUG__)
#define DEBUG_DEFAULT_FLAGS ( \
                             DBG_MEM          \
                           | DBG_REFCOUNT     \
                           | DBG_W3SOBJ       \
                           | DBG_FACTORY      \
                           | DBG_W3SUI        \
                           | DBG_APP          \
                           | DBG_RUNTIME      \
                           | DBG_WORKER       \
                           | DBG_SESSION      \
                           | DBG_SOCKET       \
                           | DBG_REQUEST      \
                           | DBG_RESPONSE     \
                           | DBG_URL          \
                           | DBG_ENTITY       \
                           | DBG_HEADERS      \
                           | DBG_UTILS        \
                           | DBG_THREAD_INFO  \
                           | DBG_CALL_INFO    \
                           | DBG_CALL_DEPTH   \
                           | DBG_TIMESTAMP    \
                           | DBG_NEST_CALLS   \
                           | OUTPUT_FLAGS)
#elif defined(__RELEASE_DEBUG__)
#define DEBUG_DEFAULT_FLAGS ( \
                             DBG_RUNTIME      \
                           | DBG_SESSION      \
                           | DBG_SOCKET       \
                           | DBG_REQUEST      \
                           | DBG_RESPONSE     \
                           | DBG_URL          \
                           | DBG_ENTITY       \
                           | DBG_HEADERS      \
                           | DBG_UTILS        \
                           | DBG_THREAD_INFO  \
                           | DBG_CALL_INFO    \
                           | DBG_CALL_DEPTH   \
                           | DBG_TIMESTAMP    \
                           | DBG_NEST_CALLS   \
                           | OUTPUT_FLAGS)
#else
#define DEBUG_DEFAULT_FLAGS ( \
                             DBG_MEM          \
                           | DBG_W3SOBJ       \
                           | DBG_RUNTIME      \
                           | DBG_WORKER       \
                           | DBG_SESSION      \
                           | DBG_SOCKET       \
                           | DBG_REQUEST      \
                           | DBG_RESPONSE     \
                           | DBG_URL          \
                           | DBG_ENTITY       \
                           | DBG_HEADERS      \
                           | DBG_UTILS        \
                           | DBG_THREAD_INFO  \
                           | DBG_CALL_INFO    \
                           | DBG_CALL_DEPTH   \
                           | DBG_TIMESTAMP    \
                           | DBG_NEST_CALLS   \
                           | OUTPUT_FLAGS)
#endif

// category flags
#define DBG_APP           0x00000001
#define DBG_WORKER        0x00000002
#define DBG_REGISTRY      0x00000004
#define DBG_MEM           0x00000008
#define DBG_W3SOBJ        0x00000010
#define DBG_REFCOUNT      0x00000020
#define DBG_FACTORY       0x00000040
#define DBG_W3SUI         0x00000080
#define DBG_SESSION       0x00000100
#define DBG_UTILS         0x00000200
#define DBG_SOCKET        0x00000400
#define DBG_REQUEST       0x00000800
#define DBG_RUNTIME       0x00001000
#define DBG_URL           0x00002000
#define DBG_ENTITY        0x00004000
#define DBG_HEADERS       0x00008000
#define DBG_RESPONSE      0x00010000
#define DBG_DISPATCH      0x00020000

// control flags
#define DBG_THROWDBGALERT 0x00800000
#define DBG_THREAD_INFO   0x01000000
#define DBG_CALL_DEPTH    0x02000000 // remove
#define DBG_TIMESTAMP     0x04000000
#define DBG_NEST_CALLS    0x08000000
#define DBG_TO_FILE       0x10000000
#define DBG_TO_DEBUGGER   0x20000000
#define DBG_CALL_INFO     0x40000000
#define DBG_NO_DEBUG      0x80000000

//
// types
//

typedef struct _memusage
{
  CRITICAL_SECTION lock;
  DWORD            total;
  MEMORYSTATUS     status;
}
MEMUSAGE, *PMEMUSAGE;

typedef enum _rettype
{
  rt_void,
  rt_bool,
  rt_dword,
  rt_hresult,
  rt_string
}
RETTYPE, *LPRETTYPE;

typedef struct _callinfo
{
  struct _callinfo* next;
  struct _callinfo* last;
  DWORD             category;
  LPCSTR            fname;
  RETTYPE           rettype;
}
CALLINFO, *LPCALLINFO;

typedef struct _threadinfo
{
  DWORD      threadid;
  DWORD      threadcat;
  DWORD      depth;
  LPCALLINFO stack;
}
THREADINFO, *LPTHREADINFO;

//
// prototypes
//

void DebugInitialize(void);
void DebugTerminate(void);

void DebugMemInitialize(void);
void DebugMemTerminate(void);
void DebugMemAlloc(void* pv);
void DebugMemFree(void* pv);

void DebugEnter(int category, RETTYPE rt, LPCSTR function, const char* format, ...);
void DebugLeave(int retval);
void DebugTrace(const char* format, ...);
void DebugAssert(LPSTR condition, LPSTR file, int line);

void DebugDataDump(LPSTR title, LPBYTE data, DWORD len);

void DebugThrowDbgAlert(void);

void AcquireDebugFileLock(void);
void ReleaseDebugFileLock(void);

LPTHREADINFO GetThreadInfo(void);

LPCALLINFO   SetCallInfo(LPTHREADINFO pti, DWORD category, RETTYPE rt, LPCSTR function);
LPCALLINFO   GetCallInfo(LPTHREADINFO pti);
void         DeleteCallInfo(LPCALLINFO pci);

LPSTR        FormatCallReturnString(LPCALLINFO pci, int retval);
LPSTR        MapCategoryToString(int category);
LPSTR        MapCompKeyToString(int key);

void  _debugout(LPTHREADINFO pti, BOOL fRaw, BOOL fTrace, const char* format, ...);
char* _gettimestamp(void);
char* _getwhitespace(int spaces);
BOOL  _opendebugfile(void);
void  _closedebugfile(void);

//
// macros
//
#define DEBUG_INITIALIZE() DebugInitialize()
#define DEBUG_TERMINATE()  DebugTerminate()

#define DEBUG_ENTER(parameters) \
              DebugEnter parameters

#define DEBUG_LEAVE(retval) \
              DebugLeave(retval)

#define DEBUG_ALLOC(block) \
              DebugMemAlloc(block)

#define DEBUG_FREE(block) \
              DebugMemFree(block)

extern DWORD g_dwDebugFlags;

#define DEBUG_TRACE(category, parameters) \
              if( DBG_##category & g_dwDebugFlags ) \
                DebugTrace parameters

#define DEBUG_DATA_DUMP(category, parameters) \
              if(DBG_##category & g_dwDebugFlags ) \
                DebugDataDump parameters

#define DEBUG_ADDREF(objname, refcount) \
              if( DBG_REFCOUNT & g_dwDebugFlags ) \
                DebugTrace("%s [%#x] addref: %d", objname, this, refcount)

#define DEBUG_RELEASE(objname, refcount) \
              if( DBG_REFCOUNT & g_dwDebugFlags ) \
                DebugTrace("%s [%#x] release: %d", objname, this, refcount)

#define DEBUG_FINALRELEASE(objname) \
              if( DBG_REFCOUNT & g_dwDebugFlags ) \
                DebugTrace("%s [%#x] final release!", objname, this)

#define DEBUG_DUMPWSOCKSTATS(wsd) \
              if( DBG_APP & g_dwDebugFlags ) \
                DebugTrace(\
                  "%s (v%d.%d in use) is %s",\
                  wsd.szDescription,\
                  (wsd.wVersion & 0x00FF),\
                  ((wsd.wVersion & 0xFF00) >> 8),\
                  wsd.szSystemStatus)


#define DEBUG_ASSERT(condition) \
          if( !(condition) ) \
            DebugAssert(#condition, __FILE__, __LINE__)

#else

// we will get rebuked for the bogus 
// arglists in the debug macros
#pragma warning( disable : 4002 )
#pragma warning( disable : 4003 )

#define DEBUG_ASSERT(x, y, z)
#define DEBUG_INITIALIZE()
#define DEBUG_TERMINATE()
#define DEBUG_ALLOC(x)
#define DEBUG_FREE(x)
#define DEBUG_ENTER(x)
#define DEBUG_LEAVE(x)
#define DEBUG_TRACE(x)
#define DEBUG_ADDREF(x)
#define DEBUG_RELEASE(x)
#define DEBUG_FINALRELEASE(x)
#define DEBUG_DUMPWSOCKSTATS(x)
#define DEBUG_DATA_DUMP(X)

#endif /* _DEBUG */
#endif /* __DEBUG_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\tools\w3spoof\inc\int_ifaces.h ===
/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Copyright (c) 2000  Microsoft Corporation

Module Name:

    int_ifaces.h

Abstract:

    Non-MIDL generated interface declarations for internal COM interfaces.
    
Author:

    Paul M Midgen (pmidge) 28-August-2000

Revision History:

    28-August-2000 pmidge
        Created

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/
#ifndef __INT_IFACES_H__
#define __INT_IFACES_H__

#ifdef __cplusplus
extern "C" {
#endif

extern const IID IID_IConfig;
extern const IID IID_IW3Spoof;
extern const IID IID_IThreadPool;
extern const IID IID_IW3SpoofEvents;

interface IConfig : public IUnknown
{
  virtual HRESULT __stdcall SetOption(DWORD dwOption, LPDWORD lpdwValue)          PURE;
  virtual HRESULT __stdcall GetOption(DWORD dwOption, LPDWORD lpdwValue)          PURE;
};

interface IW3Spoof : public IConfig
{
  virtual HRESULT __stdcall GetRuntime(IW3SpoofRuntime** pprt)                    PURE;
  virtual HRESULT __stdcall GetTypeLibrary(ITypeLib** pptl)                       PURE;
  virtual HRESULT __stdcall GetScriptEngine(IActiveScript** ppas)                 PURE;
  virtual HRESULT __stdcall GetScriptPath(LPWSTR client, LPWSTR* path)            PURE;
  virtual HRESULT __stdcall Notify(LPWSTR clientid, PSESSIONOBJ pso, STATE state) PURE;
  virtual HRESULT __stdcall WaitForUnload(void)                                   PURE;
  virtual HRESULT __stdcall Terminate(void)                                       PURE;
};

interface IThreadPool : public IUnknown
{
  virtual HRESULT __stdcall GetStatus(PIOCTX* ppioc, LPBOOL pbQuit)               PURE;
  virtual HRESULT __stdcall GetSession(LPWSTR clientid, PSESSIONOBJ* ppso)        PURE;
  virtual HRESULT __stdcall Register(SOCKET s)                                    PURE;
};

interface IW3SpoofEvents : public IUnknown
{
  virtual HRESULT __stdcall OnSessionOpen(LPWSTR clientid)                        PURE;
  virtual HRESULT __stdcall OnSessionStateChange(LPWSTR clientid, STATE state)    PURE;
  virtual HRESULT __stdcall OnSessionClose(LPWSTR clientid)                       PURE;
};

#ifdef __cplusplus
}
#endif

#endif /* __INT_IFACES_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\tools\w3spoof\inc\dispids.h ===
/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Copyright (c) 2000  Microsoft Corporation

Module Name:

    dispids.h

Abstract:

    W3Spoof automation interface dispids.
    
Author:

    Paul M Midgen (pmidge) 11-July-2000


Revision History:

    11-July-2000 pmidge
        Created

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/

#ifndef __DISPIDS_H__
#define __DISPIDS_H__

#define DISPID_SESSION_BASE             0x00000001
#define DISPID_SOCKET_BASE              0x00000100
#define DISPID_HEADERS_BASE             0x00000200
#define DISPID_ENTITY_BASE              0x00000300
#define DISPID_URL_BASE                 0x00000400
#define DISPID_REQUEST_BASE             0x00000500
#define DISPID_RESPONSE_BASE            0x00000600
#define DISPID_W3SPOOF_BASE             0x00000800

#define DISPID_SESSION_SOCKET           (DISPID_SESSION_BASE + 1)
#define DISPID_SESSION_REQUEST          (DISPID_SESSION_BASE + 2)
#define DISPID_SESSION_RESPONSE         (DISPID_SESSION_BASE + 3)
#define DISPID_SESSION_GETPROPERTYBAG   (DISPID_SESSION_BASE + 4)
#define DISPID_SESSION_KEEPALIVE        (DISPID_SESSION_BASE + 5)

#define DISPID_SOCKET_PARENT            (DISPID_SOCKET_BASE + 1)
#define DISPID_SOCKET_SEND              (DISPID_SOCKET_BASE + 2)
#define DISPID_SOCKET_RECV              (DISPID_SOCKET_BASE + 3)
#define DISPID_SOCKET_OPTION            (DISPID_SOCKET_BASE + 4)
#define DISPID_SOCKET_CLOSE             (DISPID_SOCKET_BASE + 5)
#define DISPID_SOCKET_RESOLVE           (DISPID_SOCKET_BASE + 6)
#define DISPID_SOCKET_LOCALNAME         (DISPID_SOCKET_BASE + 7)
#define DISPID_SOCKET_LOCALADDRESS      (DISPID_SOCKET_BASE + 8)
#define DISPID_SOCKET_LOCALPORT         (DISPID_SOCKET_BASE + 9)
#define DISPID_SOCKET_REMOTENAME        (DISPID_SOCKET_BASE + 10)
#define DISPID_SOCKET_REMOTEADDRESS     (DISPID_SOCKET_BASE + 11)
#define DISPID_SOCKET_REMOTEPORT        (DISPID_SOCKET_BASE + 12)

#define DISPID_HEADERS_PARENT           (DISPID_HEADERS_BASE + 1)
#define DISPID_HEADERS_SET              (DISPID_HEADERS_BASE + 2)
#define DISPID_HEADERS_GET              (DISPID_HEADERS_BASE + 3)
#define DISPID_HEADERS_GETHEADER        (DISPID_HEADERS_BASE + 4)
#define DISPID_HEADERS_SETHEADER        (DISPID_HEADERS_BASE + 5)

#define DISPID_ENTITY_PARENT            (DISPID_ENTITY_BASE + 1)
#define DISPID_ENTITY_GET               (DISPID_ENTITY_BASE + 2)
#define DISPID_ENTITY_SET               (DISPID_ENTITY_BASE + 3)
#define DISPID_ENTITY_COMPRESS          (DISPID_ENTITY_BASE + 4)
#define DISPID_ENTITY_DECOMPRESS        (DISPID_ENTITY_BASE + 5)
#define DISPID_ENTITY_LENGTH            (DISPID_ENTITY_BASE + 6)

#define DISPID_URL_PARENT               (DISPID_URL_BASE + 1)
#define DISPID_URL_ENCODING             (DISPID_URL_BASE + 2)
#define DISPID_URL_SCHEME               (DISPID_URL_BASE + 3)
#define DISPID_URL_SERVER               (DISPID_URL_BASE + 4)
#define DISPID_URL_PORT                 (DISPID_URL_BASE + 5)
#define DISPID_URL_PATH                 (DISPID_URL_BASE + 6)
#define DISPID_URL_RESOURCE             (DISPID_URL_BASE + 7)
#define DISPID_URL_QUERY                (DISPID_URL_BASE + 8)
#define DISPID_URL_FRAGMENT             (DISPID_URL_BASE + 9)
#define DISPID_URL_ESCAPE               (DISPID_URL_BASE + 10)
#define DISPID_URL_UNESCAPE             (DISPID_URL_BASE + 11)
#define DISPID_URL_SET                  (DISPID_URL_BASE + 12)
#define DISPID_URL_GET                  (DISPID_URL_BASE + 13)

#define DISPID_REQUEST_PARENT           (DISPID_REQUEST_BASE + 1)
#define DISPID_REQUEST_HEADERS          (DISPID_REQUEST_BASE + 2)
#define DISPID_REQUEST_ENTITY           (DISPID_REQUEST_BASE + 3)
#define DISPID_REQUEST_URL              (DISPID_REQUEST_BASE + 4)
#define DISPID_REQUEST_VERB             (DISPID_REQUEST_BASE + 5)
#define DISPID_REQUEST_HTTPVERSION      (DISPID_REQUEST_BASE + 6)

#define DISPID_RESPONSE_PARENT          (DISPID_RESPONSE_BASE + 1)
#define DISPID_RESPONSE_HEADERS         (DISPID_RESPONSE_BASE + 2)
#define DISPID_RESPONSE_ENTITY          (DISPID_RESPONSE_BASE + 3)
#define DISPID_RESPONSE_STATUSCODE      (DISPID_RESPONSE_BASE + 4)
#define DISPID_RESPONSE_STATUSTEXT      (DISPID_RESPONSE_BASE + 5)

#define DISPID_W3SPOOF_REGISTERCLIENT   (DISPID_W3SPOOF_BASE + 1)
#define DISPID_W3SPOOF_REVOKECLIENT     (DISPID_W3SPOOF_BASE + 2)

#endif /* __DISPIDS_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\tools\w3spoof\inc\hashtable.h ===
/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Copyright (c) 2000  Microsoft Corporation

Module Name:

    hashtable.cxx

Abstract:

    Simple hash table implementation.


Author:

    Paul M Midgen (pmidge) 14-August-2000


Revision History:

    14-August-2000 pmidge
        Created

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/

#include <common.h>

/*++===========================================================================

    An array is separated into N buckets that     +---+
    each contain a pointer to a binary search     | 0 |------> O
    tree. The tree's nodes are indexed by a       +---+       / \
    DWORD identifier to enable speedy traversals. | 1 |      O   O
    The array buckets are indexed by the values   +---+     / \   \
    generated by the hashing function supplied    | 2 |    O   O   O
    by a derived class.                           +---+        
                                                  | N |

    Clients derive a class from the hashtable ADT and specialize it for a 
    given data type. Any data type can be used. The only function the client
    must implement is the GetHashAndBucket function, and their class must
    provide the number of buckets the ADT needs to support. This is usually
    some number that is modulo'd against the generated hashes to yield the
    bucket number.

===========================================================================--*/

#define HT_COMPARE_LARGER  0x00000001
#define HT_COMPARE_SMALLER 0x00000002
#define HT_COMPARE_EQUAL   0x00000003

#define HT_TREE_ROOT       0x00000004
#define HT_TREE_RHSUBTREE  0x00000005
#define HT_TREE_LHSUBTREE  0x00000006

typedef struct _NODE
{
  DWORD  hash;
  DWORD  bucket;
  LPVOID data;
  _NODE* parent;
  _NODE* rh_child;
  _NODE* lh_child;
  BOOL   isLeft;
}
NODE, *PNODE;

typedef VOID (*PFNCLEARFUNC)(LPVOID* ppv);

template <class T> class CHashTable
{
  public:
    CHashTable(DWORD buckets)
    {
      pfnClear  = NULL;
      cBuckets  = buckets;
      arBuckets = new PNODE[buckets];
      InitializeCriticalSection(&csTable);
    }

   ~CHashTable()
    {
      SAFEDELETEBUF(arBuckets);
      DeleteCriticalSection(&csTable);
    }

    virtual void GetHashAndBucket(T id, LPDWORD lpHash, LPDWORD lpBucket) =0;

    DWORD Insert(T id, LPVOID pv);
    DWORD Get(T id, LPVOID* ppv);
    DWORD Delete(T id, LPVOID* ppv);

    void  Clear(void);
    void  SetClearFunction(PFNCLEARFUNC pfn) { pfnClear = pfn; }

  private:
    void  _Get(DWORD hash, PNODE& proot, PNODE& pnode);
    DWORD _Insert(PNODE& proot, PNODE pnew);
    void  _Remove(DWORD hash, PNODE& proot, PNODE& pnode);

    PNODE _NewNode(T id, LPVOID pv);
    DWORD _CompareNodes(DWORD hash_target, DWORD hash_tree);

    BOOL  _HasChildren(PNODE pnode);
    void  _PostTraverseAndDelete(PNODE proot);
    void  _Lock(void)   { EnterCriticalSection(&csTable); }
    void  _Unlock(void) { LeaveCriticalSection(&csTable); }

    PNODE*       arBuckets;
    DWORD        cBuckets;
    CRITSEC      csTable;
    PFNCLEARFUNC pfnClear;
};

typedef class CHashTable<LPWSTR> WSZHASHTBL;

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------

template <class T> DWORD CHashTable<T>::Insert(T id, LPVOID pv)
{
  DWORD ret = ERROR_SUCCESS;
  PNODE pn  = _NewNode(id, pv);

  _Lock();

    if( pn )
    {
      ret = _Insert(arBuckets[pn->bucket], pn);
    }
    else
    {
      ret = ERROR_OUTOFMEMORY;
    }

  _Unlock();

  return ret;
}

template <class T> DWORD CHashTable<T>::Get(T id, LPVOID* ppv)
{
  DWORD ret    = ERROR_SUCCESS;
  DWORD hash   = 0L;
  DWORD bucket = 0L;
  PNODE pnode  = NULL;

  GetHashAndBucket(id, &hash, &bucket);

  _Lock();

    _Get(hash, arBuckets[bucket], pnode);

    if( pnode )
    {
      *ppv = (void*) pnode->data;
    }
    else
    {
      *ppv = NULL;
      ret  = ERROR_NOT_FOUND;
    }

  _Unlock();

  return ret;
}

template <class T> DWORD CHashTable<T>::Delete(T id, LPVOID* ppv)
{
  DWORD ret   = ERROR_SUCCESS;
  DWORD hash   = 0L;
  DWORD bucket = 0L;
  PNODE pnode = NULL;

  GetHashAndBucket(id, &hash, &bucket);

  _Lock();

    _Remove(hash, arBuckets[bucket], pnode);

    if( pnode )
    {
      if( ppv )
      {
        *ppv = pnode->data;
      }
      else
      {
        if( pfnClear )
        {
          pfnClear(&pnode->data);
        }
      }

      delete pnode;
    }
    else
    {
      ret = ERROR_NOT_FOUND;

      if( ppv )
      {
        *ppv = NULL;
      }
    }

  _Unlock();

  return ret;
}

template <class T> void CHashTable<T>::Clear(void)
{
  _Lock();

    for(DWORD n=0; n < cBuckets; n++)
    {
      if( arBuckets[n] )
      {
        _PostTraverseAndDelete(arBuckets[n]);
        arBuckets[n] = NULL;
      }
    }

  _Unlock();
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------

template <class T> DWORD CHashTable<T>::_Insert(PNODE& proot, PNODE pnew)
{
  DWORD ret = ERROR_SUCCESS;

  if( pnew )
  {
    if( !proot )
    {
      proot = pnew;
    }
    else
    {
      switch( _CompareNodes(pnew->hash, proot->hash) )
      {
        case HT_COMPARE_SMALLER :
          {
            pnew->isLeft = TRUE;
            pnew->parent = proot;
            ret = _Insert(proot->lh_child, pnew);
          }
          break;

        case HT_COMPARE_LARGER :
          {
            pnew->isLeft = FALSE;
            pnew->parent = proot;
            ret = _Insert(proot->rh_child, pnew);
          }
          break;

        case HT_COMPARE_EQUAL :
          {
            if( pfnClear )
            {
              pfnClear(&proot->data);
            }

            ret         = ERROR_DUP_NAME;
            proot->data = pnew->data;
            delete pnew;
          }
          break;
      }
    }
  }

  return ret;
}

template <class T> void CHashTable<T>::_Get(DWORD hash, PNODE& proot, PNODE& pnode)
{
  if( proot )
  {
    switch( _CompareNodes(hash, proot->hash) )
    {
      case HT_COMPARE_SMALLER :
        {
          _Get(hash, proot->lh_child, pnode);
        }
        break;

      case HT_COMPARE_LARGER :
        {
          _Get(hash, proot->rh_child, pnode);
        }
        break;

      case HT_COMPARE_EQUAL :
        {
          pnode = proot;
        }
        break;
    }
  }
  else
  {
    pnode = NULL;
  }
}

template <class T> void CHashTable<T>::_Remove(DWORD hash, PNODE& proot, PNODE& pnode)
{
  if( proot )
  {
    switch( _CompareNodes(hash, proot->hash) )
    {
      case HT_COMPARE_SMALLER :
        {
          _Remove(hash, proot->lh_child, pnode);
        }
        break;

      case HT_COMPARE_LARGER :
        {
          _Remove(hash, proot->rh_child, pnode);
        }
        break;

      case HT_COMPARE_EQUAL :
        {
          pnode = proot;

          //
          // if proot has no parent it is the tree's root node
          //
          //   - if it has children, promote the left child to root
          //     and insert the right child in the new tree. after
          //     inserting, make sure the new root has no parent.
          //
          //   - if it has no children the tree is empty, set the root
          //     to null
          //

          if( !proot->parent )
          {
            if( _HasChildren(proot) )
            {
              proot = proot->lh_child;
              _Insert(proot, pnode->rh_child);
              proot->parent = NULL;
            }
            else
            {
              proot = NULL;
            }
          }
          else
          {
            if( proot->isLeft )
            {
              proot->parent->lh_child = NULL;
            }
            else
            {
              proot->parent->rh_child = NULL;
            }

            _Insert(pnode->parent, pnode->lh_child);
            _Insert(pnode->parent, pnode->rh_child);
          }
        }
        break;
    }
  }
  else
  {
    pnode = NULL;
  }
}

template <class T> void CHashTable<T>::_PostTraverseAndDelete(PNODE proot)
{
  if( proot )
  {
    _PostTraverseAndDelete(proot->lh_child);
    _PostTraverseAndDelete(proot->rh_child);

    if( pfnClear )
    {
      pfnClear(&proot->data);
    }

    delete proot;
    proot = NULL;
  }
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------

template <class T> DWORD CHashTable<T>::_CompareNodes(DWORD hash_target, DWORD hash_tree)
{
  if( hash_target == hash_tree )
  {
    return HT_COMPARE_EQUAL;
  }
  else if( hash_target < hash_tree )
  {
    return HT_COMPARE_SMALLER;
  }
  else
  {
    return HT_COMPARE_LARGER;
  }
}

template <class T> PNODE CHashTable<T>::_NewNode(T id, LPVOID pv)
{
  PNODE pn = new NODE;

  if( pn )
  {
    GetHashAndBucket(id, &pn->hash, &pn->bucket);
    pn->data = pv;
  }

  return pn;
}

template <class T> BOOL CHashTable<T>::_HasChildren(PNODE pnode)
{
  if( pnode )
  {
    return (pnode->lh_child || pnode->rh_child);
  }
  else
  {
    return FALSE;
  }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\tools\w3spoof\inc\mem.h ===
/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Copyright (c) 1999  Microsoft Corporation

Module Name:

    mem.h

Abstract:

    Internal memory allocation/deallocation routines.
    
Author:

    Paul M Midgen (pmidge) 01-June-2000


Revision History:

    01-June-2000 pmidge
        Created

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/

#ifndef __MEM_H__
#define __MEM_H__

#include "common.h"

void  _InitMem(void);

void* __cdecl operator new(size_t size);
void  __cdecl operator delete(void* pv);

#endif /* __MEM_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\tools\w3spoof\inc\linklist.h ===
/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Copyright (c) 2000  Microsoft Corporation

Module Name:

    linklist.h

Abstract:

    Linked list template class.


Author:

    Paul M Midgen (pmidge) 14-November-2000


Revision History:

    14-November-2000 pmidge
        Created

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/

#include <common.h>

typedef struct _ITEM
{
  LPVOID        value;
  struct _ITEM* next;
}
ITEM, *PITEM;

typedef struct _LINK
{
  DWORD         hash;
  PITEM         item;
  DWORD         items;
  struct _LINK* next;
}
LINK, *PLINK;

typedef VOID (*PFNCLEARFUNC)(LPVOID* ppv);

template <class T, class V> class CLinkedList
{
  public:
    CLinkedList()
    {
      m_pfnClear = NULL;
      m_List     = NULL;
      m_cList    = 0L;
      InitializeCriticalSection(&m_csList);
    }

   ~CLinkedList()
    {
      DeleteCriticalSection(&m_csList);
    }

    HRESULT Insert(T id, V value);
    HRESULT Get(T id, V* pvalue);
    HRESULT Delete(T id);
    HRESULT Collection(T id, V* collection, LPDWORD items);
    void    Clear(void);

    void SetClearFunction(PFNCLEARFUNC pfn) { m_pfnClear = pfn; }

    virtual void GetHash(T id, LPDWORD lpHash) =0;

  private:
    void _NewLink(T id, V value, PLINK* pplink);
    void _NewItem(LPVOID pv, PITEM* ppitem);
    void _InsertItem(PITEM proot, PITEM item);
    void _DeleteItems(PITEM proot);
    void _DeleteList(PLINK proot);
    void _Lock(void)   { EnterCriticalSection(&m_csList); }
    void _Unlock(void) { LeaveCriticalSection(&m_csList); }

    PLINK        m_List;
    DWORD        m_cList;
    CRITSEC      m_csList;
    PFNCLEARFUNC m_pfnClear;
};

typedef class CLinkedList<LPSTR, BSTR> HTTPHEADERLIST;

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------

template <class T, class V> HRESULT CLinkedList<T, V>::Insert(T id, V value)
{
  HRESULT hr        = S_OK;
  BOOL    bContinue = TRUE;
  PLINK   link      = m_List;
  PLINK   insert    = NULL;

  _NewLink(id, value, &insert);

  if( !insert )
  {
    hr = E_OUTOFMEMORY;
    goto quit;
  }

  _Lock();

    if( link )
    {
      while( bContinue )
      {
        if( link->hash == insert->hash )
        {
          _InsertItem(link->item, insert->item);

          link->items += 1;
          bContinue    = FALSE;

          delete insert;
        }
        else
        {
          if( link->next )
          {
            link = link->next;
          }
          else
          {
            link->next  = insert;
            m_cList    += 1;
            bContinue   = FALSE;
          }
        }
      }
    }
    else
    {
      m_List   = insert;
      m_cList += 1; 
    }

  _Unlock();

quit:

  return hr;
}

template <class T, class V> HRESULT CLinkedList<T, V>::Get(T id, V* pvalue)
{
  HRESULT hr     = S_OK;
  BOOL    bFound = FALSE;
  DWORD   hash   = 0L;
  PLINK   link   = m_List;

  GetHash(id, &hash);

  if( !pvalue )
  {
    hr = E_POINTER;
    goto quit;
  }

  _Lock();

    while( !bFound && link )
    {
      if( link->hash == hash )
      {
        *pvalue = (V) link->item->value;
        bFound  = TRUE;
      }
      else
      {
        link = link->next;
      }
    }

    if( !bFound )
    {
      *pvalue = NULL;
      hr      = E_FAIL;
    }

  _Unlock();

quit:

  return hr;
}

template <class T, class V> HRESULT CLinkedList<T, V>::Delete(T id)
{
  HRESULT hr        = S_OK;
  BOOL    bContinue = TRUE;
  DWORD   hash      = 0L;
  PLINK   link      = m_List;
  PLINK   last      = m_List;

  GetHash(id, &hash);

  _Lock();

    while( bContinue && link )
    {
      if( link->hash == hash )
      {
        _DeleteItems(link->item);

        m_List      = (m_List == link) ? m_List->next : m_List;
        m_cList    -= 1;   
        last->next  = link->next;
        bContinue   = FALSE;

        delete link;
      }
      else
      {
        last = link;
        link = link->next;
      }
    }

    if( bContinue )
    {
      hr = E_FAIL;
    }

  _Unlock();

  return hr;
}

template <class T, class V> HRESULT CLinkedList<T, V>::Collection(T id, V* collection, LPDWORD items)
{
  //
  // TODO: implementation
  //

  return S_OK;
}

template <class T, class V> void CLinkedList<T, V>::Clear(void)
{
  _Lock();

    _DeleteList(m_List);
    m_List  = NULL;
    m_cList = 0L;

  _Unlock();
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------

template <class T, class V> void CLinkedList<T, V>::_NewLink(T id, V value, PLINK* pplink)
{
  PLINK plink = new LINK;

  GetHash(id, &plink->hash);
  _NewItem((void*) value, &plink->item);

  plink->items = 1;
  plink->next  = NULL;

  *pplink = plink;
}

template <class T, class V> void CLinkedList<T, V>::_NewItem(LPVOID pv, PITEM* ppitem)
{
  PITEM pitem = new ITEM;

  pitem->value = pv;
  pitem->next  = NULL;

  *ppitem = pitem;
}

template <class T, class V> void CLinkedList<T, V>::_InsertItem(PITEM proot, PITEM item)
{
  while( proot->next )
    proot = proot->next;

  proot->next = item;
}

template <class T, class V> void CLinkedList<T, V>::_DeleteItems(PITEM proot)
{
  if( proot )
  {
    if( m_pfnClear )
    {
      m_pfnClear((void**) &proot->value);
    }

    _DeleteItems(proot->next);
    delete proot;
  }
}

template <class T, class V> void CLinkedList<T, V>::_DeleteList(PLINK proot)
{
  if( proot )
  {
    _DeleteList(proot->next);
    _DeleteItems(proot->item);
    delete proot;
  }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\tools\w3spoof\inc\om.h ===
/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Copyright (c) 1999  Microsoft Corporation

Module Name:

    om.h

Abstract:

    Object declarations for object model components.
    
Author:

    Paul M Midgen (pmidge) 13-October-2000


Revision History:

    13-October-2000 pmidge
        Created on Friday the 13th!!

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/

#ifndef __OM_H__
#define __OM_H__

#include "common.h"

class CSession : public ISession,
                 public IProvideClassInfo,
                 public IActiveScriptSite
{
  public:
    DECLAREIUNKNOWN();
    DECLAREIDISPATCH();
    DECLAREIPROVIDECLASSINFO();

  public:
    // ISession
    HRESULT __stdcall get_Socket(IDispatch** ppdisp);
    HRESULT __stdcall get_Request(IDispatch** ppdisp);
    HRESULT __stdcall get_Response(IDispatch** ppdisp);
    HRESULT __stdcall get_KeepAlive(VARIANT* IsKA);
    HRESULT __stdcall GetPropertyBag(VARIANT Name, IDispatch** ppdisp);

    // IActiveScriptSite
    HRESULT __stdcall GetLCID(LCID* plcid);

    HRESULT __stdcall GetItemInfo(
                        LPCOLESTR pstrName,
                        DWORD dwReturnMask,
                        IUnknown** ppunk,
                        ITypeInfo** ppti
                        );

    HRESULT __stdcall GetDocVersionString(BSTR* pbstrVersion);
    HRESULT __stdcall OnScriptTerminate(const VARIANT* pvarResult, const EXCEPINFO* pei);
    HRESULT __stdcall OnStateChange(SCRIPTSTATE ss);
    HRESULT __stdcall OnScriptError(IActiveScriptError* piase);
    HRESULT __stdcall OnEnterScript(void);
    HRESULT __stdcall OnLeaveScript(void);

    // CSession
    CSession();
   ~CSession();

    HRESULT Run(PIOCTX pioc);
    HRESULT Terminate(void);

    static HRESULT Create(PIOCTX pioc, IW3Spoof* pw3s);

  private:
    HRESULT          _Initialize(PIOCTX pioc, IW3Spoof* pw3s);
    HRESULT          _InitScriptEngine(void);
    HRESULT          _LoadScript(void);
    HRESULT          _SetScriptSite(BOOL bClone);
    HRESULT          _ResetScriptEngine(void);
    HRESULT          _LoadScriptDispids(void);
    HRESULT          _InitSocketObject(PIOCTX pioc);
    HRESULT          _InitRequestObject(void);
    void             _SetKeepAlive(PIOCTX pioc);
    void             _SetObjectState(STATE state);
    BOOL             _SetNextServerState(SERVERSTATE state);
    void             _Lock(void);
    void             _Unlock(void);

    LONG             m_cRefs;
    LPWSTR           m_wszClient;
    LPWSTR           m_wszClientId;
    BOOL             m_bIsKeepAlive;
    SCRIPTDISPID     m_CurrentHandler;
    LCID             m_lcid;
    PSOCKETOBJ       m_socketobj;
    PREQUESTOBJ      m_requestobj;
    PRESPONSEOBJ     m_responseobj;
    ITypeLib*        m_ptl;
    IW3Spoof*        m_pw3s;
    IActiveScript*   m_pas;
    IDispatch*       m_psd;
    DISPID           m_arHandlerDispids[SCRIPTHANDLERS];
    CRITSEC          m_lock;
    STATE            m_objstate;
};


class CSocket : public ISocket,
                public IProvideClassInfo,
                public IObjectWithSite
{
  public:
    DECLAREIUNKNOWN();
    DECLAREIDISPATCH();
    DECLAREIPROVIDECLASSINFO();
    DECLAREIOBJECTWITHSITE();

  public:
    // ISocket
    HRESULT __stdcall Send(VARIANT Data);
    HRESULT __stdcall Recv(VARIANT *Data);
    HRESULT __stdcall Close(VARIANT Method);
    HRESULT __stdcall Resolve(BSTR Host, BSTR *Address);

    HRESULT __stdcall get_Parent(IDispatch** ppdisp);
    HRESULT __stdcall get_LocalName(BSTR *Name);
    HRESULT __stdcall get_LocalAddress(BSTR *Address);
    HRESULT __stdcall get_LocalPort(VARIANT *Port);
    HRESULT __stdcall get_RemoteName(BSTR *Name);
    HRESULT __stdcall get_RemoteAddress(BSTR *Address);
    HRESULT __stdcall get_RemotePort(VARIANT *Port);

    HRESULT __stdcall get_Option(BSTR Option, VARIANT *Value);
    HRESULT __stdcall put_Option(BSTR Option, VARIANT Value);

    // CSocket
    CSocket();
   ~CSocket();

    HRESULT     Run(PIOCTX pioc);
    HRESULT     Terminate(void);
    SERVERSTATE GetServerState(void);
    void        SetServerState(SERVERSTATE ss);

    static HRESULT Create(PIOCTX pioc, PSOCKETOBJ* ppsocketobj);

    friend class CSession;

  protected:
    void        GetSendBuffer(WSABUF** ppwb);
    void        GetRecvBuffer(WSABUF** ppwb);
    DWORD       GetBytesSent(void);
    DWORD       GetBytesReceived(void);

  private:
    HRESULT     _Initialize(PIOCTX pioc);
    void        _SetObjectState(STATE state);
    BOOL        _ResizeBuffer(PIOCTX pioc, DWORD len);
    HRESULT     _Send(PIOCTX pioc);
    HRESULT     _Recv(PIOCTX pioc);
    BOOL        _Flush(void);
    HRESULT     _TestWinsockError(void);

    LONG        m_cRefs;
    SOCKET      m_socket;
    PHOSTINFO   m_local;
    PHOSTINFO   m_remote;
    PIOCTX      m_rcvd;
    PIOCTX      m_sent;
    IUnknown*   m_pSite;
    LPWSTR      m_wszClientId;
    SERVERSTATE m_serverstate;
    STATE       m_objstate;
};


class CRequest : public IRequest,
                 public IProvideClassInfo,
                 public IObjectWithSite
{
  public:
    DECLAREIUNKNOWN();
    DECLAREIDISPATCH();
    DECLAREIPROVIDECLASSINFO();
    DECLAREIOBJECTWITHSITE();

  public:
    // IRequest
    HRESULT __stdcall get_Parent(IDispatch **ppdisp);
    HRESULT __stdcall get_Headers(IDispatch **ppdisp);
    HRESULT __stdcall get_Entity(IDispatch **ppdisp);
    HRESULT __stdcall get_Url(IDispatch **ppdisp);
    HRESULT __stdcall get_Verb(BSTR *Verb);
    HRESULT __stdcall get_HttpVersion(BSTR *HttpVersion);

    // CRequest
    CRequest();
   ~CRequest();

    void Terminate(void);

    static HRESULT Create(CHAR* request, DWORD len, PREQUESTOBJ* ppreq);

  private:
    HRESULT     _Initialize(CHAR* request, DWORD len);
    void        _Cleanup(void);
    HRESULT     _SiteMemberObjects(void);
    BOOL        _CrackRequest(LPSTR request, DWORD len, LPSTR* reqline, LPSTR* headers, LPSTR* entity, LPDWORD contentlength);
    LPSTR*      _CrackRequestLine(CHAR* buf, DWORD len);

    LONG        m_cRefs;
    IUnknown*   m_pSite;
    LPWSTR      m_wszVerb;
    LPWSTR      m_wszHTTPVersion;
    PURLOBJ     m_urlobj;
    PHEADERSOBJ m_headersobj;
    PENTITYOBJ  m_entityobj;
};


class CResponse : public IResponse,
                  public IProvideClassInfo,
                  public IObjectWithSite
{
  public:
    DECLAREIUNKNOWN();
    DECLAREIDISPATCH();
    DECLAREIPROVIDECLASSINFO();
    DECLAREIOBJECTWITHSITE();

  public:
    // IResponse
    HRESULT __stdcall get_Parent(IDispatch **ppdisp);
    HRESULT __stdcall get_Headers(IDispatch **ppdisp);
    HRESULT __stdcall putref_Headers(IDispatch **ppdisp);
    HRESULT __stdcall get_Entity(IDispatch **ppdisp);
    HRESULT __stdcall putref_Entity(IDispatch **ppdisp);
    HRESULT __stdcall get_StatusCode(VARIANT *Code);
    HRESULT __stdcall put_StatusCode(VARIANT StatusCode);
    HRESULT __stdcall get_StatusText(BSTR *StatusText);
    HRESULT __stdcall put_StatusText(BSTR StatusText);
    
    // CResponse
    CResponse();
   ~CResponse();

    HRESULT Terminate(void);

    static HRESULT Create(CHAR* response, DWORD len, PRESPONSEOBJ* ppresponse);

  private:
    HRESULT     _Initialize(CHAR* response, DWORD len);

    LONG        m_cRefs;
    IUnknown*   m_pSite;
    PHEADERSOBJ m_headersobj;
    PENTITYOBJ  m_entityobj;
};


class CUrl : public IUrl,
             public IProvideClassInfo,
             public IObjectWithSite
{
  public:
    DECLAREIUNKNOWN();
    DECLAREIDISPATCH();
    DECLAREIPROVIDECLASSINFO();
    DECLAREIOBJECTWITHSITE();

  public:
    // IUrl
    HRESULT __stdcall get_Parent(IDispatch **ppdisp);
    HRESULT __stdcall get_Encoding(BSTR *Encoding);    
    HRESULT __stdcall get_Scheme(BSTR *Scheme);
    HRESULT __stdcall put_Scheme(BSTR Scheme);    
    HRESULT __stdcall get_Server(BSTR *Server);    
    HRESULT __stdcall put_Server(BSTR Server);    
    HRESULT __stdcall get_Port(VARIANT *Port);    
    HRESULT __stdcall put_Port(VARIANT Port);    
    HRESULT __stdcall get_Path(BSTR *Path);    
    HRESULT __stdcall put_Path(BSTR Path);    
    HRESULT __stdcall get_Resource(BSTR *Resource);    
    HRESULT __stdcall put_Resource(BSTR Resource);    
    HRESULT __stdcall get_Query(BSTR *Query);    
    HRESULT __stdcall put_Query(BSTR Query);    
    HRESULT __stdcall get_Fragment(BSTR *Fragment);    
    HRESULT __stdcall put_Fragment(BSTR Fragment);    
    HRESULT __stdcall Escape(BSTR *Url);    
    HRESULT __stdcall Unescape(BSTR *Url);    
    HRESULT __stdcall Set(BSTR Url);
    HRESULT __stdcall Get(BSTR *Url);

    // CUrl
    CUrl();
   ~CUrl();

    static HRESULT Create(CHAR* url, BOOL bReadOnly, PURLOBJ* ppurl);

    void Terminate(void);

  private:
    HRESULT    _Initialize(CHAR* url, BOOL bReadOnly);
    void       _Cleanup(void);

    LONG       m_cRefs;
    IUnknown*  m_pSite;
    ITypeInfo* m_pti;
    BOOL       m_bReadOnly;
    BOOL       m_bEscaped;
    LPSTR      m_szOriginalUrl;
    LPSTR      m_szUnescapedUrl;
    LPWSTR     m_wszUrl;
    LPWSTR     m_wszScheme;
    USHORT     m_usPort;
    LPWSTR     m_wszServer;
    LPWSTR     m_wszPath;
    LPWSTR     m_wszResource;
    LPWSTR     m_wszQuery;
    LPWSTR     m_wszFragment;
};


class CHeaders : public IHeaders,
                 public IProvideClassInfo,
                 public IObjectWithSite
{
  public:
    DECLAREIUNKNOWN();
    DECLAREIDISPATCH();
    DECLAREIPROVIDECLASSINFO();
    DECLAREIOBJECTWITHSITE();

  public:
    // IHeaders
    HRESULT __stdcall get_Parent(IDispatch **ppdisp);
    HRESULT __stdcall Get(BSTR *Headers);
    HRESULT __stdcall Set(VARIANT *Headers);
    HRESULT __stdcall GetHeader(BSTR Header, VARIANT *Value);
    HRESULT __stdcall SetHeader(BSTR Header, VARIANT *Value);

    // CHeaders
    CHeaders();
   ~CHeaders();

    static HRESULT Create(CHAR* headers, BOOL bReadOnly, PHEADERSOBJ* ppheaders);

    void Terminate(void);

  private:
    HRESULT     _Initialize(CHAR* headers, BOOL bReadOnly);
    HRESULT     _ParseHeaders(CHAR* headers);
    void        _Cleanup(void);

    LONG        m_cRefs;
    IUnknown*   m_pSite;
    ITypeInfo*  m_pti;
    BOOL        m_bReadOnly;
    CHAR*       m_pchHeaders;
    PHEADERLIST m_headerlist;
}; 


class CEntity : public IEntity,
                public IProvideClassInfo,
                public IObjectWithSite
{
  public:
    DECLAREIUNKNOWN();
    DECLAREIDISPATCH();
    DECLAREIPROVIDECLASSINFO();
    DECLAREIOBJECTWITHSITE();

  public:
    // IEntity
    HRESULT __stdcall get_Parent(IDispatch **ppdisp);
    HRESULT __stdcall get_Length(VARIANT *Length);
    HRESULT __stdcall Get(VARIANT *Entity);
    HRESULT __stdcall Set(VARIANT Entity);
    HRESULT __stdcall Compress(BSTR Method);
    HRESULT __stdcall Decompress(VARIANT Method);

    // CEntity
    CEntity();
   ~CEntity();

    static HRESULT Create(LPBYTE data, DWORD length, BOOL bReadOnly, PENTITYOBJ* ppentity);

    void Terminate(void);

  private:
    HRESULT    _Initialize(LPBYTE data, DWORD length, BOOL bReadOnly);
    void       _Cleanup(void);

    LONG       m_cRefs;
    IUnknown*  m_pSite;
    ITypeInfo* m_pti;    
    BOOL       m_bReadOnly;
    LPBYTE     m_pbData;
    DWORD      m_cData;
};

#endif /* __OM_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\tools\w3spoof\inc\registry.h ===
/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Copyright (c) 2000  Microsoft Corporation

Module Name:

    registry.h

Abstract:

    Registry functions
    
Author:

    Paul M Midgen (pmidge) 23-May-2000


Revision History:

    23-May-2000 pmidge
        Created

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/

#ifndef _REGISTRY_H_
#define _REGISTRY_H_

#include "common.h"

HKEY _GetRootKey(BOOL fOpen);

BOOL SetRegValue(LPCWSTR wszValueName, DWORD dwType, LPVOID pvData, DWORD dwSize);
BOOL GetRegValue(LPCWSTR wszValueName, DWORD dwType, LPVOID* ppvData);

#endif /* _REGISTRY_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\tools\w3spoof\inc\stores.h ===
#include "common.h"

typedef class CStringMap  STRINGMAP;
typedef class CStringMap* PSTRINGMAP;
typedef class CHeaderList  HEADERLIST;
typedef class CHeaderList* PHEADERLIST;

VOID VariantKiller(LPVOID* ppv);
VOID PropertyBagKiller(LPVOID* ppv);
VOID BSTRKiller(LPVOID* ppv);

class CStringMap : public WSZHASHTBL
{
  public:
    CStringMap() : WSZHASHTBL(100) {}
   ~CStringMap() {}

    void GetHashAndBucket(LPWSTR id, LPDWORD lpHash, LPDWORD lpBucket);
};


class CHeaderList : public HTTPHEADERLIST
{
  public:
    CHeaderList() {}
   ~CHeaderList() {}

    void GetHash(LPSTR id, LPDWORD lpHash);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\tools\w3spoof\inc\utils.h ===
/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Copyright (c) 1999  Microsoft Corporation

Module Name:

    utils.h

Abstract:

    Utility functions.
    
Author:

    Paul M Midgen (pmidge) 12-January-2001


Revision History:

    12-January-2001 pmidge
        Created

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/

#ifndef _UTILS_H_
#define _UTILS_H_

// file retrieval
BOOL             GetFile(LPCWSTR path, HANDLE* phUNC, IWinHttpRequest** ppWHR, DWORD mode, BOOL* bReadOnly);
BOOL             __PathIsUNC(LPCWSTR path);
BOOL             __PathIsURL(LPCWSTR path);
IWinHttpRequest* __OpenUrl(LPCWSTR url);
HANDLE           __OpenFile(LPCWSTR path, DWORD mode, BOOL* bReadOnly);

// oleautomation/scripting
BOOL    GetJScriptCLSID(LPCLSID pclsid);
HRESULT GetTypeInfoFromName(LPCOLESTR name, ITypeLib* ptl, ITypeInfo** ppti);
DISPID  GetDispidFromName(PDISPIDTABLEENTRY pdt, DWORD cEntries, LPWSTR name);
void    AddRichErrorInfo(EXCEPINFO* pei, LPWSTR source, LPWSTR description, HRESULT error);
DWORD   GetHash(LPWSTR name);
DWORD   GetHash(LPSTR name);
HRESULT ProcessVariant(VARIANT* pvar, LPBYTE* ppbuf, LPDWORD pcbuf, LPDWORD pbytes);
HRESULT ProcessObject(IUnknown* punk, LPBYTE* ppbuf, LPDWORD pcbuf, LPDWORD pbytes);
HRESULT ValidateDispatchArgs(REFIID riid, DISPPARAMS* pdp, VARIANT* pvr, UINT* pae);
HRESULT ValidateInvokeFlags(WORD flags, WORD accesstype, BOOL bNotMethod);
HRESULT ValidateArgCount(DISPPARAMS* pdp, DWORD needed, BOOL bHasOptionalArgs, DWORD optional);
HRESULT HandleDispatchError(LPWSTR id, EXCEPINFO* pei, HRESULT hr);

// winsock
void ParseSocketInfo(PIOCTX pi);
void GetHostname(struct in_addr ip, LPSTR* ppsz);

// string & type manipulation
char*  __strndup(const char* src, int len);
char*  __strdup(const char* src);
WCHAR* __wstrndup(const WCHAR* src, int len);
WCHAR* __wstrdup(const WCHAR* src);
CHAR*  __widetoansi(const WCHAR* pwsz);
WCHAR* __ansitowide(const char* psz);
BOOL   __isempty(VARIANT var);
BSTR   __ansitobstr(LPCSTR src);
BSTR   __widetobstr(LPCWSTR wsrc);
char*  __unescape(char* str);

#endif /* _UTILS_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\tools\w3spoof\om\entity\dispatch.cxx ===
/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Copyright (c) 2000  Microsoft Corporation

Module Name:

    dispatch.cxx

Abstract:

    Implements the IDispatch interface for the Entity object.
    
Author:

    Paul M Midgen (pmidge) 13-November-2000


Revision History:

    13-November-2000 pmidge
        Created

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/

#include "common.h"

//
// WARNING: do not modify these values. use disphash.exe to generate
//          new values.
//
DISPIDTABLEENTRY g_EntityDisptable[] =
{
  0x00021b1c,   DISPID_ENTITY_PARENT,       L"parent",
  0x00003b7b,   DISPID_ENTITY_GET,          L"get",
  0x00003f5f,   DISPID_ENTITY_SET,          L"set",
  0x00083673,   DISPID_ENTITY_COMPRESS,     L"compress",
  0x001fc1e8,   DISPID_ENTITY_DECOMPRESS,   L"decompress",
  0x0002142e,   DISPID_ENTITY_LENGTH,       L"length"
};

DWORD g_cEntityDisptable = (sizeof(g_EntityDisptable) / sizeof(DISPIDTABLEENTRY));


//-----------------------------------------------------------------------------
// IDispatch
//-----------------------------------------------------------------------------
HRESULT
__stdcall
CEntity::GetTypeInfoCount(UINT* pctinfo)
{
  DEBUG_ENTER((
    DBG_DISPATCH,
    rt_hresult,
    "CEntity::GetTypeInfoCount",
    "this=%#x; pctinfo=%#x",
    this,
    pctinfo
    ));

  HRESULT hr = S_OK;

    if( !pctinfo )
    {
      hr = E_POINTER;
    }
    else
    {
      *pctinfo = 1;
    }

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CEntity::GetTypeInfo(UINT index, LCID lcid, ITypeInfo** ppti)
{
  DEBUG_ENTER((
    DBG_DISPATCH,
    rt_hresult,
    "CEntity::GetTypeInfo",
    "this=%#x; index=%#x; lcid=%#x; ppti=%#x",
    this,
    index,
    lcid,
    ppti
    ));

  HRESULT hr = S_OK;

  if( !ppti )
  {
    hr = E_POINTER;
  }
  else
  {
    if( index != 0 )
    {
      hr    = DISP_E_BADINDEX;
      *ppti = NULL;
    }
    else
    {
      hr = GetClassInfo(ppti);
    }
  }

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CEntity::GetIDsOfNames(REFIID riid, LPOLESTR* arNames, UINT cNames, LCID lcid, DISPID* arDispId)
{
  DEBUG_ENTER((
    DBG_DISPATCH,
    rt_hresult,
    "CEntity::GetIDsOfNames",
    "this=%#x; riid=%s; arNames=%#x; cNames=%d; lcid=%#x; arDispId=%#x",
    this,
    MapIIDToString(riid),
    arNames,
    cNames,
    lcid,
    arDispId
    ));

  HRESULT hr = S_OK;
  UINT    n  = 0L;

  if( !IsEqualIID(riid, IID_NULL) )
  {
    hr = E_INVALIDARG;
    goto quit;
  }

  while( n < cNames )
  {
    arDispId[n] = GetDispidFromName(g_EntityDisptable, g_cEntityDisptable, arNames[n]);
    ++n;
  }

quit:

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CEntity::Invoke(DISPID dispid, REFIID riid, LCID lcid, WORD flags, DISPPARAMS* pdp, VARIANT* pvr, EXCEPINFO* pei, UINT* pae)
{
  DEBUG_ENTER((
    DBG_DISPATCH,
    rt_hresult,
    "CEntity::Invoke",
    "this=%#x; dispid=%s; riid=%s; lcid=%#x; flags=%#x; pdp=%#x; pvr=%#x; pei=%#x; pae=%#x",
    this,
    MapDispidToString(dispid),
    MapIIDToString(riid),
    lcid,
    flags,
    pdp, pvr,
    pei, pae
    ));

  HRESULT hr = S_OK;

  hr = ValidateDispatchArgs(riid, pdp, pvr, pae);

    if( FAILED(hr) )
      goto quit;

  switch( dispid )
  {
    case DISPID_ENTITY_PARENT :
      {
        hr = ValidateInvokeFlags(flags, DISPATCH_PROPERTYGET, TRUE);

        if( SUCCEEDED(hr) )
        {
          V_VT(pvr) = VT_DISPATCH;
          hr        = get_Parent(&V_DISPATCH(pvr));
        }
      }
      break;

    case DISPID_ENTITY_LENGTH :
      {
        hr = ValidateInvokeFlags(flags, DISPATCH_PROPERTYGET, TRUE);

        if( SUCCEEDED(hr) )
        {
          hr = get_Length(pvr);
        }
      }
      break;

    case DISPID_ENTITY_GET :
      {
        hr = ValidateInvokeFlags(flags, DISPATCH_METHOD, FALSE);

        if( SUCCEEDED(hr) )
        {
          hr = ValidateArgCount(pdp, 0, FALSE, 0);

          if( SUCCEEDED(hr) )
          {
            if( pvr )
            {
              hr = Get(pvr);
            }
          }
        }
      }
      break;

    case DISPID_ENTITY_SET :
      {
        NEWVARIANT(entity);

        hr = ValidateInvokeFlags(flags, DISPATCH_METHOD, FALSE);

        if( SUCCEEDED(hr) )
        {
          hr = ValidateArgCount(pdp, 1, FALSE, 0);

          if( SUCCEEDED(hr) )
          {
            VariantCopy(&entity, &pdp->rgvarg[0]);
            
              hr = Set(entity);

            VariantClear(&entity);
          }
        }
      }
      break;

    case DISPID_ENTITY_COMPRESS :
      {
        hr = ValidateInvokeFlags(flags, DISPATCH_METHOD, FALSE);

        if( SUCCEEDED(hr) )
        {
          hr = ValidateArgCount(pdp, 1, FALSE, 0);

          if( SUCCEEDED(hr) )
          {
            hr = Compress(V_BSTR(&pdp->rgvarg[0]));
          }
        }
      }
      break;

    case DISPID_ENTITY_DECOMPRESS :
      {
        NEWVARIANT(method);

        hr = ValidateInvokeFlags(flags, DISPATCH_METHOD, FALSE);

        if( SUCCEEDED(hr) )
        {
          hr = ValidateArgCount(pdp, 1, FALSE, 0);

          if( SUCCEEDED(hr) )
          {
            VariantCopy(&method, &pdp->rgvarg[0]);
            
              hr = Decompress(method);
              
            VariantClear(&method);
          }
        }
      }
      break;
   
    default : hr = DISP_E_MEMBERNOTFOUND;
  }

quit:

  if( FAILED(hr) )
  {
    hr = HandleDispatchError(L"entity object", pei, hr);
  }

  DEBUG_LEAVE(hr);
  return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\tools\w3spoof\inc\w3srt.h ===
/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Copyright (c) 1999  Microsoft Corporation

Module Name:

    w3srt.h

Abstract:

    Object declarations for the W3Spoof runtime environment.
    
Author:

    Paul M Midgen (pmidge) 03-November-2000


Revision History:

    03-November-2000 pmidge
        Created

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/

#ifndef __W3SRT_H__
#define __W3SRT_H__

#include "common.h"

typedef class CW3SRuntime      RUNTIME;
typedef class CW3SRuntime*     PRUNTIME;
typedef class CW3SPropertyBag  PROPERTYBAG;
typedef class CW3SPropertyBag* PPROPERTYBAG;
typedef class CW3SFile         FILEOBJ;
typedef class CW3SFile*        PFILEOBJ;

#define DISPID_RUNTIME_BASE          0x10000000
#define DISPID_PROPERTYBAG_BASE      0x20000000
#define DISPID_FILE_BASE             0x30000000

#define DISPID_RUNTIME_GETFILE       (DISPID_RUNTIME_BASE + 1)

#define DISPID_PROPERTYBAG_GET       (DISPID_PROPERTYBAG_BASE + 1)
#define DISPID_PROPERTYBAG_SET       (DISPID_PROPERTYBAG_BASE + 2)
#define DISPID_PROPERTYBAG_EXPIRES   (DISPID_PROPERTYBAG_BASE + 3)
#define DISPID_PROPERTYBAG_FLUSH     (DISPID_PROPERTYBAG_BASE + 4)

#define DISPID_FILE_OPEN             (DISPID_FILE_BASE + 1)
#define DISPID_FILE_CLOSE            (DISPID_FILE_BASE + 2)
#define DISPID_FILE_WRITE            (DISPID_FILE_BASE + 3)
#define DISPID_FILE_WRITELINE        (DISPID_FILE_BASE + 4)
#define DISPID_FILE_WRITEBLANKLINE   (DISPID_FILE_BASE + 5)
#define DISPID_FILE_READ             (DISPID_FILE_BASE + 6)
#define DISPID_FILE_READALL          (DISPID_FILE_BASE + 7)
#define DISPID_FILE_ATTRIBUTES       (DISPID_FILE_BASE + 8)
#define DISPID_FILE_SIZE             (DISPID_FILE_BASE + 9)
#define DISPID_FILE_TYPE             (DISPID_FILE_BASE + 10)
#define DISPID_FILE_DATELASTMODIFIED (DISPID_FILE_BASE + 11)

#ifdef __cplusplus
extern "C" {
#endif

extern const IID IID_IW3SpoofRuntime;
extern const IID IID_IW3SpoofPropertyBag;
extern const IID IID_IW3SpoofFile;
  
//-----------------------------------------------------------------------------
// W3Spoof Runtime Interface Declarations
//-----------------------------------------------------------------------------
interface IW3SpoofPropertyBag : public IDispatch
{
  virtual HRESULT __stdcall Get(
                              /*[in]*/          BSTR Name,
                              /*[out, retval]*/ VARIANT* Value
                              ) PURE;

  virtual HRESULT __stdcall Set(
                              /*[in]*/           BSTR Name,
                              /*[in, optional]*/ VARIANT Value
                              ) PURE;

  virtual HRESULT __stdcall get_Expires(
                              /*[propget]*/
                              /*[out, retval]*/ VARIANT* Expiry
                              ) PURE;

  virtual HRESULT __stdcall put_Expires(
                              /*[propput]*/
                              /*[in, optional]*/ VARIANT Expiry
                              ) PURE;

  virtual HRESULT __stdcall Flush(void) PURE;
};


interface IW3SpoofFile : public IDispatch
{
  virtual HRESULT __stdcall Open(
                              /*[in]*/           BSTR     Filename,
                              /*[in, optional]*/ VARIANT  Mode,
                              /*[out, retval]*/  VARIANT* Success
                              ) PURE;

  virtual HRESULT __stdcall Close(void) PURE;

  virtual HRESULT __stdcall Write(
                              /*[in]*/          VARIANT  Data,
                              /*[out, retval]*/ VARIANT* Success
                              ) PURE;

  virtual HRESULT __stdcall WriteLine(
                              /*[in]*/          BSTR     Line,
                              /*[out, retval]*/ VARIANT* Success
                              ) PURE;

  virtual HRESULT __stdcall WriteBlankLine(
                              /*[out, retval]*/ VARIANT* Success
                              ) PURE;

  virtual HRESULT __stdcall Read(
                              /*[in]*/          VARIANT  Bytes,
                              /*[out, retval]*/ VARIANT* Data
                              ) PURE;

  virtual HRESULT __stdcall ReadAll(
                              /*[out, retval]*/ VARIANT* Data
                              ) PURE;

  virtual HRESULT __stdcall Attributes(
                              /*[out, retval]*/ VARIANT* Attributes
                              ) PURE;

  virtual HRESULT __stdcall Size(
                              /*[out, retval]*/ VARIANT* Size
                              ) PURE;

  virtual HRESULT __stdcall Type(
                              /*[out, retval]*/ VARIANT* Type
                              ) PURE;

  virtual HRESULT __stdcall DateLastModified(
                              /*[out, retval]*/ VARIANT* Date
                              ) PURE;
};


interface IW3SpoofRuntime : public IUnknown
{
  virtual HRESULT __stdcall GetFile(IDispatch** ppdisp) PURE;
  virtual HRESULT __stdcall GetPropertyBag(BSTR Name, IW3SpoofPropertyBag** ppbag) PURE;
};

#ifdef __cplusplus
}
#endif

//-----------------------------------------------------------------------------
// W3Spoof Runtime Object Declarations
//-----------------------------------------------------------------------------
class CW3SRuntime : public IW3SpoofRuntime,
                    public IDispatch
{
  public:
    DECLAREIUNKNOWN();
    DECLAREIDISPATCH();

  public:
    // IW3SpoofRuntime
    HRESULT __stdcall GetFile(IDispatch** ppdisp);
    HRESULT __stdcall GetPropertyBag(BSTR Name, IW3SpoofPropertyBag** ppbag);

    CW3SRuntime();
   ~CW3SRuntime();

    HRESULT Terminate(void);

    static HRESULT Create(PRUNTIME* pprt);

  private:
    HRESULT    _Initialize(void);

    LONG       m_cRefs;
    PSTRINGMAP m_propertybags;
};


class CW3SPropertyBag : public IW3SpoofPropertyBag
{
  public :
    DECLAREIUNKNOWN();
    DECLAREIDISPATCH();

  public:
    HRESULT __stdcall Get(BSTR Name, VARIANT* Value);
    HRESULT __stdcall Set(BSTR Name, VARIANT Value);
    HRESULT __stdcall get_Expires(VARIANT* Expiry);
    HRESULT __stdcall put_Expires(VARIANT Expiry);
    HRESULT __stdcall Flush(void);

    CW3SPropertyBag();
   ~CW3SPropertyBag();

    HRESULT GetBagName(LPWSTR* ppwsz);
    HRESULT Terminate(void);

    static HRESULT Create(LPWSTR name, PPROPERTYBAG* ppbag);

  private:
    HRESULT    _Initialize(LPWSTR name);
    void       _Reset(void);
    BOOL       _IsStale(void);

    LONG       m_cRefs;
    LPWSTR     m_name;
    BOOL       m_stale;
    DWORD      m_expiry;
    DWORD      m_created;
    PSTRINGMAP m_propertybag;
};

class CW3SFile : public IW3SpoofFile
{
  public:
    DECLAREIUNKNOWN();
    DECLAREIDISPATCH();

  public:
    HRESULT __stdcall Open(BSTR Filename, VARIANT Mode, VARIANT* Success);
    HRESULT __stdcall Close(void);
    HRESULT __stdcall Write(VARIANT Data, VARIANT* Success);
    HRESULT __stdcall WriteLine(BSTR Line, VARIANT* Success);
    HRESULT __stdcall WriteBlankLine(VARIANT* Success);
    HRESULT __stdcall Read(VARIANT Bytes, VARIANT* Data);
    HRESULT __stdcall ReadAll(VARIANT* Data);
    HRESULT __stdcall Attributes(VARIANT* Attributes);
    HRESULT __stdcall Size(VARIANT* Size);
    HRESULT __stdcall Type(VARIANT* Type);
    HRESULT __stdcall DateLastModified(VARIANT* Date);

    CW3SFile();
   ~CW3SFile();

    static HRESULT Create(IW3SpoofFile** ppw3sf);
  
  private:
    void             _Cleanup(void);
    BOOL             _CacheHttpResponse(void);

    LONG             m_cRefs;
    BOOL             m_bFileOpened;
    BOOL             m_bReadOnly;
    BOOL             m_bAsciiData;
    BOOL             m_bHttpResponseCached;
    HANDLE           m_hFile;
    IWinHttpRequest* m_pWHR;
    VARIANT          m_vHttpResponse;
    DWORD            m_cHttpBytesRead;
    BHFI             m_bhfi;
};

#endif /* __W3SRT_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\tools\w3spoof\om\om.inc ===
!IF 0

Copyright (c) 1994  Microsoft Corporation

Module Name:

    w3spoof.inc

Abstract:

    Common makefile contents for w3spoof project

!ENDIF

!IFNDEF SDKINC
SDKINC=$(SDK_INC_PATH)
!ENDIF

!IFDEF LIBDIR
!ERROR LIBDIR already defined - choose new name
!ENDIF

LIBDIR=..\..\lib\$(_OBJ_DIR)
W3SPOOFINC=..\..\inc

#
# if TARGETPATH is not defined (in the paths that build libraries) then this
# is the default target path
#
!IFNDEF TARGETPATH
TARGETPATH=$(LIBDIR)
TARGETTYPE=LIBRARY
!ENDIF

#
# what it is that we're building
#
MAJORCOMP=w3spoof

USE_NOLIBS=1
#USE_LIBCMT=0
NO_NTDLL=1
#NO_BINPLACE=0
BINPLACE_PLACEFILE=..\..\binplace.txt

#
# Linker flags
#
WIN32_WINNT_VERSION=0x0500
#WIN32_WIN95_VERSION=0x0400

#
# compiler warning flags
#
MSC_WARNING_LEVEL=/W3 /WX

#
# compiler definitions
#
C_DEFINES=$(C_DEFINES) -DWIN32

CLEANINF = cleaninf.exe $(CLEANINF_FLAGS)

#
# Set debugging level
#
!IF "$(NTDEBUG)" != "" && "$(NTDEBUG)" != "retail" && "$(NTDEBUG)" != "ntsdnodbg"
C_DEFINES=$(C_DEFINES) -D_DEBUG
!ENDIF

!IF "$(__FULL_DEBUG__)" != "" && "$(__RELEASE_DEBUG__)" == ""
C_DEFINES=$(C_DEFINES) -D__FULL_DEBUG__
!IF "$(__DBG_TO_CONSOLE__)" == "1"
C_DEFINES=$(C_DEFINES) -D__DBG_TO_CONSOLE__
!ENDIF
!ENDIF

!IF "$(__RELEASE_DEBUG__)" != "" && "$(__FULL_DEBUG__)" == ""
C_DEFINES=$(C_DEFINES) -D__RELEASE_DEBUG__
!ENDIF


!IFNDEF W3SPOOF_PCH
PRECOMPILED_OPTION=/Fp..\..\inc\$(_OBJ_DIR)\*\common.pch /Yucommon.h
PRECOMPILED_CXX=1
!ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\tools\w3spoof\inc\w3sobj.h ===
/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Copyright (c) 2000  Microsoft Corporation

Module Name:

    w3sobj.h

Abstract:

    Header for the W3Spoof class & related functions, etc.
    
Author:

    Paul M Midgen (pmidge) 07-June-2000


Revision History:

    07-June-2000 pmidge
        Created

    17-July-2000 pmidge
        Added class factory & IW3Spoof interface.

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/

#ifndef _W3SOBJ_H_
#define _W3SOBJ_H_

#include "common.h"

class IOCTX
{
  public:
    IOCTX(IOTYPE iot, SOCKET s);
   ~IOCTX();

    IOTYPE Type(void);
    BOOL   AllocateWSABuffer(DWORD size, LPVOID pv);
    void   FreeWSABuffer(void);
    BOOL   ResizeWSABuffer(DWORD size);
    void   DisableIoCompletion(void);
    void   AddRef(void);
    void   Release(void);

  public:
    PIOCTX      pthis;
    OVERLAPPED  overlapped;
    SOCKET      socket;
    LPVOID      sockbuf;
    PHOSTINFO   local;
    PHOSTINFO   remote;
    LPWSTR      clientid;
    WSABUF*     pwsa;
    DWORD       bufsize;
    PSESSIONOBJ session;
    DWORD       bytes;
    DWORD       flags;
    DWORD       error;

  private:
    LONG       _cRefs;
    IOTYPE     _iot;
};

DWORD WINAPI ThreadFunc(LPVOID lpv);

class CW3Spoof : public IW3Spoof,
                 public IThreadPool,
                 public IW3SpoofClientSupport,
                 public IExternalConnection,
                 public IConnectionPointContainer
{
  public:
    DECLAREIUNKNOWN();

    // IConfig
    HRESULT __stdcall SetOption(DWORD dwOption, LPDWORD lpdwValue);
    HRESULT __stdcall GetOption(DWORD dwOption, LPDWORD lpdwValue);

    //
    // IW3Spoof
    //
    HRESULT __stdcall GetRuntime(IW3SpoofRuntime** pprt);
    HRESULT __stdcall GetTypeLibrary(ITypeLib** pptl);
    HRESULT __stdcall GetScriptEngine(IActiveScript** ppas);
    HRESULT __stdcall GetScriptPath(LPWSTR client, LPWSTR* path);
    HRESULT __stdcall Notify(LPWSTR clientid, PSESSIONOBJ pso, STATE state);
    HRESULT __stdcall WaitForUnload(void);
    HRESULT __stdcall Terminate(void);

    //
    // IThreadPool
    //
    HRESULT __stdcall GetStatus(PIOCTX* ppioc, LPBOOL pbQuit);
    HRESULT __stdcall GetSession(LPWSTR clientid, PSESSIONOBJ* ppso);
    HRESULT __stdcall Register(SOCKET s);

    DECLAREIDISPATCH();

    //
    // IW3SpoofClientSupport
    //
    HRESULT __stdcall RegisterClient(BSTR Client, BSTR ScriptPath);
    HRESULT __stdcall RevokeClient(BSTR Client);

    //
    // IExternalConnection
    //
    DWORD __stdcall AddConnection(DWORD type, DWORD reserved);
    DWORD __stdcall ReleaseConnection(DWORD type, DWORD reserved, BOOL bCloseIfLast);

    //
    // IConnectionPointContainer
    //
    HRESULT __stdcall EnumConnectionPoints(IEnumConnectionPoints** ppEnum);
    HRESULT __stdcall FindConnectionPoint(REFIID riid, IConnectionPoint** ppCP);

    //
    // Class methods
    //
    CW3Spoof();
   ~CW3Spoof();

    static HRESULT Create(IW3Spoof** ppw3s);

  private:
    DWORD            _Initialize(void);
    void             _LoadRegDefaults(void);
    BOOL             _InitializeThreads(void);
    void             _TerminateThreads(void);

    DWORD            _QueueAccept(void);
    BOOL             _CompleteAccept(PIOCTX pioc);
    BOOL             _DisconnectSocket(PIOCTX pioc, BOOL fNBGC);
    void             _SetState(STATE st);


  private:
    LONG             m_cRefs;
    LONG             m_cExtRefs;
    HANDLE           m_evtServerUnload;
    STATE            m_state;
    PRUNTIME         m_prt;
    ITypeLib*        m_ptl;
    IActiveScript*   m_pas;
    PSTRINGMAP       m_clientmap;
    PSTRINGMAP       m_sessionmap;
    DWORD            m_dwPoolSize;
    DWORD            m_dwMaxActiveThreads;
    USHORT           m_usServerPort;
    LPHANDLE         m_arThreads;
    SOCKET           m_sListen;
    HANDLE           m_hIOCP;
    LONG             m_AcceptQueueStatus;
    LONG             m_MaxQueuedAccepts;
    LONG             m_PendingAccepts;

  public:
    //
    // connection point object
    //
    class CW3SpoofEventsCP : public IConnectionPoint
    {
      public:
        //
        // IUnknown
        //
        HRESULT __stdcall QueryInterface(REFIID riid, void** ppv);
        ULONG   __stdcall AddRef(void);
        ULONG   __stdcall Release(void);

        //
        // IConnectionPoint
        //
        HRESULT __stdcall GetConnectionInterface(IID* pIID);
        HRESULT __stdcall GetConnectionPointContainer(IConnectionPointContainer** ppCPC);
        HRESULT __stdcall Advise(IUnknown* punkSink, LPDWORD pdwCookie);
        HRESULT __stdcall Unadvise(DWORD dwCookie);
        HRESULT __stdcall EnumConnections(IEnumConnections** ppEnum);

        //
        // object methods
        //
        CW3SpoofEventsCP()
        {
          m_cRefs        = 0L;
          m_cConnections = 0L;
          m_dwCookie     = 0L;
          m_pSite        = NULL;
          m_pSink        = NULL;
        }

       ~CW3SpoofEventsCP() {}

        void FireOnSessionOpen(LPWSTR clientid)
        {
          if(m_pSink)
          {
            m_pSink->OnSessionOpen(clientid);
          }
        }

        void FireOnSessionStateChange(LPWSTR clientid, STATE state)
        {
          if(m_pSink)
          {
            m_pSink->OnSessionStateChange(clientid, state);
          }
        }

        void FireOnSessionClose(LPWSTR clientid)
        {
          if(m_pSink)
          {
            m_pSink->OnSessionClose(clientid);
          }
        }

        void SetSite(IW3Spoof* pSite)
        {
          m_pSite = pSite;
        }

      private:
        LONG            m_cRefs;
        DWORD           m_cConnections;
        DWORD           m_dwCookie;
        IW3Spoof*       m_pSite;
        IW3SpoofEvents* m_pSink;
    };

    friend class CW3SpoofEventsCP;

  private:
    CW3SpoofEventsCP m_CP;
};

class CFactory : public IClassFactory
{
  public:
    //
    // IUnknown
    //
    HRESULT __stdcall QueryInterface(REFIID riid, void** ppv);
    ULONG   __stdcall AddRef(void);
    ULONG   __stdcall Release(void);

    //
    // IClassFactory
    //
    HRESULT __stdcall CreateInstance(IUnknown* pContainer, REFIID riid, void** ppv);
    HRESULT __stdcall LockServer(BOOL fLock);

    //
    // Class methods
    //
    CFactory();
   ~CFactory();

    static HRESULT Create(CFactory** ppCF);
    HRESULT Activate(void);
    HRESULT Terminate(void);

  private:
    HRESULT   _RegisterTypeLibrary(BOOL fMode);
    HRESULT   _RegisterServer(BOOL fMode);
    HRESULT   _RegisterClassFactory(BOOL fMode);
    IW3Spoof* m_pw3s;
    DWORD     m_dwCookie;
    LONG      m_cRefs;
    LONG      m_cLocks;
};

#endif /* _W3SOBJ_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\tools\w3spoof\inc\resources.h ===
/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Copyright (c) 2000  Microsoft Corporation

Module Name:

    resources.h

Abstract:

    Defines and other global manifests used in the W3Spoof project.
    
Author:

    Paul M Midgen (pmidge) 13-August-2000


Revision History:

    13-August-2000 pmidge
        Created

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/

#ifndef __RESOURCES_H__
#define __RESOURCES_H__

#define SHELLMESSAGE_W3SICON (WM_USER+12387)

#define INITIAL_DATA_BUFFER_SIZE 4096

#define SOCKET_CLOSE_ABORTIVE    0
#define SOCKET_CLOSE_GRACEFUL    1

#define CK_INVALID_KEY           0xFFFFFFFF
#define CK_NEW_CONNECTION        0x00000000
#define CK_NORMAL                0x00000001
#define CK_CANCEL_IO             0x00000002
#define CK_TERMINATE_THREAD      0x00000003

#define TPO_MAX_POOL_THREADS     0x00000001
#define TPO_MAX_ACTIVE_THREADS   0x00000002
#define TPO_SERVER_LISTEN_PORT   0x00000003
#define TPO_CONDITIONAL_ACCEPT   0x00000004

#define ERROR_FAILURE            0xFFFFF666

typedef DWORD (WINAPI *THREADFUNC)(LPVOID lpv);

#define DECLAREIUNKNOWN() \
    HRESULT __stdcall QueryInterface(REFIID riid, void** ppv); \
    ULONG   __stdcall AddRef(void); \
    ULONG   __stdcall Release(void); 

#define DECLAREIDISPATCH() \
    HRESULT __stdcall GetTypeInfoCount(UINT* pctinfo);  \
    HRESULT __stdcall GetTypeInfo(UINT index, LCID lcid, ITypeInfo** ppti); \
    HRESULT __stdcall GetIDsOfNames(REFIID riid, LPOLESTR* arNames, UINT cNames, LCID lcid, DISPID* arDispId); \
    HRESULT __stdcall Invoke(DISPID dispid, REFIID riid, LCID lcid, WORD flags, DISPPARAMS* pdp, VARIANT* pvr, EXCEPINFO* pei, UINT* pae);

#define DECLAREIPROVIDECLASSINFO() \
  HRESULT __stdcall GetClassInfo(ITypeInfo** ppti);

#define DECLAREIOBJECTWITHSITE() \
    HRESULT __stdcall SetSite(IUnknown* pUnkSite); \
    HRESULT __stdcall GetSite(REFIID riid, void** ppvSite);

#define SAFECLOSE(x) if((x!=INVALID_HANDLE_VALUE) && (x!=NULL)) { CloseHandle(x); x=NULL; }
#define SAFECLOSESOCKET(x) if(x!=INVALID_SOCKET) { closesocket(x); x=INVALID_SOCKET; }
#define SAFEDELETE(x) if(x) { delete x; x=NULL; }
#define SAFEDELETEBUF(x) if(DWORD(x)) {delete [] x; x=NULL;}
#define SAFERELEASE(x) if(x) { x->Release(); x=NULL; }
#define SAFETERMINATE(x) if(x) { x->Terminate(); }
#define SAFEDELETEBSTR(x) if(x) { SysFreeString(x); x=NULL; }
#define VALIDSOCKET(x) ((x!=INVALID_SOCKET) ? TRUE : FALSE)
#define VALIDDISPID(x) ((x!=DISPID_UNKNOWN) ? TRUE : FALSE)
#define SOCKADDRBUFSIZE (sizeof(SOCKADDR_IN)+16)
#define NEWVARIANT(x) VARIANT x; VariantInit(&x);
#define GETIOCTX(x) (x ? ((PIOCTX)((DWORD_PTR)x - sizeof(DWORD_PTR))) : NULL)

//
// forward decls
//

class CW3Spoof;

//
// typedefs
//

typedef class IOCTX*                 PIOCTX;
typedef class CSession               SESSIONOBJ;
typedef class CSession*              PSESSIONOBJ;
typedef class CSocket                SOCKETOBJ;
typedef class CSocket*               PSOCKETOBJ;
typedef class CRequest               REQUESTOBJ;
typedef class CRequest*              PREQUESTOBJ;
typedef class CResponse              RESPONSEOBJ;
typedef class CResponse*             PRESPONSEOBJ;
typedef class CUrl                   URLOBJ;
typedef class CUrl*                  PURLOBJ;
typedef class CHeaders               HEADERSOBJ;
typedef class CHeaders*              PHEADERSOBJ;
typedef class CEntity                ENTITYOBJ;
typedef class CEntity*               PENTITYOBJ;
typedef struct sockaddr_in           SOCKADDR_IN;
typedef struct sockaddr_in*          PSOCKADDR_IN;
typedef CRITICAL_SECTION             CRITSEC;
typedef LPCRITICAL_SECTION           PCRITSEC;
typedef BY_HANDLE_FILE_INFORMATION   BHFI;
typedef LPBY_HANDLE_FILE_INFORMATION LPBHFI;
typedef URL_COMPONENTSW              URLCOMP;
typedef LPURL_COMPONENTSW            PURLCOMP;

typedef struct _HOSTINFO
{
  char*   name;
  char*   addr;
  u_short port;
}
HOSTINFO, *PHOSTINFO;

typedef enum _state
{
  ST_CREATED,
  ST_OPENING,
  ST_OPEN,
  ST_CLOSING,
  ST_CLOSED,
  ST_ERROR
}
STATE, *PSTATE;

typedef enum _serverstate
{
  SS_START_STATE      = 0,
  SS_SOCKET_CONNECTED,
  SS_REQUEST_PENDING,
  SS_REQUEST_COMPLETE,
  SS_RESPONSE_PENDING,
  SS_RESPONSE_COMPLETE,
  SS_SOCKET_DISCONNECTED
}
SERVERSTATE, *PSERVERSTATE;

#define SCRIPTHANDLERS 5

typedef enum _tagScriptDispid
{
  Global    = -1,
  OnConnect = 0,
  OnDataAvailable,
  OnRequest,
  OnResponse,
  OnClose
}
SCRIPTDISPID, *PSCRIPTDISPID;

typedef enum _tagIOTYPE
{
  IOCT_CONNECT = 0,
  IOCT_RECV,
  IOCT_SEND,
  IOCT_DUMMY
}
IOTYPE, *PIOTYPE;

typedef struct _dispidtableentry
{
  DWORD  hash;
  DISPID dispid;
  LPWSTR name;
}
DISPIDTABLEENTRY, *PDISPIDTABLEENTRY;

#endif /* __RESOURCES_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\tools\w3spoof\om\entity\entity.cxx ===
/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Copyright (c) 2000  Microsoft Corporation

Module Name:

    entity.cxx

Abstract:

    Implements the Entity object.
    
Author:

    Paul M Midgen (pmidge) 13-November-2000


Revision History:

    13-November-2000 pmidge
        Created

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/

#include "common.h"

LPWSTR g_wszEntityObjectName = L"entity";

//-----------------------------------------------------------------------------
// CEntity methods
//-----------------------------------------------------------------------------
CEntity::CEntity():
  m_cRefs(1),
  m_pSite(NULL),
  m_pti(NULL),
  m_pbData(NULL),
  m_cData(0)
{
  DEBUG_TRACE(ENTITY, ("CEntity [%#x] created", this));
}


CEntity::~CEntity()
{
  DEBUG_TRACE(ENTITY, ("CEntity [%#x] deleted", this));
}


HRESULT
CEntity::Create(LPBYTE data, DWORD length, BOOL bReadOnly, PENTITYOBJ* ppentity)
{
  DEBUG_ENTER((
    DBG_ENTITY,
    rt_hresult,
    "CEntity::Create",
    "data=%#x; length=%d; bReadOnly=%d; ppentity=%#x",
    data,
    length,
    bReadOnly,
    ppentity
    ));

  HRESULT    hr  = S_OK;
  PENTITYOBJ peo = NULL;

  if( !ppentity )
  {
    hr = E_POINTER;
    goto quit;
  }
  
  if( peo = new ENTITYOBJ )
  {
    if( SUCCEEDED(peo->_Initialize(data, length, bReadOnly)) )
    {
      *ppentity = peo;
    }
    else
    {
      delete peo;
      *ppentity = NULL;
      hr        = E_FAIL;
    }
  }
  else
  {
    hr = E_OUTOFMEMORY;
  }

quit:

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
CEntity::_Initialize(LPBYTE data, DWORD length, BOOL bReadOnly)
{
  DEBUG_ENTER((
    DBG_ENTITY,
    rt_hresult,
    "CEntity::_Initialize",
    "this=%#x; data=%#x; length=%d; bReadOnly=%d",
    this,
    data,
    length,
    bReadOnly
    ));

  HRESULT hr = S_OK;

    m_bReadOnly = bReadOnly;
    m_cData     = length;

    if( m_cData )
    {
      m_pbData = new BYTE[m_cData];
      memcpy(m_pbData, data, m_cData);
    }
  
  DEBUG_LEAVE(hr);
  return hr;
}


void
CEntity::_Cleanup(void)
{
  DEBUG_TRACE(ENTITY, ("CEntity [%#x] cleaning up", this));

  m_cData = 0L;
  SAFEDELETEBUF(m_pbData);
}


void
CEntity::Terminate(void)
{
  DEBUG_TRACE(ENTITY, ("CEntity [%#x] terminating", this));

  m_bReadOnly = FALSE;
  SAFERELEASE(m_pSite);
  Release();
}


//-----------------------------------------------------------------------------
// IUnknown
//-----------------------------------------------------------------------------
HRESULT
__stdcall
CEntity::QueryInterface(REFIID riid, void** ppv)
{
  DEBUG_ENTER((
    DBG_REFCOUNT,
    rt_hresult,
    "CEntity::QueryInterface",
    "this=%#x; riid=%s; ppv=%#x",
    this,
    MapIIDToString(riid),
    ppv
    ));

  HRESULT hr = S_OK;

  if( !ppv )
  {
    hr = E_POINTER;
    goto quit;
  }

    if(
      IsEqualIID(riid, IID_IUnknown)  ||
      IsEqualIID(riid, IID_IDispatch) ||
      IsEqualIID(riid, IID_IEntity)
      )
    {
      *ppv = static_cast<IEntity*>(this);
    }
    else if( IsEqualIID(riid, IID_IProvideClassInfo) )
    {
      *ppv = static_cast<IProvideClassInfo*>(this);
    }
    else if( IsEqualIID(riid, IID_IObjectWithSite) )
    {
      *ppv = static_cast<IObjectWithSite*>(this);
    }
    else
    {
      *ppv = NULL;
      hr   = E_NOINTERFACE;
    }

  if( SUCCEEDED(hr) )
  {
    reinterpret_cast<IUnknown*>(*ppv)->AddRef();
  }

quit:

  DEBUG_LEAVE(hr);
  return hr;
}


ULONG
__stdcall
CEntity::AddRef(void)
{
  InterlockedIncrement(&m_cRefs);
  DEBUG_ADDREF("CEntity", m_cRefs);
  return m_cRefs;
}


ULONG
__stdcall
CEntity::Release(void)
{
  InterlockedDecrement(&m_cRefs);
  DEBUG_RELEASE("CEntity", m_cRefs);

  if( m_cRefs == 0 )
  {
    DEBUG_FINALRELEASE("CEntity");
    _Cleanup();
    SAFERELEASE(m_pti);
    delete this;
    return 0;
  }

  return m_cRefs;
}


//-----------------------------------------------------------------------------
// IProvideClassInfo
//-----------------------------------------------------------------------------
HRESULT
__stdcall
CEntity::GetClassInfo(ITypeInfo** ppti)
{
  DEBUG_ENTER((
    DBG_ENTITY,
    rt_hresult,
    "CEntity::GetClassInfo",
    "this=%#x; ppti=%#x",
    this,
    ppti
    ));

  HRESULT hr = S_OK;


  if( ppti )
  {
    m_pti->AddRef();
    *ppti = m_pti;
  }
  else
  {
    hr = E_POINTER;
  }

  DEBUG_LEAVE(hr);
  return hr;
}


//-----------------------------------------------------------------------------
// IObjectWithSite
//-----------------------------------------------------------------------------
HRESULT
__stdcall
CEntity::SetSite(IUnknown* pUnkSite)
{
  DEBUG_ENTER((
    DBG_ENTITY,
    rt_hresult,
    "CEntity::SetSite",
    "this=%#x; pUnkSite=%#x",
    this,
    pUnkSite
    ));

  HRESULT            hr         = S_OK;
  IActiveScriptSite* pias       = NULL;
  IObjectWithSite*   pcontainer = NULL;

    if( !pUnkSite )
    {
      hr = E_INVALIDARG;
    }
    else
    {
      SAFERELEASE(m_pSite);
      SAFERELEASE(m_pti);

      m_pSite = pUnkSite;
      m_pSite->AddRef();

      hr = m_pSite->QueryInterface(IID_IObjectWithSite, (void**) &pcontainer);

      if( SUCCEEDED(hr) )
      {
        hr = pcontainer->GetSite(IID_IActiveScriptSite, (void**) &pias);

        if( SUCCEEDED(hr) )
        {
          hr = pias->GetItemInfo(
                       g_wszEntityObjectName,
                       SCRIPTINFO_ITYPEINFO,
                       NULL,
                       &m_pti
                       );
        }
      }
    }

  SAFERELEASE(pcontainer);
  SAFERELEASE(pias);

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CEntity::GetSite(REFIID riid, void** ppvSite)
{
  DEBUG_ENTER((
    DBG_ENTITY,
    rt_hresult,
    "CEntity::GetSite",
    "this=%#x; riid=%s; ppvSite=%#x",
    this,
    MapIIDToString(riid),
    ppvSite
    ));

  HRESULT hr = S_OK;

    if( !ppvSite )
    {
      hr = E_POINTER;
    }
    else
    {
      if( m_pSite )
      {
        hr = m_pSite->QueryInterface(riid, ppvSite);
      }
    }

  DEBUG_LEAVE(hr);
  return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\tools\w3spoof\om\entity\methods.cxx ===
/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Copyright (c) 2000  Microsoft Corporation

Module Name:

    methods.cxx

Abstract:

    Implements methods part of the Entity object's dual interface.
    
Author:

    Paul M Midgen (pmidge) 13-November-2000


Revision History:

    13-November-2000 pmidge
        Created

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/

#include "common.h"

HRESULT
__stdcall
CEntity::get_Parent(IDispatch **ppdisp)
{
  DEBUG_ENTER((
    DBG_ENTITY,
    rt_hresult,
    "CEntity::get_Parent",
    "this=%#x; ppdisp=%#x",
    this,
    ppdisp
    ));

  HRESULT hr = S_OK;

    if( ppdisp )
    {
      if( m_pSite )
      {
        hr = m_pSite->QueryInterface(IID_IDispatch, (void**) ppdisp);
      }
      else
      {
        *ppdisp = NULL;
        hr      = E_UNEXPECTED;
      }
    }
    else
    {
      hr = E_POINTER;
    }

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CEntity::get_Length(VARIANT *Length)
{
  DEBUG_ENTER((
    DBG_ENTITY,
    rt_hresult,
    "CEntity::get_Length",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

    if( Length )
    {
      V_VT(Length)  = VT_UI4;
      V_UI4(Length) = m_cData;
    }
    else
    {
      hr = E_POINTER;
    }

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CEntity::Get(VARIANT *Entity)
{
  DEBUG_ENTER((
    DBG_ENTITY,
    rt_hresult,
    "CEntity::Get",
    "this=%#x",
    this
    ));

  HRESULT    hr  = S_OK;
  SAFEARRAY* psa = NULL;

  if( !Entity )
  {
    hr = E_POINTER;
  }
  else
  {
    if( m_cData )
    {
      DEBUG_DATA_DUMP(ENTITY, ("entity body", m_pbData, m_cData));

      psa = SafeArrayCreateVector(VT_UI1, 1, m_cData);

      if( psa )
      {
        memcpy((LPBYTE) psa->pvData, m_pbData, m_cData);

        V_VT(Entity)    = VT_ARRAY | VT_UI1;
        V_ARRAY(Entity) = psa;
      }
      else
      {
        hr = E_FAIL;
      }
    }
    else
    {
      V_VT(Entity) = VT_NULL;
    }
  }

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CEntity::Set(VARIANT Entity)
{
  DEBUG_ENTER((
    DBG_ENTITY,
    rt_hresult,
    "CEntity::Set",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

    if( !m_bReadOnly )
    {
      _Cleanup();

      if( !__isempty(Entity) )
      {
        hr = ProcessVariant(&Entity, &m_pbData, &m_cData, NULL);
      }
    }
    else
    {
      hr = E_ACCESSDENIED;
    }
  
  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CEntity::Compress(BSTR Method)
{
  DEBUG_ENTER((
    DBG_ENTITY,
    rt_hresult,
    "CEntity::Compress",
    "this=%#x",
    this
    ));

  HRESULT hr = E_NOTIMPL;

  //
  // TODO: implementation
  //

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CEntity::Decompress(VARIANT Method)
{
  DEBUG_ENTER((
    DBG_ENTITY,
    rt_hresult,
    "CEntity::Decompress",
    "this=%#x",
    this
    ));

  HRESULT hr = E_NOTIMPL;

  //
  // TODO: implementation
  //

  DEBUG_LEAVE(hr);
  return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\tools\w3spoof\om\headers\headers.cxx ===
/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Copyright (c) 2000  Microsoft Corporation

Module Name:

    headers.cxx

Abstract:

    Implements the Headers object.
    
Author:

    Paul M Midgen (pmidge) 13-November-2000


Revision History:

    13-November-2000 pmidge
        Created

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/

#include "common.h"

LPWSTR g_wszHeadersObjectName = L"headers";

//-----------------------------------------------------------------------------
// CHeaders methods
//-----------------------------------------------------------------------------
CHeaders::CHeaders():
  m_cRefs(1),
  m_pSite(NULL),
  m_pti(NULL),
  m_bReadOnly(FALSE),
  m_headerlist(NULL),
  m_pchHeaders(NULL)
{
  DEBUG_TRACE(HEADERS, ("CHeaders [%#x] created", this));
}


CHeaders::~CHeaders()
{
  DEBUG_TRACE(HEADERS, ("CHeaders [%#x] deleted", this));
}


HRESULT
CHeaders::Create(CHAR* headers, BOOL bReadOnly, PHEADERSOBJ* ppheaders)
{
  DEBUG_ENTER((
    DBG_HEADERS,
    rt_hresult,
    "CHeaders::Create",
    "headers=%#x; bReadOnly=%d; ppheaders=%#x",
    headers,
    bReadOnly,
    ppheaders
    ));

  HRESULT     hr  = S_OK;
  PHEADERSOBJ pho = NULL;

  if( !headers )
  {
    hr = E_INVALIDARG;
    goto quit;
  }

  if( !ppheaders )
  {
    hr = E_POINTER;
    goto quit;
  }
  
  if( pho = new HEADERSOBJ )
  {
    if( SUCCEEDED(pho->_Initialize(headers, bReadOnly)) )
    {
      *ppheaders = pho;
    }
    else
    {
      delete pho;
      *ppheaders = NULL;
      hr         = E_FAIL;
    }
  }
  else
  {
    hr = E_OUTOFMEMORY;
  }

quit:

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
CHeaders::_Initialize(CHAR* headers, BOOL bReadOnly)
{
  DEBUG_ENTER((
    DBG_HEADERS,
    rt_hresult,
    "CHeaders::_Initialize",
    "this=%#x; headers=%#x; bReadOnly=%d",
    this,
    headers,
    bReadOnly
    ));

  HRESULT hr = S_OK;

  if( !headers )
  {
    hr = E_INVALIDARG;
    goto quit;
  }

  m_bReadOnly  = bReadOnly;
  m_headerlist = new HEADERLIST;

  m_headerlist->SetClearFunction(BSTRKiller);

  hr = _ParseHeaders(headers);

quit:
  
  DEBUG_LEAVE(hr);
  return hr;
}


void
CHeaders::_Cleanup(void)
{
  DEBUG_TRACE(HEADERS, ("CHeaders [%#x] cleaning up", this));

  m_headerlist->Clear();
  SAFEDELETE(m_headerlist);
  SAFEDELETEBUF(m_pchHeaders);
}


void
CHeaders::Terminate(void)
{
  DEBUG_TRACE(HEADERS, ("CHeaders [%#x] terminating", this));

  m_bReadOnly = FALSE;
  SAFERELEASE(m_pSite);
  Release();
}


HRESULT
CHeaders::_ParseHeaders(CHAR* headers)
{
  DEBUG_ENTER((
    DBG_HEADERS,
    rt_hresult,
    "CHeaders::_ParseHeaders",
    "this=%#x; headers=%#x",
    this,
    headers
    ));

  HRESULT hr    = S_OK;
  LPSTR   name  = NULL;
  LPSTR   value = NULL;

  if( headers )
  {
    m_pchHeaders = __strdup(headers);
  }
  else
  {
    DEBUG_TRACE(HEADERS, ("no headers present"));
    hr = E_FAIL;
    goto quit;
  }

  name = strtok(headers, ":");

  while( name )
  {
    value = strtok(NULL, "\r\n");

    if( value )
    {
      value += (value[0] == ' ') ? 1 : 0;

      m_headerlist->Insert(name, __ansitobstr(value));
      name = strtok(NULL, ":\r\n");
    }
    else
    {
      // this is an error condition?

      name = NULL;
    }
  }

quit:

  DEBUG_LEAVE(hr);
  return hr;
}


//-----------------------------------------------------------------------------
// IUnknown
//-----------------------------------------------------------------------------
HRESULT
__stdcall
CHeaders::QueryInterface(REFIID riid, void** ppv)
{
  DEBUG_ENTER((
    DBG_REFCOUNT,
    rt_hresult,
    "CHeaders::QueryInterface",
    "this=%#x; riid=%s; ppv=%#x",
    this,
    MapIIDToString(riid),
    ppv
    ));

  HRESULT hr = S_OK;

  if( !ppv )
  {
    hr = E_POINTER;
    goto quit;
  }

    if(
      IsEqualIID(riid, IID_IUnknown)  ||
      IsEqualIID(riid, IID_IDispatch) ||
      IsEqualIID(riid, IID_IHeaders)
      )
    {
      *ppv = static_cast<IHeaders*>(this);
    }
    else if( IsEqualIID(riid, IID_IProvideClassInfo) )
    {
      *ppv = static_cast<IProvideClassInfo*>(this);
    }
    else if( IsEqualIID(riid, IID_IObjectWithSite) )
    {
      *ppv = static_cast<IObjectWithSite*>(this);
    }
    else
    {
      *ppv = NULL;
      hr   = E_NOINTERFACE;
    }

  if( SUCCEEDED(hr) )
  {
    reinterpret_cast<IUnknown*>(*ppv)->AddRef();
  }

quit:

  DEBUG_LEAVE(hr);
  return hr;
}


ULONG
__stdcall
CHeaders::AddRef(void)
{
  InterlockedIncrement(&m_cRefs);
  DEBUG_ADDREF("CHeaders", m_cRefs);
  return m_cRefs;
}


ULONG
__stdcall
CHeaders::Release(void)
{
  InterlockedDecrement(&m_cRefs);
  DEBUG_RELEASE("CHeaders", m_cRefs);

  if( m_cRefs == 0 )
  {
    DEBUG_FINALRELEASE("CHeaders");
    _Cleanup();
    SAFERELEASE(m_pti);
    delete this;
    return 0;
  }

  return m_cRefs;
}


//-----------------------------------------------------------------------------
// IProvideClassInfo
//-----------------------------------------------------------------------------
HRESULT
__stdcall
CHeaders::GetClassInfo(ITypeInfo** ppti)
{
  DEBUG_ENTER((
    DBG_HEADERS,
    rt_hresult,
    "CHeaders::GetClassInfo",
    "this=%#x; ppti=%#x",
    this,
    ppti
    ));

  HRESULT hr = S_OK;

    if( ppti )
    {
      m_pti->AddRef();
      *ppti = m_pti;
    }
    else
    {
      hr = E_POINTER;
    }

  DEBUG_LEAVE(hr);
  return hr;
}


//-----------------------------------------------------------------------------
// IObjectWithSite
//-----------------------------------------------------------------------------
HRESULT
__stdcall
CHeaders::SetSite(IUnknown* pUnkSite)
{
  DEBUG_ENTER((
    DBG_HEADERS,
    rt_hresult,
    "CHeaders::SetSite",
    "this=%#x; pUnkSite=%#x",
    this,
    pUnkSite
    ));

  HRESULT            hr         = S_OK;
  IActiveScriptSite* pias       = NULL;
  IObjectWithSite*   pcontainer = NULL;

    if( !pUnkSite )
    {
      hr = E_INVALIDARG;
    }
    else
    {
      SAFERELEASE(m_pSite);
      SAFERELEASE(m_pti);

      m_pSite = pUnkSite;
      m_pSite->AddRef();

      hr = m_pSite->QueryInterface(IID_IObjectWithSite, (void**) &pcontainer);

      if( SUCCEEDED(hr) )
      {
        hr = pcontainer->GetSite(IID_IActiveScriptSite, (void**) &pias);

        if( SUCCEEDED(hr) )
        {
          hr = pias->GetItemInfo(
                       g_wszHeadersObjectName,
                       SCRIPTINFO_ITYPEINFO,
                       NULL,
                       &m_pti
                       );
        }
      }
    }

  SAFERELEASE(pcontainer);
  SAFERELEASE(pias);

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CHeaders::GetSite(REFIID riid, void** ppvSite)
{
  DEBUG_ENTER((
    DBG_HEADERS,
    rt_hresult,
    "CHeaders::GetSite",
    "this=%#x; riid=%s; ppvSite=%#x",
    this,
    MapIIDToString(riid),
    ppvSite
    ));

  HRESULT hr = S_OK;

    if( !ppvSite )
    {
      hr = E_POINTER;
    }
    else
    {
      hr = m_pSite->QueryInterface(riid, ppvSite);
    }

  DEBUG_LEAVE(hr);
  return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\tools\w3spoof\om\request\methods.cxx ===
/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Copyright (c) 2000  Microsoft Corporation

Module Name:

    methods.cxx

Abstract:

    Implements methods part of the Request object's dual interface.
    
Author:

    Paul M Midgen (pmidge) 03-November-2000


Revision History:

    03-November-2000 pmidge
        Created

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/

#include "common.h"

HRESULT
__stdcall
CRequest::get_Parent(IDispatch **ppdisp)
{
  DEBUG_ENTER((
    DBG_REQUEST,
    rt_hresult,
    "CRequest::get_Parent",
    "this=%#x; ppdisp=%#x",
    this,
    ppdisp
    ));

  HRESULT hr = S_OK;

    if( !ppdisp )
    {
      hr = E_POINTER;
    }
    else
    {
      if( m_pSite )
      {
        hr = m_pSite->QueryInterface(IID_IDispatch, (void**) ppdisp);
      }
      else
      {
        *ppdisp = NULL;
        hr      = E_UNEXPECTED;
      }
    }

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CRequest::get_Headers(IDispatch **ppdisp)
{
  DEBUG_ENTER((
    DBG_REQUEST,
    rt_hresult,
    "CRequest::get_Headers",
    "this=%#x; ppdisp=%#x",
    this,
    ppdisp
    ));

  HRESULT hr = S_OK;

    if( !ppdisp )
    {
      hr = E_POINTER;
    }
    else
    {
      if( m_headersobj )
      {
        hr = m_headersobj->QueryInterface(IID_IDispatch, (void**) ppdisp);
      }
      else
      {
        *ppdisp = NULL;
        hr      = E_UNEXPECTED;
      }
    }

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CRequest::get_Entity(IDispatch **ppdisp)
{
  DEBUG_ENTER((
    DBG_REQUEST,
    rt_hresult,
    "CRequest::get_Entity",
    "this=%#x; ppdisp=%#x",
    this,
    ppdisp
    ));

  HRESULT hr = S_OK;

    if( !ppdisp )
    {
      hr = E_POINTER;
    }
    else
    {
      if( m_entityobj )
      {
        hr = m_entityobj->QueryInterface(IID_IDispatch, (void**) ppdisp);
      }
      else
      {
        *ppdisp = NULL;
        hr      = E_UNEXPECTED;
      }
    }

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CRequest::get_Url(IDispatch **ppdisp)
{
  DEBUG_ENTER((
    DBG_REQUEST,
    rt_hresult,
    "CRequest::get_Url",
    "this=%#x; ppdisp=%#x",
    this,
    ppdisp
    ));

  HRESULT hr = S_OK;

    if( !ppdisp )
    {
      hr = E_POINTER;
    }
    else
    {
      if( m_urlobj )
      {
        hr = m_urlobj->QueryInterface(IID_IDispatch, (void**) ppdisp);
      }
      else
      {
        *ppdisp = NULL;
        hr      = E_UNEXPECTED;
      }
    }

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CRequest::get_Verb(BSTR *Verb)
{
  DEBUG_ENTER((
    DBG_REQUEST,
    rt_hresult,
    "CRequest::get_Verb",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

    if( !Verb )
    {
      hr = E_POINTER;
    }
    else
    {
      *Verb = __widetobstr(m_wszVerb);
    }

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CRequest::get_HttpVersion(BSTR *HttpVersion)
{
  DEBUG_ENTER((
    DBG_REQUEST,
    rt_hresult,
    "CRequest::get_HttpVersion",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

    if( !HttpVersion )
    {
      hr = E_POINTER;
    }
    else
    {
      *HttpVersion = __widetobstr(m_wszHTTPVersion);
    }

  DEBUG_LEAVE(hr);
  return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\tools\w3spoof\om\headers\dispatch.cxx ===
/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Copyright (c) 2000  Microsoft Corporation

Module Name:

    dispatch.cxx

Abstract:

    Implements the IDispatch interface for the Headers object.
    
Author:

    Paul M Midgen (pmidge) 13-November-2000


Revision History:

    13-November-2000 pmidge
        Created

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/

#include "common.h"

//
// WARNING: do not modify these values. use disphash.exe to generate
//          new values.
//
DISPIDTABLEENTRY g_HeadersDisptable[] =
{
  0x00021b1c,   DISPID_HEADERS_PARENT,      L"parent",
  0x00003f5f,   DISPID_HEADERS_SET,         L"set",
  0x00003b7b,   DISPID_HEADERS_GET,         L"get",
  0x00104b18,   DISPID_HEADERS_GETHEADER,   L"getheader",
  0x00113b84,   DISPID_HEADERS_SETHEADER,   L"setheader"
};

DWORD g_cHeadersDisptable = (sizeof(g_HeadersDisptable) / sizeof(DISPIDTABLEENTRY));


//-----------------------------------------------------------------------------
// IDispatch
//-----------------------------------------------------------------------------
HRESULT
__stdcall
CHeaders::GetTypeInfoCount(UINT* pctinfo)
{
  DEBUG_ENTER((
    DBG_DISPATCH,
    rt_hresult,
    "CHeaders::GetTypeInfoCount",
    "this=%#x; pctinfo=%#x",
    this,
    pctinfo
    ));

  HRESULT hr = S_OK;

    if( !pctinfo )
    {
      hr = E_POINTER;
    }
    else
    {
      *pctinfo = 1;
    }

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CHeaders::GetTypeInfo(UINT index, LCID lcid, ITypeInfo** ppti)
{
  DEBUG_ENTER((
    DBG_DISPATCH,
    rt_hresult,
    "CHeaders::GetTypeInfo",
    "this=%#x; index=%#x; lcid=%#x; ppti=%#x",
    this,
    index,
    lcid,
    ppti
    ));

  HRESULT hr   = S_OK;

  if( !ppti )
  {
    hr = E_POINTER;
  }
  else
  {
    if( index != 0 )
    {
      hr    = DISP_E_BADINDEX;
      *ppti = NULL;
    }
    else
    {
      hr = GetClassInfo(ppti);
    }
  }

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CHeaders::GetIDsOfNames(REFIID riid, LPOLESTR* arNames, UINT cNames, LCID lcid, DISPID* arDispId)
{
  DEBUG_ENTER((
    DBG_DISPATCH,
    rt_hresult,
    "CHeaders::GetIDsOfNames",
    "this=%#x; riid=%s; arNames=%#x; cNames=%d; lcid=%#x; arDispId=%#x",
    this,
    MapIIDToString(riid),
    arNames,
    cNames,
    lcid,
    arDispId
    ));

  HRESULT hr = S_OK;
  UINT    n  = 0L;

  if( !IsEqualIID(riid, IID_NULL) )
  {
    hr = E_INVALIDARG;
    goto quit;
  }

  while( n < cNames )
  {
    arDispId[n] = GetDispidFromName(g_HeadersDisptable, g_cHeadersDisptable, arNames[n]);
    ++n;
  }

quit:

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CHeaders::Invoke(DISPID dispid, REFIID riid, LCID lcid, WORD flags, DISPPARAMS* pdp, VARIANT* pvr, EXCEPINFO* pei, UINT* pae)
{
  DEBUG_ENTER((
    DBG_DISPATCH,
    rt_hresult,
    "CHeaders::Invoke",
    "this=%#x; dispid=%s; riid=%s; lcid=%#x; flags=%#x; pdp=%#x; pvr=%#x; pei=%#x; pae=%#x",
    this,
    MapDispidToString(dispid),
    MapIIDToString(riid),
    lcid,
    flags,
    pdp, pvr,
    pei, pae
    ));

  HRESULT hr = S_OK;

  hr = ValidateDispatchArgs(riid, pdp, pvr, pae);

    if( FAILED(hr) )
      goto quit;

  switch( dispid )
  {
    case DISPID_HEADERS_PARENT :
      {
        hr = ValidateInvokeFlags(flags, DISPATCH_PROPERTYGET, TRUE);

        if( SUCCEEDED(hr) )
        {
          if( pvr )
          {
            V_VT(pvr) = VT_DISPATCH;
            hr        = get_Parent(&V_DISPATCH(pvr));
          }
        }
      }
      break;

    case DISPID_HEADERS_SET :
      {
        hr = ValidateInvokeFlags(flags, DISPATCH_METHOD, FALSE);

        if( SUCCEEDED(hr) )
        {
          hr = ValidateArgCount(pdp, 1, FALSE, 0);

          if( SUCCEEDED(hr) )
          {
            hr = Set(&pdp->rgvarg[0]);
          }
        }
      }
      break;

    case DISPID_HEADERS_GET :
      {
        hr = ValidateInvokeFlags(flags, DISPATCH_METHOD, FALSE);

        if( SUCCEEDED(hr) )
        {
          if( pvr )
          {
            V_VT(pvr) = VT_BSTR;
            hr        = Get(&V_BSTR(pvr));
          }
        }
      }
      break;

    case DISPID_HEADERS_GETHEADER :
      {
        hr = ValidateInvokeFlags(flags, DISPATCH_METHOD, FALSE);

        if( SUCCEEDED(hr) )
        {
          hr = ValidateArgCount(pdp, 1, FALSE, 0);

          if( SUCCEEDED(hr) )
          {
            if( pvr )
            {
              hr = GetHeader(
                     V_BSTR(&pdp->rgvarg[0]),
                     pvr
                     );
            }
          }
        }
      }
      break;

    case DISPID_HEADERS_SETHEADER :
      {
        NEWVARIANT(name);
        NEWVARIANT(value);

        hr = ValidateInvokeFlags(flags, DISPATCH_METHOD, FALSE);

        if( SUCCEEDED(hr) )
        {
          hr = ValidateArgCount(pdp, 1, TRUE, 1);

          if( SUCCEEDED(hr) )
          {
            hr = DispGetParam(pdp, 0, VT_BSTR, &name, pae);
            
            if( SUCCEEDED(hr) )
            {
              hr = DispGetParam(pdp, 1, VT_BSTR, &value, pae);
              
              hr = SetHeader(
                     V_BSTR(&name),
                     (SUCCEEDED(hr) ? &value : NULL)
                     );
            }

            VariantClear(&name);
            VariantClear(&value);
          }
        }
      }
      break;

    default : hr = DISP_E_MEMBERNOTFOUND;
  }

quit:

  if( FAILED(hr) )
  {
    hr = HandleDispatchError(L"headers object", pei, hr);
  }

  DEBUG_LEAVE(hr);
  return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\tools\w3spoof\om\request\request.cxx ===
/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Copyright (c) 2000  Microsoft Corporation

Module Name:

    request.cxx

Abstract:

    Implements the Request object.
    
Author:

    Paul M Midgen (pmidge) 03-November-2000


Revision History:

    03-November-2000 pmidge
        Created

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/

#include "common.h"

LPWSTR g_wszRequestObjectName = L"request";

//-----------------------------------------------------------------------------
// CRequest methods
//-----------------------------------------------------------------------------
CRequest::CRequest():
  m_cRefs(1),
  m_pSite(NULL),
  m_wszVerb(NULL),
  m_wszHTTPVersion(NULL),
  m_urlobj(NULL),
  m_headersobj(NULL),
  m_entityobj(NULL)
{
  DEBUG_TRACE(REQUEST, ("CRequest [%#x] created", this));
}


CRequest::~CRequest()
{
  DEBUG_TRACE(REQUEST, ("CRequest [%#x] deleted", this));
}


HRESULT
CRequest::Create(CHAR* request, DWORD len, PREQUESTOBJ* ppreq)
{
  DEBUG_ENTER((
    DBG_REQUEST,
    rt_hresult,
    "CRequest::Create",
    "request=%#x; len=%d; ppreq=%#x",
    request,
    len,
    ppreq
    ));

  HRESULT     hr  = S_OK;
  PREQUESTOBJ pro = NULL;

  if( !request || (len == 0) )
  {
    hr = E_INVALIDARG;
    goto quit;
  }

  if( !ppreq )
  {
    hr = E_POINTER;
    goto quit;
  }
  
  if( pro = new REQUESTOBJ )
  {
    if( SUCCEEDED(pro->_Initialize(request, len)) )
    {
      *ppreq = pro;
    }
    else
    {
      delete pro;
      *ppreq = NULL;
      hr     = E_FAIL;
    }
  }
  else
  {
    hr = E_OUTOFMEMORY;
  }

quit:

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
CRequest::_Initialize(CHAR* request, DWORD len)
{
  DEBUG_ENTER((
    DBG_REQUEST,
    rt_hresult,
    "CRequest::_Initialize",
    "this=%#x; request=%#x; len=%d",
    this,
    request,
    len
    ));

  HRESULT hr            = S_OK;
  BOOL    bCracked      = FALSE;
  LPSTR*  arParts       = NULL;
  LPSTR   reqline       = NULL;
  LPSTR   headers       = NULL;
  LPSTR   entity        = NULL;
  DWORD   contentlength = 0L;


  bCracked = _CrackRequest(request, len, &reqline, &headers, &entity, &contentlength);

    if( !bCracked )
    {
      DEBUG_TRACE(REQUEST, ("failed to crack request data"));
      hr = E_FAIL;
      goto quit;
    }

  arParts = _CrackRequestLine(reqline, len);

    if( !arParts )
    {
      DEBUG_TRACE(REQUEST, ("failed to crack the request line"));
      hr = E_FAIL;
      goto quit;
    }
    else
    {
      m_wszVerb        = __ansitowide(arParts[0]);
      m_wszHTTPVersion = __ansitowide(arParts[2]);
    }

  hr = URLOBJ::Create(arParts[1], TRUE, &m_urlobj);

    if( FAILED(hr) )
    {
      DEBUG_TRACE(REQUEST, ("failed to create url object"));
      goto quit;
    }

  hr = HEADERSOBJ::Create(headers, TRUE, &m_headersobj);

    if( FAILED(hr) )
    {
      DEBUG_TRACE(REQUEST, ("failed to create headers object"));
      goto quit;
    }

  if( entity && contentlength )
  {
    hr = ENTITYOBJ::Create((LPBYTE) entity, contentlength, TRUE, &m_entityobj);
    
    if( FAILED(hr) )
    {
      DEBUG_TRACE(REQUEST, ("no entity object was created"));
      hr = S_OK;
    }
  }

quit:

  SAFEDELETEBUF(arParts);

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
CRequest::_SiteMemberObjects(void)
{
  HRESULT          hr    = NULL;
  IObjectWithSite* piows = NULL;

  if( m_urlobj )
  {
    hr = m_urlobj->QueryInterface(IID_IObjectWithSite, (void**) &piows);

      if( SUCCEEDED(hr) )
      {
        piows->SetSite(dynamic_cast<IRequest*>(this));
        SAFERELEASE(piows);
      }
      else
      {
        goto quit;
      }
  }

  if( m_headersobj )
  {
    hr = m_headersobj->QueryInterface(IID_IObjectWithSite, (void**) &piows);

    if( SUCCEEDED(hr) )
    {
      piows->SetSite(dynamic_cast<IRequest*>(this));
      SAFERELEASE(piows);
    }
    else
    {
      goto quit;
    }
  }

  if( m_entityobj )
  {
    hr = m_entityobj->QueryInterface(IID_IObjectWithSite, (void**) &piows);

    if( SUCCEEDED(hr) )
    {
      piows->SetSite(dynamic_cast<IRequest*>(this));
      SAFERELEASE(piows);
    }
  }

quit:

  return hr;
}


void
CRequest::_Cleanup(void)
{
  DEBUG_TRACE(REQUEST, ("CRequest [%#x] cleaning up", this));

  SAFEDELETEBUF(m_wszVerb);
  SAFEDELETEBUF(m_wszHTTPVersion);
}


void
CRequest::Terminate(void)
{
  DEBUG_TRACE(REQUEST, ("CRequest [%#x] terminating", this));

  SAFERELEASE(m_pSite);
  SAFETERMINATE(m_urlobj);
  SAFETERMINATE(m_headersobj);
  SAFETERMINATE(m_entityobj);
  Release();
}


BOOL
CRequest::_CrackRequest(LPSTR request, DWORD len, LPSTR* reqline, LPSTR* headers, LPSTR* entity, LPDWORD contentlength)
//
// what: null delimits the three major chunks of a request
//
// input: request       - the request buffer
//        len           - the length of the request buffer
//        reqline       - [out] the request line
//        headers       - [out] the header blob
//        entity        - [out] the entity blob
//        contentlength - [out] length of the entity blob
//
// returns: true if the request was processed, false if the request was empty
//
// request format: reqline CRLF headers CRLF CRLF entity
//
{
  BOOL  bCracked  = TRUE;
  LPSTR token     = NULL;
  DWORD bytesleft = 0L;

  if( request )
  {
    *reqline = request;
    token    = strstr(request, "\r\n");
    
    // get the request line, there MUST be one of these.
    if( token )
    {
      memset(token, '\0', 2);
      token       += 2;
      bytesleft    = len - (token-request);
      
      // get the request headers, they MUST exist.
      if( bytesleft )
      {
        *headers = token;
        token    = strstr(token, "\r\n\r\n");
      
        if( token )
        {
          // delimit the header blob and see if there's an entity...
          // there needn't be an entity for this function to succeed.
          memset(token, '\0', 4);
          token       += 4;
          bytesleft    = len - (token-request);

          *contentlength = bytesleft;

          if( bytesleft )
          {
            *entity = token;
          }
        }
      }
      else
      {
        DEBUG_TRACE(REQUEST, ("couldn\'t find the request headers!"));
        bCracked = FALSE;
      }
    }
    else
    {
      DEBUG_TRACE(REQUEST, ("couldn\'t find the request line!"));
      bCracked = FALSE;
    }
  }
  else
  {
    DEBUG_TRACE(REQUEST, ("can\'t crack empty request"));
    bCracked = FALSE;
  }

  return bCracked;
}


LPSTR*
CRequest::_CrackRequestLine(CHAR* buf, DWORD len)
//
// what: cracks the http request line from a buffered request
//
// input: buf - the request buffer
//        len - the length of the buffer, not the data
//
// returns: array of three string pointers to the null-delimited pieces
//
//          index 0 : verb
//          index 1 : url
//          index 2 : version
//
// request line format: verb SP url SP version CRLF
//
{
  LPSTR* arParts  = NULL;
  LPSTR  delim    = " \r\n";
  LPSTR  token    = NULL;
  BOOL   bCracked = FALSE;

  token = strtok(buf, delim);

  if( token )
  {
    arParts    = new LPSTR[3];
    arParts[0] = token;

    token = strtok(NULL, delim);

    if( token )
    {
      arParts[1] = token;
      token      = strtok(NULL, delim);

      if( token )
      {
        arParts[2] = token;
        bCracked   = TRUE;
      }
    }
  }

  if( !bCracked )
  {
    DEBUG_TRACE(REQUEST, ("failed to crack the request line!"));
    SAFEDELETEBUF(arParts);
  }

  return arParts;
}

//-----------------------------------------------------------------------------
// IUnknown
//-----------------------------------------------------------------------------
HRESULT
__stdcall
CRequest::QueryInterface(REFIID riid, void** ppv)
{
  DEBUG_ENTER((
    DBG_REFCOUNT,
    rt_hresult,
    "CRequest::QueryInterface",
    "this=%#x; riid=%s; ppv=%#x",
    this,
    MapIIDToString(riid),
    ppv
    ));

  HRESULT hr = S_OK;

  if( !ppv )
  {
    hr = E_POINTER;
    goto quit;
  }

    if(
      IsEqualIID(riid, IID_IUnknown)  ||
      IsEqualIID(riid, IID_IDispatch) ||
      IsEqualIID(riid, IID_IRequest)
      )
    {
      *ppv = static_cast<IRequest*>(this);
    }
    else if( IsEqualIID(riid, IID_IObjectWithSite) )
    {
      *ppv = static_cast<IObjectWithSite*>(this);
    }
    else
    {
      *ppv = NULL;
      hr   = E_NOINTERFACE;
    }

  if( SUCCEEDED(hr) )
  {
    reinterpret_cast<IUnknown*>(*ppv)->AddRef();
  }

quit:

  DEBUG_LEAVE(hr);
  return hr;
}


ULONG
__stdcall
CRequest::AddRef(void)
{
  InterlockedIncrement(&m_cRefs);
  DEBUG_ADDREF("CRequest", m_cRefs);
  return m_cRefs;
}


ULONG
__stdcall
CRequest::Release(void)
{
  InterlockedDecrement(&m_cRefs);
  DEBUG_RELEASE("CRequest", m_cRefs);

  if( m_cRefs == 0 )
  {
    DEBUG_FINALRELEASE("CRequest");
    _Cleanup();
    delete this;
    return 0;
  }

  return m_cRefs;
}


//-----------------------------------------------------------------------------
// IProvideClassInfo
//-----------------------------------------------------------------------------
HRESULT
__stdcall
CRequest::GetClassInfo(ITypeInfo** ppti)
{
  DEBUG_ENTER((
    DBG_REQUEST,
    rt_hresult,
    "CRequest::GetClassInfo",
    "this=%#x; ppti=%#x",
    this,
    ppti
    ));

  HRESULT            hr   = S_OK;
  IActiveScriptSite* pias = NULL;

  if( ppti )
  {
    if( m_pSite )
    {
      hr = m_pSite->QueryInterface(IID_IActiveScriptSite, (void**) &pias);

      if( SUCCEEDED(hr) )
      {
        hr = pias->GetItemInfo(
                     g_wszRequestObjectName,
                     SCRIPTINFO_ITYPEINFO,
                     NULL,
                     ppti
                     );
      }
    }
    else
    {
      hr = E_FAIL;
    }
  }
  else
  {
    hr = E_POINTER;
  }

  SAFERELEASE(pias);

  DEBUG_LEAVE(hr);
  return hr;
}


//-----------------------------------------------------------------------------
// IObjectWithSite
//-----------------------------------------------------------------------------
HRESULT
__stdcall
CRequest::SetSite(IUnknown* pUnkSite)
{
  DEBUG_ENTER((
    DBG_REQUEST,
    rt_hresult,
    "CRequest::SetSite",
    "this=%#x; pUnkSite=%#x",
    this,
    pUnkSite
    ));

  HRESULT hr = S_OK;

    if( !pUnkSite )
    {
      hr = E_INVALIDARG;
    }
    else
    {
      SAFERELEASE(m_pSite);

      m_pSite = pUnkSite;
      m_pSite->AddRef();

      _SiteMemberObjects();
    }

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CRequest::GetSite(REFIID riid, void** ppvSite)
{
  DEBUG_ENTER((
    DBG_REQUEST,
    rt_hresult,
    "CRequest::GetSite",
    "this=%#x; riid=%s; ppvSite=%#x",
    this,
    MapIIDToString(riid),
    ppvSite
    ));

  HRESULT hr = S_OK;

    if( !ppvSite )
    {
      hr = E_POINTER;
    }
    else
    {
      if( m_pSite )
      {
        hr = m_pSite->QueryInterface(riid, ppvSite);
      }
      else
      {
        hr = E_FAIL;
      }
    }

  DEBUG_LEAVE(hr);
  return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\tools\w3spoof\om\headers\methods.cxx ===
/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Copyright (c) 2000  Microsoft Corporation

Module Name:

    methods.cxx

Abstract:

    Implements methods part of the Headers object's dual interface.
    
Author:

    Paul M Midgen (pmidge) 13-November-2000


Revision History:

    13-November-2000 pmidge
        Created

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/

#include "common.h"

HRESULT
__stdcall
CHeaders::get_Parent(IDispatch **ppdisp)
{
  DEBUG_ENTER((
    DBG_HEADERS,
    rt_hresult,
    "CHeaders::get_Parent",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

    if( !ppdisp )
    {
      hr = E_POINTER;
    }
    else
    {
      if( m_pSite )
      {
        hr = m_pSite->QueryInterface(IID_IDispatch, (void**) ppdisp);
      }
      else
      {
        *ppdisp = NULL;
        hr      = E_UNEXPECTED;
      }
    }

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CHeaders::Get(BSTR *Headers)
{
  DEBUG_ENTER((
    DBG_HEADERS,
    rt_hresult,
    "CHeaders::Get",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

    if( !Headers )
    {
      hr = E_POINTER;
    }
    else
    {
      *Headers = __ansitobstr(m_pchHeaders);
    }

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CHeaders::Set(VARIANT *Headers)
{
  DEBUG_ENTER((
    DBG_HEADERS,
    rt_hresult,
    "CHeaders::Set",
    "this=%#x",
    this
    ));

  HRESULT hr  = S_OK;
  LPSTR   tmp = NULL;

    if( !m_bReadOnly )
    {
      m_headerlist->Clear();

      if( Headers )
      {
        tmp = __widetoansi(V_BSTR(Headers));
        hr  = _ParseHeaders(tmp);
      }
    }
    else
    {
      hr = E_ACCESSDENIED;
    }

  SAFEDELETEBUF(tmp);

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CHeaders::GetHeader(BSTR Header, VARIANT *Value)
{
  DEBUG_ENTER((
    DBG_HEADERS,
    rt_hresult,
    "CHeaders::GetHeader",
    "this=%#x; header=%S",
    this,
    Header
    ));

  HRESULT hr    = S_OK;
  LPSTR   name  = NULL;
  BSTR    value = NULL;

  if( !Header )
  {
    hr = E_INVALIDARG;
    goto quit;
  }

  if( !Value )
  {
    hr = E_POINTER;
    goto quit;
  }

  //
  // TODO: collection support using SAFEARRAYs
  //

  name = __widetoansi(Header);
  hr   = m_headerlist->Get(name, &value);

  if( SUCCEEDED(hr) )
  {
    DEBUG_TRACE(HEADERS, ("found: %S", value));

    V_VT(Value)   = VT_BSTR;
    V_BSTR(Value) = SysAllocString(value);
  }
  else
  {
    DEBUG_TRACE(HEADERS, ("not found"));

    V_VT(Value) = VT_NULL;
    hr          = S_OK;
  }

  SAFEDELETEBUF(name);

quit:

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CHeaders::SetHeader(BSTR Header, VARIANT *Value)
{
  DEBUG_ENTER((
    DBG_HEADERS,
    rt_hresult,
    "CHeaders::SetHeader",
    "this=%#x; header=%S",
    this,
    Header
    ));

  HRESULT hr   = S_OK;
  LPSTR   name = NULL;

  if( !Header )
  {
    hr = E_INVALIDARG;
    goto quit;
  }

  if( !m_bReadOnly )
  {
    name = __widetoansi(Header);

      if( !Value || __isempty(*Value) )
      {
        m_headerlist->Delete(name);
      }
      else
      {
        m_headerlist->Insert(name, __widetobstr(V_BSTR(Value)));
      }

    SAFEDELETEBUF(name);
  }
  else
  {
    hr = E_ACCESSDENIED;
  }

quit:

  DEBUG_LEAVE(hr);
  return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\tools\w3spoof\om\response\methods.cxx ===
/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Copyright (c) 2000  Microsoft Corporation

Module Name:

    methods.cxx

Abstract:

    Implements methods part of the Response object's dual interface.
    
Author:

    Paul M Midgen (pmidge) 13-November-2000


Revision History:

    13-November-2000 pmidge
        Created

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/

#include "common.h"

HRESULT
__stdcall
CResponse::get_Parent(IDispatch **ppdisp)
{
  DEBUG_ENTER((
    DBG_RESPONSE,
    rt_hresult,
    "CResponse::",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CResponse::get_Headers(IDispatch **ppdisp)
{
  DEBUG_ENTER((
    DBG_RESPONSE,
    rt_hresult,
    "CResponse::",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CResponse::putref_Headers(IDispatch **ppdisp)
{
  DEBUG_ENTER((
    DBG_RESPONSE,
    rt_hresult,
    "CResponse::",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CResponse::get_Entity(IDispatch **ppdisp)
{
  DEBUG_ENTER((
    DBG_RESPONSE,
    rt_hresult,
    "CResponse::",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CResponse::putref_Entity(IDispatch **ppdisp)
{
  DEBUG_ENTER((
    DBG_RESPONSE,
    rt_hresult,
    "CResponse::",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CResponse::get_StatusCode(VARIANT *Code)
{
  DEBUG_ENTER((
    DBG_RESPONSE,
    rt_hresult,
    "CResponse::",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CResponse::put_StatusCode(VARIANT StatusCode)
{
  DEBUG_ENTER((
    DBG_RESPONSE,
    rt_hresult,
    "CResponse::",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CResponse::get_StatusText(BSTR *StatusText)
{
  DEBUG_ENTER((
    DBG_RESPONSE,
    rt_hresult,
    "CResponse::",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CResponse::put_StatusText(BSTR StatusText)
{
  DEBUG_ENTER((
    DBG_RESPONSE,
    rt_hresult,
    "CResponse::",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

  DEBUG_LEAVE(hr);
  return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\tools\w3spoof\om\request\dispatch.cxx ===
/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Copyright (c) 2000  Microsoft Corporation

Module Name:

    dispatch.cxx

Abstract:

    Implements the IDispatch interface for the Request object.
    
Author:

    Paul M Midgen (pmidge) 03-November-2000


Revision History:

    03-November-2000 pmidge
        Created

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/

#include "common.h"

//
// WARNING: do not modify these values. use disphash.exe to generate
//          new values.
//
DISPIDTABLEENTRY g_RequestDisptable[] =
{
  0x00021b1c,   DISPID_REQUEST_PARENT,      L"parent",
  0x000401cd,   DISPID_REQUEST_HEADERS,     L"headers",
  0x000213d4,   DISPID_REQUEST_ENTITY,      L"entity",
  0x0000417f,   DISPID_REQUEST_URL,         L"url",
  0x00008715,   DISPID_REQUEST_VERB,        L"verb",
  0x00448859,   DISPID_REQUEST_HTTPVERSION, L"httpversion"
};

DWORD g_cRequestDisptable = (sizeof(g_RequestDisptable) / sizeof(DISPIDTABLEENTRY));


//-----------------------------------------------------------------------------
// IDispatch
//-----------------------------------------------------------------------------
HRESULT
__stdcall
CRequest::GetTypeInfoCount(UINT* pctinfo)
{
  DEBUG_ENTER((
    DBG_DISPATCH,
    rt_hresult,
    "CRequest::GetTypeInfoCount",
    "this=%#x; pctinfo=%#x",
    this,
    pctinfo
    ));

  HRESULT hr = S_OK;

    if( !pctinfo )
    {
      hr = E_POINTER;
    }
    else
    {
      *pctinfo = 1;
    }

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CRequest::GetTypeInfo(UINT index, LCID lcid, ITypeInfo** ppti)
{
  DEBUG_ENTER((
    DBG_DISPATCH,
    rt_hresult,
    "CRequest::GetTypeInfo",
    "this=%#x; index=%#x; lcid=%#x; ppti=%#x",
    this,
    index,
    lcid,
    ppti
    ));

  HRESULT hr = S_OK;

  if( !ppti )
  {
    hr = E_POINTER;
  }
  else
  {
    if( index != 0 )
    {
      hr    = DISP_E_BADINDEX;
      *ppti = NULL;
    }
    else
    {
      hr = GetClassInfo(ppti);
    }
  }

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CRequest::GetIDsOfNames(REFIID riid, LPOLESTR* arNames, UINT cNames, LCID lcid, DISPID* arDispId)
{
  DEBUG_ENTER((
    DBG_DISPATCH,
    rt_hresult,
    "CRequest::GetIDsOfNames",
    "this=%#x; riid=%s; arNames=%#x; cNames=%d; lcid=%#x; arDispId=%#x",
    this,
    MapIIDToString(riid),
    arNames,
    cNames,
    lcid,
    arDispId
    ));

  HRESULT hr = S_OK;
  UINT    n  = 0L;

  if( !IsEqualIID(riid, IID_NULL) )
  {
    hr = E_INVALIDARG;
    goto quit;
  }

  while( n < cNames )
  {
    arDispId[n] = GetDispidFromName(g_RequestDisptable, g_cRequestDisptable, arNames[n]);
    ++n;
  }

quit:

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CRequest::Invoke(DISPID dispid, REFIID riid, LCID lcid, WORD flags, DISPPARAMS* pdp, VARIANT* pvr, EXCEPINFO* pei, UINT* pae)
{
  DEBUG_ENTER((
    DBG_DISPATCH,
    rt_hresult,
    "CRequest::Invoke",
    "this=%#x; dispid=%s; riid=%s; lcid=%#x; flags=%#x; pdp=%#x; pvr=%#x; pei=%#x; pae=%#x",
    this,
    MapDispidToString(dispid),
    MapIIDToString(riid),
    lcid,
    flags,
    pdp, pvr,
    pei, pae
    ));

  HRESULT hr = S_OK;

  // make sure there aren't any bits set we don't understand
  if( flags & ~(DISPATCH_METHOD | DISPATCH_PROPERTYGET | DISPATCH_PROPERTYPUT) )
  {
    hr = E_INVALIDARG;
    goto quit;
  }

  if( !IsEqualIID(riid, IID_NULL) )
  {
    hr = DISP_E_UNKNOWNINTERFACE;
    goto quit;
  }

  if( !pdp )
  {
    hr = E_INVALIDARG;
    goto quit;
  }

  if( pae )
  {
    *pae = 0;
  }

  if( pvr )
  {
    VariantInit(pvr);
  }

  switch( dispid )
  {
    case DISPID_VALUE :
      {
        V_VT(pvr) = VT_DISPATCH;
        hr        = QueryInterface(IID_IDispatch, (void**) &V_DISPATCH(pvr));
      }
      break;

    case DISPID_REQUEST_PARENT :
      {
        V_VT(pvr) = VT_DISPATCH;
        hr        = get_Parent(&V_DISPATCH(pvr));

        if( hr == E_UNEXPECTED )
        {
          V_VT(pvr) = VT_NULL;
          hr        = S_OK;
        }
      }
      break;

    case DISPID_REQUEST_HEADERS :
      {
        V_VT(pvr) = VT_DISPATCH;
        hr        = get_Headers(&V_DISPATCH(pvr));

        if( hr == E_UNEXPECTED )
        {
          V_VT(pvr) = VT_NULL;
          hr        = S_OK;
        }
      }
      break;

    case DISPID_REQUEST_ENTITY :
      {
        V_VT(pvr) = VT_DISPATCH;
        hr        = get_Entity(&V_DISPATCH(pvr));

        if( hr == E_UNEXPECTED )
        {
          V_VT(pvr) = VT_NULL;
          hr        = S_OK;
        }
      }
      break;

    case DISPID_REQUEST_URL :
      {
        V_VT(pvr) = VT_DISPATCH;
        hr        = get_Url(&V_DISPATCH(pvr));

        if( hr == E_UNEXPECTED )
        {
          V_VT(pvr) = VT_NULL;
          hr        = S_OK;
        }
      }
      break;

    case DISPID_REQUEST_VERB :
      {
        V_VT(pvr) = VT_BSTR;
        hr        = get_Verb(&V_BSTR(pvr));
      }
      break;

    case DISPID_REQUEST_HTTPVERSION :
      {
        V_VT(pvr) = VT_BSTR;
        hr        = get_HttpVersion(&V_BSTR(pvr));
      }
      break;

    default :
    {
      hr = DISP_E_MEMBERNOTFOUND;
    }
  }

quit:

  DEBUG_LEAVE(hr);
  return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\tools\w3spoof\om\response\dispatch.cxx ===
/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Copyright (c) 2000  Microsoft Corporation

Module Name:

    dispatch.cxx

Abstract:

    Implements the IDispatch interface for the Response object.
    
Author:

    Paul M Midgen (pmidge) 13-November-2000


Revision History:

    13-November-2000 pmidge
        Created

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/

#include "common.h"

//
// WARNING: do not modify these values. use disphash.exe to generate
//          new values.
//
DISPIDTABLEENTRY g_ResponseDisptable[] =
{
  0x00021b1c,   DISPID_RESPONSE_PARENT,       L"parent",
  0x000401cd,   DISPID_RESPONSE_HEADERS,      L"headers",
  0x000213d4,   DISPID_RESPONSE_ENTITY,       L"entity",
  0x00235a1d,   DISPID_RESPONSE_STATUSCODE,   L"statuscode",
  0x00236646,   DISPID_RESPONSE_STATUSTEXT,   L"statustext"
};

DWORD g_cResponseDisptable = (sizeof(g_ResponseDisptable) / sizeof(DISPIDTABLEENTRY));


//-----------------------------------------------------------------------------
// IDispatch
//-----------------------------------------------------------------------------
HRESULT
__stdcall
CResponse::GetTypeInfoCount(UINT* pctinfo)
{
  DEBUG_ENTER((
    DBG_RESPONSE,
    rt_hresult,
    "CResponse::GetTypeInfoCount",
    "this=%#x; pctinfo=%#x",
    this,
    pctinfo
    ));

  HRESULT hr = S_OK;

    if( !pctinfo )
    {
      hr = E_POINTER;
    }
    else
    {
      *pctinfo = 1;
    }

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CResponse::GetTypeInfo(UINT index, LCID lcid, ITypeInfo** ppti)
{
  DEBUG_ENTER((
    DBG_RESPONSE,
    rt_hresult,
    "CResponse::GetTypeInfo",
    "this=%#x; index=%#x; lcid=%#x; ppti=%#x",
    this,
    index,
    lcid,
    ppti
    ));

  HRESULT hr   = S_OK;

  if( !ppti )
  {
    hr = E_POINTER;
  }
  else
  {
    if( index != 0 )
    {
      hr    = DISP_E_BADINDEX;
      *ppti = NULL;
    }
    else
    {
      hr = GetClassInfo(ppti);
    }
  }

  if( FAILED(hr) )
  {
    *ppti = NULL;        
  }

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CResponse::GetIDsOfNames(REFIID riid, LPOLESTR* arNames, UINT cNames, LCID lcid, DISPID* arDispId)
{
  DEBUG_ENTER((
    DBG_RESPONSE,
    rt_hresult,
    "CResponse::GetIDsOfNames",
    "this=%#x; riid=%s; arNames=%#x; cNames=%d; lcid=%#x; arDispId=%#x",
    this,
    MapIIDToString(riid),
    arNames,
    cNames,
    lcid,
    arDispId
    ));

  HRESULT hr = S_OK;
  UINT    n  = 0L;

  if( !IsEqualIID(riid, IID_NULL) )
  {
    hr = E_INVALIDARG;
    goto quit;
  }

  while( n < cNames )
  {
    arDispId[n] = GetDispidFromName(g_ResponseDisptable, g_cResponseDisptable, arNames[n]);
    ++n;
  }

quit:

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CResponse::Invoke(DISPID dispid, REFIID riid, LCID lcid, WORD flags, DISPPARAMS* pdp, VARIANT* pvr, EXCEPINFO* pei, UINT* pae)
{
  DEBUG_ENTER((
    DBG_RESPONSE,
    rt_hresult,
    "CResponse::Invoke",
    "this=%#x; dispid=%s; riid=%s; lcid=%#x; flags=%#x; pdp=%#x; pvr=%#x; pei=%#x; pae=%#x",
    this,
    MapDispidToString(dispid),
    MapIIDToString(riid),
    lcid,
    flags,
    pdp, pvr,
    pei, pae
    ));

  HRESULT hr = S_OK;

  // make sure there aren't any bits set we don't understand
  if( flags & ~(DISPATCH_METHOD | DISPATCH_PROPERTYGET | DISPATCH_PROPERTYPUT) )
  {
    hr = E_INVALIDARG;
    goto quit;
  }

  if( !IsEqualIID(riid, IID_NULL) )
  {
    hr = DISP_E_UNKNOWNINTERFACE;
    goto quit;
  }

  if( !pdp )
  {
    hr = E_INVALIDARG;
    goto quit;
  }

  if( pae )
  {
    *pae = 0;
  }

  if( pvr )
  {
    VariantInit(pvr);
  }

  switch( dispid )
  {
    case DISPID_VALUE :
      {
        V_VT(pvr) = VT_DISPATCH;
        hr        = QueryInterface(IID_IDispatch, (void**) &V_DISPATCH(pvr));
      }
      break;

    case DISPID_RESPONSE_PARENT :
      {
        V_VT(pvr) = VT_DISPATCH;
        hr        = get_Parent(&V_DISPATCH(pvr));
      }
      break;

    //
    // TODO: implementation
    //
    
    default :
      {
        hr = DISP_E_MEMBERNOTFOUND;
      }
  }

quit:

  DEBUG_LEAVE(hr);
  return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\tools\w3spoof\om\session\methods.cxx ===
/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Copyright (c) 2000  Microsoft Corporation

Module Name:

    methods.cxx

Abstract:

    Implements methods part of the Session object's dual interface.
    
Author:

    Paul M Midgen (pmidge) 24-October-2000


Revision History:

    24-October-2000 pmidge
        Created

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/

#include "common.h"

HRESULT
__stdcall
CSession::get_Socket(IDispatch** ppdisp)
{
  DEBUG_ENTER((
    DBG_SESSION,
    rt_hresult,
    "CSession::get_Socket",
    "this=%#x; ppdisp=%#x",
    this,
    ppdisp
    ));

  HRESULT hr = S_OK;

    if( !ppdisp )
    {
      hr = E_POINTER;
    }
    else
    {
      *ppdisp = NULL;

      if( m_socketobj )
      {
        hr = m_socketobj->QueryInterface(IID_IDispatch, (void**) ppdisp);
      }
    }

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CSession::get_Request(IDispatch** ppdisp)
{
  DEBUG_ENTER((
    DBG_SESSION,
    rt_hresult,
    "CSession::get_Request",
    "this=%#x; ppdisp=%#x",
    this,
    ppdisp
    ));

  HRESULT hr = S_OK;

    if( !ppdisp )
    {
      hr = E_POINTER;
    }
    else
    {
      *ppdisp = NULL;

      if( m_requestobj )
      {
        hr = m_requestobj->QueryInterface(IID_IDispatch, (void**) ppdisp);
      }
    }

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CSession::get_Response(IDispatch** ppdisp)
{
  DEBUG_ENTER((
    DBG_SESSION,
    rt_hresult,
    "CSession::get_Response",
    "this=%#x; ppdisp=%#x",
    this,
    ppdisp
    ));

  HRESULT hr = S_OK;

    if( !ppdisp )
    {
      hr = E_POINTER;
    }
    else
    {
      *ppdisp = NULL;
      //hr = m_responseobj->QueryInterface(IID_IDispatch, (void**) ppdisp);
    }

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CSession::GetPropertyBag(VARIANT Name, IDispatch** ppdisp)
{
  DEBUG_ENTER((
    DBG_SESSION,
    rt_hresult,
    "CSession::GetPropertyBag",
    "this=%#x; name=%S; ppdisp=%#x",
    this,
    V_BSTR(&Name),
    ppdisp
    ));

  HRESULT              hr      = S_OK;
  BSTR                 bagname = NULL;
  WCHAR*               buf     = NULL;
  DWORD                len     = 0L;
  IW3SpoofRuntime*     prt     = NULL;
  IW3SpoofPropertyBag* pbag    = NULL;

    if( !ppdisp )
    {
      hr = E_POINTER;
    }
    else
    {
      hr = m_pw3s->GetRuntime(&prt);

        if( SUCCEEDED(hr) )
        {
          //
          // "Name" is passed in by the script, something like "foo" or whatever. We
          //  combine that string with the client name and stuff the result in
          //  "bagname". This is how we avoid name collisions between different clients
          // running the same script.
          //

          len = (SysStringLen(V_BSTR(&Name)) + wcslen(m_wszClient))+2; // : & NULL
          buf = new WCHAR[len];

          wsprintfW(buf, L"%s:%s", m_wszClient, V_BSTR(&Name));
      
          bagname = __widetobstr(buf);
          hr      = prt->GetPropertyBag(bagname, &pbag);

          if( SUCCEEDED(hr) )
          {
            hr = pbag->QueryInterface(IID_IDispatch, (void**) ppdisp);
          }
        }

      SysFreeString(bagname);
      SAFEDELETEBUF(buf);
      SAFERELEASE(prt);
      SAFERELEASE(pbag);
    }

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CSession::get_KeepAlive(VARIANT* IsKA)
{
  DEBUG_ENTER((
    DBG_SESSION,
    rt_hresult,
    "CSession::get_KeepAlive",
    "this=%#x; IsKA=%#x",
    this,
    IsKA
    ));

  HRESULT hr = S_OK;

    if( !IsKA )
    {
      hr = E_POINTER;
    }
    else
    {
      V_VT(IsKA)   = VT_BOOL;
      V_BOOL(IsKA) = m_bIsKeepAlive ? VARIANT_TRUE : VARIANT_FALSE;
    }

  DEBUG_LEAVE(hr);
  return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\tools\w3spoof\om\response\response.cxx ===
/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Copyright (c) 2000  Microsoft Corporation

Module Name:

    response.cxx

Abstract:

    Implements the Response object.
    
Author:

    Paul M Midgen (pmidge) 13-November-2000


Revision History:

    13-November-2000 pmidge
        Created

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/

#include "common.h"

LPWSTR g_wszResponseObjectName = L"response";

//-----------------------------------------------------------------------------
// CResponse methods
//-----------------------------------------------------------------------------
CResponse::CResponse():
  m_cRefs(1),
  m_pSite(NULL)
{
  DEBUG_TRACE(RESPONSE, ("CResponse created: %#x", this));
}


CResponse::~CResponse()
{
  //
  // TODO: implementation
  //

  DEBUG_TRACE(RESPONSE, ("CResponse deleted: %#x", this));
}


HRESULT
CResponse::Create(CHAR* response, DWORD len, PRESPONSEOBJ* ppresponse)
{
  DEBUG_ENTER((
    DBG_RESPONSE,
    rt_hresult,
    "CResponse::Create",
    "response=%#x; ppresponse=%#x",
    response,
    ppresponse
    ));

  HRESULT      hr  = S_OK;
  PRESPONSEOBJ pro = NULL;

  if( !response )
  {
    hr = E_INVALIDARG;
    goto quit;
  }

  if( !ppresponse )
  {
    hr = E_POINTER;
    goto quit;
  }
  
  if( pro = new RESPONSEOBJ )
  {
    if( SUCCEEDED(pro->_Initialize(response, len)) )
    {
      *ppresponse = pro;
    }
    else
    {
      delete pro;
      *ppresponse = NULL;
      hr          = E_FAIL;
    }
  }
  else
  {
    hr = E_OUTOFMEMORY;
  }

quit:

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
CResponse::_Initialize(CHAR* response, DWORD len)
{
  DEBUG_ENTER((
    DBG_RESPONSE,
    rt_hresult,
    "CResponse::_Initialize",
    "this=%#x; response=%#x",
    this,
    response
    ));

  HRESULT hr = S_OK;

  //
  // TODO: implementation
  //
  
  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
CResponse::Terminate(void)
{
  DEBUG_ENTER((
    DBG_RESPONSE,
    rt_hresult,
    "CResponse::Terminate",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

  //
  // TODO: implementation
  //

  SAFERELEASE(m_pSite);
  Release();
 
  DEBUG_LEAVE(hr);
  return hr;
}


//-----------------------------------------------------------------------------
// IUnknown
//-----------------------------------------------------------------------------
HRESULT
__stdcall
CResponse::QueryInterface(REFIID riid, void** ppv)
{
  DEBUG_ENTER((
    DBG_REFCOUNT,
    rt_hresult,
    "CResponse::QueryInterface",
    "this=%#x; riid=%s; ppv=%#x",
    this,
    MapIIDToString(riid),
    ppv
    ));

  HRESULT hr = S_OK;

  if( !ppv )
  {
    hr = E_POINTER;
    goto quit;
  }

    if(
      IsEqualIID(riid, IID_IUnknown)  ||
      IsEqualIID(riid, IID_IDispatch) ||
      IsEqualIID(riid, IID_IResponse)
      )
    {
      *ppv = static_cast<IResponse*>(this);
    }
    else if( IsEqualIID(riid, IID_IObjectWithSite) )
    {
      *ppv = static_cast<IObjectWithSite*>(this);
    }
    else
    {
      *ppv = NULL;
      hr   = E_NOINTERFACE;
    }

  if( SUCCEEDED(hr) )
  {
    reinterpret_cast<IUnknown*>(*ppv)->AddRef();
  }

quit:

  DEBUG_LEAVE(hr);
  return hr;
}


ULONG
__stdcall
CResponse::AddRef(void)
{
  InterlockedIncrement(&m_cRefs);
  DEBUG_ADDREF("CResponse", m_cRefs);
  return m_cRefs;
}


ULONG
__stdcall
CResponse::Release(void)
{
  InterlockedDecrement(&m_cRefs);
  DEBUG_RELEASE("CResponse", m_cRefs);

  if( m_cRefs == 0 )
  {
    DEBUG_FINALRELEASE("CResponse");
    delete this;
    return 0;
  }

  return m_cRefs;
}


//-----------------------------------------------------------------------------
// IProvideClassInfo
//-----------------------------------------------------------------------------
HRESULT
__stdcall
CResponse::GetClassInfo(ITypeInfo** ppti)
{
  DEBUG_ENTER((
    DBG_RESPONSE,
    rt_hresult,
    "CResponse::GetClassInfo",
    "this=%#x; ppti=%#x",
    this,
    ppti
    ));

  HRESULT            hr   = S_OK;
  IActiveScriptSite* pias = NULL;
  IObjectWithSite*   pcnt = NULL;
  IObjectWithSite*   pssn = NULL;

  if( ppti )
  {
    hr = m_pSite->QueryInterface(IID_IObjectWithSite, (void**) &pcnt);

    if( SUCCEEDED(hr) )
    {
      hr = pcnt->QueryInterface(IID_IObjectWithSite, (void**) &pssn);

      if( SUCCEEDED(hr) )
      {
        hr = pssn->QueryInterface(IID_IActiveScriptSite, (void**) &pias);

        if( SUCCEEDED(hr) )
        {
          hr = pias->GetItemInfo(
                       g_wszResponseObjectName,
                       SCRIPTINFO_ITYPEINFO,
                       NULL,
                       ppti
                       );
        }
      }
    }
  }
  else
  {
    hr = E_POINTER;
  }

  SAFERELEASE(pcnt);
  SAFERELEASE(pssn);
  SAFERELEASE(pias);

  DEBUG_LEAVE(hr);
  return hr;
}


//-----------------------------------------------------------------------------
// IObjectWithSite
//-----------------------------------------------------------------------------
HRESULT
__stdcall
CResponse::SetSite(IUnknown* pUnkSite)
{
  DEBUG_ENTER((
    DBG_RESPONSE,
    rt_hresult,
    "CResponse::SetSite",
    "this=%#x; pUnkSite=%#x",
    this,
    pUnkSite
    ));

  HRESULT hr = S_OK;

    if( !pUnkSite )
    {
      hr = E_INVALIDARG;
    }
    else
    {
      SAFERELEASE(m_pSite);

      m_pSite = pUnkSite;
      m_pSite->AddRef();
    }

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CResponse::GetSite(REFIID riid, void** ppvSite)
{
  DEBUG_ENTER((
    DBG_RESPONSE,
    rt_hresult,
    "CResponse::GetSite",
    "this=%#x; riid=%s; ppvSite=%#x",
    this,
    MapIIDToString(riid),
    ppvSite
    ));

  HRESULT hr = S_OK;

    if( !ppvSite )
    {
      hr = E_POINTER;
    }
    else
    {
      hr = m_pSite->QueryInterface(riid, ppvSite);
    }

  DEBUG_LEAVE(hr);
  return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\tools\w3spoof\om\session\dispatch.cxx ===
/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Copyright (c) 2000  Microsoft Corporation

Module Name:

    dispatch.cxx

Abstract:

    Implements the IDispatch interface for the session object.
    
Author:

    Paul M Midgen (pmidge) 10-October-2000


Revision History:

    10-October-2000 pmidge
        Created

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/

#include "common.h"

//
// WARNING: do not modify these values. use disphash.exe to generate
//          new values.
//
DISPIDTABLEENTRY g_SessionDisptable[] =
{
  0x00022b50,   DISPID_SESSION_SOCKET,         L"socket",
  0x00045386,   DISPID_SESSION_REQUEST,        L"request",
  0x0008a9a2,   DISPID_SESSION_RESPONSE,       L"response",
  0x020e7138,   DISPID_SESSION_GETPROPERTYBAG, L"getpropertybag",
  0x00106953,   DISPID_SESSION_KEEPALIVE,      L"keepalive"
};

DWORD g_cSessionDisptable = (sizeof(g_SessionDisptable) / sizeof(DISPIDTABLEENTRY));


HRESULT
__stdcall
CSession::GetTypeInfoCount(UINT* pctinfo)
{
  DEBUG_ENTER((
    DBG_SESSION,
    rt_hresult,
    "CSession::GetTypeInfoCount",
    "this=%#x; pctinfo=%#x",
    this,
    pctinfo
    ));

  HRESULT hr = S_OK;

    if( !pctinfo )
    {
      hr = E_POINTER;
    }
    else
    {
      *pctinfo = 1;
    }

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CSession::GetTypeInfo(UINT index, LCID lcid, ITypeInfo** ppti)
{
  DEBUG_ENTER((
    DBG_SESSION,
    rt_hresult,
    "CSession::GetTypeInfo",
    "this=%#x; index=%d; lcid=%#x; ppti=%#x",
    this,
    index,
    (LONG) lcid,
    ppti
    ));

  HRESULT hr = S_OK;

    if( !ppti )
    {
      hr = E_POINTER;
    }
    else
    {
      *ppti = NULL;

      if( index != 0 )
      {
        hr = DISP_E_BADINDEX;
      }
      else
      {
        hr = m_ptl->QueryInterface(IID_ITypeInfo, (void**) ppti);
      }
    }

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CSession::GetIDsOfNames(REFIID riid, LPOLESTR* arNames, UINT cNames, LCID lcid, DISPID* arDispId)
{
  DEBUG_ENTER((
    DBG_SESSION,
    rt_hresult,
    "CSession::GetIDsOfNames",
    "this=%#x; riid=%s; arNames=%#x; cNames=%d; lcid=%#x; arDispId=%#x",
    this,
    MapIIDToString(riid),
    arNames,
    cNames,
    lcid,
    arDispId
    ));

  HRESULT hr = S_OK;
  UINT    n  = 0L;

  if( !IsEqualIID(riid, IID_NULL) )
  {
    hr = E_INVALIDARG;
    goto quit;
  }

  while( n < cNames )
  {
    arDispId[n] = GetDispidFromName(g_SessionDisptable, g_cSessionDisptable, arNames[n]);
    ++n;
  }

quit:

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CSession::Invoke(DISPID dispid, REFIID riid, LCID lcid, WORD flags, DISPPARAMS* pdp, VARIANT* pvr, EXCEPINFO* pei, UINT* pae)
{
  DEBUG_ENTER((
    DBG_SESSION,
    rt_hresult,
    "CSession::Invoke",
    "this=%#x; dispid=%s; riid=%s; lcid=%#x; flags=%#x; pdp=%#x; pvr=%#x; pei=%#x; pae=%#x",
    this,
    MapDispidToString(dispid),
    MapIIDToString(riid),
    lcid, flags,
    pdp, pvr,
    pei, pae
    ));

  HRESULT hr = S_OK;

  hr = ValidateDispatchArgs(riid, pdp, pvr, pae);

    if( FAILED(hr) )
      goto quit;

  switch( dispid )
  {
    case DISPID_SESSION_SOCKET :
      {
        hr = ValidateInvokeFlags(flags, DISPATCH_PROPERTYGET, TRUE);

        if( SUCCEEDED(hr) )
        {
          V_VT(pvr) = VT_DISPATCH;
          hr        = get_Socket(&V_DISPATCH(pvr));
        }
      }
      break;

    case DISPID_SESSION_REQUEST :
      {
        hr = ValidateInvokeFlags(flags, DISPATCH_PROPERTYGET, TRUE);

        if( SUCCEEDED(hr) )
        {
          V_VT(pvr) = VT_DISPATCH;
          hr        = get_Request(&V_DISPATCH(pvr));
        }
      }
      break;

    case DISPID_SESSION_RESPONSE :
      {
        hr = ValidateInvokeFlags(flags, DISPATCH_PROPERTYGET, TRUE);

        if( SUCCEEDED(hr) )
        {
          V_VT(pvr) = VT_DISPATCH;
          hr        = get_Response(&V_DISPATCH(pvr));
        }
      }
      break;

    case DISPID_SESSION_GETPROPERTYBAG :
      {
        NEWVARIANT(name);

        hr = ValidateInvokeFlags(flags, DISPATCH_METHOD, FALSE);

        if( SUCCEEDED(hr) )
        {
          hr = ValidateArgCount(pdp, 0, TRUE, 1);

          if( SUCCEEDED(hr) )
          {
            hr = DispGetParam(pdp, 0, VT_BSTR, &name, pae);

              if( FAILED(hr) )
              {
                V_VT(&name)   = VT_BSTR;
                V_BSTR(&name) = SysAllocString(L"default");
                pae           = 0;
              }
              
            V_VT(pvr) = VT_DISPATCH;
            hr        = GetPropertyBag(name, &V_DISPATCH(pvr));

            VariantClear(&name);
          }
        }
      }
      break;

    case DISPID_SESSION_KEEPALIVE :
      {
        hr = ValidateInvokeFlags(flags, DISPATCH_PROPERTYGET, TRUE);

        if( SUCCEEDED(hr) )
        {
          hr = ValidateArgCount(pdp, 0, FALSE, 0);

          if( SUCCEEDED(hr) )
          {
            hr = get_KeepAlive(pvr);
          }
        }
      }
      break;

    default : hr = DISP_E_MEMBERNOTFOUND;
  }

quit:

  if( FAILED(hr) )
  {
    hr = HandleDispatchError(L"session object", pei, hr);
  }

  DEBUG_LEAVE(hr);
  return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\tools\w3spoof\om\socket\dispatch.cxx ===
/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Copyright (c) 2000  Microsoft Corporation

Module Name:

    dispatch.cxx

Abstract:

    Implements the IDispatch interface for the socket object.
    
Author:

    Paul M Midgen (pmidge) 23-October-2000


Revision History:

    23-October-2000 pmidge
        Created

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/

#include "common.h"

// from socket.cxx
extern LPWSTR g_wszSocketObjectName;


//
// WARNING: do not modify these values. use disphash.exe to generate
//          new values.
//
DISPIDTABLEENTRY g_SocketDisptable[] =
{
  0x00021b1c,   DISPID_SOCKET_PARENT,           L"parent",
  0x000084ab,   DISPID_SOCKET_SEND,             L"send",
  0x000083b3,   DISPID_SOCKET_RECV,             L"recv",
  0x00022de1,   DISPID_SOCKET_OPTION,           L"option",
  0x00010203,   DISPID_SOCKET_CLOSE,            L"close",
  0x000453c0,   DISPID_SOCKET_RESOLVE,          L"resolve",
  0x0010bcf1,   DISPID_SOCKET_LOCALNAME,        L"localname",
  0x00857183,   DISPID_SOCKET_LOCALADDRESS,     L"localaddress",
  0x0010c4d0,   DISPID_SOCKET_LOCALPORT,        L"localport",
  0x00225479,   DISPID_SOCKET_REMOTENAME,       L"remotename",
  0x01120dce,   DISPID_SOCKET_REMOTEADDRESS,    L"remoteaddress",
  0x00225c58,   DISPID_SOCKET_REMOTEPORT,       L"remoteport"
};

DWORD g_cSocketDisptable = (sizeof(g_SocketDisptable) / sizeof(DISPIDTABLEENTRY));


//-----------------------------------------------------------------------------
// IDispatch
//-----------------------------------------------------------------------------
HRESULT
__stdcall
CSocket::GetTypeInfoCount(UINT* pctinfo)
{
  DEBUG_ENTER((
    DBG_SOCKET,
    rt_hresult,
    "CSocket::GetTypeInfoCount",
    "this=%#x; pctinfo=%#x",
    this,
    pctinfo
    ));

  HRESULT hr = S_OK;

    if( !pctinfo )
    {
      hr = E_POINTER;
    }
    else
    {
      *pctinfo = 1;
    }

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CSocket::GetTypeInfo(UINT index, LCID lcid, ITypeInfo** ppti)
{
  DEBUG_ENTER((
    DBG_SOCKET,
    rt_hresult,
    "CSocket::GetTypeInfo",
    "this=%#x; index=%#x; lcid=%#x; ppti=%#x",
    this,
    index,
    lcid,
    ppti
    ));

  HRESULT            hr   = S_OK;
  IActiveScriptSite* pias = NULL;

  if( !ppti )
  {
    hr = E_POINTER;
  }
  else
  {
    if( index != 0 )
    {
      hr = DISP_E_BADINDEX;
    }
    else
    {
      m_pSite->QueryInterface(IID_IActiveScriptSite, (void**) &pias);

      hr = pias->GetItemInfo(
             g_wszSocketObjectName,
             SCRIPTINFO_ITYPEINFO,
             NULL,
             ppti
             );
    }
  }

  if( FAILED(hr) )
  {
    *ppti = NULL;
  }

  SAFERELEASE(pias);

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CSocket::GetIDsOfNames(REFIID riid, LPOLESTR* arNames, UINT cNames, LCID lcid, DISPID* arDispId)
{
  DEBUG_ENTER((
    DBG_SOCKET,
    rt_hresult,
    "CSocket::GetIDsOfNames",
    "this=%#x; riid=%s; arNames=%#x; cNames=%d; lcid=%#x; arDispId=%#x",
    this,
    MapIIDToString(riid),
    arNames,
    cNames,
    lcid,
    arDispId
    ));

  HRESULT hr = S_OK;
  UINT    n  = 0L;

  if( !IsEqualIID(riid, IID_NULL) )
  {
    hr = E_INVALIDARG;
    goto quit;
  }

  while( n < cNames )
  {
    arDispId[n] = GetDispidFromName(g_SocketDisptable, g_cSocketDisptable, arNames[n]);
    ++n;
  }

quit:

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CSocket::Invoke(DISPID dispid, REFIID riid, LCID lcid, WORD flags, DISPPARAMS* pdp, VARIANT* pvr, EXCEPINFO* pei, UINT* pae)
{
  DEBUG_ENTER((
    DBG_SOCKET,
    rt_hresult,
    "CSocket::Invoke",
    "this=%#x; dispid=%s; riid=%s; lcid=%#x; flags=%#x; pdp=%#x; pvr=%#x; pei=%#x; pae=%#x",
    this,
    MapDispidToString(dispid),
    MapIIDToString(riid),
    lcid,
    flags,
    pdp, pvr,
    pei, pae
    ));

  HRESULT hr = S_OK;

  hr = ValidateDispatchArgs(riid, pdp, pvr, pae);

    if( FAILED(hr) )
      goto quit;

  switch( dispid )
  {
    case DISPID_SOCKET_PARENT :
      {
        hr = ValidateInvokeFlags(flags, DISPATCH_PROPERTYGET, TRUE);

        if( SUCCEEDED(hr) )
        {
          V_VT(pvr) = VT_DISPATCH;
          hr        = get_Parent(&V_DISPATCH(pvr));
        }
      }
      break;

    case DISPID_SOCKET_SEND :
      {
        hr = ValidateInvokeFlags(flags, DISPATCH_METHOD, FALSE);

        if( SUCCEEDED(hr) )
        {
          hr = ValidateArgCount(pdp, 1, FALSE, 0);

          if( SUCCEEDED(hr) )
          {
            hr = Send(pdp->rgvarg[0]);
          }
        }
      }
      break;

    case DISPID_SOCKET_RECV :
      {
        hr = ValidateInvokeFlags(flags, DISPATCH_METHOD, FALSE);

        if( SUCCEEDED(hr) )
        {
          hr = ValidateArgCount(pdp, 0, FALSE, 0);

          if( SUCCEEDED(hr) )
          {
            hr = Recv(pvr);
          }
        }
      }
      break;
    
    case DISPID_SOCKET_CLOSE :
      {
        NEWVARIANT(method);

        hr = ValidateInvokeFlags(flags, DISPATCH_METHOD, FALSE);

        if( SUCCEEDED(hr) )
        {
          hr = ValidateArgCount(pdp, 0, TRUE, 1);

          if( SUCCEEDED(hr) )
          {
            hr = DispGetParam(pdp, 0, VT_BOOL, &method, pae);

              if( FAILED(hr) )
              {
                V_VT(&method)   = VT_BOOL;
                V_BOOL(&method) = TRUE;
                pae             = 0;
              }
              
            hr = Close(method);
            VariantClear(&method);
          }
        }
      }
      break;

    case DISPID_SOCKET_RESOLVE :
      {
        hr = ValidateInvokeFlags(flags, DISPATCH_METHOD, FALSE);

        if( SUCCEEDED(hr) )
        {
          hr = ValidateArgCount(pdp, 1, FALSE, 0);

          if( SUCCEEDED(hr) )
          {
            if( pvr )
            {
              V_VT(pvr) = VT_BSTR;
              hr        = Resolve(V_BSTR(&pdp->rgvarg[0]), &V_BSTR(pvr));
            }
          }
        }
      }
      break;

    case DISPID_SOCKET_LOCALNAME :
      {
        hr = ValidateInvokeFlags(flags, DISPATCH_PROPERTYGET, TRUE);

        if( SUCCEEDED(hr) )
        {
          V_VT(pvr) = VT_BSTR;
          hr        = get_LocalName(&V_BSTR(pvr));
        }
      }
      break;

    case DISPID_SOCKET_LOCALADDRESS :
      {
        hr = ValidateInvokeFlags(flags, DISPATCH_PROPERTYGET, TRUE);

        if( SUCCEEDED(hr) )
        {
          V_VT(pvr) = VT_BSTR;
          hr        = get_LocalAddress(&V_BSTR(pvr));
        }
      }
      break;

    case DISPID_SOCKET_LOCALPORT :
      {
        hr = ValidateInvokeFlags(flags, DISPATCH_PROPERTYGET, TRUE);

        if( SUCCEEDED(hr) )
        {
          hr = get_LocalPort(pvr);
        }
      }
      break;

    case DISPID_SOCKET_REMOTENAME :
      {
        hr = ValidateInvokeFlags(flags, DISPATCH_PROPERTYGET, TRUE);

        if( SUCCEEDED(hr) )
        {
          V_VT(pvr) = VT_BSTR;
          hr        = get_RemoteName(&V_BSTR(pvr));
        }
      }
      break;

    case DISPID_SOCKET_REMOTEADDRESS :
      {
        hr = ValidateInvokeFlags(flags, DISPATCH_PROPERTYGET, TRUE);

        if( SUCCEEDED(hr) )
        {
          V_VT(pvr) = VT_BSTR;
          hr        = get_RemoteAddress(&V_BSTR(pvr));
        }
      }
      break;

    case DISPID_SOCKET_REMOTEPORT :
      {
        hr = ValidateInvokeFlags(flags, DISPATCH_PROPERTYGET, TRUE);

        if( SUCCEEDED(hr) )
        {
          hr = get_RemotePort(pvr);
        }
      }
      break;

    case DISPID_SOCKET_OPTION :
      {
        hr = E_NOTIMPL;
      }
      break;

    default : hr = DISP_E_MEMBERNOTFOUND;
  }

quit:

  if( FAILED(hr) )
  {
    hr = HandleDispatchError(L"socket object", pei, hr);
  }

  DEBUG_LEAVE(hr);
  return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\tools\w3spoof\om\session\session.cxx ===
/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Copyright (c) 2000  Microsoft Corporation

Module Name:

    session.cxx

Abstract:

    Implements the session object.
    
Author:

    Paul M Midgen (pmidge) 10-October-2000


Revision History:

    10-October-2000 pmidge
        Created

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/

#include "common.h"

extern LPWSTR g_wszRuntimeObjectName;

LPWSTR g_wszSessionObjectName = L"session";
LPWSTR g_arHandlerNames[]     =
{
  L"OnConnect",
  L"OnDataAvailable",
  L"OnRequest",
  L"OnResponse",
  L"OnClose"
};

//-----------------------------------------------------------------------------
// CSession methods
//-----------------------------------------------------------------------------
CSession::CSession():
  m_cRefs(1),
  m_wszClient(NULL),
  m_wszClientId(NULL),
  m_bIsKeepAlive(TRUE),
  m_CurrentHandler(Global),
  m_ptl(NULL),
  m_pw3s(NULL),
  m_pas(NULL),
  m_psd(NULL),
  m_lcid(0),
  m_socketobj(NULL),
  m_requestobj(NULL),
  m_responseobj(NULL),
  m_objstate(ST_CREATED)
{
  DEBUG_TRACE(SESSION, ("CSession created: %#x", this));
}


CSession::~CSession()
{
  DEBUG_TRACE(SESSION, ("CSession deleted: %#x", this));
  DEBUG_ASSERT((m_objstate == ST_CLOSED));
}


HRESULT
CSession::Create(PIOCTX pioc, IW3Spoof* pw3s)
{
  DEBUG_ENTER((
    DBG_SESSION,
    rt_hresult,
    "CSession::Create",
    "pioc=%#x; pw3s=%#x",
    pioc,
    pw3s
    ));

  HRESULT   hr   = S_OK;
  CSession* pssn = NULL;

  if( !(pioc && pw3s) )
  {
    hr = E_INVALIDARG;
  }
  else
  {
    if( pssn = new SESSIONOBJ )
    {
      if( SUCCEEDED(pssn->_Initialize(pioc, pw3s)) )
      {
        pioc->session = pssn;
      }
      else
      {
        DEBUG_TRACE(SESSION, ("ERROR! nuking uninitialized session object"));
        pssn->_SetObjectState(ST_ERROR);
        pssn->Terminate();
        hr = E_FAIL;
      }
    }
    else
    {
      hr = E_OUTOFMEMORY;
    }
  }

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
CSession::_Initialize(PIOCTX pioc, IW3Spoof* pw3s)
{
  DEBUG_ENTER((
    DBG_SESSION,
    rt_hresult,
    "CSession::_Initialize",
    "this=%#x; pioc=%#x; pw3s=%#x",
    this,
    pioc,
    pw3s
    ));

  HRESULT hr = S_OK;

  if( m_objstate == ST_CREATED )
  {
    InitializeCriticalSection(&m_lock);

    m_wszClient   = __ansitowide(pioc->remote->name);
    m_wszClientId = __wstrdup(pioc->clientid);
    m_lcid        = GetThreadLocale();
    m_pw3s        = pw3s;
    m_pw3s->AddRef();

    _SetObjectState(ST_OPENING);

      hr = m_pw3s->GetTypeLibrary(&m_ptl);

        if( FAILED(hr) )
          goto quit;

      hr = _InitSocketObject(pioc);

        if( FAILED(hr) )
          goto quit;

      hr = m_pw3s->GetScriptEngine(&m_pas);

        if( FAILED(hr) )
          goto quit;

      hr = _SetScriptSite(FALSE);

        if( FAILED(hr) )
          goto quit;

      hr = _InitScriptEngine();

        if( FAILED(hr) )
          goto quit;

      hr = _LoadScript();

        if( FAILED(hr) )
          goto quit;
        
      hr = _LoadScriptDispids();

        if( FAILED(hr) )
          goto quit;

    _SetObjectState(ST_OPEN);
    _SetNextServerState(SS_START_STATE);
  }
  else
  {
    hr = E_UNEXPECTED;
  } 

quit:

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
CSession::Terminate(void)
{
  DEBUG_ENTER((
    DBG_SESSION,
    rt_hresult,
    "CSession::Terminate",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

  _SetObjectState(ST_CLOSING);

    m_pas->Close();
    SAFERELEASE(m_psd);
    SAFERELEASE(m_pas);
    SAFERELEASE(m_ptl);

    SAFEDELETEBUF(m_wszClient);
 
    SAFETERMINATE(m_requestobj);
    m_requestobj = NULL;

    //SAFETERMINATE(m_responseobj);
    // m_responseobj = NULL;

    SAFETERMINATE(m_socketobj);
    m_socketobj = NULL;

    _Unlock();
    DeleteCriticalSection(&m_lock);

  //
  // once this call and the implicit notification to the w3spoof object completes,
  // the session is an orphan. this is the point of no return.
  //
  _SetObjectState(ST_CLOSED);

  SAFEDELETEBUF(m_wszClientId);
  SAFERELEASE(m_pw3s);

  //
  // one bogus case that will result in this assert popping is when multiple
  // outstanding references to the script engine are held in this process. the
  // way the script engine does garbage collection will usually result in a couple
  // of 'dead' sessions lying about for a while. they all get cleaned up when the
  // final ref to the script engine server is released.
  //
  DEBUG_ASSERT((m_cRefs == 1));

  Release();

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
CSession::Run(PIOCTX pioc)
//
// Session FSM
//
// This is the session object FSM. Worker threads 'run' each server OM through this function.
// When this function returns the server should be in a state where i/o is completing asynchronously.
// All other states are optimized to be handled without the OM relinquishing the worker thread.
//
// Only one thread at a time can run a given OM, so we lock the OM when the FSM is entered.
//
// Anywhere you see 'goto next_state', you're in a non-default state transition handler. This is an
// optimized case where we immediately process the pending state instead of waiting for a completion
// event to trigger an FSM call. These cases are caused by the user calling socket.send, recv or close
// from script.
//
// Script-based socket I/O calls don't generate completions. In the event the call would overlap, we
// wait because asynchronous script coding would make a seemingly simple task unnecessarily hard.
//
{
  DEBUG_ENTER((
    DBG_SESSION,
    rt_hresult,
    "CSession::Run",
    "this=%#x; pioc=%#x",
    this,
    pioc
    ));

  HRESULT     hr     = S_OK;
  SERVERSTATE st     = SS_START_STATE;
  UINT        argerr = 0L;
  DISPPARAMS  dp     = {0};
  NEWVARIANT(vr);

  _Lock();

    // if an io error occurred when we dequeued from the thread pool,
    // the io context's error field will be set.
    if( pioc->error != ERROR_SUCCESS )
    {
      DEBUG_TRACE(SESSION, ("session fsm detected error %s", MapErrorToString(pioc->error)));

      switch( pioc->error )
      {
        case ERROR_NETNAME_DELETED :
          {
            DEBUG_TRACE(SESSION, ("client dropped connection"));
            _SetNextServerState(SS_SOCKET_DISCONNECTED);
          }
          break;

        case ERROR_OPERATION_ABORTED :
          {
            DEBUG_TRACE(SESSION, ("pending io (%s) aborted", MapIOTYPEToString(pioc->Type())));
            _SetNextServerState(SS_SOCKET_DISCONNECTED);
          }
          break;

        default :
          {
            DEBUG_TRACE(SESSION, ("error not handled"));
            _SetNextServerState(SS_SOCKET_DISCONNECTED);
          }
      }
    }

    _SetScriptSite(TRUE);

next_state:

    st = m_socketobj->GetServerState();
    DEBUG_TRACE(SESSION, ("executing server state %s", MapStateToString(st)));

    switch( st )
    {
      case SS_SOCKET_CONNECTED :
        {
          //===========================================
          // state   : SS_SOCKET_CONNECTED
          //
          // follows : new connections only
          //
          // next    : default  - SS_REQUEST_PENDING
          //           on send  - SS_RESPONSE_COMPLETE
          //           on recv  - SS_REQUEST_COMPLETE
          //           on close - SS_SOCKET_DISCONNECTED
          //===========================================
          m_CurrentHandler = OnConnect;

          if( VALIDDISPID(m_arHandlerDispids[m_CurrentHandler]) )
          {
            hr = m_psd->Invoke(
                          m_arHandlerDispids[m_CurrentHandler],
                          IID_NULL, m_lcid,
                          DISPATCH_METHOD,
                          &dp, &vr, NULL, &argerr
                          );

            if( FAILED(hr) )
            {
              DEBUG_TRACE(SESSION, ("aborting fsm due to script error"));
              goto terminate;
            }
          }

          if( !_SetNextServerState(SS_SOCKET_CONNECTED) )
          {
            goto next_state;
          }
          else
          {
            PIOCTX pioc = new IOCTX(IOCT_RECV, INVALID_SOCKET);

            if( pioc )
            {
              pioc->clientid = m_wszClientId;
              pioc->session  = this;
              hr             = m_socketobj->Run(pioc);
            }
            else
            {
              DEBUG_TRACE(SESSION, ("terminating due to low-memory condition"));
              hr = E_OUTOFMEMORY;
              goto terminate;
            }
          }
        }
        break;

      case SS_REQUEST_PENDING :
        {
          //===========================================
          // state   : SS_REQUEST_PENDING
          //
          // follows : default  - SS_SOCKET_CONNECTED
          //           other    - SS_RESPONSE_COMPLETE
          //
          // next    : default  - SS_REQUEST_COMPLETE
          //           on send  - SS_RESPONSE_COMPLETE
          //           on recv  - SS_REQUEST_COMPLETE
          //           on close - SS_SOCKET_DISCONNECTED
          //===========================================
          m_CurrentHandler = OnDataAvailable;

          if( VALIDDISPID(m_arHandlerDispids[m_CurrentHandler]) )
          {
            hr = m_psd->Invoke(
                          m_arHandlerDispids[m_CurrentHandler],
                          IID_NULL, m_lcid,
                          DISPATCH_METHOD,
                          &dp, &vr, NULL, &argerr
                          );

            if( FAILED(hr) )
            {
              DEBUG_TRACE(SESSION, ("aborting fsm due to script error"));
              goto terminate;
            }
          }

          if( !_SetNextServerState(SS_REQUEST_PENDING) )
          {
            goto next_state;  
          }
        }

      case SS_REQUEST_COMPLETE :
        {
          //===========================================
          // state   : SS_REQUEST_COMPLETE
          //
          // follows : default  - SS_REQUEST_PENDING
          //           other    - SS_SOCKET_CONNECTED
          //
          // next    : default  - SS_RESPONSE_PENDING
          //           on send  - SS_RESPONSE_COMPLETE
          //           on recv  - disallowed
          //           on close - SS_SOCKET_DISCONNECTED
          //===========================================

          _SetKeepAlive(pioc);

          hr               = _InitRequestObject();
          m_CurrentHandler = OnRequest;

          if( SUCCEEDED(hr) )
          {
            if( VALIDDISPID(m_arHandlerDispids[m_CurrentHandler]) )
            {
              hr = m_psd->Invoke(
                            m_arHandlerDispids[m_CurrentHandler],
                            IID_NULL, m_lcid,
                            DISPATCH_METHOD,
                            &dp, &vr, NULL, &argerr
                            );

              if( FAILED(hr) )
              {
                DEBUG_TRACE(SESSION, ("aborting fsm due to script error"));
                goto terminate;
              }
            }
          }

          if( !_SetNextServerState(SS_REQUEST_COMPLETE) )
          {
            goto next_state;
          }
        }

      case SS_RESPONSE_PENDING :
        {
          //===========================================
          // state   : SS_RESPONSE_PENDING
          //
          // follows : default  - SS_REQUEST_COMPLETE
          //           other    - SS_SOCKET_CONNECTED
          //
          // next    : default  - SS_RESPONSE_COMPLETE
          //           on send  - SS_RESPONSE_COMPLETE
          //           on recv  - disallowed
          //           on close - SS_SOCKET_DISCONNECTED
          //===========================================

          //
          // TODO: create response object
          //

          m_CurrentHandler = OnResponse;

          if( VALIDDISPID(m_arHandlerDispids[m_CurrentHandler]) )
          {
            hr = m_psd->Invoke(
                          m_arHandlerDispids[m_CurrentHandler],
                          IID_NULL, m_lcid,
                          DISPATCH_METHOD,
                          &dp, &vr, NULL, &argerr
                          );

            if( FAILED(hr) )
            {
              DEBUG_TRACE(SESSION, ("aborting fsm due to script error"));
              goto terminate;
            }
          }

          if( !_SetNextServerState(SS_RESPONSE_PENDING) )
          {
            goto next_state;
          }
          else
          {
            //
            // TODO: stuff default response info into an io context
            //       and send it, queueing a send, then bail.
            //
            hr = m_socketobj->Run(NULL);
          }
        }
        break;

      case SS_RESPONSE_COMPLETE :
        {
          if( m_bIsKeepAlive )
          {
            PIOCTX pioc = new IOCTX(IOCT_RECV, INVALID_SOCKET);

            if( pioc )
            {
              _SetNextServerState(SS_RESPONSE_COMPLETE);

              pioc->clientid = m_wszClientId;
              pioc->session  = this;
              hr             = m_socketobj->Run(pioc);
            }
            else
            {
              DEBUG_TRACE(SESSION, ("terminating due to low-memory condition"));
              hr = E_OUTOFMEMORY;
              goto terminate;
            }
          }
          else
          {
            _SetNextServerState(SS_SOCKET_DISCONNECTED);
            goto next_state;
          }
        }
        break;

      case SS_SOCKET_DISCONNECTED :
        {
          m_CurrentHandler = OnClose;

          if( VALIDDISPID(m_arHandlerDispids[m_CurrentHandler]) )
          {
            hr = m_psd->Invoke(
                          m_arHandlerDispids[m_CurrentHandler],
                          IID_NULL, m_lcid,
                          DISPATCH_METHOD,
                          &dp, &vr, NULL, &argerr
                          );
          }
          
          goto terminate;
        }
        break;
    }

    _ResetScriptEngine();

  _Unlock();

quit:
  
  DEBUG_LEAVE(hr);
  return hr;

terminate: 

  Terminate();
  goto quit;
}


HRESULT
CSession::_InitSocketObject(PIOCTX pioc)
{
  DEBUG_ENTER((
    DBG_REQUEST,
    rt_hresult,
    "CSession::_InitSocketObject",
    "this=%#x; pioc=%#x",
    this,
    pioc
    ));

  HRESULT          hr    = S_OK;
  IObjectWithSite* piows = NULL;

    if( SUCCEEDED(SOCKETOBJ::Create(pioc, &m_socketobj)) )
    {
      m_socketobj->QueryInterface(
                     IID_IObjectWithSite,
                     (void**) &piows
                     );
      
      piows->SetSite(dynamic_cast<ISession*>(this));
    }
    else
    {
      DEBUG_TRACE(SESSION, ("failed to create socket object"));
      hr = 