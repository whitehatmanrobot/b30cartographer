6
#define IDS_ADMIN					457
#define IDS_SERVER					458
#define IDS_UNKNOWN					459
#define IDS_FORMAT_ORIGIN				460
#define IDS_FORMAT_UNKNOWN_HEX				461
#define IDS_GETCONFIG3_DESCRIPTION			462
#define IDS_REQUEST_PROPERTIES				463
#define IDS_CERT_PROPERTIES				464
#define IDS_LOG_COMMANDLINE				465
#define IDS_CONFIGDISPLAY_SANITIZEDNAME_COLON		466
#define IDS_FORMAT_EXTENSION				467
#define IDS_ERR_FORMAT_SHOW_TOO_FEW_ARGS		468
#define IDS_ERR_FORMAT_SHOW_TOO_MANY_ARGS		469
#define IDS_ERR_CONFIGGETCONFIG				470
#define IDS_ERR_FORMAT_COMMAND_FAILED			471
#define IDS_CHECK7F_FIELD_UNKNOWN			472
#define IDS_CHECK7F_FIELD_NONE				473
#define IDS_CHECK7F_FIELD_OTHER				474
#define IDS_CHECK7F_FIELD_ISSUER			475
#define IDS_CHECK7F_FIELD_ISSUERRDN			476
#define IDS_CHECK7F_FIELD_ISSUERRDNATTRIBUTE		477
#define IDS_CHECK7F_FIELD_ISSUERRDNSTRING		478
#define IDS_CHECK7F_FIELD_SUBJECT			479
#define IDS_CHECK7F_FIELD_SUBJECTRDN			480
#define IDS_CHECK7F_FIELD_SUBJECTRDNATTRIBUTE		481
#define IDS_CHECK7F_FIELD_SUBJECTRDNSTRING		482
#define IDS_CHECK7F_FIELD_EXTENSIONS			483
#define IDS_CHECK7F_FIELD_EXTENSIONARRAY		484
#define IDS_CHECK7F_FIELD_EXTENSION			485
#define IDS_CHECK7F_FIELD_EXTENSIONVALUE		486
#define IDS_CHECK7F_FIELD_EXTENSIONVALUERAW		487
#define IDS_NO_KEY_PROVIDER_INFO			488
#define IDS_VIEW_DESCRIPTION				489
#define IDS_FORMAT_ADDED_TO_DS_STORE			490
#define IDS_PING_DESCRIPTION				491
#define IDS_PINGADMIN_DESCRIPTION			492
#define IDS_CONFIGDISPLAY_COMMONNAME_COLON		493
#define IDS_CONFIGDISPLAY_ORGUNIT_COLON			494
#define IDS_CONFIGDISPLAY_ORG_COLON			495
#define IDS_CONFIGDISPLAY_LOCALITY_COLON		496
#define IDS_CONFIGDISPLAY_STATE_COLON			497
#define IDS_CONFIGDISPLAY_COUNTRY_COLON			498
#define IDS_CONFIGDISPLAY_CONFIG_COLON			499
#define IDS_CONFIGDISPLAY_EXCHANGECERT_COLON		500
#define IDS_CONFIGDISPLAY_SIGCERT_COLON			501
#define IDS_CONFIGDISPLAY_DESCRIPTION_COLON		502
#define IDS_CONFIGDISPLAY_SERVER_COLON			503
#define IDS_CONFIGDISPLAY_AUTHORITY_COLON		504
#define IDS_CONFIGDISPLAY_ENTRY				505
#define IDS_CERTIFICATE_EXTENSIONS			506
#define IDS_REQUEST_ATTRIBUTES				507
#define IDS_SHUTDOWN_DESCRIPTION			508
#define IDS_LOG_STATUS					509
#define IDS_SCHEMA_DESCRIPTION				510
#define IDS_LOG_STATUSOK				511
#define IDS_PASSWORD_DESCRIPTION			512
#define IDS_DUMP_CERT					513
#define IDS_DUMP_CRL					514
#define IDS_DUMP_REQUEST				515
#define IDS_DUMP_KEYGEN					516
#define IDS_FORMAT_VERSION				517
#define IDS_SERIAL					518
#define IDS_SIGNATURE_ALGORITHM				519
#define IDS_PUBLICKEY_ALGORITHM				520
#define IDS_ISSUERUNIQUEID				521
#define IDS_SUBJECTUNIQUEID				522
#define IDS_NOTBEFORE					523
#define IDS_NOTAFTER					524
#define IDS_THISUPDATE					525
#define IDS_NEXTUPDATE					526
#define IDS_REVOCATIONDATE				527
#define IDS_EXTENSIONS					528
#define IDS_CRLEXTENSIONS				529
#define IDS_DUMP_PKCS7					530
#define IDS_ERR_FORMAT_ROOT_CERT_BAD_SIG		531
#define IDS_NO_ROOT_CERT				532
#define IDS_ROOT_CERT					533
#define IDS_NO_ROOT_CERT_GOOD_SIG			534
#define IDS_REVOKING					535
#define IDS_PASSWORDPROMPT				536
#define IDS_UNKNOWN_EXTENSION				537
#define IDS_PRIVATEKEY					538
#define IDS_LENGTH					539
#define IDS_GMT_DESCRIPTION				540
#define IDS_GMT_SUFFIX					541
#define IDS_BACKUPPFX_USAGEARGS				542
#define IDS_BACKUPPFX_DESCRIPTION			543
#define IDS_RESTOREPFX_USAGEARGS			544
#define IDS_RESTOREPFX_DESCRIPTION			545
#define IDS_STORE_USAGEARGS				546
#define IDS_STORE_DESCRIPTION				547
#define IDS_FORMAT_PROVIDER_TYPE			548
#define IDS_FORMAT_KEY_CONTAINER			549
#define IDS_FORMAT_PROVIDER_NAME			550
#define IDS_FORMAT_KEYSPEC				551
#define IDS_FORMAT_FLAGS 				552
#define IDS_FORMAT_RESTORED				553
#define IDS_FORMAT_BACKEDUP				554
#define IDS_INSTALLCERT_USAGEARGS			555
#define IDS_INSTALLCERT_DESCRIPTION			556
#define IDS_DUMP_PKCS7_CONTENTS				557
#define IDS_DUMP_PKCS7_ATTRIBUTES			558
#define IDS_DUMP_PKCS7_SIGNCERT				559
#define IDS_FORMAT_DUMP_LEVEL_START			560
#define IDS_FORMAT_DUMP_LEVEL_END			561
#define IDS_FORMAT_LANG					562
#define IDS_FORMAT_FILE					563
#define IDS_FORMAT_PRODUCT				564
#define IDS_DUMP_PKCS7_NO_SIGNER			565
#define IDS_DUMP_PKCS7_NO_CONTENT			566
#define IDS_DUMP_PKCS7_NO_CERTIFICATES			567
#define IDS_DUMP_PKCS7_NO_CRLS				568
#define IDS_DUMP_PKCS7_CERTIFICATES			569
#define IDS_DUMP_PKCS7_CRLS				570
#define IDS_RENEWAL_CERT				571
#define IDS_FORMAT_ENCRYPTEDHASH_COLON			572
#define IDS_FORMAT_PKCS7_ATTRIBUTE_COUNT		573
#define IDS_ATTRIBUTE					574
#define IDS_FORMAT_PKCS7_ATTRIBUTE_VALUE		575
#define IDS_BACKUPDB_USAGEARGS				576
#define IDS_BACKUPDB_DESCRIPTION			577
#define IDS_RESTOREDB_USAGEARGS				578
#define IDS_RESTOREDB_DESCRIPTION			579
#define IDS_CRL_REASON_UNSPECIFIED			580
#define IDS_CRL_REASON_KEY_COMPROMISE			581
#define IDS_CRL_REASON_CA_COMPROMISE			582
#define IDS_CRL_REASON_AFFILIATION_CHANGED		583
#define IDS_CRL_REASON_SUPERSEDED			584
#define IDS_CRL_REASON_CESSATION_OF_OPERATION		585
#define IDS_CRL_REASON_CERTIFICATE_HOLD			586
#define IDS_CRL_REASON_REMOVE_FROM_CRL			587
#define IDS_CSP_DESCRIPTION			        588
#define IDS_CSPTEST_DESCRIPTION				589
#define IDS_CSPTEST_USAGEARGS				590
#define IDS_SILENT_DESCRIPTION				591
#define IDS_VIEW_ARGDESCRIPTION				592
#define IDS_GETCERT_USAGEARGS				593
#define IDS_DISP_ACTIVE					594
#define IDS_DISP_PENDING				595
#define IDS_DISP_ISSUED					596
#define IDS_DISP_REVOKED				597
#define IDS_DISP_ERROR					598
#define IDS_DISP_DENIED					599
#define IDS_RENEWALCERT					600
#define IDS_FORMAT_RESTORE_NEEDS_RESTART		601
#define IDS_ADMIN_INTERFACE_ALIVE			602
#define IDS_DB_OPEN_FAILURE				603
#define IDS_DB_ACCESS_STOP_SERVER			604
#define IDS_CONFIGDISPLAY_LOCAL				605
#define IDS_ERR_FORMAT_NO_LOCAL_CONFIG			606
#define IDS_CRL_REASON_UNREVOKE				607
#define IDS_ERROR_ACCESSDENIED_CAUSE                    608
#define IDS_NO_KEY_PROPERTY				609
#define IDS_FORMAT_SERVER_ALIVE				610
#define IDS_FORMAT_CONNECTING				611
#define IDS_USER_DESCRIPTION				612
#define IDS_FORMAT_DUMP_CERT_INDEX			613
#define IDS_NEWPASSWORDPROMPT				614
#define IDS_CONFIRMPASSWORDPROMPT			615
#define IDS_NOCONFIRMPASSWORD				616
#define IDS_NO_KEY					617
#define IDS_BACKUP_USAGEARGS				618
#define IDS_BACKUP_DESCRIPTION				619
#define IDS_RESTORE_USAGEARGS				620
#define IDS_RESTORE_DESCRIPTION 			621
#define IDS_ADDSTORE_USAGEARGS				622
#define IDS_ADDSTORE_DESCRIPTION			623
#define IDS_DELSTORE_USAGEARGS				624
#define IDS_DELSTORE_DESCRIPTION			625
#define IDS_VERIFYSTORE_USAGEARGS			626
#define IDS_VERIFYSTORE_DESCRIPTION			627
#define IDS_FORMAT_DELETE_CERT_INDEX			628
#define IDS_UNTRUSTED_ROOT				629
#define IDS_INCOMPLETE_CHAIN				630
#define IDS_CERT_VERIFIES				631
#define IDS_CR_DISP_INCOMPLETE				632
#define IDS_CR_DISP_ERROR				633
#define IDS_CR_DISP_DENIED				634
#define IDS_CR_DISP_ISSUED				635
#define IDS_CR_DISP_ISSUED_OUT_OF_BAND			636
#define IDS_CR_DISP_UNDER_SUBMISSION			637
#define IDS_CR_DISP_REVOKED				638
#define IDS_CERT_DISPOSITION_PENDING			639
#define IDS_ROOT_STORE_NEEDS_ROOT_CERT			640
#define IDS_FORCE_DESCRIPTION				641
#define IDS_FORMAT_USE_FORCE 				642
#define IDS_FORMAT_BACKEDUPDBNOFULL			643
#define IDS_FORMAT_BACKEDUPDBFULL			644
#define IDS_FORMAT_BACKEDUPDB				645
#define IDS_FORMAT_BACKEDUPDBKEEP			646
#define IDS_FORMAT_BACKEDUPDBNOKEEP			647
#define IDS_FORMAT_RESTOREDB				648
#define IDS_UNKNOWN_ATTRIBUTE				649
#define IDS_OIDNAME_USAGEARGS				650
#define IDS_OIDNAME_DESCRIPTION				651
#define IDS_UNKNOWN_OBJECTID				652
#define IDS_IMPORTCERT_USAGEARGS                        653
#define IDS_IMPORTCERT_DESCRIPTION                      654
#define IDS_FORMAT_IMPORTCERT                           655
#define IDS_REVOCATION_OFFLINE				656
#define IDS_NO_REVOCATION_CHECK				657
#define IDS_DYNAMICFILES_DESCRIPTION			658
#define IDS_GETREG_USAGEARGS				659
#define IDS_GETREG_DESCRIPTION				660
#define IDS_SETREG_USAGEARGS				661
#define IDS_SETREG_DESCRIPTION				662
#define IDS_OLD_REG_VALUE				663
#define IDS_NEW_REG_VALUE				664
#define IDS_FORMAT_ALTNAMECOUNT				665
#define IDS_ALTNAME					666
#define IDS_DATABASELOCATIONS_DESCRIPTION		667
#define IDS_FORMAT_INVALIDBACKUPDIR			668
#define IDS_FORMAT_INVALIDRESTOREDIR			669
#define IDS_FORMAT_BADBACKUPRESULTS			670
#define IDS_FORMAT_RESTOREDDBNOFULL			671
#define IDS_FORMAT_RESTOREDDBFULL			672
#define IDS_IMPORTEDCERT				673
#define IDS_NOWNOTBEFORE_ERROR				674
#define IDS_NOWNOTAFTER_ERROR				675
#define IDS_CANOTBEFORE_ERROR				676
#define IDS_CANOTAFTER_ERROR				677
#define IDS_TELETEX_EXTENSIONS				678
#define IDS_ERRCODE_USAGEARGS				679
#define IDS_ERRCODE_DESCRIPTION				680
#define IDS_VROOT_DESCRIPTION				681
#define IDS_FORMAT_VROOT				682
#define IDS_FORMAT_FILESHARE				683
#define IDS_VROOTDISP_CREATED				684
#define IDS_VROOTDISP_DELETED				685
#define IDS_VROOTDISP_EXISTS				686
#define IDS_VROOTDISP_NOTFOUND				687
#define IDS_VROOTDISP_CREATEERROR			688
#define IDS_VROOTDISP_DELETERROR			689
#define IDS_VROOTDISP_NOTSUPPORTED			690
#define IDS_VROOT_USAGEARGS				691
#define IDS_BACKUPPROGRESSDB				692
#define IDS_BACKUPPROGRESSLOG				693
#define IDS_BACKUPPROGRESSTRUNCATELOG			694
#define IDS_RESTOREPROGRESSDB				695
#define IDS_RESTOREPROGRESSLOG				696
#define IDS_MAXINDEX					697
#define IDS_DISP_CA_CERT				698
#define IDS_DISP_CA_CERT_CHAIN				699
#define IDS_CHARS					700
#define IDS_OVERFLOW					701
#define IDS_FORMAT_USAGE_REPEATEDNAMEDARG		702
#define IDS_INCOMPLETE_CONFIG				703
#define IDS_DSPUBLISH_ARGDESCRIPTION			704
#define IDS_DB_ACCESS_INSTALL_SERVER			705
#define IDS_RED_CONNECTING				706
#define IDS_RED_CONNECT_FAIL				707
#define IDS_RED_CROW_CONVERT				708
#define IDS_RED_CROW_DUP				709
#define IDS_RED_CROW_BADCA				710
#define IDS_RED_ROWID					711
#define IDS_RED_SKIP_DUP				712
#define IDS_RED_SKIP_BADCA				713
#define IDS_RED_ROW_MAP					714
#define IDS_RED_BEGIN_NAMES				715
#define IDS_RED_END_NAMES				716
#define IDS_GETMAPI_DESCRIPTION				717
#define IDS_SETMAPI_USAGEARGS				718
#define IDS_SETMAPI_DESCRIPTION				719
#define IDS_VIEW_ROWS					720
#define IDS_VIEW_ROWPROPERTIES				721
#define IDS_VIEW_ATTRIBUTES				722
#define IDS_VIEW_EXTENSIONS				723
#define IDS_VIEW_TOTALFIELDS				724
#define IDS_VIEW_STATS					725
#define IDS_PRIVATE_KEY_NOT_EXPORTABLE                  726
#define IDS_ENTERPRISE_ROOT                             727
#define IDS_ENTERPRISE_SUB                              728
#define IDS_STANDALONE_ROOT                             729
#define IDS_STANDALONE_SUB                              730
#define IDS_CATYPE_UNKNOWN                              731
#define IDS_RENEWCERT_USAGEARGS				732
#define IDS_RENEWCERT_DESCRIPTION			733
#define IDS_FORMAT_CERTHASH_COLON			734
#define IDS_FORMAT_MESSAGE_TEXT				735
#define IDS_FORMAT_DUMP_CRL_INDEX			736
#define IDS_FORMAT_DELETE_CRL_INDEX			737
#define IDS_FORMAT_CCACERTS				738
#define IDS_KEYS					739
#define IDS_VALUES					740
#define IDS_FORMAT_LOADTESTCRL				741
#define IDS_CRL						742
#define IDS_NOWNOTBEFORECRL_ERROR			743
#define IDS_NOWNOTAFTERCRL_ERROR			744
#define IDS_CANOTBEFORECRL_ERROR			745
#define IDS_CANOTAFTERCRL_ERROR				746
#define IDS_FORMAT_CA_CRLSUBJECT_NOT_ISSUER		747
#define IDS_CA_CRLSUBJECT_IS_ISSUER			748
#define IDS_ERR_CA_SIG_NOT_CRLISSUER			749
#define IDS_CRL_SIG_OK					750
#define IDS_KEYID_IS_KEYAUTHORITY			751
#define IDS_ERR_KEYID_NOT_KEYAUTHORITY			752
#define IDS_NO_KEYID					753
#define IDS_CADISP_INCOMPLETE				754
#define IDS_CADISP_ERROR				755
#define IDS_CADISP_ERROR_CRL				756
#define IDS_CADISP_REVOKED				757
#define IDS_CADISP_VALID				758
#define IDS_CADISP_EXPIRED				759
#define IDS_CADISP_UNDERSUBMISSION			760
#define IDS_CADISP_UNKNOWN				761
#define IDS_KEY_USAGEARGS				762
#define IDS_KEY_DESCRIPTION				763
#define IDS_DELKEY_USAGEARGS				764
#define IDS_DELKEY_DESCRIPTION				765
#define IDS_REVOKED_CERT				766
#define IDS_PROP_CACERSTATUSCODE			767
#define IDS_CONFIGDISPLAY_FLAGS_COLON			768
#define IDS_ERR_PRIVATEKEY_MISMATCH			769
#define IDS_SIGNATURE_OK				770
#define IDS_SIGNATURE_BAD				771
#define IDS_DSCERT_DESCRIPTION				772
#define IDS_DSCERT_USAGEARGS				773
#define IDS_DSCRL_DESCRIPTION				774
#define IDS_DSCRL_USAGEARGS				775
#define IDS_DS_USAGEARGS				776
#define IDS_DS_DESCRIPTION				777
#define IDS_DSDEL_USAGEARGS				778
#define IDS_DSDEL_DESCRIPTION				779
#define IDS_DELETING					780
#define IDS_CAINFO_USAGEARGS				781
#define IDS_CAINFO_DESCRIPTION				782
#define IDS_CAINFO_USAGEHEADERCOLON			783
#define IDS_CAINFO_USAGEERROR				784
#define IDS_CAINFO_USAGEINDEX				785
#define IDS_REQFLAGS_FORCEUTF8				786
#define IDS_FORMAT_SIGNATURE_UNUSEDBITS			787
#define IDS_CONFIGDISPLAY_SHORTNAME_COLON		788
#define IDS_CONFIGDISPLAY_SANITIZEDSHORTNAME_COLON	789
#define IDS_SMIME_CAPABILITIES				790
#define IDS_REQUEST_FILE_COLON				791
#define IDS_PKCS7ATTRIBUTE				792
#define IDS_NO_SIGNATURE				793
#define IDS_DUMP_CERTSEQ				794
#define IDS_MISSING_CERT				795
//#define IDS_UNUSED					796
#define IDS_SCHEMA_USAGE				797
#define IDS_VIEW_USAGE					798
#define IDS_DSDELTACRL_USAGEARGS			799
#define IDS_DSDELTACRL_DESCRIPTION			800
#define IDS_SECONDS_DESCRIPTION				801
#define IDS_NOBASICCONSTRAINTS2_ERROR			802
#define IDS_CANNOTDECODEBASICCONSTRAINTS2_ERROR		803
#define IDS_ENDENTITYCACERT_ERROR			804
#define IDS_CACERT					805
#define IDS_ENDENTITYCERT				806
#define IDS_FORMAT_ELEMENT				807
#define IDS_REQTYPE_CMC					808
#define IDS_ERR_FORMAT_BAD_CERT				809
#define IDS_ENCRYPTION_OK				810
#define IDS_ENCRYPTION_BAD				811
#define IDS_V1_DESCRIPTION				812
#define IDS_PROP_FILEVERSION				813
#define IDS_PROP_PRODUCTVERSION				814
#define IDS_PROP_EXITCOUNT				815
#define IDS_PROP_EXITDESCRIPTION			816
#define IDS_PROP_POLICYDESCRIPTION			817
#define IDS_PROP_CANAME					818
#define IDS_PROP_SANITIZEDCANAME			819
#define IDS_PROP_SHAREDFOLDER				820
#define IDS_PROP_CATYPE					821
#define IDS_PROP_PARENTCA				822
#define IDS_PROP_CASIGCERTCOUNT				823
#define IDS_PROP_CASIGCERT				824
#define IDS_PROP_CASIGCERTCHAIN				825
#define IDS_PROP_CAXCHGCERTCOUNT			826
#define IDS_PROP_CAXCHGCERT				827
#define IDS_PROP_CAXCHGCERTCHAIN			828
#define IDS_PROP_BASECRL				829
#define IDS_PROP_DELTACRL				830
#define IDS_PROP_CACERTSTATE				831
#define IDS_PROP_CRLSTATE				832
#define IDS_PROP_CAINFO					833
#define IDS_CAPROPINFO_DESCRIPTION			834
#define IDS_ADMIN_DESCRIPTION				835
#define IDS_PROP_CAPROPIDMAX				836
#define IDS_GETCERT_DESCRIPTION				837
#define IDS_GETCERT_TITLE    				838
#define IDS_GETCERT_SUBTITLE				839
#define IDS_GETCERT_SUBTITLE_OBJID			840
#define IDS_GETCERT_SUBTITLE_ERA			841
#define IDS_GETCERT_SUBTITLE_KRA			842
#define IDS_FORMAT_KEYHASH_COLON			843
#define IDS_DUMP_CMC					844
#define IDS_DUMP_CMCRESPONSE				845
#define IDS_TAGGED_ATTRIBUTES				846
#define IDS_TAGGED_CONTENTINFO				847
#define IDS_TAGGED_REQUESTS				848
#define IDS_TAGGED_OTHERMESSAGES			849
#define IDS_UNKNOWN_REQUEST_CHOICE			850
#define IDS_BODY_PART_ID				851
#define IDS_ERR_FORMAT_LOADKEY				852
#define IDS_EXPIRED_CERT				853
#define IDS_DUMP_PKCS7_UNAUTHATTRIBUTES			854
#define IDS_DUMP_PKCS7_CONTENT_TYPE			855
#define IDS_DATA_REFERENCE				856
#define IDS_CERT_REFERENCE				857
#define IDS_VALUE					858
#define IDS_UNKNOWN_TAGGED_ATTRIBUTE			859
#define IDS_DUMP_PKCS7_SIGNER_COUNT			860
#define IDS_SIGNER_INFO					861
#define IDS_HASH_ALGORITHM				862
#define IDS_HASH_ENCRYPTION_ALGORITHM			863
#define IDS_FORMAT_STORED_HASH_COLON			864
#define IDS_FORMAT_COMPUTED_HASH_COLON			865
#define IDS_CMCATTRIBUTE				866
#define IDS_EXCHANGEAIA					867
#define IDS_EXCHANGEVERSION				868
#define IDS_HASHFILE_USAGEARGS                          869
#define IDS_HASHFILE_DESCRIPTION                        870
#define IDS_FORMAT_HASHFILEOUTPUT                       871
#define IDS_REQFLAGS_CAXCHGCERT				872
#define IDS_PASS					873
#define IDS_DUMP_PKCS7_NO_RECIPIENT			874
#define IDS_DUMP_PKCS7_RECIPIENT_COUNT			875
#define IDS_RECIPIENT_INFO				876
#define IDS_PROP_DNSNAME				877
#define IDS_GETKEY_USAGEARGS				878
#define IDS_GETKEY_DESCRIPTION				879
#define IDS_RECOVERKEY_USAGEARGS			880
#define IDS_RECOVERKEY_DESCRIPTION			881
#define IDS_DUMP_USAGEARGS				882
#define IDS_DUMP_DECRYPTED				883
#define IDS_CANT_DECRYPT				884
#define IDS_NEED_RECOVERY_CERT				885
#define IDS_USER_CERT					886
#define IDS_ALGORITHM_CLASS				887
#define IDS_ALGORITHM_TYPE				888
#define IDS_ALGORITHM_SUBID				889
#define IDS_CMC_STATUS					890
#define IDS_BODY_REFERENCE				891
#define IDS_CMC_STATUSSTRING				892
#define IDS_CMC_OTHERCHOICE				893
#define IDS_CMC_FAILINFO				894
#define IDS_PENDTOKEN					895
#define IDS_PENDTIME					896
#define IDS_DSPUBLISH_USAGEARGS				897
#define IDS_DSPUBLISH_DESCRIPTION			898
#define IDS_FORMAT_LOADCERTORCRL			899
// Leave 900 to 1999 for clibres.h
#define IDS_BYTES					2000
#define IDS_FORMAT_ALREADY_IN_DS_STORE			2001
#define IDS_CERTIFICATE					2002
#define IDS_FORMAT_SUBJECTKEYID_COLON			2003
#define IDS_PRECOMPUTED					2004
#define IDS_CANNOT_CREATE_STORE				2005
#define IDS_CANNOT_OPEN_STORE				2006
#define IDS_REPAIRSTORE_USAGEARGS			2007
#define IDS_REPAIRSTORE_DESCRIPTION			2008
//#define IDS_UNUSED					2009
#define IDS_DELREG_DESCRIPTION				2010
#define IDS_DETACHED_SIGNATURE				2011
#define IDS_EXPORTPFX_USAGEARGS				2012
#define IDS_EXPORTPFX_DESCRIPTION			2013
#define IDS_IMPORTPFX_USAGEARGS				2014
#define IDS_IMPORTPFX_DESCRIPTION			2015
#define IDS_DSTEMPLATE_USAGEARGS			2016
#define IDS_DSTEMPLATE_DESCRIPTION			2017
#define IDS_DSADDTEMPLATE_USAGEARGS			2018
#define IDS_DSADDTEMPLATE_DESCRIPTION			2019
#define IDS_CREATED_TEMPLATE				2020
#define IDS_UPDATED_TEMPLATE				2021
#define IDS_FORMAT_COMMAND_SUCCEEDED			2022
#define IDS_FORMAT_RESTART_SERVER			2023
#define IDS_TEMPLATE_USAGEARGS				2024
#define IDS_TEMPLATE_DESCRIPTION			2025
#define IDS_TEMPLATECAS_USAGEARGS			2026
#define IDS_TEMPLATECAS_DESCRIPTION			2027
#define IDS_CATEMPLATES_USAGEARGS			2028
#define IDS_CATEMPLATES_DESCRIPTION			2029
#define IDS_UT_DESCRIPTION				2030
#define IDS_MT_DESCRIPTION				2031
#define IDS_TEMPLATE_EXTENSIONS				2032
//#define IDS_UNUSED					2033
//#define IDS_UNUSED					2034
#define IDS_NOCR_DESCRIPTION				2035
#define IDS_ENCODEHEX_USAGEARGS				2036
#define IDS_ENCODEHEX_DESCRIPTION			2037
#define IDS_FORMAT_ELEMENT_DUMP				2038
#define IDS_SPLIT_DESCRIPTION				2039
#define IDS_ENTERPRISE_DESCRIPTION			2040
#define IDS_EXPORTPVK_USAGEARGS				2041
#define IDS_EXPORTPVK_DESCRIPTION			2042
#define IDS_FORMAT_QUERYING				2043
#define IDS_PROP_ROLESEPARATIONENABLED			2044
#define IDS_ISSUANCE_POLICIES				2045
#define IDS_APPLICATION_POLICIES			2046
#define IDS_URLCACHE_USAGEARGS				2047
#define IDS_URLCACHE_DESCRIPTION			2048
#define IDS_PROP_KRACERTCOUNT				2049
#define IDS_PROP_KRACERTUSEDCOUNT			2050
#define IDS_PROP_KRACERT				2051
#define IDS_INVALID_OBJECTID				2052
#define IDS_DUMP_PKCS7CMS				2053
#define IDS_NO_DISPLAY_NAMES				2054
#define IDS_TYPE_MISMATCH				2055
#define IDS_LOCALIZEDNAME				2056
#define IDS_CSP_PROVIDER_INFO				2057
#define IDS_SIGN_USAGEARGS				2058
#define IDS_SIGN_DESCRIPTION				2059
#define IDS_SIGNINGSUBJECT				2060
#define IDS_DELETEROW_USAGEARGS				2061
#define IDS_DELETEROW_DESCRIPTION			2062
#define IDS_FORMAT_DELETED_ROW_COUNT			2063
#define IDS_FORMAT_DATE_REQUIRES_TABLE			2064
#define IDS_FORMAT_DATE_IN_FUTURE			2065
#define IDS_FORMAT_CRLHASH_COLON			2066
#define IDS_REQTYPE_CRLS				2067
#define IDS_REQTYPE_FULLRESPONSE			2068
#define IDS_PROP_CASIGCERTCRLCHAIN			2069
#define IDS_PROP_CAXCHGCERTCRLCHAIN			2070
#define IDS_PULSE_DESCRIPTION				2071
#define IDS_MACHINEINFO_USAGEARGS			2072
#define IDS_MACHINEINFO_DESCRIPTION			2073
#define IDS_FORMAT_MISSING_MACHINE_ATTRIBUTE		2074
#define IDS_GROUP_LIST_COLON				2075
#define IDS_DCINFO_USAGEARGS				2076
#define IDS_DCINFO_DESCRIPTION				2077
#define IDS_REMOTEENTROOT				2078
#define IDS_REMOTEKDCCERT				2079
#define IDS_DCUNAVAILABLE				2080
#define IDS_FORMAT_TESTINGDC				2081
#define IDS_FORMAT_DCROOTCERTS				2082
#define IDS_FORMAT_KDCCERTS				2083
#define IDS_UNKNOWN_PROPERTY				2084
#define IDS_TEMPLATE_NAME				2085
#define IDS_FORMAT_PUBLICKEY_LENGTH			2086
#define IDS_PROP_ADVANCEDSERVER				2087
#define IDS_PROP_BASECRLPUBLISHSTATUS			2088
#define IDS_PROP_DELTACRLPUBLISHSTATUS			2089
#define IDS_PROP_TEMPLATES				2090
#define IDS_FORMAT_PROVPARM				2091
#define IDS_FORMAT_PROVPARMFLAGS			2092
#define IDS_ARCHIVED					2093
#define IDS_ENTINFO_USAGEARGS				2094
#define IDS_ENTINFO_DESCRIPTION				2095
#define IDS_TCAINFO_DESCRIPTION				2096
#define IDS_FORMAT_DSSKEY_LENGTH			2097
#define IDS_FORMAT_DUMP_CTL_INDEX			2098
#define IDS_CLIENTID					2099
#define IDS_USERCOLON					2100
#define IDS_MACHINECOLON				2101
#define IDS_DUMP_CTL					2102
#define IDS_LISTID					2103
#define IDS_SEQUENCENO					2104
#define IDS_SUBJECT_ALGORITHM				2105
#define IDS_CTLENTRIES					2106
#define IDS_USAGEENTRIES				2107
#define IDS_FORMAT_SUBJECTID_COLON			2108
#define IDS_VIEWSTORE_TITLE				2109
#define IDS_VIEWSTORE_SUBTITLE				2110
#define IDS_VIEWSTORE_SUBTITLE_DELETE			2111
#define IDS_FORMAT_SAVED_CERT_NAME			2112
#define IDS_FORMAT_DELETED_CERT_NAME			2113
#define IDS_REQFLAGS_ENROLLONBEHALFOF			2114
#define IDS_SCINFO_USAGEARGS				2115
#define IDS_SCINFO_DESCRIPTION				2116
#define IDS_SERVICEPAUSED				2117
#define IDS_SERVICESTOPPED				2118
#define IDS_SERVICEUNKNOWNSTATE				2119
#define IDS_SMARTCARD_RUNNING				2120
#define IDS_SMARTCARD_NOTRUNNING			2121
#define IDS_SIGNATURE_NOTKEYEXCHANGE			2122
#define IDS_FORMAT_SERVER_DEAD				2123
#define IDS_GETDECRYPTCERT_SUBTITLE			2124
#define IDS_DISP_FOREIGN_CERT				2125
#define IDS_DISP_KRA_CERT				2126
#define IDS_UPN_COLON					2127
#define IDS_REQFLAGS_SUBJECTUNMODIFIED			2128
#define IDS_REQFLAGS_PUBLISHERROR			2129
#define IDS_NULL_SIGNATUREMATCHES			2130
#define IDS_FORMAT_SOURCE_URL				2131
#define IDS_FORMAT_LOCAL_FILENAME			2132
#define IDS_FORMAT_USE_COUNT				2133
#define IDS_FORMAT_HIT_RATE				2134
#define IDS_FORMAT_FILE_SIZE				2135
#define IDS_FORMAT_LAST_MOD_TIME_COLON			2136
#define IDS_FORMAT_EXPIRE_TIME_COLON			2137
#define IDS_FORMAT_LAST_ACCESS_TIME_COLON		2138
#define IDS_FORMAT_LAST_SYNC_TIME_COLON			2139
#define IDS_ERROR_CHECK_MACHINE_NAME			2140
#define IDS_ERROR_NO_TRAILING				2141
#define IDS_ISSUER_DOMAIN_POLICY			2142
#define IDS_SUBJECT_DOMAIN_POLICY			2143
#define IDS_FORMAT_MAP_ARRAY_COLON			2144
#define IDS_FORMAT_CERT_TYPE_NOT_DC			2145
#define IDS_FORMAT_CERT_USAGE_MISSING			2146
#define IDS_FORMAT_DELETE_DC_CERT			2147
#define IDS_FORMAT_DELETE_CERT_FROM_STORE_FAILED	2148
#define IDS_FORMAT_KDC_PATH				2149
#define IDS_NO_KDC_MY_STORE				2150
#define IDS_NO_KDC_ENT_STORE				2151
#define IDS_FORMAT_OPEN_REMOTE_MY_FAILED		2152
#define IDS_FORMAT_ERROR_GET_ARCHIVE_PROP		2153
#define IDS_LIST_ARCHIVED_CERT				2154
#define IDS_NO_AUTOENROLLED_CERT			2155 
#define IDS_FORMAT_OPEN_STORE_REMOTE_ENT_FAILED		2156
#define IDS_NO_AUTOENROLL_OBJECT			2157
#define IDS_NO_ACCESS					2158
#define IDS_CA_EXPIRATION_DATA				2159
#define IDS_FORMAT_CA_EXPIRATION_FAILED			2160
#define IDS_FORMAT_CA_EXPIRATION			2161
#define IDS_SUPPORTED_TEMPLATE				2162
#define IDS_NO_SUPPORTED_TEMPLATE			2163
#define IDS_FORMAT_CA_NAME_PROP_FAILED			2164
#define IDS_FORMAT_CA_NAME_LIST				2165
#define IDS_FORMAT_CA_DNS_PROP_FAILED			2166
#define IDS_FORMAT_CA_MACHINE_LIST			2167
#define IDS_FORMAT_CA_DS_LIST				2168
#define IDS_FORMAT_CERT_DN_PROP_FAILED			2169
#define IDS_FORMAT_CERT_DN_LIST				2170
#define IDS_FORMAT_CA_ALG_PROP_FAILED			2171
#define IDS_FORMAT_CA_ALG_LIST				2172
#define IDS_NO_ALG_UNEXPECTED				2173
#define IDS_NO_CT_FOR_CA				2174
#define IDS_NO_CT_BUT_EXISTS				2175
#define IDS_NO_CA_ON_DOMAIN				2176
#define IDS_FORMAT_NO_DFS				2177
#define IDS_DFS_DATA_ACCESS				2178
#define IDS_NO_ENTRY_IN_PING				2179
#define IDS_NO_DSPATH					2180
#define IDS_FORMAT_REG_QUERY_VALUE_FAILED		2181
#define IDS_NO_FILE_SYS_PATH				2182
#define IDS_API_RPINT_FAILED				2183
#define IDS_FORMAT_LDAP_NO_ENTRY			2184
#define IDS_ROOT_CERT_IN_POLICY				2185
#define IDS_FORMAT_CERT_COLON				2186
#define IDS_NO_ROOT_IN_POLICY				2187
#define IDS_CHECK_EVENT_LOG				2188
#define IDS_POLICY_MACHINE				2189
#define IDS_POLICY_USER					2190
#define IDS_POSSIBLE_NO_POLICY				2191
#define IDS_DEFAULT_CERT_FOR_MACHINE			2192
#define IDS_DEFAULT_CERT_FOR_USER			2193
#define IDS_POLICY_DOWNLOAD_ERROR			2194
#define IDS_FORMAT_COMPUTER_NAME			2195
#define IDS_FORMAT_USER_NAME				2196
#define IDS_BAD_OPTION					2197
#define IDS_FORMAT_MACHINE_LIST				2198
#define IDS_FORMAT_KEY_LIST				2199
#define IDS_FORMAT_GPO_NAME				2200
#define IDS_REQUEST_SIGNATUREMATCHES			2201
#define IDS_OUT_USAGE					2202
#define IDS_OUT_DESCRIPTION				2203
#define IDS_RESTRICT_USAGE				2204
#define IDS_RESTRICT_DESCRIPTION			2205
#define IDS_CONFIG_USAGE				2206
#define IDS_CONFIG_DESCRIPTION				2207
#define IDS_USAGE_LIST_VERBS				2208
#define IDS_FORMAT_USAGE_ONE_HELP			2209
#define IDS_USAGE_ALL_HELP				2210
#define IDS_IMPORT_CERT_FOREIGN				2211
#define IDS_IMPORT_CERT_DOMESTIC			2212
#define IDS_IMPORT_CERT_EXISTS				2213
#define IDS_IMPORT_KEY_REPLACED				2214
#define IDS_IMPORT_KEY_SAVED				2215
#define IDS_IMPORT_KEY_EXISTS				2216
#define IDS_IMPORT_CERT_SKIPPED_SIGNING			2217
#define IDS_KMS_USERS					2218
#define IDS_KMS_CERTS_SKIPPED				2219
#define IDS_KMS_CERTS_TOTAL				2220
#define IDS_KMS_CERTS_FOREIGN				2221
#define IDS_KMS_CERTS_ALREADYSAVED			2222
#define IDS_KMS_CERTS_SAVED				2223
#define IDS_KMS_CERTS_NOTSAVED				2224
#define IDS_KMS_KEYS_TOTAL				2225
#define IDS_KMS_KEYS_ALREADYSAVED			2226
#define IDS_KMS_KEYS_UPDATED				2227
#define IDS_KMS_KEYS_SAVED				2228
#define IDS_KMS_KEYS_NOTSAVED				2229
#define IDS_MERGEPFX_DESCRIPTION			2230
#define IDS_MERGEPFX_USAGEARGS				2231
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\tools\certut\reg.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       reg.cpp
//
//--------------------------------------------------------------------------

#include <pch.cpp>

#pragma hdrstop

#include <xenroll.h>
#include "polreg.h"
#include "certtype.h"


// add two WCHAR L'\0's after the registry value, in case of a poorly
// formed REG_MULTI_SZ.  Add another to handle possible odd sizes.

#define cbVALUEZEROPAD	(3 * sizeof(WCHAR))


typedef struct _DUMPFLAGS
{
    DWORD Mask;
    DWORD Value;
    WCHAR const *pwszDescription;
} DUMPFLAGS;


#define _DFBIT(def)		{ (def), (def), L#def }
#define _DFBIT2(mask, def)	{ (mask), (def), L#def }


DUMPFLAGS g_adfEditFlags[] =
{
    _DFBIT(EDITF_ENABLEREQUESTEXTENSIONS),
    _DFBIT(EDITF_REQUESTEXTENSIONLIST),
    _DFBIT(EDITF_DISABLEEXTENSIONLIST),
    _DFBIT(EDITF_ADDOLDKEYUSAGE),
    _DFBIT(EDITF_ADDOLDCERTTYPE),
    _DFBIT(EDITF_ATTRIBUTEENDDATE),
    _DFBIT(EDITF_BASICCONSTRAINTSCRITICAL),
    _DFBIT(EDITF_BASICCONSTRAINTSCA),
    _DFBIT(EDITF_ENABLEAKIKEYID),
    _DFBIT(EDITF_ATTRIBUTECA),
    _DFBIT(EDITF_IGNOREREQUESTERGROUP),
    _DFBIT(EDITF_ENABLEAKIISSUERNAME),
    _DFBIT(EDITF_ENABLEAKIISSUERSERIAL),
    _DFBIT(EDITF_ENABLEAKICRITICAL),
    _DFBIT(EDITF_SERVERUPGRADED),
    _DFBIT(EDITF_ATTRIBUTEEKU),
    _DFBIT(EDITF_ENABLEDEFAULTSMIME),
    { 0, 0, NULL }
};

DUMPFLAGS g_adfCRLFlags[] =
{
    _DFBIT(CRLF_DELTA_USE_OLDEST_UNEXPIRED_BASE),
    _DFBIT(CRLF_DELETE_EXPIRED_CRLS),
    _DFBIT(CRLF_CRLNUMBER_CRITICAL),
    _DFBIT(CRLF_REVCHECK_IGNORE_OFFLINE),
    _DFBIT(CRLF_IGNORE_INVALID_POLICIES),
    _DFBIT(CRLF_REBUILD_MODIFIED_SUBJECT_ONLY),
    _DFBIT(CRLF_SAVE_FAILED_CERTS),
    _DFBIT(CRLF_IGNORE_UNKNOWN_CMC_ATTRIBUTES),
    _DFBIT(CRLF_ACCEPT_OLDRFC_CMC),
    _DFBIT(CRLF_PUBLISH_EXPIRED_CERT_CRLS),
    { 0, 0, NULL }
};

DUMPFLAGS g_adfKRAFlags[] =
{
    _DFBIT(KRAF_ENABLEFOREIGN),
    _DFBIT(KRAF_SAVEBADREQUESTKEY),
    { 0, 0, NULL }
};

#define ISSCERT_LDAPURL		ISSCERT_LDAPURL_OLD
#define ISSCERT_HTTPURL		ISSCERT_HTTPURL_OLD
#define ISSCERT_FTPURL		ISSCERT_FTPURL_OLD
#define ISSCERT_FILEURL		ISSCERT_FILEURL_OLD

DUMPFLAGS g_adfIssuercertFlags[] =
{
    _DFBIT(ISSCERT_LDAPURL),
    _DFBIT(ISSCERT_HTTPURL),
    _DFBIT(ISSCERT_FTPURL),
    _DFBIT(ISSCERT_FILEURL),
    _DFBIT(ISSCERT_ENABLE),
    { 0, 0, NULL }
};


DUMPFLAGS g_adfRequestDispositionFlags[] =
{
    _DFBIT2(REQDISP_MASK, REQDISP_PENDING),
    _DFBIT2(REQDISP_MASK, REQDISP_ISSUE),
    _DFBIT2(REQDISP_MASK, REQDISP_DENY),
    _DFBIT2(REQDISP_MASK, REQDISP_USEREQUESTATTRIBUTE),
    _DFBIT(REQDISP_PENDINGFIRST),
    { 0, 0, NULL }
};


#define REVEXT_CDPLDAPURL	REVEXT_CDPLDAPURL_OLD
#define REVEXT_CDPHTTPURL	REVEXT_CDPHTTPURL_OLD
#define REVEXT_CDPFTPURL	REVEXT_CDPFTPURL_OLD
#define REVEXT_CDPFILEURL	REVEXT_CDPFILEURL_OLD

DUMPFLAGS g_adfRevocationTypeFlags[] =
{
    _DFBIT(REVEXT_CDPLDAPURL),
    _DFBIT(REVEXT_CDPHTTPURL),
    _DFBIT(REVEXT_CDPFTPURL),
    _DFBIT(REVEXT_CDPFILEURL),
    _DFBIT(REVEXT_CDPENABLE),
    _DFBIT(REVEXT_ASPENABLE),
    { 0, 0, NULL }
};


DUMPFLAGS g_adfSetupStatus[] =
{
    _DFBIT(SETUP_SERVER_FLAG),
    _DFBIT(SETUP_CLIENT_FLAG),
    _DFBIT(SETUP_SUSPEND_FLAG),
    _DFBIT(SETUP_REQUEST_FLAG),
    _DFBIT(SETUP_ONLINE_FLAG),
    _DFBIT(SETUP_DENIED_FLAG),
    _DFBIT(SETUP_CREATEDB_FLAG),
    _DFBIT(SETUP_ATTEMPT_VROOT_CREATE),
    _DFBIT(SETUP_FORCECRL_FLAG),
    _DFBIT(SETUP_UPDATE_CAOBJECT_SVRTYPE),
    _DFBIT(SETUP_SERVER_UPGRADED_FLAG),
    { 0, 0, NULL }
};


DUMPFLAGS g_adfCertPublishFlags[] =
{
    _DFBIT(EXITPUB_FILE),
    _DFBIT(EXITPUB_ACTIVEDIRECTORY),
    _DFBIT(EXITPUB_EMAILNOTIFYALL),
    _DFBIT(EXITPUB_EMAILNOTIFYSMARTCARD),
    { 0, 0, NULL }
};


DUMPFLAGS g_adfCAType[] =
{
    _DFBIT2(MAXDWORD, ENUM_ENTERPRISE_ROOTCA),
    _DFBIT2(MAXDWORD, ENUM_ENTERPRISE_SUBCA),
    _DFBIT2(MAXDWORD, ENUM_STANDALONE_ROOTCA),
    _DFBIT2(MAXDWORD, ENUM_STANDALONE_SUBCA),
    _DFBIT2(MAXDWORD, ENUM_UNKNOWN_CA),
    { 0, 0, NULL }
};


DUMPFLAGS g_adfForceTeletex[] =
{
    _DFBIT2(ENUM_TELETEX_MASK, ENUM_TELETEX_OFF),
    _DFBIT2(ENUM_TELETEX_MASK, ENUM_TELETEX_ON),
    _DFBIT2(ENUM_TELETEX_MASK, ENUM_TELETEX_AUTO),
    _DFBIT2(ENUM_TELETEX_UTF8, ENUM_TELETEX_UTF8),
    { 0, 0, NULL }
};


DUMPFLAGS g_adfCSURL[] =
{
    _DFBIT(CSURL_SERVERPUBLISH),
    _DFBIT(CSURL_ADDTOCERTCDP),
    _DFBIT(CSURL_ADDTOFRESHESTCRL),
    _DFBIT(CSURL_ADDTOCRLCDP),
    _DFBIT(CSURL_PUBLISHRETRY),
    _DFBIT(CSURL_ADDTOCERTOCSP),
    { 0, 0, NULL }
};


// Enrollment Flags:

DUMPFLAGS g_adfTemplateEnroll[] =
{
    _DFBIT(CT_FLAG_INCLUDE_SYMMETRIC_ALGORITHMS),
    _DFBIT(CT_FLAG_PEND_ALL_REQUESTS),
    _DFBIT(CT_FLAG_PUBLISH_TO_KRA_CONTAINER),
    _DFBIT(CT_FLAG_PUBLISH_TO_DS),
    _DFBIT(CT_FLAG_AUTO_ENROLLMENT_CHECK_USER_DS_CERTIFICATE),
    _DFBIT(CT_FLAG_AUTO_ENROLLMENT),
    _DFBIT(CT_FLAG_PREVIOUS_APPROVAL_VALIDATE_REENROLLMENT),
    _DFBIT(CT_FLAG_DOMAIN_AUTHENTICATION_NOT_REQUIRED),
    _DFBIT(CT_FLAG_USER_INTERACTION_REQUIRED),
    _DFBIT(CT_FLAG_ADD_TEMPLATE_NAME),
    _DFBIT(CT_FLAG_REMOVE_INVALID_CERTIFICATE_FROM_PERSONAL_STORE),
    { 0, 0, NULL }
};


// Certificate Subject Name Flags:

DUMPFLAGS g_adfTemplateName[] =
{
    _DFBIT(CT_FLAG_ENROLLEE_SUPPLIES_SUBJECT),
    _DFBIT(CT_FLAG_ADD_EMAIL),
    _DFBIT(CT_FLAG_ADD_OBJ_GUID),
    _DFBIT(CT_FLAG_ADD_DIRECTORY_PATH),
    _DFBIT(CT_FLAG_ENROLLEE_SUPPLIES_SUBJECT_ALT_NAME),
    _DFBIT(CT_FLAG_SUBJECT_ALT_REQUIRE_SPN),
    _DFBIT(CT_FLAG_SUBJECT_ALT_REQUIRE_DIRECTORY_GUID),
    _DFBIT(CT_FLAG_SUBJECT_ALT_REQUIRE_UPN),
    _DFBIT(CT_FLAG_SUBJECT_ALT_REQUIRE_EMAIL),
    _DFBIT(CT_FLAG_SUBJECT_ALT_REQUIRE_DNS),
    _DFBIT(CT_FLAG_SUBJECT_REQUIRE_DNS_AS_CN),
    _DFBIT(CT_FLAG_SUBJECT_REQUIRE_EMAIL),
    _DFBIT(CT_FLAG_SUBJECT_REQUIRE_COMMON_NAME),
    _DFBIT(CT_FLAG_SUBJECT_REQUIRE_DIRECTORY_PATH),
    { 0, 0, NULL }
};

DUMPFLAGS g_adfTemplatePrivateKey[] =
{
// Private Key Flags:
    _DFBIT(CT_FLAG_REQUIRE_PRIVATE_KEY_ARCHIVAL),
    _DFBIT(CT_FLAG_EXPORTABLE_KEY),
    { 0, 0, NULL }
};


// Old V1 template flags definitions:
//efine CT_FLAG_ENROLLEE_SUPPLIES_SUBJECT   0x00000001
//efine CT_FLAG_ADD_EMAIL                   0x00000002
//efine CT_FLAG_ADD_OBJ_GUID                0x00000004
//efine CT_FLAG_PUBLISH_TO_DS               0x00000008
//efine CT_FLAG_EXPORTABLE_KEY              0x00000010
//efine CT_FLAG_AUTO_ENROLLMENT             0x00000020
//efine CT_FLAG_MACHINE_TYPE                0x00000040
//efine CT_FLAG_IS_CA                       0x00000080
//efine CT_FLAG_ADD_DIRECTORY_PATH          0x00000100
//efine CT_FLAG_ADD_TEMPLATE_NAME           0x00000200
#define CT_FLAG_ADD_SUBJECT_DIRECTORY_PATH  0x00000400
//efine CT_FLAG_IS_CROSS_CA                 0x00000800
//efine CT_FLAG_IS_DEFAULT                  0x00010000
//efine CT_FLAG_IS_MODIFIED                 0x00020000
#define CT_FLAG_IS_DELETED                  0x00040000
#define CT_FLAG_POLICY_MISMATCH             0x00080000


// General Flags

DUMPFLAGS g_adfTemplateGeneral[] =
{
    _DFBIT(CT_FLAG_ENROLLEE_SUPPLIES_SUBJECT),
    _DFBIT(CT_FLAG_ADD_EMAIL),
    _DFBIT(CT_FLAG_ADD_OBJ_GUID),
    _DFBIT(CT_FLAG_PUBLISH_TO_DS),
    _DFBIT(CT_FLAG_EXPORTABLE_KEY),
    _DFBIT(CT_FLAG_AUTO_ENROLLMENT),
    _DFBIT(CT_FLAG_MACHINE_TYPE),
    _DFBIT(CT_FLAG_IS_CA),
    _DFBIT(CT_FLAG_ADD_DIRECTORY_PATH),
    _DFBIT(CT_FLAG_ADD_TEMPLATE_NAME),
    _DFBIT(CT_FLAG_ADD_SUBJECT_DIRECTORY_PATH),
    _DFBIT(CT_FLAG_IS_CROSS_CA),
    _DFBIT(CT_FLAG_IS_DEFAULT),
    _DFBIT(CT_FLAG_IS_MODIFIED),
    _DFBIT(CT_FLAG_IS_DELETED),
    _DFBIT(CT_FLAG_POLICY_MISMATCH),
    { 0, 0, NULL }
};


DUMPFLAGS g_adfKMSCertStatus[] =
{
    _DFBIT(CERTFLAGS_REVOKED),
    _DFBIT(CERTFLAGS_NOT_EXPIRED),
    _DFBIT(CERTFLAGS_SIGNING),
    _DFBIT(CERTFLAGS_SEALING),
    _DFBIT(CERTFLAGS_CURRENT),
    _DFBIT(CERTFLAGS_IMPORTED),
    _DFBIT2(CERTFLAGS_VERSION_3, CERTFLAGS_VERSION_1),
    _DFBIT2(CERTFLAGS_VERSION_3, CERTFLAGS_VERSION_3),
    { 0, 0, NULL }
};


DUMPFLAGS g_adfCRLPublishFlags[] =
{
    _DFBIT(CPF_BASE),
    _DFBIT(CPF_DELTA),
    _DFBIT(CPF_COMPLETE),
    _DFBIT(CPF_SHADOW),
    _DFBIT(CPF_CASTORE_ERROR),
    _DFBIT(CPF_BADURL_ERROR),
    _DFBIT(CPF_MANUAL),
    _DFBIT(CPF_LDAP_ERROR),
    _DFBIT(CPF_FILE_ERROR),
    _DFBIT(CPF_FTP_ERROR),
    _DFBIT(CPF_HTTP_ERROR),
    { 0, 0, NULL }
};

DUMPFLAGS g_adfCAFlags[] =
{
    _DFBIT(CA_FLAG_NO_TEMPLATE_SUPPORT),
    _DFBIT(CA_FLAG_SUPPORTS_NT_AUTHENTICATION),
    _DFBIT(CA_FLAG_CA_SUPPORTS_MANUAL_AUTHENTICATION),
    _DFBIT(CA_FLAG_CA_SERVERTYPE_ADVANCED),
    { 0, 0, NULL }
};


DUMPFLAGS g_adfOIDFlags[] =
{
    _DFBIT2(MAXDWORD, CERT_OID_TYPE_TEMPLATE),
    _DFBIT2(MAXDWORD, CERT_OID_TYPE_ISSUER_POLICY),
    _DFBIT2(MAXDWORD, CERT_OID_TYPE_APPLICATION_POLICY),
    { 0, 0, NULL }
};


DUMPFLAGS g_adfRequestClientId[] =
{
    _DFBIT2(MAXDWORD, XECI_DISABLE),
    _DFBIT2(MAXDWORD, XECI_XENROLL),
    _DFBIT2(MAXDWORD, XECI_AUTOENROLL),
    _DFBIT2(MAXDWORD, XECI_REQWIZARD),
    _DFBIT2(MAXDWORD, XECI_CERTREQ),
    { 0, 0, NULL }
};


typedef struct _DUMPFLAGSREGMAP
{
    WCHAR const *pwszRegName;
    DUMPFLAGS const *adf;
} DUMPFLAGSREGMAP;


DUMPFLAGSREGMAP g_adfrm[] = {
    { wszREGEDITFLAGS,		g_adfEditFlags },
    { wszREGISSUERCERTURLFLAGS,	g_adfIssuercertFlags },
    { wszREGREQUESTDISPOSITION,	g_adfRequestDispositionFlags },
    { wszREGREVOCATIONTYPE,	g_adfRevocationTypeFlags },
    { wszREGSETUPSTATUS,	g_adfSetupStatus },
    { wszREGCERTPUBLISHFLAGS,	g_adfCertPublishFlags },
    { wszREGCRLEDITFLAGS,	g_adfEditFlags },
    { wszREGCRLFLAGS,		g_adfCRLFlags },
    { wszREGKRAFLAGS,		g_adfKRAFlags },
    { wszREGCATYPE,		g_adfCAType},
    { wszREGWEBCLIENTCATYPE,	g_adfCAType},
    { wszREGFORCETELETEX,	g_adfForceTeletex},
    { CERTTYPE_RPOP_ENROLLMENT_FLAG, g_adfTemplateEnroll },
    { CERTTYPE_PROP_NAME_FLAG, g_adfTemplateName },
    { CERTTYPE_PROP_PRIVATE_KEY_FLAG, g_adfTemplatePrivateKey },
  //{ CERTTYPE_PROP_FLAGS,      g_adfTemplateGeneral },
    { wszCUREGDSTEMPLATEFLAGS,	g_adfTemplateGeneral },
    { wszCUREGDSCAFLAGS,	g_adfCAFlags },
  //{ OID_PROP_TYPE,		g_adfOIDFlags },
    { wszCUREGDSOIDFLAGS,	g_adfOIDFlags },
    { wszPROPCERTIFICATEENROLLMENTFLAGS, g_adfTemplateEnroll },
    { wszPROPCERTIFICATEGENERALFLAGS, g_adfTemplateGeneral },
    { wszKMSCERTSTATUS,		g_adfKMSCertStatus },
    { wszPROPCRLPUBLISHFLAGS,	g_adfCRLPublishFlags },
    { wszREQUESTCLIENTID,	g_adfRequestClientId },
    { wszREGCRLPUBLICATIONURLS, g_adfCSURL },
    { wszREGCACERTPUBLICATIONURLS, g_adfCSURL },
    { NULL,			NULL }
};


VOID
cuPrintFlags(
    IN DWORD Flags,
    IN DUMPFLAGS const *pdf)
{
    DWORD ExtraFlags = Flags;
    
    for ( ; NULL != pdf->pwszDescription; pdf++)
    {
	BOOL fSet = (Flags & pdf->Mask) == pdf->Value;

	if (fSet || g_fVerbose)
	{
	    wprintf(
		L"    %ws%ws -- %x",
		fSet? g_wszEmpty : L"  " wszLPAREN,
		pdf->pwszDescription,
		pdf->Value);
	    if (9 < pdf->Value)
	    {
		wprintf(L" (%d)", pdf->Value);
	    }
	    if (!fSet)
	    {
		wprintf(wszRPAREN);
	    }
	    wprintf(wszNewLine);
	}
	ExtraFlags &= ~pdf->Mask;
    }
    if (0 != ExtraFlags)
    {
	wprintf(L"    0x%x (%u)\n", ExtraFlags, ExtraFlags);
    }
}


WCHAR const *
regTail(
    IN WCHAR const *pwszRegName)
{
    WCHAR const *pwsz = wcsrchr(pwszRegName, L'\\');

    if (NULL != pwsz)
    {
	pwsz++;
    }
    else
    {
	pwsz = pwszRegName;
    }
    return(pwsz);
}


HRESULT
cuLookupRegFlags(
    IN WCHAR const *pwszRegName,
    OUT DUMPFLAGS const **ppdf)
{
    HRESULT hr = E_INVALIDARG;
    DUMPFLAGSREGMAP const *pdfrm;

    *ppdf = NULL;
    pwszRegName = regTail(pwszRegName);
    for (pdfrm = g_adfrm; NULL != pdfrm->pwszRegName; pdfrm++)
    {
	if (0 == lstrcmpi(pwszRegName, pdfrm->pwszRegName))
	{
	    *ppdf = pdfrm->adf;
	    hr = S_OK;
	    break;
	}
    }
    return(hr);
}


VOID
cuPrintRegDWord(
    IN DWORD Value,
    IN WCHAR const *pwszRegName)
{
    HRESULT hr;

    pwszRegName = regTail(pwszRegName);
    if (0 == lstrcmpi(wszREGVERSION, pwszRegName))
    {
	wprintf(L" -- %u.%u", Value >> 16, Value & ((1 << 16) - 1));
    }
}


BOOL
cuPrintRegFlags(
    IN BOOL fNewLine,
    IN DWORD Flags,
    IN WCHAR const *pwszRegName)
{
    HRESULT hr;
    DUMPFLAGS const *pdf;

    pwszRegName = regTail(pwszRegName);
    if (0 == lstrcmpi(wszHASHALGORITHM, pwszRegName) ||
	0 == lstrcmpi(wszENCRYPTIONALGORITHM, pwszRegName))
    {
	cuDumpAlgid(Flags);
	hr = S_OK;
    }
    else
    {
	hr = cuLookupRegFlags(pwszRegName, &pdf);
	_JumpIfError2(hr, error, "cuLookupRegFlags", hr);

	if (fNewLine)
	{
	    wprintf(wszNewLine);
	}
	cuPrintFlags(Flags, pdf);
    }

error:
    return(S_OK == hr);
}


HRESULT
cuMapRegFlags(
    IN WCHAR const *pwszRegName,
    IN WCHAR const *pwszRegValue,
    IN BOOL fClearField,
    IN OUT DWORD *pFlags)
{
    HRESULT hr;
    WCHAR const *pwsz;
    DUMPFLAGS const *pdf;

    hr = cuLookupRegFlags(pwszRegName, &pdf);
    _JumpIfErrorStr2(hr, error, "cuLookupRegFlags", pwszRegName, hr);

    for ( ; NULL != pdf->pwszDescription; pdf++)
    {
	if (0 == lstrcmpi(pwszRegValue, pdf->pwszDescription))
	{
	    break;
	}
	pwsz = wcschr(pdf->pwszDescription, L'_');
	if (NULL == pwsz)
	{
	    continue;
	}
	if (0 == lstrcmpi(pwszRegValue, &pwsz[1]))
	{
	    break;
	}
    }
    if (NULL == pdf->pwszDescription)
    {
	hr = E_INVALIDARG;
	_JumpErrorStr2(hr, error, "no match", pwszRegValue, hr);
    }

    *pFlags &= ~pdf->Mask;
    if (!fClearField)
    {
	*pFlags |= pdf->Value;
    }
    hr = S_OK;

error:
    return(hr);
}


HRESULT
OpenSubKey(
    IN OUT HKEY *phkey,
    IN WCHAR const *pwszName,
    OUT WCHAR **ppwszSubKeyName,
    OUT WCHAR **ppwszValueName)
{
    HRESULT hr;
    HKEY hkeySub = NULL;
    HKEY hkey;
    WCHAR *pwszSubKeyName = NULL;
    WCHAR *pwszT;
    DWORD cwcSkip;
    DWORD i;
    WCHAR awc[MAX_PATH];
    
    hr = myDupString(pwszName, &pwszSubKeyName);
    _JumpIfError(hr, error, "myDupString");

    cwcSkip = wcslen(pwszName);

    hr = RegOpenKeyEx(
		*phkey,
		pwszSubKeyName,
		0,
		KEY_ALL_ACCESS,
		&hkeySub);
    if (S_OK != hr)
    {
	//_PrintErrorStr(hr, "RegOpenKeyEx", pwszName);

	hkeySub = NULL;
	pwszT = wcsrchr(pwszSubKeyName, L'\\');
	if (NULL != pwszT)
	{
	    *pwszT = L'\0';
	    cwcSkip = SAFE_SUBTRACT_POINTERS(pwszT, pwszSubKeyName) + 1;

	    hr = RegOpenKeyEx(
			*phkey,
			pwszSubKeyName,
			0,
			KEY_ALL_ACCESS,
			&hkeySub);
	    _JumpIfErrorStr(hr, error, "RegOpenKeyEx", pwszSubKeyName);
	}
    }

    if (NULL != hkeySub)
    {
	pwszName += cwcSkip;

	if (L'\0' != *pwszName)
	{
	    // Look for case-ignore registry value name, & use the value's
	    // correct upper/lower case spelling if an existing registry value:

	    for (i = 0; ; i++)
	    {
		DWORD cwc = ARRAYSIZE(awc);
		hr = RegEnumValue(hkeySub, i, awc, &cwc, NULL, NULL, NULL, NULL);
		if (S_OK != hr)
		{
		    hr = S_OK;
		    break;
		}
		if (0 == lstrcmpi(awc, pwszName))
		{
		    pwszName = awc;
		    break;
		}
	    }
	}
    }

    hr = myDupString(pwszName, ppwszValueName);
    _JumpIfError(hr, error, "myDupString");

    if (NULL != hkeySub)
    {
	RegCloseKey(*phkey);
	*phkey = hkeySub;
	hkeySub = NULL;
    }

    *ppwszSubKeyName = pwszSubKeyName;
    pwszSubKeyName = NULL;

error:
    if (NULL != pwszSubKeyName)
    {
	LocalFree(pwszSubKeyName);
    }
    if (NULL != hkeySub)
    {
	RegCloseKey(hkeySub);
    }
    return(myHError(hr));
}


VOID
PrintRegStringValue(
    IN WCHAR const *pwszLookupName,
    IN WCHAR const *pwszValue)
{
    DWORD Flags;
    
    wprintf(L"%ws", pwszValue);
    if (iswdigit(*pwszValue))
    {
	cuPrintPossibleObjectIdName(pwszValue);
    }
    cuPrintRegFlags(TRUE, _wtoi(pwszValue), pwszLookupName);
}


VOID
PrintRegValue(
    IN WCHAR const *pwszLookupName,
    IN WCHAR const *pwszDisplayName,
    IN DWORD dwType,
    IN BOOL fPrintDwordNameAndValue,
    IN BOOL fPrintType,
    IN DWORD cwcSeparator,
    IN DWORD cbValue,
    OPTIONAL IN BYTE const *pbValue,
    OPTIONAL OUT BOOL *pfLongValue)
{
    HRESULT hr;
    DWORD i;
    WCHAR const *pwsz;
    BOOL fLongValue = FALSE;
    char const *pszEqual = NULL != pbValue? " =" : "";
    
    if (0 == cwcSeparator && fPrintType)
    {
	cwcSeparator = 1;
    }
    if (fPrintDwordNameAndValue)
    {
	wprintf(L"  %ws%*ws", pwszDisplayName, cwcSeparator, L"");
    }
    switch (dwType)
    {
	case REG_DWORD:
	    if (fPrintDwordNameAndValue)
	    {
		wprintf(
		    L"%ws%hs",
		    fPrintType? L"REG_DWORD" : L"",
		    pszEqual);
	    }
	    if (NULL != pbValue)
	    {
		CSASSERT(sizeof(DWORD) == cbValue);
		if (fPrintDwordNameAndValue)
		{
		    wprintf(L" %x", *(DWORD *) pbValue);
		    if (9 < *(DWORD *) pbValue)
		    {
			wprintf(L" (%d)", *(DWORD *) pbValue);
		    }
		    cuPrintRegDWord(*(DWORD *) pbValue, pwszLookupName);
		    wprintf(wszNewLine);
		}
		if (cuPrintRegFlags(FALSE, *(DWORD *) pbValue, pwszLookupName))
		{
		    fLongValue = TRUE;
		}
	    }
	    else
	    {
		if (fPrintDwordNameAndValue)
		{
		    wprintf(wszNewLine);
		}
	    }
	    break;

	case REG_SZ:
	    if (fPrintType)
	    {
		wprintf(L"REG_SZ");
	    }
	    if (NULL != pbValue && 0 != cbValue)
	    {
		CSASSERT((wcslen((WCHAR const *) pbValue) + 1) * sizeof(WCHAR) == cbValue);
		wprintf(L" = ");
		PrintRegStringValue(pwszLookupName, (WCHAR const *) pbValue);
		if (44 < wcslen((WCHAR const *) pbValue))
		{
		    fLongValue = TRUE;
		}
	    }
	    wprintf(wszNewLine);
	    break;

	case REG_MULTI_SZ:
	    wprintf(
		L"%ws%hs",
		fPrintType? L"REG_MULTI_SZ" : L"",
		pszEqual);
	    if (NULL != pbValue && 0 != cbValue)
	    {
		pwsz = (WCHAR const *) pbValue;
		if (L'\0' == *pwsz)
		{
		    // empty value
		}
		else if (!fPrintType && L'\0' == pwsz[wcslen(pwsz) + 1])
		{
		    // single value

		    wprintf(L" ");
		    PrintRegStringValue(pwszLookupName, (WCHAR const *) pbValue);
		    pwsz += wcslen(pwsz) + 1;
		}
		else
		{
		    wprintf(wszNewLine);
		    i = 0;
		    for ( ; L'\0' != *pwsz; pwsz += wcslen(pwsz) + 1)
		    {
			wprintf(L"    %u: ", i);
			PrintRegStringValue(pwszLookupName, pwsz);
			wprintf(wszNewLine);
			i++;
		    }
		    fLongValue = TRUE;
		}
		CSASSERT(
		    (pwsz == (WCHAR *) pbValue && 2 * sizeof(WCHAR) == cbValue) ||
		    (SAFE_SUBTRACT_POINTERS((BYTE *) pwsz, pbValue) +
			sizeof(WCHAR) ==
			cbValue));
	    }
	    if (!fLongValue)
	    {
		wprintf(wszNewLine);
	    }
	    break;

	default:
	case REG_BINARY:
	    if (fPrintType)
	    {
		if (REG_BINARY == dwType)
		{
		    wprintf(L"REG_BINARY");
		}
		else
		{
		    wprintf(L"???=%x%", dwType);
		}
	    }
	    wprintf(L"%hs", pszEqual);
	    if (NULL != pbValue && 0 != cbValue)
	    {
		BOOL fDump = TRUE;
		WCHAR const *pwszNL = wszNewLine;
		
		if (REG_BINARY == dwType && sizeof(FILETIME) == cbValue)
		{
		    hr = cuDumpFileTimeOrPeriod(
					0,
					NULL,
					(FILETIME const *) pbValue);
		    if (S_OK == hr)
		    {
			if (g_fVerbose)
			{
			    pwszNL = NULL;
			}
			else
			{
			    fDump = FALSE;
			}
		    }
		}
		if (fDump)
		{
		    if (NULL != pwszNL)
		    {
			wprintf(pwszNL);
		    }
		    DumpHex(0, pbValue, cbValue);
		    fLongValue = TRUE;
		}
	    }
	    break;
    }
    if (NULL != pfLongValue)
    {
	*pfLongValue = fLongValue;
    }
}


BOOL
cuRegPrintDwordValue(
    IN BOOL fPrintNameAndValue,
    IN WCHAR const *pwszLookupName,
    IN WCHAR const *pwszDisplayName,
    IN DWORD dwValue)
{
    BOOL fDisplayed = FALSE;

    PrintRegValue(
	    pwszLookupName,
	    pwszDisplayName,
	    REG_DWORD,
	    fPrintNameAndValue,
	    FALSE,
	    0,		// cwcSeparator
	    sizeof(dwValue),
	    (BYTE const *) &dwValue,
	    &fDisplayed);
    return(fDisplayed);
}


VOID
cuRegPrintAwszValue(
    IN WCHAR const *pwszName,
    OPTIONAL IN WCHAR const * const *prgpwszValues)
{
    WCHAR *pwszzValues = NULL;
    WCHAR *pwsz;
    DWORD cwcAlloc;
    DWORD i;

    cwcAlloc = 1;
    if (NULL == prgpwszValues || NULL == prgpwszValues[0])
    {
	cwcAlloc++;
    }
    else
    {
	for (i = 0; NULL != prgpwszValues[i]; i++)
	{
	    cwcAlloc += wcslen(prgpwszValues[i]) + 1;
	}
    }
    pwszzValues = (WCHAR *) LocalAlloc(LMEM_FIXED, cwcAlloc * sizeof(WCHAR));
    if (NULL == pwszzValues)
    {
	_JumpError(E_OUTOFMEMORY, error, "LocalAlloc");
    }
    pwsz = pwszzValues;
    if (NULL == prgpwszValues || NULL == prgpwszValues[0])
    {
	*pwsz++ = L'\0';
    }
    else
    {
	for (i = 0; NULL != prgpwszValues[i]; i++)
	{
	    wcscpy(pwsz, prgpwszValues[i]);
	    pwsz += wcslen(pwsz) + 1;
	}
    }
    *pwsz = L'\0';
    CSASSERT(SAFE_SUBTRACT_POINTERS(pwsz, pwszzValues) + 1 == cwcAlloc);
    
    PrintRegValue(
	    pwszName,
	    pwszName,
	    REG_MULTI_SZ,
	    TRUE,
	    FALSE,
	    0,		// cwcSeparator
	    cwcAlloc * sizeof(WCHAR),
	    (BYTE const *) pwszzValues,
	    NULL);	// pfLongValue

error:
    if (NULL != pwszzValues)
    {
	LocalFree(pwszzValues);
    }
}


#define REGOP_NONE	0
#define REGOP_SET	1
#define REGOP_CLEAR	2


BOOL
IsInList(
    IN WCHAR const *pwsz,
    IN WCHAR const *pwszzList)
{
    BOOL fFound = FALSE;
    WCHAR *pwszT;
    
    for ( ; L'\0' != *pwszzList; pwszzList += wcslen(pwszzList) + 1)
    {
	if (0 == lstrcmpi(pwszzList, pwsz))
	{
	    fFound = TRUE;
	    break;
	}
    }
    return(fFound);
}


HRESULT
CombineMultiSzRegValues(
    IN DWORD RegOp,
    IN WCHAR const *pwszRegValue,
    IN DWORD dwTypeOld,
    IN DWORD cbValueOld,
    IN BYTE const *pbValueOld,
    OUT BYTE **ppbValue,
    OUT DWORD *pcbValue)
{
    HRESULT hr;
    WCHAR *pwszDst;
    WCHAR const *pwsz;
    DWORD cpwsz;
    WCHAR const **apwsz = NULL;
    DWORD cOld = 0;
    DWORD cNew = 0;
    DWORD cCombined;
    WCHAR *pwszzNew = NULL;
    DWORD cwc;
    DWORD i;
    
    if (REGOP_NONE != RegOp)
    {
	pwsz = (WCHAR *) pbValueOld;
	if (NULL != pwsz && 0 != cbValueOld)
	{
	    for ( ; L'\0' != *pwsz; pwsz += wcslen(pwsz) + 1)
	    {
		cOld++;
	    }
	}
    }

    // Convert backslash-n sequences to L'\0' and move data up.

    cwc = wcslen(pwszRegValue) + 1 + 1;
    pwszzNew = (WCHAR *) LocalAlloc(LMEM_FIXED, cwc * sizeof(WCHAR));
    if (NULL == pwszzNew)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }
    pwszDst = pwszzNew;
    pwsz = pwszRegValue;

    if (L'\0' != *pwsz && REGOP_CLEAR != RegOp)
    {
	cNew++;
    }
    while (L'\0' != *pwsz)
    {
	WCHAR wc;

	wc = *pwsz++;
	if (L'\\' == wc && L'n' == *pwsz)
	{
	    if (0 != cNew)
	    {
		cNew++;
	    }
	    wc = L'\0';
	    pwsz++;
	    while (L'\\' == pwsz[0] && L'n' == pwsz[1])
	    {
		pwsz += 2;
	    }
	}
	*pwszDst++ = wc;
    }
    *pwszDst++ = L'\0';
    *pwszDst = L'\0';


    apwsz = (WCHAR const **) LocalAlloc(LMEM_FIXED, (cOld + cNew) * sizeof(apwsz[0]));
    if (NULL == apwsz)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }

    cCombined = 0;
    if (cOld)
    {
	for (pwsz = (WCHAR *) pbValueOld; L'\0' != *pwsz; pwsz += wcslen(pwsz) + 1)
	{
	    if (REGOP_SET == RegOp || !IsInList(pwsz, pwszzNew))
	    {
		apwsz[cCombined++] = pwsz;
	    }
	}
    }
    if (cNew)
    {
	for (pwsz = pwszzNew; L'\0' != *pwsz; pwsz += wcslen(pwsz) + 1)
	{
	    if (REGOP_NONE == RegOp || !IsInList(pwsz, (WCHAR *) pbValueOld))
	    {
		apwsz[cCombined++] = pwsz;
	    }
	}
    }
    CSASSERT(cOld + cNew >= cCombined);

    cwc = 1;
    for (i = 0; i < cCombined; i++)
    {
	cwc += wcslen(apwsz[i]) + 1;
    }
    if (0 == cCombined)
    {
	cwc++;
    }

    *pcbValue = cwc * sizeof(WCHAR);
    *ppbValue = (BYTE *) LocalAlloc(LMEM_FIXED, *pcbValue);
    if (NULL == *ppbValue)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }

    pwszDst = (WCHAR *) *ppbValue;
    for (i = 0; i < cCombined; i++)
    {
	wcscpy(pwszDst, apwsz[i]);
	pwszDst += wcslen(pwszDst) + 1;
    }
    if (0 == cCombined)
    {
	*pwszDst++ = L'\0';
    }
    *pwszDst = L'\0';

    CSASSERT(SAFE_SUBTRACT_POINTERS(pwszDst, (WCHAR *) *ppbValue) + 1 == cwc);
    hr = S_OK;

error:
    if (NULL != apwsz)
    {
	LocalFree(apwsz);
    }
    if (NULL != pwszzNew)
    {
	LocalFree(pwszzNew);
    }
    return(hr);
}


HRESULT
ParseRegValue(
    IN WCHAR const *pwszRegName,
    IN DWORD cbValueOld,
    IN BYTE const *pbValueOld,
    IN OUT DWORD *pdwType,
    IN WCHAR const *pwszRegValue,
    OUT DWORD *pcbValue,
    OUT BYTE **ppbValue)
{
    HRESULT hr;
    WCHAR const *pwsz;
    DWORD cb;
    DWORD dw;
    DWORD dwValue;
    DWORD dwType;
    DWORD cNewLine;
    DWORD RegOp;
    BOOL fNumber;

    // A leading '-' or '+' character is used as a REGOP_* operator.
    // To include it as part of the string, add leading whitespace,
    // or separate the operator from the string by one or more spaces.
    //
    // "-foo" -- remove "foo" from registry value
    // "- foo" -- remove "foo" from registry value
    // " -foo" -- overwrite registry value with "-foo"
    // "--foo" -- remove "-foo" from registry value
    // "- -foo" -- remove "-foo" from registry value

    dwValue = 0;
    cNewLine = 0;
    if (REG_DWORD == *pdwType)
    {
	CSASSERT(sizeof(dw) == cbValueOld);
	dwValue = *(DWORD *) pbValueOld;
    }
    if (L'+' == *pwszRegValue)
    {
	RegOp = REGOP_SET;		// set bits in existing value
	pwszRegValue++;
    }
    else if (L'-' == *pwszRegValue)
    {
	RegOp = REGOP_CLEAR;		// clear bits in existing value
	pwszRegValue++;
    }
    else
    {
	RegOp = REGOP_NONE;		// overwrite value
	dwValue = 0;
    }
    while (L' ' == *pwszRegValue || L'\t' == *pwszRegValue)
    {
	pwszRegValue++;
    }

    cb = sizeof(dwValue);		// assume REG_DWORD
    dwType = REG_DWORD;

    fNumber = FALSE;
    
    if (L'+' == *pwszRegValue ||
	L'-' == *pwszRegValue ||
	iswdigit(*pwszRegValue))
    {
	hr = cuGetSignedLong(pwszRegValue, (LONG *) &dw);
	if (S_OK == hr)
	{
	    fNumber = TRUE;
	    switch (RegOp)
	    {
		default:
		case REGOP_NONE:
		    dwValue = dw;
		    break;

		case REGOP_SET:
		    dwValue |= dw;
		    break;

		case REGOP_CLEAR:
		    dwValue &= ~dw;
		    break;
	    }
	}
    }
    if (!fNumber)
    {
	hr = cuMapRegFlags(
			pwszRegName,
			pwszRegValue,
			REGOP_CLEAR == RegOp,
			&dwValue);
	if (S_OK != hr)
	{
	    pwsz = pwszRegValue;
	    while (TRUE)
	    {
		pwsz = wcschr(pwsz, L'\\');
		if (NULL == pwsz)
		{
		    break;
		}
		if (L'n' == *++pwsz)
		{
		    cNewLine++;
		}
	    }
	    if (0 == cNewLine)
	    {
		dwType = REG_SZ;
	    }
	    else
	    {
		dwType = REG_MULTI_SZ;
	    }
	    cb = (wcslen(pwszRegValue) + 1) * sizeof(WCHAR);
	}
    }

    if (REG_NONE != *pdwType && dwType != *pdwType)
    {
	if (REG_SZ == dwType && REG_MULTI_SZ == *pdwType)
	{
	    dwType = REG_MULTI_SZ;
	    if (0 == cNewLine)
	    {
		cb += sizeof(WCHAR);
	    }
	}
	else if (REG_MULTI_SZ != dwType || REG_SZ != *pdwType)
	{
	    hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	    _JumpError(hr, error, "bad registry value type");
	}
    }

    if (REG_MULTI_SZ == dwType)
    {
	hr = CombineMultiSzRegValues(
			    RegOp,
			    pwszRegValue,
			    *pdwType,
			    cbValueOld,
			    pbValueOld,
			    ppbValue,
			    pcbValue);
	_JumpIfError(hr, error, "CombineMultiSzRegValues");
    }
    else
    {
	*ppbValue = (BYTE *) LocalAlloc(LMEM_FIXED, cb);
	if (NULL == *ppbValue)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "LocalAlloc");
	}
	*pcbValue = cb;

	if (REG_DWORD == dwType)
	{
	    CSASSERT(sizeof(dwValue) == cb);
	    CopyMemory(*ppbValue, &dwValue, sizeof(dwValue));
	}
	else
	{
	    if (REGOP_NONE != RegOp)
	    {
		hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
		_JumpErrorStr(hr, error, "bad registry value string", pwszRegValue);
	    }
	    CSASSERT((wcslen(pwszRegValue) + 1) * sizeof(WCHAR) <= cb);
	    wcscpy((WCHAR *) *ppbValue, pwszRegValue);
	}
    }
    *pdwType = dwType;
    if (g_fVerbose)
    {
	DumpHex(0, *ppbValue, *pcbValue);
    }
    hr = S_OK;

error:
    return(hr);
}


HRESULT
WriteRegValue(
    IN HKEY hkey,
    IN WCHAR const *pwszName,
    IN DWORD dwType,
    IN DWORD cbValue,
    IN BYTE const *pbValue)
{
    HRESULT hr;

    hr = RegSetValueEx(hkey, pwszName, 0, dwType, pbValue, cbValue);
    _JumpIfErrorStr(hr, error, "RegSetValueEx", pwszName);

error:
    return(myHError(hr));
}


HRESULT
ReadRegValue(
    IN HKEY hkey,
    IN WCHAR const *pwszName,
    OUT DWORD *pdwType,
    OUT DWORD *pcbValue,
    OUT BYTE **ppbValue)
{
    HRESULT hr;
    DWORD cb;

    *ppbValue = NULL;
    cb = 0;
    hr = RegQueryValueEx(
		    hkey,
		    pwszName,
		    NULL,
		    pdwType,
		    NULL,
		    &cb);
    _JumpIfErrorStr2(hr, error, "RegQueryValueEx", pwszName, ERROR_FILE_NOT_FOUND);

    // add two WCHAR L'\0's after the registry value, in case of a poorly
    // formed REG_MULTI_SZ.  Add another to handle possible odd sizes.

    *ppbValue = (BYTE *) LocalAlloc(LMEM_FIXED, cb + cbVALUEZEROPAD);
    if (NULL == *ppbValue)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }

    hr = RegQueryValueEx(
		    hkey,
		    pwszName,
		    NULL,
		    pdwType,
		    *ppbValue,
		    &cb);
    _JumpIfErrorStr(hr, error, "RegQueryValueEx", pwszName);

    if (REG_SZ == *pdwType || REG_MULTI_SZ == *pdwType)
    {
	WCHAR *pwszStart;
	WCHAR *pwsz;
	
	pwszStart = (WCHAR *) *ppbValue;
	cb &= ~(sizeof(WCHAR) - 1);
	pwsz = &pwszStart[cb / sizeof(WCHAR)];

	ZeroMemory(pwsz, cbVALUEZEROPAD);
	pwsz = pwszStart;
	while (L'\0' != pwsz[0] || L'\0' != pwsz[1])
	{
	    pwsz++;
	}
	cb = (SAFE_SUBTRACT_POINTERS(pwsz, pwszStart) +
		(REG_SZ == *pdwType? 1 : 2)) * sizeof(WCHAR);
    }
    *pcbValue = cb;

error:
    if (S_OK != hr)
    {
	if (NULL != *ppbValue)
	{
	    LocalFree(*ppbValue);
	    *ppbValue = NULL;
	}
    }
    return(myHError(hr));
}


#define cwcVALUENAME	25	// Nominal registry value name length

HRESULT
DumpRegKeysAndValues(
    IN HKEY hkey,
    OPTIONAL WCHAR *pwszValueNamePrefix)
{
    HRESULT hr;
    DWORD i;
    DWORD j;
    DWORD cwc;
    DWORD dwType;
    WCHAR awc[MAX_PATH + 1];
    DWORD cb;
    BYTE *pb;
    BYTE ab[8 + cbVALUEZEROPAD];	// enough for small registry values
    DWORD cbAlloc;
    BYTE *pbAlloc = ab;
    BOOL fLongValue;
    WCHAR *pwszPrefix = NULL;
    DWORD cwcPrefix;

    if (NULL != pwszValueNamePrefix)
    {
	cwcPrefix = wcslen(pwszValueNamePrefix);
	pwszPrefix = (WCHAR *) LocalAlloc(
				    LMEM_FIXED,
				    (cwcPrefix + 1) * sizeof(WCHAR));
	if (NULL == pwszPrefix)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "LocalAlloc");
	}
    }
    for (i = j = 0; ; i++)
    {
	cwc = ARRAYSIZE(awc);
	hr = RegEnumKey(hkey, i, awc, cwc);
	if (S_OK != hr)
	{
	    if ((HRESULT) ERROR_NO_MORE_ITEMS != hr)
	    {
		_PrintError(hr, "RegEnumKey");
	    }
	    break;
	}
	if (NULL != pwszPrefix)
	{
	    wcsncpy(pwszPrefix, awc, cwcPrefix);
	    pwszPrefix[cwcPrefix] = L'\0';
	    if (0 != lstrcmpi(pwszValueNamePrefix, pwszPrefix))
	    {
		continue;
	    }
	}

	if (0 == j)
	{
	    wprintf(wszNewLine);
	    wprintf(myLoadResourceString(IDS_KEYS));	// "Keys:"
	    wprintf(wszNewLine);
	}
	else if (0 == (j % 5))
	{
	    wprintf(wszNewLine);
	}
	wprintf(L"  %ws\n", awc);
	j++;
    }

    cbAlloc = sizeof(ab) - cbVALUEZEROPAD;
    fLongValue = FALSE;
    for (i = j = 0; ; i++)
    {
	DWORD cwcSep;

	cwc = ARRAYSIZE(awc);
	cb = cbAlloc;
	pb = pbAlloc;
	hr = RegEnumValue(hkey, i, awc, &cwc, NULL, &dwType, pb, &cb);
	if (S_OK != hr)
	{
	    if ((HRESULT) ERROR_MORE_DATA != hr)
	    {
		if ((HRESULT) ERROR_NO_MORE_ITEMS != hr)
		{
		    _PrintError(hr, "RegEnumValue");
		}
		break;
	    }
	    CSASSERT(NULL != pb);
	    pb = (BYTE *) LocalAlloc(LMEM_FIXED, cb + cbVALUEZEROPAD);
	    if (NULL == pb)
	    {
		hr = E_OUTOFMEMORY;
		_JumpError(hr, error, "LocalAlloc");
	    }
	    if (ab != pbAlloc)
	    {
		LocalFree(pbAlloc);
	    }
	    pbAlloc = pb;
	    cbAlloc = cb;
	    cwc = ARRAYSIZE(awc);
	    hr = RegEnumValue(hkey, i, awc, &cwc, NULL, &dwType, pb, &cb);
	    _JumpIfError(hr, error, "RegEnumValue",);
	}
	if (NULL != pb)
	{
	    ZeroMemory(&pb[cb], cbVALUEZEROPAD);
	}
	if (NULL != pwszPrefix)
	{
	    wcsncpy(pwszPrefix, awc, cwcPrefix);
	    pwszPrefix[cwcPrefix] = L'\0';
	    if (0 != lstrcmpi(pwszValueNamePrefix, pwszPrefix))
	    {
		continue;
	    }
	}
	if (0 == j)
	{
	    wprintf(wszNewLine);
	    wprintf(myLoadResourceString(IDS_VALUES));	// "Values:"
	    wprintf(wszNewLine);
	}
	else if (fLongValue || 0 == (j % 5))
	{
	    wprintf(wszNewLine);
	}
	cwcSep = wcslen(awc);
	cwcSep = cwcVALUENAME < cwcSep? 0 : cwcVALUENAME - cwcSep;
	PrintRegValue(awc, awc, dwType, TRUE, TRUE, cwcSep, cb, pb, &fLongValue);
	j++;
    }
    hr = S_OK;

error:
    if (NULL != pbAlloc && ab != pbAlloc)
    {
	LocalFree(pbAlloc);
    }
    if (NULL != pwszPrefix)
    {
	LocalFree(pwszPrefix);
    }
    return(myHError(hr));
}


HRESULT
verbGetReg(
    IN WCHAR const *pwszOption,
    OPTIONAL IN WCHAR const *pwszRegName,
    IN WCHAR const *pwszArg2,
    IN WCHAR const *pwszArg3,
    IN WCHAR const *pwszArg4)
{
    HRESULT hr;
    WCHAR *pwszPath = NULL;
    WCHAR *pwszName = NULL;
    WCHAR *pwszValueName = NULL;
    WCHAR *pwszSubKeyName = NULL;
    DWORD dwType;
    DWORD cbValue;
    BYTE *pbValue = NULL;
    HKEY hkey = NULL;

    if (NULL == pwszRegName)
    {
	pwszRegName = L"";
    }
    hr = myRegOpenRelativeKey(
			g_pwszConfig,
			pwszRegName,
			RORKF_FULLPATH | (g_fUserRegistry? RORKF_USERKEY : 0),
			&pwszPath,
			&pwszName,
			&hkey);
    _JumpIfErrorStr(hr, error, "myRegOpenRelativeKey", pwszRegName);

    hr = OpenSubKey(&hkey, pwszName, &pwszSubKeyName, &pwszValueName);
    _JumpIfError(hr, error, "OpenSubKey");

    wprintf(
	L"%ws%ws%ws%ws:\n",
	g_fUserRegistry && 0 == _wcsnicmp(
				    pwszPath,
				    wszCERTTYPECACHE,
				    WSZARRAYSIZE(wszCERTTYPECACHE))?
	    L"HKEY_CURRENT_USER\\" : L"HKEY_LOCAL_MACHINE\\",
	L'\0' != *pwszPath? pwszPath : wszREGKEYCONFIG,
	L'\0' != *pwszSubKeyName? L"\\" : L"",
	pwszSubKeyName);

    if (NULL == pwszValueName ||
	L'\0' == *pwszValueName ||
	NULL != wcschr(pwszValueName, L'*'))
    {
	if (NULL != pwszValueName)
	{
	    WCHAR *pwsz = wcschr(pwszValueName, L'*');

	    if (NULL != pwsz)
	    {
		*pwsz = L'\0';
	    }
	}

	hr = DumpRegKeysAndValues(hkey, pwszValueName);
	_JumpIfError(hr, error, "DumpRegKeysAndValues");
    }
    else
    {
	hr = ReadRegValue(hkey, pwszValueName, &dwType, &cbValue, &pbValue);
	_JumpIfErrorStr(hr, error, "ReadRegValue", pwszValueName);

	wprintf(wszNewLine);
	PrintRegValue(
		pwszValueName,
		pwszValueName,
		dwType,
		TRUE,
		TRUE,
		0,
		cbValue,
		pbValue,
		NULL);
    }

error:
    if (NULL != hkey)
    {
        RegCloseKey(hkey);
    }
    if (NULL != pwszPath)
    {
	LocalFree(pwszPath);
    }
    if (NULL != pwszName)
    {
	LocalFree(pwszName);
    }
    if (NULL != pwszSubKeyName)
    {
	LocalFree(pwszSubKeyName);
    }
    if (NULL != pwszValueName)
    {
	LocalFree(pwszValueName);
    }
    if (NULL != pbValue)
    {
	LocalFree(pbValue);
    }
    return(hr);
}


HRESULT
verbSetReg(
    IN WCHAR const *pwszOption,
    IN WCHAR const *pwszRegName,
    IN WCHAR const *pwszRegValue,
    IN WCHAR const *pwszArg3,
    IN WCHAR const *pwszArg4)
{
    HRESULT hr;
    WCHAR *pwszPath = NULL;
    WCHAR *pwszName = NULL;
    WCHAR *pwszValueName = NULL;
    WCHAR *pwszSubKeyName = NULL;
    DWORD dwType;
    DWORD cbValue;
    DWORD cbValueArg;
    BYTE *pbValueOld = NULL;
    BYTE *pbValueNew = NULL;
    BYTE *pbValueArg = NULL;
    HKEY hkey = NULL;
    DWORD dw;

    hr = myRegOpenRelativeKey(
			g_pwszConfig,
			pwszRegName,
			RORKF_FULLPATH |
			    RORKF_CREATESUBKEYS |
			    (g_fUserRegistry? RORKF_USERKEY : 0),
			&pwszPath,
			&pwszName,
			&hkey);
    _JumpIfErrorStr(hr, error, "myRegOpenRelativeKey", pwszRegName);

    hr = OpenSubKey(&hkey, pwszName, &pwszSubKeyName, &pwszValueName);
    _JumpIfError(hr, error, "OpenSubKey");

    wprintf(
	L"%ws%ws%ws%ws:\n",
	g_fVerbose? L"HKEY_LOCAL_MACHINE\\" : L"",
	L'\0' != *pwszPath? pwszPath : wszREGKEYCONFIG,
	L'\0' != *pwszSubKeyName? L"\\" : L"",
	pwszSubKeyName);

    hr = ReadRegValue(hkey, pwszValueName, &dwType, &cbValue, &pbValueOld);
    if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) != hr)
    {
	_JumpIfErrorStr(hr, error, "ReadRegValue", pwszValueName);
    }

    if (NULL != pbValueOld)
    {
	wprintf(wszNewLine);
	wprintf(myLoadResourceString(IDS_OLD_REG_VALUE));	// "Old Value:"
	wprintf(wszNewLine);
	PrintRegValue(
		pwszValueName,
		pwszValueName,
		dwType,
		TRUE,
		TRUE,
		0,
		cbValue,
		pbValueOld,
		NULL);
    }
    else
    {
	dwType = REG_NONE;
    }

    hr = ParseRegValue(
		    pwszRegName,
		    cbValue,
		    pbValueOld,
		    &dwType,
		    pwszRegValue,
		    &cbValueArg,
		    &pbValueArg);
    _JumpIfErrorStr(hr, error, "ParseRegValue", pwszRegValue);

    hr = WriteRegValue(hkey, pwszValueName, dwType, cbValueArg, pbValueArg);
    _JumpIfErrorStr(hr, error, "WriteRegValue", pwszValueName);

    hr = ReadRegValue(hkey, pwszValueName, &dwType, &cbValue, &pbValueNew);
    _JumpIfErrorStr(hr, error, "ReadRegValue", pwszValueName);

    wprintf(wszNewLine);
    wprintf(myLoadResourceString(IDS_NEW_REG_VALUE));	// "New Value:"
    wprintf(wszNewLine);
    PrintRegValue(
	    pwszValueName,
	    pwszValueName,
	    dwType,
	    TRUE,
	    TRUE,
	    0,
	    cbValue,
	    pbValueNew,
	    NULL);

error:
    if (NULL != hkey)
    {
        RegCloseKey(hkey);
    }
    if (NULL != pwszPath)
    {
	LocalFree(pwszPath);
    }
    if (NULL != pwszName)
    {
	LocalFree(pwszName);
    }
    if (NULL != pwszSubKeyName)
    {
	LocalFree(pwszSubKeyName);
    }
    if (NULL != pwszValueName)
    {
	LocalFree(pwszValueName);
    }
    if (NULL != pbValueOld)
    {
	LocalFree(pbValueOld);
    }
    if (NULL != pbValueArg)
    {
	LocalFree(pbValueArg);
    }
    if (NULL != pbValueNew)
    {
	LocalFree(pbValueNew);
    }
    return(hr);
}


HRESULT
verbDelReg(
    IN WCHAR const *pwszOption,
    IN WCHAR const *pwszRegName,
    IN WCHAR const *pwszArg2,
    IN WCHAR const *pwszArg3,
    IN WCHAR const *pwszArg4)
{
    HRESULT hr;
    WCHAR *pwszPath = NULL;
    WCHAR *pwszName = NULL;
    WCHAR *pwszValueName = NULL;
    WCHAR *pwszSubKeyName = NULL;
    DWORD dwType;
    DWORD cbValue;
    BYTE *pbValueOld = NULL;
    HKEY hkey = NULL;
    DWORD dw;

    hr = myRegOpenRelativeKey(
			g_pwszConfig,
			pwszRegName,
			RORKF_FULLPATH |
			    RORKF_CREATESUBKEYS |
			    (g_fUserRegistry? RORKF_USERKEY : 0),
			&pwszPath,
			&pwszName,
			&hkey);
    _JumpIfErrorStr(hr, error, "myRegOpenRelativeKey", pwszRegName);

    hr = OpenSubKey(&hkey, pwszName, &pwszSubKeyName, &pwszValueName);
    _JumpIfError(hr, error, "OpenSubKey");

    wprintf(
	L"%ws%ws%ws%ws:\n",
	L"HKEY_LOCAL_MACHINE\\",
	L'\0' != *pwszPath? pwszPath : wszREGKEYCONFIG,
	L'\0' != *pwszSubKeyName? L"\\" : L"",
	pwszSubKeyName);

    hr = ReadRegValue(hkey, pwszValueName, &dwType, &cbValue, &pbValueOld);
    if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) != hr)
    {
	_JumpIfErrorStr(hr, error, "ReadRegValue", pwszValueName);
    }

    if (NULL != pbValueOld)
    {
	wprintf(wszNewLine);
	wprintf(myLoadResourceString(IDS_OLD_REG_VALUE));	// "Old Value:"
	wprintf(wszNewLine);
	PrintRegValue(
		pwszValueName,
		pwszValueName,
		dwType,
		TRUE,
		TRUE,
		0,
		cbValue,
		pbValueOld,
		NULL);
    }

    hr = RegDeleteValue(hkey, pwszName);
    if (S_OK != hr)
    {
	hr = myHError(hr);
	_JumpErrorStr(hr, error, "RegDeleteValue", pwszName);
    }

error:
    if (NULL != hkey)
    {
        RegCloseKey(hkey);
    }
    if (NULL != pwszPath)
    {
	LocalFree(pwszPath);
    }
    if (NULL != pwszName)
    {
	LocalFree(pwszName);
    }
    if (NULL != pwszSubKeyName)
    {
	LocalFree(pwszSubKeyName);
    }
    if (NULL != pwszValueName)
    {
	LocalFree(pwszValueName);
    }
    if (NULL != pbValueOld)
    {
	LocalFree(pbValueOld);
    }
    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\tools\certut\store.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       store.cpp
//
//--------------------------------------------------------------------------

#include <pch.cpp>

#pragma hdrstop

#include <setupapi.h>
#include "ocmanage.h"
#include "initcert.h"
#include "cscsp.h"
#include "csber.h"


DWORD
cuGetSystemStoreFlags()
{
    return(g_fEnterpriseRegistry?
	    CERT_SYSTEM_STORE_LOCAL_MACHINE_ENTERPRISE :
	    (g_fUserRegistry?
	     CERT_SYSTEM_STORE_CURRENT_USER :
	     CERT_SYSTEM_STORE_LOCAL_MACHINE));
}


// Parse a CertIndex -- any one of the following:
//
// Return the following in *piCert, *piCRL and *piCTL.  MAXDWORD if not
// specified
// Each value must be less than 64k.
//  iCert	decimal number
//  iCert.iCRL	decimal number, period, decimal number
//  .iCRL	period, decimal number
//  ..iCTL	period, period, decimal number
//
// Return the string in *ppwszCertName, if no Cert, CRL and CTL indexes.

HRESULT
ParseCertCRLIndex(
    IN WCHAR const *pwszCertIndex,
    OUT WCHAR **ppwszCertName,
    OUT DWORD *piCert,
    OUT DWORD *piCRL,
    OUT DWORD *piCTL)
{
    HRESULT hr;
    WCHAR *pwszCopy = NULL;
    
    *ppwszCertName = NULL;
    *piCert = MAXDWORD;
    *piCRL = MAXDWORD;
    *piCTL = MAXDWORD;
    if (NULL != pwszCertIndex && 0 != lstrcmp(L"*", pwszCertIndex))
    {
	BOOL fNumericIndex = TRUE;
	WCHAR *pwszCert;
	WCHAR *pwszCRL;
	WCHAR *pwszCTL;
	
	if (L' ' == *pwszCertIndex)
	{
	    fNumericIndex = FALSE;
	    pwszCertIndex++;
	}
	hr = myDupString(pwszCertIndex, &pwszCopy);
	_JumpIfError(hr, error, "myDupString");

	pwszCert = pwszCopy;

	if (!iswdigit(*pwszCert) && L'.' != *pwszCert)
	{
	    fNumericIndex = FALSE;
	}

	pwszCRL = NULL;
	pwszCTL = NULL;
	if (fNumericIndex)
	{
	    pwszCRL = wcschr(pwszCert, L'.');
	    if (NULL != pwszCRL)
	    {
		*pwszCRL++ = L'\0';
		pwszCTL = wcschr(pwszCRL, L'.');
		if (NULL != pwszCTL)
		{
		    *pwszCTL++ = L'\0';
		    if (L'\0' != *pwszCTL)
		    {
			hr = cuGetLong(pwszCTL, (LONG *) piCTL);
			if (S_OK != hr || 64*1024 <= *piCTL)
			{
			    fNumericIndex = FALSE;
			}
		    }
		}
		if (fNumericIndex && L'\0' != *pwszCRL)
		{
		    hr = cuGetLong(pwszCRL, (LONG *) piCRL);
		    if (S_OK != hr || 64*1024 <= *piCRL)
		    {
			fNumericIndex = FALSE;
		    }
		}
	    }
	}
	if (fNumericIndex && L'\0' != *pwszCert)
	{
	    hr = cuGetLong(pwszCert, (LONG *) piCert);
	    if (S_OK != hr || 64*1024 <= *piCert)
	    {
		fNumericIndex = FALSE;
	    }
	}
	if (!fNumericIndex)
	{
	    hr = myRevertSanitizeName(pwszCertIndex, ppwszCertName);
	    _JumpIfError(hr, error, "myRevertSanitizeName");

	    *piCert = MAXDWORD;
	    *piCRL = MAXDWORD;
	    *piCTL = MAXDWORD;
	}
    }
    if (g_fVerbose)
    {
	wprintf(
	    L"pwszCertIndex=%ws, Name=%ws idx=%d.%d.%d\n",
	    pwszCertIndex,
	    *ppwszCertName,
	    *piCert,
	    *piCRL,
	    *piCTL);
    }
    hr = S_OK;

error:
    if (NULL != pwszCopy)
    {
	LocalFree(pwszCopy);
    }
    return(hr);
}


HRESULT
SavePFXStoreToFile(
    IN HCERTSTORE hStorePFX,
    IN WCHAR const *pwszfnOut,
    IN WCHAR const *pwszPassword,
    IN OUT WCHAR **ppwszPassword)
{
    HRESULT hr;
    CRYPT_DATA_BLOB pfx;
    WCHAR wszPassword[MAX_PATH];

    pfx.pbData = NULL;

    if (NULL == *ppwszPassword)
    {
	if (NULL == pwszPassword || 0 == wcscmp(L"*", pwszPassword))
	{
	    wprintf(L"Enter new password for output file %ws:\n", pwszfnOut);
	    hr = cuGetPassword(TRUE, wszPassword, ARRAYSIZE(wszPassword));
	    _JumpIfError(hr, error, "cuGetPassword");

	    pwszPassword = wszPassword;
	}
	hr = myDupString(pwszPassword, ppwszPassword);
	_JumpIfError(hr, error, "myDupString");
    }
    pwszPassword = *ppwszPassword;

    // GemPlus returns NTE_BAD_TYPE instead of NTE_BAD_KEY, blowing up
    // REPORT_NOT_ABLE* filtering.  if they ever get this right, we can pass
    // "[...] : EXPORT_PRIVATE_KEYS"

    hr = myPFXExportCertStore(
		hStorePFX,
		&pfx,
		pwszPassword,
		EXPORT_PRIVATE_KEYS | REPORT_NOT_ABLE_TO_EXPORT_PRIVATE_KEY);
    _JumpIfError(hr, error, "myPFXExportCertStore");

    hr = EncodeToFileW(
		pwszfnOut,
		pfx.pbData,
		pfx.cbData,
		CRYPT_STRING_BINARY | g_EncodeFlags);
    _JumpIfError(hr, error, "EncodeToFileW");

error:
    if (NULL != pfx.pbData)
    {
	LocalFree(pfx.pbData);
    }
    return(hr);
}


HRESULT
SavePFXToFile(
    IN CERT_CONTEXT const *pCert,
    IN WCHAR const *pwszfnOut,
    IN BOOL fFirst,
    IN WCHAR const *pwszPassword,
    IN OUT WCHAR **ppwszPassword)
{
    HRESULT hr;
    HCERTSTORE hTempMemoryStore = NULL;

    hTempMemoryStore = CertOpenStore(
				CERT_STORE_PROV_MEMORY,
				X509_ASN_ENCODING,
				NULL,
				CERT_STORE_NO_CRYPT_RELEASE_FLAG |
				    CERT_STORE_ENUM_ARCHIVED_FLAG,
				NULL);
    if (NULL == hTempMemoryStore)
    {
        hr = myHLastError();
        _JumpError(hr, error, "CertOpenStore");
    }

    // Begin Chain Building

    hr = myAddChainToMemoryStore(hTempMemoryStore, pCert);
    _JumpIfError(hr, error, "myAddChainToMemoryStore");

    // End Chain Building

    hr = SavePFXStoreToFile(
			hTempMemoryStore,
			pwszfnOut,
			pwszPassword,
			ppwszPassword);
    _JumpIfError(hr, error, "SavePFXStoreToFile");

error:
    if (NULL != hTempMemoryStore)
    {
	CertCloseStore(hTempMemoryStore, CERT_CLOSE_STORE_CHECK_FLAG);
    }
    return(hr);
}


HRESULT
SavePVKToFile(
    IN CERT_CONTEXT const *pCert,
    IN WCHAR const *pwszfnOut,
    IN BOOL fFirst)
{
    return(S_OK);
}


HRESULT
cuDumpCTLProperties(
    IN CTL_CONTEXT const *pCTL)
{
    HRESULT hr;
    DWORD dwPropId;
    BYTE *pb = NULL;
    DWORD cb;

    dwPropId = 0;
    while (TRUE)
    {
	if (NULL != pb)
	{
	    LocalFree(pb);
	    pb = NULL;
	}
	dwPropId = CertEnumCTLContextProperties(pCTL, dwPropId);
	if (0 == dwPropId)
	{
	    break;
	}
	while (TRUE)
	{
	    if (!CertGetCTLContextProperty(pCTL, dwPropId, pb, &cb))
	    {
		hr = myHLastError();
		_JumpError(hr, error, "CertGetCTLContextProperty");
	    }
	    if (NULL != pb)
	    {
		break;		// memory alloc'd, property fetched
	    }
	    pb = (BYTE *) LocalAlloc(LMEM_FIXED, cb);
	    if (NULL == pb)
	    {
		hr = E_OUTOFMEMORY;
		_JumpError(hr, error, "LocalAlloc");
	    }
	}
	hr = cuDumpFormattedProperty(dwPropId, NULL, pb, cb);
	_PrintIfError(hr, "cuDumpFormattedProperty");
    }
    hr = S_OK;

error:
    if (NULL != pb)
    {
	LocalFree(pb);
    }
    return(hr);
}


HRESULT
cuDumpCRLProperties(
    IN CRL_CONTEXT const *pCRL)
{
    HRESULT hr;
    DWORD dwPropId;
    BYTE *pb = NULL;
    DWORD cb;

    dwPropId = 0;
    while (TRUE)
    {
	if (NULL != pb)
	{
	    LocalFree(pb);
	    pb = NULL;
	}
	dwPropId = CertEnumCRLContextProperties(pCRL, dwPropId);
	if (0 == dwPropId)
	{
	    break;
	}
	while (TRUE)
	{
	    if (!CertGetCRLContextProperty(pCRL, dwPropId, pb, &cb))
	    {
		hr = myHLastError();
		_JumpError(hr, error, "CertGetCRLContextProperty");
	    }
	    if (NULL != pb)
	    {
		break;		// memory alloc'd, property fetched
	    }
	    pb = (BYTE *) LocalAlloc(LMEM_FIXED, cb);
	    if (NULL == pb)
	    {
		hr = E_OUTOFMEMORY;
		_JumpError(hr, error, "LocalAlloc");
	    }
	}
	hr = cuDumpFormattedProperty(dwPropId, NULL, pb, cb);
	_PrintIfError(hr, "cuDumpFormattedProperty");
    }
    hr = S_OK;

error:
    if (NULL != pb)
    {
	LocalFree(pb);
    }
    return(hr);
}


HRESULT
cuDumpCertProperties(
    IN CERT_CONTEXT const *pCert)
{
    HRESULT hr;
    DWORD dwPropId;
    BYTE *pb = NULL;
    DWORD cb;

    dwPropId = 0;
    while (TRUE)
    {
	dwPropId = CertEnumCertificateContextProperties(pCert, dwPropId);
	if (0 == dwPropId)
	{
	    break;
	}
	if (NULL != pb)
	{
	    LocalFree(pb);
	    pb = NULL;
	}
	while (TRUE)
	{
	    if (!CertGetCertificateContextProperty(pCert, dwPropId, pb, &cb))
	    {
		hr = myHLastError();
		_JumpError(hr, error, "CertGetCertificateContextProperty");
	    }
	    if (NULL != pb)
	    {
		break;		// memory alloc'd, property fetched
	    }
	    pb = (BYTE *) LocalAlloc(LMEM_FIXED, cb);
	    if (NULL == pb)
	    {
		hr = E_OUTOFMEMORY;
		_JumpError(hr, error, "LocalAlloc");
	    }
	}
	hr = cuDumpFormattedProperty(dwPropId, NULL, pb, cb);
	_PrintIfError(hr, "cuDumpFormattedProperty");
    }
    hr = S_OK;

error:
    if (NULL != pb)
    {
	LocalFree(pb);
    }
    return(hr);
}


HRESULT
EnumCertsInStore(
    IN HCERTSTORE hStore,
    IN DWORD Mode,
    IN DWORD iCertSave,
    OPTIONAL IN WCHAR const *pwszCertName,
    IN DWORD cbHash,
    OPTIONAL IN BYTE *pbHash,
    OPTIONAL IN WCHAR const *pwszfnOut,
    OPTIONAL IN WCHAR const *pwszPasswordArg,
    IN OUT WCHAR **ppwszPassword,
    OUT DWORD *pcCert)
{
    HRESULT hr;
    HRESULT hr2;
    DWORD iCert;
    CERT_CONTEXT const *pCert = NULL;
    BSTR strSerialNumber = NULL;

    *pcCert = 0;
    hr2 = S_OK;
    if (NULL != pwszCertName)
    {
	hr = myMakeSerialBstr(pwszCertName, &strSerialNumber);
	_PrintIfError2(hr, "myMakeSerialBstr", hr);
    }
    for (iCert = 0; ; iCert++)
    {
	DWORD VerifyState;
	BOOL fSigningKey;
	BOOL fMatchingKey;

	pCert = CertEnumCertificatesInStore(hStore, pCert);
	if (NULL == pCert)
	{
	    break;
	}
	if (MAXDWORD == iCertSave || iCert == iCertSave)
	{
	    DWORD cb;

	    if (NULL != pwszCertName)
	    {
		BOOL fMatch;
		
		hr = myCertMatch(
			pCert,
			pwszCertName,
			NULL == strSerialNumber &&	// fAllowMissingCN
			    NULL == pbHash,
			pbHash,
			cbHash,
			strSerialNumber,
			&fMatch);
		_PrintIfError(hr, "myCertMatch");
		if (S_OK == hr2)
		{
		    hr2 = hr;
		}
		if (S_OK != hr || !fMatch)
		{
		    continue;
		}
	    }
	    if (0 != *pcCert)
	    {
		wprintf(wszNewLine);
	    }

	    wprintf(
		myLoadResourceString(IDS_FORMAT_DUMP_CERT_INDEX),  // "================ Certificate %d ================"
		iCert);
	    wprintf(wszNewLine);

	    if (CertGetCertificateContextProperty(
					    pCert,
					    CERT_ARCHIVED_PROP_ID,
					    NULL,
					    &cb))
	    {
		wprintf(myLoadResourceString(IDS_ARCHIVED)); // "Archived!"
		wprintf(wszNewLine);
	    }
	    if (iCert == iCertSave &&
		NULL != pwszfnOut &&
		(DVNS_SAVECERT & Mode))
	    {
		hr = EncodeToFileW(
			    pwszfnOut,
			    pCert->pbCertEncoded,
			    pCert->cbCertEncoded,
			    CRYPT_STRING_BINARY | g_EncodeFlags);
		_PrintIfError(hr, "EncodeToFileW");
		if (S_OK == hr2)
		{
		    hr2 = hr;
		}
	    }

	    hr = cuDumpAsnBinary(
			    pCert->pbCertEncoded,
			    pCert->cbCertEncoded,
			    MAXDWORD);
	    _PrintIfError(hr, "cuDumpAsnBinary");
	    if (S_OK == hr2)
	    {
		hr2 = hr;
	    }

	    if (DVNS_REPAIRKPI & Mode)
	    {
		if (!CryptFindCertificateKeyProvInfo(
					    pCert,
					    0,	// dwFlags
					    NULL))	// pvReserved
		{
		    hr = myHLastError();
		    _PrintError(hr, "CryptFindCertificateKeyProvInfo");
		    if (S_OK == hr2)
		    {
			hr2 = hr;
		    }
		}
	    
	    }
	    if ((DVNS_DUMPPROPERTIES & Mode) && !g_fQuiet)
	    {
		hr = cuDumpCertProperties(pCert);
		_PrintIfError(hr, "cuDumpCertProperties");
		if (S_OK == hr2)
		{
		    hr2 = hr;
		}
	    }
	    if (DVNS_DUMPKEYS & Mode)
	    {
		if (0 == (DVNS_DUMPPROPERTIES & Mode) || g_fQuiet)
		{
		    hr = cuDumpCertKeyProviderInfo(
					    g_wszPad2,
					    pCert,
					    NULL,
					    NULL);
		    _PrintIfError(hr, "cuDumpCertKeyProviderInfo");
		    if (S_OK == hr2)
		    {
			hr2 = hr;
		    }
		}
		hr = cuDumpPrivateKey(pCert, &fSigningKey, &fMatchingKey);
		if (!IsHrSkipPrivateKey(hr))
		{
		    if (S_OK != hr)
		    {
			wprintf(myLoadResourceString(
			    fSigningKey?
				IDS_SIGNATURE_BAD :   // "Signature test FAILED"
				IDS_ENCRYPTION_BAD)); // "Encryption test FAILED"
			wprintf(wszNewLine);
			_PrintError(hr, "cuDumpPrivateKey");
			fMatchingKey = FALSE;
		    }

		    if (fMatchingKey)
		    {
			wprintf(myLoadResourceString(
			    fSigningKey?
				IDS_SIGNATURE_OK :   // "Signature test passed"
				IDS_ENCRYPTION_OK)); // "Encryption test passed"
			wprintf(wszNewLine);
		    }
		}
	    }
	    if (DVNS_VERIFYCERT & Mode)
	    {
		hr = cuVerifyCertContext(
				pCert,
				(DVNS_CASTORE & Mode)? hStore : NULL,
				NULL,
				0,
				&VerifyState);
		if (S_OK != hr)
		{
		    cuPrintError(IDS_ERR_FORMAT_BAD_CERT, hr);
		    _PrintError(hr, "cuVerifyCertContext");
		    if (S_OK == hr2)
		    {
			hr2 = hr;		// Save first error
		    }
		}
		else if (0 == (VS_ERRORMASK & VerifyState))
		{
		    wprintf(myLoadResourceString(IDS_CERT_VERIFIES)); // "Certificate is valid"
		}
		wprintf(wszNewLine);
	    }
	    if (DVNS_SAVEPFX & Mode)
	    {
		hr = SavePFXToFile(
				pCert,
				pwszfnOut,
				0 == *pcCert,
				pwszPasswordArg,
				ppwszPassword);
		_PrintIfError(hr, "SavePFXToFile");
		if (S_OK == hr2)
		{
		    hr2 = hr;
		}
	    }
	    if (DVNS_SAVEPVK & Mode)
	    {
		hr = SavePVKToFile(pCert, pwszfnOut, 0 == *pcCert);
		_PrintIfError(hr, "SavePVKToFile");
		if (S_OK == hr2)
		{
		    hr2 = hr;
		}
	    }
	    (*pcCert)++;
	}
    }
    hr = hr2;
    _JumpIfError(hr, error, "EnumCertsInStore");

error:
    if (NULL != pCert)
    {
	CertFreeCertificateContext(pCert);
    }
    if (NULL != strSerialNumber)
    {
	SysFreeString(strSerialNumber);
    }
    return(hr);
}


HRESULT
EnumCRLsInStore(
    IN HCERTSTORE hStore,
    IN DWORD Mode,
    IN DWORD iCRLSave,
    OPTIONAL IN WCHAR const *pwszCertName,
    IN DWORD cbHash,
    OPTIONAL IN BYTE *pbHash,
    OPTIONAL IN WCHAR const *pwszfnOut,
    OUT DWORD *pcCRL)
{
    HRESULT hr;
    HRESULT hr2;
    DWORD iCRL;
    CRL_CONTEXT const *pCRL = NULL;

    *pcCRL = 0;
    hr2 = S_OK;
    for (iCRL = 0; ; iCRL++)
    {
	pCRL = CertEnumCRLsInStore(hStore, pCRL);
	if (NULL == pCRL)
	{
	    break;
	}
	if (MAXDWORD == iCRLSave || iCRL == iCRLSave)
	{
	    if (NULL != pwszCertName)
	    {
		BOOL fMatch;
		
		hr = myCRLMatch(
			    pCRL,
			    pwszCertName,
			    TRUE,		// fAllowMissingCN
			    pbHash,
			    cbHash,
			    &fMatch);
		_PrintIfError(hr, "myCRLMatch");
		if (S_OK == hr2)
		{
		    hr2 = hr;
		}
		if (S_OK != hr || !fMatch)
		{
		    continue;
		}
	    }
	    if (0 != *pcCRL)
	    {
		wprintf(wszNewLine);
	    }

	    wprintf(
		myLoadResourceString(IDS_FORMAT_DUMP_CRL_INDEX),  // "================ CRL %d ================"
		iCRL);
	    wprintf(wszNewLine);

	    if (iCRL == iCRLSave &&
		NULL != pwszfnOut &&
		(DVNS_SAVECRL & Mode))
	    {
		hr = EncodeToFileW(
			    pwszfnOut,
			    pCRL->pbCrlEncoded,
			    pCRL->cbCrlEncoded,
			    CRYPT_STRING_BINARY | g_EncodeFlags);
		_PrintIfError(hr, "EncodeToFileW");
		if (S_OK == hr2)
		{
		    hr2 = hr;
		}
	    }

	    hr = cuDumpAsnBinary(
			    pCRL->pbCrlEncoded,
			    pCRL->cbCrlEncoded,
			    MAXDWORD);
	    _PrintIfError(hr, "cuDumpAsnBinary");
	    if (S_OK == hr2)
	    {
		hr2 = hr;
	    }

	    if ((DVNS_DUMPPROPERTIES & Mode) && !g_fQuiet)
	    {
		hr = cuDumpCRLProperties(pCRL);
		_PrintIfError(hr, "cuDumpCRLProperties");
		if (S_OK == hr2)
		{
		    hr2 = hr;
		}
	    }
	    (*pcCRL)++;
	}
    }
    hr = hr2;
    _JumpIfError(hr, error, "EnumCRLsInStore");

error:
    if (NULL != pCRL)
    {
	CertFreeCRLContext(pCRL);
    }
    return(hr);
}


HRESULT
EnumCTLsInStore(
    IN HCERTSTORE hStore,
    IN DWORD Mode,
    IN DWORD iCTLSave,
    OPTIONAL IN WCHAR const *pwszCertName,
    IN DWORD cbHash,
    OPTIONAL IN BYTE *pbHash,
    OPTIONAL IN WCHAR const *pwszfnOut,
    OUT DWORD *pcCTL)
{
    HRESULT hr;
    HRESULT hr2;
    DWORD iCTL;
    CTL_CONTEXT const *pCTL = NULL;

    *pcCTL = 0;
    hr2 = S_OK;
    for (iCTL = 0; ; iCTL++)
    {
	pCTL = CertEnumCTLsInStore(hStore, pCTL);
	if (NULL == pCTL)
	{
	    break;
	}
	if (MAXDWORD == iCTLSave || iCTL == iCTLSave)
	{
	    DWORD cb;

	    if (NULL != pwszCertName)
	    {
		BOOL fMatch;
		
		hr = myCTLMatch(pCTL, pbHash, cbHash, &fMatch);
		_PrintIfError(hr, "myCTLMatch");
		if (S_OK == hr2)
		{
		    hr2 = hr;
		}
		if (S_OK != hr || !fMatch)
		{
		    continue;
		}
	    }
	    if (0 != *pcCTL)
	    {
		wprintf(wszNewLine);
	    }

	    wprintf(
		myLoadResourceString(IDS_FORMAT_DUMP_CTL_INDEX),  // "================ CTL %d ================"
		iCTL);
	    wprintf(wszNewLine);

	    if (CertGetCTLContextProperty(
				    pCTL,
				    CERT_ARCHIVED_PROP_ID,
				    NULL,
				    &cb))
	    {
		wprintf(myLoadResourceString(IDS_ARCHIVED)); // "Archived!"
		wprintf(wszNewLine);
	    }
	    if (iCTL == iCTLSave &&
		NULL != pwszfnOut &&
		(DVNS_SAVECTL & Mode))
	    {
		hr = EncodeToFileW(
			    pwszfnOut,
			    pCTL->pbCtlEncoded,
			    pCTL->cbCtlEncoded,
			    CRYPT_STRING_BINARY | g_EncodeFlags);
		_PrintIfError(hr, "EncodeToFileW");
		if (S_OK == hr2)
		{
		    hr2 = hr;
		}
	    }

	    hr = cuDumpAsnBinary(
			    pCTL->pbCtlEncoded,
			    pCTL->cbCtlEncoded,
			    MAXDWORD);
	    _PrintIfError(hr, "cuDumpAsnBinary");
	    if (S_OK == hr2)
	    {
		hr2 = hr;
	    }

	    if ((DVNS_DUMPPROPERTIES & Mode) && !g_fQuiet)
	    {
		hr = cuDumpCTLProperties(pCTL);
		_PrintIfError(hr, "cuDumpCTLProperties");
		if (S_OK == hr2)
		{
		    hr2 = hr;
		}
	    }
#if 0
	    if (DVNS_VERIFYCERT & Mode)
	    {
		hr = cuVerifyCertContext(
				pCTL,
				(DVNS_CASTORE & Mode)? hStore : NULL,
				NULL,
				0,
				&VerifyState);
		if (S_OK != hr)
		{
		    cuPrintError(IDS_ERR_FORMAT_BAD_CTL, hr);
		    _PrintError(hr, "cuVerifyCertContext");
		    if (S_OK == hr2)
		    {
			hr2 = hr;		// Save first error
		    }
		}
		else
		{
		    wprintf(myLoadResourceString(IDS_CTL_VERIFIES)); // "CTL is valid"
		}
		wprintf(wszNewLine);
	    }
#endif
	    (*pcCTL)++;
	}
    }
    hr = hr2;
    _JumpIfError(hr, error, "EnumCTLsInStore");

error:
    if (NULL != pCTL)
    {
	CertFreeCTLContext(pCTL);
    }
    return(hr);
}


HRESULT
cuDumpAndVerifyStore(
    IN HCERTSTORE hStore,
    IN DWORD Mode,
    OPTIONAL IN WCHAR const *pwszCertName,
    IN DWORD iCertSave,
    IN DWORD iCRLSave,
    IN DWORD iCTLSave,
    OPTIONAL IN WCHAR const *pwszfnOut,
    OPTIONAL IN WCHAR const *pwszPasswordArg)
{
    HRESULT hr;
    HRESULT hr2;
    BYTE *pbHash = NULL;
    DWORD cbHash;
    BOOL fVerboseOld = g_fVerbose;
    BOOL fQuietOld = g_fQuiet;
    WCHAR *pwszPassword = NULL;
    DWORD cCert = 0;
    DWORD cCRL = 0;
    DWORD cCTL = 0;

    if (g_fVerbose)
    {
	g_fVerbose--;
    }
    else
    {
	g_fQuiet = TRUE;
    }
    hr2 = S_OK;

    if (NULL != pwszCertName)
    {
	hr = WszToMultiByteInteger(TRUE, pwszCertName, &cbHash, &pbHash);
	_PrintIfError2(hr, "WszToMultiByteInteger", hr);
    }

    if (NULL != pwszCertName ||
	MAXDWORD != iCertSave ||
	(MAXDWORD == iCRLSave && MAXDWORD == iCTLSave))
    {
	hr = EnumCertsInStore(
			hStore,
			Mode, 
			iCertSave,
			pwszCertName,
			cbHash,
			pbHash,
			pwszfnOut,
			pwszPasswordArg,
			&pwszPassword,
			&cCert);
	_PrintIfError(hr, "EnumCertsInStore");
	if (S_OK == hr2)
	{
	    hr2 = hr;
	}
    }

    if (NULL != pwszCertName ||
	MAXDWORD != iCRLSave ||
	(MAXDWORD == iCertSave && MAXDWORD == iCTLSave))
    {
	hr = EnumCRLsInStore(
			hStore,
			Mode,
			iCRLSave,
			pwszCertName,
			cbHash,
			pbHash,
			pwszfnOut,
			&cCRL);
	_PrintIfError(hr, "EnumCRLsInStore");
	if (S_OK == hr2)
	{
	    hr2 = hr;
	}
    }

    if (NULL != pwszCertName ||
	MAXDWORD != iCTLSave ||
	(MAXDWORD == iCertSave && MAXDWORD == iCRLSave))
    {
	hr = EnumCTLsInStore(
			hStore,
			Mode,
			iCTLSave,
			pwszCertName,
			cbHash,
			pbHash,
			pwszfnOut,
			&cCTL);
	_PrintIfError(hr, "EnumCTLsInStore");
	if (S_OK == hr2)
	{
	    hr2 = hr;
	}
    }

    hr = hr2;
    if (S_OK == hr && NULL != pwszCertName && 0 == (cCert + cCRL + cCTL))
    {
	hr = NTE_NOT_FOUND;
        _JumpError(hr, error, "cuDumpAndVerifyStore");
    }

error:
    g_fVerbose = fVerboseOld;
    g_fQuiet = fQuietOld;
    if (NULL != pbHash)
    {
	LocalFree(pbHash);
    }
    if (NULL != pwszPassword)
    {
	LocalFree(pwszPassword);
    }
    return(hr);
}


#define wszLDAPPREFIX	L"ldap:///"

HRESULT
cuOpenCertStore(
    IN WCHAR const *pwszStoreName,
    IN OUT DWORD *pMode,
    OUT HCERTSTORE *phStore)
{
    HRESULT hr;
    WCHAR awc[7];
    LPCSTR pszStoreProvider = CERT_STORE_PROV_SYSTEM_REGISTRY_W;
    WCHAR *pwszStoreAlloc = NULL;
    WCHAR *pwszStoreAlloc2 = NULL;

    if (NULL == pwszStoreName ||
	0 == wcscmp(L"*", pwszStoreName) ||
	0 == lstrcmpi(wszCA_CERTSTORE, pwszStoreName))
    {
        pwszStoreName = wszCA_CERTSTORE;
    	*pMode |= DVNS_CASTORE;
    }
    wcsncpy(awc, pwszStoreName, ARRAYSIZE(awc));
    awc[ARRAYSIZE(awc) - 1] = L'\0';
    if (0 == lstrcmpi(L"ldap:/", awc))
    {
	pszStoreProvider = CERT_STORE_PROV_LDAP_W;
	*pMode |= DVNS_DSSTORE;
    }
    else
    {
	awc[3] = L'\0';
	if (0 == lstrcmpi(L"CN=", awc))
	{
	    pszStoreProvider = CERT_STORE_PROV_LDAP_W;
	    pwszStoreAlloc = (WCHAR *) LocalAlloc(
		    LMEM_FIXED, 
		    (WSZARRAYSIZE(wszLDAPPREFIX) + wcslen(pwszStoreName) + 1) *
			sizeof(WCHAR));
	    if (NULL == pwszStoreAlloc)
	    {
		hr = E_OUTOFMEMORY;
		_JumpError(hr, error, "LocalAlloc");
	    }
	    wcscpy(pwszStoreAlloc, wszLDAPPREFIX);
	    wcscat(pwszStoreAlloc, pwszStoreName);
	    pwszStoreName = pwszStoreAlloc;
	    *pMode |= DVNS_DSSTORE;
	}
    }
    if (DVNS_DSSTORE & *pMode)
    {
	hr = myInternetUncanonicalizeURL(pwszStoreName, &pwszStoreAlloc2);
	_JumpIfError(hr, error, "myInternetUncanonicalizeURL");

	pwszStoreName = pwszStoreAlloc2;
    }

    *phStore = CertOpenStore(
		pszStoreProvider,
		X509_ASN_ENCODING,
		NULL,		// hProv
		CERT_STORE_NO_CRYPT_RELEASE_FLAG |
		    CERT_STORE_ENUM_ARCHIVED_FLAG |
		    (((DVNS_REPAIRKPI | DVNS_WRITESTORE) & *pMode)?
			0 : CERT_STORE_READONLY_FLAG) |
		    (g_fForce? 0 : CERT_STORE_OPEN_EXISTING_FLAG) |
		    cuGetSystemStoreFlags(),
		pwszStoreName);
    if (NULL == *phStore)
    {
        hr = myHLastError();
        _JumpErrorStr(hr, error, "CertOpenStore", pwszStoreName);
    }
    hr = S_OK;

error:
    if (NULL != pwszStoreAlloc)
    {
	LocalFree(pwszStoreAlloc);
    }
    if (NULL != pwszStoreAlloc2)
    {
	LocalFree(pwszStoreAlloc2);
    }
    return(hr);
}


HRESULT
DumpAndVerifyNamedStore(
    IN WCHAR const *pwszStoreName,
    IN DWORD Mode,
    OPTIONAL IN WCHAR const *pwszCertName,
    IN DWORD iCertSave,
    IN DWORD iCRLSave,
    IN DWORD iCTLSave,
    OPTIONAL IN WCHAR const *pwszfnOut,
    OPTIONAL IN WCHAR const *pwszPassword)
{
    HRESULT hr;
    HCERTSTORE hStore = NULL;

    hr = cuOpenCertStore(pwszStoreName, &Mode, &hStore);
    _JumpIfError(hr, error, "cuOpenCertStore");

    hr = cuDumpAndVerifyStore(
			hStore,
			Mode,
			pwszCertName,
			iCertSave,
			iCRLSave,
			iCTLSave,
			pwszfnOut,
			pwszPassword);
    _JumpIfError(hr, error, "cuDumpAndVerifyStore");

error:
    if (NULL != hStore)
    {
	CertCloseStore(hStore, CERT_CLOSE_STORE_CHECK_FLAG);
    }
    return(hr);
}


HRESULT
verbViewOrDeleteStore(
    IN WCHAR const *pwszOption,
    OPTIONAL IN WCHAR const *pwszStoreName,
    OPTIONAL IN WCHAR const *pwszCertIndex,
    OPTIONAL IN WCHAR const *pwszfnOut,
    IN WCHAR const *pwszArg4)
{
    HRESULT hr;
    WCHAR *pwszCertName = NULL;
    DWORD Mode;
    DWORD iCert;
    DWORD iCRL;
    DWORD iCTL;
    HCERTSTORE hStore = NULL;
    CERT_CONTEXT const *pCert = NULL;
    BOOL fDelete = g_wszViewDelStore == pwszOption;
    WCHAR *pwszSubject = NULL;

    hr = ParseCertCRLIndex(pwszCertIndex, &pwszCertName, &iCert, &iCRL, &iCTL);
    _JumpIfErrorStr(hr, error, "ParseCertCRLIndex", pwszCertIndex);

    Mode = DVNS_SAVECERT;
    if (fDelete)
    {
	Mode |= DVNS_WRITESTORE;
    }

    hr = cuOpenCertStore(pwszStoreName, &Mode, &hStore);
    _JumpIfError(hr, error, "cuOpenCertStore");

    hr = myGetCertificateFromPicker(
		g_hInstance,		// hInstance
		NULL,			// hwndParent
		IDS_VIEWSTORE_TITLE,	// idTitle
		fDelete? IDS_VIEWSTORE_SUBTITLE_DELETE :
			 IDS_VIEWSTORE_SUBTITLE, // idSubTitle
		0,			// dwFlags -- CUCS_*
		pwszCertName,		// pwszCommonName
		1,			// cStore
		&hStore,		// rghStore
		0,			// cpszObjId
		NULL,			// apszObjId
		&pCert);		// ppCert
    _JumpIfError(hr, error, "myGetCertificateFromPicker");

    if (NULL != pCert)
    {
	hr = myCertNameToStr(
		    X509_ASN_ENCODING,
		    &pCert->pCertInfo->Subject,
		    CERT_X500_NAME_STR | CERT_NAME_STR_REVERSE_FLAG,
		    &pwszSubject);
	_JumpIfError(hr, error, "myCertNameToStr");

	if (NULL != pwszfnOut)
	{
	    hr = EncodeToFileW(
			pwszfnOut,
			pCert->pbCertEncoded,
			pCert->cbCertEncoded,
			CRYPT_STRING_BINARY | g_EncodeFlags);
	    _JumpIfError(hr, error, "EncodeToFileW");
	    wprintf(
		myLoadResourceString(
		    IDS_FORMAT_SAVED_CERT_NAME), // "Saved certificate %ws"
		    pwszSubject);
	    wprintf(L": %ws\n", pwszfnOut);
	}
	if (fDelete)
	{
	    if (!CertDeleteCertificateFromStore(pCert))
	    {
		hr = myHLastError();
		_JumpError(hr, error, "CertDeleteCertificateFromStore");
	    }
	    pCert = NULL;

	    wprintf(
		myLoadResourceString(
		    IDS_FORMAT_DELETED_CERT_NAME), // "Deleted certificate %ws"
		    pwszSubject);
	    wprintf(wszNewLine);
	}
    }
    hr = S_OK;

error:
    if (NULL != pwszSubject)
    {
	LocalFree(pwszSubject);
    }
    if (NULL != pwszCertName)
    {
	LocalFree(pwszCertName);
    }
    if (NULL != pCert)
    {
	CertFreeCertificateContext(pCert);
    }
    if (NULL != hStore)
    {
	CertCloseStore(hStore, CERT_CLOSE_STORE_CHECK_FLAG);
    }
    return(hr);
}


HRESULT
verbStore(
    IN WCHAR const *pwszOption,
    IN WCHAR const *pwszStoreName,
    IN WCHAR const *pwszCertIndex,
    IN WCHAR const *pwszfnOut,
    IN WCHAR const *pwszArg4)
{
    HRESULT hr;
    WCHAR *pwszCertName = NULL;
    DWORD iCert;
    DWORD iCRL;
    DWORD iCTL;

    hr = ParseCertCRLIndex(pwszCertIndex, &pwszCertName, &iCert, &iCRL, &iCTL);
    _JumpIfErrorStr(hr, error, "ParseCertCRLIndex", pwszCertIndex);

    hr = DumpAndVerifyNamedStore(
		    pwszStoreName,
		    DVNS_SAVECERT |
			DVNS_SAVECRL |
			DVNS_SAVECTL |
			DVNS_DUMP |
			DVNS_DUMPKEYS |
			DVNS_DUMPPROPERTIES,
		    pwszCertName,
		    iCert,
		    iCRL,
		    iCTL,
		    pwszfnOut,
		    NULL);
    _JumpIfError(hr, error, "DumpAndVerifyNamedStore");

error:
    if (NULL != pwszCertName)
    {
	LocalFree(pwszCertName);
    }
    return(hr);
}


HRESULT
verbAddStore(
    IN WCHAR const *pwszOption,
    IN WCHAR const *pwszStoreName,
    IN WCHAR const *pwszfnIn,
    IN WCHAR const *pwszArg3,
    IN WCHAR const *pwszArg4)
{
    HRESULT hr;
    WCHAR *pwszStore = NULL;
    DWORD Mode;
    HCERTSTORE hStore = NULL;
    CERT_CONTEXT const *pCertContext = NULL;
    CRL_CONTEXT const *pCRLContext = NULL;
    BOOL fRoot = FALSE;

    Mode = DVNS_WRITESTORE;	// force open for write

    hr = cuOpenCertStore(pwszStoreName, &Mode, &hStore);
    if (S_OK != hr)
    {
	wprintf(myLoadResourceString(
		    g_fForce?
			IDS_CANNOT_CREATE_STORE :   // "Cannot open Cert store."
			IDS_CANNOT_OPEN_STORE));   // "Cannot open existing Cert store.  Use -f switch to force Cert store creation."
	wprintf(wszNewLine);
        _JumpErrorStr(hr, error, "cuOpenCertStore", pwszStoreName);
    }

    // Load and decode certificate

    hr = cuLoadCert(pwszfnIn, &pCertContext);
    if (S_OK != hr)
    {
	if (CRYPT_E_ASN1_BADTAG != hr)
	{
	    _JumpError(hr, error, "cuLoadCert");
	}
	hr = cuLoadCRL(pwszfnIn, &pCRLContext);
	_JumpIfError(hr, error, "cuLoadCRL");

	if (!CertAddCRLContextToStore(
				hStore,
				pCRLContext,
				CERT_STORE_ADD_REPLACE_EXISTING,
				NULL))
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "CertAddCRLContextToStore");
	}
    }
    else
    {
	if (CertCompareCertificateName(
			X509_ASN_ENCODING,
			&pCertContext->pCertInfo->Issuer,
			&pCertContext->pCertInfo->Subject))
	{
	    hr = cuVerifySignature(
			    pCertContext->pbCertEncoded,
			    pCertContext->cbCertEncoded,
			    &pCertContext->pCertInfo->SubjectPublicKeyInfo,
			    FALSE);
	    fRoot = S_OK == hr;
	    _PrintIfError(hr, "cuVerifySignature");
	}
	if (0 == lstrcmpi(pwszStoreName, L"root") && !fRoot)
	{
	    wprintf(myLoadResourceString(IDS_ROOT_STORE_NEEDS_ROOT_CERT));  // "Cannot add a non-root certificate to the root store"
	    wprintf(wszNewLine);
	    hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	    _JumpError(hr, error, "Non-root cert");
	}

	if (!CertAddCertificateContextToStore(
					hStore,
					pCertContext,
					CERT_STORE_ADD_REPLACE_EXISTING,
					NULL))
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "CertAddCertificateContextToStore");
	}
    }
    hr = S_OK;

error:
    cuUnloadCert(&pCertContext);
    cuUnloadCRL(&pCRLContext);
    if (NULL != pwszStore)
    {
	LocalFree(pwszStore);
    }
    if (NULL != hStore)
    {
	CertCloseStore(hStore, CERT_CLOSE_STORE_CHECK_FLAG);
    }
    return(hr);
}


HRESULT
verbDelStore(
    IN WCHAR const *pwszOption,
    IN WCHAR const *pwszStoreName,
    IN WCHAR const *pwszCertIndex,
    IN WCHAR const *pwszArg3,
    IN WCHAR const *pwszArg4)
{
    HRESULT hr;
    WCHAR *pwszStore = NULL;
    HCERTSTORE hStore = NULL;
    CERT_CONTEXT const *pCert = NULL;
    CRL_CONTEXT const *pCRL = NULL;
    WCHAR *pwszCertName = NULL;
    BYTE *pbHash = NULL;
    DWORD cbHash;
    BSTR strSerialNumber = NULL;
    DWORD Mode;
    DWORD iCert;
    DWORD iCertDel;
    DWORD iCRL;
    DWORD iCRLDel;
    DWORD iCTL;
    DWORD iCTLDel;

    if (NULL == pwszStoreName || 0 == wcscmp(L"*", pwszStoreName))
    {
        pwszStoreName = wszCA_CERTSTORE;
    }

    hr = ParseCertCRLIndex(pwszCertIndex, &pwszCertName, &iCertDel, &iCRLDel, &iCTLDel);
    _JumpIfErrorStr(hr, error, "ParseCertCRLIndex", pwszCertIndex);

    if (MAXDWORD == iCertDel && NULL == pwszCertName && MAXDWORD == iCRLDel)
    {
	hr = E_INVALIDARG;
	_JumpErrorStr(hr, error, "incomplete Index arg", pwszCertIndex);
    }
    if (NULL != pwszCertName)
    {
	hr = WszToMultiByteInteger(TRUE, pwszCertName, &cbHash, &pbHash);
	_PrintIfError2(hr, "WszToMultiByteInteger", hr);

	hr = myMakeSerialBstr(pwszCertName, &strSerialNumber);
	_PrintIfError2(hr, "myMakeSerialBstr", hr);
    }

    Mode = DVNS_WRITESTORE;	// force open for write

    hr = cuOpenCertStore(pwszStoreName, &Mode, &hStore);
    _JumpIfError(hr, error, "cuOpenCertStore");

    if (MAXDWORD != iCertDel || NULL != pwszCertName)
    {
	for (iCert = 0; ; iCert++)
	{
	    pCert = CertEnumCertificatesInStore(hStore, pCert);
	    if (NULL == pCert)
	    {
		break;
	    }
	    if (iCert == iCertDel ||
		(MAXDWORD == iCertDel && NULL != pwszCertName))
	    {
		CERT_CONTEXT const *pCertT;

		if (NULL != pwszCertName)
		{
		    BOOL fMatch;
		    
		    hr = myCertMatch(
				pCert,
				pwszCertName,
				FALSE,		// fAllowMissingCN
				pbHash,
				cbHash,
				strSerialNumber,
				&fMatch);
		    _JumpIfError(hr, error, "myCertMatch");

		    if (!fMatch)
		    {
			continue;
		    }
		}
		wprintf(
		    myLoadResourceString(IDS_FORMAT_DELETE_CERT_INDEX),  // "Deleting Certificate %d"
		    iCert);
		wprintf(wszNewLine);

		pCertT = CertDuplicateCertificateContext(pCert);
		if (!CertDeleteCertificateFromStore(pCertT))
		{
		    hr = myHLastError();
		    _JumpError(hr, error, "CertDeleteCertificateFromStore");
		}
		if (iCert == iCertDel)
		{
		    break;
		}
	    }
	}
    }
    if (MAXDWORD != iCRLDel)
    {
	for (iCRL = 0; ; iCRL++)
	{
	    pCRL = CertEnumCRLsInStore(hStore, pCRL);
	    if (NULL == pCRL)
	    {
		break;
	    }
	    if (iCRL == iCRLDel ||
		(MAXDWORD == iCRLDel && NULL != pwszCertName))
	    {
		CRL_CONTEXT const *pCRLT;

		if (NULL != pwszCertName)
		{
		    BOOL fMatch;
		    
		    hr = myCRLMatch(
				pCRL,
				pwszCertName,
				FALSE,		// fAllowMissingCN
				pbHash,
				cbHash,
				&fMatch);
		    _JumpIfError(hr, error, "myCRLMatch");

		    if (!fMatch)
		    {
			continue;
		    }
		}
		wprintf(
		    myLoadResourceString(IDS_FORMAT_DELETE_CRL_INDEX),  // "Deleting CRL %d"
		    iCRL);
		wprintf(wszNewLine);

		pCRLT = CertDuplicateCRLContext(pCRL);
		if (!CertDeleteCRLFromStore(pCRLT))
		{
		    hr = myHLastError();
		    _JumpError(hr, error, "CertDeleteCRLFromStore");
		}
		if (iCRL == iCRLDel)
		{
		    break;
		}
	    }
	}
    }
    hr = S_OK;

error:
    if (NULL != strSerialNumber)
    {
	SysFreeString(strSerialNumber);
    }
    if (NULL != pbHash)
    {
	LocalFree(pbHash);
    }
    if (NULL != pwszCertName)
    {
	LocalFree(pwszCertName);
    }
    if (NULL != pwszStore)
    {
	LocalFree(pwszStore);
    }
    if (NULL != pCert)
    {
	CertFreeCertificateContext(pCert);
    }
    if (NULL != pCRL)
    {
	CertFreeCRLContext(pCRL);
    }
    if (NULL != hStore)
    {
	CertCloseStore(hStore, CERT_CLOSE_STORE_CHECK_FLAG);
    }
    return(hr);
}


HRESULT
verbVerifyStore(
    IN WCHAR const *pwszOption,
    IN WCHAR const *pwszStoreName,
    IN WCHAR const *pwszCertIndex,
    IN WCHAR const *pwszArg3,
    IN WCHAR const *pwszArg4)
{
    HRESULT hr;
    WCHAR *pwszCertName = NULL;
    DWORD iCert;
    DWORD iCRL;
    DWORD iCTL;

    hr = ParseCertCRLIndex(pwszCertIndex, &pwszCertName, &iCert, &iCRL, &iCTL);
    _JumpIfErrorStr(hr, error, "ParseCertCRLIndex", pwszCertIndex);

    hr = DumpAndVerifyNamedStore(
		    pwszStoreName,
		    DVNS_SAVECERT |
			DVNS_SAVECRL |
			DVNS_SAVECTL |
			DVNS_VERIFYCERT |
			DVNS_DUMPKEYS |
			DVNS_DUMPPROPERTIES,
		    pwszCertName,
		    iCert,
		    iCRL,
		    iCTL,
		    NULL,
		    NULL);
    _JumpIfError(hr, error, "DumpAndVerifyNamedStore");

error:
    if (NULL != pwszCertName)
    {
	LocalFree(pwszCertName);
    }
    return(hr);
}


HRESULT
verbRepairStore(
    IN WCHAR const *pwszOption,
    IN WCHAR const *pwszStoreName,
    IN WCHAR const *pwszCertIndex,
    IN WCHAR const *pwszArg3,
    IN WCHAR const *pwszArg4)
{
    HRESULT hr;
    WCHAR *pwszCertName = NULL;
    DWORD iCert;
    DWORD iCRL;
    DWORD iCTL;

    hr = ParseCertCRLIndex(pwszCertIndex, &pwszCertName, &iCert, &iCRL, &iCTL);
    _JumpIfErrorStr(hr, error, "ParseCertCRLIndex", pwszCertIndex);

    hr = DumpAndVerifyNamedStore(
		    pwszStoreName,
		    DVNS_SAVECERT |
			DVNS_SAVECRL |
			DVNS_SAVECTL |
			DVNS_REPAIRKPI |
			DVNS_DUMPKEYS,
		    pwszCertName,
		    iCert,
		    iCRL,
		    iCTL,
		    NULL,
		    NULL);
    _JumpIfError(hr, error, "DumpAndVerifyNamedStore");

error:
    if (NULL != pwszCertName)
    {
	LocalFree(pwszCertName);
    }
    return(hr);
}


HRESULT
verbExportPVK(
    IN WCHAR const *pwszOption,
    IN WCHAR const *pwszCertIndex,
    IN WCHAR const *pwszfnPVKBaseName,
    IN WCHAR const *pwszStoreName,
    IN WCHAR const *pwszArg4)
{
    HRESULT hr;
    WCHAR *pwszCertName = NULL;
    DWORD iCert;
    DWORD iCRL;
    DWORD iCTL;

    hr = ParseCertCRLIndex(pwszCertIndex, &pwszCertName, &iCert, &iCRL, &iCTL);
    _JumpIfErrorStr(hr, error, "ParseCertCRLIndex", pwszCertIndex);

    hr = DumpAndVerifyNamedStore(
		    NULL == pwszStoreName? wszMY_CERTSTORE : pwszStoreName,
		    DVNS_SAVEPVK | DVNS_DUMPKEYS,
		    pwszCertName,
		    iCert,
		    iCRL,
		    iCTL,
		    pwszfnPVKBaseName,
		    NULL);
    _JumpIfError(hr, error, "DumpAndVerifyNamedStore");

error:
    if (NULL != pwszCertName)
    {
	LocalFree(pwszCertName);
    }
    return(hr);
}


HRESULT
verbExportPFX(
    IN WCHAR const *pwszOption,
    IN WCHAR const *pwszCertIndex,
    IN WCHAR const *pwszfnPFX,
    IN WCHAR const *pwszPassword,
    IN WCHAR const *pwszStoreName)
{
    HRESULT hr;
    WCHAR *pwszCertName = NULL;
    DWORD iCert;
    DWORD iCRL;
    DWORD iCTL;

    hr = ParseCertCRLIndex(pwszCertIndex, &pwszCertName, &iCert, &iCRL, &iCTL);
    _JumpIfErrorStr(hr, error, "ParseCertCRLIndex", pwszCertIndex);

    hr = DumpAndVerifyNamedStore(
		    NULL == pwszStoreName? wszMY_CERTSTORE : pwszStoreName,
		    DVNS_SAVEPFX | DVNS_DUMPKEYS,
		    pwszCertName,
		    iCert,
		    iCRL,
		    iCTL,
		    pwszfnPFX,
		    pwszPassword);
    _JumpIfError(hr, error, "DumpAndVerifyNamedStore");

error:
    if (NULL != pwszCertName)
    {
	LocalFree(pwszCertName);
    }
    return(hr);
}


HRESULT
cuImportChainAndKeys(
    IN CERT_CHAIN_CONTEXT const *pChain,
    IN BOOL fUser,
    OPTIONAL IN WCHAR const *pwszStoreName)
{
    HRESULT hr;
    CRYPT_KEY_PROV_INFO *pkpi = NULL;
    WCHAR *pwszSimpleName = NULL;
    WCHAR *pwszRawContainerName = NULL;
    WCHAR *pwszKeyContainerName = NULL;
    CERT_CONTEXT const *pcc;
    DWORD cwc;
    WCHAR *pwsz;

    if (NULL == pwszStoreName)
    {
	pwszStoreName = wszMY_CERTSTORE;
    }
    pcc = pChain->rgpChain[0]->rgpElement[0]->pCertContext;

    hr = myCertGetNameString(
			pcc,
			CERT_NAME_SIMPLE_DISPLAY_TYPE,
			&pwszSimpleName);
    _JumpIfError(hr, error, "myCertGetNameString");

    hr = myCertGetKeyProviderInfo(pcc, &pkpi);
    _JumpIfError(hr, error, "myCertGetKeyProviderInfo");

    for (pwsz = pkpi->pwszContainerName; L'\0' != *pwsz; pwsz++)
    {
	if (L'A' <= *pwsz && L'F' >= *pwsz)
	{
	    *pwsz += L'a' - L'A';
	}
    }
    pwsz = pkpi->pwszContainerName;
    if (wcLBRACE == *pwsz)
    {
	pwsz++;
    }

    cwc = wcslen(pwszSimpleName) + 1 + wcslen(pwsz);
    pwszRawContainerName = (WCHAR *) LocalAlloc(
					LMEM_FIXED,
					(cwc + 1) * sizeof(WCHAR));
    if (NULL == pwszRawContainerName)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }
    wcscpy(pwszRawContainerName, pwszSimpleName);
    wcscat(pwszRawContainerName, L"-");
    wcscat(pwszRawContainerName, pwsz);
    pwsz = &pwszRawContainerName[wcslen(pwszRawContainerName) - 1];
    if (wcLBRACE == *pkpi->pwszContainerName && wcRBRACE == *pwsz)
    {
	*pwsz = L'\0';
    }

    hr = mySanitizeName(pwszRawContainerName, &pwszKeyContainerName);
    _JumpIfError(hr, error, "mySanitizeName");

    wprintf(L"%ws -- %ws\n", pwszSimpleName, pwszKeyContainerName);

    hr = myCopyKeys(
		pkpi,
		pkpi->pwszContainerName,	// pwszOldContainer
		pwszKeyContainerName,		// pwszNewContainer
		fUser,				// fOldUserKey
		fUser,				// fNewUserKey
		g_fForce);
    _JumpIfError(hr, error, "myCopyKeys");

    pkpi->pwszContainerName = pwszKeyContainerName;

    hr = mySaveChainAndKeys(
			pChain->rgpChain[0],
			pwszStoreName,
			cuGetSystemStoreFlags(),
			pkpi,
			NULL);
    _JumpIfError(hr, error, "mySaveChainAndKeys");

error:
    if (NULL != pkpi)
    {
	LocalFree(pkpi);
    }
    if (NULL != pwszSimpleName)
    {
        LocalFree(pwszSimpleName);
    }
    if (NULL != pwszRawContainerName)
    {
        LocalFree(pwszRawContainerName);
    }
    if (NULL != pwszKeyContainerName)
    {
        LocalFree(pwszKeyContainerName);
    }
    return(hr);
}


HRESULT
verbImportPFX(
    IN WCHAR const *pwszOption,
    IN WCHAR const *pwszfnPFX,
    IN WCHAR const *pwszPassword,
    IN WCHAR const *pwszStoreName,
    IN WCHAR const *pwszArg4)
{
    HRESULT hr;
    CRYPT_DATA_BLOB pfx;
    WCHAR wszPassword[MAX_PATH];
    HCERTSTORE hStorePFX = NULL;
    RESTORECHAIN *paRestoreChain = NULL;
    DWORD cRestoreChain;
    DWORD iChain;
    BOOL fUser = !g_fEnterpriseRegistry && g_fUserRegistry;

    pfx.pbData = NULL;

    if (NULL == pwszPassword || 0 == wcscmp(L"*", pwszPassword))
    {
	hr = cuGetPassword(FALSE, wszPassword, ARRAYSIZE(wszPassword));
	_JumpIfError(hr, error, "cuGetPassword");

	pwszPassword = wszPassword;
    }
    hr = DecodeFileW(pwszfnPFX, &pfx.pbData, &pfx.cbData, CRYPT_STRING_ANY);
    _JumpIfError(hr, error, "DecodeFileW");

    CSASSERT(NULL != pfx.pbData);

    if (!PFXIsPFXBlob(&pfx))
    {
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
        _JumpError(hr, error, "PFXIsPFXBlob");
    }

    hStorePFX = myPFXImportCertStore(
				&pfx,
				pwszPassword,
				CRYPT_EXPORTABLE | 
				    (fUser? 0 : CRYPT_MACHINE_KEYSET));
    if (NULL == hStorePFX)
    {
        hr = myHLastError();
        _JumpError(hr, error, "myPFXImportCertStore");
    }

    cRestoreChain = 0;
    hr = myGetChainArrayFromStore(
                                hStorePFX,
				FALSE,
				fUser,
                                NULL,		// ppwszCommonName
                                &cRestoreChain,
                                NULL);
    _JumpIfError(hr, error, "myGetChainArrayFromStore");

    if (0 == cRestoreChain)
    {
        hr = HRESULT_FROM_WIN32(CRYPT_E_SELF_SIGNED);
        _JumpError(hr, error, "myGetChainArrayFromStore <no chain>");
    }

    paRestoreChain = (RESTORECHAIN *) LocalAlloc(
				    LMEM_FIXED | LMEM_ZEROINIT,
				    cRestoreChain * sizeof(paRestoreChain[0]));
    if (NULL == paRestoreChain)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }

    hr = myGetChainArrayFromStore(
			    hStorePFX,
			    FALSE,
			    fUser,
			    NULL,		// ppwszCommonName
			    &cRestoreChain,
			    paRestoreChain);
    _JumpIfError(hr, error, "myGetChainArrayFromStore");

    for (iChain = 0; iChain < cRestoreChain; iChain++)
    {
	CERT_CHAIN_CONTEXT const *pChain = paRestoreChain[iChain].pChain;
	CERT_PUBLIC_KEY_INFO *pPublicKeyInfo;

	if (1 > pChain->cChain)
	{
	    hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	    _JumpError(hr, error, "No Chain Context");
	}
	hr = cuImportChainAndKeys(pChain, fUser, pwszStoreName);
	_JumpIfError(hr, error, "cuImportChainAndKeys");
    }
    hr = S_OK;

error:
    if (NULL != paRestoreChain)
    {
        for (iChain = 0; iChain < cRestoreChain; iChain++)
	{
	    if (NULL != paRestoreChain[iChain].pChain)
	    {
		CertFreeCertificateChain(paRestoreChain[iChain].pChain);
	    }
	}
	LocalFree(paRestoreChain);
    }
    if (NULL != hStorePFX)
    {
        myDeleteGuidKeys(hStorePFX, !fUser);
	CertCloseStore(hStorePFX, CERT_CLOSE_STORE_CHECK_FLAG);
    }
    if (NULL != pfx.pbData)
    {
        LocalFree(pfx.pbData);
    }
    return(hr);
}


HRESULT
AddStringToList(
    IN WCHAR const *pwszNew,
    IN OUT WCHAR ***papwsz)
{
    HRESULT hr;
    WCHAR *pwszAlloc = NULL;
    WCHAR **ppwsz;
    DWORD i;

    // Count the strings in the existing list.
    // If the new string matches an existing string, return imemdiately.

    ppwsz = *papwsz;
    i = 0;
    if (NULL != ppwsz)
    {
	for ( ; NULL != ppwsz[i]; i++)
	{
	    if (0 == lstrcmp(pwszNew, ppwsz[i]))
	    {
		hr = S_OK;
		goto error;
	    }
	}
    }
    hr = myDupString(pwszNew, &pwszAlloc);
    _JumpIfError(hr, error, "myDupString");

    ppwsz = (WCHAR **) LocalAlloc(LMEM_FIXED, (i + 2) * sizeof(*ppwsz));
    if (NULL == ppwsz)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }

    // Insert the new string at the head of the list.

    ppwsz[0] = pwszAlloc;
    pwszAlloc = NULL;
    if (0 != i)
    {
	CopyMemory(&ppwsz[1], *papwsz, i * sizeof(*ppwsz));
	LocalFree(*papwsz);
    }
    ppwsz[i + 1] = NULL;
    *papwsz = ppwsz;
    hr = S_OK;

error:
    if (NULL != pwszAlloc)
    {
	LocalFree(pwszAlloc);
    }
    return(hr);
}


HRESULT
AddPFXToStore(
    IN WCHAR const *pwszfn,
    IN HCERTSTORE hStoreMerge,
    IN OUT WCHAR ***papwszPasswordList)
{
    HRESULT hr;
    WCHAR const * const *ppwszPasswordList = *papwszPasswordList;
    DWORD i;
    CRYPT_DATA_BLOB pfx;
    HCERTSTORE hStorePFX = NULL;
    WCHAR wszPassword[MAX_PATH];
    WCHAR const *pwszPassword;
    CERT_CONTEXT const *pCert = NULL;

    pfx.pbData = NULL;

    hr = DecodeFileW(pwszfn, &pfx.pbData, &pfx.cbData, CRYPT_STRING_ANY);
    _JumpIfError(hr, error, "DecodeFileW");

    if (!PFXIsPFXBlob(&pfx))
    {
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
        _JumpError(hr, error, "PFXIsPFXBlob");
    }

    // Try all of the passwords collected so far.

    if (NULL != ppwszPasswordList)
    {
	for (i = 0; NULL != ppwszPasswordList[i]; i++)
	{
	    hStorePFX = myPFXImportCertStore(
					&pfx,
					ppwszPasswordList[i],
					CRYPT_EXPORTABLE);
	    if (NULL != hStorePFX)
	    {
		break;
	    }
	    hr = myHLastError();
	    _PrintError2(
		    hr,
		    "myPFXImportCertStore",
		    HRESULT_FROM_WIN32(ERROR_INVALID_PASSWORD));
	}
    }

    // Try the unparsed command line password, or collect a new one.

    pwszPassword = g_pwszPassword;
    while (NULL == hStorePFX)
    {
	if (NULL != pwszPassword)
	{
	    hStorePFX = myPFXImportCertStore(
					&pfx,
					pwszPassword,
					CRYPT_EXPORTABLE);
	    if (NULL != hStorePFX)
	    {
		break;
	    }
	    hr = myHLastError();
	    _PrintError2(
		    hr,
		    "myPFXImportCertStore",
		    HRESULT_FROM_WIN32(ERROR_INVALID_PASSWORD));
	}

	wprintf(L"Enter password for %ws:\n", pwszfn);
	hr = cuGetPassword(FALSE, wszPassword, ARRAYSIZE(wszPassword));
	_JumpIfError(hr, error, "cuGetPassword");

	hr = AddStringToList(wszPassword, papwszPasswordList);
	_JumpIfError(hr, error, "AddStringToList");

	pwszPassword = wszPassword;
    }
    CSASSERT(NULL != hStorePFX);
    while (TRUE)
    {
	pCert = CertEnumCertificatesInStore(hStorePFX, pCert);
	if (NULL == pCert)
	{
	    break;
	}
	if (!CertAddCertificateContextToStore(
					hStoreMerge,
					pCert,
					CERT_STORE_ADD_REPLACE_EXISTING,
					NULL))
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "CertAddCertificateContextToStore");
	}
	if (!CertDeleteCertificateFromStore(pCert))
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "CertDeleteCertificateFromStore");
	}
	pCert = NULL;
    }
    hr = S_OK;

error:
    if (NULL != pCert)
    {
	CertFreeCertificateContext(pCert);
    }
    if (NULL != hStorePFX)
    {
        myDeleteGuidKeys(hStorePFX, FALSE);
	CertCloseStore(hStorePFX, CERT_CLOSE_STORE_CHECK_FLAG);
    }
    if (NULL != pfx.pbData)
    {
        LocalFree(pfx.pbData); 
    }
    return(hr);
}


HRESULT
verbMergePFX(
    IN WCHAR const *pwszOption,
    IN WCHAR const *pwszfnPFXInFileList,
    IN WCHAR const *pwszfnPFXOutFile,
    IN WCHAR const *pwszArg3,
    IN WCHAR const *pwszArg4)
{
    HRESULT hr;
    WCHAR **ppwszfnList = NULL;
    WCHAR **ppwszPasswordList = NULL;
    DWORD i;
    HCERTSTORE hStoreMerge = NULL;
    WCHAR *pwszPasswordAlloc = NULL;
    WCHAR *pwszPasswordOut;

    hr = cuParseStrings(
		pwszfnPFXInFileList,
		FALSE,
		NULL,
		NULL,
		&ppwszfnList,
		NULL);
    _JumpIfError(hr, error, "cuParseStrings");

    pwszPasswordOut = NULL;
    if (NULL != g_pwszPassword)
    {
	hr = cuParseStrings(
		    g_pwszPassword,
		    FALSE,
		    NULL,
		    NULL,
		    &ppwszPasswordList,
		    NULL);
	_JumpIfError(hr, error, "cuParseStrings");

	for (i = 0; NULL != ppwszPasswordList[i]; i++)
	{
	}
	if (i > 1 && 0 != lstrcmp(L"*", ppwszPasswordList[i - 1]))
	{
	    pwszPasswordOut = ppwszPasswordList[i - 1];
	}
    }
    hStoreMerge = CertOpenStore(
			    CERT_STORE_PROV_MEMORY,
			    X509_ASN_ENCODING,
			    NULL,
			    CERT_STORE_NO_CRYPT_RELEASE_FLAG |
				CERT_STORE_ENUM_ARCHIVED_FLAG,
			    NULL);
    if (NULL == hStoreMerge)
    {
        hr = myHLastError();
        _JumpError(hr, error, "CertOpenStore");
    }
    for (i = 0; NULL != ppwszfnList[i]; i++)
    {
	hr = AddPFXToStore(
		    ppwszfnList[i],
		    hStoreMerge,
		    &ppwszPasswordList);
	_JumpIfError(hr, error, "AddPFXToStore");
    }
    hr = SavePFXStoreToFile(
		    hStoreMerge,
		    pwszfnPFXOutFile,
		    pwszPasswordOut,
		    &pwszPasswordAlloc);
    _JumpIfError(hr, error, "SavePFXStoreToFile");

error:
    if (NULL != hStoreMerge)
    {
        myDeleteGuidKeys(hStoreMerge, FALSE);
	CertCloseStore(hStoreMerge, CERT_CLOSE_STORE_CHECK_FLAG);
    }
    cuFreeStringArray(ppwszPasswordList);
    cuFreeStringArray(ppwszfnList);
    if (NULL != pwszPasswordAlloc)
    {
	LocalFree(pwszPasswordAlloc);
    }
    return(hr);
}


HRESULT
GetMarshaledDword(
    IN BOOL fFetchLength,
    IN OUT BYTE const **ppb,
    IN OUT DWORD *pcb,
    OUT DWORD *pdw)
{
    HRESULT hr = HRESULT_FROM_WIN32(ERROR_HANDLE_EOF);

    if (sizeof(*pdw) > *pcb)
    {
	_JumpError(hr, error, "input buffer too small");
    }
    *pdw = *(DWORD UNALIGNED *) *ppb;
    *ppb += sizeof(*pdw);
    *pcb -= sizeof(*pdw);
    if (fFetchLength && *pdw > *pcb)
    {
	_JumpError(hr, error, "input buffer too small for length");
    }
    hr = S_OK;

error:
    return(hr);
}


HRESULT
DecodeSequence(
    IN BYTE const *pbSeq,
    IN DWORD cbSeq,
    IN DWORD cSeq,
    OUT CRYPT_SEQUENCE_OF_ANY **ppSeq)
{
    HRESULT hr;
    DWORD cb;
    DWORD i;
    CRYPT_SEQUENCE_OF_ANY *pSeq = NULL;

    *ppSeq = NULL;
    if (!myDecodeObject(
		    X509_ASN_ENCODING,
		    X509_SEQUENCE_OF_ANY,
		    pbSeq,
		    cbSeq,
		    CERTLIB_USE_LOCALALLOC,
		    (VOID **) &pSeq,
		    &cb))
    {
	hr = myHLastError();
	_JumpError(hr, error, "myDecodeObject");
    }
    hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
    if (cSeq != pSeq->cValue)
    {
	_JumpError(hr, error, "Sequence count");
    }
    for (i = 0; i < cSeq; i++)
    {
	if (NULL == pSeq->rgValue[i].pbData || 0 == pSeq->rgValue[i].cbData)
	{
	    _JumpError(hr, error, "Empty Sequence");
	}
    }
    *ppSeq = pSeq;
    pSeq = NULL;
    hr = S_OK;

error:
    if (NULL != pSeq)
    {
	LocalFree(pSeq);
    }
    return(hr);
}


#define k_PrivateKeyVersion	0

HRESULT
VerifyKeyVersion(
    IN BYTE const *pbIn,
    IN DWORD cbIn)
{
    HRESULT hr;
    DWORD dwKeyVersion;
    DWORD cb;

    dwKeyVersion = MAXDWORD;
    cb = sizeof(dwKeyVersion);
    if (!CryptDecodeObject(
		    X509_ASN_ENCODING,
		    X509_INTEGER,
		    pbIn,
		    cbIn,
		    0,
		    &dwKeyVersion,
		    &cb))
    {
	hr = myHLastError();
	_JumpError(hr, error, "CryptDecodeObject");
    }
    if (k_PrivateKeyVersion != dwKeyVersion)
    {
	hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	_JumpError(hr, error, "Public key version");
    }
    hr = S_OK;

error:
    return(hr);
}


//+-------------------------------------------------------------------------
// Inputs a private key in PKCS PrivateKeyInfo format:
//  RSAPrivateKeyInfo ::= SEQUENCE {
//      version             Version,    -- only 0 supported
//      privateKeyAlgorithm PrivateKeyAlgorithmIdentifier,
//      privateKey          PrivateKey
//  }
//
//  Version ::= INTEGER
//
//  PrivateKeyAlgorithmIdentifier ::= AlgorithmIdentifier
//
//  PrivateKey ::= OCTET STRING     -- contains an RSAPrivateKey
//
//  RSAPrivateKey ::= SEQUENCE {
//      version         Version,    -- only 0 supported
//      modulus         INTEGER,    -- n
//      publicExponent  INTEGER,    -- e
//      privateExponent INTEGER,    -- d
//      prime1          INTEGER,    -- p
//      prime2          INTEGER,    -- q
//      exponent1       INTEGER,    -- d mod (p-1)
//      exponent2       INTEGER,    -- d mod (q-1)
//      coefficient     INTEGER     -- (inverse of q) mod p
//  }
//
// returns a PRIVATEKEYBLOB
//--------------------------------------------------------------------------

// Indexes into pSeqOuter:
#define ISO_VERSION	0
#define ISO_ALG		1
#define ISO_KEY		2
#define ISO_MAX		3	// number of elements

// Indexes into pSeqAlg:
#define ISA_OID		0
#define ISA_PARM	1
#define ISA_MAX		2	// number of elements

// Indexes into pSeqKey:
#define ISK_VERSION	0
#define ISK_MODULUS	1	// public key
#define ISK_PUBEXP	2
#define ISK_PRIVEXP	3
#define ISK_PRIME1	4
#define ISK_PRIME2	5
#define ISK_EXP1	6
#define ISK_EXP2	7
#define ISK_COEFF	8
#define ISK_MAX		9	// number of elements

typedef struct _KEYBLOBMAP
{
    DWORD dwisk;	// index into pSeqKey: ISK_*
    DWORD dwdivisor;	// cbitKey/dwDivisor is expected byte count
} KEYBLOBMAP;

// The KEYBLOBMAP array defines the order and expected size of the key element
// integers as they will appear in the RSA PRIVATEKEYBLOB.

KEYBLOBMAP g_akbm[] = {
    { ISK_MODULUS, 8 },		// public key
    { ISK_PRIME1,  16 },
    { ISK_PRIME2,  16 },
    { ISK_EXP1,    16 },
    { ISK_EXP2,    16 },
    { ISK_COEFF,   16 },
    { ISK_PRIVEXP, 8 },
};

HRESULT
myDecodeKMSRSAKey(
    IN BYTE const *pbKMSRSAKey,
    IN DWORD cbKMSRSAKey,
    OUT BYTE **ppbKey,
    OUT DWORD *pcbKey)
{
    HRESULT hr;
    CRYPT_SEQUENCE_OF_ANY *pSeqOuter = NULL;
    CRYPT_SEQUENCE_OF_ANY *pSeqAlg = NULL;
    CRYPT_SEQUENCE_OF_ANY *pSeqKey = NULL;
    DWORD cb;
    DWORD i;
    BYTE *pb;
    BYTE *pbKey = NULL;
    DWORD cbKey;
    DWORD cbitKey;
    char *pszObjId = NULL;
    CRYPT_DATA_BLOB *pBlobKey = NULL;
    CRYPT_INTEGER_BLOB *apIntKey[ISK_MAX];
    DWORD dwPubExp;

    *ppbKey = NULL;
    ZeroMemory(apIntKey, sizeof(apIntKey));
    hr = DecodeSequence(pbKMSRSAKey, cbKMSRSAKey, ISO_MAX, &pSeqOuter);
    _JumpIfError(hr, error, "DecodeSequence");

    hr = VerifyKeyVersion(
		    pSeqOuter->rgValue[ISO_VERSION].pbData,
		    pSeqOuter->rgValue[ISO_VERSION].cbData);
    _JumpIfError(hr, error, "VerifyKeyVersion");

    hr = DecodeSequence(
		pSeqOuter->rgValue[ISO_ALG].pbData,
		pSeqOuter->rgValue[ISO_ALG].cbData,
		ISA_MAX,
		&pSeqAlg);
    _JumpIfError(hr, error, "DecodeSequence");

    hr = cuDecodeObjId(
		pSeqAlg->rgValue[ISA_OID].pbData,
		pSeqAlg->rgValue[ISA_OID].cbData,
		&pszObjId);
    _JumpIfError(hr, error, "cuDecodeObjId");

    // key algorithm must be szOID_RSA_RSA

    if (0 != strcmp(szOID_RSA_RSA, pszObjId))
    {
	hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	_JumpError(hr, error, "Bad key alg ObjId");
    }

    // key algorithm parms must be NULL (BER_NULL, cb == 0)

    if (2 != pSeqAlg->rgValue[ISA_PARM].cbData ||
	BER_NULL != pSeqAlg->rgValue[ISA_PARM].pbData[0] ||
	0 != pSeqAlg->rgValue[ISA_PARM].pbData[1])
    {
	hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	_JumpError(hr, error, "Bad key alg parameters");
    }

    if (!myDecodeObject(
		    X509_ASN_ENCODING,
		    X509_OCTET_STRING,
		    pSeqOuter->rgValue[ISO_KEY].pbData,
		    pSeqOuter->rgValue[ISO_KEY].cbData,
		    CERTLIB_USE_LOCALALLOC,
		    (VOID **) &pBlobKey,
		    &cb))
    {
	hr = myHLastError();
	_JumpError(hr, error, "myDecodeObject");
    }

    hr = DecodeSequence(
		pBlobKey->pbData,
		pBlobKey->cbData,
		ARRAYSIZE(apIntKey),
		&pSeqKey);
    _JumpIfError(hr, error, "DecodeSequence");

    hr = VerifyKeyVersion(
		    pSeqKey->rgValue[ISK_VERSION].pbData,
		    pSeqKey->rgValue[ISK_VERSION].cbData);
    _JumpIfError(hr, error, "VerifyKeyVersion");

    cb = sizeof(dwPubExp);
    if (!CryptDecodeObject(
		    X509_ASN_ENCODING,
		    X509_INTEGER,
		    pSeqKey->rgValue[ISK_PUBEXP].pbData,
		    pSeqKey->rgValue[ISK_PUBEXP].cbData,
		    0,
		    &dwPubExp,
		    &cb))
    {
	hr = myHLastError();
	_JumpError(hr, error, "CryptDecodeObject");
    }

    for (i = 0; i < ARRAYSIZE(apIntKey); i++)
    {
	if (!myDecodeObject(
			X509_ASN_ENCODING,
			X509_MULTI_BYTE_INTEGER,
			pSeqKey->rgValue[i].pbData,
			pSeqKey->rgValue[i].cbData,
			CERTLIB_USE_LOCALALLOC,
			(VOID **) &apIntKey[i],
			&cb))
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "myDecodeObject");
	}
    }
    cbitKey = apIntKey[ISK_MODULUS]->cbData * 8;

#if 0
    for (i = 0; i < ARRAYSIZE(apIntKey); i++)
    {
	wprintf(wszNewLine);
	DumpHex(
	    DH_NOTABPREFIX | DH_NOASCIIHEX | 4,
	    apIntKey[i]->pbData,
	    apIntKey[i]->cbData);
    }
#endif
    cbKey = sizeof(BLOBHEADER) + sizeof(RSAPUBKEY);
    for (i = 0; i < ARRAYSIZE(g_akbm); i++)
    {
	cbKey += cbitKey / g_akbm[i].dwdivisor;
    }
    pbKey = (BYTE *) LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, cbKey);
    if (NULL == pbKey)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }

    pb = pbKey;
    ((BLOBHEADER *) pb)->bType = PRIVATEKEYBLOB;
    ((BLOBHEADER *) pb)->bVersion = CUR_BLOB_VERSION;
    ((BLOBHEADER *) pb)->aiKeyAlg = CALG_RSA_KEYX;

    pb += sizeof(BLOBHEADER);
    ((RSAPUBKEY *) pb)->magic = 0x32415352;	// "RSA2"
    ((RSAPUBKEY *) pb)->bitlen = cbitKey;
    ((RSAPUBKEY *) pb)->pubexp = dwPubExp;

    pb += sizeof(RSAPUBKEY);
    for (i = 0; i < ARRAYSIZE(g_akbm); i++)
    {
	CSASSERT(ISK_MAX > g_akbm[i].dwisk);
	cb = cbitKey / g_akbm[i].dwdivisor;
	if (cb != apIntKey[g_akbm[i].dwisk]->cbData)
	{
	    hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	    _JumpError(hr, error, "Bad key element size");
	}
	CopyMemory(pb, apIntKey[g_akbm[i].dwisk]->pbData, cb);
	pb += cb;
    }
    CSASSERT(pb = &pbKey[cbKey]);
    if (g_fVerbose)
    {
	wprintf(L"%d bit key\n", cbitKey);
	if (1 < g_fVerbose)
	{
	    DumpHex(DH_NOTABPREFIX | 4, pbKey, cbKey);
	}
    }
    *pcbKey = cbKey;
    *ppbKey = pbKey;
    pbKey = NULL;
    hr = S_OK;

error:
    if (NULL != pSeqOuter)
    {
	LocalFree(pSeqOuter);
    }
    if (NULL != pSeqAlg)
    {
	LocalFree(pSeqAlg);
    }
    if (NULL != pSeqKey)
    {
	LocalFree(pSeqKey);
    }
    if (NULL != pszObjId)
    {
	LocalFree(pszObjId);
    }
    if (NULL != pBlobKey)
    {
	LocalFree(pBlobKey);
    }
    for (i = 0; i < ARRAYSIZE(apIntKey); i++)
    {
	if (NULL != apIntKey[i])
	{
	    LocalFree(apIntKey[i]);
	}
    }
    if (NULL != pbKey)
    {
	LocalFree(pbKey);
    }
    return(hr);
}


HRESULT
myVerifyKMSKey(
    IN BYTE const *pbCert,
    IN DWORD cbCert,
    IN BYTE const *pbKey,
    IN DWORD cbKey)
{
    HRESULT hr;
    CERT_CONTEXT const *pCert;
    HCRYPTPROV hProv = NULL;
    HCRYPTKEY hKey = NULL;
    CERT_PUBLIC_KEY_INFO *pPublicKeyInfo = NULL;
    DWORD cb;

    pCert = CertCreateCertificateContext(X509_ASN_ENCODING, pbCert, cbCert);
    if (NULL == pCert)
    {
	hr = myHLastError();
	_JumpError(hr, error, "CertCreateCertificateContext");
    }

    if (!CryptAcquireContext(
			&hProv,
			NULL,
			NULL,
			PROV_RSA_FULL,
			CRYPT_VERIFYCONTEXT))
    {
	hr = myHLastError();
	_JumpError(hr, error, "CryptAcquireContext");
    }
    if (!CryptImportKey(hProv, pbKey, cbKey, NULL, CRYPT_EXPORTABLE, &hKey))
    {
	hr = myHLastError();
	_JumpError(hr, error, "CryptImportKey");
    }
    if (!myCryptExportPublicKeyInfo(
				hProv,
				AT_KEYEXCHANGE,
				CERTLIB_USE_LOCALALLOC,
				&pPublicKeyInfo,
				&cb))
    {
	hr = myHLastError();
	_JumpError(hr, error, "myCryptExportPublicKeyInfo");
    }
    if (g_fVerbose)
    {
	cuDumpVersion(pCert->pCertInfo->dwVersion + 1);
	if (1 < g_fVerbose)
	{
	    cuDumpPublicKey(&pCert->pCertInfo->SubjectPublicKeyInfo);
	    cuDumpPublicKey(pPublicKeyInfo);
	}
    }

    if (!myCertComparePublicKeyInfo(
			    X509_ASN_ENCODING,
			    CERT_V1 == pCert->pCertInfo->dwVersion,
			    pPublicKeyInfo,
			    &pCert->pCertInfo->SubjectPublicKeyInfo))
    {
	// by design, (my)CertComparePublicKeyInfo doesn't set last error!

	hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	wprintf(myLoadResourceString(IDS_ERR_PUBLICKEY_MISMATCH)); // "ERROR: Certificate public key does NOT match stored keyset"
	wprintf(wszNewLine);
	_JumpError(hr, error, "myCertComparePublicKeyInfo");
    }
    hr = myValidateKeyForEncrypting(
			    hProv,
			    &pCert->pCertInfo->SubjectPublicKeyInfo,
			    CALG_RC4);
    if (S_OK != hr)
    {
	wprintf(myLoadResourceString(IDS_ERR_PRIVATEKEY_MISMATCH)); // "ERROR: Certificate public key does NOT match private key"
	wprintf(wszNewLine);
	_JumpError(hr, error, "myValidateKeyForEncrypting");
    }
    if (g_fVerbose)
    {
	wprintf(L"Private key verifies\n");
    }

error:
    if (NULL != pCert)
    {
	CertFreeCertificateContext(pCert);
    }
    if (NULL != pPublicKeyInfo)
    {
	LocalFree(pPublicKeyInfo);
    }
    if (NULL != hKey)
    {
	CryptDestroyKey(hKey);
    }
    if (NULL != hProv)
    {
	CryptReleaseContext(hProv, 0);
    }
    return(hr);
}


HRESULT
cuDumpAsnBinaryQuiet(
    IN BYTE const *pb,
    IN DWORD cb,
    IN DWORD iElement)
{
    HRESULT hr;
    BOOL fVerboseOld = g_fVerbose;
    BOOL fQuietOld = g_fQuiet;

    if (g_fVerbose)
    {
	g_fVerbose--;
    }
    else
    {
	g_fQuiet = TRUE;
    }
    hr = cuDumpAsnBinary(pb, cb, iElement);
    _JumpIfError(hr, error, "cuDumpAsnBinary");

error:
    g_fVerbose = fVerboseOld;
    g_fQuiet = fQuietOld;
    return(hr);
}


HRESULT
ReadTaggedBlob(
    IN HANDLE hFile,
    IN DWORD cbRemain,
    OUT TagHeader *pth,
    OUT BYTE **ppb)
{
    HRESULT hr;
    DWORD cbRead;
    
    *ppb = NULL;
    if (!ReadFile(hFile, pth, sizeof(*pth), &cbRead, NULL))
    {
	hr = myHLastError();
	_JumpError(hr, error, "ReadFile");
    }
    hr = HRESULT_FROM_WIN32(ERROR_HANDLE_EOF);
    if (cbRead != sizeof(*pth))
    {
	DBGPRINT((
	    DBG_SS_ERROR,
	    "ReadFile read %u bytes, requested %u\n",
	    cbRead,
	    sizeof(*pth)));
	_JumpError(hr, error, "ReadFile(cbRead)");
    }
    if (cbRead + pth->cbSize > cbRemain)
    {
	DBGPRINT((
	    DBG_SS_ERROR,
	    "Header size %u bytes, cbRemain %u\n",
	    sizeof(*pth) + pth->cbSize,
	    cbRemain));
	_JumpError(hr, error, "cbRemain");
    }

    *ppb = (BYTE *) LocalAlloc(LMEM_FIXED, pth->cbSize);
    if (NULL == *ppb)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }
    if (!ReadFile(hFile, *ppb, pth->cbSize, &cbRead, NULL))
    {
	hr = myHLastError();
	_JumpError(hr, error, "ReadFile");
    }
    if (cbRead != pth->cbSize)
    {
	hr = HRESULT_FROM_WIN32(ERROR_HANDLE_EOF);
	DBGPRINT((
	    DBG_SS_ERROR,
	    "ReadFile read %u bytes, requested %u\n",
	    cbRead,
	    pth->cbSize));
	_JumpError(hr, error, "ReadFile(cbRead)");
    }
    hr = S_OK;

error:
    if (S_OK != hr && NULL != *ppb)
    {
	LocalFree(*ppb);
	*ppb = NULL;
    }
    return(hr);
}


BOOL
DumpKMSTag(
    IN TagHeader const *pth)
{
    WCHAR const *pwsz;
    WCHAR awctag[20];

    pwsz = NULL;
    switch (pth->tag)
    {
	case KMS_LOCKBOX_TAG:      pwsz = L"KMS_LOCKBOX_TAG";      break;
	case KMS_SIGNING_CERT_TAG: pwsz = L"KMS_SIGNING_CERT_TAG"; break;
	case KMS_SIGNATURE_TAG:    pwsz = L"KMS_SIGNATURE_TAG";    break;
	case KMS_USER_RECORD_TAG:  pwsz = L"KMS_USER_RECORD_TAG";  break;
	default:
	    swprintf(awctag, L"%u", pth->tag);
	    pwsz = awctag;
	    break;
    }
    if (1 < g_fVerbose)
    {
	wprintf(
	    L"%ws: %x (%u) %ws\n",
	    pwsz,
	    pth->cbSize,
	    pth->cbSize,
	    myLoadResourceString(IDS_BYTES));		// "Bytes"
    }
    return(pwsz != awctag);	// TRUE if tag is valid
}


HRESULT
VerifyKMSExportFile(
    IN HANDLE hFile,
    IN DWORD cbFile,
    OUT CERT_CONTEXT const **ppccSigner)
{
    HRESULT hr;
    DWORD cbRemain;
    DWORD cbRead;
    TagHeader th;
    BYTE *pb = NULL;
    CERT_CONTEXT const *pccSigner = NULL;
    HCRYPTPROV hProv = NULL;
    HCRYPTHASH hHash = NULL;
    HCRYPTKEY hkeyPub = NULL;
    BOOL fVerified = FALSE;
    WCHAR *pwszSubject = NULL;

    *ppccSigner = NULL;

    if (!CryptAcquireContext(
			&hProv,
			NULL,		// pszContainer
			NULL,		// pszProvider
			PROV_RSA_FULL,
			CRYPT_VERIFYCONTEXT))
    {
	hr = myHLastError();
	_JumpError(hr, error, "CryptAcquireContext");
    }
    if (!CryptCreateHash(hProv, CALG_SHA1, 0, 0, &hHash))
    {
	hr = myHLastError();
	_JumpError(hr, error, "CryptCreateHash");
    }

    cbRemain = cbFile;
    while (0 < cbRemain)
    {
	fVerified = FALSE;
	CSASSERT(NULL == pb);
	hr = ReadTaggedBlob(hFile, cbRemain, &th, &pb);
	_JumpIfError(hr, error, "ReadTaggedBlob");
	
	if (!DumpKMSTag(&th))
	{
	    hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	    _JumpError(hr, error, "invalid tag");
	}

	switch (th.tag)
	{
	    case KMS_SIGNING_CERT_TAG:

		if (g_fVerbose || g_fSplitASN)
		{
		    hr = cuDumpAsnBinaryQuiet(pb, th.cbSize, MAXDWORD);
		    _JumpIfError(hr, error, "cuDumpAsnBinaryQuiet");
		}

		if (NULL != pccSigner)
		{
		    hr = HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS);
		    _JumpError(hr, error, "too many signers");
		}
		pccSigner = CertCreateCertificateContext(
						    X509_ASN_ENCODING,
						    pb,
						    th.cbSize);
		if (NULL == pccSigner)
		{
		    hr = myHLastError();
		    _JumpError(hr, error, "CertCreateCertificateContext");
		}
		hr = myCertNameToStr(
			    X509_ASN_ENCODING,
			    &pccSigner->pCertInfo->Subject,
			    CERT_X500_NAME_STR | CERT_NAME_STR_REVERSE_FLAG,
			    &pwszSubject);
		_PrintIfError(hr, "myCertNameToStr");
		wprintf(L"Processing KMS exports from:");
		wprintf(L"\n    %ws\n\n", pwszSubject);
		break;

	    case KMS_SIGNATURE_TAG:
		if (NULL != hkeyPub)
		{
		    _JumpError(hr, error, "too many signatures");
		}
		if (NULL == pccSigner)
		{
		    hr = TRUST_E_NO_SIGNER_CERT;
		    _JumpError(hr, error, "no signer");
		}
		if (!CryptImportPublicKeyInfo(
				hProv,
				X509_ASN_ENCODING,
				&pccSigner->pCertInfo->SubjectPublicKeyInfo,
				&hkeyPub))
		{
		    hr = myHLastError();
		    _JumpError(hr, error, "CryptImportPublicKeyInfo");
		}
		if (!CryptVerifySignature(
				hHash,
				pb,
				th.cbSize,
				hkeyPub,
				NULL,
				0))
		{
		    hr = myHLastError();
		    _JumpError(hr, error, "CryptVerifySignature");
		}
		fVerified = TRUE;
		wprintf(L"KMS export file signature verifies\n");
		break;

	    default:
		if (!CryptHashData(hHash, (BYTE *) &th, sizeof(th), 0))
		{
		    hr = myHLastError();
		    _JumpError(hr, error, "CryptHashData");
		}
		if (!CryptHashData(hHash, pb, th.cbSize, 0))
		{
		    hr = myHLastError();
		    _JumpError(hr, error, "CryptHashData");
		}
		break;
	}
	LocalFree(pb);
	pb = NULL;
	CSASSERT(cbRemain >= sizeof(th) + sizeof(th.cbSize));
	cbRemain -= sizeof(th) + th.cbSize;
    }
    if (!fVerified)
    {
	hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
        _JumpError(hr, error, "unsigned data");
    }
    hr = S_OK;

error:
    if (NULL != pwszSubject)
    {
	LocalFree(pwszSubject);
    }
    if (NULL != pb)
    {
	LocalFree(pb);
    }
    if (NULL != hkeyPub)
    {
	CryptDestroyKey(hkeyPub);
    }
    if (NULL != hHash)
    {
	CryptDestroyHash(hHash);
    }
    if (NULL != hProv)
    {
	CryptReleaseContext(hProv, 0);
    }
    return(hr);
}


HRESULT
myEncryptPrivateKey(
    IN CERT_CONTEXT const *pccXchg,
    IN BYTE const *pbKey,
    IN DWORD cbKey,
    OUT BYTE **ppbKeyEncrypted,
    OUT DWORD *pcbKeyEncrypted)
{
    HRESULT hr;
    ALG_ID rgalgId[] = { CALG_3DES, CALG_RC4, CALG_RC2 };
    DWORD i;

    *ppbKeyEncrypted = NULL;

    hr = CRYPT_E_NOT_FOUND;
    for (i = 0; i < ARRAYSIZE(rgalgId); i++)
    {
	// encryt into pkcs7

	hr = myCryptEncryptMessage(
			    rgalgId[i],
			    1,			// cCertRecipient
			    &pccXchg,		// rgCertRecipient
			    pbKey,
			    cbKey,
			    NULL,		// hCryptProv
			    ppbKeyEncrypted,
			    pcbKeyEncrypted);
	if (S_OK == hr)
	{
	    break;		// done
	}
	_PrintError2(hr, "myCryptEncryptMessage", hr);
    }
    _JumpIfError(hr, error, "myCryptEncryptMessage");

error:
    return(hr);
}


#define CB_IV	8

typedef struct _KMSSTATS {
    DWORD cRecUser;

    DWORD cCertWithoutKeys;
    DWORD cCertTotal;
    DWORD cCertNotSaved;
    DWORD cCertAlreadySaved;
    DWORD cCertSaved;
    DWORD cCertSavedForeign;

    DWORD cKeyTotal;
    DWORD cKeyNotSaved;
    DWORD cKeyAlreadySaved;
    DWORD cKeySaved;
    DWORD cKeySavedOverwrite;
} KMSSTATS;


HRESULT
ArchiveCertAndKey(
    IN DISPATCHINTERFACE *pdiAdmin,
    IN CERT_CONTEXT const *pccXchg,
    IN BYTE const *pbCert,
    IN DWORD cbCert,
    IN BYTE const *pbKey,
    IN DWORD cbKey,
    IN OUT KMSSTATS *pkmsStats)
{
    HRESULT hr;
    LONG RequestId;
    BYTE *pbKeyEncrypted = NULL;
    DWORD cbKeyEncrypted;
    CERT_CONTEXT const *pcc = NULL;
    BYTE abHash[CBMAX_CRYPT_HASH_LEN];
    DWORD cbHash;
    BSTR strHash = NULL;
    BOOL fCertSaved = FALSE;
    DWORD ids;
    
    pcc = CertCreateCertificateContext(X509_ASN_ENCODING, pbCert, cbCert);
    if (NULL == pcc)
    {
	hr = myHLastError();
	_JumpError(hr, error, "CertCreateCertificateContext");
    }
    ids = 0;
    hr = Admin_ImportCertificate(
			pdiAdmin,
			g_pwszConfig,
			(WCHAR const *) pbCert,
			cbCert,
			CR_IN_BINARY,
			&RequestId);
    if (g_fForce &&
	S_OK != hr &&
	HRESULT_FROM_WIN32(ERROR_OBJECT_ALREADY_EXISTS) != hr)
    {
	hr = Admin_ImportCertificate(
			    pdiAdmin,
			    g_pwszConfig,
			    (WCHAR const *) pbCert,
			    cbCert,
			    ICF_ALLOWFOREIGN | CR_IN_BINARY,
			    &RequestId);
	if (S_OK == hr)
	{
	    pkmsStats->cCertSavedForeign++;
	    ids = IDS_IMPORT_CERT_FOREIGN; // "Imported foreign certificate"
	}
    }
    if (HRESULT_FROM_WIN32(ERROR_OBJECT_ALREADY_EXISTS) != hr)
    {
	_JumpIfError2(hr, error, "Admin_ImportCertificate", NTE_BAD_SIGNATURE);

	//wprintf(L"RequestId = %u\n", RequestId);
	pkmsStats->cCertSaved++;
	if (0 == ids)
	{
	    ids = IDS_IMPORT_CERT_DOMESTIC;	// "Imported certificate"
	}
    }
    else
    {
	RequestId = MAXDWORD;
	pkmsStats->cCertAlreadySaved++;
	ids = IDS_IMPORT_CERT_EXISTS;		// "Certificate exists"

	cbHash = sizeof(abHash);
	if (!CertGetCertificateContextProperty(
					pcc,
					CERT_SHA1_HASH_PROP_ID,
					abHash,
					&cbHash))
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "CertGetCertificateContextProperty");
	}
	hr = MultiByteIntegerToBstr(TRUE, cbHash, abHash, &strHash);
	_JumpIfError(hr, error, "MultiByteIntegerToBstr");
    }
    fCertSaved = TRUE;
    if (g_fVerbose)
    {
	wprintf(myLoadResourceString(ids));
	wprintf(wszNewLine);
    }
    else
    {
	wprintf(L".");
    }

    hr = myEncryptPrivateKey(
		    pccXchg,
		    pbKey,
		    cbKey,
		    &pbKeyEncrypted,
		    &cbKeyEncrypted);
    _JumpIfError(hr, error, "myEncryptPrivateKey");

    ids = 0;
    hr = Admin2_ImportKey(
		    pdiAdmin,
		    g_pwszConfig,
		    RequestId,
		    strHash,
		    CR_IN_BINARY,
		    (WCHAR const *) pbKeyEncrypted,
		    cbKeyEncrypted);
    if (g_fForce && HRESULT_FROM_WIN32(ERROR_OBJECT_ALREADY_EXISTS) == hr)
    {
	hr = Admin2_ImportKey(
			pdiAdmin,
			g_pwszConfig,
			RequestId,
			strHash,
			IKF_OVERWRITE | CR_IN_BINARY,
			(WCHAR const *) pbKeyEncrypted,
			cbKeyEncrypted);
	if (S_OK == hr)
	{
	    pkmsStats->cKeySavedOverwrite++;
	    ids = IDS_IMPORT_KEY_REPLACED;	// "Archived key replaced"
	}
    }
    if (HRESULT_FROM_WIN32(ERROR_OBJECT_ALREADY_EXISTS) != hr)
    {
	_JumpIfError(hr, error, "Admin2_ImportKey");

	pkmsStats->cKeySaved++;
	if (0 == ids)
	{
	    ids = IDS_IMPORT_KEY_SAVED;	// "Archived key"
	}
    }
    else
    {
	pkmsStats->cKeyAlreadySaved++;
	ids = IDS_IMPORT_KEY_EXISTS;	// "Key already archived"
    }
    if (g_fVerbose)
    {
	wprintf(myLoadResourceString(ids));
	wprintf(wszNewLine);
    }
    else
    {
	wprintf(L".");
    }
    hr = S_OK;

error:
    if (S_OK != hr)
    {
	cuPrintErrorMessageText(hr);
	if (!fCertSaved)
	{
	    pkmsStats->cCertNotSaved++;
	}
	pkmsStats->cKeyNotSaved++;
    }
    if (NULL != pbKeyEncrypted)
    {
	LocalFree(pbKeyEncrypted);
    }
    if (NULL != strHash)
    {
	SysFreeString(strHash);
    }
    if (NULL != pcc)
    {
	CertFreeCertificateContext(pcc);
    }
    return(hr);
}


HRESULT
ImportOneKMSUser(
    IN DISPATCHINTERFACE *pdiAdmin,
    IN CERT_CONTEXT const *pccXchg,
    IN BYTE const *pbRecUser,
    IN DWORD cbRecUser,
    IN HCRYPTKEY hkeySym,
    IN OUT KMSSTATS *pkmsStats)
{
    HRESULT hr;
    BYTE const *pbT = pbRecUser;
    WCHAR *pwszUser = NULL;
    DWORD cbT = cbRecUser;
    DWORD cb;
    DWORD dw;
    CLSID clsid;
    WCHAR *pwszGUID = NULL;
    BYTE *pbKeyASN = NULL;
    DWORD cbKeyASN;
    DWORD cbStream;

    pkmsStats->cRecUser++;

    // Get the user's directory GUID

    CopyMemory(&clsid, pbT, sizeof(clsid));

    hr = myCLSIDToWsz(&clsid, &pwszGUID);
    _JumpIfError(hr, error, "myCLSIDToWsz");

    pbT += sizeof(GUID);
    cbT -= sizeof(GUID);

    // Get the user's name length

    hr = GetMarshaledDword(TRUE, &pbT, &cbT, &cb);
    _JumpIfError(hr, error, "GetMarshaledDword");

    pwszUser = (WCHAR *) LocalAlloc(
				LMEM_FIXED,
				((cb / sizeof(WCHAR)) + 1) * sizeof(WCHAR));
    if (NULL == pwszUser)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }
    CopyMemory(pwszUser, pbT, cb);
    pwszUser[cb / sizeof(WCHAR)] = L'\0';

    if (g_fVerbose)
    {
	wprintf(L"\n----------------------\n");
    }
    if (g_fVerbose)
    {
	wprintf(L"User: %ws -- %ws\n", pwszUser, pwszGUID);
    }

    pbT += cb;
    cbT -= cb;

    // for each User cert:

    while (0 < cbT)
    {
	DWORD CertStatus;
	FILETIME ftRevoke;
	BYTE const *pbCert;
	DWORD cbCert;
	    
	if (g_fVerbose)
	{
	    wprintf(wszNewLine);
	}
	hr = GetMarshaledDword(FALSE, &pbT, &cbT, &CertStatus);
	_JumpIfError(hr, error, "GetMarshaledDword");

	if (1 < g_fVerbose)
	{
	    wprintf(wszNewLine);
	    cuRegPrintDwordValue(
			    TRUE,
			    wszKMSCERTSTATUS,
			    wszKMSCERTSTATUS,
			    CertStatus);
	}

	hr = GetMarshaledDword(TRUE, &pbT, &cbT, &cb);
	_JumpIfError(hr, error, "GetMarshaledDword");

	// Dump one user cert:

	pbCert = pbT;
	cbCert = cb;
	if (g_fSplitASN)
	{
	    wprintf(wszNewLine);
	    hr = cuDumpAsnBinaryQuiet(pbCert, cbCert, MAXDWORD);
	    _JumpIfError(hr, error, "cuDumpAsnBinaryQuiet");
	}

	pbT += cb;
	cbT -= cb;

	// Get the revocation date (KMS export date):

	hr = GetMarshaledDword(
			FALSE,
			&pbT,
			&cbT,
			&ftRevoke.dwLowDateTime);
	_JumpIfError(hr, error, "GetMarshaledDword");

	hr = GetMarshaledDword(
			FALSE,
			&pbT,
			&cbT,
			&ftRevoke.dwHighDateTime);
	_JumpIfError(hr, error, "GetMarshaledDword");

	if (g_fVerbose)
	{
	    hr = cuDumpFileTime(IDS_REVOCATIONDATE, NULL, &ftRevoke);
	    _PrintIfError(hr, "cuDumpFileTime");
	}

	// Only encryption certs have archived keys:

	if (0 == (CERTFLAGS_SEALING & CertStatus))
	{
	    pkmsStats->cCertWithoutKeys++;
	    if (g_fVerbose)
	    {
		wprintf(myLoadResourceString(IDS_IMPORT_CERT_SKIPPED_SIGNING)); // "Ignored signing certificate"
		wprintf(wszNewLine);
	    }
	    continue;
	}
	pkmsStats->cCertTotal++;
	pkmsStats->cKeyTotal++;

	// get encrypted private key size

	hr = GetMarshaledDword(TRUE, &pbT, &cbT, &cb);
	_JumpIfError(hr, error, "GetMarshaledDword");
	
	// get 8 byte RC2 IV 

	if (1 < g_fVerbose)
	{
	    wprintf(L"IV:\n");
	    DumpHex(
		DH_NOADDRESS | DH_NOTABPREFIX | DH_NOASCIIHEX | 4,
		pbT,
		CB_IV);
	}

	if (NULL != hkeySym)
	{
	    // Set IV

	    if (!CryptSetKeyParam(
				hkeySym,
				KP_IV,
				const_cast<BYTE *>(pbT),
				0))
	    {        
		hr = GetLastError();
		_JumpIfError(hr, error, "CryptSetKeyParam");
	    }
	}
	pbT += CB_IV;
	cbT -= CB_IV;
	cb -= CB_IV;

	if (1 < g_fVerbose)
	{
	    wprintf(wszNewLine);
	    wprintf(L"Encrypted key:\n");
	    DumpHex(0, pbT, cb);
	}
	
	// decrypt key using hkeySym
	// in-place decode is Ok because the size of the
	// original data is always less than or equal to that
	// of the encrypted data 
	
	cbStream = cb;	// save off the real stream size first
	if (NULL != hkeySym)
	{
	    cbKeyASN = cb;
	    pbKeyASN = (BYTE *) LocalAlloc(LMEM_FIXED, cb);
	    if (NULL == pbKeyASN)
	    {
		hr = E_OUTOFMEMORY;
		_JumpError(hr, error, "LocalAlloc");
	    }
	    CopyMemory(pbKeyASN, pbT, cbKeyASN);
	    if (!CryptDecrypt(hkeySym, NULL, TRUE, 0, pbKeyASN, &cb))
	    {
		hr = GetLastError();
		_PrintError(hr, "CryptDecrypt");
	    }
	    else
	    {
		BYTE *pbKey;
		DWORD cbKey;

		if (1 < g_fVerbose)
		{
		    wprintf(wszNewLine);
		    wprintf(L"Decrypted key:\n");
		    DumpHex(0, pbKeyASN, cb);
		}

		hr = myDecodeKMSRSAKey(pbKeyASN, cbKeyASN, &pbKey, &cbKey);
		_JumpIfError(hr, error, "myDecodeKMSRSAKey");

		hr = myVerifyKMSKey(pbCert, cbCert, pbKey, cbKey);
		_PrintIfError(hr, "myVerifyKMSKey");

		hr = ArchiveCertAndKey(
				pdiAdmin,
				pccXchg,
				pbCert,
				cbCert,
				pbKey,
				cbKey,
				pkmsStats);
		_PrintIfError2(hr, "ArchiveCertAndKey", NTE_BAD_SIGNATURE);

		ZeroMemory(pbKey, cbKey);	// Key material
		LocalFree(pbKey);
	    }
	    ZeroMemory(pbKeyASN, cbKeyASN);	// Key material
	    LocalFree(pbKeyASN);
	    pbKeyASN = NULL;
	}

	// skip cbStream bytes, not cb

	pbT += cbStream;
	cbT -= cbStream;
    }
    hr = S_OK;

error:
    if (NULL != pwszGUID)
    {
	LocalFree(pwszGUID);
    }
    if (NULL != pbKeyASN)
    {
	ZeroMemory(pbKeyASN, cbKeyASN);	// Key material
	LocalFree(pbKeyASN);
    }
    return(hr);
}


HRESULT
GetCAXchgCert(
    IN DISPATCHINTERFACE *pdiAdmin,
    OUT CERT_CONTEXT const **ppccXchg)
{
    HRESULT hr;
    BSTR strCert = NULL;
    
    *ppccXchg = NULL;

    hr = Admin2_GetCAProperty(
			pdiAdmin,
			g_pwszConfig,
			CR_PROP_CAXCHGCERT,
			0,			// PropIndex
			PROPTYPE_BINARY,
			CR_OUT_BINARY,
			&strCert);
    _JumpIfError(hr, error, "Admin2_GetCAProperty");

    *ppccXchg = CertCreateCertificateContext(
					X509_ASN_ENCODING,
					(BYTE const *) strCert,
					SysStringByteLen(strCert));
    if (NULL == *ppccXchg)
    {
	hr = myHLastError();
	_JumpError(hr, error, "CertCreateCertificateContext");
    }
    hr = S_OK;

error:
    if (NULL != strCert)
    {
	SysFreeString(strCert);
    }
    return(hr);
}


typedef struct _KMSMAP {
    DWORD dwFieldOffset;
    DWORD idMsg;
} KMSMAP;


KMSMAP g_akmUsers[] = {
  { FIELD_OFFSET(KMSSTATS, cRecUser), IDS_KMS_USERS, },
};

KMSMAP g_akmCerts[] = {
  { FIELD_OFFSET(KMSSTATS, cCertWithoutKeys),  IDS_KMS_CERTS_SKIPPED, },
  { FIELD_OFFSET(KMSSTATS, cCertTotal),        IDS_KMS_CERTS_TOTAL, },
  { FIELD_OFFSET(KMSSTATS, cCertSavedForeign), IDS_KMS_CERTS_FOREIGN, },
  { FIELD_OFFSET(KMSSTATS, cCertAlreadySaved), IDS_KMS_CERTS_ALREADYSAVED, },
  { FIELD_OFFSET(KMSSTATS, cCertSaved),        IDS_KMS_CERTS_SAVED, },
  { FIELD_OFFSET(KMSSTATS, cCertNotSaved),     IDS_KMS_CERTS_NOTSAVED, },
};

KMSMAP g_akmKeys[] = {
  { FIELD_OFFSET(KMSSTATS, cKeyTotal),          IDS_KMS_KEYS_TOTAL, },
  { FIELD_OFFSET(KMSSTATS, cKeyAlreadySaved),   IDS_KMS_KEYS_ALREADYSAVED, },
  { FIELD_OFFSET(KMSSTATS, cKeySavedOverwrite), IDS_KMS_KEYS_UPDATED, },
  { FIELD_OFFSET(KMSSTATS, cKeySaved),          IDS_KMS_KEYS_SAVED, },
  { FIELD_OFFSET(KMSSTATS, cKeyNotSaved),       IDS_KMS_KEYS_NOTSAVED, },
};


VOID
DumpKMSMap(
    IN KMSSTATS const *pkmsStats,
    IN KMSMAP const *pkm,
    IN DWORD ckm)
{
    DWORD i;
    BOOL fFirst = TRUE;
    DWORD count;

    for (i = 0; i < ckm; i++)
    {
	count = *(DWORD *) Add2ConstPtr(pkmsStats, pkm[i].dwFieldOffset);
	if (g_fVerbose || 0 != count)
	{
	    if (fFirst)
	    {
		wprintf(wszNewLine);
		fFirst = FALSE;
	    }
	    wprintf(myLoadResourceString(pkm[i].idMsg));
	    wprintf(L": %u\n", count);
	}
    }
}


VOID
DumpKMSStats(
    IN KMSSTATS const *pkmsStats)
{
    DumpKMSMap(pkmsStats, g_akmUsers, ARRAYSIZE(g_akmUsers));
    DumpKMSMap(pkmsStats, g_akmCerts, ARRAYSIZE(g_akmCerts));
    DumpKMSMap(pkmsStats, g_akmKeys, ARRAYSIZE(g_akmKeys));
}


HRESULT
ImportKMSExportedUsers(
    IN HANDLE hFile,
    IN DWORD cbFile,
    IN HCRYPTPROV hProvKMS,
    IN HCRYPTKEY hkeyKMS)
{
    HRESULT hr;
    DWORD cbRemain;
    DWORD cbRead;
    TagHeader th;
    BYTE *pb = NULL;
    HCRYPTKEY hkeySym = NULL;
    KMSSTATS kmsStats;
    DISPATCHINTERFACE diAdmin;
    BOOL fMustRelease = FALSE;
    CERT_CONTEXT const *pccXchg = NULL;

    ZeroMemory(&kmsStats, sizeof(kmsStats));

    hr = Admin_Init(g_DispatchFlags, &diAdmin);
    _JumpIfError(hr, error, "Admin_Init");

    fMustRelease = TRUE;

    hr = GetCAXchgCert(&diAdmin, &pccXchg);
    _JumpIfError(hr, error, "GetCAXchgCert");

    cbRemain = cbFile;
    while (0 < cbRemain)
    {
	CSASSERT(NULL == pb);
	hr = ReadTaggedBlob(hFile, cbRemain, &th, &pb);
	_JumpIfError(hr, error, "ReadTaggedBlob");

	if (!DumpKMSTag(&th))
	{
	    hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	    _JumpError(hr, error, "invalid tag");
	}

	switch (th.tag)
	{
	    case KMS_LOCKBOX_TAG:
            {
		if (1 < g_fVerbose)
		{
		    hr = cuDumpPrivateKeyBlob(pb, th.cbSize, FALSE);
		    _PrintIfError(hr, "cuDumpPrivateKeyBlob");
		}

                // only need one symmetric key per file

                if (NULL == hkeySym)
                {
		    // 0x0000660c ALG_ID CALG_RC2_128
		    //
		    // CALG_RC2_128:
		    //  ALG_CLASS_DATA_ENCRYPT|ALG_TYPE_BLOCK|ALG_SID_RC2_128
		    //
		    // CALG_CYLINK_MEK:
		    //  ALG_CLASS_DATA_ENCRYPT|ALG_TYPE_BLOCK|ALG_SID_CYLINK_MEK
		    //
		    // UGH!  Exchange's CALG_RC2_128 #define collides with
		    // wincrypt.h's CALG_CYLINK_MEK -- fix it up to be the
		    // correct CALG_RC2 algid from wincrypt.h.

		    ((PUBLICKEYSTRUC *) pb)->aiKeyAlg = CALG_RC2;

		    // dump the fixed-up blob

		    if (1 < g_fVerbose)
		    {
			hr = cuDumpPrivateKeyBlob(pb, th.cbSize, FALSE);
			_PrintIfError(hr, "cuDumpPrivateKeyBlob");
		    }

		    // import 128 bit key 

		    if (!CryptImportKey(
				    hProvKMS,
				    pb,
				    th.cbSize,
				    hkeyKMS,
				    0,
				    &hkeySym))
		    {
			hr = myHLastError();
			_PrintError(hr, "CryptImportKey");
			wprintf(L"Failed to import symmetric key\n");
		    }
		    else
		    {
			// We found the right lockbox.  Effective keylen is
			// still 40 bits in our CSP, reset to 128

			DWORD dwEffectiveKeylen = 128;

			if (!CryptSetKeyParam(
					hkeySym,
					KP_EFFECTIVE_KEYLEN,
					(BYTE *) &dwEffectiveKeylen,
					0))
			{
			    hr = myHLastError();
			    _JumpError(hr, error, "CryptSetKeyParam(KP_EFFECTIVE_KEYLEN)");
			}
			wprintf(L"Lock box opened, symmetric key successfully decrypted\n");
		    }
		}
		break;
	    }

	    case KMS_USER_RECORD_TAG:
		hr = ImportOneKMSUser(
				&diAdmin,
				pccXchg,
				pb,
				th.cbSize,
				hkeySym,
				&kmsStats);
		_JumpIfError(hr, error, "ImportOneKMSUser");

		break;

	    default:
		break;
	}

	LocalFree(pb);
	pb = NULL;
	CSASSERT(cbRemain >= sizeof(th) + sizeof(th.cbSize));
	cbRemain -= sizeof(th) + th.cbSize;
    }

    if (!g_fVerbose)
    {
	wprintf(wszNewLine);
    }
    DumpKMSStats(&kmsStats);
    hr = S_OK;

error:
    if (NULL != pccXchg)
    {
	CertFreeCertificateContext(pccXchg);
    }
    if (fMustRelease)
    {
	Admin_Release(&diAdmin);
    }
    if (NULL != hkeySym)
    {
	CryptDestroyKey(hkeySym);
    }
    return(hr);
}


HRESULT
LoadKMSCert(
    IN WCHAR const *pwszCertId,
    OUT CERT_CONTEXT const **ppccKMS,
    OUT HCRYPTPROV *phProvKMS,
    OUT HCRYPTKEY *phkeyKMS)
{
    HRESULT hr;
    CRYPT_KEY_PROV_INFO *pkpiKMS = NULL;
    DWORD cbkpiKMS;
    BYTE *pbKey = NULL;
    DWORD cbKey;
    HCRYPTKEY hkeyKMSSig = NULL;

    *ppccKMS = NULL;
    *phProvKMS = NULL;
    *phkeyKMS = NULL;

    hr = myGetCertificateFromPicker(
			    g_hInstance,
			    NULL,		// hwndParent
			    IDS_GETCERT_TITLE,	// "Certificate List"
			    IDS_GETDECRYPTCERT_SUBTITLE,

			    // dwFlags: HKLM+HKCU My store
			    CUCS_MYSTORE |
				CUCS_MACHINESTORE |
				CUCS_USERSTORE |
				CUCS_PRIVATEKEYREQUIRED |
				(g_fCryptSilent? CUCS_SILENT : 0),
			    pwszCertId,
			    0,			// cStore
			    NULL,		// rghStore
			    0,			// cpszObjId
			    NULL,		// apszObjId
			    ppccKMS);		// ppCert
    _JumpIfError(hr, error, "myGetCertificateFromPicker");

    if (NULL == *ppccKMS)
    {
	hr = ERROR_CANCELLED;
	_JumpError(hr, error, "myGetCertificateFromPicker");
    }

    if (!myCertGetCertificateContextProperty(
			*ppccKMS,
			CERT_KEY_PROV_INFO_PROP_ID,
			CERTLIB_USE_LOCALALLOC,
			(VOID **) &pkpiKMS,
			&cbkpiKMS))
    {
	hr = myHLastError();
	_JumpError(hr, error, "myCertGetCertificateContextProperty");
    }
    if (g_fVerbose)
    {
	wprintf(L"CryptAcquireContext(%ws)\n", pkpiKMS->pwszContainerName);
    }
    if (!CryptAcquireContext(
			phProvKMS,
			pkpiKMS->pwszContainerName,
			pkpiKMS->pwszProvName,
			pkpiKMS->dwProvType,
			pkpiKMS->dwFlags))
    {
	hr = myHLastError();
	wprintf(L"CryptAcquireContext() --> %x\n", hr);
	_JumpError(hr, error, "CryptAcquireContext");
    }

    if (!CryptGetUserKey(*phProvKMS, AT_KEYEXCHANGE, phkeyKMS))
    {
	hr = myHLastError();
	if (hr != NTE_NO_KEY)
	{
	    _JumpError(hr, error, "CryptGetUserKey");
	}

	if (!CryptGetUserKey(*phProvKMS, AT_SIGNATURE, &hkeyKMSSig))
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "CryptGetUserKey - sig");
	}

	// UGH! migrate from AT_SIGNATURE container!

	cbKey = 0;
	hr = myCryptExportKey(
			hkeyKMSSig,	// hKey
			NULL,		// hKeyExp
			PRIVATEKEYBLOB,	// dwBlobType
			0,		// dwFlags
			&pbKey,
			&cbKey);
	_JumpIfError(hr, error, "myCryptExportKey");

	// UGH! fix up the algid to signature...

	((PUBLICKEYSTRUC *) pbKey)->aiKeyAlg = CALG_RSA_KEYX;
	
	// and re-import it

	if (!CryptImportKey(
			*phProvKMS,
			pbKey,
			cbKey,
			NULL,
			0,
			phkeyKMS))
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "CryptImportKey");
	}
	wprintf(L"Moved AT_SIGNATURE key to AT_KEYEXCHANGE\n");
    }
    hr = S_OK;

error:
    if (S_OK != hr)
    {
	if (NULL != *ppccKMS)
	{
	    CertFreeCertificateContext(*ppccKMS);
	    *ppccKMS = NULL;
	}
	if (NULL != *phProvKMS)
	{
	    CryptReleaseContext(*phProvKMS, 0);
	    *phProvKMS = NULL;
	}
    }
    if (NULL != pbKey)
    {
        LocalFree(pbKey); 
    }
    if (NULL != pkpiKMS)
    {
        LocalFree(pkpiKMS); 
    }
    if (NULL != hkeyKMSSig)
    {
        CryptDestroyKey(hkeyKMSSig);
    }
    return(hr);
}


HRESULT
ImportOnePFXCert(
    IN DISPATCHINTERFACE *pdiAdmin,
    IN CERT_CONTEXT const *pccXchg,
    IN CERT_CONTEXT const *pCert,
    IN OUT KMSSTATS *pkmsStats)
{
    HRESULT hr;
    CRYPT_KEY_PROV_INFO *pkpi = NULL;
    HCRYPTPROV hProv = NULL;
    HCRYPTKEY hKey = NULL;
    BYTE *pbKey = NULL;
    DWORD cbKey;

    hr = myCertGetKeyProviderInfo(pCert, &pkpi);
    if (S_OK != hr)
    {
	_PrintError(hr, "myCertGetKeyProviderInfo");
	pkmsStats->cCertWithoutKeys++;
	hr = S_OK;
	goto error;
    }
    pkmsStats->cCertTotal++;
    if (!CryptAcquireContext(
			&hProv,
			pkpi->pwszContainerName,
			pkpi->pwszProvName,
			pkpi->dwProvType,
			0))
    {
	hr = myHLastError();
	_JumpError(hr, error, "CryptAcquireContext");
    }
    if (!CryptGetUserKey(hProv, pkpi->dwKeySpec, &hKey))
    {
	hr = myHLastError();
	_JumpIfError(hr, error, "CryptGetUserKey");
    }
    hr = myCryptExportPrivateKey(hKey, &pbKey, &cbKey);
    _JumpIfError(hr, error, "myCryptExportPrivateKey");

    pkmsStats->cKeyTotal++;

    hr = myVerifyKMSKey(
		pCert->pbCertEncoded,
		pCert->cbCertEncoded,
		pbKey,
		cbKey);
    _JumpIfError(hr, error, "myVerifyKMSKey");

    hr = ArchiveCertAndKey(
		    pdiAdmin,
		    pccXchg,
		    pCert->pbCertEncoded,
		    pCert->cbCertEncoded,
		    pbKey,
		    cbKey,
		    pkmsStats);
    _JumpIfError(hr, error, "ArchiveCertAndKey");

error:
    if (NULL != pbKey)
    {
	ZeroMemory(pbKey, cbKey);	// Key material
	LocalFree(pbKey);
    }
    if (NULL != hProv)
    {
	CryptReleaseContext(hProv, 0);
    }
    if (NULL != pkpi)
    {
	LocalFree(pkpi);
    }
    return(hr);
}


HRESULT
ImportKMSPFXFile(
    IN WCHAR const *pwszfn)
{
    HRESULT hr;
    CRYPT_DATA_BLOB pfx;
    WCHAR wszPassword[MAX_PATH];
    WCHAR const *pwszPassword;
    CERT_CONTEXT const *pccXchg = NULL;
    HCERTSTORE hStorePFX = NULL;
    CERT_CONTEXT const *pCert = NULL;
    DISPATCHINTERFACE diAdmin;
    BOOL fMustRelease = FALSE;
    KMSSTATS kmsStats;

    ZeroMemory(&kmsStats, sizeof(kmsStats));
    pfx.pbData = NULL;

    hr = DecodeFileW(pwszfn, &pfx.pbData, &pfx.cbData, CRYPT_STRING_ANY);
    if (S_OK != hr)
    {
	cuPrintError(IDS_ERR_FORMAT_DECODEFILE, hr);
	goto error;
    }
    if (!PFXIsPFXBlob(&pfx))
    {
	hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	_JumpError(hr, error, "not a PFX");
    }

    pwszPassword = g_pwszPassword;
    if (NULL == pwszPassword)
    {
	hr = cuGetPassword(FALSE, wszPassword, ARRAYSIZE(wszPassword));
	_JumpIfError(hr, error, "cuGetPassword");
    }

    hStorePFX = myPFXImportCertStore(&pfx, pwszPassword, CRYPT_EXPORTABLE);
    if (NULL == hStorePFX)
    {
	hr = myHLastError();
	_JumpError(hr, error, "myPFXImportCertStore");
    }

    hr = Admin_Init(g_DispatchFlags, &diAdmin);
    _JumpIfError(hr, error, "Admin_Init");

    fMustRelease = TRUE;

    hr = GetCAXchgCert(&diAdmin, &pccXchg);
    _JumpIfError(hr, error, "GetCAXchgCert");

    while (TRUE)
    {
	pCert = CertEnumCertificatesInStore(hStorePFX, pCert);
	if (NULL == pCert)
	{
	    break;
	}
	hr = ImportOnePFXCert(&diAdmin, pccXchg, pCert, &kmsStats);
	_PrintIfError(hr, "ImportOnePFXCert");
    }
    DumpKMSStats(&kmsStats);
    hr = S_OK;

error:
    if (NULL != hStorePFX)
    {
        myDeleteGuidKeys(hStorePFX, FALSE);
	CertCloseStore(hStorePFX, CERT_CLOSE_STORE_CHECK_FLAG);
    }
    if (NULL != pccXchg)
    {
	CertFreeCertificateContext(pccXchg);
    }
    if (fMustRelease)
    {
	Admin_Release(&diAdmin);
    }
    if (NULL != pfx.pbData)
    {
        LocalFree(pfx.pbData); 
    }
    return(hr);
}


HRESULT
ImportKMSExportFile(
    IN WCHAR const *pwszfnKMS,
    IN WCHAR const *pwszCertId,
    OUT BOOL *pfBadTag)
{
    HRESULT hr;
    CERT_CONTEXT const *pccKMS = NULL;
    HCRYPTPROV hProvKMS = NULL;
    HCRYPTKEY hkeyKMS = NULL;
    HANDLE hFile = INVALID_HANDLE_VALUE;
    DWORD cbFile;
    CERT_CONTEXT const *pccSigner = NULL;

    *pfBadTag = TRUE;
    hFile = CreateFile(
		    pwszfnKMS,
		    GENERIC_READ,
		    FILE_SHARE_READ,
		    NULL,
		    OPEN_EXISTING,
		    FILE_FLAG_SEQUENTIAL_SCAN,
		    NULL);
    if (INVALID_HANDLE_VALUE == hFile)
    {
	hr = myHLastError();
	_JumpError(hr, error, "CreateFile");
    }

    cbFile = GetFileSize(hFile, NULL);
    if (MAXDWORD == cbFile)
    {
	hr = myHLastError();
	_JumpError(hr, error, "GetFileSize");
    }

    // verify the KMS data signature

    hr = VerifyKMSExportFile(hFile, cbFile, &pccSigner);
    _JumpIfError(hr, error, "VerifyKMSExportFile");

    *pfBadTag = FALSE;
    if (INVALID_SET_FILE_POINTER == SetFilePointer(hFile, 0, NULL, FILE_BEGIN))
    {
	hr = myHLastError();
	_JumpError(hr, error, "SetFilePointer");
    }

    // Load the KMS recipient cert to be used to decrypt user keys

    hr = LoadKMSCert(pwszCertId, &pccKMS, &hProvKMS, &hkeyKMS);
    _JumpIfError(hr, error, "LoadKMSCert");

    // import the KMS data

    hr = ImportKMSExportedUsers(hFile, cbFile, hProvKMS, hkeyKMS);
    _JumpIfError(hr, error, "ImportKMSExportedUsers");

error:
    if (NULL != pccKMS)
    {
	CertFreeCertificateContext(pccKMS);
    }
    if (NULL != pccSigner)
    {
	CertFreeCertificateContext(pccSigner);
    }
    if (NULL != hkeyKMS)
    {
       CryptDestroyKey(hkeyKMS);
    }
    if (NULL != hProvKMS)
    {
	CryptReleaseContext(hProvKMS, 0);
    }
    if (INVALID_HANDLE_VALUE != hFile)
    {
        CloseHandle(hFile);
    }
    return(hr);
}


HRESULT
verbImportKMS(
    IN WCHAR const *pwszOption,
    IN WCHAR const *pwszfnKMS,
    IN WCHAR const *pwszCertId,
    IN WCHAR const *pwszArg3,
    IN WCHAR const *pwszArg4)
{
    HRESULT hr;
    BOOL fBadTag;

    hr = ImportKMSExportFile(pwszfnKMS, pwszCertId, &fBadTag);
    if (S_OK != hr)
    {
	_PrintError(hr, "ImportKMSExportFile");
	if (!fBadTag)
	{
	    goto error;
	}
	hr = ImportKMSPFXFile(pwszfnKMS);
	_JumpIfError(hr, error, "ImportKMSPFXFile");
    }

error:
    return(hr);
}


WCHAR const g_wszProviderNameDefault[] = MS_DEF_PROV_W;
DWORD g_dwProviderType = PROV_RSA_FULL;


HRESULT
EnumKeys(
    IN WCHAR const *pwszProvName,
    IN DWORD dwProvType,
    IN BOOL fSkipKeys,
    OPTIONAL IN WCHAR const *pwszKeyContainerName)
{
    HRESULT hr;
    KEY_LIST *pKeyList = NULL;
    KEY_LIST *pKeyT;
    WCHAR *pwszRevert = NULL;
    CERT_PUBLIC_KEY_INFO *pPubKeyInfoSig = NULL;
    CERT_PUBLIC_KEY_INFO *pPubKeyInfoXchg = NULL;
    WCHAR const *pwszPrefix;

    if (!fSkipKeys)
    {
	hr = csiGetKeyList(
		    dwProvType,		// dwProvType
		    pwszProvName,	// pwszProvName
		    !g_fUserRegistry,	// fMachineKeyset
		    !g_fCryptSilent,	// inverted fSilent: default is Silent!
		    &pKeyList);
	_JumpIfErrorStr(hr, error, "csiGetKeyList", pwszProvName);
    }
    if (fSkipKeys || NULL != pKeyList)
    {
	wprintf(L"%ws:\n", pwszProvName);
    }
    for (pKeyT = pKeyList; NULL != pKeyT; pKeyT = pKeyT->next)
    {
	DWORD dwProvTypeT;

	hr = myRevertSanitizeName(pKeyT->pwszName, &pwszRevert);
	_JumpIfError(hr, error, "myRevertSanitizeName");

	if (NULL == pwszKeyContainerName ||
	    0 == lstrcmpi(pwszKeyContainerName, pwszRevert))
	{
	    wprintf(L"  %ws", pwszRevert);
	    if (g_fVerbose && 0 != lstrcmp(pKeyT->pwszName, pwszRevert))
	    {
		wprintf(L" -- %ws", pKeyT->pwszName);
	    }
	    wprintf(wszNewLine);

	    dwProvTypeT = dwProvType;
	    hr = cuLoadKeys(
			pwszProvName,
			&dwProvTypeT,
			pKeyT->pwszName,
			!g_fUserRegistry,	// fMachineKeyset
			TRUE,
			NULL,
			&pPubKeyInfoSig,
			&pPubKeyInfoXchg);
	    if (S_OK != hr)
	    {
		cuPrintError(IDS_ERR_FORMAT_LOADKEYS, hr);
	    }
	    if (NULL != pPubKeyInfoSig || NULL != pPubKeyInfoXchg)
	    {
		pwszPrefix = g_wszPad4;
		if (NULL != pPubKeyInfoSig)
		{
		    wprintf(L"    AT_SIGNATURE");
		    LocalFree(pPubKeyInfoSig);
		    pPubKeyInfoSig = NULL;
		    pwszPrefix = L", ";
		}
		if (NULL != pPubKeyInfoXchg)
		{
		    wprintf(L"%wsAT_KEYEXCHANGE", pwszPrefix);
		    LocalFree(pPubKeyInfoXchg);
		    pPubKeyInfoXchg = NULL;
		}
		wprintf(wszNewLine);
	    }
	    if (NULL == pwszKeyContainerName)
	    {
		wprintf(wszNewLine);
	    }
	}
	LocalFree(pwszRevert);
	pwszRevert = NULL;
    }
    hr = S_OK;

error:
    if (NULL != pPubKeyInfoSig)
    {
	LocalFree(pPubKeyInfoSig);
    }
    if (NULL != pPubKeyInfoXchg)
    {
	LocalFree(pPubKeyInfoXchg);
    }
    if (NULL != pwszRevert)
    {
	LocalFree(pwszRevert);
    }
    if (NULL != pKeyList)
    {
	csiFreeKeyList(pKeyList);
    }
    return(hr);
}


HRESULT
verbKey(
    IN WCHAR const *pwszOption,
    OPTIONAL IN WCHAR const *pwszKeyContainerName,
    OPTIONAL IN WCHAR const *pwszProvider,
    IN WCHAR const *pwszArg3,
    IN WCHAR const *pwszArg4)
{
    HRESULT hr;
    WCHAR *pwszProvName = NULL;
    DWORD i;
    DWORD dwProvType;
    BOOL fSkipKeys = FALSE;

    if (NULL == pwszProvider)
    {
	pwszProvider = g_wszProviderNameDefault; // default CSP
    }
    else if (0 == lstrcmp(L"*", pwszProvider))
    {
	pwszProvider = NULL;			// all CSPs
    }
    if (NULL != pwszKeyContainerName)
    {
	if (0 == lstrcmp(L"*", pwszKeyContainerName))
	{
	    pwszKeyContainerName = NULL;		// all keys
	}
	else if (0 == lstrcmp(L"-", pwszKeyContainerName))
	{
	    pwszKeyContainerName = NULL;		// all keys
	    fSkipKeys = TRUE;
	}
    }

    if (NULL != pwszProvider)
    {
	hr = csiGetProviderTypeFromProviderName(pwszProvider, &dwProvType);
        _JumpIfErrorStr(hr, error, "csiGetProviderTypeFromProviderName", pwszProvider);
	
	hr = EnumKeys(
		    pwszProvider,
		    dwProvType,
		    fSkipKeys,
		    pwszKeyContainerName);
        _JumpIfErrorStr(hr, error, "EnumKeys", pwszProvider);
    }
    else
    {
	for (i = 0; ; i++)
	{
	    CSASSERT(NULL == pwszProvName);
	    hr = myEnumProviders(i, NULL, 0, &dwProvType, &pwszProvName);
	    if (S_OK != hr)
	    {
		if (HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS) == hr ||
		    NTE_FAIL == hr)
		{
		    // no more providers under type, out of i loop
		    break;
		}
 
		// invalid csp entry, skip it
		wprintf(L"Failed to enum CSP at (%ld)\n", i);
	    }
	    else
	    {
		hr = EnumKeys(
			    pwszProvName,
			    dwProvType,
			    fSkipKeys,
			    pwszKeyContainerName);
		_JumpIfErrorStr(hr, error, "EnumKeys", pwszProvName);

		LocalFree(pwszProvName);
		pwszProvName = NULL;
	    }
	}
    }
    hr = S_OK;

error:
    if (NULL != pwszProvName)
    {
	LocalFree(pwszProvName);
    }
    return(hr);
}


HRESULT
cuSanitizeNameWithSuffix(
    IN WCHAR const *pwszName,
    OUT WCHAR **ppwszNameOut)
{
    HRESULT hr;
    WCHAR const *pwszSuffix;
    WCHAR const *pwsz;
    WCHAR *pwszBase = NULL;
    WCHAR *pwszSanitizedName = NULL;
    DWORD cwc;

    pwsz = wcsrchr(pwszName, wcLPAREN);
    pwszSuffix = pwsz;
    if (NULL != pwsz)
    {
	BOOL fSawDigit = FALSE;

	pwsz++;
	while (iswdigit(*pwsz))
	{
	    pwsz++;
	    fSawDigit = TRUE;
	}
	if (fSawDigit &&
	    wcRPAREN == *pwsz &&
	    (L'.' == pwsz[1] || L'\0' == pwsz[1]))
	{
	    cwc = SAFE_SUBTRACT_POINTERS(pwszSuffix, pwszName);

	    pwszBase = (WCHAR *) LocalAlloc(
					LMEM_FIXED,
					(cwc + 1) * sizeof(WCHAR));
	    if (NULL == pwszBase)
	    {
		hr = E_OUTOFMEMORY;
		_JumpError(hr, error, "LocalAlloc");
	    }
	    CopyMemory(pwszBase, pwszName, cwc * sizeof(WCHAR));
	    pwszBase[cwc] = L'\0';
	    pwszName = pwszBase;
	}
	else
	{
	    pwszSuffix = NULL;
	}
    }
    hr = mySanitizeName(pwszName, &pwszSanitizedName);
    _JumpIfError(hr, error, "mySanitizeName");

    if (NULL == pwszSuffix)
    {
	*ppwszNameOut = pwszSanitizedName;
	pwszSanitizedName = NULL;
    }
    else
    {
	*ppwszNameOut = (WCHAR *) LocalAlloc(
				    LMEM_FIXED,
				    (wcslen(pwszSanitizedName) +
					wcslen(pwszSuffix) +
					1) * sizeof(WCHAR));
	if (NULL == *ppwszNameOut)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "LocalAlloc");
	}
	wcscpy(*ppwszNameOut, pwszSanitizedName);
	wcscat(*ppwszNameOut, pwszSuffix);
    }
    hr = S_OK;

error:
    if (NULL != pwszSanitizedName)
    {
	LocalFree(pwszSanitizedName);
    }
    if (NULL != pwszBase)
    {
	LocalFree(pwszBase);
    }
    return(hr);
}


HRESULT
verbDelKey(
    IN WCHAR const *pwszOption,
    IN WCHAR const *pwszKeyContainerName,
    OPTIONAL IN WCHAR const *pwszProvider,
    IN WCHAR const *pwszArg3,
    IN WCHAR const *pwszArg4)
{
    HRESULT hr;
    HCRYPTPROV hProv = NULL;
    WCHAR *apwszKeyContainer[3];
    DWORD i, dwProviderType;
    DWORD dwFlags = CRYPT_DELETEKEYSET;

    // If supplied provider is NULL, use the default provider. 
    if (pwszProvider == NULL) 
    {
	pwszProvider = g_wszProviderNameDefault;
    }
    
    apwszKeyContainer[0] = const_cast<WCHAR *>(pwszKeyContainerName);
    apwszKeyContainer[1] = NULL;
    apwszKeyContainer[2] = NULL;

    hr = mySanitizeName(pwszKeyContainerName, &apwszKeyContainer[1]);
    _JumpIfError(hr, error, "mySanitizeName");

    hr = cuSanitizeNameWithSuffix(pwszKeyContainerName, &apwszKeyContainer[2]);
    _JumpIfError(hr, error, "cuSanitizeNameWithSuffix");

    hr = csiGetProviderTypeFromProviderName(pwszProvider, &dwProviderType);
    _JumpIfError(hr, error, "csiGetProviderTypeFromProviderName");
      
    if (g_fCryptSilent)
    {
        dwFlags |= CRYPT_SILENT;
    }

    for (i = 0; i < ARRAYSIZE(apwszKeyContainer); i++)
    {
	if (!myCertSrvCryptAcquireContext(
			    &hProv,
			    apwszKeyContainer[i],
			    pwszProvider,
			    dwProviderType, 
			    dwFlags,
			    !g_fUserRegistry))	// fMachineKeyset
	{
	    hr = myHLastError();
	    _PrintErrorStr2(
			hr,
			"myCertSrvCryptAcquireContext",
			apwszKeyContainer[i],
			hr);
	}
	else
	{
	    DWORD j;
	    
	    wprintf(L"  %ws", apwszKeyContainer[i]);
	    if (g_fVerbose)
	    {
		wprintf(L" --");
		for (j = 0; j < ARRAYSIZE(apwszKeyContainer); j++)
		{
		    wprintf(L" %ws", apwszKeyContainer[j]);
		}
	    }
	    wprintf(wszNewLine);
	    hr = S_OK;
	    break;
	}
    }
    _JumpIfError(hr, error, "myCertSrvCryptAcquireContext");

error:
    for (i = 1; i < ARRAYSIZE(apwszKeyContainer); i++)
    {
	if (NULL != apwszKeyContainer[i])
	{
	    LocalFree(apwszKeyContainer[i]);
	}
    }
    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\tools\certut\verify.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       verify.cpp
//
//--------------------------------------------------------------------------

#include <pch.cpp>

#pragma hdrstop

#include "cscsp.h"


HRESULT
VerifyKeyAuthority(
    CERT_NAME_BLOB const *pIssuer,
    CERT_INFO const *pCertInfoCA,
    BYTE const *pbData,
    DWORD cbData,
    BOOL *pfKeyAuthorityMatch)
{
    CERT_AUTHORITY_KEY_ID2_INFO const *pcaki = NULL;
    DWORD cbcaki;
    HRESULT hr = S_OK;
    BOOL fDisplayIssuer = g_fVerbose;
    CERT_NAME_BLOB const *pAuthorityCertIssuerName = NULL;
    BYTE *pbHash = NULL;
    DWORD cbHash;

    *pfKeyAuthorityMatch = TRUE;

    if (!myDecodeKeyAuthority2(
			    X509_ASN_ENCODING,
			    pbData,
			    cbData,
			    CERTLIB_USE_LOCALALLOC,
			    &pcaki,
			    &cbcaki))
    {
	hr = myHLastError();
	_JumpError(hr, error, "myDecodeKeyAuthority(IssuerKey)");
    }
    if (0 != pcaki->KeyId.cbData)
    {
	//DumpHex(DH_NOTABPREFIX | 4, pcaki->KeyId.pbData, pcaki->KeyId.cbData);
	hr = myGetPublicKeyHash(
			pCertInfoCA,
			&pCertInfoCA->SubjectPublicKeyInfo,
			&pbHash,
			&cbHash);
	_JumpIfError(hr, error, "myGetPublicKeyHash");

	//DumpHex(DH_NOTABPREFIX | 4, pbHash, cbHash);

	if (cbHash == pcaki->KeyId.cbData &&
	    0 == memcmp(pbHash, pcaki->KeyId.pbData, cbHash))
	{
	    wprintf(myLoadResourceString(IDS_KEYID_IS_KEYAUTHORITY)); // "CA Key Id matches Key Id"
	}
	else
	{
	    wprintf(wszNewLine);
	    wprintf(myLoadResourceString(IDS_ERR_KEYID_NOT_KEYAUTHORITY)); // "ERROR: CA Key Id does not match Key Id"
	    wprintf(wszNewLine);
	    *pfKeyAuthorityMatch = FALSE;
	}
    }
    else
    {
	wprintf(myLoadResourceString(IDS_NO_KEYID)); // "No Key Id"
    }
    wprintf(wszNewLine);

    if (1 == pcaki->AuthorityCertIssuer.cAltEntry &&
	CERT_ALT_NAME_DIRECTORY_NAME ==
	    pcaki->AuthorityCertIssuer.rgAltEntry[0].dwAltNameChoice)
    {

	pAuthorityCertIssuerName = &pcaki->AuthorityCertIssuer.rgAltEntry[0].DirectoryName;

	// The Issuer's Issuer name and the Issuer's SerialNumber combined
	// should uniquely identify the Issuer cert.

	// Verify Issuer's Issuer name:
	//        -------- ------ ----

	if (!CertCompareCertificateName(
		    X509_ASN_ENCODING,
		    const_cast<CERT_NAME_BLOB *>(&pCertInfoCA->Issuer),
		    const_cast<CERT_NAME_BLOB *>(pAuthorityCertIssuerName)))
	{
	    // This API doesn't set LastError
	    hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);

	    wprintf(wszNewLine);
	    wprintf(
		myLoadResourceString(IDS_ERR_FORMAT_ISSUER_NOT_KEYAUTHORITY), // "ERROR: CA Issuer name does not match Key Authority name (%x)"
		hr);

	    hr = S_OK;
	    fDisplayIssuer = TRUE;
	    *pfKeyAuthorityMatch = FALSE;
	}
	else
	{
	    wprintf(myLoadResourceString(IDS_ISSUER_IS_KEYAUTHORITY)); // "CA Issuer name matches Key Authority name"
	}
    }
    else
    {
	wprintf(myLoadResourceString(IDS_NO_KEYAUTHORITY)); // "No Key Authority name"
    }
    wprintf(wszNewLine);

    if (0 != pcaki->AuthorityCertSerialNumber.cbData)
    {
	if (pCertInfoCA->SerialNumber.cbData !=
		pcaki->AuthorityCertSerialNumber.cbData ||
	    0 != memcmp(
		    pCertInfoCA->SerialNumber.pbData,
		    pcaki->AuthorityCertSerialNumber.pbData,
		    pcaki->AuthorityCertSerialNumber.cbData))
	{
	    wprintf(wszNewLine);
	    wprintf(myLoadResourceString(IDS_SERIAL_NOT_KEYAUTHORITY)); // "ERROR: Issuer serial number does not match Key Authority"
	    wprintf(wszNewLine);

	    fDisplayIssuer = TRUE;
	    *pfKeyAuthorityMatch = FALSE;
	}
	else
	{
	    wprintf(myLoadResourceString(IDS_SERIAL_IS_KEYAUTHORITY)); // "Issuer serial number matches Key Authority"
	}
    }
    else
    {
	wprintf(myLoadResourceString(IDS_NO_KEYAUTHORITYSERIAL)); // "No Key Authority serial number"
    }
    wprintf(wszNewLine);

    if (fDisplayIssuer)
    {
	hr = cuDisplayCertName(
			TRUE,
			NULL,
			myLoadResourceString(IDS_ISSUERNAME), // "Issuer Name"
			g_wszPad4,
			pIssuer);
	_JumpIfError(hr, error, "cuDisplayCertName(Issuer)");

	if (NULL != pAuthorityCertIssuerName)
	{
	    hr = cuDisplayCertName(
			    TRUE,
			    NULL,
			    myLoadResourceString(IDS_KEYAUTHORITYNAME), // "KeyAuthority
			    g_wszPad4,
			    pAuthorityCertIssuerName);
	    _JumpIfError(hr, error, "cuDisplayCertName(KeyAuthority)");
	}

	wprintf(wszNewLine);
	wprintf(myLoadResourceString(IDS_KEYID)); // "KeyId:"
	wprintf(wszNewLine);

	DumpHex(DH_NOTABPREFIX | 4, pcaki->KeyId.pbData, pcaki->KeyId.cbData);

	wprintf(wszNewLine);

	hr = cuDumpSerial(
		    NULL,
		    IDS_KEYAUTHORITYSERIAL,
		    &pcaki->AuthorityCertSerialNumber);
	_JumpIfError(hr, error, "cuDumpSerial");

	wprintf(wszNewLine);

	hr = cuDumpSerial(NULL, IDS_CASERIAL, &pCertInfoCA->SerialNumber);
	_JumpIfError(hr, error, "cuDumpSerial");
    }

error:
    if (NULL != pcaki)
    {
	LocalFree(const_cast<CERT_AUTHORITY_KEY_ID2_INFO *>(pcaki));
    }
    if (NULL != pbHash)
    {
	LocalFree(pbHash);
    }
    return(hr);
}


static DWORD s_adwProvType[] =
{
    PROV_RSA_FULL,
    PROV_RSA_SIG,
    PROV_DSS,
    PROV_FORTEZZA,
    PROV_MS_EXCHANGE,
    PROV_SSL,
    PROV_RSA_SCHANNEL,
    PROV_DSS_DH,
    PROV_EC_ECDSA_SIG,
    PROV_EC_ECNRA_SIG,
    PROV_EC_ECDSA_FULL,
    PROV_EC_ECNRA_FULL,
    PROV_DH_SCHANNEL,
    PROV_SPYRUS_LYNKS,
    PROV_RNG,
    PROV_INTEL_SEC,
};


HRESULT
cuLoadKeys(
    OPTIONAL IN WCHAR const *pwszProvName,
    IN OUT DWORD *pdwProvType,
    IN WCHAR const *pwszKeyContainerName,
    IN BOOL fMachineKeyset,
    IN BOOL fSoftFail,
    OPTIONAL OUT HCRYPTPROV *phProv,
    OPTIONAL OUT CERT_PUBLIC_KEY_INFO **ppPubKeyInfo,
    OPTIONAL OUT CERT_PUBLIC_KEY_INFO **ppPubKeyInfoXchg)
{
    HRESULT hr;
    HRESULT hr2;
    HCRYPTPROV hProv = NULL;
    DWORD cb;
    DWORD *pdwProvTypeT = pdwProvType;
    DWORD *pdwProvTypeEnd = &pdwProvTypeT[1];
    DWORD dwSilent = g_fCryptSilent? CRYPT_SILENT : 0;
    CERT_PUBLIC_KEY_INFO *pPubKeyInfo = NULL;
    CERT_PUBLIC_KEY_INFO *pPubKeyInfoXchg = NULL;

    if (NULL != phProv)
    {
	*phProv = NULL;
    }
    if (NULL != ppPubKeyInfo)
    {
	*ppPubKeyInfo = NULL;
    }
    if (NULL != ppPubKeyInfoXchg)
    {
	*ppPubKeyInfoXchg = NULL;
    }

    // If no provider type was specified, try them all

    if (0 == *pdwProvTypeT)
    {
	pdwProvTypeT = s_adwProvType;
	pdwProvTypeEnd = &s_adwProvType[ARRAYSIZE(s_adwProvType)];
    }

    hr = S_OK;
    for ( ; pdwProvTypeT < pdwProvTypeEnd; pdwProvTypeT++)
    {
	DBGPRINT((
	    DBG_SS_CERTUTILI,
	    "myCertSrvCryptAcquireContext(%ws, t=%x, f=%x, m=%x)\n",
	    pwszKeyContainerName,
	    *pdwProvTypeT,
	    dwSilent,
	    fMachineKeyset));

	if (myCertSrvCryptAcquireContext(
			    &hProv,
			    pwszKeyContainerName,
			    pwszProvName,
			    *pdwProvTypeT,
			    dwSilent,		// dwFlags
			    fMachineKeyset))
	{
	    hr = S_OK;
	    break;
	}
	hr2 = myHLastError();
	if (S_OK == hr ||
	    (NTE_BAD_PROV_TYPE != hr2 &&
	     NTE_PROV_TYPE_NOT_DEF != hr2 &&
	     NTE_BAD_KEYSET != hr2))
	{
	    hr = hr2;
	}
	_PrintErrorStr2(
		hr2,
		"myCertSrvCryptAcquireContext",
		pwszKeyContainerName,
		hr2);
	if (NTE_BAD_FLAGS == hr2 &&
	    PROV_MS_EXCHANGE == *pdwProvTypeT &&
	    ((CRYPT_SILENT & dwSilent) || fMachineKeyset))
	{
	    DBGPRINT((
		DBG_SS_CERTUTILI,
		"myCertSrvCryptAcquireContext(%ws, t=%x, f=%x, m=%x)\n",
		pwszKeyContainerName,
		*pdwProvTypeT,
		0,
		FALSE));

	    if (myCertSrvCryptAcquireContext(
				&hProv,
				pwszKeyContainerName,
				pwszProvName,
				*pdwProvTypeT,
				0,		// dwFlags
				FALSE))
	    {
		hr = S_OK;
		break;
	    }
	    hr2 = myHLastError();
	    _PrintErrorStr2(
		    hr2,
		    "myCertSrvCryptAcquireContext",
		    pwszKeyContainerName,
		    hr2);
	}
    }
    if (S_OK != hr)
    {
	cuPrintErrorAndString(
			L"CryptAcquireContext",
			0,
			hr,
			pwszKeyContainerName);
	goto error;
    }

    // export the public key blob

    if (NULL != ppPubKeyInfo &&
	!myCryptExportPublicKeyInfo(
				hProv,
				AT_SIGNATURE,
				CERTLIB_USE_LOCALALLOC,
				&pPubKeyInfo,
				&cb))
    {
	hr = myHLastError();
	if (!fSoftFail)
	{
	    cuPrintErrorAndString(
			    L"CryptExportPublicKeyInfo",
			    0,
			    hr,
			    L"AT_SIGNATURE");
	    goto error;
	}
    }

    if (NULL != ppPubKeyInfoXchg &&
	!myCryptExportPublicKeyInfo(
				hProv,
				AT_KEYEXCHANGE,
				CERTLIB_USE_LOCALALLOC,
				&pPubKeyInfoXchg,
				&cb))
    {
	hr = myHLastError();
	if (!fSoftFail)
	{
	    cuPrintErrorAndString(
			    L"CryptExportPublicKeyInfo",
			    0,
			    hr,
			    L"AT_KEYEXCHANGE");
	    goto error;
	}
    }
    *pdwProvType = *pdwProvTypeT;
    if (NULL != phProv)
    {
	*phProv = hProv;
	hProv = NULL;
    }
    if (NULL != ppPubKeyInfo)
    {
	*ppPubKeyInfo = pPubKeyInfo;
	pPubKeyInfo = NULL;
    }
    if (NULL != ppPubKeyInfoXchg)
    {
	*ppPubKeyInfoXchg = pPubKeyInfoXchg;
	pPubKeyInfoXchg = NULL;
    }
    hr = S_OK;

error:
    if (NULL != pPubKeyInfo)
    {
	LocalFree(pPubKeyInfo);
    }
    if (NULL != pPubKeyInfoXchg)
    {
	LocalFree(pPubKeyInfoXchg);
    }
    if (NULL != hProv)
    {
	CryptReleaseContext(hProv, 0);
    }
    return(hr);
}


HRESULT
VerifyPrivateKey(
    IN CERT_CONTEXT const *pCertContextCA,
    IN WCHAR const *pwszSanitizedCA,
    IN WCHAR const *pwszKeyContainerName,
    OUT BOOL *pfMatchFailed)
{
    HRESULT hr;
    DWORD dwProvType;
    WCHAR *pwszProvName = NULL;
    ALG_ID idAlg;
    BOOL fMachineKeyset;

    *pfMatchFailed = TRUE;

    // get provider name

    hr = myGetCertSrvCSP(
		    FALSE,		// fEncryptionCSP
		    pwszSanitizedCA,
		    &dwProvType,
		    &pwszProvName,
		    &idAlg,
		    &fMachineKeyset,
		    NULL);		// pdwKeySize
    _JumpIfError(hr, error, "myGetCertSrvCSP");

    hr = myValidateHashForSigning(
		    pwszKeyContainerName,
		    pwszProvName,
		    dwProvType,
		    fMachineKeyset,
		    &pCertContextCA->pCertInfo->SubjectPublicKeyInfo,
		    idAlg);
    if (S_OK != hr)
    {
	_PrintError(hr, "myValidateHashForSigning");
    }
    else
    {
	*pfMatchFailed = FALSE;
    }
    hr = S_OK;

error:
    if (NULL != pwszProvName)
    {
	LocalFree(pwszProvName);
    }
    return(hr);
}


HRESULT
VerifyCAKeys(
    IN CERT_CONTEXT const *pCertContextCA,
    IN WCHAR const *pwszSanitizedCA,
    IN WCHAR const *pwszCertNameCA,
    IN WCHAR const *pwszKeyContainerName)
{
    HRESULT hr;
    CERT_PUBLIC_KEY_INFO *pPubKeyInfo = NULL;
    BOOL fMatchFailed = FALSE;
    BOOL fSignatureFailed = FALSE;
    WCHAR *pwszRevert = NULL;
    DWORD dwNameId;
    CRYPT_KEY_PROV_INFO kpi;
    CRYPT_KEY_PROV_INFO *pkpi = NULL;
    DWORD cbkpi;

    ZeroMemory(&kpi, sizeof(kpi));
    hr = myGetNameId(pCertContextCA, &dwNameId);
    if (S_OK != hr)
    {
	_PrintError(hr, "myGetNameId");
	dwNameId = MAXDWORD;
    }
    hr = myRevertSanitizeName(pwszKeyContainerName, &pwszRevert);
    _JumpIfError(hr, error, "myRevertSanitizeName");

    if (!myCertGetCertificateContextProperty(
			pCertContextCA,
			CERT_KEY_PROV_INFO_PROP_ID,
			CERTLIB_USE_LOCALALLOC,
			(VOID **) &pkpi,
			&cbkpi))
    {
	hr = myHLastError();
	_PrintError(hr, "myCertGetCertificateContextProperty");

	kpi.pwszContainerName = const_cast<WCHAR *>(pwszKeyContainerName);
    }
    else
    {
	kpi = *pkpi;
	if (0 != lstrcmp(pwszKeyContainerName, pkpi->pwszContainerName))
	{
	    wprintf(
		L"%ws --> %ws\n",
		pwszKeyContainerName,
		pkpi->pwszContainerName);

	    kpi.pwszContainerName = pkpi->pwszContainerName;
	}
    }

    // Load public key

    hr = cuLoadKeys(
		kpi.pwszProvName,
		&kpi.dwProvType,
		kpi.pwszContainerName,
		TRUE,			// fMachineKeyset
		FALSE,			// fSoftFail
		NULL,			// phProv
		&pPubKeyInfo,
		NULL);
    if (S_OK != hr)
    {
	cuPrintError(IDS_ERR_FORMAT_LOADKEYS, hr);
	goto error;
    }

    // see if the public key matches the certificate's public key

    if (!CertComparePublicKeyInfo(
			    X509_ASN_ENCODING,
			    pPubKeyInfo,
			    &pCertContextCA->pCertInfo->SubjectPublicKeyInfo))
    {
	wprintf(wszNewLine);
	wprintf(myLoadResourceString(IDS_ERR_PUBLICKEY_MISMATCH)); // "ERROR: Certificate public key does NOT match stored keyset"
	wprintf(wszNewLine);
	wprintf(wszNewLine);

	fMatchFailed = TRUE;
    }

    if (!fMatchFailed)
    {
	hr = VerifyPrivateKey(
			pCertContextCA,
			pwszSanitizedCA,
			kpi.pwszContainerName,
			&fSignatureFailed);
	_JumpIfError(hr, error, "VerifyPrivateKey");
    }

    if (g_fVerbose || fMatchFailed)
    {
	wprintf(wszNewLine);
	wprintf(myLoadResourceString(IDS_CONTAINER_PUBLIC_KEY)); // "Container Public Key:"
	wprintf(wszNewLine);
	DumpHex(
	    DH_NOTABPREFIX | 4,
	    pPubKeyInfo->PublicKey.pbData,
	    pPubKeyInfo->PublicKey.cbData);

	wprintf(wszNewLine);
	wprintf(myLoadResourceString(IDS_CERT_PUBLIC_KEY)); // "Certificate Public Key:"
	wprintf(wszNewLine);
	DumpHex(
	    DH_NOTABPREFIX | 4,
	    pCertContextCA->pCertInfo->SubjectPublicKeyInfo.PublicKey.pbData,
	    pCertContextCA->pCertInfo->SubjectPublicKeyInfo.PublicKey.cbData);
    }

error:
    if (S_OK == hr)
    {
	wprintf(
	    myLoadResourceString(
		fMatchFailed?
		    IDS_FORMAT_KEY_NOT_VERIFY : // "%ws does NOT verify as the public key in %ws"
		    IDS_FORMAT_KEY_IS_VERIFY),  // "%ws verifies as the public key in %ws"
	    pwszRevert,
	    pwszCertNameCA);

	if (MAXDWORD != dwNameId)
	{
	    wprintf(
		L" V%u.%u",
		CANAMEIDTOICERT(dwNameId),
		CANAMEIDTOIKEY(dwNameId));
	}

	if (fMatchFailed || fSignatureFailed)
	{
	    hr = E_INVALIDARG;
	    if (fSignatureFailed)
	    {
		wprintf(L" -- ");
		wprintf(myLoadResourceString(IDS_SIGNATURE_BAD)); // "Signature test FAILED"
	    }
	}
	else
	{
	    wprintf(L" -- ");
	    wprintf(myLoadResourceString(IDS_SIGNATURE_OK)); // "Signature test passed"
	}
	wprintf(wszNewLine);
    }
    if (NULL != pwszRevert)
    {
	LocalFree(pwszRevert);
    }
    if (NULL != pPubKeyInfo)
    {
	LocalFree(pPubKeyInfo);
    }
    if (NULL != pkpi)
    {
	LocalFree(pkpi);
    }
    return(hr);
}


HRESULT
VerifyAllCAKeys(
    IN WCHAR const *pwszCA,
    IN WCHAR const *pwszSanitizedCA)
{
    HRESULT hr;
    WCHAR *pwszCertName = NULL;
    DWORD cCACerts;
    DWORD iHash;
    HCERTSTORE hMyStore = NULL;
    CERT_CONTEXT const *pccCA = NULL;
    CRYPT_KEY_PROV_INFO *pkpi = NULL;
    DWORD cbkpi;

    hr = myGetCARegHashCount(pwszSanitizedCA, CSRH_CASIGCERT, &cCACerts);
    if (S_OK == hr && 0 == cCACerts)
    {
	hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
    }
    _JumpIfError(hr, error, "myGetCARegHashCount");

    // open MY store

    hMyStore = CertOpenStore(
		       CERT_STORE_PROV_SYSTEM_W,
		       X509_ASN_ENCODING,
		       NULL,			// hProv
		       CERT_SYSTEM_STORE_LOCAL_MACHINE,
		       wszMY_CERTSTORE);
    if (NULL == hMyStore)
    {
        hr = myHLastError();
        _JumpError(hr, error, "CertOpenStore");
    }

    for (iHash = 0; iHash < cCACerts; iHash++)
    {
	DWORD NameId;
	
	hr = myFindCACertByHashIndex(
				hMyStore,
				pwszSanitizedCA,
				CSRH_CASIGCERT,
				iHash,
				&NameId,
				&pccCA);
	if (S_FALSE == hr)
	{
	    continue;
	}
	_JumpIfError(hr, error, "myFindCACertByHashIndex");

	// get the private key provider info

	if (!myCertGetCertificateContextProperty(
			    pccCA,
			    CERT_KEY_PROV_INFO_PROP_ID,
			    CERTLIB_USE_LOCALALLOC,
			    (VOID **) &pkpi,
			    &cbkpi))
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "myCertGetCertificateContextProperty");
	}

	if (MAXDWORD == NameId)
	{
	    NameId = MAKECANAMEID(iHash, iHash);
	}
	hr = myAllocIndexedName(
			pwszCA,
			CANAMEIDTOICERT(NameId),
			&pwszCertName);
	_JumpIfError(hr, error, "myAllocIndexedName");

	hr = VerifyCAKeys(
		    pccCA,
		    pwszSanitizedCA,
		    pwszCertName,
		    pkpi->pwszContainerName);
	_JumpIfError(hr, error, "VerifyCAKeys");

	CertFreeCertificateContext(pccCA);
	pccCA = NULL;

	LocalFree(pkpi);
	pkpi = NULL;

	LocalFree(pwszCertName);
	pwszCertName = NULL;
    }

error:
    if (NULL != pkpi)
    {
	LocalFree(pkpi);
    }
    if (NULL != pccCA)
    {
	CertFreeCertificateContext(pccCA);
    }
    if (NULL != hMyStore)
    {
        CertCloseStore(hMyStore, CERT_CLOSE_STORE_CHECK_FLAG);
    }
    if (NULL != pwszCertName)
    {
	LocalFree(pwszCertName);
    }
    return(hr);
}


HRESULT
verbVerifyKeys(
    IN WCHAR const *pwszOption,
    OPTIONAL IN WCHAR const *pwszKeyContainerName,
    OPTIONAL IN WCHAR const *pwszfnCertCA,
    OPTIONAL IN WCHAR const *pwszArg3,
    OPTIONAL IN WCHAR const *pwszArg4)
{
    HRESULT hr;
    CERT_CONTEXT const *pCertContextCA = NULL;
    WCHAR *pwszCA = NULL;
    WCHAR *pwszSanitizedCA = NULL;
    WCHAR *pwszRevertContainer = NULL;
    WCHAR *pwszSanitizedContainer = NULL;

    hr = cuGetLocalCANameFromConfig(NULL, &pwszCA);
    _JumpIfError(hr, error, "GetLocalCANameFromConfig");

    hr = mySanitizeName(pwszCA, &pwszSanitizedCA);
    _JumpIfError(hr, error, "mySanitizeName");

    if (NULL == pwszfnCertCA)
    {
	if (NULL != pwszKeyContainerName)
	{
	    hr = E_INVALIDARG;
	    _JumpError(hr, error, "extra arg");
	}

	hr = VerifyAllCAKeys(pwszCA, pwszSanitizedCA);
	_JumpIfError(hr, error, "VerifyAllCAKeys");
    }
    else
    {
	hr = myRevertSanitizeName(pwszKeyContainerName, &pwszRevertContainer);
	_JumpIfError(hr, error, "myRevertSanitizeName");

	hr = cuSanitizeNameWithSuffix(
			    pwszRevertContainer,
			    &pwszSanitizedContainer);
	_JumpIfError(hr, error, "cuSanitizeNameWithSuffix");

	// Load and decode CA certificate

	hr = cuLoadCert(pwszfnCertCA, &pCertContextCA);
	if (S_OK != hr)
	{
	    cuPrintError(IDS_ERR_FORMAT_LOADCACERT, hr);
	    goto error;
	}

	hr = VerifyCAKeys(
		    pCertContextCA,
		    pwszSanitizedCA,
		    pwszfnCertCA,
		    pwszSanitizedContainer);
	_JumpIfError(hr, error, "VerifyCAKeys");
    }

error:
    cuUnloadCert(&pCertContextCA);
    if (NULL != pwszSanitizedCA)
    {
	LocalFree(pwszSanitizedCA);
    }
    if (NULL != pwszCA)
    {
	LocalFree(pwszCA);
    }
    if (NULL != pwszSanitizedContainer)
    {
	LocalFree(pwszSanitizedContainer);
    }
    if (NULL != pwszRevertContainer)
    {
	LocalFree(pwszRevertContainer);
    }
    return(hr);
}


VOID
cuDumpPolicies(
    IN UINT idMsg,
    IN WCHAR const *pwszzPolicies)
{
    if (NULL != pwszzPolicies)
    {
	wprintf(L"%ws:\n", myLoadResourceString(idMsg));

	for ( ;
	     L'\0' != *pwszzPolicies;
	     pwszzPolicies += wcslen(pwszzPolicies) + 1)
	{
	    wprintf(g_wszPad4);
	    cuDumpOIDAndDescription(pwszzPolicies);
	    wprintf(wszNewLine);
	}
    }
}


HRESULT
cuVerifyCertContext(
    IN CERT_CONTEXT const *pCert,
    OPTIONAL IN HCERTSTORE hStoreCA,
    OPTIONAL IN char *apszPolicies[],
    IN DWORD cPolicies,
    OUT DWORD *pVerifyState)
{
    HRESULT hr;
    DWORD idMsg;
    WCHAR *pwszMissingIssuer = NULL;
    WCHAR *pwszzIssuancePolicies = NULL;
    WCHAR *pwszzApplicationPolicies = NULL;
    DWORD Flags;
    char *apszEnrollOids[] = { szOID_ENROLLMENT_AGENT };

    *pVerifyState = 0;
    if (CertCompareCertificateName(
		    X509_ASN_ENCODING,
		    &pCert->pCertInfo->Issuer,
		    &pCert->pCertInfo->Subject))
    {
	*pVerifyState |= VS_ROOT;
#if 0
	hr = cuVerifySignature(
			pCert->pbCertEncoded,
			pCert->cbCertEncoded,
			&pCert->pCertInfo->SubjectPublicKeyInfo,
			FALSE);
	if (S_OK == hr)
	{
	    *pVerifyState |= VS_ROOTSIGOK;
	}
	_PrintIfError(hr, "cuVerifySignature");
#endif
    }

    // Verify the cert and chain:
    Flags = 0;
    if (g_fEnterpriseRegistry)
    {
	Flags |= CA_VERIFY_FLAGS_NT_AUTH;
	if (NULL == apszPolicies || 0 == cPolicies)
	{
	    apszPolicies = apszEnrollOids;
	    cPolicies = ARRAYSIZE(apszEnrollOids);
	}
    }
    if (g_fForce)
    {
	Flags |= CA_VERIFY_FLAGS_IGNORE_OFFLINE |
		    CA_VERIFY_FLAGS_ALLOW_UNTRUSTED_ROOT;
	if (1 < g_fForce)
	{
	    Flags |= CA_VERIFY_FLAGS_NO_REVOCATION;
	}
    }
    if (!g_fQuiet)
    {
	Flags |= CA_VERIFY_FLAGS_DUMP_CHAIN;
    }
    if (g_fSplitASN)
    {
	Flags |= CA_VERIFY_FLAGS_SAVE_CHAIN;
    }

    hr = myVerifyCertContextEx(
			pCert,
                        Flags,
			cPolicies,
			apszPolicies,
			g_fUserRegistry? HCCE_CURRENT_USER : HCCE_LOCAL_MACHINE,
			NULL,			// pft
			hStoreCA,		// hAdditionalStore
			&pwszMissingIssuer,
			&pwszzIssuancePolicies,
			&pwszzApplicationPolicies);

    cuDumpPolicies(IDS_ISSUANCE_POLICIES, pwszzIssuancePolicies);
    cuDumpPolicies(IDS_APPLICATION_POLICIES, pwszzApplicationPolicies);

    idMsg = 0;
    if (CRYPT_E_REVOKED == hr)
    {
	idMsg = IDS_REVOKED_CERT;	// "Certificate is REVOKED"
	*pVerifyState |= VS_REVOKED;
    }
    else if (CERT_E_UNTRUSTEDROOT == hr)
    {
	idMsg = IDS_UNTRUSTED_ROOT;	// "Verifies against UNTRUSTED root"
	*pVerifyState |= VS_UNTRUSTEDROOT;
    }
    else if (CERT_E_CHAINING == hr)
    {
	idMsg = IDS_INCOMPLETE_CHAIN;	// "Incomplete certificate chain"
	*pVerifyState |= VS_INCOMPLETECHAIN;
    }
    else if (CERT_E_EXPIRED == hr)
    {
	idMsg = IDS_EXPIRED_CERT;	// "Expired certificate"
	*pVerifyState |= VS_EXPIRED;
    }
    else if (CRYPT_E_REVOCATION_OFFLINE == hr)
    {
	idMsg = IDS_REVOCATION_OFFLINE;	// "Revocation check skipped -- server offline"
	*pVerifyState |= VS_REVOCATIONOFFLINE;
    }
    else if (CRYPT_E_NO_REVOCATION_CHECK == hr)
    {
	idMsg = IDS_NO_REVOCATION_CHECK; // "Revocation check skipped -- no revocation information available"
	*pVerifyState |= VS_NOREVOCATIONCHECK;
    }
    if (0 != idMsg)
    {
	wprintf(myLoadResourceString(idMsg));
	wprintf(wszNewLine);
	if (NULL != pwszMissingIssuer)
	{
	    wprintf(myLoadResourceString(IDS_MISSING_CERT));
	    wprintf(L"\n    %ws\n", pwszMissingIssuer);
	}
	hr = S_OK;
    }
    if (S_OK != hr)
    {
	*pVerifyState |= VS_OTHERERROR;
    }
    _JumpIfError(hr, error, "cuVerifyCertContext");

error:
    if (NULL != pwszMissingIssuer)
    {
	LocalFree(pwszMissingIssuer);
    }
    if (NULL != pwszzIssuancePolicies)
    {
	LocalFree(pwszzIssuancePolicies);
    }
    if (NULL != pwszzApplicationPolicies)
    {
	LocalFree(pwszzApplicationPolicies);
    }
    return(hr);
}


#define RS_INCOMPLETE	0
#define RS_PASS		1
#define RS_FAIL		2
#define RS_REVOKED	3

DWORD
VerifyRevocation(
    IN CERT_CONTEXT const *pCertContext,
    OPTIONAL IN CERT_CONTEXT const *pCertContextCA)
{
    HRESULT hr;
    CERT_REVOCATION_PARA crp;
    CERT_REVOCATION_STATUS crs;
    DWORD RevState;

    ZeroMemory(&crp, sizeof(crp));
    crp.cbSize = sizeof(crp);
    crp.pIssuerCert = pCertContextCA;

    ZeroMemory(&crs, sizeof(crs));
    crs.cbSize = sizeof(crs);

    if (!CertVerifyRevocation(
			X509_ASN_ENCODING,
			CERT_CONTEXT_REVOCATION_TYPE,
			1,				// cContext
			(VOID **) &pCertContext,	// rgpContext
			0,				// dwFlags
			&crp,
			&crs))
    {
	hr = myHLastError();
	if (CRYPT_E_REVOKED == hr)
	{
	    wprintf(
		myLoadResourceString(IDS_FORMAT_IS_REVOKED), // "Certificate is REVOKED (Reason=%x)"
		crs.dwReason);
	    wprintf(wszNewLine);
	    RevState = RS_REVOKED;
	    goto error;
	}
	if (CRYPT_E_NO_REVOCATION_CHECK != hr)
	{
	    wprintf(wszNewLine);
	    cuPrintError(IDS_ERR_FORMAT_VERIFY_REVSTATUS, hr); // "ERROR: Verify Revocation Status returned %ws"
	    cuPrintErrorMessageText(hr);
	    wprintf(wszNewLine);

	    RevState = RS_FAIL;
	    goto error;
	}
	wprintf(myLoadResourceString(IDS_CANNOT_CHECK_REVSTATUS));  // "Cannot check revocation status"
	wprintf(wszNewLine);

	RevState = RS_INCOMPLETE;
	goto error;
    }
    wprintf(myLoadResourceString(IDS_REVSTATUS_OK)); // "Revocation check passed"
    wprintf(wszNewLine);
    RevState = RS_PASS;

error:
    return(RevState);
}


#define CAS_UNKNOWN	0
#define CAS_CA		1
#define CAS_ENDENTITY	2

VOID
VerifyCACert(
    IN CERT_INFO const *pCertInfo,
    IN BOOL fCA,
    OUT DWORD *pState)
{
    HRESULT hr;
    CERT_EXTENSION *pExt;
    UINT id = 0;

    *pState = CAS_UNKNOWN;

    pExt = CertFindExtension(
			szOID_BASIC_CONSTRAINTS2,
			pCertInfo->cExtension,
			pCertInfo->rgExtension);
    if (NULL == pExt)
    {
	// This API doesn't set LastError
	//hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
	//_PrintError(hr, "CertFindExtension");

	if (fCA)
	{
	    id = IDS_NOBASICCONSTRAINTS2_ERROR; // "ERROR: CA Cert has no Basic Constraints2 Extension"
	}
    }
    else
    {
	DWORD cb;
	CERT_BASIC_CONSTRAINTS2_INFO Constraints;

	cb = sizeof(Constraints);
	if (!CryptDecodeObject(
			    X509_ASN_ENCODING,
			    X509_BASIC_CONSTRAINTS2,
			    pExt->Value.pbData,
			    pExt->Value.cbData,
			    0,
			    &Constraints,
			    &cb))
	{
	    hr = myHLastError();
	    _PrintError(hr, "CryptDecodeObject");

	    id = IDS_CANNOTDECODEBASICCONSTRAINTS2_ERROR; // "ERROR: Cannot decode CA Cert Basic Constraints2 Extension"
	}
	else
	{
	    *pState = Constraints.fCA? CAS_CA : CAS_ENDENTITY;
	    if (!Constraints.fCA)
	    {
		id = IDS_ENDENTITYCACERT_ERROR; // "ERROR: CA Cert is an End Entity certificate"
	    }
	}
    }
    if (fCA && 0 != id)
    {
	wprintf(wszNewLine);
	wprintf(myLoadResourceString(id));
	wprintf(wszNewLine);
	wprintf(wszNewLine);
    }
    if (!fCA)
    {
	switch (*pState)
	{
	    case CAS_CA:
		wprintf(myLoadResourceString(IDS_CACERT)); // "Cert is a CA certificate"
		wprintf(wszNewLine);
		break;

	    case CAS_ENDENTITY:
		wprintf(myLoadResourceString(IDS_ENDENTITYCERT)); // "Cert is an End Entity certificate"
		wprintf(wszNewLine);
		break;
	}
    }
}


HRESULT
VerifyCertAgainstChain(
    IN WCHAR const *pwszfnCert)
{
    HRESULT hr;
    CERT_CONTEXT const *pCertContext = NULL;
    DWORD VerifyState;
    DWORD CertState;
    DWORD RevState;

    // Load and decode certificates

    hr = cuLoadCert(pwszfnCert, &pCertContext);
    if (S_OK != hr)
    {
	cuPrintError(IDS_FORMAT_LOADTESTCERT, hr);
	goto error;
    }

    // Display name info:

    hr = cuDisplayCertNames(TRUE, NULL, pCertContext->pCertInfo);
    _JumpIfError(hr, error, "cuDisplayCertNames(Cert)");

    cuDumpSerial(NULL, IDS_CERT_SERIAL, &pCertContext->pCertInfo->SerialNumber);
    wprintf(wszNewLine);

    hr = cuVerifyCertContext(
			pCertContext,	// pCert
			NULL,		// hStoreCA
			NULL,		// apszPolicies
			0,		// cPolicies
			&VerifyState);
    _JumpIfError(hr, error, "cuVerifyCertContext");

    VerifyCACert(pCertContext->pCertInfo, FALSE, &CertState);

    if (!g_fCryptSilent)
    {
	RevState = VerifyRevocation(pCertContext, NULL);
    }

error:
    cuUnloadCert(&pCertContext);
    return(hr);
}


HRESULT
VerifyCertAgainstParent(
    IN WCHAR const *pwszfnCert,
    IN WCHAR const *pwszfnCertCA,
    OUT BOOL *pfCertLoaded)
{
    HRESULT hr;
    CERT_INFO const *pCertInfo;
    CERT_INFO const *pCertInfoCA;
    CERT_CONTEXT const *pCertContext = NULL;
    CERT_CONTEXT const *pCertContextCA = NULL;
    DWORD dwFlags;
    BOOL fDisplayCANames = g_fVerbose;
    DWORD i;
    BOOL fCertInvalid = FALSE;
    DWORD RevState = RS_INCOMPLETE;
    BOOL fCheckRevocation = FALSE;
    SYSTEMTIME st;
    FILETIME ft;
    DWORD CAState;
    DWORD CertState;

    // Load and decode certificates

    *pfCertLoaded = FALSE;
    hr = cuLoadCert(pwszfnCert, &pCertContext);
    if (S_OK != hr)
    {
	if (CRYPT_E_ASN1_BADTAG != hr)
	{
	    cuPrintError(IDS_FORMAT_LOADTESTCERT, hr);
	}
	goto error;
    }
    *pfCertLoaded = TRUE;
    pCertInfo = pCertContext->pCertInfo;

    hr = cuLoadCert(pwszfnCertCA, &pCertContextCA);
    if (S_OK != hr)
    {
	cuPrintError(IDS_FORMAT_LOADCACERT, hr);
	goto error;
    }
    pCertInfoCA = pCertContextCA->pCertInfo;

    // Display name info:

    hr = cuDisplayCertNames(
			TRUE,
			myLoadResourceString(IDS_CERT), // "Cert"
			pCertInfo);
    _JumpIfError(hr, error, "cuDisplayCertNames(Cert)");

    hr = cuDisplayCertNames(
			TRUE,
			myLoadResourceString(IDS_CA), // "CA"
			pCertInfoCA);
    _JumpIfError(hr, error, "cuDisplayCertNames(CA)");

    if (g_fVerbose)
    {
	wprintf(wszNewLine);
	cuDumpSerial(NULL, IDS_CERT_SERIAL, &pCertInfo->SerialNumber);

	wprintf(wszNewLine);
	cuDumpSerial(NULL, IDS_ROOT_SERIAL, &pCertInfoCA->SerialNumber);

	wprintf(wszNewLine);
    }

    if (!CertCompareCertificateName(
		    X509_ASN_ENCODING,
		    const_cast<CERT_NAME_BLOB *>(&pCertInfoCA->Issuer),
		    const_cast<CERT_NAME_BLOB *>(&pCertInfoCA->Subject)))
    {
	// This API doesn't set LastError
	hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);

	wprintf(myLoadResourceString(IDS_FORMAT_CA_NOT_ROOT)); // "CA is not a root: Subject name does not match Issuer"
	wprintf(wszNewLine);
	wprintf(wszNewLine);
	hr = S_OK;
    }
    if (fDisplayCANames)
    {
	hr = cuDisplayCertNames(
			    TRUE,
			    myLoadResourceString(IDS_CA), // "CA"
			    pCertInfoCA);
	_JumpIfError(hr, error, "cuDisplayCertNames(CA)");
    }

    if (!CertCompareCertificateName(
			X509_ASN_ENCODING,
			const_cast<CERT_NAME_BLOB *>(&pCertInfo->Issuer),
			const_cast<CERT_NAME_BLOB *>(&pCertInfoCA->Subject)))
    {
	// This API doesn't set LastError
	hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);

	wprintf(wszNewLine);
	wprintf(
	    myLoadResourceString(IDS_FORMAT_CA_SUBJECT_NOT_ISSUER), // "ERROR: CA Subject name does not match Cert Issuer (%x)"
	    hr);
	wprintf(wszNewLine);
	wprintf(wszNewLine);
	hr = S_OK;
	fCertInvalid = TRUE;
    }
    else
    {
	wprintf(myLoadResourceString(IDS_CA_SUBJECT_IS_ISSUER)); // "CA Subject name matches Cert Issuer"
	wprintf(wszNewLine);
    }

    GetSystemTime(&st);
    if (!SystemTimeToFileTime(&st, &ft))
    {
	hr = myHLastError();
	_JumpError(hr, error, "SystemTimeToFileTime");
    }
    if (0 < CompareFileTime(&pCertInfo->NotBefore, &ft))
    {
	wprintf(wszNewLine);
	wprintf(
	    myLoadResourceString(IDS_NOWNOTBEFORE_ERROR)); // "ERROR: Cert is not yet valid"
	wprintf(wszNewLine);
	wprintf(wszNewLine);
	fCertInvalid = TRUE;
    }
    if (0 > CompareFileTime(&pCertInfo->NotAfter, &ft))
    {
	wprintf(wszNewLine);
	wprintf(
	    myLoadResourceString(IDS_NOWNOTAFTER_ERROR)); // "ERROR: Cert has expired"
	wprintf(wszNewLine);
	wprintf(wszNewLine);
	fCertInvalid = TRUE;
    }

    if (0 < CompareFileTime(&pCertInfoCA->NotBefore, &pCertInfo->NotBefore))
    {
	wprintf(wszNewLine);
	wprintf(
	    myLoadResourceString(IDS_CANOTBEFORE_ERROR)); // "ERROR: Cert Valid before CA Cert Valid"
	wprintf(wszNewLine);
	wprintf(wszNewLine);
	//fCertInvalid = TRUE;
    }
    if (0 > CompareFileTime(&pCertInfoCA->NotAfter, &pCertInfo->NotAfter))
    {
	wprintf(wszNewLine);
	wprintf(
	    myLoadResourceString(IDS_CANOTAFTER_ERROR)); // "ERROR: Cert Expires after CA Cert Expires"
	wprintf(wszNewLine);
	wprintf(wszNewLine);
	//fCertInvalid = TRUE;
    }

    VerifyCACert(pCertInfoCA, TRUE, &CAState);
    VerifyCACert(pCertInfo, FALSE, &CertState);

    hr = S_OK;

    dwFlags =
	CERT_STORE_SIGNATURE_FLAG |
	CERT_STORE_TIME_VALIDITY_FLAG;
	//CERT_STORE_REVOCATION_FLAG;

    if (g_fVerbose)
    {
	wprintf(
	    myLoadResourceString(IDS_FORMAT_CERTVERIFYSUBJECTCERTIFICATECONTEXT_FLAGS), // "CertVerifySubjectCertificateContext Flags = %x --> "
	    dwFlags);
    }

    if (!CertVerifySubjectCertificateContext(
				pCertContext,
				pCertContextCA,
				&dwFlags))
    {
	hr = myHLastError();
	if (g_fVerbose)
	{
	    wprintf(wszNewLine);
	    fflush(stdout);
	}
	_JumpError(hr, error, "CertVerifySubjectCertificateContext");
    }
    if (g_fVerbose)
    {
	wprintf(L"%x\n", dwFlags);
    }
    if (0 != dwFlags)
    {
	wprintf(wszNewLine);
	wprintf(
	    myLoadResourceString(IDS_ERR_FORMAT_VALIDATION), // "ERROR: Certificate validation failure: %x"
	    dwFlags);
	wprintf(wszNewLine);
	if (CERT_STORE_SIGNATURE_FLAG & dwFlags)
	{
	    wprintf(myLoadResourceString(IDS_ERR_CA_SIG_NOT_ISSUER)); // "ERROR: CA did not issue Certificate: Signature check failed"
	    wprintf(wszNewLine);
	}
	if (CERT_STORE_TIME_VALIDITY_FLAG & dwFlags)
	{
	    wprintf(myLoadResourceString(IDS_ERR_EXPIRED)); // "ERROR: Certificate has expired"
	    wprintf(wszNewLine);
	}
	wprintf(wszNewLine);
	//hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	fCertInvalid = TRUE;
	//goto error;
    }
    else
    {
	wprintf(myLoadResourceString(IDS_CURRENT_SIG_OK)); // "Certificate is current and signature is valid"
	wprintf(wszNewLine);
    }

    for (i = 0; i < pCertInfo->cExtension; i++)
    {
	CERT_EXTENSION *pce;

	pce = &pCertInfo->rgExtension[i];
	//wprintf(L"%d: %hs: %d, %x (%x)\n", i, pce->pszObjId, pce->fCritical, pce->Value.pbData, pce->Value.cbData);
	if (0 == strcmp(pce->pszObjId, szOID_AUTHORITY_KEY_IDENTIFIER2))
	{
	    BOOL fKeyAuthorityMatch;

	    //wprintf(L"%d: %ws\n", i, L"szOID_AUTHORITY_KEY_IDENTIFIER2");
	    hr = VerifyKeyAuthority(
			    &pCertInfo->Issuer,
			    pCertInfoCA,
			    pce->Value.pbData,
			    pce->Value.cbData,
			    &fKeyAuthorityMatch);
	    _JumpIfError(hr, error, "VerifyKeyAuthority");

	    if (!fKeyAuthorityMatch)
	    {
		fCertInvalid = TRUE;
	    }
	}
	else
	if (0 == strcmp(pce->pszObjId, szOID_KEY_ATTRIBUTES))
	{
	    //wprintf(L"%d: %ws\n", i, L"szOID_KEY_ATTRIBUTES");
	}
	else
	if (0 == strcmp(pce->pszObjId, szOID_CRL_DIST_POINTS))
	{
	    //wprintf(L"%d: %ws\n", i, L"szOID_CRL_DIST_POINTS");
	    wprintf(myLoadResourceString(IDS_CRL_DIST_POINTS)); // "Contains CRL_DIST_POINTS revocation-check extension"
	    wprintf(wszNewLine);
	    fCheckRevocation = TRUE;
	}
	else
	if (0 == strcmp(pce->pszObjId, szOID_NETSCAPE_REVOCATION_URL))
	{
	    //wprintf(L"%d: %ws\n", i, L"szOID_NETSCAPE_REVOCATION_URL");
	    wprintf(myLoadResourceString(IDS_NETSCAPE_REVOCATION_URL)); // "Contains NETSCAPE_REVOCATION_URL revocation-check extension"
	    wprintf(wszNewLine);
	    fCheckRevocation = TRUE;
	}
    }
    if (fCheckRevocation)
    {
	if (!g_fCryptSilent)
	{
	    RevState = VerifyRevocation(pCertContext, pCertContextCA);
	}
    }
    else
    {
	wprintf(myLoadResourceString(IDS_NO_REVCHECKEXTENSION)); // "Certificate has no revocation-check extension"
	wprintf(wszNewLine);
	RevState = RS_INCOMPLETE;
    }

error:
    cuUnloadCert(&pCertContext);
    cuUnloadCert(&pCertContextCA);
    if (S_OK == hr)
    {
	DWORD msgid;

	wprintf(wszNewLine);
	wprintf(
	    myLoadResourceString(
		    fCertInvalid?
			IDS_FORMAT_NOT_VERIFY : // "%ws does NOT verify as issued by %ws"
			IDS_FORMAT_IS_VERIFY), // "%ws verifies as issued by %ws"
	    pwszfnCert,
	    pwszfnCertCA);

	switch (RevState)
	{
	    case RS_FAIL:
		msgid = IDS_FORMAT_REVCHECK_FAIL;	// " -- Revocation check FAILED."
		break;

	    case RS_PASS:
		msgid = IDS_FORMAT_REVCHECK_PASS;	// " -- Revocation check passed."
		break;

	    case RS_REVOKED:
		msgid = IDS_FORMAT_REVCHECK_REVOKED;	// " -- Revocation check: REVOKED."
		break;

	    default:
		msgid = IDS_FORMAT_REVCHECK_SKIPPED;	// " -- Revocation check skipped."
		break;
	}
	wprintf(myLoadResourceString(msgid));
	wprintf(wszNewLine);
	if (fCertInvalid)
	{
	    hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	}
    }
    return(hr);
}


HRESULT
VerifyCRLAgainstCACert(
    IN WCHAR const *pwszfnCRL,
    IN WCHAR const *pwszfnCertCA)
{
    HRESULT hr;
    CRL_CONTEXT const *pCRLContext = NULL;
    CERT_CONTEXT const *pCertContextCA = NULL;
    CRL_INFO const *pCRLInfo;
    CERT_INFO const *pCertInfoCA;
    BOOL fDisplayCANames = g_fVerbose;
    DWORD i;
    BOOL fCRLInvalid = FALSE;
    SYSTEMTIME st;
    FILETIME ft;

    // Load and decode CRL and certificate

    hr = cuLoadCRL(pwszfnCRL, &pCRLContext);
    if (S_OK != hr)
    {
	cuPrintError(IDS_FORMAT_LOADTESTCRL, hr);
	goto error;
    }
    pCRLInfo = pCRLContext->pCrlInfo;

    hr = cuLoadCert(pwszfnCertCA, &pCertContextCA);
    if (S_OK != hr)
    {
	cuPrintError(IDS_FORMAT_LOADCACERT, hr);
	goto error;
    }
    pCertInfoCA = pCertContextCA->pCertInfo;

    // Display name info:

    hr = cuDisplayCertName(
			TRUE,
			myLoadResourceString(IDS_CRL), // "CRL"
			myLoadResourceString(IDS_ISSUER), // "Issuer"
			g_wszPad4,
			&pCRLInfo->Issuer);
    _JumpIfError(hr, error, "cuDisplayCertName(CRL Issuer)");

    hr = cuDisplayCertNames(
			TRUE,
			myLoadResourceString(IDS_CA), // "CA"
			pCertInfoCA);
    _JumpIfError(hr, error, "cuDisplayCertNames(CA)");

    if (g_fVerbose)
    {
	//wprintf(wszNewLine);
	//cuDumpSerial(NULL, IDS_CERT_SERIAL, &pCRLInfo->SerialNumber);

	wprintf(wszNewLine);
	cuDumpSerial(NULL, IDS_ROOT_SERIAL, &pCertInfoCA->SerialNumber);

	wprintf(wszNewLine);
    }

    if (!CertCompareCertificateName(
			X509_ASN_ENCODING,
			const_cast<CERT_NAME_BLOB *>(&pCertInfoCA->Issuer),
			const_cast<CERT_NAME_BLOB *>(&pCertInfoCA->Subject)))
    {
	// This API doesn't set LastError
	hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);

	wprintf(myLoadResourceString(IDS_FORMAT_CA_NOT_ROOT)); // "CA is not a root: Subject name does not match Issuer"
	wprintf(wszNewLine);
	wprintf(wszNewLine);
	hr = S_OK;
    }
    if (fDisplayCANames)
    {
	hr = cuDisplayCertNames(
			    TRUE,
			    myLoadResourceString(IDS_CA), // "CA"
			    pCertInfoCA);
	_JumpIfError(hr, error, "cuDisplayCertNames(CA)");
    }

    if (!CertCompareCertificateName(
			X509_ASN_ENCODING,
			const_cast<CERT_NAME_BLOB *>(&pCRLInfo->Issuer),
			const_cast<CERT_NAME_BLOB *>(&pCertInfoCA->Subject)))
    {
	// This API doesn't set LastError
	hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);

	wprintf(wszNewLine);
	wprintf(
	    myLoadResourceString(IDS_FORMAT_CA_CRLSUBJECT_NOT_ISSUER), // "ERROR: CA Subject name does not match CRL Issuer (%x)"
	    hr);
	wprintf(wszNewLine);
	wprintf(wszNewLine);
	hr = S_OK;
	fCRLInvalid = TRUE;
    }
    else
    {
	wprintf(myLoadResourceString(IDS_CA_CRLSUBJECT_IS_ISSUER)); // "CA Subject name matches CRL Issuer"
	wprintf(wszNewLine);
    }

    GetSystemTime(&st);
    if (!SystemTimeToFileTime(&st, &ft))
    {
	hr = myHLastError();
	_JumpError(hr, error, "SystemTimeToFileTime");
    }
    if (0 < CompareFileTime(&pCRLInfo->ThisUpdate, &ft))
    {
	wprintf(wszNewLine);
	wprintf(
	    myLoadResourceString(IDS_NOWNOTBEFORECRL_ERROR)); // "ERROR: CRL is not yet valid"
	wprintf(wszNewLine);
	wprintf(wszNewLine);
	fCRLInvalid = TRUE;
    }
    if ((0 != pCRLInfo->NextUpdate.dwLowDateTime ||
	 0 != pCRLInfo->NextUpdate.dwHighDateTime) &&
	0 > CompareFileTime(&pCRLInfo->NextUpdate, &ft))
    {
	wprintf(wszNewLine);
	wprintf(
	    myLoadResourceString(IDS_NOWNOTAFTERCRL_ERROR)); // "ERROR: CRL has expired"
	wprintf(wszNewLine);
	wprintf(wszNewLine);
	fCRLInvalid = TRUE;
    }

    if (0 < CompareFileTime(&pCertInfoCA->NotBefore, &pCRLInfo->ThisUpdate))
    {
	wprintf(wszNewLine);
	wprintf(
	    myLoadResourceString(IDS_CANOTBEFORECRL_ERROR)); // "ERROR: CRL Valid before CA Cert Valid"
	wprintf(wszNewLine);
	wprintf(wszNewLine);
	//fCRLInvalid = TRUE;
    }
    if ((0 != pCRLInfo->NextUpdate.dwLowDateTime ||
	 0 != pCRLInfo->NextUpdate.dwHighDateTime) &&
	0 > CompareFileTime(&pCertInfoCA->NotAfter, &pCRLInfo->NextUpdate))
    {
	wprintf(wszNewLine);
	wprintf(
	    myLoadResourceString(IDS_CANOTAFTERCRL_ERROR)); // "ERROR: CRL Expires after CA Cert Expires"
	wprintf(wszNewLine);
	wprintf(wszNewLine);
	//fCRLInvalid = TRUE;
    }

    // verify CRL signature with the CA Cert public key

    if (CryptVerifyCertificateSignature(
			NULL,
			X509_ASN_ENCODING,
			pCRLContext->pbCrlEncoded,
			pCRLContext->cbCrlEncoded,
			&pCertContextCA->pCertInfo->SubjectPublicKeyInfo))
    {
	wprintf(myLoadResourceString(IDS_CRL_SIG_OK)); // "CRL signature is valid"
	wprintf(wszNewLine);
    }
    else
    {
	hr = myHLastError();
	_PrintError(hr, "CryptVerifyCertificateSignature");
	wprintf(myLoadResourceString(IDS_ERR_CA_SIG_NOT_CRLISSUER)); // "ERROR: CA did not issue CRL: Signature check failed"
	wprintf(wszNewLine);
	fCRLInvalid = TRUE;
    }

    for (i = 0; i < pCRLInfo->cExtension; i++)
    {
	CERT_EXTENSION *pce;

	pce = &pCRLInfo->rgExtension[i];
	//wprintf(L"%d: %hs: %d, %x (%x)\n", i, pce->pszObjId, pce->fCritical, pce->Value.pbData, pce->Value.cbData);
	if (0 == strcmp(pce->pszObjId, szOID_AUTHORITY_KEY_IDENTIFIER2))
	{
	    BOOL fKeyAuthorityMatch;

	    //wprintf(L"%d: %ws\n", i, L"szOID_AUTHORITY_KEY_IDENTIFIER2");

	    hr = VerifyKeyAuthority(
			    &pCRLInfo->Issuer,
			    pCertInfoCA,
			    pce->Value.pbData,
			    pce->Value.cbData,
			    &fKeyAuthorityMatch);
	    _JumpIfError(hr, error, "VerifyKeyAuthority");

	    if (!fKeyAuthorityMatch)
	    {
		fCRLInvalid = TRUE;
	    }
	}
    }

error:
    cuUnloadCRL(&pCRLContext);
    cuUnloadCert(&pCertContextCA);
    if (S_OK == hr)
    {
	DWORD msgid;

	wprintf(wszNewLine);
	wprintf(
	    myLoadResourceString(
		    fCRLInvalid?
			IDS_FORMAT_NOT_VERIFY : // "%ws does NOT verify as issued by %ws"
			IDS_FORMAT_IS_VERIFY), // "%ws verifies as issued by %ws"
	    pwszfnCRL,
	    pwszfnCertCA);
	wprintf(wszNewLine);
	if (fCRLInvalid)
	{
	    hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	}
    }
    return(hr);
}


HRESULT
verbVerifyCert(
    IN WCHAR const *pwszOption,
    IN WCHAR const *pwszfnCert,
    IN WCHAR const *pwszfnCertCA,
    IN WCHAR const *pwszArg3,
    IN WCHAR const *pwszArg4)
{
    HRESULT hr;
    BOOL fCertLoaded;

    if (NULL != pwszfnCertCA)
    {
	hr = VerifyCertAgainstParent(pwszfnCert, pwszfnCertCA, &fCertLoaded);
	if (S_OK != hr && !fCertLoaded)
	{
	    hr = VerifyCRLAgainstCACert(pwszfnCert, pwszfnCertCA);
	}
    }
    else
    {
	hr = VerifyCertAgainstChain(pwszfnCert);
    }
    return(hr);
}


DWORD amsgidState[CHECK7F_COUNT] = {
    //IDS_CHECK7F_FIELD_UNKNOWN,		// "???"
    IDS_CHECK7F_FIELD_NONE,			// "None"
    IDS_CHECK7F_FIELD_OTHER,			// "Other"
    IDS_CHECK7F_FIELD_ISSUER,			// "Issuer"
    IDS_CHECK7F_FIELD_ISSUERRDN,		// "IssuerRDN"
    IDS_CHECK7F_FIELD_ISSUERRDNATTRIBUTE,	// "IssuerRDNAttribute"
    IDS_CHECK7F_FIELD_ISSUERRDNSTRING,		// "IssuerRDNString"
    IDS_CHECK7F_FIELD_SUBJECT,			// "Subject"
    IDS_CHECK7F_FIELD_SUBJECTRDN,		// "SubjectRDN"
    IDS_CHECK7F_FIELD_SUBJECTRDNATTRIBUTE,	// "SubjectRDNAttribute"
    IDS_CHECK7F_FIELD_SUBJECTRDNSTRING,		// "SubjectRDNString"
    IDS_CHECK7F_FIELD_EXTENSIONS,		// "Extensions"
    IDS_CHECK7F_FIELD_EXTENSIONARRAY,		// "ExtensionArray"
    IDS_CHECK7F_FIELD_EXTENSION,		// "Extension"
    IDS_CHECK7F_FIELD_EXTENSIONVALUE,		// "ExtensionValue"
    IDS_CHECK7F_FIELD_EXTENSIONVALUERAW,	// "ExtensionValueRaw"
};


HRESULT
verbCheck7f(
    IN WCHAR const *pwszOption,
    IN WCHAR const *pwszfnCert,
    IN WCHAR const *pwszArg2,
    IN WCHAR const *pwszArg3,
    IN WCHAR const *pwszArg4)
{
    HRESULT hr;
    CERT_CONTEXT const *pCertContext = NULL;
    CERT_INFO const *pCertInfo;
    WCHAR const *pwszObjectIdDescription = NULL;
    DWORD i;
    DWORD dwLen;
    DWORD index;
    DWORD index2;
    DWORD state;
    DWORD cwcField;
    DWORD cwcObjectId;
    WCHAR wszField[128];
    WCHAR wszObjectId[40];

    // Load and decode certificates

    hr = cuLoadCert(pwszfnCert, &pCertContext);
    if (S_OK != hr)
    {
	cuPrintError(IDS_FORMAT_LOADTESTCERT, hr);
	goto error;
    }
    pCertInfo = pCertContext->pCertInfo;

    if (g_fVerbose)
    {
	wprintf(wszNewLine);
	wprintf(myLoadResourceString(IDS_CERTCOLON)); // "Cert:"
	wprintf(wszNewLine);
	DumpHex(0, pCertContext->pbCertEncoded, pCertContext->cbCertEncoded);

	// Display name info:

	hr = cuDisplayCertNames(
			    TRUE,
			    myLoadResourceString(IDS_CERT), // "Cert"
			    pCertInfo);
	_JumpIfError(hr, error, "cuDisplayCertNames(Cert)");
    }

    cwcField = sizeof(wszField)/sizeof(wszField[0]);
    cwcObjectId = sizeof(wszObjectId)/sizeof(wszObjectId[0]);
    hr = myCheck7f(
		pCertContext->pbCertEncoded,
		pCertContext->cbCertEncoded,
		g_fVerbose,
		&state,
		&index,
		&index2,
		&cwcField,
		wszField,
		&cwcObjectId,
		wszObjectId,
		&pwszObjectIdDescription);
    _JumpIfError(hr, error, "myCheck7f");

    if (CHECK7F_NONE != state)
    {
	DWORD msgid = IDS_CHECK7F_FIELD_UNKNOWN; // "???"
	
	CSASSERT(0 != amsgidState[CHECK7F_COUNT - 1]);
	if (CHECK7F_COUNT > state)
	{
	    msgid = amsgidState[state];
	}
	CSASSERT(0 != msgid);
	wprintf(myLoadResourceString(IDS_FORMAT_SUSPECT_LENGTH)); // "Suspect length in"
	wprintf(myLoadResourceString(msgid));
	if (0 != index)
	{
	    wprintf(
		0 != index2? L"[%u,%u]" : L"[%u]",
		index - 1,
		index2 - 1);
	}
	wprintf(L": field=%ws", wszField);
	wprintf(
	    myLoadResourceString(IDS_FORMAT_FIELD), // ": field=%ws"
	    wszField);
	if (0 != index)
	{
	    wprintf(
		0 != index2? L"[%u,%u]" : L"[%u]",
		index - 1,
		index2 - 1);
	}
	if (L'\0' != wszObjectId[0])
	{
	    wprintf(
		myLoadResourceString(IDS_FORMAT_OID), // ", oid=%ws"
		wszObjectId);
	}
	if (NULL != pwszObjectIdDescription)
	{
	    wprintf(L" (%ws)", pwszObjectIdDescription);
	}
	wprintf(wszNewLine);
	hr = CERTSRV_E_ENCODING_LENGTH;
    }

    for (i = 0; i < pCertInfo->cExtension; i++)
    {
	CERT_EXTENSION *pce;
	WCHAR const *pwszDescriptiveName;

	pce = &pCertInfo->rgExtension[i];
	if (g_fVerbose)
	{
	    wprintf(wszNewLine);
	    wprintf(
		myLoadResourceString(IDS_FORMAT_EXTENSION_OID), // "Extension %d: oid=""%hs"" fcrit=%u length=%x"
		i,
		pce->pszObjId,
		pce->fCritical,
		pce->Value.cbData);
		
	    pwszDescriptiveName = cuGetOIDNameA(pce->pszObjId);
	    if (NULL != pwszDescriptiveName)
	    {
		wprintf(L" (%ws)", pwszDescriptiveName);
	    }
	    wprintf(wszNewLine);
	    DumpHex(0, pce->Value.pbData, pce->Value.cbData);
	}
    }

error:
    cuUnloadCert(&pCertContext);
    return(hr);
}


HRESULT
cuVerifySignature(
    IN BYTE const *pbEncoded,
    IN DWORD cbEncoded,
    IN CERT_PUBLIC_KEY_INFO const *pcpki,
    IN BOOL fSuppressError)
{
    HRESULT hr;
    DWORD id = 0;

    // verify with the passed public key
    if (!CryptVerifyCertificateSignature(
			    NULL,
			    X509_ASN_ENCODING,
			    const_cast<BYTE *>(pbEncoded),
			    cbEncoded,
			    const_cast<CERT_PUBLIC_KEY_INFO *>(pcpki)))
    {
	hr = myHLastError();
	if (E_INVALIDARG == hr)
	{
	    CRYPT_DATA_BLOB Blob;

	    Blob.cbData = cbEncoded;
	    Blob.pbData = const_cast<BYTE *>(pbEncoded);
	    if (!CryptVerifyCertificateSignatureEx(
				    NULL,	// hCryptProv
				    X509_ASN_ENCODING,
				    CRYPT_VERIFY_CERT_SIGN_SUBJECT_BLOB,
				    &Blob,
				    CRYPT_VERIFY_CERT_SIGN_ISSUER_NULL,
				    NULL,	// pvIssuer
				    0,		// dwFlags
				    NULL))	// pvReserved
	    {
		HRESULT hr2 = myHLastError();

		_PrintError(hr2, "CryptVerifyCertificateSignatureEx");
	    }
	    else
	    {
		hr = S_OK;
		id = IDS_NULL_SIGNATUREMATCHES; // "NULL signature verifies"
	    }
	}
	if (S_OK != hr && !fSuppressError)
	{
	    id = IDS_ERR_FORMAT_NO_SIGNATUREMATCHES; // "Signature does not match Public key: %x"
	}
    }
    else
    {
	hr = S_OK;
	id = IDS_SIGNATUREMATCHES;	// "Signature matches Public Key"
    }
    if (0 != id)
    {
	wprintf(myLoadResourceString(id), hr);
	wprintf(wszNewLine);
    }
    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\tools\certut\scinfo.cpp ===
//+-------------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (C) Microsoft Corporation, 1996 - 2001
//
// File:       scinfo.cpp
//
// Abstract:
//
// This application is used to provide a snapshot of the Calais (Smart Card
// Resource Manager) service's status, and to display certificates on smart
// cards via the common WinNT UI.
//
// SCInfo -- describes the RM status and displays each available sc cert(s)
//
// The following options are always enabled:
//	Readername	-- for just one reader
//	-sig		-- display signature key certs only
//	-ex		-- display exchange key certs only
//	-nocert		-- don't look for certs to display
//	-key		-- verify keyset public key matches cert public key
//
// Author: Amanda Matlosz (AMatlosz) 07/14/1998
//
// Environment: Win32 Console App
//
// Notes: For use in NT5 public key rollout testing
//
// Need to include the following libs:
//	winscard.lib
//
//--------------------------------------------------------------------------

#include <pch.cpp>

#pragma hdrstop

#include <winscard.h>
#include <winsvc.h>
#include <cryptui.h>


#define szOID_KERB_PKINIT_CLIENT_CERT_TYPE szOID_PKIX_KP_CLIENT_AUTH
#define wszSCARDSERVICE	L"SCardSvr"


//+-------------------------------------------------------------------------
// IsSCardSvrRunning checks the registry and queries the service for status
//--------------------------------------------------------------------------

HRESULT
IsSCardSvrRunning()
{
    HRESULT hr;
    SC_HANDLE hSCM = NULL;
    SC_HANDLE hService = NULL;
    SERVICE_STATUS ssStatus;		// current status of the service
    WCHAR const *pwszError = NULL;
    UINT idmsg = IDS_SMARTCARD_NOTRUNNING; // "The Microsoft Smart Card Resource Manager is not running."
    UINT idmsg2 = 0;

    // BUGBUG: call winscard.dll!SCardAccessStartedEvent instead?

    hSCM = OpenSCManager(
		    NULL,		// machine (NULL == local)
		    NULL,		// database (NULL == default)
		    SC_MANAGER_CONNECT);	// access required
    if (NULL == hSCM)
    {
	hr = myHLastError();
	pwszError = L"OpenSCManager";
	_JumpError(hr, error, "OpenSCManager");
    }
    hService = OpenService(hSCM, wszSCARDSERVICE, SERVICE_QUERY_STATUS);
    if (NULL == hService)
    {
	hr = myHLastError();
	pwszError = L"OpenService";
	_JumpError(hr, error, "OpenService");
    }
    if (!QueryServiceStatus(hService, &ssStatus))
    {
	hr = myHLastError();
	pwszError = L"QueryServiceStatus";
	_JumpError(hr, error, "QueryServiceStatus");
    }

    hr = HRESULT_FROM_WIN32(ERROR_INVALID_STATE);
    pwszError = wszSCARDSERVICE;
    switch (ssStatus.dwCurrentState)
    {
	case SERVICE_CONTINUE_PENDING:
	case SERVICE_PAUSE_PENDING:
	case SERVICE_PAUSED:
	    idmsg2 = IDS_SERVICEPAUSED; // "Service is paused.";
	    _JumpError(hr, error, "Service paused");

	case SERVICE_START_PENDING:
	case SERVICE_STOP_PENDING:
	case SERVICE_STOPPED:
	    idmsg2 = IDS_SERVICESTOPPED; // "Service is stopped.";
	    _JumpError(hr, error, "Service stopped");

	case SERVICE_RUNNING:
	    break;

	default:
	    idmsg2 = IDS_SERVICEUNKNOWNSTATE; // "Service is in an unknown state.";
	    _JumpError(hr, error, "Service state unknown");
    }
    idmsg = IDS_SMARTCARD_RUNNING; // "The Microsoft Smart Card Resource Manager is running."
    hr = S_OK;

error:

    // Display status

    wprintf(myLoadResourceString(idmsg));
    wprintf(wszNewLine);
    if (S_OK != hr)
    {
	cuPrintErrorAndString(
			pwszError,
			idmsg2,
			hr,
			NULL);
    }
    if (NULL != hService)
    {
        CloseServiceHandle(hService);
    }
    if (NULL != hSCM)
    {
        CloseServiceHandle(hSCM);
    }
    return(hr);
}


VOID
FreeReaderList(
    IN SCARDCONTEXT hSCard,
    IN WCHAR *pwszzReaderNameAlloc,
    IN SCARD_READERSTATE *prgReaderState)
{
    if (NULL != hSCard)
    {
	if (NULL != pwszzReaderNameAlloc)
	{
	    SCardFreeMemory(hSCard, pwszzReaderNameAlloc);
	}
        SCardReleaseContext(hSCard);
    }
    if (NULL != prgReaderState)
    {
	LocalFree(prgReaderState);
    }
}


//+-------------------------------------------------------------------------
// BuildReaderList tries to set *phSCard and get a list of currently available
// smart card readers.
//--------------------------------------------------------------------------

HRESULT
BuildReaderList(
    OPTIONAL IN WCHAR const *pwszReaderName,
    OUT SCARDCONTEXT *phSCard,
    OUT WCHAR **ppwszzReaderNameAlloc,
    OUT SCARD_READERSTATE **pprgReaderState,
    OUT DWORD *pcReaders)
{
    HRESULT hr;
    DWORD i;
    DWORD dwAutoAllocate;
    SCARDCONTEXT hSCard = NULL;
    WCHAR *pwszzReaderNameAlloc = NULL;
    SCARD_READERSTATE *prgReaderState = NULL;
    DWORD cReaders;

    *phSCard = NULL;
    *ppwszzReaderNameAlloc = NULL;
    *pcReaders = 0;
    *pprgReaderState = NULL;

    wprintf(L"Current reader/card status:\n");

    // Acquire global SCARDCONTEXT from resource manager if possible

    hr = SCardEstablishContext(SCARD_SCOPE_USER, NULL, NULL, &hSCard);
    if (S_OK != hr)
    {
	wprintf(L"SCardEstablishContext failed for user scope.\n");
	wprintf(L"A list of smart card readers cannot be determined.\n");
	_JumpError(hr, error, "SCardEstablishContext");
    }

    // Build a readerstatus array from either a list of readers; or use the one
    // the user specified

    cReaders = 1;
    if (NULL == pwszReaderName)
    {
	dwAutoAllocate = SCARD_AUTOALLOCATE;
	hr = SCardListReaders(
			    hSCard,
			    SCARD_DEFAULT_READERS,
			    (WCHAR *) &pwszzReaderNameAlloc,
			    &dwAutoAllocate);
	if (S_OK != hr)
	{
	    wprintf(
		L"SCardListReaders failed for SCARD_ALL_READERS with 0x%x\n",
		hr);

	    if (SCARD_E_NO_READERS_AVAILABLE == hr)
	    {
		wprintf(L"No smart card readers are currently available.\n");
	    }
	    else
	    {
		wprintf(L"A list of smart card readers could not be determined.\n");
	    }
	    _JumpError(hr, error, "SCardListReaders");
	}

	// Build a readerstatus array...

	cReaders = 0;
	if (NULL != pwszzReaderNameAlloc)
	{
	    for (
		pwszReaderName = pwszzReaderNameAlloc;
		L'\0' != *pwszReaderName;
		pwszReaderName += wcslen(pwszReaderName) + 1)
	    {
		cReaders++;
	    }
	}
	pwszReaderName = pwszzReaderNameAlloc;
    }
    prgReaderState = (SCARD_READERSTATE *) LocalAlloc(
				LMEM_FIXED | LMEM_ZEROINIT,
				cReaders * sizeof(**pprgReaderState));
    if (NULL == prgReaderState)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }

    wprintf(L"Readers: %u\n", cReaders);
    for (i = 0; i < cReaders; i++)
    {
	wprintf(L"  %u: %ws\n", i, pwszReaderName);
	prgReaderState[i].szReader = const_cast<WCHAR *>(pwszReaderName);
	prgReaderState[i].dwCurrentState = SCARD_STATE_UNAWARE;
	pwszReaderName += wcslen(pwszReaderName) + 1;
    }

    // ...And get the reader status from the resource manager

    hr = SCardGetStatusChange(
			hSCard,
			INFINITE,	// hardly
			prgReaderState,
			cReaders);
    if (S_OK != hr)
    {
	wprintf(L"SCardGetStatusChange failed with 0x%x\n", hr);
	_JumpError(hr, error, "SCardGetStatusChange");
    }
    *phSCard = hSCard;
    hSCard = NULL;

    *ppwszzReaderNameAlloc = pwszzReaderNameAlloc;
    pwszzReaderNameAlloc = NULL;

    *pprgReaderState = prgReaderState;
    prgReaderState = NULL;

    *pcReaders = cReaders;
    hr = S_OK;

error:
    FreeReaderList(hSCard, pwszzReaderNameAlloc, prgReaderState);
    return(hr);
}


//+-------------------------------------------------------------------------
// DisplayReaderList displays the status for a list of readers.
//--------------------------------------------------------------------------

HRESULT
DisplayReaderList(
    IN SCARDCONTEXT hSCard,
    IN SCARD_READERSTATE const *prgReaderState,
    IN DWORD cReaders)
{
    HRESULT hr;
    DWORD i;
    DWORD dwAutoAllocate;

    // Display all reader information

    for (i = 0; i < cReaders; i++)
    {
	DWORD dwState;
	WCHAR const *pwszSep;
	static WCHAR const s_wszSep[] = L" | ";

	//--- reader: readerName

	wprintf(L"--- Reader: %ws\n", prgReaderState[i].szReader);

	//--- status: /bits/

	wprintf(L"--- Status:");
	dwState = prgReaderState[i].dwEventState;

	pwszSep = L" ";
	if (SCARD_STATE_UNKNOWN & dwState)
	{
	    wprintf(L"%wsSCARD_STATE_UNKNOWN", pwszSep);
	    pwszSep = s_wszSep;
	}
	if (SCARD_STATE_UNAVAILABLE & dwState)
	{
	    wprintf(L"%wsSCARD_STATE_UNAVAILABLE", pwszSep);
	    pwszSep = s_wszSep;
	}
	if (SCARD_STATE_EMPTY & dwState)
	{
	    wprintf(L"%wsSCARD_STATE_EMPTY", pwszSep);
	    pwszSep = s_wszSep;
	}
	if (SCARD_STATE_PRESENT & dwState)
	{
	    wprintf(L"%wsSCARD_STATE_PRESENT", pwszSep);
	    pwszSep = s_wszSep;
	}
	if (SCARD_STATE_EXCLUSIVE & dwState)
	{
	    wprintf(L"%wsSCARD_STATE_EXCLUSIVE", pwszSep);
	    pwszSep = s_wszSep;
	}
	if (SCARD_STATE_INUSE & dwState)
	{
	    wprintf(L"%wsSCARD_STATE_INUSE", pwszSep);
	    pwszSep = s_wszSep;
	}
	if (SCARD_STATE_MUTE & dwState)
	{
	    wprintf(L"%wsSCARD_STATE_MUTE", pwszSep);
	    pwszSep = s_wszSep;
	}
	if (SCARD_STATE_UNPOWERED & dwState)
	{
	    wprintf(L"%wsSCARD_STATE_UNPOWERED", pwszSep);
	}
	wprintf(L"\n");

	//--- status: what scstatus would say

	wprintf(L"--- Status: ");

	// NO CARD

	if (SCARD_STATE_EMPTY & dwState)
	{
	    wprintf(L"No card.");// SC_STATUS_NO_CARD;
	}

	// CARD in reader: SHARED, EXCLUSIVE, FREE, UNKNOWN ?

	else
	if (SCARD_STATE_PRESENT & dwState)
	{
	    if (SCARD_STATE_MUTE & dwState)
	    {
		// SC_STATUS_UNKNOWN;

		wprintf(
		    L"The card is unrecognized or not responding.");
	    }
	    else
	    if (SCARD_STATE_INUSE & dwState)
	    {
		if (dwState & SCARD_STATE_EXCLUSIVE & dwState)
		{
		    // SC_STATUS_EXCLUSIVE

		    wprintf(L"Card is in use exclusively by another process.");
		}
		else
		{
		    // SC_STATUS_SHARED

		    wprintf(L"The card is being shared by a process.");
		}
	    }
	    else
	    {
		// SC_SATATUS_AVAILABLE

		wprintf(L"The card is available for use.");
	    }
	}
	// READER ERROR: at this point, something's gone wrong
	else	// dwState & SCARD_STATE_UNAVAILABLE
	{
	    // SC_STATUS_ERROR;

	    wprintf(L"Card/Reader not responding.");
	}
	wprintf(L"\n");

	//- card name(s):

	wprintf(L"---   Card:");
	if (0 < prgReaderState[i].cbAtr)
	{
	    WCHAR *pwszCardName = NULL;

	    // Get the name of the card

	    dwAutoAllocate = SCARD_AUTOALLOCATE;
	    hr = SCardListCards(
			    hSCard,
			    prgReaderState[i].rgbAtr,
			    NULL,
			    0,
			    (WCHAR *) &pwszCardName,
			    &dwAutoAllocate);
	    if (S_OK != hr || NULL == pwszCardName)
	    {
		wprintf(L"Unknown Card.");
	    }
	    else
	    {
		WCHAR const *pwszName;

		pwszSep = L"";
		for (
		    pwszName = pwszCardName;
		    L'\0' != *pwszName;
		    pwszName += wcslen(pwszName) + 1)
		{
		    wprintf(L"%ws %ws", pwszSep, pwszName);
		    pwszSep = L",";
		}
	    }
	    if (NULL != pwszCardName)
	    {
		SCardFreeMemory(hSCard, pwszCardName);
	    }
	}
	wprintf(L"\n");
    }
    hr = S_OK;

//error:
    return(hr);
}


HRESULT
myCryptGetProvParamToUnicode(
    IN HCRYPTPROV hProv,
    IN DWORD dwParam,
    OUT WCHAR **ppwszOut,
    IN DWORD dwFlags)
{
    HRESULT hr;
    char *psz = NULL;
    DWORD cb;

    *ppwszOut = NULL;
    if (!CryptGetProvParam(hProv, dwParam, NULL, &cb, 0))
    {
	hr = myHLastError();
	_JumpError(hr, error, "CryptGetProvParam");
    }

    psz = (char *) LocalAlloc(LMEM_FIXED, cb);
    if (NULL == psz)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }
    if (!CryptGetProvParam(hProv, dwParam, (BYTE *) psz, &cb, 0))
    {
	hr = myHLastError();
	_JumpError(hr, error, "CryptGetProvParam");
    }

    if (!myConvertSzToWsz(ppwszOut, psz, -1))
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "myConvertSzToWsz");
    }
    hr = S_OK;

error:
    if (NULL != psz)
    {
        LocalFree(psz);
    }
    return(hr);
}


//+-------------------------------------------------------------------------
// GetCertContext -- called by DisplayCerts
//--------------------------------------------------------------------------

HRESULT
GetCertContext(
    IN HCRYPTPROV hProv,
    IN HCRYPTKEY hKey,
    IN DWORD dwKeySpec,
    IN WCHAR const *pwszKeyType,
    OUT CERT_CONTEXT const **ppCert)
{
    HRESULT hr;
    CERT_CONTEXT const *pCert = NULL;
    CERT_PUBLIC_KEY_INFO *pKey = NULL;
    CRYPT_KEY_PROV_INFO KeyProvInfo;
    WCHAR *pwszContainerName = NULL;
    WCHAR *pwszProvName = NULL;
    BYTE *pbCert = NULL;
    DWORD cbCert;
    DWORD cbKey;

    *ppCert = NULL;

    // Get the cert from this key

    if (!CryptGetKeyParam(hKey, KP_CERTIFICATE, NULL, &cbCert, 0))
    {
        hr = myHLastError();
        if (HRESULT_FROM_WIN32(ERROR_MORE_DATA) != hr)
        {
            _JumpError(hr, error, "CryptGetKeyParam");
        }
    }
    pbCert = (BYTE *) LocalAlloc(LMEM_FIXED, cbCert);
    if (NULL == pbCert)
    {
        hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }
    if (!CryptGetKeyParam(hKey, KP_CERTIFICATE, pbCert, &cbCert, 0))
    {
        hr = myHLastError();
	_JumpError(hr, error, "CryptGetKeyParam");
    }

    // Convert the certificate into a Cert Context.

    pCert = CertCreateCertificateContext(
				    X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
				    pbCert,
				    cbCert);
    if (NULL == pCert)
    {
        hr = myHLastError();
        _JumpError(hr, error, "CertCreateCertificateContext");
    }

    // BUGBUG: move to after CertSetCertificateContextProperty?

    hr = cuDumpCertKeyProviderInfo(g_wszPad2, pCert, NULL, NULL);
    _PrintIfError(hr, "cuDumpCertKeyProviderInfo");

    // Perform public key check

    wprintf(L"\nPerforming %ws public key matching test...\n", pwszKeyType);

    if (!CryptExportPublicKeyInfo(
		    hProv,
		    dwKeySpec,
		    X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
		    NULL,
		    &cbKey))		// in, out
    {
	hr = myHLastError();
	wprintf(L"CryptExportPublicKeyInfo failed: 0x%x\n ", hr);
	_JumpError(hr, error, "CryptExportPublicKeyInfo");
    }
    if (0 == cbKey)
    {
	hr = SCARD_E_UNEXPECTED;	// huh?
	wprintf(L"CryptExportPublicKeyInfo succeeded but returned size==0\n");
	_JumpError(hr, error, "zero info size");
    }

    pKey = (CERT_PUBLIC_KEY_INFO *) LocalAlloc(LMEM_FIXED, cbKey);
    if (NULL == pKey)
    {
	hr = E_OUTOFMEMORY;
	wprintf(L"Could not complete key test; out of memory\n");
	_JumpError(hr, error, "LocalAlloc");
    }

    if (!CryptExportPublicKeyInfo(
			    hProv,
			    dwKeySpec,
			    X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
			    pKey,
			    &cbKey))
    {
	hr = myHLastError();
	wprintf(L"CryptExportPublicKeyInfo failed: 0x%x\n ", hr);
	_JumpError(hr, error, "CryptExportPublicKeyInfo");
    }

    if (!CertComparePublicKeyInfo(
	  X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
	  pKey,			// from the private keyset
	  &pCert->pCertInfo->SubjectPublicKeyInfo))	// cert public key
    {
	wprintf(L"\nPublic key from KeyProvInfo container:\n");
	cuDumpPublicKey(pKey);
	wprintf(L"\nPublic key from Cert:\n");
	cuDumpPublicKey(&pCert->pCertInfo->SubjectPublicKeyInfo);

	// by design, CertComparePublicKeyInfo doesn't set last error!

	hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	_JumpError(hr, error, "CertComparePublicKeyInfo");
    }
    wprintf(L"Public key matching test succeeded\n");

    // Associate cryptprovider w/ the private key property of this cert
    // ... need the container name

    hr = myCryptGetProvParamToUnicode(
			hProv,
			PP_CONTAINER,
			&pwszContainerName,
			0);
    _JumpIfError(hr, error, "myCryptGetProvParamToUnicode");

    //  ... need the provider name

    hr = myCryptGetProvParamToUnicode(hProv, PP_NAME, &pwszProvName, 0);
    _JumpIfError(hr, error, "myCryptGetProvParamToUnicode");

    // Set the cert context properties to reflect the prov info

    KeyProvInfo.pwszContainerName = pwszContainerName;
    KeyProvInfo.pwszProvName = pwszProvName;
    KeyProvInfo.dwProvType = PROV_RSA_FULL;
    KeyProvInfo.dwFlags = CERT_SET_KEY_CONTEXT_PROP_ID;
    KeyProvInfo.cProvParam = 0;
    KeyProvInfo.rgProvParam = NULL;
    KeyProvInfo.dwKeySpec = dwKeySpec;

    if (!CertSetCertificateContextProperty(
				    pCert,
				    CERT_KEY_PROV_INFO_PROP_ID,
				    0,
				    (VOID *) &KeyProvInfo))
    {
        hr = myHLastError();

	// the cert's been incorrectly created -- scrap it.

	_JumpError(hr, error, "CertSetCertificateContextProperty");
    }
    *ppCert = pCert;
    pCert = NULL;
    hr = S_OK;

error:
    if (NULL != pKey)
    {
	LocalFree(pKey);
    }
    if (NULL != pwszContainerName)
    {
        LocalFree(pwszContainerName);
    }
    if (NULL != pwszProvName)
    {
        LocalFree(pwszProvName);
    }
    if (NULL != pCert)
    {
	CertFreeCertificateContext(pCert);
    }
    return(hr);
}


//+-------------------------------------------------------------------------
// DisplayChainInfo -- This code verifies that the SC cert is valid.
// Uses identical code to KDC cert chaining engine.
//
// Author: Todds
//--------------------------------------------------------------------------

DWORD
DisplayChainInfo(
    IN CERT_CONTEXT const *pCert)
{
    HRESULT hr;
    CERT_CHAIN_PARA ChainParameters;
    char *pszClientAuthUsage = szOID_KERB_PKINIT_CLIENT_CERT_TYPE;
    CERT_CHAIN_CONTEXT const *pChainContext = NULL;
    DWORD VerifyState;

    ZeroMemory(&ChainParameters, sizeof(ChainParameters));
    ChainParameters.cbSize = sizeof(ChainParameters);
    ChainParameters.RequestedUsage.dwType = USAGE_MATCH_TYPE_AND;
    ChainParameters.RequestedUsage.Usage.cUsageIdentifier = 1;
    ChainParameters.RequestedUsage.Usage.rgpszUsageIdentifier = &pszClientAuthUsage;

    if (!CertGetCertificateChain(
                          HCCE_LOCAL_MACHINE,
                          pCert,
                          NULL,			// evaluate at current time
                          NULL,			// no additional stores
                          &ChainParameters,
                          CERT_CHAIN_REVOCATION_CHECK_CHAIN_EXCLUDE_ROOT,
                          NULL,			// reserved
                          &pChainContext))
    {
        hr = myHLastError();
	wprintf(L"CertGetCertificateChain failed: 0x%x\n ", hr);
	_JumpError(hr, error, "CertGetCertificateChain");
    }
    if (CERT_TRUST_NO_ERROR != pChainContext->TrustStatus.dwErrorStatus)
    {
	//DisplayChain(pChainContext, 0);
	wprintf(L"Chain on smart card is invalid\n");
	hr = TRUST_E_FAIL;
	_PrintError(hr, "CertGetCertificateChain");
    }
    else
    {
	wprintf(L"Chain validates\n");
    }

    hr = cuVerifyCertContext(
			pCert,			// pCert
			NULL,			// hStoreCA
			&pszClientAuthUsage,	// apszPolicies
			1,			// cPolicies
			&VerifyState);
    _JumpIfError(hr, error, "cuVerifyCertContext");

error:
    if (NULL != pChainContext)
    {
        CertFreeCertificateChain(pChainContext);
    }
    return(hr);
}


HRESULT
DisplayReaderCertAndKey(
    IN SCARD_READERSTATE const *pReaderState,
    IN HCRYPTPROV hProv,
    IN DWORD dwKeySpec,
    IN WCHAR const *pwszKeyType,
    IN WCHAR const *pwszCardName,
    IN WCHAR const *pwszCSPName)
{
    HRESULT hr;
    HCRYPTKEY hKey = NULL;
    CERT_CONTEXT const *pCert = NULL;
    DWORD cwc;
    WCHAR *pwszTitle = NULL;
    CRYPTUI_VIEWCERTIFICATE_STRUCT CertViewInfo;

    // Get the key

    if (!CryptGetUserKey(hProv, dwKeySpec, &hKey))
    {
	hr = myHLastError();
	if (NTE_NO_KEY == hr)
	{
	    wprintf(
		L"No %ws key for reader: %ws\n",
		pwszKeyType,
		pReaderState->szReader);
	}
	else
	{
	    wprintf(
		L"An error (0x%x) occurred opening the %ws key for reader: %ws\n",
		hr,
		pwszKeyType,
		pReaderState->szReader);
	}
	_JumpError2(hr, error, "CryptGetUserKey", NTE_NO_KEY);
    }

    // Get the cert for this key

    hr = GetCertContext(hProv, hKey, dwKeySpec, pwszKeyType, &pCert);
    if (S_OK != hr)
    {
	wprintf(
	    L"No %ws cert retrieved for reader: %ws\n",
	    pwszKeyType,
	    pReaderState->szReader);
	_JumpError(hr, error, "GetCertContext");
    }

    // Attempt to build a certificate chain

    wprintf(
	L"\nPerforming cert chain verification...\n");

    DisplayChainInfo(pCert);

    // call common UI to display Cert Context
    // (from cryptui.h (cryptui.dll))

    cwc = wcslen(pReaderState->szReader) +
	    2 +
	    wcslen(pwszKeyType);
    pwszTitle = (WCHAR *) LocalAlloc(
				LMEM_FIXED,
				(cwc + 1) * sizeof(WCHAR));
    if (NULL == pwszTitle)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }

    swprintf(
	pwszTitle,
	L"%ws: %ws",
	pReaderState->szReader,
	pwszKeyType);

    ZeroMemory(&CertViewInfo, sizeof(CertViewInfo));
    CertViewInfo.dwSize = sizeof(CertViewInfo);
    //CertViewInfo.hwndParent = NULL;
    CertViewInfo.szTitle = pwszTitle;
    CertViewInfo.dwFlags = CRYPTUI_DISABLE_EDITPROPERTIES |
				CRYPTUI_DISABLE_ADDTOSTORE;
    CertViewInfo.pCertContext = pCert;

    CryptUIDlgViewCertificate(&CertViewInfo, NULL);
    CertFreeCertificateContext(pCert);

    wprintf(
	L"Displayed %ws cert for reader %ws\n",
	pwszKeyType,
	pReaderState->szReader);
    hr = S_OK;

error:
    if (NULL != pwszTitle)
    {
	LocalFree(pwszTitle);
    }
    if (NULL != hKey)
    {
	CryptDestroyKey(hKey);
    }
    return(hr);
}


HRESULT
DisplayReaderCert(
    IN SCARDCONTEXT hSCard,
    IN SCARD_READERSTATE const *pReaderState)
{
    HRESULT hr;
    HRESULT hr2;
    DWORD dwAutoAllocate;
    WCHAR wszFQCN[256];
    HCRYPTPROV hProv = NULL;
    WCHAR *pwszCardName = NULL;
    WCHAR *pwszCSPName = NULL;

    if (0 >= pReaderState->cbAtr)
    {
	hr = S_OK;
	goto error;	// no point to do any more work on this reader
    }

    // Inform user of current test

    wprintf(L"\n=======================================================\n");
    wprintf(
	L"Analyzing card in reader: %ws\n",
	pReaderState->szReader);

    // Get the name of the card

    dwAutoAllocate = SCARD_AUTOALLOCATE;
    hr = SCardListCards(
		    hSCard,
		    pReaderState->rgbAtr,
		    NULL,			// rgguidInterfaces 
		    0,				// cguidInterfaceCount 
		    (WCHAR *) &pwszCardName,	// mszCards 
		    &dwAutoAllocate);		// pcchCards 
    _JumpIfError(hr, error, "SCardListCards");

    dwAutoAllocate = SCARD_AUTOALLOCATE;
    hr = SCardGetCardTypeProviderName(
				hSCard,
				pwszCardName,
				SCARD_PROVIDER_CSP,
				(WCHAR *) &pwszCSPName,
				&dwAutoAllocate);
    if (S_OK != hr)
    {
	wprintf(
	    L"Error on SCardGetCardTypeProviderName for %ws: 0x%x\n",
	    pwszCardName,
	    hr);
	_JumpError(hr, error, "SCardGetCardTypeProviderName");
    }

    // Prepare FullyQualifiedContainerName for CryptAcquireContext call

    swprintf(wszFQCN, L"\\\\.\\%ws\\", pReaderState->szReader);

    if (!CryptAcquireContext(
			&hProv,
			wszFQCN,	// default container via reader
			pwszCSPName,
			PROV_RSA_FULL,
			CRYPT_SILENT))
    {
	hr = myHLastError();
	wprintf(
	    L"Error on CryptAcquireContext for %ws: 0x%x\n",
	    pwszCSPName,
	    hr);
	_JumpError(hr, error, "SCardGetCardTypeProviderName");
    }

    // Enumerate the keys user specified and display the certs...

    hr = DisplayReaderCertAndKey(
			pReaderState,
			hProv,
			AT_SIGNATURE,
			L"AT_SIGNATURE",
			pwszCardName,
			pwszCSPName);
    _PrintIfError2(hr, "DisplayReaderCertAndKey", NTE_NO_KEY);

    hr2 = DisplayReaderCertAndKey(
			pReaderState,
			hProv,
			AT_KEYEXCHANGE,
			L"AT_KEYEXCHANGE",
			pwszCardName,
			pwszCSPName);
    _PrintIfError2(hr2, "DisplayReaderCertAndKey", NTE_NO_KEY);
    if (S_OK == hr)
    {
	hr = hr2;
	hr2 = S_OK;
    }

    // ignore NTE_NO_KEY if the other key type exists:

    if (S_OK == hr2 && NTE_NO_KEY == hr)
    {
	hr = S_OK;
    }

error:
    if (NULL != pwszCSPName)
    {
	SCardFreeMemory(hSCard, pwszCSPName);
    }
    if (NULL != pwszCardName)
    {
	SCardFreeMemory(hSCard, pwszCardName);
    }
    if (NULL != hProv)
    {
	CryptReleaseContext(hProv, 0);
    }
    return(hr);
}


//+-------------------------------------------------------------------------
// DisplayCerts
//--------------------------------------------------------------------------

HRESULT
DisplayCerts(
    IN SCARDCONTEXT hSCard,
    IN SCARD_READERSTATE const *prgReaderState,
    IN DWORD cReaders)
{
    HRESULT hr;
    HRESULT hr2;
    DWORD i;

    // For each reader that has a card, load the CSP and display the cert

    hr = S_OK;
    for (i = 0; i < cReaders; i++)
    {
	hr2 = DisplayReaderCert(hSCard, &prgReaderState[i]);
	_PrintIfError(hr2, "DisplayReaderCert");
	if (S_OK == hr)
	{
	    hr = hr2;
	}
    }
    return(hr);
}


//+-------------------------------------------------------------------------
// verbSCInfo -- This is the main entry point for the smart card test program.
// Nice and simple, borrowed from DBarlow
//
// Author: Doug Barlow (dbarlow) 11/10/1997
//
// Revisions:
// 	AMatlosz 2/26/98
//--------------------------------------------------------------------------

HRESULT
verbSCInfo(
    IN WCHAR const *pwszOption,
    OPTIONAL IN WCHAR const *pwszReaderName,
    IN WCHAR const *pwszArg2,
    IN WCHAR const *pwszArg3,
    IN WCHAR const *pwszArg4)
{
    HRESULT hr;
    HRESULT hr2;
    SCARDCONTEXT hSCard = NULL;
    WCHAR *pwszzReaderNameAlloc = NULL;
    SCARD_READERSTATE *prgReaderState = NULL;
    DWORD cReaders;
    
    hr = IsSCardSvrRunning();
    _JumpIfError(hr, error, "IsSCardSvrRunning");

    hr = BuildReaderList(
		    pwszReaderName,
		    &hSCard,
		    &pwszzReaderNameAlloc,
		    &prgReaderState,
		    &cReaders);
    _PrintIfError(hr, "BuildReaderList");

    hr2 = DisplayReaderList(hSCard, prgReaderState, cReaders);
    _PrintIfError(hr2, "DisplayReaderList");
    if (S_OK == hr)
    {
	hr = hr2;
    }

    hr2 = DisplayCerts(hSCard, prgReaderState, cReaders);
    _PrintIfError(hr2, "DisplayCerts");
    if (S_OK == hr)
    {
	hr = hr2;
    }
    wprintf(L"\ndone.\n");

error:
    FreeReaderList(hSCard, pwszzReaderNameAlloc, prgReaderState);
    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\tools\certut\tcainfo.cpp ===
//+-------------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (C) Microsoft Corporation, 1998 - 2000
//
// File:       tcainfo.cpp
//
// This code contains tests to exercise the functionality of the certcli
// "CA" interfaces, detailed in certca.h
//
//--------------------------------------------------------------------------

#include <pch.cpp>

#pragma hdrstop

#include <certca.h>
#include <winldap.h>

#define wszREGADMINALIAS	L"Software\\Policies\\Microsoft\\CertificateTemplates\\Aliases\\Administrator"
#define wszREGPOLICYHISTORY	L"Software\\Microsoft\\Windows\\CurrentVersion\\Group Policy\\History"

#define TE_USER		0
#define TE_MACHINE	1


VOID
cuPrintAPIError(
    IN WCHAR const *pwszAPIName,
    IN HRESULT hr);

VOID
cuPrintError(
    IN WCHAR const *pwszMsg);


VOID
cuPrintAPIError(
    IN WCHAR const *pwszAPIName,
    IN HRESULT hr)
{
    wprintf(myLoadResourceString(IDS_API_RPINT_FAILED), pwszAPIName, hr);
    wprintf(wszNewLine);
}

VOID
cuPrintError(
    IN WCHAR const *pwszMsg)
{
    wprintf(L"%ws\n", pwszMsg);
}


//
// CheckSupportedCertTypes()
//
// This function checks the certificate types enumerated through the property
// API, and compares them to the types enumerated by the cert type API.
//
// Params:
// hCA             -   IN  Handle to CA
// papwszProperty  -   IN  String array w/ present values
//
// Returns:
// HRESULT from CAINFO calls.
//

HRESULT
CheckSupportedCertTypes(
    IN HCAINFO hCA,
    IN WCHAR const * const *papwszTemplate)
{
    HRESULT hr;
    DWORD dwCT = 1;
    DWORD dwCT2 = 0;
    DWORD cTemplate;
    DWORD i;
    BOOL *pfPresent = NULL;
    HCERTTYPE hCT = NULL;
    HCERTTYPE hPrevCT = NULL;
    WCHAR **papwszCTFriendlyName = NULL;

    // First, find out how many cert types there are according to
    // value returned from property array...

    for (cTemplate = 0; NULL != papwszTemplate[cTemplate]; cTemplate++)
	;
    cTemplate--;	// adjust

    // alloc bool array for testing

    pfPresent = (BOOL *) LocalAlloc(
				LMEM_FIXED | LMEM_ZEROINIT,
				sizeof(BOOL) * cTemplate);
    if (NULL == pfPresent)
    {
        hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }

    // Let's try out the enumeration of cert types on the CA object,
    // just as a sanity check...  we'll then compare them against
    // the values stored in the property array.

    hr = CAEnumCertTypesForCA(
			hCA,
			CT_ENUM_USER_TYPES | CT_ENUM_MACHINE_TYPES,
			&hCT);
    if (S_OK != hr)
    {
        cuPrintAPIError(L"CAEnumCertTypesForCA", hr);
        goto error;
    }
    if (NULL == hCT)	// no cert types for CA
    {
        // Should be at least one, according to property enumeration

        if (NULL != papwszTemplate[0])
	{
            wprintf(myLoadResourceString(IDS_NO_CT_BUT_EXISTS));
    	    wprintf(wszNewLine);
            goto error;
        }
        wprintf(myLoadResourceString(IDS_NO_CT_FOR_CA));
    	wprintf(wszNewLine);
    }

    dwCT2 = CACountCertTypes(hCT);

    // Mark bool...

    hr = CAGetCertTypeProperty(
			hCT,
			CERTTYPE_PROP_FRIENDLY_NAME,
			&papwszCTFriendlyName);
    if (S_OK != hr)
    {
        cuPrintAPIError(L"CAGetCertTypeProperty", hr);
        goto error;
    }
    wprintf(L"CT #%u: %ws\n", dwCT, papwszCTFriendlyName[0]);

    hr = CACertTypeAccessCheck(hCT, NULL);
    if (S_OK != hr)
    {
	if (hr != E_ACCESSDENIED)
	{
            cuPrintAPIError(L"CACertTypeAccessCheck", hr);
            goto error;
        }
	wprintf(myLoadResourceString(IDS_NO_ACCESS));
	wprintf(wszNewLine);
	hr = S_OK;
    }

    for (i = 0; i < cTemplate; i++)
    {
        if (0 == lstrcmpi(papwszCTFriendlyName[0], papwszTemplate[i]))
	{
            pfPresent[i] = TRUE;
            break;
        }
    }

    if (NULL != papwszCTFriendlyName)
    {
        CAFreeCertTypeProperty(hCT, papwszCTFriendlyName);
        papwszCTFriendlyName = NULL;
    }

    // Enumerate remaining certificate types for CA

    hPrevCT = hCT;

    while (NULL != hCT)
    {
        // set up enumeration object

        hCT = NULL;

        hr = CAEnumNextCertType(hPrevCT, &hCT);
        if (NULL != hPrevCT)
	{
            CACloseCertType(hPrevCT);
            hPrevCT = hCT;
        }
        if (S_OK != hr)
	{
            cuPrintAPIError(L"CAEnumNextCertType", hr);
            goto error;
        }
        if (NULL == hCT)
	{
            wprintf(L"#CTs: %u\n", dwCT);
            break;
        }

        // CACountCertTypes checking

        dwCT++;

        // Mark bool...

        hr = CAGetCertTypeProperty(
			    hCT,
			    CERTTYPE_PROP_FRIENDLY_NAME,
			    &papwszCTFriendlyName);

        wprintf(L"CT #%u: %ws\n", dwCT, papwszCTFriendlyName[0]);

        hr = CACertTypeAccessCheck(hCT, NULL);
        if (S_OK != hr)
	{
            if (hr != E_ACCESSDENIED)
	    {
                cuPrintAPIError(L"CACertTypeAccessCheck", hr);
                goto error;
            }
	    wprintf(myLoadResourceString(IDS_NO_ACCESS));
	    wprintf(wszNewLine);
	    hr = S_OK;
        }

        for (i = 0; i < cTemplate; i++)
	{
            if (0 == lstrcmpi(papwszCTFriendlyName[0], papwszTemplate[i]))
	    {
                pfPresent[i] = TRUE;
                break;
            }
        }
        if (NULL != papwszCTFriendlyName)
	{
            CAFreeCertTypeProperty(hCT, papwszCTFriendlyName);
            papwszCTFriendlyName = NULL;
        }
    }

error:
    if (NULL != papwszCTFriendlyName)
    {
	CAFreeCertTypeProperty(hCT, papwszCTFriendlyName);
    }
    return(hr);
}


//
// ShowExpirationTime()
//
// This function simply displays the expiration time.
//
// Parameters:
//
// hCA     -   IN  Handle to CA
//
// Returns:
//
// HRESULT from APIs, or S_OK
//

HRESULT
ShowExpirationTime(
    IN HCAINFO hCA)
{
    HRESULT hr = S_OK;
    HRESULT hrRet = S_OK;
    DWORD dwExp;
    WCHAR buff[256];

    DWORD ardwUnits[] =   {CA_UNITS_DAYS,
                           CA_UNITS_WEEKS,
                           CA_UNITS_MONTHS,
                           CA_UNITS_YEARS};

    WCHAR *arwszDisplay[] = {L"Days",
                              L"Weeks",
                              L"Months",
                              L"Years"};

    // Retrieve and display expiration data

    wprintf(wszNewLine);
    wprintf(myLoadResourceString(IDS_CA_EXPIRATION_DATA));
    wprintf(wszNewLine);

    for (DWORD i = 0; i < 4; i++)
    {
        hr = CAGetCAExpiration(hCA, &dwExp, &ardwUnits[i]);
        if (S_OK != hr)
	{
            wprintf(myLoadResourceString(IDS_FORMAT_CA_EXPIRATION_FAILED), arwszDisplay[i], hr);
            wprintf(wszNewLine);
            hrRet = hr;
        }
	else
	{
            wprintf(myLoadResourceString(IDS_FORMAT_CA_EXPIRATION), arwszDisplay[i], dwExp);
            wprintf(wszNewLine);
        }
    }
    wprintf(L"####                   ####\n");
    return(hrRet);
}


//
// DisplaySupportedCertTypes()
//
// Returns:
//
// hr from CAINFO API, fills array of cert types, for use in -addct flag
//

HRESULT
DisplaySupportedCertTypes(
    IN HCAINFO hCA,
    OUT WCHAR ***ppapwszTemplate)
{
    HRESULT hr;
    DWORD i;

    hr = CAGetCAProperty(hCA, CA_PROP_CERT_TYPES, ppapwszTemplate);
    _JumpIfErrorStr(hr, error, "CAGetCAProperty", CA_PROP_CERT_TYPES);

    wprintf(myLoadResourceString(IDS_SUPPORTED_TEMPLATE));
    wprintf(wszNewLine);

    // Prepare certificate types in tab delimited format

    if (NULL == *ppapwszTemplate || NULL == **ppapwszTemplate)
    {
        wprintf(myLoadResourceString(IDS_NO_SUPPORTED_TEMPLATE));
        wprintf(wszNewLine);
	hr = CRYPT_E_NOT_FOUND;
	_JumpErrorStr(hr, error, "CAGetCAProperty", CA_PROP_CERT_TYPES);
    }

    for (i = 0; NULL != (*ppapwszTemplate)[i]; i++)
    {
        wprintf(L"%ws\n", (*ppapwszTemplate)[i]);
    }

    wprintf(L":::::::::::::::::::::::::::::::::::\n");

    // This compares the values returned from the property enumeration
    // to the values returned by enumerating the cert types

    hr = CheckSupportedCertTypes(hCA, *ppapwszTemplate);
    _JumpIfError(hr, error, "CheckSupportedCertTypes");

error:
    return(hr);
}


HRESULT
PingCA(
    IN WCHAR const *pwszCAName,
    IN WCHAR const *pwszServer)
{
    HRESULT hr;
    WCHAR *pwszConfig = NULL;

    hr = myFormConfigString(pwszServer, pwszCAName, &pwszConfig);
    _JumpIfError(hr, error, "myFormConfigString");

    hr = cuPingCertSrv(pwszConfig);
    _JumpIfError(hr, error, "cuPingCertSrv");

error:
    if (NULL != pwszConfig)
    {
	LocalFree(pwszConfig);
    }
    return(hr);
}


HRESULT
DisplayCAInfo(
    IN HCAINFO hCA,
    IN BOOL fPing)
{
    HRESULT hr;
    HRESULT hr2 = S_OK;
    WCHAR wszMachine[512];
    WCHAR wszCA[256];
    DWORD dwCount = 0;
    WCHAR **pawszProperty = NULL;
    WCHAR **pawszCertTypes = NULL;

    // CA Name

    hr = CAGetCAProperty(hCA, CA_PROP_NAME, &pawszProperty);
    if (S_OK != hr)
    {
        wprintf(myLoadResourceString(IDS_FORMAT_CA_NAME_PROP_FAILED), hr);
        wprintf(wszNewLine);

        goto error;
    }
    wcscpy(wszCA, pawszProperty[0]);

    wprintf(wszNewLine);
    wprintf(
        myLoadResourceString(IDS_FORMAT_CA_NAME_LIST),
        pawszProperty[0]);
    wprintf(wszNewLine);

    if (NULL != pawszProperty)
    {
        hr = CAFreeCAProperty(hCA, pawszProperty);
        if (S_OK != hr)
	{
            cuPrintAPIError(L"CAFreeCAProperty", hr);
            goto error;
        }
        pawszProperty = NULL;
    }

    // Machine name for CA

    hr = CAGetCAProperty(hCA, CA_PROP_DNSNAME, &pawszProperty);
    if (S_OK != hr)
    {
        wprintf(myLoadResourceString(IDS_FORMAT_CA_DNS_PROP_FAILED), hr);
        wprintf(wszNewLine);
        goto error;
    }
    wcscpy(wszMachine, pawszProperty[0]);

    // Display CA Machine DNS Name

    wprintf(myLoadResourceString(IDS_FORMAT_CA_MACHINE_LIST), pawszProperty[0]);
    wprintf(wszNewLine);

    if (NULL != pawszProperty)
    {
        hr = CAFreeCAProperty(hCA, pawszProperty);
        if (S_OK != hr)
	{
            cuPrintAPIError(L"CAFreeCAProperty", hr);
            goto error;
        }
        pawszProperty = NULL;
    }

    // DN of CA Object on DS

    hr = CAGetCAProperty(hCA, CA_PROP_DSLOCATION, &pawszProperty);
    if (S_OK != hr)
    {
        wprintf(myLoadResourceString(IDS_FORMAT_CA_NAME_PROP_FAILED), hr);
        wprintf(wszNewLine);

        goto error;
    }

    // Display DN Name
    wprintf(myLoadResourceString(IDS_FORMAT_CA_DS_LIST), pawszProperty[0]);	// assume single DN
    wprintf(wszNewLine);

    if (NULL != pawszProperty)
    {
        hr = CAFreeCAProperty(hCA, pawszProperty);
        if (S_OK != hr)
	{
            cuPrintAPIError(L"CAFreeCAProperty", hr);
            goto error;
        }
        pawszProperty = NULL;
    }

    // Cert Types for CA == Multi valued property
    hr = DisplaySupportedCertTypes(hCA, &pawszCertTypes);
    if (S_OK != hr)
    {
        goto error;
    }
    if (NULL != pawszProperty)
    {
        hr = CAFreeCAProperty(hCA, pawszCertTypes);
        if (S_OK != hr)
	{
            cuPrintAPIError(L"CAFreeCAProperty", hr);
            goto error;
        }
        pawszProperty = NULL;
    }

    // DN of CA certificate

    hr = CAGetCAProperty(hCA, CA_PROP_CERT_DN, &pawszProperty);
    if (S_OK != hr)
    {
        wprintf(myLoadResourceString(IDS_FORMAT_CERT_DN_PROP_FAILED), hr);
        wprintf(wszNewLine);
        goto error;
    }

    // assume single DN for CA

    wprintf(myLoadResourceString(IDS_FORMAT_CERT_DN_LIST), pawszProperty[0]);
    wprintf(wszNewLine);

    if (NULL != pawszProperty)
    {
        hr = CAFreeCAProperty(hCA, pawszProperty);
        if (S_OK != hr)
	{
            cuPrintAPIError(L"CAFreeCAProperty", hr);
            goto error;
        }
        pawszProperty = NULL;
    }

    // Signature algs

    hr = CAGetCAProperty(hCA, CA_PROP_SIGNATURE_ALGS, &pawszProperty);
    if (S_OK != hr)
    {
        wprintf(myLoadResourceString(IDS_FORMAT_CA_ALG_PROP_FAILED), hr);
        wprintf(wszNewLine);
        goto error;
    }
    if (NULL != pawszProperty)
    {
        wprintf(
            myLoadResourceString(IDS_FORMAT_CA_ALG_LIST),
            pawszProperty[0]);

        hr = CAFreeCAProperty(hCA, pawszProperty);
        if (S_OK != hr)
	{
            cuPrintAPIError(L"CAFreeCAProperty", hr);
            goto error;
        }
        pawszProperty = NULL;
    }
    else
    {
        wprintf(myLoadResourceString(IDS_NO_ALG_UNEXPECTED));
        wprintf(wszNewLine);
   }

    // Get the expiration date/time/... for an indvidual CA

    hr = ShowExpirationTime(hCA);
    if (S_OK != hr)
        goto error;

    if (fPing)
    {
        PingCA(wszCA, wszMachine);
    }
    hr = S_OK;

error:
    return(hr);
}


// EnumCAs()
//
// We've got to assume that this works.  Enumerates CAs on the DS.
//
// Returns:
// Number of CA's on DS.
//

HRESULT
EnumCAs(
    IN WCHAR const *pwszDomain,
    IN BOOL fPing)
{
    HRESULT hr;
    DWORD i;
    DWORD cCA;
    HCAINFO hCA = NULL;

    // Enumerate all of the CA's on the DS

    hr = CAEnumFirstCA(pwszDomain, 0, &hCA);
    if (S_OK != hr)
    {
        cuPrintAPIError(L"CAEnumFirstCA", hr);
        goto error;
    }
    if (NULL == hCA)
    {
	    wprintf(myLoadResourceString(IDS_NO_CA_ON_DOMAIN));
	    wprintf(wszNewLine);
	    hr = CRYPT_E_NOT_FOUND;
        goto error;
    }

    // Make sure that the counting function works at this stage.

    cCA = CACountCAs(hCA);

    // We've got first CA, so lets look at some info about it

    hr = DisplayCAInfo(hCA, fPing);
    _JumpIfError(hr, error, "DisplayCAInfo");

    for (i = 1; i < cCA; i++)
    {
	HCAINFO hNextCA;

        hr = CAEnumNextCA(hCA, &hNextCA);
        if (S_OK != hr)
	{
            cuPrintAPIError(L"EnumNextCA", hr);
	    _JumpError(hr, error, "CAEnumNextCA");
        }
        if (NULL == hNextCA)
	{
            wprintf(
                L"================ %u CAs on %ws Domain ====",
                i,
                pwszDomain);
	    wprintf(wszNewLine);
            break;
        }

        // It is difficult to determine what the desired behavior will be for
	// this api call.

        hr = CACloseCA(hCA);
        if (S_OK != hr)
	{
            cuPrintAPIError(L"CACloseCA", hr);
            goto error;
        }

        hCA = hNextCA;

        hr = DisplayCAInfo(hCA, fPing);
	_JumpIfError(hr, error, "DisplayCAInfo");
    }

    // check the count in the enumeration, and verify the results

    if (cCA != i)
    {
        cuPrintAPIError(
            L"CACountCAs returned wrong value after CAEnumNextCA!",
            cCA);

        hr = E_FAIL;
        goto error;
    }
    wprintf(L"================ %u CAs on %ws Domain ====", i, pwszDomain);
    wprintf(wszNewLine);

error:
    if (NULL != hCA)
    {
	CACloseCA(hCA);
    }
    return(hr);
}


//
// TestDFSPath()
//
// Verifies that the DFS on this machine can access the SYSVOL share
//

HRESULT
TestDFSPath(
    IN WCHAR const *pwszDFSPath)
{
    HRESULT hr;
    DWORD dwDate = 0;
    DWORD dwTime = 0;

    WIN32_FILE_ATTRIBUTE_DATA   sFileData;

    if (!GetFileAttributesEx(
		    pwszDFSPath,
		    GetFileExInfoStandard,
		    (VOID *) &sFileData))
    {
	hr = myHLastError();
    wprintf(myLoadResourceString(IDS_FORMAT_NO_DFS), hr);
	wprintf(wszNewLine);
	goto error;

	// To do... Add diagnostics here
    }
    wprintf(myLoadResourceString(IDS_DFS_DATA_ACCESS));
	wprintf(wszNewLine);

error:
    return(hr);
}


//
// TestLdapPath()
//
// This function verifies that LDAP connectivity is still there for a given
// ldap URL
//

HRESULT
TestLdapPath(
    IN WCHAR const *pwszLdapURL)
{
    HRESULT hr;
    LDAP *pldapbind = NULL;
    ULONG ldaperr = LDAP_SUCCESS;
    WCHAR *rgwszSearchAttribute[2] = {L"CN", NULL};
    WCHAR *pwszSearchParam =  L"(&(objectClass=*))";
    LDAPMessage *SearchResult = NULL;
    WCHAR buff[256];
    WCHAR *pwszTmpUrl = NULL;

    pldapbind = ldap_init(NULL, LDAP_PORT);

    if (NULL == pldapbind)
    {
	hr = myHLastError();
        cuPrintAPIError(L"TestLdapPath:ldap_init", hr);
        goto error;
    }

	// This gives the IP address of the Cached LDAP DC from
	// binding handle.  Resolve the name?
    ldaperr = ldap_bind_s(pldapbind, NULL, NULL, LDAP_AUTH_NEGOTIATE);

    wprintf(L"Cached LDAP DC: %ws\n", pldapbind->ld_host);

    if (ldaperr != LDAP_SUCCESS)
    {
        cuPrintAPIError(L"TestLdapPath:ldap_bind", ldaperr);
        goto error;
    }

    // Parse URL, and do the search thing.
    pwszTmpUrl = wcsstr(pwszLdapURL, L"//");
    pwszTmpUrl += 2;

    ldaperr = ldap_search_s(
			pldapbind,
			pwszTmpUrl,
			LDAP_SCOPE_SUBTREE,
			pwszSearchParam,
			rgwszSearchAttribute,
			0,
			&SearchResult);

    if (ldaperr != LDAP_SUCCESS)
    {
        // we can't be 100% sure that this attribute is on the objec
        // for example, user UPN, so don't log to event log
        cuPrintAPIError(L"ldap_search", ldaperr);
        goto error;
    }

    if (0 == ldap_count_entries(pldapbind, SearchResult))
    {
        wprintf(myLoadResourceString(IDS_NO_ENTRY_IN_PING));
		wprintf(wszNewLine);
        goto error;
    }
    hr = S_OK;

error:
    if (NULL != SearchResult)
    {
	ldap_msgfree(SearchResult);
    }
    if (NULL != pldapbind)
    {
	ldap_unbind(pldapbind);
    }
    return(hr);
}


//
// DisplayHistoryData()
//
// This function takes a key name, hkey, and value, and prints the value string.
//

HRESULT
DisplayHistoryData(
    IN WCHAR const *pwszSubKeyName,
    IN HKEY hPolicyKey)
{
    HRESULT hr;
    HKEY hKeyNew = NULL;
    WCHAR buff[512];
    DWORD cwc;
    DWORD dwType;

    // Get #'d history key handle

    hr = RegOpenKeyEx(
		hPolicyKey,
		pwszSubKeyName,
		0,
		KEY_ENUMERATE_SUB_KEYS | KEY_QUERY_VALUE,
		&hKeyNew);
    if (S_OK != hr)
    {
	cuPrintAPIError(L"RegOpenKeyEx", hr);
	return(hr);
    }

    // Get GPO Values

    cwc = ARRAYSIZE(buff);
    hr = RegQueryValueEx(
		    hKeyNew,
		    L"DisplayName",
		    0,
		    &dwType,
		    (BYTE *) buff,
		    &cwc);
    if (S_OK != hr)
    {
	cuPrintAPIError(L"RegQueryValue", hr);
	goto error;
    }

    wprintf(wszNewLine);
    wprintf(myLoadResourceString(IDS_FORMAT_KEY_LIST), pwszSubKeyName, buff);
    wprintf(wszNewLine);

    cwc = ARRAYSIZE(buff);
    hr = RegQueryValueEx(
		    hKeyNew,
		    L"GPOName",
		    0,
		    &dwType,
		    (BYTE *) buff,
		    &cwc);
    if (S_OK != hr)
    {
	cuPrintAPIError(L"RegQueryValue", hr);
	goto error;
    }

    wprintf(myLoadResourceString(IDS_FORMAT_GPO_NAME), buff);
    wprintf(wszNewLine);

    // See if LDAP can hit this policy

    cwc = ARRAYSIZE(buff);
    hr = RegQueryValueEx(
		    hKeyNew,
		    L"DSPath",
		    0,
		    &dwType,
		    (BYTE *) buff,
		    &cwc);
    if (hr == S_OK)
    {
	hr = TestLdapPath(buff);
    }
    else if (hr == ERROR_FILE_NOT_FOUND)
    {
	    wprintf(myLoadResourceString(IDS_NO_DSPATH));
        wprintf(wszNewLine);
    }
    else
    {
	    wprintf(myLoadResourceString(IDS_FORMAT_REG_QUERY_VALUE_FAILED), hr);
        wprintf(wszNewLine);
	    goto error;
    }

    // See if DFS can get the data..

    cwc = ARRAYSIZE(buff);
    hr = RegQueryValueEx(
		    hKeyNew,
		    L"FileSysPath",
		    0,
		    &dwType,
		    (BYTE *) buff,
		    &cwc);
    if (hr == S_OK)
    {
	hr = TestDFSPath(buff);
    }
    else if (hr == ERROR_FILE_NOT_FOUND)
    {
	    wprintf(myLoadResourceString(IDS_NO_FILE_SYS_PATH));
        wprintf(wszNewLine);
    }
    else
    {
	    wprintf(myLoadResourceString(IDS_FORMAT_REG_QUERY_VALUE_FAILED), hr);
        wprintf(wszNewLine);
	    goto error;
    }
    hr = S_OK;

error:
    if (NULL != hKeyNew)
    {
	RegCloseKey(hKeyNew);
    }
    return(hr);
}


//
// ResultFree()
//
// Frees results copied from LDAP search
//

VOID
ResultFree(
    IN OUT WCHAR **rgwszRes)
{
    DWORD i = 0;

    if (NULL != rgwszRes)
    {
	while (NULL != rgwszRes[i])
	{
	    LocalFree(rgwszRes[i]);
	    i++;
	}
	LocalFree(rgwszRes);
    }
}


HRESULT
ResultAlloc(
    IN WCHAR const * const *rgpwszLdapRes,
    OUT WCHAR ***prgpwszOut)
{
    HRESULT hr;
    DWORD cValue;
    DWORD i;
    WCHAR **rgpwszOut = NULL;

    for (cValue = 0; NULL != rgpwszLdapRes[cValue]; cValue++)
	;

    rgpwszOut = (WCHAR **) LocalAlloc(
				LMEM_FIXED | LMEM_ZEROINIT,
				(cValue + 1) * sizeof(WCHAR *));
    if (NULL == rgpwszOut)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }

    for (i = 0; i < cValue; i++)
    {
	hr = myDupString(rgpwszLdapRes[i], &rgpwszOut[i]);
	_JumpIfError(hr, error, "myDupString");
    }
    rgpwszOut[i] = NULL;
    *prgpwszOut = rgpwszOut;
    rgpwszOut = NULL;
    hr = S_OK;

error:
    if (NULL != rgpwszOut)
    {
	ResultFree(rgpwszOut);
    }
    return(hr);
}


//
// GetPropertyFromDSObject()
//
// This function calls the DS to get a property of the user or machine object,
// mimicing the call made by the CA.
//
// Params:
//
// rgwszSearchAttribute  - IN  NULL Terminated WCHAR *array. Only coded for 1
//                            value retrieval at a time
//
// Returns:
//
// Pointer to string array that must be freed by call to LocalFree(), and
// wszDN, if User specified
//

WCHAR **
GetPropertyFromDSObject(
    IN WCHAR **rgwszSearchAttribute,
    IN BOOL fMachine,
    OPTIONAL OUT WCHAR **ppwszUserDN)
{
    HRESULT hr;
    LDAP *pldapbind = NULL;
    ULONG ldaperr = LDAP_SUCCESS;

    WCHAR *pwszEmail = NULL;
    WCHAR *pwszCNName = NULL;
    DWORD cwc;
    WCHAR wszNTLM[MAX_PATH];
    WCHAR wszDN[MAX_PATH];

    WCHAR *pwszSearchUser = L"(&(objectClass=user)";
    WCHAR *pwszSearchComputer = L"(&(objectClass=computer)(cn=";
    WCHAR wszSearchParam[MAX_PATH];

    WCHAR *pwszAttName = NULL;
    WCHAR **rgwszValues = NULL;
    WCHAR **rgwszRet = NULL;
    LDAPMessage *SearchResult = NULL;
    LDAPMessage *Attributes = NULL;
    DWORD dwValCount;

    if (fMachine) 
    {
        // Get CN

	cwc = ARRAYSIZE(wszNTLM);
        if (!GetComputerName(wszNTLM, &cwc))
	{
	    hr = myHLastError();
            cuPrintAPIError(L"GetComputerName", hr);
            goto error;
        }

        // Get DN

	cwc = ARRAYSIZE(wszDN);
        if (!GetComputerObjectName(NameFullyQualifiedDN, wszDN, &cwc))
	{
	    hr = myHLastError();
            cuPrintAPIError(L"GetComputerName", hr);
            goto error;
        }
        pwszCNName = wszNTLM;
    }
    else	// User
    {
        // Get the SAM name..

	cwc = ARRAYSIZE(wszNTLM);
        if (!GetUserNameEx(NameSamCompatible, wszNTLM, &cwc))
	{
            hr = myHLastError();
	    _PrintError(hr, "GetUserNameEx");
            cuPrintAPIError(L"GetUserNameEx", hr);
            goto error;
        }

        // Fix NULL termination bug

        if (0 != cwc) 
	{
            wszNTLM[cwc - 1] = L'\0';
        }

        // Parse off user name...

        pwszCNName = wcschr(wszNTLM, L'\\');
        if (NULL == pwszCNName)
	{
            pwszCNName = wszNTLM;
        }
	else
	{
            pwszCNName++;
        }

        cwc = ARRAYSIZE(wszDN);
        if (!TranslateName(
		    wszNTLM,
		    NameSamCompatible,
		    NameFullyQualifiedDN,
		    wszDN,
		    &cwc))
	{
            hr = myHLastError();
            cuPrintAPIError(L"TranslateName", hr);
            goto error;
        }
    }

    if (!fMachine && NULL != ppwszUserDN)
    {
	hr = myDupString(wszDN, ppwszUserDN);
	_JumpIfError(hr, error, "myDupString");
    }

    // Init LDAP calls

    pldapbind = ldap_init(NULL, LDAP_PORT);
    if (NULL == pldapbind)
    {
	hr = myHLastError();
        cuPrintAPIError(L"ldap_init", hr);
        goto error;
    }

    ldaperr = ldap_bind_s(pldapbind, NULL, NULL, LDAP_AUTH_NEGOTIATE);
    if (ldaperr != LDAP_SUCCESS)
    {
        cuPrintAPIError(L"ldap_bind", ldaperr);
        goto error;
    }

    // Compose search string

    if (fMachine)
    {
        swprintf(wszSearchParam, L"%ws%ws))", pwszSearchComputer, pwszCNName);
    }
    else
    {
        swprintf(wszSearchParam, L"%ws)", pwszSearchUser);
    }

    // Do the search

    ldaperr = ldap_search_s(
			pldapbind,
			wszDN,
			LDAP_SCOPE_SUBTREE,
			wszSearchParam,
			rgwszSearchAttribute,
			0,
			&SearchResult);
    if (ldaperr != LDAP_SUCCESS)
    {
        // we can't be 100% sure that this attribute is on the objec
        // for example, user UPN, so don't log to event log

        cuPrintAPIError(L"ldap_search", ldaperr);
        goto error;
    }

    if (0 == ldap_count_entries(pldapbind, SearchResult))
    {
        wprintf(myLoadResourceString(IDS_FORMAT_LDAP_NO_ENTRY), rgwszSearchAttribute[0]);
		wprintf(wszNewLine);
        goto error;
    }

    // Make assumption that only one value will be returned for a user.
    Attributes = ldap_first_entry(pldapbind, SearchResult);

    if (NULL == Attributes)
    {
	hr = myHLastError();
        cuPrintAPIError(L"ldap_first_entry", hr);
        goto error;
    }


    rgwszValues = ldap_get_values(
                        pldapbind,
                        Attributes,
                        rgwszSearchAttribute[0]); // remember, only one search
    if (NULL == rgwszValues)
    {
        // we can't be 100% sure that this attribute is on the object
        // for example, user UPN, so don't log to event log
        // wprintf(L"ldap_get_values failed! %x", hr);

        hr = S_OK;
	goto error;
    }

    // ok, we've got the required attributes off of the user object..
    // Let's return the proper strings, which must be freed by ResultFree()

    hr = ResultAlloc(rgwszValues, &rgwszRet);
    _JumpIfError(hr, error, "ResultAlloc");

error:
    if (NULL != SearchResult)
    {
	ldap_msgfree(SearchResult);
    }
    if (NULL != rgwszValues)
    {
	ldap_value_free(rgwszValues);
    }
    if (NULL != pldapbind)
    {
	ldap_unbind(pldapbind);
    }
    return(rgwszRet);
}


//
//
// DisplayLMGPRoot()
//
// This function uses CAPI2 api to enumerate roots in group policy root store
//

HRESULT
DisplayLMGPRoot()
{
    HRESULT hr;
    HCERTSTORE hStore = NULL;
    DWORD cCert;
    CERT_CONTEXT const *pcc = NULL;
    CERT_CONTEXT const *pccPrev;
    CRYPT_HASH_BLOB HashBlob;

    ZeroMemory(&HashBlob, sizeof(CRYPT_HASH_BLOB));
    HashBlob.cbData = CBMAX_CRYPT_HASH_LEN;
    HashBlob.pbData = (BYTE *) LocalAlloc(LMEM_FIXED, CBMAX_CRYPT_HASH_LEN);

    if (NULL == HashBlob.pbData)
    {
	hr = E_OUTOFMEMORY;
	cuPrintAPIError(L"LocalAlloc", hr);
	goto error;
    }

    // Open local machine GP store

    hStore = CertOpenStore(
		    CERT_STORE_PROV_SYSTEM_W,
		    0,
		    NULL,
		    CERT_STORE_OPEN_EXISTING_FLAG |
		    CERT_SYSTEM_STORE_LOCAL_MACHINE_GROUP_POLICY,
		    (VOID const *) wszROOT_CERTSTORE);
    if (NULL == hStore)
    {
	hr = myHLastError();
	cuPrintAPIError(L"CertOpenStore", hr);
	goto error;
    }

    wprintf(myLoadResourceString(IDS_ROOT_CERT_IN_POLICY));
    wprintf(wszNewLine);

    // Enumerate certificates in store, giving subject, and thumbprint

    cCert = 0;
    pccPrev = NULL;
    while (TRUE)
    {
	pcc = CertEnumCertificatesInStore(hStore, pccPrev);
	if (NULL == pcc)
	{
	    break;
	}

	// Output info

	wprintf(myLoadResourceString(IDS_FORMAT_CERT_COLON), cCert);
    wprintf(wszNewLine);


	hr = cuDumpSerial(g_wszPad2, IDS_SERIAL, &pcc->pCertInfo->SerialNumber);
	_PrintIfError(hr, "cuDumpSerial");

	hr = cuDisplayCertNames(FALSE, g_wszPad2, pcc->pCertInfo);
	_PrintIfError(hr, "cuDisplayCertNames");

	hr = cuDumpCertType(g_wszPad2, pcc->pCertInfo);
	_PrintIfError2(hr, "cuDumpCertType", CRYPT_E_NOT_FOUND);

	hr = cuDisplayHash(
		    g_wszPad2,
		    pcc,
		    NULL,
		    CERT_SHA1_HASH_PROP_ID,
		    L"sha1");
	_PrintIfError(hr, "cuDisplayHash");

	wprintf(wszNewLine);

	// Prepare for next cert

	pccPrev = pcc;
	cCert++;
    }
    if (0 == cCert)
    {
        wprintf(myLoadResourceString(IDS_NO_ROOT_IN_POLICY));
		wprintf(wszNewLine);

        wprintf(myLoadResourceString(IDS_CHECK_EVENT_LOG));
		wprintf(wszNewLine);
    }
    hr = S_OK;

error:
    return(hr);
}


//
// DisplayPolicyList()
//
// This function displays the GPOs applied to a machine / user
//

HRESULT
DisplayPolicyList(
    IN DWORD dwFlags)
{
    HKEY hKey = (dwFlags & TE_MACHINE)? HKEY_LOCAL_MACHINE : HKEY_CURRENT_USER;
    HKEY hPolicyKey = NULL;
    HRESULT hr;
    DWORD dwIndex = 0;
    DWORD cwc;
    WCHAR buff[512];
    WCHAR **rgszValues = NULL;
    FILETIME ft;

    // Output

    switch (dwFlags)
    {
	case TE_MACHINE:
	    wprintf(myLoadResourceString(IDS_POLICY_MACHINE));
        wprintf(wszNewLine);

	    break;

	default:
	    wprintf(myLoadResourceString(IDS_POLICY_USER));
        wprintf(wszNewLine);
    }

    // Open history key for enumeration

    hr = RegOpenKeyEx(
		    hKey,
		    wszREGPOLICYHISTORY,
		    0,
		    KEY_ENUMERATE_SUB_KEYS | KEY_QUERY_VALUE,
		    &hPolicyKey);
    if (S_OK != hr)
    {
	    cuPrintAPIError(L"RegOpenKeyEx", hr);

        wprintf(myLoadResourceString(IDS_POSSIBLE_NO_POLICY));
        wprintf(wszNewLine);
	    goto error;
    }
    while (TRUE)
    {
        cwc = ARRAYSIZE(buff);
	hr = RegEnumKeyEx(
		    hPolicyKey,
		    dwIndex,
		    buff,
		    &cwc,
		    NULL,
		    NULL,
		    NULL,
		    &ft);
	if (S_OK != hr)
	{
	    if (hr == ERROR_NO_MORE_ITEMS)
	    {
		break;
	    }
	    cuPrintAPIError(L"RegEnumKeyEx", hr);
	    goto error;
	}
	DisplayHistoryData(buff, hPolicyKey);
	dwIndex++;
    }
    hr = S_OK;

error:
    if (NULL != hPolicyKey)
    {
	RegCloseKey(hPolicyKey);
    }
    return(hr);
}


//
// DisplayAlias()
//
// This function displays the certificate template alias GUID, so that
// we can see which GUID | Certtype will be enrolled for.
//

HRESULT
DisplayAlias(
    IN DWORD dwFlags)
{
    HRESULT hr;
    HKEY hKey = (TE_MACHINE & dwFlags)? HKEY_LOCAL_MACHINE : HKEY_CURRENT_USER;
    HKEY hAliasKey = NULL;
    WCHAR wszguid[MAX_PATH];
    DWORD cwc;
    DWORD dwType = 0;
    WCHAR *wszTrim = NULL;

    // Output

    switch (dwFlags)
    {
	case TE_MACHINE:
        wprintf(myLoadResourceString(IDS_DEFAULT_CERT_FOR_MACHINE));
        wprintf(wszNewLine);
	    break;

	default:
        wprintf(myLoadResourceString(IDS_DEFAULT_CERT_FOR_USER));
        wprintf(wszNewLine);
    }

    // Open alias key for admin cert type

    hr = RegOpenKeyEx(
		    hKey,
		    wszREGADMINALIAS,
		    0,
		    KEY_ENUMERATE_SUB_KEYS | KEY_QUERY_VALUE | KEY_READ,
		    &hAliasKey);

    if (S_OK != hr)
    {
	    cuPrintAPIError(L"RegOpenKey", hr);

        wprintf(myLoadResourceString(IDS_POLICY_DOWNLOAD_ERROR));
        wprintf(wszNewLine);

	    return(hr);
    }

    cwc = ARRAYSIZE(wszguid);
    hr = RegQueryValueEx(
			hAliasKey,
			L"Alias",
			0,
			&dwType,
			(BYTE *) wszguid,
			&cwc);
    if (S_OK != hr)
    {
	cuPrintAPIError(L"RegQueryValue", hr);
	goto error;
    }

    // Trim off |Administrator

    wszTrim = wcschr(wszguid, L'|');

    if(wszTrim)
        *wszTrim = L'\0';

    wprintf(wszguid);
    wprintf(L"\n\n");

error:

    if (NULL != hAliasKey)
	RegCloseKey(hAliasKey);

    return(hr);
}


//
// ShowUserAndComputerInfo()
//
// GetUserName and GetComputerName()
//

HRESULT
ShowUserAndComputerInfo()
{
    HRESULT hr;
    WCHAR buff[256];
    DWORD cwc;

    cwc = ARRAYSIZE(buff);
    if (!GetComputerNameEx(ComputerNamePhysicalNetBIOS, buff, &cwc))
    {
        hr = myHLastError();
	    _PrintError(hr, "GetComputerNameEx");
        cuPrintAPIError(L"GetComputerNameEx", hr);
    }
    else
    {
        wprintf(myLoadResourceString(IDS_FORMAT_COMPUTER_NAME), buff);
		wprintf(wszNewLine);
	    hr = S_OK;
    }

    cwc = ARRAYSIZE(buff);
    if (!GetUserNameEx(NameSamCompatible, buff, &cwc))
    {
	HRESULT hr2 = myHLastError();

	_PrintError(hr, "GetUserNameEx");
        cuPrintAPIError(L"GetUserNameEx", hr2);
	if (S_OK == hr)
	{
	    hr = hr2;
	}
    }
    else
    {
        wprintf(myLoadResourceString(IDS_FORMAT_USER_NAME), buff);
		wprintf(wszNewLine);
		wprintf(wszNewLine);
    }

//error:
    return(hr);
}


//
// Display Client Info
//
// This function is responsible for printing out the certificate template
// alias information, as well as any policies downloaded for an individual
// machine.
//

HRESULT
DisplayClientInfo()
{
    HRESULT hr = S_OK;
    HRESULT hr2;
    WCHAR **rgwszDSSearchRes = NULL;
    WCHAR *rgwszSearch[] = { L"mail", NULL };

    // Show user and computer name *including domain*

    hr2 = ShowUserAndComputerInfo();
    _PrintIfError(hr2, "ShowUserAndComputerInfo");
    if (S_OK == hr)
    {
	hr = hr2;
    }

    // First, we want to display current alias info

    hr2 = DisplayAlias(TE_USER);
    _PrintIfError(hr2, "DisplayAlias");
    if (S_OK == hr)
    {
	hr = hr2;
    }

    hr2 = DisplayAlias(TE_MACHINE);
    _PrintIfError(hr2, "DisplayAlias");
    if (S_OK == hr)
    {
	hr = hr2;
    }

    // Then, display all of the policies downloaded

    hr2 = DisplayPolicyList(TE_USER);
    _PrintIfError(hr2, "DisplayPolicyList");
    if (S_OK == hr)
    {
	hr = hr2;
    }

    hr2 = DisplayPolicyList(TE_MACHINE);
    _PrintIfError(hr2, "DisplayPolicyList");
    if (S_OK == hr)
    {
	hr = hr2;
    }


    // Show the root certificates in the LMGP store

    hr2 = DisplayLMGPRoot();
    _PrintIfError(hr2, "DisplayLMGPRoot");
    if (S_OK == hr)
    {
	hr = hr2;
    }

    // Display autoenrollment object(s)
#if 0
    hr2 = DisplayAutoenrollmentObjects();
    _PrintIfError(hr2, "DisplayAutoenrollmentObjects");
    if (S_OK == hr)
    {
	hr = hr2;
    }
#endif

    // Verify DC LDAP connectivity
    // PingDC();

    rgwszDSSearchRes = GetPropertyFromDSObject(rgwszSearch, FALSE, NULL);
    if (NULL != rgwszDSSearchRes)
    {
	ResultFree(rgwszDSSearchRes);
    }

//error:
    return(hr);
}


HRESULT
verbTCAInfo(
    IN WCHAR const *pwszOption,
    OPTIONAL IN WCHAR const *pwszDomain,
    OPTIONAL IN WCHAR const *pwszPing,
    IN WCHAR const *pwszArg3,
    IN WCHAR const *pwszArg4)
{
    HRESULT hr;

    if (NULL == pwszDomain && NULL == pwszPing)
    {
	hr = DisplayClientInfo();
	_JumpIfError(hr, error, "DisplayClientInfo");
    }
    else
    {
	BOOL fPing = FALSE;

	if (NULL != pwszDomain && 0 == lstrcmp(L"-", pwszDomain))
	{
	    pwszDomain = NULL;
	}
	if (NULL != pwszPing)
	{
	    if (0 == lstrcmpi(L"ping", pwszPing))
	    {
		fPing = TRUE;
	    }
	    else
	    {
		hr = E_INVALIDARG;
		_JumpError(hr, error, "pwszPing");
	    }
	}
	hr = EnumCAs(pwszDomain, fPing);
	_JumpIfError(hr, error, "EnumCAs");
    }
    hr = S_OK;

error:
    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\tools\certut\resstr.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       resstr.h
//
//--------------------------------------------------------------------------

    RESSTR(IDS_DUMP_DESCRIPTION),
    RESSTR(IDS_GETCONFIG_DESCRIPTION),
    RESSTR(IDS_GETCONFIG2_DESCRIPTION),
    RESSTR(IDS_CAVERSION),
    RESSTR(IDS_DECODEHEX_DESCRIPTION),
    RESSTR(IDS_DECODE_DESCRIPTION),
    RESSTR(IDS_ENCODE_DESCRIPTION),
    RESSTR(IDS_DENY_DESCRIPTION),
    RESSTR(IDS_RESUBMIT_DESCRIPTION),
    RESSTR(IDS_REVOKE_DESCRIPTION),
    RESSTR(IDS_CRL_DESCRIPTION),
    RESSTR(IDS_GETCRL_DESCRIPTION),
    RESSTR(IDS_ISVALID_DESCRIPTION),
    RESSTR(IDS_SETATTRIBUTES_DESCRIPTION),
    RESSTR(IDS_SETEXTENSION_DESCRIPTION),
    RESSTR(IDS_CACERT_DESCRIPTION),
    RESSTR(IDS_CACHAIN_DESCRIPTION),
    RESSTR(IDS_IMPORTKMS_USAGEARGS),
    RESSTR(IDS_IMPORTKMS_DESCRIPTION),
    RESSTR(IDS_DB_DESCRIPTION),
    RESSTR(IDS_VERIFYKEYS_DESCRIPTION),
    RESSTR(IDS_VERIFY_DESCRIPTION),
    RESSTR(IDS_7F_DESCRIPTION),
    RESSTR(IDS_USAGE_DESCRIPTION),
    RESSTR(IDS_VERBOSE_DESCRIPTION),
    RESSTR(IDS_IDISPATCH_DESCRIPTION),
    RESSTR(IDS_REVERSE_DESCRIPTION),
    RESSTR(IDS_OPTIONS_USAGEARGS),
    RESSTR(IDS_CRL_REASON_UNRECOGNIZED),
    RESSTR(IDS_INFILEOUTFILE_USAGEARGS),
    RESSTR(IDS_SCHEMA_COLUMNHEADERS),
    RESSTR(IDS_SCHEMA_COLUMNUNDERLINE),
    RESSTR(IDS_DENY_USAGEARGS),
    RESSTR(IDS_RESUBMIT_USAGEARGS),
    RESSTR(IDS_REVOKE_USAGEARGS),
    RESSTR(IDS_CRL_USAGEARGS),
    RESSTR(IDS_GETCRL_USAGEARGS),
    RESSTR(IDS_ISVALID_USAGEARGS),
    RESSTR(IDS_SETATTRIBUTES_USAGEARGS),
    RESSTR(IDS_SETEXTENSION_USAGEARGS),
    RESSTR(IDS_CACERT_USAGEARGS),
    RESSTR(IDS_CACHAIN_USAGEARGS),
    RESSTR(IDS_VERIFYKEYS_USAGEARGS),
    RESSTR(IDS_VERIFY_USAGEARGS),
    RESSTR(IDS_7F_USAGEARGS),
    RESSTR(IDS_ERR_NOMEMORY),
    RESSTR(IDS_FORMAT_USAGE_MISSINGNAMEDARG),
    RESSTR(IDS_FORMAT_USAGE_UNKNOWNARG),
    RESSTR(IDS_FORMAT_USAGE_MULTIPLEVERBARGS),
    RESSTR(IDS_USAGE_MISSINGARG),
    RESSTR(IDS_USAGE_TOOMANYARGS),
    RESSTR(IDS_USAGE_INTERNALVERBTABLEERROR),
    RESSTR(IDS_FORMAT_USAGE_EXTRAOPTION),
    RESSTR(IDS_USAGE_HEADER),
    RESSTR(IDS_USAGE_OPTIONS),
    RESSTR(IDS_USAGE_VERBS),
    RESSTR(IDS_OIDNAME_ARGDESCRIPTION),
    RESSTR(IDS_INDEXED),
    RESSTR(IDS_FORMAT_INPUT_LENGTH),
    RESSTR(IDS_NO_KEYAUTHORITYSERIAL),
    RESSTR(IDS_FORMAT_OUTPUT_LENGTH),
    RESSTR(IDS_ERR_FORMAT_DECODEFILE),
    RESSTR(IDS_ERR_FORMAT_ENCODETOFILE),
    RESSTR(IDS_ISSUER),
    RESSTR(IDS_SUBJECT),
    RESSTR(IDS_ERR_FORMAT_ISSUER_NOT_KEYAUTHORITY),
    RESSTR(IDS_ISSUER_IS_KEYAUTHORITY),
    RESSTR(IDS_NO_KEYAUTHORITY),
    RESSTR(IDS_SERIAL_NOT_KEYAUTHORITY),
    RESSTR(IDS_SERIAL_IS_KEYAUTHORITY),
    RESSTR(IDS_ISSUERNAME),
    RESSTR(IDS_KEYAUTHORITYNAME),
    RESSTR(IDS_KEYID),
    RESSTR(IDS_KEYAUTHORITYSERIAL),
    RESSTR(IDS_CASERIAL),
    RESSTR(IDS_PROCESSCOLON),
    RESSTR(IDS_TCAINFO_USAGEARGS),
    RESSTR(IDS_ERR_FORMAT_LOADKEYS),
    RESSTR(IDS_ERR_FORMAT_LOADCACERT),
    RESSTR(IDS_ERR_PUBLICKEY_MISMATCH),
    RESSTR(IDS_CONTAINER_PUBLIC_KEY),
    RESSTR(IDS_CERT_PUBLIC_KEY),
    RESSTR(IDS_FORMAT_KEY_IS_VERIFY),
    RESSTR(IDS_FORMAT_KEY_NOT_VERIFY),
    RESSTR(IDS_FORMAT_IS_REVOKED),
    RESSTR(IDS_ERR_FORMAT_VERIFY_REVSTATUS),
    RESSTR(IDS_CANNOT_CHECK_REVSTATUS),
    RESSTR(IDS_REVSTATUS_OK),
    RESSTR(IDS_FORMAT_LOADTESTCERT),
    RESSTR(IDS_FORMAT_LOADCACERT),
    RESSTR(IDS_CERT),
    RESSTR(IDS_CA),
    RESSTR(IDS_CERT_SERIAL),
    RESSTR(IDS_ROOT_SERIAL),
    RESSTR(IDS_FORMAT_CA_NOT_ROOT),
    RESSTR(IDS_FORMAT_CA_SUBJECT_NOT_ISSUER),
    RESSTR(IDS_CA_SUBJECT_IS_ISSUER),
    RESSTR(IDS_FORMAT_CERTVERIFYSUBJECTCERTIFICATECONTEXT_FLAGS),
    RESSTR(IDS_ERR_FORMAT_VALIDATION),
    RESSTR(IDS_ERR_CA_SIG_NOT_ISSUER),
    RESSTR(IDS_ERR_EXPIRED),
    RESSTR(IDS_CURRENT_SIG_OK),
    RESSTR(IDS_CRL_DIST_POINTS),
    RESSTR(IDS_NETSCAPE_REVOCATION_URL),
    RESSTR(IDS_NO_REVCHECKEXTENSION),
    RESSTR(IDS_FORMAT_IS_VERIFY),
    RESSTR(IDS_FORMAT_NOT_VERIFY),
    RESSTR(IDS_FORMAT_REVCHECK_SKIPPED),
    RESSTR(IDS_FORMAT_REVCHECK_PASS),
    RESSTR(IDS_FORMAT_REVCHECK_REVOKED),
    RESSTR(IDS_FORMAT_REVCHECK_FAIL),
    RESSTR(IDS_SIGNATUREMATCHES),
    RESSTR(IDS_CRLENTRIES),
    RESSTR(IDS_CERTCOLON),
    RESSTR(IDS_QUESTIONMARKS),
    RESSTR(IDS_FORMAT_SUSPECT_LENGTH),
    RESSTR(IDS_FORMAT_FIELD),
    RESSTR(IDS_FORMAT_OID),
    RESSTR(IDS_FORMAT_EXTENSION_OID),
    RESSTR(IDS_ERR_FORMAT_NO_SIGNATUREMATCHES),
    RESSTR(IDS_ERR_FORMAT_CANNOT_DECODE),
    RESSTR(IDS_ALG_OID),
    RESSTR(IDS_ALG_PARAMETERS_COLON),
    RESSTR(IDS_NULL),
    RESSTR(IDS_FORMAT_PUBLICKEY_UNUSEDBITS),
    RESSTR(IDS_FORMAT_CHALLENGE_STRING),
    RESSTR(IDS_FORMAT_CONFIG_STRING),
    RESSTR(IDS_FORMAT_ICERTCONFIG_CONFIG_STRING),
    RESSTR(IDS_FORMAT_PENDING_REQUESTID),
    RESSTR(IDS_CERT_ISSUED),
    RESSTR(IDS_CERT_NOT_ISSUED_DISPOSITION),
    RESSTR(IDS_CERT_DISPOSITION_INVALID),
    RESSTR(IDS_CERT_DISPOSITION_VALID),
    RESSTR(IDS_CERT_DISPOSITION_REVOKED),
    RESSTR(IDS_PROPTYPE_DATE),
    RESSTR(IDS_PROPTYPE_LONG),
    RESSTR(IDS_PROPTYPE_STRING),
    RESSTR(IDS_PROPTYPE_BINARY),
    RESSTR(IDS_SCHEMA_COLON),
    RESSTR(IDS_FORMAT_ROWID),
    RESSTR(IDS_FORMAT_OPENING_DB),
    RESSTR(IDS_PROP_EMPTY),
    RESSTR(IDS_FORMAT_ERROR),
    RESSTR(IDS_SEPARATOR),
    RESSTR(IDS_REQTYPE_ANY),
    RESSTR(IDS_REQTYPE_PKCS10),
    RESSTR(IDS_REQTYPE_KEYGEN),
    RESSTR(IDS_REQTYPE_PKCS7),
    RESSTR(IDS_REQTYPE_UNKNOWN),
    RESSTR(IDS_REQFLAGS_FORCETELETEX),
    RESSTR(IDS_REQFLAGS_RENEWAL),
    RESSTR(IDS_CRITICAL),
    RESSTR(IDS_DISABLED),
    RESSTR(IDS_FORMAT_POLICYFLAGS),
    RESSTR(IDS_REQUEST),
    RESSTR(IDS_POLICY),
    RESSTR(IDS_ADMIN),
    RESSTR(IDS_SERVER),
    RESSTR(IDS_UNKNOWN),
    RESSTR(IDS_FORMAT_ORIGIN),
    RESSTR(IDS_FORMAT_UNKNOWN_HEX),
    RESSTR(IDS_GETCONFIG3_DESCRIPTION),
    RESSTR(IDS_REQUEST_PROPERTIES),
    RESSTR(IDS_CERT_PROPERTIES),
    RESSTR(IDS_LOG_COMMANDLINE),
    RESSTR(IDS_CONFIGDISPLAY_SANITIZEDNAME_COLON),
    RESSTR(IDS_FORMAT_EXTENSION),
    RESSTR(IDS_ERR_FORMAT_SHOW_TOO_FEW_ARGS),
    RESSTR(IDS_ERR_FORMAT_SHOW_TOO_MANY_ARGS),
    RESSTR(IDS_ERR_CONFIGGETCONFIG),
    RESSTR(IDS_ERR_FORMAT_COMMAND_FAILED),
    RESSTR(IDS_CHECK7F_FIELD_UNKNOWN),
    RESSTR(IDS_CHECK7F_FIELD_NONE),
    RESSTR(IDS_CHECK7F_FIELD_OTHER),
    RESSTR(IDS_CHECK7F_FIELD_ISSUER),
    RESSTR(IDS_CHECK7F_FIELD_ISSUERRDN),
    RESSTR(IDS_CHECK7F_FIELD_ISSUERRDNATTRIBUTE),
    RESSTR(IDS_CHECK7F_FIELD_ISSUERRDNSTRING),
    RESSTR(IDS_CHECK7F_FIELD_SUBJECT),
    RESSTR(IDS_CHECK7F_FIELD_SUBJECTRDN),
    RESSTR(IDS_CHECK7F_FIELD_SUBJECTRDNATTRIBUTE),
    RESSTR(IDS_CHECK7F_FIELD_SUBJECTRDNSTRING),
    RESSTR(IDS_CHECK7F_FIELD_EXTENSIONS),
    RESSTR(IDS_CHECK7F_FIELD_EXTENSIONARRAY),
    RESSTR(IDS_CHECK7F_FIELD_EXTENSION),
    RESSTR(IDS_CHECK7F_FIELD_EXTENSIONVALUE),
    RESSTR(IDS_CHECK7F_FIELD_EXTENSIONVALUERAW),
    RESSTR(IDS_NO_KEY_PROVIDER_INFO),
    RESSTR(IDS_VIEW_DESCRIPTION),
    RESSTR(IDS_FORMAT_ADDED_TO_DS_STORE),
    RESSTR(IDS_PING_DESCRIPTION),
    RESSTR(IDS_PINGADMIN_DESCRIPTION),
    RESSTR(IDS_CONFIGDISPLAY_COMMONNAME_COLON),
    RESSTR(IDS_CONFIGDISPLAY_ORGUNIT_COLON),
    RESSTR(IDS_CONFIGDISPLAY_ORG_COLON),
    RESSTR(IDS_CONFIGDISPLAY_LOCALITY_COLON),
    RESSTR(IDS_CONFIGDISPLAY_STATE_COLON),
    RESSTR(IDS_CONFIGDISPLAY_COUNTRY_COLON),
    RESSTR(IDS_CONFIGDISPLAY_CONFIG_COLON),
    RESSTR(IDS_CONFIGDISPLAY_EXCHANGECERT_COLON),
    RESSTR(IDS_CONFIGDISPLAY_SIGCERT_COLON),
    RESSTR(IDS_CONFIGDISPLAY_DESCRIPTION_COLON),
    RESSTR(IDS_CONFIGDISPLAY_SERVER_COLON),
    RESSTR(IDS_CONFIGDISPLAY_AUTHORITY_COLON),
    RESSTR(IDS_CONFIGDISPLAY_ENTRY),
    RESSTR(IDS_CERTIFICATE_EXTENSIONS),
    RESSTR(IDS_REQUEST_ATTRIBUTES),
    RESSTR(IDS_SHUTDOWN_DESCRIPTION),
    RESSTR(IDS_LOG_STATUS),
    RESSTR(IDS_SCHEMA_DESCRIPTION),
    RESSTR(IDS_LOG_STATUSOK),
    RESSTR(IDS_PASSWORD_DESCRIPTION),
    RESSTR(IDS_DUMP_CERT),
    RESSTR(IDS_DUMP_CRL),
    RESSTR(IDS_DUMP_REQUEST),
    RESSTR(IDS_DUMP_KEYGEN),
    RESSTR(IDS_FORMAT_VERSION),
    RESSTR(IDS_SERIAL),
    RESSTR(IDS_SIGNATURE_ALGORITHM),
    RESSTR(IDS_PUBLICKEY_ALGORITHM),
    RESSTR(IDS_ISSUERUNIQUEID),
    RESSTR(IDS_SUBJECTUNIQUEID),
    RESSTR(IDS_NOTBEFORE),
    RESSTR(IDS_NOTAFTER),
    RESSTR(IDS_THISUPDATE),
    RESSTR(IDS_NEXTUPDATE),
    RESSTR(IDS_REVOCATIONDATE),
    RESSTR(IDS_EXTENSIONS),
    RESSTR(IDS_CRLEXTENSIONS),
    RESSTR(IDS_DUMP_PKCS7),
    RESSTR(IDS_ERR_FORMAT_ROOT_CERT_BAD_SIG),
    RESSTR(IDS_NO_ROOT_CERT),
    RESSTR(IDS_ROOT_CERT),
    RESSTR(IDS_NO_ROOT_CERT_GOOD_SIG),
    RESSTR(IDS_REVOKING),
    RESSTR(IDS_PASSWORDPROMPT),
    RESSTR(IDS_UNKNOWN_EXTENSION),
    RESSTR(IDS_PRIVATEKEY),
    RESSTR(IDS_LENGTH),
    RESSTR(IDS_GMT_DESCRIPTION),
    RESSTR(IDS_GMT_SUFFIX),
    RESSTR(IDS_BACKUPPFX_USAGEARGS),
    RESSTR(IDS_BACKUPPFX_DESCRIPTION),
    RESSTR(IDS_RESTOREPFX_USAGEARGS),
    RESSTR(IDS_RESTOREPFX_DESCRIPTION),
    RESSTR(IDS_STORE_USAGEARGS),
    RESSTR(IDS_STORE_DESCRIPTION),
    RESSTR(IDS_FORMAT_PROVIDER_TYPE),
    RESSTR(IDS_FORMAT_KEY_CONTAINER),
    RESSTR(IDS_FORMAT_PROVIDER_NAME),
    RESSTR(IDS_FORMAT_KEYSPEC),
    RESSTR(IDS_FORMAT_FLAGS),
    RESSTR(IDS_FORMAT_RESTORED),
    RESSTR(IDS_FORMAT_BACKEDUP),
    RESSTR(IDS_INSTALLCERT_USAGEARGS),
    RESSTR(IDS_INSTALLCERT_DESCRIPTION),
    RESSTR(IDS_DUMP_PKCS7_CONTENTS),
    RESSTR(IDS_DUMP_PKCS7_ATTRIBUTES),
    RESSTR(IDS_DUMP_PKCS7_SIGNCERT),
    RESSTR(IDS_FORMAT_DUMP_LEVEL_START),
    RESSTR(IDS_FORMAT_DUMP_LEVEL_END),
    RESSTR(IDS_FORMAT_LANG),
    RESSTR(IDS_FORMAT_FILE),
    RESSTR(IDS_FORMAT_PRODUCT),
    RESSTR(IDS_DUMP_PKCS7_NO_SIGNER),
    RESSTR(IDS_DUMP_PKCS7_NO_CONTENT),
    RESSTR(IDS_DUMP_PKCS7_NO_CERTIFICATES),
    RESSTR(IDS_DUMP_PKCS7_NO_CRLS),
    RESSTR(IDS_DUMP_PKCS7_CERTIFICATES),
    RESSTR(IDS_DUMP_PKCS7_CRLS),
    RESSTR(IDS_RENEWAL_CERT),
    RESSTR(IDS_FORMAT_ENCRYPTEDHASH_COLON),
    RESSTR(IDS_FORMAT_PKCS7_ATTRIBUTE_COUNT),
    RESSTR(IDS_ATTRIBUTE),
    RESSTR(IDS_FORMAT_PKCS7_ATTRIBUTE_VALUE),
    RESSTR(IDS_BACKUPDB_USAGEARGS),
    RESSTR(IDS_BACKUPDB_DESCRIPTION),
    RESSTR(IDS_RESTOREDB_USAGEARGS),
    RESSTR(IDS_RESTOREDB_DESCRIPTION),
    RESSTR(IDS_CRL_REASON_UNSPECIFIED),
    RESSTR(IDS_CRL_REASON_KEY_COMPROMISE),
    RESSTR(IDS_CRL_REASON_CA_COMPROMISE),
    RESSTR(IDS_CRL_REASON_AFFILIATION_CHANGED),
    RESSTR(IDS_CRL_REASON_SUPERSEDED),
    RESSTR(IDS_CRL_REASON_CESSATION_OF_OPERATION),
    RESSTR(IDS_CRL_REASON_CERTIFICATE_HOLD),
    RESSTR(IDS_CRL_REASON_REMOVE_FROM_CRL),
    RESSTR(IDS_CSP_DESCRIPTION),
    RESSTR(IDS_CSPTEST_DESCRIPTION),
    RESSTR(IDS_CSPTEST_USAGEARGS),
    RESSTR(IDS_SILENT_DESCRIPTION),
    RESSTR(IDS_VIEW_ARGDESCRIPTION),
    RESSTR(IDS_GETCERT_USAGEARGS),
    RESSTR(IDS_DISP_ACTIVE),
    RESSTR(IDS_DISP_PENDING),
    RESSTR(IDS_DISP_ISSUED),
    RESSTR(IDS_DISP_REVOKED),
    RESSTR(IDS_DISP_ERROR),
    RESSTR(IDS_DISP_DENIED),
    RESSTR(IDS_RENEWALCERT),
    RESSTR(IDS_FORMAT_RESTORE_NEEDS_RESTART),
    RESSTR(IDS_ADMIN_INTERFACE_ALIVE),
    RESSTR(IDS_DB_OPEN_FAILURE),
    RESSTR(IDS_DB_ACCESS_STOP_SERVER),
    RESSTR(IDS_CONFIGDISPLAY_LOCAL),
    RESSTR(IDS_ERR_FORMAT_NO_LOCAL_CONFIG),
    RESSTR(IDS_CRL_REASON_UNREVOKE),
    RESSTR(IDS_ERROR_ACCESSDENIED_CAUSE),
    RESSTR(IDS_NO_KEY_PROPERTY),
    RESSTR(IDS_FORMAT_SERVER_ALIVE),
    RESSTR(IDS_FORMAT_CONNECTING),
    RESSTR(IDS_USER_DESCRIPTION),
    RESSTR(IDS_FORMAT_DUMP_CERT_INDEX),
    RESSTR(IDS_NEWPASSWORDPROMPT),
    RESSTR(IDS_CONFIRMPASSWORDPROMPT),
    RESSTR(IDS_NOCONFIRMPASSWORD),
    RESSTR(IDS_NO_KEY),
    RESSTR(IDS_BACKUP_USAGEARGS),
    RESSTR(IDS_BACKUP_DESCRIPTION),
    RESSTR(IDS_RESTORE_USAGEARGS),
    RESSTR(IDS_RESTORE_DESCRIPTION),
    RESSTR(IDS_ADDSTORE_USAGEARGS),
    RESSTR(IDS_ADDSTORE_DESCRIPTION),
    RESSTR(IDS_DELSTORE_USAGEARGS),
    RESSTR(IDS_DELSTORE_DESCRIPTION),
    RESSTR(IDS_VERIFYSTORE_USAGEARGS),
    RESSTR(IDS_VERIFYSTORE_DESCRIPTION),
    RESSTR(IDS_FORMAT_DELETE_CERT_INDEX),
    RESSTR(IDS_UNTRUSTED_ROOT),
    RESSTR(IDS_INCOMPLETE_CHAIN),
    RESSTR(IDS_CERT_VERIFIES),
    RESSTR(IDS_CR_DISP_INCOMPLETE),
    RESSTR(IDS_CR_DISP_ERROR),
    RESSTR(IDS_CR_DISP_DENIED),
    RESSTR(IDS_CR_DISP_ISSUED),
    RESSTR(IDS_CR_DISP_ISSUED_OUT_OF_BAND),
    RESSTR(IDS_CR_DISP_UNDER_SUBMISSION),
    RESSTR(IDS_CR_DISP_REVOKED),
    RESSTR(IDS_CERT_DISPOSITION_PENDING),
    RESSTR(IDS_ROOT_STORE_NEEDS_ROOT_CERT),
    RESSTR(IDS_FORCE_DESCRIPTION),
    RESSTR(IDS_FORMAT_USE_FORCE),
    RESSTR(IDS_FORMAT_BACKEDUPDBNOFULL),
    RESSTR(IDS_FORMAT_BACKEDUPDBFULL),
    RESSTR(IDS_FORMAT_BACKEDUPDB),
    RESSTR(IDS_FORMAT_BACKEDUPDBKEEP),
    RESSTR(IDS_FORMAT_BACKEDUPDBNOKEEP),
    RESSTR(IDS_FORMAT_RESTOREDB),
    RESSTR(IDS_UNKNOWN_ATTRIBUTE),
    RESSTR(IDS_OIDNAME_USAGEARGS),
    RESSTR(IDS_OIDNAME_DESCRIPTION),
    RESSTR(IDS_UNKNOWN_OBJECTID),
    RESSTR(IDS_IMPORTCERT_USAGEARGS),
    RESSTR(IDS_IMPORTCERT_DESCRIPTION),
    RESSTR(IDS_FORMAT_IMPORTCERT),
    RESSTR(IDS_REVOCATION_OFFLINE),
    RESSTR(IDS_NO_REVOCATION_CHECK),
    RESSTR(IDS_DYNAMICFILES_DESCRIPTION),
    RESSTR(IDS_GETREG_USAGEARGS),
    RESSTR(IDS_GETREG_DESCRIPTION),
    RESSTR(IDS_SETREG_USAGEARGS),
    RESSTR(IDS_SETREG_DESCRIPTION),
    RESSTR(IDS_OLD_REG_VALUE),
    RESSTR(IDS_NEW_REG_VALUE),
    RESSTR(IDS_FORMAT_ALTNAMECOUNT),
    RESSTR(IDS_ALTNAME),
    RESSTR(IDS_DATABASELOCATIONS_DESCRIPTION),
    RESSTR(IDS_FORMAT_INVALIDBACKUPDIR),
    RESSTR(IDS_FORMAT_INVALIDRESTOREDIR),
    RESSTR(IDS_FORMAT_BADBACKUPRESULTS),
    RESSTR(IDS_FORMAT_RESTOREDDBNOFULL),
    RESSTR(IDS_FORMAT_RESTOREDDBFULL),
    RESSTR(IDS_IMPORTEDCERT),
    RESSTR(IDS_NOWNOTBEFORE_ERROR),
    RESSTR(IDS_NOWNOTAFTER_ERROR),
    RESSTR(IDS_CANOTBEFORE_ERROR),
    RESSTR(IDS_CANOTAFTER_ERROR),
    RESSTR(IDS_TELETEX_EXTENSIONS),
    RESSTR(IDS_ERRCODE_USAGEARGS),
    RESSTR(IDS_ERRCODE_DESCRIPTION),
    RESSTR(IDS_VROOT_DESCRIPTION),
    RESSTR(IDS_FORMAT_VROOT),
    RESSTR(IDS_FORMAT_FILESHARE),
    RESSTR(IDS_VROOTDISP_CREATED),
    RESSTR(IDS_VROOTDISP_DELETED),
    RESSTR(IDS_VROOTDISP_EXISTS),
    RESSTR(IDS_VROOTDISP_NOTFOUND),
    RESSTR(IDS_VROOTDISP_CREATEERROR),
    RESSTR(IDS_VROOTDISP_DELETERROR),
    RESSTR(IDS_VROOTDISP_NOTSUPPORTED),
    RESSTR(IDS_VROOT_USAGEARGS),
    RESSTR(IDS_BACKUPPROGRESSDB),
    RESSTR(IDS_BACKUPPROGRESSLOG),
    RESSTR(IDS_BACKUPPROGRESSTRUNCATELOG),
    RESSTR(IDS_RESTOREPROGRESSDB),
    RESSTR(IDS_RESTOREPROGRESSLOG),
    RESSTR(IDS_MAXINDEX),
    RESSTR(IDS_DISP_CA_CERT),
    RESSTR(IDS_DISP_CA_CERT_CHAIN),
    RESSTR(IDS_CHARS),
    RESSTR(IDS_OVERFLOW),
    RESSTR(IDS_FORMAT_USAGE_REPEATEDNAMEDARG),
    RESSTR(IDS_INCOMPLETE_CONFIG),
    RESSTR(IDS_DSPUBLISH_ARGDESCRIPTION),
    RESSTR(IDS_DB_ACCESS_INSTALL_SERVER),
    RESSTR(IDS_RED_CONNECTING),
    RESSTR(IDS_RED_CONNECT_FAIL),
    RESSTR(IDS_RED_CROW_CONVERT),
    RESSTR(IDS_RED_CROW_DUP),
    RESSTR(IDS_RED_CROW_BADCA),
    RESSTR(IDS_RED_ROWID),
    RESSTR(IDS_RED_SKIP_DUP),
    RESSTR(IDS_RED_SKIP_BADCA),
    RESSTR(IDS_RED_ROW_MAP),
    RESSTR(IDS_RED_BEGIN_NAMES),
    RESSTR(IDS_RED_END_NAMES),
    RESSTR(IDS_GETMAPI_DESCRIPTION),
    RESSTR(IDS_SETMAPI_USAGEARGS),
    RESSTR(IDS_SETMAPI_DESCRIPTION),
    RESSTR(IDS_VIEW_ROWS),
    RESSTR(IDS_VIEW_ROWPROPERTIES),
    RESSTR(IDS_VIEW_ATTRIBUTES),
    RESSTR(IDS_VIEW_EXTENSIONS),
    RESSTR(IDS_VIEW_TOTALFIELDS),
    RESSTR(IDS_VIEW_STATS),
    RESSTR(IDS_PRIVATE_KEY_NOT_EXPORTABLE),
    RESSTR(IDS_ENTERPRISE_ROOT),
    RESSTR(IDS_ENTERPRISE_SUB),
    RESSTR(IDS_STANDALONE_ROOT),
    RESSTR(IDS_STANDALONE_SUB),
    RESSTR(IDS_CATYPE_UNKNOWN),
    RESSTR(IDS_RENEWCERT_USAGEARGS),
    RESSTR(IDS_RENEWCERT_DESCRIPTION),
    RESSTR(IDS_FORMAT_CERTHASH_COLON),
    RESSTR(IDS_FORMAT_MESSAGE_TEXT),
    RESSTR(IDS_FORMAT_DUMP_CRL_INDEX),
    RESSTR(IDS_FORMAT_DELETE_CRL_INDEX),
    RESSTR(IDS_FORMAT_CCACERTS),
    RESSTR(IDS_KEYS),
    RESSTR(IDS_VALUES),
    RESSTR(IDS_FORMAT_LOADTESTCRL),
    RESSTR(IDS_CRL),
    RESSTR(IDS_NOWNOTBEFORECRL_ERROR),
    RESSTR(IDS_NOWNOTAFTERCRL_ERROR),
    RESSTR(IDS_CANOTBEFORECRL_ERROR),
    RESSTR(IDS_CANOTAFTERCRL_ERROR),
    RESSTR(IDS_FORMAT_CA_CRLSUBJECT_NOT_ISSUER),
    RESSTR(IDS_CA_CRLSUBJECT_IS_ISSUER),
    RESSTR(IDS_ERR_CA_SIG_NOT_CRLISSUER),
    RESSTR(IDS_CRL_SIG_OK),
    RESSTR(IDS_KEYID_IS_KEYAUTHORITY),
    RESSTR(IDS_ERR_KEYID_NOT_KEYAUTHORITY),
    RESSTR(IDS_NO_KEYID),
    RESSTR(IDS_CADISP_INCOMPLETE),
    RESSTR(IDS_CADISP_ERROR),
    RESSTR(IDS_CADISP_ERROR_CRL),
    RESSTR(IDS_CADISP_REVOKED),
    RESSTR(IDS_CADISP_VALID),
    RESSTR(IDS_CADISP_EXPIRED),
    RESSTR(IDS_CADISP_UNDERSUBMISSION),
    RESSTR(IDS_CADISP_UNKNOWN),
    RESSTR(IDS_KEY_USAGEARGS),
    RESSTR(IDS_KEY_DESCRIPTION),
    RESSTR(IDS_DELKEY_USAGEARGS),
    RESSTR(IDS_DELKEY_DESCRIPTION),
    RESSTR(IDS_REVOKED_CERT),
    RESSTR(IDS_PROP_CACERSTATUSCODE),
    RESSTR(IDS_CONFIGDISPLAY_FLAGS_COLON),
    RESSTR(IDS_ERR_PRIVATEKEY_MISMATCH),
    RESSTR(IDS_SIGNATURE_OK),
    RESSTR(IDS_SIGNATURE_BAD),
    RESSTR(IDS_DSCERT_DESCRIPTION),
    RESSTR(IDS_DSCERT_USAGEARGS),
    RESSTR(IDS_DSCRL_DESCRIPTION),
    RESSTR(IDS_DSCRL_USAGEARGS),
    RESSTR(IDS_DS_USAGEARGS),
    RESSTR(IDS_DS_DESCRIPTION),
    RESSTR(IDS_DSDEL_USAGEARGS),
    RESSTR(IDS_DSDEL_DESCRIPTION),
    RESSTR(IDS_DELETING),
    RESSTR(IDS_CAINFO_USAGEARGS),
    RESSTR(IDS_CAINFO_DESCRIPTION),
    RESSTR(IDS_CAINFO_USAGEHEADERCOLON),
    RESSTR(IDS_CAINFO_USAGEERROR),
    RESSTR(IDS_CAINFO_USAGEINDEX),
    RESSTR(IDS_REQFLAGS_FORCEUTF8),
    RESSTR(IDS_FORMAT_SIGNATURE_UNUSEDBITS),
    RESSTR(IDS_CONFIGDISPLAY_SHORTNAME_COLON),
    RESSTR(IDS_CONFIGDISPLAY_SANITIZEDSHORTNAME_COLON),
    RESSTR(IDS_SMIME_CAPABILITIES),
    RESSTR(IDS_REQUEST_FILE_COLON),
    RESSTR(IDS_PKCS7ATTRIBUTE),
    RESSTR(IDS_NO_SIGNATURE),
    RESSTR(IDS_DUMP_CERTSEQ),
    RESSTR(IDS_MISSING_CERT),
    RESSTR(IDS_SCHEMA_USAGE),
    RESSTR(IDS_VIEW_USAGE),
    RESSTR(IDS_DSDELTACRL_USAGEARGS),
    RESSTR(IDS_DSDELTACRL_DESCRIPTION),
    RESSTR(IDS_SECONDS_DESCRIPTION),
    RESSTR(IDS_NOBASICCONSTRAINTS2_ERROR),
    RESSTR(IDS_CANNOTDECODEBASICCONSTRAINTS2_ERROR),
    RESSTR(IDS_ENDENTITYCACERT_ERROR),
    RESSTR(IDS_CACERT),
    RESSTR(IDS_ENDENTITYCERT),
    RESSTR(IDS_FORMAT_ELEMENT),
    RESSTR(IDS_REQTYPE_CMC),
    RESSTR(IDS_ERR_FORMAT_BAD_CERT),
    RESSTR(IDS_ENCRYPTION_OK),
    RESSTR(IDS_ENCRYPTION_BAD),
    RESSTR(IDS_V1_DESCRIPTION),
    RESSTR(IDS_PROP_FILEVERSION),
    RESSTR(IDS_PROP_PRODUCTVERSION),
    RESSTR(IDS_PROP_EXITCOUNT),
    RESSTR(IDS_PROP_EXITDESCRIPTION),
    RESSTR(IDS_PROP_POLICYDESCRIPTION),
    RESSTR(IDS_PROP_CANAME),
    RESSTR(IDS_PROP_SANITIZEDCANAME),
    RESSTR(IDS_PROP_SHAREDFOLDER),
    RESSTR(IDS_PROP_CATYPE),
    RESSTR(IDS_PROP_PARENTCA),
    RESSTR(IDS_PROP_CASIGCERTCOUNT),
    RESSTR(IDS_PROP_CASIGCERT),
    RESSTR(IDS_PROP_CASIGCERTCHAIN),
    RESSTR(IDS_PROP_CAXCHGCERTCOUNT),
    RESSTR(IDS_PROP_CAXCHGCERT),
    RESSTR(IDS_PROP_CAXCHGCERTCHAIN),
    RESSTR(IDS_PROP_BASECRL),
    RESSTR(IDS_PROP_DELTACRL),
    RESSTR(IDS_PROP_CACERTSTATE),
    RESSTR(IDS_PROP_CRLSTATE),
    RESSTR(IDS_PROP_CAINFO),
    RESSTR(IDS_CAPROPINFO_DESCRIPTION),
    RESSTR(IDS_ADMIN_DESCRIPTION),
    RESSTR(IDS_PROP_CAPROPIDMAX),
    RESSTR(IDS_GETCERT_DESCRIPTION),
    RESSTR(IDS_GETCERT_TITLE),
    RESSTR(IDS_GETCERT_SUBTITLE),
    RESSTR(IDS_GETCERT_SUBTITLE_OBJID),
    RESSTR(IDS_GETCERT_SUBTITLE_ERA),
    RESSTR(IDS_GETCERT_SUBTITLE_KRA),
    RESSTR(IDS_FORMAT_KEYHASH_COLON),
    RESSTR(IDS_DUMP_CMC),
    RESSTR(IDS_DUMP_CMCRESPONSE),
    RESSTR(IDS_TAGGED_ATTRIBUTES),
    RESSTR(IDS_TAGGED_CONTENTINFO),
    RESSTR(IDS_TAGGED_REQUESTS),
    RESSTR(IDS_TAGGED_OTHERMESSAGES),
    RESSTR(IDS_UNKNOWN_REQUEST_CHOICE),
    RESSTR(IDS_BODY_PART_ID),
    RESSTR(IDS_ERR_FORMAT_LOADKEY),
    RESSTR(IDS_EXPIRED_CERT),
    RESSTR(IDS_DUMP_PKCS7_UNAUTHATTRIBUTES),
    RESSTR(IDS_DUMP_PKCS7_CONTENT_TYPE),
    RESSTR(IDS_DATA_REFERENCE),
    RESSTR(IDS_CERT_REFERENCE),
    RESSTR(IDS_VALUE),
    RESSTR(IDS_UNKNOWN_TAGGED_ATTRIBUTE),
    RESSTR(IDS_DUMP_PKCS7_SIGNER_COUNT),
    RESSTR(IDS_SIGNER_INFO),
    RESSTR(IDS_HASH_ALGORITHM),
    RESSTR(IDS_HASH_ENCRYPTION_ALGORITHM),
    RESSTR(IDS_FORMAT_STORED_HASH_COLON),
    RESSTR(IDS_FORMAT_COMPUTED_HASH_COLON),
    RESSTR(IDS_CMCATTRIBUTE),
    RESSTR(IDS_EXCHANGEAIA),
    RESSTR(IDS_EXCHANGEVERSION),
    RESSTR(IDS_HASHFILE_USAGEARGS),
    RESSTR(IDS_HASHFILE_DESCRIPTION),
    RESSTR(IDS_FORMAT_HASHFILEOUTPUT),
    RESSTR(IDS_REQFLAGS_CAXCHGCERT),
    RESSTR(IDS_PASS),
    RESSTR(IDS_DUMP_PKCS7_NO_RECIPIENT),
    RESSTR(IDS_DUMP_PKCS7_RECIPIENT_COUNT),
    RESSTR(IDS_RECIPIENT_INFO),
    RESSTR(IDS_PROP_DNSNAME),
    RESSTR(IDS_GETKEY_USAGEARGS),
    RESSTR(IDS_GETKEY_DESCRIPTION),
    RESSTR(IDS_RECOVERKEY_USAGEARGS),
    RESSTR(IDS_RECOVERKEY_DESCRIPTION),
    RESSTR(IDS_DUMP_USAGEARGS),
    RESSTR(IDS_DUMP_DECRYPTED),
    RESSTR(IDS_CANT_DECRYPT),
    RESSTR(IDS_NEED_RECOVERY_CERT),
    RESSTR(IDS_USER_CERT),
    RESSTR(IDS_ALGORITHM_CLASS),
    RESSTR(IDS_ALGORITHM_TYPE),
    RESSTR(IDS_ALGORITHM_SUBID),
    RESSTR(IDS_CMC_STATUS),
    RESSTR(IDS_BODY_REFERENCE),
    RESSTR(IDS_CMC_STATUSSTRING),
    RESSTR(IDS_CMC_OTHERCHOICE),
    RESSTR(IDS_CMC_FAILINFO),
    RESSTR(IDS_PENDTOKEN),
    RESSTR(IDS_PENDTIME),
    RESSTR(IDS_DSPUBLISH_USAGEARGS),
    RESSTR(IDS_DSPUBLISH_DESCRIPTION),
    RESSTR(IDS_FORMAT_LOADCERTORCRL),
    RESSTR(IDS_BYTES),
    RESSTR(IDS_FORMAT_ALREADY_IN_DS_STORE),
    RESSTR(IDS_CERTIFICATE),
    RESSTR(IDS_FORMAT_SUBJECTKEYID_COLON),
    RESSTR(IDS_PRECOMPUTED),
    RESSTR(IDS_CANNOT_CREATE_STORE),
    RESSTR(IDS_CANNOT_OPEN_STORE),
    RESSTR(IDS_REPAIRSTORE_USAGEARGS),
    RESSTR(IDS_REPAIRSTORE_DESCRIPTION),
    RESSTR(IDS_DELREG_DESCRIPTION),
    RESSTR(IDS_DETACHED_SIGNATURE),
    RESSTR(IDS_EXPORTPFX_USAGEARGS),
    RESSTR(IDS_EXPORTPFX_DESCRIPTION),
    RESSTR(IDS_IMPORTPFX_USAGEARGS),
    RESSTR(IDS_IMPORTPFX_DESCRIPTION),
    RESSTR(IDS_DSTEMPLATE_USAGEARGS),
    RESSTR(IDS_DSTEMPLATE_DESCRIPTION),
    RESSTR(IDS_DSADDTEMPLATE_USAGEARGS),
    RESSTR(IDS_DSADDTEMPLATE_DESCRIPTION),
    RESSTR(IDS_CREATED_TEMPLATE),
    RESSTR(IDS_UPDATED_TEMPLATE),
    RESSTR(IDS_FORMAT_COMMAND_SUCCEEDED),
    RESSTR(IDS_FORMAT_RESTART_SERVER),
    RESSTR(IDS_TEMPLATE_USAGEARGS),
    RESSTR(IDS_TEMPLATE_DESCRIPTION),
    RESSTR(IDS_TEMPLATECAS_USAGEARGS),
    RESSTR(IDS_TEMPLATECAS_DESCRIPTION),
    RESSTR(IDS_CATEMPLATES_USAGEARGS),
    RESSTR(IDS_CATEMPLATES_DESCRIPTION),
    RESSTR(IDS_UT_DESCRIPTION),
    RESSTR(IDS_MT_DESCRIPTION),
    RESSTR(IDS_TEMPLATE_EXTENSIONS),
    RESSTR(IDS_NOCR_DESCRIPTION),
    RESSTR(IDS_ENCODEHEX_USAGEARGS),
    RESSTR(IDS_ENCODEHEX_DESCRIPTION),
    RESSTR(IDS_FORMAT_ELEMENT_DUMP),
    RESSTR(IDS_SPLIT_DESCRIPTION),
    RESSTR(IDS_ENTERPRISE_DESCRIPTION),
    RESSTR(IDS_EXPORTPVK_USAGEARGS),
    RESSTR(IDS_EXPORTPVK_DESCRIPTION),
    RESSTR(IDS_FORMAT_QUERYING),
    RESSTR(IDS_PROP_ROLESEPARATIONENABLED),
    RESSTR(IDS_ISSUANCE_POLICIES),
    RESSTR(IDS_APPLICATION_POLICIES),
    RESSTR(IDS_URLCACHE_USAGEARGS),
    RESSTR(IDS_URLCACHE_DESCRIPTION),
    RESSTR(IDS_PROP_KRACERTCOUNT),
    RESSTR(IDS_PROP_KRACERTUSEDCOUNT),
    RESSTR(IDS_PROP_KRACERT),
    RESSTR(IDS_INVALID_OBJECTID),
    RESSTR(IDS_DUMP_PKCS7CMS),
    RESSTR(IDS_NO_DISPLAY_NAMES),
    RESSTR(IDS_TYPE_MISMATCH),
    RESSTR(IDS_LOCALIZEDNAME),
    RESSTR(IDS_CSP_PROVIDER_INFO),
    RESSTR(IDS_SIGN_USAGEARGS),
    RESSTR(IDS_SIGN_DESCRIPTION),
    RESSTR(IDS_SIGNINGSUBJECT),
    RESSTR(IDS_DELETEROW_USAGEARGS),
    RESSTR(IDS_DELETEROW_DESCRIPTION),
    RESSTR(IDS_FORMAT_DELETED_ROW_COUNT),
    RESSTR(IDS_FORMAT_DATE_REQUIRES_TABLE),
    RESSTR(IDS_FORMAT_DATE_IN_FUTURE),
    RESSTR(IDS_FORMAT_CRLHASH_COLON),
    RESSTR(IDS_REQTYPE_CRLS),
    RESSTR(IDS_REQTYPE_FULLRESPONSE),
    RESSTR(IDS_PROP_CASIGCERTCRLCHAIN),
    RESSTR(IDS_PROP_CAXCHGCERTCRLCHAIN),
    RESSTR(IDS_PULSE_DESCRIPTION),
    RESSTR(IDS_MACHINEINFO_USAGEARGS),
    RESSTR(IDS_MACHINEINFO_DESCRIPTION),
    RESSTR(IDS_FORMAT_MISSING_MACHINE_ATTRIBUTE),
    RESSTR(IDS_GROUP_LIST_COLON),
    RESSTR(IDS_DCINFO_USAGEARGS),
    RESSTR(IDS_DCINFO_DESCRIPTION),
    RESSTR(IDS_REMOTEENTROOT),
    RESSTR(IDS_REMOTEKDCCERT),
    RESSTR(IDS_DCUNAVAILABLE),
    RESSTR(IDS_FORMAT_TESTINGDC),
    RESSTR(IDS_FORMAT_DCROOTCERTS),
    RESSTR(IDS_FORMAT_KDCCERTS),
    RESSTR(IDS_UNKNOWN_PROPERTY),
    RESSTR(IDS_TEMPLATE_NAME),
    RESSTR(IDS_FORMAT_PUBLICKEY_LENGTH),
    RESSTR(IDS_PROP_ADVANCEDSERVER),
    RESSTR(IDS_PROP_BASECRLPUBLISHSTATUS),
    RESSTR(IDS_PROP_DELTACRLPUBLISHSTATUS),
    RESSTR(IDS_PROP_TEMPLATES),
    RESSTR(IDS_FORMAT_PROVPARM),
    RESSTR(IDS_FORMAT_PROVPARMFLAGS),
    RESSTR(IDS_ARCHIVED),
    RESSTR(IDS_ENTINFO_USAGEARGS),
    RESSTR(IDS_ENTINFO_DESCRIPTION),
    RESSTR(IDS_TCAINFO_DESCRIPTION),
    RESSTR(IDS_FORMAT_DSSKEY_LENGTH),
    RESSTR(IDS_FORMAT_DUMP_CTL_INDEX),
    RESSTR(IDS_CLIENTID),
    RESSTR(IDS_USERCOLON),
    RESSTR(IDS_MACHINECOLON),
    RESSTR(IDS_DUMP_CTL),
    RESSTR(IDS_LISTID),
    RESSTR(IDS_SEQUENCENO),
    RESSTR(IDS_SUBJECT_ALGORITHM),
    RESSTR(IDS_CTLENTRIES),
    RESSTR(IDS_USAGEENTRIES),
    RESSTR(IDS_FORMAT_SUBJECTID_COLON),
    RESSTR(IDS_VIEWSTORE_TITLE),
    RESSTR(IDS_VIEWSTORE_SUBTITLE),
    RESSTR(IDS_VIEWSTORE_SUBTITLE_DELETE),
    RESSTR(IDS_FORMAT_SAVED_CERT_NAME),
    RESSTR(IDS_FORMAT_DELETED_CERT_NAME),
    RESSTR(IDS_REQFLAGS_ENROLLONBEHALFOF),
    RESSTR(IDS_SCINFO_USAGEARGS),
    RESSTR(IDS_SCINFO_DESCRIPTION),
    RESSTR(IDS_SERVICEPAUSED),
    RESSTR(IDS_SERVICESTOPPED),
    RESSTR(IDS_SERVICEUNKNOWNSTATE),
    RESSTR(IDS_SMARTCARD_RUNNING),
    RESSTR(IDS_SMARTCARD_NOTRUNNING),
    RESSTR(IDS_SIGNATURE_NOTKEYEXCHANGE),
    RESSTR(IDS_FORMAT_SERVER_DEAD),
    RESSTR(IDS_GETDECRYPTCERT_SUBTITLE),
    RESSTR(IDS_DISP_FOREIGN_CERT),
    RESSTR(IDS_DISP_KRA_CERT),
    RESSTR(IDS_UPN_COLON),
    RESSTR(IDS_REQFLAGS_SUBJECTUNMODIFIED),
    RESSTR(IDS_REQFLAGS_PUBLISHERROR),
    RESSTR(IDS_NULL_SIGNATUREMATCHES),
    RESSTR(IDS_FORMAT_SOURCE_URL),
    RESSTR(IDS_FORMAT_LOCAL_FILENAME),
    RESSTR(IDS_FORMAT_USE_COUNT),
    RESSTR(IDS_FORMAT_HIT_RATE),
    RESSTR(IDS_FORMAT_FILE_SIZE),
    RESSTR(IDS_FORMAT_LAST_MOD_TIME_COLON),
    RESSTR(IDS_FORMAT_EXPIRE_TIME_COLON),
    RESSTR(IDS_FORMAT_LAST_ACCESS_TIME_COLON),
    RESSTR(IDS_FORMAT_LAST_SYNC_TIME_COLON),
    RESSTR(IDS_ERROR_CHECK_MACHINE_NAME),
    RESSTR(IDS_ERROR_NO_TRAILING),
    RESSTR(IDS_ISSUER_DOMAIN_POLICY),
    RESSTR(IDS_SUBJECT_DOMAIN_POLICY),
    RESSTR(IDS_FORMAT_MAP_ARRAY_COLON),
    RESSTR(IDS_FORMAT_CERT_TYPE_NOT_DC),
    RESSTR(IDS_FORMAT_CERT_USAGE_MISSING),
    RESSTR(IDS_FORMAT_DELETE_DC_CERT),
    RESSTR(IDS_FORMAT_DELETE_CERT_FROM_STORE_FAILED),
    RESSTR(IDS_FORMAT_KDC_PATH),
    RESSTR(IDS_NO_KDC_MY_STORE),
    RESSTR(IDS_NO_KDC_ENT_STORE),
    RESSTR(IDS_FORMAT_OPEN_REMOTE_MY_FAILED),
    RESSTR(IDS_FORMAT_ERROR_GET_ARCHIVE_PROP),
    RESSTR(IDS_LIST_ARCHIVED_CERT),
    RESSTR(IDS_NO_AUTOENROLLED_CERT),
    RESSTR(IDS_FORMAT_OPEN_STORE_REMOTE_ENT_FAILED),
    RESSTR(IDS_NO_AUTOENROLL_OBJECT),
    RESSTR(IDS_NO_ACCESS),
    RESSTR(IDS_CA_EXPIRATION_DATA),
    RESSTR(IDS_FORMAT_CA_EXPIRATION_FAILED),
    RESSTR(IDS_FORMAT_CA_EXPIRATION),
    RESSTR(IDS_SUPPORTED_TEMPLATE),
    RESSTR(IDS_NO_SUPPORTED_TEMPLATE),
    RESSTR(IDS_FORMAT_CA_NAME_PROP_FAILED),
    RESSTR(IDS_FORMAT_CA_NAME_LIST),
    RESSTR(IDS_FORMAT_CA_DNS_PROP_FAILED),
    RESSTR(IDS_FORMAT_CA_MACHINE_LIST),
    RESSTR(IDS_FORMAT_CA_DS_LIST),
    RESSTR(IDS_FORMAT_CERT_DN_PROP_FAILED),
    RESSTR(IDS_FORMAT_CERT_DN_LIST),
    RESSTR(IDS_FORMAT_CA_ALG_PROP_FAILED),
    RESSTR(IDS_FORMAT_CA_ALG_LIST),
    RESSTR(IDS_NO_ALG_UNEXPECTED),
    RESSTR(IDS_NO_CT_FOR_CA),
    RESSTR(IDS_NO_CT_BUT_EXISTS),
    RESSTR(IDS_NO_CA_ON_DOMAIN),
    RESSTR(IDS_FORMAT_NO_DFS),
    RESSTR(IDS_DFS_DATA_ACCESS),
    RESSTR(IDS_NO_ENTRY_IN_PING),
    RESSTR(IDS_NO_DSPATH),
    RESSTR(IDS_FORMAT_REG_QUERY_VALUE_FAILED),
    RESSTR(IDS_NO_FILE_SYS_PATH),
    RESSTR(IDS_API_RPINT_FAILED),
    RESSTR(IDS_FORMAT_LDAP_NO_ENTRY),
    RESSTR(IDS_ROOT_CERT_IN_POLICY),
    RESSTR(IDS_FORMAT_CERT_COLON),
    RESSTR(IDS_NO_ROOT_IN_POLICY),
    RESSTR(IDS_CHECK_EVENT_LOG),
    RESSTR(IDS_POLICY_MACHINE),
    RESSTR(IDS_POLICY_USER),
    RESSTR(IDS_POSSIBLE_NO_POLICY),
    RESSTR(IDS_DEFAULT_CERT_FOR_MACHINE),
    RESSTR(IDS_DEFAULT_CERT_FOR_USER),
    RESSTR(IDS_POLICY_DOWNLOAD_ERROR),
    RESSTR(IDS_FORMAT_COMPUTER_NAME),
    RESSTR(IDS_FORMAT_USER_NAME),
    RESSTR(IDS_BAD_OPTION),
    RESSTR(IDS_FORMAT_MACHINE_LIST),
    RESSTR(IDS_FORMAT_KEY_LIST),
    RESSTR(IDS_FORMAT_GPO_NAME),
    RESSTR(IDS_REQUEST_SIGNATUREMATCHES),
    RESSTR(IDS_OUT_USAGE),
    RESSTR(IDS_OUT_DESCRIPTION),
    RESSTR(IDS_RESTRICT_USAGE),
    RESSTR(IDS_RESTRICT_DESCRIPTION),
    RESSTR(IDS_CONFIG_USAGE),
    RESSTR(IDS_CONFIG_DESCRIPTION),
    RESSTR(IDS_USAGE_LIST_VERBS),
    RESSTR(IDS_FORMAT_USAGE_ONE_HELP),
    RESSTR(IDS_USAGE_ALL_HELP),
    RESSTR(IDS_IMPORT_CERT_FOREIGN),
    RESSTR(IDS_IMPORT_CERT_DOMESTIC),
    RESSTR(IDS_IMPORT_CERT_EXISTS),
    RESSTR(IDS_IMPORT_KEY_REPLACED),
    RESSTR(IDS_IMPORT_KEY_SAVED),
    RESSTR(IDS_IMPORT_KEY_EXISTS),
    RESSTR(IDS_IMPORT_CERT_SKIPPED_SIGNING),
    RESSTR(IDS_KMS_USERS),
    RESSTR(IDS_KMS_CERTS_SKIPPED),
    RESSTR(IDS_KMS_CERTS_TOTAL),
    RESSTR(IDS_KMS_CERTS_FOREIGN),
    RESSTR(IDS_KMS_CERTS_ALREADYSAVED),
    RESSTR(IDS_KMS_CERTS_SAVED),
    RESSTR(IDS_KMS_CERTS_NOTSAVED),
    RESSTR(IDS_KMS_KEYS_TOTAL),
    RESSTR(IDS_KMS_KEYS_ALREADYSAVED),
    RESSTR(IDS_KMS_KEYS_UPDATED),
    RESSTR(IDS_KMS_KEYS_SAVED),
    RESSTR(IDS_KMS_KEYS_NOTSAVED),
    RESSTR(IDS_MERGEPFX_DESCRIPTION),
    RESSTR(IDS_MERGEPFX_USAGEARGS),
    RESSTR(IDS_CAHIER_CERTFILE_FILTER),
    RESSTR(IDS_CAHIER_INSTALL_TITLE),
    RESSTR(IDS_ILOG_MISSING_PROVIDER),
    RESSTR(IDS_ERR_INCOMPLETECHAIN),
    RESSTR(IDS_ERR_INVALIDCHAIN),
    RESSTR(IDS_ERR_RETRIEVE_PENDING),
    RESSTR(IDS_ILOG_GETCANAME),
    RESSTR(IDS_ILOG_SELECTCA),
    RESSTR(IDS_ILOG_SAVECERTANDKEYS),
    RESSTR(IDS_ILOG_RETRIEVECERT),
    RESSTR(IDS_ILOG_FINISHSUSPENDEDSETUP),
    RESSTR(IDS_ERR_NOTCACERT),
    RESSTR(IDS_ILOG_SETUPCOMPLETE),
    RESSTR(IDS_ILOG_RETRIEVEPENDING),
    RESSTR(IDS_ILOG_KEYINDEX),
    RESSTR(IDS_ILOG_LOADOLDCERT),
    RESSTR(IDS_ILOG_CLONECERT),
    RESSTR(IDS_ILOG_BUILDREQUEST),
    RESSTR(IDS_ILOG_RENEWOLDKEY),
    RESSTR(IDS_ILOG_INSTALLCERT),
    RESSTR(IDS_ILOG_RENEWNEWKEY),
    RESSTR(IDS_ILOG_BUILDCERT),
    RESSTR(IDS_ILOG_SAVECHAINANDKEYS),
    RESSTR(IDS_REQUEST_HELPTEXT),
    RESSTR(IDS_ILOG_CREATECDP),
    RESSTR(IDS_ILOG_CREATENTAUTHTRUST),
    RESSTR(IDS_ILOG_CREATEROOTTRUST),
    RESSTR(IDS_ILOG_PUBLISHCA),
    RESSTR(IDS_ILOG_SUBMITREQUEST),
    RESSTR(IDS_ERR_BADCSP),
    RESSTR(IDS_ERR_BAD_CA_CERT_7F),
    RESSTR(IDS_ERR_RENEWEDCERTCAVERSION),
    RESSTR(IDS_ERR_UNTRUSTEDROOT),
    RESSTR(IDS_ERR_CERTADDCERTIFICATECONTEXTTOSTORE),
    RESSTR(IDS_ERR_CERTCREATECERTIFICATECONTEXT),
    RESSTR(IDS_ILOG_SETSECURITY),
    RESSTR(IDS_ERR_CREATEFILE),
    RESSTR(IDS_ERR_DELETEKEY),
    RESSTR(IDS_ERR_ENCODEKEYATTR),
    RESSTR(IDS_ERR_ENCODETOBESIGNED),
    RESSTR(IDS_ERR_ENV_NOT_SET),
    RESSTR(IDS_ERR_FULL_TOKEN),
    RESSTR(IDS_ERR_GENKEYFAIL),
    RESSTR(IDS_ERR_GETCOMPUTERNAME),
    RESSTR(IDS_ERR_KEYSECURITY),
    RESSTR(IDS_ERR_MYDECODENAME),
    RESSTR(IDS_ERR_NOT_ENTERPRISE_USER),
    RESSTR(IDS_ERR_NOT_MATCH_NAME),
    RESSTR(IDS_ILOG_GENERATEKEYS),
    RESSTR(IDS_ERR_REPEATWIZPREFIX),
    RESSTR(IDS_ERR_REQUEST_DENIED),
    RESSTR(IDS_ERR_REQUEST_ERROR),
    RESSTR(IDS_ERR_REQUEST_INCOMPLETE),
    RESSTR(IDS_ERR_REQUEST_OUTOFBAND),
    RESSTR(IDS_ERR_REQUEST_PENDING),
    RESSTR(IDS_ERR_REQUEST_REVOKED),
    RESSTR(IDS_ERR_SETKEYPROVIDER),
    RESSTR(IDS_ERR_SUBMIT_REQUEST),
    RESSTR(IDS_ERR_SUBMIT_REQUEST_FAIL),
    RESSTR(IDS_CAHIER_INSTALL_MISIINGCERT_TITLE),
    RESSTR(IDS_ERR_WRITEDERTOFILE),
    RESSTR(IDS_ERR_WRITEFILE),
    RESSTR(IDS_ILOG_SETKEYSECURITY),
    RESSTR(IDS_MSG_PARENTCA_CONFIG),
    RESSTR(IDS_MSG_REQUEST_ID),
    RESSTR(IDS_MSG_TITLE),
    RESSTR(IDS_ILOG_SETADMINONLYFOLDERSECURITY),
    RESSTR(IDS_ERR_NO_KEY_ACCESS),
    RESSTR(IDS_CA_PICKER_TITLE),
    RESSTR(IDS_CA_PICKER_PROMPT),
    RESSTR(IDS_CERTTYPE_USER),
    RESSTR(IDS_CERTTYPE_USER_AS),
    RESSTR(IDS_CERTTYPE_USER_SMARTCARD_LOGON),
    RESSTR(IDS_CERTTYPE_EFS),
    RESSTR(IDS_CERTTYPE_ADMIN),
    RESSTR(IDS_CERTTYPE_EFS_RECOVERY),
    RESSTR(IDS_CERTTYPE_CODE_SIGNING),
    RESSTR(IDS_CERTTYPE_CTL_SIGNING),
    RESSTR(IDS_CERTTYPE_MACHINE),
    RESSTR(IDS_CERTTYPE_DC),
    RESSTR(IDS_CERTTYPE_WEBSERVER),
    RESSTR(IDS_CERTTYPE_KDC),
    RESSTR(IDS_CERTTYPE_ROOT_CA),
    RESSTR(IDS_CERTTYPE_SUBORDINATE_CA),
    RESSTR(IDS_CERTTYPE_ENROLLMENT_AGENT),
    RESSTR(IDS_CERTTYPE_SMARTCARD_USER),
    RESSTR(IDS_CERTTYPE_USER_SIGNATURE),
    RESSTR(IDS_ILOG_BAD_NUMERICFIELD),
    RESSTR(IDS_CERTTYPE_IPSEC_INTERMEDIATE_ONLINE),
    RESSTR(IDS_ILOG_BAD_VALIDITY_COUNT),
    RESSTR(IDS_CERTTYPE_IPSEC_INTERMEDIATE_OFFLINE),
    RESSTR(IDS_ILOG_BAD_VALIDITY_STRING),
    RESSTR(IDS_CERTTYPE_ROUTER_OFFLINE),
    RESSTR(IDS_REQUEST_FILE_DEFEXT),
    RESSTR(IDS_REQUEST_OPEN_TITLE),
    RESSTR(IDS_REQUEST_FILE_FILTER),
    RESSTR(IDS_WRN_COMPUTERNAME_EMPTY),
    RESSTR(IDS_WRN_CANAME_EMPTY),
    RESSTR(IDS_WRN_CANAME_NOT_MATCH),
    RESSTR(IDS_WRN_PINGCA_FAIL),
    RESSTR(IDS_CERTTYPE_ENROLLMENT_AGENT_OFFLINE),
    RESSTR(IDS_CERTTYPE_EXCHANGE_USER),
    RESSTR(IDS_CERTTYPE_EXCHANGE_USER_SIGNATURE),
    RESSTR(IDS_WRN_CALIST_EMPTY),
    RESSTR(IDS_CERTTYPE_MACHINE_ENROLLMENT_AGENT),
    RESSTR(IDS_REQUEST_SAVE_TITLE),
    RESSTR(IDS_CERTTYPE_CEP_ENCRYPTION),
    RESSTR(IDS_ILOG_CAPOLICY_BUILD),
    RESSTR(IDS_ILOG_CAPOLICY_ELEMENT),
    RESSTR(IDS_ILOG_CAPOLICY_EXTENSION),
    RESSTR(IDS_ILOG_CAPOLICY_NOKEY),
    RESSTR(IDS_ILOG_CAPOLICY_OPEN),
    RESSTR(IDS_ILOG_CAPOLICY_OPEN_FAILED),
    RESSTR(IDS_ILOG_BEGIN),
    RESSTR(IDS_ILOG_END),
    RESSTR(IDS_ACTRL_CAADMIN),
    RESSTR(IDS_ACTRL_OFFICER),
    RESSTR(IDS_ACTRL_AUDITOR),
    RESSTR(IDS_ACTRL_OPERATOR),
    RESSTR(IDS_ACTRL_CAREAD),
    RESSTR(IDS_ACTRL_ENROLL),
    RESSTR(IDS_ILOG_CAPOLICY_CLOSE),
    RESSTR(IDS_ILOG_MESSAGEBOX),
    RESSTR(IDS_ILOG_BAD_VALIDITY_STRING_UNATTEND),
    RESSTR(IDS_CERTTYPE_KEY_RECOVERY_AGENT),
    RESSTR(IDS_CERTTYPE_CA_EXCHANGE),
    RESSTR(IDS_EMPTY_FRIENDLY_NAME),
    RESSTR(IDS_CERTTYPE_CROSS_CA),
    RESSTR(IDS_CERTTYPE_DC_AUTH),
    RESSTR(IDS_CERTTYPE_DS_EMAIL_REPLICATION),
    RESSTR(IDS_WARN_ENTERPRISE_REQUIREMENTS),
    RESSTR(IDS_WRN_OLD_CA),
    RESSTR(IDS_KRA_DESCRIPTION),
    RESSTR(IDS_EMAIL_REPLICATION_DESCRIPTION),
    RESSTR(IDS_CROSS_CA_DESCRIPTION),
    RESSTR(IDS_CA_DESCRIPTION),
    RESSTR(IDS_MACHINE_DESCRIPTION),
    RESSTR(IDS_END_USER_DESCRIPTION),
    RESSTR(IDS_UNKNOWN_DESCRIPTION),
    RESSTR(IDS_STORENAME_DS_KRA),
    RESSTR(IDS_STORENAME_DS_AIA),
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\tools\tautoenr\tautoenr.cpp ===
//--------------------------------------------------------------------
// TAutoEnr - implementation
// Copyright (C) Microsoft Corporation, 1997 - 1999
//
// test autoenrollment
//

#include <stdlib.h>
#include <string.h>
#include <windows.h>
#include <stdio.h>
#include <certca.h>
#include <autoenr.h>
#include <conio.h>

typedef HANDLE (WINAPI * PFNCertAutoenrollment)( 
                HWND     hwndParent,
                DWORD    dwStatus);

//move to autoenr.h file
//#define MACHINE_AUTOENROLLMENT_TIMER_NAME L"AUTOENRL:MachineEnrollmentTimer"
//#define USER_AUTOENROLLMENT_TIMER_NAME    L"AUTOENRL:UserEnrollmentTimer"

#define MACHINE_AUTOENROLLMENT_MUTEX_NAME L"AUTOENRL:MachineEnrollmentMutex"
#define USER_AUTOENROLLMENT_MUTEX_NAME    L"AUTOENRL:UserEnrollmentMutex"


//--------------------------------------------------------------------
void PrintHelp(void) {
    wprintf(
L"tautoenrl <testID>\n"
L"  Available tests:\n"
L"    startup - test autoenroll in startup mode\n"
L"    wakeup - test autoenroll in startup mode\n"
L"    triguser - test user autoenroll trigger event\n"
L"    trigmachine - test machine autoenroll trigger event\n"
L"    timeruser - test user autoenroll timer\n"
L"    timermachine - test machine autoenroll timer\n"
L"    remove_commit - test domain disjoin commit\n"
L"    remove_rollback - test domain disjoin roll back\n"
        );
}

//--------------------------------------------------------------------
HRESULT TimerTest(WCHAR * wszTimerName) {
    HRESULT hr;
    LARGE_INTEGER liDueTime;

    // must be cleaned up
    HANDLE hTimer=NULL;

    wprintf(L"Testing the '%s' timer.\n", wszTimerName);

    hTimer=OpenWaitableTimer(TIMER_MODIFY_STATE, false, wszTimerName);
    if (NULL==hTimer) {
        hr=HRESULT_FROM_WIN32(GetLastError());
        wprintf(L"OpenWaitableTimer(%s) failed with 0x%08X.\n", wszTimerName, hr);
        goto error;
    }

    liDueTime.QuadPart=((signed __int64)-10000000)*60;
    if (!SetWaitableTimer (hTimer, &liDueTime, 0, NULL, 0, FALSE)) {
        hr=HRESULT_FROM_WIN32(GetLastError());
        wprintf(L"SetWaitableTimer failed with 0x%08X.\n", hr);
        goto error;
    }
    wprintf(L"Timer '%s' will go off in 1 minute.\n", wszTimerName);


    hr=S_OK;
error:
    if (NULL!=hTimer) {
        CloseHandle(hTimer);
    }
    return hr;
}

//--------------------------------------------------------------------
HRESULT MutexTest(WCHAR * wszMutexName) {
    HRESULT hr;
    DWORD dwWaitResult;

    // must be cleaned up
    HANDLE hMutex=NULL;

    wprintf(L"Testing the '%s' mutex.\n", wszMutexName);

    hMutex=OpenMutex(SYNCHRONIZE, false, wszMutexName);
    if (NULL==hMutex) {
        hr=HRESULT_FROM_WIN32(GetLastError());
        wprintf(L"OpenMutex(%s) failed with 0x%08X.\n", wszMutexName, hr);
        goto error;
    }

    dwWaitResult=WaitForSingleObject(hMutex, 0);
    if (WAIT_FAILED==dwWaitResult) {
        hr=HRESULT_FROM_WIN32(GetLastError());
        wprintf(L"WaitForSingleObject failed with 0x%08X.\n", hr);
        goto error;
    }
    if (WAIT_TIMEOUT==dwWaitResult) {
        wprintf(L"Mutex held by someone else.\n");
    } else {
        wprintf(L"Mutex Acquired. Press an key to release.\n");
        _getch();
        if (!ReleaseMutex(hMutex)) {
            hr=HRESULT_FROM_WIN32(GetLastError());
            wprintf(L"ReleaseMutex failed with 0x%08X.\n", hr);
            goto error;
        }
        wprintf(L"Mutex released.\n");
    }
    hr=S_OK;
error:
    if (NULL!=hMutex) {
        CloseHandle(hMutex);
    }
    return hr;
}

//--------------------------------------------------------------------
HRESULT EventTest(WCHAR * wszEventName) {
    HRESULT hr;

    // must be cleaned up
    HANDLE hEvent=NULL;

    wprintf(L"Signaling the '%s' event.\n", wszEventName);

    hEvent=OpenEvent(EVENT_MODIFY_STATE, false, wszEventName);
    if (NULL==hEvent) {
        hr=HRESULT_FROM_WIN32(GetLastError());
        wprintf(L"OpenEvent(%s) failed with 0x%08X.\n", wszEventName, hr);
        goto error;
    }

    if (!SetEvent(hEvent)) {
        hr=HRESULT_FROM_WIN32(GetLastError());
        wprintf(L"SetEvent failed with 0x%08X.\n", hr);
        goto error;
    }

    hr=S_OK;
error:
    if (NULL!=hEvent) {
        CloseHandle(hEvent);
    }
    return hr;
}

//--------------------------------------------------------------------
HRESULT BasicTest(DWORD dwStatus) {
    HRESULT hr;
    PFNCertAutoenrollment pfnCertAutoenrollment;
    DWORD dwWaitResult;

    // must be cleaned up
    HANDLE hThread=NULL;
    HMODULE hInstAuto=NULL;

    if (dwStatus==CERT_AUTO_ENROLLMENT_START_UP) {
        wprintf(L"Invoking autoenrollment in startup mode...\n");
    } else {
        wprintf(L"Invoking autoenrollment in wakeup mode...\n");
    }

    hInstAuto=LoadLibrary(L"pautoenr.dll");
    if (NULL==hInstAuto) {
        hr=HRESULT_FROM_WIN32(GetLastError());
        wprintf(L"LoadLibrary failed with 0x%08X.\n", hr);
        goto error;
    }

    pfnCertAutoenrollment=(PFNCertAutoenrollment)GetProcAddress(hInstAuto, "CertAutoEnrollment");
    if (NULL==pfnCertAutoenrollment) {
        hr=HRESULT_FROM_WIN32(GetLastError());
        wprintf(L"GetProcAddress(CertAutoEnrollment) failed with 0x%08X.\n", hr);
        goto error;
    }

    // call the autoenrollment
    hThread=pfnCertAutoenrollment(GetDesktopWindow(), dwStatus);
    if (NULL!=hThread) {
        wprintf(L"Waiting for background thread to finish...\n");
        dwWaitResult=WaitForSingleObject(hThread, INFINITE);
        if (WAIT_FAILED==dwWaitResult) {
            hr=HRESULT_FROM_WIN32(GetLastError());
            wprintf(L"WaitForSingleObject failed with 0x%08X.\n", hr);
            goto error;
        }
    }

    hr=S_OK;
error:

    if (NULL!=hThread) {
        CloseHandle(hThread);
    }
    if (NULL!=hInstAuto) {
        FreeLibrary(hInstAuto);
    }

	return hr;
}
//--------------------------------------------------------------------
HRESULT TestRemove(DWORD dwFlags) {
    HRESULT hr;
    if(!CertAutoRemove(dwFlags))
    {
        hr=GetLastError();
        goto error;
    }

    hr=S_OK;
error:
    return hr;
}
//--------------------------------------------------------------------
extern "C" int __cdecl wmain(int nArgs, WCHAR ** rgwszArgs) {
    HRESULT hr;

    if (2!=nArgs || 0==wcscmp(rgwszArgs[1], L"/?") || 0==wcscmp(rgwszArgs[1], L"-?")) {
        PrintHelp();
        goto done;
    }

    if (0==_wcsicmp(L"startup", rgwszArgs[1])) {
        hr=BasicTest(CERT_AUTO_ENROLLMENT_START_UP);

    } else if (0==_wcsicmp(L"wakeup", rgwszArgs[1])) {
        hr=BasicTest(CERT_AUTO_ENROLLMENT_WAKE_UP);

    } else if (0==_wcsicmp(L"triguser", rgwszArgs[1])) {
        hr=EventTest(USER_AUTOENROLLMENT_TRIGGER_EVENT);

    } else if (0==_wcsicmp(L"trigmachine", rgwszArgs[1])) {
        hr=EventTest(L"Global\\" MACHINE_AUTOENROLLMENT_TRIGGER_EVENT);

    } else if (0==_wcsicmp(L"timeruser", rgwszArgs[1])) {
        hr=TimerTest(USER_AUTOENROLLMENT_TIMER_NAME);

    } else if (0==_wcsicmp(L"timermachine", rgwszArgs[1])) {
        hr=TimerTest(L"Global\\" MACHINE_AUTOENROLLMENT_TIMER_NAME);

    } else if (0==_wcsicmp(L"remove_commit", rgwszArgs[1])) {
        hr=TestRemove(CERT_AUTO_REMOVE_COMMIT);

    } else if (0==_wcsicmp(L"remove_rollback", rgwszArgs[1])) {
        hr=TestRemove(CERT_AUTO_REMOVE_ROLL_BACK);
        
    } else {
        wprintf(L"Command '%s' unknown.\n", rgwszArgs[1]);
        goto done;
    }

    if (FAILED(hr)) {
        wprintf(L"Command '%s' failed with error 0x%08X.\n", rgwszArgs[1], hr);
    } else {
        wprintf(L"Command '%s' completed successfully.\n", rgwszArgs[1]);
    }

done:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\tools\tcertcli\tcertcli.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       tcertcli.cpp
//
//--------------------------------------------------------------------------

#include <stdlib.h>
#include <string.h>
#include <windows.h>
#include <stdio.h>
#include <certca.h>
#include <winldap.h>
#include <dsrole.h>
#include <dsgetdc.h>
#include <lmaccess.h>
#include <lmapibuf.h>


//--------------------------------------------------------------------
HRESULT
myRobustLdapBindEx(
    OUT LDAP ** ppldap,
    OPTIONAL OUT LPWSTR* ppszForestDNSName,
    IN BOOL fGC)
{
    HRESULT hr;
    BOOL fForceRediscovery = FALSE;
    DWORD dwGetDCFlags = DS_RETURN_DNS_NAME;
    PDOMAIN_CONTROLLER_INFO pDomainInfo = NULL;
    LDAP *pld = NULL;
    WCHAR const *pwszDomainControllerName = NULL;
    ULONG ldaperr;

    if (fGC)
    {
        dwGetDCFlags |= DS_GC_SERVER_REQUIRED;
    }

    do {
        if (fForceRediscovery)
        {
           dwGetDCFlags |= DS_FORCE_REDISCOVERY;
        }
	ldaperr = LDAP_SERVER_DOWN;

        // netapi32!DsGetDcName is delay loaded, so wrap

        __try
        {
            // Get the GC location
            hr = DsGetDcName(
			NULL,     // Delayload wrapped
			NULL, 
			NULL, 
			NULL,
			dwGetDCFlags,
			&pDomainInfo);
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            hr=E_UNEXPECTED;
        }
        if (S_OK != hr)
        {
	    hr = HRESULT_FROM_WIN32(hr);
            if (fForceRediscovery)
            {
		        goto error;
            }
	    fForceRediscovery = TRUE;
	    continue;
        }

        if (NULL == pDomainInfo ||
            (fGC && 0 == (DS_GC_FLAG & pDomainInfo->Flags)) ||
            0 == (DS_DNS_CONTROLLER_FLAG & pDomainInfo->Flags) ||
            NULL == pDomainInfo->DomainControllerName)
        {
            if (!fForceRediscovery)
            {
                fForceRediscovery = TRUE;
                continue;
            }
            hr = HRESULT_FROM_WIN32(ERROR_CANT_ACCESS_DOMAIN_INFO);
            goto error;
        }

        pwszDomainControllerName = pDomainInfo->DomainControllerName;

        // skip past forward slashes (why are they there?)

        while (L'\\' == *pwszDomainControllerName)
        {
            pwszDomainControllerName++;
        }

        // bind to ds

        pld = ldap_init(
		    const_cast<WCHAR *>(pwszDomainControllerName),
		    fGC? LDAP_GC_PORT : LDAP_PORT);
        if (NULL == pld)
	{
            ldaperr = LdapGetLastError();
	}
        else
        {
            // do this because we're explicitly setting DC name

            ldaperr = ldap_set_option(pld, LDAP_OPT_AREC_EXCLUSIVE, LDAP_OPT_ON);


	    ldaperr = ldap_bind_s(pld, NULL, NULL, LDAP_AUTH_NEGOTIATE);
        }

        hr = HRESULT_FROM_WIN32(LdapMapErrorToWin32(ldaperr));

        if (fForceRediscovery)
        {
            break;
        }
        fForceRediscovery = TRUE;

    } while (LDAP_SERVER_DOWN == ldaperr);

    // everything's cool, party down

    if (S_OK == hr)
    {
        *ppldap = pld;
        pld = NULL;
    }

error:
    if (NULL != pld)
    {
        ldap_unbind(pld);
    }

    // we know netapi32 was already loaded safely (that's where we got
    // pDomainInfo), so no need to wrap

    if (NULL != pDomainInfo)
    {
        NetApiBufferFree(pDomainInfo);     // Delayload wrapped
    }
    return(hr);
}

//--------------------------------------------------------------------
HRESULT
myRobustLdapBind(
    OUT LDAP ** ppldap,
    IN BOOL fGC)
{
    return(myRobustLdapBindEx(ppldap, NULL, fGC));
}

//--------------------------------------------------------------------
void PrintHelp(void) {
    wprintf(
L"tcertcli <testID>\n"
L"  Available tests:\n"
L"    OID - test CAOIDxxxx functions\n"
L"    Template - test CACertTypexxxx functions\n"
L"    Query - test CACertTypeQuery functions without pld\n"
L"    QueryLDAP - test CACertTypeQuery functions with pld\n"
L"    CAEnum <CAName> - test CAEnumCertTypesForCA functions without pld\n"
L"    CAEnumLDAP  <CAName> - test CAEnumCertTypesForCAEx functions with pld\n"
L"    TemplateDes - test the description property of templates\n"
L"    Clone <TemplateName> - test the clone without pld\n"
L"    CloneLDAP <TemplateName> - test the clone with pld\n"
L"    ACRS - test create/delete autoenrollment object from ACRS store\n"
L"    OIDURL - test URL code for OID container\n"
    );
}

//--------------------------------------------------------------------
BOOL TemplateTest()
{
    BOOL                fSuccess=FALSE;
	HRESULT				hr=S_OK;
    DWORD               dwProp=0;
    LPWSTR              rgwszProp[4];
    CERT_ENHKEY_USAGE   KeyUsage;
    LPSTR               szOID="1.2.3.4.5.6";
    FILETIME            time1;
    FILETIME            time2;
    DWORD               dwNameFlag;

    HCERTTYPE           hCertType=NULL;
    HANDLE              hClientToken=NULL;
    HANDLE              hHandle = NULL;
    PCERT_EXTENSIONS    pCertExtensions=NULL;
    LPWSTR              *pwszProp=NULL;
    LPWSTR              *pwszProp1=NULL;
    PSECURITY_DESCRIPTOR    pSD=NULL;
    LPWSTR              pwszOID=NULL;
    LPWSTR              pwsz=NULL;
    DWORD               dwType=0;

    //get the client token
    hHandle = GetCurrentThread();
    if (NULL == hHandle)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }
    else
    {

        if (!OpenThreadToken(hHandle,
                             TOKEN_QUERY,
                             TRUE,  // open as self
                             &hClientToken))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            CloseHandle(hHandle);
            hHandle = NULL;
        }
    }
    if(hr != S_OK)
    {
        hHandle = GetCurrentProcess();
        if (NULL == hHandle)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }
        else
        {
            HANDLE hProcessToken = NULL;
            hr = S_OK;


            if (!OpenProcessToken(hHandle,
                                 TOKEN_DUPLICATE,
                                 &hProcessToken))
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
                CloseHandle(hHandle);
                hHandle = NULL;
            }
            else
            {
                if(!DuplicateToken(hProcessToken,
                               SecurityImpersonation,
                               &hClientToken))
                {
                    hr = HRESULT_FROM_WIN32(GetLastError());
                    CloseHandle(hHandle);
                    hHandle = NULL;
                }
                CloseHandle(hProcessToken);
            }
        }
    }

    if(S_OK != hr)
        goto error;

    //find a certifcate type admin
    if(S_OK != CAFindCertTypeByName(
        wszCERTTYPE_ADMIN,
        NULL,
        CT_ENUM_USER_TYPES,
        &hCertType
        ))
    {
        wprintf(L"Can not find template %s\n", wszCERTTYPE_ADMIN);
        goto error;
    }

    //get the name flag
    if(S_OK != CAGetCertTypeFlagsEx(
        hCertType,
        CERTTYPE_SUBJECT_NAME_FLAG,
        &dwNameFlag
        ))
    {
        wprintf(L"Can not find template %s\n", wszCERTTYPE_ADMIN);
        goto error;
    }

    //get all extensions
    if(S_OK != CAGetCertTypeExtensionsEx(
        hCertType,
        0,
        NULL,
        &pCertExtensions
        ))
    {
        wprintf(L"Can not find extensions %s\n", wszCERTTYPE_ADMIN);
        goto error;
    }     

    if(S_OK != (CAFreeCertTypeExtensions(hCertType, pCertExtensions)))
        goto error;

    pCertExtensions=NULL;

    //get template extensions
    if(S_OK != CAGetCertTypeExtensionsEx(
        hCertType,
        CT_EXTENSION_TEMPLATE,
        NULL,
        &pCertExtensions
        ))
    {
        wprintf(L"Can not find extensions %s\n", wszCERTTYPE_ADMIN);
        goto error;
    }     

    if(S_OK != (CAFreeCertTypeExtensions(hCertType, pCertExtensions)))
        goto error;

    pCertExtensions=NULL;

    //get selected extension
    if(S_OK != CAGetCertTypeExtensionsEx(
        hCertType,
        CT_EXTENSION_BASIC_CONTRAINTS | CT_EXTENSION_APPLICATION_POLICY,
        NULL,
        &pCertExtensions
        ))
    {
        wprintf(L"Can not find extensions %s\n", wszCERTTYPE_ADMIN);
    }     
    else
    {
        if(S_OK != (CAFreeCertTypeExtensions(hCertType, pCertExtensions)))
           goto error;
    }

    pCertExtensions=NULL;

    //get all extension from the old way
    if(S_OK != CAGetCertTypeExtensions(
        hCertType,
        &pCertExtensions
        ))
    {
        wprintf(L"Can not find extensions %s\n", wszCERTTYPE_ADMIN);
        goto error;
    }     

    if(S_OK != (CAFreeCertTypeExtensions(hCertType, pCertExtensions)))
        goto error;

    pCertExtensions=NULL;

    if(S_OK != CAGetCertTypeFlagsEx(
        hCertType,
        CERTTYPE_SUBJECT_NAME_FLAG,
        &dwNameFlag
        ))
    {
        wprintf(L"Can not find template %s\n", wszCERTTYPE_ADMIN);
        goto error;
    }

    if(S_OK != CAGetCertTypePropertyEx(
	hCertType,
	CERTTYPE_PROP_FRIENDLY_NAME,
	&pwszProp))
    {
        wprintf(L"Can not get friendly name for template %s\n", wszCERTTYPE_ADMIN);
        goto error;
    }
	
    wprintf(L"The friendly name for %s is %s\n", wszCERTTYPE_ADMIN, pwszProp[0]);

    CAFreeCertTypeProperty(hCertType, pwszProp);
    pwszProp=NULL;

    CACloseCertType(hCertType);
    hCertType=NULL;
    //delete a certifcate type
    if(S_OK != CAFindCertTypeByName(
        wszCERTTYPE_USER,
        NULL,
        CT_ENUM_USER_TYPES,
        &hCertType
        ))
        goto error;

    if(S_OK != CADeleteCertType(hCertType))
        goto error;

    if(S_OK != CACloseCertType(hCertType))
        goto error;

    hCertType=NULL;


    //testing find cert type by oid
    if(S_OK != CAFindCertTypeByName(
        wszCERTTYPE_CA_EXCHANGE,
        NULL,
        CT_ENUM_USER_TYPES | CT_FLAG_NO_CACHE_LOOKUP | CT_ENUM_MACHINE_TYPES,
        &hCertType
        ))
        goto error;


    if(S_OK != CAGetCertTypePropertyEx(
        hCertType,
        CERTTYPE_PROP_OID,
        &pwszProp))
        goto error;

    if(S_OK != CACloseCertType(hCertType))
        goto error;

    hCertType=NULL;

    if(S_OK != CAFindCertTypeByName(
        pwszProp[0],
        NULL,
        CT_FIND_BY_OID | CT_ENUM_MACHINE_TYPES,
        &hCertType
        ))
        goto error;


    if(S_OK != CAGetCertTypePropertyEx(
        hCertType,
        CERTTYPE_PROP_OID,
        &pwszProp1))
        goto error;

    if(0!=wcscmp(pwszProp[0], pwszProp1[0]))
        goto error;

    if(S_OK != CAFreeCertTypeProperty(hCertType, pwszProp))
        goto error;

    if(S_OK != CAFreeCertTypeProperty(hCertType, pwszProp1))
        goto error;

    if(S_OK != CACloseCertType(hCertType))
        goto error;

    hCertType=NULL;

    //create a certificate type
    if(S_OK != CACreateCertType(L"NewCertType",
                                NULL,
                                0,
                                &hCertType))
        goto error;

    if(S_OK != CAUpdateCertType(hCertType))
        goto error;

    if(S_OK != CACloseCertType(hCertType))
        goto error;

    hCertType=NULL;

    //retrieve V1 certifcate type: EFS
	//access check on the EFS cert type
    if(S_OK != CAFindCertTypeByName(
        wszCERTTYPE_EFS,
        NULL,
        CT_ENUM_USER_TYPES,
        &hCertType
        ))
        goto error;

    if(S_OK != CAGetCertTypeFlagsEx(
            hCertType,
            CERTTYPE_GENERAL_FLAG,
            &dwProp))
        goto error;

    printf("The general flag for EFS is: %d\n", dwProp);


    if(S_OK != CAGetCertTypeFlagsEx(
            hCertType,
            CERTTYPE_PRIVATE_KEY_FLAG,
            &dwProp))
        goto error;

    printf("The private key flag for EFS is: %d\n", dwProp);

    if(S_OK != CAGetCertTypePropertyEx(
            hCertType,
            CERTTYPE_PROP_SCHEMA_VERSION,
            &dwProp))
        goto error;

    printf("The schema version for EFS is: %d\n", dwProp);

    if(S_OK != CACertTypeAccessCheckEx(
        hCertType,
        hClientToken,
        CERTTYPE_ACCESS_CHECK_ENROLL))
        goto error;

    //no autoenrollment
    if(S_OK == CACertTypeAccessCheckEx(
        hCertType,
        hClientToken,
        CERTTYPE_ACCESS_CHECK_AUTO_ENROLL))
        goto error;

     if(S_OK != CACloseCertType(hCertType))
        goto error;

    hCertType=NULL;

     //retrieve V2 certifcate type: EFS
	//access check on the EFS cert type
    if(S_OK != CAFindCertTypeByName(
        wszCERTTYPE_CROSS_CA,
        NULL,
        CT_ENUM_MACHINE_TYPES | CT_ENUM_USER_TYPES,
        &hCertType
        ))
        goto error;

    if(S_OK != CACertTypeAccessCheckEx(
        hCertType,
        hClientToken,
        CERTTYPE_ACCESS_CHECK_ENROLL))
        goto error;

    //no autoenrollment
    if(S_OK == CACertTypeAccessCheckEx(
        hCertType,
        hClientToken,
        CERTTYPE_ACCESS_CHECK_AUTO_ENROLL))
        goto error;

     if(S_OK != CACloseCertType(hCertType))
        goto error;

    hCertType=NULL;

  //clone a certificate type
    if(S_OK != CAFindCertTypeByName(
        wszCERTTYPE_SUBORDINATE_CA,
        NULL,
        CT_ENUM_MACHINE_TYPES,
        &hCertType
        ))
        goto error;


    rgwszProp[0]=L"ClonedCertType";
    rgwszProp[1]=NULL;

    if(S_OK != CASetCertTypePropertyEx(
        hCertType,
        CERTTYPE_PROP_CN,
        rgwszProp))
        goto error;


    rgwszProp[0]=L"ClonedCertType Friendly";
    rgwszProp[1]=NULL;

    if(S_OK != CASetCertTypePropertyEx(
        hCertType,
        CERTTYPE_PROP_FRIENDLY_NAME,
        rgwszProp))
        goto error;

    rgwszProp[0]=L"1.2.3.4.5";
    rgwszProp[1]=NULL;

    if(S_OK != CASetCertTypePropertyEx(
        hCertType,
        CERTTYPE_PROP_OID,
        rgwszProp))
        goto error; 

    rgwszProp[0]=L"1.2.3.4.5.6.7.8.9.10";
    rgwszProp[1]=NULL;

    if(S_OK != CASetCertTypePropertyEx(
        hCertType,
        CERTTYPE_PROP_APPLICATION_POLICY,
        rgwszProp))
        goto error; 
    
    rgwszProp[0]=L"1.2.3.4.5.6.7.8.9.10.11";
    rgwszProp[1]=NULL;

    if(S_OK != CASetCertTypePropertyEx(
        hCertType,
        CERTTYPE_PROP_RA_APPLICATION_POLICY,
        rgwszProp))
        goto error; 

    rgwszProp[0]=L"1.2.3.4.5.6.7.8.9.10.11.12";
    rgwszProp[1]=NULL;

    if(S_OK != CASetCertTypePropertyEx(
        hCertType,
        CERTTYPE_PROP_RA_POLICY,
        rgwszProp))
        goto error;    
    
    rgwszProp[0]=NULL;

    if(S_OK != CASetCertTypePropertyEx(
        hCertType,
        CERTTYPE_PROP_SUPERSEDE,
        rgwszProp))
        goto error; 
     
    rgwszProp[0]=L"CloneSuper1";
    rgwszProp[1]=L"CloneSuper2";
    rgwszProp[2]=L"CloneSuper3";
    rgwszProp[3]=NULL;

    if(S_OK != CASetCertTypePropertyEx(
        hCertType,
        CERTTYPE_PROP_SUPERSEDE,
        rgwszProp))
        goto error;  

    dwProp=2048;

    if(S_OK != CASetCertTypePropertyEx(
        hCertType,
        CERTTYPE_PROP_MIN_KEY_SIZE,
        &dwProp))
        goto error;  

    if(S_OK != CAGetCertTypeExtensions(
            hCertType,
            &pCertExtensions))
        goto error;

    KeyUsage.cUsageIdentifier=1;
    KeyUsage.rgpszUsageIdentifier=&szOID;
    if(S_OK != CASetCertTypeExtension(
            hCertType,
            TEXT(szOID_ENHANCED_KEY_USAGE),
            CA_EXT_FLAG_CRITICAL,
            &KeyUsage))
        goto error;


   if(S_OK != CAUpdateCertType(hCertType))
        goto error;

    if(S_OK != CACloseCertType(hCertType))
        goto error;

    hCertType=NULL;


    //edit V2 certificate type: KeyRecoveryAgent
    //update SD, Expiration, 
    if(S_OK != CAFindCertTypeByName(
        wszCERTTYPE_KEY_RECOVERY_AGENT,
        NULL,
        CT_ENUM_USER_TYPES,
        &hCertType
        ))
        goto error;

    if(S_OK != CACertTypeAccessCheckEx(
        hCertType,
        hClientToken,
        CERTTYPE_ACCESS_CHECK_ENROLL))
        goto error;


    dwProp=103;

    if(S_OK != CASetCertTypePropertyEx(
        hCertType,
        CERTTYPE_PROP_REVISION,
        &dwProp))
        goto error;

    if(S_OK != CASetCertTypeFlagsEx(
        hCertType,
        CERTTYPE_ENROLLMENT_FLAG,
        0))
        goto error;

    if(S_OK != CASetCertTypeFlagsEx(
        hCertType,
        CERTTYPE_SUBJECT_NAME_FLAG,
        0))
        goto error;

    if(S_OK != CAGetCertTypeExpiration(
        hCertType,
        &time1,
        &time2))
        goto error;

    if(S_OK != CASetCertTypeExpiration(
        hCertType,
        &time1,
        &time2))
        goto error;

    if(S_OK != CACertTypeGetSecurity(
         hCertType,
         &pSD))
        goto error;

    if(S_OK != CACertTypeSetSecurity(
        hCertType,
        pSD))
        goto error;

    if(S_OK != CAGetCertTypePropertyEx(
            hCertType,
            CERTTYPE_PROP_CSP_LIST,
            &pwszProp))
        goto error;

    if(pwszProp && pwszProp[0])
        printf("The CSP for KRA is: %S\n", pwszProp[0]);
  
    if(S_OK !=  CAFreeCertTypeProperty(
            hCertType,
            pwszProp))
        goto error;
    pwszProp=NULL;


    if(S_OK != CAGetCertTypePropertyEx(
            hCertType,
            CERTTYPE_PROP_RA_POLICY,
            &pwszProp))
        goto error;

    if(pwszProp && pwszProp[0])
        printf("The RAPolicy for KRA is: %S\n", pwszProp[0]);

    if(S_OK !=  CAFreeCertTypeProperty(
            hCertType,
            pwszProp))
        goto error;
    pwszProp=NULL;

    rgwszProp[0]=L"1.2.3.4.5.6.7.8.9.10";
    rgwszProp[1]=L"2.2.3.4.5.6.7.8.9.10";
    rgwszProp[2]=NULL;

    if(S_OK != CASetCertTypePropertyEx(
        hCertType,
        CERTTYPE_PROP_APPLICATION_POLICY,
        rgwszProp))
        goto error; 
    
    rgwszProp[0]=L"1.2.3.4.5.6.7.8.9.10.11";
    rgwszProp[1]=L"2.2.3.4.5.6.7.8.9.10.11";
    rgwszProp[2]=NULL;

    if(S_OK != CASetCertTypePropertyEx(
        hCertType,
        CERTTYPE_PROP_RA_APPLICATION_POLICY,
        rgwszProp))
        goto error; 

    if(S_OK != CAGetCertTypePropertyEx(
            hCertType,
            CERTTYPE_PROP_RA_APPLICATION_POLICY,
            &pwszProp))
        goto error;

    if(pwszProp && pwszProp[0])
        printf("The RAAppPolicy for KRA is: %S\n", pwszProp[0]);

    if(S_OK !=  CAFreeCertTypeProperty(
            hCertType,
            pwszProp))
        goto error;
    pwszProp=NULL;

    if(S_OK != CAGetCertTypePropertyEx(
            hCertType,
            CERTTYPE_PROP_APPLICATION_POLICY,
            &pwszProp))
        goto error;

    if(pwszProp && pwszProp[0])
        printf("The AppPolicy for KRA is: %S\n", pwszProp[0]);

    if(S_OK !=  CAFreeCertTypeProperty(
            hCertType,
            pwszProp))
        goto error;
    pwszProp=NULL;

    if(S_OK != CAUpdateCertType(hCertType))
        goto error;

    if(S_OK != CACloseCertType(hCertType))
        goto error;

    hCertType=NULL;


    //get the KRA properties again
    if(S_OK != CAFindCertTypeByName(
        wszCERTTYPE_KEY_RECOVERY_AGENT,
        NULL,
        CT_ENUM_USER_TYPES,
        &hCertType
        ))
        goto error;

    if(S_OK != CAGetCertTypePropertyEx(
            hCertType,
            CERTTYPE_PROP_RA_APPLICATION_POLICY,
            &pwszProp))
        goto error;

    if(pwszProp && pwszProp[0])
        printf("The RAAppPolicy for KRA is: %S\n", pwszProp[0]);

    if(S_OK !=  CAFreeCertTypeProperty(
            hCertType,
            pwszProp))
        goto error;
    pwszProp=NULL;

    if(S_OK != CAGetCertTypePropertyEx(
            hCertType,
            CERTTYPE_PROP_APPLICATION_POLICY,
            &pwszProp))
        goto error;

    if(pwszProp && pwszProp[0])
        printf("The AppPolicy for KRA is: %S\n", pwszProp[0]);

    if(S_OK !=  CAFreeCertTypeProperty(
            hCertType,
            pwszProp))
        goto error;
    pwszProp=NULL;  

    fSuccess=TRUE;

error:
    if(pwszOID)
        LocalFree(pwszOID);

    if(pCertExtensions)
        CAFreeCertTypeExtensions(hCertType,pCertExtensions);

    if(hCertType)
        CACloseCertType(hCertType);

    if(pSD)
        LocalFree(pSD);

    if(hHandle)
        CloseHandle(hHandle);

    if(hClientToken)
        CloseHandle(hClientToken);

    return fSuccess;
}  


//--------------------------------------------------------------------
BOOL OIDTest()
{
    BOOL                fSuccess=FALSE;
	HRESULT				hr=S_OK;
    DWORD               dwProp=0;
    LPWSTR              rgwszProp[4];
    CERT_ENHKEY_USAGE   KeyUsage;
    LPSTR               szOID="1.2.3.4.5.6";
    FILETIME            time1;
    FILETIME            time2;

    LPWSTR              *pwszProp=NULL;
    LPWSTR              *pwszProp1=NULL;
    LPWSTR              pwszOID=NULL;
    LPWSTR              pwsz=NULL;
    DWORD               dwType=0;


    //oid manipulation
    //create
    if(S_OK != CAOIDCreateNew(CERT_OID_TYPE_TEMPLATE, 0,
                &pwszOID))
        goto error;

    //set/get property test
    if(S_OK != CAOIDSetProperty(
                pwszOID,
                CERT_OID_PROPERTY_DISPLAY_NAME,
                L"MyNewOIDFriendlyName"))
        goto error;

    if(S_OK != CAOIDSetProperty(
                pwszOID,
                CERT_OID_PROPERTY_CPS,
                L"MYCSPStatement"))
        goto error;

    if(S_OK != CAOIDGetProperty(
                pwszOID,
                CERT_OID_PROPERTY_CPS,
                &pwsz))
        goto error;

    printf("The CPS statement is: %S\n", pwsz);

    if(S_OK != CAOIDFreeProperty(pwsz))
        goto error;
    pwsz=NULL;

    if(S_OK != CAOIDGetProperty(
                pwszOID,
                CERT_OID_PROPERTY_TYPE,
                &dwType))
        goto error;

    printf("The property type is: %d\n", dwType);

    if(S_OK == CAOIDSetProperty(
                pwszOID,
                CERT_OID_PROPERTY_TYPE,
                L"MyNewOIDFriendlyName"))
        goto error;

    if(S_OK == CAOIDSetProperty(
                L"1.2",
                CERT_OID_PROPERTY_DISPLAY_NAME,
                L"MyNewOIDFriendlyName"))
        goto error;

    //add and delete
    if(S_OK != CAOIDAdd(CERT_OID_TYPE_ISSUER_POLICY, 0, L"1.2.3"))
        goto error;

    if(S_OK != CAOIDAdd(CERT_OID_TYPE_ISSUER_POLICY, 0, L"1.2.3.4"))
        goto error;

    if(S_OK != CAOIDSetProperty(L"1.2.3.4",  
                CERT_OID_PROPERTY_DISPLAY_NAME,
                L"MyNewIssuerPolicyOid"))
        goto error;

    if(S_OK != CAOIDGetProperty(L"1.2.3.4",  
                CERT_OID_PROPERTY_DISPLAY_NAME,
                &pwsz))
        goto error;
    printf("The display name is: %S\n", pwsz);

   if(S_OK != CAOIDSetProperty(L"1.2.3.4",  
                CERT_OID_PROPERTY_CPS,
                L"The DS Issuer Policy String"))
        goto error;

   if(S_OK != CAOIDSetProperty(L"1.2.3.4",  
                CERT_OID_PROPERTY_CPS,
                NULL))
        goto error;

   if(S_OK != CAOIDSetProperty(L"1.2.3.4",  
                CERT_OID_PROPERTY_CPS,
                L"New CPS"))
        goto error;

    if(S_OK != CAOIDFreeProperty(pwsz))
        goto error;
    pwsz=NULL;

    if(CRYPT_E_EXISTS != CAOIDAdd(CERT_OID_TYPE_ISSUER_POLICY, 0, L"1.2.3"))
        goto error;

    if(S_OK != CAOIDDelete(L"1.2.3"))
        goto error;

    if(S_OK != CAOIDDelete(L"1.2.3.4"))
        goto error;

    //URL testing
    if(S_OK != CAOIDGetLdapURL(CERT_OID_TYPE_TEMPLATE,
                                0,
                                &pwsz))
        goto error;
    printf("The URL for template is: %S\n", pwsz);

    if(S_OK != CAOIDFreeLdapURL(pwsz))
        goto error;

    if(S_OK != CAOIDGetLdapURL(CERT_OID_TYPE_ALL,
                                0,
                                &pwsz))
        goto error;
    printf("The URL for all is: %S\n", pwsz);

    if(S_OK != CAOIDFreeLdapURL(pwsz))
        goto error;

    if(S_OK != CAOIDGetLdapURL(CERT_OID_TYPE_APPLICATION_POLICY,
                                0,
                                &pwsz))
        goto error;
    printf("The URL for application policy is: %S\n", pwsz);

    if(S_OK != CAOIDFreeLdapURL(pwsz))
        goto error;

    fSuccess=TRUE;

error:
    if(pwszOID)
        LocalFree(pwszOID);

   return fSuccess;

} 

//--------------------------------------------------------------------
BOOL QueryTest(BOOL fBind)
{
   
    HRESULT             hr=E_FAIL;
    BOOL                fResult = FALSE;
    DWORD               dwNumber = 0;
    DWORD               dwIndex=0;

    LDAP                *pldap=NULL;
    HCERTTYPEQUERY      hCertTypeQuery=NULL;

    if(fBind)
    {
        if(S_OK != (hr = myRobustLdapBind(&pldap, FALSE)))
        {
            wprintf(L"myRobustLdapBind failed with 0x%08X. \n",hr);
            goto error;
        }

    }

    if(S_OK != CACertTypeRegisterQuery(0, pldap, &hCertTypeQuery))
    {
        wprintf(L"CACertTypeRegisterQury failed with 0x%08X. \n",hr);
        goto error;
    }

    for(dwIndex=0; dwIndex < 3; dwIndex++)
    {
        if(S_OK != CACertTypeQuery(hCertTypeQuery, &dwNumber))
        {
            wprintf(L"CACertTypeQuery failed with 0x%08X. \n",hr);
            goto error;
        }

        wprintf(L"CACertTypeQuery returned %d. \n", dwNumber);
        wprintf(L"Wait for 20 seconds. \n");
        Sleep(20 * 1000);
    }

    fResult = TRUE;

error:

    if(hCertTypeQuery)
        CACertTypeUnregisterQuery(hCertTypeQuery);

    if(pldap)
        ldap_unbind(pldap);

    return fResult;
}


//--------------------------------------------------------------------
//
//
//   CAEnumTest
//
//
//--------------------------------------------------------------------
BOOL CAEnumTest(BOOL fBind, LPWSTR pwszCA)
{
    HRESULT             hr=E_FAIL;
    BOOL                fResult = FALSE;
    DWORD               dwCount = 0;


    HCAINFO             hCAInfo = NULL;
    HCERTTYPE           hCertType = NULL;
    LDAP                *pldap=NULL;
    LPWSTR              *awszProp=NULL;

    if(fBind)
    {
        if(S_OK != (hr = myRobustLdapBind(&pldap, FALSE)))
        {
            wprintf(L"myRobustLdapBind failed with 0x%08X. \n",hr);
            goto error;
        }

    }

    if(S_OK != (hr = CAFindByName(
                    pwszCA,
                    NULL,
                    CA_FIND_LOCAL_SYSTEM,
                    &hCAInfo)))
    {
        wprintf(L"CAFindByName failed with 0x%08X. \n",hr);
        goto error;
    }

    if(NULL==hCAInfo)
    {
        wprintf(L"CAFindByName return NULL hCAInfo. \n");
        goto error;
    }

    if(fBind)
    {
        hr = CAEnumCertTypesForCAEx(
                hCAInfo,
                (LPCWSTR)pldap,
                CT_FIND_LOCAL_SYSTEM | CT_ENUM_MACHINE_TYPES | CT_ENUM_USER_TYPES |
                CT_FLAG_SCOPE_IS_LDAP_HANDLE | CT_FLAG_NO_CACHE_LOOKUP,
                &hCertType);
    }
    else
    {
        hr = CAEnumCertTypesForCA(
                hCAInfo,
                CT_FIND_LOCAL_SYSTEM | CT_ENUM_MACHINE_TYPES | CT_ENUM_USER_TYPES,
                &hCertType);
    }


    if( (S_OK != hr) || (NULL == hCertType))
    {
        wprintf(L"CAEnumCertTyes failed with 0x%08X. \n",hr);
        goto error;
    }

    dwCount = CACountCertTypes(hCertType);

    if(0 == dwCount)
    {
        wprintf(L"Error: CACountCertTypes returns 0 templates.\n");
        goto error;
    }

    wprintf(L"CACountCertTypes returns %d templates.\n", dwCount);

    //get the CA properties
    hr=CAGetCAProperty(hCAInfo,
                CA_PROP_DNSNAME,
                &awszProp);

    if((S_OK != hr) || (NULL==awszProp) || (NULL==awszProp[0]))
    {
        wprintf(L"CAGetCAProperty failed with 0x%08X. \n",hr);
        goto error;
    }

    wprintf(L"CA's DNS name is %s.\n", awszProp[0]);

    hr=CAFreeCAProperty(hCAInfo, awszProp);

    if(S_OK != hr)
    {
        wprintf(L"CAFreeCAProperty failed with 0x%08X. \n",hr);
        goto error;
    }

    //name
    hr=CAGetCAProperty(hCAInfo,
                CA_PROP_NAME,
                &awszProp);

    if((S_OK != hr) || (NULL==awszProp) || (NULL==awszProp[0]))
    {
        wprintf(L"CAGetCAProperty failed with 0x%08X. \n",hr);
        goto error;
    }

    wprintf(L"CA's CN name is %s.\n", awszProp[0]);

    hr=CAFreeCAProperty(hCAInfo, awszProp);

    if(S_OK != hr)
    {
        wprintf(L"CAFreeCAProperty failed with 0x%08X. \n",hr);
        goto error;
    }

    //display name
    hr=CAGetCAProperty(hCAInfo,
                CA_PROP_DISPLAY_NAME,
                &awszProp);

    if((S_OK != hr) || (NULL==awszProp) || (NULL==awszProp[0]))
    {
        wprintf(L"CAGetCAProperty failed with 0x%08X. \n",hr);
        goto error;
    }


    wprintf(L"CA's display name is %s.\n", awszProp[0]);

    hr=CAFreeCAProperty(hCAInfo, awszProp);

    if(S_OK != hr)
    {
        wprintf(L"CAFreeCAProperty failed with 0x%08X. \n",hr);
        goto error;
    }

    //cert types
    hr=CAGetCAProperty(hCAInfo,
                CA_PROP_CERT_TYPES,
                &awszProp);

    if((S_OK != hr) || (NULL==awszProp) || (NULL==awszProp[0]))
    {
        wprintf(L"CAGetCAProperty failed with 0x%08X. \n",hr);
        goto error;
    }

    wprintf(L"CA's cert types name is %s.\n", awszProp[0]);

    hr=CAFreeCAProperty(hCAInfo, awszProp);

    if(S_OK != hr)
    {
        wprintf(L"CAFreeCAProperty failed with 0x%08X. \n",hr);
        goto error;
    }

    fResult = TRUE;

error:

    if(hCertType)
        CACloseCertType(hCertType);

    if(hCAInfo)
    {
        CACloseCA(hCAInfo);
    }

    if(pldap)
        ldap_unbind(pldap);

    return fResult;
}

//--------------------------------------------------------------------
//
//   CloneTest
//
//
//--------------------------------------------------------------------
BOOL CloneTest(BOOL fBind, LPWSTR pwszCertType)
{
    HRESULT             hr=E_FAIL;
    BOOL                fResult = FALSE;
    DWORD               dwFindCT=CT_ENUM_MACHINE_TYPES | CT_ENUM_USER_TYPES;
    WCHAR               wszName[100];
    WCHAR               wszFriendlyName[100];

    LPWSTR              *awszFriendlyName=NULL;
    LDAP                *pldap=NULL;
    HCERTTYPE           hCertType=NULL;
    HCERTTYPE           hNewCertType=NULL;

    if(fBind)
    {
        if(S_OK != (hr = myRobustLdapBind(&pldap, FALSE)))
        {
            wprintf(L"myRobustLdapBind failed with 0x%08X. \n",hr);
            goto error;
        }

    }
   

    if(S_OK != (hr = CAFindCertTypeByName(
                    pwszCertType,
                    NULL,
                    dwFindCT,
                    &hCertType)))
    {
        wprintf(L"CAFindCertTypeByName failed with 0x%08X. \n",hr);
        goto error;
    }


    wcscpy(wszName, pwszCertType);
    wcscat(wszName, L"_Clone");

    wcscpy(wszFriendlyName, pwszCertType);
    wcscat(wszFriendlyName, L"_CloneFriendly");

    if(S_OK != (hr=CACloneCertType(hCertType,
                                    wszName,
                                    wszFriendlyName, 
                                    pldap,
                                    fBind? CT_CLONE_KEEP_AUTOENROLLMENT_SETTING | CT_CLONE_KEEP_SUBJECT_NAME_SETTING : 0,
                                    &hNewCertType)))
    {
        wprintf(L"CACloneCertType failed with 0x%08X. \n",hr);
        goto error;
    }


    if(S_OK != (hr=CAUpdateCertType(hNewCertType)))
    {
        wprintf(L"CAUpdateCertType failed with 0x%08X. \n",hr);
        goto error;

    }

    //close the tempate
    if(S_OK != (hr=CACloseCertType(hNewCertType)))
    {
        hNewCertType=NULL;
        wprintf(L"CACloseCertType failed with 0x%08X. \n",hr);
        goto error;
    }

    hNewCertType=NULL;

    if(S_OK != (hr = CAFindCertTypeByName(
                    wszName,
                    NULL,
                    dwFindCT,
                    &hNewCertType)))
    {
        wprintf(L"CAFindCertTypeByName for the cloned template failed with 0x%08X. \n",hr);
        goto error;
    }

    if(S_OK != (hr=CAGetCertTypePropertyEx(
                    hNewCertType,
                    CERTTYPE_PROP_FRIENDLY_NAME,    
                    &awszFriendlyName)))
    {
        wprintf(L"CAGetCertTypePropertyEx for the cloned template failed with 0x%08X. \n",hr);
        goto error;
    }

    if(0 != (wcscmp(awszFriendlyName[0], wszFriendlyName)))
    {
        wprintf(L"The friendly name for the cloned template does not match the original. \n");
        hr=E_FAIL;
        goto error;
    }

    fResult = TRUE;

error:


    if(pldap)
        ldap_unbind(pldap);

    if(awszFriendlyName)
        CAFreeCertTypeProperty(hNewCertType, awszFriendlyName);

    if(hCertType)
        CACloseCertType(hCertType);

    if(hNewCertType)
        CACloseCertType(hNewCertType);

    return fResult;
}

//--------------------------------------------------------------------
//
//    TemplateDesTest
//
//
//--------------------------------------------------------------------
BOOL    TemplateDesTest()
{
    BOOL        fResult = FALSE;
    HRESULT     hr = E_FAIL;
    DWORD       dwCount=0;
    DWORD       dwIndex=0;

    HCERTTYPE   hCertType=NULL;
    HCERTTYPE   hNextCertType=NULL;
    LPWSTR      *pwszFriendlyName=NULL;
    LPWSTR      *pwszDescription=NULL;
    HANDLE              hClientToken=NULL;
    HANDLE              hHandle = NULL;
    HCAINFO     hCAInfo=NULL;


    //get the client token
/*    hHandle = GetCurrentThread();
    if (NULL == hHandle)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }
    else
    {

        if (!OpenThreadToken(hHandle,
                             TOKEN_QUERY,
                             TRUE,  // open as self
                             &hClientToken))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            CloseHandle(hHandle);
            hHandle = NULL;
        }
    }
    if(hr != S_OK)
    {
        hHandle = GetCurrentProcess();
        if (NULL == hHandle)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }
        else
        {
            HANDLE hProcessToken = NULL;
            hr = S_OK;


            if (!OpenProcessToken(hHandle,
                                 TOKEN_DUPLICATE,
                                 &hProcessToken))
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
                CloseHandle(hHandle);
                hHandle = NULL;
            }
            else
            {
                if(!DuplicateToken(hProcessToken,
                               SecurityImpersonation,
                               &hClientToken))
                {
                    hr = HRESULT_FROM_WIN32(GetLastError());
                    CloseHandle(hHandle);
                    hHandle = NULL;
                }
                CloseHandle(hProcessToken);
            }
        }
    }

    if(S_OK != hr)
        goto error;

    hr = CAFindCertTypeByName(L"WindowsTestBuildSigning",
                              NULL,
                              CT_ENUM_USER_TYPES,
                              &hCertType);

    if(S_OK != hr)
    {
        wprintf(L"CAFindCertTypeByName failed with 0x%08X. \n",hr);
        goto error;
    }

    hr = CACertTypeAccessCheck(
                hCertType,
                hClientToken
                );

    if(S_OK != hr)
    {
        wprintf(L"CACertTypeAccessCheck failed with 0x%08X. \n",hr);
        goto error;
    }


    hr = CAFindByName(
        L"Microsoft Windows VBL03 !0028DS!0029",
        NULL,
        0,
        &hCAInfo);

    if((S_OK != hr) || (NULL==hCAInfo))
    {
        wprintf(L"CAFindByName for %s failed with 0x%08X. \n", hr);
        goto error;
    }

    hr=CAAccessCheck(hCAInfo,
                    hClientToken);

    if(S_OK != hr)
    {
        wprintf(L"CAAccessCheck failed with 0x%08X. \n",hr);
        goto error;
    } */


    hr = CAEnumCertTypes(
                CT_ENUM_MACHINE_TYPES | CT_ENUM_USER_TYPES,
                &hCertType);

    if((S_OK != hr) || (NULL==hCertType))
    {
        wprintf(L"CAEnumCertTyes failed with 0x%08X. \n",hr);
        goto error;
    }

    dwCount = CACountCertTypes(hCertType);

    wprintf(L"We have 0x%d cert types. \n", dwCount);

    if(0 == dwCount)
        goto error;

    for(dwIndex=0; dwIndex < dwCount; dwIndex++)
    {
        if(dwIndex!=0)
        {
            hr = CAEnumNextCertType(hCertType, &hNextCertType);
            
            if(S_OK != hr)
            {
                wprintf(L"CAEnumNextCertType failed with 0x%08X. \n",hr);
                goto error;
            }
            
            CACloseCertType(hCertType);
    
            hCertType=hNextCertType;

        }

        hr = CAGetCertTypePropertyEx(hCertType,
                                    CERTTYPE_PROP_FRIENDLY_NAME,
                                    &pwszFriendlyName);

        if((S_OK != hr) || (NULL==pwszFriendlyName) || (NULL==pwszFriendlyName[0]))
        {
            wprintf(L"Friendly Name property failed with 0x%08X. \n",hr);
            goto error;
        }
                                   
        hr = CAGetCertTypePropertyEx(hCertType,
                                    CERTTYPE_PROP_DESCRIPTION,
                                    &pwszDescription);

        if((S_OK != hr) || (NULL==pwszDescription) || (NULL==pwszDescription[0]))
        {
            wprintf(L"Description property failed with 0x%08X. \n",hr);
            goto error;
        }

        wprintf(L"%s has the description of %s. \n",pwszFriendlyName[0], pwszDescription[0]);

        CAFreeCertTypeProperty(hCertType, pwszFriendlyName);
        CAFreeCertTypeProperty(hCertType, pwszDescription);
    }  

    fResult = TRUE;

error:
    if(hHandle)
        CloseHandle(hHandle);

    if(hClientToken)
        CloseHandle(hClientToken);

    return fResult;

}

//--------------------------------------------------------------------
//
//    OIDURLTest
//
//
//--------------------------------------------------------------------
BOOL    OIDURLTest()
{
    BOOL        fResult=FALSE;
    HRESULT     hr=E_FAIL; 
    DWORD       dwIndex=0;

    LPWSTR      pwsz=NULL;


    for(dwIndex=0; dwIndex < 14; dwIndex++)
    {
        //URL testing
        if(S_OK != (hr=CAOIDGetLdapURL(CERT_OID_TYPE_TEMPLATE,
                                    0,
                                    &pwsz)))
        {
            wprintf(L"CAOIDGetLdapURL failed with 0x%08X. \n",hr);
        }

        printf("The URL for template is: %S\n", pwsz);

        if(S_OK != (hr=CAOIDFreeLdapURL(pwsz)))
        {
            wprintf(L"CAOIDFreeLdapURL failed with 0x%08X. \n",hr);
            goto error;  
        }

        //sleep for 1 second
        Sleep(1000);
    }

    fResult=TRUE;

error:

    return fResult;

}


//--------------------------------------------------------------------
//
//    ACRSTest
//
//
//--------------------------------------------------------------------
BOOL    ACRSTest()
{
    BOOL        fResult=FALSE;
    HRESULT     hr=E_FAIL;


  /*  hr = CACreateLocalAutoEnrollmentObject(
                    wszCERTTYPE_DC,                     // DC certificate
                    NULL,                               // any CA
                    NULL,                               // reserved
                    CERT_SYSTEM_STORE_LOCAL_MACHINE);  
    
    if(S_OK != hr)
    {
        wprintf(L"CreateLocalAutoEnrollmentObject failed with 0x%08X. \n",hr);
        goto error;
    } */

    hr = CADeleteLocalAutoEnrollmentObject(
                    wszCERTTYPE_DC,                     // DC certificate
                    NULL,                               // any CA
                    NULL,                               // reserved
                    CERT_SYSTEM_STORE_LOCAL_MACHINE);  
    
    if(S_OK != hr)
    {
        wprintf(L"DeleteLocalAutoEnrollmentObject failed with 0x%08X. \n",hr);
        goto error;
    }

    fResult=TRUE;

error:

    return fResult;

}


//--------------------------------------------------------------------
extern "C" int __cdecl wmain(int nArgs, WCHAR ** rgwszArgs) 
{
    BOOL    fResult;


    if (1 == nArgs || 0==wcscmp(rgwszArgs[1], L"/?") || 0==wcscmp(rgwszArgs[1], L"-?")) {
        PrintHelp();
        goto done;
    }

    if (0==_wcsicmp(L"OID", rgwszArgs[1])) {
        fResult=OIDTest();

    } else if (0==_wcsicmp(L"Template", rgwszArgs[1])) {
        fResult=TemplateTest();

    } else if (0==_wcsicmp(L"Query", rgwszArgs[1])) {
        fResult=QueryTest(FALSE);

    } else if (0==_wcsicmp(L"QueryLDAP", rgwszArgs[1])) {
        fResult=QueryTest(TRUE);

    } else if (0==_wcsicmp(L"CAEnum", rgwszArgs[1])) {
        fResult=CAEnumTest(FALSE, rgwszArgs[2]);

    } else if (0==_wcsicmp(L"CAEnumLDAP", rgwszArgs[1])) {
        fResult=CAEnumTest(TRUE, rgwszArgs[2]);

    } else if (0==_wcsicmp(L"Clone", rgwszArgs[1])) {
        fResult=CloneTest(FALSE, rgwszArgs[2]);

    } else if (0==_wcsicmp(L"CloneLDAP", rgwszArgs[1])) {
        fResult=CloneTest(TRUE, rgwszArgs[2]);

    } else if (0==_wcsicmp(L"TemplateDes", rgwszArgs[1])) {
        fResult=TemplateDesTest();

    } else if (0==_wcsicmp(L"ACRS", rgwszArgs[1])) {
        fResult=ACRSTest();

    } else if (0==_wcsicmp(L"OIDURL", rgwszArgs[1])) {
        fResult=OIDURLTest();

    } else {
        wprintf(L"Command '%s' unknown.\n", rgwszArgs[1]);
        goto done;
    }
      
    if (!fResult) {
        wprintf(L"Command '%s' failed \n", rgwszArgs[1]);
    } else {
        wprintf(L"Command '%s' completed successfully.\n", rgwszArgs[1]);
    }

done:
    return fResult;
	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\tools\certut\view.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       view.cpp
//
//--------------------------------------------------------------------------

#include <pch.cpp>

#pragma hdrstop


#include <esent.h>
#include <certdb.h>
#include "csprop.h"

#define wszQUEUE	L"Queue"
#define wszLOG		L"Log"
#define wszLOGFAIL	L"LogFail"
#define wszREVOKED	L"Revoked"

#define wszCOLONQUEUE	L":" wszQUEUE
#define wszCOLONLOG	L":" wszLOG
#define wszCOLONLOGFAIL	L":" wszLOGFAIL
#define wszCOLONREVOKED	L":" wszREVOKED


ICertDB *g_pdb = NULL;

WCHAR const g_wszAttrib[] = L"attrib";
WCHAR const g_wszExt[] = L"ext";
WCHAR const g_wszCRL[] = L"CRL";

WCHAR const *g_apwszAllowedPrefixes[] =
{
    g_wszAttrib,
    g_wszExt,
    NULL
};

BOOL
cuDBIsShutDownInProgress()
{
    return(NULL == g_pdb);
}


HRESULT
ParseToken(
    OUT WCHAR *awcBuf,
    IN DWORD cwcBuf,
    IN BOOL fMatchPrefix,
    OPTIONAL IN WCHAR const *pwszPrefix,
    OPTIONAL IN WCHAR const * const *apwszAllowedPrefixes,
    OPTIONAL OUT BOOL *pfAllColumns,
    OUT WCHAR const **ppwszColumn,
    IN OUT WCHAR const **ppwszNext);


WCHAR const *
cuwszPropType(
   IN LONG PropType)
{
    DWORD msgid;

    switch (PropType)
    {
	case PROPTYPE_DATE:
	    msgid = IDS_PROPTYPE_DATE;		// "Date"
	    break;

	case PROPTYPE_LONG:
	    msgid = IDS_PROPTYPE_LONG;		// "Long"
	    break;

	case PROPTYPE_STRING:
	    msgid = IDS_PROPTYPE_STRING;	// "String"
	    break;

	case PROPTYPE_BINARY:
	    msgid = IDS_PROPTYPE_BINARY;	// "Binary"
	    break;

	default:
	    msgid = IDS_QUESTIONMARKS;		// "???"
	    break;
    }
    return(myLoadResourceString(msgid));
}


typedef struct _COLINFO
{
    BSTR strCol;
    BSTR strColDisplay;
    LONG type;
    LONG maxlen;
    LONG indexed;
} COLINFO;


VOID
cuPrintSchemaEntry(
    OPTIONAL IN WCHAR const *pwszName,
    IN WCHAR const *pwszDisplayName,
    IN LONG Type,
    IN LONG cbMax)
{
    // wprintf(L"  %-28ws  %-28ws  %-6ws", ...);
    // OR
    // wprintf(L"%-30ws  %-6ws", ...);

    if (NULL != pwszName)
    {
	wprintf(L"  ");
	myConsolePrintString(28, pwszName);
	wprintf(L"  ");
    }
    myConsolePrintString(NULL != pwszName? 28 : 30, pwszDisplayName);
    wprintf(L"  ");
    myConsolePrintString(6, cuwszPropType(PROPTYPE_MASK & Type));

    if (0 != cbMax)
    {
	wprintf(L"  %u", cbMax);
    }
    if (PROPFLAGS_INDEXED & Type)
    {
	wprintf(myLoadResourceString(IDS_INDEXED)); // " -- Indexed"
    }
    wprintf(wszNewLine);
}


HRESULT
DisplaySchema(
    IN DISPATCHINTERFACE *pdiView,
    IN LONG cColOut,
    OPTIONAL IN OUT COLINFO *aColInfo,
    IN BOOL fResult)
{
    HRESULT hr;
    LONG i;
    BOOL fMustReleaseColumn = FALSE;
    DISPATCHINTERFACE diViewColumn;
    BSTR strCol = NULL;
    BSTR strColDisplay = NULL;
    LONG type;
    LONG maxlen;
    LONG indexed;

    wprintf(myLoadResourceString(IDS_SCHEMA_COLON)); // "Schema:"
    wprintf(wszNewLine);
    wprintf(myLoadResourceString(IDS_SCHEMA_COLUMNHEADERS)); // "Name..Type..."
    wprintf(wszNewLine);
    wprintf(myLoadResourceString(IDS_SCHEMA_COLUMNUNDERLINE)); // "____...____"
    wprintf(wszNewLine);

    hr = View_EnumCertViewColumn(
		pdiView,
		fResult? CVRC_COLUMN_RESULT : CVRC_COLUMN_SCHEMA,
		&diViewColumn);
    _JumpIfError(hr, error, "View_EnumCertViewColumn");

    fMustReleaseColumn = TRUE;

    for (i = 0; ; i++)
    {
	LONG ielt;

	hr = ViewColumn_Next(&diViewColumn, &ielt);
	if (S_FALSE == hr || (S_OK == hr && -1 == ielt))
	{
	    CSASSERT(-1 == ielt);
	    CSASSERT(i == cColOut);
	    hr = S_OK;
	    break;
	}
	_JumpIfError(hr, error, "ViewColumn_Next");
	CSASSERT(-1 != ielt);
	CSASSERT(i < cColOut);

	hr = ViewColumn_GetName(&diViewColumn, &strCol);
	_JumpIfError(hr, error, "ViewColumn_GetName");

	hr = ViewColumn_GetDisplayName(&diViewColumn, &strColDisplay);
	_JumpIfError(hr, error, "ViewColumn_GetDisplayName");

	hr = ViewColumn_GetType(&diViewColumn, &type);
	_JumpIfError(hr, error, "ViewColumn_GetType");

	hr = ViewColumn_GetMaxLength(&diViewColumn, &maxlen);
	_JumpIfError(hr, error, "ViewColumn_GetType");

	hr = ViewColumn_IsIndexed(&diViewColumn, &indexed);
	_JumpIfError(hr, error, "ViewColumn_IsIndexed");

	cuPrintSchemaEntry(
			strCol,
			strColDisplay,
			type | (indexed? PROPFLAGS_INDEXED : 0),
			maxlen);

	if (NULL != aColInfo)
	{
	    aColInfo[i].strCol = strCol;
	    strCol = NULL;
	    aColInfo[i].strColDisplay = strColDisplay;
	    strColDisplay = NULL;
	    aColInfo[i].type = type;
	    aColInfo[i].maxlen = maxlen;
	    aColInfo[i].indexed = indexed;
	}
    }

error:
    if (NULL != strCol)
    {
	SysFreeString(strCol);
    }
    if (NULL != strColDisplay)
    {
	SysFreeString(strColDisplay);
    }
    if (fMustReleaseColumn)
    {
	ViewColumn_Release(&diViewColumn);
    }
    return(hr);
}


LONG *g_askip = NULL;
LONG g_cskip = 0;
LONG g_iskip = 0;
BOOL g_fskip = FALSE;

LONG
GetSkip(
    IN BOOL fAdvance)
{
    LONG cskip = 0;

    if (g_fskip)
    {
	if (g_iskip >= g_cskip)
	{
	    g_iskip = 0;
	}
	cskip = g_askip[g_iskip];
	if (fAdvance)
	{
	    g_iskip++;
	}
    }
    return(cskip);
}


HRESULT
ParseSkipCounts(
    IN WCHAR const *pwszField)
{
    HRESULT hr;
    LONG i;
    WCHAR const *pwszNext;
    WCHAR const *pwszColumn;
    WCHAR awc[MAX_PATH];

    pwszNext = pwszField;
    for (i = 0; ; i++)
    {
	hr = ParseToken(
		    awc,
		    ARRAYSIZE(awc),
		    FALSE,
		    NULL,
		    NULL,
		    NULL,
		    &pwszColumn,
		    &pwszNext);
	if (S_FALSE == hr)
	{
	    break;
	}
	_JumpIfError(hr, error, "ParseToken");
    }
    if (0 != i)
    {
	g_askip = (LONG *) LocalAlloc(LMEM_FIXED, i * sizeof(LONG));
	if (NULL == g_askip)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "no memory for skip counts array");
	}
	g_cskip = i;
	g_iskip = 0;

	pwszNext = pwszField;
	for (i = 0; ; i++)
	{
	    hr = ParseToken(
			awc,
			ARRAYSIZE(awc),
			FALSE,
			NULL,
			NULL,
			NULL,
			&pwszColumn,
			&pwszNext);
	    if (S_FALSE == hr)
	    {
		break;
	    }
	    _JumpIfError(hr, error, "ParseToken");

	    hr = cuGetSignedLong(pwszColumn, &g_askip[i]);
	    _JumpIfError(hr, error, "cuGetLong");

	    //wprintf(L"ParseToken: %u: skip = '%ws' %d\n", i, pwszColumn, g_askip[i]);
	}
	CSASSERT(i == g_cskip);
	g_fskip = TRUE;
    }
    hr = S_OK;

error:
    return(hr);
}


HRESULT
ParseRestriction(
    IN WCHAR const *pwszField,
    OUT LONG *pColIndex,
    OUT LONG *pSeekOperator,
    OUT LONG *pSortOrder,
    OUT WCHAR **ppwszColName,
    OUT WCHAR **ppwszColValue)
{
    HRESULT hr;
    DWORD i;
    LONG SortOrder;
    LONG SeekOperator;
    LONG SeekOperator2;
    WCHAR *pwszColName = NULL;
    WCHAR *pwszColValue = NULL;

    *pColIndex = 0;
    *ppwszColName = NULL;
    *ppwszColValue = NULL;

    SeekOperator = CVR_SEEK_GE;
    SortOrder = CVR_SORT_NONE;
    if (L'+' == *pwszField)
    {
	SortOrder = CVR_SORT_ASCEND;
	pwszField++;
    }
    else if (L'-' == *pwszField)
    {
	SortOrder = CVR_SORT_DESCEND;
	pwszField++;
    }
    while (L' ' == *pwszField)
    {
	pwszField++;
    }

    // Copy the column name into wszBuf, and advance the pointer

    i = wcscspn(pwszField, L"<>=");

    pwszColName = (WCHAR *) LocalAlloc(LMEM_FIXED, (i + 1) * sizeof(WCHAR));
    if (NULL == pwszColName)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }

    CopyMemory(pwszColName, pwszField, i * sizeof(WCHAR));
    pwszField += i;
    while (0 < i && L' ' == pwszColName[i - 1])
    {
	i--;
    }
    pwszColName[i] = L'\0';

    switch (*pwszField)
    {
	case L'\0':
	    SeekOperator = CVR_SEEK_NONE;
	    break;

	case L'<':
	    SeekOperator = CVR_SEEK_LT;		// "<"
	    SeekOperator2 = CVR_SEEK_LE;	// "<="
	    break;

	case L'>':
	    SeekOperator = CVR_SEEK_GT;		// ">"
	    SeekOperator2 = CVR_SEEK_GE;	// ">="
	    break;

	case L'=':
	    SeekOperator = CVR_SEEK_EQ;		// "="
	    SeekOperator2 = CVR_SEEK_EQ;	// "=="
	    break;
	
	default:
	    hr = E_INVALIDARG;
	    _JumpError(hr, error, "bad seek operator");
    }
    if (L'\0' != *pwszField)
    {
	if (L'=' == *++pwszField)
	{
	    SeekOperator = SeekOperator2;
	    pwszField++;
	}
    }

    while (L' ' == *pwszField)
    {
	pwszField++;
    }
    i = wcslen(pwszField);
    if (0 != i)
    {
	pwszColValue = (WCHAR *) LocalAlloc(
				    LMEM_FIXED,
				    (i + 1) * sizeof(WCHAR));
	if (NULL == pwszColValue)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "LocalAlloc");
	}

	wcscpy(pwszColValue, pwszField);
	while (0 < i && L' ' == pwszColValue[i - 1])
	{
	    i--;
	}
	pwszColValue[i] = L'\0';
	cuConvertEscapeSequences(pwszColValue);
    }
    if (NULL == pwszColValue)
    {
	if (0 == lstrcmpi(pwszColName, wszCOLONQUEUE))
	{
	    *pColIndex = CV_COLUMN_QUEUE_DEFAULT;
	}
	else if (0 == lstrcmpi(pwszColName, wszCOLONLOG))
	{
	    *pColIndex = CV_COLUMN_LOG_DEFAULT;
	}
	else if (0 == lstrcmpi(pwszColName, wszCOLONLOGFAIL))
	{
	    *pColIndex = CV_COLUMN_LOG_FAILED_DEFAULT;
	}
	else if (0 == lstrcmpi(pwszColName, wszCOLONREVOKED))
	{
	    *pColIndex = CV_COLUMN_LOG_REVOKED_DEFAULT;
	}
	else
	{
	    hr = E_INVALIDARG;
	    _JumpError(hr, error, "bad special column name");
	}
    }
    else
    {
	*ppwszColName = pwszColName;
	*ppwszColValue = pwszColValue;
	pwszColName = NULL;
	pwszColValue = NULL;
    }
    *pSortOrder = SortOrder;
    *pSeekOperator = SeekOperator;
    hr = S_OK;

error:
    if (NULL != pwszColName)
    {
	LocalFree(pwszColName);
    }
    if (NULL != pwszColValue)
    {
	LocalFree(pwszColValue);
    }
    return(hr);
}


HRESULT
ParseSpecialColumnValue(
    IN WCHAR const *pwszColValue,
    IN LONG ColType,
    IN OUT LONG *pSeekOperator,
    IN OUT LONG *pSortOrder,
    OUT BOOL *pfLastRow)
{
    HRESULT hr;

    *pfLastRow = FALSE;
    if (0 != lstrcmp(pwszColValue, L"$"))
    {
	hr = S_OK;
	goto error;
    }
    if (CVR_SEEK_EQ != *pSeekOperator || CVR_SORT_NONE != *pSortOrder)
    {
	hr = E_INVALIDARG;
	_JumpError(hr, error, "bad special restriction");
    }
    *pSeekOperator = CVR_SEEK_GE;
    *pSortOrder = CVR_SORT_DESCEND;
    *pfLastRow = TRUE;
    hr = S_OK;

error:
    return(hr);
}


HRESULT
SetViewRestriction(
    IN DISPATCHINTERFACE *pdiView,
    IN WCHAR const *pwszField,
    OUT BOOL *pfLastRow)
{
    HRESULT hr;
    VARIANT var;
    LONG ColIndex;
    LONG ColType;
    BSTR strColName = NULL;
    LONG SeekOperator;
    LONG SortOrder;
    WCHAR *pwszColName = NULL;
    WCHAR *pwszColValue = NULL;
    BOOL fMustReleaseColumn = FALSE;
    DISPATCHINTERFACE diViewColumn;

    VariantInit(&var);
    *pfLastRow = FALSE;

    hr = ParseRestriction(
			pwszField,
			&ColIndex,
			&SeekOperator,
			&SortOrder,
			&pwszColName,
			&pwszColValue);
    _JumpIfErrorStr(hr, error, "ParseRestriction", pwszField);

    // no value to parse if a special column...

    if (NULL == pwszColName)
    {
	CSASSERT(0 > ColIndex);
    }
    else
    {
	LONG ielt;

	hr = View_GetColumnIndex(
			    pdiView,
			    CVRC_COLUMN_SCHEMA,
			    pwszColName,
			    &ColIndex);
	_JumpIfErrorStr(hr, error, "View_GetColumnIndex", pwszColName);

	hr = View_EnumCertViewColumn(
			    pdiView,
			    CVRC_COLUMN_SCHEMA,
			    &diViewColumn);
	_JumpIfError(hr, error, "View_EnumCertViewColumn");

	fMustReleaseColumn = TRUE;

	hr = ViewColumn_Skip(&diViewColumn, ColIndex);
	_JumpIfError(hr, error, "ViewColumn_Skip");

	hr = ViewColumn_Next(&diViewColumn, &ielt);
	if (S_OK == hr && -1 == ielt)
	{
	    hr = S_FALSE;
	}
	_JumpIfError(hr, error, "ViewColumn_Next");

	hr = ViewColumn_GetName(&diViewColumn, &strColName);
	_JumpIfError(hr, error, "GetName");

	hr = ViewColumn_GetType(&diViewColumn, &ColType);
	_JumpIfError(hr, error, "GetType");

	hr = ParseSpecialColumnValue(
				pwszColValue,
				ColType,
				&SeekOperator,
				&SortOrder,
				pfLastRow);
	_JumpIfError(hr, error, "ParseSpecialColumnValue");

	switch (ColType)
	{
	    case PROPTYPE_LONG:
		var.lVal = 0;
		if (!*pfLastRow)
		{
		    hr = cuGetSignedLong(pwszColValue, &var.lVal);
		    _JumpIfError(hr, error, "bad numeric operand");
		}
		var.vt = VT_I4;
		break;

	    case PROPTYPE_DATE:
		var.date = 0;
		if (!*pfLastRow)
		{
		    hr = myWszLocalTimeToGMTDate(pwszColValue, &var.date);
		    _JumpIfError(hr, error, "invalid date format");
		}
		var.vt = VT_DATE;
		cuDumpDate(&var.date);
		break;

	    case PROPTYPE_STRING:
	    {
		WCHAR const *pwsz = L"";
		
		var.bstrVal = NULL;
		if (!*pfLastRow)
		{
		    pwsz = pwszColValue;
		}
		if (!ConvertWszToBstr(&var.bstrVal, pwsz, MAXDWORD))
		{
		    hr = E_OUTOFMEMORY;
		    _JumpError(hr, error, "ConvertWszToBstr");
		}
		var.vt = VT_BSTR;
		break;
	    }

	    case PROPTYPE_BINARY:
	    default:
		hr = E_INVALIDARG;
		_JumpError(hr, error, "not supported");
	}
    }
    //wprintf(L"ColIndex=%x(%d) vt=%d\n", ColIndex, ColIndex, var.vt);

    hr = View_SetRestriction(
			pdiView,
			ColIndex,		// Restriction ColumnIndex
			SeekOperator,
			SortOrder,
			&var);			// pvarValue
    _JumpIfError(hr, error, "View_SetRestriction");

error:
    if (NULL != pwszColName)
    {
	LocalFree(pwszColName);
    }
    if (NULL != pwszColValue)
    {
	LocalFree(pwszColValue);
    }
    if (fMustReleaseColumn)
    {
	ViewColumn_Release(&diViewColumn);
    }
    if (NULL != strColName)
    {
	SysFreeString(strColName);
    }
    VariantClear(&var);
    return(hr);
}


HRESULT
cuParseStrings(
    IN WCHAR const *pwszStrings,
    IN BOOL fMatchPrefix,
    OPTIONAL IN WCHAR const *pwszPrefix,
    OPTIONAL IN WCHAR const * const *apwszAllowedPrefixes,
    OUT WCHAR ***papwszStrings,
    OPTIONAL OUT BOOL *pfAllFields)
{
    HRESULT hr;
    WCHAR const *pwszNext;
    WCHAR awc[MAX_PATH];
    DWORD i;
    WCHAR const *pwszCurrent;
    WCHAR **ppwsz;
    DWORD cb;

    if (NULL != pfAllFields)
    {
	*pfAllFields = FALSE;
    }

    pwszNext = pwszStrings;
    for (i = 0; ; i++)
    {
	hr = ParseToken(
		    awc,
		    ARRAYSIZE(awc),
		    fMatchPrefix,
		    pwszPrefix,
		    apwszAllowedPrefixes,
		    pfAllFields,
		    &pwszCurrent,
		    &pwszNext);
	if (S_FALSE == hr)
	{
	    break;
	}
	_JumpIfError(hr, error, "ParseToken");
    }
    if (0 != i)
    {
	*papwszStrings = (WCHAR **) LocalAlloc(
					    LMEM_FIXED | LMEM_ZEROINIT,
					    (i + 1) * sizeof(WCHAR *));
	if (NULL == *papwszStrings)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "no memory for string array");
	}

	ppwsz = *papwszStrings;
	pwszNext = pwszStrings;
	for ( ; 0 < i; i--)
	{
	    hr = ParseToken(
			awc,
			ARRAYSIZE(awc),
			fMatchPrefix,
			pwszPrefix,
			apwszAllowedPrefixes,
			pfAllFields,
			&pwszCurrent,
			&pwszNext);
	    CSASSERT(S_FALSE != hr);
	    _JumpIfError(hr, error, "ParseToken");

	    cb = (wcslen(pwszCurrent) + 1) * sizeof(WCHAR);
	    *ppwsz = (WCHAR *) LocalAlloc(LMEM_FIXED, cb);
	    if (NULL == *ppwsz)
	    {
		hr = E_OUTOFMEMORY;
		_JumpError(hr, error, "no memory for string");
	    }
	    CopyMemory(*ppwsz, pwszCurrent, cb);
	    ppwsz++;

	}
	*ppwsz = NULL;
    }
    hr = S_OK;

error:
    return(hr);
}


HRESULT
ParseViewRestrictions(
    IN WCHAR const *pwszRestrictions,
    OUT WCHAR ***papwszRestrictions)
{
    HRESULT hr;

    hr = cuParseStrings(
		pwszRestrictions,
		FALSE,
		NULL,
		NULL,
		papwszRestrictions,
		NULL);
    _JumpIfError(hr, error, "cuParseStrings");

error:
    return(hr);
}


HRESULT
ParseToken(
    OUT WCHAR *awcBuf,
    IN DWORD cwcBuf,
    IN BOOL fMatchPrefix,
    OPTIONAL IN WCHAR const *pwszPrefix,
    OPTIONAL IN WCHAR const * const *apwszAllowedPrefixes,
    OPTIONAL OUT BOOL *pfAllColumns,
    OUT WCHAR const **ppwszColumn,
    IN OUT WCHAR const **ppwszNext)
{
    HRESULT hr;
    WCHAR const *pwsz;
    WCHAR *pwszT;
    WCHAR *pwszColumn;
    DWORD cwc;
    DWORD cwcPrefix = 0;

    if (NULL != pwszPrefix)
    {
	cwcPrefix = wcslen(pwszPrefix);
    }
    while (TRUE)
    {
	// Grab the next comma-separated token, and trim white space.

	awcBuf[0] = L'\0';
	pwsz = *ppwszNext;
	while (L' ' == *pwsz)
	{
	    pwsz++;
	}
	cwc = wcscspn(pwsz, L",");
	if (cwc >= cwcBuf)
	{
	    hr = HRESULT_FROM_WIN32(ERROR_BUFFER_OVERFLOW);
	    _JumpError(hr, error, "Buffer overflow");
	}
	CopyMemory(awcBuf, pwsz, cwc * sizeof(WCHAR));
	awcBuf[cwc] = L'\0';

	pwsz += cwc;
	while (L',' == *pwsz)
	{
	    pwsz++;
	}
	*ppwszNext = pwsz;

	while (0 < cwc && L' ' == awcBuf[cwc - 1])
	{
	    awcBuf[--cwc] = L'\0';
	}

	if (0 == cwc)
	{
	    *ppwszColumn = NULL;
	    hr = S_FALSE;
	    _JumpError2(hr, error, "end of list", hr);
	}
	pwszColumn = awcBuf;	// assume no prefix

	if (fMatchPrefix)
	{
	    // Look for a colon separator that delimits a matching prefix.
	    // The separator must precede any relational operators:

	    cwc = wcscspn(awcBuf, L"<>=:");
	    pwszT = &awcBuf[cwc];

	    if (L':' != *pwszT)
	    {
		if (NULL != pwszPrefix)
		{
		    continue;		// prefix missing, but expected
		}
	    }
	    else
	    {
		pwszColumn = pwszT;
		*pwszColumn++ = L'\0';
		while (L' ' == *pwszColumn)
		{
		    pwszColumn++;
		}
		while (pwszT > awcBuf && L' ' == *(pwszT - 1))
		{
		    *--pwszT = L'\0';
		}

		if (NULL != apwszAllowedPrefixes)
		{
		    WCHAR const * const *ppwsz;
		    
		    for (ppwsz = apwszAllowedPrefixes; NULL != *ppwsz; ppwsz++)
		    {
			if (0 == lstrcmpi(awcBuf, *ppwsz))
			{
			    break;
			}
		    }
		    if (NULL == *ppwsz)
		    {
			hr = E_INVALIDARG;
			_JumpErrorStr(hr, error, "bad prefix", awcBuf);
		    }
		}
		if (NULL == pwszPrefix)
		{
		    continue;		// prefix not expected
		}
		if (pwszT - awcBuf != (LONG) cwcPrefix)
		{
		    continue;		// prefix length doesn't match
		}
		if (0 != lstrcmpi(awcBuf, pwszPrefix))
		{
		    continue;		// prefix doesn't match
		}
	    }
	    if (NULL != pfAllColumns && 0 == lstrcmpi(pwszColumn, L"all"))
	    {
		*pfAllColumns = TRUE;
		continue;
	    }
	}
	*ppwszColumn = pwszColumn;
	hr = S_OK;
	break;
    }

error:
    if (S_OK != hr && 0 < cwcBuf)
    {
	awcBuf[0] = L'\0';
    }
    return(hr);
}


HRESULT
ParseViewColumns(
    IN WCHAR const *pwszColumns,
    IN WCHAR const *pwszPrefix,
    OPTIONAL IN WCHAR const * const *apwszAllowedPrefixes,
    OUT WCHAR ***papwszColumns,
    OUT BOOL *pfAllColumns)
{
    HRESULT hr;

    hr = cuParseStrings(
		pwszColumns,
		TRUE,
		pwszPrefix,
		apwszAllowedPrefixes,
		papwszColumns,
		pfAllColumns);
    _JumpIfError(hr, error, "cuParseStrings");

error:
    return(hr);
}


VOID
PrintRowIndex(
    IN LONG iRow,
    IN OUT BOOL *pfPrinted)
{
    if (!*pfPrinted)
    {
	wprintf(wszNewLine);
	wprintf(myLoadResourceString(IDS_FORMAT_ROWID), iRow); // "Row %u:"
	wprintf(wszNewLine);
	*pfPrinted = TRUE;
    }
}


VOID
cuFreeStringArray(
    IN OUT WCHAR **apwsz)
{
    WCHAR **ppwsz;

    if (NULL != apwsz)
    {
	for (ppwsz = apwsz; NULL != *ppwsz; ppwsz++)
	{
	    LocalFree(*ppwsz);
	}
	LocalFree(apwsz);
    }
}


VOID
DumpLongValue(
    IN LONG longValue,
    IN WCHAR const *pwszColumName)
{
    long aidMsg[20];
    DWORD cidMsg;
    DWORD i;
    WCHAR const *pwszError = NULL;
    WCHAR const *pwszMsg = NULL;
    WCHAR awchr[cwcHRESULTSTRING];
    BOOL fDisplayNumeric = TRUE;
    BOOL fDisplayFlags = FALSE;

    cidMsg = 0;
    if (0 == lstrcmpi(
		wszPROPREQUESTDOT wszPROPREQUESTDISPOSITION,
		pwszColumName))
    {
	switch (longValue)
	{
	    case DB_DISP_ACTIVE:  aidMsg[0] = IDS_DISP_ACTIVE;        break;
	    case DB_DISP_PENDING: aidMsg[0] = IDS_DISP_PENDING;       break;
	    case DB_DISP_FOREIGN: aidMsg[0] = IDS_DISP_FOREIGN_CERT;  break;
	    case DB_DISP_KRA_CERT: aidMsg[0] = IDS_DISP_KRA_CERT;     break;
	    case DB_DISP_CA_CERT: aidMsg[0] = IDS_DISP_CA_CERT;       break;
	    case DB_DISP_CA_CERT_CHAIN:
				  aidMsg[0] = IDS_DISP_CA_CERT_CHAIN; break;
	    case DB_DISP_ISSUED:  aidMsg[0] = IDS_DISP_ISSUED;        break;
	    case DB_DISP_REVOKED: aidMsg[0] = IDS_DISP_REVOKED;       break;
	    case DB_DISP_ERROR:   aidMsg[0] = IDS_DISP_ERROR;         break;
	    case DB_DISP_DENIED:  aidMsg[0] = IDS_DISP_DENIED;        break;
	    default:              aidMsg[0] = IDS_QUESTIONMARKS;      break;
	}
	cidMsg = 1;
    }
    else
    if (0 == lstrcmpi(wszPROPREQUESTDOT wszPROPREQUESTFLAGS, pwszColumName))
    {
	if (CR_FLG_RENEWAL & longValue)
	{
	    aidMsg[cidMsg++] = IDS_REQFLAGS_RENEWAL;
	}
	if (CR_FLG_FORCETELETEX & longValue)
	{
	    aidMsg[cidMsg++] = IDS_REQFLAGS_FORCETELETEX;
	}
	if (CR_FLG_FORCEUTF8 & longValue)
	{
	    aidMsg[cidMsg++] = IDS_REQFLAGS_FORCEUTF8;
	}
	if (CR_FLG_CAXCHGCERT & longValue)
	{
	    aidMsg[cidMsg++] = IDS_REQFLAGS_CAXCHGCERT;
	}
	if (CR_FLG_ENROLLONBEHALFOF & longValue)
	{
	    aidMsg[cidMsg++] = IDS_REQFLAGS_ENROLLONBEHALFOF;
	}
	if (CR_FLG_SUBJECTUNMODIFIED & longValue)
	{
	    aidMsg[cidMsg++] = IDS_REQFLAGS_SUBJECTUNMODIFIED;
	}
	if (CR_FLG_PUBLISHERROR & longValue)
	{
	    aidMsg[cidMsg++] = IDS_REQFLAGS_PUBLISHERROR;
	}
#if 1 // BUGBUG: temporary!!!
	if (CR_FLG_OLDRFCCMC & longValue)
	{
	    aidMsg[cidMsg++] = IDS_REQTYPE_CMC;
	}
#endif
    }
    else
    if (0 == lstrcmpi(wszPROPREQUESTDOT wszPROPREQUESTTYPE, pwszColumName))
    {
	switch (CR_IN_FORMATMASK & longValue)
	{
	    case CR_IN_FORMATANY: aidMsg[0] = IDS_REQTYPE_ANY;     break;
	    case CR_IN_PKCS10:    aidMsg[0] = IDS_REQTYPE_PKCS10;  break;
	    case CR_IN_KEYGEN:    aidMsg[0] = IDS_REQTYPE_KEYGEN;  break;
	    case CR_IN_PKCS7:     aidMsg[0] = IDS_REQTYPE_PKCS7;   break;
	    case CR_IN_CMC:       aidMsg[0] = IDS_REQTYPE_CMC;     break;
	    default:              aidMsg[0] = IDS_REQTYPE_UNKNOWN; break;
	}
	cidMsg = 1;
	if (CR_IN_CRLS & longValue)
	{
	    aidMsg[cidMsg++] = IDS_REQTYPE_CRLS;
	}
	if (CR_IN_FULLRESPONSE & longValue)
	{
	    aidMsg[cidMsg++] = IDS_REQTYPE_FULLRESPONSE;
	}
    }
    else
    if (0 == lstrcmpi(
		wszPROPREQUESTDOT wszPROPREQUESTSTATUSCODE,
		pwszColumName) ||
	0 == lstrcmpi(wszPROPCRLPUBLISHSTATUSCODE, pwszColumName))
    {
	pwszError = myGetErrorMessageText(longValue, FALSE);
	wprintf(L" %ws -- %ws", myHResultToString(awchr, longValue), pwszError);
	fDisplayNumeric = FALSE;
    }
    else
    if (0 == lstrcmpi(
		wszPROPREQUESTDOT wszPROPREQUESTREVOKEDREASON,
		pwszColumName))
    {
	aidMsg[0] = cuidCRLReason(longValue);
	cidMsg = 1;
    }
    else
    {
	fDisplayFlags = TRUE;
    }

    if (fDisplayNumeric)
    {
	wprintf(L" 0x%x", longValue);
	if (0 > longValue || 9 < longValue)
	{
	    wprintf(L" (%d)", longValue);
	}
    }
    if (0 != cidMsg)
    {
	WCHAR const *pwszComma = myLoadResourceString(IDS_SEPARATOR); // ", "

	wprintf(L" -- ");
	for (i = 0; i < cidMsg; i++)
	{
	    wprintf(
		L"%ws%ws",
		0 == i? L"" : pwszComma,
		myLoadResourceString(aidMsg[i]));
	}
    }
    if (0 == lstrcmpi(wszPROPEXTFLAGS, pwszColumName))
    {
	wprintf(L" -- %ws", cuwszFromExtFlags(longValue));
    }
    else if (0 == lstrcmpi(wszPROPCERTIFICATEISSUERNAMEID, pwszColumName) ||
	     0 == lstrcmpi(wszPROPCRLNAMEID, pwszColumName))
    {
	cuPrintPossibleObjectIdName(TEXT(szOID_CERTSRV_CA_VERSION));
	wprintf(
	    L" %u.%u",
	    CANAMEIDTOICERT(longValue),
	    CANAMEIDTOIKEY(longValue));
    }
    wprintf(wszNewLine);
    if (fDisplayFlags)
    {
	cuRegPrintDwordValue(FALSE, pwszColumName, pwszColumName, longValue);
    }
    if (NULL != pwszError)
    {
	LocalFree(const_cast<WCHAR *>(pwszError));
    }
}


HRESULT
GetBinaryColumnFormat(
    IN WCHAR const *pwszColumnName,
    OUT LONG *pFormat)
{
    LONG Format = CV_OUT_BINARY;

    if (0 == lstrcmpi(
		wszPROPREQUESTDOT wszPROPREQUESTRAWREQUEST,
		pwszColumnName))
    {
	Format = CV_OUT_BASE64REQUESTHEADER;
    }
    else
    if (0 == lstrcmpi(wszPROPRAWCERTIFICATE, pwszColumnName) ||
	0 == lstrcmpi(
		wszPROPREQUESTDOT wszPROPREQUESTRAWOLDCERTIFICATE,
		pwszColumnName) ||
	0 == lstrcmpi(wszPROPCERTIFICATERAWSMIMECAPABILITIES, pwszColumnName))
    {
	Format = CV_OUT_BASE64HEADER;
    }
    else
    if (0 == lstrcmpi(wszPROPCRLRAWCRL, pwszColumnName))
    {
	Format = CV_OUT_BASE64X509CRLHEADER;
    }
    else
    if (0 == lstrcmpi(wszPROPCERTIFICATERAWPUBLICKEY, pwszColumnName))
    {
	Format = CV_OUT_HEXADDR;
    }
    else
    {
	Format = CV_OUT_HEXASCIIADDR;
    }
    *pFormat = Format;
    return(S_OK);
}


VOID
DumpBinaryValue(
    IN WCHAR const *pwszColName,
    OPTIONAL IN WCHAR const *pwszObjId,
    IN LONG Format,
    IN BYTE const *pb,
    IN DWORD cb,
    OPTIONAL IN WCHAR const *pwszStringValue)
{
    wprintf(wszNewLine);
    if (NULL == pwszObjId ||
	0 != lstrcmpi(wszPROPEXTRAWVALUE, pwszColName) ||
	!cuDumpFormattedExtension(pwszObjId, pb, cb) ||
	g_fVerbose)
    {
	if (NULL != pwszStringValue)
	{
	    cuPrintCRLFString(NULL, pwszStringValue);
	    wprintf(wszNewLine);
	}
	else
	{
	    DumpHex(
		DH_NOADDRESS |
		(CV_OUT_HEX == Format? DH_NOASCIIHEX : 0),
		pb,
		cb);
	}
    }
    if (g_fVerbose &&
	(CV_OUT_BASE64HEADER == Format ||
	 CV_OUT_BASE64REQUESTHEADER == Format ||
	 CV_OUT_BASE64X509CRLHEADER == Format))
    {
	BOOL fVerboseOld = g_fVerbose;

	if (g_fVerbose)
	{
	    g_fVerbose--;
	}
	cuDumpAsnBinary(pb, cb, MAXDWORD);
	g_fVerbose = fVerboseOld;
	wprintf(wszNewLine);
    }
}


BOOL
ShouldDisplay(
    IN WCHAR const *pwszName,
    IN BOOL fDisplay,
    IN WCHAR const * const *apwsz)
{
    if (!fDisplay)
    {
	WCHAR const * const *ppwsz;

	for (ppwsz = apwsz; NULL != *ppwsz; ppwsz++)
	{
	    if (0 == lstrcmpi(pwszName, *ppwsz))
	    {
		fDisplay = TRUE;
		break;
	    }
	}
    }
    return(fDisplay);
}

typedef struct _DBSTATS
{
    DWORD cTotal;
    DWORD cbTotal;
    DWORD cbMax;
} DBSTATS;


VOID
UpdateStats(
    IN OUT DBSTATS *pstats,
    IN DWORD cbProp)
{
    if (0 != cbProp)
    {
	pstats->cTotal++;
	pstats->cbTotal += cbProp;
	if (pstats->cbMax < cbProp)
	{
	    pstats->cbMax = cbProp;
	}
	//wprintf(L"c=%u cb=%x(%x)\n", pstats->cTotal, pstats->cbTotal, cbProp);
    }
}


VOID
CombineStats(
    IN OUT DBSTATS *pstats,
    IN DBSTATS const *pstats2)
{
    pstats->cTotal += pstats2->cTotal;
    pstats->cbTotal += pstats2->cbTotal;
    if (pstats->cbMax < pstats2->cbMax)
    {
	pstats->cbMax = pstats2->cbMax;
    }
}


VOID
DumpStats(
    IN DBSTATS const *pstats,
    IN DWORD idStats)
{
    wprintf(
	myLoadResourceString(IDS_VIEW_STATS), // "%u %ws, Total Size = %u, Max Size = %u, Ave Size = %u",
	pstats->cTotal,
	myLoadResourceString(idStats),
	pstats->cbTotal,
	pstats->cbMax,
	0 != pstats->cTotal? pstats->cbTotal / pstats->cTotal : 0);
    wprintf(wszNewLine);
}


VOID
DumpViewStats(
    IN DWORD cRowTotal,
    IN DBSTATS const *pstatsRowProperties,
    IN DBSTATS const *pstatsAttributes,
    IN DBSTATS const *pstatsExtensions)
{
    DBSTATS statsSum;

    wprintf(wszNewLine);
    wprintf(
	myLoadResourceString(IDS_VIEW_ROWS),	// "%u Rows"
	cRowTotal);
    wprintf(wszNewLine);

    DumpStats(pstatsRowProperties, IDS_VIEW_ROWPROPERTIES); // "Row Properties"
    DumpStats(pstatsAttributes, IDS_VIEW_ATTRIBUTES); // "Request Attributes"
    DumpStats(pstatsExtensions, IDS_VIEW_EXTENSIONS); // "Certificate Extensions"

    statsSum = *pstatsRowProperties;
    CombineStats(&statsSum, pstatsAttributes);
    CombineStats(&statsSum, pstatsExtensions);

    DumpStats(&statsSum, IDS_VIEW_TOTALFIELDS); // "Total Fields"
}


#define VDQ_NONE	0
#define VDQ_SCHEMA	1
#define VDQ_QUEUE	2
#define VDQ_LOG		3
#define VDQ_LOGFAIL	4
#define VDQ_REVOKED	5


HRESULT
verbViewDump(
    IN WCHAR const *pwszOption,
    IN WCHAR const *pwszTable,
    IN WCHAR const *pwszSkipCounts,
    IN WCHAR const *pwszField3,
    IN WCHAR const *pwszField4)
{
    HRESULT hr;
    BOOL fSchema = g_wszSchema == pwszOption;
    DWORD vdq = VDQ_NONE;
    LONG cvColDefault = 0;
    DISPATCHINTERFACE diView;
    DISPATCHINTERFACE diViewColumn;
    DISPATCHINTERFACE diViewRow;
    DISPATCHINTERFACE diViewAttribute;
    DISPATCHINTERFACE diViewExtension;
    BOOL fMustRelease = FALSE;
    BOOL fMustReleaseColumn = FALSE;
    BOOL fMustReleaseAttribute = FALSE;
    BOOL fMustReleaseExtension = FALSE;
    BOOL fMustReleaseRow = FALSE;
    LONG i;
    LONG cColFull;
    LONG cColOut;
    COLINFO *aColInfo = NULL;
    LONG iRow;
    LONG RowIndex;
    LONG iCol;
    LONG ColIndex;
    LONG iAttribute;
    LONG AttributeIndex;
    LONG iExtension;
    LONG ExtensionIndex;
    BSTR strName = NULL;
    BSTR strObjId = NULL;
    BSTR strValue = NULL;
    BSTR strValueBinary = NULL;
    WCHAR const *pwszExtensionFormat;
    WCHAR **apwszRestrictions = NULL;
    WCHAR **apwszColumns = NULL;
    WCHAR **apwszAttributes = NULL;
    WCHAR **apwszExtensions = NULL;
    WCHAR **ppwsz;
    BOOL fLastRow = FALSE;
    BOOL fAllColumns;
    BOOL fAllAttributes = FALSE;
    BOOL fAllExtensions = FALSE;
    BOOL fSkip;
    DWORD cbProp;
    DWORD cRowTotal = 0;
    DBSTATS statsRowProperties;
    DBSTATS statsAttributes;
    DBSTATS statsExtensions;
    DWORD cvrcTable = CVRC_TABLE_REQCERT;
    WCHAR const *pwszDefaultRestriction = NULL;

    if (NULL != pwszTable)
    {
	if (0 == lstrcmpi(g_wszSchema, pwszTable))
	{
	    fSchema = TRUE;
	}
	else
	if (0 == lstrcmpi(wszQUEUE, pwszTable))
	{
	    vdq = VDQ_QUEUE;
	    pwszDefaultRestriction = wszCOLONQUEUE;
	    cvColDefault = CV_COLUMN_QUEUE_DEFAULT;
	}
	else
	if (0 == lstrcmpi(wszLOG, pwszTable))
	{
	    vdq = VDQ_LOG;
	    pwszDefaultRestriction = wszCOLONLOG;
	    cvColDefault = CV_COLUMN_LOG_DEFAULT;
	}
	else
	if (0 == lstrcmpi(wszLOGFAIL, pwszTable))
	{
	    vdq = VDQ_LOGFAIL;
	    pwszDefaultRestriction = wszCOLONLOGFAIL;
	    cvColDefault = CV_COLUMN_LOG_DEFAULT;
	}
	else
	if (0 == lstrcmpi(wszREVOKED, pwszTable))
	{
	    vdq = VDQ_REVOKED;
	    pwszDefaultRestriction = wszCOLONREVOKED;
	    cvColDefault = CV_COLUMN_LOG_REVOKED_DEFAULT;
	}
	else
	if (0 == lstrcmpi(g_wszExt, pwszTable))
	{
	    cvrcTable = CVRC_TABLE_EXTENSIONS;
	    //cvColDefault = CV_COLUMN_EXTENSION_DEFAULT;
	}
	else
	if (0 == lstrcmpi(g_wszAttrib, pwszTable))
	{
	    cvrcTable = CVRC_TABLE_ATTRIBUTES;
	    //cvColDefault = CV_COLUMN_ATTRIBUTE_DEFAULT;
	}
	else
	if (0 == lstrcmpi(g_wszCRL, pwszTable))
	{
	    cvrcTable = CVRC_TABLE_CRL;
	    //cvColDefault = CV_COLUMN_CRL_DEFAULT;
	}
	else if (NULL == pwszSkipCounts && iswdigit(*pwszTable))
	{
	    pwszSkipCounts = pwszTable;
	}
	else
	{
	    hr = E_INVALIDARG;
	    _JumpError(hr, error, "bad view/table name");
	}
    }

    if (NULL != pwszSkipCounts)
    {
	hr = ParseSkipCounts(pwszSkipCounts);
	_JumpIfError(hr, error, "ParseSkipCounts");
    }

    hr = View_Init(g_DispatchFlags, &diView);
    _JumpIfError(hr, error, "View_Init");

    fMustRelease = TRUE;

    hr = View_OpenConnection(&diView, g_pwszConfig);
    _JumpIfError(hr, error, "View_OpenConnection");

    if (CVRC_TABLE_REQCERT != cvrcTable)
    {
	hr = View2_SetTable(&diView, cvrcTable);
	_JumpIfError(hr, error, "View2_SetTable");
    }

    if (NULL != g_pwszRestrict)
    {
	hr = ParseViewRestrictions(g_pwszRestrict, &apwszRestrictions);
	_JumpIfError(hr, error, "ParseViewRestrictions");

	for (ppwsz = apwszRestrictions; NULL != *ppwsz; ppwsz++)
	{
	    BOOL f;

	    hr = SetViewRestriction(&diView, *ppwsz, &f);
	    _JumpIfErrorStr(hr, error, "SetViewRestriction", *ppwsz);

	    if (f)
	    {
		fLastRow = TRUE;
	    }
	}
    }
    else
    if (NULL != pwszDefaultRestriction)
    {
	hr = SetViewRestriction(&diView, pwszDefaultRestriction, &fLastRow);
	_JumpIfError(hr, error, "SetViewRestriction");
    }

    // If not a special default view, and no output columns were specified
    // for the requests+certs table, include all attributes and extensions.

    if (NULL == pwszDefaultRestriction &&
	NULL == g_pwszOut &&
	CVRC_TABLE_REQCERT == cvrcTable)
    {
	fAllAttributes = TRUE;
	fAllExtensions = TRUE;
    }

    hr = View_GetColumnCount(&diView, CVRC_COLUMN_SCHEMA, &cColFull);
    _JumpIfError(hr, error, "View_GetColumnCount");

    if (NULL != g_pwszOut)
    {
	hr = ParseViewColumns(
			g_pwszOut,
			NULL,
			NULL,
			&apwszColumns,
			&fAllColumns);
	_JumpIfError(hr, error, "ParseViewColumns");

	hr = ParseViewColumns(
			g_pwszOut,
			g_wszAttrib,
			g_apwszAllowedPrefixes,
			&apwszAttributes,
			&fAllAttributes);
	_JumpIfError(hr, error, "ParseViewColumns");

	hr = ParseViewColumns(
			g_pwszOut,
			g_wszExt,
			NULL,
			&apwszExtensions,
			&fAllExtensions);
	_JumpIfError(hr, error, "ParseViewColumns");

	if (NULL == apwszColumns)
	{
	    if (!g_fReverse)
	    {
		hr = View_SetResultColumnCount(&diView, 0);
		_JumpIfError(hr, error, "View_SetResultColumnCount");
	    }
	}
	else
	{
	    for (ppwsz = apwszColumns; NULL != *ppwsz; ppwsz++)
		;

	    hr = View_SetResultColumnCount(
			&diView,
			SAFE_SUBTRACT_POINTERS(ppwsz, apwszColumns));
	    _JumpIfError(hr, error, "View_SetResultColumnCount");

	    for (ppwsz = apwszColumns; NULL != *ppwsz; ppwsz++)
	    {
		hr = View_GetColumnIndex(
				    &diView,
				    CVRC_COLUMN_SCHEMA,
				    *ppwsz,
				    &ColIndex);
		_JumpIfErrorStr(hr, error, "View_GetColumnIndex", *ppwsz);

		hr = View_SetResultColumn(&diView, ColIndex);
		_JumpIfError(hr, error, "View_SetResultColumn");
	    }
	}
    }
    else if (NULL == pwszDefaultRestriction)
    {
	if (g_fReverse)
	{
	    hr = View_SetResultColumnCount(&diView, cColFull + 1);
	    _JumpIfError(hr, error, "View_SetResultColumnCount");

	    hr = View_SetResultColumn(&diView, 0);
	    _JumpIfError(hr, error, "View_SetResultColumn(0)");

	    for (i = cColFull; i > 0; i--)
	    {
		hr = View_SetResultColumn(&diView, i - 1);
		_JumpIfError(hr, error, "View_SetResultColumn");
	    }
	}
	else
	{
	    hr = View_SetResultColumnCount(&diView, cColFull);
	    _JumpIfError(hr, error, "View_SetResultColumnCount");

	    for (i = 0; i < cColFull; i++)
	    {
		hr = View_SetResultColumn(&diView, i);
		_JumpIfError(hr, error, "View_SetResultColumn");
	    }
	}
    }
    else
    {
	// Use the default set of columns for the specified special view.
	
	CSASSERT(0 > cvColDefault);

	hr = View_SetResultColumnCount(&diView, cvColDefault);
	_JumpIfError(hr, error, "View_SetResultColumnCount");
    }

    hr = View_OpenView(&diView, &diViewRow);
    _JumpIfError(hr, error, "View_OpenView");
    fMustReleaseRow = TRUE;

    hr = View_GetColumnCount(&diView, CVRC_COLUMN_RESULT, &cColOut);
    _JumpIfError(hr, error, "View_GetColumnCount");

    aColInfo = (COLINFO *) LocalAlloc(
				LMEM_FIXED | LMEM_ZEROINIT,
				cColOut * sizeof(aColInfo[0]));
    if (NULL == aColInfo)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "no memory for column info array");
    }

    if (fSchema)
    {
	hr = DisplaySchema(&diView, cColFull, NULL, FALSE);
	_JumpIfError(hr, error, "DisplaySchema");

	goto error;
    }

    if (0 != cColOut)
    {
	hr = DisplaySchema(&diView, cColOut, aColInfo, TRUE);
	_JumpIfError(hr, error, "DisplaySchema");
    }

    ZeroMemory(&statsRowProperties, sizeof(statsRowProperties));
    ZeroMemory(&statsAttributes, sizeof(statsAttributes));
    ZeroMemory(&statsExtensions, sizeof(statsExtensions));

    for (iRow = 1; ; iRow++)
    {
	BOOL fRowPrinted;
	BOOL fHeaderPrinted;
	BOOL fExtraNewLine;
	LONG cskip;

	if (NULL != strObjId)
	{
	    SysFreeString(strObjId);
	    strObjId = NULL;
	}
	cskip = GetSkip(TRUE);
	switch (cskip)
	{
	    case 0:
		break;

	    case 101:
		hr = ViewRow_Reset(&diViewRow);
		_JumpIfError(hr, error, "ViewRow_Reset");

		iRow = 1;
		break;

	    case 102:
		{
		    DISPATCHINTERFACE diViewRowClone;

		    hr = ViewRow_Clone(&diViewRow, &diViewRowClone);
		    _JumpIfError(hr, error, "ViewRow_Clone");

		    ViewRow_Release(&diViewRow);
		    diViewRow = diViewRowClone;	// structure assignment
		    goto done;
		}

	    case 103:
		goto done;

	    default:
		hr = ViewRow_Skip(&diViewRow, cskip);
		_JumpIfError(hr, error, "ViewRow_Skip");

		iRow += cskip;
	}

	hr = ViewRow_Next(&diViewRow, &RowIndex);
	if (S_FALSE == hr || (S_OK == hr && -1 == RowIndex))
	{
	    LONG MaxIndex;

	    hr = ViewRow_GetMaxIndex(&diViewRow, &MaxIndex);
	    _JumpIfError(hr, error, "ViewRow_GetMaxIndex");

	    wprintf(
		L"\n%ws: %u\n",
		myLoadResourceString(IDS_MAXINDEX),	// "Maximum Row Index"
		MaxIndex);

	    if (101 == GetSkip(FALSE))
	    {
		continue;
	    }
	    break;
	}
	_JumpIfError(hr, error, "ViewRow_Next");
	CSASSERT(RowIndex == iRow);

	cRowTotal++;
	fRowPrinted = FALSE;
	fExtraNewLine = FALSE;

	if (fMustReleaseColumn)
	{
	    ViewColumn_Release(&diViewColumn);
	    fMustReleaseColumn = FALSE;
	}

	hr = ViewRow_EnumCertViewColumn(&diViewRow, &diViewColumn);
	_JumpIfError(hr, error, "ViewRow_EnumCertViewColumn");

	fMustReleaseColumn = TRUE;

	for (iCol = 0; ; iCol++)
	{
	    LONG Format;
	    LONG longValue;
	    DATE dateValue;
	    VOID *pretval;

	    if (NULL != strValue)
	    {
		SysFreeString(strValue);
		strValue = NULL;
	    }
	    if (NULL != strValueBinary)
	    {
		SysFreeString(strValueBinary);
		strValueBinary = NULL;
	    }
	    hr = ViewColumn_Next(&diViewColumn, &ColIndex);
	    if (S_FALSE == hr || (S_OK == hr && -1 == ColIndex))
	    {
		break;
	    }
	    _JumpIfError(hr, error, "ViewColumn_Next");
	    CSASSERT(ColIndex == iCol);

	    hr = ViewColumn_GetType(&diViewColumn, &i);
	    _JumpIfError(hr, error, "GetType");

	    CSASSERT(i == aColInfo[iCol].type);

	    PrintRowIndex(iRow, &fRowPrinted);
	    fExtraNewLine = TRUE;

	    wprintf(L"  %ws:", aColInfo[iCol].strColDisplay);

	    Format = CV_OUT_BINARY;
	    switch (aColInfo[iCol].type)
	    {
		case PROPTYPE_LONG:
		    pretval = &longValue;
		    break;

		case PROPTYPE_DATE:
		    pretval = &dateValue;
		    break;

		case PROPTYPE_STRING:
		    pretval = &strValue;
		    break;

		case PROPTYPE_BINARY:
		    pretval = &strValue;
		    hr = GetBinaryColumnFormat(aColInfo[iCol].strCol, &Format);
		    _JumpIfError(hr, error, "GetBinaryColumnFormat");

		    break;

		default:
		    hr = E_FAIL;
		    _JumpError(hr, error, "bad proptype");
	    }
	    hr = ViewColumn_GetValue(
				&diViewColumn,
				Format,
				aColInfo[iCol].type,
				pretval);
	    if (CERTSRV_E_PROPERTY_EMPTY == hr)
	    {
		wprintf(L" ");
		wprintf(myLoadResourceString(IDS_PROP_EMPTY)); // "EMPTY"
		wprintf(wszNewLine);
	    }
	    else
	    {
		_JumpIfError(hr, error, "ViewColumn_GetValue");

		cbProp = 0;
		switch (aColInfo[iCol].type)
		{
		    case PROPTYPE_LONG:
			DumpLongValue(longValue, aColInfo[iCol].strCol);
			cbProp = sizeof(LONG);
			break;

		    case PROPTYPE_DATE:
			cuDumpDate(&dateValue);
			cbProp = sizeof(DATE);
			break;

		    case PROPTYPE_BINARY:
			if (CV_OUT_BINARY != Format)
			{
			    hr = ViewColumn_GetValue(
						&diViewColumn,
						CV_OUT_BINARY,
						PROPTYPE_BINARY,
						&strValueBinary);
			    _JumpIfError(hr, error, "ViewColumn_GetValue");
			}
			else
			{
			    strValueBinary = strValue;
			    strValue = NULL;
			}
			cbProp = SysStringByteLen(strValueBinary);
			DumpBinaryValue(
				    aColInfo[iCol].strCol,
				    strObjId,
				    Format,
				    (BYTE *) strValueBinary,
				    cbProp,
				    strValue);
			break;

		    case PROPTYPE_STRING:
			wprintf(L" \"");
			cuPrintCRLFString(NULL, strValue);
			wprintf(L"\"");
			cuPrintPossibleObjectIdName(strValue);
			wprintf(wszNewLine);
			if (g_fVerbose)
			{
			    DumpHex(
				0,
				(BYTE *) strValue,
				SysStringByteLen(strValue));
			    wprintf(wszNewLine);
			}
			cbProp = wcslen(strValue) * sizeof(WCHAR);
			if (0 == lstrcmpi(
				    wszPROPEXTNAME,
				    aColInfo[iCol].strCol))
			{
			    if (NULL != strObjId)
			    {
				SysFreeString(strObjId);
			    }
			    strObjId = SysAllocString(strValue);
			}
			break;
		}
		UpdateStats(&statsRowProperties, cbProp);
	    }
	}

	fSkip = TRUE;
	if (fAllAttributes || NULL != apwszAttributes)
	{
	    // Enumerate Request Attributes

	    hr = ViewRow_EnumCertViewAttribute(&diViewRow, 0, &diViewAttribute);
	    if (CERTSRV_E_PROPERTY_EMPTY == hr)
	    {
		_PrintError2(hr, "ViewRow_EnumCertViewAttribute", hr);
	    }
	    else
	    {
		_JumpIfError(hr, error, "ViewRow_EnumCertViewAttribute");

		fSkip = FALSE;
		fMustReleaseAttribute = TRUE;
	    }
	}

	if (!fSkip)
	{
	    fHeaderPrinted = FALSE;

	    for (iAttribute = 0; ; iAttribute++)
	    {
		hr = ViewAttribute_Next(&diViewAttribute, &AttributeIndex);
		if (S_FALSE == hr || (S_OK == hr && -1 == AttributeIndex))
		{
		    break;
		}
		_JumpIfError(hr, error, "ViewAttribute_Next");
		CSASSERT(AttributeIndex == iAttribute);

		hr = ViewAttribute_GetName(&diViewAttribute, &strName);
		_JumpIfError(hr, error, "GetName");

		if (ShouldDisplay(strName, fAllAttributes, apwszAttributes))
		{
		    if (!fHeaderPrinted)
		    {
			PrintRowIndex(iRow, &fRowPrinted);
			if (fExtraNewLine)
			{
			    wprintf(wszNewLine);
			}
			wprintf(
			    L"  %ws\n",
			    myLoadResourceString(IDS_REQUEST_ATTRIBUTES)); // "Request Attributes:"
			fHeaderPrinted = TRUE;
			fExtraNewLine = TRUE;
		    }

		    if (NULL != strValue)
		    {
			SysFreeString(strValue);
			strValue = NULL;
		    }
		    hr = ViewAttribute_GetValue(&diViewAttribute, &strValue);
		    _JumpIfError(hr, error, "GetValue");

		    wprintf(L"    %ws: \"%ws\"\n", strName, strValue);

		    UpdateStats(
			    &statsAttributes,
			    (wcslen(strName) + wcslen(strValue)) *
				sizeof(WCHAR) +
				sizeof(LONG));	// for RequestId
		}
	    }
	    ViewAttribute_Release(&diViewAttribute);
	    fMustReleaseAttribute = FALSE;
	}

	fSkip = TRUE;
	if (fAllExtensions || NULL != apwszExtensions)
	{
	    // Enumerate Certificate Extensions

	    hr = ViewRow_EnumCertViewExtension(&diViewRow, 0, &diViewExtension);
	    if (CERTSRV_E_PROPERTY_EMPTY == hr)
	    {
		_PrintError2(hr, "ViewRow_EnumCertViewExtension", hr);
	    }
	    else
	    {
		_JumpIfError(hr, error, "ViewRow_EnumCertViewExtension");

		fSkip = FALSE;
		fMustReleaseExtension = TRUE;
	    }
	}

	if (!fSkip)
	{
	    fHeaderPrinted = FALSE;

	    pwszExtensionFormat = myLoadResourceString(IDS_FORMAT_EXTENSION); // "%ws: Flags = %x%ws, Length = %x"

	    for (iExtension = 0; ; iExtension++)
	    {
		LONG ExtFlags;

		hr = ViewExtension_Next(&diViewExtension, &ExtensionIndex);
		if (S_FALSE == hr || (S_OK == hr && -1 == ExtensionIndex))
		{
		    break;
		}
		_JumpIfError(hr, error, "ViewExtension_Next");
		CSASSERT(ExtensionIndex == iExtension);

		hr = ViewExtension_GetName(&diViewExtension, &strName);
		_JumpIfError(hr, error, "GetName");

		if (ShouldDisplay(strName, fAllExtensions, apwszExtensions))
		{
		    if (!fHeaderPrinted)
		    {
			PrintRowIndex(iRow, &fRowPrinted);
			if (fExtraNewLine)
			{
			    wprintf(wszNewLine);
			}
			wprintf(
			    L"  %ws\n",
			    myLoadResourceString(IDS_CERTIFICATE_EXTENSIONS)); // "Certificate Extensions:"
			fHeaderPrinted = TRUE;
		    }

		    hr = ViewExtension_GetFlags(&diViewExtension, &ExtFlags);
		    _JumpIfError(hr, error, "GetFlags");

		    if (NULL != strValue)
		    {
			SysFreeString(strValue);
			strValue = NULL;
		    }
		    hr = ViewExtension_GetValue(
					    &diViewExtension,
					    PROPTYPE_BINARY,
					    CV_OUT_BINARY,
					    &strValue);
		    _JumpIfError(hr, error, "GetValue");

		    wprintf(g_wszPad4);
		    wprintf(
			pwszExtensionFormat,
			strName,
			ExtFlags,
			cuwszFromExtFlags(ExtFlags),
			SysStringByteLen(strValue));
		    wprintf(wszNewLine);

		    if (!cuDumpFormattedExtension(
					strName,
					(BYTE const *) strValue,
					SysStringByteLen(strValue)) ||
			g_fVerbose)
		    {
			wprintf(wszNewLine);
			DumpHex(
			    DH_NOTABPREFIX | 4,
			    (BYTE const *) strValue,
			    SysStringByteLen(strValue));
		    }
		    wprintf(wszNewLine);

		    UpdateStats(
			    &statsExtensions,
			    wcslen(strName) * sizeof(WCHAR) +
				SysStringByteLen(strValue) +	// for ext
				sizeof(LONG) +		// for RequestId
				sizeof(ExtFlags));	// for ExtensionFlags
		}
	    }
	    ViewExtension_Release(&diViewExtension);
	    fMustReleaseExtension = FALSE;
	}
	if (fLastRow)
	{
	    break;
	}
    }

done:
    DumpViewStats(
	    cRowTotal,
	    &statsRowProperties,
	    &statsAttributes,
	    &statsExtensions);
    hr = S_OK;

error:
    if (NULL != aColInfo)
    {
	for (i = 0; i < cColOut; i++)
	{
	    if (NULL != aColInfo[i].strCol)
	    {
		SysFreeString(aColInfo[i].strCol);
	    }
	    if (NULL != aColInfo[i].strColDisplay)
	    {
		SysFreeString(aColInfo[i].strColDisplay);
	    }
	}
	LocalFree(aColInfo);
    }

    cuFreeStringArray(apwszRestrictions);
    cuFreeStringArray(apwszColumns);
    cuFreeStringArray(apwszAttributes);
    cuFreeStringArray(apwszExtensions);

    if (NULL != strObjId)
    {
	SysFreeString(strObjId);
    }
    if (NULL != strName)
    {
	SysFreeString(strName);
    }
    if (NULL != strValue)
    {
	SysFreeString(strValue);
    }
    if (NULL != strValueBinary)
    {
	SysFreeString(strValueBinary);
    }
    if (fMustReleaseAttribute)
    {
	ViewAttribute_Release(&diViewAttribute);
    }
    if (fMustReleaseExtension)
    {
	ViewExtension_Release(&diViewExtension);
    }
    if (fMustReleaseColumn)
    {
	ViewColumn_Release(&diViewColumn);
    }
    if (fMustReleaseRow)
    {
	ViewRow_Release(&diViewRow);
    }
    if (fMustRelease)
    {
	View_Release(&diView);
    }
    return(hr);
}


HRESULT
DBShutDown(
    IN ICertDB *pdb)
{
    HRESULT hr;

    CSASSERT(NULL != pdb);
    hr = pdb->ShutDown(0);
    pdb->Release();
    return(hr);
}


// Control-C handler to shut down DB

BOOL
cuDBAbortShutDown(
    IN DWORD dwCtrlType)
{
    HRESULT hr;
    ICertDB *pdb;

    EnterCriticalSection(&g_DBCriticalSection);
    pdb = g_pdb;
    g_pdb = NULL;
    if (NULL != pdb)
    {
	DBShutDown(pdb);
	SetConsoleCtrlHandler(cuDBAbortShutDown, FALSE);
    }
    LeaveCriticalSection(&g_DBCriticalSection);
    return(TRUE);
}


HRESULT
DBOpen(
    IN WCHAR const *pwszAuthority,
    IN BOOL fReadOnly,
    OUT ICertDB **ppdb)
{
    HRESULT hr = S_OK;
    DWORD cb;
    DWORD i;
    HKEY hkey = NULL;
    WCHAR awszDatabase[MAX_PATH];
    WCHAR awszLogDir[MAX_PATH];
    WCHAR awszSystemDir[MAX_PATH];
    WCHAR awszTempDir[MAX_PATH];
    DWORD Flags;

    WCHAR *pawszDirBuf[4] =
    {
	awszDatabase,
	awszLogDir,
	awszSystemDir,
	awszTempDir
    };

    WCHAR *pawszRegNames[4] =
    {
	wszREGDBDIRECTORY,
	wszREGDBLOGDIRECTORY,
	wszREGDBSYSDIRECTORY,
	wszREGDBTEMPDIRECTORY
    };

    // get info from registry

    hr = RegOpenKey(HKEY_LOCAL_MACHINE, wszREGKEYCONFIGPATH, &hkey);
    _JumpIfError(hr, error, "RegOpenKey(CAName)");

    for (i = 0; i < 4; i++)
    {
	cb = sizeof(WCHAR) * MAX_PATH;
	hr = RegQueryValueEx(
			hkey,
			pawszRegNames[i],
			NULL,
			NULL,
			(BYTE *) pawszDirBuf[i],
			&cb);
	_JumpIfError(hr, error, "RegQueryValueEx(DB*Dir)");
    }
    wcscat(awszDatabase, L"\\");
    wcscat(awszDatabase, pwszAuthority);
    wcscat(awszDatabase, wszDBFILENAMEEXT);

    wprintf(
	myLoadResourceString(IDS_FORMAT_OPENING_DB), // "Opening Database %ws"
	awszDatabase);
    wprintf(wszNewLine);

    hr = CoCreateInstance(
                       CLSID_CCertDB,
                       NULL,               // pUnkOuter
                       CLSCTX_INPROC_SERVER,
                       IID_ICertDB,
                       (VOID **) ppdb);
    _JumpIfError(hr, error, "CoCreateInstance(ICertDB)");

    Flags = 0;		// CDBOPEN_CREATEIFNEEDED?
    if (fReadOnly)
    {
	Flags |= CDBOPEN_READONLY;
    }
    else if (g_fForce)
    {
	Flags |= CDBOPEN_CREATEIFNEEDED;
    }
    hr = (*ppdb)->Open(
		    Flags,
		    2,			// cSession
		    L"certutil.exe",	// pwszEventSource
		    awszDatabase,	// pwszDBFile
		    awszLogDir,		// pwszLogDir
		    awszSystemDir,	// pwszSystemDir
		    awszTempDir);	// pwszTempDir
    _JumpIfError(hr, error, "ICertDB::Open");

error:
    if (S_OK != hr)
    {
	if (NULL != *ppdb)
	{
	    (*ppdb)->Release();
	    *ppdb = NULL;
	}
    }
    if (NULL != hkey)
    {
        RegCloseKey(hkey);
    }
    return(hr);
}


HRESULT
cuDBOpen(
    IN WCHAR const *pwszAuthority,
    IN BOOL fReadOnly,
    OUT ICertDB **ppdb)
{
    HRESULT hr;
    WCHAR *pwszSanitizedCA = NULL;

    hr = mySanitizeName(pwszAuthority, &pwszSanitizedCA);
    _JumpIfError(hr, error, "mySanitizeName");

    SetConsoleCtrlHandler(NULL, TRUE);		// ignore CTL-C during cuDBOpen
    hr = DBOpen(pwszSanitizedCA, fReadOnly, ppdb);
    if (S_OK != hr)
    {
	cuPrintError(IDS_DB_OPEN_FAILURE, hr);
	if (myJetHResult(JET_errFileAccessDenied) == hr)
	{
	    wprintf(myLoadResourceString(IDS_DB_ACCESS_STOP_SERVER));
	    wprintf(wszNewLine);
	}
	else
	{
	    wprintf(myLoadResourceString(IDS_DB_ACCESS_INSTALL_SERVER)); // "Ensure the server is correctly installed and retry."
	    wprintf(wszNewLine);
	}
	_JumpError(hr, error, "DBOpen");
    }
    g_pdb = *ppdb;
    SetConsoleCtrlHandler(cuDBAbortShutDown, TRUE);
    SetConsoleCtrlHandler(NULL, FALSE);		// allow CTL-C

error:
    if (NULL != pwszSanitizedCA)
    {
	LocalFree(pwszSanitizedCA);
    }
    return(hr);
}


CERTDBCOLUMN g_adcRequests[50];
DWORD g_cdcRequests;

CERTDBCOLUMN g_adcCertificates[50];
DWORD g_cdcCertificates;

HRESULT
DBLoadSchema(
    IN ICertDB *pdb)
{
    HRESULT hr;
    IEnumCERTDBCOLUMN *penum = NULL;
    CERTDBCOLUMN acol[2];
    DWORD ccol;
    DWORD i;
    CERTDBCOLUMN *pdc;
    CERTDBCOLUMN const *pdcEnd;
    CERTDBCOLUMN *pdcReq = g_adcRequests;
    CERTDBCOLUMN *pdcCert = g_adcCertificates;
    DWORD *pcdc;

    hr = pdb->EnumCertDBColumn(CVRC_TABLE_REQCERT, &penum);
    _JumpIfError(hr, error, "EnumCertDBColumn");

    while (TRUE)
    {
	hr = penum->Next(ARRAYSIZE(acol), acol, &ccol);
	if (S_FALSE != hr)
	{
	    _JumpIfError(hr, error, "Next");
	}
	for (i = 0; i < ccol; i++)
	{
	    if (0 == _wcsnicmp(
			    wszPROPREQUESTDOT,
			    acol[i].pwszName,
			    WSZARRAYSIZE(wszPROPREQUESTDOT)))
	    {
		pdc = pdcReq++;
		pcdc = &g_cdcRequests;
		pdcEnd = &g_adcRequests[ARRAYSIZE(g_adcRequests) - 1];
	    }
	    else
	    {
		pdc = pdcCert++;
		pcdc = &g_cdcCertificates;
		pdcEnd = &g_adcCertificates[ARRAYSIZE(g_adcCertificates) - 1];
	    }
	    if (pdc >= pdcEnd)
	    {
		wprintf(L"Property Name Table overflow\n");
		hr = HRESULT_FROM_WIN32(ERROR_BUFFER_OVERFLOW);
		_JumpError(hr, error, "Property Name Table overflow");
	    }
	    *pdc = acol[i];
	    (*pcdc)++;
	}
	if (S_FALSE == hr)
	{
	    break;
	}
    }
    hr = S_OK;

error:
    if (NULL != penum)
    {
	penum->Release();
    }
    return(hr);
}


HRESULT
DBLookupColumnInfo1(
    IN CERTDBCOLUMN const *pdc,
    IN DWORD ColIndex,
    OUT CERTDBCOLUMN const **ppdc)
{
    HRESULT hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);

    *ppdc = NULL;
    for ( ; NULL != pdc->pwszName; pdc++)
    {
	if (pdc->Index == ColIndex)
	{
	    *ppdc = pdc;
	    hr = S_OK;
	    break;
	}
    }

//error:
    return(hr);
}


HRESULT
DBLookupColumnInfo(
    IN DWORD ColIndex,
    OUT CERTDBCOLUMN const **ppdc,
    OUT DWORD *pdwTable)
{
    HRESULT hr;

    hr = DBLookupColumnInfo1(
		    g_adcRequests,
		    ColIndex,
		    ppdc);
    if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) != hr)
    {
	_JumpIfError(hr, error, "DBLookupColumnInfo1");

	*pdwTable = PROPTABLE_REQUEST;
    }
    else
    {
	hr = DBLookupColumnInfo1(
			g_adcCertificates,
			ColIndex,
			ppdc);
	*pdwTable = PROPTABLE_CERTIFICATE;
    }
    _JumpIfError(hr, error, "DBLookupColumnInfo1");

error:
    return(hr);
}


HRESULT
DBDumpColumn(
    IN CERTDBCOLUMN const *pdc)
{
    HRESULT hr;

    cuPrintSchemaEntry(
		    pdc->pwszName,
		    pdc->pwszDisplayName,
		    pdc->Type,
		    pdc->cbMax);
    hr = S_OK;

//error:
    return(hr);
}


HRESULT
DBDumpSchema1(
    IN CERTDBCOLUMN const *pdc)
{
    HRESULT hr;
    CERTDBCOLUMN const *pdcEnd;

    for ( ; NULL != pdc->pwszName; pdc++)
    {
	hr = DBDumpColumn(pdc);
	_JumpIfError(hr, error, "DBDumpColumn");
    }
    hr = S_OK;

error:
    return(hr);
}


HRESULT
DBDumpSchema(
    IN ICertDB *pdb,
    OPTIONAL IN DWORD const *pcol,
    IN DWORD ccol)
{
    HRESULT hr;
    DWORD acol[100];
    DWORD i;

    if (1 == ccol && NULL != pcol && 0 > (LONG) *pcol)
    {
	hr = pdb->GetDefaultColumnSet(*pcol, ARRAYSIZE(acol), acol, &ccol);
	_JumpIfError(hr, error, "GetDefaultColumnSet");

	if (ARRAYSIZE(acol) == ccol)
	{
	    hr = HRESULT_FROM_WIN32(ERROR_BUFFER_OVERFLOW);
	    _JumpError(hr, error, "GetDefaultColumnSet");
	}
	pcol = acol;
    }

    wprintf(myLoadResourceString(IDS_SCHEMA_COLON)); // "Schema:"
    wprintf(wszNewLine);
    wprintf(myLoadResourceString(IDS_SCHEMA_COLUMNHEADERS)); // "Name..Type..."
    wprintf(wszNewLine);
    wprintf(myLoadResourceString(IDS_SCHEMA_COLUMNUNDERLINE)); // "____...____"
    wprintf(wszNewLine);

    if (NULL != pcol)
    {
	for (i = 0; i < ccol; i++)
	{
	    CERTDBCOLUMN const *pdc;
	    DWORD dwTable;

	    hr = DBLookupColumnInfo(pcol[i], &pdc, &dwTable);
	    _JumpIfError(hr, error, "DBLookupColumnInfo");

	    hr = DBDumpColumn(pdc);
	    _JumpIfError(hr, error, "DBDumpColumn");
	}
    }
    else
    {
	hr = DBDumpSchema1(g_adcRequests);
	_JumpIfError(hr, error, "DBDumpSchema1");

	hr = DBDumpSchema1(g_adcCertificates);
	_JumpIfError(hr, error, "DBDumpSchema1");
    }
    hr = S_OK;

error:
    return(hr);
}


VOID
DBFreeSchema1(
    IN CERTDBCOLUMN const *pdc,
    IN DWORD cdc)
{
    CERTDBCOLUMN const *pdcEnd;

    for (pdcEnd = &pdc[cdc]; pdc < pdcEnd; pdc++)
    {
	if (NULL != pdc->pwszName)
	{
	    CoTaskMemFree(pdc->pwszName);
	}
	if (NULL != pdc->pwszDisplayName)
	{
	    CoTaskMemFree(pdc->pwszDisplayName);
	}
    }
}


VOID
DBFreeSchema()
{
    DBFreeSchema1(g_adcRequests, g_cdcRequests);
    DBFreeSchema1(g_adcCertificates, g_cdcCertificates);
}


HRESULT
DBGetColumnInfo1(
    IN CERTDBCOLUMN const *pdc,
    IN WCHAR const *pwszColName,
    OUT WCHAR const **ppwszColNameActual,
    OUT DWORD *pColIndex,
    OUT LONG *pColType)
{
    HRESULT hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);

    *ppwszColNameActual = NULL;
    for ( ; NULL != pdc->pwszName; pdc++)
    {
	if (0 == lstrcmpi(pwszColName, pdc->pwszName))
	{
	    *ppwszColNameActual = pdc->pwszName;
	}
	else
	if (NULL != pdc->pwszDisplayName &&
	    0 == lstrcmpi(pwszColName, pdc->pwszDisplayName))
	{
	    *ppwszColNameActual = pdc->pwszDisplayName;
	}
	else
	{
	    continue;
	}
	*pColIndex = pdc->Index;
	*pColType = pdc->Type;
	hr = S_OK;
	break;
    }

//error:
    return(hr);
}


HRESULT
DBGetColumnInfo(
    IN ICertDB *pdb,
    IN WCHAR const *pwszColName,
    OUT WCHAR const **ppwszColNameActual,
    OUT DWORD *pColIndex,
    OUT LONG *pColType)
{
    HRESULT hr;
    WCHAR *pwsz;
    WCHAR *pwszRequestColName = NULL;

    hr = DBGetColumnInfo1(
		    g_adcRequests,
		    pwszColName,
		    ppwszColNameActual,
		    pColIndex,
		    pColType);
    if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) != hr)
    {
	_JumpIfError(hr, error, "DBGetColumnInfo1");
    }
    else
    {
	DBGPRINT((DBG_SS_CERTUTILI, "DBGetColumnInfo1(req, %ws) = %x\n", pwszColName, hr));
	hr = DBGetColumnInfo1(
			g_adcCertificates,
			pwszColName,
			ppwszColNameActual,
			pColIndex,
			pColType);
	if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) != hr)
	{
	    _JumpIfError(hr, error, "DBGetColumnInfo1");
	}
	else
	{
	    DBGPRINT((DBG_SS_CERTUTILI, "DBGetColumnInfo1(cert, %ws) = %x\n", pwszColName, hr));
	    pwsz = wcschr(pwszColName, L'.');
	    if (NULL == pwsz)
	    {
		pwszRequestColName = (WCHAR *) LocalAlloc(
		    LMEM_FIXED,
		    (WSZARRAYSIZE(wszPROPREQUESTDOT) + wcslen(pwszColName) + 1) *
			sizeof(WCHAR));
		if (NULL == pwszRequestColName)
		{
		    hr = E_OUTOFMEMORY;
		    _JumpError(hr, error, "LocalAlloc");
		}
		wcscpy(pwszRequestColName, wszPROPREQUESTDOT);
		wcscat(pwszRequestColName, pwszColName);
		hr = DBGetColumnInfo1(
				g_adcRequests,
				pwszRequestColName,
				ppwszColNameActual,
				pColIndex,
				pColType);
		DBGPRINT((DBG_SS_CERTUTILI, "DBGetColumnInfo1(req, %ws) = %x\n", pwszRequestColName, hr));
	    }
	}
	_JumpIfError(hr, error, "DBGetColumnInfo1");
    }

error:
    if (NULL != pwszRequestColName)
    {
	LocalFree(pwszRequestColName);
    }
    return(hr);
}


HRESULT
cuDBPrintProperty(
    OPTIONAL IN ICertDBRow *prow,
    IN DWORD Type,
    IN WCHAR const *pwszColName,
    IN WCHAR const *pwszDisplayName,
    OPTIONAL IN BYTE const *pbValue,
    IN DWORD cbValue,
    OUT DWORD *pcbValue)
{
    HRESULT hr;
    DWORD cb = 0;
    BYTE ab[64*1024];
    LONG Format;
    WCHAR *pwszOut = NULL;

    EnterCriticalSection(&g_DBCriticalSection);
    *pcbValue = 0;
    if (cuDBIsShutDownInProgress())
    {
	hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);
	_JumpError(hr, error, "cuDBIsShutDownInProgress");
    }
    wprintf(L"  %ws:", pwszDisplayName);
    if (NULL == pbValue)
    {
	cb = sizeof(ab);
	hr = prow->GetProperty(pwszColName, Type, &cb, ab);
	if (S_OK != hr)
	{
	    wprintf(L" ");
	    if (CERTSRV_E_PROPERTY_EMPTY != hr)
	    {
		cuPrintError(IDS_FORMAT_ERROR, hr);	// "error = %ws"
		_JumpError(hr, error, "GetProperty");
	    }
	    wprintf(myLoadResourceString(IDS_PROP_EMPTY)); // "EMPTY"
	    wprintf(wszNewLine);
	    cb = 0;
	}
	else
	{
	    pbValue = ab;
	    cbValue = cb;
	}
    }
    if (NULL != pbValue)
    {
	switch (PROPTYPE_MASK & Type)
	{
	    case PROPTYPE_LONG:
		DumpLongValue(*(DWORD *) pbValue, pwszColName);
		break;

	    case PROPTYPE_DATE:
		hr = cuDumpFileTime(0, NULL, (FILETIME const *) pbValue);
		_JumpIfError(hr, error, "cuDumpFileTime");
		break;

	    case PROPTYPE_BINARY:
		hr = GetBinaryColumnFormat(pwszColName, &Format);
		_JumpIfError(hr, error, "GetBinaryColumnFormat");

		if (CV_OUT_BINARY != Format)
		{
		    CSASSERT(CV_OUT_BASE64HEADER == CRYPT_STRING_BASE64HEADER);
		    CSASSERT(CV_OUT_BASE64 == CRYPT_STRING_BASE64);
		    CSASSERT(
			CV_OUT_BASE64REQUESTHEADER == CRYPT_STRING_BASE64REQUESTHEADER);
		    CSASSERT(CV_OUT_HEX == CRYPT_STRING_HEX);
		    CSASSERT(CV_OUT_HEXASCII == CRYPT_STRING_HEXASCII);
		    CSASSERT(CV_OUT_HEXADDR == CRYPT_STRING_HEXADDR);
		    CSASSERT(CV_OUT_HEXASCIIADDR == CRYPT_STRING_HEXASCIIADDR);

		    hr = myCryptBinaryToString(
					pbValue,
					cbValue,
					Format,
					&pwszOut);
		    _JumpIfError(hr, error, "myCryptBinaryToString");
		}
		DumpBinaryValue(
			pwszColName,
			NULL, 		// pwszObjId
			Format,
			pbValue,
			cbValue,
			pwszOut);
		break;

	    case PROPTYPE_STRING:
		wprintf(L" \"");
		cuPrintCRLFString(NULL, (WCHAR const *) pbValue);
		wprintf(L"\"");
		cuPrintPossibleObjectIdName((WCHAR const *) pbValue);
		wprintf(wszNewLine);
		break;
	}
    }
    *pcbValue = cb;
    hr = S_OK;

error:
    LeaveCriticalSection(&g_DBCriticalSection);
    if (NULL != pwszOut)
    {
	LocalFree(pwszOut);
    }
    return(hr);
}


HRESULT
DBPrintRow(
    IN ICertDB *pdb,
    IN DWORD iRow,
    IN DWORD RowId,
    OPTIONAL IN CERTDBRESULTROW const *pResultRow,
    OPTIONAL IN DWORD const *acol,
    IN DWORD ccol,
    IN BOOL fAllColumns,
    IN OUT DBSTATS *pstatsRowProperties,
    OPTIONAL IN WCHAR const * const *apwszAttributes,
    IN BOOL fAllAttributes,
    IN OUT DBSTATS *pstatsAttributes,
    OPTIONAL IN WCHAR const * const *apwszExtensions,
    IN BOOL fAllExtensions,
    IN OUT DBSTATS *pstatsExtensions)
{
    HRESULT hr;
    ICertDBRow *prow = NULL;
    DWORD ReqId;
    CERTDBCOLUMN const *pdc;
    LONG cskip;
    IEnumCERTDBNAME *penum = NULL;
    ULONG celtFetched;
    CERTDBNAME cdbn;
    BYTE abValue[64+1024];
    DWORD dwTable;
    DWORD i;
    DWORD cb;

    BOOL fRowPrinted = FALSE;
    BOOL fExtraNewLine = FALSE;
    BOOL fHeaderPrinted;

    cdbn.pwszName = NULL;

    hr = pdb->OpenRow(
		PROPOPEN_READONLY | PROPTABLE_REQCERT,
		RowId,
		NULL,
		&prow);
    _JumpIfError2(hr, error, "OpenRow", CERTSRV_E_PROPERTY_EMPTY);

    prow->GetRowId(&ReqId);

    if (NULL != pResultRow)
    {
#if 0
	wprintf(
	    L"Row %u: ReqId=%u, ccol=%u, type=%x, index=%x, cb=%u, value=%u\n",
	    iRow,
	    pResultRow->rowid,
	    pResultRow->ccol,
	    pResultRow->acol[0].Type,
	    pResultRow->acol[0].Index,
	    pResultRow->acol[0].cbValue,
	    *(DWORD *) pResultRow->acol[0].pbValue);
#endif
	for (i = 0; i < pResultRow->ccol; i++)
	{
	    CERTDBRESULTCOLUMN *pcol = &pResultRow->acol[i];

	    hr = DBLookupColumnInfo(pcol->Index, &pdc, &dwTable);
	    _JumpIfError(hr, error, "DBLookupColumnInfo");

	    CSASSERT(pcol->Type == pdc->Type);

	    PrintRowIndex(iRow, &fRowPrinted);
	    fExtraNewLine = TRUE;

	    hr = cuDBPrintProperty(
			    prow,
			    dwTable | pcol->Type,
			    pdc->pwszName,
			    pdc->pwszDisplayName,
			    pcol->pbValue,
			    pcol->cbValue,
			    &cb);
	    _JumpIfError(hr, error, "cuDBPrintProperty");

	    UpdateStats(pstatsRowProperties, cb);
	}
    }
    else if (NULL != acol)
    {
	for (i = 0; i < ccol; i++)
	{
	    PrintRowIndex(iRow, &fRowPrinted);
	    fExtraNewLine = TRUE;

	    hr = DBLookupColumnInfo(acol[i], &pdc, &dwTable);
	    _JumpIfError(hr, error, "DBLookupColumnInfo");

	    hr = cuDBPrintProperty(
			    prow,
			    dwTable | pdc->Type,
			    pdc->pwszName,
			    pdc->pwszDisplayName,
			    NULL,	// pbValue
			    0,		// cbValue
			    &cb);
	    _JumpIfError(hr, error, "cuDBPrintProperty");

	    UpdateStats(pstatsRowProperties, cb);
	}
    }
    else if (fAllColumns)
    {
	PrintRowIndex(iRow, &fRowPrinted);
	fExtraNewLine = TRUE;

	for (pdc = g_adcRequests; NULL != pdc->pwszName; pdc++)
	{
	    hr = cuDBPrintProperty(
			    prow,
			    PROPTABLE_REQUEST | pdc->Type,
			    pdc->pwszName,
			    pdc->pwszDisplayName,
			    NULL,	// pbValue
			    0,		// cbValue
			    &cb);
	    _JumpIfError(hr, error, "cuDBPrintProperty");

	    UpdateStats(pstatsRowProperties, cb);
	}

	wprintf(wszNewLine);
	wprintf(L"  ");
	wprintf(myLoadResourceString(IDS_CERT_PROPERTIES)); // "Certificate Properties:"
	wprintf(wszNewLine);

	for (pdc = g_adcCertificates; NULL != pdc->pwszName; pdc++)
	{
	    hr = cuDBPrintProperty(
			    prow,
			    PROPTABLE_CERTIFICATE | pdc->Type,
			    pdc->pwszName,
			    pdc->pwszDisplayName,
			    NULL,	// pbValue
			    0,		// cbValue
			    &cb);
	    _JumpIfError(hr, error, "cuDBPrintProperty");

	    UpdateStats(pstatsRowProperties, cb);
	}
	wprintf(wszNewLine);
    }

    if (fAllAttributes || NULL != apwszAttributes)
    {
	fHeaderPrinted = FALSE;

	hr = prow->EnumCertDBName(CIE_TABLE_ATTRIBUTES, &penum);
	_JumpIfError(hr, error, "EnumCertDBName");

	while (TRUE)
	{
	    hr = penum->Next(1, &cdbn, &celtFetched);
	    if (S_FALSE == hr)
	    {
		break;
	    }
	    _JumpIfError(hr, error, "Next");

	    CSASSERT(1 == celtFetched);
	    CSASSERT(NULL != cdbn.pwszName);

	    if (ShouldDisplay(cdbn.pwszName, fAllAttributes, apwszAttributes))
	    {
		if (!fHeaderPrinted)
		{
		    PrintRowIndex(iRow, &fRowPrinted);
		    if (fExtraNewLine)
		    {
			wprintf(wszNewLine);
		    }
		    wprintf(
			L"  %ws\n",
			myLoadResourceString(IDS_REQUEST_ATTRIBUTES)); // "Request Attributes:"
		    fHeaderPrinted = TRUE;
		    fExtraNewLine = TRUE;
		}
		hr = cuDBPrintProperty(
				prow,
				PROPTABLE_ATTRIBUTE | PROPTYPE_STRING,
				cdbn.pwszName,
				cdbn.pwszName,
				NULL,		// pbValue
				0,		// cbValue
				&cb);		// returned cbValue
		_JumpIfError(hr, error, "cuDBPrintProperty");

		UpdateStats(
			pstatsAttributes,
			wcslen(cdbn.pwszName) * sizeof(WCHAR) +
			    cb +
			    sizeof(LONG));	// for RequestId
	    }
	    CoTaskMemFree(cdbn.pwszName);
	    cdbn.pwszName = NULL;
	}
	penum->Release();
	penum = NULL;
    }

    if (fAllExtensions || NULL != apwszExtensions)
    {
	fHeaderPrinted = FALSE;

	hr = prow->EnumCertDBName(CIE_TABLE_EXTENSIONS, &penum);
	_JumpIfError(hr, error, "EnumCertDBName");

	while (TRUE)
	{
	    DWORD ExtFlags;

	    hr = penum->Next(1, &cdbn, &celtFetched);
	    if (S_FALSE == hr)
	    {
		break;
	    }
	    _JumpIfError(hr, error, "Next");

	    CSASSERT(1 == celtFetched);
	    CSASSERT(NULL != cdbn.pwszName);

	    if (ShouldDisplay(cdbn.pwszName, fAllExtensions, apwszExtensions))
	    {
		if (!fHeaderPrinted)
		{
		    PrintRowIndex(iRow, &fRowPrinted);
		    if (fExtraNewLine)
		    {
			wprintf(wszNewLine);
		    }
		    wprintf(
			L"  %ws\n",
			myLoadResourceString(IDS_CERTIFICATE_EXTENSIONS)); // "Certificate Extensions:"
		    fHeaderPrinted = TRUE;
		}
		cb = sizeof(abValue);
		hr = prow->GetExtension(cdbn.pwszName, &ExtFlags, &cb, abValue);
		_JumpIfError(hr, error, "GetExtension");

		wprintf(g_wszPad4);
		wprintf(
		    myLoadResourceString(IDS_FORMAT_EXTENSION), // "%ws: Flags = %x%ws, Length = %x"
		    cdbn.pwszName,
		    ExtFlags,
		    cuwszFromExtFlags(ExtFlags),
		    cb);
		wprintf(wszNewLine);

		if (!cuDumpFormattedExtension(cdbn.pwszName, abValue, cb) ||
		    g_fVerbose)
		{
		    wprintf(wszNewLine);
		    DumpHex(DH_NOTABPREFIX | 4, abValue, cb);
		}
		wprintf(wszNewLine);

		UpdateStats(
			pstatsExtensions,
			wcslen(cdbn.pwszName) * sizeof(WCHAR) +
			    cb +		// for ext
			    sizeof(LONG) +	// for RequestId
			    sizeof(ExtFlags));	// for ExtensionFlags
	    }
	    CoTaskMemFree(cdbn.pwszName);
	    cdbn.pwszName = NULL;
	}
    }
    hr = S_OK;

error:
    if (NULL != cdbn.pwszName)
    {
	CoTaskMemFree(cdbn.pwszName);
    }
    if (NULL != penum)
    {
	penum->Release();
    }
    if (NULL != prow)
    {
	prow->Release();
    }
    return(hr);
}


WCHAR const *
wszSeekOperator(
    IN LONG SeekOperator)
{
    WCHAR const *pwsz;
    static WCHAR s_wszBuf[20];

    switch (CVR_SEEK_MASK & SeekOperator)
    {
	case CVR_SEEK_NONE: pwsz = L"None"; break;
	case CVR_SEEK_EQ:   pwsz = L"==";   break;
	case CVR_SEEK_LT:   pwsz = L"<";    break;
	case CVR_SEEK_LE:   pwsz = L"<=";   break;
	case CVR_SEEK_GE:   pwsz = L">=";   break;
	case CVR_SEEK_GT:   pwsz = L">";    break;
	default:
	    wsprintf(s_wszBuf, L"???=%x", SeekOperator);
	    pwsz = s_wszBuf;
	    break;
    }
    if (s_wszBuf != pwsz && (CVR_SEEK_NODELTA & SeekOperator))
    {
	wcscpy(s_wszBuf, pwsz);
	wcscat(s_wszBuf, L",NoDelta");
	pwsz = s_wszBuf;
    }

    return(pwsz);
}


WCHAR const *
wszSortOperator(
    IN LONG SortOrder)
{
    WCHAR const *pwsz;
    static WCHAR s_wszBuf[20];

    switch (SortOrder)
    {
	case CVR_SORT_NONE:    pwsz = L"None";    break;
	case CVR_SORT_ASCEND:  pwsz = L"Ascend";  break;
	case CVR_SORT_DESCEND: pwsz = L"Descend"; break;
	default:
	    wsprintf(s_wszBuf, L"???=%x", SortOrder);
	    pwsz = s_wszBuf;
	    break;
    }
    return(pwsz);
}


HRESULT
DBParseRestriction(
    IN ICertDB *pdb,
    IN WCHAR const *pwszRestriction,
    OUT CERTVIEWRESTRICTION *pcvr,
    OUT BOOL *pfLastRow)
{
    HRESULT hr;
    LONG ColType;
    WCHAR *pwszColName = NULL;
    WCHAR *pwszColValue = NULL;
    WCHAR const *pwszColNameActual;
    LONG lVal;
    DATE date;
    BYTE const *pb;

    *pfLastRow = FALSE;

    hr = ParseRestriction(
		    pwszRestriction,
		    (LONG *) &pcvr->ColumnIndex,
		    &pcvr->SeekOperator,
		    &pcvr->SortOrder,
		    &pwszColName,
		    &pwszColValue);
    _JumpIfErrorStr(hr, error, "ParseRestriction", pwszRestriction);

    // no value to parse if a special column...

    if (NULL == pwszColName)
    {
	CSASSERT(0 > (LONG) pcvr->ColumnIndex);
	pcvr->cbValue = 0;
    }
    else
    {
	hr = DBGetColumnInfo(
			pdb,
			pwszColName,
			&pwszColNameActual,
			&pcvr->ColumnIndex,
			&ColType);
	_JumpIfErrorStr(hr, error, "DBGetColumnInfo", pwszColName);

	hr = ParseSpecialColumnValue(
				pwszColValue,
				PROPTYPE_MASK & ColType,
				&pcvr->SeekOperator,
				&pcvr->SortOrder,
				pfLastRow);
	_JumpIfError(hr, error, "ParseSpecialColumnValue");

	switch (PROPTYPE_MASK & ColType)
	{
	    case PROPTYPE_LONG:
		lVal = 0;
		if (!*pfLastRow)
		{
		    hr = cuGetSignedLong(pwszColValue, &lVal);
		    _JumpIfError(hr, error, "bad numeric operand");
		}
		pb = (BYTE const *) &lVal;
		pcvr->cbValue = sizeof(lVal);
		break;

	    case PROPTYPE_DATE:
		date = 0;
		if (!*pfLastRow)
		{
		    hr = myWszLocalTimeToGMTDate(pwszColValue, &date);
		    _JumpIfError(hr, error, "invalid date format");
		}
		pb = (BYTE const *) &date;
		pcvr->cbValue = sizeof(date);
		cuDumpDate(&date);
		break;

	    case PROPTYPE_STRING:
	    {
		WCHAR const *pwsz = L"";

		if (!*pfLastRow)
		{
		    pwsz = pwszColValue;
		}
		pb = (BYTE const *) pwsz;
		pcvr->cbValue = (wcslen(pwsz) + 1) * sizeof(WCHAR);
		break;
	    }

	    case PROPTYPE_BINARY:
	    default:
		hr = E_INVALIDARG;
		_JumpError(hr, error, "not supported");
	}
    }

    pcvr->pbValue = (BYTE *) LocalAlloc(LMEM_FIXED, pcvr->cbValue);
    if (NULL == pcvr->pbValue)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }
    CopyMemory(pcvr->pbValue, pb, pcvr->cbValue);

    DBGPRINT((
	DBG_SS_CERTUTILI,
	"Restriction: Col=%ws Index=%x Seek='%ws' Sort=%ws cb=%x, pb=%x\n",
	pwszColNameActual,
	pcvr->ColumnIndex,
	wszSeekOperator(pcvr->SeekOperator),
	wszSortOperator(pcvr->SortOrder),
	pcvr->cbValue,
	pcvr->pbValue));
    DBGDUMPHEX((DBG_SS_CERTUTILI, 0, pcvr->pbValue, pcvr->cbValue));

error:
    if (NULL != pwszColName)
    {
	LocalFree(pwszColName);
    }
    if (NULL != pwszColValue)
    {
	LocalFree(pwszColValue);
    }
    return(hr);
}


HRESULT
verbDBDump(
    IN WCHAR const *pwszOption,
    IN WCHAR const *pwszRequestId,
    IN WCHAR const *pwszArg2,
    IN WCHAR const *pwszArg3,
    IN WCHAR const *pwszArg4)
{
    HRESULT hr;
    WCHAR const *pwsz;
    ICertDB *pdb = NULL;
    ICertDBRow *prow = NULL;
    IEnumCERTDBRESULTROW *penum = NULL;
    DWORD i;
    DWORD imin = 1;
    DWORD RequestId;
    LONG cskip;
    WCHAR **apwszRestrictions = NULL;
    WCHAR **apwszColumns = NULL;
    WCHAR **apwszAttributes = NULL;
    WCHAR **apwszExtensions = NULL;
    WCHAR **ppwsz;
    BOOL fLastRow = FALSE;
    BOOL fAllColumns;
    BOOL fAllAttributes;
    BOOL fAllExtensions;
    CERTVIEWRESTRICTION *acvr = NULL;
    DWORD ccvr;
    DWORD *acol = NULL;
    DWORD ccol;
    CERTDBRESULTROW arow[35];
    DWORD crow;
    BOOL fReleaseRows = FALSE;
    DWORD iRow;
    DBSTATS statsRowProperties;
    DBSTATS statsAttributes;
    DBSTATS statsExtensions;

    ZeroMemory(&statsRowProperties, sizeof(statsRowProperties));
    ZeroMemory(&statsAttributes, sizeof(statsAttributes));
    ZeroMemory(&statsExtensions, sizeof(statsExtensions));

    if (NULL != pwszRequestId)
    {
	if (L'+' == *pwszRequestId)
	{
	    hr = ParseSkipCounts(&pwszRequestId[1]);
	    _JumpIfError(hr, error, "ParseSkipCounts");
	}
	else
	{
	    hr = cuGetLong(pwszRequestId, (LONG *) &RequestId);
	    _JumpIfError(hr, error, "RequestId must be a number");

	    imin = RequestId;
	    fLastRow = TRUE;
	}
    }
    pwsz = wcschr(g_pwszConfig, L'\\');
    if (NULL != pwsz)
    {
	pwsz++;
    }
    else
    {
	pwsz = g_pwszConfig;
    }

    hr = cuDBOpen(pwsz, TRUE, &pdb);
    _JumpIfError(hr, error, "cuDBOpen");

    hr = DBLoadSchema(pdb);
    _JumpIfError(hr, error, "DBLoadSchema");

    if (1 < g_fVerbose)
    {
	hr = DBDumpSchema(pdb, NULL, 0);
	_JumpIfError(hr, error, "DBDumpSchema");
    }

    ccvr = 0;
    if (NULL != g_pwszRestrict)
    {
	hr = ParseViewRestrictions(g_pwszRestrict, &apwszRestrictions);
	_JumpIfError(hr, error, "ParseViewRestrictions");

	for (ppwsz = apwszRestrictions; NULL != *ppwsz; ppwsz++)
	    ;
	ccvr = (DWORD) (ppwsz - apwszRestrictions);
	acvr = (CERTVIEWRESTRICTION *) LocalAlloc(
					    LMEM_FIXED | LMEM_ZEROINIT,
					    ccvr * sizeof(acvr[0]));
	if (NULL == acvr)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "LocalAlloc");
	}

	for (i = 0; i < ccvr; i++)
	{
	    BOOL f;

	    hr = DBParseRestriction(pdb, apwszRestrictions[i], &acvr[i], &f);
	    _JumpIfErrorStr(
			hr,
			error,
			"DBParseRestriction",
			apwszRestrictions[i]);

	    if (f)
	    {
		fLastRow = TRUE;
	    }
	}
    }

    ccol = 0;
    fAllColumns = TRUE;
    fAllAttributes = TRUE;
    fAllExtensions = TRUE;
    if (NULL != g_pwszOut)
    {
	fAllAttributes = FALSE;
	fAllExtensions = FALSE;

	hr = ParseViewColumns(
			g_pwszOut,
			NULL,
			NULL,
			&apwszColumns,
			&fAllColumns);
	_JumpIfError(hr, error, "ParseViewColumns");

	if (NULL != apwszColumns)
	{
	    for (ppwsz = apwszColumns; NULL != *ppwsz; ppwsz++)
		;

	    ccol = (DWORD) (ppwsz - apwszColumns);
	}

	hr = ParseViewColumns(
			g_pwszOut,
			g_wszAttrib,
			g_apwszAllowedPrefixes,
			&apwszAttributes,
			&fAllAttributes);
	_JumpIfError(hr, error, "ParseViewColumns");

	hr = ParseViewColumns(
			g_pwszOut,
			g_wszExt,
			NULL,
			&apwszExtensions,
			&fAllExtensions);
	_JumpIfError(hr, error, "ParseViewColumns");
    }

    if (fAllColumns)
    {
	ccol = g_cdcRequests + g_cdcCertificates;
    }
    if (0 != ccol)
    {
	acol = (DWORD *) LocalAlloc(LMEM_FIXED, ccol * sizeof(acol[0]));
	if (NULL == acol)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "LocalAlloc");
	}

	if (fAllColumns)
	{
	    for (i = 0; i < ccol; i++)
	    {
		CERTDBCOLUMN const *pdc;

		pdc = (i < g_cdcRequests)?
			&g_adcRequests[i] :
			&g_adcCertificates[i - g_cdcRequests];
		acol[i] = pdc->Index;
	    }
	}
	else
	{
	    CSASSERT(NULL != apwszColumns);
	    for (i = 0; i < ccol; i++)
	    {
		WCHAR const *pwszColNameActual;
		LONG ColType;

		hr = DBGetColumnInfo(
				pdb,
				apwszColumns[i],
				&pwszColNameActual,
				&acol[i],
				&ColType);
		_JumpIfErrorStr(hr, error, "DBGetColumnInfo", apwszColumns[i]);
	    }
	}
    }

    hr = DBDumpSchema(pdb, acol, ccol);
    _JumpIfError(hr, error, "DBDumpSchema");

    if (NULL != g_pwszRestrict)
    {
	BOOL fNoMore;

	hr = pdb->OpenView(ccvr, acvr, ccol, acol, 0x0, &penum);
	_JumpIfError(hr, error, "OpenView");

	iRow = 1;
	fNoMore = FALSE;
	while (!fNoMore)
	{
	    hr = penum->Next((ULONG)(fLastRow? 1 : ARRAYSIZE(arow)), arow, &crow);
	    if (S_FALSE == hr)
	    {
		hr = S_OK;
		fNoMore = TRUE;
	    }
	    _JumpIfError(hr, error, "Next");

	    fReleaseRows = TRUE;

	    //wprintf(L"celtFetched = %u\n", crow);
	    for (i = 0; i < crow; i++, iRow++)
	    {
		hr = DBPrintRow(
			    pdb,
			    iRow,
			    arow[i].rowid,
			    &arow[i],
			    NULL,		// acol
			    0,			// ccol
			    FALSE,		// fAllColumns
			    &statsRowProperties,
			    apwszAttributes,
			    fAllAttributes,
			    &statsAttributes,
			    apwszExtensions,
			    fAllExtensions,
			    &statsExtensions);
		_JumpIfError(hr, error, "DBPrintRow");
	    }

	    if (fNoMore)
	    {
		CSASSERT(ARRAYSIZE(arow) > crow);
		CSASSERT(i == crow);
		CSASSERT(arow[i].rowid == ~arow[i].ccol);
		wprintf(
		    L"\n%ws: %u\n",
		    myLoadResourceString(IDS_MAXINDEX),	// "Maximum Row Index"
		    arow[i].rowid);
	    }

	    hr = penum->ReleaseResultRow(crow, arow);
	    _JumpIfError(hr, error, "ReleaseResultRow");

	    fReleaseRows = FALSE;

	    if (fLastRow)
	    {
		break;
	    }
	}
    }
    else
    {
	DWORD imax;

	iRow = 1;
	imax = fLastRow? imin + 1 : MAXDWORD;
	for (i = imin; i < imax; i++, iRow++)
	{
	    hr = DBPrintRow(
			pdb,
			iRow,
			i,		// RowId
			NULL,		// pResultRow
			acol,
			ccol,
			fAllColumns,
			&statsRowProperties,
			apwszAttributes,
			fAllAttributes,
			&statsAttributes,
			apwszExtensions,
			fAllExtensions,
			&statsExtensions);
	    if (CERTSRV_E_PROPERTY_EMPTY == hr)	// RowId doesn't exist
	    {
		hr = S_OK;
		break;
	    }
	    _JumpIfError(hr, error, "DBPrintRow");
	}
    }
    DumpViewStats(
	    iRow - 1,
	    &statsRowProperties,
	    &statsAttributes,
	    &statsExtensions);

error:
    cuFreeStringArray(apwszRestrictions);
    cuFreeStringArray(apwszColumns);
    cuFreeStringArray(apwszAttributes);
    cuFreeStringArray(apwszExtensions);

    if (NULL != acvr)
    {
	for (i = 0; i < ccvr; i++)
	{
	    if (NULL != acvr[i].pbValue)
	    {
		LocalFree(acvr[i].pbValue);
	    }
	}
	LocalFree(acvr);
    }
    if (NULL != acol)
    {
	LocalFree(acol);
    }
    DBFreeSchema();

    if (fReleaseRows)
    {
	hr = penum->ReleaseResultRow(crow, arow);
	_JumpIfError(hr, error, "ReleaseResultRow");
    }

    // Take critical section to make sure we wait for CTL-C DB shutdown.

    EnterCriticalSection(&g_DBCriticalSection);
    if (cuDBIsShutDownInProgress())
    {
	if (myJetHResult(JET_errTermInProgress) == hr)
	{
	    hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);
	}
    }
    else
    {
	if (NULL != penum)
	{	
	    penum->Release();
	}
	if (NULL != prow)
	{	
	    prow->Release();
	}
    }
    LeaveCriticalSection(&g_DBCriticalSection);
    cuDBAbortShutDown(0);
    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\tools\tcertcli\auto\autoenrl.c ===
/****************************** Module Header ******************************\
* Module Name: autoenrl.c
*
* Copyright (c) 1997, Microsoft Corporation
*
* Module for Public Key certificate auto enrollment
*
* History:
* 11-21-97 jeffspel       Created.
* 01-30-98 jeffspel       changed to include machine auto enrollment
\***************************************************************************/
#include "precomp.h"
#pragma hdrstop
#include "tchar.h"



#define AE_DEFAULT_REFRESH_RATE 8 // 8 hour default autoenrollment rate

#define SYSTEM_POLICIES_KEY          TEXT("Software\\Policies\\Microsoft\\Windows\\System")

#define MAX_TEMPLATE_NAME_VALUE_SIZE             64 // sizeof (CERT_NAME_VALUE) + wcslen(wszCERTTYPE_DC)
#define MAX_DN_SIZE 256

#define MACHINE_AUTOENROLL_INITIAL_DELAY         10 // seconds
#define USER_AUTOENROLL_INITIAL_DELAY         120 // seconds

LPWSTR  g_wszEmptyExtension=L"Empty Extension";

#if DBG

DWORD g_AutoenrollDebugLevel = AE_ERROR ; //| AE_WARNING | AE_INFO | AE_TRACE;

#endif



PISECURITY_DESCRIPTOR AEMakeGenericSecurityDesc();

//
// Structure to hold information passed to Auto Enrollment threads
//

HANDLE g_hUserMutex = 0;
HANDLE g_hMachineMutex = 0;

#define DS_ATTR_COMMON_NAME     TEXT("cn")
#define DS_ATTR_DNS_NAME        TEXT("dNSHostName")
#define DS_ATTR_EMAIL_ADDR      TEXT("mail")
#define DS_ATTR_OBJECT_GUID     TEXT("objectGUID")
#define DS_ATTR_UPN             TEXT("userPrincipalName")

static HINSTANCE            g_hInstSecur32 = NULL;
static HINSTANCE            g_hInstWldap32 = NULL;
static PFNLDAP_INIT         g_pfnldap_init = NULL;
static PFNLDAP_BIND_S       g_pfnldap_bind_s = NULL;
static PFNLDAP_SET_OPTION   g_pfnldap_set_option = NULL;
static PFNLDAP_SEARCH_EXT_S g_pfnldap_search_ext_s = NULL;
static PFNLDAP_FIRST_ENTRY  g_pfnldap_first_entry = NULL;
static PFNLDAP_EXPLODE_DN   g_pfnldap_explode_dn = NULL;
static PFNLDAP_GET_VALUES   g_pfnldap_get_values = NULL;
static PFNLDAP_VALUE_FREE   g_pfnldap_value_free = NULL;
static PFNLDAP_MSGFREE      g_pfnldap_msgfree = NULL;
static PFNLDAP_UNBIND       g_pfnldap_unbind = NULL;
static PFNLDAPGETLASTERROR  g_pfnLdapGetLastError = NULL;
static PFNLDAPMAPERRORTOWIN32 g_pfnLdapMapErrorToWin32 = NULL;
static PFNGETUSERNAMEEX     g_pfnGetUserNameEx = NULL;


#ifndef CERT_ENTERPRISE_SYSTEM_STORE_REGPATH
#define CERT_ENTERPRISE_SYSTEM_STORE_REGPATH L"Software\\Microsoft\\EnterpriseCertificates"
#endif


typedef struct _AUTO_ENROLL_THREAD_INFO_
{
    BOOL                fMachineEnrollment;
    HANDLE              hNotifyEvent;
    HANDLE              hTimer;
    HANDLE              hToken;
    HANDLE              hNotifyWait;
    HANDLE              hTimerWait;
} AUTO_ENROLL_THREAD_INFO, *PAUTO_ENROLL_THREAD_INFO;

//
// Structure to hold internal information needed perform Auto Enrollment
//

typedef struct _INTERNAL_CA_LIST_
{
    HCAINFO hCAInfo;
    LPWSTR  wszName;
    BYTE    CACertHash[20];
    LPWSTR  wszDNSName;
    LPWSTR  *awszCertificateTemplates;
} INTERNAL_CA_LIST, *PINTERNAL_CA_LIST;

typedef struct _INTERNAL_INFO_
{
    BOOL                fMachineEnrollment;
    HANDLE              hToken;
    HCERTSTORE          hRootStore;
    HCERTSTORE          hCAStore;
    HCERTSTORE          hMYStore;   
    LPTSTR             * awszldap_UPN;
    LPTSTR             wszConstructedUPN;
    LPTSTR             * awszEmail;
    LPTSTR              wszDN;
    CERT_NAME_BLOB      blobDN;

    // List of all ca's
    DWORD               ccaList;
    PINTERNAL_CA_LIST   acaList;

} INTERNAL_INFO, *PINTERNAL_INFO;


typedef struct _AE_INSTANCE_INFO_
{
    PCCTL_CONTEXT       pCTLContext;
    PINTERNAL_INFO      pInternalInfo;
    PCCERT_CONTEXT      pOldCert;
    BOOL                fRenewalOK;
    DWORD               dwRandomIndex;
    LPWSTR              pwszCertType;
    LPWSTR              pwszAEIdentifier;
    CERT_EXTENSIONS     *pCertTypeExtensions;
    DWORD               dwCertTypeFlags;
    LARGE_INTEGER        ftExpirationOffset;

} AE_INSTANCE_INFO, *PAE_INSTANCE_INFO;



// Key usage masks
typedef struct _KUMASK {
    DWORD dwMask;
    LPSTR pszAlg;
} KUMASK;


KUMASK g_aKUMasks[] =
{
    {~CERT_KEY_AGREEMENT_KEY_USAGE, szOID_RSA_RSA },
    {~CERT_KEY_ENCIPHERMENT_KEY_USAGE, szOID_OIWSEC_dsa },
    {~CERT_KEY_ENCIPHERMENT_KEY_USAGE, szOID_X957_DSA },
    {~CERT_KEY_ENCIPHERMENT_KEY_USAGE, szOID_ANSI_X942_DH },
    {~CERT_KEY_ENCIPHERMENT_KEY_USAGE, szOID_RSA_DH },
    {~CERT_KEY_AGREEMENT_KEY_USAGE, szOID_OIWSEC_rsaXchg },
    {~CERT_KEY_ENCIPHERMENT_KEY_USAGE, szOID_INFOSEC_mosaicKMandUpdSig }
};

DWORD g_cKUMasks = sizeof(g_aKUMasks)/sizeof(g_aKUMasks[0]);


#define DEFAULT_AUTO_ENROLL_PROV    "pautoenr.dll"

#define AUTOENROLL_EVENT_LOG_SUBKEY L"System\\CurrentControlSet\\Services\\EventLog\\System\\AutoEnroll"
#define SZ_AUTO_ENROLL              L"AutoEnroll"

HRESULT 
myGetConfigDN(
    IN  LDAP *pld,
    OUT LPWSTR *pwszConfigDn
    );

LPWSTR 
HelperExtensionToString(PCERT_EXTENSION Extension);

HRESULT
aeRobustLdapBind(
    OUT LDAP ** ppldap,
    IN BOOL fGC);

// 
// Time skew margin for fast CA's
//
#define FILETIME_TICKS_PER_SECOND  10000000

#define DEFAULT_AUTOENROLL_SKEW  60*60*1  // 1 hour

// 
// ERROR values to be logged as events when auto enrollment fails
//


//
// memory allocation and free routines
void *AEAlloc(
              IN DWORD cb
              )
{
    return LocalAlloc(LMEM_ZEROINIT, cb);
}

void AEFree(
            void *p
            )
{
    LocalFree(p);
}

HRESULT GetExceptionError(EXCEPTION_POINTERS const *pep)
{
    if((pep == NULL) || (pep->ExceptionRecord == NULL))
    {
        return E_UNEXPECTED;
    }

    return pep->ExceptionRecord->ExceptionCode;
}

//
// Name:    AELogTestResult
//
// Description: This function logs the result of a certificate 
// test into the AE_CERT_TEST_ARRAY
//
void AELogTestResult(PAE_CERT_TEST_ARRAY    *ppAEData,
                     DWORD                  idTest,
                     ...)
{
    va_list ArgList;
    va_start(ArgList, idTest);

    if((*ppAEData == NULL) ||
       ((*ppAEData)->cTests ==  (*ppAEData)->cMaxTests))
    {
        PAE_CERT_TEST_ARRAY pAENew = NULL;
        DWORD               cAENew = ((*ppAEData)?(*ppAEData)->cMaxTests:0) + 
                                     AE_CERT_TEST_SIZE_INCREMENT;
        // We need to grow the array

        pAENew = LocalAlloc(LMEM_FIXED, sizeof(AE_CERT_TEST_ARRAY) + 
                                        (cAENew - ANYSIZE_ARRAY)*sizeof(AE_CERT_TEST));
        if(pAENew == NULL)
        {
            return;
        }
        pAENew->dwVersion = AE_CERT_TEST_ARRAY_VERSION;
        pAENew->fRenewalOK = ((*ppAEData)?(*ppAEData)->fRenewalOK:FALSE);
        pAENew->cTests = ((*ppAEData)?(*ppAEData)->cTests:0);
        pAENew->cMaxTests = cAENew;
        if((*ppAEData) && (pAENew->cTests != 0))
        {
            CopyMemory(pAENew->Test, (*ppAEData)->Test, sizeof(AE_CERT_TEST)*pAENew->cTests);
        }

        if(*ppAEData)
        {
            AEFree(*ppAEData);
        }

        (*ppAEData) = pAENew;
    }

    (*ppAEData)->Test[(*ppAEData)->cTests].idTest = idTest;

    if(FormatMessage(
        FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_HMODULE,
        g_hInstance,
        idTest,
        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
        (PVOID)&(*ppAEData)->Test[(*ppAEData)->cTests].pwszReason,
        0,
        &ArgList))
    {

        (*ppAEData)->cTests++;
    }

}

void AEFreeTestResult(PAE_CERT_TEST_ARRAY    *ppAEData)
{
    DWORD iTest = 0;
    if((ppAEData == NULL) || (*ppAEData == NULL))
    {
        return;
    }

    for(iTest = 0; iTest < (*ppAEData)->cTests; iTest++)
    {
        if((*ppAEData)->Test[iTest].pwszReason)
        {
            LocalFree((*ppAEData)->Test[iTest].pwszReason);
        }
    }

    AEFree(*ppAEData);
    *ppAEData = NULL;
    
}

//
// Name:    LogAutoEnrollmentEvent
//
// Description: This function registers an event in the event log of the
//              local machine.
//
void LogAutoEnrollmentEvent(
                            IN DWORD  dwEventId,
                            IN HANDLE hToken,
                            ...
                            )
{
    HANDLE      hEventSource = 0;
    BYTE        FastBuffer[256];
    PTOKEN_USER ptgUser;
    DWORD       cbUser;
    BOOL        fAlloced = FALSE;
    PSID        pSID = NULL;

    WORD dwEventType = 0;

    LPWSTR      awszStrings[20];
    WORD        cStrings = 0;
    LPWSTR      wszString = NULL;


    va_list ArgList;
    va_start(ArgList, hToken);

    for(wszString = va_arg(ArgList, LPWSTR); wszString != NULL; wszString = va_arg(ArgList, LPWSTR))
    {
        awszStrings[cStrings++] = wszString;
        if(cStrings >= ARRAYSIZE(awszStrings))
        {
            break;
        }
    }

    va_end(ArgList);

    // event logging code
    hEventSource = RegisterEventSourceW(NULL, EVENTLOG_SOURCE);

    if(NULL == hEventSource)
        goto Ret;


    // check if the token is non zero is so then impersonating so get the SID
    if (hToken)
    {
        ptgUser = (PTOKEN_USER)FastBuffer; // try fast buffer first
        cbUser = 256;

        if (!GetTokenInformation(
                        hToken,    // identifies access token
                        TokenUser, // TokenUser info type
                        ptgUser,   // retrieved info buffer
                        cbUser,  // size of buffer passed-in
                        &cbUser  // required buffer size
                        ))
        {
            if(GetLastError() == ERROR_INSUFFICIENT_BUFFER)
            {
                //
                // try again with the specified buffer size
                //

                if (NULL != (ptgUser = (PTOKEN_USER)AEAlloc(cbUser)))
                {
                    fAlloced = TRUE;

                    // get the user info and assign the sid if able to
                    if (GetTokenInformation(
                                    hToken,    // identifies access token
                                    TokenUser, // TokenUser info type
                                    ptgUser,   // retrieved info buffer
                                    cbUser,  // size of buffer passed-in
                                    &cbUser  // required buffer size
                                    ))
                    {
                        pSID = ptgUser->User.Sid;
                    }
                }
            }

        }
        else
        {
            // assign the sid when fast buffer worked
            pSID = ptgUser->User.Sid;
        }
    }
    switch(dwEventId >> 30)
    {
    case 0:
        dwEventType = EVENTLOG_SUCCESS;
        break;
    case 1:
        dwEventType = EVENTLOG_INFORMATION_TYPE;
        break;
    case 2:
        dwEventType = EVENTLOG_WARNING_TYPE;
        break;
    case 3:
        dwEventType = EVENTLOG_ERROR_TYPE;
        break;
    }

    // UNDONE - probably want a string to go with the error code
    if (!ReportEventW(hEventSource, // handle of event source
                 dwEventType,  // event type
                 0,                    // event category
                 dwEventId,            // event ID
                 pSID,                 // current user's SID
                 cStrings,             // strings in lpszStrings
                 0,                    // no bytes of raw data
                 (LPCWSTR*)awszStrings,// array of error strings
                 NULL                  // no raw data
                 ))
    {
        goto Ret;
    }

Ret:

    if (hEventSource)
        (VOID) DeregisterEventSource(hEventSource);
    return;
}

//
// Name:    LogAutoEnrollmentError
//
// Description: This function registers an event in the event log of the
//              local machine.
//

void LogAutoEnrollmentError(
                            IN HRESULT hr,
                            IN DWORD   dwEventId,
                            IN BOOL fMachineEnrollment,
                            IN HANDLE hToken,
                            IN LPWSTR wszCertType,
                            IN LPWSTR wszCA
                            )
{
    HKEY        hRegKey = 0;
	WCHAR       szMsg[512];
    HANDLE      hEventSource = 0;
    LPWSTR      lpszStrings[4];
    WORD        cStrings = 0;

    BYTE        FastBuffer[256];
    PTOKEN_USER ptgUser;
    DWORD       cbUser;
    BOOL        fAlloced = FALSE;
    PSID        pSID = NULL;

    WORD dwEventType = 0;


    // event logging code
    hEventSource = RegisterEventSourceW(NULL, EVENTLOG_SOURCE);

    if(NULL == hEventSource)
        goto Ret;

    wsprintfW(szMsg, L"0x%lx", hr);        
    lpszStrings[cStrings++] = szMsg;


    FormatMessage(
            FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
            NULL,
            hr,
            MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
            (WCHAR *) &lpszStrings[cStrings++],
            0,
            NULL);
    
    if(wszCertType)
    {
        lpszStrings[cStrings++] = wszCertType;
    }

    if(wszCA)
    {
        lpszStrings[cStrings++] = wszCA;
    }   


    // check if the token is non zero is so then impersonating so get the SID
    if (hToken)
    {
        ptgUser = (PTOKEN_USER)FastBuffer; // try fast buffer first
        cbUser = 256;

        if (!GetTokenInformation(
                        hToken,    // identifies access token
                        TokenUser, // TokenUser info type
                        ptgUser,   // retrieved info buffer
                        cbUser,  // size of buffer passed-in
                        &cbUser  // required buffer size
                        ))
        {
            if(GetLastError() == ERROR_INSUFFICIENT_BUFFER)
            {
                //
                // try again with the specified buffer size
                //

                if (NULL != (ptgUser = (PTOKEN_USER)AEAlloc(cbUser)))
                {
                    fAlloced = TRUE;

                    // get the user info and assign the sid if able to
                    if (GetTokenInformation(
                                    hToken,    // identifies access token
                                    TokenUser, // TokenUser info type
                                    ptgUser,   // retrieved info buffer
                                    cbUser,  // size of buffer passed-in
                                    &cbUser  // required buffer size
                                    ))
                    {
                        pSID = ptgUser->User.Sid;
                    }
                }
            }

        }
        else
        {
            // assign the sid when fast buffer worked
            pSID = ptgUser->User.Sid;
        }
    }
    switch(dwEventId >> 30)
    {
    case 0:
        dwEventType = EVENTLOG_SUCCESS;
        break;
    case 1:
        dwEventType = EVENTLOG_INFORMATION_TYPE;
        break;
    case 2:
        dwEventType = EVENTLOG_WARNING_TYPE;
        break;
    case 3:
        dwEventType = EVENTLOG_ERROR_TYPE;
        break;
    }

    // UNDONE - probably want a string to go with the error code
    if (!ReportEventW(hEventSource, // handle of event source
                 dwEventType,  // event type
                 0,                    // event category
                 dwEventId,            // event ID
                 pSID,                 // current user's SID
                 cStrings,             // strings in lpszStrings
                 0,                    // no bytes of raw data
                 (LPCWSTR*)lpszStrings,// array of error strings
                 NULL                  // no raw data
                 ))
    {
        goto Ret;
    }

Ret:
    if (hRegKey)
        RegCloseKey(hRegKey);
    if (hEventSource)
        (VOID) DeregisterEventSource(hEventSource);

    if((cStrings == 2) && lpszStrings[1])
    {
        AEFree(lpszStrings[1]);
    }
    return;
}

//+-------------------------------------------------------------------------
//  Microsoft Auto Enrollment Object Identifiers
//+-------------------------------------------------------------------------

//
// Name:    LoadAndCallEnrollmentProvider
//
// Description: This function loads the specified Auto Enrollment provider,
//              and calls the entry point to that provider.  It then
//              unloads the provider.
//
  
BOOL LoadAndCallEnrollmentProvider(
                                   IN BOOL fMachineEnrollment,
                                   IN PAUTO_ENROLL_INFO pEnrollmentInfo
                                   )
{
    HANDLE  hAutoEnrollProv = 0;
    FARPROC pEntryPoint = NULL;
    BOOL    fRet = FALSE;

    AE_BEGIN(L"LoadAndCallEnrollmentProvider");

    // load the auto enrollment provider and get the entry point
    if (NULL == (hAutoEnrollProv =
        LoadLibraryA(pEnrollmentInfo->pszAutoEnrollProvider)))
    {
        AE_DEBUG((AE_ERROR, L"Could not load auto-enrollment provider %ls\n\r", pEnrollmentInfo->pszAutoEnrollProvider));
        goto Ret;
    }

    if (NULL == (pEntryPoint = GetProcAddress(hAutoEnrollProv,
                                              "ProvAutoEnrollment")))
    {
        AE_DEBUG((AE_ERROR, L"Entry point ProvAutoEnrollment not found in %ls\n\r", pEnrollmentInfo->pszAutoEnrollProvider));
        goto Ret;
    }

    if (FALSE == pEntryPoint(fMachineEnrollment, pEnrollmentInfo))
    {
        AE_DEBUG((AE_ERROR, L"Enrollment Failed, wizard returned %lx error\n", GetLastError()));
        LogAutoEnrollmentError(HRESULT_FROM_WIN32(GetLastError()),
                               EVENT_AE_ENROLLMENT_FAILED,
                               fMachineEnrollment,
                               NULL,
                               pEnrollmentInfo->pwszCertType, pEnrollmentInfo->pwszCAAuthority);
        goto Ret;
    }


    AE_DEBUG((AE_WARNING, L"Enrolled for a %ls certificate\n", pEnrollmentInfo->pwszCertType));


    fRet = TRUE;
Ret:
    if (hAutoEnrollProv)
        FreeLibrary(hAutoEnrollProv);
    AE_END();
    return fRet;
}

//
// Name:    InitInternalInfo
//
// Description: This function initializes information needed to proceed with
//              auto enrollment.
//
  
HRESULT InitInternalInfo(
                         LDAP *pld,
                      IN BOOL fMachineEnrollment,
                      IN HANDLE hToken,
                      OUT PINTERNAL_INFO pInternalInfo
                      )
{
    HRESULT     hrLocal = S_OK;
    HRESULT     hrNetwork  = S_OK;
    DWORD       dwOpenStoreFlags = CERT_SYSTEM_STORE_CURRENT_USER;
    DWORD       dwErr = 0;
    BOOL        fRet = FALSE;
    DWORD       ldaperr;
    DWORD       cNameBuffer;
    LDAPMessage * SearchResult = NULL;
    LDAPMessage * PrincipalAttributes = NULL;
    HCAINFO     hCACurrent = NULL;
    DWORD       iCAIndex, cCA;
    DWORD       cbHash;
    struct l_timeval        timeout;

    

    // Initialize LDAP session
    LPTSTR wszSearchUser = TEXT("(objectCategory=user)");
    LPTSTR wszSearchComputer = TEXT("(objectCategory=computer)");

    // We want the following attributes
    LPTSTR AttrsUser[] = {
                        DS_ATTR_COMMON_NAME,
                        DS_ATTR_EMAIL_ADDR,
                        DS_ATTR_OBJECT_GUID,
                        DS_ATTR_UPN,
                        NULL,
                      };
    LPTSTR AttrsComputer[] = {
                        DS_ATTR_COMMON_NAME,
                        DS_ATTR_DNS_NAME,
                        DS_ATTR_EMAIL_ADDR,
                        DS_ATTR_OBJECT_GUID,
                        DS_ATTR_UPN,
                        NULL,
                      };

    AE_BEGIN(L"InitInternalInfo");
    pInternalInfo->fMachineEnrollment = fMachineEnrollment;

    pInternalInfo->hToken = hToken;

    if (fMachineEnrollment)
    {
        dwOpenStoreFlags = CERT_SYSTEM_STORE_LOCAL_MACHINE;
    }

    // open the appropriate ROOT store
    if (NULL == (pInternalInfo->hRootStore = CertOpenStore(
        CERT_STORE_PROV_SYSTEM_W, 0, 0, dwOpenStoreFlags | CERT_STORE_READONLY_FLAG, L"ROOT")))
    {
        hrLocal = HRESULT_FROM_WIN32(GetLastError());
        AE_DEBUG((AE_ERROR, L"Unable to open ROOT store (%lx)\n\r", hrLocal));
        goto Ret;
    }

    // open the appropriate CA store
    if (NULL == (pInternalInfo->hCAStore = CertOpenStore(
        CERT_STORE_PROV_SYSTEM_W, 0, 0, dwOpenStoreFlags | CERT_STORE_READONLY_FLAG, L"CA")))
    {
        hrLocal = HRESULT_FROM_WIN32(GetLastError());
        AE_DEBUG((AE_ERROR, L"Unable to open CA store (%lx)\n\r", hrLocal));
        goto Ret;
    }

    // open the appropriate MY store
    if (NULL == (pInternalInfo->hMYStore = CertOpenStore(
        CERT_STORE_PROV_SYSTEM_W, 0, 0, dwOpenStoreFlags, L"MY")))
    {
        hrLocal = HRESULT_FROM_WIN32(GetLastError());
        AE_DEBUG((AE_ERROR, L"Unable to open MY store (%lx)\n\r", hrLocal));
        goto Ret;
    }
    if(!CertControlStore(pInternalInfo->hMYStore, 0, CERT_STORE_CTRL_AUTO_RESYNC, NULL))
    {
        hrLocal = HRESULT_FROM_WIN32(GetLastError());
        AE_DEBUG((AE_ERROR, L"Unable configure MY store for auto-resync(%lx)\n\r", hrLocal));
        goto Ret;
    }

    cNameBuffer = MAX_DN_SIZE;
    pInternalInfo->wszDN = AEAlloc(cNameBuffer*sizeof(TCHAR));
    if(pInternalInfo->wszDN == NULL)
    {
        hrLocal = E_OUTOFMEMORY;
        goto Ret;
    }
    if(!g_pfnGetUserNameEx(NameFullyQualifiedDN, pInternalInfo->wszDN, &cNameBuffer))
    {
        hrLocal  = HRESULT_FROM_WIN32(GetLastError());
        AE_DEBUG((AE_ERROR, L"GetUserNameEx Failed (%lx)\n\r", hrLocal));

        goto Ret;
    } 
    // Normalize the directory DN into a 
    // real BER encoded name
    pInternalInfo->blobDN.cbData = 0;
    CertStrToName(X509_ASN_ENCODING,
                  pInternalInfo->wszDN,
                  CERT_X500_NAME_STR,
                  NULL,
                  NULL,
                  &pInternalInfo->blobDN.cbData,
                  NULL);
    if(pInternalInfo->blobDN.cbData == 0)
    {
        hrLocal  = HRESULT_FROM_WIN32(GetLastError());
        goto Ret; 
    }
    pInternalInfo->blobDN.pbData = AEAlloc(pInternalInfo->blobDN.cbData);
    if(pInternalInfo->blobDN.pbData == NULL)
    {
        hrLocal = E_OUTOFMEMORY;
        goto Ret;
    }
    if(!CertStrToName(X509_ASN_ENCODING,
                  pInternalInfo->wszDN,
                  CERT_X500_NAME_STR,
                  NULL,
                  pInternalInfo->blobDN.pbData,
                  &pInternalInfo->blobDN.cbData,
                  NULL))
    {
        hrLocal  = HRESULT_FROM_WIN32(GetLastError());
        AE_DEBUG((AE_ERROR, L"Could not encode DN (%lx)\n\r", hrLocal));
        goto Ret;
    }
                                

    timeout.tv_sec = csecLDAPTIMEOUT;
    timeout.tv_usec = 0;


    ldaperr = g_pfnldap_search_ext_s(pld, 
                  pInternalInfo->wszDN,
                  LDAP_SCOPE_BASE,
                  (fMachineEnrollment?wszSearchComputer:wszSearchUser),
                  (fMachineEnrollment?AttrsComputer:AttrsUser),
                  0,
                  NULL,
                  NULL,
                  &timeout,
                  10000,
                  &SearchResult);

    if(ldaperr != LDAP_SUCCESS)
    {
        hrNetwork  = HRESULT_FROM_WIN32(g_pfnLdapMapErrorToWin32(ldaperr));
        AE_DEBUG((AE_ERROR, L"ldap_search_ext_s failed (%lx)\n\r", hrLocal));
        goto Ret;
    }


    PrincipalAttributes = 
        g_pfnldap_first_entry(pld, 
                         SearchResult); 

    if(NULL == PrincipalAttributes)
    {
        AE_DEBUG((AE_ERROR, L"no user entity found\n\r"));
        hrNetwork  = HRESULT_FROM_WIN32(ERROR_NO_SUCH_USER);
        goto Ret;
    }
    if(fMachineEnrollment)
    {
        pInternalInfo->awszldap_UPN = g_pfnldap_get_values(pld, 
                                      PrincipalAttributes, 
                                      DS_ATTR_DNS_NAME);

        if((pInternalInfo->awszldap_UPN) &&
            (*pInternalInfo->awszldap_UPN))
        {
            AE_DEBUG((AE_INFO, L"ldap DNS Name %ls\n\r", *pInternalInfo->awszldap_UPN));
        }

    }
    else
    {
        pInternalInfo->awszldap_UPN = g_pfnldap_get_values(pld, 
                                          PrincipalAttributes, 
                                          DS_ATTR_UPN);
        if((pInternalInfo->awszldap_UPN == NULL) ||
           (*pInternalInfo->awszldap_UPN == NULL))
        {
            LPTSTR wszUPNBuffer = NULL;
            DWORD  cbUPNBuffer = 0;
            LPTSTR *awszExplodedDN, * pwszCurrent;
            // Build a UPN.  The UPN is built from 
            // The username (without the SAM domain), 


            // Get a buffer that will be big enough
            GetUserName(NULL, &cbUPNBuffer);
            if(cbUPNBuffer == 0)
            {
                hrLocal  = HRESULT_FROM_WIN32(GetLastError());
                goto Ret;
            }

            cbUPNBuffer += _tcslen(pInternalInfo->wszDN)*sizeof(TCHAR);

            wszUPNBuffer = AEAlloc(cbUPNBuffer);
            if(wszUPNBuffer == NULL)
            {
                hrLocal = E_OUTOFMEMORY;
                goto Ret;
            }
            if(!GetUserName(wszUPNBuffer, &cbUPNBuffer))
            {
                hrLocal  = HRESULT_FROM_WIN32(GetLastError());
                goto Ret;
            }

            awszExplodedDN = g_pfnldap_explode_dn(pInternalInfo->wszDN, 0);
            if(awszExplodedDN != NULL)
            {
                _tcscat(wszUPNBuffer, TEXT("@"));
                pwszCurrent = awszExplodedDN;
                while(*pwszCurrent)
                {
                    if(0 == _tcsncmp(*pwszCurrent, TEXT("DC="), 3))
                    {
                        _tcscat(wszUPNBuffer, (*pwszCurrent)+3);
                        _tcscat(wszUPNBuffer, TEXT("."));
                    }
                    pwszCurrent++;
                }
                // remove the trailing '.' or "@" if there were no DC=

                wszUPNBuffer[_tcslen(wszUPNBuffer)-1] = 0;
            }
            pInternalInfo->wszConstructedUPN = wszUPNBuffer;
            AE_DEBUG((AE_INFO, L"Constructed UPN %ls\n\r", pInternalInfo->wszConstructedUPN));
        }
        else
        {
            AE_DEBUG((AE_INFO, L"ldap UPN %ls\n\r", *pInternalInfo->awszldap_UPN));

        }
    }
    pInternalInfo->awszEmail = g_pfnldap_get_values(pld, 
                                      PrincipalAttributes, 
                                      DS_ATTR_EMAIL_ADDR);

    if((pInternalInfo->awszEmail) &&
        (*pInternalInfo->awszEmail))
    {
        AE_DEBUG((AE_INFO, L"E-mail name %ls\n\r", *pInternalInfo->awszEmail));
    }
    // Build up the list of CA's
    // Build up the list of CA's
    hrNetwork = CAEnumFirstCA((LPCWSTR)pld, 
                       CA_FLAG_SCOPE_IS_LDAP_HANDLE |
                       (fMachineEnrollment?CA_FIND_LOCAL_SYSTEM:0), 
                       &hCACurrent);
    if(hrNetwork != S_OK)
    {
        goto Ret;
    }
    if((hCACurrent == NULL) || (0 == (cCA =  CACountCAs(hCACurrent))))
    {
        pInternalInfo->ccaList = 0;
        AE_DEBUG((AE_WARNING, L"No CA's available for auto-enrollment\n\r"));
        goto Ret;
    }


    pInternalInfo->acaList = (PINTERNAL_CA_LIST)AEAlloc(sizeof(INTERNAL_CA_LIST) * cCA);
    if(pInternalInfo->acaList == NULL)
    {
        hrLocal = E_OUTOFMEMORY;
        goto Ret;
    }
    ZeroMemory(pInternalInfo->acaList, sizeof(INTERNAL_CA_LIST) * cCA);
    AE_DEBUG((AE_INFO, L" %d CA's in enterprise\n\r", cCA));

    pInternalInfo->ccaList = 0;
    hrLocal = S_OK;
    hrNetwork = S_OK;

    for(iCAIndex = 0; iCAIndex < cCA; iCAIndex++ )       
    {
        PCCERT_CONTEXT pCert = NULL;
        LPWSTR *awszName = NULL;
        HCAINFO hCANew = NULL;

        if(iCAIndex > 0)
        {
            hrNetwork = CAEnumNextCA(hCACurrent, &hCANew);
        }
        // Clean up from previous

        if(pInternalInfo->acaList[pInternalInfo->ccaList].wszName)
        {
            AEFree(pInternalInfo->acaList[pInternalInfo->ccaList].wszName);
        }
        if(pInternalInfo->acaList[pInternalInfo->ccaList].wszDNSName)
        {
            AEFree(pInternalInfo->acaList[pInternalInfo->ccaList].wszDNSName);
        }
        if(pInternalInfo->acaList[iCAIndex].awszCertificateTemplates)
        {
            CAFreeCAProperty(pInternalInfo->acaList[pInternalInfo->ccaList].hCAInfo,
                             pInternalInfo->acaList[iCAIndex].awszCertificateTemplates);
        }

        if(pInternalInfo->acaList[pInternalInfo->ccaList].hCAInfo)
        {
            CACloseCA(pInternalInfo->acaList[pInternalInfo->ccaList].hCAInfo);
            pInternalInfo->acaList[pInternalInfo->ccaList].hCAInfo = NULL;
        }
         
        if((hrNetwork != S_OK) ||
           (hrLocal != S_OK))
        {
            break;
        }

        if(iCAIndex > 0)
        {
            hCACurrent = hCANew; 
        }

        if(hCACurrent == NULL)
        {
            break;
        }

        pInternalInfo->acaList[pInternalInfo->ccaList].hCAInfo = hCACurrent;

        hrNetwork = CAGetCAProperty(hCACurrent, 
                             CA_PROP_NAME,
                             & awszName);
        if(hrNetwork != S_OK)
        {
            AE_DEBUG((AE_INFO, L"No name property for ca\n\r"));
            // skip to the next one.
            hrNetwork = S_OK;
            continue;
        }
        if((awszName != NULL) && (*awszName != NULL))
        {
            pInternalInfo->acaList[pInternalInfo->ccaList].wszName = AEAlloc(sizeof(WCHAR)*(wcslen(*awszName)+1));
            if(pInternalInfo->acaList[pInternalInfo->ccaList].wszName == NULL)
            {        
                CAFreeCAProperty(hCACurrent, awszName);
                hrLocal = E_OUTOFMEMORY;
                continue;
            }
            wcscpy(pInternalInfo->acaList[pInternalInfo->ccaList].wszName, *awszName);
        }
        else
        {
            AE_DEBUG((AE_INFO, L"No name property for ca\n\r"));
            if(awszName != NULL)
            {        
                CAFreeCAProperty(hCACurrent, awszName);
            }
            // skip to the next one
            continue;
        }

        CAFreeCAProperty(hCACurrent, awszName);
        hrNetwork = CAGetCAProperty(hCACurrent, 
                             CA_PROP_DNSNAME,
                             & awszName);
        if(hrNetwork != S_OK)
        {
            AE_DEBUG((AE_INFO, L"No DNS property for CA %ls\n\r", pInternalInfo->acaList[pInternalInfo->ccaList].wszName));
            hrNetwork = S_OK;
            continue;
        }
        if((awszName != NULL) && (*awszName != NULL))
        {
            pInternalInfo->acaList[pInternalInfo->ccaList].wszDNSName = AEAlloc(sizeof(WCHAR)*(wcslen(*awszName)+1));
            if(pInternalInfo->acaList[pInternalInfo->ccaList].wszDNSName == NULL)
            {
                CAFreeCAProperty(hCACurrent, awszName);
                hrLocal = E_OUTOFMEMORY;
                continue;
            }
            wcscpy(pInternalInfo->acaList[pInternalInfo->ccaList].wszDNSName, *awszName);
        }
        else
        {
            AE_DEBUG((AE_INFO, L"No DNS property for CA %ls\n\r", pInternalInfo->acaList[pInternalInfo->ccaList].wszName));
            if(awszName != NULL)
            {        
                CAFreeCAProperty(hCACurrent, awszName);
            }
            continue;
        }


        CAFreeCAProperty(hCACurrent, awszName);
        hrNetwork = CAGetCAProperty(hCACurrent, 
                             CA_PROP_CERT_TYPES,
                             & pInternalInfo->acaList[pInternalInfo->ccaList].awszCertificateTemplates);
        if(hrNetwork != S_OK)
        {
            AE_DEBUG((AE_INFO, L"No cert type property for CA %ls\n\r", pInternalInfo->acaList[pInternalInfo->ccaList].wszName));
            continue;
        }

        hrNetwork = CAGetCACertificate(hCACurrent, &pCert);
        if(hrNetwork != S_OK)
        {
            AE_DEBUG((AE_INFO, L"No certificate property for CA %ls\n\r", pInternalInfo->acaList[pInternalInfo->ccaList].wszName));
            continue;
        }
        cbHash = sizeof(pInternalInfo->acaList[pInternalInfo->ccaList].CACertHash);

        if(!CertGetCertificateContextProperty(pCert,
                                          CERT_SHA1_HASH_PROP_ID,
                                          pInternalInfo->acaList[pInternalInfo->ccaList].CACertHash,
                                          &cbHash))
        {
            continue;
        }
        CertFreeCertificateContext(pCert);
        AE_DEBUG((AE_INFO, L"CA %ls\\%ls available\n\r", 
                 pInternalInfo->acaList[pInternalInfo->ccaList].wszName,
                 pInternalInfo->acaList[pInternalInfo->ccaList].wszDNSName));
        pInternalInfo->ccaList++;
    }
    if(pInternalInfo->ccaList == 0)
    {
        AE_DEBUG((AE_WARNING, L"No CA's available for auto-enrollment\n\r"));
    }

    fRet = TRUE;
Ret:
    if (hrLocal != S_OK)
    {
        LogAutoEnrollmentError(hrLocal,
                               EVENT_AE_LOCAL_CYCLE_INIT_FAILED,
                               pInternalInfo->fMachineEnrollment,
                               pInternalInfo->hToken,
                               NULL, NULL);
    }
    if (hrNetwork != S_OK)
    {
        LogAutoEnrollmentError(hrNetwork,
                               EVENT_AE_NETWORK_CYCLE_INIT_FAILED,
                               pInternalInfo->fMachineEnrollment,
                               pInternalInfo->hToken,
                               NULL, NULL);
    }

    if(SearchResult)
    {
        g_pfnldap_msgfree(SearchResult);
    }

    AE_END();
    if(hrLocal != S_OK)
    {
        return hrLocal;
    }
    return hrNetwork;
}

//
// Name:    FreeInternalInfo
//
// Description: This function frees and resources which were needed for
//              auto enrollment.
//
  
void FreeInternalInfo(
                      IN PINTERNAL_INFO pInternalInfo
                      )
{
    DWORD i;
    if (pInternalInfo->hRootStore)
        CertCloseStore(pInternalInfo->hRootStore, 0);
    if (pInternalInfo->hCAStore)
        CertCloseStore(pInternalInfo->hCAStore, 0);
    if (pInternalInfo->hMYStore)
        CertCloseStore(pInternalInfo->hMYStore, 0);

    if(pInternalInfo->awszldap_UPN)
    {
        g_pfnldap_value_free(pInternalInfo->awszldap_UPN);
    }

    if(pInternalInfo->awszEmail)
    {
        g_pfnldap_value_free(pInternalInfo->awszEmail);
    }

    if(pInternalInfo->wszDN)
    {
        AEFree(pInternalInfo->wszDN);
    }
    if(pInternalInfo->blobDN.pbData)
    {
        AEFree(pInternalInfo->blobDN.pbData);
    }

    if(pInternalInfo->wszConstructedUPN)
    {
        AEFree(pInternalInfo->wszConstructedUPN);
    }

    if( pInternalInfo->acaList )
    {

        for(i=0; i <pInternalInfo->ccaList; i++)
        {
            if(pInternalInfo->acaList[i].wszName)
            {
                AEFree(pInternalInfo->acaList[i].wszName);
            }
            if(pInternalInfo->acaList[i].wszDNSName)
            {
                AEFree(pInternalInfo->acaList[i].wszDNSName);
            }
            if(pInternalInfo->acaList[i].awszCertificateTemplates)
            {

                CAFreeCAProperty(pInternalInfo->acaList[i].hCAInfo,
                                 pInternalInfo->acaList[i].awszCertificateTemplates);
            }
            if(pInternalInfo->acaList[i].hCAInfo)
            {
                CACloseCA(pInternalInfo->acaList[i].hCAInfo);
            }
        }
        AEFree(pInternalInfo->acaList);
    }
}


//
// Name:    InitInstance
//
// Description: This function initializes information needed to proceed with
//              auto enrollment.
//
BOOL InitInstance(
                      IN PCCTL_CONTEXT pCTLContext,
                      IN PINTERNAL_INFO pInternalInfo,
                      OUT PAE_INSTANCE_INFO pInstance
                      )
{
    FILETIME    ft;


    pInstance->pCTLContext = CertDuplicateCTLContext(pCTLContext);
    pInstance->pInternalInfo = pInternalInfo;

    // choose a random CA order
    // Get the current time
    GetSystemTimeAsFileTime(&ft); 

    // use mod to get something marginally random
    // It's an index into the main list of ca's
    if(pInternalInfo->ccaList)
    {
        pInstance->dwRandomIndex = ft.dwLowDateTime %
                    pInternalInfo->ccaList;
    }
    else
    {
        pInstance->dwRandomIndex = 0;
    }

    return TRUE;
}



//
// Name:    FreeInstance
//
// Description: This function frees and resources which were needed for
//              auto enrollment.
//
  
void FreeInstance(
                      IN PAE_INSTANCE_INFO pInstance
                      )
{
    if (pInstance->pOldCert)
        CertFreeCertificateContext(pInstance->pOldCert);

    if (pInstance->pwszCertType)
        AEFree(pInstance->pwszCertType);

    if (pInstance->pwszAEIdentifier)
        AEFree(pInstance->pwszAEIdentifier);

    if (pInstance->pCertTypeExtensions)             // use LocalFree b/c certcli.dll
        LocalFree(pInstance->pCertTypeExtensions);  // uses LocalAlloc to alloc

    if(pInstance->pCTLContext)
    {
        CertFreeCTLContext(pInstance->pCTLContext);
    }
}


// Name:    SetEnrollmentType
//
// Description: This function retrieves additional enrollment information
//              needed to enroll for a cert.
//
  
BOOL SetEnrollmentCertType(
                                 IN PAE_INSTANCE_INFO pInstance,
                                 OUT PAUTO_ENROLL_INFO pEnrollmentInfo
                                 )
{
    BOOL    fRet = FALSE;

    // copy over the cert extensions, this is freed by the FreeInternalInfo
    // function, but after being used in the EnrollmentInfo struct
    pEnrollmentInfo->CertExtensions.cExtension =
            pInstance->pCertTypeExtensions->cExtension;
    pEnrollmentInfo->CertExtensions.rgExtension =
            pInstance->pCertTypeExtensions->rgExtension;

    // copy over the cert type name, this is freed by the FreeInternalInfo
    // function, but after being used in the EnrollmentInfo struct
    pEnrollmentInfo->pwszCertType = pInstance->pwszCertType;


    // The auto enrollment ID is used to uniquely tie an autoenrolled cert to
    // it's autoenrollment object. 
    pEnrollmentInfo->pwszAutoEnrollmentID = pInstance->pwszAEIdentifier;
    

    // copy over the handle to the MY store, this is freed by the
    // FreeInternalInfo  function, but after being used in the
    // EnrollmentInfo struct
    pEnrollmentInfo->hMYStore = pInstance->pInternalInfo->hMYStore;

    // copy over the pointer to the cert context to be renewed, this
    // is freed by the FreeInternalInfo  function, but after being used in the
    // EnrollmentInfo struct
    if ((pInstance->pOldCert) && (pInstance->fRenewalOK))
    {
        pEnrollmentInfo->pOldCert = pInstance->pOldCert;
    }

    // Enrollment controll chooses provider type  based on cert type
    pEnrollmentInfo->dwProvType = 0;
    // Enrollment controll chooses key spec  based on cert type
    pEnrollmentInfo->dwKeySpec = 0;

    // UNDONE - currently the gen key flags is hard coded to 0x0
    pEnrollmentInfo->dwGenKeyFlags = 0;

    fRet = TRUE;
//Ret:
    return fRet;
}



// Name:    GetCertTypeInfo
//
// Description: This function retrieves information (the extensions) for the
//              cert type specified in the ListIdentifier field of the auto enrollment
//              object (CTL) in the internal info structure.  In addition the
//              function makes a call to check if the current entity has permission
//              to enroll for this cert type.
//

BOOL GetCertTypeInfo(
                     IN OUT PAE_INSTANCE_INFO pInstance,
                     IN LDAP * pld,
                     OUT BOOL *pfPermissionToEnroll
                     )
{
    HRESULT     hr = S_OK;
    HCERTTYPE   hCertType = 0;
    DWORD       dwErr = 0;
    BOOL        fRet = FALSE;
    LPWSTR      *awszName = NULL;

    LPWSTR      wszCertTypeName = NULL;

    CERT_EXTENSIONS     CertTypeExtensions;
    AE_BEGIN(L"GetCertTypeInfo");

    *pfPermissionToEnroll = FALSE;



    AE_DEBUG((AE_INFO, L"Found auto-enrollment object with cert type: %ls\n\r", 
              pInstance->pCTLContext->pCtlInfo->ListIdentifier.pbData));

    wszCertTypeName = wcschr((LPWSTR)pInstance->pCTLContext->pCtlInfo->ListIdentifier.pbData, L'|');
    if(wszCertTypeName)
    {
        wszCertTypeName++;
    }
    else
    {
        wszCertTypeName = (LPWSTR)pInstance->pCTLContext->pCtlInfo->ListIdentifier.pbData;
    }

    

    // get a handle to the cert type
    if (S_OK != (hr = CAFindCertTypeByName(wszCertTypeName,
                                     (HCAINFO)pld,                    // special optimization, ldap handle passed as scope
                                     CT_FLAG_SCOPE_IS_LDAP_HANDLE |
                                     (pInstance->pInternalInfo->fMachineEnrollment?
                                       CT_ENUM_MACHINE_TYPES  | CT_FIND_LOCAL_SYSTEM :
                                       CT_ENUM_USER_TYPES), 
                                     &hCertType)))
    {
        AE_DEBUG((AE_WARNING, L"Unknown cert type: %ls\n\r", pInstance->pwszCertType));
        goto Ret;
    }
    // get the extensions for the cert type
    if (S_OK != (hr = CAGetCertTypeProperty(hCertType,
                                      CERTTYPE_PROP_DN,
                                      &awszName)))
    {
        AE_DEBUG((AE_WARNING, L"Could not get cert type full name: %ls\n\r",
                 pInstance->pCTLContext->pCtlInfo->ListIdentifier.pbData));
        goto Ret;
    }
    if((awszName == NULL) || (*awszName == NULL))
    {
        AE_DEBUG((AE_WARNING, L"Could not get cert type full name: %ls\n\r",
                 pInstance->pCTLContext->pCtlInfo->ListIdentifier.pbData));
        hr = CERTSRV_E_PROPERTY_EMPTY;
        goto Ret;
    }

    if (NULL == (pInstance->pwszCertType = (LPWSTR)AEAlloc(
        (wcslen(*awszName) + 1)*sizeof(WCHAR))))
    {
        hr = E_OUTOFMEMORY;
        goto Ret;
    }
    wcscpy(pInstance->pwszCertType, *awszName);

    if (NULL == (pInstance->pwszAEIdentifier = (LPWSTR)AEAlloc(
        (wcslen((LPWSTR)pInstance->pCTLContext->pCtlInfo->ListIdentifier.pbData) + 1)*sizeof(WCHAR))))
    {
        hr = E_OUTOFMEMORY;
        goto Ret;
    }
    wcscpy(pInstance->pwszAEIdentifier, (LPWSTR)pInstance->pCTLContext->pCtlInfo->ListIdentifier.pbData);

    // get the extensions for the cert type
    if (S_OK != (hr = CAGetCertTypeExtensions(hCertType,
                                        &pInstance->pCertTypeExtensions)))
    {
        AE_DEBUG((AE_WARNING, L"Could not get cert type extensions: %ls\n\r", pInstance->pwszCertType));
        goto Ret;
    }

    // get the extensions for the cert type
    if (S_OK != (hr = CAGetCertTypeFlags(hCertType,
                                   &pInstance->dwCertTypeFlags)))
    {
        AE_DEBUG((AE_WARNING, L"Could not get cert type flags: %ls\n\r", pInstance->pwszCertType));
        goto Ret;
    }

    // get the expiration offset
    if (S_OK != (hr = CAGetCertTypeExpiration(hCertType,
                                        NULL,
                                        (LPFILETIME)&pInstance->ftExpirationOffset)))
    {
        AE_DEBUG((AE_WARNING, L"Could not get cert type expirations: %ls\n\r", pInstance->pwszCertType));
        goto Ret;
    }

    *pfPermissionToEnroll = (S_OK == CACertTypeAccessCheck(hCertType, pInstance->pInternalInfo->hToken));


    fRet = TRUE;
Ret:
    if (hr != S_OK)
    {
        LogAutoEnrollmentError(hr,
                               EVENT_UAE_UNKNOWN_CERT_TYPE,
                               pInstance->pInternalInfo->fMachineEnrollment,
                               pInstance->pInternalInfo->hToken, 
                               (LPWSTR)pInstance->pCTLContext->pCtlInfo->ListIdentifier.pbData, NULL);
    }
    // close the handle to the cert type
    if (hCertType)
    {
        if(awszName)
        {
            CAFreeCertTypeProperty(hCertType, awszName);
        }
        CACloseCertType(hCertType);
    }

    AE_END();
    return fRet;
}




//
// Name:    CompareEnhancedKeyUsageExtensions
//
// Description: This function checks if a the enhanced key usage extensions
//              in a certificate contain the enhanced key usage extensions
//              from the auto enrollment object (CTL),
//
  
HRESULT CompareEnhancedKeyUsageExtensions(
                                       IN PAE_INSTANCE_INFO         pInstance,
                                       IN PCCERT_CONTEXT            pCertContext,
                                       IN OUT PAE_CERT_TEST_ARRAY  *ppAEData
                                       )
{
    HRESULT             hr = S_OK;
    PCERT_ENHKEY_USAGE  pCertUsage = NULL;
    DWORD               cbCertUsage;
    PCERT_ENHKEY_USAGE  pAEObjUsage = NULL;
    DWORD               cbAEObjUsage;
    PCERT_EXTENSION     pAEObjUsageExt;
    PCERT_EXTENSION     pCertUsageExt;
    DWORD               i;
    DWORD               j;

    LPWSTR wszCertEKU = NULL;
    LPWSTR wszTemplateEKU = NULL;



    // get the enhanced key usages from the auto enrollment obj extensions
    pCertUsageExt = CertFindExtension(szOID_ENHANCED_KEY_USAGE,
                            pCertContext->pCertInfo->cExtension,
                            pCertContext->pCertInfo->rgExtension);



    if(pCertUsageExt)
    {
        if (!CryptDecodeObject(CRYPT_ASN_ENCODING, szOID_ENHANCED_KEY_USAGE, 
                               pCertUsageExt->Value.pbData,
                               pCertUsageExt->Value.cbData,
                               0, NULL, &cbCertUsage))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto Ret;
        }

        if (NULL == (pCertUsage = (PCERT_ENHKEY_USAGE)AEAlloc(cbCertUsage)))
        {
            hr = E_OUTOFMEMORY;
            goto Ret;
        }

        if (!CryptDecodeObject(CRYPT_ASN_ENCODING, szOID_ENHANCED_KEY_USAGE, 
                               pCertUsageExt->Value.pbData,
                               pCertUsageExt->Value.cbData,
                               0, pCertUsage, &cbCertUsage))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto Ret;
        }
    }
    else
    {
        // No usage, so this cert is good for everything
        goto Ret;

    }



    // get the enhanced key usages from the auto enrollment obj extensions
    pAEObjUsageExt = CertFindExtension(szOID_ENHANCED_KEY_USAGE,
                            pInstance->pCertTypeExtensions->cExtension,
                            pInstance->pCertTypeExtensions->rgExtension);



    if(pAEObjUsageExt)
    {
        if (!CryptDecodeObject(CRYPT_ASN_ENCODING, szOID_ENHANCED_KEY_USAGE, 
                               pAEObjUsageExt->Value.pbData,
                               pAEObjUsageExt->Value.cbData,
                               0, NULL, &cbAEObjUsage))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto Ret;
        }

        if (NULL == (pAEObjUsage = (PCERT_ENHKEY_USAGE)AEAlloc(cbAEObjUsage)))
        {
            hr = E_OUTOFMEMORY;
            goto Ret;
        }

        if (!CryptDecodeObject(CRYPT_ASN_ENCODING, szOID_ENHANCED_KEY_USAGE, 
                               pAEObjUsageExt->Value.pbData,
                               pAEObjUsageExt->Value.cbData,
                               0, pAEObjUsage, &cbAEObjUsage))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto Ret;
        }
    }
    else
    {
        // The template requires no usage extension, so
        // because the cert has a usage extension, we fail
        // the test.
        goto Failed;

    }


    // check if the number of usages is smaller in the cert then in the
    // auto enrollment object
    if (pCertUsage->cUsageIdentifier < pAEObjUsage->cUsageIdentifier)
    {
        goto Failed;
    }

    // check if all the usages found in the auto enrollment object are in
    // the cert
    for (i=0;i<pAEObjUsage->cUsageIdentifier;i++)
    {
        for (j=0;j<pCertUsage->cUsageIdentifier;j++)
        {
            if (0 == strcmp(pCertUsage->rgpszUsageIdentifier[j],
                            pAEObjUsage->rgpszUsageIdentifier[i]))
            {
                break;
            }
        }
        if (j == pCertUsage->cUsageIdentifier)
        {
            goto Failed;
        }
    }

Ret:

    if(wszCertEKU)
    {
        AEFree(wszCertEKU);
    }

    if(wszTemplateEKU)
    {
        AEFree(wszTemplateEKU);
    }


    if (pCertUsage)
        AEFree(pCertUsage);
    if (pAEObjUsage)
        AEFree(pAEObjUsage);
    return hr;


Failed:


    // Log a failure of this test

    // Build extension strings
    wszCertEKU = HelperExtensionToString(pCertUsageExt);

  /*  if(wszCertEKU == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Ret;
    }*/

    wszTemplateEKU = HelperExtensionToString(pAEObjUsageExt);

   /* if(wszTemplateEKU == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Ret;
    }*/

    AELogTestResult(ppAEData,
                    AE_TEST_EXTENSION_EKU,
                    wszCertEKU ? wszCertEKU : g_wszEmptyExtension,
                    wszTemplateEKU ? wszTemplateEKU : g_wszEmptyExtension);


    goto Ret;
}


#define MAX_KEY_USAGE_SIZE  20   // sizeof(CRYPT_BIT_BLOB) for 64bit + sizeof(DWORD)
//
// Name:    CompareKeyUsageExtensions
//
// Description: This function checks if the key usages
//              in a certificate are a superset of the key usages
//              from the auto enrollment object (CTL),
//
  

HRESULT CompareKeyUsageExtensions(
                               IN PAE_INSTANCE_INFO pInstance,
                               IN PCCERT_CONTEXT pCertContext,
                               IN OUT PAE_CERT_TEST_ARRAY  *ppAEData
                               )
{
    HRESULT             hr = S_OK;
    PCERT_EXTENSION     pCertUsageExt;
    PCERT_EXTENSION     pAEObjUsageExt;
    DWORD               i;
    DWORD               dwMask = (DWORD)-1;
    BYTE                bCertUsageBuffer[MAX_KEY_USAGE_SIZE];
    BYTE                bAEObjUsageBuffer[MAX_KEY_USAGE_SIZE];
    PCRYPT_BIT_BLOB     pCertUsage = (PCRYPT_BIT_BLOB)bCertUsageBuffer;
    PCRYPT_BIT_BLOB     pAEObjUsage = (PCRYPT_BIT_BLOB)bAEObjUsageBuffer;
    DWORD               dwKeyUsage;


    LPWSTR              wszCertKU = NULL;
    LPWSTR              wszTemplateKU = NULL;



    // get the key usages from the cert
    pCertUsageExt = CertFindExtension(szOID_KEY_USAGE,
                            pCertContext->pCertInfo->cExtension,
                            pCertContext->pCertInfo->rgExtension);

    // get the key usages from the auto enrollment obj extensions
    pAEObjUsageExt = CertFindExtension(szOID_KEY_USAGE,
                            pInstance->pCertTypeExtensions->cExtension,
                            pInstance->pCertTypeExtensions->rgExtension);

    // If the cert has no key usage extension, then it's good in general
    if (NULL == pCertUsageExt)
    {
        goto Ret;
    }

    // If the type requires no extension, and the cert has one,
    // then the cert is too limited.
    if(pAEObjUsageExt == NULL)
    {
        goto Failed;
    }

    // Decode the key usage into their basic bit's
    dwKeyUsage = MAX_KEY_USAGE_SIZE;
    if(!CryptDecodeObject(X509_ASN_ENCODING,
                          X509_KEY_USAGE,
                          pCertUsageExt->Value.pbData,
                          pCertUsageExt->Value.cbData,
                          0, 
                          (PVOID *)pCertUsage,
                          &dwKeyUsage))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Ret;
    }

    // Decode the key usage into their basic bit's
    dwKeyUsage = MAX_KEY_USAGE_SIZE;
    if(!CryptDecodeObject(X509_ASN_ENCODING,
                          X509_KEY_USAGE,
                          pAEObjUsageExt->Value.pbData,
                          pAEObjUsageExt->Value.cbData,
                          0, 
                          (PVOID *)pAEObjUsage,
                          &dwKeyUsage))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Ret;
    }

    // Get the mask based on algs
    for(i=0; i < g_cKUMasks; i++)
    {
        if(strcmp(pCertContext->pCertInfo->SubjectPublicKeyInfo.Algorithm.pszObjId, g_aKUMasks[i].pszAlg) == 0)
        {
            dwMask = g_aKUMasks[i].dwMask;
            break;
        }
    }


    // see if auto enroll obj keys usages are a sub set of cert's
    if (pAEObjUsage->cbData > pCertUsage->cbData)
    {
        goto Failed;
    }

    for (i=0;i<pAEObjUsage->cbData;i++)
    {
        BYTE bMask = 0xff;
        if(i < sizeof(DWORD))
        {
            bMask = ((PBYTE)&dwMask)[i];
        }
        if ((pAEObjUsage->pbData[i] & bMask ) !=
            ((pAEObjUsage->pbData[i] & bMask )  &
             pCertUsage->pbData[i]))
        {
            goto Failed;
        }
    }



Ret:

    if(wszCertKU)
    {
        AEFree(wszCertKU);
    }

    if(wszTemplateKU)
    {
        AEFree(wszTemplateKU);
    }

    return hr;
Failed:


    // Log a failure of this test

    // Build extension strings
    wszCertKU = HelperExtensionToString(pCertUsageExt);

   /* if(wszCertKU == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Ret;
    }*/

    wszTemplateKU = HelperExtensionToString(pAEObjUsageExt);
   /* if(wszTemplateKU == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Ret;
    }*/

    AELogTestResult(ppAEData,
                    AE_TEST_EXTENSION_KU,
                    wszCertKU ? wszCertKU : g_wszEmptyExtension,
                    wszTemplateKU ? wszTemplateKU : g_wszEmptyExtension);
    goto Ret;

}
//
// Name:    CompareBasicConstraints
//
// Description: This function checks if the basic constraints
//              in a certificate are a superset of the basic
//              constraints from the auto enrollment object (CTL),
//
  
HRESULT CompareBasicConstraints(
                                IN PAE_INSTANCE_INFO pInstance,
                                IN PCCERT_CONTEXT pCertContext,
                                IN OUT PAE_CERT_TEST_ARRAY  *ppAEData
                               )
{
    HRESULT                         hr = S_OK;
    PCERT_EXTENSION                 pCertConstraints;
    CERT_BASIC_CONSTRAINTS2_INFO    CertConstraintInfo = {FALSE, FALSE, 0};   
    PCERT_EXTENSION                 pAEObjConstraints;
    CERT_BASIC_CONSTRAINTS2_INFO    AEObjConstraintInfo = {FALSE, FALSE, 0};
    DWORD                           cb;
    DWORD                           i;

    LPWSTR wszCertBC = NULL;

    LPWSTR wszTemplateBC = NULL;


    // get the basic constraints from the cert
    pCertConstraints = CertFindExtension(szOID_BASIC_CONSTRAINTS2,
                            pCertContext->pCertInfo->cExtension,
                            pCertContext->pCertInfo->rgExtension);

    // get the basic constraints from the auto enrollment obj extensions
    pAEObjConstraints = CertFindExtension(szOID_BASIC_CONSTRAINTS2,
                            pInstance->pCertTypeExtensions->cExtension,
                            pInstance->pCertTypeExtensions->rgExtension);


    // decode the objects
    if(pCertConstraints)
    {
        cb = sizeof(CertConstraintInfo);
        if (!CryptDecodeObject(CRYPT_ASN_ENCODING, szOID_BASIC_CONSTRAINTS2, 
                               pCertConstraints->Value.pbData,
                               pCertConstraints->Value.cbData,
                               0, &CertConstraintInfo, &cb))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto Ret;
        }
    }

    if(pAEObjConstraints)
    {
        cb = sizeof(AEObjConstraintInfo);
        if (!CryptDecodeObject(CRYPT_ASN_ENCODING, szOID_BASIC_CONSTRAINTS2, 
                               pAEObjConstraints->Value.pbData,
                               pAEObjConstraints->Value.cbData,
                               0, &AEObjConstraintInfo, &cb))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto Ret;
        }
    }
    // see if auto enroll obj constraints are the same as the cert's
    if (AEObjConstraintInfo.fCA != CertConstraintInfo.fCA)
    {
        goto Failed;
    }
    if (CertConstraintInfo.fCA)
    {
        if (CertConstraintInfo.fPathLenConstraint !=
            AEObjConstraintInfo.fPathLenConstraint)
        {
            goto Failed;
        }
        if (CertConstraintInfo.fPathLenConstraint)
        {
            if (CertConstraintInfo.dwPathLenConstraint >
                AEObjConstraintInfo.dwPathLenConstraint)
            {
                goto Failed;
            }
        }
    }

Ret:

        // Build extension strings

    if(wszCertBC)
    {
        AEFree(wszCertBC);
    }

    if(wszTemplateBC)
    {
        AEFree(wszTemplateBC);
    }

    
    return hr;
Failed:


    // Log a failure of this test

    // Build extension strings
    wszCertBC = HelperExtensionToString(pCertConstraints);

   /* if(wszCertBC == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Ret;
    }*/

    wszTemplateBC = HelperExtensionToString(pAEObjConstraints);
   /* if(wszTemplateBC == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Ret;
    }*/

    AELogTestResult(ppAEData,
                    AE_TEST_EXTENSION_BC,
                    wszCertBC ? wszCertBC : g_wszEmptyExtension,
                    wszTemplateBC ? wszTemplateBC : g_wszEmptyExtension);
    goto Ret;

}


//
// Name:    VerifyTemplateName
//
// Description: 
//
  
HRESULT VerifyTemplateName(
                             IN PAE_INSTANCE_INFO pInstance,
                             IN PCCERT_CONTEXT pCertContext,
                             IN OUT PAE_CERT_TEST_ARRAY  *ppAEData
                             )
{
    HRESULT hr = S_OK;
    BOOL   fMatch = FALSE;
    PCERT_NAME_VALUE pTemplateName = NULL;



    if(pInstance->dwCertTypeFlags & CT_FLAG_ADD_TEMPLATE_NAME)
    {
        DWORD           cbTemplateName = MAX_TEMPLATE_NAME_VALUE_SIZE;
        BYTE           pbName[MAX_TEMPLATE_NAME_VALUE_SIZE];  // Only needs to be as big as wszDomainController


        PCERT_EXTENSION pCertType = CertFindExtension(szOID_ENROLL_CERTTYPE_EXTENSION,
                                                        pCertContext->pCertInfo->cExtension,
                                                        pCertContext->pCertInfo->rgExtension);


        if(pCertType == NULL)
        {
            goto Failed;
        }
        if(!CryptDecodeObject(X509_ASN_ENCODING,
                          X509_UNICODE_ANY_STRING,
                          pCertType->Value.pbData,
                          pCertType->Value.cbData,
                          0,
                          pbName,
                          &cbTemplateName))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto Ret;
        }
        pTemplateName = (PCERT_NAME_VALUE)pbName;
        if(pTemplateName->Value.pbData == NULL)
        {
            goto Failed;
        }

        if(wcscmp((LPWSTR)  pTemplateName->Value.pbData, pInstance->pwszCertType) != 0)
        {
            goto Failed;
        }
    }


Ret:
    return hr;


Failed:


    {
        WCHAR wszTemplateName[MAX_PATH];
        if(pTemplateName)
        {
            wcscpy(wszTemplateName, (LPWSTR)  pTemplateName->Value.pbData);
        }
        else
        {
            if(!LoadString(g_hInstance, IDS_AUTOENROLL_TEMPLATE_EXT, wszTemplateName, MAX_PATH))
            {
                wcscpy(wszTemplateName, L"No template name");
            }

        }
        AELogTestResult(ppAEData,
                    AE_TEST_EXTENSION_TEMPLATE,
                    wszTemplateName,
                    pInstance->pwszCertType);

    }

    goto Ret;
}

//
// Name:    VerifyCommonExtensions
//
// Description: This function checks if a the extensions in a certificate
//              contain the appropriate extensions from the certificate template
//
  
HRESULT VerifyCommonExtensions(
                     IN PAE_INSTANCE_INFO       pInstance,
                     IN PCCERT_CONTEXT          pCertContext,
                     IN OUT PAE_CERT_TEST_ARRAY  *ppAEData
                     )
{
    HRESULT hr = S_OK;


    AE_BEGIN(L"VerifyCommonExtensions");


    if (S_OK != (hr = CompareEnhancedKeyUsageExtensions(pInstance,
                                                        pCertContext,
                                                        ppAEData)))
    {
        goto Ret;
    }

    // check key usages
    if (S_OK != (hr = CompareKeyUsageExtensions(pInstance,
                                                pCertContext,
                                                ppAEData)))
    {
        goto Ret;
    }


    // check basic constraints
    if (S_OK != (hr = CompareBasicConstraints(pInstance,
                                              pCertContext,
                                              ppAEData)))
    {
        goto Ret;
    }

    // Check to see if the cert extension should be there, and if it matches.
    // check basic constraints
    if (S_OK != (hr = VerifyTemplateName(pInstance,
                                         pCertContext,
                                         ppAEData)))
    {
        goto Ret;
    }



Ret:
    AE_END();
    return hr;
}

//
// Name:    VerifyCertificateNaming
//
// Description: Determine whether the acutal naming information
//              for the user matches that in the certificate.
//
  
HRESULT VerifyCertificateNaming(
                     IN PAE_INSTANCE_INFO           pInstance,
                     IN PCCERT_CONTEXT              pCert,
                     IN OUT PAE_CERT_TEST_ARRAY  *  ppAEData
                     )
{

    HRESULT             hr = S_OK;
    PCERT_NAME_INFO     pInfo = NULL;

    DWORD           cbInfo = 0;
    DWORD           iRDN, iATTR;
    DWORD           iExtension;

    BOOL            fSubjectUPNMatch = FALSE;
    BOOL            fSubjectEmailMatch = FALSE;

    BOOL            fAltSubjectEmailMatch = FALSE;
    BOOL            fDNMatch = FALSE;
    BOOL            fDNSMatch = FALSE;
    BOOL            fObjIDMatch = FALSE;
    BOOL            fAltSubjectUPNMatch = FALSE;

    BOOL            fDisplaySubjectName = FALSE;
    BOOL            fDisplayAltSubjectName = FALSE;

    AE_BEGIN(L"VerifyCertificateNaming");


    // First, check if the cert type specifies enrollee supplied subject name
    if(0 != (pInstance->dwCertTypeFlags & CT_FLAG_ENROLLEE_SUPPLIES_SUBJECT))
    {
        // We don't care what's in the cert, so return.
        goto Ret;
    }

    fSubjectEmailMatch = fAltSubjectEmailMatch = ((pInstance->pInternalInfo->awszEmail == NULL) ||
               (*pInstance->pInternalInfo->awszEmail == NULL));

    fObjIDMatch = (0 == (pInstance->dwCertTypeFlags & CT_FLAG_ADD_OBJ_GUID));

    // Verify the names in the Subject Name


    if(!CryptDecodeObjectEx(pCert->dwCertEncodingType,
                        X509_NAME,
                        pCert->pCertInfo->Subject.pbData,
                        pCert->pCertInfo->Subject.cbData,
                        CRYPT_ENCODE_ALLOC_FLAG,
                        NULL,
                        &pInfo,
                        &cbInfo))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        AE_DEBUG((AE_ERROR, L"Could not decode certificate name (%lx)\n\r", hr));
        goto Ret;
    }

    AE_DEBUG((AE_TRACE, L"Comparing Subject Name\n\r"));

    for(iRDN = 0; iRDN < pInfo->cRDN; iRDN++)
    {
        for(iATTR = 0; iATTR < pInfo->rgRDN[iRDN].cRDNAttr; iATTR++)
        {
            LPTSTR wszRDNAttr = NULL;
            DWORD  cszRDNAttr = 0;

            // Get this name string
            cszRDNAttr = CertRDNValueToStr(pInfo->rgRDN[iRDN].rgRDNAttr[iATTR].dwValueType,
                                           &pInfo->rgRDN[iRDN].rgRDNAttr[iATTR].Value,
                                            NULL,
                                            0);
            if(cszRDNAttr == 0)
            {
                continue;
            }

            wszRDNAttr = AEAlloc(cszRDNAttr * sizeof(TCHAR));
            if(wszRDNAttr == NULL)
            {
                hr = E_OUTOFMEMORY;
                goto Ret;
            }
            cszRDNAttr = CertRDNValueToStr(pInfo->rgRDN[iRDN].rgRDNAttr[iATTR].dwValueType,
                                           &pInfo->rgRDN[iRDN].rgRDNAttr[iATTR].Value,
                                            wszRDNAttr,
                                            cszRDNAttr);
            if(cszRDNAttr == 0)
            {
                // We couldn't convert the name for some reason
                AEFree(wszRDNAttr);
                continue;
            }

            if(strcmp(szOID_COMMON_NAME, pInfo->rgRDN[iRDN].rgRDNAttr[iATTR].pszObjId) == 0)
            {
                // If there are published UPN's, then
                // we should check against those for a match,
                // otherwise, we check against the generated UPN
                if((pInstance->pInternalInfo->awszldap_UPN != NULL) &&
                   (*pInstance->pInternalInfo->awszldap_UPN != NULL))
                {
                    LPTSTR *pwszCurrentName = pInstance->pInternalInfo->awszldap_UPN;
                    while(*pwszCurrentName)
                    {
                        if(_tcscmp(*pwszCurrentName, wszRDNAttr) == 0)
                        {
                            fSubjectUPNMatch = TRUE;
                            break;
                        }
                        pwszCurrentName++;
                    }
                }
                else if(pInstance->pInternalInfo->wszConstructedUPN != NULL)
                {
                    if(_tcscmp(pInstance->pInternalInfo->wszConstructedUPN, wszRDNAttr) == 0)
                    {
                        fSubjectUPNMatch = TRUE;
                    }
                }

            }

            if(strcmp(szOID_RSA_emailAddr, pInfo->rgRDN[iRDN].rgRDNAttr[iATTR].pszObjId) == 0)
            {
                // If there are published e-mails, then
                // we should check against those for a match
                if((pInstance->pInternalInfo->awszEmail != NULL) &&
                   (*pInstance->pInternalInfo->awszEmail != NULL))
                {
                    LPTSTR *pwszCurrentEmail = pInstance->pInternalInfo->awszEmail;
                    while(*pwszCurrentEmail)
                    {
                        if(_tcscmp(*pwszCurrentEmail, wszRDNAttr) == 0)
                        {
                            fSubjectEmailMatch = TRUE;
                            break;
                        }
                        pwszCurrentEmail++;
                    }
                }
                else
                {
                    // We have no e-mail name for this subject, yet there
                    // was one in the cert.
                    fSubjectEmailMatch = FALSE;
                }
            }
            AEFree(wszRDNAttr);
        }
    }



    // Now check the extensions

    for(iExtension = 0; iExtension < pCert->pCertInfo->cExtension; iExtension++)
    {
        if((strcmp(pCert->pCertInfo->rgExtension[iExtension].pszObjId, szOID_SUBJECT_ALT_NAME) == 0) ||
            (strcmp(pCert->pCertInfo->rgExtension[iExtension].pszObjId, szOID_SUBJECT_ALT_NAME2) == 0))
        {
            PCERT_ALT_NAME_INFO pAltName = NULL;
            DWORD               cbAltName = 0;
            DWORD               iAltName;
            // Now, check the AltSubjectName fields.
            if(!CryptDecodeObjectEx(pCert->dwCertEncodingType,
                                X509_ALTERNATE_NAME,
                                pCert->pCertInfo->rgExtension[iExtension].Value.pbData,
                                pCert->pCertInfo->rgExtension[iExtension].Value.cbData,
                                CRYPT_ENCODE_ALLOC_FLAG,
                                NULL,
                                &pAltName,
                                &cbAltName))
            {
                continue;
            }

            for(iAltName = 0; iAltName < pAltName->cAltEntry; iAltName++)
            {
                switch(pAltName->rgAltEntry[iAltName].dwAltNameChoice)
                {
                    case CERT_ALT_NAME_RFC822_NAME:
                        {
                            // If there are published e-mails, then
                            // we should check against those for a match
                            if((pInstance->pInternalInfo->awszEmail != NULL) &&
                               (*pInstance->pInternalInfo->awszEmail != NULL))
                            {
                                LPTSTR *pwszCurrentEmail = pInstance->pInternalInfo->awszEmail;
                                while(*pwszCurrentEmail)
                                {
                                    if(_tcscmp(*pwszCurrentEmail, pAltName->rgAltEntry[iAltName].pwszRfc822Name) == 0)
                                    {
                                        fAltSubjectEmailMatch = TRUE;
                                        break;
                                    }
                                    pwszCurrentEmail++;
                                }
                            }
                            else
                            {
                                fAltSubjectEmailMatch = FALSE;
                            }
                        }
                        break;
                    case CERT_ALT_NAME_DIRECTORY_NAME:
                        {
                            if(CertCompareCertificateName(pCert->dwCertEncodingType,
                                                          &pInstance->pInternalInfo->blobDN,
                                                          &pAltName->rgAltEntry[iAltName].DirectoryName))
                            {
                                fDNMatch = TRUE;
                            }
                        }
                        break;
                    case CERT_ALT_NAME_DNS_NAME:
                        {
                            if(pInstance->pInternalInfo->fMachineEnrollment)
                            {
                                if((pInstance->pInternalInfo->awszldap_UPN != NULL) &&
                                   (*pInstance->pInternalInfo->awszldap_UPN != NULL))
                                {
                                    LPTSTR *pwszCurrentName = pInstance->pInternalInfo->awszldap_UPN;
                                    while(*pwszCurrentName)
                                    {
                                        if(_tcscmp(*pwszCurrentName, pAltName->rgAltEntry[iAltName].pwszDNSName) == 0)
                                        {
                                            fDNSMatch = TRUE;
                                            break;
                                        }
                                        pwszCurrentName++;
                                    }
                                }
                            }
                            else
                            {
                                fDNSMatch = FALSE;
                            }
                        }
                        break;
                    case CERT_ALT_NAME_OTHER_NAME:

                        if(strcmp(pAltName->rgAltEntry[iAltName].pOtherName->pszObjId, 
                            szOID_NTDS_REPLICATION) == 0)
                                  
                        {
                            if(pInstance->dwCertTypeFlags & CT_FLAG_ADD_OBJ_GUID)
                            {
                                // Object ID's should always be the same, so don't compare them
                                // for now.
                                fObjIDMatch = TRUE;
                            }
                            else
                            {
                                // We had an obj-id, but we shouldn't 
                                fObjIDMatch = FALSE;
                            }
                        } else if (strcmp(pAltName->rgAltEntry[iAltName].pOtherName->pszObjId, 
                                    szOID_NT_PRINCIPAL_NAME) == 0)
                        {
                            PCERT_NAME_VALUE    PrincipalNameBlob = NULL;
                            DWORD               PrincipalNameBlobSize = 0;
                            if(CryptDecodeObjectEx(pCert->dwCertEncodingType,
                                                X509_UNICODE_ANY_STRING,
                                                pAltName->rgAltEntry[iAltName].pOtherName->Value.pbData,
                                                pAltName->rgAltEntry[iAltName].pOtherName->Value.cbData,
                                                CRYPT_DECODE_ALLOC_FLAG,
                                                NULL,
                                                (PVOID)&PrincipalNameBlob,
                                                &PrincipalNameBlobSize))
                            {

                                // If there are published UPN's, then
                                // we should check against those for a match,
                                // otherwise, we check against the generated UPN
                                if((pInstance->pInternalInfo->awszldap_UPN != NULL) &&
                                   (*pInstance->pInternalInfo->awszldap_UPN != NULL))
                                {
                                    LPTSTR *pwszCurrentName = pInstance->pInternalInfo->awszldap_UPN;
                                    while(*pwszCurrentName)
                                    {
                                        if(_tcscmp(*pwszCurrentName, 
                                                  (LPWSTR)PrincipalNameBlob->Value.pbData) == 0)
                                        {
                                            fAltSubjectUPNMatch = TRUE;
                                            break;
                                        }
                                        pwszCurrentName++;
                                    }
                                }
                                else if(pInstance->pInternalInfo->wszConstructedUPN != NULL)
                                {
                                    if(_tcscmp(pInstance->pInternalInfo->wszConstructedUPN, 
                                               (LPWSTR)PrincipalNameBlob->Value.pbData) == 0)
                                    {
                                        fAltSubjectUPNMatch = TRUE;
                                    }
                                }
                                LocalFree(PrincipalNameBlob);
                            }

                        }
                        break;
                    default:
                        break;

                }
            }
            LocalFree(pAltName);
        }
    }

    if(((pInstance->pInternalInfo->fMachineEnrollment)?
        ((!fSubjectUPNMatch)||(!fDNSMatch)):
          ((!fSubjectUPNMatch) && (!fAltSubjectUPNMatch))))
    {
        // We didn't find an appropriate UPN in either the subject or alt subject
        DWORD cUPNChars = 0;
        LPWSTR wszUPN = NULL;
        LPTSTR *pwszCurrentName = pInstance->pInternalInfo->awszldap_UPN;
        if(pInstance->pInternalInfo->wszConstructedUPN)
        {
            cUPNChars += wcslen(pInstance->pInternalInfo->wszConstructedUPN)+1;
        }

        while((NULL != pwszCurrentName) && (NULL != *pwszCurrentName))
        {
            cUPNChars += wcslen(*pwszCurrentName++)+1;
        }
        wszUPN = AEAlloc((cUPNChars+1)*sizeof(WCHAR));
        if(wszUPN == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto Ret;
        }
        wszUPN[0] = 0;
        if(pInstance->pInternalInfo->wszConstructedUPN)
        {
            wcscat(wszUPN, pInstance->pInternalInfo->wszConstructedUPN);
            wcscat(wszUPN, L",");
        }
        pwszCurrentName = pInstance->pInternalInfo->awszldap_UPN;
        while((NULL != pwszCurrentName) && (NULL != *pwszCurrentName))
        {
            wcscat(wszUPN, *pwszCurrentName++);
            wcscat(wszUPN, L",");
        }

        // Kill the last ','
        wszUPN[cUPNChars-1] = 0;


        AELogTestResult(ppAEData,
                        pInstance->pInternalInfo->fMachineEnrollment?AE_TEST_NAME_SUBJECT_DNS:AE_TEST_NAME_UPN,
                        wszUPN);
        AEFree(wszUPN);
        fDisplaySubjectName = TRUE;
        fDisplayAltSubjectName = TRUE;
    }

    if((pInstance->dwCertTypeFlags & CT_FLAG_ADD_EMAIL) && 
       ((!fSubjectEmailMatch) || 
       (!fAltSubjectEmailMatch)))
    {
        // We didn't find an appropriate UPN in either the subject or alt subject
        DWORD cEmailChars = 0;
        LPWSTR wszEmail = NULL;
        LPTSTR *pwszCurrentEmail = pInstance->pInternalInfo->awszEmail;
        while((NULL != pwszCurrentEmail) && (NULL != *pwszCurrentEmail))
        {
            cEmailChars += wcslen(*pwszCurrentEmail++)+1;
        }
        wszEmail = AEAlloc((cEmailChars+1)*sizeof(WCHAR));
        if(wszEmail == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto Ret;
        }
        wszEmail[0] = 0;

        pwszCurrentEmail = pInstance->pInternalInfo->awszEmail;
        while((NULL != pwszCurrentEmail) && (NULL != *pwszCurrentEmail))
        {
            wcscat(wszEmail, *pwszCurrentEmail++);
            wcscat(wszEmail, L",");
        }
        // Kill the last ','
        wszEmail[cEmailChars-1] = 0;

        if(!fSubjectEmailMatch && fAltSubjectEmailMatch)
        {
            AELogTestResult(ppAEData,
                        AE_TEST_NAME_SUBJECT_EMAIL,
                        wszEmail);
        }
        else if(!fAltSubjectEmailMatch && fSubjectEmailMatch)
        {
            AELogTestResult(ppAEData,
                        AE_TEST_NAME_ALT_SUBJECT_EMAIL,
                        wszEmail);
        }
        else if((!fAltSubjectEmailMatch) && (!fSubjectEmailMatch))
        {
            AELogTestResult(ppAEData,
                        AE_TEST_NAME_BOTH_SUBJECT_EMAIL,
                        wszEmail);
        }
        
        AEFree(wszEmail);
        if(!fSubjectEmailMatch)
        {
            fDisplaySubjectName = TRUE;
        }
        if(!fAltSubjectEmailMatch)
        {
            fDisplayAltSubjectName = TRUE;
        }

    }

    if((pInstance->dwCertTypeFlags & CT_FLAG_ADD_DIRECTORY_PATH) && 
       (!fDNMatch))
    {
        AELogTestResult(ppAEData,
                    AE_TEST_NAME_DIRECTORY_NAME,
                    pInstance->pInternalInfo->wszDN);
        fDisplayAltSubjectName = TRUE;


    }

    if(!fObjIDMatch)
    {

        AELogTestResult(ppAEData,
            (pInstance->dwCertTypeFlags & CT_FLAG_ADD_OBJ_GUID)?AE_TEST_NAME_NO_OBJID:AE_TEST_NAME_OBJID);
        fDisplayAltSubjectName = TRUE;
    }

    if(fDisplaySubjectName)
    {

        DWORD cNameStr = 0;
        LPWSTR wszNameStr = NULL;
        cNameStr = CertNameToStr(X509_ASN_ENCODING,
                      &pCert->pCertInfo->Subject,
                      CERT_X500_NAME_STR,
                      NULL,
                      0);

        if(cNameStr)
        {
            wszNameStr = (LPWSTR)AEAlloc(cNameStr*sizeof(WCHAR));
            if(wszNameStr == NULL)
            {
                hr = E_OUTOFMEMORY;
                goto Ret;
            }

            cNameStr = CertNameToStr(X509_ASN_ENCODING,
                          &pCert->pCertInfo->Subject,
                          CERT_X500_NAME_STR,
                          wszNameStr,
                          cNameStr);




            AELogTestResult(ppAEData,
                        AT_TEST_SUBJECT_NAME,
                        wszNameStr);
            AEFree(wszNameStr);
        }

    }

    if(fDisplayAltSubjectName)
    {
        DWORD cbFormat = 0;
        LPWSTR wszFormat = NULL;
        for(iExtension = 0; iExtension < pCert->pCertInfo->cExtension; iExtension++)
        {
            if((strcmp(pCert->pCertInfo->rgExtension[iExtension].pszObjId, szOID_SUBJECT_ALT_NAME) == 0) ||
                (strcmp(pCert->pCertInfo->rgExtension[iExtension].pszObjId, szOID_SUBJECT_ALT_NAME2) == 0))
            {


                wszFormat = HelperExtensionToString(&pCert->pCertInfo->rgExtension[iExtension]);

                if(wszFormat == NULL)
                {
                    hr = E_OUTOFMEMORY;
                    goto Ret;
                }


                AELogTestResult(ppAEData,
                        AT_TEST_ALT_SUBJECT_NAME,
                        wszFormat);
                LocalFree(wszFormat);
            }
        }

    }
Ret:
    if(pInfo)
    {
        LocalFree(pInfo);
    }

    return hr;
}


//
// Name:    VerifyCertificateChaining
//
// Description: This function checks if if the certificate has expired, or has been revoked
//
HRESULT VerifyCertificateChaining(
                     IN PAE_INSTANCE_INFO           pInstance,
                     IN PCCERT_CONTEXT              pCert,
                     IN OUT PAE_CERT_TEST_ARRAY  *  ppAEData
                     ) 
{

    HRESULT hr = S_OK;
    HRESULT hrChainStatus = S_OK;

    CERT_CHAIN_PARA             ChainParams;
    CERT_CHAIN_POLICY_PARA      ChainPolicy;
    CERT_CHAIN_POLICY_STATUS    PolicyStatus;
    PCCERT_CHAIN_CONTEXT        pChainContext = NULL;
    PCTL_INFO                   pCTLInfo = NULL;
    LARGE_INTEGER               ftTime;


    AE_BEGIN(L"VerifyCertificateChaining");

    if(*ppAEData)
    {
        (*ppAEData)->fRenewalOK = FALSE;
    }

    pCTLInfo = pInstance->pCTLContext->pCtlInfo;
    // Build the certificate chain for trust
    // operations
    ChainParams.cbSize = sizeof(ChainParams);
    ChainParams.RequestedUsage.dwType = USAGE_MATCH_TYPE_AND;

    ChainParams.RequestedUsage.Usage.cUsageIdentifier = 0;
    ChainParams.RequestedUsage.Usage.rgpszUsageIdentifier = NULL;

    ChainPolicy.cbSize = sizeof(ChainPolicy);
    ChainPolicy.dwFlags = 0;  // ignore nothing
    ChainPolicy.pvExtraPolicyPara = NULL;

    PolicyStatus.cbSize = sizeof(PolicyStatus);
    PolicyStatus.dwError = 0;
    PolicyStatus.lChainIndex = -1;
    PolicyStatus.lElementIndex = -1;
    PolicyStatus.pvExtraPolicyStatus = NULL;

    // Build a small time skew into the chain building in order to deal
    // with servers that may skew slightly fast.
    GetSystemTimeAsFileTime((LPFILETIME)&ftTime);
    ftTime.QuadPart += Int32x32To64(FILETIME_TICKS_PER_SECOND, DEFAULT_AUTOENROLL_SKEW);

    // Build a cert chain for the current status of the cert..
    if(!CertGetCertificateChain(pInstance->pInternalInfo->fMachineEnrollment?HCCE_LOCAL_MACHINE:HCCE_CURRENT_USER,
                                pCert,
                                (LPFILETIME)&ftTime,
                                NULL,
                                &ChainParams,
                                CERT_CHAIN_REVOCATION_CHECK_END_CERT |
                                CERT_CHAIN_REVOCATION_CHECK_CHAIN,
                                NULL,
                                &pChainContext))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        AE_DEBUG((AE_WARNING, L"Could not build certificate chain (%lx)\n\r", hr));

        goto Ret;
    }
    
    if(!CertVerifyCertificateChainPolicy(CERT_CHAIN_POLICY_BASE,
                                          pChainContext,
                                          &ChainPolicy,
                                          &PolicyStatus))
    {
        hrChainStatus = HRESULT_FROM_WIN32(GetLastError());
        AE_DEBUG((AE_WARNING, L"Base Chain Policy failed (%lx) - must get new cert\n\r", PolicyStatus.dwError));
    }
    else
    {
        hrChainStatus = PolicyStatus.dwError;
    }
    if((S_OK ==  hrChainStatus) ||
       (CRYPT_E_NO_REVOCATION_CHECK ==  hrChainStatus) ||
       (CRYPT_E_REVOCATION_OFFLINE ==  hrChainStatus))
    {
        // The cert is still currently acceptable by trust standards,
        // so we can renew it.

        if(NULL == (*ppAEData))
        {
            (*ppAEData) = (PAE_CERT_TEST_ARRAY)LocalAlloc(LMEM_FIXED, sizeof(AE_CERT_TEST_ARRAY) + 
                                            (AE_CERT_TEST_SIZE_INCREMENT - ANYSIZE_ARRAY)*sizeof(AE_CERT_TEST));
            if((*ppAEData) == NULL)
            {
                hr = E_OUTOFMEMORY;
                goto Ret;

            }
            (*ppAEData)->dwVersion = AE_CERT_TEST_ARRAY_VERSION;
            (*ppAEData)->cTests = 0;
            (*ppAEData)->cMaxTests = AE_CERT_TEST_SIZE_INCREMENT;
        }
        (*ppAEData)->fRenewalOK = TRUE;
        hrChainStatus = S_OK;
    }
    else
    {
        LPWSTR wszChainStatus = NULL;
        if(0 == FormatMessage(
                FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
                NULL,
                hrChainStatus,
                MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                (WCHAR *) &wszChainStatus,
                0,
                NULL))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto Ret;
        }
    
        // The cert has expired or has been revoked or something,
        // we must re-enroll
        AELogTestResult(ppAEData,
                    AE_TEST_CHAIN_FAIL,
                    hrChainStatus,
                    wszChainStatus);
        AEFree(wszChainStatus);
        
    }
    // Verify that the immediate CA of the cert exists in the
    // Autoenrollment Object.  Empty ctl's imply any CA is
    // ok.
    if(pCTLInfo->cCTLEntry)
    {
        DWORD i;
        BYTE  pHash[20];
        DWORD cbHash;
        cbHash = sizeof(pHash);
        AE_DEBUG((AE_TRACE, L"Verifying Issuer presence in auto-enrollment object\n\r"));


        if((pChainContext == NULL) ||
            (pChainContext->rgpChain == NULL) ||
            (pChainContext->cChain < 1) ||
            (pChainContext->rgpChain[0]->rgpElement == NULL) ||
            (pChainContext->rgpChain[0]->cElement < 2))
        {
            hr = E_POINTER;
            goto Ret;
        }

        if(!CertGetCertificateContextProperty(pChainContext->rgpChain[0]->rgpElement[1]->pCertContext,
                                          CERT_SHA1_HASH_PROP_ID,
                                          pHash,
                                          &cbHash))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            AE_DEBUG((AE_ERROR, L"Could not get certificate Hash (%lx)\n\r",hr));
            goto Ret;
        }

        for(i=0; i < pCTLInfo->cCTLEntry; i++)
        {
            if(pCTLInfo->rgCTLEntry[i].SubjectIdentifier.pbData == NULL)
                continue;

            if(pCTLInfo->rgCTLEntry[i].SubjectIdentifier.cbData != cbHash)
                continue;

            if(memcmp(pCTLInfo->rgCTLEntry[i].SubjectIdentifier.pbData,
                      pHash,
                      cbHash) == 0)
            {
                break;
            }
        }
        if(i == pCTLInfo->cCTLEntry)
        {
            AE_DEBUG((AE_WARNING, L"Issuer not in auto-enrollment list - must renew\n\r"));

            AELogTestResult(ppAEData,
                            AE_TEST_ISSUER_FAIL);
        }
    }


    if(pChainContext)
    {
        CertFreeCertificateChain(pChainContext);
        pChainContext = NULL;
    }


    // only check expiration status if the cert is otherwise ok
    if(hrChainStatus == S_OK)
    {

        // Nudge the evaluation of the cert chain by the expiration
        // offset so we know if is expired by that time in the future.
        GetSystemTimeAsFileTime((LPFILETIME)&ftTime);
        // Build the certificate chain for trust
        // operations
        ChainParams.cbSize = sizeof(ChainParams);
        ChainParams.RequestedUsage.dwType = USAGE_MATCH_TYPE_AND;

        ChainParams.RequestedUsage.Usage.cUsageIdentifier = 0;
        ChainParams.RequestedUsage.Usage.rgpszUsageIdentifier = NULL;

        if(pInstance->ftExpirationOffset.QuadPart < 0)
        {
            LARGE_INTEGER ftHalfLife;
            ftHalfLife.QuadPart = (((LARGE_INTEGER *)&pCert->pCertInfo->NotAfter)->QuadPart - 
                                   ((LARGE_INTEGER *)&pCert->pCertInfo->NotBefore)->QuadPart)/2;
    

            if(ftHalfLife.QuadPart > (- pInstance->ftExpirationOffset.QuadPart))
            {
                // Assume that the old cert is not time nesting invalid
                ftTime.QuadPart -= pInstance->ftExpirationOffset.QuadPart;
            }
            else
            {
                ftTime.QuadPart += ftHalfLife.QuadPart;
            }
        }
        else
        {
            ftTime = pInstance->ftExpirationOffset;
        }

        // Is this a renewal, or an enroll on behalf of...
        if(!CertGetCertificateChain(pInstance->pInternalInfo->fMachineEnrollment?HCCE_LOCAL_MACHINE:HCCE_CURRENT_USER,
                                    pCert,
                                    (LPFILETIME)&ftTime,
                                    NULL,
                                    &ChainParams,
                                    0,
                                    NULL,
                                    &pChainContext))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            AE_DEBUG((AE_WARNING, L"Could not build certificate chain (%lx)\n\r", hr));

            goto Ret;
        }

        // Verify revocation and expiration of the certificate
        ChainPolicy.cbSize = sizeof(ChainPolicy);
        ChainPolicy.dwFlags = 0;  // ignore nothing
        ChainPolicy.pvExtraPolicyPara = NULL;

        PolicyStatus.cbSize = sizeof(PolicyStatus);
        PolicyStatus.dwError = 0;
        PolicyStatus.lChainIndex = -1;
        PolicyStatus.lElementIndex = -1;
        PolicyStatus.pvExtraPolicyStatus = NULL;

        if(!CertVerifyCertificateChainPolicy(CERT_CHAIN_POLICY_BASE,
                                              pChainContext,
                                              &ChainPolicy,
                                              &PolicyStatus))
        {
            hrChainStatus = HRESULT_FROM_WIN32(GetLastError());
            AE_DEBUG((AE_WARNING, L"Base Chain Policy failed (%lx) - must get new cert\n\r", hr));
        }
        else
        {
            hrChainStatus = PolicyStatus.dwError;
        }

        if((S_OK != hrChainStatus) &&
           (CRYPT_E_NO_REVOCATION_CHECK != hrChainStatus) &&
           (CRYPT_E_REVOCATION_OFFLINE != hrChainStatus))
        {
            // The cert has expired or has been revoked or something,
            // we must re-enroll
            AELogTestResult(ppAEData,
                            AT_TEST_PENDING_EXPIRATION);
        }
    }

Ret:
    if(pChainContext)
    {
        CertFreeCertificateChain(pChainContext);
    }

    AE_END();
    
    return hr;    
}

HRESULT VerifyAutoenrolledCertificate(
                     IN PAE_INSTANCE_INFO           pInstance,
                     IN PCCERT_CONTEXT              pCert,
                     IN OUT PAE_CERT_TEST_ARRAY  *  ppAEData
                     )
{
    HRESULT hr = S_OK;

    hr = VerifyCommonExtensions(pInstance, pCert, ppAEData);
    if(FAILED(hr))
    {
        return hr;
    }

    hr = VerifyCertificateNaming(pInstance, pCert, ppAEData);
    if(FAILED(hr))
    {
        return hr;
    }

    hr = VerifyCertificateChaining(pInstance, pCert, ppAEData);


    return hr;
}


//
// Name:    IsOldCertificateValid
//
// Description: This function checks if the certificate in the pOldCert
//              member is valid to satisfy this auto-enrollment request,
//              or if it should be renewed. 
//
HRESULT IsOldCertificateValid(
                     IN PAE_INSTANCE_INFO pInstance,
                     OUT BOOL *pfNeedNewCert
                     ) 
{

    HRESULT hr = S_OK;

    PAE_CERT_TEST_ARRAY         pAEData = NULL;


    AE_BEGIN(L"IsOldCertificateValid");

    *pfNeedNewCert = TRUE;

    if((pInstance == NULL) ||
       (pInstance->pCTLContext == NULL) ||
       (pInstance->pCTLContext->pCtlInfo == NULL))
    {
        goto Ret;
    }
    pInstance->fRenewalOK = FALSE;


    hr =  VerifyAutoenrolledCertificate(pInstance,
                                        pInstance->pOldCert,
                                        &pAEData);

    if(FAILED(hr))
    {
        goto Ret;
    }

    if(pAEData)
    {
        pInstance->fRenewalOK = pAEData->fRenewalOK;
    }

    // Scan the verification results
    if((pAEData) && (pAEData->cTests > 0))
    {
        BOOL  fFailed = FALSE;
        DWORD cFailureMessage= 0;
        DWORD iFailure;
        LPWSTR wszFailureMessage = NULL;
        LPWSTR wszCurrent;
        DWORD  cTestArray = 0;
        DWORD  cbTestArray = 0;
        DWORD  * aidTestArray = NULL;
        DWORD  iTest;

        if(CertGetCertificateContextProperty(pInstance->pOldCert,
                                          AE_CERT_TEST_ARRAY_PROPID,
                                          NULL,
                                          &cbTestArray))
        {
            aidTestArray = (DWORD *)AEAlloc(cbTestArray);
            CertGetCertificateContextProperty(pInstance->pOldCert,
                                                      AE_CERT_TEST_ARRAY_PROPID,
                                                      aidTestArray,
                                                      &cbTestArray);
            cTestArray = cbTestArray/sizeof(aidTestArray[0]);
        }




        // Check to see of these are ignored failures.

        for(iFailure=0; iFailure < pAEData->cTests; iFailure++)
        {

            if(FAILED(pAEData->Test[iFailure].idTest))
            {
                // Are we ignoring this test?
                for(iTest = 0; iTest < cTestArray; iTest++)
                {
                    if(aidTestArray[iTest] == pAEData->Test[iFailure].idTest)
                        break;
                }
                if(iTest != cTestArray)
                {
                    if(pAEData->Test[iFailure].pwszReason)
                    {
                        LocalFree(pAEData->Test[iFailure].pwszReason);
                    }
                    pAEData->Test[iFailure].pwszReason = NULL;
                    pAEData->Test[iFailure].idTest = S_OK;

                    continue;
                }
                fFailed = TRUE;
            }
            if(pAEData->Test[iFailure].pwszReason)
            {
                cFailureMessage += wcslen(pAEData->Test[iFailure].pwszReason);
            }
        }
        cFailureMessage += 5;
        if(aidTestArray)
        {
            AEFree(aidTestArray);
        }

        if(fFailed)
        {
            wszFailureMessage = (LPWSTR)AEAlloc(cFailureMessage*sizeof(WCHAR));
            if(wszFailureMessage == NULL)
            {
                hr = E_OUTOFMEMORY;
                goto Ret;
            }

            wcscpy(wszFailureMessage, L"\n\r\n\r");
            wszCurrent = wszFailureMessage+2; 

            for(iFailure=0; iFailure < pAEData->cTests; iFailure++)
            {
                if(pAEData->Test[iFailure].pwszReason)
                {
                    wcscpy(wszCurrent, pAEData->Test[iFailure].pwszReason);
                    wszCurrent += wcslen(pAEData->Test[iFailure].pwszReason);
                }
            }

            LogAutoEnrollmentEvent(pInstance->fRenewalOK?
                                    EVENT_OLD_CERT_VERIFY_RENEW_WARNING:
                                    EVENT_OLD_CERT_VERIFY_REENROLL_WARNING,
                                    pInstance->pInternalInfo->hToken,
                                    pInstance->pwszCertType,
                                    wszFailureMessage,
                                    NULL);
            AEFree(wszFailureMessage);
            // Report the event here
            goto Ret;
        }
    }





    *pfNeedNewCert = FALSE;

Ret:

    if(pAEData)
    {

        AEFreeTestResult(&pAEData);
    }

    if(hr != S_OK)
    {
        LogAutoEnrollmentError(hr,
                               EVENT_UAE_VERIFICATION_FAILURE,
                               pInstance->pInternalInfo->fMachineEnrollment,
                               pInstance->pInternalInfo->hToken,
                               pInstance->pwszCertType, NULL);
    }

    AE_END();


    
    return hr;    
}


//
// Name:    IsOldCertificateValid
//
// Description: This function checks if the certificate in the pOldCert
//              member is valid to satisfy this auto-enrollment request,
//              or if it should be renewed. 
//
HRESULT VerifyEnrolledCertificate(
                     IN PAE_INSTANCE_INFO pInstance,
                     IN PCCERT_CONTEXT    pCert
                     ) 
{

    HRESULT hr = S_OK;

    PAE_CERT_TEST_ARRAY         pAEData = NULL;
    CRYPT_DATA_BLOB AETestArray = {0, NULL};

    AE_BEGIN(L"IsOldCertificateValid");
    AETestArray.cbData = 0;
    AETestArray.pbData = NULL;


    if((pInstance == NULL) ||
       (pInstance->pCTLContext == NULL) ||
       (pInstance->pCTLContext->pCtlInfo == NULL))
    {
        goto Ret;
    }
    pInstance->fRenewalOK = FALSE;


    hr =  VerifyAutoenrolledCertificate(pInstance,
                                        pCert,
                                        &pAEData);

    if(FAILED(hr))
    {
        goto Ret;
    }


    // Scan the verification results
    if((pAEData) && (pAEData->cTests > 0))
    {
        BOOL  fFailed = FALSE;
        DWORD cFailureMessage= 0;
        DWORD iFailure;
        LPWSTR wszFailureMessage = NULL;
        LPWSTR wszCurrent;
        DWORD  cTestArray = 0;
        DWORD  iTestArray = 0;

        cTestArray = pAEData->cTests;
        AETestArray.cbData = cTestArray*sizeof(DWORD);

        if(AETestArray.cbData)
        {
            AETestArray.pbData = AEAlloc(AETestArray.cbData);
        }
        else
        {
            AETestArray.pbData = NULL;
        }



        // Check to see of these are ignored failures.

        for(iFailure=0; iFailure < pAEData->cTests; iFailure++)
        {

            if(FAILED(pAEData->Test[iFailure].idTest))
            {
                fFailed = TRUE;
                if(AETestArray.pbData)
                {
                    ((DWORD *)AETestArray.pbData)[iTestArray++] = pAEData->Test[iFailure].idTest;
                }
            }
            if(pAEData->Test[iFailure].pwszReason)
            {
                cFailureMessage += wcslen(pAEData->Test[iFailure].pwszReason);
            }
        }
        cFailureMessage += 5;

        wszFailureMessage = (LPWSTR)AEAlloc(cFailureMessage*sizeof(WCHAR));
        if(wszFailureMessage == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto Ret;
        }

        wcscpy(wszFailureMessage, L"\n\r\n\r");
        wszCurrent = wszFailureMessage+2; 

        for(iFailure=0; iFailure < pAEData->cTests; iFailure++)
        {
            if(pAEData->Test[iFailure].pwszReason)
            {
                wcscpy(wszCurrent, pAEData->Test[iFailure].pwszReason);
                wszCurrent += wcslen(pAEData->Test[iFailure].pwszReason);
            }
        }

        LogAutoEnrollmentEvent(EVENT_ENROLLED_CERT_VERIFY_WARNING,
                                pInstance->pInternalInfo->hToken,
                                pInstance->pwszCertType,
                                wszFailureMessage,
                                NULL);
        AEFree(wszFailureMessage);

        // Report the event here
    }


    CertSetCertificateContextProperty(pCert,
                                      AE_CERT_TEST_ARRAY_PROPID,
                                      0,
                                      AETestArray.pbData?&AETestArray:NULL);



Ret:

    if(pAEData)
    {

        AEFreeTestResult(&pAEData);
    }

    if(hr != S_OK)
    {
        LogAutoEnrollmentError(hr,
                               EVENT_UAE_VERIFICATION_FAILURE,
                               pInstance->pInternalInfo->fMachineEnrollment,
                               pInstance->pInternalInfo->hToken,
                               pInstance->pwszCertType, NULL);
    }

    AE_END();
    
    return hr;    
}

//
// Name:    FindExistingEnrolledCertificate
//
// Description: This function searches for an existing certificate
//              enrolled with this auto-enrollment object.
//
  
BOOL FindExistingEnrolledCertificate(IN PAE_INSTANCE_INFO pInstance,
                                     OUT PCCERT_CONTEXT  *ppCert)
{
    PCCERT_CONTEXT  pCertContext = NULL;
    PCCERT_CONTEXT  pPrevContext = NULL;
    DWORD           i;
    BOOL            fRet = FALSE;

    DWORD           dwEnrollPropId = CERT_AUTO_ENROLL_PROP_ID;


    LPWSTR          wszEnrollmentId = NULL;
    DWORD           cbEnrollmentId = 0;
    DWORD           cbCurrentId=0;

    AE_BEGIN(L"FindExistingEnrolledCertificate");


    if(pInstance->pwszCertType == NULL)
    {
        return FALSE;
    }

    cbEnrollmentId = sizeof(WCHAR) * (wcslen(pInstance->pwszAEIdentifier) + 1);
    wszEnrollmentId = (WCHAR *)AEAlloc(cbEnrollmentId);
    if(wszEnrollmentId == NULL)
    {
        return FALSE;
    }

    if(*ppCert)
    {
        CertFreeCertificateContext(*ppCert);
    }
    *ppCert = NULL;

        // check if cert from CA is in the MY store
     while(pCertContext = CertFindCertificateInStore(
                pInstance->pInternalInfo->hMYStore,
                X509_ASN_ENCODING, 
                0, 
                CERT_FIND_PROPERTY,
                &dwEnrollPropId, 
                pPrevContext))
     {

        pPrevContext = pCertContext;

        // check if this is an auto enroll cert and
        // if the cert type is correct

        cbCurrentId = cbEnrollmentId;
        if(!CertGetCertificateContextProperty(pCertContext,
                                              CERT_AUTO_ENROLL_PROP_ID, 
                                              wszEnrollmentId, 
                                              &cbCurrentId))
        {
            continue;
        }

        if(wcscmp(wszEnrollmentId, pInstance->pwszAEIdentifier) != 0)
        {
            continue;
        }
        AE_DEBUG((AE_INFO, L"Found auto-enrolled certificate for %ls cert\n\r", pInstance->pwszCertType));

        *ppCert = pCertContext;
        pCertContext = NULL;
        break;

    }
    fRet = TRUE; 

    if (pCertContext)
        CertFreeCertificateContext(pCertContext);
    if(wszEnrollmentId)
    {
        AEFree(wszEnrollmentId);
    }
    AE_END();
    return fRet;
}



//
// Name:        
//
// Description: This function calls a function to determine if an auto
//              enrollment is to occur and if so it trys to enroll with
//              different CAs until either an enrollment is successful or
//              the list of CAs is exhausted.
//
  
void EnrollmentWithCTL(
                       IN PAE_INSTANCE_INFO pInstance,
                       IN LDAP *            pld
                       )
{
    INTERNAL_INFO       pInternalInfo;
    BOOL                fNeedToEnroll = FALSE;
    AUTO_ENROLL_INFO    EnrollmentInfo;
    DWORD               *pdwCAEntries = NULL;
    DWORD               i;
    BOOL                fPermitted;
    BOOL                fAnyAcceptableCAs = FALSE;
    DWORD               dwFailureCode = E_FAIL;


    AE_BEGIN(L"EnrollmentWithCTL");

    if(!GetCertTypeInfo(pInstance,
                      pld,
                     &fPermitted))
    {
        goto Ret;
    }
    if(!fPermitted)
    {
        AE_DEBUG((AE_INFO, L"Not permitted to enroll for %ls cert type\n", pInstance->pwszCertType));

        goto Ret;
    }

    if(!FindExistingEnrolledCertificate(pInstance, &pInstance->pOldCert))
    {
        goto Ret;
    }

    if(pInstance->pOldCert)
    {
        if(FAILED(IsOldCertificateValid(pInstance, &fNeedToEnroll)))
        {
            goto Ret;
        }
        if(!fNeedToEnroll)
        {
            goto Ret;
        }
        if(!pInstance->fRenewalOK)
        {
            CRYPT_DATA_BLOB Archived;
            Archived.cbData = 0;
            Archived.pbData = NULL;

            // We force an archive on the old cert and close it.
            CertSetCertificateContextProperty(pInstance->pOldCert,
                                              CERT_ARCHIVED_PROP_ID,
                                              0,
                                              &Archived);
        }
    }

    // It looks like we need to enroll
    // for a cert.  


    do
    {
        // Loop through all avaialble ca's to find one
        // that supports this cert type, and is in our CTL

        for (i=0;i<pInstance->pInternalInfo->ccaList;i++)
        {
            DWORD dwIndex;
            LPWSTR *pwszCertType;
            DWORD iCTL;
            dwIndex = (i + pInstance->dwRandomIndex) % pInstance->pInternalInfo->ccaList;
            AE_DEBUG((AE_TRACE, L"Trying CA %ws\\%ws\n\r", pInstance->pInternalInfo->acaList[dwIndex].wszDNSName, pInstance->pInternalInfo->acaList[dwIndex].wszName));

            // Does this CA support our cert type.
            pwszCertType = pInstance->pInternalInfo->acaList[dwIndex].awszCertificateTemplates;
            if(pwszCertType == NULL)
            {
                AE_DEBUG((AE_TRACE, L"There are no cert types supported on this CA\n\r"));
                continue;
            }
            while(*pwszCertType)
            {
                if(wcscmp(*pwszCertType, pInstance->pwszCertType) == 0)
                {
                    break;
                }
                pwszCertType++;
            }
            if(*pwszCertType == NULL)
            {
                AE_DEBUG((AE_TRACE, L"The cert type %ws is not supported on this CA\n\r", pInstance->pwszCertType));
                continue;
            }

            // Is this CA in our CTL List
            if(pInstance->pCTLContext->pCtlInfo->cCTLEntry > 0)
            {
                for(iCTL = 0; iCTL < pInstance->pCTLContext->pCtlInfo->cCTLEntry; iCTL++)
                {
                    PCTL_ENTRY pEntry= &pInstance->pCTLContext->pCtlInfo->rgCTLEntry[iCTL];

                    if(pEntry->SubjectIdentifier.cbData != sizeof(pInstance->pInternalInfo->acaList[dwIndex].CACertHash))
                    {
                        continue;
                    }

                    if(memcmp(pEntry->SubjectIdentifier.pbData, 
                              pInstance->pInternalInfo->acaList[dwIndex].CACertHash, 
                              pEntry->SubjectIdentifier.cbData) == 0)
                    {
                        break;
                    }         
                }
                if(iCTL == pInstance->pCTLContext->pCtlInfo->cCTLEntry)
                {
                    AE_DEBUG((AE_TRACE, L"The CA is not supported by the auto-enrollment object\n\r"));
                    continue;
                }
            }

            ZeroMemory(&EnrollmentInfo, sizeof(EnrollmentInfo));

            // Yes, we may enroll at this CA!
            fAnyAcceptableCAs = TRUE;

            EnrollmentInfo.pwszCAMachine = pInstance->pInternalInfo->acaList[dwIndex].wszDNSName;
            EnrollmentInfo.pwszCAAuthority = pInstance->pInternalInfo->acaList[dwIndex].wszName;
            EnrollmentInfo.pszAutoEnrollProvider = DEFAULT_AUTO_ENROLL_PROV;
            EnrollmentInfo.fRenewal = pInstance->fRenewalOK && (pInstance->pOldCert != NULL);



            if(!SetEnrollmentCertType(pInstance, &EnrollmentInfo))
            {
                AE_DEBUG((AE_TRACE, L"SetEnrollmentCertType failed\n\r"));
                continue;
            }
        

            // load the provider and call the entry point
            if (LoadAndCallEnrollmentProvider(pInstance->pInternalInfo->fMachineEnrollment,
                                              &EnrollmentInfo))
            {
                PCCERT_CONTEXT pNewCert = NULL;
                // Succeeded, 
                // verify the cert that was retrieved
                if(!FindExistingEnrolledCertificate(pInstance, &pNewCert))
                {
                    continue;
                }
                
                VerifyEnrolledCertificate(pInstance, pNewCert);

                CertFreeCertificateContext(pNewCert);

                break;
            }
        }

        if(i == pInstance->pInternalInfo->ccaList)
        {
            // 
            // If we have a preexisting cert, then we may need to try twice, first
            // to renew, and then to re-enroll

            if(pInstance->pOldCert)
            {

                // Try again, but re-enrolling this time
                CRYPT_DATA_BLOB Archived;
                Archived.cbData = 0;
                Archived.pbData = NULL;

                // We force an archive on the old cert and close it.
                CertSetCertificateContextProperty(pInstance->pOldCert,
                                                  CERT_ARCHIVED_PROP_ID,
                                                  0,
                                                  &Archived);
                CertFreeCertificateContext(pInstance->pOldCert);
                pInstance->pOldCert = NULL;
                pInstance->fRenewalOK = FALSE;
                continue;
            }


            AE_DEBUG((AE_WARNING, L"Auto-enrollment not performed\n\r"));
            break;
            // failed
        }
        else
        {
            break;
        }

    } while (TRUE);
Ret:
    AE_END();
    return;
}

#define SHA1_HASH_LENGTH    20

PCCERT_CONTEXT FindCertificateInOtherStore(
    IN HCERTSTORE hOtherStore,
    IN PCCERT_CONTEXT pCert
    )
{
    BYTE rgbHash[SHA1_HASH_LENGTH];
    CRYPT_DATA_BLOB HashBlob;

    HashBlob.pbData = rgbHash;
    HashBlob.cbData = SHA1_HASH_LENGTH;
    if (!CertGetCertificateContextProperty(
            pCert,
            CERT_SHA1_HASH_PROP_ID,
            rgbHash,
            &HashBlob.cbData
            ) || SHA1_HASH_LENGTH != HashBlob.cbData)
        return NULL;

    return CertFindCertificateInStore(
            hOtherStore,
            0,                  // dwCertEncodingType
            0,                  // dwFindFlags
            CERT_FIND_SHA1_HASH,
            (const void *) &HashBlob,
            NULL                //pPrevCertContext
            );
}

//
// Name:    UpdateEnterpriseRoots
//
// Description: This function enumerates all of the roots in the DS based
// enterprise root store, and moves them into the local machine root store.
//

HRESULT WINAPI UpdateEnterpriseRoots(LDAP *pld)
{

    HRESULT hr = S_OK;
    LPWSTR wszLdapRootStore = NULL;
    LPWSTR wszConfig = NULL;
    HCERTSTORE hEnterpriseRoots = NULL,
               hRootStore = NULL;
    PCCERT_CONTEXT pContext = NULL,
                   pOtherCert = NULL;

    static  LPWSTR s_wszEnterpriseRoots =  L"ldap:///CN=Certification Authorities,CN=Public Key Services,CN=Services,%ws?cACertificate?one?objectCategory=certificationAuthority";

    hr = myGetConfigDN(pld, &wszConfig);
    if(hr != S_OK)
    {
        goto error;
    }


    wszLdapRootStore = (LPWSTR)LocalAlloc(LMEM_FIXED, sizeof(WCHAR)*(wcslen(wszConfig)+wcslen(s_wszEnterpriseRoots)));
    if(wszLdapRootStore == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto error;
    }

    wsprintf(wszLdapRootStore, 
             s_wszEnterpriseRoots,
             wszConfig);

    
    hRootStore = CertOpenStore( CERT_STORE_PROV_SYSTEM_REGISTRY_W, 
                                0, 
                                0, 
                                CERT_SYSTEM_STORE_LOCAL_MACHINE_ENTERPRISE, 
                                L"ROOT");
    if(hRootStore == NULL)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        AE_DEBUG((AE_ERROR, L"Unable to open ROOT store (%lx)\n\r", hr));
        goto error;
    }

    hEnterpriseRoots = CertOpenStore(CERT_STORE_PROV_LDAP, 
                  0,
                  0,
                  CERT_STORE_READONLY_FLAG,
                  wszLdapRootStore);
    
    if(hEnterpriseRoots == NULL)
    {
        DWORD err = GetLastError();

        // Checking against NO_SUCH_OBJECT 
        // is a workaround for the fact that 
        // the ldap provider returns LDAP errors
        if((err == LDAP_NO_SUCH_OBJECT) ||
           (err == ERROR_FILE_NOT_FOUND))
        {
            // There was no store, so there are no certs
            hr = S_OK;
            goto error;
        }


        hr = HRESULT_FROM_WIN32(err);

        AE_DEBUG((AE_ERROR, L"Unable to open ROOT store (%lx)\n\r", hr));
        goto error;
    }


    while(pContext = CertEnumCertificatesInStore(hEnterpriseRoots, pContext))
    {
        if (pOtherCert = FindCertificateInOtherStore(hRootStore, pContext)) {
            CertFreeCertificateContext(pOtherCert);
        } 
        else
        {
            CertAddCertificateContextToStore(hRootStore,
                                         pContext,
                                         CERT_STORE_ADD_ALWAYS,
                                         NULL);
        }
    }

    while(pContext = CertEnumCertificatesInStore(hRootStore, pContext))
    {
        if (pOtherCert = FindCertificateInOtherStore(hEnterpriseRoots, pContext)) {
            CertFreeCertificateContext(pOtherCert);
        } 
        else
        {
            CertDeleteCertificateFromStore(CertDuplicateCertificateContext(pContext));
        }
    }


error:

    if(hr != S_OK)
    {
            LogAutoEnrollmentError(hr,
                                   EVENT_UPDATE_ENTERPRISE_ROOT_FAILURE,
                                   TRUE,
                                   NULL,
                                   NULL, NULL);

    }

    if(wszLdapRootStore)
    {
        LocalFree(wszLdapRootStore);
    }

    if(wszConfig)
    {
        LocalFree(wszConfig);
    }
    if(hEnterpriseRoots)
    {
        CertCloseStore(hEnterpriseRoots,0);
    }
    if(hRootStore)
    {
        CertCloseStore(hRootStore,0);
    }

    return hr;
}

//
// Name:    UpdateNTAuthTrust
//
// Description: This function enumerates all of the roots in the DS based
// NTAuth store, and moves them into the local machine NTAuth.
//

HRESULT WINAPI UpdateNTAuthTrust(LDAP *pld)
{

    HRESULT hr = S_OK;
    LPWSTR wszNTAuth = NULL;
    LPWSTR wszConfig = NULL;
    HCERTSTORE hDSAuthRoots = NULL,
               hAuthStore = NULL;
    PCCERT_CONTEXT pContext = NULL,
                   pOtherCert = NULL;

    static  LPWSTR s_wszNTAuthRoots =  L"ldap:///CN=Public Key Services,CN=Services,%ws?cACertificate?one?cn=NTAuthCertificates";

    hr = myGetConfigDN(pld, &wszConfig);
    if(hr != S_OK)
    {
        goto error;
    }


    wszNTAuth = (LPWSTR)LocalAlloc(LMEM_FIXED, sizeof(WCHAR)*(wcslen(wszConfig)+wcslen(s_wszNTAuthRoots)));
    if(wszNTAuth == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto error;
    }

    wsprintf(wszNTAuth, 
             s_wszNTAuthRoots,
             wszConfig);

    
    hAuthStore = CertOpenStore( CERT_STORE_PROV_SYSTEM_REGISTRY_W, 
                                0, 
                                0, 
                                CERT_SYSTEM_STORE_LOCAL_MACHINE_ENTERPRISE, 
                                L"NTAuth");
    if(hAuthStore == NULL)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        AE_DEBUG((AE_ERROR, L"Unable to open NTAuth store (%lx)\n\r", hr));
        goto error;
    }

    hDSAuthRoots = CertOpenStore(CERT_STORE_PROV_LDAP, 
                  0,
                  0,
                  CERT_STORE_READONLY_FLAG,
                  wszNTAuth);
    
    if(hDSAuthRoots == NULL)
    {
         DWORD err = GetLastError();
       // Checking against NO_SUCH_OBJECT 
        // is a workaround for the fact that 
        // the ldap provider returns LDAP errors
        if((err == LDAP_NO_SUCH_OBJECT) ||
           (err == ERROR_FILE_NOT_FOUND))
        {
            // There was no store, so there are no certs
            hr = S_OK;
            goto error;
        }
        
        hr = HRESULT_FROM_WIN32(err);
        AE_DEBUG((AE_ERROR, L"Unable to open ROOT store (%lx)\n\r", hr));
        goto error;
    }


    while(pContext = CertEnumCertificatesInStore(hDSAuthRoots, pContext))
    {
        if (pOtherCert = FindCertificateInOtherStore(hAuthStore, pContext)) {
            CertFreeCertificateContext(pOtherCert);
        } 
        else
        {
            CertAddCertificateContextToStore(hAuthStore,
                                         pContext,
                                         CERT_STORE_ADD_ALWAYS,
                                         NULL);
        }
    }


    while(pContext = CertEnumCertificatesInStore(hAuthStore, pContext))
    {
        if (pOtherCert = FindCertificateInOtherStore(hDSAuthRoots, pContext)) {
            CertFreeCertificateContext(pOtherCert);
        } 
        else
        {
            CertDeleteCertificateFromStore(CertDuplicateCertificateContext(pContext));
        }
    }


error:
    if(hr != S_OK)
    {
            LogAutoEnrollmentError(hr,
                                   EVENT_UPDATE_NTAUTH_FAILURE,
                                   TRUE,
                                   NULL,
                                   NULL, NULL);

    }
    
    if(wszNTAuth)
    {
        LocalFree(wszNTAuth);
    }

    if(wszConfig)
    {
        LocalFree(wszConfig);
    }
    if(hDSAuthRoots)
    {
        CertCloseStore(hDSAuthRoots,0);
    }
    if(hAuthStore)
    {
        CertCloseStore(hAuthStore,0);
    }

    return hr;
}

//
// Name:    ProcessAutoEnrollment
//
// Description: This function retrieves the appropriate auto enrollment
//              objects (CTLs) and then calls a function to proceed with
//              auto enrollment for each of the objects.

//

DWORD WINAPI ProcessAutoEnrollment(
                                        BOOL   fMachineEnrollment,
                                        HANDLE hToken
                                        )
{
    DWORD                       i;
    DWORD                       dwOpenStoreFlags = CERT_SYSTEM_STORE_LOCAL_MACHINE | CERT_STORE_READONLY_FLAG;
    HCERTSTORE                  hACRSStore = 0;
    PCCTL_CONTEXT               pCTLContext = NULL;
    PCCTL_CONTEXT               pPrevCTLContext = NULL;
    CTL_FIND_USAGE_PARA         CTLFindUsage;
    LPSTR                       pszCTLUsageOID;
    CERT_PHYSICAL_STORE_INFO    PhysicalStoreInfo;
    DWORD                       dwRet = 0;
    INTERNAL_INFO               InternalInfo;
    BOOL                        fInitialized = FALSE;
    LDAP                        *pld = NULL;



    __try
    {
        AE_DEBUG((AE_TRACE, L"ProcessAutoEnrollment:%ls\n\r", fMachineEnrollment?L"Machine":L"User"));
        memset(&InternalInfo, 0, sizeof(InternalInfo));
    
        memset(&PhysicalStoreInfo, 0, sizeof(PhysicalStoreInfo));
        memset(&CTLFindUsage, 0, sizeof(CTLFindUsage));
        CTLFindUsage.cbSize = sizeof(CTLFindUsage);

        // since this is a user we need to impersonate the user
        if (!fMachineEnrollment)
        {
            if (hToken)
            {
                if (!ImpersonateLoggedOnUser(hToken))
                {
                    dwRet = GetLastError();
                    AE_DEBUG((AE_ERROR, L"Could not impersonate user: (%lx)\n\r", dwRet));
                    LogAutoEnrollmentError(HRESULT_FROM_WIN32(dwRet),
                                           EVENT_AE_SECURITY_INIT_FAILED,
                                           fMachineEnrollment,
                                           hToken,
                                           NULL, NULL);

                    goto Ret;
                }
            }
        }


        if(fMachineEnrollment)
        {
            dwRet = aeRobustLdapBind(&pld, FALSE);
            if(dwRet != S_OK)
            {
                goto Ret;
            }

            UpdateEnterpriseRoots(pld);
            UpdateNTAuthTrust(pld);
        }



        // if the auto enrollment is for a user then we need to shut off inheritance
        // from the local machine store so that we don't try and enroll for certs
        // which are meant to be for the machine
        if (!fMachineEnrollment)
        {
		    dwOpenStoreFlags = CERT_SYSTEM_STORE_CURRENT_USER | CERT_STORE_READONLY_FLAG;

            PhysicalStoreInfo.cbSize = sizeof(PhysicalStoreInfo);
            PhysicalStoreInfo.dwFlags = CERT_PHYSICAL_STORE_OPEN_DISABLE_FLAG;

            if (!CertRegisterPhysicalStore(L"ACRS", 
                                           CERT_SYSTEM_STORE_CURRENT_USER,
                                           CERT_PHYSICAL_STORE_LOCAL_MACHINE_NAME, 
                                           &PhysicalStoreInfo,
                                           NULL))
            {
                dwRet = GetLastError();
                AE_DEBUG((AE_ERROR, L"Could not register ACRS store: (%lx)\n\r", dwRet ));
                LogAutoEnrollmentError(HRESULT_FROM_WIN32(dwRet),
                                       EVENT_AE_LOCAL_CYCLE_INIT_FAILED,
                                       fMachineEnrollment,
                                       hToken,
                                       NULL, NULL);
                goto Ret;
            }
        }

        // open the ACRS store and fine the CTL based on the auto enrollment usage
        if (0 == (hACRSStore = CertOpenStore(CERT_STORE_PROV_SYSTEM_W,
                                              0, 0, dwOpenStoreFlags, L"ACRS")))
        {
            dwRet = GetLastError();
            AE_DEBUG((AE_ERROR, L"Could not open ACRS store: (%lx)\n\r", dwRet ));
            LogAutoEnrollmentError(HRESULT_FROM_WIN32(dwRet),
                                   EVENT_AE_LOCAL_CYCLE_INIT_FAILED,
                                   fMachineEnrollment,
                                   hToken,
                                   NULL, NULL);
            goto Ret;
        }

        // look for the Auto Enrollment usage
        CTLFindUsage.SubjectUsage.cUsageIdentifier = 1;
        pszCTLUsageOID = szOID_AUTO_ENROLL_CTL_USAGE;
        CTLFindUsage.SubjectUsage.rgpszUsageIdentifier = &pszCTLUsageOID;
  
        for (i=0;;i++)
        {
            AE_INSTANCE_INFO Instance;

            memset(&Instance, 0, sizeof(Instance));

            if (NULL == (pCTLContext = CertFindCTLInStore(hACRSStore,
                                                         X509_ASN_ENCODING,
                                                         CTL_FIND_SAME_USAGE_FLAG,
                                                         CTL_FIND_USAGE,
                                                         &CTLFindUsage,
                                                         pPrevCTLContext)))
            {
                // Freed by CertFindCTLInStore.
                pPrevCTLContext = NULL;
                break;
            }
            pPrevCTLContext = pCTLContext;

            if(!fInitialized)
            {
                if(pld == NULL)
                {   dwRet = aeRobustLdapBind(&pld, FALSE);
                    if(dwRet != S_OK)
                    {
                        goto Ret;
                    }
                }
                // Initialize the internal information needed for an auto enrollment
                if (S_OK != (dwRet = InitInternalInfo(pld,
                                                      fMachineEnrollment,
                                                      hToken, 
                                                      &InternalInfo)))
                {
                    break;
                }
                if(InternalInfo.ccaList == 0)
                {
                    // No CA's
                    break;
                }
                fInitialized = TRUE;
            }

            if(!InitInstance(pPrevCTLContext,
                                &InternalInfo,
                                &Instance))
            {
                dwRet = E_FAIL;
                break;
            }
               // UNDONE - perform a WinVerifyTrust check on this auto
            // enrollment object (CTL) to make sure it is trusted

            // have a CTL so do the Enrollment
            EnrollmentWithCTL(&Instance, pld);

            FreeInstance(&Instance);
        }
    }
    __except ( dwRet = GetExceptionError(GetExceptionInformation()), EXCEPTION_EXECUTE_HANDLER )
    {
        AE_DEBUG((AE_ERROR, L"Exception Caught (%lx)\n\r", dwRet ));
        goto Ret;
    }
Ret:
    __try
    {


        FreeInternalInfo(&InternalInfo);


        if(pPrevCTLContext)
        {
            CertFreeCTLContext(pPrevCTLContext);
        }
        if (hACRSStore)
            CertCloseStore(hACRSStore, 0);
        if (hToken)
        {
            if (!fMachineEnrollment)
            {
                RevertToSelf();
            }
        }
        if(pld != NULL)
        {
            g_pfnldap_unbind(pld);
        }
        AE_END();
    }
    __except ( dwRet = GetExceptionError(GetExceptionInformation()), EXCEPTION_EXECUTE_HANDLER )
    {

        return dwRet;
    }
    return dwRet;
}



//*************************************************************
//
//  AutoEnrollmentThread()
//
//  Purpose:    Background thread for AutoEnrollment.
//
//  Parameters: pInfo   - AutoEnrollment info
//
//  Return:     0
//
//*************************************************************

VOID AutoEnrollmentThread (PVOID pVoid, BOOLEAN fTimeout)
{
    HINSTANCE hInst;
    HKEY hKey;
    HKEY hCurrent ;
    DWORD dwType, dwSize, dwResult;
    LONG lTimeout;
    LARGE_INTEGER DueTime;
    PAUTO_ENROLL_THREAD_INFO pInfo = pVoid;
    DWORD   dwWaitResult;
    // This is executed in a worker thread, so we need to be safe.

    AE_BEGIN(L"AutoEnrollmentThread");

    if(fTimeout)
    {
        AE_END();
        return ;
    }

    dwWaitResult = WaitForSingleObject(pInfo->fMachineEnrollment?g_hMachineMutex:g_hUserMutex, 0);

    if((dwWaitResult == WAIT_FAILED) ||
        (dwWaitResult == WAIT_TIMEOUT))
    {
        AE_DEBUG((AE_ERROR, L"Mutex Contention\n\r" ));
        AE_END();
        return;
    }

    __try
    {


        // Process the auto-enrollment.
        ProcessAutoEnrollment(
                              pInfo->fMachineEnrollment,
                              pInfo->hToken
                              );
        


        // 
        // Build a timer event to ping us
        // in about 8 hours if we don't get
        // notified.


        lTimeout = AE_DEFAULT_REFRESH_RATE;


        //
        // Query for the refresh timer value
        //
        hCurrent = HKEY_LOCAL_MACHINE ;

        if (pInfo->fMachineEnrollment || NT_SUCCESS( RtlOpenCurrentUser( KEY_READ, &hCurrent ) ) )
        {

            if (RegOpenKeyEx (hCurrent,
                              SYSTEM_POLICIES_KEY,
                              0, KEY_READ, &hKey) == ERROR_SUCCESS) {

                dwSize = sizeof(lTimeout);
                RegQueryValueEx (hKey,
                                 TEXT("AutoEnrollmentRefreshTime"),
                                 NULL,
                                 &dwType,
                                 (LPBYTE) &lTimeout,
                                 &dwSize);

                RegCloseKey (hKey);
            }

            if (!pInfo->fMachineEnrollment)
            {
                RegCloseKey( hCurrent );
            }
        }


        //
        // Limit the timeout to once every 1080 hours (45 days)
        //

        if (lTimeout >= 1080) {
            lTimeout = 1080;
        }

        if (lTimeout < 0) {
            lTimeout = 0;
        }


        //
        // Convert hours to milliseconds
        //

        lTimeout =  lTimeout * 60 * 60 * 1000;


        //
        // Special case 0 milliseconds to be 7 seconds
        //

        if (lTimeout == 0) {
            lTimeout = 7000;
        }


        DueTime.QuadPart = Int32x32To64(-10000, lTimeout);

        if(!SetWaitableTimer (pInfo->hTimer, &DueTime, 0, NULL, 0, FALSE))
        {
            AE_DEBUG((AE_WARNING, L"Could not reset timer (%lx)\n\r", GetLastError()));
        }
    }
    __except ( EXCEPTION_EXECUTE_HANDLER )
    {
    }
    ReleaseMutex(pInfo->fMachineEnrollment?g_hMachineMutex:g_hUserMutex);
    AE_END();
    return ;
}

//*************************************************************
//
//  AutoEnrollmentWorker()
//
//  Purpose:    Called by the worker thread mechanism to launch an auto-enrollment thread.
//
//  Parameters: pInfo   - AutoEnrollment info
//
//  Return:     0
//
//*************************************************************

/*VOID AutoEnrollmentWorker (PVOID pVoid, BOOLEAN fTimeout)
{
    if(fTimeout)
    {
        return ;
    }

}*/


//+---------------------------------------------------------------------------
//
//  Function:   StartAutoEnrollThread
//
//  Synopsis:   Starts a thread which causes Autoenrollment
//
//  Arguments:  
//              fMachineEnrollment - indicates if enrolling for a machine
//
//  History:    01-11-98   jeffspel   Created
//
//  Notes:
//
//----------------------------------------------------------------------------


HANDLE RegisterAutoEnrollmentProcessing(
                               IN BOOL fMachineEnrollment,
                               IN HANDLE hToken
                               )
{
    DWORD                       dwThreadId;
    HANDLE                      hWait = 0;
    PAUTO_ENROLL_THREAD_INFO    pThreadInfo = NULL;
    TCHAR szEventName[60];
    LARGE_INTEGER DueTime;
    HKEY          hKeySafeBoot = NULL;
    DWORD         dwStatus = ERROR_SUCCESS;
    
    SECURITY_ATTRIBUTES sa = {0,NULL, FALSE};
    AE_DEBUG((AE_TRACE, L"RegisterAutoEnrollmentProcessing:%ls\n\r",fMachineEnrollment?L"Machine":L"User"));
    __try
    {


        //
        // We don't do autoenrollment in safe boot
        //

        // copied from the service controller code
        dwStatus = RegOpenKey(HKEY_LOCAL_MACHINE,
                              L"system\\currentcontrolset\\control\\safeboot\\option",
                              &hKeySafeBoot);

        if (dwStatus == ERROR_SUCCESS) {

            DWORD dwSafeBoot = 0;
            DWORD cbSafeBoot = sizeof(dwSafeBoot);
            //
            // we did in fact boot under safeboot control
            //

            dwStatus = RegQueryValueEx(hKeySafeBoot,
                                       L"OptionValue",
                                       NULL,
                                       NULL,
                                       (LPBYTE)&dwSafeBoot,
                                       &cbSafeBoot);

            if (dwStatus != ERROR_SUCCESS) 
			{
                dwSafeBoot = 0;
            }

			RegCloseKey(hKeySafeBoot);

            if(dwSafeBoot)
            {
                goto error;
            }
        }

            
        if((g_hInstSecur32 == NULL) ||
            (g_hInstWldap32 == NULL))
        {
            goto error;
        }

        if (NULL == (pThreadInfo = AEAlloc(sizeof(AUTO_ENROLL_THREAD_INFO))))
        {
            goto error;
        }

        ZeroMemory(pThreadInfo, sizeof(AUTO_ENROLL_THREAD_INFO));

        pThreadInfo->fMachineEnrollment = fMachineEnrollment;

        // if this is a user auto enrollment then duplicate the thread token
        if (!pThreadInfo->fMachineEnrollment)
        {
            if (!DuplicateToken(hToken, SecurityImpersonation,
                                &pThreadInfo->hToken))
            {
                AE_DEBUG((AE_ERROR, L"Could not acquire user token: (%lx)\n\r", GetLastError()));
                goto error;
            }

        }



        sa.nLength = sizeof(sa);
        sa.bInheritHandle = FALSE;
        sa.lpSecurityDescriptor = AEMakeGenericSecurityDesc();

        pThreadInfo->hNotifyEvent = CreateEvent(&sa, FALSE, FALSE, fMachineEnrollment?
                                                                     MACHINE_AUTOENROLLMENT_TRIGGER_EVENT:
                                                                     USER_AUTOENROLLMENT_TRIGGER_EVENT);

        if(sa.lpSecurityDescriptor)
        {
            LocalFree(sa.lpSecurityDescriptor);
        }


        if(pThreadInfo->hNotifyEvent == NULL)
        {
            AE_DEBUG((AE_ERROR, L"Could not create GPO Notification Event: (%lx)\n\r", GetLastError()));
            goto error;
        }
        if(!RegisterGPNotification(pThreadInfo->hNotifyEvent,
                                   pThreadInfo->fMachineEnrollment))
        {
            AE_DEBUG((AE_ERROR, L"Could not register for GPO Notification: (%lx)\n\r", GetLastError()));
            goto error;

        }

        if(pThreadInfo->fMachineEnrollment)
        {
            wsprintf (szEventName, TEXT("AUTOENRL: machine refresh timer for %d:%d"),
                  GetCurrentProcessId(), GetCurrentThreadId());
        }
        else
        {
            wsprintf (szEventName, TEXT("AUTOENRL: user refresh timer for %d:%d"),
                  GetCurrentProcessId(), GetCurrentThreadId());
        }
        pThreadInfo->hTimer = CreateWaitableTimer (NULL, FALSE, szEventName);


        if(pThreadInfo->hTimer == NULL)
        {
            goto error;
        }

        if (! RegisterWaitForSingleObject(&pThreadInfo->hNotifyWait,
                                          pThreadInfo->hNotifyEvent, 
                                          AutoEnrollmentThread,
                                          (PVOID)pThreadInfo, 
                                          INFINITE,
                                          0))
        {
            AE_DEBUG((AE_ERROR, L"RegisterWait failed: (%lx)\n\r", GetLastError() ));
            goto error;
        }


         if (! RegisterWaitForSingleObject(&pThreadInfo->hTimerWait,
                     pThreadInfo->hTimer, 
                     AutoEnrollmentThread,
                     (void*)pThreadInfo,
                     INFINITE,
                     0))
        {
            AE_DEBUG((AE_ERROR, L"RegisterWait failed: (%lx)\n\r", GetLastError()));
            goto error;
        }

        // Seed the timer with about 5 minutes, so we can come back
        // and run an auto-enroll later without blocking this thread.

         DueTime.QuadPart = Int32x32To64(-10000,  
                                         (fMachineEnrollment?MACHINE_AUTOENROLL_INITIAL_DELAY:
                                                            USER_AUTOENROLL_INITIAL_DELAY)
                                          * 1000);
        if(!SetWaitableTimer (pThreadInfo->hTimer, &DueTime, 0, NULL, 0, FALSE))
        {
            AE_DEBUG((AE_WARNING, L"Could not reset timer (%lx)\n\r", GetLastError()));
        }
        
    }
    __except ( EXCEPTION_EXECUTE_HANDLER )
    {
        goto error;
    }
    
    AE_RETURN(pThreadInfo);

error:

    if(pThreadInfo)
    {
        if(pThreadInfo->hTimerWait)
        {
            UnregisterWaitEx(pThreadInfo->hTimerWait, INVALID_HANDLE_VALUE );
        }
        if(pThreadInfo->hTimer)
        {
            CloseHandle(pThreadInfo->hTimer);
        }
        if(pThreadInfo->hNotifyWait)
        {
            UnregisterWaitEx(pThreadInfo->hNotifyWait, INVALID_HANDLE_VALUE);
        }
        if(pThreadInfo->hNotifyEvent)
        {
            CloseHandle(pThreadInfo->hNotifyEvent);
        }
        if(pThreadInfo->hToken)
        {
            CloseHandle(pThreadInfo->hToken);
        }

        AEFree(pThreadInfo);
    
    }
    
    AE_RETURN(NULL);
} 

BOOL DeRegisterAutoEnrollment(HANDLE hAuto)
{
    PAUTO_ENROLL_THREAD_INFO    pThreadInfo = (PAUTO_ENROLL_THREAD_INFO)hAuto;

    if(pThreadInfo == NULL)
    {
        return FALSE;
    }
    if(pThreadInfo->hTimerWait)
    {
        UnregisterWaitEx(pThreadInfo->hTimerWait, INVALID_HANDLE_VALUE);
    }
    if(pThreadInfo->hTimer)
    {
        CloseHandle(pThreadInfo->hTimer);
    }

    if(pThreadInfo->hNotifyWait)
    {
        UnregisterWaitEx(pThreadInfo->hNotifyWait, INVALID_HANDLE_VALUE );
    }

    if(pThreadInfo->hNotifyEvent)
    {
        UnregisterGPNotification(pThreadInfo->hNotifyEvent);
        CloseHandle(pThreadInfo->hNotifyEvent);
    }
    if(pThreadInfo->hToken)
    {
        CloseHandle(pThreadInfo->hToken);
    }

    AEFree(pThreadInfo);
    return TRUE;

}


VOID InitializeAutoEnrollmentSupport (VOID)
{

    // NOTE, auto-enrollment is registered by
    // the GPO download startup code.

    AE_BEGIN(L"InitializeAutoEnrollmentSupport");


    g_hUserMutex = CreateMutex(NULL, FALSE, NULL);
    if(g_hUserMutex)
    {
        g_hMachineMutex = CreateMutex(NULL, FALSE, NULL);
    }
    if((g_hUserMutex == NULL) || (g_hMachineMutex == NULL))
    {
        AE_DEBUG((AE_ERROR, L"Could not create enrollment mutex (%lx)\n\r", GetLastError()));
        AE_END();

        return;
    }

    //
    // Load some functions we need
    //

    g_hInstWldap32 = LoadLibrary (TEXT("wldap32.dll"));

    if (!g_hInstWldap32) {
        LogAutoEnrollmentError(GetLastError(), EVENT_AE_INITIALIZATION_FAILED, TRUE, NULL, NULL, NULL);
        goto Exit;
    }

    g_pfnldap_init = (PFNLDAP_INIT) GetProcAddress (g_hInstWldap32,
#ifdef UNICODE
                                        "ldap_initW");
#else
                                        "ldap_initA");
#endif

    if (!g_pfnldap_init) {
        LogAutoEnrollmentError(GetLastError(), EVENT_AE_INITIALIZATION_FAILED, TRUE, NULL, NULL, NULL);

        goto Exit;
    }

    g_pfnldap_bind_s = (PFNLDAP_BIND_S) GetProcAddress (g_hInstWldap32,
#ifdef UNICODE
                                        "ldap_bind_sW");
#else
                                        "ldap_bind_sA");
#endif

    if (!g_pfnldap_bind_s) {
        LogAutoEnrollmentError(GetLastError(), EVENT_AE_INITIALIZATION_FAILED, TRUE, NULL, NULL, NULL);

        goto Exit;
    }

    g_pfnldap_set_option= (PFNLDAP_SET_OPTION) GetProcAddress (g_hInstWldap32,
                                        "ldap_set_option");

    if (!g_pfnldap_set_option) {
        LogAutoEnrollmentError(GetLastError(), EVENT_AE_INITIALIZATION_FAILED, TRUE, NULL, NULL, NULL);

        goto Exit;
    }

    g_pfnldap_search_ext_s = (PFNLDAP_SEARCH_EXT_S) GetProcAddress (g_hInstWldap32,
#ifdef UNICODE
                                        "ldap_search_ext_sW");
#else
                                        "ldap_search_ext_sA");
#endif

    if (!g_pfnldap_search_ext_s) {
        LogAutoEnrollmentError(GetLastError(), EVENT_AE_INITIALIZATION_FAILED, TRUE, NULL, NULL, NULL);
        goto Exit;
    }
    g_pfnldap_explode_dn = (PFNLDAP_EXPLODE_DN) GetProcAddress (g_hInstWldap32,
#ifdef UNICODE
                                        "ldap_explode_dnW");
#else
                                        "ldap_explode_dnA");
#endif

    if (!g_pfnldap_explode_dn) {
        LogAutoEnrollmentError(GetLastError(), EVENT_AE_INITIALIZATION_FAILED, TRUE, NULL, NULL, NULL);
        goto Exit;
    }
    g_pfnldap_first_entry = (PFNLDAP_FIRST_ENTRY) GetProcAddress (g_hInstWldap32,
                                        "ldap_first_entry");

    if (!g_pfnldap_first_entry) {
        LogAutoEnrollmentError(GetLastError(), EVENT_AE_INITIALIZATION_FAILED, TRUE, NULL, NULL, NULL);
        goto Exit;
    }
    g_pfnldap_get_values = (PFNLDAP_GET_VALUES) GetProcAddress (g_hInstWldap32,
#ifdef UNICODE
                                        "ldap_get_valuesW");
#else
                                        "ldap_get_valuesA");
#endif

    if (!g_pfnldap_get_values) {
        LogAutoEnrollmentError(GetLastError(), EVENT_AE_INITIALIZATION_FAILED, TRUE, NULL, NULL, NULL);

        goto Exit;
    }


    g_pfnldap_value_free = (PFNLDAP_VALUE_FREE) GetProcAddress (g_hInstWldap32,
#ifdef UNICODE
                                        "ldap_value_freeW");
#else
                                        "ldap_value_freeA");
#endif

    if (!g_pfnldap_value_free) {
        LogAutoEnrollmentError(GetLastError(), EVENT_AE_INITIALIZATION_FAILED, TRUE, NULL, NULL, NULL);
        goto Exit;
    }


    g_pfnldap_msgfree = (PFNLDAP_MSGFREE) GetProcAddress (g_hInstWldap32,
                                        "ldap_msgfree");

    if (!g_pfnldap_msgfree) {
        LogAutoEnrollmentError(GetLastError(), EVENT_AE_INITIALIZATION_FAILED, TRUE, NULL, NULL, NULL);
        goto Exit;
    }


    g_pfnldap_unbind = (PFNLDAP_UNBIND) GetProcAddress (g_hInstWldap32,
                                        "ldap_unbind");

    if (!g_pfnldap_unbind) {
        LogAutoEnrollmentError(GetLastError(), EVENT_AE_INITIALIZATION_FAILED, TRUE, NULL, NULL, NULL);
        goto Exit;
    }

    g_pfnLdapGetLastError = (PFNLDAPGETLASTERROR) GetProcAddress (g_hInstWldap32,
                                        "LdapGetLastError");

    if (!g_pfnLdapGetLastError) {
        LogAutoEnrollmentError(GetLastError(), EVENT_AE_INITIALIZATION_FAILED, TRUE, NULL, NULL, NULL);
        goto Exit;
    }

    g_pfnLdapMapErrorToWin32 = (PFNLDAPMAPERRORTOWIN32) GetProcAddress (g_hInstWldap32,
                                        "LdapMapErrorToWin32");

    if (!g_pfnLdapMapErrorToWin32) {
        LogAutoEnrollmentError(GetLastError(), EVENT_AE_INITIALIZATION_FAILED, TRUE, NULL, NULL, NULL);
        goto Exit;
    }

    g_hInstSecur32 = LoadLibrary (TEXT("secur32.dll"));

    if (!g_hInstSecur32) {
        LogAutoEnrollmentError(GetLastError(), EVENT_AE_INITIALIZATION_FAILED, TRUE, NULL, NULL, NULL);

        goto Exit;
    }


    g_pfnGetUserNameEx = (PFNGETUSERNAMEEX)GetProcAddress (g_hInstSecur32,
#ifdef UNICODE
                                        "GetUserNameExW");
#else
                                        "GetUserNameExA");
#endif
    if (!g_pfnGetUserNameEx) {
        LogAutoEnrollmentError(GetLastError(), EVENT_AE_INITIALIZATION_FAILED, TRUE, NULL, NULL, NULL);
        goto Exit;
    }


    AE_END();
    return;
Exit:

    if(g_hInstSecur32)
    {
        FreeLibrary(g_hInstSecur32);
        g_hInstSecur32 = NULL;

    }
    if(g_hInstWldap32)
    {
        FreeLibrary(g_hInstWldap32);
        g_hInstWldap32 = NULL;
    }

    AE_END();

    return;

}

#if DBG
void
AEDebugLog(long Mask,  LPCWSTR Format, ...)
{
    va_list ArgList;
    int     Level = 0;
    int     PrefixSize = 0;
    int     iOut;
    WCHAR    wszOutString[MAX_DEBUG_BUFFER];
    long    OriginalMask = Mask;

    if (Mask & g_AutoenrollDebugLevel)
    {

	    // Make the prefix first:  "Process.Thread> GINA-XXX"

	    iOut = wsprintfW(
			    wszOutString,
			    L"%3d.%3d> AUTOENRL: ",
			    GetCurrentProcessId(),
			    GetCurrentThreadId());

	    va_start(ArgList, Format);

	    if (wvsprintf(&wszOutString[iOut], Format, ArgList) < 0)
	    {
	        static WCHAR wszOverFlow[] = L"\n<256 byte OVERFLOW!>\n";

	        // Less than zero indicates that the string would not fit into the
	        // buffer.  Output a special message indicating overflow.

	        wcscpy(
		    &wszOutString[(sizeof(wszOutString) - sizeof(wszOverFlow))/sizeof(WCHAR)],
		    wszOverFlow);
	    }
	    va_end(ArgList);
	    OutputDebugStringW(wszOutString);
    }
}
#endif

HRESULT 
myGetConfigDN(
    IN  LDAP *pld,
    OUT LPWSTR *pwszConfigDn
    )

{

    HRESULT hr;
    ULONG  LdapError;

    LDAPMessage  *SearchResult = NULL;
    LDAPMessage  *Entry = NULL;
    WCHAR        *Attr = NULL;
    BerElement   *BerElement;
    WCHAR        **Values = NULL;

    WCHAR  *AttrArray[3];
    struct l_timeval        timeout;

    WCHAR  *ConfigurationNamingContext = L"configurationNamingContext";
    WCHAR  *ObjectClassFilter          = L"objectCategory=*";

    //
    // Set the out parameters to null
    //
    if(pwszConfigDn)
    {
        *pwszConfigDn = NULL;
    }

    timeout.tv_sec = csecLDAPTIMEOUT;
    timeout.tv_usec = 0;
    //
    // Query for the ldap server oerational attributes to obtain the default
    // naming context.
    //
    AttrArray[0] = ConfigurationNamingContext;
    AttrArray[1] = NULL;  // this is the sentinel

    LdapError = g_pfnldap_search_ext_s(pld,
                               NULL,
                               LDAP_SCOPE_BASE,
                               ObjectClassFilter,
                               AttrArray,
                               FALSE,
                               NULL,
                               NULL,
                               &timeout,
                               10000,
                               &SearchResult);

    hr = HRESULT_FROM_WIN32(g_pfnLdapMapErrorToWin32(LdapError));

    if (S_OK == hr) {

        Entry = g_pfnldap_first_entry(pld, SearchResult);

        if (Entry) {

            Values = g_pfnldap_get_values(pld, 
                                        Entry, 
                                        ConfigurationNamingContext);

            if (Values && Values[0]) {
                (*pwszConfigDn) = (LPWSTR)LocalAlloc(LMEM_FIXED, sizeof(WCHAR)*(wcslen(Values[0])+1));
                if(NULL==(*pwszConfigDn))
                    hr=E_OUTOFMEMORY;
                else
                    wcscpy((*pwszConfigDn), Values[0]);
            }

            g_pfnldap_value_free(Values);

        }

        if (pwszConfigDn && (!(*pwszConfigDn))) {
            //
            // We could not get the default domain or out of memory - bail out
            //
            if(E_OUTOFMEMORY != hr)
                hr =  HRESULT_FROM_WIN32(ERROR_CANT_ACCESS_DOMAIN_INFO);

        }
        if(SearchResult)
        {
            g_pfnldap_msgfree(SearchResult);
        }

    }

    return hr;
}


LPWSTR HelperExtensionToString(PCERT_EXTENSION Extension)
{
    LPWSTR wszFormat = NULL;
    DWORD cbFormat = 0;

    if(NULL==Extension)
        return NULL;


    CryptFormatObject(X509_ASN_ENCODING,
                      0,
                      0,
                      NULL,
                      Extension->pszObjId,
                      Extension->Value.pbData,
                      Extension->Value.cbData,
                      NULL,
                      &cbFormat);
    if(cbFormat)
    {
        wszFormat = (LPWSTR)AEAlloc(cbFormat);
        if(wszFormat == NULL)
        {
            return NULL;
        }

        CryptFormatObject(X509_ASN_ENCODING,
                          0,
                          0,
                          NULL,
                          Extension->pszObjId,
                          Extension->Value.pbData,
                          Extension->Value.cbData,
                          wszFormat,
                          &cbFormat);

    }

    return wszFormat;
}


//*************************************************************
//
//  MakeGenericSecurityDesc()
//
//  Purpose:    manufacture a security descriptor with generic
//              access
//
//  Parameters:
//
//  Return:     pointer to SECURITY_DESCRIPTOR or NULL on error
//
//  Comments:
//
//  History:    Date        Author     Comment
//              4/12/99     NishadM    Created
//
//*************************************************************

PISECURITY_DESCRIPTOR AEMakeGenericSecurityDesc()
{
    PISECURITY_DESCRIPTOR       psd = 0;
    SID_IDENTIFIER_AUTHORITY    authNT = SECURITY_NT_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY    authWORLD = SECURITY_WORLD_SID_AUTHORITY;

    PACL    pAcl = 0;
    PSID    psidSystem = 0,
            psidAdmin = 0,
            psidEveryOne = 0;
    DWORD   cbMemSize;
    DWORD   cbAcl;
    DWORD   aceIndex;
    BOOL    bSuccess = FALSE;

    //
    // Get the system sid
    //

    if (!AllocateAndInitializeSid(&authNT, 1, SECURITY_LOCAL_SYSTEM_RID,
                                  0, 0, 0, 0, 0, 0, 0, &psidSystem)) {
         goto Exit;
    }

    //
    // Get the Admin sid
    //

    if (!AllocateAndInitializeSid(&authNT, 2, SECURITY_BUILTIN_DOMAIN_RID,
                                  DOMAIN_ALIAS_RID_ADMINS, 0, 0,
                                  0, 0, 0, 0, &psidAdmin)) {
         goto Exit;
    }

    //
    // Get the EveryOne sid
    //

    if (!AllocateAndInitializeSid(&authWORLD, 1, SECURITY_WORLD_RID,
                                  0, 0, 0, 0, 0, 0, 0, &psidEveryOne)) {

        goto Exit;
    }

    cbAcl = (2 * GetLengthSid (psidSystem)) +
            (2 * GetLengthSid (psidAdmin))  +
            (2 * GetLengthSid (psidEveryOne))  +
            sizeof(ACL) +
            (6 * (sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD)));


    //
    // Allocate space for the SECURITY_DESCRIPTOR + ACL
    //

    cbMemSize = sizeof( SECURITY_DESCRIPTOR ) + cbAcl;

    psd = (PISECURITY_DESCRIPTOR) GlobalAlloc(GMEM_FIXED, cbMemSize);

    if (!psd) {
        goto Exit;
    }

    //
    // increment psd by sizeof SECURITY_DESCRIPTOR
    //

    pAcl = (PACL) ( ( (unsigned char*)(psd) ) + sizeof(SECURITY_DESCRIPTOR) );

    if (!InitializeAcl(pAcl, cbAcl, ACL_REVISION)) {
        goto Exit;
    }

    //
    // GENERIC_ALL for local system
    //

    aceIndex = 0;
    if (!AddAccessAllowedAce(pAcl, ACL_REVISION, GENERIC_ALL, psidSystem)) {
        goto Exit;
    }

    //
    // GENERIC_ALL for Administrators
    //

    aceIndex++;
    if (!AddAccessAllowedAce(pAcl, ACL_REVISION, GENERIC_ALL, psidAdmin)) {
        goto Exit;
    }

    //
    // GENERIC_READ | GENERIC_WRITE | GENERIC_EXECUTE | SYNCHRONIZE for world
    //

    aceIndex++;
    if (!AddAccessAllowedAce(pAcl, ACL_REVISION, GENERIC_READ | GENERIC_WRITE | GENERIC_EXECUTE | SYNCHRONIZE, psidEveryOne)) {
        goto Exit;
    }

    //
    // Put together the security descriptor
    //

    if (!InitializeSecurityDescriptor(psd, SECURITY_DESCRIPTOR_REVISION)) {
        goto Exit;
    }

    if (!SetSecurityDescriptorDacl(psd, TRUE, pAcl, FALSE)) {
        goto Exit;
    }

    bSuccess = TRUE;
Exit:
    if (psidSystem) {
        FreeSid(psidSystem);
    }

    if (psidAdmin) {
        FreeSid(psidAdmin);
    }

    if (psidEveryOne) {
        FreeSid(psidEveryOne);
    }

    if (!bSuccess && psd) {
        GlobalFree(psd);
        psd = 0;
    }

    return psd;
}

HRESULT
aeRobustLdapBind(
    OUT LDAP ** ppldap,
    IN BOOL fGC)
{
    DWORD dwErr = ERROR_SUCCESS;
    HRESULT hr = S_OK;
    BOOL fForceRediscovery = FALSE;
    DWORD dwGetDCFlags = DS_RETURN_DNS_NAME | DS_BACKGROUND_ONLY;
    PDOMAIN_CONTROLLER_INFO pDomainInfo = NULL;
    LDAP *pld = NULL;
    LPWSTR   wszDomainControllerName = NULL;

    ULONG   ldaperr;

    if(fGC)
    {
        dwGetDCFlags |= DS_GC_SERVER_REQUIRED;
    }

    do {
        // netapi32!DsGetDcName is delay loaded, so wrap
        if(fForceRediscovery)
        {
           dwGetDCFlags |= DS_FORCE_REDISCOVERY;
        }
        ldaperr = LDAP_SERVER_DOWN;

        __try
        {
            // Get the GC location
            dwErr = DsGetDcName(NULL,     // Delayload wrapped
                                NULL, 
                                NULL, 
                                NULL,
                                 dwGetDCFlags,
                                &pDomainInfo);
        }
        __except(dwErr = GetExceptionError(GetExceptionInformation()), EXCEPTION_EXECUTE_HANDLER)
        {
        }
        if(dwErr != ERROR_SUCCESS)
        {
            hr = HRESULT_FROM_WIN32(dwErr);
            goto error;
        }

        if((pDomainInfo == NULL) || 
           ((pDomainInfo->Flags & DS_GC_FLAG) == 0) ||
           ((pDomainInfo->Flags & DS_DNS_CONTROLLER_FLAG) == 0) ||
           (pDomainInfo->DomainControllerName == NULL))
        {
            if(!fForceRediscovery)
            {
                fForceRediscovery = TRUE;
                continue;
            }
            hr = HRESULT_FROM_WIN32(ERROR_CANT_ACCESS_DOMAIN_INFO);
            goto error;
        }


        wszDomainControllerName = pDomainInfo->DomainControllerName;


        // skip past forward slashes (why are they there?)
        while(*wszDomainControllerName == L'\\')
        {
            wszDomainControllerName++;
        }

        // bind to ds
        if((pld = g_pfnldap_init(wszDomainControllerName, fGC?LDAP_GC_PORT:LDAP_PORT)) == NULL)
        {
            ldaperr = g_pfnLdapGetLastError();
        }
        else
        {
	    ldaperr = g_pfnldap_bind_s(pld, NULL, NULL, LDAP_AUTH_NEGOTIATE);
        }
        hr = HRESULT_FROM_WIN32(g_pfnLdapMapErrorToWin32(ldaperr));

        if(fForceRediscovery)
        {
            break;
        }
        fForceRediscovery = TRUE;

    } while(ldaperr == LDAP_SERVER_DOWN);

    if(hr == S_OK)
    {
        *ppldap = pld;
        pld = NULL;
    }

error:

    if(pld)
    {
        g_pfnldap_unbind(pld);
    }
    // we know netapi32 was already loaded safely (that's where we got pDomainInfo), so no need to wrap
    if(pDomainInfo)
    {
        NetApiBufferFree(pDomainInfo);     // Delayload wrapped
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\tools\tinstall\tinstall.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       tinstall.cpp
//
//--------------------------------------------------------------------------

#include <stdlib.h>
#include <string.h>
#include <windows.h>
#include <stdio.h>
#include <certca.h>
#include <winldap.h>
#include <ntldap.h>
#include <dsrole.h>
#include <dsgetdc.h>
#include <accctrl.h>
#include <lmerr.h>

#include <lmaccess.h>
#include <lmapibuf.h>

//--------------------------------------------------------------------------
//
//       Defines
//
//--------------------------------------------------------------------------
#define DS_RETEST_SECONDS                   3
#define CVT_BASE	                        (1000 * 1000 * 10)
#define CVT_SECONDS	                        (1)
#define CERTTYPE_SECURITY_DESCRIPTOR_NAME   L"NTSecurityDescriptor"
#define TEMPLATE_CONTAINER_NAME             L"CN=Certificate Templates,CN=Public Key Services,CN=Services,"
#define SCHEMA_CONTAINER_NAME               L"CN=Schema,"


typedef WCHAR *CERTSTR; 


//--------------------------------------------------------------------------
//
//
//     Helper Functions
//
//--------------------------------------------------------------------------
HANDLE GetClientIdentity()
{
    HANDLE  hHandle       = NULL;
    HANDLE  hClientToken  = NULL; 
    HANDLE  hProcessToken = NULL; 

    // Step 1: attempt to acquire the thread token.  
    if(hHandle = GetCurrentThread())
    {
        if (OpenThreadToken(hHandle,
			     TOKEN_QUERY,
			     TRUE,           // open as self
			     &hClientToken))
        goto Exit;
    }
  
    if (hHandle != NULL)
    {
        CloseHandle(hHandle); 
        hHandle=NULL;
    }
    
    // We failed to get the thread token, now try to acquire the process token:
    hHandle = GetCurrentProcess();
    if (NULL == hHandle)
	    goto Exit; 
    
    if (!OpenProcessToken(hHandle,
			  TOKEN_DUPLICATE,
			  &hProcessToken))
	    goto Exit; 
    
    if(!DuplicateToken(hProcessToken,
		       SecurityImpersonation,
		       &hClientToken))
	    goto Exit;
    
Exit:
    if (NULL != hHandle)       
        CloseHandle(hHandle); 

    if (NULL != hProcessToken) 
        CloseHandle(hProcessToken); 
    
    return hClientToken; 
}    



HRESULT
myHError(HRESULT hr)
{

    if (S_OK != hr && S_FALSE != hr && !FAILED(hr))
    {
        hr = HRESULT_FROM_WIN32(hr);
        if (0 == HRESULT_CODE(hr))
        {
            // A call failed without properly setting an error condition!
            hr = E_UNEXPECTED;
        }
    }
    return(hr);
}


HRESULT
myDupString(
    IN WCHAR const *pwszIn,
    IN WCHAR **ppwszOut)
{
    DWORD cb;
    HRESULT hr;

    cb = (wcslen(pwszIn) + 1) * sizeof(WCHAR);
    *ppwszOut = (WCHAR *) LocalAlloc(LMEM_FIXED, cb);
    if (NULL == *ppwszOut)
    {
	hr = E_OUTOFMEMORY;
	goto error;
    }
    CopyMemory(*ppwszOut, pwszIn, cb);
    hr = S_OK;

error:
    return(hr);
}


UINT    CertStringLen(CERTSTR cstrString)
{
    if(cstrString == NULL)
    {
        return 0;
    }
    return(*((UINT *)((PBYTE)cstrString - sizeof(UINT))))/sizeof(WCHAR);
}

UINT    CertStringByteLen(CERTSTR cstrString)
{
    if(cstrString == NULL)
    {
        return 0;
    }
    return(*((UINT *)((PBYTE)cstrString - sizeof(UINT))));
}

CERTSTR CertAllocStringByteLen(LPCSTR szString, UINT len)
{
    PBYTE  pbResult;

    pbResult = (PBYTE)LocalAlloc(LMEM_FIXED, len + sizeof(UINT) + sizeof(WCHAR));
    if (NULL == pbResult)
        return NULL;

    *((UINT *)pbResult) = len;
    pbResult += sizeof(UINT);

    *((UNALIGNED WCHAR *)(pbResult+len)) = 0;
    if(szString)
    {
        CopyMemory(pbResult, szString, min(len, strlen(szString)+1));
    }

    return (CERTSTR)pbResult;
}

CERTSTR CertAllocStringLen(LPCWSTR wszString, UINT len)
{
    CERTSTR szResult;
    szResult = CertAllocStringByteLen(NULL, len*sizeof(WCHAR));
    if (NULL != szResult && NULL != wszString)
    {
        CopyMemory(szResult, wszString, min(wcslen(wszString)+1, len)*sizeof(WCHAR));
    }

    return szResult;
}

HRESULT CertFreeString(CERTSTR cstrString)
{
    WCHAR *pData = (WCHAR *)(((PBYTE)cstrString)-sizeof(UINT));
    if(cstrString == NULL)
    {
        return E_POINTER;
    }
    LocalFree(pData);
    return S_OK;
}

CERTSTR CertAllocString(LPCWSTR wszString)
{
    if(wszString == NULL)
    {
        return NULL;
    }
    return CertAllocStringLen(wszString, wcslen(wszString)+1);
}




DWORD
CAGetAuthoritativeDomainDn(
    IN  LDAP*   LdapHandle,
    OUT CERTSTR *DomainDn,
    OUT CERTSTR *ConfigDn
    )
/*++

Routine Description:

    This routine simply queries the operational attributes for the
    domaindn and configdn.

    The strings returned by this routine must be freed by the caller
    using RtlFreeHeap() using the process heap.

Parameters:

    LdapHandle    : a valid handle to an ldap session

    DomainDn      : a pointer to a string to be allocated in this routine

    ConfigDn      : a pointer to a string to be allocated in this routine

Return Values:

    An error from the win32 error space.

    ERROR_SUCCESS and

    Other operation errors.

--*/
{

    DWORD  WinError = ERROR_SUCCESS;
    ULONG  LdapError;

    LDAPMessage  *SearchResult = NULL;
    LDAPMessage  *Entry = NULL;
    WCHAR        *Attr = NULL;
    BerElement   *BerElement;
    WCHAR        **Values = NULL;

    WCHAR  *AttrArray[3];

    WCHAR  *DefaultNamingContext       = L"defaultNamingContext";
    WCHAR  *ConfigNamingContext       = L"configurationNamingContext";
    WCHAR  *ObjectClassFilter          = L"objectClass=*";

    //
    // These must be present
    //

    //
    // Set the out parameters to null
    //

    if(DomainDn)
    {
        *DomainDn = NULL;
    }
    if(ConfigDn)
    {
        *ConfigDn = NULL;
    }

    //
    // Query for the ldap server oerational attributes to obtain the default
    // naming context.
    //
    AttrArray[0] = DefaultNamingContext;
    AttrArray[1] = ConfigNamingContext;  // this is the sentinel
    AttrArray[2] = NULL;  // this is the sentinel

    __try
    {
	    LdapError = ldap_search_sW(LdapHandle,
				       NULL,
				       LDAP_SCOPE_BASE,
				       ObjectClassFilter,
				       AttrArray,
				       FALSE,
				       &SearchResult);

	    WinError = LdapMapErrorToWin32(LdapError);

	    if (ERROR_SUCCESS == WinError) {

            Entry = ldap_first_entry(LdapHandle, SearchResult);

            if (Entry)
            {

                Attr = ldap_first_attributeW(LdapHandle, Entry, &BerElement);

                while (Attr)
                {

                    if (!_wcsicmp(Attr, DefaultNamingContext))
                    {

                        if(DomainDn)
                        {
	                        Values = ldap_get_values(LdapHandle, Entry, Attr);

	                        if (Values && Values[0])
                            {
                                (*DomainDn) = CertAllocString(Values[0]);
	                        }
	                        ldap_value_free(Values);
                        }

                    }
                    else if (!_wcsicmp(Attr, ConfigNamingContext))
                    {

                        if(ConfigDn)
                        {
	                        Values = ldap_get_values(LdapHandle, Entry, Attr);

	                        if (Values && Values[0])
                            {
                                (*ConfigDn) = CertAllocString(Values[0]);
	                        }
	                        ldap_value_free(Values);
                        }

                    }

                    Attr = ldap_next_attribute(LdapHandle, Entry, BerElement);
                }
            }

            if ( DomainDn && (!(*DomainDn)))
            {
	            //
	            // We could get the default domain - bail out
	            //
	            WinError =  ERROR_CANT_ACCESS_DOMAIN_INFO;

            }
            else if ( ConfigDn && (!(*ConfigDn)))
            {
	            //
	            // We could get the default domain - bail out
	            //
	            WinError =  ERROR_CANT_ACCESS_DOMAIN_INFO;

            }

	    }
    }
    __except(WinError = GetExceptionCode(), EXCEPTION_EXECUTE_HANDLER)
    {
    }

    // make sure we free this
    if (SearchResult)
        ldap_msgfree( SearchResult );

    return WinError;
}



HRESULT
myDoesDSExist(
    IN BOOL fRetry)
{
    HRESULT hr = S_OK;

    static BOOL s_fKnowDSExists = FALSE;
    static HRESULT s_hrDSExists = HRESULT_FROM_WIN32(ERROR_NO_SUCH_DOMAIN);
    static FILETIME s_ftNextTest = {0,0};
    
    if (s_fKnowDSExists && (s_hrDSExists != S_OK) && fRetry)
    //    s_fKnowDSExists = FALSE;	// force a retry
    {
        FILETIME ftCurrent;
        GetSystemTimeAsFileTime(&ftCurrent);

        // if Compare is < 0 (next < current), force retest
        if (0 > CompareFileTime(&s_ftNextTest, &ftCurrent))
            s_fKnowDSExists = FALSE;    
    }

    if (!s_fKnowDSExists)
    {
        GetSystemTimeAsFileTime(&s_ftNextTest);

	// set NEXT in 100ns increments

        ((LARGE_INTEGER *) &s_ftNextTest)->QuadPart +=
	    (__int64) (CVT_BASE * CVT_SECONDS * 60) * DS_RETEST_SECONDS;

        // NetApi32 is delay loaded, so wrap to catch problems when it's not available
        __try
        {
            DOMAIN_CONTROLLER_INFO *pDCI;
            DSROLE_PRIMARY_DOMAIN_INFO_BASIC *pDsRole;
        
            // ensure we're not standalone
            pDsRole = NULL;
            hr = DsRoleGetPrimaryDomainInformation(	// Delayload wrapped
				    NULL,
				    DsRolePrimaryDomainInfoBasic,
				    (BYTE **) &pDsRole);

            if (S_OK == hr &&
                (pDsRole->MachineRole == DsRole_RoleStandaloneServer ||
                 pDsRole->MachineRole == DsRole_RoleStandaloneWorkstation))
            {
                hr = HRESULT_FROM_WIN32(ERROR_NO_SUCH_DOMAIN);
            }

            if (NULL != pDsRole) 
	    {
                DsRoleFreeMemory(pDsRole);     // Delayload wrapped
	    }
            if (S_OK == hr)
            {
                // not standalone; return info on our DS

                pDCI = NULL;
                hr = DsGetDcName(    // Delayload wrapped
			    NULL,
			    NULL,
			    NULL,
			    NULL,
			    DS_DIRECTORY_SERVICE_PREFERRED,
			    &pDCI);
            
                if (S_OK == hr && 0 == (pDCI->Flags & DS_DS_FLAG))
                {
                    hr = HRESULT_FROM_WIN32(ERROR_CANT_ACCESS_DOMAIN_INFO);
                }
                if (NULL != pDCI)
                {
                   NetApiBufferFree(pDCI);    // Delayload wrapped
                }
            }
            s_fKnowDSExists = TRUE;
        }
        __except(hr = GetExceptionCode(), EXCEPTION_EXECUTE_HANDLER)
        {
        }

        // else just allow users without netapi flounder with timeouts
        // if ds not available...

        s_hrDSExists = myHError(hr);
    }
    return(s_hrDSExists);
}




HRESULT
myRobustLdapBindEx(
    OUT LDAP ** ppldap,
    OPTIONAL OUT LPWSTR* ppszForestDNSName,
    IN BOOL fGC)
{
    HRESULT hr;
    BOOL fForceRediscovery = FALSE;
    DWORD dwGetDCFlags = DS_RETURN_DNS_NAME;
    PDOMAIN_CONTROLLER_INFO pDomainInfo = NULL;
    LDAP *pld = NULL;
    WCHAR const *pwszDomainControllerName = NULL;
    ULONG ldaperr;

    if (fGC)
    {
        dwGetDCFlags |= DS_GC_SERVER_REQUIRED;
    }

    do {
        if (fForceRediscovery)
        {
           dwGetDCFlags |= DS_FORCE_REDISCOVERY;
        }
	ldaperr = LDAP_SERVER_DOWN;

        // netapi32!DsGetDcName is delay loaded, so wrap

        __try
        {
            // Get the GC location
            hr = DsGetDcName(
			NULL,     // Delayload wrapped
			NULL, 
			NULL, 
			NULL,
			dwGetDCFlags,
			&pDomainInfo);
        }
        __except(hr = GetExceptionCode(), EXCEPTION_EXECUTE_HANDLER)
        {
        }
        if (S_OK != hr)
        {
	    hr = HRESULT_FROM_WIN32(hr);
            if (fForceRediscovery)
            {
                goto error;
            }
	    fForceRediscovery = TRUE;
	    continue;
        }

        if (NULL == pDomainInfo ||
            (fGC && 0 == (DS_GC_FLAG & pDomainInfo->Flags)) ||
            0 == (DS_DNS_CONTROLLER_FLAG & pDomainInfo->Flags) ||
            NULL == pDomainInfo->DomainControllerName)
        {
            if (!fForceRediscovery)
            {
                fForceRediscovery = TRUE;
                continue;
            }
            hr = HRESULT_FROM_WIN32(ERROR_CANT_ACCESS_DOMAIN_INFO);
            goto error;
        }

        pwszDomainControllerName = pDomainInfo->DomainControllerName;

        // skip past forward slashes (why are they there?)

        while (L'\\' == *pwszDomainControllerName)
        {
            pwszDomainControllerName++;
        }

        // bind to ds

        pld = ldap_init(
		    const_cast<WCHAR *>(pwszDomainControllerName),
		    fGC? LDAP_GC_PORT : LDAP_PORT);
        if (NULL == pld)
	{
            ldaperr = LdapGetLastError();
	}
        else
        {
            // do this because we're explicitly setting DC name

            ldaperr = ldap_set_option(pld, LDAP_OPT_AREC_EXCLUSIVE, LDAP_OPT_ON);

	    ldaperr = ldap_bind_s(pld, NULL, NULL, LDAP_AUTH_NEGOTIATE);
        }
        hr = myHError(LdapMapErrorToWin32(ldaperr));

        if (fForceRediscovery)
        {
            break;
        }
        fForceRediscovery = TRUE;

    } while (LDAP_SERVER_DOWN == ldaperr);

    // everything's cool, party down

    if (S_OK == hr)
    {
        if (NULL != ppszForestDNSName)
        {
             hr = myDupString(
			pDomainInfo->DomainControllerName,
			ppszForestDNSName);

             if(S_OK != hr)
                 goto error;
        }
        *ppldap = pld;
        pld = NULL;
    }

error:
    if (NULL != pld)
    {
        ldap_unbind(pld);
    }

    // we know netapi32 was already loaded safely (that's where we got
    // pDomainInfo), so no need to wrap

    if (NULL != pDomainInfo)
    {
        NetApiBufferFree(pDomainInfo);     // Delayload wrapped
    }
    return(hr);
}

HRESULT
myRobustLdapBind(
    OUT LDAP ** ppldap,
    IN BOOL fGC)
{
    return(myRobustLdapBindEx(ppldap, NULL, fGC));
}

//--------------------------------------------------------------------
static HRESULT GetRootDomEntitySid(SID ** ppSid, DWORD dwEntityRid)
{
    HRESULT hr;
    NET_API_STATUS nasError;
    unsigned int nSubAuthorities;
    unsigned int nSubAuthIndex;

    // must be cleaned up
    SID * psidRootDomEntity=NULL;
    USER_MODALS_INFO_2 * pumi2=NULL;
    DOMAIN_CONTROLLER_INFOW * pdci=NULL;
    DOMAIN_CONTROLLER_INFOW * pdciForest=NULL;

    // initialize out params
    *ppSid=NULL;


    // get the forest name
    nasError=DsGetDcNameW(NULL, NULL, NULL, NULL, 0, &pdciForest);
    if (NERR_Success!=nasError) {
        hr=HRESULT_FROM_WIN32(nasError);
        goto error;
    }

    // get the top level DC name
    nasError=DsGetDcNameW(NULL, pdciForest->DnsForestName, NULL, NULL, 0, &pdci);
    if (NERR_Success!=nasError) {
        hr=HRESULT_FROM_WIN32(nasError);
        goto error;
    }

    // get the domain Sid on the top level DC.
    nasError=NetUserModalsGet(pdci->DomainControllerName, 2, (LPBYTE *)&pumi2);
    if(NERR_Success!=nasError) {
        hr=HRESULT_FROM_WIN32(nasError);
        goto error;
    }

    nSubAuthorities=*GetSidSubAuthorityCount(pumi2->usrmod2_domain_id);

    // allocate storage for new Sid. account domain Sid + account Rid
    psidRootDomEntity=(SID *)LocalAlloc(LPTR, GetSidLengthRequired((UCHAR)(nSubAuthorities+1)));

    if(NULL == psidRootDomEntity)
    {
        hr=E_OUTOFMEMORY;
        goto error;
    }

    // copy the first few peices into the SID
    if (!InitializeSid(psidRootDomEntity, 
            GetSidIdentifierAuthority(pumi2->usrmod2_domain_id), 
            (BYTE)(nSubAuthorities+1)))
    {
        hr=HRESULT_FROM_WIN32(GetLastError());
        goto error;
    }

    // copy existing subauthorities from account domain Sid into new Sid
    for (nSubAuthIndex=0; nSubAuthIndex < nSubAuthorities ; nSubAuthIndex++) {
        *GetSidSubAuthority(psidRootDomEntity, nSubAuthIndex)=
            *GetSidSubAuthority(pumi2->usrmod2_domain_id, nSubAuthIndex);
    }

    // append Rid to new Sid
    *GetSidSubAuthority(psidRootDomEntity, nSubAuthorities)=dwEntityRid;

    *ppSid=psidRootDomEntity;
    psidRootDomEntity=NULL;
    hr=S_OK;

error:
    if (NULL!=psidRootDomEntity) {
        FreeSid(psidRootDomEntity);
    }
    if (NULL!=pdci) {
        NetApiBufferFree(pdci);
    }
    if (NULL!=pdci) {
        NetApiBufferFree(pdciForest);
    }
    if (NULL!=pumi2) {
        NetApiBufferFree(pumi2);
    }

    return hr;
}


//--------------------------------------------------------------------
HRESULT GetRootDomAdminSid(SID ** ppSid)
{
    return GetRootDomEntitySid(ppSid, DOMAIN_GROUP_RID_ADMINS);
}


//***********************************************************************************
//
//
//    Main
//
//          This function will install new Whistler certificate template if and onlyif
//    the following conditions are TRUE:
//
//          1. Whilster Schema
//          2. New certificate templates have not yet installed
//          3. The caller has privilege to install templates in the directory
//
//
//***********************************************************************************
void __cdecl main(
    int argc,
    char **argv)
{
	
    HRESULT             hr=S_OK;
    DWORD               dwErr=0;
    ULONG               ldaperr=0;
    struct l_timeval    timeout;
    DWORD               dwCount=0;
    LPWSTR              awszAttr[2];
    BOOL                fAccessAllowed = FALSE;
    DWORD               grantAccess=0;
    GENERIC_MAPPING     AccessMapping;
    PRIVILEGE_SET       ps;
    DWORD               dwPSSize = sizeof(ps);
    LDAPMessage         *Entry = NULL;
    CHAR                sdBerValue[] = {0x30, 0x03, 0x02, 0x01, DACL_SECURITY_INFORMATION |
                                                 OWNER_SECURITY_INFORMATION |
                                                 GROUP_SECURITY_INFORMATION };
       
    LDAPControl         se_info_control =
                        {
                            LDAP_SERVER_SD_FLAGS_OID_W,
                            {
                                5, sdBerValue
                            },
                            TRUE
                        };

    LDAPControl         permissive_modify_control =
                        {
                            LDAP_SERVER_PERMISSIVE_MODIFY_OID_W,
                            {
                                0, NULL
                            },
                            FALSE
                        };


    PLDAPControl        server_controls[3] =
                        {
                            &se_info_control,
                            &permissive_modify_control,
                            NULL
                        };



    HCERTTYPE           hCertType=NULL;      
    LDAP                *pld = NULL;
    CERTSTR             bstrConfig = NULL;
    CERTSTR             bstrDN = NULL;
    LDAPMessage         *SearchResult = NULL;
    LDAPMessage         *SDResult = NULL;
    struct berval       **apSD =NULL;
    PSECURITY_DESCRIPTOR    pSD=NULL;
    HANDLE              hClientToken=NULL;
    SID                 * psidRootDomAdmins=NULL;
    BOOL                bIsRootDomAdmin=FALSE;



    //*************************************************************
    // 
    // check the schema version
    //
    
    //retrieve the ldap handle and the config string
    if(S_OK != myDoesDSExist(TRUE))
    {
        wprintf(L"No DS exists.\n");
        goto error;
    }

    if(S_OK != (hr = myRobustLdapBind(&pld, FALSE)))
    {
        wprintf(L"Error: Failed to bind to the DS.\n");
        goto error;
    }

	dwErr = CAGetAuthoritativeDomainDn(pld, NULL, &bstrConfig);
	if(ERROR_SUCCESS != dwErr)
    {
        wprintf(L"Error: Failed to get the domain name.\n");
	    hr = HRESULT_FROM_WIN32(dwErr);
        goto error;
    }

    bstrDN = CertAllocStringLen(NULL, wcslen(bstrConfig) + wcslen(SCHEMA_CONTAINER_NAME));
    if(NULL == bstrDN)
    {
        wprintf(L"Error: Failed to get the container name.\n");
        hr=E_OUTOFMEMORY;
        goto error;
    }

    wcscpy(bstrDN, SCHEMA_CONTAINER_NAME);
    wcscat(bstrDN, bstrConfig);

    timeout.tv_sec = 300;
    timeout.tv_usec = 0;

    awszAttr[0]=L"cn";
    awszAttr[1]=NULL;
    
 	ldaperr = ldap_search_stW(
              pld, 
		      (LPWSTR)bstrDN,
		      LDAP_SCOPE_ONELEVEL,
		      L"(cn=ms-PKI-Enrollment-Flag)",
		      awszAttr,
		      0,
              &timeout,
		      &SearchResult);

    if(LDAP_SUCCESS != ldaperr)
    {
        wprintf(L"We have W2K Schema.  Exit\n");
        hr=S_OK;
        goto error;
    }

    dwCount = ldap_count_entries(pld, SearchResult);

    if(0 == dwCount)
    {
        wprintf(L"We have W2K Schema.  Exit\n");
        hr=S_OK;
        goto error;
    }


    //*************************************************************
    // 
    //  check if keyRecoveryAgent certificate is present and
    //  and update to date
    //
    hr=CAFindCertTypeByName(
                wszCERTTYPE_DS_EMAIL_REPLICATION,
                NULL,
                CT_ENUM_MACHINE_TYPES | CT_FLAG_NO_CACHE_LOOKUP,
                &hCertType);

    if((S_OK == hr) && (NULL!=hCertType))
    {
        wprintf(L"Key Recovery Agent certificate template already exists.\n");	

        //check if the template is update to date
        if(CAIsCertTypeCurrent(0, wszCERTTYPE_DS_EMAIL_REPLICATION))
        {
            wprintf(L"Key Recovery Agent certificate template is current.  Exit\n");	
            goto error;
        }
    }

    //*************************************************************
    // 
    //  check the write access
    //
    //
    if(NULL==(hClientToken=GetClientIdentity()))
    {
        wprintf(L"Can not retrieve client identity.\n");
        hr = myHError(GetLastError());
        goto error;
    }

    //get the SD of the certificate template container
    if(bstrDN)
        CertFreeString(bstrDN);

    bstrDN = CertAllocStringLen(NULL, wcslen(bstrConfig) + wcslen(TEMPLATE_CONTAINER_NAME));
    if(NULL == bstrDN)
    {
        wprintf(L"Error: Failed to get the container name.\n");
        hr=E_OUTOFMEMORY;
        goto error;
    }

    wcscpy(bstrDN, TEMPLATE_CONTAINER_NAME);
    wcscat(bstrDN, bstrConfig);



    awszAttr[0]=CERTTYPE_SECURITY_DESCRIPTOR_NAME;
    awszAttr[1]=NULL;

    ldaperr = ldap_search_ext_sW(
                  pld, 
		          (LPWSTR)bstrDN,
		          LDAP_SCOPE_BASE,
		          L"(objectclass=*)",
		          awszAttr,
		          0,
                  (PLDAPControl *)&server_controls,
                  NULL,
                  &timeout,
                  10,
		          &SDResult);

    if(LDAP_SUCCESS != ldaperr)
    {
        wprintf(L"Fail to locate the template container.\n");
        hr = myHError(LdapMapErrorToWin32(ldaperr));
        goto error;
    }

    if(NULL == (Entry = ldap_first_entry(pld, SDResult)))
    {
        wprintf(L"Can not find first entry for template container.\n");
        hr = E_UNEXPECTED;
        goto error;
    }

    apSD = ldap_get_values_len(pld, Entry, CERTTYPE_SECURITY_DESCRIPTOR_NAME);
    if(apSD == NULL)
    {
        wprintf(L"Can not retrieve security descriptor.\n");
        hr = E_FAIL;
        goto error;
   }

    pSD = LocalAlloc(LMEM_FIXED, (*apSD)->bv_len);
    if(pSD == NULL)
    {
        wprintf(L"Error: No more memory.\n");
        hr = E_OUTOFMEMORY;
        goto error;
    }

    CopyMemory(pSD, (*apSD)->bv_val, (*apSD)->bv_len);

    //check the write access
    if(!AccessCheckByType(
		  pSD,                      // security descriptor
		  NULL,                     // SID of object being checked
		  hClientToken,             // handle to client access token
		  ACTRL_DS_CREATE_CHILD |
          ACTRL_DS_LIST,            // requested access rights 
		  NULL,                     // array of object types
		  0,                        // number of object type elements
		  &AccessMapping,           // map generic to specific rights
		  &ps,                      // receives privileges used
		  &dwPSSize,                // size of privilege-set buffer
		  &grantAccess,             // retrieves mask of granted rights
		  &fAccessAllowed))         // retrieves results of access check);
    {
        wprintf(L"Error: Fail to check the write access.\n");
        hr = myHError(GetLastError());
        goto error;
    }

    if(!fAccessAllowed)
    {
        wprintf(L"No previlege to create certificate template.  Exit\n");
        hr = S_OK;
        goto error;
    }


    //*************************************************************
    // 
    //  check the root domain admin rights
    //
    //
    hr=GetRootDomAdminSid(&psidRootDomAdmins);

    if(S_OK != hr)
    {
        wprintf(L"Error: GetRootDomAdminSid.\n");
        goto error;
    }


    // check for membership
    if (!CheckTokenMembership(NULL, psidRootDomAdmins, &bIsRootDomAdmin)) 
    {
        hr=HRESULT_FROM_WIN32(GetLastError());
        wprintf(L"Error: CheckTokenMembership.\n");
        goto error;
    }

    if(FALSE == bIsRootDomAdmin)
    {
        wprintf(L"No domain admin rights to create certificate template.  Exit\n");
        hr = S_OK;
        goto error;
    }

    //*************************************************************
    // 
    //  everything looks good.  Install the certificate templates
    //
    //
    if(IDNO == MessageBoxW(
                NULL, 
                L"The system detects that new certificate templates should be installed.  Do you want to install them?",
                L"Certificate Templates",
                MB_YESNO))
    {
        hr=S_OK;
        goto error;
    }

    hr=CAInstallDefaultCertType(0);

    if(hr != S_OK)
    {
        wprintf(L"Installation failed with 0x%08X.\n", hr);	
        goto error;
    }

    wprintf(L"Certificate templates are successfully installed.\n");

error:

    if (psidRootDomAdmins) 
        FreeSid(psidRootDomAdmins);
    
    if(hClientToken)
        CloseHandle(hClientToken);

    if(pSD)
        LocalFree(pSD);

    if(apSD != NULL)
        ldap_value_free_len(apSD);

    if(SDResult)
        ldap_msgfree(SDResult);

    if(SearchResult)
        ldap_msgfree(SearchResult);

    if(bstrDN)
        CertFreeString(bstrDN);

    if(hCertType)
        CACloseCertType(hCertType);

    if(bstrConfig)
        CertFreeString(bstrConfig);

    if (pld)
        ldap_unbind(pld);

    if(S_OK == hr)
        wprintf(L"Test Passed\n");
    else
        wprintf(L"Test Failed\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\tools\viewtest\pch.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        pch.cpp
//
// Contents:    Cert Server precompiled header
//
//---------------------------------------------------------------------------
#define __DIR__         "viewtest"

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <tchar.h>
#include <wincrypt.h>

#include <certsrv.h>
#include "certlib.h"
#include "csdisp.h"

#pragma hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\tools\viewtest\viewtest.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       viewtest.cpp
//
//--------------------------------------------------------------------------

#include <pch.cpp>

#pragma hdrstop

VOID EnumView(IEnumCERTVIEWROW *pRow);

LONG g_idxRequestId;


void __cdecl main(int argc, char* argv[])
{
    HRESULT hr;
    WCHAR sz[MAX_PATH];
    
    BSTR bstrConfig = NULL;
    ICertView* pView = NULL;
    IEnumCERTVIEWROW* pRow = NULL;
    BOOL fCoInit = FALSE;
    
    int nWCharsRequired;
    WCHAR* wszConfig = NULL;
    
    hr = CoInitialize(NULL);
    if ((hr == S_OK) || (hr == S_FALSE))
        fCoInit = TRUE;
    
    hr = CoCreateInstance(
        CLSID_CCertView,
        NULL,		// pUnkOuter
        CLSCTX_INPROC_SERVER,
        IID_ICertView,
        (VOID **) &pView);
    if (S_OK != hr)
        goto Ret;
    
    if (argc < 2)
    {
	hr = ConfigGetConfig(0, 0, &bstrConfig);
	_JumpIfError(hr, Ret, "ConfigGetConfig");
    }
    else
    {
	nWCharsRequired = MultiByteToWideChar(
	    GetACP(),
	    0,
	    argv[1],
	    -1,
	    NULL,
	    0);
	if (0 >= nWCharsRequired)
	{
	    hr = GetLastError();
	    _JumpError(hr, Ret, "MultiByteToWideChar");
	}
	wszConfig = (WCHAR *) LocalAlloc(
	    LMEM_FIXED,
	    nWCharsRequired * sizeof(WCHAR));
	if (NULL == wszConfig)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, Ret, "LocalAlloc");
	}
	if (0 >= MultiByteToWideChar(
	    GetACP(),
	    0,
	    argv[1],
	    -1,
	    wszConfig,
	    nWCharsRequired))
	{
	    hr = GetLastError();
	    _JumpError(hr, Ret, "MultiByteToWideChar");
	}
	bstrConfig = SysAllocString(wszConfig);
    }
    
    hr = pView->OpenConnection(bstrConfig);
    if (hr != S_OK)
    {
        wprintf(L"Could not open connection to %hs\n", argv[1]);
        goto Ret;
    }
    
    VARIANT var;
    VariantInit(&var);
    var.lVal = DB_DISP_QUEUE_MAX;
    var.vt = VT_I4;
    LONG idxCol;
    
    hr = pView->GetColumnIndex(FALSE, wszPROPREQUESTDOT wszPROPREQUESTDISPOSITION, &idxCol);
    _JumpIfError(hr, Ret, "GetColumnIndex");

    hr = pView->SetRestriction(
        idxCol,		                    // Request Disposition's ColumnIndex
        CVR_SEEK_LE,	                // SeekOperator
        CVR_SORT_NONE,                  // SortOrder
        &var);		                    // pvarValue
    
    VariantClear(&var);
    if (hr != S_OK)
        goto Ret;
    
    // canned pending view
    hr = pView->SetResultColumnCount(CV_COLUMN_LOG_DEFAULT);
    if (hr != S_OK)
        goto Ret;
    
    
    hr = pView->OpenView(&pRow);
    if (hr != S_OK)
        goto Ret;

    hr = pView->GetColumnIndex(TRUE, wszPROPREQUESTDOT wszPROPREQUESTREQUESTID, &g_idxRequestId);
    _JumpIfError(hr, Ret, "GetColumnIndex");
    
    EnumView(pRow);
    
Ret:
    if (pView)
        pView->Release();
    if (pRow)
        pRow->Release();
    
    if (bstrConfig)
        SysFreeString(bstrConfig);
    
    if (wszConfig)
        LocalFree(wszConfig);
    
    if (fCoInit)
        CoUninitialize();
    return;
}


DWORD
GetRequestId(
    IEnumCERTVIEWROW *pRow)
{
    HRESULT hr;
    IEnumCERTVIEWCOLUMN *pCol = NULL;
    DWORD RequestId = MAXDWORD;
    BSTR strName = NULL;
    LONG Index;
    VARIANT var;
   
    VariantInit(&var);
    
    hr = pRow->EnumCertViewColumn(&pCol);
    _JumpIfError(hr, error, "EnumCertViewColumn");

    hr = pCol->Skip(g_idxRequestId);
    _JumpIfError(hr, error, "Skip");

    hr = pCol->Next(&Index);
    _JumpIfError(hr, error, "Next");

    hr = pCol->GetValue(CV_OUT_BINARY, &var);
    _JumpIfError(hr, error, "GetValue");

    if (VT_I4 == var.vt)
    {
	RequestId = var.lVal;
    }

error:
    VariantClear(&var);
    if (NULL != strName)
    {
	SysFreeString(strName);
    }
    if (NULL != pCol)
    {
	pCol->Release();
    }
    return(RequestId);
}


HRESULT
RowNext(
    IEnumCERTVIEWROW *pRow,
    LONG *plNext)
{
    HRESULT hr;
    DWORD RequestId;

    hr = pRow->Next(plNext);
    if (S_OK != hr)
    {
	fflush(stdout);
	fflush(stderr);
	wprintf(L"Next: %x\n", hr);
	fflush(stdout);
	fflush(stderr);
	goto error;
    }
    RequestId = GetRequestId(pRow);

    fflush(stdout);
    fflush(stderr);
    wprintf(
	L"Row: %d  RequestId: %d%hs\n",
	*plNext,
	RequestId,
	*plNext + 2 == (LONG) RequestId? "" : " ERROR");
    fflush(stdout);
    fflush(stderr);

error:
    return(hr);
}


VOID
EnumView(
    IEnumCERTVIEWROW *pRow)
{
    HRESULT hr;
    LONG lNext;

    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Skip(0);		_PrintIfError(hr, "Skip(0)");
    hr = RowNext(pRow, &lNext);	_PrintIfError(hr, "Next");
    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Skip(1);		_PrintIfError(hr, "Skip(1)");
    hr = RowNext(pRow, &lNext);	_PrintIfError(hr, "Next");
    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Skip(2);		_PrintIfError(hr, "Skip(2)");
    hr = RowNext(pRow, &lNext);	_PrintIfError(hr, "Next");
    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Skip(3);		_PrintIfError(hr, "Skip(3)");
    hr = RowNext(pRow, &lNext);	_PrintIfError(hr, "Next");
    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Skip(4);		_PrintIfError(hr, "Skip(4)");
    hr = RowNext(pRow, &lNext);	_PrintIfError(hr, "Next");
    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Skip(5);		_PrintIfError(hr, "Skip(5)");
    hr = RowNext(pRow, &lNext);	_PrintIfError(hr, "Next");
    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Skip(6);		_PrintIfError(hr, "Skip(6)");
    hr = RowNext(pRow, &lNext);	_PrintIfError(hr, "Next");
    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Skip(7);		_PrintIfError(hr, "Skip(7)");
    hr = RowNext(pRow, &lNext);	_PrintIfError(hr, "Next");
    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Skip(8);		_PrintIfError(hr, "Skip(8)");
    hr = RowNext(pRow, &lNext);	_PrintIfError(hr, "Next");
    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Skip(9);		_PrintIfError(hr, "Skip(9)");
    hr = RowNext(pRow, &lNext);	_PrintIfError(hr, "Next");
    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Skip(10);	_PrintIfError(hr, "Skip(10)");
    hr = RowNext(pRow, &lNext);	_PrintIfError(hr, "Next");
    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Skip(11);	_PrintIfError(hr, "Skip(11)");
    hr = RowNext(pRow, &lNext);	_PrintIfError(hr, "Next");
    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Skip(12);	_PrintIfError(hr, "Skip(12)");
    hr = RowNext(pRow, &lNext);	_PrintIfError(hr, "Next");
    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Skip(13);	_PrintIfError(hr, "Skip(13)");
    hr = RowNext(pRow, &lNext);	_PrintIfError(hr, "Next");
    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Skip(14);	_PrintIfError(hr, "Skip(14)");
    hr = RowNext(pRow, &lNext);	_PrintIfError(hr, "Next");
    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Skip(15);	_PrintIfError(hr, "Skip(15)");
    hr = RowNext(pRow, &lNext);	_PrintIfError(hr, "Next");
    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Skip(16);	_PrintIfError(hr, "Skip(16)");
    hr = RowNext(pRow, &lNext);	_PrintIfError(hr, "Next");
    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Skip(17);	_PrintIfError(hr, "Skip(17)");
    hr = RowNext(pRow, &lNext);	_PrintIfError(hr, "Next");
    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Skip(18);	_PrintIfError(hr, "Skip(18)");
    hr = RowNext(pRow, &lNext);	_PrintIfError(hr, "Next");
    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Skip(3);		_PrintIfError(hr, "Skip(3)");
    hr = RowNext(pRow, &lNext);	_PrintIfError(hr, "Next");
    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Skip(4);		_PrintIfError(hr, "Skip(4)");
    hr = RowNext(pRow, &lNext);	_PrintIfError(hr, "Next");
    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Skip(5);		_PrintIfError(hr, "Skip(5)");
    hr = RowNext(pRow, &lNext);	_PrintIfError(hr, "Next");
    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Skip(14);	_PrintIfError(hr, "Skip(14)");
    hr = RowNext(pRow, &lNext);	_PrintIfError(hr, "Next");
    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Skip(15);	_PrintIfError(hr, "Skip(15)");
    hr = RowNext(pRow, &lNext);	_PrintIfError(hr, "Next");
    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Skip(16);	_PrintIfError(hr, "Skip(16)");
    hr = RowNext(pRow, &lNext);	_PrintIfError(hr, "Next");
    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Skip(17);	_PrintIfError(hr, "Skip(17)");
    hr = RowNext(pRow, &lNext);	_PrintIfError(hr, "Next");
    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Skip(18);	_PrintIfError(hr, "Skip(18)");
    hr = RowNext(pRow, &lNext);	_PrintIfError(hr, "Next");
    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Skip(19);	_PrintIfError(hr, "Skip(19)");
    hr = RowNext(pRow, &lNext);	_PrintIfError(hr, "Next");
    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Skip(20);	_PrintIfError(hr, "Skip(20)");
    hr = RowNext(pRow, &lNext);	_PrintIfError(hr, "Next");
    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Skip(21);	_PrintIfError(hr, "Skip(21)");
    hr = RowNext(pRow, &lNext);	_PrintIfError(hr, "Next");
    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Skip(22);	_PrintIfError(hr, "Skip(22)");
    hr = RowNext(pRow, &lNext);	_PrintIfError(hr, "Next");
    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Skip(23);	_PrintIfError(hr, "Skip(23)");
    hr = RowNext(pRow, &lNext);	_PrintIfError(hr, "Next");
    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Skip(24);	_PrintIfError(hr, "Skip(24)");
    hr = RowNext(pRow, &lNext);	_PrintIfError(hr, "Next");
    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Skip(25);	_PrintIfError(hr, "Skip(25)");
    hr = RowNext(pRow, &lNext);	_PrintIfError(hr, "Next");
    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Skip(26);	_PrintIfError(hr, "Skip(26)");
    hr = RowNext(pRow, &lNext);	_PrintIfError(hr, "Next");
    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Skip(27);	_PrintIfError(hr, "Skip(27)");
    hr = RowNext(pRow, &lNext);	_PrintIfError(hr, "Next");
    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Skip(28);	_PrintIfError(hr, "Skip(28)");
    hr = RowNext(pRow, &lNext);	_PrintIfError(hr, "Next");
    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Skip(29);	_PrintIfError(hr, "Skip(29)");
    hr = RowNext(pRow, &lNext);	_PrintIfError(hr, "Next");
    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Skip(30);	_PrintIfError(hr, "Skip(30)");
    hr = RowNext(pRow, &lNext);	_PrintIfError(hr, "Next");
    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Skip(31);	_PrintIfError(hr, "Skip(31)");
    hr = RowNext(pRow, &lNext);	_PrintIfError(hr, "Next");
    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Skip(32);	_PrintIfError(hr, "Skip(32)");
    hr = RowNext(pRow, &lNext);	_PrintIfError(hr, "Next");
    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Skip(46);	_PrintIfError(hr, "Skip(46)");
    hr = RowNext(pRow, &lNext);	_PrintIfError(hr, "Next");
    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Skip(47);	_PrintIfError(hr, "Skip(47)");
    hr = RowNext(pRow, &lNext);	_PrintIfError(hr, "Next");
    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Skip(48);	_PrintIfError(hr, "Skip(48)");
    hr = RowNext(pRow, &lNext);	_PrintIfError(hr, "Next");
    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Skip(49);	_PrintIfError(hr, "Skip(49)");
    hr = RowNext(pRow, &lNext);	_PrintIfError(hr, "Next");
    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Skip(50);	_PrintIfError(hr, "Skip(50)");
    hr = RowNext(pRow, &lNext);	_PrintIfError(hr, "Next");
    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Skip(51);	_PrintIfError(hr, "Skip(51)");
    hr = RowNext(pRow, &lNext);	_PrintIfError(hr, "Next");
    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Skip(52);	_PrintIfError(hr, "Skip(52)");
    hr = RowNext(pRow, &lNext);	_PrintIfError(hr, "Next");
    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Skip(53);	_PrintIfError(hr, "Skip(53)");
    hr = RowNext(pRow, &lNext);	_PrintIfError(hr, "Next");
    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Skip(54);	_PrintIfError(hr, "Skip(54)");
    hr = RowNext(pRow, &lNext);	_PrintIfError(hr, "Next");
    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Skip(55);	_PrintIfError(hr, "Skip(55)");
    hr = RowNext(pRow, &lNext);	_PrintIfError(hr, "Next");
    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Skip(56);	_PrintIfError(hr, "Skip(56)");
    hr = RowNext(pRow, &lNext);	_PrintIfError(hr, "Next");
    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Skip(57);	_PrintIfError(hr, "Skip(57)");
    hr = RowNext(pRow, &lNext);	_PrintIfError(hr, "Next");
    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Skip(58);	_PrintIfError(hr, "Skip(58)");
    hr = RowNext(pRow, &lNext);	_PrintIfError(hr, "Next");
    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Skip(59);	_PrintIfError(hr, "Skip(59)");
    hr = RowNext(pRow, &lNext);	_PrintIfError(hr, "Next");
    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Skip(60);	_PrintIfError(hr, "Skip(60)");
    hr = RowNext(pRow, &lNext);	_PrintIfError(hr, "Next");
    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Skip(61);	_PrintIfError(hr, "Skip(61)");
    hr = RowNext(pRow, &lNext);	_PrintIfError(hr, "Next");
    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Skip(62);	_PrintIfError(hr, "Skip(62)");
    hr = RowNext(pRow, &lNext);	_PrintIfError(hr, "Next");
    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Skip(63);	_PrintIfError(hr, "Skip(63)");
    hr = RowNext(pRow, &lNext);	_PrintIfError(hr, "Next");
    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Skip(64);	_PrintIfError(hr, "Skip(64)");
    hr = RowNext(pRow, &lNext);	_PrintIfError(hr, "Next");
    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Skip(62);	_PrintIfError(hr, "Skip(62)");
    hr = RowNext(pRow, &lNext);	_PrintIfError(hr, "Next");
    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Skip(63);	_PrintIfError(hr, "Skip(63)");
    hr = RowNext(pRow, &lNext);	_PrintIfError(hr, "Next");
    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Skip(61);	_PrintIfError(hr, "Skip(61)");
    hr = RowNext(pRow, &lNext);	_PrintIfError(hr, "Next");
    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Skip(62);	_PrintIfError(hr, "Skip(62)");
    hr = RowNext(pRow, &lNext);	_PrintIfError(hr, "Next");
    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Skip(46);	_PrintIfError(hr, "Skip(46)");
    hr = RowNext(pRow, &lNext);	_PrintIfError(hr, "Next");
    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Skip(47);	_PrintIfError(hr, "Skip(47)");
    hr = RowNext(pRow, &lNext);	_PrintIfError(hr, "Next");
    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Skip(48);	_PrintIfError(hr, "Skip(48)");
    hr = RowNext(pRow, &lNext);	_PrintIfError(hr, "Next");
    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Skip(49);	_PrintIfError(hr, "Skip(49)");
    hr = RowNext(pRow, &lNext);	_PrintIfError(hr, "Next");
    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Skip(50);	_PrintIfError(hr, "Skip(50)");
    hr = RowNext(pRow, &lNext);	_PrintIfError(hr, "Next");
    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Skip(51);	_PrintIfError(hr, "Skip(51)");
    hr = RowNext(pRow, &lNext);	_PrintIfError(hr, "Next");
    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Skip(52);	_PrintIfError(hr, "Skip(52)");
    hr = RowNext(pRow, &lNext);	_PrintIfError(hr, "Next");
    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Skip(53);	_PrintIfError(hr, "Skip(53)");
    hr = RowNext(pRow, &lNext);	_PrintIfError(hr, "Next");
    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Skip(54);	_PrintIfError(hr, "Skip(54)");
    hr = RowNext(pRow, &lNext);	_PrintIfError(hr, "Next");
    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Skip(55);	_PrintIfError(hr, "Skip(55)");
    hr = RowNext(pRow, &lNext);	_PrintIfError(hr, "Next");
    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Skip(56);	_PrintIfError(hr, "Skip(56)");
    hr = RowNext(pRow, &lNext);	_PrintIfError(hr, "Next");
    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Skip(57);	_PrintIfError(hr, "Skip(57)");
    hr = RowNext(pRow, &lNext);	_PrintIfError(hr, "Next");
    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Skip(58);	_PrintIfError(hr, "Skip(58)");
    hr = RowNext(pRow, &lNext);	_PrintIfError(hr, "Next");
    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Skip(59);	_PrintIfError(hr, "Skip(59)");
    hr = RowNext(pRow, &lNext);	_PrintIfError(hr, "Next");
    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Skip(60);	_PrintIfError(hr, "Skip(60)");
    hr = RowNext(pRow, &lNext);	_PrintIfError(hr, "Next");
    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Skip(61);	_PrintIfError(hr, "Skip(61)");
    hr = RowNext(pRow, &lNext);	_PrintIfError(hr, "Next");
    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Skip(29);	_PrintIfError(hr, "Skip(29)");
    hr = RowNext(pRow, &lNext);	_PrintIfError(hr, "Next");
    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Skip(30);	_PrintIfError(hr, "Skip(30)");
    hr = RowNext(pRow, &lNext);	_PrintIfError(hr, "Next");
    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Skip(31);	_PrintIfError(hr, "Skip(31)");
    hr = RowNext(pRow, &lNext);	_PrintIfError(hr, "Next");
    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Skip(32);	_PrintIfError(hr, "Skip(32)");
    hr = RowNext(pRow, &lNext);	_PrintIfError(hr, "Next");
    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Skip(33);	_PrintIfError(hr, "Skip(33)");
    hr = RowNext(pRow, &lNext);	_PrintIfError(hr, "Next");
    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Skip(34);	_PrintIfError(hr, "Skip(34)");
    hr = RowNext(pRow, &lNext);	_PrintIfError(hr, "Next");
    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Skip(35);	_PrintIfError(hr, "Skip(35)");
    hr = RowNext(pRow, &lNext);	_PrintIfError(hr, "Next");
    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Skip(36);	_PrintIfError(hr, "Skip(36)");
    hr = RowNext(pRow, &lNext);	_PrintIfError(hr, "Next");
    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Skip(37);	_PrintIfError(hr, "Skip(37)");
    hr = RowNext(pRow, &lNext);	_PrintIfError(hr, "Next");
    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Skip(38);	_PrintIfError(hr, "Skip(38)");
    hr = RowNext(pRow, &lNext);	_PrintIfError(hr, "Next");
    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Skip(39);	_PrintIfError(hr, "Skip(39)");
    hr = RowNext(pRow, &lNext);	_PrintIfError(hr, "Next");
    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Skip(40);	_PrintIfError(hr, "Skip(40)");
    hr = RowNext(pRow, &lNext);	_PrintIfError(hr, "Next");
    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Skip(41);	_PrintIfError(hr, "Skip(41)");
    hr = RowNext(pRow, &lNext);	_PrintIfError(hr, "Next");
    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Skip(42);	_PrintIfError(hr, "Skip(42)");
    hr = RowNext(pRow, &lNext);	_PrintIfError(hr, "Next");
    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Skip(43);	_PrintIfError(hr, "Skip(43)");
    hr = RowNext(pRow, &lNext);	_PrintIfError(hr, "Next");
    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Skip(44);	_PrintIfError(hr, "Skip(44)");
    hr = RowNext(pRow, &lNext);	_PrintIfError(hr, "Next");
    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Skip(45);	_PrintIfError(hr, "Skip(45)");
    hr = RowNext(pRow, &lNext);	_PrintIfError(hr, "Next");
    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Skip(46);	_PrintIfError(hr, "Skip(46)");
    hr = RowNext(pRow, &lNext);	_PrintIfError(hr, "Next");
    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Skip(12);	_PrintIfError(hr, "Skip(12)");
    hr = RowNext(pRow, &lNext);	_PrintIfError(hr, "Next");
    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Skip(13);	_PrintIfError(hr, "Skip(13)");
    hr = RowNext(pRow, &lNext);	_PrintIfError(hr, "Next");
    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Skip(14);	_PrintIfError(hr, "Skip(14)");
    hr = RowNext(pRow, &lNext);	_PrintIfError(hr, "Next");
    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Skip(15);	_PrintIfError(hr, "Skip(15)");
    hr = RowNext(pRow, &lNext);	_PrintIfError(hr, "Next");
    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Skip(16);	_PrintIfError(hr, "Skip(16)");
    hr = RowNext(pRow, &lNext);	_PrintIfError(hr, "Next");
    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Skip(17);	_PrintIfError(hr, "Skip(17)");
    hr = RowNext(pRow, &lNext);	_PrintIfError(hr, "Next");
    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Skip(18);	_PrintIfError(hr, "Skip(18)");
    hr = RowNext(pRow, &lNext);	_PrintIfError(hr, "Next");
    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Skip(19);	_PrintIfError(hr, "Skip(19)");
    hr = RowNext(pRow, &lNext);	_PrintIfError(hr, "Next");
    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Skip(20);	_PrintIfError(hr, "Skip(20)");
    hr = RowNext(pRow, &lNext);	_PrintIfError(hr, "Next");
    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Skip(21);	_PrintIfError(hr, "Skip(21)");
    hr = RowNext(pRow, &lNext);	_PrintIfError(hr, "Next");
    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Skip(22);	_PrintIfError(hr, "Skip(22)");
    hr = RowNext(pRow, &lNext);	_PrintIfError(hr, "Next");
    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Skip(23);	_PrintIfError(hr, "Skip(23)");
    hr = RowNext(pRow, &lNext);	_PrintIfError(hr, "Next");
    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Skip(24);	_PrintIfError(hr, "Skip(24)");
    hr = RowNext(pRow, &lNext);	_PrintIfError(hr, "Next");
    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Skip(25);	_PrintIfError(hr, "Skip(25)");
    hr = RowNext(pRow, &lNext);	_PrintIfError(hr, "Next");
    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Skip(26);	_PrintIfError(hr, "Skip(26)");
    hr = RowNext(pRow, &lNext);	_PrintIfError(hr, "Next");
    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Skip(27);	_PrintIfError(hr, "Skip(27)");
    hr = RowNext(pRow, &lNext);	_PrintIfError(hr, "Next");
    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Skip(28);	_PrintIfError(hr, "Skip(28)");
    hr = RowNext(pRow, &lNext);	_PrintIfError(hr, "Next");
    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Skip(29);	_PrintIfError(hr, "Skip(29)");
    hr = RowNext(pRow, &lNext);	_PrintIfError(hr, "Next");
    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Skip(0);		_PrintIfError(hr, "Skip(0)");
    hr = RowNext(pRow, &lNext);	_PrintIfError(hr, "Next");
    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Skip(1);		_PrintIfError(hr, "Skip(1)");
    hr = RowNext(pRow, &lNext);	_PrintIfError(hr, "Next");
    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Skip(2);		_PrintIfError(hr, "Skip(2)");
    hr = RowNext(pRow, &lNext);	_PrintIfError(hr, "Next");
    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Skip(3);		_PrintIfError(hr, "Skip(3)");
    hr = RowNext(pRow, &lNext);	_PrintIfError(hr, "Next");
    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Skip(4);		_PrintIfError(hr, "Skip(4)");
    hr = RowNext(pRow, &lNext);	_PrintIfError(hr, "Next");
    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Skip(5);		_PrintIfError(hr, "Skip(5)");
    hr = RowNext(pRow, &lNext);	_PrintIfError(hr, "Next");
    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Skip(6);		_PrintIfError(hr, "Skip(6)");
    hr = RowNext(pRow, &lNext);	_PrintIfError(hr, "Next");
    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Skip(7);		_PrintIfError(hr, "Skip(7)");
    hr = RowNext(pRow, &lNext);	_PrintIfError(hr, "Next");
    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Skip(8);		_PrintIfError(hr, "Skip(8)");
    hr = RowNext(pRow, &lNext);	_PrintIfError(hr, "Next");
    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Skip(9);		_PrintIfError(hr, "Skip(9)");
    hr = RowNext(pRow, &lNext);	_PrintIfError(hr, "Next");
    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Skip(10);	_PrintIfError(hr, "Skip(10)");
    hr = RowNext(pRow, &lNext);	_PrintIfError(hr, "Next");
    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Skip(11);	_PrintIfError(hr, "Skip(11)");
    hr = RowNext(pRow, &lNext);	_PrintIfError(hr, "Next");
    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Skip(12);	_PrintIfError(hr, "Skip(12)");
    hr = RowNext(pRow, &lNext);	_PrintIfError(hr, "Next");
    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Skip(110);	_PrintIfError(hr, "Skip(110)");
    hr = RowNext(pRow, &lNext);	_PrintIfError(hr, "Expected END: Next");


    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Skip(81);	_PrintIfError(hr, "Skip(81)");
    hr = RowNext(pRow, &lNext);	_PrintIfError(hr, "Next");
    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Skip(82);	_PrintIfError(hr, "Skip(82)");
    hr = RowNext(pRow, &lNext);	_PrintIfError(hr, "Next");
    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Skip(83);	_PrintIfError(hr, "Skip(83)");
    hr = RowNext(pRow, &lNext);	_PrintIfError(hr, "Next");
    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Skip(84);	_PrintIfError(hr, "Skip(84)");
    hr = RowNext(pRow, &lNext);	_PrintIfError(hr, "Next");
    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Skip(85);	_PrintIfError(hr, "Skip(85)");
    hr = RowNext(pRow, &lNext);	_PrintIfError(hr, "Next");
    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Skip(86);	_PrintIfError(hr, "Skip(86)");
    hr = RowNext(pRow, &lNext);	_PrintIfError(hr, "Next");
    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Skip(87);	_PrintIfError(hr, "Skip(87)");
    hr = RowNext(pRow, &lNext);	_PrintIfError(hr, "Next");
    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Skip(88);	_PrintIfError(hr, "Skip(88)");
    hr = RowNext(pRow, &lNext);	_PrintIfError(hr, "Next");
    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Skip(89);	_PrintIfError(hr, "Skip(89)");
    hr = RowNext(pRow, &lNext);	_PrintIfError(hr, "Next");
    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Skip(90);	_PrintIfError(hr, "Skip(90)");
    hr = RowNext(pRow, &lNext);	_PrintIfError(hr, "Next");
    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Skip(91);	_PrintIfError(hr, "Skip(91)");
    hr = RowNext(pRow, &lNext);	_PrintIfError(hr, "Next");
    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Skip(92);	_PrintIfError(hr, "Skip(92)");
    hr = RowNext(pRow, &lNext);	_PrintIfError(hr, "Next");
    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Skip(93);	_PrintIfError(hr, "Skip(93)");
    hr = RowNext(pRow, &lNext);	_PrintIfError(hr, "Next");
    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Skip(94);	_PrintIfError(hr, "Skip(94)");
    hr = RowNext(pRow, &lNext);	_PrintIfError(hr, "Next");
    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Skip(95);	_PrintIfError(hr, "Skip(95)");
    hr = RowNext(pRow, &lNext);	_PrintIfError(hr, "Next");
    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Skip(96);	_PrintIfError(hr, "Skip(96)");
    hr = RowNext(pRow, &lNext);	_PrintIfError(hr, "Next");
    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Skip(97);	_PrintIfError(hr, "Skip(97)");
    hr = RowNext(pRow, &lNext);	_PrintIfError(hr, "Next");
    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Skip(98);	_PrintIfError(hr, "Skip(98)");
    hr = RowNext(pRow, &lNext);	_PrintIfError(hr, "Next");
    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Skip(0);		_PrintIfError(hr, "Skip(0)");
    hr = RowNext(pRow, &lNext);	_PrintIfError(hr, "Next");
    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Skip(1);		_PrintIfError(hr, "Skip(1)");
    hr = RowNext(pRow, &lNext);	_PrintIfError(hr, "Next");
    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Skip(2);		_PrintIfError(hr, "Skip(2)");
    hr = RowNext(pRow, &lNext);	_PrintIfError(hr, "Next");
    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Skip(3);		_PrintIfError(hr, "Skip(3)");
    hr = RowNext(pRow, &lNext);	_PrintIfError(hr, "Next");
    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Skip(4);		_PrintIfError(hr, "Skip(4)");
    hr = RowNext(pRow, &lNext);	_PrintIfError(hr, "Next");
    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Skip(5);		_PrintIfError(hr, "Skip(5)");
    hr = RowNext(pRow, &lNext);	_PrintIfError(hr, "Next");
    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Skip(6);		_PrintIfError(hr, "Skip(6)");
    hr = RowNext(pRow, &lNext);	_PrintIfError(hr, "Next");
    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Skip(7);		_PrintIfError(hr, "Skip(7)");
    hr = RowNext(pRow, &lNext);	_PrintIfError(hr, "Next");
    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Skip(8);		_PrintIfError(hr, "Skip(8)");
    hr = RowNext(pRow, &lNext);	_PrintIfError(hr, "Next");
    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Skip(9);		_PrintIfError(hr, "Skip(9)");
    hr = RowNext(pRow, &lNext);	_PrintIfError(hr, "Next");
    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Skip(10);	_PrintIfError(hr, "Skip(10)");
    hr = RowNext(pRow, &lNext);	_PrintIfError(hr, "Next");
    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Skip(11);	_PrintIfError(hr, "Skip(11)");
    hr = RowNext(pRow, &lNext);	_PrintIfError(hr, "Next");
    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Skip(12);	_PrintIfError(hr, "Skip(12)");
    hr = RowNext(pRow, &lNext);	_PrintIfError(hr, "Next");
    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Skip(13);	_PrintIfError(hr, "Skip(13)");
    hr = RowNext(pRow, &lNext);	_PrintIfError(hr, "Next");
    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Skip(14);	_PrintIfError(hr, "Skip(14)");
    hr = RowNext(pRow, &lNext);	_PrintIfError(hr, "Next");
    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Skip(15);	_PrintIfError(hr, "Skip(15)");
    hr = RowNext(pRow, &lNext);	_PrintIfError(hr, "Next");
    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Skip(16);	_PrintIfError(hr, "Skip(16)");
    hr = RowNext(pRow, &lNext);	_PrintIfError(hr, "Next");
    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Skip(17);	_PrintIfError(hr, "Skip(17)");
    hr = RowNext(pRow, &lNext);	_PrintIfError(hr, "Next");
    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Skip(18);	_PrintIfError(hr, "Skip(18)");
    hr = RowNext(pRow, &lNext);	_PrintIfError(hr, "Next");
    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Skip(0);		_PrintIfError(hr, "Skip(0)");
    hr = RowNext(pRow, &lNext);	_PrintIfError(hr, "Next");
    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Skip(1);		_PrintIfError(hr, "Skip(1)");
    hr = RowNext(pRow, &lNext);	_PrintIfError(hr, "Next");
    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Skip(2);		_PrintIfError(hr, "Skip(2)");
    hr = RowNext(pRow, &lNext);	_PrintIfError(hr, "Next");
    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Skip(3);		_PrintIfError(hr, "Skip(3)");
    hr = RowNext(pRow, &lNext);	_PrintIfError(hr, "Next");
    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Skip(4);		_PrintIfError(hr, "Skip(4)");
    hr = RowNext(pRow, &lNext);	_PrintIfError(hr, "Next");
    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Skip(5);		_PrintIfError(hr, "Skip(5)");
    hr = RowNext(pRow, &lNext);	_PrintIfError(hr, "Next");
    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Skip(6);		_PrintIfError(hr, "Skip(6)");
    hr = RowNext(pRow, &lNext);	_PrintIfError(hr, "Next");
    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Skip(7);		_PrintIfError(hr, "Skip(7)");
    hr = RowNext(pRow, &lNext);	_PrintIfError(hr, "Next");
    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Skip(8);		_PrintIfError(hr, "Skip(8)");
    hr = RowNext(pRow, &lNext);	_PrintIfError(hr, "Next");
    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Skip(9);		_PrintIfError(hr, "Skip(9)");
    hr = RowNext(pRow, &lNext);	_PrintIfError(hr, "Next");
    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Skip(10);	_PrintIfError(hr, "Skip(10)");
    hr = RowNext(pRow, &lNext);	_PrintIfError(hr, "Next");
    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Skip(11);	_PrintIfError(hr, "Skip(11)");
    hr = RowNext(pRow, &lNext);	_PrintIfError(hr, "Next");
    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Skip(12);	_PrintIfError(hr, "Skip(12)");
    hr = RowNext(pRow, &lNext);	_PrintIfError(hr, "Next");
    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Skip(13);	_PrintIfError(hr, "Skip(13)");
    hr = RowNext(pRow, &lNext);	_PrintIfError(hr, "Next");
    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Skip(14);	_PrintIfError(hr, "Skip(14)");
    hr = RowNext(pRow, &lNext);	_PrintIfError(hr, "Next");
    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Skip(15);	_PrintIfError(hr, "Skip(15)");
    hr = RowNext(pRow, &lNext);	_PrintIfError(hr, "Next");
    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Skip(16);	_PrintIfError(hr, "Skip(16)");
    hr = RowNext(pRow, &lNext);	_PrintIfError(hr, "Next");
    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Skip(17);	_PrintIfError(hr, "Skip(17)");
    hr = RowNext(pRow, &lNext);	_PrintIfError(hr, "Next");
    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Skip(18);	_PrintIfError(hr, "Skip(18)");
    hr = RowNext(pRow, &lNext);	_PrintIfError(hr, "Next");
    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Skip(19);	_PrintIfError(hr, "Skip(19)");
    hr = RowNext(pRow, &lNext);	_PrintIfError(hr, "Next");
    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Skip(20);	_PrintIfError(hr, "Skip(20)");
    hr = RowNext(pRow, &lNext);	_PrintIfError(hr, "Next");
    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Skip(21);	_PrintIfError(hr, "Skip(21)");
    hr = RowNext(pRow, &lNext);	_PrintIfError(hr, "Next");
    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Skip(22);	_PrintIfError(hr, "Skip(22)");
    hr = RowNext(pRow, &lNext);	_PrintIfError(hr, "Next");
    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Skip(23);	_PrintIfError(hr, "Skip(23)");
    hr = RowNext(pRow, &lNext);	_PrintIfError(hr, "Next");
    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Skip(24);	_PrintIfError(hr, "Skip(24)");
    hr = RowNext(pRow, &lNext);	_PrintIfError(hr, "Next");
    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Skip(25);	_PrintIfError(hr, "Skip(25)");
    hr = RowNext(pRow, &lNext);	_PrintIfError(hr, "Next");
    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Skip(26);	_PrintIfError(hr, "Skip(26)");
    hr = RowNext(pRow, &lNext);	_PrintIfError(hr, "Next");
    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Skip(27);	_PrintIfError(hr, "Skip(27)");
    hr = RowNext(pRow, &lNext);	_PrintIfError(hr, "Next");
    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Skip(28);	_PrintIfError(hr, "Skip(28)");
    hr = RowNext(pRow, &lNext);	_PrintIfError(hr, "Next");
    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Skip(29);	_PrintIfError(hr, "Skip(29)");
    hr = RowNext(pRow, &lNext);	_PrintIfError(hr, "Next");
    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Skip(30);	_PrintIfError(hr, "Skip(30)");
    hr = RowNext(pRow, &lNext);	_PrintIfError(hr, "Next");
    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Skip(31);	_PrintIfError(hr, "Skip(31)");
    hr = RowNext(pRow, &lNext);	_PrintIfError(hr, "Next");
    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Skip(32);	_PrintIfError(hr, "Skip(32)");
    hr = RowNext(pRow, &lNext);	_PrintIfError(hr, "Next");
    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Skip(33);	_PrintIfError(hr, "Skip(33)");
    hr = RowNext(pRow, &lNext);	_PrintIfError(hr, "Next");
    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Skip(34);	_PrintIfError(hr, "Skip(34)");
    hr = RowNext(pRow, &lNext);	_PrintIfError(hr, "Next");
    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Skip(35);	_PrintIfError(hr, "Skip(35)");
    hr = RowNext(pRow, &lNext);	_PrintIfError(hr, "Next");

    wprintf(L"About to Reset+Skip(17)+Next\n");

    hr = pRow->Reset();		_PrintIfError(hr, "Reset");
    hr = pRow->Skip(17);	_PrintIfError(hr, "Skip(17)");
    hr = RowNext(pRow, &lNext);	_PrintIfError(hr, "Next");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\tools\viewtest\resource.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       resource.h
//
//--------------------------------------------------------------------------

//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
//

#define IDI_APP                         		201
#define IDI_PRODUCT                     		202

#define IDS_DUMP_DESCRIPTION				301
#define IDS_GETCONFIG_DESCRIPTION			302
#define IDS_GETCONFIG2_DESCRIPTION			303
#define IDS_KEYGEN_DESCRIPTION				304
#define IDS_DECODEHEX_DESCRIPTION			305
#define IDS_DECODE_DESCRIPTION				306
#define IDS_ENCODE_DESCRIPTION				307
#define IDS_DENY_DESCRIPTION				308
#define IDS_RESUBMIT_DESCRIPTION			309
#define IDS_REVOKE_DESCRIPTION				310
#define IDS_CRL_DESCRIPTION				311
#define IDS_GETCRT_DESCRIPTION				312
#define IDS_ISVALID_DESCRIPTION				313
#define IDS_SETATTRIBUTES_DESCRIPTION			314
#define IDS_SETEXTENSION_DESCRIPTION			315
#define IDS_CACERT_DESCRIPTION				316
#define IDS_CACHAIN_DESCRIPTION				317
#define IDS_LOG_DESCRIPTION				318
#define IDS_QUEUE_DESCRIPTION				319
#define IDS_DB_DESCRIPTION				320
#define IDS_VERIFYKEYS_DESCRIPTION			321
#define IDS_VERIFY_DESCRIPTION				322
#define IDS_7F_DESCRIPTION				323
#define IDS_USAGE_DESCRIPTION				324
#define IDS_VERBOSE_DESCRIPTION				325
#define IDS_IDISPATCH_DESCRIPTION			326
#define IDS_REVERSE_DESCRIPTION				327
#define IDS_OPTIONS_USAGEARGS				328
#define IDS_KEYGEN_USAGEARGS				329
#define IDS_INFILEOUTFILE_USAGEARGS			330
#define IDS_SCHEMA_COLUMNHEADERS 			331
#define IDS_SCHEMA_COLUMNUNDERLINE			332
#define IDS_DENY_USAGEARGS				333
#define IDS_RESUBMIT_USAGEARGS				334
#define IDS_REVOKE_USAGEARGS				335
#define IDS_CRL_USAGEARGS				336
#define IDS_GETCRT_USAGEARGS				337
#define IDS_ISVALID_USAGEARGS				338
#define IDS_SETATTRIBUTES_USAGEARGS			339
#define IDS_SETEXTENSION_USAGEARGS			340
#define IDS_CACERT_USAGEARGS				341
#define IDS_CACHAIN_USAGEARGS				342
#define IDS_VERIFYKEYS_USAGEARGS			343
#define IDS_VERIFY_USAGEARGS				344
#define IDS_7F_USAGEARGS				345
#define IDS_ERR_NOMEMORY				346
#define IDS_USAGE_MISSINGCONFIGARG			347
#define IDS_USAGE_UNKNOWNARG				348
#define IDS_USAGE_MULTIPLEVERBARGS			349
#define IDS_USAGE_MISSINGARG				350
#define IDS_USAGE_TOOMANYARGS				351
#define IDS_USAGE_INTERNALVERBTABLEERROR		352
#define IDS_USAGE_EXTRACONFIGARG			353
#define IDS_USAGE_HEADER				354
#define IDS_USAGE_OPTIONS				355
#define IDS_USAGE_VERBS					356
#define IDS_USAGE_CONFIGSTRING				357
#define IDS_INDEXED					358
#define IDS_FORMAT_INPUT_LENGTH				359
#define IDS_NO_KEYAUTHORITYSERIAL			360
#define IDS_FORMAT_OUTPUT_LENGTH			361
#define IDS_ERR_FORMAT_DECODEFILE			362
#define IDS_ERR_FORMAT_ENCODETOFILE			363
#define IDS_ISSUER					364
#define IDS_SUBJECT					365
#define IDS_ERR_FORMAT_ISSUER_NOT_KEYAUTHORITY		366
#define IDS_ISSUER_IS_KEYAUTHORITY			367
#define IDS_NO_KEYAUTHORITY				368
#define IDS_SERIAL_NOT_KEYAUTHORITY			369
#define IDS_SERIAL_IS_KEYAUTHORITY			370
#define IDS_ISSUERNAME					371
#define IDS_KEYAUTHORITYNAME				372
#define IDS_KEYID					373
#define IDS_KEYAUTHORITYSERIAL				374
#define IDS_CASERIAL					375
#define IDS_ERR_FORMAT_CRYPTACQUIRECONTEXT		376
#define IDS_ERR_FORMAT_CRYPTEXPORTPUBLICKEYINFO		377
#define IDS_ERR_FORMAT_LOADKEYS				378
#define IDS_ERR_FORMAT_LOADCACERT			379
#define IDS_ERR_PUBLICKEY_MISMATCH			380
#define IDS_CONTAINER_PUBLIC_KEY			381
#define IDS_ROOT_PUBLIC_KEY				382
#define IDS_FORMAT_KEY_IS_VERIFY			383
#define IDS_FORMAT_KEY_NOT_VERIFY			384
#define IDS_FORMAT_IS_REVOKED				385
#define IDS_ERR_FORMAT_VERIFY_REVSTATUS			386
#define IDS_CANNOT_CHECK_REVSTATUS			387
#define IDS_REVSTATUS_OK				388
#define IDS_FORMAT_LOADTESTCERT				389
#define IDS_FORMAT_LOADCACERT				390
#define IDS_CERT					391
#define IDS_CA						392
#define IDS_CERT_SERIAL					393
#define IDS_ROOT_SERIAL					394
#define IDS_FORMAT_CA_NOT_ROOT				395
#define IDS_FORMAT_CA_SUBJECT_NOT_ISSUER		396
#define IDS_CA_SUBJECT_IS_ISSUER			397
#define IDS_FORMAT_CERTVERIFYSUBJECTCERTIFICATECONTEXT_FLAGS	398
#define IDS_ERR_FORMAT_VALIDATION			399
#define IDS_ERR_CA_SIG_NOT_ISSUER			400
#define IDS_ERR_EXPIRED					401
#define IDS_CURRENT_SIG_OK				402
#define IDS_CRL_DIST_POINTS				403
#define IDS_NETSCAPE_REVOCATION_URL			404
#define IDS_NO_REVCHECKEXTENSION			405
#define IDS_FORMAT_IS_VERIFY				406
#define IDS_FORMAT_NOT_VERIFY				407
#define IDS_FORMAT_REVCHECK_SKIPPED			408
#define IDS_FORMAT_REVCHECK_PASS			409
#define IDS_FORMAT_REVCHECK_REVOKED			410
#define IDS_FORMAT_REVCHECK_FAIL			411
#define IDS_SIGNATUREMATCHES				412
#define IDS_CRLENTRIES					413
#define IDS_CERTCOLON					414
#define IDS_QUESTIONMARKS				415
#define IDS_FORMAT_SUSPECT_LENGTH			416
#define IDS_FORMAT_FIELD				417
#define IDS_FORMAT_OID					418
#define IDS_FORMAT_EXTENSION_OID			419
#define IDS_ERR_FORMAT_NO_SIGNATUREMATCHES		420
#define IDS_ERR_FORMAT_CANNOT_DECODE			421
#define IDS_FORMAT_ALG_OID				422
#define IDS_ALG_PARAMETERS_COLON			423
#define IDS_NULL					424
#define IDS_FORMAT_PUBLICKEY_UNUSEDBITS			425
#define IDS_FORMAT_CHALLENGE_STRING			426
#define IDS_FORMAT_CONFIG_STRING			427
#define IDS_FORMAT_ICERTCONFIG_CONFIG_STRING		428
#define IDS_FORMAT_PENDING_REQUESTID			429
#define IDS_CERT_ISSUED					430
#define IDS_CERT_NOT_ISSUED_DISPOSITION			431
#define IDS_CERT_DISPOSITION_INVALID			432
#define IDS_CERT_DISPOSITION_VALID			433
#define IDS_CERT_DISPOSITION_REVOKED			434
#define IDS_PROPTYPE_DATE				435
#define IDS_PROPTYPE_LONG				436
#define IDS_PROPTYPE_STRING				437
#define IDS_PROPTYPE_BINARY				438
#define IDS_SCHEMA_COLON				439
#define IDS_FORMAT_ROWID				440
#define IDS_FORMAT_OPENING_DB				441
#define IDS_PROP_EMPTY					442
#define IDS_FORMAT_ERROR				443
#define IDS_SEPARATOR					444
#define IDS_REQTYPE_ANY					445
#define IDS_REQTYPE_PKCS10				446
#define IDS_REQTYPE_KEYGEN				447
#define IDS_REQTYPE_PKCS7				448
#define IDS_REQTYPE_UNKNOWN				449
#define IDS_REQFLAGS_FORCETELETEX			450
#define IDS_REQFLAGS_RENEWAL				451
#define IDS_CRITICAL					452
#define IDS_DISABLED					453
#define IDS_FORMAT_POLICYFLAGS				454
#define IDS_REQUEST					455
#define IDS_POLICY					456
#define IDS_ADMIN					457
#define IDS_SERVER					458
#define IDS_UNKNOWN					459
#define IDS_FORMAT_ORIGIN				460
#define IDS_FORMAT_UNKNOWN_HEX				461
#define IDS_FORMAT_REQUEST_ID				462
#define IDS_REQUEST_PROPERTIES				463
#define IDS_CERT_PROPERTIES				464
#define IDS_REQUEST_ATTRIBUTES				465
#define IDS_CERT_EXTENSIONS				466
#define IDS_FORMAT_EXTENSION				467
#define IDS_ERR_FORMAT_SHOW_TOO_FEW_ARGS		468
#define IDS_ERR_FORMAT_SHOW_TOO_MANY_ARGS		469
#define IDS_ERR_CONFIGGETCONFIG				470
#define IDS_ERR_FORMAT_COMMAND_FAILED			471

#define IDS_CHECK7F_FIELD_UNKNOWN			472
#define IDS_CHECK7F_FIELD_NONE				473
#define IDS_CHECK7F_FIELD_OTHER				474
#define IDS_CHECK7F_FIELD_ISSUER			475
#define IDS_CHECK7F_FIELD_ISSUERRDN			476
#define IDS_CHECK7F_FIELD_ISSUERRDNATTRIBUTE		477
#define IDS_CHECK7F_FIELD_ISSUERRDNSTRING		478
#define IDS_CHECK7F_FIELD_SUBJECT			479
#define IDS_CHECK7F_FIELD_SUBJECTRDN			480
#define IDS_CHECK7F_FIELD_SUBJECTRDNATTRIBUTE		481
#define IDS_CHECK7F_FIELD_SUBJECTRDNSTRING		482
#define IDS_CHECK7F_FIELD_EXTENSIONS			483
#define IDS_CHECK7F_FIELD_EXTENSIONARRAY		484
#define IDS_CHECK7F_FIELD_EXTENSION			485
#define IDS_CHECK7F_FIELD_EXTENSIONVALUE		486
#define IDS_CHECK7F_FIELD_EXTENSIONVALUERAW		487

#define IDS_NO_KEY_PROVIDER_INFO			488
#define IDS_VIEW_DESCRIPTION				489
#define IDS_LOGFAIL_DESCRIPTION				490
#define IDS_PING_DESCRIPTION				491
#define IDS_PINGADMIN_DESCRIPTION			492

#define IDS_CONFIGDISPLAY_COMMONNAME_COLON		493
#define IDS_CONFIGDISPLAY_ORGUNIT_COLON			494
#define IDS_CONFIGDISPLAY_ORG_COLON			495
#define IDS_CONFIGDISPLAY_LOCALITY_COLON		496
#define IDS_CONFIGDISPLAY_STATE_COLON			497
#define IDS_CONFIGDISPLAY_COUNTRY_COLON			498
#define IDS_CONFIGDISPLAY_CONFIG_COLON			499
#define IDS_CONFIGDISPLAY_EXCHANGECERT_COLON		500
#define IDS_CONFIGDISPLAY_SIGCERT_COLON			501
#define IDS_CONFIGDISPLAY_DESCRIPTION_COLON		502
#define IDS_CONFIGDISPLAY_SERVER_COLON			503
#define IDS_CONFIGDISPLAY_AUTHORITY_COLON		504
#define IDS_CONFIGDISPLAY_ENTRY				505

#define IDS_CERTIFICATEEXTENSIONS			506
#define IDS_REQUESTATTRIBUTES				507

#define IDS_SHUTDOWN_DESCRIPTION			508
#define IDS_USAGE_MISSINGOUTARG				509
#define IDS_SCHEMA_DESCRIPTION				510
#define IDS_USAGE_EXTRAOUTARG				511
#define IDS_USAGE_OUTSTRING				512

#define IDS_DUMP_CERT					513
#define IDS_DUMP_CRL					514
#define IDS_DUMP_REQUEST				515
#define IDS_DUMP_KEYGEN					516
#define IDS_FORMAT_VERSION				517
#define IDS_SERIAL					518
#define IDS_SIGNATURE_ALGORITHM				519
#define IDS_PUBLICKEY_ALGORITHM				520
#define IDS_ISSUERUNIQUEID				521
#define IDS_SUBJECTUNIQUEID				522
#define IDS_NOTBEFORE					523
#define IDS_NOTAFTER					524
#define IDS_THISUPDATE					525
#define IDS_NEXTUPDATE					526
#define IDS_REVOCATIONDATE				527
#define IDS_EXTENSIONS					528
#define IDS_CRLEXTENSIONS				529
#define IDS_DUMP_PKCS7					530
#define IDS_ERR_FORMAT_ROOT_CERT_BAD_SIG		531
#define IDS_NO_ROOT_CERT				532
#define IDS_ROOT_CERT					533
#define IDS_NO_ROOT_CERT_GOOD_SIG			534
#define IDS_REVOKING					535
#define IDS_PASSWORDPROMPT				536
#define IDS_UNKNOWN_EXTENSION				537
#define IDS_PRIVATEKEY					538
#define IDS_LENGTH					539
#define IDS_GMT_DESCRIPTION				540
#define IDS_GMT_SUFFIX					541
#define IDS_BACKUPPFX_USAGEARGS				542
#define IDS_BACKUPPFX_DESCRIPTION			543
#define IDS_RESTOREPFX_USAGEARGS			544
#define IDS_RESTOREPFX_DESCRIPTION			545
#define IDS_STORE_USAGEARGS				546
#define IDS_STORE_DESCRIPTION				547
#define IDS_FORMAT_PROVIDER_TYPE			548
#define IDS_FORMAT_KEY_CONTAINER			549
#define IDS_FORMAT_PROVIDER_NAME			550
#define IDS_FORMAT_KEYSPEC				551
#define IDS_FORMAT_FLAGS 				552
#define IDS_FORMAT_RESTORED				553
#define IDS_FORMAT_BACKEDUP				554
#define IDS_HIER_USAGEARGS				555
#define IDS_HIER_DESCRIPTION				556
#define IDS_DUMP_PKCS7_CONTENTS				557
#define IDS_DUMP_PKCS7_ATTRIBUTES			558
#define IDS_DUMP_PKCS7_SIGNCERT				559
#define IDS_FORMAT_DUMP_LEVEL_START			560
#define IDS_FORMAT_DUMP_LEVEL_END			561
#define IDS_FORMAT_LANG					562
#define IDS_FORMAT_FILE					563
#define IDS_FORMAT_PRODUCT				564
#define IDS_DUMP_PKCS7_NO_SIGNCERT			565
#define IDS_DUMP_PKCS7_NO_CONTENT			566
#define IDS_DUMP_PKCS7_NO_CERTIFICATES			567
#define IDS_DUMP_PKCS7_NO_CRLS				568
#define IDS_DUMP_PKCS7_CERTIFICATES			569
#define IDS_DUMP_PKCS7_CRLS				570
#define IDS_RENEWAL_CERT				571
#define IDS_DUMP_PKCS7_NO_ATTRIBUTES			572
#define IDS_FORMAT_PKCS7_ATTRIBUTE_COUNT		573
#define IDS_ATTRIBUTE					574
#define IDS_FORMAT_PKCS7_ATTRIBUTE_VALUE		575
#define IDS_BACKUPDB_USAGEARGS				576
#define IDS_BACKUPDB_DESCRIPTION			577
#define IDS_RESTOREDB_USAGEARGS				578
#define IDS_RESTOREDB_DESCRIPTION			579
#define IDS_CRL_REASON_UNSPECIFIED			580
#define IDS_CRL_REASON_KEY_COMPROMISE			581
#define IDS_CRL_REASON_CA_COMPROMISE			582
#define IDS_CRL_REASON_AFFILIATION_CHANGED		583
#define IDS_CRL_REASON_SUPERSEDED			584
#define IDS_CRL_REASON_CESSATION_OF_OPERATION		585
#define IDS_CRL_REASON_CERTIFICATE_HOLD			586
#define IDS_CRL_REASON_REMOVE_FROM_CRL			587
#define IDS_CSP_DESCRIPTION			        588
#define IDS_CSPTEST_DESCRIPTION				589
#define IDS_CSPTEST_USAGEARGS				590
#define IDS_USAGE_MISSINGRESTRICTARG			591
#define IDS_USAGE_RESTRICTSTRING			592
#define IDS_USAGE_EXTRARESTRICTARG			593
#define IDS_DISP_ACTIVE					594
#define IDS_DISP_PENDING				595
#define IDS_DISP_ISSUED					596
#define IDS_DISP_REVOKED				597
#define IDS_DISP_ERROR					598
#define IDS_DISP_DENIED					599
#define IDS_RENEWALCERT					600
#define IDS_FORMAT_RESTORE_NEEDS_RESTART		601
#define IDS_ADMIN_INTERFACE_ALIVE			602
#define IDS_DB_OPEN_FAILURE				603
#define IDS_DB_ACCESS_STOP_SERVER			604
#define IDS_CONFIGDISPLAY_LOCAL				605
#define IDS_ERR_FORMAT_NO_LOCAL_CONFIG			606
#define IDS_ERROR_ACCESSDENIED_CAUSE                    608
#define IDS_NO_KEY_PROPERTY				609
#define IDS_FORMAT_SERVER_ALIVE				610
#define IDS_FORMAT_CONNECTING				611
#define IDS_USER_DESCRIPTION				612
#define IDS_FORMAT_DUMP_CERT_INDEX			613
#define IDS_NEWPASSWORDPROMPT				614
#define IDS_CONFIRMPASSWORDPROMPT			615
#define IDS_NOCONFIRMPASSWORD				616
#define IDS_NO_KEY					617
#define IDS_BACKUP_USAGEARGS				618
#define IDS_BACKUP_DESCRIPTION				619
#define IDS_RESTORE_USAGEARGS				620
#define IDS_RESTORE_DESCRIPTION 			621
#define IDS_ADDSTORE_USAGEARGS				622
#define IDS_ADDSTORE_DESCRIPTION			623
#define IDS_DELSTORE_USAGEARGS				624
#define IDS_DELSTORE_DESCRIPTION			625
#define IDS_VERIFYSTORE_USAGEARGS			626
#define IDS_VERIFYSTORE_DESCRIPTION			627
#define IDS_FORMAT_DELETE_CERT_INDEX			628
#define IDS_UNTRUSTED_ROOT				629
#define IDS_INCOMPLETE_CHAIN				630
#define IDS_MATCHING_KEY				631
#define IDS_CR_DISP_INCOMPLETE				632
#define IDS_CR_DISP_ERROR				633
#define IDS_CR_DISP_DENIED				634
#define IDS_CR_DISP_ISSUED				635
#define IDS_CR_DISP_ISSUED_OUT_OF_BAND			636
#define IDS_CR_DISP_UNDER_SUBMISSION			637
#define IDS_CR_DISP_REVOKED				638
#define IDS_CERT_DISPOSITION_PENDING			639
#define IDS_ROOT_STORE_NEEDS_ROOT_CERT			640
#define IDS_FORCE_DESCRIPTION				641
#define IDS_FORMAT_USE_FORCE 				642
#define IDS_FORMAT_BACKEDUPDBNOFULL			643
#define IDS_FORMAT_BACKEDUPDBFULL			644
#define IDS_FORMAT_BACKEDUPDB				645
#define IDS_FORMAT_BACKEDUPDBKEEP			646
#define IDS_FORMAT_BACKEDUPDBNOKEEP			647
#define IDS_FORMAT_RESTOREDB				648
#define IDS_UNKNOWN_ATTRIBUTE				649
#define IDS_OID_USAGEARGS				650
#define IDS_OID_DESCRIPTION				651
#define IDS_UNKNOWN_OBJECTID				652
#define IDS_IMPORTCERT_USAGEARGS                        653
#define IDS_IMPORTCERT_DESCRIPTION                      654
#define IDS_FORMAT_IMPORTCERT                           655
#define IDS_REVOCATION_OFFLINE				656
#define IDS_NO_REVOCATION_CHECK				657
#define IDS_DYNAMICFILES_DESCRIPTION			658
#define IDS_GETREG_USAGEARGS				659
#define IDS_GETREG_DESCRIPTION				660
#define IDS_SETREG_USAGEARGS				661
#define IDS_SETREG_DESCRIPTION				662
#define IDS_OLD_REG_VALUE				663
#define IDS_NEW_REG_VALUE				664
#define IDS_FORMAT_ALTNAMECOUNT				665
#define IDS_ALTNAME					666
#define IDS_DATABASELOCATIONS_DESCRIPTION		667
#define IDS_FORMAT_INVALIDBACKUPDIR			668
#define IDS_FORMAT_INVALIDRESTOREDIR			669
#define IDS_FORMAT_BADBACKUPRESULTS			670
#define IDS_FORMAT_RESTOREDDBNOFULL			671
#define IDS_FORMAT_RESTOREDDBFULL			672
#define IDS_IMPORTEDCERT				673
#define IDS_NOWNOTBEFORE_ERROR				674
#define IDS_NOWNOTAFTER_ERROR				675
#define IDS_CANOTBEFORE_ERROR				676
#define IDS_CANOTAFTER_ERROR				677
#define IDS_TELETEX_EXTENSIONS				678
#define IDS_ERRCODE_USAGEARGS				679
#define IDS_ERRCODE_DESCRIPTION				680
#define IDS_VROOT_DESCRIPTION				681
#define IDS_FORMAT_VROOT				682
#define IDS_FORMAT_FILESHARE				683
#define IDS_VROOTDISP_CREATED				684
#define IDS_VROOTDISP_DELETED				685
#define IDS_VROOTDISP_EXISTS				686
#define IDS_VROOTDISP_NOTFOUND				687
#define IDS_VROOTDISP_CREATEERROR			688
#define IDS_VROOTDISP_DELETERROR			689
#define IDS_VROOTDISP_NOTSUPPORTED			690
#define IDS_VROOT_USAGEARGS				691
#define IDS_BACKUPPROGRESSDB				692
#define IDS_BACKUPPROGRESSLOG				693
#define IDS_BACKUPPROGRESSTRUNCATELOG			694
#define IDS_RESTOREPROGRESSDB				695
#define IDS_RESTOREPROGRESSLOG				696
#define IDS_MAXINDEX					697
#define IDS_DISP_CA_CERT				698
#define IDS_DISP_CA_CERT_CHAIN				699

// Next default values for new objects

#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        698
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1006
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\scerpc\commonrc.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    scedllrc.h

Abstract:

    This module defines resource IDs for strings

Author:

    Jin Huang (Jinhuang) 17-Sept.-1997

Revision History:

--*/
#ifndef __commonrc__
#define __commonrc__

#define IDS_EVERYONE                        17553
#define IDS_NAME_LOCAL                      17554
#define IDS_CREATOR_OWNER                   17555
#define IDS_CREATOR_GROUP                   17556
#define IDS_CREATOR_OWNER_SERVER            17557
#define IDS_CREATOR_GROUP_SERVER            17558
#define IDS_NT_PSEUDO_DOMAIN                17559
#define IDS_DIALUP                          17560
#define IDS_NETWORK                         17561
#define IDS_BATCH                           17562
#define IDS_INTERACTIVE                     17563
#define IDS_SERVICE                         17564
#define IDS_ANONYMOUS_LOGON                 17565
#define IDS_PROXY                           17566
#define IDS_ENTERPRISE_DOMAIN               17667
#define IDS_NAME_SELF                       17568
#define IDS_AUTHENTICATED_USERS             17569
#define IDS_RESTRICTED                      17570
#define IDS_TERMINAL_SERVER_USER            17571
#define IDS_ADMINISTRATORS                  17572
#define IDS_NAME_USERS                      17573
#define IDS_NAME_GUESTS                     17574
#define IDS_POWER_USERS                     17575
#define IDS_ACCOUNT_OPERATORS               17576
#define IDS_SERVER_OPERATORS                17577
#define IDS_PRINT_OPERATORS                 17578
#define IDS_BACKUP_OPERATORS                17579
#define IDS_REPLICATOR                      17580
#define IDS_LOCALSERVICE                    17581
#define IDS_NETWORKSERVICE                  17582
#define IDS_REMOTE_DESKTOP_USERS            17583
#define IDS_NETWORK_CONFIGURATION_OPERATORS 17584
#define IDS_LOCAL_SYSTEM                    17585
#define IDS_RAS_SERVERS                     17586
#define IDS_PREW2KCOMPACCESS                17587

#define SCEERR_ADD                          17600
#define SCEERR_ADD_MEMBEROF                 17601
#define SCEERR_ADD_MEMBERS                  17602
#define SCEERR_ADDTO                        17603
#define SCEERR_BUILD_OBJECT                 17604
#define SCEERR_BUILD_SD                     17605
#define SCEERR_CANT_FIND_DATATYPE           17606
#define SCEERR_CANT_FIND_KEYWORD            17607
#define SCEERR_CANT_FIND_SECTION            17608
#define SCEERR_CONVERT_LDAP                 17609
#define SCEERR_CREATE                       17610
#define SCEERR_ERROR_CREATE                 17611
#define SCEERR_INVALID_PATH                 17612
#define SCEERR_INVALID_PRIVILEGE            17613
#define SCEERR_MORE_OBJECTS                 17614
#define SCEERR_NOT_EXPECTED                 17615
#define SCEERR_OBJECT_FIELDS                17616
#define SCEERR_OPEN                         17617
#define SCEERR_OPEN_ID                      17618
#define SCEERR_PROCESS_OBJECT               17619
#define SCEERR_QUERY_INFO                   17620
#define SCEERR_QUERY_PRIVILEGE              17621
#define SCEERR_QUERY_VALUE                  17622
#define SCEERR_REGVALUE_FIELDS              17623
#define SCEERR_SET_SECURITY                 17624
#define SCEERR_WRITE_INFO                   17625

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\scerpc\common.cpp ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    common.cpp

Abstract:

    Shared APIs

Author:

    Jin Huang

Revision History:

    jinhuang        23-Jan-1998   merged from multiple modules

--*/
#include "headers.h"
#include <alloca.h>

#if DBG

    DEFINE_DEBUG2(Sce);

    DEBUG_KEY   SceDebugKeys[] = {{DEB_ERROR,        "Error"},
                                 {DEB_WARN,          "Warn"},
                                 {DEB_TRACE,         "Trace"},
                                 {0,                 NULL}};


    VOID
    DebugInitialize()
    {
        SceInitDebug(SceDebugKeys);
    }

    VOID
    DebugUninit()
    {
        SceUnloadDebug();
    }

#endif // DBG

HINSTANCE MyModuleHandle=NULL;
HANDLE  hEventLog = NULL;
TCHAR EventSource[64];
const TCHAR c_szCRLF[]    = TEXT("\r\n");

#define RIGHT_DS_CREATE_CHILD     ACTRL_DS_CREATE_CHILD
#define RIGHT_DS_DELETE_CHILD     ACTRL_DS_DELETE_CHILD
#define RIGHT_DS_DELETE_SELF      DELETE
#define RIGHT_DS_LIST_CONTENTS    ACTRL_DS_LIST
#define RIGHT_DS_SELF_WRITE       ACTRL_DS_SELF
#define RIGHT_DS_READ_PROPERTY    ACTRL_DS_READ_PROP
#define RIGHT_DS_WRITE_PROPERTY   ACTRL_DS_WRITE_PROP

//
// defines for DSDIT, DSLOG, SYSVOL registry path
//
#define szNetlogonKey    TEXT("System\\CurrentControlSet\\Services\\Netlogon\\Parameters")
#define szNTDSKey        TEXT("System\\CurrentControlSet\\Services\\NTDS\\Parameters")
#define szSetupKey       TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Setup")
#define szSysvolValue    TEXT("SysVol")
#define szDSDITValue     TEXT("DSA Working Directory")
#define szDSLOGValue     TEXT("Database log files path")
#define szBootDriveValue TEXT("BootDir")

//
// Define the generic rights
//

// generic read
#define GENERIC_READ_MAPPING     ((STANDARD_RIGHTS_READ)     | \
                                  (ACTRL_DS_LIST)   | \
                                  (ACTRL_DS_READ_PROP))

// generic execute
#define GENERIC_EXECUTE_MAPPING  ((STANDARD_RIGHTS_EXECUTE)  | \
                                  (ACTRL_DS_LIST))
// generic right
#define GENERIC_WRITE_MAPPING    ((STANDARD_RIGHTS_WRITE)    | \
                                  (ACTRL_DS_SELF)      | \
                                  (ACTRL_DS_WRITE_PROP))
// generic all

#define GENERIC_ALL_MAPPING      ((STANDARD_RIGHTS_REQUIRED) | \
                                  (ACTRL_DS_CREATE_CHILD)    | \
                                  (ACTRL_DS_DELETE_CHILD)    | \
                                  (ACTRL_DS_READ_PROP)   | \
                                  (ACTRL_DS_WRITE_PROP)  | \
                                  (ACTRL_DS_LIST)   | \
                                  (ACTRL_DS_SELF))

GENERIC_MAPPING DsGenMap = {
                        GENERIC_READ_MAPPING,
                        GENERIC_WRITE_MAPPING,
                        GENERIC_EXECUTE_MAPPING,
                        GENERIC_ALL_MAPPING
                        };

DWORD
ScepCompareExplicitAcl(
    IN SE_OBJECT_TYPE ObjectType,
    IN BOOL IsContainer,
    IN PACL pAcl1,
    IN PACL pAcl2,
    OUT PBOOL pDifferent
    );

NTSTATUS
ScepAnyExplicitAcl(
    IN PACL Acl,
    IN DWORD Processed,
    OUT PBOOL pExist
    );

BOOL
ScepEqualAce(
    IN SE_OBJECT_TYPE ObjectType,
    IN BOOL IsContainer,
    IN ACE_HEADER *pAce1,
    IN ACE_HEADER *pAce2
    );

DWORD
ScepGetCurrentUserProfilePath(
    OUT PWSTR *ProfilePath
    );

DWORD
ScepGetUsersProfileName(
    IN UNICODE_STRING AssignedProfile,
    IN PSID AccountSid,
    IN BOOL bDefault,
    OUT PWSTR *UserProfilePath
    );

BOOL
ScepConvertSDDLAceType(
    LPTSTR  pszValue,
    PCWSTR  szSearchFor,  // only two letters are allowed
    PCWSTR  szReplace
    );
BOOL
ScepConvertSDDLSid(
    LPTSTR  pszValue,
    PCWSTR  szSearchFor,  // only two letters are allowed
    PCWSTR  szReplace
    );

NTSTATUS
ScepConvertAclBlobToAdl(
    IN      SE_OBJECT_TYPE  ObjectType,
    IN      BOOL    IsContainer,
    IN      PACL    pAcl,
    OUT     DWORD   *pdwAceNumber,
    OUT     BOOL    *pbAclNoExplicitAces,
    OUT     PSCEP_ADL_NODE *hTable
    );

DWORD
ScepAdlLookupAdd(
    IN      SE_OBJECT_TYPE ObjectType,
    IN      BOOL IsContainer,
    IN      ACE_HEADER   *pAce,
    OUT     PSCEP_ADL_NODE *hTable
    );

PSCEP_ADL_NODE
ScepAdlLookup(
    IN  ACE_HEADER   *pAce,
    IN  PSCEP_ADL_NODE *hTable
    );


DWORD
ScepAddToAdlList(
    IN      SE_OBJECT_TYPE ObjectType,
    IN      BOOL    IsContainer,
    IN      ACE_HEADER *pAce,
    OUT     PSCEP_ADL_NODE *pAdlList
    );

VOID
ScepAdlMergeMasks(
    IN  SE_OBJECT_TYPE  ObjectType,
    IN  BOOL    IsContainer,
    IN  ACE_HEADER  *pAce,
    IN  PSCEP_ADL_NODE pNode
    );

BOOL
ScepEqualAdls(
    IN  PSCEP_ADL_NODE *hTable1,
    IN  PSCEP_ADL_NODE *hTable2
    );

VOID
ScepFreeAdl(
    IN    PSCEP_ADL_NODE *hTable
    );

SCESTATUS
ScepFreeAdlList(
   IN PSCEP_ADL_NODE pAdlList
   );

BOOL
ScepEqualSid(
    IN PISID pSid1,
    IN PISID pSid2
    );

PWSTR
ScepMultiSzWcsstr(
    PWSTR   pszStringToSearchIn,
    PWSTR   pszStringToSearchFor
    );

//
// function definitions
//

SCESTATUS
WINAPI
SceSvcpGetInformationTemplate(
    IN HINF hInf,
    IN PCWSTR ServiceName,
    IN PCWSTR Key OPTIONAL,
    OUT PSCESVC_CONFIGURATION_INFO *ServiceInfo
    )
{
    SCESTATUS rc=SCESTATUS_SUCCESS;

    if ( hInf == NULL || hInf == INVALID_HANDLE_VALUE ||
         ServiceName == NULL || ServiceInfo == NULL ) {

        return(SCESTATUS_INVALID_PARAMETER);

    }

    LONG nCount=0;

    if ( Key == NULL ) {
        //
        // get the entire section count
        //
        nCount = SetupGetLineCount(hInf, ServiceName);

        if ( nCount <= 0 ) {
            //
            // the section is not there, or nothing in the section
            //
            rc =SCESTATUS_RECORD_NOT_FOUND;

        }

    } else {

        nCount = 1;
    }

    if ( rc == SCESTATUS_SUCCESS ) {

        //
        // allocate buffer for the section
        //
        *ServiceInfo = (PSCESVC_CONFIGURATION_INFO)ScepAlloc(LMEM_FIXED,
                              sizeof(SCESVC_CONFIGURATION_INFO));

        if ( *ServiceInfo == NULL ) {
            rc = SCESTATUS_NOT_ENOUGH_RESOURCE;

        } else {

            (*ServiceInfo)->Lines =
                (PSCESVC_CONFIGURATION_LINE)ScepAlloc(LMEM_ZEROINIT,
                          nCount*sizeof(SCESVC_CONFIGURATION_LINE));

            if ( (*ServiceInfo)->Lines == NULL ) {

                rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
                ScepFree(*ServiceInfo);
                *ServiceInfo = NULL;

            } else {
                (*ServiceInfo)->Count = nCount;
            }
        }

    }

    if ( rc == SCESTATUS_SUCCESS ) {

        //
        // get each line in the section, nor a single key now
        //
        INFCONTEXT    InfLine;
        DWORD         LineLen, Len, KeyLen, DataSize;
        DWORD         i, cFields;
        DWORD         LineCount=0;
        PWSTR         Keyname=NULL, Strvalue=NULL;


        //
        // look for the first line in the Servi   ceName section
        //
        if(SetupFindFirstLine(hInf,ServiceName,NULL,&InfLine)) {

            do {
                //
                // read each line in the section and append to the end of the buffer
                // note: the required size returned from SetupGetStringField already
                // has one more character space.
                //
                rc = SCESTATUS_INVALID_DATA;

                if ( SetupGetStringField(&InfLine, 0, NULL, 0, &KeyLen) ) {

                    Keyname = (PWSTR)ScepAlloc( LMEM_ZEROINIT, (KeyLen+1)*sizeof(WCHAR));

                    if ( Keyname != NULL ) {

                        if ( SetupGetStringField(&InfLine, 0, Keyname, KeyLen, NULL) ) {

                            //
                            // Got key name, compare with Key if specified.
                            //
                            if ( Key == NULL || _wcsicmp(Keyname, Key) == 0 ) {

                                cFields = SetupGetFieldCount( &InfLine );
                                LineLen = 0;
                                Len = 0;

                                rc = SCESTATUS_SUCCESS;
                                //
                                // count total number of characters for the value
                                //
                                for ( i=0; i<cFields; i++) {

                                    if( SetupGetStringField(&InfLine,i+1,NULL,0,&DataSize) ) {

                                        LineLen += (DataSize + 1);

                                    } else {

                                        rc = SCESTATUS_INVALID_DATA;
                                        break;
                                    }
                                }

                                if ( rc == SCESTATUS_SUCCESS ) {

                                    Strvalue = (PWSTR)ScepAlloc( LMEM_ZEROINIT,
                                                                 (LineLen+1)*sizeof(WCHAR) );

                                    if( Strvalue != NULL ) {

                                        for ( i=0; i<cFields; i++) {

                                            if ( !SetupGetStringField(&InfLine, i+1,
                                                         Strvalue+Len, LineLen-Len, &DataSize) ) {

                                                rc = SCESTATUS_INVALID_DATA;
                                                break;
                                            }

                                            if ( i == cFields-1)
                                                *(Strvalue+Len+DataSize-1) = L'\0';
                                            else
                                                *(Strvalue+Len+DataSize-1) = L',';
                                            Len += DataSize;
                                        }

                                        if ( rc == SCESTATUS_SUCCESS ) {
                                            //
                                            // everything is successful
                                            //
                                            (*ServiceInfo)->Lines[LineCount].Key = Keyname;
                                            (*ServiceInfo)->Lines[LineCount].Value = Strvalue;
                                            (*ServiceInfo)->Lines[LineCount].ValueLen = LineLen*sizeof(WCHAR);

                                            Keyname = NULL;
                                            Strvalue = NULL;
                                            rc = SCESTATUS_SUCCESS;

                                            LineCount++;

                                            if ( Key != NULL ) {
                                                break; // break the do while loop because the exact match for the key is found
                                            }

                                        } else {
                                            ScepFree( Strvalue );
                                            Strvalue = NULL;
                                        }

                                    } else
                                        rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
                                }

                            } else {
                                //
                                // did not find the right key, go to next line
                                //
                                rc = SCESTATUS_SUCCESS;
                            }
                        }

                        if ( Keyname != NULL ) {
                            ScepFree(Keyname);
                            Keyname = NULL;
                        }

                    } else {
                        rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
                    }
                }

                if ( rc != SCESTATUS_SUCCESS ) {
                    break;
                }

            } while ( SetupFindNextLine(&InfLine,&InfLine) );

        } else {

            rc = SCESTATUS_RECORD_NOT_FOUND;
        }
        //
        // if no exact match for the key is found, return the error code
        //
        if ( rc == SCESTATUS_SUCCESS && Key != NULL && LineCount == 0 ) {
            rc = SCESTATUS_RECORD_NOT_FOUND;
        }
    }

    if ( rc != SCESTATUS_SUCCESS && *ServiceInfo != NULL ) {
        //
        // free ServiceInfo
        //
        PSCESVC_CONFIGURATION_LINE Lines;

        Lines = ((PSCESVC_CONFIGURATION_INFO)(*ServiceInfo))->Lines;

        for ( DWORD i=0; i<((PSCESVC_CONFIGURATION_INFO)(*ServiceInfo))->Count; i++) {

            if ( Lines[i].Key != NULL ) {
                ScepFree(Lines[i].Key);
            }

            if ( Lines[i].Value != NULL ) {
                ScepFree(Lines[i].Value);
            }
        }

        ScepFree(Lines);
        ScepFree(*ServiceInfo);
        *ServiceInfo = NULL;
    }

    return(rc);

}


DWORD
ScepAddToNameList(
    OUT PSCE_NAME_LIST *pNameList,
    IN PWSTR Name,
    IN ULONG Len
    )
/* ++
Routine Description:

    This routine adds a name (wchar) to the name list. The new added
    node is always placed as the head of the list for performance reason.

Arguments:

    pNameList -  The address of the name list to add to.

    Name      -  The name to add

    Len       -  number of wchars in Name

Return value:

    Win32 error code
-- */
{

    PSCE_NAME_LIST pList=NULL;
    ULONG  Length=Len;

    //
    // check arguments
    //
    if ( pNameList == NULL )
        return(ERROR_INVALID_PARAMETER);

    if ( Name == NULL )
        return(NO_ERROR);

    if ( Len == 0 )
        Length = wcslen(Name);

    if ( Length == 0 )
        return(NO_ERROR);

    //
    // allocate a new node
    //
    pList = (PSCE_NAME_LIST)ScepAlloc( (UINT)0, sizeof(SCE_NAME_LIST));

    if ( pList == NULL )
        return(ERROR_NOT_ENOUGH_MEMORY);

    pList->Name = (PWSTR)ScepAlloc( LMEM_ZEROINIT, (Length+1)*sizeof(TCHAR));
    if ( pList->Name == NULL ) {
        ScepFree(pList);
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    //
    // add the node to the front of the list and link its next to the old list
    //
    wcsncpy(pList->Name, Name, Length);
    pList->Next = *pNameList;
    *pNameList = pList;

    return(NO_ERROR);
}



SCESTATUS
ScepBuildErrorLogInfo(
    IN DWORD   rc,
    OUT PSCE_ERROR_LOG_INFO *errlog,
    IN UINT    nId,
//    IN PCWSTR  fmt,
    ...
    )
/* ++

Routine Description:

   This routine add the error information to the end of error log info list
   (errlog). The error information is stored in SCE_ERROR_LOG_INFO structure.

Arguments:

   rc - Win32 error code

   errlog - the error log info list head

   fmt - a format string

   ... - variable arguments

Return value:

   SCESTATUS error code

-- */
{
    PSCE_ERROR_LOG_INFO pNode;
    PSCE_ERROR_LOG_INFO pErr;
    DWORD              bufferSize;
    PWSTR              buf=NULL;
    va_list            args;
    WCHAR              szTempString[256];

    //
    // check arguments
    //
//    if ( errlog == NULL || fmt == NULL )
    if ( errlog == NULL || nId == 0 )
        return(SCESTATUS_SUCCESS);

    szTempString[0] = L'\0';

    LoadString( MyModuleHandle,
                nId,
                szTempString,
                256
                );
    if ( szTempString[0] == L'\0' )
        return(SCESTATUS_SUCCESS);

    SafeAllocaAllocate( buf, SCE_BUF_LEN*sizeof(WCHAR) );

    if ( buf == NULL ) {
        return(SCESTATUS_NOT_ENOUGH_RESOURCE);
    }

    va_start( args, nId );
    vswprintf( buf, szTempString, args );
    va_end( args );

    bufferSize = wcslen(buf);

    //
    // no error information to be stored. return
    //

    SCESTATUS rCode=SCESTATUS_SUCCESS;

    if ( bufferSize != 0 ) {

        //
        // allocate memory and store error information in pNode->buffer
        //

        pNode = (PSCE_ERROR_LOG_INFO)ScepAlloc( 0, sizeof(SCE_ERROR_LOG_INFO) );

        if ( pNode != NULL ) {

            pNode->buffer = (LPTSTR)ScepAlloc( 0, (bufferSize+1)*sizeof(TCHAR) );
            if ( pNode->buffer != NULL ) {

                //
                // Error information is in "SystemMessage : Caller'sMessage" format
                //
                pNode->buffer[0] = L'\0';

                wcscpy(pNode->buffer, buf);

                pNode->rc = rc;
                pNode->next = NULL;

                //
                // link it to the list
                //
                if ( *errlog == NULL )

                    //
                    // This is the first node in the error log information list
                    //

                    *errlog = pNode;

                else {

                    //
                    // find the last node in the list
                    //

                    for ( pErr=*errlog; pErr->next; pErr = pErr->next );
                    pErr->next = pNode;
                }

            } else {

                ScepFree(pNode);
                rCode = SCESTATUS_NOT_ENOUGH_RESOURCE;
            }

        } else {
            rCode = SCESTATUS_NOT_ENOUGH_RESOURCE;
        }

    }

    SafeAllocaFree( buf );

    return(rc);

}


DWORD
ScepRegQueryIntValue(
    IN HKEY hKeyRoot,
    IN PWSTR SubKey,
    IN PWSTR ValueName,
    OUT DWORD *Value
    )
/* ++

Routine Description:

   This routine queries a REG_DWORD value from a value name/subkey.

Arguments:

   hKeyRoot    - root

   SubKey      - key path

   ValueName   - name of the value

   Value       - the output value for the ValueName

Return values:

   Win32 error code
-- */
{
    DWORD   Rcode;
    DWORD   RegType;
    DWORD   dSize=0;
    HKEY    hKey=NULL;

    if(( Rcode = RegOpenKeyEx(hKeyRoot,
                              SubKey,
                              0,
                              KEY_READ,
                              &hKey
                             )) == ERROR_SUCCESS ) {

        if(( Rcode = RegQueryValueEx(hKey,
                                     ValueName,
                                     0,
                                     &RegType,
                                     NULL,
                                     &dSize
                                    )) == ERROR_SUCCESS ) {
            switch (RegType) {
            case REG_DWORD:
            case REG_DWORD_BIG_ENDIAN:

                Rcode = RegQueryValueEx(hKey,
                                       ValueName,
                                       0,
                                       &RegType,
                                       (BYTE *)Value,
                                       &dSize
                                      );
                if ( Rcode != ERROR_SUCCESS ) {

                    if ( Value != NULL )
                        *Value = 0;

                }
                break;

            default:

                Rcode = ERROR_INVALID_DATATYPE;

                break;
            }
        }
    }

    if( hKey )
        RegCloseKey( hKey );

    return(Rcode);
}


DWORD
ScepRegSetIntValue(
    IN HKEY hKeyRoot,
    IN PWSTR SubKey,
    IN PWSTR ValueName,
    IN DWORD Value
    )
/* ++

Routine Description:

   This routine sets a REG_DWORD value to a value name/subkey.

Arguments:

   hKeyRoot    - root

   SubKey      - key path

   ValueName   - name of the value

   Value       - the value to set

Return values:

   Win32 error code
-- */
{
    DWORD   Rcode;
    HKEY    hKey=NULL;

    if(( Rcode = RegOpenKeyEx(hKeyRoot,
                              SubKey,
                              0,
                              KEY_SET_VALUE,
                              &hKey
                             )) == ERROR_SUCCESS ) {

        Rcode = RegSetValueEx( hKey,
                               ValueName,
                               0,
                               REG_DWORD,
                               (BYTE *)&Value,
                               4
                               );

    }

    if( hKey )
        RegCloseKey( hKey );

    return(Rcode);
}

DWORD
ScepRegQueryBinaryValue(
    IN HKEY hKeyRoot,
    IN PWSTR SubKey,
    IN PWSTR ValueName,
    OUT PBYTE *ppValue
    )
/* ++

Routine Description:

   This routine queries a REG_BINARY value from a value name/subkey.

Arguments:

   hKeyRoot    - root

   SubKey      - key path

   ValueName   - name of the value

   Value       - the output value for the ValueName

Return values:

   Win32 error code
-- */
{
    DWORD   Rcode;
    DWORD   RegType;
    DWORD   dSize=0;
    HKEY    hKey=NULL;

    if(( Rcode = RegOpenKeyEx(hKeyRoot,
                              SubKey,
                              0,
                              KEY_READ,
                              &hKey
                             )) == ERROR_SUCCESS ) {

        // get the size since it is free form binary
        if(( Rcode = RegQueryValueEx(hKey,
                                     ValueName,
                                     0,
                                     &RegType,
                                     NULL,
                                     &dSize
                                    )) == ERROR_SUCCESS ) {
            switch (RegType) {
            case REG_BINARY:

                //need to free this outside
                if (ppValue)
                    *ppValue = ( PBYTE )ScepAlloc( 0, sizeof(BYTE) * dSize);

                Rcode = RegQueryValueEx(hKey,
                                       ValueName,
                                       0,
                                       &RegType,
                                       ( PBYTE ) *ppValue,
                                       &dSize
                                      );
                if ( Rcode != ERROR_SUCCESS ) {

                    if ( *ppValue != NULL )
                        **ppValue = (BYTE)0;

                }
                break;

            default:

                Rcode = ERROR_INVALID_DATATYPE;

                break;
            }
        }
    }

    if( hKey )
        RegCloseKey( hKey );

    return(Rcode);
}


DWORD
ScepRegSetValue(
    IN HKEY hKeyRoot,
    IN PWSTR SubKey,
    IN PWSTR ValueName,
    IN DWORD RegType,
    IN BYTE *Value,
    IN DWORD ValueLen
    )
/* ++

Routine Description:

   This routine sets a string value to a value name/subkey.

Arguments:

   hKeyRoot    - root

   SubKey      - key path

   ValueName   - name of the value

   Value       - the value to set

   ValueLen    - The number of bytes in Value

Return values:

   Win32 error code
-- */
{
    DWORD   Rcode;
    DWORD   NewKey;
    HKEY    hKey=NULL;
    SECURITY_ATTRIBUTES     SecurityAttributes;
    PSECURITY_DESCRIPTOR    SecurityDescriptor=NULL;


    if(( Rcode = RegOpenKeyEx(hKeyRoot,
                              SubKey,
                              0,
                              KEY_SET_VALUE,
                              &hKey
                             )) != ERROR_SUCCESS ) {

        SecurityAttributes.nLength              = sizeof( SECURITY_ATTRIBUTES );
        SecurityAttributes.lpSecurityDescriptor = SecurityDescriptor;
        SecurityAttributes.bInheritHandle       = FALSE;

        Rcode = RegCreateKeyEx(
                   hKeyRoot,
                   SubKey,
                   0,
                   NULL, // LPTSTR lpClass,
                   REG_OPTION_NON_VOLATILE,
                   KEY_WRITE, // KEY_SET_VALUE,
                   NULL, // &SecurityAttributes,
                   &hKey,
                   &NewKey
                  );
    }

    if ( Rcode == ERROR_SUCCESS ) {

        Rcode = RegSetValueEx( hKey,
                               ValueName,
                               0,
                               RegType,
                               Value,
                               ValueLen
                               );

    }

    if( hKey )
        RegCloseKey( hKey );

    return(Rcode);
}

DWORD
ScepRegQueryValue(
    IN HKEY hKeyRoot,
    IN PWSTR SubKey,
    IN PCWSTR ValueName,
    OUT PVOID *Value,
    OUT LPDWORD pRegType
    )
/* ++

Routine Description:

   This routine queries a REG_SZ value from a value name/subkey.
   The output buffer is allocated if it is NULL. It must be freed
   by LocalFree

Arguments:

   hKeyRoot    - root

   SubKey      - key path

   ValueName   - name of the value

   Value       - the output string for the ValueName

Return values:

   Win32 error code
-- */
{
    DWORD   Rcode;
    DWORD   dSize=0;
    HKEY    hKey=NULL;
    BOOL    FreeMem=FALSE;

    if ( SubKey == NULL || ValueName == NULL ||
         Value == NULL || pRegType == NULL ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    if(( Rcode = RegOpenKeyEx(hKeyRoot,
                              SubKey,
                              0,
                              KEY_READ,
                              &hKey
                             )) == ERROR_SUCCESS ) {

        if(( Rcode = RegQueryValueEx(hKey,
                                     ValueName,
                                     0,
                                     pRegType,
                                     NULL,
                                     &dSize
                                    )) == ERROR_SUCCESS ) {
            switch (*pRegType) {
/*
            case REG_DWORD:
            case REG_DWORD_BIG_ENDIAN:

                Rcode = RegQueryValueEx(hKey,
                                       ValueName,
                                       0,
                                       pRegType,
                                       (BYTE *)(*Value),
                                       &dSize
                                      );
                if ( Rcode != ERROR_SUCCESS ) {

                    if ( *Value != NULL )
                        *((BYTE *)(*Value)) = 0;
                }
                break;
*/
            case REG_SZ:
            case REG_EXPAND_SZ:
            case REG_MULTI_SZ:
                if ( *Value == NULL ) {
                    *Value = (PVOID)ScepAlloc( LMEM_ZEROINIT, (dSize+1)*sizeof(TCHAR));
                    FreeMem = TRUE;
                }

                if ( *Value == NULL ) {
                    Rcode = ERROR_NOT_ENOUGH_MEMORY;
                } else {
                    Rcode = RegQueryValueEx(hKey,
                                           ValueName,
                                           0,
                                           pRegType,
                                           (BYTE *)(*Value),
                                           &dSize
                                          );
                    if ( Rcode != ERROR_SUCCESS && FreeMem ) {
                        ScepFree(*Value);
                        *Value = NULL;
                    }
                }

                break;
            default:

                Rcode = ERROR_INVALID_DATATYPE;

                break;
            }
        }
    }

    if( hKey )
        RegCloseKey( hKey );

    return(Rcode);
}

DWORD
ScepRegDeleteValue(
    IN HKEY hKeyRoot,
    IN PWSTR SubKey,
    IN PWSTR ValueName
   )
/* ++

Routine Description:

   This routine delete the reg value

Arguments:

   hKeyRoot    - root

   SubKey      - key path

   ValueName   - name of the value


Return values:

   Win32 error code
-- */
{
    DWORD   Rcode;
    HKEY    hKey=NULL;

    if(( Rcode = RegOpenKeyEx(hKeyRoot,
                              SubKey,
                              0,
                              KEY_READ | KEY_WRITE,
                              &hKey
                             )) == ERROR_SUCCESS ) {

        Rcode = RegDeleteValue(hKey, ValueName);

    }

    if( hKey )
        RegCloseKey( hKey );

    return(Rcode);
}


SCESTATUS
ScepCreateDirectory(
    IN PCWSTR ProfileLocation,
    IN BOOL FileOrDir,
    PSECURITY_DESCRIPTOR pSecurityDescriptor OPTIONAL
    )
/* ++
Routine Description:

    This routine creates directory(ies) as specified in the ProfileLocation.


Arguments:

    ProfileLocation     - The directory (full path) to create

    FileOrDir           - TRUE = Dir name, FALSE = file name

    pSecurityDescriptor - The secrity descriptor for the directories to create.
                            If it is NULL, then the parent directory's inherit
                            security descriptor is used.

Return Value:

    SCESTATUS_SUCCESS
    SCESTATUS_INVALID_PARAMETER
    SCESTATUS_NOT_ENOUGH_RESOURCE
    SCESTATUS_OTHER_ERROR

-- */
{
    PWSTR       Buffer=NULL;
    PWSTR       pTemp=NULL;
    DWORD       Len=0;
    SCESTATUS    rc;
    SECURITY_ATTRIBUTES sa;


    if ( ProfileLocation == NULL ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    if ( wcsncmp(ProfileLocation,L"\\\\?\\",4) == 0 ) {

        pTemp = (PWSTR)ProfileLocation+4;
    } else {
        pTemp = (PWSTR)ProfileLocation;
    }

    //
    // skip the first '\\' for example, c:\winnt
    //
    pTemp = wcschr(pTemp, L'\\');
    if ( pTemp == NULL ) {
        if ( ProfileLocation[1] == L':' ) {
            return(SCESTATUS_SUCCESS);
        } else {
            return(SCESTATUS_INVALID_PARAMETER);
        }
    } else if ( *(pTemp+1) == L'\\' ) {
        //
        // there is a machine name here
        //
        pTemp = wcschr(pTemp+2, L'\\');
        if ( pTemp == NULL ) {
            //
            // just a machine name, invalid
            //
            return(SCESTATUS_INVALID_PARAMETER);
        } else {
            //
            // look for the share name end
            //
            pTemp = wcschr(pTemp+1, L'\\');

            if ( pTemp == NULL ) {
                //
                // no directory is specified
                //
                return(SCESTATUS_INVALID_PARAMETER);
            }

        }

    }

    //
    // Make a copy of the profile location
    //
    Buffer = (PWSTR)ScepAlloc( 0, (wcslen(ProfileLocation)+1)*sizeof(WCHAR));
    if ( Buffer == NULL ) {
        return(SCESTATUS_NOT_ENOUGH_RESOURCE);
    }

    wcscpy( Buffer, ProfileLocation );

    //
    // Looping to find the next '\\'
    //
    sa.nLength = sizeof(SECURITY_ATTRIBUTES);
    sa.lpSecurityDescriptor = (LPVOID)pSecurityDescriptor;
    sa.bInheritHandle = FALSE;

    do {
        pTemp = wcschr( pTemp+1, L'\\');
        if ( pTemp != NULL ) {
            Len = (DWORD)(pTemp - ProfileLocation);
            Buffer[Len] = L'\0';
        } else if ( FileOrDir )
            Len = 0;  // dir name
        else
            break;    // file name. DO NOT create directory for the file name part

        //
        // should make a security descriptor and set
        //
        if ( CreateDirectory(
                Buffer,
                &sa
                ) == FALSE ) {
            if ( GetLastError() != ERROR_ALREADY_EXISTS ) {
                rc = ScepDosErrorToSceStatus(GetLastError());
                goto Done;
            }
        }

        if ( Len != 0 )
            Buffer[Len] = L'\\';


    } while (  pTemp != NULL );

    rc = SCESTATUS_SUCCESS;

Done:

    ScepFree(Buffer);

    return(rc);

}



DWORD
ScepSceStatusToDosError(
    IN SCESTATUS SceStatus
    )
// converts SCESTATUS error code to dos error defined in winerror.h
{
    switch(SceStatus) {

    case SCESTATUS_SUCCESS:
        return(NO_ERROR);

    case SCESTATUS_OTHER_ERROR:
        return(ERROR_EXTENDED_ERROR);

    case SCESTATUS_INVALID_PARAMETER:
        return(ERROR_INVALID_PARAMETER);

    case SCESTATUS_RECORD_NOT_FOUND:
        return(ERROR_NO_MORE_ITEMS);

    case SCESTATUS_NO_MAPPING:
        return(ERROR_NONE_MAPPED);

    case SCESTATUS_TRUST_FAIL:
        return(ERROR_TRUSTED_DOMAIN_FAILURE);

    case SCESTATUS_INVALID_DATA:
        return(ERROR_INVALID_DATA);

    case SCESTATUS_OBJECT_EXIST:
        return(ERROR_FILE_EXISTS);

    case SCESTATUS_BUFFER_TOO_SMALL:
        return(ERROR_INSUFFICIENT_BUFFER);

    case SCESTATUS_PROFILE_NOT_FOUND:
        return(ERROR_FILE_NOT_FOUND);

    case SCESTATUS_BAD_FORMAT:
        return(ERROR_BAD_FORMAT);

    case SCESTATUS_NOT_ENOUGH_RESOURCE:
        return(ERROR_NOT_ENOUGH_MEMORY);

    case SCESTATUS_ACCESS_DENIED:
        return(ERROR_ACCESS_DENIED);

    case SCESTATUS_CANT_DELETE:
        return(ERROR_CURRENT_DIRECTORY);

    case SCESTATUS_PREFIX_OVERFLOW:
        return(ERROR_BUFFER_OVERFLOW);

    case SCESTATUS_ALREADY_RUNNING:
        return(ERROR_SERVICE_ALREADY_RUNNING);

    case SCESTATUS_SERVICE_NOT_SUPPORT:
        return(ERROR_NOT_SUPPORTED);

    case SCESTATUS_MOD_NOT_FOUND:
        return(ERROR_MOD_NOT_FOUND);

    case SCESTATUS_EXCEPTION_IN_SERVER:
        return(ERROR_EXCEPTION_IN_SERVICE);

    case SCESTATUS_JET_DATABASE_ERROR:
        return(ERROR_DATABASE_FAILURE);

    case SCESTATUS_TIMEOUT:
        return(ERROR_TIMEOUT);

    case SCESTATUS_PENDING_IGNORE:
        return(ERROR_IO_PENDING);

    case SCESTATUS_SPECIAL_ACCOUNT:
        return(ERROR_SPECIAL_ACCOUNT);

    default:
        return(ERROR_EXTENDED_ERROR);
    }
}



SCESTATUS
ScepDosErrorToSceStatus(
    DWORD rc
    )
{
    switch(rc) {
    case NO_ERROR:
        return(SCESTATUS_SUCCESS);

    case ERROR_INVALID_PARAMETER:
    case RPC_S_INVALID_STRING_BINDING:
    case RPC_S_INVALID_BINDING:
    case RPC_X_NULL_REF_POINTER:
        return(SCESTATUS_INVALID_PARAMETER);

    case ERROR_INVALID_DATA:
        return(SCESTATUS_INVALID_DATA);

    case ERROR_FILE_NOT_FOUND:
    case ERROR_PATH_NOT_FOUND:
    case ERROR_BAD_NETPATH:

        return(SCESTATUS_PROFILE_NOT_FOUND);

    case ERROR_ACCESS_DENIED:
    case ERROR_SHARING_VIOLATION:
    case ERROR_LOCK_VIOLATION:
    case ERROR_NETWORK_ACCESS_DENIED:
    case ERROR_CANT_ACCESS_FILE:
    case RPC_S_SERVER_TOO_BUSY:

        return(SCESTATUS_ACCESS_DENIED);

    case ERROR_NOT_ENOUGH_MEMORY:
    case ERROR_OUTOFMEMORY:
    case RPC_S_OUT_OF_RESOURCES:
        return(SCESTATUS_NOT_ENOUGH_RESOURCE);

    case ERROR_BAD_FORMAT:
        return(SCESTATUS_BAD_FORMAT);

    case ERROR_CURRENT_DIRECTORY:
        return(SCESTATUS_CANT_DELETE);

    case ERROR_SECTOR_NOT_FOUND:
    case ERROR_SERVICE_DOES_NOT_EXIST:
    case ERROR_RESOURCE_DATA_NOT_FOUND:
    case ERROR_NO_MORE_ITEMS:
        return(SCESTATUS_RECORD_NOT_FOUND);

    case ERROR_NO_TRUST_LSA_SECRET:
    case ERROR_NO_TRUST_SAM_ACCOUNT:
    case ERROR_TRUSTED_DOMAIN_FAILURE:
    case ERROR_TRUSTED_RELATIONSHIP_FAILURE:
    case ERROR_TRUST_FAILURE:
        return(SCESTATUS_TRUST_FAIL);

    case ERROR_NONE_MAPPED:
        return(SCESTATUS_NO_MAPPING);

    case ERROR_DUP_NAME:
    case ERROR_FILE_EXISTS:

        return(SCESTATUS_OBJECT_EXIST);

    case ERROR_BUFFER_OVERFLOW:
        return(SCESTATUS_PREFIX_OVERFLOW);

    case ERROR_INSUFFICIENT_BUFFER:
    case RPC_S_STRING_TOO_LONG:

        return(SCESTATUS_BUFFER_TOO_SMALL);

    case ERROR_SERVICE_ALREADY_RUNNING:
        return(SCESTATUS_ALREADY_RUNNING);

    case ERROR_NOT_SUPPORTED:
    case RPC_S_INVALID_NET_ADDR:
    case RPC_S_NO_ENDPOINT_FOUND:
    case RPC_S_SERVER_UNAVAILABLE:
    case RPC_S_CANNOT_SUPPORT:
        return(SCESTATUS_SERVICE_NOT_SUPPORT);

    case ERROR_MOD_NOT_FOUND:
    case ERROR_PROC_NOT_FOUND:
        return(SCESTATUS_MOD_NOT_FOUND);

    case ERROR_EXCEPTION_IN_SERVICE:
        return(SCESTATUS_EXCEPTION_IN_SERVER);

    case ERROR_DATABASE_FAILURE:
        return(SCESTATUS_JET_DATABASE_ERROR);

    case ERROR_TIMEOUT:
        return(SCESTATUS_TIMEOUT);

    case ERROR_IO_PENDING:
        return(SCESTATUS_PENDING_IGNORE);

    case ERROR_SPECIAL_ACCOUNT:
    case ERROR_PASSWORD_RESTRICTION:
        return(SCESTATUS_SPECIAL_ACCOUNT);

    default:
        return(SCESTATUS_OTHER_ERROR);

    }
}


SCESTATUS
ScepChangeAclRevision(
    IN PSECURITY_DESCRIPTOR pSD,
    IN BYTE NewRevision
    )
/*
Change AclRevision to the NewRevision.

This routine is made for backward compatility because NT4 does not support
the new ACL_REVISION_DS.

*/
{
    BOOLEAN bPresent=FALSE;
    BOOLEAN bDefault=FALSE;
    PACL    pAcl=NULL;
    NTSTATUS    NtStatus;


    if ( pSD ) {
        //
        // change acl revision on DACL
        //
        NtStatus = RtlGetDaclSecurityDescriptor (
                        pSD,
                        &bPresent,
                        &pAcl,
                        &bDefault
                        );
        if ( NT_SUCCESS(NtStatus) && bPresent && pAcl ) {
            pAcl->AclRevision = NewRevision;
        }

        //
        // change acl revision on SACL
        //
        pAcl = NULL;
        bPresent = FALSE;

        NtStatus = RtlGetSaclSecurityDescriptor (
                        pSD,
                        &bPresent,
                        &pAcl,
                        &bDefault
                        );
        if ( NT_SUCCESS(NtStatus) && bPresent && pAcl ) {
            pAcl->AclRevision = NewRevision;
        }

    }
    return(SCESTATUS_SUCCESS);

}

BOOL
ScepEqualSid(
    IN PISID pSid1,
    IN PISID pSid2
    )
{
    if ( pSid1 == NULL && pSid2 == NULL )
        return(TRUE);
    if ( pSid1 == NULL || pSid2 == NULL )
        return(FALSE);

    return (EqualSid((PSID)pSid1, (PSID)pSid2) ? TRUE: FALSE);
}

BOOL
ScepEqualGuid(
    IN GUID *Guid1,
    IN GUID *Guid2
    )
{
    if ( Guid1 == NULL && Guid2 == NULL )
        return(TRUE);
    if ( Guid1 == NULL || Guid2 == NULL )
        return(FALSE);
/*
    if ( Guid1->Data1 != Guid2->Data1 ||
         Guid1->Data2 != Guid2->Data2 ||
         Guid1->Data3 != Guid2->Data3 ||
         *((DWORD *)(Guid1->Data4)) != *((DWORD *)(Guid2->Data4)) ||
         *((DWORD *)(Guid1->Data4)+1) != *((DWORD *)(Guid2->Data4)+1) )
        return(FALSE);

    return(TRUE);
*/
    return (!memcmp(Guid1, Guid2, sizeof(GUID)));
}


SCESTATUS
ScepAddToGroupMembership(
    OUT PSCE_GROUP_MEMBERSHIP *pGroupMembership,
    IN  PWSTR Keyname,
    IN  DWORD KeyLen,
    IN  PSCE_NAME_LIST pMembers,
    IN  DWORD ValueType,
    IN  BOOL bCheckDup,
    IN  BOOL bReplaceList
    )
{
    PSCE_GROUP_MEMBERSHIP   pGroup=NULL;
    SCESTATUS rc=SCESTATUS_SUCCESS;

    if ( pGroupMembership == NULL || Keyname == NULL ||
         KeyLen <= 0 ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    //
    // find if the group is already defined
    //
    if ( bCheckDup ) {

        for ( pGroup=*pGroupMembership; pGroup != NULL; pGroup=pGroup->Next ) {
            if ( _wcsnicmp( pGroup->GroupName, Keyname, KeyLen) == 0 &&
                 pGroup->GroupName[KeyLen] == L'\0' )
                break;
        }
    }

    if ( pGroup == NULL ) {
        // not found. create a new node

        pGroup = (PSCE_GROUP_MEMBERSHIP)ScepAlloc( LMEM_ZEROINIT,
                                                 sizeof(SCE_GROUP_MEMBERSHIP) );

        if ( pGroup != NULL ) {

            pGroup->GroupName = (PWSTR)ScepAlloc( LMEM_ZEROINIT,
                                                 (KeyLen+1)*sizeof(WCHAR) );
            if (pGroup->GroupName != NULL) {

                wcsncpy( pGroup->GroupName, Keyname, KeyLen );

                pGroup->Next = *pGroupMembership;
                pGroup->Status = SCE_GROUP_STATUS_NC_MEMBERS | SCE_GROUP_STATUS_NC_MEMBEROF;
                *pGroupMembership = pGroup;

            } else {

                ScepFree(pGroup);
                rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
            }

        } else
            rc  = SCESTATUS_NOT_ENOUGH_RESOURCE;

    }

    if ( rc == SCESTATUS_SUCCESS ) {

        if ( ValueType == 0 ) {

            if ( bReplaceList ) {

                ScepFreeNameList(pGroup->pMembers);
                pGroup->pMembers = pMembers;

            } else if ( pGroup->pMembers == NULL )
                pGroup->pMembers = pMembers;

            pGroup->Status &= ~SCE_GROUP_STATUS_NC_MEMBERS;

        } else {

            if ( bReplaceList ) {

                ScepFreeNameList(pGroup->pMemberOf);
                pGroup->pMemberOf = pMembers;

            } else if ( pGroup->pMemberOf == NULL )
                pGroup->pMemberOf = pMembers;

            pGroup->Status &= ~SCE_GROUP_STATUS_NC_MEMBEROF;
        }
    }

    return(rc);

}


DWORD
ScepAddOneServiceToList(
    IN LPWSTR lpServiceName,
    IN LPWSTR lpDisplayName,
    IN DWORD ServiceStatus,
    IN PVOID pGeneral OPTIONAL,
    IN SECURITY_INFORMATION SeInfo,
    IN BOOL bSecurity,
    OUT PSCE_SERVICES *pServiceList
    )
/*
Routine Description:

    Add service name, startup status, security descriptor or a engine name
    to the service list. The service list must be freed using SceFreePSCE_SERVICES

Arguments:

    lpServiceName - The service name

    ServiceStatus - The startup status of the service

    pGeneral - The security descriptor or the engine dll name, decided by
                bSecurity

    bSecurity - TRUE = a security descriptor is passed in pGeneral
                FALSE = a engine dll name is passed in pGeneral

    pServiceList - The service list to output

Return Value:

    ERROR_SUCCESS
    Win32 errors
*/
{
    if ( NULL == lpServiceName || pServiceList == NULL ) {
        return(ERROR_INVALID_PARAMETER);
    }

    PSCE_SERVICES pServiceNode;
    DWORD rc=ERROR_SUCCESS;

    //
    // allocate a service node
    //
    pServiceNode = (PSCE_SERVICES)LocalAlloc(LMEM_ZEROINIT, sizeof(SCE_SERVICES));
    if ( pServiceNode != NULL ) {
       //
       // allocate buffer for ServiceName
       //
       pServiceNode->ServiceName = (PWSTR)LocalAlloc(LMEM_FIXED,
                                    (wcslen(lpServiceName) + 1)*sizeof(WCHAR));
       if ( NULL != pServiceNode->ServiceName ) {
           //
           // fill the service node
           //
           if ( lpDisplayName != NULL ) {

               pServiceNode->DisplayName = (PWSTR)LocalAlloc(LMEM_FIXED,
                                    (wcslen(lpDisplayName) + 1)*sizeof(WCHAR));

               if ( pServiceNode->DisplayName != NULL ) {
                   wcscpy(pServiceNode->DisplayName, lpDisplayName);

               } else {
                   rc = ERROR_NOT_ENOUGH_MEMORY;
               }
           } else
               pServiceNode->DisplayName = NULL;

           if ( rc == NO_ERROR ) {

               wcscpy(pServiceNode->ServiceName, lpServiceName);
               pServiceNode->Status = 0;
               pServiceNode->Startup = (BYTE)ServiceStatus;

               if ( bSecurity ) {
                   //
                   // security descriptor
                   //
                   pServiceNode->General.pSecurityDescriptor = (PSECURITY_DESCRIPTOR)pGeneral;
                   pServiceNode->SeInfo = SeInfo;
               } else {
                   //
                   // service engine name
                   //
                   pServiceNode->General.ServiceEngineName = (PWSTR)pGeneral;
               }
               //
               // link to the list
               //
               pServiceNode->Next = *pServiceList;
               *pServiceList = pServiceNode;

           } else {
               LocalFree(pServiceNode->ServiceName);
           }

       } else
           rc = ERROR_NOT_ENOUGH_MEMORY;

       if ( rc != ERROR_SUCCESS ) {
           LocalFree(pServiceNode);
       }

    } else
        rc = ERROR_NOT_ENOUGH_MEMORY;

    return(rc);
}



DWORD
ScepIsAdminLoggedOn(
    OUT PBOOL bpAdminLogon
    )
{

    HANDLE          Token;
    NTSTATUS        NtStatus;
    SID_IDENTIFIER_AUTHORITY IdAuth=SECURITY_NT_AUTHORITY;
    PSID            AdminsSid=NULL;


    if ( bpAdminLogon == NULL ) {
        return(ERROR_INVALID_PARAMETER);
    }

    *bpAdminLogon = FALSE;

    if (!OpenThreadToken( GetCurrentThread(),
                          TOKEN_QUERY | TOKEN_DUPLICATE,
                          FALSE,
                          &Token)) {

        if (!OpenProcessToken( GetCurrentProcess(),
                               TOKEN_QUERY | TOKEN_DUPLICATE,
                               &Token))

            return(GetLastError());

    }
    //
    // Parepare AdminsSid
    //
    NtStatus = RtlAllocateAndInitializeSid(
                    &IdAuth,
                    2,
                    SECURITY_BUILTIN_DOMAIN_RID,
                    DOMAIN_ALIAS_RID_ADMINS,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    &AdminsSid );

    DWORD rc32 = RtlNtStatusToDosError(NtStatus);

    if (NT_SUCCESS(NtStatus) ) {

        //
        // use the CheckTokenMembership API which handles the group attributes
        //

        HANDLE NewToken;

        if ( DuplicateToken( Token, SecurityImpersonation, &NewToken )) {

            if ( FALSE == CheckTokenMembership(
                                NewToken,
                                AdminsSid,
                                bpAdminLogon
                                ) ) {

                //
                // error occured when checking membership, assume it is not a member
                //

                *bpAdminLogon = FALSE;

                rc32 = GetLastError();

            }

            CloseHandle(NewToken);

        } else {

            rc32 = GetLastError();
        }

#if 0
        DWORD           i;
        DWORD           ReturnLen, NewLen;
        PVOID           Info=NULL;

        //
        // check groups
        //
        NtStatus = NtQueryInformationToken (
                        Token,
                        TokenGroups,
                        NULL,
                        0,
                        &ReturnLen
                        );
        if ( NtStatus == STATUS_BUFFER_TOO_SMALL ) {
            //
            // allocate buffer
            //
            Info = ScepAlloc(0, ReturnLen+1);

            if ( Info != NULL ) {
                NtStatus = NtQueryInformationToken (
                                Token,
                                TokenGroups,
                                Info,
                                ReturnLen,
                                &NewLen
                                );
                if ( NT_SUCCESS(NtStatus) ) {

                    for ( i = 0; i<((PTOKEN_GROUPS)Info)->GroupCount; i++) {
                        //
                        // check each group sid
                        //
                        if ( ((PTOKEN_GROUPS)Info)->Groups[i].Sid != NULL &&
                             RtlEqualSid(((PTOKEN_GROUPS)Info)->Groups[i].Sid, AdminsSid) ) {
                            *bpAdminLogon = TRUE;
                            break;
                        }
                    }
                }

                ScepFree(Info);
            }
        }

        rc32 = RtlNtStatusToDosError(NtStatus);

#endif

        //
        // Free administrators Sid
        //
        RtlFreeSid(AdminsSid);
    }

    CloseHandle(Token);

    return(rc32);

}


DWORD
ScepGetProfileSetting(
    IN PCWSTR ValueName,
    IN BOOL bAdminLogon,
    OUT PWSTR *Setting
    )
/*
Routine Description:

    This routine returns JET profile setting for the ValueName from registry.
    If there is no setting in registry (e.g., first time), a default setting
    for the ValueName will be built. The output Setting string must be freed
    by LocalFree after its use.

Arguments:

    ValueName - The registry value name to retrieve

    bAdminLogon - The flag to indicate if logged on user is admin equivalent

    Setting - the ouptut buffer

Return Value:

    Win32 error codes
*/
{
    DWORD RegType;
    DWORD rc;
    PWSTR SysRoot=NULL;
    PWSTR ProfilePath=NULL;
    TCHAR TempName[256];


    if ( ValueName == NULL || Setting == NULL ) {
        return( ERROR_INVALID_PARAMETER );
    }

    *Setting = NULL;

    if (bAdminLogon ) {
        if ( _wcsicmp(L"DefaultProfile", ValueName ) == 0 ) {
            //
            // do not query the system database name in registry
            //
            rc = ERROR_FILE_NOT_FOUND;

        } else {

            rc = ScepRegQueryValue(
                    HKEY_LOCAL_MACHINE,
                    SCE_ROOT_PATH,
                    ValueName,
                    (PVOID *)Setting,
                    &RegType
                    );
        }

    } else {

        HKEY hCurrentUser=NULL;
        //
        // the HKEY_CURRENT_USER may be linked to .default
        // depends on the current calling process
        //
        rc =RegOpenCurrentUser(
                KEY_READ,
                &hCurrentUser
                );

        if ( rc != NO_ERROR ) {
            hCurrentUser = NULL;
        }

        rc = ScepRegQueryValue(
                hCurrentUser ? hCurrentUser : HKEY_CURRENT_USER,
                SCE_ROOT_PATH,
                ValueName,
                (PVOID *)Setting,
                &RegType
                );

        if ( hCurrentUser ) {
            // close it
            RegCloseKey(hCurrentUser);
        }
    }

    //
    // if registry type is not REG_SZ or REG_EXPAND_SZ,
    // return status won't be SUCCESS
    //

    if ( rc != NO_ERROR ) {

        //
        // use the default
        //
        RegType =  0;
        rc = ScepGetNTDirectory( &SysRoot, &RegType, SCE_FLAG_WINDOWS_DIR );

        if ( rc == NO_ERROR ) {

            if ( SysRoot != NULL ) {

                if ( bAdminLogon ) {
                    //
                    // default location is %SystemRoot%\Security\Database\secedit.sdb
                    //
                    wcscpy(TempName, L"\\Security\\Database\\secedit.sdb");
                    RegType += wcslen(TempName)+1;

                    *Setting = (PWSTR)ScepAlloc( 0, RegType*sizeof(WCHAR));
                    if ( *Setting != NULL ) {
                        swprintf(*Setting, L"%s%s", SysRoot, TempName );

                        *(*Setting+RegType-1) = L'\0';
/*
                        // do not save system database name
                        // set this value as the default profile name for administrators
                        //

                        ScepRegSetValue(
                            HKEY_LOCAL_MACHINE,
                            SCE_ROOT_PATH,
                            (PWSTR)ValueName,
                            REG_SZ,
                            (BYTE *)(*Setting),
                            (RegType-1)*sizeof(WCHAR)
                            );
*/

                    } else
                        rc = ERROR_NOT_ENOUGH_MEMORY;

                } else {
                    //
                    // default location is <UserProfilesDirectory>\Profiles\<User>\secedit.sdb
                    // on NT5, it will be %SystemDrive%\Users\Profiles...
                    // on NT4, it is %SystemRoot%\Profiles...
                    // GetCurrentUserProfilePath already handles NT4/NT5 difference
                    //
                    rc = ScepGetCurrentUserProfilePath(&ProfilePath);

                    if ( rc == NO_ERROR && ProfilePath != NULL ) {
                        //
                        // get the current user profile path
                        //
                        wcscpy(TempName, L"\\secedit.sdb");

                        *Setting = (PWSTR)ScepAlloc(0, (wcslen(ProfilePath)+wcslen(TempName)+1)*sizeof(WCHAR));

                        if ( *Setting != NULL ) {
                            swprintf(*Setting, L"%s%s\0", ProfilePath,TempName );

                        } else
                            rc = ERROR_NOT_ENOUGH_MEMORY;

                        ScepFree(ProfilePath);

                    } else {

                        rc = NO_ERROR;
                        wcscpy(TempName, L"\\Profiles\\secedit.sdb");
#if _WINNT_WIN32>=0x0500
                        //
                        // default to <ProfilesDirectory>\Profiles
                        // get the profiles directory first
                        //
                        RegType = 0;
                        GetProfilesDirectory(NULL, &RegType);

                        if ( RegType ) {
                            //
                            // allocate the total buffer
                            //
                            RegType += wcslen(TempName);

                            *Setting = (PWSTR)ScepAlloc( LMEM_ZEROINIT, (RegType+1)*sizeof(WCHAR));

                            if ( *Setting ) {
                                //
                                // call to get the profiles directory again
                                //
                                if ( GetProfilesDirectory(*Setting, &RegType) ) {

                                    wcscat(*Setting, TempName );

                                } else {
                                    rc = GetLastError();

                                    ScepFree(*Setting);
                                    *Setting = NULL;
                                }

                            } else {
                                rc = ERROR_NOT_ENOUGH_MEMORY;
                            }

                        } else {
                            rc = GetLastError();
                        }
#else
                        //
                        // default to %SystemRoot%\Profiles
                        //
                        RegType += wcslen(TempName)+1;

                        *Setting = (PWSTR)ScepAlloc( 0, RegType*sizeof(WCHAR));

                        if ( *Setting != NULL ) {
                            swprintf(*Setting, L"%s%s", SysRoot,TempName );

                            *(*Setting+RegType-1) = L'\0';

                            rc = ERROR_SUCCESS;

                        } else {
                            rc = ERROR_NOT_ENOUGH_MEMORY;
                        }
#endif
                    }
                }

                ScepFree(SysRoot);

            } else
                rc = ERROR_INVALID_DATA;
        }
    }

    return(rc);
}



DWORD
ScepCompareObjectSecurity(
    IN SE_OBJECT_TYPE ObjectType,
    IN BOOL IsContainer,
    IN PSECURITY_DESCRIPTOR pSecurityDescriptor,
    IN PSECURITY_DESCRIPTOR ProfileSD,
    IN SECURITY_INFORMATION ProfileSeInfo,
    OUT PBYTE IsDifferent
    )
/* ++

Routine Description:

   Compare two security descriptors

Arguments:

   ObjectType         - the object type

   pSecurityDescriptor - The security descriptor of current object's setting

   ProfileSD          - security descriptor specified in the template

   ProfileSeInfo      - security information specified in the template

Return value:

   SCESTATUS error codes

++ */
{
    BOOL    Different=FALSE;
    BOOL    DifPermOrAudit;
    DWORD   rc=ERROR_SUCCESS;
    PSID    pSid1=NULL;
    PSID    pSid2=NULL;
    BOOLEAN tFlag;
    BOOLEAN aclPresent;
    PACL    pAcl1=NULL;
    PACL    pAcl2=NULL;
    SECURITY_DESCRIPTOR_CONTROL Control1;
    SECURITY_DESCRIPTOR_CONTROL Control2;
    DWORD       Win32rc;


    BYTE   Status=0;

    if ( IsDifferent == NULL ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    if ( pSecurityDescriptor == NULL &&
         ProfileSD == NULL ) {

        if ( IsDifferent ) {
            *IsDifferent = SCE_STATUS_MISMATCH;
        }
        return(rc);
    }

    if ( IsDifferent ) {
        *IsDifferent = 0;
    }

    //
    // if ProfileSD is specified and protection does not match SystemSD, then mismatch
    // don't care if ProfileSD is not specified
    //

    if ( pSecurityDescriptor == NULL || !NT_SUCCESS(RtlGetControlSecurityDescriptor (
                                                                                    pSecurityDescriptor,
                                                                                    &Control1,
                                                                                    &Win32rc  // temp use
                                                                                    ))) {

        Control1 = 0;

    }

    if ( ProfileSD == NULL || !NT_SUCCESS(RtlGetControlSecurityDescriptor (
                                                                          ProfileSD,
                                                                          &Control2,
                                                                          &Win32rc  // temp use
                                                                          ))) {

        Control2 = 0;

    }

    if ((Control1 & SE_DACL_PROTECTED) != (Control2 & SE_DACL_PROTECTED)) {

        Different = TRUE;
        Status |= SCE_STATUS_PERMISSION_MISMATCH;

    }

    if ((Control1 & SE_SACL_PROTECTED) != (Control2 & SE_SACL_PROTECTED)) {

        Different = TRUE;
        Status |= SCE_STATUS_AUDIT_MISMATCH;

    }


    //
    // Compare two security descriptors
    //
    if ( ProfileSeInfo & OWNER_SECURITY_INFORMATION ) {
        if ( pSecurityDescriptor == NULL ||
             !NT_SUCCESS( RtlGetOwnerSecurityDescriptor(
                                     pSecurityDescriptor,
                                     &pSid1,
                                     &tFlag)
                                    ) ) {

            pSid1 = NULL;
        }
        if ( ProfileSD == NULL ||
             !NT_SUCCESS( RtlGetOwnerSecurityDescriptor(
                                         ProfileSD,
                                         &pSid2,
                                         &tFlag)
                                        ) ) {

            pSid2 = NULL;
        }
        if ( (pSid1 == NULL && pSid2 != NULL) ||
             (pSid1 != NULL && pSid2 == NULL) ||
             (pSid1 != NULL && pSid2 != NULL && !EqualSid(pSid1, pSid2)) ) {

            Different = TRUE;
        }
    }

#if 0
    //
    // Get Group address
    //

    if ( ProfileSeInfo & GROUP_SECURITY_INFORMATION ) {
        pSid1 = NULL;
        pSid2 = NULL;
        if ( pSecurityDescriptor == NULL ||
             !NT_SUCCESS( RtlGetGroupSecurityDescriptor(
                                  pSecurityDescriptor,
                                  &pSid1,
                                  &tFlag)
                                ) ) {

            pSid1 = NULL;
        }
        if ( ProfileSD == NULL ||
             !NT_SUCCESS( RtlGetGroupSecurityDescriptor(
                                          ProfileSD,
                                          &pSid2,
                                          &tFlag)
                                        ) ) {

            pSid2 = NULL;
        }
        if ( (pSid1 == NULL && pSid2 != NULL) ||
             (pSid1 != NULL && pSid2 == NULL) ||
             (pSid1 != NULL && pSid2 != NULL && !EqualSid(pSid1, pSid2)) ) {

            Different = TRUE;
        }
    }
#endif

    //
    // Get DACL address
    //

    if ( !(Status & SCE_STATUS_PERMISSION_MISMATCH) && (ProfileSeInfo & DACL_SECURITY_INFORMATION) ) {
        if ( pSecurityDescriptor == NULL ||
             !NT_SUCCESS( RtlGetDaclSecurityDescriptor(
                                         pSecurityDescriptor,
                                         &aclPresent,
                                         &pAcl1,
                                         &tFlag)
                                       ) ) {

            pAcl1 = NULL;
        } else if ( !aclPresent )
            pAcl1 = NULL;
        if ( ProfileSD == NULL ||
             !NT_SUCCESS( RtlGetDaclSecurityDescriptor(
                                         ProfileSD,
                                         &aclPresent,
                                         &pAcl2,
                                         &tFlag)
                                       ) ) {

            pAcl2 = NULL;
        } else if ( !aclPresent )
            pAcl2 = NULL;

        //
        // compare two ACLs
        //
        DifPermOrAudit = FALSE;
        rc = ScepCompareExplicitAcl( ObjectType, IsContainer, pAcl1, pAcl2, &DifPermOrAudit );

        if ( rc != ERROR_SUCCESS ) {
            goto Done;
        }

        if ( DifPermOrAudit ) {
            Different = TRUE;
            Status |= SCE_STATUS_PERMISSION_MISMATCH;
        }
    }

    //
    // Get SACL address
    //

    if ( !(Status & SCE_STATUS_AUDIT_MISMATCH) && (ProfileSeInfo & SACL_SECURITY_INFORMATION) ) {
        pAcl1 = NULL;
        pAcl2 = NULL;
        if ( pSecurityDescriptor == NULL ||
             !NT_SUCCESS( RtlGetSaclSecurityDescriptor(
                                         pSecurityDescriptor,
                                         &aclPresent,
                                         &pAcl1,
                                         &tFlag)
                                       ) ) {

            pAcl1 = NULL;

        } else if ( !aclPresent )
            pAcl1 = NULL;

        if ( ProfileSD == NULL ||
             !NT_SUCCESS( RtlGetSaclSecurityDescriptor(
                                         ProfileSD,
                                         &aclPresent,
                                         &pAcl2,
                                         &tFlag)
                                       ) ) {

            pAcl2 = NULL;

        } else if ( !aclPresent )
            pAcl2 = NULL;

        //
        // compare two ACLs
        //
        DifPermOrAudit = FALSE;
        rc = ScepCompareExplicitAcl( ObjectType, IsContainer, pAcl1, pAcl2, &DifPermOrAudit );

        if ( rc != ERROR_SUCCESS ) {
            goto Done;
        }

        if ( DifPermOrAudit ) {
            Different = TRUE;
            Status |= SCE_STATUS_AUDIT_MISMATCH;
        }
    }

    if ( IsDifferent && Different ) {

        *IsDifferent = SCE_STATUS_MISMATCH;

        if ( Status ) {
            *IsDifferent |= Status;
        }
    }

Done:

    return(rc);
}



DWORD
ScepCompareExplicitAcl(
    IN SE_OBJECT_TYPE ObjectType,
    IN BOOL IsContainer,
    IN PACL pAcl1,
    IN PACL pAcl2,
    OUT PBOOL pDifferent
    )
/*
Routine Description:

    This routine compares explicit aces of two ACLs for exact match. Exact
    match means: same access type, same inheritance flag, same access mask,
    same GUID/Object GUID (if available), and same SID.

    Inherited aces (INHERITED_ACE is set) are ignored.

Arguments:

    pAcl1 - The first ACL

    pAcl2 - The 2nd ACL

    pDifferent - The output flag to indicate different

Return Value:

    Win32 error codes
*/
{
    NTSTATUS        NtStatus=STATUS_SUCCESS;
    DWORD           dwAcl1AceCount, dwAcl2AceCount;
    ACE_HEADER      *pAce1=NULL;
    ACE_HEADER      *pAce2=NULL;
    PSCEP_ADL_NODE hTable1 [SCEP_ADL_HTABLE_SIZE];
    PSCEP_ADL_NODE hTable2 [SCEP_ADL_HTABLE_SIZE];

    memset(hTable1, NULL, SCEP_ADL_HTABLE_SIZE * sizeof(PSCEP_ADL_NODE) );
    memset(hTable2, NULL, SCEP_ADL_HTABLE_SIZE * sizeof(PSCEP_ADL_NODE) );

    *pDifferent = FALSE;

    //
    // if pAcl1 is NULL, pAcl2 should have 0 explicit Ace
    //
    if ( pAcl1 == NULL ) {
        NtStatus = ScepAnyExplicitAcl( pAcl2, 0, pDifferent );
        return(RtlNtStatusToDosError(NtStatus));
    }

    //
    // if pAcl2 is NULL, pAcl1 should have 0 explicit Ace
    //
    if ( pAcl2 == NULL ) {
        NtStatus = ScepAnyExplicitAcl( pAcl1, 0, pDifferent );
        return(RtlNtStatusToDosError(NtStatus));
    }

    //
    // both ACLs are not NULL
    //

    BOOL bAcl1NoExplicitAces;
    BOOL bAcl2NoExplicitAces;

    dwAcl1AceCount = 0;
    dwAcl2AceCount = 0;

    while ( dwAcl1AceCount < pAcl1->AceCount || dwAcl2AceCount < pAcl2->AceCount) {
        //
        // convert Acl1 into Access Description Language and insert into htable for this blob
        // blob is defined as a contiguous AceList of same type
        //
        bAcl1NoExplicitAces = TRUE;
        if (dwAcl1AceCount < pAcl1->AceCount) {
            NtStatus = ScepConvertAclBlobToAdl(ObjectType,
                                               IsContainer,
                                               pAcl1,
                                               &dwAcl1AceCount,
                                               &bAcl1NoExplicitAces,
                                               hTable1);

                if ( !NT_SUCCESS(NtStatus) )
                goto Done;
        }

        //
        // convert Acl2 into Access Description Language and insert into htable for this blob
        //
        bAcl2NoExplicitAces = TRUE;
        if (dwAcl2AceCount < pAcl2->AceCount) {
            NtStatus = ScepConvertAclBlobToAdl(ObjectType,
                                               IsContainer,
                                               pAcl2,
                                               &dwAcl2AceCount,
                                               &bAcl2NoExplicitAces,
                                               hTable2);
            if ( !NT_SUCCESS(NtStatus) )
                goto Done;
        }

        //
        // compare Adls for Acl1 and Acl2 blobs
        // if after ignoring INHERITED_ACES, one Acl has no aces and the other has, then bAcl1NoExplicitAces != bAcl2NoExplicitAces
        //

        if (bAcl1NoExplicitAces != bAcl2NoExplicitAces || !ScepEqualAdls(hTable1, hTable2) ) {

            *pDifferent = TRUE;
            ScepFreeAdl(hTable1);
            ScepFreeAdl(hTable2);
            return(ERROR_SUCCESS);
        }

        //
        // need to reuse hTables for next blobs
        //

        ScepFreeAdl(hTable1);
        ScepFreeAdl(hTable2);

        //
        // the Adls are equal - so continue with next blobs for Acl1 and Acl2
        //
    }


Done:

    //
    // free in case goto was taken
    //

    ScepFreeAdl(hTable1);
    ScepFreeAdl(hTable2);

    return(RtlNtStatusToDosError(NtStatus));
}


NTSTATUS
ScepConvertAclBlobToAdl(
    IN      SE_OBJECT_TYPE  ObjectType,
    IN      BOOL    IsContainer,
    IN      PACL    pAcl,
    OUT     DWORD   *pdwAceNumber,
    OUT     BOOL    *pbAclNoExplicitAces,
    OUT     PSCEP_ADL_NODE *hTable
    )
/*
Routine Description:

    This routine builds the Adl for a contiguous block of same type aces.
    Inherited aces (INHERITED_ACE is set) are ignored.

Arguments:

    IN  ObjectType          - the type of object, passed on to other functions
    IN  IsContainer         - whether container or not, passed on to other functions
    IN  pAcl                - the Acl to be converted to Adl
    OUT pdwAceNumber        - running count of the aces considered
    OUT pbAclNoExplicitAces - whether there were explicit aces (if FALSE, there is at leat one explicit ace)
    OUT hTable              - the Adl structure for this Acl

Return Value:

    Win32 error codes
*/
{
    NTSTATUS        NtStatus=STATUS_SUCCESS;
    ACE_HEADER      *pAce=NULL;

    if (pAcl == NULL || pdwAceNumber == NULL ||
        hTable == NULL || pbAclNoExplicitAces == NULL) {

        return (STATUS_INVALID_PARAMETER);

    }

    DWORD dwAceNumber = *pdwAceNumber;

    NtStatus = RtlGetAce(pAcl, dwAceNumber, (PVOID *)&pAce);
    if ( !NT_SUCCESS(NtStatus) )
        goto Done;

    //
    // get the first non INHERITED_ACE
    //

    while ( (pAce->AceFlags & INHERITED_ACE)  &&  (++dwAceNumber < pAcl->AceCount) ) {

        NtStatus = RtlGetAce(pAcl, dwAceNumber, (PVOID *)&pAce);
        if ( !NT_SUCCESS(NtStatus) )
            goto Done;

    }

    if ( !(pAce->AceFlags & INHERITED_ACE) ) {

        UCHAR   AclAceType;

        *pbAclNoExplicitAces = FALSE;

        AclAceType = pAce->AceType;

        //
        // in a blob of AclAceType
        //
        while ( (pAce->AceType == AclAceType) &&  (dwAceNumber < pAcl->AceCount) ) {

            if (NO_ERROR != ScepAdlLookupAdd(ObjectType, IsContainer, pAce, hTable)){

                NtStatus = STATUS_NO_MEMORY;
                goto Done;

            }

            //
            // get the next ace in Acl
            //
            if (++dwAceNumber < pAcl->AceCount) {

                //
                // skip INHERITED_ACEs if any except if AceType changes
                //
                do {

                    NtStatus = RtlGetAce(pAcl, dwAceNumber, (PVOID *)&pAce);
                    if ( !NT_SUCCESS(NtStatus) )
                        goto Done;

                    //
                    // if AceType changes (e.g. from A to D) we quit building the Adl
                    // irrespective of whether it is an INHERITED_ACE
                    //

                    if (pAce->AceType != AclAceType)
                        break;

                } while ( (pAce->AceFlags & INHERITED_ACE) && (++dwAceNumber < pAcl->AceCount) );
            }
        }
    }

Done:
    //
    // update the running count of aces for this Acl
    //

    *pdwAceNumber = dwAceNumber;

    return(NtStatus);

}

BOOL
ScepEqualAdls(
    IN  PSCEP_ADL_NODE *hTable1,
    IN  PSCEP_ADL_NODE *hTable2
    )
/*
Routine Description:

    This routine compares rwo Adls - if the Adls are  equal, the hTables will be laid out in the same
    fashion since hashing function is the same. Two Adls are equal iff they match all of the below

        (a) SID, GIUD1, GIUD2
        (b) AceType
        (c) All the masks

Arguments:

    IN  hTable1     - the first Adl hash table
    IN  hTable2     - the secomd Adl hash table

Return Value:

    BOOL - true if equal
*/
{
    PSCEP_ADL_NODE    pNode1 = NULL;
    PSCEP_ADL_NODE    pNode2 = NULL;

    //
    // the Adls should be the same if superimposed over each other since they use the same hash etc.
    //

    for (DWORD   numBucket = 0; numBucket < SCEP_ADL_HTABLE_SIZE; numBucket++) {

        //
        // walk each bucket, marching pointers in pairs
        //

        pNode1 = hTable1[numBucket];
        pNode2 = hTable2[numBucket];

        while (pNode1 && pNode2) {

            if ( pNode1->AceType != pNode2->AceType ||
                 pNode1->dwEffectiveMask != pNode2->dwEffectiveMask ||
                 pNode1->dw_CI_IO_Mask != pNode2->dw_CI_IO_Mask ||
                 pNode1->dw_OI_IO_Mask != pNode2->dw_OI_IO_Mask ||
                 pNode1->dw_NP_CI_IO_Mask != pNode2->dw_NP_CI_IO_Mask ||
                 !ScepEqualSid(pNode1->pSid, pNode2->pSid) ||
                 !ScepEqualGuid(pNode1->pGuidObjectType, pNode2->pGuidObjectType) ||
                 !ScepEqualGuid(pNode1->pGuidInheritedObjectType, pNode2->pGuidInheritedObjectType) ) {

                return FALSE;
            }

            pNode1 = pNode1->Next;
            pNode2 = pNode2->Next;
        }

        if (pNode1 == NULL && pNode2 != NULL ||
            pNode1 != NULL && pNode2 == NULL) {
            return FALSE;
        }

    }

    return(TRUE);

}

DWORD
ScepAdlLookupAdd(
    IN      SE_OBJECT_TYPE ObjectType,
    IN      BOOL IsContainer,
    IN      ACE_HEADER   *pAce,
    OUT     PSCEP_ADL_NODE *hTable
    )
/*
Routine Description:

    This routine adds and initializes a new entry in the hTable for pAce->Sid or merges the
    existing access masks if pAce->Sid already exists

Arguments:

    IN  ObjectType          - the type of object, passed on to other functions
    IN  IsContainer         - whether container or not, passed on to other functions
    IN  pAce                - the ace to be parsed into the Adl hTable
    OUT hTable              - the hTable for this Adl

Return Value:

    Dos error codes
*/
{
    DWORD rc = NO_ERROR;
    PISID pSid = NULL;
    PSCEP_ADL_NODE  pNode = NULL;

    if (pAce == NULL || hTable == NULL)
        return ERROR_INVALID_PARAMETER;

    switch ( pAce->AceType ) {
    case ACCESS_ALLOWED_ACE_TYPE:
    case ACCESS_DENIED_ACE_TYPE:
    case SYSTEM_AUDIT_ACE_TYPE:
    case SYSTEM_ALARM_ACE_TYPE:

        pSid = (PISID)&((PACCESS_ALLOWED_ACE)pAce)->SidStart;

        break;

    case ACCESS_ALLOWED_OBJECT_ACE_TYPE:
    case ACCESS_DENIED_OBJECT_ACE_TYPE:
    case SYSTEM_AUDIT_OBJECT_ACE_TYPE:
    case SYSTEM_ALARM_OBJECT_ACE_TYPE:

        pSid = (PISID)ScepObjectAceObjectType(pAce);

        break;

    default:
        // should not get in here taken care of just after switch
        ;
    }

    if (pSid == NULL)
        return(ERROR_INVALID_PARAMETER);

    pNode = ScepAdlLookup(pAce, hTable);

    //
    // hashed by last subauthority of  SID - will need to change this if too many collisions in hTable
    // once mapped to a bucket, for exact match, have to match the triple <SID,GUID1,GUID2>
    //

    if (pNode == NULL)

        //
        // seeing this triple <SID, GUID1, GUID2> for the first time
        //

        rc = ScepAddToAdlList( ObjectType,
                               IsContainer,
                               pAce,
                               &hTable[(pSid->SubAuthority[pSid->SubAuthorityCount - 1] % SCEP_ADL_HTABLE_SIZE)]
                               );


    else

        //
        // already exists so simply merge the masks
        //

        ScepAdlMergeMasks(ObjectType,
                          IsContainer,
                          pAce,
                          pNode
                          );

    return rc;

}


PSCEP_ADL_NODE
ScepAdlLookup(
    IN  ACE_HEADER   *pAce,
    IN  PSCEP_ADL_NODE *hTable
    )
/*
Routine Description:

    This routine searches searches the Adl hTable for the converted pAce's entry and returns
    a pointer to it if present, else returns NULL


Arguments:

    IN  pAce        - the Ace to convert to <SID,GUID1,GUID2> and search for
    IN  hTable      - the Adl in which pAce might exist

Return Value:

    The node corresponding to pAce if it found, else NULL
*/
{
    PSCEP_ADL_NODE  pNode;
    PISID   pSid = NULL;
    GUID    *pGuidObjectType = NULL;
    GUID    *pGuidInheritedObjectType = NULL;

    switch ( pAce->AceType ) {
    case ACCESS_ALLOWED_ACE_TYPE:
    case ACCESS_DENIED_ACE_TYPE:
    case SYSTEM_AUDIT_ACE_TYPE:
    case SYSTEM_ALARM_ACE_TYPE:

        pSid = (PISID)&((PACCESS_ALLOWED_ACE)pAce)->SidStart;

        break;

    case ACCESS_ALLOWED_OBJECT_ACE_TYPE:
    case ACCESS_DENIED_OBJECT_ACE_TYPE:
    case SYSTEM_AUDIT_OBJECT_ACE_TYPE:
    case SYSTEM_ALARM_OBJECT_ACE_TYPE:

        pSid = (PISID)ScepObjectAceObjectType(pAce);
        pGuidObjectType = ScepObjectAceObjectType(pAce);
        pGuidInheritedObjectType = ScepObjectAceInheritedObjectType(pAce);

        break;

    default:
        // should not get in here since filtered out by caller ScepAdlLookupAdd()
        // in any case we do a check right after thsi switch
        ;

    }

    //
    // there might be something better we can do to handle this case
    //
    if (pSid == NULL)
        return NULL;


    for (pNode = hTable[(pSid->SubAuthority[pSid->SubAuthorityCount - 1] % SCEP_ADL_HTABLE_SIZE)];
         pNode != NULL; pNode = pNode->Next){

        if ( ScepEqualSid(pNode->pSid, pSid) &&
             ScepEqualGuid(pNode->pGuidObjectType, pGuidObjectType) &&
             ScepEqualGuid(pNode->pGuidInheritedObjectType, pGuidInheritedObjectType) ) {

                return pNode;
            }
    }
    return NULL;
}

DWORD
ScepAddToAdlList(
    IN      SE_OBJECT_TYPE ObjectType,
    IN      BOOL    IsContainer,
    IN      ACE_HEADER *pAce,
    OUT     PSCEP_ADL_NODE *pAdlList
    )
/*
Routine Description:

    This routine adds an ace to the head of the bucket into which pAce->Sid hashes (pAdlList)


Arguments:

    IN  ObjectType          - the type of object, passed on to other functions
    IN  IsContainer         - whether container or not, passed on to other functions
    IN  pAce                - the Ace to convert and add
    OUT pAdlList            - head of the bucket into which pAce->Sid hashes into

Return Value:

    Dos error code
*/
{

    PSCEP_ADL_NODE pNode=NULL;

    //
    // check arguments
    //
    if ( pAdlList == NULL || pAce == NULL )
        return(ERROR_INVALID_PARAMETER);

    //
    // allocate a new node
    //
    pNode = (PSCEP_ADL_NODE)ScepAlloc( (UINT)0, sizeof(SCEP_ADL_NODE));

    if ( pNode == NULL )
        return(ERROR_NOT_ENOUGH_MEMORY);

    pNode->pSid = NULL;
    pNode->pGuidObjectType = NULL;
    pNode->pGuidInheritedObjectType = NULL;
    pNode->AceType = pAce->AceType;
    pNode->Next = NULL;

    //
    // initialize the node with fields from pAce
    //

    switch ( pAce->AceType ) {
    case ACCESS_ALLOWED_ACE_TYPE:
    case ACCESS_DENIED_ACE_TYPE:
    case SYSTEM_AUDIT_ACE_TYPE:
    case SYSTEM_ALARM_ACE_TYPE:

        pNode->pSid = (PISID)&((PACCESS_ALLOWED_ACE)pAce)->SidStart;

        break;

    case ACCESS_ALLOWED_OBJECT_ACE_TYPE:
    case ACCESS_DENIED_OBJECT_ACE_TYPE:
    case SYSTEM_AUDIT_OBJECT_ACE_TYPE:
    case SYSTEM_ALARM_OBJECT_ACE_TYPE:

        pNode->pSid = (PISID)ScepObjectAceObjectType(pAce);
        pNode->pGuidObjectType = ScepObjectAceObjectType(pAce);
        pNode->pGuidInheritedObjectType = ScepObjectAceInheritedObjectType(pAce);

        break;

    default:
        // should not get in here since filtered out by caller ScepAdlLookupAdd()
        ScepFree(pNode);
        return(ERROR_INVALID_PARAMETER);
        ;

    }

    //
    // initialize all masks for this node
    //

    pNode->dwEffectiveMask = 0;
    pNode->dw_CI_IO_Mask = 0;
    pNode->dw_OI_IO_Mask = 0;
    pNode->dw_NP_CI_IO_Mask = 0;

    ScepAdlMergeMasks(ObjectType,
                      IsContainer,
                      pAce,
                      pNode
                      );

    //
    // add the node to the front of the list and link its next to the old list
    //

    pNode->Next = *pAdlList;
    *pAdlList = pNode;

    return(NO_ERROR);
}

VOID
ScepAdlMergeMasks(
    IN  SE_OBJECT_TYPE  ObjectType,
    IN  BOOL    IsContainer,
    IN  ACE_HEADER  *pAce,
    IN  PSCEP_ADL_NODE pNode
    )
/*
Routine Description:

    The actual routine that merges the masks from pAce onto pNode


Arguments:

    IN  ObjectType          - the type of object, passed on to other functions
    IN  IsContainer         - whether container or not, passed on to other functions
    IN  pAce                - the Ace to extract flags and OR with (source)
    IN  pNode               - the Adl node to update masks (target)

Return Value:

    Nothing
*/
{
    DWORD   dwMask = 0;

    switch ( pAce->AceType ) {
    case ACCESS_ALLOWED_ACE_TYPE:
    case ACCESS_DENIED_ACE_TYPE:
    case SYSTEM_AUDIT_ACE_TYPE:
    case SYSTEM_ALARM_ACE_TYPE:
        dwMask = ((PACCESS_ALLOWED_ACE)pAce)->Mask;

        break;

    case ACCESS_ALLOWED_OBJECT_ACE_TYPE:
    case ACCESS_DENIED_OBJECT_ACE_TYPE:
    case SYSTEM_AUDIT_OBJECT_ACE_TYPE:
    case SYSTEM_ALARM_OBJECT_ACE_TYPE:

        dwMask = ((PACCESS_ALLOWED_OBJECT_ACE)pAce)->Mask;

        break;

    default:
        // should not get in here since filtered out by all callers (3 deep)
        ;

    }

    //
    // if generic bits present, get the object specific masks
    //
    if ( dwMask & (GENERIC_READ |
                   GENERIC_WRITE |
                   GENERIC_EXECUTE |
                   GENERIC_ALL)) {

        switch ( ObjectType ) {
        case SE_DS_OBJECT:

            RtlMapGenericMask (
                              &dwMask,
                              &DsGenMap
                              );

            break;

        case SE_SERVICE:

            RtlMapGenericMask (
                              &dwMask,
                              &SvcGenMap
                              );
            break;

        case SE_REGISTRY_KEY:

            RtlMapGenericMask (
                              &dwMask,
                              &KeyGenericMapping
                              );
            break;

        case SE_FILE_OBJECT:

            RtlMapGenericMask (
                              &dwMask,
                              &FileGenericMapping
                              );
            break;

        default:
            // if this happens, dwMask is not mapped to object specific bits
            ;
        }
    }

    //
    // effective mask is updated for non-IO aces only
    //

    if ( !(pAce->AceFlags & INHERIT_ONLY_ACE) ) {
        pNode->dwEffectiveMask |= dwMask;
    }

    //
    // for non-containers, we don't care about the CI, OI masks (to simulate config)
    //

    if (IsContainer) {

        //
        // if NP, we only care about CI
        // else we care about CI, OI
        //

        if (pAce->AceFlags & NO_PROPAGATE_INHERIT_ACE) {

            if (pAce->AceFlags & CONTAINER_INHERIT_ACE) {
                pNode->dw_NP_CI_IO_Mask |= dwMask;
            }

        } else {

            if ( (pAce->AceFlags & CONTAINER_INHERIT_ACE) )
                pNode->dw_CI_IO_Mask |= dwMask;
            if ( !(ObjectType & SE_REGISTRY_KEY) && (pAce->AceFlags & OBJECT_INHERIT_ACE) )
                pNode->dw_OI_IO_Mask |= dwMask;

        }
    }

    return;

}

VOID
ScepFreeAdl(
    IN    PSCEP_ADL_NODE *hTable
    )
/*
Routine Description:

    This routine frees the linked lists of nodes (buckets) and reset's them for further use

Arguments:

    IN  hTable      - the hash-table to free

Return Value:

    Nothing
*/
{

    if (hTable) {
        for (UINT bucketNum = 0; bucketNum < SCEP_ADL_HTABLE_SIZE; bucketNum++ ) {
            ScepFreeAdlList(hTable[bucketNum]);
            hTable[bucketNum] = NULL;
        }
    }

}

SCESTATUS
ScepFreeAdlList(
   IN PSCEP_ADL_NODE pAdlList
   )
/*
Routine Description:

    This is the actual routine that frees the linked lists of nodes (buckets)

Arguments:

   IN   pAdlList    - head of bucket to free

Return Value:

    Nothing
*/
{
    PSCEP_ADL_NODE pCurAdlNode;
    PSCEP_ADL_NODE pTempNode;
    SCESTATUS      rc=SCESTATUS_SUCCESS;

    if ( pAdlList == NULL )
        return(rc);

    pCurAdlNode = pAdlList;
    while ( pCurAdlNode != NULL ) {

        pTempNode = pCurAdlNode;
        pCurAdlNode = pCurAdlNode->Next;

        __try {
            ScepFree( pTempNode );
        } __except (EXCEPTION_EXECUTE_HANDLER) {
            rc = SCESTATUS_INVALID_PARAMETER;
        }

    }
    return(rc);
}


NTSTATUS
ScepAnyExplicitAcl(
    IN PACL Acl,
    IN DWORD Processed,
    OUT PBOOL pExist
    )
/*
Routine Description:

    This routine detects if there is any explicit ace in the Acl. The DWORD
    Processed is a bit mask of the aces already checked.

Arguments:

    Acl - The Acl

    Processed - The bit mask for the processed aces (so it won't be checked again)

    pExist - The output flag to indicate if there is any explicit ace

Return Value:

    NTSTATUS
*/
{
    NTSTATUS    NtStatus=STATUS_SUCCESS;
    DWORD       j;
    ACE_HEADER  *pAce=NULL;

    //
    // check output argument
    //
    if ( pExist == NULL )
        return(STATUS_INVALID_PARAMETER);

    *pExist = FALSE;

    if ( Acl == NULL )
        return(NtStatus);

    for ( j=0; j<Acl->AceCount; j++ ) {
        if ( Processed & (1 << j) )
            continue;

        NtStatus = RtlGetAce(Acl, j, (PVOID *)&pAce);
        if ( !NT_SUCCESS(NtStatus) )
            return(NtStatus);

        if ( pAce == NULL )
            continue;

        if ( !(pAce->AceFlags & INHERITED_ACE) ) {
            //
            // find a explicit Ace in Acl
            //
            *pExist = TRUE;
            break;
        }

    }

    return(NtStatus);

}


BOOL
ScepEqualAce(
    IN SE_OBJECT_TYPE ObjectType,
    IN BOOL IsContainer,
    IN ACE_HEADER *pAce1,
    IN ACE_HEADER *pAce2
    )
// compare two aces for exact match. The return BOOL value indicates the
// match or not
{
    PSID    pSid1=NULL, pSid2=NULL;
    ACCESS_MASK Access1=0, Access2=0;

    if ( pAce1 == NULL && pAce2 == NULL )
        return(TRUE);

    if ( pAce1 == NULL || pAce2 == NULL )
        return(FALSE);

    //
    // compare ace access type
    //
    if ( pAce1->AceType != pAce2->AceType )
        return(FALSE);


    if ( IsContainer ) {
        //
        // compare ace inheritance flag
        //
        if ( pAce1->AceFlags != pAce2->AceFlags )
            return(FALSE);
    }

    switch ( pAce1->AceType ) {
    case ACCESS_ALLOWED_ACE_TYPE:
    case ACCESS_DENIED_ACE_TYPE:
    case SYSTEM_AUDIT_ACE_TYPE:
    case SYSTEM_ALARM_ACE_TYPE:
        pSid1 = (PSID)&((PACCESS_ALLOWED_ACE)pAce1)->SidStart;
        pSid2 = (PSID)&((PACCESS_ALLOWED_ACE)pAce2)->SidStart;
        Access1 = ((PACCESS_ALLOWED_ACE)pAce1)->Mask;
        Access2 = ((PACCESS_ALLOWED_ACE)pAce2)->Mask;
        break;

    case ACCESS_ALLOWED_OBJECT_ACE_TYPE:
    case ACCESS_DENIED_OBJECT_ACE_TYPE:
    case SYSTEM_AUDIT_OBJECT_ACE_TYPE:
    case SYSTEM_ALARM_OBJECT_ACE_TYPE:

        if ( ((PACCESS_ALLOWED_OBJECT_ACE)pAce1)->Flags !=
             ((PACCESS_ALLOWED_OBJECT_ACE)pAce2)->Flags ) {
            return(FALSE);
        }

        if ( ( ((PACCESS_ALLOWED_OBJECT_ACE)pAce1)->Flags & ACE_OBJECT_TYPE_PRESENT ) ||
             ( ((PACCESS_ALLOWED_OBJECT_ACE)pAce1)->Flags & ACE_INHERITED_OBJECT_TYPE_PRESENT ) ) {
            //
            // at least one GUID exists
            //
            if ( !ScepEqualGuid( (GUID *)&((PACCESS_ALLOWED_OBJECT_ACE)pAce1)->ObjectType,
                               (GUID *)&((PACCESS_ALLOWED_OBJECT_ACE)pAce2)->ObjectType ) ) {
                return(FALSE);
            }

            if ( ( ((PACCESS_ALLOWED_OBJECT_ACE)pAce1)->Flags & ACE_OBJECT_TYPE_PRESENT ) &&
                 ( ((PACCESS_ALLOWED_OBJECT_ACE)pAce1)->Flags & ACE_INHERITED_OBJECT_TYPE_PRESENT ) ) {
                //
                // the second GUID also exists
                //
                if ( !ScepEqualGuid( (GUID *)&((PACCESS_ALLOWED_OBJECT_ACE)pAce1)->InheritedObjectType,
                                   (GUID *)&((PACCESS_ALLOWED_OBJECT_ACE)pAce2)->InheritedObjectType) ) {
                    return(FALSE);
                }

                pSid1 = (PSID)&((PACCESS_ALLOWED_OBJECT_ACE)pAce1)->SidStart;
                pSid2 = (PSID)&((PACCESS_ALLOWED_OBJECT_ACE)pAce2)->SidStart;

            } else {

                pSid1 = (PSID)&((PACCESS_ALLOWED_OBJECT_ACE)pAce1)->InheritedObjectType;
                pSid2 = (PSID)&((PACCESS_ALLOWED_OBJECT_ACE)pAce2)->InheritedObjectType;
            }

        } else {

            //
            // none of the GUID exists
            //
            pSid1 = (PSID)&((PACCESS_ALLOWED_OBJECT_ACE)pAce1)->ObjectType;
            pSid2 = (PSID)&((PACCESS_ALLOWED_OBJECT_ACE)pAce2)->ObjectType;
        }

        Access1 = ((PACCESS_ALLOWED_OBJECT_ACE)pAce1)->Mask;
        Access2 = ((PACCESS_ALLOWED_OBJECT_ACE)pAce2)->Mask;


        break;
    default:
        return(FALSE); // not recognized Ace type
    }

    if ( pSid1 == NULL || pSid2 == NULL )
        //
        // no Sid, ignore the Ace
        //
        return(FALSE);

    //
    // compare the sids
    //
    if ( !EqualSid(pSid1, pSid2) )
        return(FALSE);

    //
    // access mask
    //
    // Translation is already done when calculating security descriptor
    // for file objects and registry objects
    //
    if ( Access1 != Access2 ) {
        switch ( ObjectType ) {
        case SE_DS_OBJECT:
            //
            // convert access mask of Access2 (from ProfileSD) for ds objects
            //

            RtlMapGenericMask (
                &Access2,
                &DsGenMap
                );
            if ( Access1 != Access2)
                return(FALSE);
            break;

        case SE_SERVICE:

            RtlMapGenericMask (
                &Access2,
                &SvcGenMap
                );
            if ( Access1 != Access2)
                return(FALSE);
            break;

        case SE_REGISTRY_KEY:

            RtlMapGenericMask (
                &Access2,
                &KeyGenericMapping
                );
            if ( Access1 != Access2)
                return(FALSE);
            break;

        case SE_FILE_OBJECT:

            RtlMapGenericMask (
                &Access2,
                &FileGenericMapping
                );
            if ( Access1 != Access2)
                return(FALSE);
            break;

        default:
            return(FALSE);
        }
    }

    return(TRUE);
}



SCESTATUS
ScepAddToNameStatusList(
    OUT PSCE_NAME_STATUS_LIST *pNameList,
    IN PWSTR Name,
    IN ULONG Len,
    IN DWORD Status
    )
/* ++
Routine Description:

    This routine adds a name (wchar) and a status to the name list.


Arguments:

    pNameList -  The name list to add to.

    Name      -  The name to add

    Len       -  number of wchars to add

    Status    -  The value for the status field

Return value:

    Win32 error code
-- */
{

    PSCE_NAME_STATUS_LIST pList=NULL;
    ULONG  Length=Len;

    if ( pNameList == NULL )
        return(ERROR_INVALID_PARAMETER);

    if ( Name != NULL && Name[0] && Len == 0 )
        Length = wcslen(Name) + 1;

//    if ( Length <= 1)
//        return(NO_ERROR);

    pList = (PSCE_NAME_STATUS_LIST)ScepAlloc( (UINT)0, sizeof(SCE_NAME_STATUS_LIST));

    if ( pList == NULL )
        return(ERROR_NOT_ENOUGH_MEMORY);

    if ( Name != NULL && Name[0] ) {
        pList->Name = (PWSTR)ScepAlloc( LMEM_ZEROINIT, (Length+1)*sizeof(TCHAR));
        if ( pList->Name == NULL ) {
            ScepFree(pList);
            return(ERROR_NOT_ENOUGH_MEMORY);
        }

        wcsncpy(pList->Name, Name, Length);
    } else
        pList->Name = NULL;

    pList->Status = Status;
    pList->Next = *pNameList;
    *pNameList = pList;

    return(NO_ERROR);
}



DWORD
ScepAddToObjectList(
    OUT PSCE_OBJECT_LIST  *pNameList,
    IN PWSTR  Name,
    IN ULONG  Len,
    IN BOOL  IsContainer,
    IN BYTE  Status,
    IN DWORD  Count,
    IN BYTE byFlags
    )
/* ++
Routine Description:

    This routine adds a name (wchar), a status, and a count to the name list.


Arguments:

    pNameList -  The name list to add to.

    Name      -  The name to add

    Len       -  number of wchars to add

    Status    -  The value for the status field

    Count     -  The value for the count field

    byFlags   -  SCE_CHECK_DUP do not add for duplicates
                 SCE_INCREASE_COUNT increase count by 1

Return value:

    Win32 error code
-- */
{

    PSCE_OBJECT_LIST pList=NULL;
    ULONG  Length=Len;

    if ( pNameList == NULL )
        return(ERROR_INVALID_PARAMETER);

    if ( Name == NULL )
        return(NO_ERROR);

    if ( Len == 0 )
         Length = wcslen(Name);

     if ( Length < 1)
         return(NO_ERROR);

    if ( byFlags & SCE_CHECK_DUP ) {
        for ( pList = *pNameList; pList != NULL; pList = pList->Next ) {
            if ( _wcsnicmp( pList->Name, Name, Length) == 0 &&
                 pList->Name[Length] == L'\0') {
                break;
            }
        }
        if ( NULL != pList ) {
            //
            // already exist. return
            //
            if ( (byFlags & SCE_INCREASE_COUNT) && 0 == pList->Count ) {
                pList->Count++;
            }
            return(NO_ERROR);
        }
    }

    pList = (PSCE_OBJECT_LIST)ScepAlloc( (UINT)0, sizeof(SCE_OBJECT_LIST));

    if ( pList == NULL )
        return(ERROR_NOT_ENOUGH_MEMORY);

    pList->Name = (PWSTR)ScepAlloc( LMEM_ZEROINIT, (Length+1)*sizeof(TCHAR));
    if ( pList->Name == NULL ) {
        ScepFree(pList);
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    wcsncpy(pList->Name, Name, Length);
    pList->Status = Status;
    pList->IsContainer = IsContainer;

    if ( byFlags & SCE_INCREASE_COUNT && 0 == Count )
        pList->Count = 1;
    else
        pList->Count = Count;

    pList->Next = *pNameList;
    *pNameList = pList;

    return(NO_ERROR);
}



DWORD
ScepGetNTDirectory(
    IN PWSTR *ppDirectory,
    IN PDWORD pDirSize,
    IN DWORD  Flag
    )
/*
Routine Description:

    This routine retrieves windows directory location or system directory
    location based on the input Flag. The output directory location must
    be freed by LocalFree after use.

Arguments:

    ppDirectory - the output buffer holding the directory location.

    pDirSize - The returned number of wchars of the output buffer

    Flag  - Flag to indicate directory
                1 = Windows directory
                2 = System directory

Return Value:

    Win32 error codes
*/
{
    DWORD  dSize=0;
    DWORD  rc=0;
    PWSTR pSubKey=NULL;
    PWSTR pValName=NULL;

    if ( ppDirectory == NULL )
        return(ERROR_INVALID_PARAMETER);

    switch ( Flag ) {
    case SCE_FLAG_WINDOWS_DIR:  // windows directory
        dSize=GetSystemWindowsDirectory( *ppDirectory, 0 );
        break;
    case SCE_FLAG_SYSTEM_DIR: // system directory
        dSize=GetSystemDirectory( *ppDirectory, 0 );
        break;

    case SCE_FLAG_DSDIT_DIR: // DS working directory
    case SCE_FLAG_DSLOG_DIR: // DS database log files directory
    case SCE_FLAG_SYSVOL_DIR: // Sysvol directory
    case SCE_FLAG_BOOT_DRIVE: // boot drive

        // get the appropriate registry path and value name
        if ( SCE_FLAG_SYSVOL_DIR == Flag ) {
            pSubKey = szNetlogonKey;
            pValName = szSysvolValue;

        } else if ( SCE_FLAG_BOOT_DRIVE == Flag ) {
            pSubKey = szSetupKey;
            pValName = szBootDriveValue;

        } else {
            pSubKey = szNTDSKey;
            if ( SCE_FLAG_DSDIT_DIR == Flag ) {
                pValName = szDSDITValue;
            } else {
                pValName = szDSLOGValue;
            }
        }

        //
        // query the value.
        // if this function is executed on a non DC, this function will fail
        // possibly with ERROR_FILE_NOT_FOUND or ERROR_PATH_NOT_FOUND
        // which in turn fails the translation.
        //
        DWORD RegType;
        rc = ScepRegQueryValue(
                HKEY_LOCAL_MACHINE,
                pSubKey,
                pValName,
                (PVOID *)ppDirectory,
                &RegType
                );

        if ( rc == ERROR_SUCCESS && RegType != REG_SZ ) {
            rc = ERROR_FILE_NOT_FOUND;
        }

        if ( rc == ERROR_SUCCESS && *ppDirectory ) {

            if ( Flag == SCE_FLAG_SYSVOL_DIR ) {
                //
                // for sysvol path, it will look like d:\winnt\sysvol\sysvol.
                // we need to remove the last sysvol from this variable
                //
                PWSTR pTemp = ScepWcstrr(*ppDirectory, L"\\sysvol");
                if ( pTemp && (pTemp != *ppDirectory) &&
                     _wcsnicmp(pTemp-7, L"\\sysvol",7 ) == 0 ) {

                    // terminate the string here
                    *pTemp = L'\0';
                }
            }

            dSize = wcslen(*ppDirectory);
        }

        break;

    default:  // invalid
        return(ERROR_INVALID_PARAMETER);
        break;
    }

    if ( dSize > 0 &&
         ( SCE_FLAG_WINDOWS_DIR == Flag ||
           SCE_FLAG_SYSTEM_DIR == Flag ) ) {

        *ppDirectory = (PWSTR)ScepAlloc(LMEM_ZEROINIT, (dSize+1)*sizeof(WCHAR));
        if ( *ppDirectory == NULL )
            return(ERROR_NOT_ENOUGH_MEMORY);

        switch ( Flag ) {
        case SCE_FLAG_WINDOWS_DIR:  // windows directory
            dSize=GetSystemWindowsDirectory( *ppDirectory, dSize );
            break;
        case SCE_FLAG_SYSTEM_DIR: // system directory
            dSize=GetSystemDirectory( *ppDirectory, dSize );
            break;
        }

    }
    *pDirSize = dSize;

    if ( dSize == 0 ) {
        if ( *ppDirectory != NULL )
            ScepFree(*ppDirectory);
        *ppDirectory = NULL;

        if ( rc ) {
            return(rc);
        } else if ( NO_ERROR == GetLastError() )
            return(ERROR_INVALID_DATA);
        else
            return(GetLastError());
    } else
        _wcsupr(*ppDirectory);

    return(NO_ERROR);

}



DWORD
ScepGetCurrentUserProfilePath(
    OUT PWSTR *ProfilePath
    )
{

    HANDLE          Token;
    NTSTATUS        NtStatus;
    DWORD           rc;
    PVOID           Info=NULL;
    DWORD           ReturnLen, NewLen;
    UNICODE_STRING  ProfileName;


    if (!OpenThreadToken( GetCurrentThread(),
                          TOKEN_QUERY,
                          FALSE,
                          &Token)) {

        if (!OpenProcessToken( GetCurrentProcess(),
                               TOKEN_QUERY,
                               &Token))

            return(GetLastError());

    }

    //
    // get token user
    //
    NtStatus = NtQueryInformationToken (
                    Token,
                    TokenUser,
                    NULL,
                    0,
                    &ReturnLen
                    );
    if ( NtStatus == STATUS_BUFFER_TOO_SMALL ) {
        //
        // allocate buffer
        //
        Info = ScepAlloc(0, ReturnLen+1);

        if ( Info != NULL ) {
            NtStatus = NtQueryInformationToken (
                            Token,
                            TokenUser,
                            Info,
                            ReturnLen,
                            &NewLen
                            );
            if ( NT_SUCCESS(NtStatus) ) {

                ProfileName.Length = 0;

                rc = ScepGetUsersProfileName(
                        ProfileName,
                        ((PTOKEN_USER)Info)->User.Sid,
                        FALSE,
                        ProfilePath
                        );
            } else
                rc = RtlNtStatusToDosError(NtStatus);

            ScepFree(Info);

        } else {
            rc = ERROR_NOT_ENOUGH_MEMORY;
        }

    } else
        rc = RtlNtStatusToDosError(NtStatus);

    CloseHandle(Token);

    return(rc);

}



DWORD
ScepGetUsersProfileName(
    IN UNICODE_STRING AssignedProfile,
    IN PSID AccountSid,
    IN BOOL bDefault,
    OUT PWSTR *UserProfilePath
    )
{
    DWORD                       rc=ERROR_INVALID_PARAMETER;
    SID_IDENTIFIER_AUTHORITY    *a;
    DWORD                       Len, i, j;
    WCHAR                       KeyName[356];
    PWSTR                       StrValue=NULL;
    PWSTR                       SystemRoot=NULL;
    DWORD                       DirSize=0;


    if ( AssignedProfile.Length > 0 && AssignedProfile.Buffer != NULL ) {
        //
        // use the assigned profile
        //
        *UserProfilePath = (PWSTR)ScepAlloc( LMEM_ZEROINIT, AssignedProfile.Length+2);
        if ( *UserProfilePath == NULL )
            return(ERROR_NOT_ENOUGH_MEMORY);

        wcsncpy(*UserProfilePath, AssignedProfile.Buffer, AssignedProfile.Length/2);
        return(NO_ERROR);

    }

    if ( AccountSid != NULL ) {
        //
        // look for this user's ProfileImageName in ProfileList in registry
        // if this user logged on the system once
        //

        memset(KeyName, '\0', 356*sizeof(WCHAR));

        swprintf(KeyName, L"Software\\Microsoft\\Windows NT\\CurrentVersion\\ProfileList\\");
        Len = wcslen(KeyName);

        a = RtlIdentifierAuthoritySid(AccountSid);

        swprintf(KeyName+Len, L"S-1-");
        for ( i=0; i<6; i++ ) {
            if ( a -> Value[i] > 0 )
                break;
        }
        for ( j=i; j<6; j++) {
            swprintf(KeyName+Len, L"%s%d", KeyName+Len, a -> Value[j]);
        }

        for (i = 0; i < *RtlSubAuthorityCountSid(AccountSid); i++) {
            swprintf(KeyName+Len, L"%s-%d", KeyName+Len, *RtlSubAuthoritySid(AccountSid, i));
        }
        //
        // now the registry full path name for the user profile is built into KeyName
        //
        rc = ScepRegQueryValue(
                 HKEY_LOCAL_MACHINE,
                 KeyName,
                 L"ProfileImagePath",
                 (PVOID *)&StrValue,
                 &Len
                 );

        if ( rc == NO_ERROR && StrValue != NULL ) {
            //
            // translatethe name to expand environment variables
            //
            DirSize = ExpandEnvironmentStrings(StrValue, NULL, 0);
            if ( DirSize ) {

                *UserProfilePath = (PWSTR)ScepAlloc(0, (DirSize+1)*sizeof(WCHAR));
                if ( *UserProfilePath ) {

                    if ( !ExpandEnvironmentStrings(StrValue, *UserProfilePath, DirSize) ) {
                        // error occurs
                        rc = GetLastError();

                        ScepFree(*UserProfilePath);
                        *UserProfilePath = NULL;
                    }

                } else {
                    rc = ERROR_NOT_ENOUGH_MEMORY;
                }
            } else {
                rc = GetLastError();
            }

            ScepFree(StrValue);

            return(rc);

        }
    }
    if ( StrValue ) {
        ScepFree(StrValue);
        StrValue = NULL;
    }
    //
    // if user is not assigned a profile explicitly, and there is no
    // profile created (under ProfileList), take the default profile
    //
    if ( bDefault ) {

        rc = NO_ERROR;

#if _WINNT_WIN32>=0x0500
        //
        // Take the default user profile
        //
        DirSize = 355;
        GetDefaultUserProfileDirectory(KeyName, &DirSize);

        if ( DirSize ) {
            //
            // length of "\\NTUSER.DAT" is 11
            //
            *UserProfilePath = (PWSTR)ScepAlloc( 0, (DirSize+12)*sizeof(WCHAR));

            if ( *UserProfilePath ) {
                if ( DirSize > 355 ) {
                    //
                    // KeyName buffer is not enough, call again
                    //
                    Len = DirSize;
                    if ( !GetDefaultUserProfileDirectory(*UserProfilePath, &Len) ) {
                        //
                        // error occurs, free the buffer
                        //
                        rc = GetLastError();

                        ScepFree(*UserProfilePath);
                        *UserProfilePath = NULL;
                    }

                } else {
                    //
                    // KeyName contains the directory
                    //
                    wcscpy(*UserProfilePath, KeyName);
                    (*UserProfilePath)[DirSize] = L'\0';
                }
                //
                // append NTUSER.DAT to the end
                //
                if ( NO_ERROR == rc ) {
                    wcscat(*UserProfilePath, L"\\NTUSER.DAT");
                }

            } else {
                rc = ERROR_NOT_ENOUGH_MEMORY;
            }
        } else {
            rc = GetLastError();
        }

#else
        //
        // for NT4: Take the default user profile
        //
        rc = ScepGetNTDirectory( &SystemRoot, &DirSize, SCE_FLAG_WINDOWS_DIR );

        if ( NO_ERROR == rc ) {
            //
            // string to append to the %SystemRoot%
            //
            wcscpy(KeyName, L"\\Profiles\\Default User\\NTUSER.DAT");
            Len = wcslen(KeyName);

            *UserProfilePath = (PWSTR)ScepAlloc( 0, (DirSize+Len+1)*sizeof(WCHAR));

            if ( *UserProfilePath == NULL ) {
                rc = ERROR_NOT_ENOUGH_MEMORY;
            } else {
                swprintf( *UserProfilePath, L"%s%s", SystemRoot, KeyName);
            }
        }
        if ( SystemRoot != NULL )
            ScepFree( SystemRoot);

#endif
    }

    return(rc);

}


DWORD
SceAdjustPrivilege(
    IN  ULONG           Priv,
    IN  BOOL            Enable,
    IN  HANDLE          TokenToAdjust
    )
/* ++

Routine Description:

   This routine enable/disable the specified privilege (Priv) to the current process.

Arguments:

   Priv  - The privilege to adjust

   Enable - TRUE = enable, FALSE = disable

   TokenToAdjust - The Token of current thread/process. It is optional

Return value:

   Win32 error code

-- */
{
    HANDLE          Token;
    NTSTATUS        Status;
    TOKEN_PRIVILEGES    Privs;

    if ( TokenToAdjust == NULL ) {
        if (!OpenThreadToken( GetCurrentThread(),
                              TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
                              FALSE,
                              &Token)) {

            if (!OpenProcessToken( GetCurrentProcess(),
                                   TOKEN_ADJUST_PRIVILEGES,
                                   &Token))

                return(GetLastError());

        }
    } else
        Token = TokenToAdjust;

    //
    // Token_privileges contains enough room for one privilege.
    //

    Privs.PrivilegeCount = 1;
    Privs.Privileges[0].Luid = RtlConvertUlongToLuid(Priv); // RtlConvertLongToLuid(Priv);
    Privs.Privileges[0].Attributes = Enable ? SE_PRIVILEGE_ENABLED : 0;

    Status = NtAdjustPrivilegesToken(Token,
                                     FALSE,
                                     &Privs,
                                     0,
                                     NULL,
                                     0);

    if (TokenToAdjust == NULL )
        CloseHandle(Token);

    return (RtlNtStatusToDosError( Status ) );
}


DWORD
ScepGetEnvStringSize(
    IN LPVOID peb
    )
{

    if ( !peb ) {
        return 0;
    }

    DWORD dwSize=0;

    LPTSTR pTemp=(LPTSTR)peb;
    DWORD Len;

    while ( *pTemp ) {
        Len = wcslen(pTemp);
        dwSize += Len+1;

        pTemp += Len+1;

    };

    dwSize++;

    return dwSize*sizeof(WCHAR);
}


//*************************************************************
// Routines to handle events
//*************************************************************

BOOL InitializeEvents (
    IN LPTSTR EventSourceName
    )
/*++

Routine Description:

    Opens the event log

Arguments:

    EventSourceName - the event's source name (usually dll or exe's name)

Return:

    TRUE if successful
    FALSE if an error occurs

--*/
{

    if ( hEventLog ) {
        //
        // already initialized
        //
        return TRUE;
    }

    //
    // Open the event source
    //

    if ( EventSourceName ) {

        wcscpy(EventSource, EventSourceName);

        hEventLog = RegisterEventSource(NULL, EventSource);

        if (hEventLog) {
            return TRUE;
        }

    } else {
        EventSource[0] = L'\0';
    }

    return FALSE;
}

int
LogEvent(
    IN HINSTANCE hInstance,
    IN DWORD LogLevel,
    IN DWORD dwEventID,
    IN UINT  idMsg,
    ...)
/*++

Routine Description:

    Logs a verbose event to the event log

Arguments:

    hInstance   - the resource dll instance

    bLogLevel   - the severity level of the log
                        STATUS_SEVERITY_INFORMATIONAL
                        STATUS_SEVERITY_WARNING
                        STATUS_SEVERITY_ERROR

    dwEventID   - the event ID (defined in uevents.mc)

    idMsg       - Message id

Return:

    TRUE if successful
    FALSE if an error occurs

--*/
{
    TCHAR szMsg[MAX_PATH];
    TCHAR szErrorMsg[2*MAX_PATH+40];
    LPTSTR aStrings[2];
    WORD wType;
    va_list marker;


    //
    // Check for the event log being open.
    //

    if (!hEventLog ) {

        if ( EventSource[0] == L'\0' ||
             !InitializeEvents(EventSource)) {
            return -1;
        }
    }


    //
    // Load the message
    //

    if (idMsg != 0) {
        if (!LoadString (hInstance, idMsg, szMsg, MAX_PATH)) {
            return -1;
        }

    } else {
        lstrcpy (szMsg, TEXT("%s"));
    }


    //
    // Plug in the arguments
    //
    szErrorMsg[0] = L'\0';
    va_start(marker, idMsg);

    __try {
        wvsprintf(szErrorMsg, szMsg, marker);
    } __except(EXCEPTION_EXECUTE_HANDLER) {

    }
    va_end(marker);


    //
    // Report the event to the eventlog
    //

    aStrings[0] = szErrorMsg;

    switch (LogLevel) {
    case STATUS_SEVERITY_WARNING:
        wType = EVENTLOG_WARNING_TYPE;
        break;
    case STATUS_SEVERITY_ERROR:
        wType = EVENTLOG_ERROR_TYPE;
        break;
    default:
        wType = EVENTLOG_INFORMATION_TYPE;
        break;
    }

    if (!ReportEvent(hEventLog,
                     wType,
                     0,
                     dwEventID,
                     NULL,
                     1,
                     0,
                     (LPCTSTR *)aStrings,
                     NULL) ) {
        return 1;
    }

    return 0;
}


int
LogEventAndReport(
    IN HINSTANCE hInstance,
    IN LPTSTR LogFileName,
    IN DWORD LogLevel,
    IN DWORD dwEventID,
    IN UINT  idMsg,
    ...)
/*++

Routine Description:

    Logs a verbose event to the event log and logs

Arguments:

    hInstance   - the resource dll handle

    LofFileName - the log file also reported to

    bLogLevel   - the severity level of the log
                        STATUS_SEVERITY_INFORMATIONAL
                        STATUS_SEVERITY_WARNING
                        STATUS_SEVERITY_ERROR

    dwEventID   - the event ID (defined in uevents.mc)

    idMsg       - Message id

Return:

    TRUE if successful
    FALSE if an error occurs

--*/
{
    TCHAR szMsg[MAX_PATH];
    TCHAR szErrorMsg[2*MAX_PATH+40];
    LPTSTR aStrings[2];
    WORD wType;
    va_list marker;


    //
    // Load the message
    //

    if (idMsg != 0) {
        if (!LoadString (hInstance, idMsg, szMsg, MAX_PATH)) {
            return -1;
        }

    } else {
        lstrcpy (szMsg, TEXT("%s"));
    }

    HANDLE hFile = INVALID_HANDLE_VALUE;
    if ( LogFileName ) {
        hFile = CreateFile(LogFileName,
                           GENERIC_WRITE,
                           FILE_SHARE_READ,
                           NULL,
                           OPEN_ALWAYS,
                           FILE_ATTRIBUTE_NORMAL,
                           NULL);

        if (hFile != INVALID_HANDLE_VALUE) {

            DWORD dwBytesWritten;

            SetFilePointer (hFile, 0, NULL, FILE_BEGIN);

            BYTE TmpBuf[3];
            TmpBuf[0] = 0xFF;
            TmpBuf[1] = 0xFE;
            TmpBuf[2] = 0;

            WriteFile (hFile, (LPCVOID)TmpBuf, 2,
                       &dwBytesWritten,
                       NULL);

            SetFilePointer (hFile, 0, NULL, FILE_END);
        }
    }

    //
    // Check for the event log being open.
    //

    if (!hEventLog && dwEventID > 0 ) {

        if ( EventSource[0] == L'\0' ||
             !InitializeEvents(EventSource)) {

            if ( INVALID_HANDLE_VALUE == hFile ) {
                return -1;   // no event log and the log file can't be opened
            }
        }
    }

    //
    // Plug in the arguments
    //
    szErrorMsg[0] = L'\0';
    va_start(marker, idMsg);

    __try {
        wvsprintf(szErrorMsg, szMsg, marker);
    } __except(EXCEPTION_EXECUTE_HANDLER) {

    }
    va_end(marker);


    //
    // Report the event to the eventlog
    //

    int iRet = 0;

    if ( hEventLog && dwEventID > 0 ) {

        aStrings[0] = szErrorMsg;

        switch (LogLevel) {
        case STATUS_SEVERITY_WARNING:
            wType = EVENTLOG_WARNING_TYPE;
            break;
        case STATUS_SEVERITY_ERROR:
            wType = EVENTLOG_ERROR_TYPE;
            break;
        default:
            wType = EVENTLOG_INFORMATION_TYPE;
            break;
        }

        if (!ReportEvent(hEventLog,
                         wType,
                         0,
                         dwEventID,
                         NULL,
                         1,
                         0,
                         (LPCTSTR *)aStrings,
                         NULL) ) {
            iRet = 1;
        }
    }

    if ( INVALID_HANDLE_VALUE != hFile ) {
        //
        // Log to the log file
        //
        ScepWriteSingleUnicodeLog(hFile, FALSE, L"\r\n");
        ScepWriteSingleUnicodeLog(hFile, TRUE, szErrorMsg );

        CloseHandle(hFile);
    }

    return iRet;
}


BOOL
ShutdownEvents (void)
/*++
Routine Description:

    Stops the event log

Arguments:

    None

Return:

    TRUE if successful
    FALSE if an error occurs
--*/
{
    BOOL bRetVal = TRUE;
    HANDLE hTemp = hEventLog;

    hEventLog = NULL;
    if (hTemp) {
        bRetVal = DeregisterEventSource(hTemp);
    }

    EventSource[0] = L'\0';
    return bRetVal;
}


SCESTATUS
ScepConvertToSDDLFormat(
    IN LPTSTR pszValue,
    IN DWORD Len
    )
{
    if ( pszValue == NULL || Len == 0 ) {
        return SCESTATUS_INVALID_PARAMETER;
    }

    ScepConvertSDDLSid(pszValue, L"DA", L"BA");

    ScepConvertSDDLSid(pszValue, L"RP", L"RE");

    ScepConvertSDDLAceType(pszValue, L"SA", L"AU");

    ScepConvertSDDLAceType(pszValue, L"SM", L"AL");

    ScepConvertSDDLAceType(pszValue, L"OM", L"OL");

    return SCESTATUS_SUCCESS;

}


BOOL
ScepConvertSDDLSid(
    LPTSTR  pszValue,
    PCWSTR  szSearchFor,  // only two letters are allowed
    PCWSTR  szReplace
    )
{

    PWSTR pTemp = pszValue;
    DWORD i;

    while ( pTemp && *pTemp != L'\0' ) {

        pTemp = wcsstr(pTemp, szSearchFor);

        if ( pTemp != NULL ) {

            //
            // find the first non space char
            // must be : or ;
            //
            i=1;

            while ( pTemp-i > pszValue && *(pTemp-i) == L' ' ) {
                i++;
            }

            if ( pTemp-i > pszValue &&
                 ( *(pTemp-i) == L':' || *(pTemp-i) == L';') ) {

                //
                // find the next non space char
                // must be ), O:, G:, D:, S:
                //

                i=2;
                while ( *(pTemp+i) == L' ' ) {
                    i++;
                }

                if ( *(pTemp+i) == L')' ||
                     ( *(pTemp+i) != L'\0' && *(pTemp+i+1) == L':')) {
                    //
                    // find one, replace it
                    //
                    *pTemp = szReplace[0];
                    *(pTemp+1) = szReplace[1];
                }

                pTemp += 2;

            } else {

                //
                // this is not a one to convert
                //
                pTemp += 2;
            }
        }
    }

    return TRUE;
}


BOOL
ScepConvertSDDLAceType(
    LPTSTR  pszValue,
    PCWSTR  szSearchFor,  // only two letters are allowed
    PCWSTR  szReplace
    )
{

    PWSTR pTemp = pszValue;
    DWORD i;

    while ( pTemp && *pTemp != L'\0' ) {

        pTemp = wcsstr(pTemp, szSearchFor);

        if ( pTemp != NULL ) {

            //
            // find the first non space char
            // must be (
            //
            i=1;

            while ( pTemp-i > pszValue && *(pTemp-i) == L' ' ) {
                i++;
            }

            if ( pTemp-i > pszValue &&
                 ( *(pTemp-i) == L'(') ) {

                //
                // find the next non space char
                // must be ;
                //

                i=2;
                while ( *(pTemp+i) == L' ' ) {
                    i++;
                }

                if ( *(pTemp+i) == L';' ) {
                    //
                    // find one, replace it with AU
                    //
                    *pTemp = szReplace[0];
                    *(pTemp+1) = szReplace[1];
                }

                pTemp += 2;

            } else {

                //
                // this is not a one to convert
                //
                pTemp += 2;
            }
        }
    }

    return TRUE;
}

BOOL
SceIsSystemDatabase(
    IN LPCTSTR DatabaseName
    )
/*
Routine Description:

    Determine if the given database is the default system database

Argument:

    DatabaseName    - the database name (full path)

Return Value:

    TRUE    - the given database is the system database

    FALSE   - the database is not the system database or error occurred
              GetLastError() to get the error.
*/
{

    if ( DatabaseName == NULL ) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    DWORD rc;
    PWSTR DefProfile=NULL;
    DWORD RegType;

/*
    // do not save system database in registry
    // always "hardcoded" to %windir%\security\database
    // query the system database name
    //
    rc = ScepRegQueryValue(
            HKEY_LOCAL_MACHINE,
            SCE_ROOT_PATH,
            L"DefaultProfile",
            (PVOID *)&DefProfile,
            &RegType
            );

    if ( rc != NO_ERROR ) {
*/
        //
        // use the default
        //
        PWSTR SysRoot=NULL;

        RegType =  0;

        rc = ScepGetNTDirectory( &SysRoot, &RegType, SCE_FLAG_WINDOWS_DIR );

        if ( rc == NO_ERROR ) {

            if ( SysRoot != NULL ) {

                //
                // default location is %SystemRoot%\Security\Database\secedit.sdb
                //
                TCHAR TempName[256];

                wcscpy(TempName, L"\\Security\\Database\\secedit.sdb");
                RegType += wcslen(TempName)+1;

                DefProfile = (PWSTR)ScepAlloc( 0, RegType*sizeof(WCHAR));
                if ( DefProfile != NULL ) {
                    swprintf(DefProfile, L"%s%s", SysRoot, TempName );

                    *(DefProfile+RegType-1) = L'\0';

                } else
                    rc = ERROR_NOT_ENOUGH_MEMORY;


                ScepFree(SysRoot);

            } else
                rc = ERROR_INVALID_DATA;
        }
//    }

    BOOL bRet=FALSE;

    if ( (rc == NO_ERROR) && DefProfile ) {

        if ( _wcsicmp(DefProfile, DatabaseName) == 0 ) {
            //
            // this is the system database
            //
            bRet = TRUE;
        }
    }

    ScepFree(DefProfile);

    //
    // set last error and return
    //
    if ( bRet ) {
        SetLastError(ERROR_SUCCESS);
    } else {
        SetLastError(rc);
    }

    return(bRet);
}

DWORD
ScepWriteVariableUnicodeLog(
    IN HANDLE hFile,
    IN BOOL bAddCRLF,
    IN LPTSTR szFormat,
    ...
    )
{
    if ( INVALID_HANDLE_VALUE == hFile || NULL == hFile ||
         NULL == szFormat ) {
        return(ERROR_INVALID_PARAMETER);
    }

    va_list            args;
    LPTSTR             lpDebugBuffer;
    DWORD              rc=ERROR_NOT_ENOUGH_MEMORY;

    lpDebugBuffer = (LPTSTR) LocalAlloc (LPTR, 2048 * sizeof(TCHAR));

    if (lpDebugBuffer) {

        va_start( args, szFormat );

        _vsnwprintf(lpDebugBuffer, 2048 - 1, szFormat, args);

        va_end( args );

        //
        // always put a CR/LF at the end
        //

        DWORD dwBytesWritten;

        if ( WriteFile (hFile, (LPCVOID) lpDebugBuffer,
                       wcslen (lpDebugBuffer) * sizeof(WCHAR),
                       &dwBytesWritten,
                       NULL) ) {

            if ( bAddCRLF ) {

                WriteFile (hFile, (LPCVOID) c_szCRLF,
                           2 * sizeof(WCHAR),
                           &dwBytesWritten,
                           NULL);
            }

            rc = ERROR_SUCCESS;

        } else {
            rc = GetLastError();
        }

        LocalFree(lpDebugBuffer);

    }

    return(rc);

}


DWORD
ScepWriteSingleUnicodeLog(
    IN HANDLE hFile,
    IN BOOL bAddCRLF,
    IN LPWSTR szMsg
    )
{
    if ( INVALID_HANDLE_VALUE == hFile ) {
        return(ERROR_INVALID_PARAMETER);
    }

    DWORD dwBytesWritten;

    if ( WriteFile (hFile, (LPCVOID) szMsg,
                   wcslen (szMsg) * sizeof(WCHAR),
                   &dwBytesWritten,
                   NULL) ) {

        if ( bAddCRLF) {
            // add \r\n to the end of the string
            WriteFile (hFile, (LPCVOID) c_szCRLF,
                       2 * sizeof(WCHAR),
                       &dwBytesWritten,
                       NULL);
        }

        return(ERROR_SUCCESS);

    } else {

        return(GetLastError());
    }

}


//+--------------------------------------------------------------------------
//
//  Function:  ScepWcstrr
//
//  Synopsis:  Returns ptr to rightmost occurence of pSubstring in pString, NULL if none
//
//  Arguments: pString to look in, pSubstring to look for
//
//  Returns:   Returns ptr to rightmost occurence of pSubstring in pString, NULL if none
//
//+--------------------------------------------------------------------------
WCHAR *
ScepWcstrr(
    IN PWSTR pString,
    IN const WCHAR *pSubstring
    )
{
    int i, j, k;

    for (i = wcslen(pString) - wcslen(pSubstring) ; i >= 0; i-- ) {

        for (j = i, k = 0; pSubstring[k] != L'\0' && towlower(pString[j]) == towlower(pSubstring[k]); j++, k++)
            ;

        if ( k > 0 && pSubstring[k] == L'\0')

            return pString + i;
    }

    return NULL;

}

DWORD
ScepExpandEnvironmentVariable(
   IN PWSTR oldFileName,
   IN PCWSTR szEnv,
   IN DWORD nFlag,
   OUT PWSTR *newFileName)
/*
Description:

    Expand built-in environment variables known by SCE, including %SystemRoot%,
    %SystemDirectory%, %SystemDrive%, %DSDIT%, %DSLOG%, %SYSVOL%, %BOOTDRIVE%.

Parameters:

    oldFileName - the file name to expand

    szEnv       - the environment variable to search for

    nFlag       - the corresponding system env variable flag
                      SCE_FLAG_WINDOWS_DIR
                      SCE_FLAG_SYSTEM_DIR
                      SCE_FLAG_BOOT_DRIVE
                      SCE_FLAG_DSDIT_DIR
                      SCE_FLAG_DSLOG_DIR
                      SCE_FLAG_SYSVOL_DIR

    newFileName - the expanded file name if succeeded

Return Value:

    ERROR_FILE_NOT_FOUND if the environment varialbe is not found in the input file name

    ERROR_SUCCESS if the env variable is successfully expanded

    Otherwise, error code is returned.

*/
{
    if ( oldFileName == NULL || szEnv == NULL || newFileName == NULL ) {
        return ERROR_INVALID_PARAMETER;
    }

    PWSTR pTemp = wcsstr( _wcsupr(oldFileName), szEnv);
    LPTSTR  NtDir=NULL;
    DWORD   newFileSize, dSize=0;
    DWORD rc = ERROR_FILE_NOT_FOUND;

    if ( pTemp != NULL ) {
        //
        // found the environment variable
        //
        rc = ScepGetNTDirectory( &NtDir, &dSize, nFlag );

        if ( NO_ERROR == rc && NtDir ) {

            pTemp += wcslen(szEnv);
            BOOL bSysDrive=FALSE;

            switch ( nFlag ) {
            case SCE_FLAG_WINDOWS_DIR:
                if ( _wcsicmp(szEnv, L"%SYSTEMDRIVE%") == 0 ) {
                    dSize = 3;
                    bSysDrive = TRUE;
                }
                break;
            case SCE_FLAG_BOOT_DRIVE:
                if ( *pTemp == L'\\' ) pTemp++;  // NtDir contains the back slash already
                break;
            }

            newFileSize = dSize + wcslen(pTemp) + 1;
            *newFileName = (PWSTR)ScepAlloc( LMEM_ZEROINIT, newFileSize*sizeof(TCHAR));

            if (*newFileName != NULL) {

               if ( SCE_FLAG_WINDOWS_DIR == nFlag && bSysDrive ) {

                   // system drive letter
                   **newFileName = NtDir[0];
                   if ( pTemp[0] )
                       swprintf(*newFileName+1, L":%s", _wcsupr(pTemp));
                   else
                       swprintf(*newFileName+1, L":\\");

               } else {
                   swprintf(*newFileName, L"%s%s", NtDir, _wcsupr(pTemp));
               }

            }
            else
               rc = ERROR_NOT_ENOUGH_MEMORY;

        } else if ( NO_ERROR == rc && !NtDir ) {
            rc = ERROR_NOT_ENOUGH_MEMORY;
        }

        if ( NtDir ) {
            ScepFree(NtDir);
        }
    }

    return(rc);
}


DWORD
ScepEnforcePolicyPropagation()
{

    DWORD rc;
    HKEY hKey1=NULL;
    HKEY hKey=NULL;
    DWORD RegType;
    DWORD dwInterval=0;
    DWORD DataSize=sizeof(DWORD);

    if(( rc = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                           GPT_SCEDLL_NEW_PATH,
                          0,
                          KEY_READ | KEY_WRITE,
                          &hKey
                         )) == ERROR_SUCCESS ) {

        rc = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                              SCE_ROOT_PATH,
                              0,
                              KEY_READ | KEY_WRITE,
                              &hKey1
                             );
    }

    if ( ERROR_SUCCESS == rc ) {

        if ( ERROR_SUCCESS != RegQueryValueEx(hKey1,
                                     TEXT("GPOSavedInterval"),
                                     0,
                                     &RegType,
                                     (BYTE *)&dwInterval,
                                     &DataSize
                                    ) ) {
            //
            // either the value doesn't exist or fail to read it.
            // In either case, it's considered as no backup value
            // Now query the current value and save it
            //
            DataSize = sizeof(DWORD);
            if ( ERROR_SUCCESS != RegQueryValueEx(hKey,
                                         TEXT("MaxNoGPOListChangesInterval"),
                                         0,
                                         &RegType,
                                         (BYTE *)&dwInterval,
                                         &DataSize
                                        ) ) {
                dwInterval = 960;
            }

            rc = RegSetValueEx( hKey1,
                                TEXT("GPOSavedInterval"),
                                0,
                                REG_DWORD,
                                (BYTE *)&dwInterval,
                                sizeof(DWORD)
                                );

        } // else if the value already exists, don't need to save it again



        if ( ERROR_SUCCESS == rc ) {
            dwInterval = 1;
            rc = RegSetValueEx( hKey,
                                TEXT("MaxNoGPOListChangesInterval"),
                                0,
                                REG_DWORD,
                                (BYTE *)&dwInterval,
                                sizeof(DWORD)
                                );
        }

    }

    //
    // close the keys
    //
    if ( hKey1 )
        RegCloseKey( hKey1 );

    if ( hKey )
        RegCloseKey( hKey );

    return(rc);

}

DWORD
ScepGetTimeStampString(
    IN OUT PWSTR pvBuffer
    )
/*
Retrun long format of date/time string based on the locale.
*/
{
    if ( pvBuffer == NULL ) {
        return(ERROR_INVALID_PARAMETER);
    }

    DWORD         rc;
    LARGE_INTEGER CurrentTime;
    LARGE_INTEGER SysTime;
    TIME_FIELDS   TimeFields;
    NTSTATUS      NtStatus;

    FILETIME      ft;
    SYSTEMTIME    st;

    NtStatus = NtQuerySystemTime(&SysTime);
    rc = RtlNtStatusToDosError(NtStatus);

    RtlSystemTimeToLocalTime (&SysTime,&CurrentTime);

    if ( NT_SUCCESS(NtStatus) &&
         (CurrentTime.LowPart != 0 || CurrentTime.HighPart != 0) ) {

        rc = ERROR_SUCCESS;

        ft.dwLowDateTime = CurrentTime.LowPart;
        ft.dwHighDateTime = CurrentTime.HighPart;

        if ( !FileTimeToSystemTime(&ft, &st) ) {

            rc = GetLastError();

        } else {
            //
            // format date/time into the right locale format
            //

            TCHAR szDate[32];
            TCHAR szTime[32];

            //
            // GetDateFormat is the NLS routine that formats a time in a
            // locale-sensitive fashion.
            //
            if (0 == GetDateFormat(LOCALE_SYSTEM_DEFAULT, DATE_LONGDATE,
                                    &st, NULL,szDate, 32)) {
                rc = GetLastError();

            } else {
                //
                // GetTimeFormat is the NLS routine that formats a time in a
                // locale-sensitive fashion.
                //
                if (0 == GetTimeFormat(LOCALE_SYSTEM_DEFAULT, 0, &st, NULL, szTime, 32)) {

                    rc = GetLastError();

                } else {

                    //
                    // Concatenate date and time
                    //
                    wcscpy(pvBuffer, szDate);
                    wcscat(pvBuffer, L" ");
                    wcscat(pvBuffer, szTime);

                }
            }
        }

        //
        // if can't get the system time in right locale,
        // print it in the current (default) format
        //
        if ( rc != NO_ERROR ) {

            memset(&TimeFields, 0, sizeof(TIME_FIELDS));

            RtlTimeToTimeFields (
                        &CurrentTime,
                        &TimeFields
                        );
            if ( TimeFields.Month > 0 && TimeFields.Month <= 12 &&
                 TimeFields.Day > 0 && TimeFields.Day <= 31 &&
                 TimeFields.Year > 1600 ) {

                swprintf(pvBuffer, L"%02d/%02d/%04d %02d:%02d:%02d\0",
                                 TimeFields.Month, TimeFields.Day, TimeFields.Year,
                                 TimeFields.Hour, TimeFields.Minute, TimeFields.Second);
            } else {
                swprintf(pvBuffer, L"%08x08x\0", CurrentTime.HighPart, CurrentTime.LowPart);
            }
        }

        rc = ERROR_SUCCESS;
    }

    return(rc);
}

DWORD
ScepAppendCreateMultiSzRegValue(
    IN  HKEY    hKeyRoot,
    IN  PWSTR   pszSubKey,
    IN  PWSTR   pszValueName,
    IN  PWSTR   pszValueValue
    )
/*++

Routine Description:

    This routine will append(if existing)/create(if not existing) w.r.t. MULTI_SZ values

Arguments:

    hKeyRoot        - root such as HKEY_LOCAL_MACHINE
    pszSubKey       - subkey such as "Software\\Microsoft\\Windows NT\\CurrentVersion\\SeCEdit"
    pszValueName    - value name of the key to be changed
    pszValueValue   - value of the value name to be changed


Return:

    error code (DWORD)
--*/
{

    DWORD   rc = ERROR_SUCCESS;
    DWORD   dwSize = 0;
    HKEY    hKey = NULL;
    DWORD   dwNewKey = NULL;
    DWORD   dwRegType = 0;

    if (hKeyRoot == NULL || pszSubKey  == NULL || pszValueName  == NULL || pszValueValue == NULL) {

        return ERROR_INVALID_PARAMETER;

    }

    if(( rc = RegOpenKeyEx(hKeyRoot,
                              pszSubKey,
                              0,
                              KEY_SET_VALUE | KEY_QUERY_VALUE ,
                              &hKey
                             )) != ERROR_SUCCESS ) {

        rc = RegCreateKeyEx(
                   hKeyRoot,
                   pszSubKey,
                   0,
                   NULL,
                   REG_OPTION_NON_VOLATILE,
                   KEY_WRITE,
                   NULL,
                   &hKey,
                   &dwNewKey
                  );
    }

    if ( ERROR_SUCCESS == rc ) {

        //
        // need to read the MULTI_SZ, append to it and set then new MULTI_SZ value
        //

        rc = RegQueryValueEx(hKey,
                             pszValueName,
                             0,
                             &dwRegType,
                             NULL,
                             &dwSize
                            );

        if ( ERROR_SUCCESS == rc || ERROR_FILE_NOT_FOUND == rc ) {

            //
            // dwSize is always size in bytes
            //

            DWORD   dwBytesToAdd = 0;

            //
            // if dwUnicodeSize == 0, then MULTI_SZ value was non-existent before
            //

            DWORD   dwUnicodeSize = (dwSize >= 2 ? dwSize/2 - 1 : 0);

            dwBytesToAdd = 2 * (wcslen(pszValueValue) + 2);

            PWSTR pszValue = (PWSTR)ScepAlloc( LMEM_ZEROINIT, dwSize + dwBytesToAdd) ;

            if ( pszValue != NULL ) {

                rc = RegQueryValueEx(hKey,
                                     pszValueName,
                                     0,
                                     &dwRegType,
                                     (BYTE *)pszValue,
                                     &dwSize
                                    );

                //
                // append pszValueValue to the end of the MULTI_SZ taking care of duplicates
                // i.e. abc\0def\0ghi\0\0 to something like
                //      abc\0def\0ghi\0jkl\0\0
                //

                if ( ScepMultiSzWcsstr(pszValue, pszValueValue) == NULL ) {

                    memcpy(pszValue + dwUnicodeSize, pszValueValue, dwBytesToAdd);
                    memset(pszValue + dwUnicodeSize + (dwBytesToAdd/2 - 2), '\0', 4);

                    if ( ERROR_SUCCESS == rc  || ERROR_FILE_NOT_FOUND == rc) {

                        rc = RegSetValueEx( hKey,
                                            pszValueName,
                                            0,
                                            REG_MULTI_SZ,
                                            (BYTE *)pszValue,
                                            (dwUnicodeSize == 0 ? dwSize + dwBytesToAdd : dwSize + dwBytesToAdd - 2)
                                          );

                    }
                }

                ScepFree(pszValue);
            }

            else {

                rc = ERROR_NOT_ENOUGH_MEMORY;
            }
        }

    }

    if( hKey )
        RegCloseKey( hKey );

    return rc;

}

PWSTR
ScepMultiSzWcsstr(
    PWSTR   pszStringToSearchIn,
    PWSTR   pszStringToSearchFor
    )
/*++

Routine Description:

    MULTI_SZ version of wcsstr

Arguments:

    pszStringToSearchIn     -   \0\0 terminated string to search in (MULTI_SZ)
    pszStringToSearchFor    -   \0 terminated string to search for (regular unicode string)

Return:

    pointer to first occurence of pszStringToSearchFor in pszStringToSearchIn

--*/
{
    PWSTR   pszCurrString = NULL;

    if (pszStringToSearchIn == NULL || pszStringToSearchFor == NULL) {
        return NULL;
    }

    if (pszStringToSearchFor[0] == L'\0' ||
        (pszStringToSearchIn[0] == L'\0' && pszStringToSearchIn[1] == L'\0') ) {
        return NULL;
    }

    pszCurrString = pszStringToSearchIn;

    __try {

        while ( !(pszCurrString[0] == L'\0' &&  pszCurrString[1] == L'\0') ) {

            if ( NULL != wcsstr(pszCurrString, pszStringToSearchFor) ) {
                return pszCurrString;
            }

            //
            // so, if C:\0E:\0\0, advance pszCurrString to the first \0 at the end ie. C:\0E:\0\0
            //        ^                                                                  ^

            pszCurrString += wcslen(pszCurrString) ;

            if (pszCurrString[0] == L'\0' &&  pszCurrString[1] == L'\0') {
                return NULL;
            }

            //
            // if it stopped at C:\0E:\0\0, advance pszCurrString C:\0E:\0\0
            //                     ^                                  ^

            pszCurrString += 1;
        }

    } __except(EXCEPTION_EXECUTE_HANDLER) {
    }


    return NULL;
}



DWORD
ScepEscapeString(
    IN const PWSTR pszSource,
    IN const DWORD dwSourceChars,
    IN const WCHAR wcEscapee,
    IN const WCHAR wcEscaper,
    IN OUT PWSTR pszTarget
    )

/* ++

Routine Description:

   Escapes escapee with escaper i.e.

   escapee -> escaper escapee escaper

   e.g. a,\0b\0c\0\0 -> a","\0b\0c\0\0

Arguments:

    pszSource       -   The source string

    dwSourceChars   -   The number of chars in pszSource

    wcEscapee       -  The escapee

    wcEscaper       -   The escaper

    pszTarget       -   The destination string

Return value:

   Number of characters copied to the target

-- */
{

    DWORD   dwTargetChars = 0;

    for (DWORD dwIndex=0; dwIndex < dwSourceChars; dwIndex++) {

        if ( pszSource[dwIndex] == wcEscapee ){
            pszTarget[0] = wcEscaper;
            pszTarget[1] = wcEscapee;
            pszTarget[2] = wcEscaper;
            pszTarget += 3;
            dwTargetChars +=3;
        }
        else {
            pszTarget[0] = pszSource[dwIndex];
            pszTarget++;
            ++dwTargetChars ;
        }
    }

    return dwTargetChars;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\scerpc\common.h ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    common.h

Abstract:

    This module defines the data structures and function prototypes
    shared by both SCE client and SCE server

Author:

    Jin Huang (jinhuang) 23-Jan-1998

Revision History:

    jinhuang (splitted from scep.h)
--*/
#ifndef _scecommon_
#define _scecommon_

typedef enum _SECURITY_DB_TYPE {
    SecurityDbSam = 1,
    SecurityDbLsa
} SECURITY_DB_TYPE, *PSECURITY_DB_TYPE;

#define SCE_TEMPLATE_MAX_SUPPORTED_VERSION      1

#define szLegalNoticeTextKeyName L"MACHINE\\Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\System\\LegalNoticeText"


//
// type of system access lookup table
//

#define SCESETUP_UPDATE_DB_ONLY         0x1000L

#define SCE_SYSTEM_DB                   0x0100L
#define SCE_CREATE_BUILTIN_ACCOUNTS     0x0200L
#define SCE_POLBIND_NO_AUTH             0x0400L
#define SCE_NO_ANALYZE                  0x0800L
#define SCE_NO_DOMAIN_POLICY            0x2000L
#define SCE_NOCOPY_DOMAIN_POLICY        0x4000L
#define SCE_COPY_LOCAL_POLICY           0x8000L

#define SCE_POLICY_TEMPLATE             0x00010000L
#define SCE_POLICY_FIRST                0x00020000L
#define SCE_POLICY_LAST                 0x00040000L

#define SCE_SYSTEM_SETTINGS             0x00080000L

#define SCE_DCPROMO_WAIT                0x00100000L
#define SCE_SETUP_SERVICE_NOSTARTTYPE   0x00200000L
#define SCE_NO_CONFIG_FILEKEY           0x00400000L
#define SCE_DC_DEMOTE                   0x00800000L
#define SCE_RE_ANALYZE                  0x01000000L
#define SCE_RSOP_CALLBACK               0x02000000L
#define SCE_GENERATE_ROLLBACK           0x04000000L


#define SCE_FLAG_WINDOWS_DIR            1
#define SCE_FLAG_SYSTEM_DIR             2
#define SCE_FLAG_DSDIT_DIR              3
#define SCE_FLAG_DSLOG_DIR              4
#define SCE_FLAG_SYSVOL_DIR             5
#define SCE_FLAG_BOOT_DRIVE             6

#define SCE_GROUP_STATUS_DONE_IN_DS     0x80000000L

#define SCEP_ADL_HTABLE_SIZE 256

//
// Macros to extract the SID from a object ACE
//
#define ScepObjectAceObjectTypePresent( Ace ) \
     ((((SCEP_PKNOWN_OBJECT_ACE)(Ace))->Flags & ACE_OBJECT_TYPE_PRESENT) != 0 )
#define ScepObjectAceInheritedObjectTypePresent( Ace ) \
     ((((SCEP_PKNOWN_OBJECT_ACE)(Ace))->Flags & ACE_INHERITED_OBJECT_TYPE_PRESENT) != 0 )

#define ScepObjectAceSid( Ace ) \
    ((PSID)(((PUCHAR)&(((SCEP_PKNOWN_OBJECT_ACE)(Ace))->SidStart)) + \
     (ScepObjectAceObjectTypePresent(Ace) ? sizeof(GUID) : 0 ) + \
     (ScepObjectAceInheritedObjectTypePresent(Ace) ? sizeof(GUID) : 0 )))

#define ScepObjectAceObjectType( Ace ) \
     ((GUID *)(ScepObjectAceObjectTypePresent(Ace) ? \
        &((SCEP_PKNOWN_OBJECT_ACE)(Ace))->SidStart : \
        NULL ))

#define ScepObjectAceInheritedObjectType( Ace ) \
     ((GUID *)(ScepObjectAceInheritedObjectTypePresent(Ace) ? \
        ( ScepObjectAceObjectTypePresent(Ace) ? \
            (PULONG)(((PUCHAR)(&((SCEP_PKNOWN_OBJECT_ACE)(Ace))->SidStart)) + sizeof(GUID)) : \
            &((SCEP_PKNOWN_OBJECT_ACE)(Ace))->SidStart ) : \
        NULL ))

static GENERIC_MAPPING FileGenericMapping = {
                        FILE_GENERIC_READ,
                        FILE_GENERIC_WRITE,
                        FILE_GENERIC_EXECUTE,
                        FILE_ALL_ACCESS
                        };

static GENERIC_MAPPING KeyGenericMapping = {
                        KEY_READ,
                        KEY_WRITE,
                        KEY_EXECUTE,
                        KEY_ALL_ACCESS
                        };

#define SERVICE_GENERIC_READ        (STANDARD_RIGHTS_READ |\
                                     SERVICE_QUERY_CONFIG |\
                                     SERVICE_QUERY_STATUS |\
                                     SERVICE_ENUMERATE_DEPENDENTS |\
                                     SERVICE_INTERROGATE |\
                                     SERVICE_USER_DEFINED_CONTROL)

#define SERVICE_GENERIC_EXECUTE     (STANDARD_RIGHTS_EXECUTE |\
                                     SERVICE_START |\
                                     SERVICE_STOP |\
                                     SERVICE_PAUSE_CONTINUE |\
                                     SERVICE_INTERROGATE |\
                                     SERVICE_USER_DEFINED_CONTROL)

#define SERVICE_GENERIC_WRITE       (STANDARD_RIGHTS_WRITE |\
                                     SERVICE_CHANGE_CONFIG )

static GENERIC_MAPPING SvcGenMap = {
                SERVICE_GENERIC_READ,
                SERVICE_GENERIC_WRITE,
                SERVICE_GENERIC_EXECUTE,
                SERVICE_ALL_ACCESS
                };

typedef struct _SCE_KEY_LOOKUP {
   PWSTR    KeyString;
   UINT     Offset;
   CHAR     BufferType;
}SCE_KEY_LOOKUP;

typedef struct _SCE_TATTOO_KEYS_ {
   PWSTR    KeyName;
   DWORD    KeyLen;
   CHAR     DataType;
   DWORD    SaveValue;
   PWSTR    Value;
}SCE_TATTOO_KEYS;

typedef struct _SCEP_HANDLE_ {

    PVOID hProfile;
    PCWSTR ServiceName;

} SCEP_HANDLE, *PSCEP_HANDLE;

//
// ACE template on which extraction macros are based on
//
typedef struct _SCEP_KNOWN_OBJECT_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    ULONG Flags;
    // GUID ObjectType;             // Optionally present
    // GUID InheritedObjectType;    // Optionally present
    ULONG SidStart;
} SCEP_KNOWN_OBJECT_ACE, *SCEP_PKNOWN_OBJECT_ACE;

typedef struct _SCEP_ADL_NODE_ {

    PISID   pSid;
    GUID    *pGuidObjectType;
    GUID    *pGuidInheritedObjectType;
    UCHAR   AceType;
    DWORD   dwEffectiveMask;
    DWORD   dw_CI_IO_Mask;
    DWORD   dw_OI_IO_Mask;
    DWORD   dw_NP_CI_IO_Mask;
    struct _SCEP_ADL_NODE_  *Next;

} SCEP_ADL_NODE, *PSCEP_ADL_NODE;


#define TICKS_PRIVILEGE             15
#define TICKS_GROUPS                15
#define TICKS_SYSTEM_ACCESS         3
#define TICKS_SYSTEM_AUDITING       3
#define TICKS_KERBEROS              3
#define TICKS_REGISTRY_VALUES       4
#define TICKS_GENERAL_SERVICES      10
#define TICKS_SPECIFIC_SERVICES     5
#define TICKS_SPECIFIC_POLICIES     5

#define TICKS_SECURITY_POLICY_DS ( TICKS_SYSTEM_ACCESS + \
                                   TICKS_SYSTEM_AUDITING + \
                                   TICKS_REGISTRY_VALUES + \
                                   TICKS_KERBEROS )

#define TICKS_MIGRATION_SECTION     100
#define TICKS_MIGRATION_V11         50

#define SCE_OPEN_OPTION_REQUIRE_ANALYSIS    1
#define SCE_OPEN_OPTION_TATTOO              2

#define SCE_RESET_POLICY_KEEP_LOCAL         0x1
#define SCE_RESET_POLICY_ENFORCE_ATREBOOT   0x2
#define SCE_RESET_POLICY_SYSPREP            0x4
#define SCE_RESET_POLICY_TATTOO             0x8

//
// strsd.c
//

DWORD
WINAPI
ConvertTextSecurityDescriptor (
    IN  PWSTR                   pwszTextSD,
    OUT PSECURITY_DESCRIPTOR   *ppSD,
    OUT PULONG                  pcSDSize,
    OUT PSECURITY_INFORMATION   pSeInfo
    );

DWORD
WINAPI
ConvertSecurityDescriptorToText (
    IN PSECURITY_DESCRIPTOR   pSD,
    IN SECURITY_INFORMATION   SecurityInfo,
    OUT PWSTR                  *ppwszTextSD,
    OUT PULONG                 pcTextSize
    );

//
// defined in common.cpp
//

SCESTATUS
ScepDosErrorToSceStatus(
    DWORD rc
    );

SCESTATUS
WINAPI
SceSvcpGetInformationTemplate(
    IN HINF hInf,
    IN PCWSTR ServiceName,
    IN PCWSTR Key OPTIONAL,
    OUT PSCESVC_CONFIGURATION_INFO *ServiceInfo
    );

SCESTATUS
ScepBuildErrorLogInfo(
    IN DWORD   rc,
    OUT PSCE_ERROR_LOG_INFO *Errlog,
    IN UINT    nId,
//    IN PCWSTR  fmt,
    ...
    );

DWORD
ScepAddToNameList(
    OUT PSCE_NAME_LIST *pNameList,
    IN PWSTR Name,
    IN ULONG Len
    );

DWORD
ScepRegQueryIntValue(
    IN HKEY hKeyRoot,
    IN PWSTR SubKey,
    IN PWSTR ValueName,
    OUT DWORD *Value
    );

DWORD
ScepRegQueryBinaryValue(
    IN HKEY hKeyRoot,
    IN PWSTR SubKey,
    IN PWSTR ValueName,
    OUT PBYTE *ppValue
    );

DWORD
ScepRegSetIntValue(
    IN HKEY hKeyRoot,
    IN PWSTR SubKey,
    IN PWSTR ValueName,
    IN DWORD Value
    );

DWORD
ScepRegQueryValue(
    IN HKEY hKeyRoot,
    IN PWSTR SubKey,
    IN PCWSTR ValueName,
    OUT PVOID *Value,
    OUT LPDWORD pRegType
    );

DWORD
ScepRegSetValue(
    IN HKEY hKeyRoot,
    IN PWSTR SubKey,
    IN PWSTR ValueName,
    IN DWORD RegType,
    IN BYTE *Value,
    IN DWORD ValueLen
    );

DWORD
ScepRegDeleteValue(
    IN HKEY hKeyRoot,
    IN PWSTR SubKey,
    IN PWSTR ValueName
   );

SCESTATUS
ScepCreateDirectory(
    IN PCWSTR ProfileLocation,
    IN BOOL FileOrDir,
    PSECURITY_DESCRIPTOR pSecurityDescriptor
    );

DWORD
ScepSceStatusToDosError(
    IN SCESTATUS SceStatus
    );

SCESTATUS
ScepChangeAclRevision(
    IN PSECURITY_DESCRIPTOR pSD,
    IN BYTE NewRevision
    );

BOOL
ScepEqualGuid(
    IN GUID *Guid1,
    IN GUID *Guid2
    );

SCESTATUS
ScepAddToGroupMembership(
    OUT PSCE_GROUP_MEMBERSHIP *pGroupMembership,
    IN  PWSTR Keyname,
    IN  DWORD KeyLen,
    IN  PSCE_NAME_LIST pMembers,
    IN  DWORD ValueType,
    IN  BOOL bCheckDup,
    IN  BOOL bReplaceList
    );

DWORD
ScepAddOneServiceToList(
    IN LPWSTR lpServiceName,
    IN LPWSTR lpDisplayName,
    IN DWORD ServiceStatus,
    IN PVOID pGeneral OPTIONAL,
    IN SECURITY_INFORMATION SeInfo,
    IN BOOL bSecurity,
    OUT PSCE_SERVICES *pServiceList
    );

DWORD
ScepIsAdminLoggedOn(
    OUT PBOOL bpAdminLogon
    );

DWORD
ScepGetProfileSetting(
    IN PCWSTR ValueName,
    IN BOOL bAdminLogon,
    OUT PWSTR *Setting
    );

DWORD
ScepCompareObjectSecurity(
    IN SE_OBJECT_TYPE ObjectType,
    IN BOOL IsContainer,
    IN PSECURITY_DESCRIPTOR pSecurityDescriptor,
    IN PSECURITY_DESCRIPTOR ProfileSD,
    IN SECURITY_INFORMATION ProfileSeInfo,
    OUT PBYTE IsDifferent
    );

SCESTATUS
ScepAddToNameStatusList(
    OUT PSCE_NAME_STATUS_LIST *pNameList,
    IN PWSTR Name,
    IN ULONG Len,
    IN DWORD Status
    );

DWORD
ScepAddToObjectList(
    OUT PSCE_OBJECT_LIST  *pNameList,
    IN PWSTR  Name,
    IN ULONG  Len,
    IN BOOL  IsContainer,
    IN BYTE  Status,
    IN DWORD  Count,
    IN BYTE byFlags
    );

DWORD
ScepGetNTDirectory(
    IN PWSTR *ppDirectory,
    IN PDWORD pDirSize,
    IN DWORD  Flag
    );

DWORD
SceAdjustPrivilege(
    IN  ULONG           Priv,
    IN  BOOL            Enable,
    IN  HANDLE          TokenToAdjust
    );

DWORD
ScepGetEnvStringSize(
    IN LPVOID peb
    );

//!!!!!!!!!!!!!!!!!!!!!!!!!!!
// routines to handle events
//!!!!!!!!!!!!!!!!!!!!!!!!!!!

BOOL
InitializeEvents (
    IN LPTSTR EventSourceName
    );

int
LogEvent (
    IN HINSTANCE hInstance,
    IN DWORD LogLevel,
    IN DWORD dwEventID,
    IN UINT idMsg,
    ...
    );

int
LogEventAndReport(
    IN HINSTANCE hInstance,
    IN LPTSTR LogFileName,
    IN DWORD LogLevel,
    IN DWORD dwEventID,
    IN UINT  idMsg,
    ...
    );

BOOL ShutdownEvents (void);

SCESTATUS
ScepConvertToSDDLFormat(
    IN LPTSTR pszValue,
    IN DWORD Len
    );

DWORD
ScepWriteVariableUnicodeLog(
    IN HANDLE hFile,
    IN BOOL bAddCRLF,
    IN LPTSTR szFormat,
    ...
    );

DWORD
ScepWriteSingleUnicodeLog(
    IN HANDLE hFile,
    IN BOOL bAddCRLF,
    IN LPWSTR szMsg
    );

WCHAR *
ScepWcstrr(
    IN PWSTR pString,
    IN const WCHAR *pSubstring
    );

DWORD
ScepExpandEnvironmentVariable(
   IN PWSTR oldFileName,
   IN PCWSTR szEnv,
   IN DWORD nFlag,
   OUT PWSTR *newFileName
   );

DWORD
ScepEnforcePolicyPropagation();

DWORD
ScepGetTimeStampString(
    IN OUT PWSTR pvBuffer
    );

DWORD
ScepAppendCreateMultiSzRegValue(
    IN  HKEY    hKeyRoot,
    IN  PWSTR   pszSubKey,
    IN  PWSTR   pszValueName,
    IN  PWSTR   pszValueValue
    );

DWORD
ScepEscapeString(
    IN const PWSTR pszSource,
    IN const DWORD dwSourceChars,
    IN const WCHAR wcEscapee,
    IN const WCHAR wcEscaper,
    IN OUT PWSTR pszTarget
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\scerpc\hashtable.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    hashtable.h

Abstract:

    This file contains the class prototypes for hashtables

Author:

    Vishnu Patankar    (VishnuP)  7-April-2000

Environment:

    User Mode - Win32

Revision History:


--*/

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Includes                                                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////
#ifndef _hashtable_
#define _hashtable_

#include "headers.h"
#include "secedit.h"

// following typedefs for readability
typedef PSCE_NAME_STATUS_LIST   PSCE_PRECEDENCE_NAME_LIST;
typedef SCE_NAME_STATUS_LIST    SCE_PRECEDENCE_NAME_LIST;

typedef class ScepHashTable SCEP_HASH_TABLE;

class ScepHashTable
{
private:

    PSCE_PRECEDENCE_NAME_LIST   Lookup(PWSTR    pName);

protected:

    PSCE_PRECEDENCE_NAME_LIST   *aTable;
    DWORD   NumBuckets;
    BOOL    bInitialized;
    DWORD   ScepGenericHash(PWSTR    pwszName);
    // if performance hits us for files/regkeys, we can make an abstract base class
    // such that files/keys can derive from this and provide their own hash functions

public:
    ScepHashTable(DWORD  dwNumBuckets);
    ~ScepHashTable();
    DWORD  LookupAdd(PWSTR    pName, DWORD    **ppSettingPrecedence);
#ifdef _DEBUG
    void ScepDumpTable();
#endif
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\scerpc\infp.h ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    infp.h

Abstract:

    Headers of inf read/write

Author:

    Jin Huang (jinhuang) 09-Dec-1996

Revision History:

--*/

#ifndef _infp_
#define _infp_

#define SCE_KEY_MAX_LENGTH     256
#define MAX_STRING_LENGTH      511

typedef DWORD SCEINF_STATUS;
/*
#define SCEINF_SUCCESS              NO_ERROR
#define SCEINF_PROFILE_NOT_FOUND    ERROR_FILE_NOT_FOUND
#define SCEINF_NOT_ENOUGH_MEMORY    ERROR_NOT_ENOUGH_MEMORY
#define SCEINF_ALREADY_RUNNING      ERROR_SERVICE_ALREADY_RUNNING
#define SCEINF_INVALID_PARAMETER    ERROR_INVALID_PARAMETER
#define SCEINF_CORRUPT_PROFILE      ERROR_BAD_FORMAT
#define SCEINF_INVALID_DATA         ERROR_INVALID_DATA
#define SCEINF_ACCESS_DENIED        ERROR_ACCESS_DENIED
#define SCEINF_OTHER_ERROR          10L
*/
typedef struct _SCE_HINF_ {

    BYTE   Type;
    HINF    hInf;

} SCE_HINF, *PSCE_HINF;


//
// function prototypes
//
SCESTATUS
SceInfpOpenProfile(
    IN PCWSTR ProfileName,
    OUT HINF *hInf
    );

SCESTATUS
SceInfpCloseProfile(
    IN HINF hInf
    );
SCESTATUS
SceInfpGetDescription(
    IN HINF hInf,
    OUT PWSTR *Description
    );

SCESTATUS
SceInfpGetSecurityProfileInfo(
    IN  HINF               hInf,
    IN  AREA_INFORMATION   Area,
    OUT PSCE_PROFILE_INFO   *ppInfoBuffer,
    OUT PSCE_ERROR_LOG_INFO *Errlog OPTIONAL
    );

SCESTATUS
SceInfpGetUserSection(
    IN HINF                hInf,
    IN PWSTR               Name,
    OUT PSCE_USER_PROFILE   *pOneProfile,
    OUT PSCE_ERROR_LOG_INFO *Errlog OPTIONAL
    );
/*
SCESTATUS
SceInfpInfErrorToSceStatus(
    IN SCEINF_STATUS InfErr
    );
*/
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\scerpc\hashtable.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    hashtable.cpp

Abstract:

    This file contains the class definitions for hashtables

Author:

    Vishnu Patankar    (VishnuP)  7-April-2000

Environment:

    User Mode - Win32

Revision History:


--*/

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Includes                                                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include "hashtable.h"


///////////////////////////////////////////////////////////////////////////////
// Constructor
//
// in:  dwNumBuckets - the hashtable size
// out:
// return value:
//
// description: creates the hashtable
//              if unable to get memory, bInitialized is set to FALSE
///////////////////////////////////////////////////////////////////////////////

ScepHashTable::ScepHashTable(DWORD    dwNumBuckets){


    if (aTable = (PSCE_PRECEDENCE_NAME_LIST*)ScepAlloc(LMEM_ZEROINIT,
                                                       dwNumBuckets * sizeof(PSCE_PRECEDENCE_NAME_LIST))){
        NumBuckets = dwNumBuckets;

        bInitialized = TRUE;
    }
    else
        bInitialized = FALSE;


}

///////////////////////////////////////////////////////////////////////////////
// Destructor
//
// in:
// out:
// return value:
//
// description: frees memory associated with the hashtable
///////////////////////////////////////////////////////////////////////////////
ScepHashTable::~ScepHashTable(){

    if (bInitialized) {

        for (DWORD BucketNo = 0 ; BucketNo < NumBuckets; BucketNo++)

            if (aTable[BucketNo])
                ScepFreeNameStatusList(aTable[BucketNo]);

        ScepFree(aTable);

        bInitialized = FALSE;

    }

}

///////////////////////////////////////////////////////////////////////////////
// Lookup() method
//
// in: pName - key to search for in the hashtable
// out:
// return value: pointer to hashtable node if found or NULL if none
//
// description: searches the bucket that pName hashed into
//              if found, returns the node, else returns NULL
///////////////////////////////////////////////////////////////////////////////
PSCE_PRECEDENCE_NAME_LIST
ScepHashTable::Lookup(
                    PWSTR   pName
                    )
{
    PSCE_PRECEDENCE_NAME_LIST  pNameList;

    for (pNameList = aTable[ScepGenericHash(pName)]; pNameList != NULL; pNameList = pNameList->Next)

        if (_wcsicmp(pName, pNameList->Name) == 0)

            return pNameList;

    return NULL;
}

///////////////////////////////////////////////////////////////////////////////
// LookupAdd() method
//
// in: pName - key to search for in the hashtable
// out: ppSettingPrecedence - pointer to pointer to the precedence of key
// return value: if out of resources error status, otherwise success
//
// description: if pName found, it returns a pointer to its precedence by reference
//              else, it attempts to create a node and copy the name
//              else it returns error out of resources
///////////////////////////////////////////////////////////////////////////////
DWORD
ScepHashTable::LookupAdd(
                       PWSTR   pName,
                       DWORD   **ppSettingPrecedence
                       )
{
    DWORD rc = NO_ERROR;

    if (bInitialized) {

        if (pName && ppSettingPrecedence && *ppSettingPrecedence == NULL) {

            PSCE_PRECEDENCE_NAME_LIST  pNameList = Lookup(pName);

            if (pNameList == NULL) {

                if (NO_ERROR == (rc = ScepAddToNameStatusList(
                                                                      &(aTable[ScepGenericHash(pName)]),
                                                                      pName,
                                                                      wcslen(pName),
                                                                      0)))

                    *ppSettingPrecedence = &(aTable[ScepGenericHash(pName)]->Status);
            }

            else {

                *ppSettingPrecedence = &(pNameList->Status);

            }


        } else {

            rc = ERROR_INVALID_PARAMETER;

        }

    }

    else {

        rc = ERROR_NOT_ENOUGH_MEMORY;

    }

    return rc;

}


///////////////////////////////////////////////////////////////////////////////
// ScepGenericHash() method
//
// in: pwszName - key to hash
// out:
// return value: hashvalue
//
// description: calculates hash value for the name (to be made virtual)
//
///////////////////////////////////////////////////////////////////////////////

DWORD
ScepHashTable::ScepGenericHash(
                            PWSTR   pwszName
                            )
{
    DWORD   hashval = 0;

    for (; *pwszName != L'\0'; pwszName++)

        hashval = towlower(*pwszName) + 47 * hashval;

    return hashval % NumBuckets;
}

#ifdef _DEBUG
void
ScepHashTable::ScepDumpTable()
{
    if (bInitialized) {

        for (DWORD BucketNo = 0 ; BucketNo < NumBuckets; BucketNo++) {

            PSCE_PRECEDENCE_NAME_LIST  pNameList, pNode;

            for (pNameList = aTable[BucketNo]; pNameList != NULL;) {

                pNode =  pNameList;

                pNameList = pNameList->Next;

                wprintf(L"\nBucket: %i, Name: %s, Precedence %i", BucketNo, pNode->Name, pNode->Status);

            }

        }
    }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\scerpc\scemm.cpp ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    scemm.cpp

Abstract:

    Shared memory management APIs

Author:

    Jin Huang

Revision History:

    jinhuang        23-Jan-1998   merged from multiple modules

--*/
#include "headers.h"
#include "scesvc.h"


PVOID
MIDL_user_allocate (
    size_t  NumBytes
    )

/*++

Routine Description:

    Allocates storage for RPC server transactions.  The RPC stubs will
    either call MIDL_user_allocate when it needs to un-marshall data into a
    buffer that the user must free.  RPC servers will use MIDL_user_allocate to
    allocate storage that the RPC server stub will free after marshalling
    the data.

Arguments:

    NumBytes - The number of bytes to allocate.

Return Value:

    none

Note:


--*/

{
    PVOID Buffer = (PVOID) ScepAlloc(LMEM_FIXED,(DWORD)NumBytes);

    if (Buffer != NULL) {

        RtlZeroMemory( Buffer, NumBytes );
    }

    return( Buffer );
}


VOID
MIDL_user_free (
    void    *MemPointer
    )

/*++

Routine Description:

    Frees storage used in RPC transactions.  The RPC client can call this
    function to free buffer space that was allocated by the RPC client
    stub when un-marshalling data that is to be returned to the client.
    The Client calls MIDL_user_free when it is finished with the data and
    desires to free up the storage.
    The RPC server stub calls MIDL_user_free when it has completed
    marshalling server data that is to be passed back to the client.

Arguments:

    MemPointer - This points to the memory block that is to be released.

Return Value:

    none.

Note:


--*/

{
    ScepFree(MemPointer);
}


SCESTATUS
ScepFreeNameList(
   IN PSCE_NAME_LIST pName
   )
/* ++
Routine Description:

   This routine frees memory associated with PSCE_NAME_LIST pName

Arguments:

   pName - a NAME_LIST

Return value:

   SCESTATUS_SUCCESS

-- */
{
    PSCE_NAME_LIST pCurName;
    PSCE_NAME_LIST pTempName;
    SCESTATUS      rc=SCESTATUS_SUCCESS;

    if ( pName == NULL )
        return(rc);

    //
    // free the Name component first then free the node
    //
    pCurName = pName;
    while ( pCurName != NULL ) {
        if ( pCurName->Name != NULL )
            __try {
                ScepFree( pCurName->Name );
            } __except (EXCEPTION_EXECUTE_HANDLER) {
                rc = SCESTATUS_INVALID_PARAMETER;
            }

        pTempName = pCurName;
        pCurName = pCurName->Next;

        __try {
            ScepFree( pTempName );
        } __except (EXCEPTION_EXECUTE_HANDLER) {
            rc = SCESTATUS_INVALID_PARAMETER;
        }

    }
    return(rc);
}


HLOCAL
ScepAlloc(
    IN UINT uFlags,
    IN UINT uBytes
    )
/*
memory allocation routine, which calls LocalAlloc.
*/
{
    HLOCAL       pTemp=NULL;

    pTemp = LocalAlloc(uFlags, uBytes);

#ifdef SCE_DBG
    if ( pTemp != NULL ) {
        TotalBytes += uBytes;
        printf("Allocate %d bytes at 0x%x. Total bytes = %d\n", uBytes, pTemp, TotalBytes);
    }
#endif
    return(pTemp);
}


VOID
ScepFree(
    HLOCAL pToFree
    )
/*
memory free routine, which calls LocalFree.
*/
{   HLOCAL pTemp;

    if (pToFree != NULL) {
        pTemp = LocalFree( pToFree );

#ifdef SCE_DBG
        if ( pTemp == NULL )
            printf("0x%x is freed\n", pToFree);
        else
            printf("Unable to free 0x%x. Error code=%d\n", pToFree, GetLastError());
#endif

    }

}


SCESTATUS
ScepFreeErrorLog(
    IN PSCE_ERROR_LOG_INFO Errlog
    )
/* ++
Routine Description:

   This routine frees memory associated with SCE_ERROR_LOG_INFO list

Arguments

   Errlog - Head of the error log

Return value:

   SCESTATUS

-- */
{
    PSCE_ERROR_LOG_INFO  pErr;
    PSCE_ERROR_LOG_INFO  pTemp;

    if ( Errlog != NULL ) {

        pErr = Errlog;
        while ( pErr != NULL ) {
            if ( pErr->buffer != NULL )
                ScepFree( pErr->buffer );

            pTemp = pErr;
            pErr = pErr->next;
            ScepFree( pTemp );
        }

    }
    return(SCESTATUS_SUCCESS);
}


SCESTATUS
ScepFreeRegistryValues(
    IN PSCE_REGISTRY_VALUE_INFO *ppRegValues,
    IN DWORD Count
    )
/*
free memory allocated for the array of SCE_REGISTRY_VALUE_INFO

*/
{
    if ( ppRegValues && *ppRegValues ) {

        for ( DWORD i=0; i<Count; i++ ) {
            //
            // free value name buffer within each element
            //
            if ( (*ppRegValues)[i].FullValueName ) {
                ScepFree((*ppRegValues)[i].FullValueName);
            }

            __try {
                if ( (*ppRegValues)[i].Value ) {
                    //
                    // this is a pointer of PWSTR
                    //
                    ScepFree((*ppRegValues)[i].Value);
                }
            } __except (EXCEPTION_EXECUTE_HANDLER) {
            }
        }
        //
        // free the array buffer
        //
        ScepFree(*ppRegValues);
        *ppRegValues = NULL;
    }

    return(SCESTATUS_SUCCESS);
}


SCESTATUS
WINAPI
SceFreeMemory(
   IN PVOID sceInfo,
   IN DWORD Category
   )
/* ++
Routine Description:

    This routine frees memory associated with  SceInfo in the specified area.
    The Type field in SceInfo indicates the type of the structure.

Arguments:

    SceInfo  - The memory buffer to free. It could be type
                    SCE_ENGINE_SCP
                    SCE_ENGINE_SAP
                    SCE_ENGINE_SMP
                    SCE_STRUCT_PROFILE
                    SCE_STRUCT_USER

    Area    - The security area to free. This argument is only used for
                SCE_ENGINE_SCP, SCE_ENGINE_SAP, and SCE_ENGINE_SMP types.


Return value:

   None

-- */
{
    SCETYPE                        sceType;
    AREA_INFORMATION              Area;
    PSCE_PROFILE_INFO              pProfileInfo=NULL;
    PSCE_USER_PROFILE              pProfile;
    PSCE_LOGON_HOUR                pTempLogon;
    PSCE_USER_SETTING              pPerUser;
    PSCE_OBJECT_SECURITY           pos;

    SCESTATUS                      rc=SCESTATUS_SUCCESS;

    if ( sceInfo == NULL )
        return(SCESTATUS_SUCCESS);

    if ( Category >= 300 ) {
        //
        // memory associated with list
        //
        __try {

            switch ( Category ) {
            case SCE_STRUCT_NAME_LIST:
                ScepFreeNameList((PSCE_NAME_LIST)sceInfo);
                break;

            case SCE_STRUCT_NAME_STATUS_LIST:
                ScepFreeNameStatusList( (PSCE_NAME_STATUS_LIST)sceInfo );
                break;

            case SCE_STRUCT_PRIVILEGE_VALUE_LIST:
                ScepFreePrivilegeValueList( (PSCE_PRIVILEGE_VALUE_LIST)sceInfo );
                break;

            case SCE_STRUCT_PRIVILEGE:
                ScepFreePrivilege( (PSCE_PRIVILEGE_ASSIGNMENT)sceInfo );
                break;

            case SCE_STRUCT_GROUP:
                ScepFreeGroupMembership( (PSCE_GROUP_MEMBERSHIP)sceInfo );
                break;

            case SCE_STRUCT_OBJECT_LIST:
                ScepFreeObjectList( (PSCE_OBJECT_LIST)sceInfo );
                break;

            case SCE_STRUCT_OBJECT_CHILDREN:
                ScepFreeObjectChildren( (PSCE_OBJECT_CHILDREN)sceInfo );
                break;

            case SCE_STRUCT_OBJECT_SECURITY:
                pos = (PSCE_OBJECT_SECURITY)sceInfo;
                if ( pos ) {
                    if ( pos->Name != NULL )
                        ScepFree( pos->Name );

                    if ( pos->pSecurityDescriptor != NULL )
                        ScepFree(pos->pSecurityDescriptor);

                    ScepFree( pos );
                }
                break;
            case SCE_STRUCT_OBJECT_ARRAY:
                ScepFreeObjectSecurity( (PSCE_OBJECT_ARRAY)sceInfo );
                break;

            case SCE_STRUCT_PROFILE:
            case SCE_STRUCT_USER:
                SceFreeMemory( sceInfo, 0 );  // type is embedded
                break;

            case SCE_STRUCT_ERROR_LOG_INFO:
                ScepFreeErrorLog( (PSCE_ERROR_LOG_INFO)sceInfo );
                break;

            case SCE_STRUCT_SERVICES:
                SceFreePSCE_SERVICES((PSCE_SERVICES)sceInfo);
                break;

            default:
                rc = SCESTATUS_INVALID_PARAMETER;
            }
        } __except (EXCEPTION_EXECUTE_HANDLER) {
            ASSERT(FALSE);
            rc = SCESTATUS_INVALID_PARAMETER;
        }

    } else {

        sceType = *((SCETYPE *)sceInfo);
        Area = (AREA_INFORMATION)Category;

        switch ( sceType ) {
        case SCE_ENGINE_SCP:
        case SCE_ENGINE_SAP:
        case SCE_ENGINE_SMP:
        case SCE_ENGINE_SCP_INTERNAL:
        case SCE_ENGINE_SMP_INTERNAL:
        case SCE_STRUCT_INF:
            pProfileInfo = (PSCE_PROFILE_INFO)sceInfo;
#if 0
            if ( Area & AREA_DS_OBJECTS ) {
                //
                // free ds list
                //
                if ( sceType == SCE_STRUCT_INF ) {
                    ScepFreeObjectSecurity(pProfileInfo->pDsObjects.pAllNodes);
                    pProfileInfo->pDsObjects.pAllNodes = NULL;

                } else {

                    ScepFreeObjectList(pProfileInfo->pDsObjects.pOneLevel);
                    pProfileInfo->pDsObjects.pOneLevel = NULL;

                }
            }
#endif
            if ( Area & AREA_FILE_SECURITY ) {
                //
                // free file list and auditing list
                //
                __try {
                    if ( sceType == SCE_STRUCT_INF ) {
                        ScepFreeObjectSecurity(pProfileInfo->pFiles.pAllNodes);
                        pProfileInfo->pFiles.pAllNodes = NULL;

                    } else {

                        ScepFreeObjectList(pProfileInfo->pFiles.pOneLevel);
                        pProfileInfo->pFiles.pOneLevel = NULL;

                    }

                } __except (EXCEPTION_EXECUTE_HANDLER) {
                    ASSERT(FALSE);
                    rc = SCESTATUS_INVALID_PARAMETER;
                }
            }


            if ( Area & AREA_REGISTRY_SECURITY ) {
                //
                // free registry keys list and auditing list
                //
                __try {
                    if ( sceType == SCE_STRUCT_INF ) {
                        ScepFreeObjectSecurity(pProfileInfo->pRegistryKeys.pAllNodes);
                        pProfileInfo->pRegistryKeys.pAllNodes = NULL;

                    } else {
                        ScepFreeObjectList(pProfileInfo->pRegistryKeys.pOneLevel);
                        pProfileInfo->pRegistryKeys.pOneLevel = NULL;

                    }

                } __except (EXCEPTION_EXECUTE_HANDLER) {
                    ASSERT(FALSE);
                    rc = SCESTATUS_INVALID_PARAMETER;
                }
            }

            if ( Area & AREA_GROUP_MEMBERSHIP ) {

                __try {
                    ScepFreeGroupMembership(pProfileInfo->pGroupMembership);
                    pProfileInfo->pGroupMembership = NULL;

                } __except (EXCEPTION_EXECUTE_HANDLER) {
                    ASSERT(FALSE);
                    rc = SCESTATUS_INVALID_PARAMETER;
                }
            }


            if ( Area & AREA_PRIVILEGES ) {

                __try {

                    switch ( sceType ) {
                    case SCE_ENGINE_SCP_INTERNAL:
                    case SCE_ENGINE_SMP_INTERNAL:
                        //
                        // SCP type Privilege Rights
                        //
                        ScepFreePrivilegeValueList(pProfileInfo->OtherInfo.scp.u.pPrivilegeAssignedTo);
                        pProfileInfo->OtherInfo.scp.u.pPrivilegeAssignedTo = NULL;
                        break;
                    case SCE_STRUCT_INF:
                        ScepFreePrivilege(pProfileInfo->OtherInfo.scp.u.pInfPrivilegeAssignedTo);
                        pProfileInfo->OtherInfo.scp.u.pInfPrivilegeAssignedTo = NULL;
                        break;
                    case SCE_ENGINE_SMP:
                    case SCE_ENGINE_SCP:
                        //
                        // SMP type Privilege Rights
                        //
                        ScepFreePrivilege(pProfileInfo->OtherInfo.smp.pPrivilegeAssignedTo);
                        pProfileInfo->OtherInfo.smp.pPrivilegeAssignedTo = NULL;
                        break;

                    default: // SAP
                        ScepFreePrivilege(pProfileInfo->OtherInfo.sap.pPrivilegeAssignedTo);
                        pProfileInfo->OtherInfo.sap.pPrivilegeAssignedTo=NULL;
                        break;
                    }

                } __except (EXCEPTION_EXECUTE_HANDLER) {
                    ASSERT(FALSE);
                    rc = SCESTATUS_INVALID_PARAMETER;
                }
            }

            if ( Area & AREA_USER_SETTINGS ) {

                __try {

                    switch ( sceType ) {
                    case SCE_ENGINE_SCP_INTERNAL:
                    case SCE_ENGINE_SMP_INTERNAL:
                    case SCE_STRUCT_INF:
                        //
                        // Account Profiles
                        //
                        ScepFreeNameList(pProfileInfo->OtherInfo.scp.pAccountProfiles);
                        pProfileInfo->OtherInfo.scp.pAccountProfiles = NULL;
                        break;

                    case SCE_ENGINE_SAP:
                        //
                        // SAP type
                        //
                        ScepFreeNameList(pProfileInfo->OtherInfo.sap.pUserList);
                        pProfileInfo->OtherInfo.sap.pUserList = NULL;
                        break;

                    default: // SMP or SCP
                        ScepFreeNameList(pProfileInfo->OtherInfo.smp.pUserList);
                        pProfileInfo->OtherInfo.smp.pUserList = NULL;
                        break;
                    }
                } __except (EXCEPTION_EXECUTE_HANDLER) {
                    ASSERT(FALSE);
                    rc = SCESTATUS_INVALID_PARAMETER;
                }
            }

            if ( Area & AREA_SECURITY_POLICY ) {

                __try {

                    if (pProfileInfo->NewAdministratorName != NULL ) {
                        ScepFree( pProfileInfo->NewAdministratorName );
                        pProfileInfo->NewAdministratorName = NULL;
                    }

                    if (pProfileInfo->NewGuestName != NULL ) {
                        ScepFree( pProfileInfo->NewGuestName );
                        pProfileInfo->NewGuestName = NULL;
                    }

                    if ( pProfileInfo->pKerberosInfo ) {
                        ScepFree(pProfileInfo->pKerberosInfo);
                        pProfileInfo->pKerberosInfo = NULL;
                    }
                    if ( pProfileInfo->RegValueCount && pProfileInfo->aRegValues ) {

                        ScepFreeRegistryValues(&pProfileInfo->aRegValues,
                                               pProfileInfo->RegValueCount);
                    }
                    pProfileInfo->RegValueCount = 0;
                    pProfileInfo->aRegValues = NULL;

                    ScepResetSecurityPolicyArea(pProfileInfo);

                } __except (EXCEPTION_EXECUTE_HANDLER) {
                    ASSERT(FALSE);
                    rc = SCESTATUS_INVALID_PARAMETER;
                }
            }
            break;

        case SCE_STRUCT_PROFILE:

            pProfile = (PSCE_USER_PROFILE)sceInfo;

            if ( pProfile != NULL ) {

                __try {

                    if (pProfile->UserProfile != NULL )
                        ScepFree(pProfile->UserProfile);
                    pProfile->UserProfile = NULL;

                    if (pProfile->LogonScript != NULL )
                        ScepFree(pProfile->LogonScript);
                    pProfile->LogonScript = NULL;

                    if (pProfile->HomeDir != NULL )
                        ScepFree(pProfile->HomeDir);
                    pProfile->HomeDir = NULL;

                    //
                    // Logon hours
                    //

                    while (pProfile->pLogonHours != NULL ) {
                        pTempLogon = pProfile->pLogonHours;
                        pProfile->pLogonHours = pProfile->pLogonHours->Next;

                        ScepFree(pTempLogon);
                    }
                    pProfile->pLogonHours = NULL;

                    //
                    // free Workstation name list
                    //

                    if ( pProfile->pWorkstations.Buffer != NULL )
                        ScepFree(pProfile->pWorkstations.Buffer);
                    pProfile->pWorkstations.Buffer = NULL;
                    pProfile->pWorkstations.MaximumLength = 0;
                    pProfile->pWorkstations.Length = 0;

                    //
                    // free Groups name list
                    //

                    ScepFreeNameList(pProfile->pGroupsBelongsTo);
                    pProfile->pGroupsBelongsTo = NULL;

                    //
                    // free AssignToUsers name list
                    //

                    ScepFreeNameList(pProfile->pAssignToUsers);
                    pProfile->pAssignToUsers = NULL;

                    //
                    // free SDs
                    //
                    if (pProfile->pHomeDirSecurity != NULL )
                        ScepFree(pProfile->pHomeDirSecurity);
                    pProfile->pHomeDirSecurity = NULL;

                    if (pProfile->pTempDirSecurity != NULL )
                        ScepFree(pProfile->pTempDirSecurity);
                    pProfile->pTempDirSecurity = NULL;

                    ScepFree(pProfile);

                } __except (EXCEPTION_EXECUTE_HANDLER) {
                    ASSERT(FALSE);
                    rc = SCESTATUS_INVALID_PARAMETER;
                }
            }
            break;

        case SCE_STRUCT_USER:

            pPerUser = (PSCE_USER_SETTING)sceInfo;

            if ( pPerUser != NULL ) {

                __try {

                    ScepFreeNameList( pPerUser->pGroupsBelongsTo);
                    pPerUser->pGroupsBelongsTo = NULL;

                    if (pPerUser->UserProfile != NULL)
                        ScepFree(pPerUser->UserProfile);
                    pPerUser->UserProfile = NULL;

                    if (pPerUser->pProfileSecurity != NULL)
                        ScepFree(pPerUser->pProfileSecurity);
                    pPerUser->pProfileSecurity = NULL;

                    if (pPerUser->LogonScript != NULL)
                        ScepFree(pPerUser->LogonScript);
                    pPerUser->LogonScript = NULL;

                    if (pPerUser->pLogonScriptSecurity != NULL)
                        ScepFree(pPerUser->pLogonScriptSecurity);
                    pPerUser->pLogonScriptSecurity = NULL;

                    if (pPerUser->HomeDir != NULL)
                        ScepFree(pPerUser->HomeDir);
                    pPerUser->HomeDir = NULL;

                    if (pPerUser->pHomeDirSecurity != NULL)
                        ScepFree(pPerUser->pHomeDirSecurity);
                    pPerUser->pHomeDirSecurity = NULL;

                    if (pPerUser->TempDir != NULL)
                        ScepFree(pPerUser->TempDir);
                    pPerUser->TempDir = NULL;

                    if (pPerUser->pTempDirSecurity != NULL)
                        ScepFree(pPerUser->pTempDirSecurity);
                    pPerUser->pTempDirSecurity = NULL;

                    while (pPerUser->pLogonHours != NULL ) {
                        pTempLogon = pPerUser->pLogonHours;
                        pPerUser->pLogonHours = pPerUser->pLogonHours->Next;

                        ScepFree(pTempLogon);
                    }
                    pPerUser->pLogonHours = NULL;

                    if ( pPerUser->pWorkstations.Buffer != NULL )
                        ScepFree( pPerUser->pWorkstations.Buffer );
                    pPerUser->pWorkstations.Buffer = NULL;
                    pPerUser->pWorkstations.MaximumLength = 0;
                    pPerUser->pWorkstations.Length = 0;

                    ScepFreeNameStatusList(pPerUser->pPrivilegesHeld);
                    pPerUser->pPrivilegesHeld = NULL;

                    ScepFree(pPerUser);

                } __except (EXCEPTION_EXECUTE_HANDLER) {
                    ASSERT(FALSE);
                    rc = SCESTATUS_INVALID_PARAMETER;
                }
            }
            break;

        default:
            return(SCESTATUS_INVALID_PARAMETER);
        }
    }

    return(rc);

}


SCESTATUS
ScepResetSecurityPolicyArea(
    IN PSCE_PROFILE_INFO pProfileInfo
    )
{
    INT i;

    if ( pProfileInfo != NULL ) {

        pProfileInfo->MinimumPasswordAge = SCE_NO_VALUE;
        pProfileInfo->MaximumPasswordAge = SCE_NO_VALUE;
        pProfileInfo->MinimumPasswordLength = SCE_NO_VALUE;
        pProfileInfo->PasswordComplexity = SCE_NO_VALUE;
        pProfileInfo->PasswordHistorySize = SCE_NO_VALUE;
        pProfileInfo->LockoutBadCount = SCE_NO_VALUE;
        pProfileInfo->ResetLockoutCount = SCE_NO_VALUE;
        pProfileInfo->LockoutDuration = SCE_NO_VALUE;
        pProfileInfo->RequireLogonToChangePassword = SCE_NO_VALUE;
        pProfileInfo->ForceLogoffWhenHourExpire = SCE_NO_VALUE;
        pProfileInfo->SecureSystemPartition = SCE_NO_VALUE;
        pProfileInfo->ClearTextPassword = SCE_NO_VALUE;
        pProfileInfo->LSAAnonymousNameLookup = SCE_NO_VALUE;

        for ( i=0; i<3; i++ ) {
            pProfileInfo->MaximumLogSize[i] = SCE_NO_VALUE;
            pProfileInfo->AuditLogRetentionPeriod[i] = SCE_NO_VALUE;
            pProfileInfo->RetentionDays[i] = SCE_NO_VALUE;
            pProfileInfo->RestrictGuestAccess[i] = SCE_NO_VALUE;
        }

        pProfileInfo->AuditSystemEvents = SCE_NO_VALUE;
        pProfileInfo->AuditLogonEvents = SCE_NO_VALUE;
        pProfileInfo->AuditObjectAccess = SCE_NO_VALUE;
        pProfileInfo->AuditPrivilegeUse = SCE_NO_VALUE;
        pProfileInfo->AuditPolicyChange = SCE_NO_VALUE;
        pProfileInfo->AuditAccountManage = SCE_NO_VALUE;
        pProfileInfo->AuditProcessTracking = SCE_NO_VALUE;
        pProfileInfo->AuditDSAccess = SCE_NO_VALUE;
        pProfileInfo->AuditAccountLogon = SCE_NO_VALUE;
        pProfileInfo->CrashOnAuditFull = SCE_NO_VALUE;

        if ( pProfileInfo->pKerberosInfo ) {
            pProfileInfo->pKerberosInfo->MaxTicketAge = SCE_NO_VALUE;
            pProfileInfo->pKerberosInfo->MaxRenewAge = SCE_NO_VALUE;
            pProfileInfo->pKerberosInfo->MaxServiceAge = SCE_NO_VALUE;
            pProfileInfo->pKerberosInfo->MaxClockSkew = SCE_NO_VALUE;
            pProfileInfo->pKerberosInfo->TicketValidateClient = SCE_NO_VALUE;
        }

        if ( pProfileInfo->RegValueCount && pProfileInfo->aRegValues ) {

            ScepFreeRegistryValues(&pProfileInfo->aRegValues,
                                   pProfileInfo->RegValueCount);
        }
        pProfileInfo->RegValueCount = 0;
        pProfileInfo->aRegValues = NULL;

        pProfileInfo->EnableAdminAccount = SCE_NO_VALUE;
        pProfileInfo->EnableGuestAccount = SCE_NO_VALUE;

        return(SCESTATUS_SUCCESS);

    } else {
        return(SCESTATUS_INVALID_PARAMETER);
    }

}



SCESTATUS
WINAPI
SceFreeProfileMemory(
    PSCE_PROFILE_INFO pProfile
    )
{
    if ( pProfile == NULL )
        return(SCESTATUS_SUCCESS);

    switch ( pProfile->Type ) {
    case SCE_ENGINE_SCP:
    case SCE_ENGINE_SAP:
    case SCE_ENGINE_SMP:
    case SCE_ENGINE_SCP_INTERNAL:
    case SCE_ENGINE_SMP_INTERNAL:
    case SCE_STRUCT_INF:

        SceFreeMemory((PVOID)pProfile, AREA_ALL);
        ScepFree(pProfile);

        break;
    default:
        return(SCESTATUS_INVALID_PARAMETER);
    }

    return(SCESTATUS_SUCCESS);
}



SCESTATUS
ScepFreePrivilege(
    IN PSCE_PRIVILEGE_ASSIGNMENT pRights
    )
{
    PSCE_PRIVILEGE_ASSIGNMENT  pTempRight;

    while ( pRights != NULL ) {

        if ( pRights->Name != NULL )
            ScepFree(pRights->Name);

        ScepFreeNameList(pRights->AssignedTo);

        pTempRight = pRights;
        pRights = pRights->Next;

        ScepFree( pTempRight );

    }
    return(SCESTATUS_SUCCESS);
}



SCESTATUS
ScepFreeObjectSecurity(
   IN PSCE_OBJECT_ARRAY pObject
   )
/* ++
Routine Description:

   This routine frees memory associated with ppObject.

Arguments:

   ppObject - buffer for object security

Return value:

   SCESTATUS_SUCCESS

-- */
{
    PSCE_OBJECT_SECURITY pCurObject;
    DWORD               i;

    if ( pObject == NULL )
        return(SCESTATUS_SUCCESS);

    for ( i=0; i<pObject->Count; i++ ) {
        pCurObject = pObject->pObjectArray[i];
        if ( pCurObject != NULL ) {

            if ( pCurObject->Name != NULL )
                ScepFree( pCurObject->Name );

            if ( pCurObject->pSecurityDescriptor != NULL )
                ScepFree(pCurObject->pSecurityDescriptor);

//            if ( pCurObject->SDspec != NULL )
//                ScepFree( pCurObject->SDspec );

            ScepFree( pCurObject );
        }
    }

    ScepFree(pObject);

    return(SCESTATUS_SUCCESS);
}

VOID
SceFreePSCE_SERVICES(
    IN PSCE_SERVICES pServiceList
    )
/*
Routine Description:

    Free memory allocated in PSCE_SERVICES structure

Arguments:

    pServiceList - the list of services node

Return Value:

    none
*/
{
    PSCE_SERVICES pTemp=pServiceList, pTemp2;

    while ( pTemp != NULL ) {
        //
        // ServiceName
        //
        if ( NULL != pTemp->ServiceName ) {
            LocalFree(pTemp->ServiceName);
        }
        //
        // display name
        //
        if ( NULL != pTemp->DisplayName ) {
            LocalFree(pTemp->DisplayName);
        }
        //
        // pSecurityDescriptor or ServiceEngineName
        // in same address
        //
        if ( NULL != pTemp->General.pSecurityDescriptor ) {
            LocalFree(pTemp->General.pSecurityDescriptor);
        }

        pTemp2 = pTemp;
        pTemp = pTemp->Next;

        // free the service node
        LocalFree(pTemp2);

    }

    return;
}



SCESTATUS
ScepFreePrivilegeValueList(
    IN PSCE_PRIVILEGE_VALUE_LIST pPrivValueList
    )
/* ++
Routine Description:

   This routine frees memory associated with PSCE_PRIVILEGE_VALUE_LIST list

Arguments:

   pPrivValueList - a PRIVILEGE_VALUE_LIST

Return value:

   SCESTATUS_SUCCESS

-- */
{
    PSCE_PRIVILEGE_VALUE_LIST pCurName;
    PSCE_PRIVILEGE_VALUE_LIST pTempName;
    SCESTATUS      rc=SCESTATUS_SUCCESS;

    if ( pPrivValueList == NULL )
        return(rc);

    pCurName = pPrivValueList;
    while ( pCurName != NULL ) {
        if ( pCurName->Name != NULL )
            __try {
                ScepFree( pCurName->Name );
            } __except (EXCEPTION_EXECUTE_HANDLER) {
                ASSERT(FALSE);
                rc = SCESTATUS_INVALID_PARAMETER;
            }

        pTempName = pCurName;
        pCurName = pCurName->Next;

        __try {
            ScepFree( pTempName );
        } __except (EXCEPTION_EXECUTE_HANDLER) {
            ASSERT(FALSE);
            rc = SCESTATUS_INVALID_PARAMETER;
        }

    }
    return(rc);
}


SCESTATUS
ScepFreeNameStatusList(
    IN PSCE_NAME_STATUS_LIST pNameList
    )
/* ++
Routine Description:

   This routine frees memory associated with PSCE_NAME_STATUS_LIST pNameList

Arguments:

   pNameList - a NAME_STATUS_LIST

Return value:

   SCESTATUS_SUCCESS

-- */
{
    PSCE_NAME_STATUS_LIST pCurName;
    PSCE_NAME_STATUS_LIST pTempName;
    SCESTATUS      rc=SCESTATUS_SUCCESS;

    if ( pNameList == NULL )
        return(rc);

    pCurName = pNameList;
    while ( pCurName != NULL ) {
        if ( pCurName->Name != NULL )
            __try {
                ScepFree( pCurName->Name );
            } __except (EXCEPTION_EXECUTE_HANDLER) {
                ASSERT(FALSE);
                rc = SCESTATUS_INVALID_PARAMETER;
            }

        pTempName = pCurName;
        pCurName = pCurName->Next;

        __try {
            ScepFree( pTempName );
        } __except (EXCEPTION_EXECUTE_HANDLER) {
            ASSERT(FALSE);
            rc = SCESTATUS_INVALID_PARAMETER;
        }

    }
    return(rc);
}


SCESTATUS
ScepFreeGroupMembership(
    IN PSCE_GROUP_MEMBERSHIP pGroup
    )
{
    PSCE_GROUP_MEMBERSHIP  pTempGroup;

    while ( pGroup != NULL ) {

        if (pGroup->GroupName != NULL)
            ScepFree(pGroup->GroupName);

        //
        // free group members name list
        //

        ScepFreeNameList(pGroup->pMembers);
        ScepFreeNameList(pGroup->pMemberOf);

        ScepFreeNameStatusList(pGroup->pPrivilegesHeld);

        pTempGroup = pGroup;
        pGroup = pGroup->Next;

        ScepFree( pTempGroup );
    }
    return(SCESTATUS_SUCCESS);

}



SCESTATUS
ScepFreeObjectList(
    IN PSCE_OBJECT_LIST pNameList
    )
/* ++
Routine Description:

   This routine frees memory associated with PSCE_OBJECT_LIST pNameList

Arguments:

   pNameList - a OBJEcT_LIST

Return value:

   SCESTATUS_SUCCESS

-- */
{
    PSCE_OBJECT_LIST pCurName;
    PSCE_OBJECT_LIST pTempName;
    SCESTATUS      rc=SCESTATUS_SUCCESS;

    if ( pNameList == NULL )
        return(rc);

    pCurName = pNameList;
    while ( pCurName != NULL ) {
        if ( pCurName->Name != NULL )
            __try {
                ScepFree( pCurName->Name );
            } __except (EXCEPTION_EXECUTE_HANDLER) {
                ASSERT(FALSE);
                rc = SCESTATUS_INVALID_PARAMETER;
            }

        pTempName = pCurName;
        pCurName = pCurName->Next;

        __try {
            ScepFree( pTempName );
        } __except (EXCEPTION_EXECUTE_HANDLER) {
            ASSERT(FALSE);
            rc = SCESTATUS_INVALID_PARAMETER;
        }

    }
    return(rc);
}


SCESTATUS
ScepFreeObjectChildren(
    IN PSCE_OBJECT_CHILDREN pNameArray
    )
/* ++
Routine Description:

   This routine frees memory associated with PSCE_OBJECT_LIST pNameList

Arguments:

   pNameList - a OBJEcT_LIST

Return value:

   SCESTATUS_SUCCESS

-- */
{

    SCESTATUS      rc=SCESTATUS_SUCCESS;

    if ( pNameArray == NULL )
        return(rc);

    rc = ScepFreeObjectChildrenNode(pNameArray->nCount,
                                    &(pNameArray->arrObject));

    ScepFree(pNameArray);

    return(rc);
}


SCESTATUS
ScepFreeObjectChildrenNode(
    IN DWORD Count,
    IN PSCE_OBJECT_CHILDREN_NODE *pArrObject
    )
{

    SCESTATUS      rc=SCESTATUS_SUCCESS;

    if ( NULL == pArrObject ) {
        return(rc);
    }

    DWORD          i;

    for ( i=0; i<Count;i++) {

        if ( pArrObject[i] ) {
            if ( pArrObject[i]->Name ) {

                ScepFree( pArrObject[i]->Name );
            }

            ScepFree(pArrObject[i]);
        }
    }

    return(rc);
}


SCESTATUS
SceSvcpFreeMemory(
    IN PVOID pvServiceInfo
    )
{
    //
    // since PSCESVC_CONFIGURATION_INFO and PSCESVC_ANALYSIS_INFO contains
    // the same bytes, we just cast ServiceInfo to one type and free it.
    //


    if ( pvServiceInfo != NULL ) {

        __try {

            for ( DWORD i=0; i<*((DWORD *)pvServiceInfo); i++ ) {

                if ( ((PSCESVC_ANALYSIS_INFO)pvServiceInfo)->Lines[i].Key ) {
                    ScepFree(((PSCESVC_ANALYSIS_INFO)pvServiceInfo)->Lines[i].Key);
                }
                if ( ((PSCESVC_ANALYSIS_INFO)pvServiceInfo)->Lines[i].Value ) {
                    ScepFree(((PSCESVC_ANALYSIS_INFO)pvServiceInfo)->Lines[i].Value);
                }

            }
            ScepFree(((PSCESVC_ANALYSIS_INFO)pvServiceInfo)->Lines);

            ScepFree(pvServiceInfo);

        } __except(EXCEPTION_EXECUTE_HANDLER) {

            ASSERT(FALSE);
            return(SCESTATUS_INVALID_PARAMETER);
        }

    }

    return(SCESTATUS_SUCCESS);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\scerpc\headers.h ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    headers.h

Abstract:

    This module includes global headers used by SCE

Author:

    Jin Huang (jinhuang) 23-Jan-1998

Revision History:

--*/

#ifndef _sceheaders_
#define _sceheaders_

//
// System header files
//
#pragma warning(push,3)

#ifdef __cplusplus
extern "C" {
#endif

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#ifdef __cplusplus
}
#endif

//
// Windows Headers
//

#include <windows.h>
#include <rpc.h>

//
// C Runtime Header
//

#include <malloc.h>
#include <memory.h>
#include <process.h>
#include <signal.h>
#include <string.h>
#include <stddef.h>
#include <stdio.h>
#include <stdlib.h>
#include <winsvc.h>

#include <setupapi.h>
#include <syssetup.h>
#include <accctrl.h>

#ifdef _WIN64
#include <wow64reg.h>
#endif

//
// CRT header files
//

#include <process.h>
#include <wchar.h>
#include <limits.h>

//
// debug stuff
//
#include <dsysdbg.h>

#if DBG == 1

    #ifdef ASSERT
        #undef ASSERT
    #endif

    #define ASSERT DsysAssert

    DECLARE_DEBUG2(Sce)

    #define SceDebugOut(args) SceDebugPrint args

    VOID
    DebugInitialize();

    VOID
    DebugUninit();

#else

    #define SceDebugOut(args)

    #define DebugInitialize()

    #define DebugUninit()

#endif // DBG


#pragma warning (pop)

// disable "symbols too long for debugger" warning: it happens a lot w/ STL

#pragma warning (disable: 4786)

// disable "exception specification ignored" warning: we use exception
// specifications

#pragma warning (disable: 4290)

// who cares about unreferenced inline removal?

#pragma warning (disable: 4514)

// we frequently use constant conditional expressions: do/while(0), etc.

#pragma warning (disable: 4127)

// some stl templates are lousy signed/unsigned mismatches

#pragma warning (disable: 4018 4146)

// we like this extension

#pragma warning (disable: 4239)

// data conversion

#pragma warning (disable: 4267)

/*
// unreferenced formal parameter

#pragma warning (disable: 4100)

// RPC stuff

#pragma warning (disable: 4211)

// cast truncation in RPC

#pragma warning (disable: 4310)

// RPC stuff

#pragma warning (disable: 4232)
*/
// often, we have local variables for the express purpose of ASSERTion.
// when compiling retail, those assertions disappear, leaving our locals
// as unreferenced.

#ifndef DBG

#pragma warning (disable: 4189 4100)

#endif // DBG

#include "secedit.h"

#include "common.h"
#include "scemm.h"

#include "uevents.h"

#define SCE_POLICY_EXTENSION_GUID   TEXT("{827D319E-6EAC-11D2-A4EA-00C04F79F83A}")
#define SCE_EFS_EXTENSION_GUID      TEXT("{B1BE8D72-6EAC-11D2-A4EA-00C04F79F83A}")

#define GPT_SCEDLL_NEW_PATH TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\GPExtensions\\") SCE_POLICY_EXTENSION_GUID
#define GPT_EFS_NEW_PATH TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\GPExtensions\\") SCE_EFS_EXTENSION_GUID

#define SDDLRoot    TEXT("D:AR(A;OICI;GA;;;BA)(A;OICI;GA;;;SY)(A;OICIIO;GA;;;CO)(A;CIOI;GRGX;;;BU)(A;CI;0x00000004;;;BU)(A;CIIO;0x00000002;;;BU)(A;;GRGX;;;WD)")

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\scerpc\scemm.h ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    scemm.h

Abstract:

    This module defines the data structures and function prototypes
    shared by both SCE client and SCE server

Author:

    Jin Huang (jinhuang) 23-Jan-1998

Revision History:

    jinhuang (splitted from scep.h)
--*/
#ifndef _scemm_
#define _scemm_

HLOCAL
ScepAlloc(
    IN UINT uFlags,
    IN UINT uBytes
    );

VOID
ScepFree(
    HLOCAL pToFree
    );

PVOID
MIDL_user_allocate (
    unsigned int   NumBytes
    );

VOID
MIDL_user_free (
    void    *MemPointer
    );

SCESTATUS
ScepFreeErrorLog(
    IN PSCE_ERROR_LOG_INFO Errlog
    );

SCESTATUS
ScepFreeNameList(
   IN PSCE_NAME_LIST pName
   );

SCESTATUS
ScepFreeRegistryValues(
    IN PSCE_REGISTRY_VALUE_INFO *ppRegValues,
    IN DWORD Count
    );

SCESTATUS
ScepResetSecurityPolicyArea(
    IN PSCE_PROFILE_INFO pProfileInfo
    );

SCESTATUS
ScepFreePrivilege(
    IN PSCE_PRIVILEGE_ASSIGNMENT pRights
    );

SCESTATUS
ScepFreeObjectSecurity(
   IN PSCE_OBJECT_ARRAY pObject
   );

VOID
SceFreePSCE_SERVICES(
    IN PSCE_SERVICES pServiceList
    );

SCESTATUS
ScepFreeNameStatusList(
    IN PSCE_NAME_STATUS_LIST pNameList
    );

SCESTATUS
ScepFreePrivilegeValueList(
    IN PSCE_PRIVILEGE_VALUE_LIST pPrivValueList
    );

SCESTATUS
ScepFreeGroupMembership(
    IN PSCE_GROUP_MEMBERSHIP pGroup
    );

SCESTATUS
ScepFreeObjectList(
    IN PSCE_OBJECT_LIST pNameList
    );

SCESTATUS
ScepFreeObjectChildren(
    IN PSCE_OBJECT_CHILDREN pNameArray
    );

SCESTATUS
ScepFreeObjectChildrenNode(
    IN DWORD Count,
    IN PSCE_OBJECT_CHILDREN_NODE *pArrObject
    );

SCESTATUS
SceSvcpFreeMemory(
    IN PVOID pvServiceInfo
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\scerpc\splay.cpp ===
/*
Copyright (c) 2000 Microsoft Corporation

Module Name:

    splay.cpp

Abstract:

    Splay trees are simpler, more space-efficient, more flexible, and faster than any other balanced tree
    scheme for storing an ordered set. This data structure satisfies all the invariants of a binary tree.

    Searching, insertion, deletion, and many other operations can all be done with amortized logarithmic
    performance. Since the trees adapt to the sequence of requests, their performance on real access
    patterns is typically even better.

Author:

    Vishnu Patankar (vishnup) 15-Aug-2000 created
    Jin Huang (jinhuang) 06-Apr-2001 modified for supporting string value and to handle multiple clients

--*/

#include "splay.h"
//#include "dumpnt.h"

#define SCEP_MIN(a, b) (a < b ? a : b)

static
PSCEP_SPLAY_NODE
ScepSplaySplay(
    IN  SCEP_NODE_VALUE_TYPE Value,
    IN  PSCEP_SPLAY_NODE pNodeToSplayAbout,
    IN  PSCEP_SPLAY_NODE pSentinel,
    IN  SCEP_NODE_VALUE_TYPE Type
    );

int
ScepValueCompare(
    PVOID    pValue1,
    PVOID    pValue2,
    SCEP_NODE_VALUE_TYPE Type
    );

static VOID
ScepSplayFreeNodes(
    IN PSCEP_SPLAY_NODE pNode,
    IN PSCEP_SPLAY_NODE pSentinel
    );

PSCEP_SPLAY_TREE
ScepSplayInitialize(
    SCEP_NODE_VALUE_TYPE Type
    )
/*
Routine Description:

    This function initializes the splay tree with a sentinel (equivalent to a NULL ptr).

Arguments:

    Type - the type for the splay value

Return Value:

    Pointer to the splay tree root.
*/
{
    if ( Type != SplayNodeSidType && Type != SplayNodeStringType ) {
        return NULL;
    }

    PSCEP_SPLAY_TREE pRoot = (PSCEP_SPLAY_TREE)LocalAlloc(LPTR, sizeof( SCEP_SPLAY_TREE ) );

    if ( pRoot ) {
        pRoot->Sentinel = (PSCEP_SPLAY_NODE) LocalAlloc(LPTR, sizeof( SCEP_SPLAY_NODE ) );

        if ( pRoot->Sentinel ) {
            pRoot->Sentinel->Left = pRoot->Sentinel->Right = pRoot->Sentinel;

            pRoot->Root = pRoot->Sentinel;
            pRoot->Type = Type;

            return pRoot;

        } else {
            LocalFree(pRoot);
        }
    }

    SetLastError(ERROR_NOT_ENOUGH_MEMORY);

    return NULL;
}

VOID
ScepSplayFreeTree(
    IN PSCEP_SPLAY_TREE *ppTreeRoot,
    IN BOOL bDestroyTree
    )
/*
Routine Description:

    This function frees the splay tree including the satellite data "Value".

Arguments:

    ppTreeRoot   -   address of the root of the tree

    bDestroyTree -   if the tree root should be destroyed (freed)

Return Value:

    VOID
*/
{
    if ( ppTreeRoot == NULL || *ppTreeRoot == NULL )
        return;

    ScepSplayFreeNodes( (*ppTreeRoot)->Root, (*ppTreeRoot)->Sentinel );

    if ( bDestroyTree ) {

        //
        // free Sentinel
        //
        LocalFree( (*ppTreeRoot)->Sentinel);

        LocalFree( *ppTreeRoot );
        *ppTreeRoot = NULL;
    } else {
        ( *ppTreeRoot)->Root = (*ppTreeRoot)->Sentinel;
    }

    return;
}

static VOID
ScepSplayFreeNodes(
    IN PSCEP_SPLAY_NODE pNode,
    IN PSCEP_SPLAY_NODE pSentinel
    )
{

    if ( pNode != pSentinel ) {

        ScepSplayFreeNodes( pNode->Left, pSentinel );
        ScepSplayFreeNodes( pNode->Right, pSentinel );
        if (pNode->Value)
            LocalFree( pNode->Value );
        LocalFree (pNode);
    }
}

static PSCEP_SPLAY_NODE
ScepSplaySingleRotateWithLeft(
    IN  PSCEP_SPLAY_NODE pNodeLeftRotate
    )
/*
Routine Description:

    This function can be called only if pNodeLeftRotate has a left child
    Perform a rotate between a node (pNodeLeftRotate) and its left child
    Update heights, then return new local root

Arguments:

    pNodeLeftRotate  -   the node to rotate left about  (local to this module)

Return Value:

    New local root after rotation
*/
{
    if ( pNodeLeftRotate == NULL ) return pNodeLeftRotate;

    PSCEP_SPLAY_NODE pNodeRightRotate;

    pNodeRightRotate = pNodeLeftRotate->Left;
    pNodeLeftRotate->Left = pNodeRightRotate->Right;
    pNodeRightRotate->Right = pNodeLeftRotate;

    return pNodeRightRotate;
}


static PSCEP_SPLAY_NODE
ScepSplaySingleRotateWithRight(
    IN  PSCEP_SPLAY_NODE pNodeRightRotate
    )
/*
Routine Description:

    This function can be called only if pNodeRightRotate has a right child
    Perform a rotate between a node (pNodeRightRotate) and its right child
    Update heights, then return new root

Arguments:

    pNodeRightRotate  -   the node to rotate right about (local to this module)

Return Value:

    New local root after rotation
*/
{
    if ( pNodeRightRotate == NULL ) return pNodeRightRotate;

    PSCEP_SPLAY_NODE pNodeLeftRotate;

    pNodeLeftRotate = pNodeRightRotate->Right;
    pNodeRightRotate->Right = pNodeLeftRotate->Left;
    pNodeLeftRotate->Left = pNodeRightRotate;

    return pNodeLeftRotate;
}


static
PSCEP_SPLAY_NODE
ScepSplaySplay(
    IN  PVOID Value,
    IN  PSCEP_SPLAY_NODE pNodeToSplayAbout,
    IN  PSCEP_SPLAY_NODE pSentinel,
    IN  SCEP_NODE_VALUE_TYPE Type
    )
/*
Routine Description:

    This is really the key routine doing all the balancing (splaying)
    Top-down splay procedure that does not requiring Value to be in tree.

Arguments:

    Value                   -   the value to splay the tree about
    pNodeToSplayAbout       -   the node to splay about (external routines such as ScepSplayInsert()
                                usually pass in the tree root). This routine is local to this module.
    pSentinel               -   the Sentinel  (terminating node)
    Type                    -   type of the splay values

Return Value:

    New local root after rotation
*/
{
    if ( pNodeToSplayAbout == NULL || pSentinel == NULL || Value == NULL) return pNodeToSplayAbout;

    SCEP_SPLAY_NODE Header;
    PSCEP_SPLAY_NODE LeftTreeMax, RightTreeMin;

    Header.Left = Header.Right = pSentinel;
    LeftTreeMax = RightTreeMin = &Header;
    pSentinel->Value = Value;

    int iRes=0;

    while ( 0 != (iRes=ScepValueCompare(Value, pNodeToSplayAbout->Value, Type)) ) {

        if ( 0 > iRes ) {
            if ( 0 > ScepValueCompare(Value, pNodeToSplayAbout->Left->Value, Type) )
                pNodeToSplayAbout = ScepSplaySingleRotateWithLeft( pNodeToSplayAbout );
            if ( pNodeToSplayAbout->Left == pSentinel )
                break;
            //
            // Link right
            //

            RightTreeMin->Left = pNodeToSplayAbout;
            RightTreeMin = pNodeToSplayAbout;
            pNodeToSplayAbout = pNodeToSplayAbout->Left;
        } else {
            if ( 0 < ScepValueCompare(Value, pNodeToSplayAbout->Right->Value, Type) )
                pNodeToSplayAbout = ScepSplaySingleRotateWithRight( pNodeToSplayAbout );
            if ( pNodeToSplayAbout->Right == pSentinel )
                break;
            //
            // Link left
            //

            LeftTreeMax->Right = pNodeToSplayAbout;
            LeftTreeMax = pNodeToSplayAbout;
            pNodeToSplayAbout = pNodeToSplayAbout->Right;
        }
    }

    //
    // reassemble
    //

    LeftTreeMax->Right = pNodeToSplayAbout->Left;
    RightTreeMin->Left = pNodeToSplayAbout->Right;
    pNodeToSplayAbout->Left = Header.Right;
    pNodeToSplayAbout->Right = Header.Left;

    //
    // reset Sentinel so that it does not point to some invalid buffer after
    // this function returns.
    //
    pSentinel->Value = NULL;

    return pNodeToSplayAbout;
}

DWORD
ScepSplayInsert(
    IN  PVOID Value,
    IN  OUT PSCEP_SPLAY_TREE pTreeRoot,
    OUT  BOOL   *pbExists
    )
/*
Routine Description:

    This function is called to insert a particular Value

Arguments:

    Value        -   the value to insert into the tree
    pTreeRoot    -   the node to splay about (usually pass in the tree root)
    pbExists     -   pointer to boolean that says if actual insertion was done or not


Return Value:

    error code
*/
{
    PSCEP_SPLAY_NODE pNewNode = NULL;
    NTSTATUS    Status;
    DWORD   dwValueLen;
    DWORD rc=ERROR_SUCCESS;

    if (pbExists)
        *pbExists = FALSE;

    if (Value == NULL || pTreeRoot == NULL ) {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // check parameter type
    //
    switch (pTreeRoot->Type) {
    case SplayNodeSidType:
        if ( !RtlValidSid((PSID)Value) ) {
            return ERROR_INVALID_PARAMETER;
        }
        dwValueLen = RtlLengthSid((PSID)Value);
        break;
    case SplayNodeStringType:
        if ( *((PWSTR)Value) == L'\0') {
            return ERROR_INVALID_PARAMETER;
        }
        dwValueLen = (wcslen((PWSTR)Value)+1)*sizeof(TCHAR);
        break;
    default:
        return ERROR_INVALID_PARAMETER;
    }

    pNewNode = (PSCEP_SPLAY_NODE) LocalAlloc(LMEM_ZEROINIT, sizeof( SCEP_SPLAY_NODE ) );
    if ( pNewNode == NULL ) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    pNewNode->dwByteLength = dwValueLen;
    pNewNode->Value = (PSID) LocalAlloc(LMEM_ZEROINIT, pNewNode->dwByteLength);

    if (pNewNode->Value == NULL) {
        LocalFree(pNewNode);
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    switch (pTreeRoot->Type) {
    case SplayNodeSidType:
        Status = RtlCopySid(pNewNode->dwByteLength, (PSID)(pNewNode->Value),  (PSID)Value);
        if (!NT_SUCCESS(Status)) {
            LocalFree(pNewNode->Value);
            LocalFree(pNewNode);
            return RtlNtStatusToDosError(Status);
        }
        break;
    case SplayNodeStringType:
        memcpy( pNewNode->Value, Value, dwValueLen );
        break;
    }


    if ( pTreeRoot->Root == pTreeRoot->Sentinel ) {
        pNewNode->Left = pNewNode->Right = pTreeRoot->Sentinel;
        pTreeRoot->Root = pNewNode;
    } else {

        pTreeRoot->Root = ScepSplaySplay( Value, pTreeRoot->Root, pTreeRoot->Sentinel, pTreeRoot->Type );

        int iRes;
        if ( 0 > (iRes=ScepValueCompare(Value, pTreeRoot->Root->Value, pTreeRoot->Type)) ) {
            pNewNode->Left = pTreeRoot->Root->Left;
            pNewNode->Right = pTreeRoot->Root;
            pTreeRoot->Root->Left = pTreeRoot->Sentinel;
            pTreeRoot->Root = pNewNode;
        } else if ( 0 < iRes ) {
            pNewNode->Right = pTreeRoot->Root->Right;
            pNewNode->Left = pTreeRoot->Root;
            pTreeRoot->Root->Right = pTreeRoot->Sentinel;
            pTreeRoot->Root = pNewNode;
        } else {
            //
            // Already in the tree
            //

            if (pbExists)
                *pbExists = TRUE;

            LocalFree(pNewNode->Value);
            LocalFree(pNewNode);

            return rc;
        }
    }

    return rc;
}



DWORD
ScepSplayDelete(
    IN  PVOID Value,
    IN  PSCEP_SPLAY_TREE pTreeRoot
    )
/*
Routine Description:

    This function is called to delete a particular Value

Arguments:

    Value        -   the value to insert into the tree
    pTreeRoot    -   the node to splay about (usually pass in the tree root)


Return Value:

    New root after deletion and splaying
*/
{
    if ( pTreeRoot == NULL ) return ERROR_INVALID_PARAMETER;

    PSCEP_SPLAY_NODE NewTree;

    if ( pTreeRoot->Root != pTreeRoot->Sentinel ) {
        //
        // strong type check
        //
        if  ( ( pTreeRoot->Type != SplayNodeSidType &&
                pTreeRoot->Type != SplayNodeStringType ) ||
              ( pTreeRoot->Type == SplayNodeSidType &&
                !RtlValidSid((PSID)Value) ) ||
              ( pTreeRoot->Type == SplayNodeStringType &&
                *((PWSTR)Value) == L'\0' ) ) {
            //
            // invalid value/type
            //
            return ERROR_INVALID_PARAMETER;
        }

        pTreeRoot->Root = ScepSplaySplay( Value, pTreeRoot->Root, pTreeRoot->Sentinel, pTreeRoot->Type );

        if ( 0 == ScepValueCompare(Value, pTreeRoot->Root->Value, pTreeRoot->Type) ) {

            //
            // found it
            //

            if ( pTreeRoot->Root->Left == pTreeRoot->Sentinel )
                NewTree = pTreeRoot->Root->Right;
            else {
                NewTree = pTreeRoot->Root->Left;
                NewTree = ScepSplaySplay( Value, NewTree, pTreeRoot->Sentinel, pTreeRoot->Type );
                NewTree->Right = pTreeRoot->Root->Right;
            }
            if (pTreeRoot->Root->Value)
                LocalFree( pTreeRoot->Root->Value);
            LocalFree( pTreeRoot->Root );

            pTreeRoot->Root = NewTree;
        }
    }

    return ERROR_SUCCESS;
}

BOOL
ScepSplayValueExist(
    IN  PVOID Value,
    IN  OUT PSCEP_SPLAY_TREE pTreeRoot
    )
{
    PSCEP_SPLAY_NODE    pMatchedNode = NULL;

    if ( pTreeRoot == NULL || Value == NULL) {
        return FALSE;
    }

    //
    // strong type check
    //
    if  ( ( pTreeRoot->Type != SplayNodeSidType &&
            pTreeRoot->Type != SplayNodeStringType ) ||
          ( pTreeRoot->Type == SplayNodeSidType &&
            !RtlValidSid((PSID)Value) ) ||
          ( pTreeRoot->Type == SplayNodeStringType &&
            *((PWSTR)Value) == L'\0' ) ) {
        //
        // invalid value/type
        //
        return FALSE;
    }

    pTreeRoot->Root = ScepSplaySplay( Value, pTreeRoot->Root, pTreeRoot->Sentinel, pTreeRoot->Type );
    pMatchedNode = pTreeRoot->Root;

    if (pMatchedNode && pMatchedNode->Value) {
        if (ScepValueCompare(pMatchedNode->Value, Value, pTreeRoot->Type) == 0) {
            return TRUE;
        }
    }

    return FALSE;
}


int
ScepValueCompare(
    PVOID    pValue1,
    PVOID    pValue2,
    SCEP_NODE_VALUE_TYPE Type
    )
/*
Routine Description:

    Lexical sid byte compare

Arguments:

    pValue1   -   ptr to first value
    pValue2   -   ptr to second value
    Type      -   the type of the value


Return Value:

    0 if Value1 == Value2
    +ve if Value1 > Value2
    -ve if Value1 < Value2
*/
{
    DWORD   dwValue1 = 0;
    DWORD   dwValue2 = 0;
    int     iByteCmpResult = 0;

    switch ( Type ) {
    case SplayNodeSidType:

        dwValue1 = RtlLengthSid((PSID)pValue1);
        dwValue2 = RtlLengthSid((PSID)pValue2);

        iByteCmpResult = memcmp(pValue1, pValue2, SCEP_MIN(dwValue1, dwValue2));

        if (dwValue1 == dwValue2)
            return iByteCmpResult;
        else if (iByteCmpResult == 0)
            return dwValue1-dwValue2;
        return iByteCmpResult;

    case SplayNodeStringType:

        iByteCmpResult = _wcsicmp((PWSTR)pValue1, (PWSTR)pValue2);
        return iByteCmpResult;
    }

    return 0;
}

BOOL
ScepSplayTreeEmpty(
    IN PSCEP_SPLAY_TREE pTreeRoot
    )
{

    if ( pTreeRoot == NULL ||
         pTreeRoot->Root == NULL ||
         pTreeRoot->Root == pTreeRoot->Sentinel ) {
        return TRUE;
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\scerpc\sceutil.cpp ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    sceutil.cpp

Abstract:

    Shared APIs

Author:

    Jin Huang

Revision History:

    jinhuang        23-Jan-1998   merged from multiple modules

--*/

#include "headers.h"
#include "sceutil.h"
#include "infp.h"
#include <sddl.h>
#include "commonrc.h"
#include "client\CGenericLogger.h"

extern HINSTANCE MyModuleHandle;

BOOL
ScepInitNameTable()
{
    LoadString(MyModuleHandle, IDS_EVERYONE, NameTable[0].Name, 36);
    LoadString(MyModuleHandle, IDS_CREATOR_OWNER, NameTable[1].Name, 36);
    LoadString(MyModuleHandle, IDS_CREATOR_GROUP, NameTable[2].Name, 36);
    LoadString(MyModuleHandle, IDS_CREATOR_OWNER_SERVER, NameTable[3].Name, 36);
    LoadString(MyModuleHandle, IDS_CREATOR_GROUP_SERVER, NameTable[4].Name, 36);
    LoadString(MyModuleHandle, IDS_DIALUP, NameTable[5].Name, 36);
    LoadString(MyModuleHandle, IDS_NETWORK, NameTable[6].Name, 36);
    LoadString(MyModuleHandle, IDS_BATCH, NameTable[7].Name, 36);
    LoadString(MyModuleHandle, IDS_INTERACTIVE, NameTable[8].Name, 36);
    LoadString(MyModuleHandle, IDS_SERVICE, NameTable[9].Name, 36);
    LoadString(MyModuleHandle, IDS_ANONYMOUS_LOGON, NameTable[10].Name, 36);
    LoadString(MyModuleHandle, IDS_PROXY, NameTable[11].Name, 36);
    LoadString(MyModuleHandle, IDS_ENTERPRISE_DOMAIN, NameTable[12].Name, 36);
    LoadString(MyModuleHandle, IDS_NAME_SELF, NameTable[13].Name, 36);
    LoadString(MyModuleHandle, IDS_AUTHENTICATED_USERS, NameTable[14].Name, 36);
    LoadString(MyModuleHandle, IDS_RESTRICTED, NameTable[15].Name, 36);
    LoadString(MyModuleHandle, IDS_TERMINAL_SERVER_USER, NameTable[16].Name, 36);
    LoadString(MyModuleHandle, IDS_LOCAL_SYSTEM, NameTable[17].Name, 36);
    LoadString(MyModuleHandle, IDS_LOCALSERVICE, NameTable[18].Name, 36);
    LoadString(MyModuleHandle, IDS_NETWORKSERVICE, NameTable[19].Name, 36);
    LoadString(MyModuleHandle, IDS_ADMINISTRATORS, NameTable[20].Name, 36);
    LoadString(MyModuleHandle, IDS_NAME_USERS, NameTable[21].Name, 36);
    LoadString(MyModuleHandle, IDS_NAME_GUESTS, NameTable[22].Name, 36);
    LoadString(MyModuleHandle, IDS_POWER_USERS, NameTable[23].Name, 36);
    LoadString(MyModuleHandle, IDS_ACCOUNT_OPERATORS, NameTable[24].Name, 36);
    LoadString(MyModuleHandle, IDS_SERVER_OPERATORS, NameTable[25].Name, 36);
    LoadString(MyModuleHandle, IDS_PRINT_OPERATORS, NameTable[26].Name, 36);
    LoadString(MyModuleHandle, IDS_BACKUP_OPERATORS, NameTable[27].Name, 36);
    LoadString(MyModuleHandle, IDS_REPLICATOR, NameTable[28].Name, 36);
    LoadString(MyModuleHandle, IDS_RAS_SERVERS, NameTable[29].Name, 36);
    LoadString(MyModuleHandle, IDS_PREW2KCOMPACCESS, NameTable[30 ].Name, 36);
    LoadString(MyModuleHandle, IDS_REMOTE_DESKTOP_USERS, NameTable[31].Name, 36);
    LoadString(MyModuleHandle, IDS_NETWORK_CONFIGURATION_OPERATORS, NameTable[32].Name, 36);

    return TRUE;
}

BOOL
ScepLookupNameTable(
    IN PWSTR Name,
    OUT PWSTR *StrSid
    )
{
    if ( Name == NULL || Name[0] == L'\0' ) {
        return FALSE;
    }

    for (int i = 0; i < TABLE_SIZE; i++) {
        if ( _wcsicmp(NameTable[i].Name, Name) == 0 ) {
            //found match
            *StrSid = (PWSTR)ScepAlloc((UINT)0, (2+wcslen(NameTable[i].StrSid))*sizeof(WCHAR));
            if ( *StrSid == NULL ) {
                return FALSE;
            } else {
                (*StrSid)[0] = L'*';
                wcscpy((*StrSid)+1, NameTable[i].StrSid);
                return TRUE;
            }
        }
    }

    return FALSE;
}


INT
ScepLookupPrivByName(
    IN PCWSTR Right
    )
/* ++
Routine Description:

    This routine looksup a user right in SCE_Rights table and returns the
    index component in SCE_Rights. The index component indicates the bit
    number for the user right.

Arguments:

    Right - The user right to look up

Return value:

    The index component in SCE_Rights table if a match is found,
    -1 for no match
-- */
{
    DWORD i;

    for (i=0; i<cPrivCnt; i++) {
        if ( _wcsicmp(Right, SCE_Privileges[i].Name) == 0 )
            return (i);
    }
    return(-1);
}



SCESTATUS
WINAPI
SceLookupPrivRightName(
    IN INT Priv,
    OUT PWSTR Name,
    OUT PINT NameLen
    )
{
    INT Len;

    if ( Name != NULL && NameLen == NULL )
        return(SCESTATUS_INVALID_PARAMETER);

    if ( Priv >= 0 && Priv < cPrivCnt ) {
        Len = wcslen(SCE_Privileges[Priv].Name);

        if ( Name != NULL ) {
            if ( *NameLen >= Len )
                wcscpy(Name, SCE_Privileges[Priv].Name);
            else {
                *NameLen = Len;
                return(SCESTATUS_BUFFER_TOO_SMALL);
            }
        }
        if ( NameLen != NULL)
            *NameLen = Len;

        return(SCESTATUS_SUCCESS);

    } else
        return SCESTATUS_RECORD_NOT_FOUND;

}


SCESTATUS
SceInfpOpenProfile(
    IN PCWSTR ProfileName,
    IN HINF *hInf
    )
/*
Routine Description:

    This routine opens a profile and returns a handle. This handle may be used
    when read information out of the profile using Setup APIs. The handle must
    be closed by calling SCECloseInfProfile.

Arguments:

    ProfileName - The profile to open

    hInf    - the address for inf handle

Return value:

    SCESTATUS
*/
{
    if ( ProfileName == NULL || hInf == NULL ) {

        return(SCESTATUS_INVALID_PARAMETER);
    }
    //
    // Check to see if the INF file is opened OK.
    // SetupOpenInfFile is defined in setupapi.h
    //

    *hInf = SetupOpenInfFile(ProfileName,
                            NULL,
                            INF_STYLE_WIN4,
                            NULL
                            );
    if (*hInf == INVALID_HANDLE_VALUE)
        return( ScepDosErrorToSceStatus( GetLastError() ) );
    else
        return( SCESTATUS_SUCCESS);
}

SCESTATUS
SceInfpCloseProfile(
    IN HINF hInf
    )
{

    if ( hInf != INVALID_HANDLE_VALUE )
        SetupCloseInfFile( hInf );

    return(SCESTATUS_SUCCESS);
}



SCESTATUS
ScepConvertMultiSzToDelim(
    IN PWSTR pValue,
    IN DWORD Len,
    IN WCHAR DelimFrom,
    IN WCHAR Delim
    )
/*
Convert the multi-sz delimiter \0 to space
*/
{
    DWORD i;

    for ( i=0; i<Len && pValue; i++) {
//        if ( *(pValue+i) == L'\0' && *(pValue+i+1) != L'\0') {
        if ( *(pValue+i) == DelimFrom && i+1 < Len &&
             *(pValue+i+1) != L'\0' ) {
            //
            // a NULL delimiter is encounted and it's not the end (double NULL)
            //
            *(pValue+i) = Delim;
        }
    }

    return(SCESTATUS_SUCCESS);
}

/*

SCESTATUS
SceInfpInfErrorToSceStatus(
    IN SCEINF_STATUS InfErr
    )
/* ++
Routine Description:

    This routine converts error codes from Inf routines into SCESTATUS code.

Arguments:

    InfErr  - The error code from Inf routines

Return Value:

    SCESTATUS code

-- *//*
{

    SCESTATUS rc;

    switch ( InfErr ) {
    case SCEINF_SUCCESS:
        rc = SCESTATUS_SUCCESS;
        break;
    case SCEINF_PROFILE_NOT_FOUND:
        rc = SCESTATUS_PROFILE_NOT_FOUND;
        break;
    case SCEINF_NOT_ENOUGH_MEMORY:
        rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
        break;
    case SCEINF_INVALID_PARAMETER:
        rc = SCESTATUS_INVALID_PARAMETER;
        break;
    case SCEINF_CORRUPT_PROFILE:
        rc = SCESTATUS_BAD_FORMAT;
        break;
    case SCEINF_INVALID_DATA:
        rc = SCESTATUS_INVALID_DATA;
        break;
    case SCEINF_ACCESS_DENIED:
        rc = SCESTATUS_ACCESS_DENIED;
        break;
    default:
        rc = SCESTATUS_OTHER_ERROR;
        break;
    }

    return(rc);
}
*/
//
// below are exported APIs in secedit.h
//


SCESTATUS
WINAPI
SceCreateDirectory(
    IN PCWSTR ProfileLocation,
    IN BOOL FileOrDir,
    PSECURITY_DESCRIPTOR pSecurityDescriptor
    )
{
    return ( ScepCreateDirectory(ProfileLocation,
                                FileOrDir,
                                pSecurityDescriptor
                                ));
}


SCESTATUS
WINAPI
SceCompareSecurityDescriptors(
    IN AREA_INFORMATION Area,
    IN PSECURITY_DESCRIPTOR pSD1,
    IN PSECURITY_DESCRIPTOR pSD2,
    IN SECURITY_INFORMATION SeInfo,
    OUT PBOOL IsDifferent
    )
{
    SE_OBJECT_TYPE ObjectType;
    BYTE resultSD=0;
    SCESTATUS rc;

    BOOL bContainer = FALSE;

    switch ( Area) {
    case AREA_REGISTRY_SECURITY:
        ObjectType = SE_REGISTRY_KEY;
        bContainer = TRUE;
        break;
    case AREA_FILE_SECURITY:
        ObjectType = SE_FILE_OBJECT;
        break;
    case AREA_DS_OBJECTS:
        ObjectType = SE_DS_OBJECT;
        bContainer = TRUE;
        break;
    case AREA_SYSTEM_SERVICE:
        ObjectType = SE_SERVICE;
        break;
    default:
        ObjectType = SE_FILE_OBJECT;
        break;
    }

    rc = ScepCompareObjectSecurity(
                ObjectType,
                bContainer,
                pSD1,
                pSD2,
                SeInfo,
                &resultSD);

    if ( resultSD )
        *IsDifferent = TRUE;
    else
        *IsDifferent = FALSE;

    return(rc);

}

SCESTATUS
WINAPI
SceAddToNameStatusList(
    IN OUT PSCE_NAME_STATUS_LIST *pNameStatusList,
    IN PWSTR Name,
    IN ULONG Len,
    IN DWORD Status
    )
{
    return(ScepAddToNameStatusList(
                    pNameStatusList,
                    Name,
                    Len,
                    Status) );
}

SCESTATUS
WINAPI
SceAddToNameList(
    IN OUT PSCE_NAME_LIST *pNameList,
    IN PWSTR Name,
    IN ULONG Len
    )
{
    return( ScepDosErrorToSceStatus(
               ScepAddToNameList(
                            pNameList,
                            Name,
                            Len
                            ) ) );
}

SCESTATUS
WINAPI
SceAddToObjectList(
    IN OUT PSCE_OBJECT_LIST  *pObjectList,
    IN PWSTR  Name,
    IN ULONG  Len,
    IN BOOL  IsContainer,   // TRUE if the object is a container type
    IN BYTE  Status,        // SCE_STATUS_IGNORE, SCE_STATUS_CHECK, SCE_STATUS_OVERWRITE
    IN BYTE  byFlags      // SCE_CHECK_DUP if duplicate Name entry should not be added, SCE_INCREASE_COUNT
    )
{
    return(ScepDosErrorToSceStatus(
                ScepAddToObjectList(
                    pObjectList,
                    Name,
                    Len,
                    IsContainer,
                    Status,
                    0,
                    byFlags
                    ) ) );
}



BOOL
SceCompareNameList(
    IN PSCE_NAME_LIST pList1,
    IN PSCE_NAME_LIST pList2
    )
/*
Routine Description:

    This routine compares two name lists for exact match. Sequence is not
    important in comparsion.

*/
{
    PSCE_NAME_LIST pName1, pName2;
    DWORD Count1=0, Count2=0;


    if ( (pList2 == NULL && pList1 != NULL) ||
         (pList2 != NULL && pList1 == NULL) ) {
//        return(TRUE);
// should be not equal
        return(FALSE);
    }

    for ( pName2=pList2; pName2 != NULL; pName2 = pName2->Next ) {

        if ( pName2->Name == NULL ) {
            continue;
        }
        Count2++;
    }

    for ( pName1=pList1; pName1 != NULL; pName1 = pName1->Next ) {

        if ( pName1->Name == NULL ) {
            continue;
        }
        Count1++;

        for ( pName2=pList2; pName2 != NULL; pName2 = pName2->Next ) {

            if ( pName2->Name == NULL ) {
                continue;
            }
            if ( _wcsicmp(pName1->Name, pName2->Name) == 0 ) {
                //
                // find a match
                //
                break;  // the second for loop
            }
        }

        if ( pName2 == NULL ) {
            //
            // does not find a match
            //
            return(FALSE);
        }
    }

    if ( Count1 != Count2 )
        return(FALSE);

    return(TRUE);
}



DWORD
WINAPI
SceEnumerateServices(
    OUT PSCE_SERVICES *pServiceList,
    IN BOOL bServiceNameOnly
    )
/*
Routine Description:

    Enumerate all services installed on the local system. The information
    returned include startup status and security descriptor on each service
    object.

Arguments:

    pServiceList - the list of services returned. Must be freed by LocalFree

return value:

    ERROR_SUCCESS
    Win32 error codes

*/
{
    SC_HANDLE   hScManager=NULL;
    LPENUM_SERVICE_STATUS   pEnumBuffer=NULL, pTempEnum;
    DWORD       ResumeHandle=0,
                BytesNeeded,
                ServicesCount=0;
    DWORD       BufSize=1024;

    //
    // check arguments
    //
    if ( NULL == pServiceList )
         return(ERROR_INVALID_PARAMETER);

    //
    // open service control manager
    //
    hScManager = OpenSCManager(
                    NULL,
                    NULL,
                    MAXIMUM_ALLOWED   //SC_MANAGER_ALL_ACCESS
//                    SC_MANAGER_CONNECT |
//                    SC_MANAGER_ENUMERATE_SERVICE |
//                    SC_MANAGER_QUERY_LOCK_STATUS
                    );

    if ( NULL == hScManager ) {

        return( GetLastError() );
    }

    DWORD       rc=NO_ERROR;
    DWORD i;
    DWORD status;

    if ( !bServiceNameOnly ) {
        //
        // Adjust privilege for setting SACL
        //
        status = SceAdjustPrivilege( SE_SECURITY_PRIVILEGE, TRUE, NULL );

        //
        // if can't adjust privilege, ignore (will error out later if SACL is requested)
        //
    }

    do {
        //
        // enumerate all services
        //
        pEnumBuffer = (LPENUM_SERVICE_STATUS)LocalAlloc(LMEM_FIXED,(UINT)BufSize);
        if ( NULL == pEnumBuffer ) {
            rc = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        if ( !EnumServicesStatus(
                    hScManager,
                    SERVICE_WIN32, // do not expose driver | SERVICE_DRIVER,
                    SERVICE_STATE_ALL,
                    pEnumBuffer,
                    BufSize,
                    &BytesNeeded,
                    &ServicesCount,
                    &ResumeHandle) ) {

            rc = GetLastError();

        } else
            rc = ERROR_SUCCESS;

        pTempEnum = pEnumBuffer;
        //
        // Process each service
        //
        if ( rc == ERROR_SUCCESS ||
             rc == ERROR_MORE_DATA ||
             rc == ERROR_INSUFFICIENT_BUFFER ) {

            rc = ERROR_SUCCESS;

            for ( i=0; pEnumBuffer && i<ServicesCount; i++ ) {
                //
                // add the service to our list
                //
                if ( bServiceNameOnly ) {
                    //
                    // only ask for service name, do not need to query
                    //
                    status = ScepAddOneServiceToList(
                                pEnumBuffer->lpServiceName,
                                pEnumBuffer->lpDisplayName,
                                0,
                                NULL,
                                0,
                                TRUE,
                                pServiceList
                                );
                } else {
                    //
                    // query startup and security descriptor
                    //
                    status = ScepQueryAndAddService(
                                hScManager,
                                pEnumBuffer->lpServiceName,
                                pEnumBuffer->lpDisplayName,
                                pServiceList
                                );
                }

                if ( status != ERROR_SUCCESS ) {
                    rc = status;
                    break;
                }
                pEnumBuffer++;
            }
        }
        //
        // Free buffer for next enumeration
        //
        if ( pTempEnum ) {
            LocalFree(pTempEnum);
            pTempEnum = NULL;
        }
        pEnumBuffer = NULL;

        BufSize = BytesNeeded + 2;
        ServicesCount = 0;

    } while ( rc == ERROR_SUCCESS && BytesNeeded > 0 );

    //
    // clear memory and close handle
    //
    CloseServiceHandle (hScManager);

    if ( rc != ERROR_SUCCESS ) {
        //
        // free memory in pServiceList
        //
        SceFreePSCE_SERVICES(*pServiceList);
        *pServiceList = NULL;
    }

    if ( !bServiceNameOnly ) {
        //
        // Adjust privilege for SACL
        //
        SceAdjustPrivilege( SE_SECURITY_PRIVILEGE, FALSE, NULL );
    }

    return(rc);

}



DWORD
ScepQueryAndAddService(
    IN SC_HANDLE hScManager,
    IN LPWSTR   lpServiceName,
    IN LPWSTR   lpDisplayName,
    OUT PSCE_SERVICES *pServiceList
    )
/*
Routine Description:

    Queries the security descriptor of the service and add all information
    to PSCE_SERVICE list

Arguments:

    hScManager - service control manager handle

    lpServiceName - The service name

    ServiceStatus - The service status

    pServiceList - The service list to output

Return Value:

    ERROR_SUCCESS
    Win32 errors
*/
{
    SC_HANDLE   hService;
    DWORD       rc=ERROR_SUCCESS;

    if ( hScManager == NULL || lpServiceName == NULL || pServiceList == NULL ) {
        return(ERROR_INVALID_PARAMETER);
    }

    //
    // Open the service
    //    SERVICE_ALL_ACCESS |
    //    READ_CONTROL       |
    //    ACCESS_SYSTEM_SECURITY
    //
    hService = OpenService(
                    hScManager,
                    lpServiceName,
                    MAXIMUM_ALLOWED |
                    ACCESS_SYSTEM_SECURITY
                   );

    if ( hService != NULL ) {
        //
        // Query the startup type
        //
        DWORD BytesNeeded=0;
        DWORD BufSize;

        //
        // Query configuration (Startup type)
        // get size first
        //
        if ( !QueryServiceConfig(
                    hService,
                    NULL,
                    0,
                    &BytesNeeded
                    ) ) {

            rc = GetLastError();

            if ( rc == ERROR_INSUFFICIENT_BUFFER ) {
                //
                // should always gets here
                //
                LPQUERY_SERVICE_CONFIG pConfig=NULL;

                pConfig = (LPQUERY_SERVICE_CONFIG)LocalAlloc(0, BytesNeeded+1);

                if ( pConfig != NULL ) {

                    rc = ERROR_SUCCESS;
                    BufSize=BytesNeeded;
                    //
                    // the real query for Startup type (pConfig->dwStartType)
                    //
                    if ( QueryServiceConfig(
                                hService,
                                pConfig,
                                BufSize,
                                &BytesNeeded
                                ) ) {
                        //
                        // Query the security descriptor length
                        // the following function does not take NULL for the
                        // address of security descriptor so use a temp buffer first
                        // to get the real length
                        //
                        BYTE BufTmp[128];
                        SECURITY_INFORMATION SeInfo;

                        //
                        // only query DACL and SACL information
                        //
/*
                        SeInfo = DACL_SECURITY_INFORMATION |
                                 SACL_SECURITY_INFORMATION |
                                 GROUP_SECURITY_INFORMATION |
                                 OWNER_SECURITY_INFORMATION;
*/
                        SeInfo = DACL_SECURITY_INFORMATION |
                                 SACL_SECURITY_INFORMATION;

                        if ( !QueryServiceObjectSecurity(
                                    hService,
                                    SeInfo,
                                    (PSECURITY_DESCRIPTOR)BufTmp,
                                    128,
                                    &BytesNeeded
                                    ) ) {

                            rc = GetLastError();

                            if ( rc == ERROR_INSUFFICIENT_BUFFER ||
                                 rc == ERROR_MORE_DATA ) {
                                //
                                // if buffer is not enough, it is ok
                                // because BytesNeeded is the real length
                                //
                                rc = ERROR_SUCCESS;
                            }
                        } else
                            rc = ERROR_SUCCESS;

                        if ( rc == ERROR_SUCCESS ) {
                            //
                            // allocate buffer for security descriptor
                            //
                            PSECURITY_DESCRIPTOR pSecurityDescriptor=NULL;

                            pSecurityDescriptor = (PSECURITY_DESCRIPTOR)LocalAlloc(LMEM_FIXED, BytesNeeded+2);

                            if ( NULL != pSecurityDescriptor ) {

                                //
                                // query the security descriptor
                                //
                                BufSize = BytesNeeded;

                                if ( QueryServiceObjectSecurity(
                                            hService,
                                            SeInfo,
                                            pSecurityDescriptor,
                                            BufSize,
                                            &BytesNeeded
                                            ) ) {
                                    //
                                    // create a service node and add it to the list
                                    //
                                    rc = ScepAddOneServiceToList(
                                              lpServiceName,
                                              lpDisplayName,
                                              pConfig->dwStartType,
                                              pSecurityDescriptor,
                                              SeInfo,
                                              TRUE,
                                              pServiceList
                                              );
                                } else {
                                    //
                                    // error query the security descriptor
                                    //
                                    rc = GetLastError();
                                }

                                if ( rc != ERROR_SUCCESS ) {
                                    LocalFree(pSecurityDescriptor);
                                }

                            } else {
                                //
                                // cannot allocate memory for security descriptor
                                //
                                rc = ERROR_NOT_ENOUGH_MEMORY;
                            }
                        }
                    } else {
                        //
                        // cannot query config
                        //
                        rc = GetLastError();
                    }

                    LocalFree(pConfig);

                } else
                    rc = ERROR_NOT_ENOUGH_MEMORY;
            }

        } else {
            //
            // should not fall in here, if it does, just return success
            //
        }

        CloseServiceHandle(hService);

    } else {
        //
        // cannot open service
        //
        rc = GetLastError();
    }

    return(rc);

}



INT
ScepLookupPrivByValue(
    IN DWORD Priv
    )
/* ++
Routine Description:

    This routine looksup a privilege in SCE_Privileges table and returns the
    index for the priv.

Arguments:

    Priv - The privilege to look up

Return value:

    The index in SCE_Privileges table if a match is found, or -1 for no match
-- */
{
    DWORD i;

    if ( Priv == 0 )
        return (-1);

    for ( i=0; i<cPrivCnt; i++) {
        if ( SCE_Privileges[i].Value == Priv )
            return i;
    }
    return (-1);
}


SCESTATUS
ScepGetProductType(
    OUT PSCE_SERVER_TYPE srvProduct
    )
{

    NT_PRODUCT_TYPE  theType;

    if ( RtlGetNtProductType(&theType) ) {

#if _WIN32_WINNT>=0x0500
        //
        // NT5+
        //
        switch (theType) {
        case NtProductLanManNt:
            *srvProduct = SCESVR_DC_WITH_DS;
            break;
        case NtProductServer:
            *srvProduct = SCESVR_NT5_SERVER;
            break;
        case NtProductWinNt:
            *srvProduct = SCESVR_NT5_WKS;
            break;
        default:
            *srvProduct = SCESVR_UNKNOWN;
        }
#else
        //
        // NT4
        //
        switch (theType) {
        case NtProductLanManNt:
            *srvProduct = SCESVR_DC;
            break;
        case NtProductServer:
            *srvProduct = SCESVR_NT4_SERVER;
            break;
        case NtProductWinNt:
            *srvProduct = SCESVR_NT4_WKS;
            break;
        default:
            *srvProduct = SCESVR_UNKNOWN;
        }
#endif
    } else {
        *srvProduct = SCESVR_UNKNOWN;
    }
    return(SCESTATUS_SUCCESS);
}



DWORD
ScepAddTwoNamesToNameList(
    OUT PSCE_NAME_LIST *pNameList,
    IN BOOL bAddSeparator,
    IN PWSTR Name1,
    IN ULONG Length1,
    IN PWSTR Name2,
    IN ULONG Length2
    )
/* ++
Routine Description:

    This routine adds two names (wchar) to the name list in the format of
    Name1\Name2, or Name1Name2, depends if bSeparator is TRUE. This routine
    is used for Domain\Account tracking list

Arguments:

    pNameList -  The name list to add to.

    Name1      -  The name 1 to add

    Length1    -  the length of name1 (number of wchars)

    Name2      - the name 2 to add

    Length2    - the length of name2 (number of wchars)

Return value:

    Win32 error code
-- */
{

    PSCE_NAME_LIST pList=NULL;
    ULONG  Length;

    if ( pNameList == NULL )
        return(ERROR_INVALID_PARAMETER);

    if ( Name1 == NULL && Name2 == NULL )
        return(NO_ERROR);

    Length = Length1 + Length2;

    if ( Length <= 0 )
        return(NO_ERROR);

    pList = (PSCE_NAME_LIST)ScepAlloc( (UINT)0, sizeof(SCE_NAME_LIST));

    if ( pList == NULL )
        return(ERROR_NOT_ENOUGH_MEMORY);

    if ( bAddSeparator ) {
        Length++;
    }

    pList->Name = (PWSTR)ScepAlloc( LMEM_ZEROINIT, (Length+1)*sizeof(TCHAR));
    if ( pList->Name == NULL ) {
        ScepFree(pList);
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    if ( Name1 != NULL && Length1 > 0 )
        wcsncpy(pList->Name, Name1, Length1);

    if ( bAddSeparator ) {
        wcsncat(pList->Name, L"\\", 1);
    }
    if ( Name2 != NULL && Length2 > 0 )
        wcsncat(pList->Name, Name2, Length2);

    pList->Next = *pNameList;
    *pNameList = pList;

    return(NO_ERROR);
}



NTSTATUS
ScepDomainIdToSid(
    IN PSID DomainId,
    IN ULONG RelativeId,
    OUT PSID *Sid
    )
/*++

Routine Description:

    Given a domain Id and a relative ID create a SID

Arguments:

    DomainId - The template SID to use.

    RelativeId - The relative Id to append to the DomainId.

    Sid - Returns a pointer to an allocated buffer containing the resultant
            Sid.  Free this buffer using NetpMemoryFree.

Return Value:

    NTSTATUS
--*/
{
    UCHAR DomainIdSubAuthorityCount; // Number of sub authorities in domain ID

    ULONG SidLength;    // Length of newly allocated SID

    //
    // Allocate a Sid which has one more sub-authority than the domain ID.
    //

    DomainIdSubAuthorityCount = *(RtlSubAuthorityCountSid( DomainId ));
    SidLength = RtlLengthRequiredSid(DomainIdSubAuthorityCount+1);

    if ((*Sid = (PSID) ScepAlloc( (UINT)0, SidLength )) == NULL ) {
        return STATUS_NO_MEMORY;
    }

    //
    // Initialize the new SID to have the same inital value as the
    // domain ID.
    //

    if ( !NT_SUCCESS( RtlCopySid( SidLength, *Sid, DomainId ) ) ) {
        ScepFree( *Sid );
        *Sid = NULL;
        return STATUS_INTERNAL_ERROR;
    }

    //
    // Adjust the sub-authority count and
    //  add the relative Id unique to the newly allocated SID
    //

    (*(RtlSubAuthorityCountSid( *Sid ))) ++;
    *RtlSubAuthoritySid( *Sid, DomainIdSubAuthorityCount ) = RelativeId;

    return ERROR_SUCCESS;
}


DWORD
ScepConvertSidToPrefixStringSid(
    IN PSID pSid,
    OUT PWSTR *StringSid
    )
/*
The pair routine to convert stringsid to a Sid is ConvertStringSidToSid
defined in sddl.h
*/
{
    if ( pSid == NULL || StringSid == NULL ) {
        return(ERROR_INVALID_PARAMETER);
    }

    UNICODE_STRING UnicodeStringSid;

    DWORD rc = RtlNtStatusToDosError(
             RtlConvertSidToUnicodeString(&UnicodeStringSid,
                                          pSid,
                                          TRUE ));

    if ( ERROR_SUCCESS == rc ) {

        *StringSid = (PWSTR)ScepAlloc(LPTR, UnicodeStringSid.Length+2*sizeof(WCHAR));

        if ( *StringSid ) {

            (*StringSid)[0] = L'*';
            wcsncpy( (*StringSid)+1, UnicodeStringSid.Buffer, UnicodeStringSid.Length/2);

        } else {
            rc = ERROR_NOT_ENOUGH_MEMORY;
        }

        RtlFreeUnicodeString( &UnicodeStringSid );

    }

    return(rc);
}


NTSTATUS
ScepConvertSidToName(
    IN LSA_HANDLE LsaPolicy,
    IN PSID AccountSid,
    IN BOOL bFromDomain,
    OUT PWSTR *AccountName,
    OUT DWORD *Length OPTIONAL
    )
{
    if ( LsaPolicy == NULL || AccountSid == NULL ||
        AccountName == NULL ) {
        return(STATUS_INVALID_PARAMETER);
    }

    PSID pTmpSid=AccountSid;
    PLSA_TRANSLATED_NAME Names=NULL;
    PLSA_REFERENCED_DOMAIN_LIST ReferencedDomains=NULL;

    NTSTATUS NtStatus = LsaLookupSids(
                            LsaPolicy,
                            1,
                            (PSID *)&pTmpSid,
                            &ReferencedDomains,
                            &Names
                            );

    DWORD Len=0;

    if ( NT_SUCCESS(NtStatus) ) {

        if ( ( Names[0].Use != SidTypeInvalid &&
               Names[0].Use != SidTypeUnknown ) ) {

            //
            // build the account name without domain name
            //
            if ( bFromDomain && Names[0].Use != SidTypeWellKnownGroup &&
                 ReferencedDomains->Entries > 0 &&
                 ReferencedDomains->Domains != NULL &&
                 Names[0].DomainIndex != -1 &&
                 (ULONG)(Names[0].DomainIndex) < ReferencedDomains->Entries &&
                 ReferencedDomains->Domains[Names[0].DomainIndex].Name.Length > 0 &&
                 ScepIsSidFromAccountDomain( ReferencedDomains->Domains[Names[0].DomainIndex].Sid ) ) {

                //
                // build domain name\account name
                //

                Len = Names[0].Name.Length + ReferencedDomains->Domains[Names[0].DomainIndex].Name.Length + 2;

                *AccountName = (PWSTR)LocalAlloc(LPTR, Len+sizeof(TCHAR));

                if ( *AccountName ) {
                    wcsncpy(*AccountName, ReferencedDomains->Domains[Names[0].DomainIndex].Name.Buffer,
                            ReferencedDomains->Domains[Names[0].DomainIndex].Name.Length/2);
                    (*AccountName)[ReferencedDomains->Domains[Names[0].DomainIndex].Name.Length/2] = L'\\';
                    wcsncpy((*AccountName)+ReferencedDomains->Domains[Names[0].DomainIndex].Name.Length/2+1,
                           Names[0].Name.Buffer, Names[0].Name.Length/2);
                } else {

                    NtStatus = STATUS_NO_MEMORY;
                }

                Len /= 2;

            } else {

                Len = Names[0].Name.Length/2;

                *AccountName = (PWSTR)LocalAlloc(LPTR, Names[0].Name.Length+2);

                if ( *AccountName ) {

                    wcsncpy(*AccountName, Names[0].Name.Buffer, Len);

                } else {

                    NtStatus = STATUS_NO_MEMORY;
                }
            }

        } else {
            NtStatus = STATUS_NONE_MAPPED;
        }

    }

    if ( ReferencedDomains ) {
        LsaFreeMemory(ReferencedDomains);
        ReferencedDomains = NULL;
    }

    if ( Names ) {
        LsaFreeMemory(Names);
        Names = NULL;
    }

    if ( NT_SUCCESS(NtStatus) && Length ) {
        *Length = Len;
    }

    return(NtStatus);
}

NTSTATUS
ScepConvertNameToSid(
    IN LSA_HANDLE LsaPolicy,
    IN PWSTR AccountName,
    OUT PSID *AccountSid
    )
{
    if ( LsaPolicy == NULL || AccountName == NULL ||
        AccountSid == NULL ) {
        return(STATUS_INVALID_PARAMETER);
    }

    PLSA_REFERENCED_DOMAIN_LIST RefDomains=NULL;
    PLSA_TRANSLATED_SID2        Sids=NULL;

    NTSTATUS NtStatus = ScepLsaLookupNames2(
                                           LsaPolicy,
                                           LSA_LOOKUP_ISOLATED_AS_LOCAL,
                                           AccountName,                            
                                           &RefDomains,                            
                                           &Sids
                                           );

    if ( NT_SUCCESS(NtStatus) && Sids ) {

        //
        // build the account sid
        //
        if ( Sids[0].Use != SidTypeInvalid &&
             Sids[0].Use != SidTypeUnknown &&
             Sids[0].Sid != NULL  ) {

            //
            // this name is mapped, the SID is in Sids[0].Sid
            //

            DWORD SidLength = RtlLengthSid(Sids[0].Sid);

            if ( (*AccountSid = (PSID) ScepAlloc( (UINT)0, SidLength)) == NULL ) {
                NtStatus = STATUS_NO_MEMORY;
            } else {

                //
                // copy the SID
                //

                NtStatus = RtlCopySid( SidLength, *AccountSid, Sids[0].Sid );
                if ( !NT_SUCCESS(NtStatus) ) {
                    ScepFree( *AccountSid );
                    *AccountSid = NULL;
                }
            }

        } else {

            NtStatus = STATUS_NONE_MAPPED;
        }
    }

    if ( Sids ) {

        LsaFreeMemory(Sids);
    }

    if ( RefDomains ) {

        LsaFreeMemory(RefDomains);
    }

    return(NtStatus);

}

NTSTATUS
ScepLsaLookupNames2(
    IN LSA_HANDLE PolicyHandle,
    IN ULONG Flags,
    IN PWSTR pszAccountName,
    OUT PLSA_REFERENCED_DOMAIN_LIST *ReferencedDomains,
    OUT PLSA_TRANSLATED_SID2 *Sids    
    )
/*++

Routine Description:

    Similar to LsaLookupNames2 except that on local lookup 
    failures, it resolves free text accounts to the domain 
    this machine is joined to

Arguments:

    PolicyHandle    -   handle to LSA
    
    Flags           -   usually LSA_LOOKUP_ISOLATED_AS_LOCAL
    
    pszAccountName  -   name of account to lookup
    
    ReferencedDomains   -   returns the reference domain id
                            (to be freed by caller)
    
    Sids    -   returns the SID looked up
                (to be freed by caller)
    
Return Value:

    NTSTATUS
--*/
{
    PWSTR           pszScopedName = NULL;
    UNICODE_STRING  UnicodeName;
    PPOLICY_ACCOUNT_DOMAIN_INFO pDomainInfo = NULL;
    
    RtlInitUnicodeString(&UnicodeName, pszAccountName);

    NTSTATUS NtStatus = LsaLookupNames2(
                            PolicyHandle,
                            Flags,
                            1,
                            &UnicodeName,
                            ReferencedDomains,
                            Sids
                            );

    if ((NtStatus == STATUS_SOME_NOT_MAPPED ||
        NtStatus == STATUS_NONE_MAPPED) &&
        NULL == wcschr(pszAccountName, L'\\') ) {

        NtStatus = LsaQueryInformationPolicy(PolicyHandle,
                                             PolicyDnsDomainInformation,
                                             ( PVOID * )&pDomainInfo );
        
        if (!NT_SUCCESS(NtStatus) || 
            pDomainInfo == NULL ||
            pDomainInfo->DomainName.Buffer == NULL || 
            pDomainInfo->DomainName.Length <= 0) {

            NtStatus = STATUS_SOME_NOT_MAPPED;
            goto ExitHandler;
        }

        pszScopedName = (PWSTR) LocalAlloc(LMEM_ZEROINIT, 
                                           (pDomainInfo->DomainName.Length/2 + wcslen(pszAccountName) + 2) * sizeof(WCHAR));

        if (pszScopedName == NULL) {
            NtStatus = STATUS_NO_MEMORY;
            goto ExitHandler;
        }
        
        wcsncpy(pszScopedName, pDomainInfo->DomainName.Buffer, pDomainInfo->DomainName.Length/2);
        wcscat(pszScopedName, L"\\");
        wcscat(pszScopedName, pszAccountName);

        RtlInitUnicodeString(&UnicodeName, pszScopedName);
        
        NtStatus = LsaLookupNames2(
                                  PolicyHandle,
                                  Flags,
                                  1,
                                  &UnicodeName,
                                  ReferencedDomains,
                                  Sids
                                  );

    }

ExitHandler:
    
    if (pszScopedName) {
        LocalFree(pszScopedName);
    }

    if (pDomainInfo) {
        LsaFreeMemory( pDomainInfo );
    }
    
    if ( STATUS_SUCCESS != NtStatus )
        return STATUS_NONE_MAPPED;
    else 
        return STATUS_SUCCESS;
}




SCESTATUS
ScepConvertNameToSidString(
    IN LSA_HANDLE LsaHandle,
    IN PWSTR Name,
    IN BOOL bAccountDomainOnly,
    OUT PWSTR *SidString,
    OUT DWORD *SidStrLen
    )
{
    if ( LsaHandle == NULL || Name == NULL ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    if ( Name[0] == L'\0' ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    if ( SidString == NULL || SidStrLen == NULL ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }
    //
    // convert the sid string to a real sid
    //
    PSID pSid=NULL;
    NTSTATUS NtStatus;
    DWORD rc;
    PLSA_REFERENCED_DOMAIN_LIST RefDomains=NULL;
    PLSA_TRANSLATED_SID2        Sids=NULL;

    NtStatus = ScepLsaLookupNames2(
                                  LsaHandle,
                                  LSA_LOOKUP_ISOLATED_AS_LOCAL,
                                  Name,                            
                                  &RefDomains,                            
                                  &Sids
                                  );

    rc = RtlNtStatusToDosError(NtStatus);

    if ( ERROR_SUCCESS == rc && Sids ) {

         //
         // name is found, make domain\account format
         //
        if ( Sids[0].Use != SidTypeInvalid &&
             Sids[0].Use != SidTypeUnknown &&
             Sids[0].Sid != NULL ) {

            //
            // this name is mapped
            //

            if ( !bAccountDomainOnly ||
                 ScepIsSidFromAccountDomain( Sids[0].Sid ) ) {

                //
                // convert to a sid string, note: a prefix "*" should be added
                //
                UNICODE_STRING UnicodeStringSid;

                rc = RtlNtStatusToDosError(
                         RtlConvertSidToUnicodeString(&UnicodeStringSid,
                                                      Sids[0].Sid,
                                                      TRUE ));

                if ( ERROR_SUCCESS == rc ) {

                    *SidStrLen = UnicodeStringSid.Length/2 + 1;
                    *SidString = (PWSTR)ScepAlloc(LPTR, UnicodeStringSid.Length + 2*sizeof(WCHAR));

                    if ( *SidString ) {

                        (*SidString)[0] = L'*';
                        wcsncpy((*SidString)+1, UnicodeStringSid.Buffer, (*SidStrLen)-1);

                    } else {
                        *SidStrLen = 0;
                        rc = ERROR_NOT_ENOUGH_MEMORY;
                    }

                    RtlFreeUnicodeString( &UnicodeStringSid );

                }

            } else {
                //
                // add only the account name
                //
                rc = ERROR_NONE_MAPPED;
            }

        } else {

            rc = ERROR_NONE_MAPPED;
        }

    }

    if ( Sids ) {

        LsaFreeMemory(Sids);
    }

    if ( RefDomains ) {

        LsaFreeMemory(RefDomains);
    }

    return(ScepDosErrorToSceStatus(rc));

}


SCESTATUS
ScepLookupSidStringAndAddToNameList(
    IN LSA_HANDLE LsaHandle,
    IN OUT PSCE_NAME_LIST *pNameList,
    IN PWSTR LookupString,
    IN ULONG Len
    )
{
    if ( LsaHandle == NULL || LookupString == NULL ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    if ( LookupString[0] == L'\0' ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    if ( Len <= 3 ||
         (LookupString[1] != L'S' && LookupString[1] != L's') ||
         LookupString[2] != L'-' ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    //
    // convert the sid string to a real sid
    //
    PSID pSid=NULL;
    NTSTATUS NtStatus;
    DWORD rc;
    PLSA_REFERENCED_DOMAIN_LIST RefDomains=NULL;
    PLSA_TRANSLATED_NAME        Names=NULL;

    if ( ConvertStringSidToSid(LookupString+1, &pSid) ) {

        NtStatus = LsaLookupSids(
                        LsaHandle,
                        1,
                        &pSid,
                        &RefDomains,
                        &Names
                        );

        rc = RtlNtStatusToDosError(NtStatus);

        LocalFree(pSid);
        pSid = NULL;

    } else {
        rc = GetLastError();
    }

    if ( ERROR_SUCCESS == rc && Names && RefDomains ) {

         //
         // name is found, make domain\account format
         //
        if ( ( Names[0].Use != SidTypeInvalid &&
               Names[0].Use != SidTypeUnknown ) ) {

            //
            // this name is mapped
            //

            if ( RefDomains->Entries > 0 && Names[0].Use != SidTypeWellKnownGroup &&
                 RefDomains->Domains != NULL &&
                 Names[0].DomainIndex != -1 &&
                 (ULONG)(Names[0].DomainIndex) < RefDomains->Entries &&
                 RefDomains->Domains[Names[0].DomainIndex].Name.Length > 0 &&
                 ScepIsSidFromAccountDomain( RefDomains->Domains[Names[0].DomainIndex].Sid ) ) {

                //
                // add both domain name and account name
                //
                rc = ScepAddTwoNamesToNameList(
                                  pNameList,
                                  TRUE,
                                  RefDomains->Domains[Names[0].DomainIndex].Name.Buffer,
                                  RefDomains->Domains[Names[0].DomainIndex].Name.Length/2,
                                  Names[0].Name.Buffer,
                                  Names[0].Name.Length/2);

            } else {
                //
                // add only the account name
                //
                rc = ScepAddToNameList(
                              pNameList,
                              Names[0].Name.Buffer,
                              Names[0].Name.Length/2);
            }

        } else {

            rc = ERROR_NONE_MAPPED;
        }

    } else {

        //
        // lookup in the constant table for builtin accounts
        // note. This will resolve the builtin SIDs to the language of the binary
        // which may not be the locale the process is running (UI)
        //

        for (int i = 0; i < TABLE_SIZE; i++) {
            if ( _wcsicmp(NameTable[i].StrSid, LookupString+1) == 0 ) {
                //
                //found match
                //
                rc = ScepAddToNameList(
                              pNameList,
                              NameTable[i].Name,
                              0);
                break;
            }
        }

    }

    if ( ERROR_SUCCESS != rc ) {

        //
        // either invalid sid string, or not found a name map, or
        // failed to add to the name list, just simply add the sid string to the name list
        //

        rc = ScepAddToNameList(
                      pNameList,
                      LookupString,
                      Len);
    }

    if ( Names ) {

        LsaFreeMemory(Names);
    }

    if ( RefDomains ) {

        LsaFreeMemory(RefDomains);
    }

    return(ScepDosErrorToSceStatus(rc));

}



SCESTATUS
ScepLookupNameAndAddToSidStringList(
    IN LSA_HANDLE LsaHandle,
    IN OUT PSCE_NAME_LIST *pNameList,
    IN PWSTR LookupString,
    IN ULONG Len
    )
{
    if ( LsaHandle == NULL || LookupString == NULL || Len == 0 ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    if ( LookupString[0] == L'\0' ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    //
    // convert the sid string to a real sid
    //
    PSID pSid=NULL;
    NTSTATUS NtStatus;
    DWORD rc;
    PLSA_REFERENCED_DOMAIN_LIST RefDomains=NULL;
    PLSA_TRANSLATED_SID2        Sids=NULL;
    UNICODE_STRING              UnicodeName;

    NtStatus = ScepLsaLookupNames2(
                                  LsaHandle,
                                  LSA_LOOKUP_ISOLATED_AS_LOCAL,
                                  LookupString,                            
                                  &RefDomains,                            
                                  &Sids
                                  );

    rc = RtlNtStatusToDosError(NtStatus);

    if ( ERROR_SUCCESS == rc && Sids ) {

         //
         // name is found, make domain\account format
         //
        if ( Sids[0].Use != SidTypeInvalid &&
             Sids[0].Use != SidTypeUnknown &&
             Sids[0].Sid ) {

            //
            // this name is mapped
            // convert to a sid string, note: a prefix "*" should be added
            //

            UNICODE_STRING UnicodeStringSid;

            rc = RtlNtStatusToDosError(
                     RtlConvertSidToUnicodeString(&UnicodeStringSid,
                                                  Sids[0].Sid,
                                                  TRUE ));

            if ( ERROR_SUCCESS == rc ) {

                rc = ScepAddTwoNamesToNameList(
                                  pNameList,
                                  FALSE,
                                  TEXT("*"),
                                  1,
                                  UnicodeStringSid.Buffer,
                                  UnicodeStringSid.Length/2);

                RtlFreeUnicodeString( &UnicodeStringSid );

            }

        } else {

            rc = ERROR_NONE_MAPPED;
        }

    }

    if ( ERROR_SUCCESS != rc ) {

        //
        // either invalid sid string, or not found a name map, or
        // failed to add to the name list, just simply add the sid string to the name list
        //

        rc = ScepAddToNameList(
                      pNameList,
                      LookupString,
                      Len);
    }

    if ( Sids ) {

        LsaFreeMemory(Sids);
    }

    if ( RefDomains ) {

        LsaFreeMemory(RefDomains);
    }

    return(ScepDosErrorToSceStatus(rc));

}


NTSTATUS
ScepOpenLsaPolicy(
    IN ACCESS_MASK  access,
    OUT PLSA_HANDLE  pPolicyHandle,
    IN BOOL bDoNotNotify
    )
/* ++
Routine Description:

    This routine opens the LSA policy with the desired access.

Arguments:

    access  - the desired access to the policy

    pPolicyHandle - returned address of the Policy Handle

Return value:

    NTSTATUS
-- */
{

    NTSTATUS                    NtStatus;
    LSA_OBJECT_ATTRIBUTES       attributes;
    SECURITY_QUALITY_OF_SERVICE service;


    memset( &attributes, 0, sizeof(attributes) );
    attributes.Length = sizeof(attributes);
    attributes.SecurityQualityOfService = &service;
    service.Length = sizeof(service);
    service.ImpersonationLevel= SecurityImpersonation;
    service.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
    service.EffectiveOnly = TRUE;

    //
    // open the lsa policy first
    //

    NtStatus = LsaOpenPolicy(
                    NULL,
                    &attributes,
                    access,
                    pPolicyHandle
                    );
/*
    if ( NT_SUCCESS(NtStatus) &&
         bDoNotNotify &&
         *pPolicyHandle ) {

        NtStatus = LsaSetPolicyReplicationHandle(pPolicyHandle);

        if ( !NT_SUCCESS(NtStatus) ) {
            LsaClose( *pPolicyHandle );
            *pPolicyHandle = NULL;
        }
    }
*/
    return(NtStatus);
}



BOOL
ScepIsSidFromAccountDomain(
    IN PSID pSid
    )
{
    if ( pSid == NULL ) {
        return(FALSE);
    }

    if ( !RtlValidSid(pSid) ) {
        return(FALSE);
    }

    PSID_IDENTIFIER_AUTHORITY pia = RtlIdentifierAuthoritySid ( pSid );

    if ( pia ) {

        if ( pia->Value[5] != 5 ||
             pia->Value[0] != 0 ||
             pia->Value[1] != 0 ||
             pia->Value[2] != 0 ||
             pia->Value[3] != 0 ||
             pia->Value[4] != 0 ) {
            //
            // this is not a account from account domain
            //
            return(FALSE);
        }


        if ( RtlSubAuthorityCountSid( pSid ) == 0 ||
             *RtlSubAuthoritySid ( pSid, 0 ) != SECURITY_NT_NON_UNIQUE ) {
            return(FALSE);
        }

        return(TRUE);
    }

    return(FALSE);
}

//+--------------------------------------------------------------------------
//
//  Function:  SetupINFAsUCS2
//
//  Synopsis:  Dumps some UCS-2 to the specified INF file if it
//  doesn't already exist; this makes the .inf/.ini manipulation code
//  use UCS-2.
//
//  Arguments: The file to create and dump to
//
//  Returns:   0 == failure, non-zero == success; use GetLastError()
//  to retrieve the error code (same as WriteFile).
//
//+--------------------------------------------------------------------------
BOOL
SetupINFAsUCS2(LPCTSTR szName)
{
  HANDLE file;
  BOOL status;

  file = CreateFile(szName,
                    GENERIC_READ | GENERIC_WRITE,
                    0,
                    NULL,
                    CREATE_NEW,
                    FILE_ATTRIBUTE_NORMAL,
                    NULL);
  if (file == INVALID_HANDLE_VALUE) {
    if (GetLastError() != ERROR_ALREADY_EXISTS)
      // Well, this isn't good -- we lose.
      status = FALSE;
    else
      // Otherwise, the file already existed, which is just fine.
      // We'll just let the .inf/.ini manipulation code keep using
      // the same charset&encoding...
      status = TRUE;
  } else {
      // We created the file -- it didn't exist.
      // So we need to spew a little UCS-2 into it.
      static WCHAR str[] = L"0[Unicode]\r\nUnicode=yes\r\n";
      DWORD n_written;
      BYTE *pbStr = (BYTE *)str;

      pbStr[0] = 0xFF;
      pbStr[1] = 0xFE;

      status = WriteFile(file,
                         (LPCVOID)str,
                         sizeof(str) - sizeof(UNICODE_NULL),
                         &n_written,
                         NULL);
    CloseHandle(file);
  }
  return status;
}


//+--------------------------------------------------------------------------
//
//  Function:  ScepStripPrefix
//
//  Arguments: pwszPath to look in
//
//  Returns:   Returns ptr to stripped path (same if no stripping)
//
//+--------------------------------------------------------------------------
WCHAR *
ScepStripPrefix(
    IN LPTSTR pwszPath
    )
{
    WCHAR wszMachPrefix[] = TEXT("LDAP://CN=Machine,");
    INT iMachPrefixLen = lstrlen( wszMachPrefix );
    WCHAR wszUserPrefix[] = TEXT("LDAP://CN=User,");
    INT iUserPrefixLen = lstrlen( wszUserPrefix );
    WCHAR *pwszPathSuffix;

    //
    // Strip out prefix to get the canonical path to Gpo
    //

    if ( CompareString( LOCALE_USER_DEFAULT, NORM_IGNORECASE,
                        pwszPath, iUserPrefixLen, wszUserPrefix, iUserPrefixLen ) == CSTR_EQUAL ) {
        pwszPathSuffix = pwszPath + iUserPrefixLen;
    } else if ( CompareString( LOCALE_USER_DEFAULT, NORM_IGNORECASE,
                        pwszPath, iMachPrefixLen, wszMachPrefix, iMachPrefixLen ) == CSTR_EQUAL ) {
        pwszPathSuffix = pwszPath + iMachPrefixLen;
    } else
        pwszPathSuffix = pwszPath;

    return pwszPathSuffix;
}


//+--------------------------------------------------------------------------
//
//  Function:  ScepGenerateGuid
//
//  Arguments: out: the guid string
//
//  Returns:   Returns guid string (has to be freed outside
//
//+--------------------------------------------------------------------------
/*
DWORD
ScepGenerateGuid(
                OUT PWSTR *ppwszGuid
                )
{
    GUID    guid;
    DWORD   rc = ERROR_SUCCESS;

    if (ppwszGuid == NULL)
        return ERROR_INVALID_PARAMETER;

    *ppwszGuid = (PWSTR) ScepAlloc(LMEM_ZEROINIT, (MAX_GUID_STRING_LEN + 1) * sizeof(WCHAR));

    if (*ppwszGuid) {

        if (ERROR_SUCCESS == (rc = ScepWbemErrorToDosError(CoCreateGuid( &guid )))) {

            if (!SCEP_NULL_GUID(guid))
                SCEP_GUID_TO_STRING(guid, *ppwszGuid);
            else {
                rc = ERROR_INVALID_PARAMETER;

            }
        }
    } else
        rc = ERROR_NOT_ENOUGH_MEMORY;

    return rc;
}
*/


SCESTATUS
SceInfpGetPrivileges(
   IN HINF hInf,
   IN BOOL bLookupAccount,
   OUT PSCE_PRIVILEGE_ASSIGNMENT *pPrivileges,
   OUT PSCE_ERROR_LOG_INFO *Errlog OPTIONAL
   )
/* ++
Description:
    Get user right assignments from a INF template. If bLookupAccount is set
    to TRUE, the accounts in user right assignments will be translated to
    account names (from SID format); else the information is returned in
    the same way as defined in the template.

Arguments:

Return Value:


-- */
{
    INFCONTEXT                   InfLine;
    SCESTATUS                     rc=SCESTATUS_SUCCESS;
    PSCE_PRIVILEGE_ASSIGNMENT     pCurRight=NULL;
    WCHAR                        Keyname[SCE_KEY_MAX_LENGTH];
    PWSTR                        StrValue=NULL;
    DWORD                        DataSize;
    DWORD                        PrivValue;
    DWORD                        i, cFields;
    LSA_HANDLE LsaHandle=NULL;

    //
    // [Privilege Rights] section
    //

    if(SetupFindFirstLine(hInf,szPrivilegeRights,NULL,&InfLine)) {

        //
        // open lsa policy handle for sid/name lookup
        //

        rc = RtlNtStatusToDosError(
                  ScepOpenLsaPolicy(
                        POLICY_LOOKUP_NAMES | POLICY_VIEW_LOCAL_INFORMATION,
                        &LsaHandle,
                        TRUE
                        ));

        if ( ERROR_SUCCESS != rc ) {
            ScepBuildErrorLogInfo(
                        rc,
                        Errlog,
                        SCEERR_ADD,
                        TEXT("LSA")
                        );
            return(ScepDosErrorToSceStatus(rc));
        }

        do {

            memset(Keyname, '\0', SCE_KEY_MAX_LENGTH*sizeof(WCHAR));
            rc = SCESTATUS_SUCCESS;

            if ( SetupGetStringField(&InfLine, 0, Keyname,
                                     SCE_KEY_MAX_LENGTH, NULL) ) {

                //
                // find a key name (which is a privilege name here ).
                // lookup privilege's value
                //
                if ( ( PrivValue = ScepLookupPrivByName(Keyname) ) == -1 ) {
                    ScepBuildErrorLogInfo( ERROR_INVALID_DATA,
                                         Errlog,
                                         SCEERR_INVALID_PRIVILEGE,
                                         Keyname
                                       );
//                    goto NextLine;
                }

                //
                // a sm_privilege_assignment structure. allocate buffer
                //
                pCurRight = (PSCE_PRIVILEGE_ASSIGNMENT)ScepAlloc( LMEM_ZEROINIT,
                                                                sizeof(SCE_PRIVILEGE_ASSIGNMENT) );
                if ( pCurRight == NULL ) {
                    rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
                    goto Done;
                }
                pCurRight->Name = (PWSTR)ScepAlloc( (UINT)0, (wcslen(Keyname)+1)*sizeof(WCHAR));
                if ( pCurRight->Name == NULL ) {
                    ScepFree(pCurRight);
                    rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
                    goto Done;
                }

                wcscpy(pCurRight->Name, Keyname);
                pCurRight->Value = PrivValue;

                cFields = SetupGetFieldCount( &InfLine );

                for ( i=0; i<cFields && rc==SCESTATUS_SUCCESS; i++) {
                    //
                    //  read each user/group name
                    //
                    if ( SetupGetStringField( &InfLine, i+1, NULL, 0, &DataSize ) ) {

                        if (DataSize > 1) {


                            StrValue = (PWSTR)ScepAlloc( 0, (DataSize+1)*sizeof(WCHAR) );

                            if ( StrValue == NULL )
                                rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
                            else {
                                StrValue[DataSize] = L'\0';
                                if ( SetupGetStringField( &InfLine, i+1, StrValue,
                                                           DataSize, NULL) ) {

                                    if ( bLookupAccount && StrValue[0] == L'*' && DataSize > 0 ) {
                                        //
                                        // this is a SID format, should look it up
                                        //
                                        rc = ScepLookupSidStringAndAddToNameList(
                                                               LsaHandle,
                                                               &(pCurRight->AssignedTo),
                                                               StrValue, // +1,
                                                               DataSize  // -1
                                                               );

                                    } else {

                                        rc = ScepAddToNameList(&(pCurRight->AssignedTo),
                                                               StrValue,
                                                               DataSize );
                                    }
                                } else
                                    rc = SCESTATUS_INVALID_DATA;
                            }

                            ScepFree( StrValue );
                            StrValue = NULL;
                        }

                    } else {
                        ScepBuildErrorLogInfo( ERROR_INVALID_DATA,
                                             Errlog,
                                             SCEERR_QUERY_INFO,
                                             Keyname );
                        rc = SCESTATUS_INVALID_DATA;
                    }
                }

                if ( rc == SCESTATUS_SUCCESS ) {
                    //
                    // add this node to the list
                    //
                    pCurRight->Next = *pPrivileges;
                    *pPrivileges = pCurRight;
                    pCurRight = NULL;

                } else
                    ScepFreePrivilege(pCurRight);

            } else
                rc = SCESTATUS_BAD_FORMAT;

//NextLine:
            if (rc != SCESTATUS_SUCCESS ) {

               ScepBuildErrorLogInfo( ScepSceStatusToDosError(rc),
                                    Errlog,
                                    SCEERR_QUERY_INFO,
                                    szPrivilegeRights
                                  );
               goto Done;
            }

        } while(SetupFindNextLine(&InfLine,&InfLine));
    }

Done:

    if ( StrValue != NULL )
        ScepFree(StrValue);

    if ( LsaHandle ) {
        LsaClose(LsaHandle);
    }

    return(rc);
}

NTSTATUS
ScepIsSystemContext(
    IN HANDLE hUserToken,
    OUT BOOL *pbSystem
    )
{
    NTSTATUS NtStatus;
    DWORD nRequired;

    //
    // variables to determine calling context
    //

    PTOKEN_USER pUser=NULL;
    SID_IDENTIFIER_AUTHORITY ia=SECURITY_NT_AUTHORITY;
    PSID SystemSid=NULL;
    BOOL b;


    //
    // get current user SID in the token
    //

    NtStatus = NtQueryInformationToken (hUserToken,
                                        TokenUser,
                                        NULL,
                                        0,
                                        &nRequired
                                        );

    if ( STATUS_BUFFER_TOO_SMALL == NtStatus ) {

        pUser = (PTOKEN_USER)LocalAlloc(0,nRequired+1);
        if ( pUser ) {
            NtStatus = NtQueryInformationToken (hUserToken,
                                                TokenUser,
                                                (PVOID)pUser,
                                                nRequired,
                                                &nRequired
                                                );
        } else {

            NtStatus = STATUS_NO_MEMORY;
        }
    }

    b = FALSE;

    if ( NT_SUCCESS(NtStatus) && pUser && pUser->User.Sid ) {

        //
        // build system sid and compare with the current user SID
        //

        NtStatus = RtlAllocateAndInitializeSid (&ia,1,SECURITY_LOCAL_SYSTEM_RID,
                                0, 0, 0, 0, 0, 0, 0, &SystemSid);
        if ( NT_SUCCESS(NtStatus) && SystemSid ) {

            //
            // check to see if it is system sid
            //

            if ( RtlEqualSid(pUser->User.Sid, SystemSid) ) {

                b=TRUE;
            }
        }
    }

    //
    // free memory allocated
    //

    if ( SystemSid ) {
        FreeSid(SystemSid);
    }

    if ( pUser ) {
        LocalFree(pUser);
    }

    *pbSystem = b;

    return NtStatus;
}

BOOL
IsNT5()
{
    WCHAR szInfName[MAX_PATH*2+1];
    szInfName[0] = L'\0';
    DWORD cNumCharsReturned = GetSystemWindowsDirectory(szInfName, MAX_PATH);

    if (cNumCharsReturned)
    {
        wcscat(szInfName, L"\\system32\\$winnt$.inf");
    }
    else {
        return TRUE;
    }

    UINT nRet = GetPrivateProfileInt( L"Networking",
                                      L"BuildNumber",
                                      0,
                                      szInfName
                                     );
    if (nRet == 0) {
        return TRUE;
    }
    else if (nRet > 1381) {
        return TRUE;
    }

    return FALSE;
}


DWORD
ScepVerifyTemplateName(
    IN PWSTR InfTemplateName,
    OUT PSCE_ERROR_LOG_INFO *pErrlog OPTIONAL
    )
/*
Routine Description:

    This routine verifies the template name for read protection and
    invalid path

Arguments:

    InfTemplateName - the full path name of the inf template

    pErrlog         - the error log buffer

Return Value:

    WIN32 error code
*/
{
    if ( !InfTemplateName ) {

        return(ERROR_INVALID_PARAMETER);
    }

    PWSTR DefProfile;
    DWORD rc;

    //
    // verify the InfTemplateName to generate
    // if read only, or access denied, return ERROR_ACCESS_DENIED
    // if invalid path, return ERROR_PATH_NOT_FOUND
    //

    DefProfile = InfTemplateName + wcslen(InfTemplateName)-1;
    while ( DefProfile > InfTemplateName+1 ) {

        if ( *DefProfile != L'\\') {
            DefProfile--;
        } else {
            break;
        }
    }

    rc = NO_ERROR;

    if ( DefProfile > InfTemplateName+2 ) {  // at least allow a drive letter, a colon, and a \

        //
        // find the directory path
        //

        DWORD Len=(DWORD)(DefProfile-InfTemplateName);

        PWSTR TmpBuf=(PWSTR)LocalAlloc(0, (Len+1)*sizeof(WCHAR));
        if ( TmpBuf ) {

            wcsncpy(TmpBuf, InfTemplateName, Len);
            TmpBuf[Len] = L'\0';

            if ( 0xFFFFFFFF == GetFileAttributes(TmpBuf) )
                rc = ERROR_PATH_NOT_FOUND;

            LocalFree(TmpBuf);

        } else {
            rc = ERROR_NOT_ENOUGH_MEMORY;
        }

    } else if ( DefProfile == InfTemplateName+2 &&
                InfTemplateName[1] == L':' ) {
        //
        // this is a template path off the root
        //

    } else {

        //
        // invalid directory path
        //

        rc = ERROR_PATH_NOT_FOUND;
    }


    if ( rc != NO_ERROR ) {
        //
        // error occurs
        //
        if ( ERROR_PATH_NOT_FOUND == rc ) {

            ScepBuildErrorLogInfo(
                rc,
                pErrlog,
                SCEERR_INVALID_PATH,
                InfTemplateName
                );
        }
        return(rc);
    }

    //
    // make it unicode aware
    // do not worry about failure
    //
    SetupINFAsUCS2(InfTemplateName);

    //
    // validate if the template is write protected
    //

    FILE *hTempFile;
    hTempFile = _wfopen(InfTemplateName, L"a+");

    if ( !hTempFile ) {
        //
        // can't overwrite/create the file, must be access denied
        //
        rc = ERROR_ACCESS_DENIED;

        ScepBuildErrorLogInfo(
            rc,
            pErrlog,
            SCEERR_ERROR_CREATE,
            InfTemplateName
            );

        return(rc);

    } else {
        fclose( hTempFile );
    }

    return(rc);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\scerpc\sceutil.h ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    sceutil.h

Abstract:

    This module defines the data structures and function prototypes
    shared by both SCE client and SCE server

Author:

    Jin Huang (jinhuang) 23-Jan-1998

Revision History:

    jinhuang (splitted from scep.h)
--*/
#ifndef _sceutil_
#define _sceutil_

#include <ntlsa.h>
#include <cfgmgr32.h>

typedef struct _SCE_USER_PRIV_LOOKUP {
   UINT     Value;
   PWSTR    Name;
}SCE_USER_PRIV_LOOKUP;

static SCE_USER_PRIV_LOOKUP SCE_Privileges[] = {
    {0,                             (PWSTR)SE_NETWORK_LOGON_NAME},
// Access the computer from network
    {SE_TCB_PRIVILEGE,              (PWSTR)SE_TCB_NAME},
// Act as part of the operating System
    {SE_MACHINE_ACCOUNT_PRIVILEGE,  (PWSTR)SE_MACHINE_ACCOUNT_NAME},
// Add workstations to the domain
    {SE_BACKUP_PRIVILEGE,           (PWSTR)SE_BACKUP_NAME},
// Back up files and directories
    {SE_CHANGE_NOTIFY_PRIVILEGE,    (PWSTR)SE_CHANGE_NOTIFY_NAME},
// Bypass traverse checking
    {SE_SYSTEMTIME_PRIVILEGE,       (PWSTR)SE_SYSTEMTIME_NAME},
// Change the system time
    {SE_CREATE_PAGEFILE_PRIVILEGE,  (PWSTR)SE_CREATE_PAGEFILE_NAME},
// Create a pagefile
    {SE_CREATE_TOKEN_PRIVILEGE,     (PWSTR)SE_CREATE_TOKEN_NAME},
// Create a token object
    {SE_CREATE_PERMANENT_PRIVILEGE, (PWSTR)SE_CREATE_PERMANENT_NAME},
// Create permanent shared objects
    {SE_DEBUG_PRIVILEGE,            (PWSTR)SE_DEBUG_NAME},
// Debug programs
    {SE_REMOTE_SHUTDOWN_PRIVILEGE,  (PWSTR)SE_REMOTE_SHUTDOWN_NAME},
// Force shutdown from a remote system
    {SE_AUDIT_PRIVILEGE,            (PWSTR)SE_AUDIT_NAME},
// Generate security audits
    {SE_INCREASE_QUOTA_PRIVILEGE,   (PWSTR)SE_INCREASE_QUOTA_NAME},
// Increase quotas
    {SE_INC_BASE_PRIORITY_PRIVILEGE,(PWSTR)SE_INC_BASE_PRIORITY_NAME},
// Increase scheduling priority
    {SE_LOAD_DRIVER_PRIVILEGE,      (PWSTR)SE_LOAD_DRIVER_NAME},
// Load and unload device drivers
    {SE_LOCK_MEMORY_PRIVILEGE,      (PWSTR)SE_LOCK_MEMORY_NAME},
// Lock pages in memory
    {0,                             (PWSTR)SE_BATCH_LOGON_NAME},
// Logon as a batch job
    {0,                             (PWSTR)SE_SERVICE_LOGON_NAME},
// Logon as a service
    {0,                             (PWSTR)SE_INTERACTIVE_LOGON_NAME},
// Logon locally
    {SE_SECURITY_PRIVILEGE,         (PWSTR)SE_SECURITY_NAME},
// Manage auditing and security log
    {SE_SYSTEM_ENVIRONMENT_PRIVILEGE, (PWSTR)SE_SYSTEM_ENVIRONMENT_NAME},
// Modify firmware environment variables
    {SE_PROF_SINGLE_PROCESS_PRIVILEGE,(PWSTR)SE_PROF_SINGLE_PROCESS_NAME},
// Profile single process
    {SE_SYSTEM_PROFILE_PRIVILEGE,   (PWSTR)SE_SYSTEM_PROFILE_NAME},
// Profile system performance
    {SE_ASSIGNPRIMARYTOKEN_PRIVILEGE, (PWSTR)SE_ASSIGNPRIMARYTOKEN_NAME},
// Replace a process-level token
    {SE_RESTORE_PRIVILEGE,          (PWSTR)SE_RESTORE_NAME},
// Restore files and directories
    {SE_SHUTDOWN_PRIVILEGE,         (PWSTR)SE_SHUTDOWN_NAME},
// Shut down the system
    {SE_TAKE_OWNERSHIP_PRIVILEGE,   (PWSTR)SE_TAKE_OWNERSHIP_NAME},
// Take ownership of files or other objects
//    {SE_UNSOLICITED_INPUT_PRIVILEGE,(PWSTR)SE_UNSOLICITED_INPUT_NAME},
// Unsolicited Input is obsolete and unused
    {0,                             (PWSTR)SE_DENY_NETWORK_LOGON_NAME},
// Deny access the computer from network
    {0,                             (PWSTR)SE_DENY_BATCH_LOGON_NAME},
// Deny Logon as a batch job
    {0,                             (PWSTR)SE_DENY_SERVICE_LOGON_NAME},
// Deny Logon as a service
    {0,                             (PWSTR)SE_DENY_INTERACTIVE_LOGON_NAME},
// Deny logon locally
    {SE_UNDOCK_PRIVILEGE,           (PWSTR)SE_UNDOCK_NAME},
// Undock privilege
    {SE_SYNC_AGENT_PRIVILEGE,       (PWSTR)SE_SYNC_AGENT_NAME},
// Sync agent privilege
    {SE_ENABLE_DELEGATION_PRIVILEGE,(PWSTR)SE_ENABLE_DELEGATION_NAME},
// enable delegation privilege
    {SE_MANAGE_VOLUME_PRIVILEGE,    (PWSTR)SE_MANAGE_VOLUME_NAME},
// (NTFS) Manage volume privilege
    {0,                             (PWSTR)SE_REMOTE_INTERACTIVE_LOGON_NAME},
// (TS) logon locally from a TS session
    {0,                             (PWSTR)SE_DENY_REMOTE_INTERACTIVE_LOGON_NAME}
// (TS) deny logon locally from a TS session
};

typedef struct _SCE_TEMP_NODE_ {
    PWSTR Name;
    DWORD Len;
    BOOL  bFree;
} SCE_TEMP_NODE, *PSCE_TEMP_NODE;

//
// This structure is used to find well known name locally for performance.
//
typedef struct _WELL_KNOWN_NAME_LOOKUP {
    PWSTR StrSid;
    WCHAR Name[36];
} WELL_KNOWN_NAME_LOOKUP, *PWELL_KNOWN_NAME_LOOKUP;

#define TABLE_SIZE            33

static WELL_KNOWN_NAME_LOOKUP  NameTable[] = {
    //Universal well-known
    { L"S-1-1-0", L'\0' },                   //Everyone
    //{ L"S-1-2-0", L'\0' },               //Local
    { L"S-1-3-0", L'\0' },              //Creator Owner
    { L"S-1-3-1", L'\0' },              //Creator Group
    { L"S-1-3-2", L'\0' },       //Creator Owner Server
    { L"S-1-3-3", L'\0' },       //Creator Group Server

    //NT well-known
    //{ L"S-1-5", L'\0' },           //NT Pseudo Domain
    { L"S-1-5-1", L'\0' },                     //Dialup
    { L"S-1-5-2", L'\0' },                    //Network
    { L"S-1-5-3", L'\0' },                      //Batch
    { L"S-1-5-4", L'\0' },                //Interactive
    { L"S-1-5-6", L'\0' },                    //Service
    { L"S-1-5-7", L'\0' },            //Anonymous Logon
    { L"S-1-5-8", L'\0' },                      //Proxy
    { L"S-1-5-9", L'\0' },          //Enterprise Domain Controllers
    { L"S-1-5-10", L'\0' },                 //Self
    { L"S-1-5-11", L'\0' },       //Authenticated Users
    { L"S-1-5-12", L'\0' },                //Restricted
    { L"S-1-5-13", L'\0' },      //Terminal Server User
    { L"S-1-5-18", L'\0' },      //Local system
    { L"S-1-5-19", L'\0' },      //Local Service
    { L"S-1-5-20", L'\0' },      //Network Service

    //Builtin
    { L"S-1-5-32-544", L'\0' },        //Administrtors
    { L"S-1-5-32-545", L'\0' },            //Users
    { L"S-1-5-32-546", L'\0' },           //Guests
    { L"S-1-5-32-547", L'\0' },           //Power Users
    { L"S-1-5-32-548", L'\0' },      //Account Operators
    { L"S-1-5-32-549", L'\0' },      //Server Operators
    { L"S-1-5-32-550", L'\0' },      //Print Operators
    { L"S-1-5-32-551", L'\0' },      //Backup Operators
    { L"S-1-5-32-552", L'\0' },      //Replicator
    { L"S-1-5-32-553", L'\0' },      //Ras Servers
    { L"S-1-5-32-554", L'\0' },      //PREW2KCOMPACCESS
    { L"S-1-5-32-555", L'\0' },      //Remote desktop users
    { L"S-1-5-32-556", L'\0' }       // network configuraiton operators
};

//
// Bit masks encoding rsop area information
//
#define SCE_RSOP_PASSWORD_INFO                (0x1)
#define SCE_RSOP_LOCKOUT_INFO                 (0x1 << 1)
#define SCE_RSOP_LOGOFF_INFO                  (0x1 << 2)
#define SCE_RSOP_ADMIN_INFO                   (0x1 << 3)
#define SCE_RSOP_GUEST_INFO                   (0x1 << 4)
#define SCE_RSOP_GROUP_INFO                   (0x1 << 5)
#define SCE_RSOP_PRIVILEGE_INFO               (0x1 << 6)
#define SCE_RSOP_FILE_SECURITY_INFO           (0x1 << 7)
#define SCE_RSOP_REGISTRY_SECURITY_INFO       (0x1 << 8)
#define SCE_RSOP_AUDIT_LOG_MAXSIZE_INFO       (0x1 << 9)
#define SCE_RSOP_AUDIT_LOG_RETENTION_INFO     (0x1 << 10)
#define SCE_RSOP_AUDIT_LOG_GUEST_INFO         (0x1 << 11)
#define SCE_RSOP_AUDIT_EVENT_INFO             (0x1 << 12)
#define SCE_RSOP_KERBEROS_INFO                (0x1 << 13)
#define SCE_RSOP_REGISTRY_VALUE_INFO          (0x1 << 14)
#define SCE_RSOP_SERVICES_INFO                (0x1 << 15)
#define SCE_RSOP_FILE_SECURITY_INFO_CHILD     (0x1 << 16)
#define SCE_RSOP_REGISTRY_SECURITY_INFO_CHILD (0x1 << 17)
#define SCE_RSOP_LSA_POLICY_INFO              (0x1 << 18)
#define SCE_RSOP_DISABLE_ADMIN_INFO           (0x1 << 19)
#define SCE_RSOP_DISABLE_GUEST_INFO           (0x1 << 20)

BOOL
ScepInitNameTable();

BOOL
ScepLookupNameTable(
    IN PWSTR Name,
    OUT PWSTR *StrSid
    );

INT
ScepLookupPrivByName(
    IN PCWSTR Right
    );

INT
ScepLookupPrivByValue(
    IN DWORD Priv
    );

SCESTATUS
ScepGetProductType(
    OUT PSCE_SERVER_TYPE srvProduct
    );

SCESTATUS
ScepConvertMultiSzToDelim(
    IN PWSTR pValue,
    IN DWORD Len,
    IN WCHAR DelimFrom,
    IN WCHAR Delim
    );

DWORD
ScepAddTwoNamesToNameList(
    OUT PSCE_NAME_LIST *pNameList,
    IN BOOL bAddSeparator,
    IN PWSTR Name1,
    IN ULONG Length1,
    IN PWSTR Name2,
    IN ULONG Length2
    );

NTSTATUS
ScepDomainIdToSid(
    IN PSID DomainId,
    IN ULONG RelativeId,
    OUT PSID *Sid
    );

DWORD
ScepConvertSidToPrefixStringSid(
    IN PSID pSid,
    OUT PWSTR *StringSid
    );

NTSTATUS
ScepConvertSidToName(
    IN LSA_HANDLE LsaPolicy,
    IN PSID AccountSid,
    IN BOOL bFromDomain,
    OUT PWSTR *AccountName,
    OUT DWORD *Length OPTIONAL
    );

NTSTATUS
ScepConvertNameToSid(
    IN LSA_HANDLE LsaPolicy,
    IN PWSTR AccountName,
    OUT PSID *AccountSid
    );

SCESTATUS
ScepConvertNameToSidString(
    IN LSA_HANDLE LsaHandle,
    IN PWSTR Name,
    IN BOOL bAccountDomainOnly,
    OUT PWSTR *SidString,
    OUT DWORD *SidStrLen
    );

SCESTATUS
ScepLookupSidStringAndAddToNameList(
    IN LSA_HANDLE LsaHandle,
    IN OUT PSCE_NAME_LIST *pNameList,
    IN PWSTR LookupString,
    IN ULONG Len
    );

SCESTATUS
ScepLookupNameAndAddToSidStringList(
    IN LSA_HANDLE LsaHandle,
    IN OUT PSCE_NAME_LIST *pNameList,
    IN PWSTR LookupString,
    IN ULONG Len
    );

NTSTATUS
ScepOpenLsaPolicy(
    IN ACCESS_MASK  access,
    OUT PLSA_HANDLE  pPolicyHandle,
    IN BOOL bDoNotNotify
    );

BOOL
ScepIsSidFromAccountDomain(
    IN PSID pSid
    );

BOOL
SetupINFAsUCS2(
    IN LPCTSTR szName
    );

WCHAR *
ScepStripPrefix(
    IN LPTSTR pwszPath
    );

DWORD
ScepGenerateGuid(
                OUT PWSTR *ppwszGuid
                );

SCESTATUS
SceInfpGetPrivileges(
   IN HINF hInf,
   IN BOOL bLookupAccount,
   OUT PSCE_PRIVILEGE_ASSIGNMENT *pPrivileges,
   OUT PSCE_ERROR_LOG_INFO *Errlog OPTIONAL
   );

DWORD
ScepQueryAndAddService(
    IN SC_HANDLE hScManager,
    IN LPWSTR   lpServiceName,
    IN LPWSTR   lpDisplayName,
    OUT PSCE_SERVICES *pServiceList
    );

NTSTATUS
ScepIsSystemContext(
    IN HANDLE hUserToken,
    OUT BOOL *pbSystem
    );

BOOL
IsNT5();

DWORD
ScepVerifyTemplateName(
    IN PWSTR InfTemplateName,
    OUT PSCE_ERROR_LOG_INFO *pErrlog OPTIONAL
    );

NTSTATUS
ScepLsaLookupNames2(
    IN LSA_HANDLE PolicyHandle,
    IN ULONG Flags,
    IN PWSTR pszAccountName,
    OUT PLSA_REFERENCED_DOMAIN_LIST *ReferencedDomains,
    OUT PLSA_TRANSLATED_SID2 *Sids    
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\scerpc\splay.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    splay.h

Abstract:

    Header file for splay.cpp (see a description of the data structures there)

Author:

    Vishnu Patankar (vishnup) 15-Aug-2000 created

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <string.h>
#include <wchar.h>
#include <stddef.h>
#include <stdlib.h>
#include <stdio.h>

#ifndef _splay_h
#define _splay_h

#ifndef Thread
#define Thread  __declspec( thread )
#endif

//
// This typedef can be changed for making the splay library more generic
// and exportable perhaps (will require function pointers for generic compares)
//

typedef enum _SCEP_NODE_VALUE_TYPE {
    SplayNodeSidType = 1,
    SplayNodeStringType
} SCEP_NODE_VALUE_TYPE;

typedef struct _SCEP_SPLAY_NODE_ {
    PVOID                   Value;
    DWORD   dwByteLength;
    struct _SCEP_SPLAY_NODE_      *Left;
    struct _SCEP_SPLAY_NODE_      *Right;
} SCEP_SPLAY_NODE, *PSCEP_SPLAY_NODE;

typedef struct _SCEP_SPLAY_TREE_ {
    _SCEP_SPLAY_NODE_       *Root;
    _SCEP_SPLAY_NODE_       *Sentinel;
    SCEP_NODE_VALUE_TYPE    Type;
} SCEP_SPLAY_TREE, *PSCEP_SPLAY_TREE;

//
// functions to do operations on the splay tree
//

VOID
ScepSplayFreeTree(
    IN PSCEP_SPLAY_TREE *ppTreeRoot,
    IN BOOL bDestroyTree
    );

PSCEP_SPLAY_TREE
ScepSplayInitialize(
    SCEP_NODE_VALUE_TYPE Type
    );

DWORD
ScepSplayInsert(
    IN  PVOID Value,
    IN  OUT PSCEP_SPLAY_TREE pTreeRoot,
    OUT  BOOL  *pbExists
    );


DWORD
ScepSplayDelete(
    IN  PVOID Value,
    IN  OUT PSCEP_SPLAY_TREE pTreeRoot
    );

BOOL
ScepSplayValueExist(
    IN  PVOID Value,
    IN  OUT PSCEP_SPLAY_TREE pTreeRoot
    );

BOOL
ScepSplayTreeEmpty(
    IN PSCEP_SPLAY_TREE pTreeRoot
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\scerpc\strsd.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    strsd.c

Abstract:

    This Module implements wrapper functions to convert from a specialized
    string representation of a security descriptor to the security descriptor
    itself, and the opposite function.

Author:

Environment:

    User Mode

Revision History:

--*/

#include "headers.h"
//#include <lmcons.h>
//#include <secobj.h>
//#include <netlib.h>
//#include <ntsecapi.h>
#include "sddl.h"

#pragma hdrstop


DWORD
ScepGetSecurityInformation(
    IN PSECURITY_DESCRIPTOR pSD,
    OUT SECURITY_INFORMATION *pSeInfo
    );

DWORD
WINAPI
ConvertTextSecurityDescriptor (
    IN  PWSTR                   pwszTextSD,
    OUT PSECURITY_DESCRIPTOR   *ppSD,
    OUT PULONG                  pcSDSize OPTIONAL,
    OUT PSECURITY_INFORMATION   pSeInfo OPTIONAL
    )
{

    DWORD rc=ERROR_SUCCESS;

    if ( NULL == pwszTextSD || NULL == ppSD ) {
        return(ERROR_INVALID_PARAMETER);
    }

    //
    // initialize output buffers
    //

    *ppSD = NULL;

    if ( pSeInfo ) {
        *pSeInfo = 0;
    }
    if ( pcSDSize ) {
        *pcSDSize = 0;
    }

    //
    // call SDDL convert apis
    //

    if ( ConvertStringSecurityDescriptorToSecurityDescriptorW(
                    pwszTextSD,
                    SDDL_REVISION_1,
                    ppSD,
                    pcSDSize
                    ) ) {
        //
        // conversion succeeds
        //

        if ( pSeInfo && *ppSD ) {

            //
            // get the SeInfo
            //

            rc = ScepGetSecurityInformation(
                        *ppSD,
                        pSeInfo
                        );

            if ( rc != ERROR_SUCCESS ) {

                LocalFree(*ppSD);
                *ppSD = NULL;

                if ( pcSDSize ) {
                    *pcSDSize = 0;
                }
            }

        }

    } else {

        rc = GetLastError();
    }

    return(rc);
}


DWORD
WINAPI
ConvertSecurityDescriptorToText (
    IN PSECURITY_DESCRIPTOR   pSD,
    IN SECURITY_INFORMATION   SecurityInfo,
    OUT PWSTR                  *ppwszTextSD,
    OUT PULONG                 pcTextSize
    )
{

    if ( ConvertSecurityDescriptorToStringSecurityDescriptorW(
                pSD,
                SDDL_REVISION_1,
                SecurityInfo,
                ppwszTextSD,
                pcTextSize
                ) ) {

        return(ERROR_SUCCESS);

    } else {

        return(GetLastError());
    }

}


DWORD
ScepGetSecurityInformation(
    IN PSECURITY_DESCRIPTOR pSD,
    OUT SECURITY_INFORMATION *pSeInfo
    )
{
    PSID Owner = NULL, Group = NULL;
    BOOLEAN Defaulted;
    NTSTATUS Status;
    SECURITY_DESCRIPTOR_CONTROL ControlCode=0;
    ULONG Revision;


    if ( !pSeInfo ) {
        return(ERROR_INVALID_PARAMETER);
    }

    *pSeInfo = 0;

    if ( !pSD ) {
        return(ERROR_SUCCESS);
    }

    Status = RtlGetOwnerSecurityDescriptor( pSD, &Owner, &Defaulted );

    if ( NT_SUCCESS( Status ) ) {

        if ( Owner && !Defaulted ) {
            *pSeInfo |= OWNER_SECURITY_INFORMATION;
        }

        Status = RtlGetGroupSecurityDescriptor( pSD, &Group, &Defaulted );

    }

    if ( NT_SUCCESS( Status ) ) {

        if ( Group && !Defaulted ) {
            *pSeInfo |= GROUP_SECURITY_INFORMATION;
        }

        Status = RtlGetControlSecurityDescriptor ( pSD, &ControlCode, &Revision);
    }

    if ( NT_SUCCESS( Status ) ) {

        if ( ControlCode & SE_DACL_PRESENT ) {
            *pSeInfo |= DACL_SECURITY_INFORMATION;
        }

        if ( ControlCode & SE_SACL_PRESENT ) {
            *pSeInfo |= SACL_SECURITY_INFORMATION;
        }

    } else {

        *pSeInfo = 0;
    }

    return( RtlNtStatusToDosError(Status) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\scerpc\client\cgenericlogger.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    cgenericlogger.cpp

Abstract:

    This file contains base class definitions for logging RSOP security extension data to WMI.

Author:

    Vishnu Patankar    (VishnuP)  7-April-2000

Environment:

    User Mode - Win32

Revision History:


--*/

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Includes                                                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////
#include "CGenericLogger.h"
#include "scedllrc.h"

extern HINSTANCE MyModuleHandle;


/////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CGenericLogger::CGenericLogger(IWbemServices *pNamespace, PWSTR pwszGPOName, const PWSTR pwszSOMID)
      : m_bInitialized(FALSE),
      m_pHr(WBEM_S_NO_ERROR),
      m_pNamespace(NULL),
      m_pClassForSpawning(NULL),
      m_pObj(NULL)

{
    m_pNamespace = pNamespace;

    m_pHr = WBEM_S_NO_ERROR;

    m_xbstrId =  L"Id";
    if (!m_xbstrId) {m_pHr = WBEM_E_OUT_OF_MEMORY; goto done;}

    m_xbstrGPO =  L"GPOID";
    if (!m_xbstrGPO) {m_pHr = WBEM_E_OUT_OF_MEMORY; goto done;}

    m_xbstrSOM =  L"SOMID";
    if (!m_xbstrSOM) {m_pHr = WBEM_E_OUT_OF_MEMORY; goto done;}

    m_xbstrPrecedence =  L"precedence";
    if (!m_xbstrPrecedence) {m_pHr = WBEM_E_OUT_OF_MEMORY; goto done;}

    m_xbstrStatus =  L"Status";
    if (!m_xbstrStatus) {m_pHr = WBEM_E_OUT_OF_MEMORY; goto done;}

    m_xbstrErrorCode =  L"ErrorCode";
    if (!m_xbstrErrorCode) {m_pHr = WBEM_E_OUT_OF_MEMORY; goto done;}

    m_xbstrCanonicalGPOName = pwszGPOName;
    if (!m_xbstrCanonicalGPOName) {m_pHr = WBEM_E_OUT_OF_MEMORY; goto done;}

    m_xbstrSOMID =  pwszSOMID;
    if (!m_xbstrSOMID) {m_pHr = WBEM_E_OUT_OF_MEMORY; goto done;}

    done:

        return;
}

CGenericLogger::~CGenericLogger()
{

    // Free class spawner instance and object instance (if need be)

    if (m_pObj) {
        m_pHr = m_pObj->Release();
        m_pObj = NULL;
        if ( FAILED(m_pHr) ) goto done;
    }

    if (m_pClassForSpawning) {
        m_pHr = m_pClassForSpawning->Release();
        m_pClassForSpawning = NULL;
        if ( FAILED(m_pHr) ) goto done;
    }

    done:

    m_pHr = WBEM_S_NO_ERROR;

    m_pNamespace = NULL;

    //doesn't matter if we cannot release

    m_bInitialized = FALSE;

    return;

}

/////////////////////////////////////////////////////////////////////
// Set error method
//////////////////////////////////////////////////////////////////////
void CGenericLogger::SetError(HRESULT   hr){

    m_pHr = hr;

}

/////////////////////////////////////////////////////////////////////
// Get error method
//////////////////////////////////////////////////////////////////////
HRESULT CGenericLogger::GetError(){

    return m_pHr;

}
/////////////////////////////////////////////////////////////////////
// Log properties common for all settings
//////////////////////////////////////////////////////////////////////

HRESULT CGenericLogger::PutGenericProperties(){

    GUID    guid;
    WCHAR   pwszGuid[MAX_GUID_STRING_LEN];


    // create unique guid for this instance

    m_pHr = CoCreateGuid( &guid );
    if ( FAILED(m_pHr) ) goto done;

    if (SCEP_NULL_GUID(guid)) goto done;

    SCEP_GUID_TO_STRING(guid, pwszGuid);

    // log generic properties

    m_pHr = PutProperty(m_pObj, m_xbstrId, pwszGuid);
    if ( FAILED(m_pHr) ) goto done;

    m_pHr = PutProperty(m_pObj, m_xbstrGPO, m_xbstrCanonicalGPOName);
    if ( FAILED(m_pHr) ) goto done;

    m_pHr = PutProperty(m_pObj, m_xbstrSOM, m_xbstrSOMID);
    if ( FAILED(m_pHr) ) goto done;

    m_pHr = PutProperty(m_pObj, m_xbstrStatus, (int)0);
    if ( FAILED(m_pHr) ) goto done;

    m_pHr = PutProperty(m_pObj, m_xbstrErrorCode, (int)ERROR_SUCCESS);
    if ( FAILED(m_pHr) ) goto done;

    done:

    return m_pHr;

}

/////////////////////////////////////////////////////////////////////
// Commit the instance to the database and free resources
//////////////////////////////////////////////////////////////////////

HRESULT CGenericLogger::PutInstAndFreeObj(){

    m_pHr = m_pNamespace->PutInstance( m_pObj, WBEM_FLAG_CREATE_OR_UPDATE, NULL, NULL );
    if ( FAILED(m_pHr) ) goto done;


done:

    m_pHr = m_pObj->Release();
    m_pObj = NULL;

    return m_pHr;
}

/////////////////////////////////////////////////////////////////////
// Get
// (a) an instance of spawner class (if needed) and
// (b) an instance of a schema object from (a)
//////////////////////////////////////////////////////////////////////

HRESULT CGenericLogger::SpawnAnInstance(IWbemClassObject **pObj)
{
    if(!m_pClassForSpawning){

        if(FAILED(m_pHr = m_pNamespace->GetObject(m_xbstrClassName, 0, NULL,
            &m_pClassForSpawning, NULL))){

            *pObj = NULL;
            return m_pHr;
        }
    }

    m_pHr = m_pClassForSpawning->SpawnInstance(0, pObj);

    return m_pHr;
}

/////////////////////////////////////////////////////////////////////
// Overloaded logging functions
//////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////
// String logging
//////////////////////////////////////////////////////////////////////

HRESULT CGenericLogger::PutProperty(IWbemClassObject *pObj, const WCHAR *wcProperty, WCHAR *wcValue)
{
    BSTR bstrName = SysAllocString(wcProperty);
    if (!bstrName) {m_pHr = WBEM_E_OUT_OF_MEMORY; return m_pHr;}

    VARIANT *vp = new VARIANT;
    if (vp == NULL )  { SysFreeString(bstrName); m_pHr = WBEM_E_OUT_OF_MEMORY; return m_pHr;}
    VariantInit(vp);
    V_VT(vp) = VT_BSTR;
    V_BSTR(vp) = SysAllocString(wcValue);
    if(!V_BSTR(vp)){

        SysFreeString(bstrName);
        m_pHr = WBEM_E_OUT_OF_MEMORY;
        goto done;
    }

    if( wcValue != NULL ) {

        m_pHr = pObj->Put(bstrName, 0, vp, NULL);

        if(FAILED(m_pHr)){

            SysFreeString(bstrName);
            VariantClear(vp);
            delete vp;
            m_pHr = WBEM_E_OUT_OF_MEMORY;
            goto done;
        }

    }else m_pHr = WBEM_E_FAILED;

    SysFreeString(bstrName);
    VariantClear(vp);
    delete vp;

    done:

    return m_pHr;
}

/////////////////////////////////////////////////////////////////////
// Integer logging
//////////////////////////////////////////////////////////////////////

HRESULT CGenericLogger::PutProperty(IWbemClassObject *pObj, const WCHAR *wcProperty, int iValue)
{
    BSTR bstrName = SysAllocString(wcProperty);
    if (!bstrName) {m_pHr = WBEM_E_OUT_OF_MEMORY; return m_pHr;}


    VARIANT *pv = new VARIANT;
    if (pv == NULL )  { SysFreeString(bstrName); m_pHr = WBEM_E_OUT_OF_MEMORY; return m_pHr;}

    if(iValue != SCE_NO_VALUE){

        VariantInit(pv);
        V_VT(pv) = VT_I4;
        V_I4(pv) = iValue;

        m_pHr = pObj->Put(bstrName, 0, pv, NULL);

        VariantClear(pv);

        if(FAILED(m_pHr)){

            SysFreeString(bstrName);
            delete pv;
            if ( FAILED(m_pHr) ) goto done;
        }

    }else m_pHr = WBEM_E_FAILED;

    SysFreeString(bstrName);
    delete pv;

    done:

    return m_pHr;
}


/////////////////////////////////////////////////////////////////////
// Boolean logging
//////////////////////////////////////////////////////////////////////

HRESULT CGenericLogger::PutProperty(IWbemClassObject *pObj, const WCHAR *wcProperty, bool bValue)
{
    BSTR bstrName = SysAllocString(wcProperty);
    if (!bstrName) {m_pHr = WBEM_E_OUT_OF_MEMORY; return m_pHr;}

    VARIANT *pv = new VARIANT;
    if (pv == NULL )  { SysFreeString(bstrName); m_pHr = WBEM_E_OUT_OF_MEMORY; return m_pHr;}
    VariantInit(pv);
    V_VT(pv) = VT_BOOL;
    if(bValue) V_BOOL(pv) = VARIANT_TRUE;
    else V_BOOL(pv) = VARIANT_FALSE;

    m_pHr = pObj->Put(bstrName, 0, pv, NULL);

    SysFreeString(bstrName);
    VariantClear(pv);
    delete pv;


        return m_pHr;
}

/////////////////////////////////////////////////////////////////////
// List logging
//////////////////////////////////////////////////////////////////////

HRESULT CGenericLogger::PutProperty(IWbemClassObject *pObj, const WCHAR *wcProperty, PSCE_NAME_LIST strList)
{

    long lCount=0;
    PSCE_NAME_LIST pTemp;

    for ( pTemp = strList; pTemp != NULL; pTemp=pTemp->Next,lCount++);
    if ( lCount == 0 ) return m_pHr; // nothing to save

    BSTR bstrName = SysAllocString(wcProperty);
    if (!bstrName) {m_pHr = WBEM_E_OUT_OF_MEMORY; goto done;}

    VARIANT v;
    SAFEARRAYBOUND sbArrayBounds ;

    sbArrayBounds.cElements = lCount;
    sbArrayBounds.lLbound = 0;

    if(V_ARRAY(&v) = SafeArrayCreate(VT_BSTR, 1, &sbArrayBounds)){

        V_VT(&v) = VT_BSTR | VT_ARRAY ;

        BSTR bstrVal;
        long j;

        //get names in the SCE_NAME_LIST structure into the VARIANT
        for(j=0, pTemp = strList; j < lCount && pTemp != NULL ; j++, pTemp=pTemp->Next){

            bstrVal = SysAllocString(pTemp->Name);
            SafeArrayPutElement(V_ARRAY(&v), &j, bstrVal);
            SysFreeString(bstrVal);
        }

        m_pHr = pObj->Put(bstrName, 0, &v, NULL);

        if ( FAILED(m_pHr) ) {
            SysFreeString(bstrName);
            VariantClear(&v);
            if ( FAILED(m_pHr) ) goto done;
        }

    }else m_pHr = WBEM_E_FAILED;

    SysFreeString(bstrName);
    VariantClear(&v);

    done:

    return m_pHr;
}


/////////////////////////////////////////////////////////////////////
// Get method
//////////////////////////////////////////////////////////////////////

HRESULT CGenericLogger::GetProperty(IWbemClassObject *pObj, const WCHAR *wcProperty, int *piValue)
{
    VARIANT v;

    BSTR bstrProp = SysAllocString(wcProperty);
    if(!bstrProp) {m_pHr = WBEM_E_OUT_OF_MEMORY; goto done;}

    VariantInit(&v);

    if(SUCCEEDED(m_pHr = pObj->Get(bstrProp, 0, &v, NULL, NULL))){

        if(V_VT(&v) == VT_I4) *piValue = V_I4(&v);
        else if(V_VT(&v) == VT_EMPTY || V_VT(&v) == VT_NULL ) m_pHr = WBEM_S_RESET_TO_DEFAULT;
        else *piValue = 0;
    }

    SysFreeString(bstrProp);
    VariantClear(&v);

    done:

    return m_pHr;
}


HRESULT DeleteInstances( WCHAR *pwszClass, IWbemServices *pWbemServices )
{
    HRESULT hr = WBEM_E_OUT_OF_MEMORY;

    try {

        IEnumWbemClassObject *pEnum = NULL;

        XBStr xbstrClass( pwszClass );
        if ( !xbstrClass )
            return WBEM_E_OUT_OF_MEMORY;

        hr = pWbemServices->CreateInstanceEnum( xbstrClass,
                                                WBEM_FLAG_SHALLOW,
                                                NULL,
                                                &pEnum );
        if ( FAILED(hr) )
            return hr;

        XInterface<IEnumWbemClassObject> xEnum( pEnum );

        XBStr xbstrPath( L"__PATH" );
        if ( !xbstrPath )
            return WBEM_E_OUT_OF_MEMORY;

        IWbemClassObject *pInstance = NULL;
        ULONG ulReturned = 1;
        LONG TIMEOUT = -1;

        while ( ulReturned == 1 ) {

            hr = pEnum->Next( TIMEOUT,
                              1,
                              &pInstance,
                              &ulReturned );
            if ( hr == WBEM_S_NO_ERROR && ulReturned == 1 ) {

                XInterface<IWbemClassObject> xInstance( pInstance );

                VARIANT var;
                VariantInit( &var );

                hr = pInstance->Get( xbstrPath,
                                     0L,
                                     &var,
                                     NULL,
                                     NULL );

                if ( FAILED(hr) )
                    return hr;

                hr = pWbemServices->DeleteInstance( var.bstrVal,
                                                    0L,
                                                    NULL,
                                                    NULL );
                VariantClear( &var );

                if ( FAILED(hr) )
                    return hr;


            }
        }
    } catch (...) {
        // do nothing
    }


    return hr;
}


/////////////////////////////////////////////////////////////////////
// Error code conversion routines
//////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////
// ESCAPE to DOS
//////////////////////////////////////////////////////////////////////
/*
DWORD
ScepSceStatusToDosError(
    IN SCESTATUS SceStatus
    )
{
    switch(SceStatus) {

    case SCESTATUS_SUCCESS:
        return(NO_ERROR);

    case SCESTATUS_OTHER_ERROR:
        return(ERROR_EXTENDED_ERROR);

    case SCESTATUS_INVALID_PARAMETER:
        return(ERROR_INVALID_PARAMETER);

    case SCESTATUS_RECORD_NOT_FOUND:
        return(ERROR_NO_MORE_ITEMS);

    case SCESTATUS_NO_MAPPING:
        return(ERROR_NONE_MAPPED);

    case SCESTATUS_TRUST_FAIL:
        return(ERROR_TRUSTED_DOMAIN_FAILURE);

    case SCESTATUS_INVALID_DATA:
        return(ERROR_INVALID_DATA);

    case SCESTATUS_OBJECT_EXIST:
        return(ERROR_FILE_EXISTS);

    case SCESTATUS_BUFFER_TOO_SMALL:
        return(ERROR_INSUFFICIENT_BUFFER);

    case SCESTATUS_PROFILE_NOT_FOUND:
        return(ERROR_FILE_NOT_FOUND);

    case SCESTATUS_BAD_FORMAT:
        return(ERROR_BAD_FORMAT);

    case SCESTATUS_NOT_ENOUGH_RESOURCE:
        return(ERROR_NOT_ENOUGH_MEMORY);

    case SCESTATUS_ACCESS_DENIED:
        return(ERROR_ACCESS_DENIED);

    case SCESTATUS_CANT_DELETE:
        return(ERROR_CURRENT_DIRECTORY);

    case SCESTATUS_PREFIX_OVERFLOW:
        return(ERROR_BUFFER_OVERFLOW);

    case SCESTATUS_ALREADY_RUNNING:
        return(ERROR_SERVICE_ALREADY_RUNNING);
    case SCESTATUS_SERVICE_NOT_SUPPORT:
        return(ERROR_NOT_SUPPORTED);

    case SCESTATUS_MOD_NOT_FOUND:
        return(ERROR_MOD_NOT_FOUND);

    case SCESTATUS_EXCEPTION_IN_SERVER:
        return(ERROR_EXCEPTION_IN_SERVICE);

    default:
        return(ERROR_EXTENDED_ERROR);
    }
}
  */

/////////////////////////////////////////////////////////////////////
// DOS to WBEM
//////////////////////////////////////////////////////////////////////

HRESULT
ScepDosErrorToWbemError(
    IN DWORD rc
    )
{
    switch(rc) {

    case NO_ERROR:
        return(WBEM_S_NO_ERROR);

    case ERROR_INVALID_PARAMETER:
        return(WBEM_E_INVALID_PARAMETER);

    case ERROR_NO_MORE_ITEMS:
    case ERROR_NONE_MAPPED:
    case ERROR_NOT_FOUND:
    case ERROR_FILE_NOT_FOUND:
    case ERROR_MOD_NOT_FOUND:
        return(WBEM_E_NOT_FOUND);

    case ERROR_INVALID_DATA:
    case ERROR_BAD_FORMAT:
        return(WBEM_E_INVALID_CONTEXT);

    case ERROR_FILE_EXISTS:
    case ERROR_SERVICE_ALREADY_RUNNING:
        return(WBEM_S_ALREADY_EXISTS);

    case ERROR_INSUFFICIENT_BUFFER:
        return(WBEM_E_BUFFER_TOO_SMALL);

    case ERROR_NOT_ENOUGH_MEMORY:
        return(WBEM_E_OUT_OF_MEMORY);

    case ERROR_ACCESS_DENIED:
        return(WBEM_E_ACCESS_DENIED);

    case ERROR_BUFFER_OVERFLOW:
        return(WBEM_E_QUEUE_OVERFLOW);

    case ERROR_NOT_SUPPORTED:
        return(WBEM_E_NOT_SUPPORTED);

    case ERROR_NO_MATCH:
        return(WBEM_E_INVALID_CLASS);

    default:
        return(WBEM_E_FAILED);
    }
}

/////////////////////////////////////////////////////////////////////
// WBEM to DOS
//////////////////////////////////////////////////////////////////////

DWORD
ScepWbemErrorToDosError(
    IN HRESULT m_pHr
    )
{
    switch(m_pHr) {

    case WBEM_S_NO_ERROR:
    // this is a boolean used while enumeration etc. - so really a tautology check (not a real error)
    case WBEM_S_FALSE:
        return(NO_ERROR);

    case WBEM_E_INVALID_PARAMETER:
        return(ERROR_INVALID_PARAMETER);

    case WBEM_E_INVALID_CLASS:
        return(ERROR_NO_MATCH);

    case WBEM_E_NOT_FOUND:
        return(ERROR_NOT_FOUND);

    case WBEM_E_INVALID_CONTEXT:
        return(ERROR_BAD_FORMAT);

    case WBEM_S_ALREADY_EXISTS:
        return(ERROR_FILE_EXISTS);

    case WBEM_E_BUFFER_TOO_SMALL:
        return(ERROR_INSUFFICIENT_BUFFER);

    case WBEM_E_OUT_OF_MEMORY:
        return(ERROR_NOT_ENOUGH_MEMORY);

    case WBEM_E_ACCESS_DENIED:
        return(ERROR_ACCESS_DENIED);

    case WBEM_E_QUEUE_OVERFLOW:
        return(ERROR_BUFFER_OVERFLOW);

    case WBEM_E_NOT_SUPPORTED:
        return(ERROR_NOT_SUPPORTED);

    default:
        return(ERROR_INVALID_PARAMETER);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\scerpc\client\clntutil.cpp ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    common.cpp

Abstract:

    Shared APIs

Author:

    Jin Huang

Revision History:

    jinhuang        23-Jan-1998   merged from multiple modules

--*/
#include "headers.h"
#include <ntrpcp.h>
#include "clntutil.h"
#include <ntlsa.h>

PVOID theCallBack = NULL;
HANDLE hCallbackWnd=NULL;
DWORD CallbackType = 0;

#define g_ServiceName   L"scesrv"


SCESTATUS
ScepSetCallback(
    IN PVOID pCallback OPTIONAL,
    IN HANDLE hWnd OPTIONAL,
    IN DWORD Type
    )
{
    theCallBack = pCallback;
    hCallbackWnd = hWnd;
    CallbackType = Type;

    return(SCESTATUS_SUCCESS);
}


NTSTATUS
ScepBindSecureRpc(
    IN  LPWSTR               servername,
    IN  LPWSTR               servicename,
    IN  LPWSTR               networkoptions,
    OUT RPC_BINDING_HANDLE   * pBindingHandle
    )
/*
Routine Description:

    This routine binds to the servicename on the server. A binding handle is
    returned if successful.

    If the service on the server is not available, this client will try to
    start that service then bind to it.

Arguments:

    servername  - the system name where SCE server service is running on

    servicename - the pipe (port) name of SCE server

    networkoptions  - the network protocol options

    pBindingHandle - the binding handle to output

Return Value:

    NTSTATUS
*/
{

    if ( !servicename || !pBindingHandle ) {
        return(STATUS_INVALID_PARAMETER);
    }

    //
    // activate the server (if already started, just return)
    //


    NTSTATUS NtStatus = RpcpBindRpc(
                            servername,
                            servicename,
                            networkoptions,
                            pBindingHandle
                            );


    if ( NT_SUCCESS(NtStatus) && *pBindingHandle ){

        //
        // set authentication info to use secure RPC
        // if can't set authentication, ignore the error
        //

        (VOID) RpcBindingSetAuthInfo(
                    *pBindingHandle,
                    NULL,
                    RPC_C_AUTHN_LEVEL_DEFAULT,
                    RPC_C_AUTHN_WINNT,
                    NULL,
                    RPC_C_AUTHZ_DCE
                    );
    }

    return(NtStatus);

}


NTSTATUS
ScepBindRpc(
    IN  LPWSTR               servername,
    IN  LPWSTR               servicename,
    IN  LPWSTR               networkoptions,
    OUT RPC_BINDING_HANDLE   * pBindingHandle
    )
/*
Routine Description:

    This routine binds to the servicename on the server. A binding handle is
    returned if successful.

    If the service on the server is not available, this client will try to
    start that service then bind to it.

Arguments:

    servername  - the system name where SCE server service is running on

    servicename - the pipe (port) name of SCE server

    networkoptions  - the network protocol options

    pBindingHandle - the binding handle to output

Return Value:

    NTSTATUS
*/
{

    if ( !servicename || !pBindingHandle ) {
        return(STATUS_INVALID_PARAMETER);
    }

    //
    // activate the server (if already started, just return)
    //


    return( RpcpBindRpc(
                servername,
                servicename,
                networkoptions,
                pBindingHandle
                ) );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\scerpc\client\cgenericlogger.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    cgenericlogger.h

Abstract:

    This file contains base class prototypes for logging RSOP security extension data to WMI.

Author:

    Vishnu Patankar    (VishnuP)  7-April-2000

Environment:

    User Mode - Win32

Revision History:


--*/

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Includes                                                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#if !defined _generic_logger_
#define _generic_logger_

#include "headers.h"
#include "smartptr.h"
#include <cfgmgr32.h>
#include <ole2.h>
#include <wininet.h>
#include <wbemidl.h>

#ifndef Thread
#define Thread  __declspec( thread )
#endif

extern IWbemServices *tg_pWbemServices;

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Private defines                                                           //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#define SCEP_GUID_TO_STRING(guid, szValue )\
              wsprintf( szValue,\
              TEXT("{%08lX-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X}"),\
              guid.Data1,\
              guid.Data2,\
              guid.Data3,\
              guid.Data4[0], guid.Data4[1],\
              guid.Data4[2], guid.Data4[3],\
              guid.Data4[4], guid.Data4[5],\
              guid.Data4[6], guid.Data4[7] )

#define SCEP_NULL_GUID(guid)\
             ((guid.Data1 == 0)   &&\
             (guid.Data2 == 0)    &&\
             (guid.Data3 == 0)    &&\
             (guid.Data4[0] == 0) &&\
             (guid.Data4[1] == 0) &&\
             (guid.Data4[2] == 0) &&\
             (guid.Data4[3] == 0) &&\
             (guid.Data4[4] == 0) &&\
             (guid.Data4[5] == 0) &&\
             (guid.Data4[6] == 0) &&\
             (guid.Data4[7] == 0) )

/////////////////////////////////////////////////////////////////////
// Base logger class prototype
//////////////////////////////////////////////////////////////////////

class CGenericLogger
{
public:
    CGenericLogger(IWbemServices *pNamespace, PWSTR pwszGPOName, const PWSTR pwszSOMID);
    virtual ~CGenericLogger();
    IWbemClassObject *m_pObj;
    IEnumWbemClassObject * m_pEnum;
//protected:

    HRESULT PutGenericProperties();
    HRESULT PutInstAndFreeObj();

    // Overloaded put methods
    HRESULT PutProperty(IWbemClassObject *pObj, const WCHAR *wcProperty, WCHAR *wcValue);
    HRESULT PutProperty(IWbemClassObject *pObj, const WCHAR *wcProperty, int iValue);
    HRESULT PutProperty(IWbemClassObject *pObj, const WCHAR *wcProperty, bool bValue);
    HRESULT PutProperty(IWbemClassObject *pObj, const WCHAR *wcProperty, PSCE_NAME_LIST strList);
    HRESULT PutProperty(IWbemClassObject *pObj, const WCHAR *wcProperty, WCHAR *mszValue, CIMTYPE cimtype);

    // Overloaded get methods
    HRESULT GetProperty(IWbemClassObject *pObj, const WCHAR *wcProperty, int *piValue);

    // Method to get an instance to populate
    HRESULT SpawnAnInstance(IWbemClassObject **pObj);

    // Method to set/get error code
    void SetError(HRESULT   hr);
    HRESULT GetError();

    // Data members unique to logger instance
    IWbemServices *m_pNamespace;
    IWbemClassObject *m_pClassForSpawning;

    // Generic schema property name placeholders
    // Use smart ptrs for implicit memory mgmt (even if exceptions thrown)

    XBStr   m_xbstrClassName;
    XBStr   m_xbstrId;
    XBStr   m_xbstrPrecedence;
    XBStr   m_xbstrGPO;
    XBStr   m_xbstrSOM;
    XBStr   m_xbstrStatus;
    XBStr   m_xbstrErrorCode;

    // Value placeholders for generic schema properties
    XBStr   m_xbstrCanonicalGPOName;
    XBStr   m_xbstrSOMID;
    XBStr   m_xbstrIdValue;

    // set to TRUE by highest derived class if all constructors completely constructed
    BOOL    m_bInitialized;

    // error code used to communicate out of memory errors etc.
    HRESULT   m_pHr;


};

// Method to clear all instances of a particular class in the namespace
HRESULT DeleteInstances(
    WCHAR *pwszClass,
    IWbemServices *pWbemServices
    );

/////////////////////////////////////////////////////////////////////
// Error code conversion routines
//////////////////////////////////////////////////////////////////////

DWORD
ScepSceStatusToDosError(
    IN SCESTATUS SceStatus
    );


HRESULT
ScepDosErrorToWbemError(
    IN DWORD rc
    );

DWORD
ScepWbemErrorToDosError(
    IN HRESULT hr
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\scerpc\client\logger.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    logger.cpp (cgenericlogger.h derivation)

Abstract:

    This file contains derived class definitions for logging RSOP security extension data to WMI.
    There is one class defined for each schema RSOP security extension class (see .mof file).

Author:

    Vishnu Patankar    (VishnuP)  7-April-2000

Environment:

    User Mode - Win32

Revision History:


--*/

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Includes                                                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include "logger.h"
#include "kerberos.h"

#ifndef Thread
#define Thread  __declspec( thread )
#endif

//extern void Thread *tg_pWbemServices;

/////////////////////////////////////////////////////////////////////
// Log class definition for
// RSOP_SecuritySettingNumeric schema class
//////////////////////////////////////////////////////////////////////

RSOP_SecuritySettingNumericLogger::RSOP_SecuritySettingNumericLogger(IWbemServices *pNamespace,
                                   PWSTR pwszGPOName, const PWSTR pwszSOMID):CGenericLogger(pNamespace, pwszGPOName, pwszSOMID)
{
    m_pHr = WBEM_S_NO_ERROR;

    m_xbstrClassName = L"RSOP_SecuritySettingNumeric";
    if (!m_xbstrClassName) {m_pHr = WBEM_E_OUT_OF_MEMORY; goto done;}

    m_xbstrKeyName = L"KeyName";
    if (!m_xbstrKeyName) {m_pHr = WBEM_E_OUT_OF_MEMORY; goto done;}

    m_xbstrSetting = L"Setting";
    if (!m_xbstrSetting) {m_pHr = WBEM_E_OUT_OF_MEMORY; goto done;}

    m_bInitialized = TRUE;

    done:

        return;
}

RSOP_SecuritySettingNumericLogger::~RSOP_SecuritySettingNumericLogger()
{

}

HRESULT
RSOP_SecuritySettingNumericLogger::Log( WCHAR *wcKeyName, DWORD  dwValue, DWORD  dwPrecedence){

    m_pHr = WBEM_S_NO_ERROR;

    m_pHr = SpawnAnInstance(&m_pObj);
    if (FAILED(m_pHr)) goto done;

    m_pHr = PutGenericProperties();
    if (FAILED(m_pHr)) goto done;

    m_pHr = PutProperty(m_pObj, m_xbstrKeyName, wcKeyName);
    if (FAILED(m_pHr)) goto done;

    m_pHr = PutProperty(m_pObj, m_xbstrSetting, (int)dwValue);
    if (FAILED(m_pHr)) goto done;

    m_pHr = PutProperty(m_pObj, m_xbstrPrecedence, (int)dwPrecedence);
    if (FAILED(m_pHr)) goto done;

    m_pHr = PutInstAndFreeObj();
    if (FAILED(m_pHr)) goto done;

    done:

        return m_pHr;
}

/////////////////////////////////////////////////////////////////////
// Log class definition for
// RSOP_SecuritySettingBoolean schema class
//////////////////////////////////////////////////////////////////////

RSOP_SecuritySettingBooleanLogger::RSOP_SecuritySettingBooleanLogger(IWbemServices *pNamespace,
                                   PWSTR pwszGPOName, const PWSTR pwszSOMID):CGenericLogger(pNamespace, pwszGPOName, pwszSOMID)
{
    m_pHr = WBEM_S_NO_ERROR;

    m_xbstrClassName = L"RSOP_SecuritySettingBoolean";
    if (!m_xbstrClassName) {m_pHr = WBEM_E_OUT_OF_MEMORY; goto done;}

    m_xbstrKeyName = L"KeyName";
    if (!m_xbstrKeyName) {m_pHr = WBEM_E_OUT_OF_MEMORY; goto done;}

    m_xbstrSetting = L"Setting";
    if (!m_xbstrSetting) {m_pHr = WBEM_E_OUT_OF_MEMORY; goto done;}

    m_bInitialized = TRUE;

    done:

        return;
}

RSOP_SecuritySettingBooleanLogger::~RSOP_SecuritySettingBooleanLogger()
{



}

HRESULT
RSOP_SecuritySettingBooleanLogger::Log( WCHAR *wcKeyName, DWORD  dwValue, DWORD  dwPrecedence){

    m_pHr = WBEM_S_NO_ERROR;

    m_pHr = SpawnAnInstance(&m_pObj);
    if (FAILED(m_pHr)) goto done;

    m_pHr = PutGenericProperties();
    if (FAILED(m_pHr)) goto done;

    m_pHr = PutProperty(m_pObj, m_xbstrKeyName, wcKeyName);
    if (FAILED(m_pHr)) goto done;

    m_pHr = PutProperty(m_pObj, m_xbstrSetting, (BOOL)(dwValue ? TRUE : FALSE));
    if (FAILED(m_pHr)) goto done;

    m_pHr = PutProperty(m_pObj, m_xbstrPrecedence, (int)dwPrecedence);
    if (FAILED(m_pHr)) goto done;

    m_pHr = PutInstAndFreeObj();
    if (FAILED(m_pHr)) goto done;

    done:

        return m_pHr;
}



/////////////////////////////////////////////////////////////////////
// Log class definition for
// RSOP_SecuritySettingString schema class
//////////////////////////////////////////////////////////////////////

RSOP_SecuritySettingStringLogger::RSOP_SecuritySettingStringLogger(IWbemServices *pNamespace,
                                   PWSTR pwszGPOName, const PWSTR pwszSOMID):CGenericLogger(pNamespace, pwszGPOName, pwszSOMID)
{
    m_pHr = WBEM_S_NO_ERROR;

    m_xbstrClassName = L"RSOP_SecuritySettingString";
    if (!m_xbstrClassName) {m_pHr = WBEM_E_OUT_OF_MEMORY; goto done;}

    m_xbstrKeyName = L"KeyName";
    if (!m_xbstrKeyName) {m_pHr = WBEM_E_OUT_OF_MEMORY; goto done;}

    m_xbstrSetting = L"Setting";
    if (!m_xbstrSetting) {m_pHr = WBEM_E_OUT_OF_MEMORY; goto done;}

    m_bInitialized = TRUE;

    done:

        return;
}

RSOP_SecuritySettingStringLogger::~RSOP_SecuritySettingStringLogger()
{


}

HRESULT
RSOP_SecuritySettingStringLogger::Log( WCHAR *wcKeyName, PWSTR  pwszValue, DWORD  dwPrecedence){

    m_pHr = WBEM_S_NO_ERROR;

    m_pHr = SpawnAnInstance(&m_pObj);
    if (FAILED(m_pHr)) goto done;

    m_pHr = PutGenericProperties();
    if (FAILED(m_pHr)) goto done;

    m_pHr = PutProperty(m_pObj, m_xbstrKeyName, wcKeyName);
    if (FAILED(m_pHr)) goto done;

    m_pHr = PutProperty(m_pObj, m_xbstrSetting, pwszValue);
    if (FAILED(m_pHr)) goto done;

    m_pHr = PutProperty(m_pObj, m_xbstrPrecedence, (int)dwPrecedence);
    if (FAILED(m_pHr)) goto done;

    m_pHr = PutInstAndFreeObj();
    if (FAILED(m_pHr)) goto done;

    done:

        return m_pHr;
}

/////////////////////////////////////////////////////////////////////
// Log class definition for
// RSOP_AuditPolicy schema class
//////////////////////////////////////////////////////////////////////

RSOP_AuditPolicyLogger::RSOP_AuditPolicyLogger(IWbemServices *pNamespace,
                                   PWSTR pwszGPOName, const PWSTR pwszSOMID):CGenericLogger(pNamespace, pwszGPOName, pwszSOMID)
{
    m_pHr = WBEM_S_NO_ERROR;

    m_xbstrClassName = L"RSOP_AuditPolicy";
    if (!m_xbstrClassName) {m_pHr = WBEM_E_OUT_OF_MEMORY; goto done;}

    m_xbstrCategory = L"Category";
    if (!m_xbstrCategory) {m_pHr = WBEM_E_OUT_OF_MEMORY; goto done;}

    m_xbstrSuccess = L"Success";
    if (!m_xbstrSuccess) {m_pHr = WBEM_E_OUT_OF_MEMORY; goto done;}

    m_xbstrFailure = L"Failure";
    if (!m_xbstrFailure) {m_pHr = WBEM_E_OUT_OF_MEMORY; goto done;}

    m_bInitialized = TRUE;

    done:

        return;
}

RSOP_AuditPolicyLogger::~RSOP_AuditPolicyLogger()
{


}

HRESULT
RSOP_AuditPolicyLogger::Log( WCHAR *wcCategory, DWORD  dwValue, DWORD  dwPrecedence){

    m_pHr = WBEM_S_NO_ERROR;

    m_pHr = SpawnAnInstance(&m_pObj);
    if (FAILED(m_pHr)) goto done;

    m_pHr = PutGenericProperties();
    if (FAILED(m_pHr)) goto done;

    m_pHr = PutProperty(m_pObj, m_xbstrCategory, wcCategory);
    if (FAILED(m_pHr)) goto done;

    m_pHr = PutProperty(m_pObj, m_xbstrSuccess, (BOOL)(dwValue & POLICY_AUDIT_EVENT_SUCCESS ? TRUE : FALSE));
    if (FAILED(m_pHr)) goto done;

    m_pHr = PutProperty(m_pObj, m_xbstrFailure, (BOOL)(dwValue & POLICY_AUDIT_EVENT_FAILURE ? TRUE : FALSE));
    if (FAILED(m_pHr)) goto done;

    m_pHr = PutProperty(m_pObj, m_xbstrPrecedence, (int)dwPrecedence);
    if (FAILED(m_pHr)) goto done;

    m_pHr = PutInstAndFreeObj();
    if (FAILED(m_pHr)) goto done;

    done:

        return m_pHr;
}

/////////////////////////////////////////////////////////////////////
// Log class definition for
// RSOP_SecurityEventLogSettingNumeric schema class
//////////////////////////////////////////////////////////////////////

RSOP_SecurityEventLogSettingNumericLogger::RSOP_SecurityEventLogSettingNumericLogger(IWbemServices *pNamespace,
                                   PWSTR pwszGPOName, const PWSTR pwszSOMID):CGenericLogger(pNamespace, pwszGPOName, pwszSOMID)
{
    m_pHr = WBEM_S_NO_ERROR;

    m_xbstrClassName = L"RSOP_SecurityEventLogSettingNumeric";
    if (!m_xbstrClassName) {m_pHr = WBEM_E_OUT_OF_MEMORY; goto done;}

    m_xbstrType = L"Type";
    if (!m_xbstrType) {m_pHr = WBEM_E_OUT_OF_MEMORY; goto done;}

    m_xbstrKeyName = L"KeyName";
    if (!m_xbstrKeyName) {m_pHr = WBEM_E_OUT_OF_MEMORY; goto done;}

    m_xbstrSetting = L"Setting";
    if (!m_xbstrSetting) {m_pHr = WBEM_E_OUT_OF_MEMORY; goto done;}

    m_bInitialized = TRUE;

    done:

        return;
}

RSOP_SecurityEventLogSettingNumericLogger::~RSOP_SecurityEventLogSettingNumericLogger()
{


}

HRESULT
RSOP_SecurityEventLogSettingNumericLogger::Log( WCHAR *wcKeyName, PWSTR  pwszType, DWORD  dwValue, DWORD  dwPrecedence){

    m_pHr = WBEM_S_NO_ERROR;

    m_pHr = SpawnAnInstance(&m_pObj);
    if (FAILED(m_pHr)) goto done;

    m_pHr = PutGenericProperties();
    if (FAILED(m_pHr)) goto done;

    m_pHr = PutProperty(m_pObj, m_xbstrKeyName, wcKeyName);
    if (FAILED(m_pHr)) goto done;

    m_pHr = PutProperty(m_pObj, m_xbstrType, pwszType);
    if (FAILED(m_pHr)) goto done;

    m_pHr = PutProperty(m_pObj, m_xbstrSetting, (int)dwValue);
    if (FAILED(m_pHr)) goto done;

    m_pHr = PutProperty(m_pObj, m_xbstrPrecedence, (int)dwPrecedence);
    if (FAILED(m_pHr)) goto done;

    m_pHr = PutInstAndFreeObj();
    if (FAILED(m_pHr)) goto done;

    done:

        return m_pHr;
}


/////////////////////////////////////////////////////////////////////
// Log class definition for
// RSOP_SecurityEventLogSettingBoolean schema class
//////////////////////////////////////////////////////////////////////

RSOP_SecurityEventLogSettingBooleanLogger::RSOP_SecurityEventLogSettingBooleanLogger(IWbemServices *pNamespace,
                                   PWSTR pwszGPOName, const PWSTR pwszSOMID):CGenericLogger(pNamespace, pwszGPOName, pwszSOMID)
{
    m_pHr = WBEM_S_NO_ERROR;

    m_xbstrClassName = L"RSOP_SecurityEventLogSettingBoolean";
    if (!m_xbstrClassName) {m_pHr = WBEM_E_OUT_OF_MEMORY; goto done;}

    m_xbstrType = L"Type";
    if (!m_xbstrType) {m_pHr = WBEM_E_OUT_OF_MEMORY; goto done;}

    m_xbstrKeyName = L"KeyName";
    if (!m_xbstrKeyName) {m_pHr = WBEM_E_OUT_OF_MEMORY; goto done;}

    m_xbstrSetting = L"Setting";
    if (!m_xbstrSetting) {m_pHr = WBEM_E_OUT_OF_MEMORY; goto done;}

    m_bInitialized = TRUE;

    done:

        return;
}

RSOP_SecurityEventLogSettingBooleanLogger::~RSOP_SecurityEventLogSettingBooleanLogger()
{


}

HRESULT
RSOP_SecurityEventLogSettingBooleanLogger::Log( WCHAR *wcKeyName, PWSTR  pwszType, DWORD  dwValue, DWORD  dwPrecedence){

    m_pHr = WBEM_S_NO_ERROR;

    m_pHr = SpawnAnInstance(&m_pObj);
    if (FAILED(m_pHr)) goto done;

    m_pHr = PutGenericProperties();
    if (FAILED(m_pHr)) goto done;

    m_pHr = PutProperty(m_pObj, m_xbstrKeyName, wcKeyName);
    if (FAILED(m_pHr)) goto done;

    m_pHr = PutProperty(m_pObj, m_xbstrType, pwszType);
    if (FAILED(m_pHr)) goto done;

    m_pHr = PutProperty(m_pObj, m_xbstrSetting, (BOOL)(dwValue ? TRUE : FALSE));
    if (FAILED(m_pHr)) goto done;

    m_pHr = PutProperty(m_pObj, m_xbstrPrecedence, (int)dwPrecedence);
    if (FAILED(m_pHr)) goto done;

    m_pHr = PutInstAndFreeObj();
    if (FAILED(m_pHr)) goto done;

    done:

        return m_pHr;
}


/////////////////////////////////////////////////////////////////////
// Log class definition for
// RSOP_RegistryValue schema class
//////////////////////////////////////////////////////////////////////

RSOP_RegistryValueLogger::RSOP_RegistryValueLogger(IWbemServices *pNamespace,
                                   PWSTR pwszGPOName, const PWSTR pwszSOMID):CGenericLogger(pNamespace, pwszGPOName, pwszSOMID)
{
    m_pHr = WBEM_S_NO_ERROR;

    m_xbstrClassName = L"RSOP_RegistryValue";
    if (!m_xbstrClassName) {m_pHr = WBEM_E_OUT_OF_MEMORY; goto done;}

    m_xbstrType = L"Type";
    if (!m_xbstrType) {m_pHr = WBEM_E_OUT_OF_MEMORY; goto done;}

    m_xbstrPath = L"Path";
    if (!m_xbstrPath) {m_pHr = WBEM_E_OUT_OF_MEMORY; goto done;}

    m_xbstrData = L"Data";
    if (!m_xbstrData) {m_pHr = WBEM_E_OUT_OF_MEMORY; goto done;}

    m_bInitialized = TRUE;

    done:

        return;
}

RSOP_RegistryValueLogger::~RSOP_RegistryValueLogger()
{


}

HRESULT
RSOP_RegistryValueLogger::Log( WCHAR *wcPath, DWORD  dwType, PWSTR  pwszData, DWORD  dwPrecedence){

    m_pHr = WBEM_S_NO_ERROR;

    m_pHr = SpawnAnInstance(&m_pObj);
    if (FAILED(m_pHr)) goto done;

    m_pHr = PutGenericProperties();
    if (FAILED(m_pHr)) goto done;

    m_pHr = PutProperty(m_pObj, m_xbstrPath, wcPath);
    if (FAILED(m_pHr)) goto done;

    m_pHr = PutProperty(m_pObj, m_xbstrType, (int)dwType);
    if (FAILED(m_pHr)) goto done;

    m_pHr = PutProperty(m_pObj, m_xbstrData, pwszData);
    if (FAILED(m_pHr)) goto done;

    m_pHr = PutProperty(m_pObj, m_xbstrPrecedence, (int)dwPrecedence);
    if (FAILED(m_pHr)) goto done;

    m_pHr = PutInstAndFreeObj();
    if (FAILED(m_pHr)) goto done;

    done:

        return m_pHr;
}


/////////////////////////////////////////////////////////////////////
// Log class definition for
// RSOP_UserPrivilegeRight schema class
//////////////////////////////////////////////////////////////////////

RSOP_UserPrivilegeRightLogger::RSOP_UserPrivilegeRightLogger(IWbemServices *pNamespace,
                                   PWSTR pwszGPOName, const PWSTR pwszSOMID):CGenericLogger(pNamespace, pwszGPOName, pwszSOMID)
{
    m_pHr = WBEM_S_NO_ERROR;

    m_xbstrClassName = L"RSOP_UserPrivilegeRight";
    if (!m_xbstrClassName) {m_pHr = WBEM_E_OUT_OF_MEMORY; goto done;}

    m_xbstrUserRight = L"UserRight";
    if (!m_xbstrUserRight) {m_pHr = WBEM_E_OUT_OF_MEMORY; goto done;}

    m_xbstrAccountList = L"AccountList";
    if (!m_xbstrAccountList) {m_pHr = WBEM_E_OUT_OF_MEMORY; goto done;}

    m_bInitialized = TRUE;

    done:

        return;
}

RSOP_UserPrivilegeRightLogger::~RSOP_UserPrivilegeRightLogger()
{


}

HRESULT
RSOP_UserPrivilegeRightLogger::Log( WCHAR *wcUserRight, PSCE_NAME_LIST  pList, DWORD  dwPrecedence){

    m_pHr = WBEM_S_NO_ERROR;

    m_pHr = SpawnAnInstance(&m_pObj);
    if (FAILED(m_pHr)) goto done;

    m_pHr = PutGenericProperties();
    if (FAILED(m_pHr)) goto done;

    m_pHr = PutProperty(m_pObj, m_xbstrUserRight, wcUserRight);
    if (FAILED(m_pHr)) goto done;

    m_pHr = PutProperty(m_pObj, m_xbstrAccountList, pList);
    if (FAILED(m_pHr)) goto done;

    m_pHr = PutProperty(m_pObj, m_xbstrPrecedence, (int)dwPrecedence);
    if (FAILED(m_pHr)) goto done;

    m_pHr = PutInstAndFreeObj();
    if (FAILED(m_pHr)) goto done;

    done:

        return m_pHr;
}


/////////////////////////////////////////////////////////////////////
// Log class definition for
// RSOP_RestrictedGroup schema class
//////////////////////////////////////////////////////////////////////

RSOP_RestrictedGroupLogger::RSOP_RestrictedGroupLogger(IWbemServices *pNamespace,
                                   PWSTR pwszGPOName, const PWSTR pwszSOMID):CGenericLogger(pNamespace, pwszGPOName, pwszSOMID)
{
    m_pHr = WBEM_S_NO_ERROR;

    m_xbstrClassName = L"RSOP_RestrictedGroup";
    if (!m_xbstrClassName) {m_pHr = WBEM_E_OUT_OF_MEMORY; goto done;}

    m_xbstrGroupName = L"GroupName";
    if (!m_xbstrGroupName) {m_pHr = WBEM_E_OUT_OF_MEMORY; goto done;}

    m_xbstrMembers = L"Members";
    if (!m_xbstrMembers) {m_pHr = WBEM_E_OUT_OF_MEMORY; goto done;}

    m_bInitialized = TRUE;

    done:

        return;
}

RSOP_RestrictedGroupLogger::~RSOP_RestrictedGroupLogger()
{


}

HRESULT
RSOP_RestrictedGroupLogger::Log( WCHAR *wcGroupName, PSCE_NAME_LIST  pList, DWORD  dwPrecedence){

    m_pHr = WBEM_S_NO_ERROR;

    m_pHr = SpawnAnInstance(&m_pObj);
    if (FAILED(m_pHr)) goto done;

    m_pHr = PutGenericProperties();
    if (FAILED(m_pHr)) goto done;

    m_pHr = PutProperty(m_pObj, m_xbstrGroupName, wcGroupName);
    if (FAILED(m_pHr)) goto done;

    m_pHr = PutProperty(m_pObj, m_xbstrMembers, pList);
    if (FAILED(m_pHr)) goto done;

    m_pHr = PutProperty(m_pObj, m_xbstrPrecedence, (int)dwPrecedence);
    if (FAILED(m_pHr)) goto done;

    m_pHr = PutInstAndFreeObj();
    if (FAILED(m_pHr)) goto done;

    done:

        return m_pHr;
}


/////////////////////////////////////////////////////////////////////
// Log class definition for
// RSOP_SystemService schema class
//////////////////////////////////////////////////////////////////////

RSOP_SystemServiceLogger::RSOP_SystemServiceLogger(IWbemServices *pNamespace,
                                   PWSTR pwszGPOName, const PWSTR pwszSOMID):CGenericLogger(pNamespace, pwszGPOName, pwszSOMID)
{
    m_pHr = WBEM_S_NO_ERROR;

    m_xbstrClassName = L"RSOP_SystemService";
    if (!m_xbstrClassName) {m_pHr = WBEM_E_OUT_OF_MEMORY; goto done;}

    m_xbstrService = L"Service";
    if (!m_xbstrService) {m_pHr = WBEM_E_OUT_OF_MEMORY; goto done;}

    m_xbstrStartupMode = L"StartupMode";
    if (!m_xbstrStartupMode) {m_pHr = WBEM_E_OUT_OF_MEMORY; goto done;}

    m_xbstrSDDLString = L"SDDLString";
    if (!m_xbstrSDDLString) {m_pHr = WBEM_E_OUT_OF_MEMORY; goto done;}

    m_bInitialized = TRUE;

    done:

        return;
}

RSOP_SystemServiceLogger::~RSOP_SystemServiceLogger()
{


}

HRESULT
RSOP_SystemServiceLogger::Log( WCHAR *wcService, BYTE  m_byStartupMode, PSECURITY_DESCRIPTOR pSecurityDescriptor, SECURITY_INFORMATION SeInfo, DWORD  dwPrecedence){


    DWORD         rc;
    PWSTR         SDspec=NULL;
    DWORD         SDsize=0;


    m_pHr = WBEM_S_NO_ERROR;


    rc = ConvertSecurityDescriptorToText(
                           pSecurityDescriptor,
                           SeInfo,
                           &SDspec,
                           &SDsize
                           );

    if (rc!= ERROR_SUCCESS) {m_pHr = ScepDosErrorToWbemError(rc); goto done;}

    if (m_pHr != WBEM_S_NO_ERROR) goto done;

    m_pHr = SpawnAnInstance(&m_pObj);
    if (FAILED(m_pHr)) goto done;

    m_pHr = PutGenericProperties();
    if (FAILED(m_pHr)) goto done;

    m_pHr = PutProperty(m_pObj, m_xbstrService, wcService);
    if (FAILED(m_pHr)) goto done;

    m_pHr = PutProperty(m_pObj, m_xbstrStartupMode, (int)m_byStartupMode);
    if (FAILED(m_pHr)) goto done;

    m_pHr = PutProperty(m_pObj, m_xbstrSDDLString, SDspec);
    if (FAILED(m_pHr)) goto done;

    m_pHr = PutProperty(m_pObj, m_xbstrPrecedence, (int)dwPrecedence);
    if (FAILED(m_pHr)) goto done;

    m_pHr = PutInstAndFreeObj();
    if (FAILED(m_pHr)) goto done;

    done:

        LocalFree(SDspec);
        SDspec = NULL;

        return m_pHr;
}


/////////////////////////////////////////////////////////////////////
// Log class definition for
// RSOP_File schema class
//////////////////////////////////////////////////////////////////////

RSOP_FileLogger::RSOP_FileLogger(IWbemServices *pNamespace,
                                   PWSTR pwszGPOName, const PWSTR pwszSOMID):CGenericLogger(pNamespace, pwszGPOName, pwszSOMID)
{
    m_pHr = WBEM_S_NO_ERROR;

    m_xbstrClassName = L"RSOP_File";
    if (!m_xbstrClassName) {m_pHr = WBEM_E_OUT_OF_MEMORY; goto done;}

    m_xbstrPath = L"Path";
    if (!m_xbstrPath) {m_pHr = WBEM_E_OUT_OF_MEMORY; goto done;}

    m_xbstrOriginalPath = L"OriginalPath";
    if (!m_xbstrOriginalPath) {m_pHr = WBEM_E_OUT_OF_MEMORY; goto done;}

    m_xbstrMode = L"Mode";
    if (!m_xbstrMode) {m_pHr = WBEM_E_OUT_OF_MEMORY; goto done;}

    m_xbstrSDDLString = L"SDDLString";
    if (!m_xbstrSDDLString) {m_pHr = WBEM_E_OUT_OF_MEMORY; goto done;}

    m_bInitialized = TRUE;

    done:

        return;
}

RSOP_FileLogger::~RSOP_FileLogger()
{


}

HRESULT
RSOP_FileLogger::Log( WCHAR *wcPath, WCHAR *wcOriginalPath, BYTE  m_byMode, PSECURITY_DESCRIPTOR pSecurityDescriptor, SECURITY_INFORMATION SeInfo, DWORD  dwPrecedence){


    DWORD         rc;
    PWSTR         SDspec=NULL;
    DWORD         SDsize=0;


    m_pHr = WBEM_S_NO_ERROR;


    rc = ConvertSecurityDescriptorToText(
                           pSecurityDescriptor,
                           SeInfo,
                           &SDspec,
                           &SDsize
                           );

    if (rc!= ERROR_SUCCESS) {m_pHr = ScepDosErrorToWbemError(rc); goto done;}

    if (m_pHr != WBEM_S_NO_ERROR) goto done;

    m_pHr = SpawnAnInstance(&m_pObj);
    if (FAILED(m_pHr)) goto done;

    m_pHr = PutGenericProperties();
    if (FAILED(m_pHr)) goto done;

    m_pHr = PutProperty(m_pObj, m_xbstrPath, wcPath);
    if (FAILED(m_pHr)) goto done;

    if (wcOriginalPath != NULL) {
        m_pHr = PutProperty(m_pObj, m_xbstrOriginalPath, wcOriginalPath);
        if (FAILED(m_pHr)) goto done;
    }

    m_pHr = PutProperty(m_pObj, m_xbstrMode, (int)m_byMode);
    if (FAILED(m_pHr)) goto done;

    m_pHr = PutProperty(m_pObj, m_xbstrSDDLString, SDspec);
    if (FAILED(m_pHr)) goto done;

    m_pHr = PutProperty(m_pObj, m_xbstrPrecedence, (int)dwPrecedence);
    if (FAILED(m_pHr)) goto done;

    m_pHr = PutInstAndFreeObj();
    if (FAILED(m_pHr)) goto done;

    done:

        LocalFree(SDspec);
        SDspec = NULL;

        return m_pHr;
}

/////////////////////////////////////////////////////////////////////
// Log class definition for
// RSOP_RegistryKey schema class
//////////////////////////////////////////////////////////////////////

RSOP_RegistryKeyLogger::RSOP_RegistryKeyLogger(IWbemServices *pNamespace,
                                   PWSTR pwszGPOName, const PWSTR pwszSOMID):CGenericLogger(pNamespace, pwszGPOName, pwszSOMID)
{
    m_pHr = WBEM_S_NO_ERROR;

    m_xbstrClassName = L"RSOP_RegistryKey";
    if (!m_xbstrClassName) {m_pHr = WBEM_E_OUT_OF_MEMORY; goto done;}

    m_xbstrPath = L"Path";
    if (!m_xbstrPath) {m_pHr = WBEM_E_OUT_OF_MEMORY; goto done;}

    m_xbstrMode = L"Mode";
    if (!m_xbstrMode) {m_pHr = WBEM_E_OUT_OF_MEMORY; goto done;}

    m_xbstrSDDLString = L"SDDLString";
    if (!m_xbstrSDDLString) {m_pHr = WBEM_E_OUT_OF_MEMORY; goto done;}

    m_bInitialized = TRUE;

    done:

        return;
}

RSOP_RegistryKeyLogger::~RSOP_RegistryKeyLogger()
{


}

HRESULT
RSOP_RegistryKeyLogger::Log( WCHAR *wcPath, BYTE  m_byMode, PSECURITY_DESCRIPTOR pSecurityDescriptor, SECURITY_INFORMATION SeInfo, DWORD  dwPrecedence){


    DWORD         rc;
    PWSTR         SDspec=NULL;
    DWORD         SDsize=0;



    m_pHr = WBEM_S_NO_ERROR;

    rc = ConvertSecurityDescriptorToText(
                           pSecurityDescriptor,
                           SeInfo,
                           &SDspec,
                           &SDsize
                           );

    if (rc!= ERROR_SUCCESS) {m_pHr = ScepDosErrorToWbemError(rc); goto done;}

    if (m_pHr != WBEM_S_NO_ERROR) goto done;

    m_pHr = SpawnAnInstance(&m_pObj);
    if (FAILED(m_pHr)) goto done;

    m_pHr = PutGenericProperties();
    if (FAILED(m_pHr)) goto done;

    m_pHr = PutProperty(m_pObj, m_xbstrPath, wcPath);
    if (FAILED(m_pHr)) goto done;

    m_pHr = PutProperty(m_pObj, m_xbstrMode, (int)m_byMode);
    if (FAILED(m_pHr)) goto done;

    m_pHr = PutProperty(m_pObj, m_xbstrSDDLString, SDspec);
    if (FAILED(m_pHr)) goto done;

    m_pHr = PutProperty(m_pObj, m_xbstrPrecedence, (int)dwPrecedence);
    if (FAILED(m_pHr)) goto done;

    m_pHr = PutInstAndFreeObj();
    if (FAILED(m_pHr)) goto done;

    done:

        LocalFree(SDspec);
        SDspec = NULL;

        return m_pHr;
}

DiagnosisStatusLogger::DiagnosisStatusLogger(IWbemServices *pNamespace,
                                   PWSTR pwszGPOName, const PWSTR pwszSOMID):CGenericLogger(pNamespace, pwszGPOName, pwszSOMID)

{
        return;
}

HRESULT DiagnosisStatusLogger::LogChild( PWSTR pwszClassName,
                                         PWSTR pwszPropertyName,
                                         PWSTR pwszPropertyValueName,
                                         DWORD  dwError,
                                         int iChildStatus)
/////////////////////////////////////////////////////////////////////////////////////////////
// Logger method for 1-property-type child search-and-log (files/registry objects          //
/////////////////////////////////////////////////////////////////////////////////////////////
{

        if ( m_pNamespace == NULL )
            return WBEM_E_CRITICAL_ERROR;

        if ( pwszClassName == NULL ||
             pwszPropertyName == NULL ||
             pwszPropertyValueName == NULL)
            return WBEM_E_INVALID_PARAMETER;

        DWORD Len = wcslen(pwszClassName) +
                    wcslen(pwszPropertyName) +
                    wcslen(pwszPropertyValueName) +
                    50;

        PWSTR tmp=(PWSTR)LocalAlloc(LPTR, (Len)*sizeof(WCHAR));

        if ( tmp == NULL )
            return WBEM_E_OUT_OF_MEMORY;

        swprintf(tmp, L"%s.precedence=1,%s=\"%s\"",
                 pwszClassName,
                 pwszPropertyName,
                 pwszPropertyValueName);

        //        XBStr   m_xbstrQuery = tmp;
        BSTR   m_xbstrQuery = SysAllocString(tmp);
        LocalFree(tmp);

        //        XBStr   m_xbstrWQL = L"WQL";
        BSTR   m_xbstrWQL = SysAllocString(L"WQL");

        m_pHr = WBEM_NO_ERROR;
        m_pEnum = NULL;
        m_pObj = NULL;
        ULONG n = 0;

        m_pHr = m_pNamespace->GetObject(
                                   m_xbstrQuery,
                                   WBEM_FLAG_RETURN_WBEM_COMPLETE,
                                   NULL,
                                   &m_pObj,
                                   NULL);

        //
        // should only get one instance for this query (since precedence = 1)
        //

    if (SUCCEEDED(m_pHr) && m_pObj) {


        m_pHr = PutProperty(m_pObj, m_xbstrStatus, iChildStatus);
        if (FAILED(m_pHr)) goto done;

        if (dwError != ERROR_SUCCESS) {
            m_pHr = PutProperty(m_pObj, m_xbstrErrorCode, (int)dwError);
            if (FAILED(m_pHr)) goto done;
        }

        m_pHr = PutInstAndFreeObj();
        if (FAILED(m_pHr)) goto done;

    } else {

        m_pHr = WBEM_E_NOT_FOUND;

    }

done:

    SysFreeString(m_xbstrQuery);
    SysFreeString(m_xbstrWQL);

    if (m_pObj){
        m_pObj->Release();
        m_pObj = NULL;
    }

    return m_pHr;
}

HRESULT DiagnosisStatusLogger::Log( PWSTR pwszClassName,
                                    PWSTR pwszPropertyName1,
                                    PWSTR pwszPropertyValueName1,
                                    PWSTR pwszPropertyName2,
                                    PWSTR pwszPropertyValueName2,
                                    DWORD  dwError)
///////////////////////////////////////////////////////////////
// Logger method for 2-property-type search-and-log          //
///////////////////////////////////////////////////////////////
{

        if ( m_pNamespace == NULL )
            return WBEM_E_CRITICAL_ERROR;

        if ( pwszClassName == NULL ||
             pwszPropertyName1 == NULL ||
             pwszPropertyValueName1 == NULL ||
             pwszPropertyName2 == NULL ||
             pwszPropertyValueName2 == NULL )

            return WBEM_E_INVALID_PARAMETER;

        DWORD Len = wcslen(pwszClassName) +
                    wcslen(pwszPropertyName1) +
                    wcslen(pwszPropertyValueName1) +
                    wcslen(pwszPropertyName2) +
                    wcslen(pwszPropertyValueName2) +
                    50;

        PWSTR tmp=(PWSTR)LocalAlloc(LPTR, (Len)*sizeof(WCHAR));

        if ( tmp == NULL )
            return WBEM_E_OUT_OF_MEMORY;

        swprintf(tmp, L"%s.precedence=1,%s=\"%s\",%s=\"%s\"",
                 pwszClassName,
                 pwszPropertyName1,
                 pwszPropertyValueName1,
                 pwszPropertyName2,
                 pwszPropertyValueName2);


        //        XBStr   m_xbstrQuery = tmp;
        BSTR   m_xbstrQuery = SysAllocString(tmp);
        LocalFree(tmp);

        //        XBStr   m_xbstrWQL = L"WQL";
        BSTR   m_xbstrWQL = SysAllocString(L"WQL");

        m_pHr = WBEM_NO_ERROR;
        m_pEnum = NULL;
        m_pObj = NULL;
        ULONG n = 0;

        m_pHr = m_pNamespace->GetObject(
                                   m_xbstrQuery,
                                   WBEM_FLAG_RETURN_WBEM_COMPLETE,
                                   NULL,
                                   &m_pObj,
                                   NULL);


        //
        // should only get one instance for this query (since precedence = 1)
        //

    if (SUCCEEDED(m_pHr) && m_pObj) {


        m_pHr = PutProperty(m_pObj, m_xbstrStatus, (dwError == ERROR_SUCCESS ? (int)1 : (int)3));
        if (FAILED(m_pHr)) goto done;

        if (dwError != ERROR_SUCCESS) {
            m_pHr = PutProperty(m_pObj, m_xbstrErrorCode, (int)dwError);
            if (FAILED(m_pHr)) goto done;
        }

        m_pHr = PutInstAndFreeObj();
        if (FAILED(m_pHr)) goto done;

    } else {

        m_pHr = WBEM_E_NOT_FOUND;

    }

done:

    SysFreeString(m_xbstrQuery);
    SysFreeString(m_xbstrWQL);

    if (m_pObj){
        m_pObj->Release();
        m_pObj = NULL;
    }

    return m_pHr;
}

HRESULT DiagnosisStatusLogger::Log( PWSTR pwszClassName,
                                    PWSTR pwszPropertyName,
                                    PWSTR pwszPropertyValueName,
                                    DWORD  dwError,
                                    BOOL Merge)
//////////////////////////////////////////////////////////////////////////////////////////////////
// Logger method for 1-property-type if-not-already-error search-and-log w or w/o merge         //
//////////////////////////////////////////////////////////////////////////////////////////////////
{

        if ( m_pNamespace == NULL )
            return WBEM_E_CRITICAL_ERROR;

        if ( pwszClassName == NULL ||
             pwszPropertyName == NULL ||
             pwszPropertyValueName == NULL)
            return WBEM_E_INVALID_PARAMETER;

        DWORD Len = wcslen(pwszClassName) +
                    wcslen(pwszPropertyName) +
                    wcslen(pwszPropertyValueName) +
                    50;

        PWSTR tmp=(PWSTR)LocalAlloc(LPTR, (Len)*sizeof(WCHAR));

        if ( tmp == NULL )
            return WBEM_E_OUT_OF_MEMORY;

        swprintf(tmp, L"%s.precedence=1,%s=\"%s\"",
                 pwszClassName,
                 pwszPropertyName,
                 pwszPropertyValueName);

        //        XBStr   m_xbstrQuery = tmp;
        BSTR   m_xbstrQuery = SysAllocString(tmp);
        LocalFree(tmp);

        //        XBStr   m_xbstrWQL = L"WQL";
        BSTR   m_xbstrWQL = SysAllocString(L"WQL");

        m_pHr = WBEM_NO_ERROR;
        m_pEnum = NULL;
        m_pObj = NULL;
        ULONG n = 0;

        m_pHr = m_pNamespace->GetObject(
                                   m_xbstrQuery,
                                   WBEM_FLAG_RETURN_WBEM_COMPLETE,
                                   NULL,
                                   &m_pObj,
                                   NULL);

    //
    // should only get one instance for this query (since precedence = 1)
    //

    if (SUCCEEDED(m_pHr) && m_pObj ) {


        if (Merge) {

            int iValue;

            m_pHr = GetProperty(m_pObj, m_xbstrStatus, &iValue);
            if (FAILED(m_pHr)) goto done;

            //
            // only put if (status = 0) or (status = 1 and dwError != ERROR_SUCCESS)
            //

            if ((DWORD)iValue == 0 ||
                ((DWORD)iValue == 1 && dwError != ERROR_SUCCESS)) {

                m_pHr = PutProperty(m_pObj, m_xbstrStatus, (dwError == ERROR_SUCCESS ? (int)1 : (int)3));
                if (FAILED(m_pHr)) goto done;

                if (dwError != ERROR_SUCCESS) {
                    m_pHr = PutProperty(m_pObj, m_xbstrErrorCode, (int)dwError);
                    if (FAILED(m_pHr)) goto done;
                }

                m_pHr = PutInstAndFreeObj();
                if (FAILED(m_pHr)) goto done;
            }

        } else {

            m_pHr = PutProperty(m_pObj, m_xbstrStatus, (dwError == ERROR_SUCCESS ? (int)1 : (int)3));
            if (FAILED(m_pHr)) goto done;

            if (dwError != ERROR_SUCCESS) {
                m_pHr = PutProperty(m_pObj, m_xbstrErrorCode, (int)dwError);
                if (FAILED(m_pHr)) goto done;
            }

            m_pHr = PutInstAndFreeObj();
            if (FAILED(m_pHr)) goto done;

        }

    } else {

        m_pHr = WBEM_E_NOT_FOUND;

    }



done:

    SysFreeString(m_xbstrQuery);
    SysFreeString(m_xbstrWQL);

    if (m_pObj){
        m_pObj->Release();
        m_pObj = NULL;
    }

    return m_pHr;
}



#ifdef _WIN64

HRESULT DiagnosisStatusLogger::LogRegistryKey( PWSTR pwszClassName,
                                    PWSTR pwszPropertyName,
                                    PWSTR pwszPropertyValueName,
                                    DWORD  dwError,
                                    BOOL bIsChild)
//////////////////////////////////////////////////////////////////////////////////////////////////
// Logger method for 1-property-type if-not-already-error search-and-log w or w/o merge         //
// Purpose is the same as regular ::Log() method, except that merge logic is different due to   //
//                                                                  64-bit and 32-bit issues    //
//////////////////////////////////////////////////////////////////////////////////////////////////
{

        if ( m_pNamespace == NULL )
            return WBEM_E_CRITICAL_ERROR;

        if ( pwszClassName == NULL ||
             pwszPropertyName == NULL ||
             pwszPropertyValueName == NULL)
            return WBEM_E_INVALID_PARAMETER;

        DWORD Len = wcslen(pwszClassName) +
                    wcslen(pwszPropertyName) +
                    wcslen(pwszPropertyValueName) +
                    50;

        PWSTR tmp=(PWSTR)LocalAlloc(LPTR, (Len)*sizeof(WCHAR));

        if ( tmp == NULL )
            return WBEM_E_OUT_OF_MEMORY;


        swprintf(tmp, L"%s.precedence=1,%s=\"%s\"",
                 pwszClassName,
                 pwszPropertyName,
                 pwszPropertyValueName);


        //        XBStr   m_xbstrQuery = tmp;
        BSTR   m_xbstrQuery = SysAllocString(tmp);
        LocalFree(tmp);

        //        XBStr   m_xbstrWQL = L"WQL";
        BSTR   m_xbstrWQL = SysAllocString(L"WQL");

        m_pHr = WBEM_NO_ERROR;
        m_pEnum = NULL;
        m_pObj = NULL;
        ULONG n = 0;

        m_pHr = m_pNamespace->GetObject(
                                   m_xbstrQuery,
                                   WBEM_FLAG_RETURN_WBEM_COMPLETE,
                                   NULL,
                                   &m_pObj,
                                   NULL);


    //
    // should only get one instance for this query (since precedence = 1)
    //


    //
    // on a 64-bit platform, the following merging logic holds for registry keys only
    // get status
    //  if status == 0 put 1 or 3 depending on dwError, also put dwError if not success
    //  else if status == 3 or 4 (64-bit key or child failed for the same key before)
    //      get error code
    //      if error code == FILE_NOT_FOUND
    //          if dwError == SUCCESS
    //              set status = 1 and error code = SUCCESS
    //          else if dwError != FILE_NOT_FOUND
    //              set status = 3 and error code = dwError
    //          else if dwError == FILE_NOT_FOUND
    //              do nothing (leave status = 3 or 4 and error code = FILE_NOT_FOUND)
    //      else
    //          if dwError == FILE_NOT_FOUND or SUCCESS
    //              leave as is
    //          else
    //              error code = dwError, status = 3
    //  else if status == 1
    //      if dwError == FILE_NOT_FOUND
    //          do nothing (leave status = 1)
    //      else if dwError != SUCCESS
    //          set status = 3 and error code = dwError
    //


    if (SUCCEEDED(m_pHr) && m_pObj) {

        int iValue;
        int iUpdateStatus = 0;
        BOOL    bUpdateErrorCode = FALSE;

        m_pHr = GetProperty(m_pObj, m_xbstrStatus, &iValue);
        if (FAILED(m_pHr)) goto done;

        if ((DWORD)iValue == 0) {

            iUpdateStatus = (dwError == ERROR_SUCCESS ? (int)1 : (int)3);
            bUpdateErrorCode = (dwError != ERROR_SUCCESS ? TRUE : FALSE);

        } else if ((DWORD)iValue == 3 || (DWORD)iValue == 4) {

            //
            // in this case, further decisions are based on the ErrorCode, so retrieve it
            //

            m_pHr = GetProperty(m_pObj, m_xbstrErrorCode, &iValue);
            if (FAILED(m_pHr)) goto done;

            if ((DWORD)iValue == ERROR_FILE_NOT_FOUND) {

                if (dwError == ERROR_SUCCESS) {

                    iUpdateStatus = 1;
                    bUpdateErrorCode = TRUE;
                } else if (dwError != ERROR_FILE_NOT_FOUND) {

                    iUpdateStatus = 3;
                    bUpdateErrorCode = TRUE;
                }
            } else {

                if (dwError != ERROR_SUCCESS && dwError != ERROR_FILE_NOT_FOUND ) {

                    iUpdateStatus = 3;
                    bUpdateErrorCode = TRUE;

                }
            }

        } else if ((DWORD)iValue == 1) {

            if (dwError != ERROR_SUCCESS && dwError != ERROR_FILE_NOT_FOUND) {

                iUpdateStatus = 3;
                bUpdateErrorCode = TRUE;
            }
        }

        if (iUpdateStatus) {

            iUpdateStatus = ((bIsChild && iUpdateStatus == 3) ? 4: 3);

            m_pHr = PutProperty(m_pObj, m_xbstrStatus, (int)iUpdateStatus);
            if (FAILED(m_pHr)) goto done;
        }

        if (bUpdateErrorCode) {

            m_pHr = PutProperty(m_pObj, m_xbstrErrorCode, (int)dwError);
            if (FAILED(m_pHr)) goto done;
        }

        m_pHr = PutInstAndFreeObj();
        if (FAILED(m_pHr)) goto done;

    } else {

        m_pHr = WBEM_E_NOT_FOUND;

    }


done:

    SysFreeString(m_xbstrQuery);
    SysFreeString(m_xbstrWQL);

    if (m_pObj){
        m_pObj->Release();
        m_pObj = NULL;
    }

    return m_pHr;
}

#endif

DiagnosisStatusLogger::~DiagnosisStatusLogger(){

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\scerpc\client\clntutil.h ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    clntutil.h

Abstract:

    Headers of SCE client utilities

Author:

    Jin Huang (jinhuang)

Revision History:

    jinhuang Created 25-Jan-1998

--*/

#ifndef _clntutil_
#define _clntutil_

#include <ntlsa.h>

//#ifdef __cplusplus
//extern "C" {
//#endif


#define SCE_SETUP_CALLBACK      0x1
#define SCE_DCPROMO_CALLBACK    0x2
#define SCE_AREA_CALLBACK       0x3

SCESTATUS
ScepSetCallback(
    IN PVOID pCallback OPTIONAL,
    IN HANDLE hWnd OPTIONAL,
    IN DWORD Type
    );

NTSTATUS
ScepBindSecureRpc(
    IN  LPWSTR               servername,
    IN  LPWSTR               servicename,
    IN  LPWSTR               networkoptions,
    OUT RPC_BINDING_HANDLE   * pBindingHandle
    );

NTSTATUS
ScepBindRpc(
    IN  LPWSTR               servername,
    IN  LPWSTR               servicename,
    IN  LPWSTR               networkoptions,
    OUT RPC_BINDING_HANDLE   * pBindingHandle
    );

DWORD
ScepActivateServer(
    IN LPTSTR SystemName OPTIONAL
    );

SCESTATUS
ScepConfigSystem(
    IN LPTSTR SystemName OPTIONAL,
    IN PCWSTR InfFileName OPTIONAL,
    IN PCWSTR DatabaseName OPTIONAL,
    IN PCWSTR LogFileName OPTIONAL,
    IN DWORD ConfigOptions,
    IN AREA_INFORMATION Area,
    IN PSCE_AREA_CALLBACK_ROUTINE pCallback OPTIONAL,
    IN HANDLE hCallbackWnd OPTIONAL,
    OUT PDWORD pdWarning OPTIONAL
    );

DWORD
ScepClearPolicyFilterTempFiles(
    BOOL bClearFile
    );

DWORD
ScepProcessPolicyFilterTempFiles(
    IN LPTSTR LogFileName OPTIONAL
    );

//#ifdef __cplusplus
//}
//#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\scerpc\client\infwrite.cpp ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    infwrite.c

Abstract:

    Routines to set information into security profiles (INF layout).

Author:

    Jin Huang (jinhuang) 07-Dec-1996

Revision History:

--*/

#include "headers.h"
#include "scedllrc.h"
#include "infp.h"
#include "sceutil.h"
#include "splay.h"
#include <io.h>
#include <sddl.h>
#pragma hdrstop

const TCHAR c_szCRLF[]    = TEXT("\r\n");
//
// Forward references
//
SCESTATUS
SceInfpWriteSystemAccess(
    IN PCWSTR ProfileName,
    IN PSCE_PROFILE_INFO pSCEinfo,
    IN BOOL bOverwrite,
    OUT PSCE_ERROR_LOG_INFO *Errlog OPTIONAL
    );

SCESTATUS
SceInfpWritePrivileges(
    IN PCWSTR ProfileName,
    IN PSCE_PRIVILEGE_ASSIGNMENT pPrivileges,
    IN BOOL bOverwrite,
    OUT PSCE_ERROR_LOG_INFO *Errlog OPTIONAL
    );

SCESTATUS
SceInfpWriteUserSettings(
    IN PCWSTR ProfileName,
    IN PSCE_NAME_LIST pProfiles,
    OUT PSCE_ERROR_LOG_INFO *Errlog OPTIONAL
    );

SCESTATUS
SceInfpWriteGroupMembership(
    IN PCWSTR ProfileName,
    IN PSCE_GROUP_MEMBERSHIP pGroupMembership,
    IN BOOL bOverwrite,
    OUT PSCE_ERROR_LOG_INFO *Errlog OPTIONAL
    );

SCESTATUS
SceInfpWriteServices(
    IN PCWSTR ProfileName,
    IN PCWSTR SectionName,
    IN PSCE_SERVICES pServices,
    IN BOOL bOverwrite,
    OUT PSCE_ERROR_LOG_INFO *Errlog OPTIONAL
   );

DWORD
SceInfpWriteOneService(
    IN PSCE_SERVICES pService,
    OUT PSCE_NAME_LIST *pNameList,
    OUT PDWORD ObjectSize,
    OUT PSCE_ERROR_LOG_INFO *Errlog OPTIONAL
    );

SCESTATUS
SceInfpWriteObjects(
    IN PCWSTR ProfileName,
    IN PCWSTR SectionName,
    IN PSCE_OBJECT_ARRAY pObjects,
    IN BOOL bOverwrite,
    OUT PSCE_ERROR_LOG_INFO *Errlog OPTIONAL
   );

DWORD
SceInfpWriteOneObject(
    IN PSCE_OBJECT_SECURITY pObject,
    OUT PSCE_NAME_LIST *pNameList,
    OUT PDWORD ObjectSize,
    OUT PSCE_ERROR_LOG_INFO *Errlog OPTIONAL
    );

SCESTATUS
SceInfpWriteAuditing(
    IN PCWSTR ProfileName,
    IN PSCE_PROFILE_INFO pSCEinfo,
    OUT PSCE_ERROR_LOG_INFO *Errlog OPTIONAL
    );

SCESTATUS
SceInfpAppendAuditing(
    IN PCWSTR ProfileName,
    IN PSCE_PROFILE_INFO pSCEinfo,
    OUT PSCE_ERROR_LOG_INFO *Errlog OPTIONAL
    );

SCESTATUS
ScepWriteOneIntValueToProfile(
    IN PCWSTR InfFileName,
    IN PCWSTR InfSectionName,
    IN PWSTR KeyName,
    IN DWORD Value
    );

SCESTATUS
SceInfpWriteAuditLogSetting(
   IN PCWSTR  InfFileName,
   IN PCWSTR InfSectionName,
   IN DWORD LogSize,
   IN DWORD Periods,
   IN DWORD RetentionDays,
   IN DWORD RestrictGuest,
   OUT PSCE_ERROR_LOG_INFO *Errlog OPTIONAL
   );

SCESTATUS
SceInfpWriteInfSection(
    IN PCWSTR InfFileName,
    IN PCWSTR InfSectionName,
    IN DWORD  TotalSize,
    IN PWSTR  *EachLineStr,
    IN DWORD  *EachLineSize,
    IN DWORD  StartIndex,
    IN DWORD  EndIndex,
    OUT PSCE_ERROR_LOG_INFO *Errlog OPTIONAL
    );

#define SCEINF_ADD_EQUAL_SIGN            1
#define SCEINF_APPEND_SECTION            2

DWORD
SceInfpWriteListSection(
    IN PCWSTR InfFileName,
    IN PCWSTR InfSectionName,
    IN DWORD  TotalSize,
    IN PSCE_NAME_LIST  ListLines,
    IN DWORD Option,
    OUT PSCE_ERROR_LOG_INFO *Errlog OPTIONAL
    );

LONG
SceInfpConvertNameListToString(
    IN LSA_HANDLE LsaHandle,
    IN PCWSTR KeyText,
    IN PSCE_NAME_LIST Fields,
    IN BOOL bOverwrite,
    OUT PWSTR *Strvalue,
    OUT PSCE_ERROR_LOG_INFO *Errlog OPTIONAL
    );

LONG
SceInfpConvertMultiSZToString(
    IN PCWSTR KeyText,
    IN UNICODE_STRING Fields,
    OUT PWSTR *Strvalue,
    OUT PSCE_ERROR_LOG_INFO *Errlog OPTIONAL
    );

SCESTATUS
ScepAllocateAndCopy(
    OUT PWSTR *Buffer,
    OUT PDWORD BufSize,
    IN DWORD MaxSize,
    IN PWSTR SrcBuf
    );

SCESTATUS
SceInfpBreakTextIntoMultiFields(
    IN PWSTR szText,
    IN DWORD dLen,
    OUT LPDWORD pnFields,
    OUT LPDWORD *arrOffset
    );

SCESTATUS
SceInfpWriteKerberosPolicy(
    IN PCWSTR  ProfileName,
    IN PSCE_KERBEROS_TICKET_INFO pKerberosInfo,
    IN BOOL bOverwrite,
    OUT PSCE_ERROR_LOG_INFO *Errlog OPTIONAL
    );

SCESTATUS
SceInfpWriteRegistryValues(
    IN PCWSTR  ProfileName,
    IN PSCE_REGISTRY_VALUE_INFO pRegValues,
    IN DWORD ValueCount,
    IN BOOL bOverwrite,
    OUT PSCE_ERROR_LOG_INFO *Errlog OPTIONAL
    );

DWORD
SceInfpWriteOneValue(
    IN PCWSTR ProfileName,
    IN SCE_REGISTRY_VALUE_INFO RegValue,
    IN BOOL bOverwrite,
    OUT PSCE_NAME_LIST *pNameList,
    OUT PDWORD ObjectSize
    );

SCESTATUS
ScepWriteSecurityProfile(
    IN  PCWSTR             InfProfileName,
    IN  AREA_INFORMATION   Area,
    IN  PSCE_PROFILE_INFO  InfoBuffer,
    IN  BOOL               bOverwrite,
    OUT PSCE_ERROR_LOG_INFO *Errlog OPTIONAL
    );

DWORD
ScepCreateTempFiles(
    IN PWSTR InfProfileName,
    OUT PWSTR *ppszTempFileName,
    OUT PWSTR *ppszTargetTempName
    );

DWORD
ScepWritePrivateProfileSection(
    IN LPCWSTR SectionName,
    IN LPTSTR pData,
    IN LPCWSTR FileName,
    IN BOOL bOverwrite
    );

DWORD
ScepAppendProfileSection(
    IN LPCWSTR SectionName,
    IN LPCWSTR FileName,
    IN LPTSTR pData
    );

#define SCEP_PROFILE_WRITE_SECTIONNAME  0x1
#define SCEP_PROFILE_GENERATE_KEYS      0x2
#define SCEP_PROFILE_CHECK_DUP          0x4

DWORD
ScepOverwriteProfileSection(
    IN LPCWSTR SectionName,
    IN LPCWSTR FileName,
    IN LPTSTR pData,
    IN DWORD dwFlags,
    IN OUT PSCEP_SPLAY_TREE pKeys
    );

DWORD
ScepWriteStrings(
    IN HANDLE hFile,
    IN BOOL bUnicode,
    IN PWSTR szPrefix,
    IN DWORD dwPrefixLen,
    IN PWSTR szString,
    IN DWORD dwStrLen,
    IN PWSTR szSuffix,
    IN DWORD dwSuffixLen,
    IN BOOL bCRLF
    );


SCESTATUS
WINAPI
SceWriteSecurityProfileInfo(
    IN  PCWSTR             InfProfileName,
    IN  AREA_INFORMATION   Area,
    IN  PSCE_PROFILE_INFO   InfoBuffer,
    OUT PSCE_ERROR_LOG_INFO *Errlog OPTIONAL
    )
// see comments in ScepWriteSecurityProfile
{
    return( ScepWriteSecurityProfile( InfProfileName,
                                      Area,
                                      InfoBuffer,
                                      TRUE,  // overwrite the section(s)
                                      Errlog
                                    ) );
}

SCESTATUS
WINAPI
SceAppendSecurityProfileInfo(
    IN  PCWSTR             InfProfileName,
    IN  AREA_INFORMATION   Area,
    IN  PSCE_PROFILE_INFO   InfoBuffer,
    OUT PSCE_ERROR_LOG_INFO *Errlog OPTIONAL
    )
// see comments in ScepWriteSecurityProfile
{
    if ( InfoBuffer == NULL ) return SCESTATUS_SUCCESS;

    SCESTATUS rc=SCESTATUS_SUCCESS;
/*
    AREA_INFORMATION Area2=0;
    HINF hInf=NULL;
    PSCE_PROFILE_INFO pOldBuffer=NULL;
    PSCE_OBJECT_ARRAY pNewKeys=NULL, pNewFiles=NULL;
    PSCE_OBJECT_ARRAY pOldKeys=NULL, pOldFiles=NULL;


    if ( (Area & AREA_REGISTRY_SECURITY) &&
         (InfoBuffer->pRegistryKeys.pAllNodes != NULL) &&
         (InfoBuffer->pRegistryKeys.pAllNodes->Count > 0) ) {

        Area2 |= AREA_REGISTRY_SECURITY;
    }

    if ( (Area & AREA_FILE_SECURITY) &&
         (InfoBuffer->pFiles.pAllNodes != NULL ) &&
         (InfoBuffer->pFiles.pAllNodes->Count > 0 ) ) {

        Area2 |= AREA_FILE_SECURITY;
    }

    if ( Area2 > 0 ) {

        //
        // query existing info from the template and check for duplicate
        // because these two sections do not support INF key name
        // any error occured in duplicate checking is ignored
        //
        rc = SceInfpOpenProfile(
                    InfProfileName,
                    &hInf
                    );

        if ( SCESTATUS_SUCCESS == rc ) {

            rc = SceInfpGetSecurityProfileInfo(
                            hInf,
                            Area2,
                            &pOldBuffer,
                            NULL
                            );

            if ( SCESTATUS_SUCCESS == rc ) {
                //
                // files/keys in the template are queried
                // now check if there is any existing files/keys
                //
                DWORD i,j,idxNew;

                if ( (Area2 & AREA_REGISTRY_SECURITY) &&
                     (pOldBuffer->pRegistryKeys.pAllNodes != NULL) &&
                     (pOldBuffer->pRegistryKeys.pAllNodes->Count > 0) ) {

                    //
                    // there are existing keys
                    // now create a new buffer
                    //
                    pNewKeys = (PSCE_OBJECT_ARRAY)ScepAlloc(0,sizeof(SCE_OBJECT_ARRAY));

                    if ( pNewKeys ) {

                        pNewKeys->Count = 0;
                        pNewKeys->pObjectArray = (PSCE_OBJECT_SECURITY *)ScepAlloc(LPTR, (pOldBuffer->pRegistryKeys.pAllNodes->Count)*sizeof(PSCE_OBJECT_SECURITY));

                        if ( pNewKeys->pObjectArray ) {
                            //
                            // checking duplicate now
                            //
                            idxNew=0;

                            for ( i=0; i<InfoBuffer->pRegistryKeys.pAllNodes->Count; i++) {

                                if ( InfoBuffer->pRegistryKeys.pAllNodes->pObjectArray[i] == NULL )
                                    continue;

                                for ( j=0; j<pOldBuffer->pRegistryKeys.pAllNodes->Count; j++) {

                                    if ( pOldBuffer->pRegistryKeys.pAllNodes->pObjectArray[j] == NULL )
                                        continue;

                                    // check if this one has been checked
                                    if ( pOldBuffer->pRegistryKeys.pAllNodes->pObjectArray[j]->Status == 255 )
                                        continue;

                                    if ( _wcsicmp(InfoBuffer->pRegistryKeys.pAllNodes->pObjectArray[i]->Name,
                                                  pOldBuffer->pRegistryKeys.pAllNodes->pObjectArray[j]->Name) == 0 ) {
                                        //
                                        // found it
                                        //
                                        pOldBuffer->pRegistryKeys.pAllNodes->pObjectArray[j]->Status = 255;
                                        break;
                                    }
                                }

                                if ( j >= pOldBuffer->pRegistryKeys.pAllNodes->Count ) {
                                    //
                                    // did not find it, now link it to the new buffer
                                    //
                                    pNewKeys->pObjectArray[idxNew] = InfoBuffer->pRegistryKeys.pAllNodes->pObjectArray[i];
                                    idxNew++;
                                }
                            }

                            pNewKeys->Count = idxNew;

                        } else {
                            rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
                            ScepFree(pNewKeys);
                            pNewKeys = NULL;
                        }

                    } else {
                        rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
                    }
                }

                if ( (Area2 & AREA_FILE_SECURITY) &&
                     (pOldBuffer->pFiles.pAllNodes != NULL ) &&
                     (pOldBuffer->pFiles.pAllNodes->Count > 0 ) ) {

                    //
                    // there are existing files
                    // now create a new buffer
                    //
                    pNewFiles = (PSCE_OBJECT_ARRAY)ScepAlloc(0,sizeof(SCE_OBJECT_ARRAY));

                    if ( pNewFiles ) {

                        pNewFiles->Count = 0;
                        pNewFiles->pObjectArray = (PSCE_OBJECT_SECURITY *)ScepAlloc(LPTR, (pOldBuffer->pFiles.pAllNodes->Count)*sizeof(PSCE_OBJECT_SECURITY));

                        if ( pNewFiles->pObjectArray ) {
                            //
                            // checking duplicate now
                            //
                            idxNew=0;

                            for ( i=0; i<InfoBuffer->pFiles.pAllNodes->Count; i++) {

                                if ( InfoBuffer->pFiles.pAllNodes->pObjectArray[i] == NULL )
                                    continue;

                                for ( j=0; j<pOldBuffer->pFiles.pAllNodes->Count; j++) {

                                    if ( pOldBuffer->pFiles.pAllNodes->pObjectArray[j] == NULL )
                                        continue;

                                    // check if this one has been checked
                                    if ( pOldBuffer->pFiles.pAllNodes->pObjectArray[j]->Status == 255 )
                                        continue;

                                    if ( _wcsicmp(InfoBuffer->pFiles.pAllNodes->pObjectArray[i]->Name,
                                                  pOldBuffer->pFiles.pAllNodes->pObjectArray[j]->Name) == 0 ) {
                                        //
                                        // found it
                                        //
                                        pOldBuffer->pFiles.pAllNodes->pObjectArray[j]->Status = 255;
                                        break;
                                    }
                                }

                                if ( j >= pOldBuffer->pFiles.pAllNodes->Count ) {
                                    //
                                    // did not find it, now link it to the new buffer
                                    //
                                    pNewFiles->pObjectArray[idxNew] = InfoBuffer->pFiles.pAllNodes->pObjectArray[i];
                                    idxNew++;
                                }
                            }

                            pNewFiles->Count = idxNew;

                        } else {
                            rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
                            ScepFree(pNewFiles);
                            pNewFiles = NULL;
                        }

                    } else {
                        rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
                    }
                }
            }

            SceInfpCloseProfile(hInf);

            SceFreeProfileMemory(pOldBuffer);
        }

    }

    if ( pNewKeys != NULL ) {
        //
        // use the purged buffer and save the old one
        //
        pOldKeys = InfoBuffer->pRegistryKeys.pAllNodes;
        InfoBuffer->pRegistryKeys.pAllNodes = pNewKeys;
    }

    if ( pNewFiles != NULL ) {

        //
        // use the purged buffer and save the old one
        //
        pOldFiles = InfoBuffer->pFiles.pAllNodes;
        InfoBuffer->pFiles.pAllNodes = pNewFiles;
    }
*/
    rc = ScepWriteSecurityProfile( InfProfileName,
                                      Area,
                                      InfoBuffer,
                                      FALSE,  // append to the section(s)
                                      Errlog
                                 );
/*
    if ( pNewKeys != NULL ) {
        //
        // reset the old pointer and free the new buffer
        //
        InfoBuffer->pRegistryKeys.pAllNodes = pOldKeys;

        ScepFree(pNewKeys->pObjectArray);
        ScepFree(pNewKeys);
    }

    if ( pNewFiles != NULL ) {

        //
        // use the purged buffer and save the old one
        //
        InfoBuffer->pFiles.pAllNodes = pOldFiles;

        ScepFree(pNewFiles->pObjectArray);
        ScepFree(pNewFiles);
    }
*/

    return rc;

}

DWORD
ScepCreateTempFiles(
    IN PWSTR InfProfileName,
    OUT PWSTR *ppszTempFileName,
    OUT PWSTR *ppszTargetTempName
    )
/*
Description:

    This function is to get a temporary file name for system context (in system
    directory) as well as for normal user context (in user profile), and copy the
    input template data to the temporary file.

Arguments:

    InfProfileName      - the template file to copy from

    ppszTempFileName    - the name of the temporary file to work on

    ppszTargetTempName  - the backup copy of the template file in sysvol
*/
{
    if ( InfProfileName == NULL || ppszTempFileName == NULL ||
         ppszTargetTempName == NULL) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    HANDLE Token=NULL;
    BOOL bSystem=FALSE;

    LONG Len=0, nSize=0, nRequired=0;
    PWSTR pTempName=NULL;
    DWORD rc=0;

    PWSTR pTemp=NULL;

    *ppszTempFileName = NULL;
    *ppszTargetTempName = NULL;

    //
    // check if we should have temp file on the target too.
    // only do this if the target file is in sysvol
    //
    if ((0xFFFFFFFF != GetFileAttributes(InfProfileName)) &&
        InfProfileName[0] == L'\\' && InfProfileName[1] == L'\\' &&
        (pTemp=wcschr(InfProfileName+2, L'\\')) ) {

        if ( _wcsnicmp(pTemp, L"\\sysvol\\", 8) == 0 ) {
            //
            // this is a file on sysvol
            //
            Len = wcslen(InfProfileName);

            *ppszTargetTempName = (PWSTR)LocalAlloc(LPTR, (Len+1)*sizeof(WCHAR));

            if ( *ppszTargetTempName ) {

                wcsncpy(*ppszTargetTempName, InfProfileName, Len-4);
                wcscat(*ppszTargetTempName, L".tmp");

            } else {
                rc = ERROR_NOT_ENOUGH_MEMORY;
                return rc;
            }
        }
    }
    //
    // determine if the current thread/process is system context
    // if this function fails, it's treated a regular user and the temp
    // file will be created in user profile location.
    //

    if (!OpenThreadToken( GetCurrentThread(),
                          TOKEN_QUERY,
                          FALSE,
                          &Token)) {

        if (!OpenProcessToken( GetCurrentProcess(),
                               TOKEN_QUERY,
                               &Token))

            Token = NULL;
    }

    if ( Token != NULL ) {

        ScepIsSystemContext(Token, &bSystem);
        CloseHandle(Token);

    }

    //
    // get a temp file name.
    //
    if ( bSystem ) {

        Len = lstrlen(TEXT("\\security\\sce00000.tmp"));
        nRequired = GetSystemWindowsDirectory(NULL, 0);

    } else {

        //
        // get the temp file name from user's temp directory
        // the environment variable "TMP" is used here because this write API
        // is always called in user's process (except called from system context)
        //
        Len = lstrlen(TEXT("\\sce00000.tmp"));
        nRequired = GetEnvironmentVariable( L"TMP", NULL, 0 );
    }

    if ( nRequired > 0 ) {
        //
        // allocate buffer big enough for the temp file name
        //
        pTempName = (LPTSTR)LocalAlloc(0, (nRequired+2+Len)*sizeof(TCHAR));

        if ( pTempName ) {

            if ( bSystem ) {

                nSize = GetSystemWindowsDirectory(pTempName, nRequired);
            } else {

                nSize = GetEnvironmentVariable(L"TMP", pTempName, nRequired );

            }

            if ( nSize > 0 ) {

                pTempName[nSize] = L'\0';

            } else {

                //
                // if failed to query the information, should fail
                //
                rc = GetLastError();
#if DBG == 1
                SceDebugPrint(DEB_ERROR, "Error %d to query temporary file path\n", rc);
#endif
                LocalFree(pTempName);
                pTempName = NULL;

            }

        } else {

            rc = ERROR_NOT_ENOUGH_MEMORY;
        }

    } else {

        rc = GetLastError();
#if DBG == 1
        SceDebugPrint(DEB_ERROR, "Error %d to query temporary file path\n", rc);
#endif
    }

    //
    // check if the temp file name is already used.
    //
    if ( ERROR_SUCCESS == rc && pTempName &&
         nSize <= nRequired ) {

        ULONG seed=GetTickCount();
        ULONG ranNum=0;

        ranNum = RtlRandomEx(&seed);
        //
        // make sure that it's not over 5 digits (99999)
        //
        if ( ranNum > 99999 )
            ranNum = ranNum % 99999;

        swprintf(pTempName+nSize,
                 bSystem ? L"\\security\\sce%05d.tmp\0" : L"\\sce%05d.tmp\0",
                 ranNum);

        DWORD index=0;
        while ( 0xFFFFFFFF != GetFileAttributes(pTempName) &&
                index <= 99999) {

            ranNum = RtlRandomEx(&seed);
            //
            // make sure that it's not over 5 digits (99999)
            //
            if ( ranNum > 99999 )
                ranNum = ranNum % 99999;

            index++;
            swprintf(pTempName+nSize,
                     bSystem ? L"\\security\\sce%05d.tmp\0" : L"\\sce%05d.tmp\0",
                     ranNum);
        }

        if ( index >= 100000 ) {
            //
            // can't get a temp file name
            //
            rc = ERROR_DUP_NAME;

#if DBG == 1
            SceDebugPrint(DEB_ERROR, "Can't get an unique temporary file name\n", rc);
#endif

        }

    } else if ( ERROR_SUCCESS == rc ) {

        rc = ERROR_INSUFFICIENT_BUFFER;
    }

    //
    // make a copy of the temp file
    //
    if ( ERROR_SUCCESS == rc ) {

        //
        // detect if the profile exist and if it does, make a local copy
        //
        DWORD dwAttr = GetFileAttributes(InfProfileName);
        if ( 0xFFFFFFFF != dwAttr ) {

            if ( FALSE == CopyFile( InfProfileName, pTempName, FALSE ) ) {

                rc = GetLastError();
#if DBG == 1
                SceDebugPrint(DEB_ERROR, "CopyFile to temp failed with %d\n", rc);
#endif
            }
        }
    }

    if ( ERROR_SUCCESS == rc ) {

        *ppszTempFileName = pTempName;

    } else {

        if ( pTempName ) {

            //
            // make usre the file is not left over
            //
            DeleteFile(pTempName);
            LocalFree(pTempName);
        }

        if ( *ppszTargetTempName ) {
            LocalFree(*ppszTargetTempName);
            *ppszTargetTempName = NULL;
        }
    }

    return(rc);
}


//
// function definitions
//
SCESTATUS
ScepWriteSecurityProfile(
    IN  PCWSTR             szInfProfileName,
    IN  AREA_INFORMATION   Area,
    IN  PSCE_PROFILE_INFO  InfoBuffer,
    IN  BOOL               bOverwrite,
    OUT PSCE_ERROR_LOG_INFO *Errlog OPTIONAL
    )
/**++

Function Description:

   This function writes all or part of information into a SCP profile in
   INF format.

Arguments:

   ProfileName -   The INF file name to write to

   Area -          area(s) for which to get information from
                     AREA_SECURITY_POLICY
                     AREA_PRIVILEGES
                     AREA_USER_SETTINGS
                     AREA_GROUP_MEMBERSHIP
                     AREA_REGISTRY_SECURITY
                     AREA_SYSTEM_SERVICE
                     AREA_FILE_SECURITY

   InfoBuffer -    Information to write. The Header of InfoBuffer contains
                   SCP/SAP file name or file handle.

   bOverwrite -    TRUE = overwrite the section(s) with InfoBuffer
                   FALSE = append InfoBuffer to the section(s)

   Errlog     -    A buffer to hold all error codes/text encountered when
                   parsing the INF file. If Errlog is NULL, no further error
                   information is returned except the return DWORD

Return Value:

   SCESTATUS_SUCCESS
   SCESTATUS_PROFILE_NOT_FOUND
   SCESTATUS_NOT_ENOUGH_RESOURCE
   SCESTATUS_INVALID_PARAMETER
   SCESTATUS_CORRUPT_PROFILE
   SCESTATUS_INVALID_DATA

-- **/
{
    SCESTATUS     rc=SCESTATUS_SUCCESS;
    DWORD         Win32rc;
    DWORD         SDsize;
    PSCE_PROFILE_INFO pNewBuffer=NULL;
    AREA_INFORMATION  Area2=0;

    PWSTR InfProfileName=NULL;
    PWSTR TargetTempName=NULL;


    if ( szInfProfileName == NULL || InfoBuffer == NULL ||
         Area == 0 ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    //
    // get a temp file name
    // if this is system context, the temp file is under %windir%\security\scexxxxx.tmp
    // else the temp file will be in the user profile location.
    //
    // temp file name must be unique to handle simultaneous changes to different templates (GPOs)
    // temp file created under system context will be cleaned up when system booted up.
    //
    Win32rc = ScepCreateTempFiles((PWSTR)szInfProfileName, &InfProfileName, &TargetTempName);

    if ( Win32rc != ERROR_SUCCESS ) {

        ScepBuildErrorLogInfo(
                    Win32rc,
                    Errlog,
                    SCEERR_ERROR_CREATE,
                    TEXT("Temp")
                    );
        return(ScepDosErrorToSceStatus(Win32rc));
    }

    //
    // initialize the error log buffer
    //
    if ( Errlog ) {
        *Errlog = NULL;
    }

    //
    // get Revision of this template
    //

    INT Revision = GetPrivateProfileInt( L"Version",
                                         L"Revision",
                                         0,
                                         InfProfileName
                                        );
    if ( Revision == 0 ) {
        //
        // maybe a old version of inf file, or
        // it's a brand new file
        //
        TCHAR szBuf[20];
        szBuf[0] = L'\0';

        SDsize = GetPrivateProfileString(TEXT("Version"),
                                        TEXT("signature"),
                                        TEXT(""),
                                        szBuf,
                                        20,
                                        InfProfileName
                                       );

        if ( SDsize == 0 ) {
            //
            // this is a new inf file
            //
            Revision = SCE_TEMPLATE_MAX_SUPPORTED_VERSION;
            //
            // make it unicode file, if error continues to use ansi
            //
            SetupINFAsUCS2(InfProfileName);
        }
    }

    //
    // system access
    //

    if ( Area & AREA_SECURITY_POLICY ) {

        rc = SceInfpWriteSystemAccess(
                        InfProfileName,
                        InfoBuffer,
                        bOverwrite,
                        Errlog
                        );

        if( rc != SCESTATUS_SUCCESS )
            goto Done;

        //
        // system auditing
        //
        if ( bOverwrite ) {

            rc = SceInfpWriteAuditing(
                        InfProfileName,
                        InfoBuffer,
                        Errlog
                        );
        } else {

            rc = SceInfpAppendAuditing(
                        InfProfileName,
                        InfoBuffer,
                        Errlog
                        );
        }

        if( rc != SCESTATUS_SUCCESS )
            goto Done;

        //
        // kerberos policy
        //
        rc = SceInfpWriteKerberosPolicy(
                    InfProfileName,
                    InfoBuffer->pKerberosInfo,
                    bOverwrite,
                    Errlog
                    );

        if( rc != SCESTATUS_SUCCESS )
            goto Done;

        //
        // regsitry values
        //
        rc = SceInfpWriteRegistryValues(
                    InfProfileName,
                    InfoBuffer->aRegValues,
                    InfoBuffer->RegValueCount,
                    bOverwrite,
                    Errlog
                    );

        if( rc != SCESTATUS_SUCCESS )
            goto Done;
    }

    //
    // privilege/rights
    //
    if ( Area & AREA_PRIVILEGES ) {

        rc = SceInfpWritePrivileges(
                    InfProfileName,
                    InfoBuffer->OtherInfo.scp.u.pInfPrivilegeAssignedTo,
                    bOverwrite,
                    Errlog
                    );

        if( rc != SCESTATUS_SUCCESS )
            goto Done;
    }
    //
    // privilege/rights and account profiles for each user
    //
#if 0
    if ( Area & AREA_USER_SETTINGS ) {

        rc = SceInfpWriteUserSettings(
                    InfProfileName,
                    InfoBuffer->OtherInfo.scp.pAccountProfiles,
                    Errlog
                    );

        if( rc != SCESTATUS_SUCCESS )
            goto Done;
    }
#endif

    //
    // group memberships
    //

    if ( Area & AREA_GROUP_MEMBERSHIP ) {
        rc = SceInfpWriteGroupMembership(
                    InfProfileName,
                    InfoBuffer->pGroupMembership,
                    bOverwrite,
                    Errlog
                    );

        if( rc != SCESTATUS_SUCCESS )
            goto Done;
    }

    if ( Revision == 0 ) {
        //
        // old SDDL format, convert it
        //
        Area2 = ~Area & (AREA_REGISTRY_SECURITY |
                          AREA_FILE_SECURITY |
                          AREA_DS_OBJECTS |
                          AREA_SYSTEM_SERVICE
                         );

        if ( Area2 > 0 ) {

            HINF hInf;

            rc = SceInfpOpenProfile(
                        InfProfileName,
                        &hInf
                        );

            if ( SCESTATUS_SUCCESS == rc ) {

                rc = SceInfpGetSecurityProfileInfo(
                                    hInf,
                                    Area2,
                                    &pNewBuffer,
                                    NULL
                                    );

                SceInfpCloseProfile(hInf);

                if ( SCESTATUS_SUCCESS != rc ) {
                    goto Done;
                }
            } else {
                //
                // the template can't be opened (new profile)
                // ignore the error
                //
                rc = SCESTATUS_SUCCESS;
            }
        }
    }

    //
    // registry keys security
    //

    if ( Area & AREA_REGISTRY_SECURITY ) {

        if ( !bOverwrite && pNewBuffer ) {

            rc = SceInfpWriteObjects(
                        InfProfileName,
                        szRegistryKeys,
                        pNewBuffer->pRegistryKeys.pAllNodes,
                        TRUE,
                        Errlog
                        );

            if( rc != SCESTATUS_SUCCESS )
                goto Done;
        }

        rc = SceInfpWriteObjects(
                    InfProfileName,
                    szRegistryKeys,
                    InfoBuffer->pRegistryKeys.pAllNodes,
                    bOverwrite,
                    Errlog
                    );

        if( rc != SCESTATUS_SUCCESS )
            goto Done;

    } else if ( pNewBuffer ) {

        //
        // should convert this section to new SDDL format
        //

        rc = SceInfpWriteObjects(
                    InfProfileName,
                    szRegistryKeys,
                    pNewBuffer->pRegistryKeys.pAllNodes,
                    TRUE,
                    Errlog
                    );

        if( rc != SCESTATUS_SUCCESS )
            goto Done;

    }

    //
    // file security
    //

    if ( Area & AREA_FILE_SECURITY ) {

        if ( !bOverwrite && pNewBuffer ) {

            rc = SceInfpWriteObjects(
                        InfProfileName,
                        szFileSecurity,
                        pNewBuffer->pFiles.pAllNodes,
                        TRUE,
                        Errlog
                        );

            if( rc != SCESTATUS_SUCCESS )
                goto Done;
        }

        rc = SceInfpWriteObjects(
                    InfProfileName,
                    szFileSecurity,
                    InfoBuffer->pFiles.pAllNodes,
                    bOverwrite,
                    Errlog
                    );

        if( rc != SCESTATUS_SUCCESS )
            goto Done;

    } else if ( pNewBuffer ) {

        //
        // should convert this section to new SDDL format
        //

        rc = SceInfpWriteObjects(
                    InfProfileName,
                    szFileSecurity,
                    pNewBuffer->pFiles.pAllNodes,
                    TRUE,
                    Errlog
                    );

        if( rc != SCESTATUS_SUCCESS )
            goto Done;
    }

#if 0
    //
    // DS security
    //

    if ( Area & AREA_DS_OBJECTS ) {

        if ( !bOverwrite && pNewBuffer ) {

            rc = SceInfpWriteObjects(
                        InfProfileName,
                        szDSSecurity,
                        pNewBuffer->pDsObjects.pAllNodes,
                        TRUE,
                        Errlog
                        );
            if( rc != SCESTATUS_SUCCESS )
                goto Done;
        }

        rc = SceInfpWriteObjects(
                    InfProfileName,
                    szDSSecurity,
                    InfoBuffer->pDsObjects.pAllNodes,
                    bOverwrite,
                    Errlog
                    );

        if( rc != SCESTATUS_SUCCESS )
            goto Done;

    } else if ( pNewBuffer ) {

        //
        // should convert this section to new SDDL format
        //

        rc = SceInfpWriteObjects(
                    InfProfileName,
                    szDSSecurity,
                    pNewBuffer->pDsObjects.pAllNodes,
                    TRUE,
                    Errlog
                    );

        if( rc != SCESTATUS_SUCCESS )
            goto Done;
    }
#endif

    if ( Area & AREA_SYSTEM_SERVICE ) {

        if ( !bOverwrite && pNewBuffer ) {

            rc = SceInfpWriteServices(
                        InfProfileName,
                        szServiceGeneral,
                        pNewBuffer->pServices,
                        TRUE,
                        Errlog
                        );
            if( rc != SCESTATUS_SUCCESS )
                goto Done;
        }

        rc = SceInfpWriteServices(
                    InfProfileName,
                    szServiceGeneral,
                    InfoBuffer->pServices,
                    bOverwrite,
                    Errlog
                    );

        if( rc != SCESTATUS_SUCCESS )
            goto Done;

    } else if ( pNewBuffer ) {

        //
        // should convert this section to new SDDL format
        //

        rc = SceInfpWriteServices(
                    InfProfileName,
                    szServiceGeneral,
                    pNewBuffer->pServices,
                    TRUE,
                    Errlog
                    );

        if( rc != SCESTATUS_SUCCESS )
            goto Done;
    }

Done:

    if ( rc == SCESTATUS_SUCCESS ) {
        //
        // always write [Version] section.
        //
        WCHAR tmp[64];
        memset(tmp, 0, 64*2);
        wcscpy(tmp, L"signature=\"$CHICAGO$\"");
        swprintf(tmp+wcslen(tmp)+1,L"Revision=%d\0\0",
                      SCE_TEMPLATE_MAX_SUPPORTED_VERSION);

        WritePrivateProfileSection(
                    L"Version",
                    tmp,
                    InfProfileName);

        //
        // all data are successfully written
        //
        if ( TargetTempName &&
             (0xFFFFFFFF != GetFileAttributes(szInfProfileName)) ) {
            //
            // now make a copy of the sysvol file first on the target directory
            //
            if ( FALSE == CopyFile( szInfProfileName, TargetTempName, FALSE ) ) {

                Win32rc = GetLastError();
                ScepBuildErrorLogInfo(
                            Win32rc,
                            Errlog,
                            IDS_ERROR_COPY_TEMPLATE,
                            Win32rc,
                            TargetTempName
                            );
                rc = ScepDosErrorToSceStatus(Win32rc);
#if DBG == 1
                SceDebugPrint(DEB_ERROR, "CopyFile to backup fails with %d\n", Win32rc);
#endif
            }
        }

        if ( SCESTATUS_SUCCESS == rc ) {
            //
            // now copy the temp file to the real sysvol file
            // make several attempts
            //
            int indx=0;
            while (indx < 5 ) {

                indx++;
                Win32rc = ERROR_SUCCESS;
                rc = SCESTATUS_SUCCESS;

                if ( FALSE == CopyFile( InfProfileName,
                                    szInfProfileName, FALSE ) ) {

                    Win32rc = GetLastError();
                    ScepBuildErrorLogInfo(
                                Win32rc,
                                Errlog,
                                IDS_ERROR_COPY_TEMPLATE,
                                Win32rc,
                                szInfProfileName
                                );
                    rc = ScepDosErrorToSceStatus(Win32rc);
#if DBG == 1
                    SceDebugPrint(DEB_WARN, "%d attempt of CopyFile fails with %d\n", indx, Win32rc);
#endif

                } else {
                    break;
                }

                Sleep(100);
            }

            ASSERT(ERROR_SUCCESS == Win32rc);

        }
    }

    //
    // delete the temp file for both success and failure case
    //
    DeleteFile(InfProfileName);
    LocalFree(InfProfileName);

    if ( TargetTempName ) {

    //
    // leave the file there if copy fails.
    //
        if ( rc == SCESTATUS_SUCCESS )
            DeleteFile(TargetTempName);

        LocalFree(TargetTempName);
    }
    return(rc);
}


SCESTATUS
SceInfpWriteSystemAccess(
    IN PCWSTR  ProfileName,
    IN PSCE_PROFILE_INFO pSCEinfo,
    IN BOOL bOverwrite,
    OUT PSCE_ERROR_LOG_INFO *Errlog OPTIONAL
    )
/*++
Routine Description:

   This routine writes system access area information to the INF file
   in section [System Access].

Arguments:

   ProfileName   - The profile to write to

   pSCEinfo       - the profile info (SCP) to write.

   Errlog     -     A buffer to hold all error codes/text encountered when
                    parsing the INF file. If Errlog is NULL, no further error
                    information is returned except the return DWORD

Return value:

   SCESTATUS -  SCESTATUS_SUCCESS
               SCESTATUS_NOT_ENOUGH_RESOURCE
               SCESTATUS_INVALID_PARAMETER
               SCESTATUS_CORRUPT_PROFILE
               SCESTATUS_INVALID_DATA

--*/

{
    SCESTATUS      rc=SCESTATUS_SUCCESS;
    DWORD         Value;
    PWSTR         Strvalue=NULL;
    DWORD         TotalSize=0;

    SCE_KEY_LOOKUP AccessSCPLookup[] = {
        {(PWSTR)TEXT("MinimumPasswordAge"),           offsetof(struct _SCE_PROFILE_INFO, MinimumPasswordAge),        'D'},
        {(PWSTR)TEXT("MaximumPasswordAge"),           offsetof(struct _SCE_PROFILE_INFO, MaximumPasswordAge),        'D'},
        {(PWSTR)TEXT("MinimumPasswordLength"),        offsetof(struct _SCE_PROFILE_INFO, MinimumPasswordLength),     'D'},
        {(PWSTR)TEXT("PasswordComplexity"),           offsetof(struct _SCE_PROFILE_INFO, PasswordComplexity),        'D'},
        {(PWSTR)TEXT("PasswordHistorySize"),          offsetof(struct _SCE_PROFILE_INFO, PasswordHistorySize),       'D'},
        {(PWSTR)TEXT("LockoutBadCount"),              offsetof(struct _SCE_PROFILE_INFO, LockoutBadCount),           'D'},
        {(PWSTR)TEXT("ResetLockoutCount"),            offsetof(struct _SCE_PROFILE_INFO, ResetLockoutCount),         'D'},
        {(PWSTR)TEXT("LockoutDuration"),              offsetof(struct _SCE_PROFILE_INFO, LockoutDuration),           'D'},
        {(PWSTR)TEXT("RequireLogonToChangePassword"), offsetof(struct _SCE_PROFILE_INFO, RequireLogonToChangePassword), 'D'},
        {(PWSTR)TEXT("ForceLogoffWhenHourExpire"),    offsetof(struct _SCE_PROFILE_INFO, ForceLogoffWhenHourExpire), 'D'},
        {(PWSTR)TEXT("NewAdministratorName"),         0,                                                            'A'},
        {(PWSTR)TEXT("NewGuestName"),                 0,                                                            'G'},
        {(PWSTR)TEXT("ClearTextPassword"),            offsetof(struct _SCE_PROFILE_INFO, ClearTextPassword),         'D'},
        {(PWSTR)TEXT("LSAAnonymousNameLookup"),       offsetof(struct _SCE_PROFILE_INFO, LSAAnonymousNameLookup), 'D'},
        {(PWSTR)TEXT("EnableAdminAccount"),          offsetof(struct _SCE_PROFILE_INFO, EnableAdminAccount), 'D'},
        {(PWSTR)TEXT("EnableGuestAccount"),          offsetof(struct _SCE_PROFILE_INFO, EnableGuestAccount), 'D'}
        };

    DWORD       cAccess = sizeof(AccessSCPLookup) / sizeof(SCE_KEY_LOOKUP);

    DWORD       i, j;
    UINT        Offset;
    PWSTR       EachLine[25];
    DWORD       EachSize[25];
    DWORD       Len;


    if (ProfileName == NULL || pSCEinfo == NULL )
        return(SCESTATUS_INVALID_PARAMETER);

    for ( i=0, j=0; i<cAccess; i++) {

        EachLine[i] = NULL;
        EachSize[i] = 0;

        //
        // get settings in AccessLookup table
        //

        Offset = AccessSCPLookup[i].Offset;

        Value = 0;
        Strvalue = NULL;
        Len = wcslen(AccessSCPLookup[i].KeyString);

        switch ( AccessSCPLookup[i].BufferType ) {
        case 'B':

            //
            // Int Field
            //
            Value = *((BOOL *)((CHAR *)pSCEinfo+Offset)) ? 1 : 0;
            EachSize[j] = Len+5;
            break;
        case 'D':

            //
            // Int Field
            //
            Value = *((DWORD *)((CHAR *)pSCEinfo+Offset));
            if ( Value != SCE_NO_VALUE )
                EachSize[j] = Len+15;
            break;
        default:

            //
            // String Field
            //
            switch( AccessSCPLookup[i].BufferType ) {
            case 'A':
                Strvalue = pSCEinfo->NewAdministratorName;
                break;
            case 'G':
                Strvalue = pSCEinfo->NewGuestName;
                break;
            default:
                Strvalue = *((PWSTR *)((CHAR *)pSCEinfo+Offset));
                break;
            }
            if ( Strvalue != NULL ) {
                EachSize[j] = Len+5+wcslen(Strvalue);
            }
            break;
        }

        if ( EachSize[j] <= 0 )
            continue;

        if ( bOverwrite ) {

            Len=(EachSize[j]+1)*sizeof(WCHAR);

            EachLine[j] = (PWSTR)ScepAlloc( LMEM_ZEROINIT, Len);
            if ( EachLine[j] == NULL ) {
                rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
                goto Done;
            }

            if (AccessSCPLookup[i].BufferType != 'B' &&
                AccessSCPLookup[i].BufferType != 'D') {

                swprintf(EachLine[j], L"%s = \"%s\"", AccessSCPLookup[i].KeyString, Strvalue);

            } else {
                swprintf(EachLine[j], L"%s = %d", AccessSCPLookup[i].KeyString, Value);
                EachSize[j] = wcslen(EachLine[j]);
            }
        } else {

            //
            // in append mode, we have to write each line separately
            //

            if (AccessSCPLookup[i].BufferType == 'B' ||
                AccessSCPLookup[i].BufferType == 'D') {

                ScepWriteOneIntValueToProfile(
                    ProfileName,
                    szSystemAccess,
                    AccessSCPLookup[i].KeyString,
                    Value
                    );

            } else if ( Strvalue ) {

                WritePrivateProfileString (szSystemAccess,
                                       AccessSCPLookup[i].KeyString,
                                       Strvalue,
                                       ProfileName);
            }
        }

        TotalSize += EachSize[j]+1;
        j++;

    }

    //
    // writes the profile section
    //
    if ( bOverwrite ) {

        if ( j > 0 ) {

            rc = SceInfpWriteInfSection(
                        ProfileName,
                        szSystemAccess,
                        TotalSize+1,
                        EachLine,
                        &EachSize[0],
                        0,
                        j-1,
                        Errlog
                        );
        } else {

            WritePrivateProfileSection(
                        szSystemAccess,
                        NULL,
                        ProfileName);

        }
    }

Done:

    for ( i=0; i<cAccess; i++ ) {

        if ( EachLine[i] != NULL ) {
            ScepFree(EachLine[i]);
        }

        EachLine[i] = NULL;
        EachSize[i] = 0;
    }

    return(rc);
}

SCESTATUS
SceInfpWritePrivileges(
    IN PCWSTR ProfileName,
    IN PSCE_PRIVILEGE_ASSIGNMENT pPrivileges,
    IN BOOL bOverwrite,
    OUT PSCE_ERROR_LOG_INFO *Errlog OPTIONAL
    )
/* ++
Routine Description:

   This routine writes privilege assignments info from the SCP buffer
   into the INF file in section [Privilege Rights].

Arguments:

   ProfileName   - the inf profile name

   pPrivileges   - the privilege assignment buffer.

   Errlog        - The error list encountered inside inf processing.

Return value:

   SCESTATUS -  SCESTATUS_SUCCESS
               SCESTATUS_NOT_ENOUGH_RESOURCE
               SCESTATUS_INVALID_PARAMETER
               SCESTATUS_BAD_FORMAT
               SCESTATUS_INVALID_DATA

-- */
{
    SCESTATUS                  rc;
    PSCE_PRIVILEGE_ASSIGNMENT  pCurRight=NULL;
    PSCE_NAME_LIST             pNameList=NULL;
    LONG                      Keysize;
    PWSTR                     Strvalue=NULL;
    DWORD                     TotalSize;

    //
    // [Privilege Rights] section
    //

    if (ProfileName == NULL )
        return(SCESTATUS_INVALID_PARAMETER);

    if ( pPrivileges == NULL ) {
        //
        // the buffer doesn't contain any privileges
        // empty the section in the file
        //
        if ( bOverwrite ) {
            WritePrivateProfileString(
                        szPrivilegeRights,
                        NULL,
                        NULL,
                        ProfileName
                        );
        }
        return(SCESTATUS_SUCCESS);
    }

    //
    // open lsa policy handle for sid/name lookup
    //
    LSA_HANDLE LsaHandle=NULL;

    rc = RtlNtStatusToDosError(
              ScepOpenLsaPolicy(
                    POLICY_LOOKUP_NAMES | POLICY_VIEW_LOCAL_INFORMATION,
                    &LsaHandle,
                    TRUE
                    ));

    if ( ERROR_SUCCESS != rc ) {
        ScepBuildErrorLogInfo(
                    rc,
                    Errlog,
                    SCEERR_ADD,
                    TEXT("LSA")
                    );
        return(ScepDosErrorToSceStatus(rc));
    }

    for (pCurRight=pPrivileges, TotalSize=0;
         pCurRight != NULL;
         pCurRight = pCurRight->Next) {
        //
        // Each privilege assignment contains the privilege's name and a list
        // of user/groups to assign to.
        //
        Keysize = SceInfpConvertNameListToString(
                          LsaHandle,
                          pCurRight->Name,
                          pCurRight->AssignedTo,
                          bOverwrite,
                          &Strvalue,
                          Errlog
                          );
        if ( Keysize >= 0 && Strvalue ) {

            if ( bOverwrite ) {
                rc = ScepAddToNameList(&pNameList, Strvalue, Keysize);
                if ( rc != SCESTATUS_SUCCESS ) { //win32 error code

                    ScepBuildErrorLogInfo(
                                rc,
                                Errlog,
                                SCEERR_ADD,
                                pCurRight->Name
                                );
                    goto Done;
                }
                TotalSize += Keysize + 1;

            } else {
                //
                // in append mode, write one line at a time
                //
                WritePrivateProfileString( szPrivilegeRights,
                                           pCurRight->Name,
                                           Strvalue,
                                           ProfileName
                                         );
            }

        } else if ( Keysize == -1 ) {
            rc = ERROR_EXTENDED_ERROR;
            goto Done;
        }

        ScepFree(Strvalue);
        Strvalue = NULL;
    }

    //
    // writes the profile section
    //
    if ( bOverwrite ) {

        rc = SceInfpWriteListSection(
                    ProfileName,
                    szPrivilegeRights,
                    TotalSize+1,
                    pNameList,
                    0,    // do not overwrite section, do not add equal sign
                    Errlog
                    );
    }

Done:

    if ( Strvalue != NULL )
        ScepFree(Strvalue);

    ScepFreeNameList(pNameList);

    if ( LsaHandle ) {
        LsaClose(LsaHandle);
    }

    return( ScepDosErrorToSceStatus(rc) );
}



SCESTATUS
SceInfpWriteUserSettings(
   IN PCWSTR ProfileName,
   IN PSCE_NAME_LIST pProfiles,
   OUT PSCE_ERROR_LOG_INFO *Errlog OPTIONAL
   )
/* ++
Routine Description:

   This routine writes user settings information from the SCP buffer
   into the INF file in section [Account Profiles].

Arguments:

   ProfileName   - the inf profile name

   pProfiles     - a list of profiles to write to the section.

   Errlog        - The error list encountered inside inf processing.

Return value:

   SCESTATUS -  SCESTATUS_SUCCESS
               SCESTATUS_OTHER_ERROR

-- */
{
    DWORD                       rc;
    PSCE_NAME_LIST               pCurProfile;
    DWORD                       TotalSize;

    if (ProfileName == NULL )
        return(SCESTATUS_INVALID_PARAMETER);

    if ( pProfiles == NULL )
        return(SCESTATUS_SUCCESS);

    for (pCurProfile=pProfiles, TotalSize=0;
         pCurProfile != NULL;
         pCurProfile = pCurProfile->Next) {

        TotalSize += wcslen(pCurProfile->Name) + 3;  // " ="
    }

    //
    // write the accountProfile section
    //
    rc = SceInfpWriteListSection(
                ProfileName,
                szAccountProfiles,
                TotalSize+1,
                pProfiles,
                SCEINF_ADD_EQUAL_SIGN,
                Errlog
                );

    if ( rc != NO_ERROR ) {
        ScepBuildErrorLogInfo(rc, Errlog,
                              SCEERR_WRITE_INFO,
                              szAccountProfiles
                              );
        return(ScepDosErrorToSceStatus(rc));

    } else
        return(SCESTATUS_SUCCESS);
}


SCESTATUS
SceInfpWriteGroupMembership(
    IN PCWSTR ProfileName,
    IN PSCE_GROUP_MEMBERSHIP pGroupMembership,
    IN BOOL bOverwrite,
    OUT PSCE_ERROR_LOG_INFO *Errlog OPTIONAL
    )
/* ++
Routine Description:

   This routine writes group membership information to the SCP INF file in
   [Group Membership] section.

Arguments:

   ProfileName - the INF profile name

   pGroupMembership  - the group membership info

   Errlog    - the error list for errors encountered in this routine.

Return value:

   SCESTATUS - SCESTATUS_SUCCESS
              SCESTATUS_NOT_ENOUGH_RESOURCE
              SCESTATUS_INVALID_PARAMETER
              SCESTATUS_BAD_FORMAT
              SCESTATUS_INVALID_DATA
-- */
{
    PSCE_GROUP_MEMBERSHIP    pGroupMembers=NULL;
    PWSTR                   Strvalue=NULL;
    LONG                    Keysize;
    SCESTATUS                rc=SCESTATUS_SUCCESS;
    DWORD                   TotalSize;
    PSCE_NAME_LIST           pNameList=NULL;
    PWSTR                   Keyname=NULL;
    DWORD                   Len;
    PWSTR                   SidString=NULL;

    if (ProfileName == NULL )
        return(SCESTATUS_INVALID_PARAMETER);

    if ( pGroupMembership == NULL ) {
        //
        // the buffer doesn't contain any groups
        // empty the section in the file
        //
        if ( bOverwrite ) {
            WritePrivateProfileString(
                        szGroupMembership,
                        NULL,
                        NULL,
                        ProfileName
                        );
        }
        return(SCESTATUS_SUCCESS);
    }

    //
    // open lsa policy handle for sid/name lookup
    //
    LSA_HANDLE LsaHandle=NULL;

    rc = RtlNtStatusToDosError(
              ScepOpenLsaPolicy(
                    POLICY_LOOKUP_NAMES | POLICY_VIEW_LOCAL_INFORMATION,
                    &LsaHandle,
                    TRUE
                    ));

    if ( ERROR_SUCCESS != rc ) {
        ScepBuildErrorLogInfo(
                    rc,
                    Errlog,
                    SCEERR_ADD,
                    TEXT("LSA")
                    );
        return(ScepDosErrorToSceStatus(rc));
    }

    //
    // process each group in the list
    //

    for ( pGroupMembers=pGroupMembership, TotalSize=0;
          pGroupMembers != NULL;
          pGroupMembers = pGroupMembers->Next ) {

        if ( (pGroupMembers->Status & SCE_GROUP_STATUS_NC_MEMBERS) &&
             (pGroupMembers->Status & SCE_GROUP_STATUS_NC_MEMBEROF) ) {
            continue;
        }

        if ( SidString ) {
            LocalFree(SidString);
            SidString = NULL;
        }

        Len = 0;

        if ( wcschr(pGroupMembers->GroupName, L'\\') ) {
            //
            // convert group name into *SID format
            //

            ScepConvertNameToSidString(
                        LsaHandle,
                        pGroupMembers->GroupName,
                        FALSE,
                        &SidString,
                        &Len
                        );
        }
        else {
            if ( ScepLookupNameTable(pGroupMembers->GroupName, &SidString) ) {
                Len = wcslen(SidString);
            }
        }

        if ( SidString == NULL ) {
            Len = wcslen(pGroupMembers->GroupName);
        }

        Keyname = (PWSTR)ScepAlloc( 0, (Len+15)*sizeof(WCHAR));
        if ( Keyname == NULL ) {
            rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
            goto Done;
        }

        if ( SidString ) {
            wcsncpy(Keyname, SidString, Len);
        } else {
            wcsncpy(Keyname, pGroupMembers->GroupName, Len);
        }

        if ( !(pGroupMembers->Status & SCE_GROUP_STATUS_NC_MEMBERS) ) {

            wcscpy(Keyname+Len, szMembers);

            Keyname[Len+9] = L'\0';

            //
            // convert the member list into a string
            //
            Keysize = SceInfpConvertNameListToString(
                              LsaHandle,
                              Keyname,
                              pGroupMembers->pMembers,
                              bOverwrite,
                              &Strvalue,
                              Errlog
                              );
            if ( Keysize >= 0 && Strvalue ) {

                if ( bOverwrite ) {

                    rc = ScepAddToNameList(&pNameList, Strvalue, Keysize);
                    if ( rc != SCESTATUS_SUCCESS ) {

                        ScepBuildErrorLogInfo(
                                    rc,
                                    Errlog,
                                    SCEERR_ADD_MEMBERS,
                                    pGroupMembers->GroupName
                                    );

                        rc = ScepDosErrorToSceStatus(rc);
                        goto Done;
                    }
                } else {
                    //
                    // append mode, write one line at a time
                    //
                    WritePrivateProfileString( szGroupMembership,
                                               Keyname,
                                               Strvalue,
                                               ProfileName
                                             );
                }
                TotalSize += Keysize + 1;

            } else if ( Keysize == -1 ) {
                rc = SCESTATUS_OTHER_ERROR;
                goto Done;
            }

            ScepFree(Strvalue);
            Strvalue = NULL;

        }

        if ( !(pGroupMembers->Status & SCE_GROUP_STATUS_NC_MEMBEROF) ) {

            //
            // convert the memberof list into a string
            //
            swprintf(Keyname+Len, L"%s", szMemberof);
            Keyname[Len+10] = L'\0';

            Keysize = SceInfpConvertNameListToString(
                              LsaHandle,
                              Keyname,
                              pGroupMembers->pMemberOf,
                              bOverwrite,
                              &Strvalue,
                              Errlog
                              );
            if ( Keysize >= 0 && Strvalue ) {

                if ( bOverwrite ) {

                    rc = ScepAddToNameList(&pNameList, Strvalue, Keysize);
                    if ( rc != SCESTATUS_SUCCESS ) {

                        ScepBuildErrorLogInfo(
                                    rc,
                                    Errlog,
                                    SCEERR_ADD_MEMBEROF,
                                    pGroupMembers->GroupName
                                    );

                        rc = ScepDosErrorToSceStatus(rc);
                        goto Done;
                    }
                } else {
                    //
                    // in append mode, write one line at a time
                    //
                    WritePrivateProfileString( szGroupMembership,
                                               Keyname,
                                               Strvalue,
                                               ProfileName
                                             );
                }
                TotalSize += Keysize + 1;

            } else if ( Keysize == -1 ) {
                rc = SCESTATUS_OTHER_ERROR;
                goto Done;
            }

            ScepFree(Strvalue);
            Strvalue = NULL;
        }
    }

    //
    // write to this profile's section
    //

    if ( bOverwrite ) {
        rc = SceInfpWriteListSection(
                ProfileName,
                szGroupMembership,
                TotalSize+1,
                pNameList,
                0,
                Errlog
                );

        rc = ScepDosErrorToSceStatus(rc);
    }

Done:

    if ( Keyname != NULL )
        ScepFree(Keyname);

    if ( Strvalue != NULL )
        ScepFree(Strvalue);

    if ( SidString ) {
        LocalFree(SidString);
    }

    ScepFreeNameList(pNameList);

    if ( LsaHandle ) {
        LsaClose(LsaHandle);
    }

    return(rc);
}


SCESTATUS
SceInfpWriteObjects(
    IN PCWSTR ProfileName,
    IN PCWSTR SectionName,
    IN PSCE_OBJECT_ARRAY pObjects,
    IN BOOL bOverwrite,
    OUT PSCE_ERROR_LOG_INFO *Errlog OPTIONAL
   )
/* ++
Routine Description:

   This routine writes registry or files security information (names and
   security descriptors) into the INF SCP file in the section provided.

Arguments:

   ProfileName   - the SCP INF file name

   SectionName   - a individual section name to retrieve. NULL = all sections for
                   the area.

   pObjects      - the buffer of objects to write.

   Errlog   - the cummulative error list to hold errors encountered in this routine.

Return value:

   SCESTATUS - SCESTATUS_SUCCESS
              SCESTATUS_NOT_ENOUGH_RESOURCE
              SCESTATUS_INVALID_PARAMETER
              SCESTATUS_BAD_FORMAT
              SCESTATUS_INVALID_DATA
-- */
{
    SCESTATUS            rc=SCESTATUS_SUCCESS;
    PSCE_NAME_LIST       pNameList=NULL;
    DWORD               TotalSize=0;
    DWORD               i, ObjectSize;


    if (ProfileName == NULL || SectionName == NULL )
        return(SCESTATUS_INVALID_PARAMETER);

    if ( pObjects == NULL || pObjects->Count == 0 ) {
        //
        // the buffer doesn't contain any objects
        // empty the section in the file
        //
        if ( bOverwrite ) {
            WritePrivateProfileString(
                        SectionName,
                        NULL,
                        NULL,
                        ProfileName
                        );
        }

        return(SCESTATUS_SUCCESS);
    }

    for ( i=0; i<pObjects->Count; i++) {

        //
        // Get string fields. Don't care the key name or if it exist.
        // Must have 3 fields each line.
        //
        rc = SceInfpWriteOneObject(
                        pObjects->pObjectArray[i],
                        &pNameList,
                        &ObjectSize,
                        Errlog
                        );
        if ( rc != SCESTATUS_SUCCESS ) {
            ScepBuildErrorLogInfo(
                        rc,
                        Errlog,
                        SCEERR_WRITE_INFO,
                        pObjects->pObjectArray[i]->Name
                        );
            goto Done;
        }
        TotalSize += ObjectSize + 1;
    }

    //
    // write to this profile's section
    //

    rc = SceInfpWriteListSection(
            ProfileName,
            SectionName,
            TotalSize+1,
            pNameList,
            bOverwrite ? 0 : SCEINF_APPEND_SECTION,
            Errlog
            );

    if ( rc != SCESTATUS_SUCCESS ) {

        ScepBuildErrorLogInfo(
                    rc,
                    Errlog,
                    SCEERR_WRITE_INFO,
                    SectionName
                    );
    }

Done:

    ScepFreeNameList(pNameList);

    rc = ScepDosErrorToSceStatus(rc);

    return(rc);

}


SCESTATUS
SceInfpWriteServices(
    IN PCWSTR ProfileName,
    IN PCWSTR SectionName,
    IN PSCE_SERVICES pServices,
    IN BOOL bOverwrite,
    OUT PSCE_ERROR_LOG_INFO *Errlog OPTIONAL
   )
/* ++
Routine Description:

   This routine writes system services general settings (startup and
   security descriptors) into the INF SCP file in the section provided.

Arguments:

   ProfileName   - the SCP INF file name

   SectionName   - a individual section name to retrieve. NULL = all sections for
                   the area.

   pServices      - the buffer of services to write.

   Errlog   - the cummulative error list to hold errors encountered in this routine.

Return value:

   SCESTATUS - SCESTATUS_SUCCESS
              SCESTATUS_NOT_ENOUGH_RESOURCE
              SCESTATUS_INVALID_PARAMETER
              SCESTATUS_BAD_FORMAT
              SCESTATUS_INVALID_DATA
-- */
{
    SCESTATUS            rc=SCESTATUS_SUCCESS;
    PSCE_NAME_LIST       pNameList=NULL;
    PSCE_SERVICES        pNode;
    DWORD               TotalSize=0;
    DWORD               ObjectSize;


    if (ProfileName == NULL || SectionName == NULL )
        return(SCESTATUS_INVALID_PARAMETER);

    if ( pServices == NULL ) {
        //
        // the buffer doesn't contain any services
        // empty the section in the file
        //
        if ( bOverwrite ) {
            WritePrivateProfileString(
                        SectionName,
                        NULL,
                        NULL,
                        ProfileName
                        );
        }
        return(SCESTATUS_SUCCESS);
    }

    for ( pNode=pServices; pNode != NULL; pNode = pNode->Next) {

        //
        // write string fields.
        //
        rc = SceInfpWriteOneService(
                        pNode,
                        &pNameList,
                        &ObjectSize,
                        Errlog
                        );
        if ( rc != SCESTATUS_SUCCESS ) {
            ScepBuildErrorLogInfo(
                        rc,
                        Errlog,
                        SCEERR_WRITE_INFO,
                        pNode->ServiceName
                        );
            goto Done;
        }
        TotalSize += ObjectSize + 1;
    }

    //
    // write to this profile's section
    //
    rc = SceInfpWriteListSection(
                ProfileName,
                SectionName,
                TotalSize+1,
                pNameList,
                bOverwrite ? 0 : SCEINF_APPEND_SECTION,
                Errlog
                );

    if ( rc != SCESTATUS_SUCCESS ) {

        ScepBuildErrorLogInfo(
                    rc,
                    Errlog,
                    SCEERR_WRITE_INFO,
                    SectionName
                    );
    }

Done:

    ScepFreeNameList(pNameList);

    rc = ScepDosErrorToSceStatus(rc);

    return(rc);

}


DWORD
SceInfpWriteOneObject(
    IN PSCE_OBJECT_SECURITY pObject,
    OUT PSCE_NAME_LIST *pNameList,
    OUT PDWORD ObjectSize,
    OUT PSCE_ERROR_LOG_INFO *Errlog OPTIONAL
    )
/* ++
Routine Description:

   This routine builds security descriptor text for one object (a registry key,
   or a file) into the name list. Each object represents one line in the INF file.

Arguments:

   pObject  - The object's security settings

   pNameList - The output string list.

   TotalSize  - the total size of the list

   Errlog    - The cummulative error list for errors encountered in this routine

Return value:

   SCESTATUS - SCESTATUS_SUCCESS
              SCESTATUS_NOT_ENOUGH_RESOURCE
              SCESTATUS_INVALID_PARAMETER
              SCESTATUS_BAD_FORMAT
              SCESTATUS_INVALID_DATA
-- */
{
    DWORD         rc;
    PWSTR         Strvalue=NULL;
    PWSTR         SDspec=NULL;
    DWORD         SDsize=0;
    DWORD         nFields;
    DWORD         *aFieldOffset=NULL;
    DWORD         i;


    *ObjectSize = 0;
    if ( pObject == NULL )
        return(ERROR_SUCCESS);

    if ( pObject->pSecurityDescriptor != NULL ) {

        //
        // convert security to text
        //
        rc = ConvertSecurityDescriptorToText(
                           pObject->pSecurityDescriptor,
                           pObject->SeInfo,
                           &SDspec,
                           &SDsize
                           );
        if ( rc != NO_ERROR ) {
            ScepBuildErrorLogInfo(
                       rc,
                       Errlog,
                       SCEERR_BUILD_SD,
                       pObject->Name
                       );
            return(rc);
        }
    }

    //
    // The Registry/File INF layout must have more than 3 fields for each line.
    // The first field is the key/file name, the 2nd field is the status
    // flag, and the 3rd field and after is the security descriptor in text
    //
    //
    // security descriptor in text is broken into multiple fields if the length
    // is greater than MAX_STRING_LENGTH  (the limit of setupapi). The break point
    // is at the following characters: ) ( ; " or space
    //
    rc = SceInfpBreakTextIntoMultiFields(SDspec, SDsize, &nFields, &aFieldOffset);

    if ( SCESTATUS_SUCCESS != rc ) {

        rc = ScepSceStatusToDosError(rc);
        goto Done;
    }
    //
    // each extra field will use 3 more chars : ,"<field>"
    //
    *ObjectSize = wcslen(pObject->Name)+5 + SDsize;
    if ( nFields ) {
        *ObjectSize += 3*nFields;
    } else {
        *ObjectSize += 2;
    }
    //
    // allocate the output buffer
    //
    Strvalue = (PWSTR)ScepAlloc(LMEM_ZEROINIT, (*ObjectSize+1) * sizeof(WCHAR) );

    if ( Strvalue == NULL ) {
        rc = ERROR_NOT_ENOUGH_MEMORY;
        goto Done;
    }
    //
    // copy data into the buffer
    //
    if ( SDspec != NULL ) {

        if ( nFields == 0 || !aFieldOffset ) {
            swprintf(Strvalue, L"\"%s\",%1d,\"%s\"", pObject->Name, pObject->Status, SDspec);
        } else {
            //
            // loop through the fields
            //
            swprintf(Strvalue, L"\"%s\",%1d\0", pObject->Name, pObject->Status);

            for ( i=0; i<nFields; i++ ) {

                if ( aFieldOffset[i] < SDsize ) {

                    wcscat(Strvalue, L",\"");
                    if ( i == nFields-1 ) {
                        //
                        // the last field
                        //
                        wcscat(Strvalue, SDspec+aFieldOffset[i]);
                    } else {

                        wcsncat(Strvalue, SDspec+aFieldOffset[i],
                                aFieldOffset[i+1]-aFieldOffset[i]);
                    }
                    wcscat(Strvalue, L"\"");
                }
            }
        }

    } else
        swprintf(Strvalue, L"\"%s\",%1d,\"\"", pObject->Name, pObject->Status);

    rc = ScepAddToNameList(pNameList, Strvalue, *ObjectSize);

    ScepFree(Strvalue);

Done:

    if ( aFieldOffset ) {
        ScepFree(aFieldOffset);
    }

    if ( SDspec != NULL )
        ScepFree(SDspec);

    return(rc);

}


DWORD
SceInfpWriteOneService(
    IN PSCE_SERVICES pService,
    OUT PSCE_NAME_LIST *pNameList,
    OUT PDWORD ObjectSize,
    OUT PSCE_ERROR_LOG_INFO *Errlog OPTIONAL
    )
/* ++
Routine Description:

   This routine builds security descriptor text for one object (a registry key,
   or a file) into the name list. Each object represents one line in the INF file.

Arguments:

   pService  - The service's general setting

   pNameList - The output string list.

   TotalSize  - the total size of the list

   Errlog    - The cummulative error list for errors encountered in this routine

Return value:

   Win32 error

-- */
{
    DWORD         rc;
    PWSTR         Strvalue=NULL;
    PWSTR         SDspec=NULL;
    DWORD         SDsize=0;
    DWORD         nFields;
    DWORD         *aFieldOffset=NULL;
    DWORD         i;


    *ObjectSize = 0;
    if ( pService == NULL )
        return(ERROR_SUCCESS);

    if ( pService->General.pSecurityDescriptor != NULL ) {

        //
        // convert security to text
        //
        rc = ConvertSecurityDescriptorToText(
                           pService->General.pSecurityDescriptor,
                           pService->SeInfo,
                           &SDspec,
                           &SDsize
                           );
        if ( rc != NO_ERROR ) {
            ScepBuildErrorLogInfo(
                       rc,
                       Errlog,
                       SCEERR_BUILD_SD,
                       pService->ServiceName
                       );
            return(rc);
        }
    }

    //
    // The service INF layout must have 3 or more fields for each line.
    // The first field is the service name, the 2nd field is the startup
    // flag, and the 3rd field and after is the security descriptor in text
    //
    //
    // security descriptor in text is broken into multiple fields if the length
    // is greater than MAX_STRING_LENGTH  (the limit of setupapi). The break point
    // is at the following characters: ) ( ; " or space
    //
    rc = SceInfpBreakTextIntoMultiFields(SDspec, SDsize, &nFields, &aFieldOffset);

    if ( SCESTATUS_SUCCESS != rc ) {
        rc = ScepSceStatusToDosError(rc);
        goto Done;
    }
    //
    // each extra field will use 3 more chars : ,"<field>"
    //
    *ObjectSize = wcslen(pService->ServiceName)+3 + SDsize;
    if ( nFields ) {
        *ObjectSize += 3*nFields;
    } else {
        *ObjectSize += 2;
    }
    //
    // allocate the output buffer
    //
    Strvalue = (PWSTR)ScepAlloc(LMEM_ZEROINIT, (*ObjectSize+1) * sizeof(WCHAR) );

    if ( Strvalue == NULL ) {
        rc = ERROR_NOT_ENOUGH_MEMORY;
        goto Done;
    }
    //
    // copy data into the buffer
    //

    if ( SDspec != NULL ) {

        if ( nFields == 0 || !aFieldOffset ) {

            swprintf(Strvalue, L"%s,%1d,\"%s\"", pService->ServiceName,
                                                 pService->Startup, SDspec);
        } else {
            //
            // loop through the fields
            //
            swprintf(Strvalue, L"%s,%1d\0", pService->ServiceName, pService->Startup);

            for ( i=0; i<nFields; i++ ) {

                if ( aFieldOffset[i] < SDsize ) {

                    wcscat(Strvalue, L",\"");
                    if ( i == nFields-1 ) {
                        //
                        // the last field
                        //
                        wcscat(Strvalue, SDspec+aFieldOffset[i]);
                    } else {

                        wcsncat(Strvalue, SDspec+aFieldOffset[i],
                                aFieldOffset[i+1]-aFieldOffset[i]);
                    }
                    wcscat(Strvalue, L"\"");
                }
            }
        }

    } else {
        swprintf(Strvalue, L"%s,%1d,\"\"", pService->ServiceName, pService->Startup);
    }

    rc = ScepAddToNameList(pNameList, Strvalue, *ObjectSize);

    ScepFree(Strvalue);

Done:

    if ( aFieldOffset ) {
        ScepFree(aFieldOffset);
    }

    if ( SDspec != NULL )
        ScepFree(SDspec);

    return(rc);

}


SCESTATUS
SceInfpWriteAuditing(
   IN PCWSTR ProfileName,
   IN PSCE_PROFILE_INFO pSCEinfo,
   OUT PSCE_ERROR_LOG_INFO *Errlog OPTIONAL
   )
/* ++
Routine Description:

   This routine writes system auditing information into the SCP INF file
   in [System Log], [Security Log], [Application Log], [Event Audit],
   [Registry Audit], and [File Audit] sections.

Arguments:

   ProfileName - The INF profile's name

   pSCEinfo  - the info buffer to write.

   Errlog   - The cummulative error list to hold errors encountered in this routine.

Return value:

   SCESTATUS - SCESTATUS_SUCCESS
              SCESTATUS_NOT_ENOUGH_RESOURCE
              SCESTATUS_INVALID_PARAMETER
              SCESTATUS_BAD_FORMAT
              SCESTATUS_INVALID_DATA
-- */
{

    SCESTATUS            rc;

    DWORD               LogSize;
    DWORD               Periods;
    DWORD               RetentionDays;
    DWORD               RestrictGuest;

    PCWSTR              szAuditLog;
    DWORD               i, j;
    PWSTR               EachLine[10];
    DWORD               EachSize[10];
    DWORD               TotalSize=0;


    if (ProfileName == NULL || pSCEinfo == NULL )
        return(SCESTATUS_INVALID_PARAMETER);

    //
    // Writes Log setting for system log, security log and application log
    //
    for ( i=0; i<3; i++) {

        // get the section name
        switch (i) {
        case 0:
            szAuditLog = szAuditSystemLog;
            break;
        case 1:
            szAuditLog = szAuditSecurityLog;
            break;
        default:
            szAuditLog = szAuditApplicationLog;
            break;
        }

        // set audit log setting
        LogSize = pSCEinfo->MaximumLogSize[i];
        Periods = pSCEinfo->AuditLogRetentionPeriod[i];
        RetentionDays = pSCEinfo->RetentionDays[i];
        RestrictGuest = pSCEinfo->RestrictGuestAccess[i];

        //
        // writes the setting to the section
        //
        rc = SceInfpWriteAuditLogSetting(
                        ProfileName,
                        szAuditLog,
                        LogSize,
                        Periods,
                        RetentionDays,
                        RestrictGuest,
                        Errlog
                        );

        if ( rc != SCESTATUS_SUCCESS )
            return(rc);
    }

    //
    // fill the array
    //
    for (i=0; i<10; i++) {
        EachLine[i] = NULL;
        EachSize[i] = 25;
    }
    j = 0;

    //
    // process each attribute for event auditing
    //
    // AuditSystemEvents
    //
    if ( pSCEinfo->AuditSystemEvents != SCE_NO_VALUE ) {
        EachLine[j] = (PWSTR)ScepAlloc((UINT)0, EachSize[j]*sizeof(WCHAR));

        if ( EachLine[j] != NULL ) {
            swprintf(EachLine[j], L"AuditSystemEvents = %d\0", pSCEinfo->AuditSystemEvents);
            EachSize[j] = wcslen(EachLine[j]);
            TotalSize += EachSize[j] + 1;
            j++;
        } else {
            rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
            goto Done;
        }
    }

    // AuditLogonEvents
    if ( pSCEinfo->AuditLogonEvents != SCE_NO_VALUE ) {
        EachLine[j] = (PWSTR)ScepAlloc((UINT)0, EachSize[j]*sizeof(WCHAR));

        if ( EachLine[j] != NULL ) {
            swprintf(EachLine[j], L"AuditLogonEvents = %d\0", pSCEinfo->AuditLogonEvents);
            EachSize[j] = wcslen(EachLine[j]);
            TotalSize += EachSize[j] + 1;
            j++;
        } else {
            rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
            goto Done;
        }
    }

    // AuditObjectAccess
    if ( pSCEinfo->AuditObjectAccess != SCE_NO_VALUE ) {
        EachLine[j] = (PWSTR)ScepAlloc((UINT)0, EachSize[j]*sizeof(WCHAR));

        if ( EachLine[j] != NULL ) {
            swprintf(EachLine[j], L"AuditObjectAccess = %d\0", pSCEinfo->AuditObjectAccess);
            EachSize[j] = wcslen(EachLine[j]);
            TotalSize += EachSize[j] + 1;
            j++;
        } else {
            rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
            goto Done;
        }
    }

    // AuditPrivilegeUse
    if ( pSCEinfo->AuditPrivilegeUse != SCE_NO_VALUE ) {
        EachLine[j] = (PWSTR)ScepAlloc((UINT)0, EachSize[j]*sizeof(WCHAR));

        if ( EachLine[j] != NULL ) {
            swprintf(EachLine[j], L"AuditPrivilegeUse = %d\0", pSCEinfo->AuditPrivilegeUse);
            EachSize[j] = wcslen(EachLine[j]);
            TotalSize += EachSize[j] + 1;
            j++;
        } else {
            rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
            goto Done;
        }
    }

    // AuditPolicyChange
    if ( pSCEinfo->AuditPolicyChange != SCE_NO_VALUE ) {
        EachLine[j] = (PWSTR)ScepAlloc((UINT)0, EachSize[j]*sizeof(WCHAR));

        if ( EachLine[j] != NULL ) {
            swprintf(EachLine[j], L"AuditPolicyChange = %d\0", pSCEinfo->AuditPolicyChange);
            EachSize[j] = wcslen(EachLine[j]);
            TotalSize += EachSize[j] + 1;
            j++;
        } else {
            rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
            goto Done;
        }
    }

    // AuditAccountManage
    if ( pSCEinfo->AuditAccountManage != SCE_NO_VALUE ) {
        EachLine[j] = (PWSTR)ScepAlloc((UINT)0, EachSize[j]*sizeof(WCHAR));

        if ( EachLine[j] != NULL ) {
            swprintf(EachLine[j], L"AuditAccountManage = %d\0", pSCEinfo->AuditAccountManage);
            EachSize[j] = wcslen(EachLine[j]);
            TotalSize += EachSize[j] + 1;
            j++;
        } else {
            rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
            goto Done;
        }
    }

    // AuditprocessTracking
    if ( pSCEinfo->AuditProcessTracking != SCE_NO_VALUE ) {
        EachLine[j] = (PWSTR)ScepAlloc((UINT)0, EachSize[j]*sizeof(WCHAR));

        if ( EachLine[j] != NULL ) {
            swprintf(EachLine[j], L"AuditProcessTracking = %d\0", pSCEinfo->AuditProcessTracking);
            EachSize[j] = wcslen(EachLine[j]);
            TotalSize += EachSize[j] + 1;
            j++;
        } else {
            rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
            goto Done;
        }
    }

    // AuditDSAccess
    if ( pSCEinfo->AuditDSAccess != SCE_NO_VALUE ) {
        EachLine[j] = (PWSTR)ScepAlloc((UINT)0, EachSize[j]*sizeof(WCHAR));

        if ( EachLine[j] != NULL ) {
            swprintf(EachLine[j], L"AuditDSAccess = %d\0", pSCEinfo->AuditDSAccess);
            EachSize[j] = wcslen(EachLine[j]);
            TotalSize += EachSize[j] + 1;
            j++;
        } else {
            rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
            goto Done;
        }
    }

    // AuditAccountLogon
    if ( pSCEinfo->AuditAccountLogon != SCE_NO_VALUE ) {
        EachLine[j] = (PWSTR)ScepAlloc((UINT)0, EachSize[j]*sizeof(WCHAR));

        if ( EachLine[j] != NULL ) {
            swprintf(EachLine[j], L"AuditAccountLogon = %d\0", pSCEinfo->AuditAccountLogon);
            EachSize[j] = wcslen(EachLine[j]);
            TotalSize += EachSize[j] + 1;
            j++;
        } else {
            rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
            goto Done;
        }
    }

    //
    // Writes the section
    //

    if ( j > 0 ) {
        rc = SceInfpWriteInfSection(
                    ProfileName,
                    szAuditEvent,
                    TotalSize+1,
                    EachLine,
                    &EachSize[0],
                    0,
                    j-1,
                    Errlog
                    );
    } else {

        WritePrivateProfileSection(
                    szAuditEvent,
                    NULL,
                    ProfileName);
    }

Done:

    for ( i=0; i<10; i++ )
        if ( EachLine[i] != NULL ) {
            ScepFree(EachLine[i]);
        }
    return(rc);
}

SCESTATUS
SceInfpAppendAuditing(
    IN PCWSTR ProfileName,
    IN PSCE_PROFILE_INFO pSCEinfo,
    OUT PSCE_ERROR_LOG_INFO *Errlog OPTIONAL
    )
{

    SCESTATUS     rc=SCESTATUS_SUCCESS;
    DWORD         Value;

    SCE_KEY_LOOKUP AuditSCPLookup[] = {
        {(PWSTR)TEXT("AuditSystemEvents"),           offsetof(struct _SCE_PROFILE_INFO, AuditSystemEvents),        'D'},
        {(PWSTR)TEXT("AuditLogonEvents"),            offsetof(struct _SCE_PROFILE_INFO, AuditLogonEvents),         'D'},
        {(PWSTR)TEXT("AuditObjectAccess"),           offsetof(struct _SCE_PROFILE_INFO, AuditObjectAccess),        'D'},
        {(PWSTR)TEXT("AuditPrivilegeUse"),           offsetof(struct _SCE_PROFILE_INFO, AuditPrivilegeUse),        'D'},
        {(PWSTR)TEXT("AuditPolicyChange"),           offsetof(struct _SCE_PROFILE_INFO, AuditPolicyChange),        'D'},
        {(PWSTR)TEXT("AuditAccountManage"),          offsetof(struct _SCE_PROFILE_INFO, AuditAccountManage),       'D'},
        {(PWSTR)TEXT("AuditProcessTracking"),        offsetof(struct _SCE_PROFILE_INFO, AuditProcessTracking),     'D'},
        {(PWSTR)TEXT("AuditDSAccess"),               offsetof(struct _SCE_PROFILE_INFO, AuditDSAccess),            'D'},
        {(PWSTR)TEXT("AuditAccountLogon"),           offsetof(struct _SCE_PROFILE_INFO, AuditAccountLogon),        'D'}
        };

    DWORD       cAudit = sizeof(AuditSCPLookup) / sizeof(SCE_KEY_LOOKUP);
    PCWSTR              szAuditLog;
    DWORD       i;
    UINT        Offset;


    if (ProfileName == NULL || pSCEinfo == NULL )
        return(SCESTATUS_INVALID_PARAMETER);

    for ( i=0; i<3; i++) {

        // get the section name
        switch (i) {
        case 0:
            szAuditLog = szAuditSystemLog;
            break;
        case 1:
            szAuditLog = szAuditSecurityLog;
            break;
        default:
            szAuditLog = szAuditApplicationLog;
            break;
        }

        ScepWriteOneIntValueToProfile(
            ProfileName,
            szAuditLog,
            L"MaximumLogSize",
            pSCEinfo->MaximumLogSize[i]
            );

        ScepWriteOneIntValueToProfile(
            ProfileName,
            szAuditLog,
            L"AuditLogRetentionPeriod",
            pSCEinfo->AuditLogRetentionPeriod[i]
            );

        ScepWriteOneIntValueToProfile(
            ProfileName,
            szAuditLog,
            L"RetentionDays",
            pSCEinfo->RetentionDays[i]
            );

        ScepWriteOneIntValueToProfile(
            ProfileName,
            szAuditLog,
            L"RestrictGuestAccess",
            pSCEinfo->RestrictGuestAccess[i]
            );

    }

    for ( i=0; i<cAudit; i++) {

        //
        // get settings in AuditLookup table
        //

        Offset = AuditSCPLookup[i].Offset;

        switch ( AuditSCPLookup[i].BufferType ) {
        case 'D':

            //
            // Int Field
            //
            Value = *((DWORD *)((CHAR *)pSCEinfo+Offset));

            ScepWriteOneIntValueToProfile(
                ProfileName,
                szAuditEvent,
                AuditSCPLookup[i].KeyString,
                Value
                );

            break;
        default:
            break;
        }
    }

    return(rc);
}

SCESTATUS
ScepWriteOneIntValueToProfile(
    IN PCWSTR InfFileName,
    IN PCWSTR InfSectionName,
    IN PWSTR KeyName,
    IN DWORD Value
    )
{
    WCHAR TmpBuf[15];

    if ( Value == SCE_NO_VALUE ) {
        return(SCESTATUS_SUCCESS);
    }

    swprintf(TmpBuf, L"%d\0", Value);

    WritePrivateProfileString( InfSectionName,
                               KeyName,
                               TmpBuf,
                               InfFileName
                             );

    return(SCESTATUS_SUCCESS);
}


SCESTATUS
SceInfpWriteAuditLogSetting(
   IN PCWSTR  InfFileName,
   IN PCWSTR InfSectionName,
   IN DWORD LogSize,
   IN DWORD Periods,
   IN DWORD RetentionDays,
   IN DWORD RestrictGuest,
   OUT PSCE_ERROR_LOG_INFO *Errlog OPTIONAL
   )
/* ++
Routine Description:

   This routine retrieves audit log setting from the INF file (SCP and SAP)
   based on the SectionName passed in. The audit log settings include MaximumSize,
   RetentionPeriod and RetentionDays. There are 3 different logs (system,
   security, and application) which all have the same setting. The information
   returned in in LogSize, Periods, RetentionDays. These 3 output arguments will
   be reset at the begining of the routine. So if error occurs after the reset,
   the original values won't be set back.

Arguments:

   InfFileName - The INF file name to write to

   InfSectionName - Log section name (SAdtSystemLog, SAdtSecurityLog, SAdtApplicationLog)

   LogSize - The maximum size of the log

   Periods - The retention period of the log

   RetentionDays - The number of days for log retention

   Errlog - The error list

Return value:

   SCESTATUS - SCESTATUS_SUCCESS
              SCESTATUS_NOT_ENOUGH_RESOURCE
              SCESTATUS_INVALID_PARAMETER
              SCESTATUS_BAD_FORMAT
              SCESTATUS_INVALID_DATA
-- */
{

    SCESTATUS    rc=SCESTATUS_SUCCESS;
    PWSTR       EachLine[4];
    DWORD       EachSize[4];
    DWORD       TotalSize=0;
    DWORD       i;


    if (InfFileName == NULL || InfSectionName == NULL )
        return(SCESTATUS_INVALID_PARAMETER);

    //
    // initialize and fill the array
    //

    for ( i=0; i<4; i++ ) {
        EachLine[i] = NULL;
        EachSize[i] = 37;
    }
    i = 0;

    if ( LogSize != (DWORD)SCE_NO_VALUE ) {

        EachLine[i] = (PWSTR)ScepAlloc((UINT)0, EachSize[i]*sizeof(WCHAR));
        if ( EachLine[i] != NULL ) {
            swprintf(EachLine[i], L"MaximumLogSize = %d", LogSize);
            EachSize[i] = wcslen(EachLine[i]);
            TotalSize += EachSize[i] + 1;
            i++;
        } else {
            rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
            goto Done;
        }
    }

    if ( Periods != (DWORD)SCE_NO_VALUE ) {
        EachLine[i] = (PWSTR)ScepAlloc((UINT)0, EachSize[i]*sizeof(WCHAR));
        if ( EachLine[i] != NULL ) {
            swprintf(EachLine[i], L"AuditLogRetentionPeriod = %d", Periods);
            EachSize[i] = wcslen(EachLine[i]);
            TotalSize += EachSize[i] + 1;
            i++;
        } else {
            rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
            goto Done;
        }
    }

    if ( RetentionDays != (DWORD)SCE_NO_VALUE ) {
        EachLine[i] = (PWSTR)ScepAlloc((UINT)0, EachSize[i]*sizeof(WCHAR));
        if ( EachLine[i] != NULL ) {
            swprintf(EachLine[i], L"RetentionDays = %d", RetentionDays);
            EachSize[i] = wcslen(EachLine[i]);
            TotalSize += EachSize[i] + 1;
            i++;
        } else {
            rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
            goto Done;
        }
    }

    if ( RestrictGuest != (DWORD)SCE_NO_VALUE ) {
        EachLine[i] = (PWSTR)ScepAlloc((UINT)0, EachSize[i]*sizeof(WCHAR));
        if ( EachLine[i] != NULL ) {
            swprintf(EachLine[i], L"RestrictGuestAccess = %d", RestrictGuest);
            EachSize[i] = wcslen(EachLine[i]);
            TotalSize += EachSize[i] + 1;
            i++;
        } else {
            rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
            goto Done;
        }
    }
    //
    // write this section
    //

    if ( i == 0 ) {
        //
        // all settings are not configured
        // delete the section
        //
        WritePrivateProfileString(
                    InfSectionName,
                    NULL,
                    NULL,
                    InfFileName
                    );
    } else {
        rc = SceInfpWriteInfSection(
                        InfFileName,
                        InfSectionName,
                        TotalSize+1,
                        EachLine,
                        &EachSize[0],
                        0,
                        i-1,
                        Errlog
                        );
    }

Done:

    if ( rc != SCESTATUS_SUCCESS ) {
        ScepBuildErrorLogInfo(
                ScepSceStatusToDosError(rc),
                Errlog,
                SCEERR_WRITE_INFO,
                InfSectionName
                );
    }
    //
    // free memory
    //
    for ( i=0; i<4; i++ ) {
        if ( EachLine[i] != NULL )
            ScepFree(EachLine[i]);
    }

    return(rc);
}


SCESTATUS
SceInfpWriteInfSection(
    IN PCWSTR InfFileName,
    IN PCWSTR InfSectionName,
    IN DWORD  TotalSize,
    IN PWSTR  *EachLineStr,
    IN DWORD  *EachLineSize,
    IN DWORD  StartIndex,
    IN DWORD  EndIndex,
    OUT PSCE_ERROR_LOG_INFO *Errlog OPTIONAL
    )
/* ++
Routine Description:

    This routine writes information in a array (each element in the array
    represents a line in the section) to the section specified by
    InfSectionName in the file specified by InfFileName. TotalSize is used
    to allocate a block of memory for writing.

Arguments:

    InfFileName  - the INF file name

    InfSectionName - the section into which to write information

    TotalSize - The size of the buffer required to write

    EachLineStr - a array of strings (each element represents a line )

    EachLineSize - a array of numbers (each number is the size of the corresponding
                    element in EachLineStr).

    StartIndex - The first index of the array

    EndIndex   - The last index of the array

    Errlog  - The list of errors

Return value:

    Win32 error code

-- */
{
    PWSTR   SectionString=NULL;
    PWSTR   pTemp;
    DWORD   i;
    BOOL    status;
    DWORD   rc = NO_ERROR;


    if (InfFileName == NULL || InfSectionName == NULL ||
        EachLineStr == NULL || EachLineSize == NULL )
        return(SCESTATUS_INVALID_PARAMETER);

    if ( TotalSize > 1 ) {
        SectionString = (PWSTR)ScepAlloc( (UINT)0, (TotalSize+1)*sizeof(WCHAR));
        if ( SectionString == NULL ) {
            rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
            return(rc);
        }

        pTemp = SectionString;
        for ( i=StartIndex; i<=EndIndex; i++) {
            if ( EachLineStr[i] != NULL && EachLineSize[i] > 0 ) {
                wcsncpy(pTemp, EachLineStr[i], EachLineSize[i]);
                pTemp += EachLineSize[i];
                *pTemp = L'\0';
                pTemp++;
            }
        }
        *pTemp = L'\0';

        //
        // writes the profile section, the following call should empty the section then
        // add all keys in SectionString to the section.
        //

        status = WritePrivateProfileSection(
                        InfSectionName,
                        SectionString,
                        InfFileName
                        );
        if ( status == FALSE ) {
             rc = GetLastError();
             ScepBuildErrorLogInfo(
                        rc,
                        Errlog,
                        SCEERR_WRITE_INFO,
                        InfSectionName
                        );
        }

        ScepFree(SectionString);
        SectionString = NULL;

    }

    return(ScepDosErrorToSceStatus(rc));
}


DWORD
SceInfpWriteListSection(
    IN PCWSTR InfFileName,
    IN PCWSTR InfSectionName,
    IN DWORD  TotalSize,
    IN PSCE_NAME_LIST  ListLines,
    IN DWORD Option,
    OUT PSCE_ERROR_LOG_INFO *Errlog OPTIONAL
    )
/* ++
Routine Description:

    This routine writes information in a PSCE_NAME_LIST type list (each node
    in the list represents a line in the section) to the section specified
    by InfSectionName in the file specified by InfFileName. TotalSize is used
    to allocate a block of memory for writing.

Arguments:

    InfFileName  - the INF file name

    InfSectionName - the section into which to write information

    TotalSize - The size of the buffer required to write

    ListLines - The list of each line's text

    Errlog  - The list of errors

Return value:

    Win32 error code

-- */
{
    PWSTR           SectionString=NULL;
    PWSTR           pTemp;
    PSCE_NAME_LIST   pName;
    BOOL            status;
    DWORD           rc=NO_ERROR;
    DWORD           Len;


    if ( TotalSize > 1 ) {
        SectionString = (PWSTR)ScepAlloc( (UINT)0, TotalSize*sizeof(WCHAR));
        if ( SectionString == NULL ) {
            rc = ERROR_NOT_ENOUGH_MEMORY;
            return(rc);
        }

        pTemp = SectionString;
        for ( pName=ListLines; pName != NULL; pName = pName->Next ) {
            Len = wcslen(pName->Name);
            wcsncpy(pTemp, pName->Name, Len);
            pTemp += Len;
            if ( Option & SCEINF_ADD_EQUAL_SIGN ) {
                *pTemp++ = L' ';
                *pTemp++ = L'=';
            }
            *pTemp++ = L'\0';
        }
        *pTemp = L'\0';

/*
        if ( !( Option & SCEINF_APPEND_SECTION ) ) {

            //
            // empty the section first
            //
            WritePrivateProfileString(
                            InfSectionName,
                            NULL,
                            NULL,
                            InfFileName
                            );
        }

        //
        // write the section
        //
        status = WritePrivateProfileSection(
                        InfSectionName,
                        SectionString,
                        InfFileName
                        );
*/
        //
        // write the section
        //
        rc = ScepWritePrivateProfileSection(
                        InfSectionName,
                        SectionString,
                        InfFileName,
                        ( Option & SCEINF_APPEND_SECTION ) ? FALSE : TRUE
                        );
        ScepFree(SectionString);
        SectionString = NULL;

//        if ( status == FALSE ) {
//            rc = GetLastError();
        if ( ERROR_SUCCESS != rc ) {

            ScepBuildErrorLogInfo(
                        rc,
                        Errlog,
                        SCEERR_WRITE_INFO,
                        InfSectionName
                        );
        }
    }

    return(rc);
}


LONG
SceInfpConvertNameListToString(
    IN LSA_HANDLE LsaPolicy,
    IN PCWSTR KeyText,
    IN PSCE_NAME_LIST Fields,
    IN BOOL bOverwrite,
    OUT PWSTR *Strvalue,
    OUT PSCE_ERROR_LOG_INFO *Errlog OPTIONAL
    )
/* ++
Routine Description:

    This routine converts names in a name list to comma delimited string.
    The format of the returned string is KeyText = f1,f2,f3,f4... where
    f1..fn are names in the name list.

Arguments:

    KeyText - a string represents the key (left side of the = sign)

    Fields  - The name list

    Strvalue - The output string

    Errlog  - The error list

Return value:

    Length of the output string if successful. -1 if error.

-- */
{
    DWORD               TotalSize;
    DWORD               Strsize;
    PWSTR               pTemp = NULL;
    PSCE_NAME_LIST      pName;
    SCE_TEMP_NODE       *tmpArray=NULL, *pa=NULL;
    DWORD               i=0,j;
    DWORD               cntAllocated=0;
    DWORD               rc=ERROR_SUCCESS;

    //
    // count the total size of all fields
    //

    for ( pName=Fields, TotalSize=0; pName != NULL; pName = pName->Next ) {

        if (pName->Name[0] == L'\0') {
            continue;
        }

        if ( i >= cntAllocated ) {
            //
            // array is not enough, reallocate
            //
            tmpArray = (SCE_TEMP_NODE *)ScepAlloc(LPTR, (cntAllocated+16)*sizeof(SCE_TEMP_NODE));

            if ( tmpArray ) {

                //
                // move pointers from the old array to the new array
                //

                if ( pa ) {
                    for ( j=0; j<cntAllocated; j++ ) {
                        tmpArray[j].Name = pa[j].Name;
                        tmpArray[j].Len = pa[j].Len;
                        tmpArray[j].bFree = pa[j].bFree;
                    }
                    ScepFree(pa);
                }
                pa = tmpArray;
                tmpArray = NULL;


                cntAllocated += 16;

            } else {
                rc = ERROR_NOT_ENOUGH_MEMORY;
                break;
            }
        }

        pTemp = NULL;
        if ( wcschr(pName->Name, L'\\') &&
             LsaPolicy ) {

            //
            // check if the name has a '\' in it, it should be translated to
            // *SID
            //
            ScepConvertNameToSidString(LsaPolicy, pName->Name, FALSE, &pTemp, &Strsize);

            if ( pTemp ) {
                pa[i].Name = pTemp;
                pa[i].bFree = TRUE;
            } else {
                pa[i].Name = pName->Name;
                pa[i].bFree = FALSE;
                Strsize = wcslen(pName->Name);
            }
        } else {
            if ( ScepLookupNameTable(pName->Name, &pTemp) ) {
                pa[i].Name = pTemp;
                pa[i].bFree = TRUE;
                Strsize = wcslen(pTemp);
            }
            else {
                pa[i].Name = pName->Name;
                pa[i].bFree = FALSE;
                Strsize = wcslen(pName->Name);
            }
        }
        pa[i].Len = Strsize;

        TotalSize += Strsize + 1;
        i++;
    }

    if ( ERROR_SUCCESS == rc ) {

        //
        // The format of the string is
        // KeyText = f1,f2,f3,....
        //

        if ( bOverwrite ) {
            Strsize = 3 + wcslen(KeyText);
            if ( TotalSize > 0 )
                TotalSize += Strsize;
            else
                TotalSize = Strsize;
        } else {
            Strsize = 0;
        }

        *Strvalue = (PWSTR)ScepAlloc((UINT)0, (TotalSize+1)*sizeof(WCHAR));
        if ( *Strvalue == NULL ) {
            rc = ERROR_NOT_ENOUGH_MEMORY;
        } else {

            if ( bOverwrite ) {
                swprintf(*Strvalue, L"%s = ", KeyText);
            }
            pTemp = *Strvalue + Strsize;

            for (j=0; j<i; j++) {
                if ( pa[j].Name ) {
                    wcscpy(pTemp, pa[j].Name);
                    pTemp += pa[j].Len;
                    *pTemp = L',';
                    pTemp++;
                }
            }
            if ( pTemp != (*Strvalue+Strsize) ) {
                *(pTemp-1) = L'\0';
            }
            *pTemp = L'\0';

        }
    }

    if ( pa ) {

        for ( j=0; j<i; j++ ) {
            if ( pa[j].Name && pa[j].bFree ) {
                ScepFree(pa[j].Name);
            }
        }
        ScepFree(pa);
    }

    if ( rc != ERROR_SUCCESS ) {
        return(-1);
    } else if ( TotalSize == 0 ) {
        return(TotalSize);
    } else {
        return(TotalSize-1);
    }
}

#if 0

SCESTATUS
WINAPI
SceWriteUserSection(
    IN PCWSTR InfProfileName,
    IN PWSTR Name,
    IN PSCE_USER_PROFILE pProfile,
    OUT PSCE_ERROR_LOG_INFO *Errlog OPTIONAL
    )
/* ++
Routine Description:

Arguments:

Return Value:

-- */
{
    PWSTR                       InfSectionName=NULL;
    SCESTATUS                    rc;
    PWSTR                       EachLine[12];
    DWORD                       EachSize[12];
    DWORD                       TotalSize;
    TCHAR                       Keyname[SCE_KEY_MAX_LENGTH];
    DWORD                       Value;
    LONG                        Keysize, i;
    PSCE_LOGON_HOUR              pLogonHour=NULL;
    PWSTR                       Strvalue=NULL;


    if ( InfProfileName == NULL ||
         Name == NULL ||
         pProfile == NULL ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    //
    // process each detail profile section
    //

    for ( i=0; i<12; i++ ) {
        EachLine[i] = NULL;
        EachSize[i] = 0;
    }

    TotalSize=0;
    memset(Keyname, '\0', SCE_KEY_MAX_LENGTH*sizeof(WCHAR));
    i = 0;

    InfSectionName = (PWSTR)ScepAlloc(LMEM_ZEROINIT, (wcslen(Name)+12)*sizeof(WCHAR));
    if ( InfSectionName == NULL )
        return(SCESTATUS_NOT_ENOUGH_RESOURCE);
    swprintf(InfSectionName, L"UserProfile %s", Name);

    //
    // initialize the error log buffer
    //
    if ( Errlog ) {
        *Errlog = NULL;
    }
    if ( pProfile->DisallowPasswordChange != SCE_NO_VALUE ) {

        // DisallowPasswordChange
        Value = pProfile->DisallowPasswordChange == 0 ? 0 : 1;
        swprintf(Keyname, L"DisallowPasswordChange = %d", Value);

        rc = ScepAllocateAndCopy(&EachLine[i], &EachSize[i], 30, Keyname );
        if ( rc != SCESTATUS_SUCCESS) {
            ScepBuildErrorLogInfo(
                    ScepSceStatusToDosError(rc),
                    Errlog,
                    SCEERR_ADDTO,
                    L"DisallowPasswordChange",
                    InfSectionName
                    );
            goto Done;
        }
        TotalSize += EachSize[i]+1;
        i++;
    }
    if ( pProfile->NeverExpirePassword != SCE_NO_VALUE ||
         pProfile->ForcePasswordChange != SCE_NO_VALUE ) {

        // PasswordChangeStyle
        if ( pProfile->NeverExpirePassword != SCE_NO_VALUE &&
             pProfile->NeverExpirePassword != 0 )
            Value = 1;
        else {
            if ( pProfile->ForcePasswordChange != SCE_NO_VALUE &&
                 pProfile->ForcePasswordChange != 0 )
                Value = 2;
            else
                Value = 0;
        }
        swprintf(Keyname, L"PasswordChangeStyle = %d", Value);

        rc = ScepAllocateAndCopy(&EachLine[i], &EachSize[i], 30, Keyname );
        if ( rc != SCESTATUS_SUCCESS) {
            ScepBuildErrorLogInfo(
                    ScepSceStatusToDosError(rc),
                    Errlog,
                    SCEERR_ADDTO,
                    L"PasswordChangeStyle",
                    InfSectionName
                    );
            goto Done;
        }
        TotalSize += EachSize[i]+1;
        i++;
    }

    if ( pProfile->AccountDisabled != SCE_NO_VALUE ) {
        // AccountDisabled
        Value = pProfile->AccountDisabled == 0 ? 0 : 1;
        swprintf(Keyname, L"AccountDisabled = %d", Value);

        rc = ScepAllocateAndCopy(&EachLine[i], &EachSize[i], 30, Keyname );
        if ( rc != SCESTATUS_SUCCESS) {
            ScepBuildErrorLogInfo(
                    ScepSceStatusToDosError(rc),
                    Errlog,
                    SCEERR_ADDTO,
                    L"AccountDisabled",
                    InfSectionName
                    );
            goto Done;
        }
        TotalSize += EachSize[i]+1;
        i++;
    }

    if ( pProfile->UserProfile != NULL ) {
        // UserProfile
        swprintf(Keyname, L"UserProfile = %s", pProfile->UserProfile);

        rc = ScepAllocateAndCopy(&EachLine[i], &EachSize[i], wcslen(Keyname)+10, Keyname );
        if ( rc != SCESTATUS_SUCCESS) {
            ScepBuildErrorLogInfo(
                    ScepSceStatusToDosError(rc),
                    Errlog,
                    SCEERR_ADDTO,
                    L"UserProfile",
                    InfSectionName
                    );
            goto Done;
        }
        TotalSize += EachSize[i]+1;
        i++;
    }

    if ( pProfile->LogonScript != NULL ) {
        // LogonScript
        swprintf(Keyname, L"LogonScript = %s", pProfile->LogonScript);

        rc = ScepAllocateAndCopy(&EachLine[i], &EachSize[i], wcslen(Keyname)+10, Keyname );
        if ( rc != SCESTATUS_SUCCESS) {
            ScepBuildErrorLogInfo(
                    ScepSceStatusToDosError(rc),
                    Errlog,
                    SCEERR_ADDTO,
                    L"LogonScript",
                    InfSectionName
                    );
            goto Done;
        }
        TotalSize += EachSize[i]+1;
        i++;
    }

    if ( pProfile->HomeDir != NULL ) {
        // HomeDir
        swprintf(Keyname, L"HomeDir = %s", pProfile->HomeDir);

        rc = ScepAllocateAndCopy(&EachLine[i], &EachSize[i], wcslen(Keyname)+10, Keyname );
        if ( rc != SCESTATUS_SUCCESS) {
            ScepBuildErrorLogInfo(
                    ScepSceStatusToDosError(rc),
                    Errlog,
                    SCEERR_ADDTO,
                    L"HomeDir",
                    InfSectionName
                    );
            goto Done;
        }
        TotalSize += EachSize[i]+1;
        i++;
    }

    if ( pProfile->pLogonHours != NULL ) {
        // LogonHours

        swprintf(Keyname, L"LogonHours = ");
        Keysize = wcslen(Keyname);

        for ( pLogonHour=pProfile->pLogonHours;
              pLogonHour != NULL;
              pLogonHour = pLogonHour->Next) {

            swprintf(&Keyname[Keysize], L"%d,%d,",pLogonHour->Start,
                                                  pLogonHour->End);
            Keysize += ((pLogonHour->Start < 9) ? 2 : 3) +
                       ((pLogonHour->End < 9 ) ? 2 : 3);
        }
        // turn off the last comma
        Keyname[Keysize-1] = L'\0';


        rc = ScepAllocateAndCopy(&EachLine[i], &EachSize[i], Keysize+5, Keyname );
        if ( rc != SCESTATUS_SUCCESS) {
            ScepBuildErrorLogInfo(
                    ScepSceStatusToDosError(rc),
                    Errlog,
                    SCEERR_ADDTO,
                    L"LogonHours",
                    InfSectionName
                    );
            goto Done;
        }
        TotalSize += EachSize[i]+1;
        i++;
    }

    if ( pProfile->pWorkstations.Buffer != NULL ) {
        // Workstations

        Keysize = SceInfpConvertMultiSZToString(
                          L"Workstations",
                          pProfile->pWorkstations,
                          &Strvalue,
                          Errlog
                          );
        if ( Keysize > 0 ) {
            EachLine[i] = Strvalue;
            EachSize[i] = Keysize;
            Strvalue = NULL;
        } else {
            rc = SCESTATUS_OTHER_ERROR;
            ScepFree(Strvalue);
            Strvalue = NULL;
            goto Done;
        }

        if ( rc != SCESTATUS_SUCCESS) {
            ScepBuildErrorLogInfo(
                    ScepSceStatusToDosError(rc),
                    Errlog,
                    SCEERR_ADDTO,
                    L"WorkstationRestricitons",
                    InfSectionName
                    );
            goto Done;
        }
        TotalSize += EachSize[i]+1;
        i++;
    }

    if ( pProfile->pGroupsBelongsTo != NULL ) {
        // GroupsBelongsTo

        Keysize = SceInfpConvertNameListToString(
                          NULL,
                          L"GroupsBelongsTo",
                          pProfile->pGroupsBelongsTo,
                          TRUE,
                          &Strvalue,
                          Errlog
                          );
        if ( Keysize > 0 ) {
            EachLine[i] = Strvalue;
            EachSize[i] = Keysize;
            Strvalue = NULL;
        } else {
            rc = SCESTATUS_OTHER_ERROR;
            ScepFree(Strvalue);
            Strvalue = NULL;
            goto Done;
        }
        if ( rc != SCESTATUS_SUCCESS) {
            ScepBuildErrorLogInfo(
                    ScepSceStatusToDosError(rc),
                    Errlog,
                    SCEERR_ADDTO,
                    L"GroupsBelongsTo",
                    InfSectionName
                    );
            goto Done;
        }
        TotalSize += EachSize[i]+1;
        i++;
    }

    if ( pProfile->pAssignToUsers != NULL ) {
        // AssignToUsers

        Keysize = SceInfpConvertNameListToString(
                          NULL,
                          L"AssignToUsers",
                          pProfile->pAssignToUsers,
                          TRUE,
                          &Strvalue,
                          Errlog
                          );
        if ( Keysize > 0 ) {
            EachLine[i] = Strvalue;
            EachSize[i] = Keysize;
            Strvalue = NULL;
        } else {
            rc = SCESTATUS_OTHER_ERROR;
            ScepFree(Strvalue);
            Strvalue = NULL;
            goto Done;
        }
    } else {
        swprintf(Keyname, L"AssignToUsers = ");
        rc = ScepAllocateAndCopy(&EachLine[i], &EachSize[i], 30, Keyname );
    }

    if ( rc != SCESTATUS_SUCCESS) {
        ScepBuildErrorLogInfo(
                ScepSceStatusToDosError(rc),
                Errlog,
                SCEERR_ADDTO,
                L"AssignToUsers",
                InfSectionName
                );
        goto Done;
    }
    TotalSize += EachSize[i]+1;
    i++;

    if ( pProfile->pHomeDirSecurity != NULL ) {

        // HomeDirSecurity
        rc = ConvertSecurityDescriptorToText(
                   pProfile->pHomeDirSecurity,
                   pProfile->HomeSeInfo,
                   &Strvalue,
                   (PULONG)&Keysize
                   );
        if ( rc == NO_ERROR ) {
            EachSize[i] = Keysize + 21;
            EachLine[i] = (PWSTR)ScepAlloc( 0, EachSize[i]*sizeof(WCHAR));
            if ( EachLine[i] != NULL ) {
                swprintf(EachLine[i], L"HomeDirSecurity = \"%s\"", Strvalue);
                EachLine[i][EachSize[i]-1] = L'\0';
            } else
                rc = SCESTATUS_NOT_ENOUGH_RESOURCE;

            ScepFree(Strvalue);
            Strvalue = NULL;

        } else {
            ScepBuildErrorLogInfo(
                    rc,
                    Errlog,
                    SCEERR_ADD,
                    L"HomeDirSecurity",
                    InfSectionName
                    );
            rc = ScepDosErrorToSceStatus(rc);
        }
        if ( rc != SCESTATUS_SUCCESS )
            goto Done;
        TotalSize += EachSize[i]+1;
        i++;

    }

    if ( pProfile->pTempDirSecurity != NULL ) {

        // TempDirSecurity
        rc = ConvertSecurityDescriptorToText(
                   pProfile->pTempDirSecurity,
                   pProfile->TempSeInfo,
                   &Strvalue,
                   (PULONG)&Keysize
                   );
        if ( rc == NO_ERROR ) {
            EachSize[i] = Keysize + 21;
            EachLine[i] = (PWSTR)ScepAlloc( 0, EachSize[i]*sizeof(WCHAR));
            if ( EachLine[i] != NULL ) {
                swprintf(EachLine[i], L"TempDirSecurity = \"%s\"", Strvalue);
                EachLine[i][EachSize[i]-1] = L'\0';
            } else
                rc = SCESTATUS_NOT_ENOUGH_RESOURCE;

            ScepFree(Strvalue);
            Strvalue = NULL;

        } else {
            ScepBuildErrorLogInfo(
                    rc,
                    Errlog,
                    SCEERR_ADDTO,
                    L"TempDirSecurity",
                    InfSectionName
                    );
            rc = ScepDosErrorToSceStatus(rc);
        }
        if ( rc != SCESTATUS_SUCCESS )
            goto Done;
        TotalSize += EachSize[i]+1;
        i++;

    }

    //
    // write to this profile's section
    //

    rc = SceInfpWriteInfSection(
                InfProfileName,
                InfSectionName,
                TotalSize+1,
                EachLine,
                &EachSize[0],
                0,
                i-1,
                Errlog
                );
    if ( rc != SCESTATUS_SUCCESS )
        goto Done;

Done:

    if ( InfSectionName != NULL )
        ScepFree(InfSectionName);

    if ( Strvalue != NULL )
        ScepFree(Strvalue);

    for ( i=0; i<12; i++ )
        if ( EachLine[i] != NULL )
            ScepFree(EachLine[i]);

    return(rc);

}
#endif


LONG
SceInfpConvertMultiSZToString(
    IN PCWSTR KeyText,
    IN UNICODE_STRING Fields,
    OUT PWSTR *Strvalue,
    OUT PSCE_ERROR_LOG_INFO *Errlog OPTIONAL
    )
/* ++
Routine Description:

    This routine converts names in a unicode string in Multi-SZ format
    (separated by NULLs) to comma delimited string. The format of the
    returned string is KeyText = f1,f2,f3,f4... where f1..fn are names
    in the unicode string.

Arguments:

    KeyText - a string represents the key (left side of the = sign)

    Fields  - The Multi-SZ string

    Strvalue - The output string

    Errlog  - The error list

Return value:

    Length of the output string if successful. -1 if error.

-- */
{
    DWORD               TotalSize;
    DWORD               Strsize;
    PWSTR               pTemp = NULL;
    PWSTR               pField=NULL;

    //
    // The format of the string is
    // KeyText = f1,f2,f3,....
    //

    Strsize = 3 + wcslen(KeyText);
    TotalSize = Fields.Length/2 + Strsize;

    *Strvalue = (PWSTR)ScepAlloc((UINT)0, (TotalSize+1)*sizeof(WCHAR));
    if ( *Strvalue == NULL ) {
        return(-1);
    }

    swprintf(*Strvalue, L"%s = ", KeyText);
    pTemp = *Strvalue + Strsize;
    pField = Fields.Buffer;

    while ( pField != NULL && pField[0] ) {
        wcscpy(pTemp, pField);
        Strsize = wcslen(pField);
        pField += Strsize+1;
        pTemp += Strsize;
        *pTemp = L',';
        pTemp++;
    }
    *(pTemp-1) = L'\0';
    *pTemp = L'\0';

    return(TotalSize-1);

}


SCESTATUS
ScepAllocateAndCopy(
    OUT PWSTR *Buffer,
    OUT PDWORD BufSize,
    IN DWORD MaxSize,
    IN PWSTR SrcBuf
    )
/* ++
Routine Description:

Arguments:

Return value:

-- */
{
    *BufSize = 0;

    *Buffer = (PWSTR)ScepAlloc( (UINT)0, MaxSize*sizeof(WCHAR));
    if ( *Buffer == NULL ) {
        return(SCESTATUS_NOT_ENOUGH_RESOURCE);
    }
    swprintf(*Buffer, L"%s", SrcBuf);
    *BufSize = wcslen(*Buffer);

    return(SCESTATUS_SUCCESS);
}


SCESTATUS
SceInfpBreakTextIntoMultiFields(
    IN PWSTR szText,
    IN DWORD dLen,
    OUT LPDWORD pnFields,
    OUT LPDWORD *arrOffset
    )
/*
If the text length is greater than MAX_STRING_LENGTH-1, this routine will
find out how many "blocks" the text can be break into (each block is less
than MAX_STRING_LENGTH-1), and the starting offsets of each block.

Setupapi has string length limit of MAX_STRING_LENGTH per field in a inf
file. SCE use setupapi to parse security templates which contain security
descriptors in text format which can have unlimited aces. So when SCE saves
text format of security descriptors into a inf file, it will break the text
into multiple fields if the length is over limit. Setupapi does not have
limit on number of fields per line.

The break point occurs when the following characters are encountered in the
text: ) ( ; " or space

*/
{
    SCESTATUS  rc=SCESTATUS_SUCCESS;
    DWORD      nFields;
    DWORD      nProc;
    DWORD *    newBuffer=NULL;
    DWORD      i;

    if ( !pnFields || !arrOffset ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }
    *pnFields = 0;
    *arrOffset = NULL;

    if ( !szText || dLen == 0 ) {
        return(SCESTATUS_SUCCESS);
    }
    //
    // initialize one field always
    //
    nFields = 1;
    *arrOffset = (DWORD *)ScepAlloc(0, nFields*sizeof(DWORD));

    if ( *arrOffset ) {
        (*arrOffset)[0] = 0;

        if ( dLen > MAX_STRING_LENGTH-1 ) {
            //
            // loop through the text
            //
            nProc = (*arrOffset)[nFields-1] + MAX_STRING_LENGTH-2;

            while ( SCESTATUS_SUCCESS == rc && nProc < dLen ) {

                while ( nProc > (*arrOffset)[nFields-1] ) {
                    //
                    // looking for the break point
                    //
                    if ( L')' == *(szText+nProc) ||
                         L'(' == *(szText+nProc) ||
                         L';' == *(szText+nProc) ||
                         L' ' == *(szText+nProc) ||
                         L'\"' == *(szText+nProc) ) {

                        break;
                    } else {
                        nProc--;
                    }
                }
                if ( nProc <= (*arrOffset)[nFields-1] ) {
                    //
                    // no break point found, then just use MAX_STRING_LENGTH-2
                    //
                    nProc = (*arrOffset)[nFields-1]+MAX_STRING_LENGTH-2;

                } else {
                    //
                    // else find a break poin at offset nProc, the next block
                    // starts at nProc+1
                    //
                    nProc++;
                }

                nFields++;
                newBuffer = (DWORD *)ScepAlloc( 0, nFields*sizeof(DWORD));

                if ( newBuffer ) {

                    for ( i=0; i<nFields-1; i++ ) {
                        newBuffer[i] = (*arrOffset)[i];
                    }
                    ScepFree(*arrOffset);
                    //
                    // set the offset to the last element
                    //
                    newBuffer[nFields-1] = nProc;
                    *arrOffset = newBuffer;

                    nProc = (*arrOffset)[nFields-1] + MAX_STRING_LENGTH-2;
                } else {
                    rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
                }
            }

        }
        *pnFields = nFields;

    } else {
        rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
    }

    if ( SCESTATUS_SUCCESS != rc ) {
        //
        // if error occurs, free memory and clear the output buffer
        //
        *pnFields = 0;
        if ( *arrOffset ) {
            ScepFree(*arrOffset);
        }
        *arrOffset = NULL;
    }

    return(rc);
}


SCESTATUS
SceInfpWriteKerberosPolicy(
    IN PCWSTR  ProfileName,
    IN PSCE_KERBEROS_TICKET_INFO pKerberosInfo,
    IN BOOL bOverwrite,
    OUT PSCE_ERROR_LOG_INFO *Errlog OPTIONAL
    )
/*++
Routine Description:

   This routine writes kerberos policy settings information to the INF file
   in section [Kerberos Policy].

Arguments:

   ProfileName   - The profile to write to

   pKerberosInfo - the Kerberos policy info (SCP) to write.

   Errlog     -     A buffer to hold all error codes/text encountered when
                    parsing the INF file. If Errlog is NULL, no further error
                    information is returned except the return DWORD

Return value:

   SCESTATUS -  SCESTATUS_SUCCESS
               SCESTATUS_NOT_ENOUGH_RESOURCE
               SCESTATUS_INVALID_PARAMETER
               SCESTATUS_CORRUPT_PROFILE
               SCESTATUS_INVALID_DATA

--*/

{
    SCESTATUS      rc=SCESTATUS_SUCCESS;

    SCE_KEY_LOOKUP AccessSCPLookup[] = {
        {(PWSTR)TEXT("MaxTicketAge"),     offsetof(struct _SCE_KERBEROS_TICKET_INFO_, MaxTicketAge),  'D'},
        {(PWSTR)TEXT("MaxRenewAge"),      offsetof(struct _SCE_KERBEROS_TICKET_INFO_, MaxRenewAge),   'D'},
        {(PWSTR)TEXT("MaxServiceAge"), offsetof(struct _SCE_KERBEROS_TICKET_INFO_, MaxServiceAge),   'D'},
        {(PWSTR)TEXT("MaxClockSkew"),offsetof(struct _SCE_KERBEROS_TICKET_INFO_, MaxClockSkew), 'D'},
        {(PWSTR)TEXT("TicketValidateClient"),     offsetof(struct _SCE_KERBEROS_TICKET_INFO_, TicketValidateClient),  'D'}
        };

    DWORD       cAccess = sizeof(AccessSCPLookup) / sizeof(SCE_KEY_LOOKUP);

    DWORD       i, j;
    PWSTR       EachLine[10];
    DWORD       EachSize[10];
    UINT        Offset;
    DWORD       Len;
    DWORD         Value;
    DWORD         TotalSize=0;


    if (!ProfileName ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    if ( !pKerberosInfo ) {
        //
        // if no kerberos information to write, just return success
        // empty the section in the file
        //
        if ( bOverwrite ) {
            WritePrivateProfileString(
                        szKerberosPolicy,
                        NULL,
                        NULL,
                        ProfileName
                        );
        }
        return(SCESTATUS_SUCCESS);
    }

    for ( i=0, j=0; i<cAccess; i++) {

        EachLine[i] = NULL;
        EachSize[i] = 0;

        //
        // get settings in AccessLookup table
        //

        Offset = AccessSCPLookup[i].Offset;

        Value = 0;
        Len = wcslen(AccessSCPLookup[i].KeyString);

        switch ( AccessSCPLookup[i].BufferType ) {
        case 'D':

            //
            // Int Field
            //
            Value = *((DWORD *)((CHAR *)pKerberosInfo+Offset));
            if ( Value != SCE_NO_VALUE ) {
                EachSize[j] = Len+15;
            }
            break;
        default:
           //
           // should not occur
           //
           break;
        }

        if ( EachSize[j] <= 0 )
            continue;

        if ( bOverwrite ) {

            Len=(EachSize[j]+1)*sizeof(WCHAR);

            EachLine[j] = (PWSTR)ScepAlloc( LMEM_ZEROINIT, Len);
            if ( EachLine[j] == NULL ) {
                rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
                goto Done;
            }

            if ( AccessSCPLookup[i].BufferType == 'D' ) {
                swprintf(EachLine[j], L"%s = %d", AccessSCPLookup[i].KeyString, Value);
                EachSize[j] = wcslen(EachLine[j]);
            }
        } else {

            //
            // in append mode, write one string at a time
            //

            ScepWriteOneIntValueToProfile(
                ProfileName,
                szKerberosPolicy,
                AccessSCPLookup[i].KeyString,
                Value
                );
        }

        TotalSize += EachSize[j]+1;
        j++;

    }

    //
    // writes the profile section
    //

    if ( bOverwrite ) {

        if ( j > 0 ) {

            rc = SceInfpWriteInfSection(
                        ProfileName,
                        szKerberosPolicy,
                        TotalSize+1,
                        EachLine,
                        &EachSize[0],
                        0,
                        j-1,
                        Errlog
                        );
        } else {

            WritePrivateProfileSection(
                        szKerberosPolicy,
                        NULL,
                        ProfileName);
        }
    }

Done:

    for ( i=0; i<cAccess; i++ ) {

        if ( EachLine[i] != NULL ) {
            ScepFree(EachLine[i]);
        }

        EachLine[i] = NULL;
        EachSize[i] = 0;
    }

    return(rc);
}


SCESTATUS
SceInfpWriteRegistryValues(
    IN PCWSTR  ProfileName,
    IN PSCE_REGISTRY_VALUE_INFO pRegValues,
    IN DWORD ValueCount,
    IN BOOL  bOverwrite,
    OUT PSCE_ERROR_LOG_INFO *Errlog OPTIONAL
    )
/*++
Routine Description:

   This routine writes registry values to the INF file in section
   [Registry Values].

Arguments:

   ProfileName   - The profile to write to

   pRegValues  - the registry values to write (in the format of ValueName=Value)

   ValueCount  - the number of values to write

   Errlog     -     A buffer to hold all error codes/text encountered when
                    parsing the INF file. If Errlog is NULL, no further error
                    information is returned except the return DWORD

Return value:

   SCESTATUS -  SCESTATUS_SUCCESS
               SCESTATUS_NOT_ENOUGH_RESOURCE
               SCESTATUS_INVALID_PARAMETER
               SCESTATUS_CORRUPT_PROFILE
               SCESTATUS_INVALID_DATA

--*/

{
    SCESTATUS      rc=SCESTATUS_SUCCESS;
    PSCE_NAME_LIST       pNameList=NULL;
    DWORD               TotalSize=0;
    DWORD               i, ObjectSize;


    if (!ProfileName ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    if ( !pRegValues || 0 == ValueCount ) {
        //
        // if no value to write, just return success
        // empty the section in the file
        //
        if ( bOverwrite ) {
            WritePrivateProfileString(
                        szRegistryValues,
                        NULL,
                        NULL,
                        ProfileName
                        );
        }
        return(SCESTATUS_SUCCESS);
    }

    for ( i=0; i<ValueCount; i++) {

        //
        // Get string fields. Don't care the key name or if it exist.
        // Must have 3 fields each line.
        //
        rc = SceInfpWriteOneValue(
                        ProfileName,
                        pRegValues[i],
                        bOverwrite,
                        &pNameList,
                        &ObjectSize
                        );
        if ( rc != SCESTATUS_SUCCESS ) {
            ScepBuildErrorLogInfo(
                        rc,
                        Errlog,
                        SCEERR_WRITE_INFO,
                        pRegValues[i].FullValueName
                        );
            goto Done;
        }
        TotalSize += ObjectSize + 1;
    }

    //
    // write to this profile's section
    //

    if ( bOverwrite ) {
        rc = SceInfpWriteListSection(
                ProfileName,
                szRegistryValues,
                TotalSize+1,
                pNameList,
                0,
                Errlog
                );

        if ( rc != SCESTATUS_SUCCESS )
            ScepBuildErrorLogInfo(
                        rc,
                        Errlog,
                        SCEERR_WRITE_INFO,
                        szRegistryValues
                        );
    }

Done:

    ScepFreeNameList(pNameList);

    rc = ScepDosErrorToSceStatus(rc);

    return(rc);

}


DWORD
SceInfpWriteOneValue(
    IN PCWSTR ProfileName,
    IN SCE_REGISTRY_VALUE_INFO RegValue,
    IN BOOL bOverwrite,
    OUT PSCE_NAME_LIST *pNameList,
    OUT PDWORD ObjectSize
    )
/* ++
Routine Description:

   This routine builds registry valueName=value for one registry value
   into the name list. Each value represents one line in the INF file.

Arguments:

   RegValue  - The registry value name and the value

   pNameList - The output string list.

   ObjectSize  - size of this line

Return value:

   SCESTATUS - SCESTATUS_SUCCESS
              SCESTATUS_NOT_ENOUGH_RESOURCE
              SCESTATUS_INVALID_PARAMETER
              SCESTATUS_BAD_FORMAT
              SCESTATUS_INVALID_DATA
-- */
{
    DWORD          rc=ERROR_SUCCESS;
    PWSTR          OneLine;


    if ( !pNameList || !ObjectSize ) {
        return(ERROR_INVALID_PARAMETER);
    }

    *ObjectSize = 0;

    if ( RegValue.FullValueName && RegValue.Value ) {

        if ( bOverwrite ) {
            *ObjectSize = wcslen(RegValue.FullValueName);
        }

        if ( RegValue.ValueType == REG_SZ ||
             RegValue.ValueType == REG_EXPAND_SZ ) {
            // need to add "" around the string
            *ObjectSize += (5+wcslen(RegValue.Value));
        } else {
            //
            // to be safe, add more spaces to the buffer
            // because ValueType can be "-1" now
            //
            *ObjectSize += (6+wcslen(RegValue.Value));
        }

        OneLine = (PWSTR)ScepAlloc(0, (*ObjectSize+1)*sizeof(WCHAR));

        if ( OneLine ) {

            if ( bOverwrite ) {
                if ( RegValue.ValueType == REG_SZ ||
                     RegValue.ValueType == REG_EXPAND_SZ ) {
                    swprintf(OneLine, L"%s=%1d,\"%s\"\0", RegValue.FullValueName,
                                                 RegValue.ValueType, RegValue.Value);
                } else {
                    swprintf(OneLine, L"%s=%1d,%s\0", RegValue.FullValueName,
                                             RegValue.ValueType, RegValue.Value);
                }
            } else {

                if ( RegValue.ValueType == REG_SZ ||
                     RegValue.ValueType == REG_EXPAND_SZ ) {
                    swprintf(OneLine, L"%1d,\"%s\"\0", RegValue.ValueType, RegValue.Value);
                } else {
                    swprintf(OneLine, L"%1d,%s\0", RegValue.ValueType, RegValue.Value);
                }
            }
            OneLine[*ObjectSize] = L'\0';

            if ( bOverwrite ) {

                rc = ScepAddToNameList(pNameList, OneLine, *ObjectSize);

            } else {
                //
                // append mode, write one value at a time
                //
                WritePrivateProfileString( szRegistryValues,
                                           RegValue.FullValueName,
                                           OneLine,
                                           ProfileName
                                         );
            }

            ScepFree(OneLine);

        } else {
            rc = ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    return(rc);

}


SCESTATUS
WINAPI
SceSvcSetInformationTemplate(
    IN PCWSTR TemplateName,
    IN PCWSTR ServiceName,
    IN BOOL bExact,
    IN PSCESVC_CONFIGURATION_INFO ServiceInfo
    )
/*
Routine Description:

    Writes information to the template in section <ServiceName>. The information is
    stored in ServiceInfo in the format of Key and Value. If bExact is set, only
    exact matched keys are overwritten, else all section is overwritten by the info
    in ServiceInfo.

    When ServiceInfo is NULL and bExact is set, delete the entire section

Arguments:

    TemplateName    - the inf template name to write to

    ServiceName     - the section name to write to

    bExact          - TRUE = all existing information in the section is erased

    ServiceInfo     - the information to write

Return Value:

    SCE status of this operation
*/
{
    if ( TemplateName == NULL || ServiceName == NULL ||
         (ServiceInfo == NULL && !bExact ) ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    DWORD i;

    if ( ServiceInfo != NULL ) {

        for ( i=0; i<ServiceInfo->Count; i++ ) {
            if ( ServiceInfo->Lines[i].Key == NULL ) {

                return(SCESTATUS_INVALID_DATA);
            }
        }
    }

    //
    // always write [Version] section.
    //
    WCHAR tmp[64];
    memset(tmp, 0, 64*2);
    wcscpy(tmp, L"signature=\"$CHICAGO$\"");
    swprintf(tmp+wcslen(tmp)+1,L"Revision=%d\0\0",
                  SCE_TEMPLATE_MAX_SUPPORTED_VERSION);

    WritePrivateProfileSection(
                L"Version",
                tmp,
                TemplateName);

    SCESTATUS rc=SCESTATUS_SUCCESS;

    if ( (bExact && ServiceInfo == NULL) || !bExact ) {
        //
        // delete the entire section
        //
        if ( !WritePrivateProfileString(ServiceName, NULL, NULL, TemplateName) ) {
            rc = ScepDosErrorToSceStatus(GetLastError());
        }
    }

    if ( ServiceInfo == NULL ) {
        return(rc);
    }

    if ( rc == SCESTATUS_SUCCESS ) {
        //
        // process each key/value in ServiceInfo
        //
        for ( i=0; i<ServiceInfo->Count; i++ ) {
            if ( !WritePrivateProfileString(ServiceName,
                                           ServiceInfo->Lines[i].Key,
                                           ServiceInfo->Lines[i].Value,
                                           TemplateName
                                           ) ) {

                rc = ScepDosErrorToSceStatus(GetLastError());
                break;
            }
        }
    }

    //
    // need to recover the crash - WMI
    //
    return(rc);

}

DWORD
ScepWritePrivateProfileSection(
    IN LPCWSTR SectionName,
    IN LPTSTR pData,
    IN LPCWSTR FileName,
    IN BOOL bOverwrite)
/*
Description:

    This function is to provide the same function as WritePrivateProfileSection
    and exceed the 32K limit of that function.

    If the file doesn't exist, the file is always created in UNICODE.

    If the file does exist and it's in UNICODE format (the first two bytes are
    0xFF, 0xFE), the data will be saved to the file in UNICODE.

    If the file does exist and it's in ANSI format, the data will be saved to
    the file in ANSI format.

    Note, this function assumes that the file is exclusively accessed. It's not
    an atomic operation as WritePrivateProfileSection. But since this is a
    private function implemented for SCE only and SCE always uses temporary
    files (exclusive for each client), there is no problem doing this way.

    Note 2, new data section is always added to the end of the file. Existing
    data in the section will be moved to the end of the file as well.

Arguments:

    SectionName     - the section name to write data to

    FileName        - the full path file name to write data to

    pData           - data in MULTI-SZ format (with no size limit)

    bOverwrite      - TRUE=data will overwrite entire section in the file

*/
{
    if ( SectionName == NULL || FileName == NULL ) {
        return ERROR_INVALID_PARAMETER;
    }

    DWORD rc=ERROR_SUCCESS;

    //
    // check to see if the file exist
    //
    if ( 0xFFFFFFFF != GetFileAttributes(FileName) ) {

        //
        // file eixsts.
        //
        if ( !bOverwrite && pData != NULL ) {
            //
            // Need to check if the same section exists and if so
            // append the data
            //
            rc = ScepAppendProfileSection(SectionName, FileName, pData);

        } else {

            //
            // the existint data, if any, is not interesting. delete it
            // if the section does not exist at all, the next call won't fail
            //
            if ( !WritePrivateProfileSection(
                                SectionName,
                                NULL,
                                FileName
                                ) ) {
                rc = GetLastError();

            } else if ( pData ) {
                //
                // now write the new data in
                //
                rc = ScepOverwriteProfileSection(SectionName,
                                                 FileName,
                                                 pData,
                                                 SCEP_PROFILE_WRITE_SECTIONNAME,
                                                 NULL);
            }
        }

    } else if ( pData ) {

        //
        // the file does not exist, no need to empty existing data
        //
        rc = ScepOverwriteProfileSection(SectionName,
                                         FileName,
                                         pData,
                                         SCEP_PROFILE_WRITE_SECTIONNAME,
                                         NULL);
    }

    return rc;
}

DWORD
ScepAppendProfileSection(
    IN LPCWSTR SectionName,
    IN LPCWSTR FileName,
    IN LPTSTR pData
    )
/*
Description:

    Append the data to the section if the section exists, otherwise, create
    the section and add data to it.

Arguments:

    SectionName     - the section name

    FileName        - the file name

    pData           - the data to append

*/
{

    DWORD rc=ERROR_SUCCESS;
    DWORD dwSize;
    PWSTR lpExisting = NULL;
    WCHAR szBuffer[256];
    DWORD nSize=256;
    BOOL bSection=TRUE;

    lpExisting = szBuffer;
    szBuffer[0] = L'\0';
    szBuffer[1] = L'\0';

    PSCEP_SPLAY_TREE pKeys=NULL;

    do {
        //
        // check if the section already exist
        //
        dwSize = GetPrivateProfileSection(SectionName, lpExisting, nSize, FileName );

        if ( dwSize == 0 ) {
            //
            // either failed or the section does not exist
            //
            rc = GetLastError();

            if ( ERROR_FILE_NOT_FOUND == rc ) {
                //
                // the file or section does not exist
                //
                rc = ERROR_SUCCESS;
                break;
            }

        } else if ( dwSize < nSize - 2 ) {
            //
            // data get copied ok because the whole buffer is filled
            //
            break;

        } else {

            //
            // buffer is not big enough, reallocate heap
            //
            if ( lpExisting && lpExisting != szBuffer ) {
                LocalFree(lpExisting);
            }

            nSize += 256;
            lpExisting = (PWSTR)LocalAlloc(LPTR, nSize*sizeof(TCHAR));

            if ( lpExisting == NULL ) {

                rc = ERROR_NOT_ENOUGH_MEMORY;
            }
        }

    } while (  rc == ERROR_SUCCESS );


    if ( ERROR_SUCCESS == rc && lpExisting[0] != L'\0') {

        //
        // now delete the existing section (to make sure the section will
        // always be at the end)
        //

        if ( !WritePrivateProfileSection(
                            SectionName,
                            NULL,
                            FileName
                            ) ) {
            //
            // fail to delete the section
            //
            rc = GetLastError();

        } else {

            //
            // save the new data first
            //
            pKeys = ScepSplayInitialize(SplayNodeStringType);

            rc = ScepOverwriteProfileSection(SectionName,
                                             FileName,
                                             pData,
                                             SCEP_PROFILE_WRITE_SECTIONNAME |
                                             SCEP_PROFILE_GENERATE_KEYS,
                                             pKeys
                                             );

            if ( ERROR_SUCCESS == rc ) {

                //
                // now append the old data and check for duplicate
                //
                rc = ScepOverwriteProfileSection(SectionName,
                                                 FileName,
                                                 lpExisting,
                                                 SCEP_PROFILE_CHECK_DUP,
                                                 pKeys
                                                 );
            }

            if ( pKeys ) {

                ScepSplayFreeTree( &pKeys, TRUE );
            }

        }

    } else if ( ERROR_SUCCESS == rc ) {

        //
        // now write the new data
        //
        rc = ScepOverwriteProfileSection(SectionName,
                                         FileName,
                                         pData,
                                         SCEP_PROFILE_WRITE_SECTIONNAME,
                                         NULL
                                         );
    }

    //
    // free existing data buffer
    //
    if ( lpExisting && (lpExisting != szBuffer) ) {
        LocalFree(lpExisting);
    }

    return rc;
}


DWORD
ScepOverwriteProfileSection(
    IN LPCWSTR SectionName,
    IN LPCWSTR FileName,
    IN LPTSTR pData,
    IN DWORD dwFlags,
    IN OUT PSCEP_SPLAY_TREE pKeys OPTIONAL
    )
/*
Description:

    Writes data to the section. Old data in the section will be overwritten.

Arguments:

    SectionName     - section name to write to

    FileName        - file name

    pData           - data to write

    dwFlags         - flags (write section name, generate keys, check duplicate)

    pKeys          - the keys to generate or check duplicate
*/
{

    DWORD rc=ERROR_SUCCESS;
    HANDLE hFile=INVALID_HANDLE_VALUE;
    BOOL bUnicode;
    DWORD dwBytesWritten;

    //
    // try create the new file
    //
    hFile = CreateFile(FileName,
                       GENERIC_READ | GENERIC_WRITE,
                       0,
                       NULL,
                       CREATE_NEW,
                       FILE_ATTRIBUTE_NORMAL,
                       NULL);

    if (hFile != INVALID_HANDLE_VALUE) {
        //
        // this is a new file, created successfully.
        // now make it UNICODE
        //
        BYTE tmpBuf[3];
        tmpBuf[0] = 0xFF;
        tmpBuf[1] = 0xFE;
        tmpBuf[2] = 0;

        if ( !WriteFile (hFile, (LPCVOID)&tmpBuf, 2,
                   &dwBytesWritten,
                   NULL) )

            return GetLastError();

        bUnicode = TRUE;

    } else {

        //
        // open the file exclusively
        //

        hFile = CreateFile(FileName,
                           GENERIC_READ | GENERIC_WRITE,
                           0,
                           NULL,
                           OPEN_ALWAYS,
                           FILE_ATTRIBUTE_NORMAL,
                           NULL);

        if (hFile != INVALID_HANDLE_VALUE) {

            SetFilePointer (hFile, 0, NULL, FILE_BEGIN);

            //
            // check the first byte of the file to see if it's UNICODE
            //
            BYTE tmpBytes[3];
            tmpBytes[0] = 0;
            tmpBytes[1] = 0;

            if ( ReadFile(hFile, (LPVOID)tmpBytes, 2, &dwBytesWritten, NULL ) &&
                 dwBytesWritten == 2 ) {

                if ( tmpBytes[0] == 0xFF && tmpBytes[1] == 0xFE ) {
                    bUnicode = TRUE;
                } else {
                    bUnicode = FALSE;
                }
            } else {
                //
                // if fails to verify the file, assume it's UNICODE
                //
                bUnicode = TRUE;
            }
        }
    }

    PWSTR pKeyStr=NULL;

    if (hFile != INVALID_HANDLE_VALUE) {

        SetFilePointer (hFile, 0, NULL, FILE_END);

        if ( dwFlags & SCEP_PROFILE_WRITE_SECTIONNAME ) {
            //
            // save the section name first
            //
            rc = ScepWriteStrings(hFile, bUnicode, L"[", 1, (PWSTR)SectionName, 0, L"]", 1, TRUE);
        }

        if ( ERROR_SUCCESS == rc ) {

            LPTSTR pTemp=pData;
            LPTSTR pTemp1=pData;
            BOOL bExists, bKeyCopied;
            DWORD rc1;
            DWORD Len;

            //
            // write each string in the MULTI-SZ string separately, with a \r\n
            //
            while ( *pTemp1 ) {

                //
                // count to the \0
                //
                bKeyCopied = FALSE;
                if ( pKeyStr ) {
                    LocalFree(pKeyStr);
                    pKeyStr = NULL;
                }

                while (*pTemp) {
                    if ( pKeys &&
                         ( (dwFlags & SCEP_PROFILE_GENERATE_KEYS) ||
                           (dwFlags & SCEP_PROFILE_CHECK_DUP) ) &&
                        !bKeyCopied &&
                        (*pTemp == L'=' || *pTemp == L',') ) {
                        //
                        // there is a key to remember
                        //
                        Len = (DWORD)(pTemp-pTemp1);

                        pKeyStr = (PWSTR)ScepAlloc(LPTR, (Len+1)*sizeof(WCHAR));
                        if ( pKeyStr ) {
                            wcsncpy(pKeyStr, pTemp1, pTemp-pTemp1);
                            bKeyCopied = TRUE;
                        } else {
                            rc = ERROR_NOT_ENOUGH_MEMORY;
                            break;
                        }
                    }
                    pTemp++;
                }

                if ( ERROR_SUCCESS != rc )
                    break;

                if ( bKeyCopied ) {

                    if ( dwFlags & SCEP_PROFILE_GENERATE_KEYS ) {
                        //
                        // add it to the splay list
                        //

                        rc1 = ScepSplayInsert( (PVOID)pKeyStr, pKeys, &bExists );

                    } else if ( dwFlags & SCEP_PROFILE_CHECK_DUP ) {
                        //
                        // check if the key already exists in the splay list
                        //
                        if ( ScepSplayValueExist( (PVOID)pKeyStr, pKeys) ) {
                            //
                            // this is a duplicate entry, continue
                            //
                            pTemp++;
                            pTemp1 = pTemp;
                            continue;
                        }

                    }
                }

                Len = (DWORD)(pTemp-pTemp1);

                rc = ScepWriteStrings(hFile,
                                      bUnicode,         // write it in UNICODE or ANSI
                                      NULL,             // no prefix
                                      0,
                                      pTemp1,           // the string
                                      Len,
                                      NULL,             // no suffix
                                      0,
                                      TRUE              // add \r\n
                                      );

                if ( ERROR_SUCCESS != rc )
                    break;

                pTemp++;
                pTemp1 = pTemp;
            }
        }

        CloseHandle (hFile);

    } else {

        rc = GetLastError();
    }

    if ( pKeyStr ) {
        LocalFree(pKeyStr);
    }

    return rc;
}


DWORD
ScepWriteStrings(
    IN HANDLE hFile,
    IN BOOL bUnicode,
    IN PWSTR szPrefix OPTIONAL,
    IN DWORD dwPrefixLen,
    IN PWSTR szString,
    IN DWORD dwStrLen,
    IN PWSTR szSuffix OPTIONAL,
    IN DWORD dwSuffixLen,
    IN BOOL bCRLF
    )
/*
Description:

    Write data to the file. Data can have prefix and/or suffix, and followed
    by a \r\n optionally.

    Data will be write in UNICODE or ANSI format based on the input paramter
    bUnicode. If ANSI format is desired, the wide chars are converted to
    multi-byte buffers then write to the file.

Arguments:

    hFile       - file handle

    bUnicode    - the file format (UNICODE=TRUE or ANSI=FALSE)

    szPrefix    - the optional prefix string

    dwPrefixLen - the optional prefix string length (in wchars)

    szString    - the string to write

    dwStrLen    - the string length

    szSuffix    - the optional suffix string

    dwSuffixLen - the optional suffix string length (in wchars)

    bCRLF       - if \r\n should be added

*/
{
    DWORD rc=ERROR_SUCCESS;
    PWSTR pwBuffer=NULL;
    DWORD dwTotal=0;
    PVOID pBuf=NULL;
    PCHAR pStr=NULL;
    DWORD dwBytes=0;

    //
    // validate parameters
    //
    if ( hFile == NULL || szString == NULL ) {
        return ERROR_INVALID_PARAMETER;
    }

    if ( szPrefix && dwPrefixLen == 0 ) {
        dwPrefixLen = wcslen(szPrefix);
    }

    if ( szSuffix && dwSuffixLen == 0 ) {
        dwSuffixLen = wcslen(szSuffix);
    }

    if ( dwStrLen == 0 ) {
        dwStrLen = wcslen(szString);
    }

    //
    // get total length
    //
    dwTotal = dwPrefixLen + dwStrLen + dwSuffixLen;

    if ( dwTotal == 0 && !bCRLF ) {
        //
        // nothing to write
        //
        return ERROR_SUCCESS;
    }

    if ( bCRLF ) {
        //
        // add \r\n
        //
        dwTotal += 2;
    }

    //
    // allocate buffer
    //
    pwBuffer = (PWSTR)LocalAlloc(LPTR, (dwTotal+1)*sizeof(TCHAR));

    if ( pwBuffer == NULL ) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // copy all data to the buffer
    //
    if ( szPrefix ) {
        wcsncpy(pwBuffer, szPrefix, dwPrefixLen);
    }

    wcsncat(pwBuffer, szString, dwStrLen);

    if ( szSuffix ) {
        wcsncat(pwBuffer, szSuffix, dwSuffixLen);
    }

    if ( bCRLF ) {
        wcscat(pwBuffer, c_szCRLF);
    }

    if ( !bUnicode ) {

        //
        // convert WCHAR into ANSI
        //
        dwBytes = WideCharToMultiByte(CP_THREAD_ACP,
                                          0,
                                          pwBuffer,
                                          dwTotal,
                                          NULL,
                                          0,
                                          NULL,
                                          NULL
                                          );

        if ( dwBytes > 0 ) {

            //
            // allocate buffer
            //
            pStr = (PCHAR)LocalAlloc(LPTR, dwBytes+1);

            if ( pStr == NULL ) {

                rc = ERROR_NOT_ENOUGH_MEMORY;

            } else {

                dwBytes = WideCharToMultiByte(CP_THREAD_ACP,
                                              0,
                                              pwBuffer,
                                              dwTotal,
                                              pStr,
                                              dwBytes,
                                              NULL,
                                              NULL
                                              );
                if ( dwBytes > 0 ) {

                    pBuf = (PVOID)pStr;

                } else {

                    rc = GetLastError();
                }
            }


        } else {
            rc = GetLastError();
        }

    } else {

        //
        // write in UNICODE, use the existing buffer
        //
        pBuf = (PVOID)pwBuffer;
        dwBytes = dwTotal*sizeof(WCHAR);
    }

    //
    // write to the file
    //
    DWORD dwBytesWritten=0;

    if ( pBuf ) {

        if ( WriteFile (hFile, (LPCVOID)pBuf, dwBytes,
                   &dwBytesWritten,
                   NULL) ) {

            if ( dwBytesWritten != dwBytes ) {
                //
                // not all data is written
                //
                rc = ERROR_INVALID_DATA;
            }

        } else {
            rc = GetLastError();
        }
    }

    if ( pStr ) {
        LocalFree(pStr);
    }

    //
    // free buffer
    //
    LocalFree(pwBuffer);

    return(rc);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\scerpc\client\infget.cpp ===
/*++
Copyright (c) 1996 Microsoft Corporation

Module Name:

    infget.c

Abstract:

    Routines to get information from security profiles (INF layout).
    Functions from setupapi.lib (setupapi.h), syssetup.lib (syssetup.h),
    netlib.lib (netlib.h) for parsing the INF layout are referenced
    besides ntdll, ntrtl, and etc.

Author:

    Jin Huang (jinhuang) 28-Oct-1996

Revision History:

--*/

#include "headers.h"
#include "scedllrc.h"
#include "infp.h"
#include "sceutil.h"
#include <sddl.h>

#pragma hdrstop

//#define INF_DBG 1

#define SCEINF_OBJECT_FLAG_DSOBJECT             1
#define SCEINF_OBJECT_FLAG_OLDSDDL              2
#define SCEINF_OBJECT_FLAG_UNKNOWN_VERSION      4


//
// Forward references
//
SCESTATUS
SceInfpGetSystemAccess(
   IN HINF hInf,
   IN DWORD ObjectFlag,
   OUT PSCE_PROFILE_INFO pSCEinfo,
   OUT PSCE_ERROR_LOG_INFO *Errlog OPTIONAL
   );

SCESTATUS
SceInfpGetUserSettings(
   IN HINF hInf,
   OUT PSCE_NAME_LIST *pProfileList,
   OUT PSCE_ERROR_LOG_INFO *Errlog OPTIONAL
   );

SCESTATUS
SceInfpGetGroupMembership(
    IN  HINF hInf,
    OUT PSCE_GROUP_MEMBERSHIP *pGroupMembership,
    OUT PSCE_ERROR_LOG_INFO *Errlog OPTIONAL
    );

SCESTATUS
SceInfpGetObjects(
     IN HINF hInf,
     IN PCWSTR SectionName,
     IN DWORD ObjectFlag,
     OUT PSCE_OBJECT_ARRAY *pAllNodes,
     OUT PSCE_ERROR_LOG_INFO *Errlog OPTIONAL
    );

SCESTATUS
SceInfpGetOneObjectSecurity(
    IN PINFCONTEXT pInfLine,
    IN DWORD ObjectFlag,
    OUT PSCE_OBJECT_SECURITY *pObject,
    OUT PSCE_ERROR_LOG_INFO *Errlog OPTIONAL
    );

SCESTATUS
SceInfpGetAuditLogSetting(
   IN HINF hInf,
   IN PCWSTR SectionName,
   IN DWORD ObjectFlag,
   OUT PDWORD LogSize,
   OUT PDWORD Periods,
   OUT PDWORD RetentionDays,
   OUT PDWORD RestrictGuest,
   IN OUT PSCE_ERROR_LOG_INFO *Errlog OPTIONAL
   );

SCESTATUS
SceInfpGetAuditing(
   IN HINF hInf,
   IN DWORD ObjectFlag,
   OUT PSCE_PROFILE_INFO pSCEinfo,
   OUT PSCE_ERROR_LOG_INFO *Errlog OPTIONAL
   );

SCESTATUS
SceInfpGetKerberosPolicy(
    IN HINF  hInf,
    IN DWORD ObjectFlag,
    OUT PSCE_KERBEROS_TICKET_INFO * ppKerberosInfo,
    OUT PSCE_ERROR_LOG_INFO *Errlog OPTIONAL
    );

SCESTATUS
SceInfpGetRegistryValues(
    IN HINF  hInf,
    IN DWORD ObjectFlag,
    OUT PSCE_REGISTRY_VALUE_INFO * ppRegValues,
    OUT LPDWORD pValueCount,
    OUT PSCE_ERROR_LOG_INFO *Errlog OPTIONAL
    );

SCESTATUS
SceInfpGetOneRegistryValue(
    IN PINFCONTEXT pInfLine,
    IN DWORD ObjectFlag,
    OUT PSCE_REGISTRY_VALUE_INFO pValues,
    OUT PSCE_ERROR_LOG_INFO *Errlog OPTIONAL
    );

SCESTATUS
SceInfpGetSystemServices(
    IN HINF hInf,
    IN DWORD ObjectFlag,
    OUT PSCE_SERVICES *pServiceList,
    OUT PSCE_ERROR_LOG_INFO *Errlog OPTIONAL
    );

//
// function definitions
//

SCESTATUS
SceInfpGetSecurityProfileInfo(
    IN  HINF               hInf,
    IN  AREA_INFORMATION   Area,
    OUT PSCE_PROFILE_INFO   *ppInfoBuffer,
    OUT PSCE_ERROR_LOG_INFO *Errlog OPTIONAL
    )
/**++

Function Description:

   This function reads all or part of information from a SCP file in INF
   format into the InfoBuffer.

   The memory related to the area(s) will be reset/freed before loading
   information from the INF file. If the return code is SCESTATUS_SUCCESS,
   then the output InfoBuffer contains the requested information. Otherwise,
   InfoBuffer contains nothing for the area(s) specified.

Arguments:

   hInf        -   The INF handle to read from.

   Area -          area(s) for which to get information from
                     AREA_SECURITY_POLICY
                     AREA_PRIVILEGES
                     AREA_USER_SETTINGS
                     AREA_GROUP_MEMBERSHIP
                     AREA_REGISTRY_SECURITY
                     AREA_SYSTEM_SERVICE
                     AREA_FILE_SECURITY

   ppInfoBuffer -  The address of SCP profile buffers. If it is NULL, a buffer
                   will be created which must be freed by SceFreeMemory. The
                   output is the information requested if successful, or nothing
                   if fail.

   Errlog     -    A buffer to hold all error codes/text encountered when
                   parsing the INF file. If Errlog is NULL, no further error
                   information is returned except the return DWORD

Return Value:

   SCESTATUS_SUCCESS
   SCESTATUS_PROFILE_NOT_FOUND
   SCESTATUS_NOT_ENOUGH_RESOURCE
   SCESTATUS_INVALID_PARAMETER
   SCESTATUS_BAD_FORMAT
   SCESTATUS_INVALID_DATA

-- **/
{
    SCESTATUS      rc=SCESTATUS_SUCCESS;
    UINT          Len;
    BOOL          bFreeMem=FALSE;
    DWORD ObjectFlag=0;

    //
    // if the INF file is not loaded (hInf = 0), then return
    //

    if ( !hInf ) {

        return( SCESTATUS_INVALID_PARAMETER );
    }

    //
    // address for InfoBuffer cannot be NULL
    //
    if ( ppInfoBuffer == NULL ) {
        return( SCESTATUS_INVALID_PARAMETER );
    }

    //
    // if the Area is not valid, then return
    //
    if ( Area & ~AREA_ALL) {

        return( SCESTATUS_INVALID_PARAMETER );
    }

    if ( *ppInfoBuffer == NULL) {
        //
        // allocate memory
        //
        Len = sizeof(SCE_PROFILE_INFO);

        *ppInfoBuffer = (PSCE_PROFILE_INFO)ScepAlloc( (UINT)0, Len );
        if ( *ppInfoBuffer == NULL ) {

            return( SCESTATUS_NOT_ENOUGH_RESOURCE );
        }
        memset(*ppInfoBuffer, '\0', Len);
        (*ppInfoBuffer)->Type = SCE_STRUCT_INF;

        ScepResetSecurityPolicyArea(*ppInfoBuffer);

        bFreeMem = TRUE;
    }


    //
    // Free related memory and reset the buffer before parsing
    // there is a problem here for now. it clears the handle and
    // filename too. So comment it out.

    SceFreeMemory( (PVOID)(*ppInfoBuffer), Area );

    //
    // system access
    //

    INT Revision = 0;
    INFCONTEXT    InfLine;

    if ( SetupFindFirstLine(hInf,L"Version",L"Revision",&InfLine) ) {
        if ( !SetupGetIntField(&InfLine, 1, (INT *)&Revision) ) {
            Revision = 0;
        }
    }

    if ( Revision == 0) {
        ObjectFlag = SCEINF_OBJECT_FLAG_OLDSDDL;
    }

    if ( Revision > SCE_TEMPLATE_MAX_SUPPORTED_VERSION ) {
        ObjectFlag |= SCEINF_OBJECT_FLAG_UNKNOWN_VERSION;
    }

    if ( Area & AREA_SECURITY_POLICY ) {

        rc = SceInfpGetSystemAccess(
                                hInf,
                                ObjectFlag,
                                *ppInfoBuffer,
                                Errlog
                              );

        if( rc != SCESTATUS_SUCCESS )
            goto Done;

        //
        // system auditing
        //
        rc = SceInfpGetAuditing(
                        hInf,
                        ObjectFlag,
                        *ppInfoBuffer,
                        Errlog
                        );

        if( rc != SCESTATUS_SUCCESS )
            goto Done;

        //
        // kerberos policy
        //
        rc = SceInfpGetKerberosPolicy(
                        hInf,
                        ObjectFlag,
                        &((*ppInfoBuffer)->pKerberosInfo),
                        Errlog
                        );

        if( rc != SCESTATUS_SUCCESS )
            goto Done;

        //
        // registry values
        //
        rc = SceInfpGetRegistryValues(
                        hInf,
                        ObjectFlag,
                        &((*ppInfoBuffer)->aRegValues),
                        &((*ppInfoBuffer)->RegValueCount),
                        Errlog
                        );

        if( rc != SCESTATUS_SUCCESS )
            goto Done;
    }

    //
    // privilege/rights
    //
    if ( Area & AREA_PRIVILEGES ) {

        rc = SceInfpGetPrivileges(
                    hInf,
                    TRUE,
                    &( (*ppInfoBuffer)->OtherInfo.scp.u.pInfPrivilegeAssignedTo ),
                    Errlog
                    );

        if( rc != SCESTATUS_SUCCESS )
            goto Done;
    }

    //
    // account profiles list
    //

    if ( Area & AREA_USER_SETTINGS ) {

        rc = SceInfpGetUserSettings(
                    hInf,
                    &( (*ppInfoBuffer)->OtherInfo.scp.pAccountProfiles ),
                    Errlog
                    );

        if( rc != SCESTATUS_SUCCESS )
                goto Done;
    }

    //
    // group memberships
    //

    if ( Area & AREA_GROUP_MEMBERSHIP ) {

        rc = SceInfpGetGroupMembership(
                      hInf,
                      &((*ppInfoBuffer)->pGroupMembership),
                      Errlog
                      );

        if( rc != SCESTATUS_SUCCESS )
            goto Done;
    }

    //
    // registry keys security
    //

    if ( Area & AREA_REGISTRY_SECURITY ) {

        rc = SceInfpGetObjects(
                   hInf,
                   szRegistryKeys,
                   ObjectFlag,
                   &((*ppInfoBuffer)->pRegistryKeys.pAllNodes),
                   Errlog
                   );
        if ( rc != SCESTATUS_SUCCESS )
            goto Done;

    }
    //
    // system services
    //

    if ( Area & AREA_SYSTEM_SERVICE ) {


        rc = SceInfpGetSystemServices(
                      hInf,
                      ObjectFlag,
                      &((*ppInfoBuffer)->pServices),
                      Errlog
                      );

        if( rc != SCESTATUS_SUCCESS )
            goto Done;
    }

    //
    // file security
    //

    if ( Area & AREA_FILE_SECURITY ) {

        rc = SceInfpGetObjects(
                   hInf,
                   szFileSecurity,
                   ObjectFlag,
                   &((*ppInfoBuffer)->pFiles.pAllNodes),
                   Errlog
                   );
        if ( rc != SCESTATUS_SUCCESS )
            goto Done;

    }
#if 0
    if ( Area & AREA_DS_OBJECTS ) {

        rc = SceInfpGetObjects(
                   hInf,
                   szDSSecurity,
                   ObjectFlag | SCEINF_OBJECT_FLAG_DSOBJECT,
                   &((*ppInfoBuffer)->pDsObjects.pAllNodes),
                   Errlog
                   );
        if ( rc != SCESTATUS_SUCCESS )
            goto Done;
    }
#endif

Done:

    if ( rc != SCESTATUS_SUCCESS ) {

        //
        // need free memory because some fatal error happened
        //

        SceFreeMemory( (PVOID)(*ppInfoBuffer), Area );
        if ( bFreeMem ) {
            ScepFree(*ppInfoBuffer);
            *ppInfoBuffer = NULL;
        }

    }

    return(rc);
}


SCESTATUS
SceInfpGetSystemAccess(
    IN HINF  hInf,
    IN DWORD ObjectFlag,
    OUT PSCE_PROFILE_INFO pSCEinfo,
    OUT PSCE_ERROR_LOG_INFO *Errlog OPTIONAL
    )
/*++
Routine Description:

   This routine retrieves system access area information from the SCP INF
   file and stores in the output buffer pSCEinfo. System access information
   includes information in [System Access] section.

Arguments:

   hInf     -  INF handle to the profile

   pSCEinfo  - the output buffer to hold profile info.

   Errlog     -     A buffer to hold all error codes/text encountered when
                    parsing the INF file. If Errlog is NULL, no further error
                    information is returned except the return DWORD

Return value:

   SCESTATUS -  SCESTATUS_SUCCESS
               SCESTATUS_NOT_ENOUGH_RESOURCE
               SCESTATUS_INVALID_PARAMETER
               SCESTATUS_BAD_FORMAT
               SCESTATUS_INVALID_DATA

--*/

{
    INFCONTEXT    InfLine;
    SCESTATUS     rc=SCESTATUS_SUCCESS;
    DWORD         Keyvalue=0;
    DWORD         DataSize=0;
    PWSTR         Strvalue=NULL;

    SCE_KEY_LOOKUP AccessSCPLookup[] = {
        {(PWSTR)TEXT("MinimumPasswordAge"),           offsetof(struct _SCE_PROFILE_INFO, MinimumPasswordAge),        'D'},
        {(PWSTR)TEXT("MaximumPasswordAge"),           offsetof(struct _SCE_PROFILE_INFO, MaximumPasswordAge),        'D'},
        {(PWSTR)TEXT("MinimumPasswordLength"),        offsetof(struct _SCE_PROFILE_INFO, MinimumPasswordLength),     'D'},
        {(PWSTR)TEXT("PasswordComplexity"),           offsetof(struct _SCE_PROFILE_INFO, PasswordComplexity),        'D'},
        {(PWSTR)TEXT("PasswordHistorySize"),          offsetof(struct _SCE_PROFILE_INFO, PasswordHistorySize),       'D'},
        {(PWSTR)TEXT("LockoutBadCount"),              offsetof(struct _SCE_PROFILE_INFO, LockoutBadCount),           'D'},
        {(PWSTR)TEXT("ResetLockoutCount"),            offsetof(struct _SCE_PROFILE_INFO, ResetLockoutCount),         'D'},
        {(PWSTR)TEXT("LockoutDuration"),              offsetof(struct _SCE_PROFILE_INFO, LockoutDuration),           'D'},
        {(PWSTR)TEXT("RequireLogonToChangePassword"), offsetof(struct _SCE_PROFILE_INFO, RequireLogonToChangePassword), 'D'},
        {(PWSTR)TEXT("ForceLogoffWhenHourExpire"),    offsetof(struct _SCE_PROFILE_INFO, ForceLogoffWhenHourExpire), 'D'},
        {(PWSTR)TEXT("NewAdministratorName"),         0,                                                            'A'},
        {(PWSTR)TEXT("NewGuestName"),                 0,                                                            'G'},
        {(PWSTR)TEXT("SecureSystemPartition"),        offsetof(struct _SCE_PROFILE_INFO, SecureSystemPartition),     'D'},
        {(PWSTR)TEXT("ClearTextPassword"),            offsetof(struct _SCE_PROFILE_INFO, ClearTextPassword),         'D'},
        {(PWSTR)TEXT("LSAAnonymousNameLookup"),       offsetof(struct _SCE_PROFILE_INFO, LSAAnonymousNameLookup),         'D'},
        {(PWSTR)TEXT("EnableAdminAccount"),          offsetof(struct _SCE_PROFILE_INFO, EnableAdminAccount),         'D'},
        {(PWSTR)TEXT("EnableGuestAccount"),          offsetof(struct _SCE_PROFILE_INFO, EnableGuestAccount),         'D'}
        };

    DWORD       cAccess = sizeof(AccessSCPLookup) / sizeof(SCE_KEY_LOOKUP);

    DWORD       i;
    UINT        Offset;
    WCHAR       Keyname[SCE_KEY_MAX_LENGTH];

    //
    // Initialize to SCE_NO_VALUE
    //
    for ( i=0; i<cAccess; i++) {
        if ( AccessSCPLookup[i].BufferType == 'D' )
            *((DWORD *)((CHAR *)pSCEinfo+AccessSCPLookup[i].Offset)) = SCE_NO_VALUE;

    }
    //
    // Locate the [System Access] section.
    //

    if(SetupFindFirstLine(hInf,szSystemAccess,NULL,&InfLine)) {

        do {

            //
            // Get key names and its setting.
            //

            rc = SCESTATUS_SUCCESS;
            memset(Keyname, '\0', SCE_KEY_MAX_LENGTH*sizeof(WCHAR));

            if ( SetupGetStringField(&InfLine, 0, Keyname, SCE_KEY_MAX_LENGTH, NULL) ) {

                for ( i=0; i<cAccess; i++) {

                    //
                    // get settings in AccessLookup table
                    //
                    Offset = AccessSCPLookup[i].Offset;

                    if (_wcsicmp(Keyname, AccessSCPLookup[i].KeyString ) == 0) {

                        switch ( AccessSCPLookup[i].BufferType ) {
                        case 'B':

                            //
                            // Int Field
                            //
                            Keyvalue = 0;
                            SetupGetIntField( &InfLine, 1, (INT *)&Keyvalue );
                            *((BOOL *)((CHAR *)pSCEinfo+Offset)) = Keyvalue ? TRUE : FALSE;

                            break;
                        case 'D':

                            //
                            // Int Field
                            //

                            if (SetupGetIntField(&InfLine, 1, (INT *)&Keyvalue ) )
                                *((DWORD *)((CHAR *)pSCEinfo+Offset)) = (DWORD)Keyvalue;

                            break;
                        default:

                            //
                            // String Field - NewAdministratorName, or NewGuestName
                            //

                            if(SetupGetStringField(&InfLine,1,NULL,0,&DataSize) && DataSize > 0) {

                                Strvalue = (PWSTR)ScepAlloc( 0, (DataSize+1)*sizeof(WCHAR));

                                if( Strvalue == NULL ) {
                                    rc = SCESTATUS_NOT_ENOUGH_RESOURCE;

                                } else {
                                    Strvalue[DataSize] = L'\0';

                                    if(SetupGetStringField(&InfLine,1,Strvalue,DataSize, NULL)) {
                                        if ( Strvalue[0] != L'\0' && Strvalue[0] != L' ') {
                                            if (AccessSCPLookup[i].BufferType == 'A') // administrator
                                                pSCEinfo->NewAdministratorName = Strvalue;
                                            else // guest
                                                pSCEinfo->NewGuestName = Strvalue;
                                        } else
                                            ScepFree(Strvalue);
                                        Strvalue = NULL;
                                    } else {
                                        ScepFree( Strvalue );
                                        rc = SCESTATUS_BAD_FORMAT;
                                    }
                                }
                            } else
                                rc = SCESTATUS_BAD_FORMAT;
                            break;
                        }

                        break; // for loop

                    }
                }

                if ( i >= cAccess &&
                     !(ObjectFlag & SCEINF_OBJECT_FLAG_UNKNOWN_VERSION) ) {

                    //
                    // Did not find a match in the lookup table
                    //

                   ScepBuildErrorLogInfo( NO_ERROR,
                                        Errlog,
                                        SCEERR_NOT_EXPECTED,
                                        Keyname,szSystemAccess );

                }
                if ( rc != SCESTATUS_SUCCESS ) {
                    ScepBuildErrorLogInfo( ScepSceStatusToDosError(rc),
                                         Errlog,
                                         SCEERR_QUERY_INFO,
                                         Keyname );
                }

            } else {
                rc = SCESTATUS_INVALID_DATA;
                ScepBuildErrorLogInfo( ERROR_INVALID_DATA, Errlog,
                                      SCEERR_QUERY_INFO,
                                      szSystemAccess);
            }

            //
            // if error happens, get out
            //
            if ( rc != SCESTATUS_SUCCESS )
                 return(rc);

        } while(SetupFindNextLine(&InfLine,&InfLine));

    }

    return(rc);
}


SCESTATUS
SceInfpGetUserSettings(
   IN HINF hInf,
   OUT PSCE_NAME_LIST *pProfileList,
   OUT PSCE_ERROR_LOG_INFO *Errlog OPTIONAL
   )
/* ++
Routine Description:

   This routine retrieves account profile list from the INF file (SCP) and
   stores in the output buffer pProfileList.

Arguments:

   hInf          - INF handle to the profile

   pProfileList  - the output buffer to hold account profile list.

   Errlog        - The error list encountered inside inf processing.

Return value:

   SCESTATUS -  SCESTATUS_SUCCESS
               SCESTATUS_NOT_ENOUGH_RESOURCE
               SCESTATUS_INVALID_PARAMETER
               SCESTATUS_BAD_FORMAT
               SCESTATUS_INVALID_DATA
-- */

{
    INFCONTEXT  InfLine;
    SCESTATUS    rc=SCESTATUS_SUCCESS;
    WCHAR       Keyname[SCE_KEY_MAX_LENGTH];

    //
    // [Account Profiles] section
    //

    if(SetupFindFirstLine(hInf,szAccountProfiles,NULL,&InfLine)) {

        do {

            memset(Keyname, '\0', SCE_KEY_MAX_LENGTH*sizeof(WCHAR));

            if ( SetupGetStringField(&InfLine, 0, Keyname, SCE_KEY_MAX_LENGTH, NULL) ) {

                //
                // find a key name which is a profile name.
                //
                rc = ScepAddToNameList(pProfileList, Keyname, 0);

                if ( rc != SCESTATUS_SUCCESS ) {
                    ScepBuildErrorLogInfo(ERROR_INVALID_DATA,
                                         Errlog,
                                         SCEERR_ADD,
                                         Keyname );
                }
            } else {
                ScepBuildErrorLogInfo(ERROR_BAD_FORMAT,
                                     Errlog,
                                     SCEERR_QUERY_INFO,
                                     L"profile name"
                                     );

                rc = SCESTATUS_BAD_FORMAT;
            }

        } while( rc == SCESTATUS_SUCCESS &&
                 SetupFindNextLine(&InfLine,&InfLine));
    }

    return(rc);
}


SCESTATUS
SceInfpGetGroupMembership(
    IN HINF hInf,
    OUT PSCE_GROUP_MEMBERSHIP *pGroupMembership,
    OUT PSCE_ERROR_LOG_INFO *Errlog OPTIONAL
    )
/* ++
Routine Description:

   This routine retrieves group membership information from the SCP INF file
   and stores in the output buffer pGroupMembership. Group membership info is
   in [Group Membership] section.

Arguments:

   hInf     - INF handle to the profile

   pGroupMembership  - the output buffer to hold group membersip information.

   Errlog    - the error list for errors encountered in this routine.

Return value:

   SCESTATUS - SCESTATUS_SUCCESS
              SCESTATUS_NOT_ENOUGH_RESOURCE
              SCESTATUS_INVALID_PARAMETER
              SCESTATUS_BAD_FORMAT
              SCESTATUS_INVALID_DATA

-- */
{
    INFCONTEXT    InfLine;
    PSCE_NAME_LIST pMembers=NULL;
    SCESTATUS      rc=SCESTATUS_SUCCESS;
    PWSTR         Keyname=NULL;
    DWORD         KeyLen;
    DWORD         ValueType;
    PWSTR         pTemp;
    DWORD         i;
    DWORD         cFields;
    DWORD         DataSize;
    PWSTR         Strvalue=NULL;
    PWSTR         GroupName=NULL;
    DWORD         GroupLen;


    if ( pGroupMembership == NULL )
        return(SCESTATUS_INVALID_PARAMETER);

    LSA_HANDLE LsaHandle=NULL;

    //
    // Locate the [Group MemberShip] section.
    //

    if ( SetupFindFirstLine(hInf,szGroupMembership,NULL,&InfLine) ) {

        //
        // open lsa policy handle for sid/name lookup
        //

        rc = RtlNtStatusToDosError(
                  ScepOpenLsaPolicy(
                        POLICY_LOOKUP_NAMES | POLICY_VIEW_LOCAL_INFORMATION,
                        &LsaHandle,
                        TRUE
                        ));

        if ( ERROR_SUCCESS != rc ) {
            ScepBuildErrorLogInfo(
                        rc,
                        Errlog,
                        SCEERR_ADD,
                        TEXT("LSA")
                        );
            return(ScepDosErrorToSceStatus(rc));
        }

        PSID pSid=NULL;

        do {
            //
            // Get group names.
            //
            rc = SCESTATUS_BAD_FORMAT;

            if ( SetupGetStringField(&InfLine, 0, NULL, 0, &KeyLen) ) {

                Keyname = (PWSTR)ScepAlloc( 0, (KeyLen+1)*sizeof(WCHAR));
                if ( Keyname == NULL ) {
                    rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
                    goto Done;
                }
                Keyname[KeyLen] = L'\0';

                if ( SetupGetStringField(&InfLine, 0, Keyname, KeyLen, NULL) ) {
                    //
                    // look for what kind of value this line is
                    //
                    pTemp = ScepWcstrr(Keyname, szMembers);
                    ValueType = 0;

                    if ( pTemp == NULL ) {
                        pTemp = ScepWcstrr(Keyname, szMemberof);
                        ValueType = 1;
                    }

                    if ( pTemp == NULL ) {
                        ScepBuildErrorLogInfo( ERROR_INVALID_DATA,
                                             Errlog,
                                             SCEERR_CANT_FIND_KEYWORD,
                                             Keyname
                                           );
                        rc = SCESTATUS_SUCCESS;
                        goto NextLine;
                    }

                    // terminiate Keyname for the group name only
                    *pTemp = L'\0';

                    if ( Keyname[0] == L'*' ) {
                        //
                        // *SID format, convert it into group name
                        //
                        if ( ConvertStringSidToSid( Keyname+1, &pSid) ) {
                            //
                            // if failed to convert from sid string to sid,
                            // treat it as any name
                            //

                            ScepConvertSidToName(
                                LsaHandle,
                                pSid,
                                TRUE,
                                &GroupName,
                                &GroupLen
                                );
                            LocalFree(pSid);
                            pSid = NULL;
                        }
                    }

                    if ( GroupName == NULL ) {
                        GroupLen = (DWORD) (pTemp - Keyname);
                    }

                    //
                    // String fields. Each string respresents a member or memberof name.
                    //

                    cFields = SetupGetFieldCount( &InfLine );

                    for ( i=0; i<cFields; i++) {
                        if(SetupGetStringField(&InfLine,i+1,NULL,0,&DataSize) && DataSize > 0 ) {

                            Strvalue = (PWSTR)ScepAlloc( LMEM_ZEROINIT,
                                                         (DataSize+1)*sizeof(WCHAR) );

                            if( Strvalue == NULL ) {
                                rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
                            } else {
                                if(SetupGetStringField(&InfLine,i+1,Strvalue,DataSize,NULL)) {

                                    //
                                    // Get a member name and save in the list
                                    //

                                    if ( Strvalue[0] == L'*' && DataSize > 0 ) {
                                        //
                                        // this is a SID format, should look it up
                                        //
                                        rc = ScepLookupSidStringAndAddToNameList(
                                                               LsaHandle,
                                                               &pMembers,
                                                               Strvalue, // +1,
                                                               DataSize  // -1
                                                               );

                                    } else {

                                        rc = ScepAddToNameList(&pMembers,
                                                              Strvalue,
                                                              DataSize+1
                                                             );
                                    }
                                }

                                ScepFree( Strvalue );
                                Strvalue = NULL;
                            }
                        }

                        if ( rc != SCESTATUS_SUCCESS)
                            break; // for loop

                    } // end of for loop

                    if ( rc == SCESTATUS_SUCCESS ) { // && pMembers != NULL ) {
                        //
                        // add this list to the group
                        //
                        rc = ScepAddToGroupMembership(
                                    pGroupMembership,
                                    GroupName ? GroupName : Keyname,
                                    GroupLen, // wcslen(Keyname),
                                    pMembers,
                                    ValueType,
                                    TRUE,
                                    TRUE
                                    );
                        if ( rc == SCESTATUS_SUCCESS )
                            pMembers = NULL;

                    }
                    // restore the character
                    *pTemp = L'_';

                }
            }

            if ( rc != SCESTATUS_SUCCESS ) {

                ScepBuildErrorLogInfo( ERROR_BAD_FORMAT,
                                  Errlog,
                                  SCEERR_QUERY_INFO,
                                  szGroupMembership
                                  );
                goto Done;

            }

NextLine:
            //
            // Free pMembers, Keyname
            //
            ScepFreeNameList(pMembers);
            pMembers = NULL;

            ScepFree(Keyname);
            Keyname = NULL;

            if ( GroupName ) {
                LocalFree(GroupName);
                GroupName = NULL;
            }

        } while(SetupFindNextLine(&InfLine,&InfLine));
    }

Done:
    //
    // Free pMembers, Keyname
    //
    ScepFreeNameList(pMembers);

    if ( Keyname != NULL )
        ScepFree(Keyname);

    if ( Strvalue != NULL )
        ScepFree( Strvalue );

    if ( LsaHandle ) {
        LsaClose(LsaHandle);
    }

    if ( GroupName ) {
        LocalFree(GroupName);
    }

    return(rc);
}


SCESTATUS
SceInfpGetObjects(
    IN HINF hInf,
    IN PCWSTR SectionName,
    IN DWORD ObjectFlag,
    OUT PSCE_OBJECT_ARRAY *pAllNodes,
    OUT PSCE_ERROR_LOG_INFO *Errlog OPTIONAL
   )
/* ++
Routine Description:

   This routine retrieves registry or files security information (names and
   security descriptors) from the INF file (SCP and SAP) and stores in the
   output buffer pSCEinfo. Registry information is in [SCRegistryKeysSecurity]
   section. Files information is in [SSFileSecurity], [SCIntel86Only], and
   [SCRISCOnly] sections. These sections have the same format, namely, 3 fields
   on each line - name, workstaiton setting, and server setting.

Arguments:

   hInf     - INF handle to the profile

   SectionName   - the section name to retrieve.

   pAllNodes  - the output buffer to hold all objects in the section.

   Errlog   - the cummulative error list to hold errors encountered in this routine.

Return value:

   SCESTATUS - SCESTATUS_SUCCESS
              SCESTATUS_NOT_ENOUGH_RESOURCE
              SCESTATUS_INVALID_PARAMETER
              SCESTATUS_BAD_FORMAT
              SCESTATUS_INVALID_DATA
-- */
{
    INFCONTEXT InfLine;
    SCESTATUS   rc=SCESTATUS_SUCCESS;
    LONG       i;
    LONG       nLines;
    DWORD      cFields;

    if ( pAllNodes == NULL || SectionName == NULL )
        return(SCESTATUS_INVALID_PARAMETER);

    //
    // count how many objects
    //
    nLines = SetupGetLineCount(hInf, SectionName );
    if ( nLines == -1 ) {
        // section not found
        return(SCESTATUS_SUCCESS);
    }
    *pAllNodes = (PSCE_OBJECT_ARRAY)ScepAlloc(0, sizeof(SCE_OBJECT_ARRAY));
    if ( *pAllNodes == NULL )
        return(SCESTATUS_NOT_ENOUGH_RESOURCE);

    (*pAllNodes)->Count = nLines;
    (*pAllNodes)->pObjectArray = NULL;

    if ( nLines == 0 )
        return(SCESTATUS_SUCCESS);

    //
    // allocate memory for all objects
    //
    (*pAllNodes)->pObjectArray = (PSCE_OBJECT_SECURITY *)ScepAlloc( LMEM_ZEROINIT,
                                             nLines*sizeof(PSCE_OBJECT_SECURITY) );
    if ( (*pAllNodes)->pObjectArray == NULL ) {
        ScepFree(*pAllNodes);
        *pAllNodes = NULL;
        return(SCESTATUS_NOT_ENOUGH_RESOURCE);
    }

    //
    // Locate the section.
    //
    if ( SetupFindFirstLine(hInf,SectionName,NULL,&InfLine) ) {
        i = 0;
        TCHAR         tmpBuf[MAX_PATH];

        do {
            //
            // Get string fields. Don't care the key name or if it exist.
            // Must have 3 fields each line for supported versions.
            //
            cFields = SetupGetFieldCount( &InfLine );

            if ( cFields < 3 ) {

                tmpBuf[0] = L'\0';
                SetupGetStringField(&InfLine,1,tmpBuf,MAX_PATH,NULL);

                ScepBuildErrorLogInfo( ERROR_INVALID_DATA,
                                     Errlog,
                                     SCEERR_OBJECT_FIELDS,
                                     tmpBuf);

                if (ObjectFlag & SCEINF_OBJECT_FLAG_UNKNOWN_VERSION) {
                    //
                    // maybe a new format for object,
                    // ignore this line
                    //
                    rc = SCESTATUS_SUCCESS;
                    goto NextLine;

                } else {
                    rc = SCESTATUS_INVALID_DATA;
                }
            }

            if ( SCESTATUS_SUCCESS == rc ) {

                rc = SceInfpGetOneObjectSecurity(
                                           &InfLine,
                                           ObjectFlag,
                                           ( (*pAllNodes)->pObjectArray + i ),
                                           Errlog
                                          );
            }

            if ( rc != SCESTATUS_SUCCESS ) {

                if ( rc == SCESTATUS_BAD_FORMAT ) {

                    ScepBuildErrorLogInfo( ERROR_BAD_FORMAT,
                                         Errlog,
                                         SCEERR_QUERY_INFO,
                                         SectionName);
                }

                break; // do..while loop
            }

            i++;

NextLine:
            if ( i > nLines ) {
                // more lines than allocated
                rc = SCESTATUS_INVALID_DATA;
                ScepBuildErrorLogInfo(ERROR_INVALID_DATA,
                                     Errlog,
                                     SCEERR_MORE_OBJECTS,
                                     nLines
                                     );
                break;
            }

        } while(SetupFindNextLine(&InfLine,&InfLine));

    }

    if ( rc != SCESTATUS_SUCCESS ) {
        // free memory
        ScepFreeObjectSecurity( *pAllNodes );
//        ScepFree( *pAllNodes );
        *pAllNodes = NULL;

    } else if ( ObjectFlag & SCEINF_OBJECT_FLAG_UNKNOWN_VERSION ) {

        //
        // reset the count because some lines may be skipped
        //
        (*pAllNodes)->Count = i;
    }

    return(rc);

}


SCESTATUS
SceInfpGetOneObjectSecurity(
    IN PINFCONTEXT pInfLine,
    IN DWORD ObjectFlag,
    OUT PSCE_OBJECT_SECURITY *ppObject,
    OUT PSCE_ERROR_LOG_INFO *Errlog OPTIONAL
    )
/* ++
Routine Description:

   This routine retrieves security setting for one object (a registry key,
   or a file) from the INF file (SCP type). Each object in these sections
   is represented by one line. Each object has 3 fields, a name, a status
   flag, and security setting. This routine stores the output in buffer
   ppObject.

Arguments:

   pInfLine  - Current line context from the INF file for one object

   ppObject  - Output buffer (tree root ) to hold the security settings for this line

   Errlog    - The cummulative error list for errors encountered in this routine

Return value:

   SCESTATUS - SCESTATUS_SUCCESS
              SCESTATUS_NOT_ENOUGH_RESOURCE
              SCESTATUS_INVALID_PARAMETER
              SCESTATUS_BAD_FORMAT
              SCESTATUS_INVALID_DATA
-- */
{
    DWORD         cFields;
    DWORD         DataSize;
    PWSTR         Strvalue=NULL;
    PWSTR         SDspec=NULL;
    DWORD         SDsize;
    DWORD         Status=0;
    PSECURITY_DESCRIPTOR  pTempSD=NULL;
    SECURITY_INFORMATION  SeInfo;
    SCESTATUS      rc=SCESTATUS_SUCCESS;

    //
    // The Registry/File INF layout must have 3 fields for each line.
    // The first field is the key/file name, the 2nd field is status flag -
    // ignore, or check, and the 3rd field is the security descriptor text
    //

    if ( ppObject == NULL )
        return(SCESTATUS_INVALID_PARAMETER);

    cFields = SetupGetFieldCount( pInfLine );

    if ( cFields < 3 ) {

        return(SCESTATUS_INVALID_DATA);

    } else if(SetupGetStringField(pInfLine,1,NULL,0,&DataSize) && DataSize > 0 ) {

        Strvalue = (PWSTR)ScepAlloc( LMEM_ZEROINIT,
                                     (DataSize+1)*sizeof(WCHAR) );
        if( Strvalue == NULL ) {
            return(SCESTATUS_NOT_ENOUGH_RESOURCE);
        } else {

            //
            // the first field is the key/file name.
            // The 2nd is a status flag.
            // The 3rd field is the security descriptor text
            //

            if( SetupGetStringField(pInfLine,1,Strvalue,DataSize,NULL) &&
                SetupGetIntField( pInfLine, 2, (INT *)&Status ) &&
//                SetupGetStringField(pInfLine,3,NULL,0,&SDsize) ) {
                SetupGetMultiSzField(pInfLine,3,NULL,0,&SDsize) ) {

                SDspec = (PWSTR)ScepAlloc( LMEM_ZEROINIT,
                                           (SDsize+1)*sizeof(WCHAR)
                                          );
                if( SDspec == NULL ) {
                    rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
                    goto Done;
                }

//                if(SetupGetStringField(pInfLine,3,SDspec,SDsize,NULL)) {
                if(SetupGetMultiSzField(pInfLine,3,SDspec,SDsize,NULL)) {

                    //
                    // convert the multi-sz delimiter to space, if there is any
                    //
                    if ( cFields > 3 ) {
                        ScepConvertMultiSzToDelim(SDspec, SDsize, L'\0', L' ');
                    }

                    if ( ObjectFlag & SCEINF_OBJECT_FLAG_OLDSDDL ) {

                        ScepConvertToSDDLFormat(SDspec, SDsize);
                    }

                    //
                    // Convert the text to real security descriptors
                    //

                    rc = ConvertTextSecurityDescriptor(
                                       SDspec,
                                       &pTempSD,
                                       &SDsize,
                                       &SeInfo
                                       );

                    if (rc == NO_ERROR) {
                        // create a new object node to hold these info.

                        if ( !(ObjectFlag & SCEINF_OBJECT_FLAG_DSOBJECT) ) {
                            ScepChangeAclRevision(pTempSD, ACL_REVISION);
                        }

                        *ppObject = (PSCE_OBJECT_SECURITY)ScepAlloc(0, sizeof(SCE_OBJECT_SECURITY));
                        if ( *ppObject == NULL )
                            rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
                        else {
                            (*ppObject)->Name = Strvalue;
                            (*ppObject)->Status = (BYTE)Status;
                            (*ppObject)->IsContainer = TRUE;         // always default to TRUE
                            (*ppObject)->pSecurityDescriptor = pTempSD;
                            (*ppObject)->SeInfo = SeInfo;
                            pTempSD = NULL;
//                            (*ppObject)->SDspec = SDspec;
//                            (*ppObject)->SDsize = SDsize;
                            Strvalue = NULL;
//                            SDspec = NULL;

                            rc = SCESTATUS_SUCCESS;
                        }
                    } else {
                        ScepBuildErrorLogInfo(rc,
                                             Errlog,
                                             SCEERR_BUILD_SD,
                                             Strvalue);

                        rc = ScepDosErrorToSceStatus(rc);
                    }

                } else
                    rc = SCESTATUS_BAD_FORMAT;
            } else
                rc = SCESTATUS_BAD_FORMAT;
        }
    } else
        rc = SCESTATUS_BAD_FORMAT;

Done:
    if ( Strvalue != NULL )
        ScepFree( Strvalue );

    if ( SDspec != NULL )
        ScepFree( SDspec );

    if ( pTempSD != NULL )
        ScepFree( pTempSD );

    return(rc);
}


SCESTATUS
SceInfpGetAuditing(
   IN HINF hInf,
   IN DWORD ObjectFlag,
   OUT PSCE_PROFILE_INFO pSCEinfo,
   OUT PSCE_ERROR_LOG_INFO *Errlog OPTIONAL
   )
/* ++
Routine Description:

   This routine retrieves system auditing information from the INF file and
   storesin the output buffer pSCEinfo. The auditing information is stored in
   [System Log], [Security Log], [Application Log], [Event Audit],
   [Registry Audit], and [File Audit] sections.

Arguments:

   hInf     - INF handle to the profile

   pSCEinfo  - the output buffer to hold SCP profile info.

   Errlog   - The cummulative error list to hold errors encountered in this routine.

Return value:

   SCESTATUS - SCESTATUS_SUCCESS
              SCESTATUS_NOT_ENOUGH_RESOURCE
              SCESTATUS_INVALID_PARAMETER
              SCESTATUS_BAD_FORMAT
              SCESTATUS_INVALID_DATA
-- */
{

    INFCONTEXT          InfLine;
    SCESTATUS            rc=SCESTATUS_SUCCESS;
    DWORD               Keyvalue;
    WCHAR               Keyname[SCE_KEY_MAX_LENGTH];
    DWORD               LogSize;
    DWORD               Periods;
    DWORD               RetentionDays;
    DWORD               RestrictGuest;
    PCWSTR              szAuditLog;
    DWORD               i;


    for ( i=0; i<3; i++ ) {

        //
        // Get Event Log setting for system log, security log and application log
        //

        switch (i) {
        case 0:
            szAuditLog = szAuditSystemLog;
            break;
        case 1:
            szAuditLog = szAuditSecurityLog;
            break;
        default:
            szAuditLog = szAuditApplicationLog;
            break;
        }

        LogSize=SCE_NO_VALUE;
        Periods=SCE_NO_VALUE;
        RetentionDays=SCE_NO_VALUE;
        RestrictGuest=SCE_NO_VALUE;

        rc = SceInfpGetAuditLogSetting(
                                   hInf,
                                   szAuditLog,
                                   ObjectFlag,
                                   &LogSize,
                                   &Periods,
                                   &RetentionDays,
                                   &RestrictGuest,
                                   Errlog
                                 );

        if ( rc != SCESTATUS_SUCCESS )
            return(rc);

        pSCEinfo->MaximumLogSize[i] = LogSize;
        pSCEinfo->AuditLogRetentionPeriod[i] = Periods;
        pSCEinfo->RetentionDays[i] = RetentionDays;
        pSCEinfo->RestrictGuestAccess[i] = RestrictGuest;
    }

    //
    // Get Audit Event info
    //
    if ( SetupFindFirstLine(hInf,szAuditEvent,NULL,&InfLine) ) {

       do {

           memset(Keyname, '\0', SCE_KEY_MAX_LENGTH*sizeof(WCHAR));

           if ( SetupGetStringField(&InfLine, 0, Keyname, SCE_KEY_MAX_LENGTH, NULL) &&
                SetupGetIntField( &InfLine, 1, (INT *)&Keyvalue )
              ) {

               if ( _wcsicmp(Keyname, TEXT("AuditSystemEvents")) == 0 ) {

                  pSCEinfo->AuditSystemEvents = Keyvalue;

               } else if ( _wcsicmp(Keyname, TEXT("AuditLogonEvents")) == 0 ) {

                  pSCEinfo->AuditLogonEvents = Keyvalue;

               } else if ( _wcsicmp(Keyname, TEXT("AuditObjectAccess")) == 0 ) {

                  pSCEinfo->AuditObjectAccess = Keyvalue;

               } else if ( _wcsicmp(Keyname, TEXT("AuditPrivilegeUse")) == 0 ) {

                  pSCEinfo->AuditPrivilegeUse = Keyvalue;

               } else if ( _wcsicmp(Keyname, TEXT("AuditPolicyChange")) == 0 ) {

                  pSCEinfo->AuditPolicyChange = Keyvalue;

               } else if ( _wcsicmp(Keyname, TEXT("AuditAccountManage")) == 0 ) {

                  pSCEinfo->AuditAccountManage = Keyvalue;

               } else if ( _wcsicmp(Keyname, TEXT("AuditProcessTracking")) == 0 ) {

                  pSCEinfo->AuditProcessTracking = Keyvalue;

               } else if ( _wcsicmp(Keyname, TEXT("AuditDSAccess")) == 0 ) {

                  pSCEinfo->AuditDSAccess = Keyvalue;

               } else if ( _wcsicmp(Keyname, TEXT("AuditAccountLogon")) == 0 ) {

                  pSCEinfo->AuditAccountLogon = Keyvalue;

               } else if ( _wcsicmp(Keyname, TEXT("CrashOnAuditFull")) == 0 ) {

                  pSCEinfo->CrashOnAuditFull = Keyvalue;

               } else if ( !(ObjectFlag & SCEINF_OBJECT_FLAG_UNKNOWN_VERSION) ) {

                  ScepBuildErrorLogInfo(0, Errlog,
                                        SCEERR_NOT_EXPECTED,
                                        Keyname, szAuditEvent);
               }

           } else {
               rc = SCESTATUS_BAD_FORMAT;
               ScepBuildErrorLogInfo( ERROR_BAD_FORMAT,
                                     Errlog,
                                     SCEERR_QUERY_INFO,
                                     szAuditEvent
                                     );
               return(rc);
           }
       } while(SetupFindNextLine(&InfLine, &InfLine));

    }

    return(rc);
}


SCESTATUS
SceInfpGetAuditLogSetting(
   IN HINF hInf,
   IN PCWSTR SectionName,
   IN DWORD ObjectFlag,
   OUT PDWORD LogSize,
   OUT PDWORD Periods,
   OUT PDWORD RetentionDays,
   OUT PDWORD RestrictGuest,
   IN OUT PSCE_ERROR_LOG_INFO *Errlog OPTIONAL
   )
/* ++
Routine Description:

   This routine retrieves audit log setting from the INF file based on the
   SectionName passed in. The audit log settings include MaximumSize,
   RetentionPeriod and RetentionDays. There are 3 different logs (system,
   security, and application) which all have the same setting. The information
   returned in in LogSize, Periods, RetentionDays. These 3 output arguments will
   be reset to SCE_NO_VALUE at the begining of the routine. So if error
   occurs after the reset, the original values won't be set back.

Arguments:

   hInf     - INF handle to the profile

   SectionName - Log section name (SAdtSystemLog, SAdtSecurityLog, SAdtApplicationLog)

   LogSize - The maximum size of the log

   Periods - The retention period of the log

   RetentionDays - The number of days for log retention

Return value:

   SCESTATUS - SCESTATUS_SUCCESS
              SCESTATUS_NOT_ENOUGH_RESOURCE
              SCESTATUS_INVALID_PARAMETER
              SCESTATUS_BAD_FORMAT
              SCESTATUS_INVALID_DATA
-- */
{

    INFCONTEXT InfLine;
    SCESTATUS   rc=SCESTATUS_SUCCESS;
    DWORD      Keyvalue;
    WCHAR      Keyname[SCE_KEY_MAX_LENGTH];

    *LogSize = SCE_NO_VALUE;
    *Periods = SCE_NO_VALUE;
    *RetentionDays = SCE_NO_VALUE;

    if ( SetupFindFirstLine(hInf,SectionName,NULL,&InfLine) ) {

        do {

            memset(Keyname, '\0', SCE_KEY_MAX_LENGTH*sizeof(WCHAR));

            if ( SetupGetStringField(&InfLine, 0, Keyname, SCE_KEY_MAX_LENGTH, NULL) &&
                 SetupGetIntField(&InfLine, 1, (INT *)&Keyvalue)
               ) {

                if ( _wcsicmp(Keyname, TEXT("MaximumLogSize")) == 0 )
                    *LogSize = Keyvalue;
                else if (_wcsicmp(Keyname, TEXT("AuditLogRetentionPeriod")) == 0 )
                    *Periods = Keyvalue;
                else if (_wcsicmp(Keyname, TEXT("RetentionDays")) == 0 )
                    *RetentionDays = Keyvalue;
                else if (_wcsicmp(Keyname, TEXT("RestrictGuestAccess")) == 0 )
                    *RestrictGuest = Keyvalue;
                else if ( !(ObjectFlag & SCEINF_OBJECT_FLAG_UNKNOWN_VERSION) ) {
                    ScepBuildErrorLogInfo(0, Errlog,
                                          SCEERR_NOT_EXPECTED,
                                          Keyname, SectionName);
                }

            } else {
                rc = SCESTATUS_BAD_FORMAT;
                ScepBuildErrorLogInfo( ERROR_BAD_FORMAT, Errlog,
                                      SCEERR_QUERY_INFO,
                                      SectionName
                                      );
            }
            if ( rc != SCESTATUS_SUCCESS )
                break;

        } while(SetupFindNextLine(&InfLine, &InfLine));

    }

    return(rc);
}


SCESTATUS
SceInfpGetUserSection(
    IN HINF    hInf,
    IN PWSTR   Name,
    OUT PSCE_USER_PROFILE *pOneProfile,
    OUT PSCE_ERROR_LOG_INFO *Errlog OPTIONAL
    )
{
    INFCONTEXT                   InfLine;
    SCESTATUS                     rc=SCESTATUS_SUCCESS;
    PSCE_LOGON_HOUR               pLogonHour=NULL;
    PWSTR                        SectionName=NULL;
    WCHAR                        Keyname[SCE_KEY_MAX_LENGTH];
    DWORD                        Keyvalue;
    DWORD                        Keyvalue2;
    PWSTR                        Strvalue=NULL;
    DWORD                        DataSize;
    DWORD                        i, cFields;
    LONG                         i1,i2;
    PSECURITY_DESCRIPTOR         pTempSD=NULL;
    SECURITY_INFORMATION         SeInfo;



    if ( hInf == NULL || Name == NULL || pOneProfile == NULL )
        return(SCESTATUS_INVALID_PARAMETER);

    SectionName = (PWSTR)ScepAlloc( LMEM_ZEROINIT, (wcslen(Name)+9)*sizeof(WCHAR));
    if ( SectionName == NULL )
        return(SCESTATUS_NOT_ENOUGH_RESOURCE);

    swprintf(SectionName, L"UserProfile %s", Name );

    if ( SetupFindFirstLine(hInf, SectionName, NULL, &InfLine) ) {

        //
        // find the detail profile section. Allocate memory
        //
        *pOneProfile = (PSCE_USER_PROFILE)ScepAlloc( 0, sizeof(SCE_USER_PROFILE));
        if ( *pOneProfile == NULL ) {
            rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
            goto Done;
        }
        //
        // initialize
        //
        (*pOneProfile)->Type = SCE_STRUCT_PROFILE;
        (*pOneProfile)->ForcePasswordChange = SCE_NO_VALUE;
        (*pOneProfile)->DisallowPasswordChange = SCE_NO_VALUE;
        (*pOneProfile)->NeverExpirePassword = SCE_NO_VALUE;
        (*pOneProfile)->AccountDisabled = SCE_NO_VALUE;
        (*pOneProfile)->UserProfile = NULL;
        (*pOneProfile)->LogonScript = NULL;
        (*pOneProfile)->HomeDir = NULL;
        (*pOneProfile)->pLogonHours = NULL;
        (*pOneProfile)->pWorkstations.Length = 0;
        (*pOneProfile)->pWorkstations.MaximumLength = 0;
        (*pOneProfile)->pWorkstations.Buffer = NULL;
        (*pOneProfile)->pGroupsBelongsTo = NULL;
        (*pOneProfile)->pAssignToUsers = NULL;
        (*pOneProfile)->pHomeDirSecurity = NULL;
        (*pOneProfile)->HomeSeInfo = 0;
        (*pOneProfile)->pTempDirSecurity = NULL;
        (*pOneProfile)->TempSeInfo = 0;


        do {

           rc = SCESTATUS_BAD_FORMAT;
           memset(Keyname, '\0', SCE_KEY_MAX_LENGTH*sizeof(WCHAR));

           if ( SetupGetStringField(&InfLine, 0, Keyname, SCE_KEY_MAX_LENGTH, NULL) ) {

                if ( _wcsicmp(Keyname, TEXT("DisallowPasswordChange")) == 0 ) {
                    //
                    // Int Field
                    //
                    if ( SetupGetIntField(&InfLine, 1, (INT *)&Keyvalue ) ) {

                        (*pOneProfile)->DisallowPasswordChange = Keyvalue;
                        rc = SCESTATUS_SUCCESS;
                    }
                    goto NextLine;

                }
                if ( _wcsicmp(Keyname, TEXT("PasswordChangeStyle")) == 0 ) {
                    //
                    // Int Field
                    //
                    if ( SetupGetIntField(&InfLine, 1, (INT *)&Keyvalue ) ) {

                        rc = SCESTATUS_SUCCESS;
                        switch (Keyvalue ) {
                        case 1:
                            (*pOneProfile)->NeverExpirePassword = 1;
                            (*pOneProfile)->ForcePasswordChange = 0;
                            break;
                        case 2:
                            (*pOneProfile)->NeverExpirePassword = 0;
                            (*pOneProfile)->ForcePasswordChange = 1;
                            break;
                        case 0:
                            // SCE_NO_VALUE for both. same as initialization
                            break;
                        default:
                            rc = SCESTATUS_INVALID_DATA;
                            break;
                        }
                    }
                    goto NextLine;

                }
                if ( _wcsicmp(Keyname, TEXT("AccountDisabled")) == 0 ) {
                    //
                    // Int Field
                    //
                    if ( SetupGetIntField(&InfLine, 1, (INT *)&Keyvalue ) ) {

                        (*pOneProfile)->AccountDisabled = Keyvalue == 0 ? 0 : 1;
                        rc = SCESTATUS_SUCCESS;
                    }
                    goto NextLine;

                }
                if ( _wcsicmp(Keyname, TEXT("UserProfile")) == 0 ) {
                    //
                    // String Field
                    //
                    if( SetupGetStringField(&InfLine,1,NULL,0,&DataSize) ) {

                        Strvalue = (PWSTR)ScepAlloc( LMEM_ZEROINIT,
                                                     (DataSize+1)*sizeof(WCHAR));

                        if( Strvalue == NULL ) {
                            rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
                        } else {
                           if(SetupGetStringField(&InfLine,1,Strvalue,DataSize,NULL)) {

                                (*pOneProfile)->UserProfile = Strvalue;
                                rc = SCESTATUS_SUCCESS;

                            } else
                                ScepFree( Strvalue );
                        }
                    }
                    goto NextLine;
                }
                if ( _wcsicmp(Keyname, TEXT("LogonScript")) == 0 ) {
                    //
                    // String Field
                    //
                    if(SetupGetStringField(&InfLine,1,NULL,0,&DataSize) ) {

                        Strvalue = (PWSTR)ScepAlloc( LMEM_ZEROINIT,
                                                     (DataSize+1)*sizeof(WCHAR));

                        if( Strvalue == NULL ) {
                            rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
                        } else {
                            if(SetupGetStringField(&InfLine,1,Strvalue,DataSize,NULL)) {

                                (*pOneProfile)->LogonScript = Strvalue;
                                rc = SCESTATUS_SUCCESS;
                            } else
                                ScepFree( Strvalue );
                        }
                    }
                    goto NextLine;
                }
                if ( _wcsicmp(Keyname, TEXT("HomeDir")) == 0 ) {
                    //
                    // String Field
                    //
                    if(SetupGetStringField(&InfLine,1,NULL,0,&DataSize) ) {

                       Strvalue = (PWSTR)ScepAlloc( LMEM_ZEROINIT,
                                                    (DataSize+1)*sizeof(WCHAR));

                        if( Strvalue == NULL ) {
                            rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
                        } else {
                            if(SetupGetStringField(&InfLine,1,Strvalue,DataSize,NULL)) {
                                (*pOneProfile)->HomeDir = Strvalue;
                                rc = SCESTATUS_SUCCESS;
                            } else
                                ScepFree( Strvalue );
                        }
                    }
                    goto NextLine;
                }
                if ( _wcsicmp(Keyname, TEXT("LogonHours")) == 0 ) {

                    //
                    // Int fields (in pairs). Each pair represents a logon hour range
                    //

                    cFields = SetupGetFieldCount( &InfLine );

                    //
                    // The first field is the key. Logon hour ranges must be in pairs
                    //

                    if ( cFields < 2 ) {
                        pLogonHour = (PSCE_LOGON_HOUR)ScepAlloc( LMEM_ZEROINIT,
                                                                sizeof(SCE_LOGON_HOUR) );
                        if ( pLogonHour == NULL ) {
                            rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
                            goto NextLine;
                        }
                        pLogonHour->Start = SCE_NO_VALUE;
                        pLogonHour->End = SCE_NO_VALUE;
                        pLogonHour->Next = (*pOneProfile)->pLogonHours;
                        (*pOneProfile)->pLogonHours = pLogonHour;

                        rc = SCESTATUS_SUCCESS;
                        goto NextLine;
                    }
                    for ( i=0; i<cFields; i+=2) {

                        if ( SetupGetIntField( &InfLine, i+1, (INT *)&Keyvalue ) &&
                             SetupGetIntField( &InfLine, i+2, (INT *)&Keyvalue2 ) ) {
                            //
                            // find a pair of logon hours.
                            //
                            pLogonHour = (PSCE_LOGON_HOUR)ScepAlloc( LMEM_ZEROINIT,
                                                                    sizeof(SCE_LOGON_HOUR) );
                            if ( pLogonHour == NULL ) {
                                rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
                                goto NextLine;
                            }
                            pLogonHour->Start = Keyvalue;
                            pLogonHour->End = Keyvalue2;
                            pLogonHour->Next = (*pOneProfile)->pLogonHours;

                            (*pOneProfile)->pLogonHours = pLogonHour;
                            rc = SCESTATUS_SUCCESS;

                        } else
                            rc = SCESTATUS_INVALID_DATA;
                    }
                    goto NextLine;
                }

                if ( _wcsicmp(Keyname, TEXT("Workstations")) == 0 ) {

                    if( SetupGetMultiSzField(&InfLine,1,NULL,0,&DataSize) ) {

                        Strvalue = (PWSTR)ScepAlloc( LMEM_ZEROINIT,
                                                     (DataSize+1)*sizeof(WCHAR));

                        if( Strvalue == NULL ) {
                            rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
                        } else {
                            if(SetupGetMultiSzField(&InfLine,1,Strvalue,DataSize,NULL)) {
                                 (*pOneProfile)->pWorkstations.Length = (USHORT)(DataSize*sizeof(WCHAR));
                                 (*pOneProfile)->pWorkstations.Buffer = Strvalue;
                                 Strvalue = NULL;
                                 rc = SCESTATUS_SUCCESS;
                            } else {
                                 rc = SCESTATUS_INVALID_DATA;
                                 ScepFree(Strvalue);
                            }
                        }
                    }
                    goto NextLine;
                }

                i1 = i2 = 0;

                if ( (i1=_wcsicmp(Keyname, TEXT("GroupsBelongsTo"))) == 0 ||
                     (i2=_wcsicmp(Keyname, TEXT("AssignToUsers"))) == 0 ) {

                    //
                    // String fields. Each string respresents a workstation name,
                    // a group name, or a user name. These names are saved in PSCE_NAME_LIST
                    //

                    cFields = SetupGetFieldCount( &InfLine );

                    for ( i=0; i<cFields; i++) {

                        if( SetupGetStringField(&InfLine,i+1,NULL,0,&DataSize) && DataSize > 0 ) {

                            if ( DataSize <= 1) {
                                rc = SCESTATUS_SUCCESS;
                                continue;
                            }

                            Strvalue = (PWSTR)ScepAlloc( LMEM_ZEROINIT,
                                                         (DataSize+1)*sizeof(WCHAR));

                            if( Strvalue == NULL ) {
                                rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
                            } else {
                                if(SetupGetStringField(&InfLine,i+1,Strvalue,DataSize,NULL)) {
                                    //
                                    // Save information in a name list
                                    //
                                    if ( i1 == 0) {
                                        rc = ScepAddToNameList(&((*pOneProfile)->pGroupsBelongsTo),
                                                         Strvalue,
                                                         DataSize+1
                                                        );
                                    } else {
                                        rc = ScepAddToNameList(&((*pOneProfile)->pAssignToUsers),
                                                         Strvalue,
                                                         DataSize+1
                                                        );
                                    }
                                    if ( rc != NO_ERROR )
                                        rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
                                }
                                ScepFree( Strvalue );
                            }
                        }
                        if ( rc != SCESTATUS_SUCCESS)
                            break; // for loop
                    }
                    goto NextLine;
                }

                i1 = i2 = 0;

                if ( (i1=_wcsicmp(Keyname, TEXT("HomeDirSecurity"))) == 0 ||
                     (i2=_wcsicmp(Keyname, TEXT("TempDirSecurity"))) == 0 ) {

//                    if(SetupGetStringField(&InfLine,1,NULL,0,&DataSize) && DataSize > 0 ) {
                    if(SetupGetMultiSzField(&InfLine,1,NULL,0,&DataSize) && DataSize > 0 ) {

                        Strvalue = (PWSTR)ScepAlloc( 0, (DataSize+1)*sizeof(WCHAR));
                        if ( Strvalue == NULL )
                            rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
                        else {
//                            if(SetupGetStringField(&InfLine,1,Strvalue,DataSize,NULL)) {
                            if(SetupGetMultiSzField(&InfLine,1,Strvalue,DataSize,NULL)) {
                                //
                                // convert multi-sz to space
                                //
                                if ( SetupGetFieldCount( &InfLine ) > 1 ) {
                                    ScepConvertMultiSzToDelim(Strvalue, DataSize, L'\0', L' ');
                                }
                                //
                                // Convert the text to real security descriptors
                                //
                                rc = ConvertTextSecurityDescriptor(
                                                   Strvalue,
                                                   &pTempSD,
                                                   &Keyvalue2,
                                                   &SeInfo
                                                   );

                                if (rc == NO_ERROR) {

                                    ScepChangeAclRevision(pTempSD, ACL_REVISION);

                                    if ( i1 == 0 ) {
                                        (*pOneProfile)->pHomeDirSecurity = pTempSD;
                                        (*pOneProfile)->HomeSeInfo = SeInfo;
                                    } else {
                                        (*pOneProfile)->pTempDirSecurity = pTempSD;
                                        (*pOneProfile)->TempSeInfo = SeInfo;
                                    }
                                    pTempSD = NULL;
                                } else {
                                    ScepBuildErrorLogInfo(
                                            rc,
                                            Errlog,
                                            SCEERR_BUILD_SD,
                                            Keyname  //Strvalue
                                            );
                                    rc = ScepDosErrorToSceStatus(rc);
                                }

                            } else
                                rc = SCESTATUS_INVALID_DATA;

                            ScepFree(Strvalue);
                        }
                    }
                    goto NextLine;
                }

                //
                // no string matched. ignore
                //

                ScepBuildErrorLogInfo(
                          NO_ERROR,
                          Errlog,
                          SCEERR_NOT_EXPECTED,
                          Keyname, SectionName);
                rc = SCESTATUS_SUCCESS;

            }
NextLine:
            if ( rc != SCESTATUS_SUCCESS ) {

                ScepBuildErrorLogInfo( ScepSceStatusToDosError(rc),
                                     Errlog,
                                     SCEERR_QUERY_INFO,
                                     SectionName
                                   );
                goto Done;
            }

        } while(SetupFindNextLine(&InfLine,&InfLine));
    }

Done:

// free memory

    if ( SectionName != NULL )
        ScepFree(SectionName);

    if ( pTempSD != NULL )
        ScepFree( pTempSD );

    if ( rc != SCESTATUS_SUCCESS ) {
        // free pOneProfile memory
        SceFreeMemory( *pOneProfile, 0 );
        *pOneProfile = NULL;
    }

    return(rc);

}

SCESTATUS
SceInfpGetDescription(
    IN HINF hInf,
    OUT PWSTR *Description
    )
{
    INFCONTEXT    InfLine;
    SCESTATUS      rc=SCESTATUS_SUCCESS;
    DWORD         LineLen, Len;
    DWORD         TotalLen=0;
    DWORD         i, cFields;

    if(SetupFindFirstLine(hInf,szDescription,NULL,&InfLine)) {

        do {

            cFields = SetupGetFieldCount( &InfLine );

            for ( i=0; i<cFields && rc==SCESTATUS_SUCCESS; i++) {
                //
                // count the total length of the description.
                //
                if ( !SetupGetStringField(&InfLine, i+1, NULL, 0, &LineLen) ) {
                    rc = SCESTATUS_BAD_FORMAT;
                }
                TotalLen += LineLen+1;
                LineLen = 0;
            }
            if ( rc != SCESTATUS_SUCCESS )
                break;
        } while ( SetupFindNextLine(&InfLine,&InfLine) );

        if ( rc == SCESTATUS_SUCCESS && TotalLen > 0 ) {
            //
            // allocate memory for the return buffer
            //
            *Description = (PWSTR)ScepAlloc( LMEM_ZEROINIT, (TotalLen+1)*sizeof(WCHAR));
            if ( *Description == NULL )
                return( SCESTATUS_NOT_ENOUGH_RESOURCE );

            // re-position to the first line
            SetupFindFirstLine(hInf,szDescription,NULL,&InfLine);

            Len = 0;
            LineLen = 0;

            do {
                //
                // read each line in the section and append to the end of the buffer
                // note: the required size returned from SetupGetStringField already
                // has one more character space.
                //
                cFields = SetupGetFieldCount( &InfLine );

                for ( i=0; i<cFields && rc==SCESTATUS_SUCCESS; i++) {
                    if ( !SetupGetStringField(&InfLine, i+1,
                                 *Description+Len, TotalLen-Len, &LineLen) ) {
                        rc = SCESTATUS_INVALID_DATA;
                    }
                    if ( i == cFields-1)
                        *(*Description+Len+LineLen-1) = L' ';
                    else
                        *(*Description+Len+LineLen-1) = L',';
                    Len += LineLen;
                }

                if ( rc != SCESTATUS_SUCCESS )
                    break;
            } while ( SetupFindNextLine(&InfLine,&InfLine) );

        }
        if ( rc != SCESTATUS_SUCCESS ) {
            // if error occurs, free memory
            ScepFree(*Description);
            *Description = NULL;
        }

    } else {
        rc = SCESTATUS_RECORD_NOT_FOUND;
    }

    return(rc);
}


SCESTATUS
SceInfpGetSystemServices(
    IN HINF hInf,
    IN DWORD ObjectFlag,
    OUT PSCE_SERVICES *pServiceList,
    OUT PSCE_ERROR_LOG_INFO *Errlog OPTIONAL
    )
/*
Routine Description:

    Get the list of services with startup status and security descriptors
    in the inf file

Arguments:

Return Value:

*/
{
    INFCONTEXT    InfLine;
    SCESTATUS      rc=SCESTATUS_SUCCESS;
    PWSTR         Keyname=NULL;
    DWORD         KeyLen;
    DWORD         Status;

    DWORD         DataSize;
    PWSTR         Strvalue=NULL;
    SECURITY_INFORMATION SeInfo;
    PSECURITY_DESCRIPTOR pSecurityDescriptor=NULL;
    DWORD         cFields=0;

    if ( pServiceList == NULL )
        return(SCESTATUS_INVALID_PARAMETER);

    //
    // Locate the [Service General Setting] section.
    //

    if ( SetupFindFirstLine(hInf,szServiceGeneral,NULL,&InfLine) ) {

        TCHAR         tmpBuf[MAX_PATH];
        do {
            //
            // Get service names.
            //
            rc = SCESTATUS_BAD_FORMAT;

            cFields = SetupGetFieldCount( &InfLine );

            if ( cFields < 3 ) {

                tmpBuf[0] = L'\0';
                SetupGetStringField(&InfLine,1,tmpBuf,MAX_PATH,NULL);

                ScepBuildErrorLogInfo( ERROR_INVALID_DATA,
                                     Errlog,
                                     SCEERR_OBJECT_FIELDS,
                                     tmpBuf);

                if ( ObjectFlag & SCEINF_OBJECT_FLAG_UNKNOWN_VERSION ) {
                    //
                    // a newer version of template, ignore this line
                    //
                    rc = SCESTATUS_SUCCESS;
                    goto NextLine;
                } else {
                    //
                    // bad format, quit
                    //
                    break;
                }

            }

            if ( SetupGetStringField(&InfLine, 1, NULL, 0, &KeyLen) ) {

                Keyname = (PWSTR)ScepAlloc( 0, (KeyLen+1)*sizeof(WCHAR));
                if ( Keyname != NULL ) {
                    Keyname[KeyLen] = L'\0';

                    if ( SetupGetStringField(&InfLine, 1, Keyname, KeyLen, NULL) ) {
                        //
                        // Get value (startup status, security descriptor SDDL)
                        //
                        if ( SetupGetIntField(&InfLine, 2, (INT *)&Status) &&
//                             SetupGetStringField(&InfLine,3,NULL,0,&DataSize) && DataSize > 0 ) {
                            SetupGetMultiSzField(&InfLine,3,NULL,0,&DataSize) && DataSize > 0 ) {

                            Strvalue = (PWSTR)ScepAlloc( LMEM_ZEROINIT,
                                                         (DataSize+1)*sizeof(WCHAR) );

                            if( Strvalue != NULL ) {
//                                if(SetupGetStringField(&InfLine,3,Strvalue,DataSize,NULL)) {
                                if(SetupGetMultiSzField(&InfLine,3,Strvalue,DataSize,NULL)) {
                                    //
                                    // convert multi-sz to space
                                    //
                                    if ( cFields > 3 ) {
                                        ScepConvertMultiSzToDelim(Strvalue, DataSize, L'\0', L' ');
                                    }

                                    if ( ObjectFlag & SCEINF_OBJECT_FLAG_OLDSDDL ) {

                                        ScepConvertToSDDLFormat(Strvalue, DataSize);
                                    }

                                    //
                                    // Convert to security descriptor
                                    //
                                    rc = ConvertTextSecurityDescriptor(
                                                       Strvalue,
                                                       &pSecurityDescriptor,
                                                       &DataSize,
                                                       &SeInfo
                                                       );
                                    if ( rc == SCESTATUS_SUCCESS ) {

                                        ScepChangeAclRevision(pSecurityDescriptor, ACL_REVISION);

                                        //
                                        // add to the service list
                                        //
                                        rc = ScepAddOneServiceToList(
                                                    Keyname,
                                                    NULL,
                                                    Status,
                                                    (PVOID)pSecurityDescriptor,
                                                    SeInfo,
                                                    TRUE,
                                                    pServiceList
                                                    );
                                        if ( rc != ERROR_SUCCESS) {
                                            LocalFree(pSecurityDescriptor);
                                            rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
                                        }
                                    }
                                }

                                ScepFree( Strvalue );
                                Strvalue = NULL;
                            } else
                                rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
                        }
                    }
                    //
                    // Free Keyname
                    //
                    ScepFree(Keyname);
                    Keyname = NULL;
                } else
                    rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
            }

            if ( rc != SCESTATUS_SUCCESS ) {

                ScepBuildErrorLogInfo( ERROR_BAD_FORMAT,
                                  Errlog,
                                  SCEERR_QUERY_INFO,
                                  szServiceGeneral
                                  );
                break;
            }
NextLine:
            ;

        } while(SetupFindNextLine(&InfLine,&InfLine));
    }

    if ( rc != SCESTATUS_SUCCESS ) {
        //
        // free the service list
        //
        SceFreePSCE_SERVICES(*pServiceList);
        *pServiceList = NULL;

    }

    return(rc);

}


SCESTATUS
SceInfpGetKerberosPolicy(
    IN HINF  hInf,
    IN DWORD ObjectFlag,
    OUT PSCE_KERBEROS_TICKET_INFO * ppKerberosInfo,
    OUT PSCE_ERROR_LOG_INFO *Errlog OPTIONAL
    )
/*++
Routine Description:

   This routine retrieves kerberos policy information from the SCP INF
   file and stores in the output buffer ppKerberosInfo.

Arguments:

   hInf     -  INF handle to the profile

   ppKerberosInfo  - the output buffer to hold kerberos info.

   Errlog     -     A buffer to hold all error codes/text encountered when
                    parsing the INF file. If Errlog is NULL, no further error
                    information is returned except the return DWORD

Return value:

   SCESTATUS -  SCESTATUS_SUCCESS
               SCESTATUS_NOT_ENOUGH_RESOURCE
               SCESTATUS_INVALID_PARAMETER
               SCESTATUS_BAD_FORMAT
               SCESTATUS_INVALID_DATA

--*/

{
    INFCONTEXT    InfLine;
    SCESTATUS      rc=SCESTATUS_SUCCESS;

    SCE_KEY_LOOKUP AccessSCPLookup[] = {
        {(PWSTR)TEXT("MaxTicketAge"),     offsetof(struct _SCE_KERBEROS_TICKET_INFO_, MaxTicketAge),  'D'},
        {(PWSTR)TEXT("MaxRenewAge"),      offsetof(struct _SCE_KERBEROS_TICKET_INFO_, MaxRenewAge),   'D'},
        {(PWSTR)TEXT("MaxServiceAge"),  offsetof(struct _SCE_KERBEROS_TICKET_INFO_, MaxServiceAge),     'D'},
        {(PWSTR)TEXT("MaxClockSkew"),    offsetof(struct _SCE_KERBEROS_TICKET_INFO_, MaxClockSkew), 'D'},
        {(PWSTR)TEXT("TicketValidateClient"),     offsetof(struct _SCE_KERBEROS_TICKET_INFO_, TicketValidateClient),  'D'}
        };

    DWORD       cAccess = sizeof(AccessSCPLookup) / sizeof(SCE_KEY_LOOKUP);

    //
    // check arguments
    //
    if ( !hInf || !ppKerberosInfo ) {
       return (SCESTATUS_INVALID_PARAMETER);
    }

    BOOL bAllocated = FALSE;
    //
    // Locate the [Kerberos Policy] section.
    //
    if(SetupFindFirstLine(hInf,szKerberosPolicy,NULL,&InfLine)) {

       //
       // allocate the output buffer if it is NULL
       //
       if ( NULL == *ppKerberosInfo ) {

          *ppKerberosInfo = (PSCE_KERBEROS_TICKET_INFO)ScepAlloc(0, sizeof(SCE_KERBEROS_TICKET_INFO));

          if ( NULL == *ppKerberosInfo ) {
             return (SCESTATUS_NOT_ENOUGH_RESOURCE);
          }
          bAllocated = TRUE;
       }
       //
       // Initialize to SCE_NO_VALUE
       //
       for ( DWORD i=0; i<cAccess; i++) {
           if ( AccessSCPLookup[i].BufferType == 'D' ) {
               *((DWORD *)((CHAR *)(*ppKerberosInfo)+AccessSCPLookup[i].Offset)) = SCE_NO_VALUE;
           }
       }

       UINT        Offset;
       WCHAR       Keyname[SCE_KEY_MAX_LENGTH];
       int       Keyvalue=0;

        do {

            //
            // Get key names and its setting.
            //

            rc = SCESTATUS_SUCCESS;
            memset(Keyname, '\0', SCE_KEY_MAX_LENGTH*sizeof(WCHAR));

            if ( SetupGetStringField(&InfLine, 0, Keyname, SCE_KEY_MAX_LENGTH, NULL) ) {

                for ( i=0; i<cAccess; i++) {

                    //
                    // get settings in AccessLookup table
                    //
                    Offset = AccessSCPLookup[i].Offset;

                    if (_wcsicmp(Keyname, AccessSCPLookup[i].KeyString ) == 0) {

                        switch ( AccessSCPLookup[i].BufferType ) {
                        case 'D':

                            //
                            // Int Field
                            //

                            if (SetupGetIntField(&InfLine, 1, (INT *)&Keyvalue ) ) {
                                *((DWORD *)((CHAR *)(*ppKerberosInfo)+Offset)) = (DWORD)Keyvalue;
                            } else {
                               rc = SCESTATUS_INVALID_DATA;
                            }

                            break;
                        default:
                            //
                            // should not occur
                            //
                            break;
                        }

                        break; // for loop

                    }
                }

                if ( i >= cAccess &&
                     !(ObjectFlag & SCEINF_OBJECT_FLAG_UNKNOWN_VERSION) ) {

                    //
                    // Did not find a match in the lookup table
                    //

                   ScepBuildErrorLogInfo( NO_ERROR,
                                        Errlog,
                                        SCEERR_NOT_EXPECTED,
                                        Keyname,szKerberosPolicy );

                }
                if ( rc != SCESTATUS_SUCCESS ) {
                    ScepBuildErrorLogInfo( ScepSceStatusToDosError(rc),
                                         Errlog,
                                         SCEERR_QUERY_INFO,
                                         Keyname );
                }

            } else {
                rc = SCESTATUS_BAD_FORMAT;
                ScepBuildErrorLogInfo( ERROR_BAD_FORMAT, Errlog,
                                      SCEERR_QUERY_INFO,
                                      szKerberosPolicy);
            }

            //
            // if error happens, get out
            //
            if ( rc != SCESTATUS_SUCCESS ) {
               break;
            }

        } while(SetupFindNextLine(&InfLine,&InfLine));

    }

    if ( SCESTATUS_SUCCESS != rc && bAllocated && *ppKerberosInfo ) {
       //
       // free allocated memory if error occurs
       //
       ScepFree(*ppKerberosInfo);
       *ppKerberosInfo = NULL;
    }

    return(rc);
}


SCESTATUS
SceInfpGetRegistryValues(
    IN HINF  hInf,
    IN DWORD ObjectFlag,
    OUT PSCE_REGISTRY_VALUE_INFO * ppRegValues,
    OUT LPDWORD pValueCount,
    OUT PSCE_ERROR_LOG_INFO *Errlog OPTIONAL
    )
/*++
Routine Description:

   This routine retrieves kerberos policy information from the SCP INF
   file and stores in the output buffer ppKerberosInfo.

Arguments:

   hInf     -  INF handle to the profile

   ppRegValues - the output array to hold registry values.

   pValueCount - the buffer to hold number of registry values in the array

   Errlog     -     A buffer to hold all error codes/text encountered when
                    parsing the INF file. If Errlog is NULL, no further error
                    information is returned except the return DWORD

Return value:

   SCESTATUS -  SCESTATUS_SUCCESS
               SCESTATUS_NOT_ENOUGH_RESOURCE
               SCESTATUS_INVALID_PARAMETER
               SCESTATUS_BAD_FORMAT
               SCESTATUS_INVALID_DATA

--*/

{
    INFCONTEXT InfLine;
    SCESTATUS   rc=SCESTATUS_SUCCESS;
    LONG       i;
    LONG       nLines;

    //
    // check arguments
    //
    if ( !hInf || !ppRegValues || !pValueCount ) {
       return (SCESTATUS_INVALID_PARAMETER);
    }

    //
    // count how many objects
    //
    nLines = SetupGetLineCount(hInf, szRegistryValues );
    if ( nLines == -1 ) {
        //
        // section not found
        //
        return(SCESTATUS_SUCCESS);
    }

    *pValueCount = nLines;
    *ppRegValues = NULL;

    if ( nLines == 0 ) {
        //
        // no value is to be secured
        //
        return(SCESTATUS_SUCCESS);
    }
    //
    // allocate memory for all objects
    //
    *ppRegValues = (PSCE_REGISTRY_VALUE_INFO)ScepAlloc( LMEM_ZEROINIT,
                                             nLines*sizeof(SCE_REGISTRY_VALUE_INFO) );
    if ( *ppRegValues == NULL ) {
        return(SCESTATUS_NOT_ENOUGH_RESOURCE);
    }

    //
    // Locate the section.
    //
    if ( SetupFindFirstLine(hInf,szRegistryValues,NULL,&InfLine) ) {
        i = 0;

        do {
            //
            // Get string key and a int value.
            //
            if ( i >= nLines ) {
                //
                // more lines than allocated
                //
                rc = SCESTATUS_INVALID_DATA;
                ScepBuildErrorLogInfo(ERROR_INVALID_DATA,
                                     Errlog,
                                     SCEERR_MORE_OBJECTS,
                                     nLines
                                     );
                break;
            }
            rc = SceInfpGetOneRegistryValue(
                                       &InfLine,
                                       ObjectFlag,
                                       &((*ppRegValues)[i]),
                                       Errlog
                                      );
            if ( SCESTATUS_SUCCESS == rc ) {
                i++;
            } else if ( ERROR_PRODUCT_VERSION == rc ) {
                //
                // a newer version, should ignore this line
                //
                rc = SCESTATUS_SUCCESS;
            } else {
                break; // do..while loop
            }

        } while(SetupFindNextLine(&InfLine,&InfLine));

    }

    if ( rc != SCESTATUS_SUCCESS ) {
        //
        // free memory
        //
        ScepFreeRegistryValues( ppRegValues, *pValueCount );
        *ppRegValues = NULL;

    } else {

        *pValueCount = i;
    }

    return(rc);

}


SCESTATUS
SceInfpGetOneRegistryValue(
    IN PINFCONTEXT pInfLine,
    IN DWORD ObjectFlag,
    OUT PSCE_REGISTRY_VALUE_INFO pValues,
    OUT PSCE_ERROR_LOG_INFO *Errlog OPTIONAL
    )
/* ++
Routine Description:

   This routine retrieves one registry value from the INF file (SCP type).
   Each registry value in these sections is represented by one line.

Arguments:

   pInfLine  - Current line context from the INF file for one object

   pValues- Output buffer to hold the regitry value name and value

   Errlog    - The cummulative error list for errors encountered in this routine

Return value:

   SCESTATUS - SCESTATUS_SUCCESS
              SCESTATUS_NOT_ENOUGH_RESOURCE
              SCESTATUS_INVALID_PARAMETER
              SCESTATUS_BAD_FORMAT
              SCESTATUS_INVALID_DATA
-- */
{
    DWORD         KeySize;
    PWSTR         Keyvalue=NULL;
    SCESTATUS     rc=SCESTATUS_SUCCESS;
    INT           dType;
    PWSTR         pValueStr=NULL;
    DWORD         nLen;


    if ( !pInfLine || !pValues )
        return(SCESTATUS_INVALID_PARAMETER);

    nLen = SetupGetFieldCount( pInfLine );

    if ( nLen < 2 ) {

        TCHAR tmpBuf[MAX_PATH];

        tmpBuf[0] = L'\0';
        SetupGetStringField(pInfLine,0,tmpBuf,MAX_PATH,NULL);

        ScepBuildErrorLogInfo( ERROR_INVALID_DATA,
                             Errlog,
                             SCEERR_REGVALUE_FIELDS,
                             tmpBuf);

        //
        // if it's a newer version template, should ignore this line
        //
        if ( ObjectFlag & SCEINF_OBJECT_FLAG_UNKNOWN_VERSION )
            return(ERROR_PRODUCT_VERSION);
        else
            return(SCESTATUS_INVALID_DATA);
    }

    //
    // get the key field (string)
    //
    if(SetupGetStringField(pInfLine,0,NULL,0,&KeySize) && KeySize > 0 ) {

        Keyvalue = (PWSTR)ScepAlloc( LMEM_ZEROINIT,
                                     (KeySize+1)*sizeof(WCHAR) );
        if( Keyvalue == NULL ) {
            return(SCESTATUS_NOT_ENOUGH_RESOURCE);
        } else {
            //
            // get key
            //
            if( SetupGetStringField(pInfLine,0,Keyvalue,KeySize,NULL) ) {
                //
                // get the data type, if error, assume REG_DWORD type
                //
                if ( !SetupGetIntField( pInfLine, 1, (INT *)&dType ) ) {
                    dType = REG_DWORD;
                }

                if ( SetupGetMultiSzField(pInfLine,2,NULL,0,&nLen) ) {

                    pValueStr = (PWSTR)ScepAlloc( LMEM_ZEROINIT,
                                               (nLen+1)*sizeof(WCHAR)
                                              );
                    if( pValueStr == NULL ) {
                        rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
                    } else if ( !SetupGetMultiSzField(pInfLine,2,pValueStr,nLen,NULL) ) {
                        rc = SCESTATUS_BAD_FORMAT;
                    } else {

                        if ( dType == REG_MULTI_SZ && 
                             (0 == _wcsicmp( Keyvalue, szLegalNoticeTextKeyName))) {
                            
                            //
                            // check for commas and escape them with "," so the UI etc. 
                            // understands this, since, here, for lines such as 
                            // k=7,a",",b,c
                            // pValueStr will be a,\0b\0c\0\0 which we should make
                            // a","\0b\0c\0\0
                            //

                            DWORD dwCommaCount = 0;

                            for ( DWORD dwIndex = 0; dwIndex < nLen; dwIndex++) {
                                if ( pValueStr[dwIndex] == L',' )
                                    dwCommaCount++;
                            }
                            
                            if ( dwCommaCount > 0 ) {
                                
                                PWSTR pValueStrEscaped;
                                DWORD dwNumBytes;

                                dwNumBytes = (nLen + 1 + dwCommaCount * 2) * sizeof(WCHAR);

                                pValueStrEscaped = (PWSTR)ScepAlloc(LMEM_ZEROINIT, dwNumBytes);
                                
                                if (pValueStrEscaped) {
                                
                                    memset(pValueStrEscaped, '\0', dwNumBytes); 

                                    nLen = ScepEscapeString(pValueStr,
                                                            nLen+1,
                                                            L',',
                                                            L'"',
                                                            pValueStrEscaped
                                                           );

                                    ScepFree(pValueStr);

                                    pValueStr = pValueStrEscaped;
                                }
                                
                                else {
                                    
                                    rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
                                
                                }
                            }
                        }

                        if ( SCESTATUS_SUCCESS == rc)
                        
                            rc = ScepConvertMultiSzToDelim(pValueStr, nLen, L'\0', L',');

                        if ( SCESTATUS_SUCCESS == rc) {

                            //
                            // assign them to the output buffer
                            //
                            pValues->FullValueName = Keyvalue;
                            Keyvalue = NULL;
                            pValues->ValueType = (DWORD)dType;

                            pValues->Value = pValueStr;
                            pValueStr = NULL;

                        }
                    }
                } else {
                    rc = SCESTATUS_BAD_FORMAT;
                }

            } else
                rc = SCESTATUS_BAD_FORMAT;
        }
    } else
        rc = SCESTATUS_BAD_FORMAT;

    if ( rc == SCESTATUS_BAD_FORMAT ) {

        ScepBuildErrorLogInfo( ERROR_BAD_FORMAT,
                             Errlog,
                             SCEERR_QUERY_INFO,
                             szRegistryValues);
    }

    if ( Keyvalue != NULL )
        ScepFree( Keyvalue );

    if ( pValueStr != NULL ) {
        ScepFree(pValueStr);
    }

    return(rc);
}



SCESTATUS
WINAPI
SceSvcGetInformationTemplate(
    IN PCWSTR TemplateName,
    IN PCWSTR ServiceName,
    IN PCWSTR Key OPTIONAL,
    OUT PSCESVC_CONFIGURATION_INFO *ServiceInfo
    )
/*
Routine Description:

    Read information from the service's section in the template (inf format) into
    the ServiceInfo buffer. If Key is specified, only one key's information is read.

Arguments:

    Template    - The template's name (inf format)

    ServiceName - The service's name as used in service control manager, is also the
                  section name used in the template

    Key - if specified, it is the key information to match in the template;
          if it is NULL, all information from the section is read

    ServiceInfo - output buffer of a array of Key/Value pairs

Return Value:


*/
{
    HINF hInf;
    SCESTATUS rc;

    if ( TemplateName == NULL || ServiceName == NULL || ServiceInfo == NULL ) {

        return(SCESTATUS_INVALID_PARAMETER);

    }

    //
    // open the template
    //

    rc = SceInfpOpenProfile(
                TemplateName,
                &hInf
                );

    if ( rc != SCESTATUS_SUCCESS )
        return(rc);

    //
    // call private API to read information.
    //

    rc = SceSvcpGetInformationTemplate(hInf,
                                      ServiceName,
                                      Key,
                                      ServiceInfo );

    //
    // close the template
    //

    SceInfpCloseProfile(hInf);

    return(rc);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\scerpc\client\polclnt.cpp ===
//depot/private/vishnup_branch/DS/security/services/scerpc/client/polclnt.cpp#3 - edit change 767 (text)
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    polclnt.cpp

Abstract:

    SCE policy integration Client APIs

Author:

    Jin Huang (jinhuang) 23-Jun-1997 created

Revision History:

    jinhuang        23-Jan-1998   split to client-server model

--*/

#include "headers.h"
#include "sceutil.h"
#include "clntutil.h"
#include "infp.h"
#include <io.h>
#include <userenv.h>
//#include <shlwapi.h>
//#include "userenvp.h"
#include "scedllrc.h"
#include "dsrole.h"
#include "commonrc.h"
#include "precedence.h"
#include "cgenericlogger.h"



#pragma hdrstop

#include <wincrypt.h>
#include <ntlsa.h>
#include <lmaccess.h>

CRITICAL_SECTION DiagnosisPolicypropSync;
static HANDLE ghAsyncThread = NULL;
extern HINSTANCE MyModuleHandle;
BOOL    gbAsyncWinlogonThread;

//
// global into which the RSOP namespace ptr is stashed
// for use when server calls back - diagnosis mode only
//

IWbemServices *tg_pWbemServices = NULL;
//
// global into which the RSOP synch status is stashed
// for use when server calls back - diagnosis mode only
//

HRESULT gHrSynchRsopStatus;

//
// global into which the RSOP asynch status is stashed
// for use when asynch thread done - diagnosis mode only
//

HRESULT gHrAsynchRsopStatus;


typedef DWORD (WINAPI *PFGETDOMAININFO)(LPCWSTR, DSROLE_PRIMARY_DOMAIN_INFO_LEVEL, PBYTE *);
typedef VOID (WINAPI *PFDSFREE)( PVOID );
//
// no need to critical section these variables because propagation always call to
// this dll in sequence.
//
BOOL gbThisIsDC = FALSE;
BOOL gbDCQueried = FALSE;
PWSTR   gpwszDCDomainName = NULL;

GUID SceExtGuid = { 0x827D319E, 0x6EAC, 0x11D2, { 0xA4, 0xEA, 0x0, 0xC0, 0x4F, 0x79, 0xF8, 0x3A } };

typedef enum _SCE_ATTACHMENT_TYPE_ {

   SCE_ATTACHMENT_SERVICE,
   SCE_ATTACHMENT_POLICY

} SCE_ATTACHMENT_TYPE;

typedef struct {
   ASYNCCOMPLETIONHANDLE pHandle;
   LPWSTR szTemplateName;
   LPWSTR szLogName;
   AREA_INFORMATION Area;
   DWORD dwDiagOptions;
   LPSTREAM pStream;
} ENGINEARGS;

static HMODULE hSceDll=NULL;

//
// private functions
//
DWORD
ScepPolStatusCallback(
    IN PFNSTATUSMESSAGECALLBACK pStatusCallback OPTIONAL,
    IN BOOL bVerbose,
    IN INT nId
    );

BOOL
ScepShouldTerminateProcessing(
    IN BOOL *pbAbort,
    IN BOOL bCheckDcpromo
    );

BOOL
ScepClearGPObjects(
    IN BOOL bPlanning
    );

DWORD
ScepControlNotificationQProcess(
    IN PWSTR szLogFileName,
    IN BOOL bThisIsDC,
    IN DWORD ControlFlag
    );

/*
BOOL
ScepCheckDemote();
*/

DWORD
SceProcessBeforeRSOPLogging(
    IN BOOL bPlanningMode,
    IN DWORD dwFlags,
    IN HANDLE hUserToken,
    IN HKEY hKeyRoot,
    IN PGROUP_POLICY_OBJECT pDeletedGPOList OPTIONAL,
    IN PGROUP_POLICY_OBJECT pChangedGPOList,
    IN ASYNCCOMPLETIONHANDLE pHandle OPTIONAL,
    IN BOOL *pbAbort,
    IN PFNSTATUSMESSAGECALLBACK pStatusCallback OPTIONAL,
    OUT AREA_INFORMATION    *pAllAreas OPTIONAL,
    OUT BOOL    *pb OPTIONAL,
    OUT PWSTR   *pszLogFileName OPTIONAL,
    OUT DWORD   *pdwWinlogonLog OPTIONAL
);

DWORD
SceProcessAfterRSOPLogging(
    IN DWORD dwFlags,
    IN ASYNCCOMPLETIONHANDLE pHandle,
    IN BOOL *pbAbort,
    IN PFNSTATUSMESSAGECALLBACK pStatusCallback,
    IN AREA_INFORMATION ThisAreas,
    IN BOOL b,
    IN PWSTR *ppszLogFileName,
    IN DWORD dwWinlogonLog,
    IN DWORD dwDiagOptions
);

DWORD
ScepProcessSecurityPolicyInOneGPO(
    IN BOOL bPlanningMode,
    IN DWORD dwFlags,
    IN PGROUP_POLICY_OBJECT pGpoInfo,
    IN LPTSTR szLogFileName OPTIONAL,
    IN OUT AREA_INFORMATION *pTotalArea
    );

AREA_INFORMATION
ScepGetAvailableArea(
    IN BOOL bPlanningMode,
    IN LPCTSTR SysPathRoot,
    IN LPCTSTR DSPath,
    IN LPTSTR InfName,
    IN GPO_LINK LinkInfo,
    IN BOOL bIsDC
    );

DWORD
ScepLogLastConfigTime();

DWORD
ScepWinlogonThreadFunc(LPVOID lpv);

DWORD
ScepEnumerateAttachments(
    OUT PSCE_NAME_LIST *pEngineList,
    IN SCE_ATTACHMENT_TYPE aType
    );

DWORD
ScepConfigureEFSPolicy(
    IN PUCHAR pEfsBlob,
    IN DWORD dwSize,
    IN DWORD dwDebugLevel
    );

DWORD
ScepWaitConfigSystem(
    IN LPTSTR SystemName OPTIONAL,
    IN PWSTR InfFileName OPTIONAL,
    IN PWSTR DatabaseName OPTIONAL,
    IN PWSTR LogFileName OPTIONAL,
    IN DWORD ConfigOptions,
    IN AREA_INFORMATION Area,
    IN PSCE_AREA_CALLBACK_ROUTINE pCallback OPTIONAL,
    IN HANDLE hCallbackWnd OPTIONAL,
    OUT PDWORD pdWarning OPTIONAL
    );

//
// the new interface - client side extension for RSOP Planning mode
//
DWORD
WINAPI
SceGenerateGroupPolicy(
    IN DWORD dwFlags,
    IN BOOL *pAbort,
    IN WCHAR *pwszSite,
    IN PRSOP_TARGET pComputerTarget,
    IN PRSOP_TARGET pUserTarget
    )
/*
Description:
    This is the new interface called from winlogon/userenv to generate planning
    RSOP data. The dll name and procedure name are registered to winlogon under
    GpExtensions.

    This routine simulates a SCE group policy template to the current system.
    The template can be in domain level, OU level, or user level.

    The input argument contains info about the GPOs to be simulated and a namespace
    pointer to log the RSOP data.

    This interface shouldn't be called for user policy.

Arguments:

    dwFlags     - the GPO Info flags
                        GPO_INFO_FLAG_MACHINE
                        GPO_INFO_FLAG_SLOWLINK
                        GPO_INFO_FLAG_BACKGROUND
                        GPO_INFO_FLAG_VERBOSE
                        GPO_INFO_FLAG_NOCHANGES

    pwszSite        - unused now

    pComputerTarget - RSOP machine structure having GPOList, token (unused now) etc.

    pUserTarget - RSOP user structure having GPOList, token (unused now) etc.

    pbAbort     - processing of GPO should be aborted if this is set to TRUE
                    (in case of system shutdown or user log off)

*/

{
    DWORD   rcGPOCreate = ERROR_SUCCESS;
    DWORD   rcLogging = ERROR_SUCCESS;
    PWSTR   szLogFileName = NULL;

    //
    // put a try except block in case arguments are invalid or wbem logging fails
    //

    __try {

        if (pComputerTarget == NULL || pComputerTarget->pWbemServices == NULL)
            return ERROR_INVALID_PARAMETER;

        (void) InitializeEvents(L"SceCli");

        rcGPOCreate = SceProcessBeforeRSOPLogging(
                                        TRUE,
                                        dwFlags,
                                        pComputerTarget->pRsopToken,
                                        0,
                                        NULL,
                                        pComputerTarget->pGPOList,
                                        NULL,
                                        pAbort,
                                        NULL,
                                        NULL,
                                        NULL,
                                        &szLogFileName,
                                        NULL
                                        );

        if (rcGPOCreate != ERROR_OPERATION_ABORTED && pComputerTarget->pGPOList)

            rcLogging = SceLogSettingsPrecedenceGPOs(
                                                    pComputerTarget->pWbemServices,
                                                    TRUE,
                                                    &szLogFileName);

        if (szLogFileName)
           ScepFree(szLogFileName);


        (void) ShutdownEvents();

    } __except(EXCEPTION_EXECUTE_HANDLER) {

        rcGPOCreate = ERROR_INVALID_PARAMETER;
    }

    //
    // rcGPOCreate dominates rcLogging
    //

    return (rcGPOCreate != ERROR_SUCCESS ? rcGPOCreate : rcLogging );

}

//
// the new interface - client side extension for RSOP Diagnosis mode
//
DWORD
WINAPI
SceProcessSecurityPolicyGPOEx(
    IN DWORD dwFlags,
    IN HANDLE hUserToken,
    IN HKEY hKeyRoot,
    IN PGROUP_POLICY_OBJECT pDeletedGPOList,
    IN PGROUP_POLICY_OBJECT pChangedGPOList,
    IN ASYNCCOMPLETIONHANDLE pHandle,
    IN BOOL *pbAbort,
    IN PFNSTATUSMESSAGECALLBACK pStatusCallback,
    IN IWbemServices *pWbemServices,
    OUT HRESULT *pHrRsopStatus
    )
/*
Description:
    This is the new interface called from winlogon/userenv to process GPOs and log
    RSOP data. The dll name and procedure name are registered to winlogon under
    GpExtensions.

    This routine applies a SCE group policy template to the current system.
    The template can be in domain level, OU level, or user level. The template
    is applied incrementally to the current system. RSOP data is also logged if
    a valid namespace pointer is passed in. The server side callbacks log statuses
    to all settings with precedence 1 (which corresponds to the merged settings
    in the server side JET database)

    This interface can be called during system boot, or every GPFrequency hours
    after logon. The input argument contains info for where this interface is
    called and under which context (user, or machine) this interface is called.

    This interface shouldn't be called for user policy.

Arguments:

    dwFlags     - the GPO Info flags
                        GPO_INFO_FLAG_MACHINE
                        GPO_INFO_FLAG_SLOWLINK
                        GPO_INFO_FLAG_BACKGROUND
                        GPO_INFO_FLAG_VERBOSE
                        GPO_INFO_FLAG_NOCHANGES

    hUserToken  - the user token for which the user policy should be applied
                    if it's the machine policy, hUserToken refers to system

    hKeyRoot    - the root for the policy in registry

    pDeletedGPOList - all deleted GPOs to process

    pChangedGPOList - all GPOs that are either changed or not changed

    pHandle     - for asynchronous processing

    pbAbort     - processing of GPO should be aborted if this is set to TRUE
                    (in case of system shutdown or user log off)

    pStatusCallback - Callback function for displaying status messages
*/
{
    if ( dwFlags & GPO_INFO_FLAG_SAFEMODE_BOOT ) {
        // call me next time
        return(ERROR_OVERRIDE_NOCHANGES);
    }

    DWORD   rcGPOCreate = ERROR_SUCCESS;
    DWORD   rcConfig = ERROR_SUCCESS;
    DWORD   rcLogging = ERROR_SUCCESS;
    AREA_INFORMATION    AllAreas;
    BOOL    b;
    PWSTR   szLogFileName = NULL;
    DWORD   dwWinlogonLog;
    DWORD dwDiagOptions = 0;

    //
    // this will protect the RSOP global vars from multiple diagnosis'/policy props
    // if asynch thread is spawned successfully, will be released there
    // else released in synch main thread
    //

    EnterCriticalSection(&DiagnosisPolicypropSync);

    if ( ghAsyncThread != NULL) {

        //
        // bug# 173858
        // on chk'd builds, LeaveCriticalSection() matches thread id's
        // so get the existing behavior in the asynch thread
        // with a wait
        //
        //
        // allow waiting thread to continue on wait error
        // don't care for error since the spawned thread will log errors etc. and
        // other policy propagation threads have to continue
        //

        WaitForSingleObject( ghAsyncThread, INFINITE);

        CloseHandle(ghAsyncThread);

        ghAsyncThread = NULL;

    }

    //
    // initialize gbAsyncWinlogonThread so it can be set to TRUE if slow thread is spawned
    //

    gbAsyncWinlogonThread = FALSE;
    gHrSynchRsopStatus = WBEM_S_NO_ERROR;
    gHrAsynchRsopStatus = WBEM_S_NO_ERROR;
    //
    // put a try except block in case arguments are invalid
    //

    __try {


        tg_pWbemServices = pWbemServices;

        //
        // if the namespace parameter is valid, increment the reference count
        // the reference count is decremented by the async thread if spawned
        //                                          else by the sync thread
        //

        if (tg_pWbemServices) {
            tg_pWbemServices->AddRef();
        }


        (void) InitializeEvents(L"SceCli");

        rcGPOCreate = SceProcessBeforeRSOPLogging(
                                                 FALSE,
                                                 dwFlags,
                                                 hUserToken,
                                                 hKeyRoot,
                                                 pDeletedGPOList,
                                                 pChangedGPOList,
                                                 pHandle,
                                                 pbAbort,
                                                 pStatusCallback,
                                                 &AllAreas,
                                                 &b,
                                                 &szLogFileName,
                                                 &dwWinlogonLog
                                                 );

        // actually *pRsopStatus should be set after callbacks are successful
        // log RSOP data if valid namespace ptr
        if ( rcGPOCreate != ERROR_OPERATION_ABORTED &&
             rcGPOCreate != ERROR_OVERRIDE_NOCHANGES && pWbemServices )
            rcLogging = ScepDosErrorToWbemError(SceLogSettingsPrecedenceGPOs(
                                                                            pWbemServices,
                                                                            FALSE,
                                                                            &szLogFileName
                                                                            ));

        if (pHrRsopStatus) {
                *pHrRsopStatus = ScepDosErrorToWbemError(rcLogging);
        }


        if (rcGPOCreate == ERROR_SUCCESS) {

            if (pWbemServices != NULL)
                dwDiagOptions |= SCE_RSOP_CALLBACK;

            rcConfig = SceProcessAfterRSOPLogging(
                                                 dwFlags,
                                                 pHandle,
                                                 pbAbort,
                                                 pStatusCallback,
                                                 AllAreas,
                                                 b,
                                                 &szLogFileName,
                                                 dwWinlogonLog,
                                                 dwDiagOptions
                                                 );
        }

        if (pHrRsopStatus && *pHrRsopStatus == S_OK && gHrSynchRsopStatus != S_OK) {

            *pHrRsopStatus = gHrSynchRsopStatus;
        }

        if ( szLogFileName ) {

            //
            // szLogFileName is NULL if it was freed somewhere in the sync thread
            // this thread will free if the asynch thread was not spawned
            //
            LocalFree(szLogFileName);
            szLogFileName = NULL;
        }

        //
        // clear callback status
        //
        ScepPolStatusCallback(pStatusCallback, FALSE, 0);

        (void) ShutdownEvents();


        if (!gbAsyncWinlogonThread) {


            if (tg_pWbemServices) {
                tg_pWbemServices->Release();
                tg_pWbemServices = NULL;
            }

            if (gpwszDCDomainName) {
                LocalFree(gpwszDCDomainName);
                gpwszDCDomainName = NULL;
            }
        }

    } __except(EXCEPTION_EXECUTE_HANDLER) {

        rcGPOCreate = ERROR_INVALID_PARAMETER;
    }
    //
    // if slow winlogon async thread was not spawned, this thread needs to release cs
    //

    LeaveCriticalSection(&DiagnosisPolicypropSync);

    //
    // make sure to release policy notification queue processing
    // if it's not released yet.
    //
    ScepControlNotificationQProcess(NULL, gbThisIsDC, 0);


    return(rcGPOCreate != ERROR_SUCCESS ? rcGPOCreate : rcConfig);

}

//
// old API support
// but if extension is RSOP enabled SceProcessSecurityPolicyGPOEx is called
//
DWORD
WINAPI
SceProcessSecurityPolicyGPO(
    IN DWORD dwFlags,
    IN HANDLE hUserToken,
    IN HKEY hKeyRoot,
    IN PGROUP_POLICY_OBJECT pDeletedGPOList,
    IN PGROUP_POLICY_OBJECT pChangedGPOList,
    IN ASYNCCOMPLETIONHANDLE pHandle,
    IN BOOL *pbAbort,
    IN PFNSTATUSMESSAGECALLBACK pStatusCallback
    )
/*
Description:
    This is the old interface called from winlogon/userenv to process GPOs. The dll
    name and procedure name are registered to winlogon under GpExtensions.

    This routine applies a SCE group policy template to the current system.
    The template can be in domain level, OU level, or user level. The template
    is applied incrementally to the current system.

    This interface can be called during system boot, or every GPFrequency hours
    after logon. The input argument contains info for where this interface is
    called and under which context (user, or machine) this interface is called.

    This interface shouldn't be called for user policy.

Arguments:

    dwFlags     - the GPO Info flags
                        GPO_INFO_FLAG_MACHINE
                        GPO_INFO_FLAG_SLOWLINK
                        GPO_INFO_FLAG_BACKGROUND
                        GPO_INFO_FLAG_VERBOSE
                        GPO_INFO_FLAG_NOCHANGES

    hUserToken  - the user token for which the user policy should be applied
                    if it's the machine policy, hUserToken refers to system

    hKeyRoot    - the root for the policy in registry

    pDeletedGPOList - all deleted GPOs to process

    pChangedGPOList - all GPOs that are either changed or not changed

    pHandle     - for asynchronous processing

    pbAbort     - processing of GPO should be aborted if this is set to TRUE
                    (in case of system shutdown or user log off)

    pStatusCallback - Callback function for displaying status messages
*/
{
    if ( dwFlags & GPO_INFO_FLAG_SAFEMODE_BOOT ) {
        // call me next time
        return(ERROR_OVERRIDE_NOCHANGES);
    }

    DWORD   rc = ERROR_SUCCESS;
    AREA_INFORMATION    AllAreas;
    BOOL    b;
    PWSTR   szLogFileName = NULL;
    DWORD   dwWinlogonLog;

    //
    // this will protect the RSOP global vars from multiple diagnosis'/policy props
    // if asynch is spawned successfully, will be released there
    // else released in synch main thread
    //
    EnterCriticalSection(&DiagnosisPolicypropSync);

    if ( ghAsyncThread != NULL) {

    //
    // bug# 173858
    // on chk'd builds, LeaveCriticalSection() matches thread id's
    // so get the existing behavior in the asynch thread
    // with a wait
    //

        //
        // allow waiting thread to continue on wait error
        // don't care for error since the spawned thread will log errors etc. and
        // other policy propagation threads have to continue
        //

        WaitForSingleObject( ghAsyncThread, INFINITE);

        CloseHandle(ghAsyncThread);

        ghAsyncThread = NULL;

    }

    //
    // initialize gbAsyncWinlogonThread so it can be set to TRUE if slow thread is spawned
    //

    gbAsyncWinlogonThread = FALSE;

    __try {

        (void) InitializeEvents(L"SceCli");

        rc = SceProcessBeforeRSOPLogging(
                                        FALSE,
                                        dwFlags,
                                        hUserToken,
                                        hKeyRoot,
                                        pDeletedGPOList,
                                        pChangedGPOList,
                                        pHandle,
                                        pbAbort,
                                        pStatusCallback,
                                        &AllAreas,
                                        &b,
                                        &szLogFileName,
                                        &dwWinlogonLog
                                        );

        if (rc == ERROR_SUCCESS) {

            rc = SceProcessAfterRSOPLogging(
                                           dwFlags,
                                           pHandle,
                                           pbAbort,
                                           pStatusCallback,
                                           AllAreas,
                                           b,
                                           &szLogFileName,
                                           dwWinlogonLog,
                                           0
                                           );
        }

        if ( szLogFileName ) {

            //
            // szLogFileName is NULL if it was freed somewhere in the sync thread
            // this thread will free if the asynch thread was not spawned
            //
            LocalFree(szLogFileName);
            szLogFileName = NULL;
        }

        if (!gbAsyncWinlogonThread) {

            if (gpwszDCDomainName) {
                LocalFree(gpwszDCDomainName);
                gpwszDCDomainName = NULL;
            }
        }
        //
        // clear callback status
        //
        ScepPolStatusCallback(pStatusCallback, FALSE, 0);

        (void) ShutdownEvents();

    } __except(EXCEPTION_EXECUTE_HANDLER) {

        rc = ERROR_INVALID_PARAMETER;
    }

    //
    // if slow winlogon async thread was not spawned, this thread needs to release cs
    //

    LeaveCriticalSection(&DiagnosisPolicypropSync);

//    if (!gbAsyncWinlogonThread) {

//        LeaveCriticalSection(&DiagnosisPolicypropSync);
//    }

    //
    // ready to copy GPOs from the sysvol location
    // should stop queue processing now
    //
    ScepControlNotificationQProcess(NULL, gbThisIsDC, 0);

    return rc;

}

DWORD
SceProcessBeforeRSOPLogging(
    IN BOOL bPlanningMode,
    IN DWORD dwFlags,
    IN HANDLE hUserToken,
    IN HKEY hKeyRoot,
    IN PGROUP_POLICY_OBJECT pDeletedGPOList OPTIONAL,
    IN PGROUP_POLICY_OBJECT pChangedGPOList,
    IN ASYNCCOMPLETIONHANDLE pHandle OPTIONAL,
    IN BOOL *pbAbort,
    IN PFNSTATUSMESSAGECALLBACK pStatusCallback OPTIONAL,
    OUT AREA_INFORMATION    *pAllAreas OPTIONAL,
    OUT BOOL    *pb OPTIONAL,
    OUT PWSTR   *pszLogFileName OPTIONAL,
    OUT DWORD   *pdwWinlogonLog OPTIONAL
    )
/*
Description:

    This routine is called for both planning and diagnosis modes. In this routine,
    all GPOs are copied locally into a cache for use by the logging routines and/or
    configuration routines after this routine.

    SceProcessAfterRSOPLogging is a sister function that is called for diagnosis mode only.

    This interface shouldn't be called for user policy but within the routine,
    a checking is still made to make sure that user level policies is not processed.
    For domain or OU level policies, This routine categories policy: 1) policy
    must be enforced before user logon (security policy and user rights),
    2) policy can be applied after user logon (for example, file security). For diagnosis mode,
    The 2nd category is applied asynchronously (in a separate thread).


Arguments:

    dwFlags     - the GPO Info flags
                        GPO_INFO_FLAG_MACHINE
                        GPO_INFO_FLAG_SLOWLINK
                        GPO_INFO_FLAG_BACKGROUND
                        GPO_INFO_FLAG_VERBOSE
                        GPO_INFO_FLAG_NOCHANGES

    hUserToken  - the user token for which the user policy should be applied
                    if it's the machine policy, hUserToken refers to system

    hKeyRoot    - the root for the policy in registry

    pDeletedGPOList - all deleted GPOs to process

    pChangedGPOList - all GPOs that are either changed or not changed

    pHandle     - for asynchronous processing

    pbAbort     - processing of GPO should be aborted if this is set to TRUE
                    (in case of system shutdown or user log off)

    pStatusCallback - Callback function for displaying status messages

Return Value:

    Win32 error
        ERROR_SUCCESS
        E_PENDING if asynchonous processing
        other errors

    Note, if error is returned, the previous cached GPO list will be used for
    next propagation (because it didn't succeed this time).

*/
{
    // validate input parameters
    if (!bPlanningMode &&  !hKeyRoot || !hUserToken ) {

        return(ERROR_INVALID_PARAMETER);
    }

    //
    //  for diagnosis, continue even if the GPO list is empty because of local security database
    //
    if ( bPlanningMode && pChangedGPOList == NULL ) {
        return(ERROR_SUCCESS);
    }

    DWORD rc = ERROR_SUCCESS;
    DWORD rcSave = ERROR_SUCCESS;
    DWORD nRequired=0;
    BOOL b = FALSE;

    DWORD  nDays;
/*
    DWORD  dPeriodInDays=0;
    DWORD  dLastSeconds=0;
    DWORD  dCurrentSeconds=0;
*/
    LARGE_INTEGER       CurrentTime;
    AREA_INFORMATION AllAreas=0;
    HANDLE hfTemp=INVALID_HANDLE_VALUE;
    //
    // variables for log file names
    //

    LPTSTR szLogFileName=NULL;
    BOOL bSuspend=FALSE;

    //
    // check if system is shutdown, or dcpromo is going
    //
    if ( ScepShouldTerminateProcessing( pbAbort, FALSE ) ) {

        return(ERROR_OPERATION_ABORTED);
    }


    if (!bPlanningMode) {

        rc = RtlNtStatusToDosError( ScepIsSystemContext(hUserToken,&b) );

    }

    if ( !bPlanningMode && !b ) {

        //
        // can't get current user SID or it's not system SID (maybe user policy)
        //

        if ( ERROR_SUCCESS != rc ) {

            //
            // error occurs when querying/comparing user token
            //

            LogEvent(MyModuleHandle,
                     STATUS_SEVERITY_ERROR,
                     SCEPOL_ERROR_PROCESS_GPO,
                     IDS_ERROR_GET_TOKEN_USER,
                     rc
                    );

            return( rc );

        } else {

            //
            // this is not the machine (system) token, return
            //
            return( ERROR_SUCCESS );
        }
    }


    if (!bPlanningMode) {

        //
        // it is machine policy since user policy is filtered out before this
        // try to get the thread/process token to check if it is the system context
        //

        HANDLE  hToken = NULL;

        if (!OpenThreadToken( GetCurrentThread(),
                              TOKEN_QUERY,
                              FALSE,
                              &hToken)) {

            if (!OpenProcessToken( GetCurrentProcess(),
                                   TOKEN_QUERY,
                                   &hToken)) {

                rc = GetLastError();
            }

        }

        if ( ERROR_SUCCESS == rc ) {

            rc = RtlNtStatusToDosError( ScepIsSystemContext(hToken,&b) );

            if (hToken)
                CloseHandle(hToken);
        }

        if (!b) {

            if ( ERROR_SUCCESS != rc ) {

                //
                // error occurs when querying/comparing system token in machine policy
                //

                LogEvent(MyModuleHandle,
                         STATUS_SEVERITY_ERROR,
                         SCEPOL_ERROR_PROCESS_GPO,
                         IDS_ERROR_GET_TOKEN_MACHINE,
                         rc
                        );

                return( rc );

            } else {

                //
                // this is not the machine (system) token, return
                //
                return( ERROR_SUCCESS );
            }

        }

    }


    //
    // check if system is shutdown, or dcpromo is going
    //
    if ( ScepShouldTerminateProcessing( pbAbort, FALSE ) ) {

        return(ERROR_OPERATION_ABORTED);
    }

    //
    // build log name %windir%\security\logs\winlogon.log
    // if the registry flag is set
    //

    DWORD dwLog = 0;

    ScepRegQueryIntValue(
                        HKEY_LOCAL_MACHINE,
                        GPT_SCEDLL_NEW_PATH,
                        (bPlanningMode ? TEXT("ExtensionRsopPlanningDebugLevel") : TEXT("ExtensionDebugLevel")),
                        &dwLog
                        );

    if ( dwLog != 0 ) {

        nRequired = GetSystemWindowsDirectory(NULL, 0);

        if ( nRequired ) {


            if (bPlanningMode) {

                szLogFileName = (LPTSTR)LocalAlloc(0, (nRequired+1+
                                                       lstrlen(PLANNING_LOG_PATH))*sizeof(TCHAR));
            }

            else{

                szLogFileName = (LPTSTR)LocalAlloc(0, (nRequired+1+
                                                       lstrlen(WINLOGON_LOG_PATH))*sizeof(TCHAR));
            }

            if ( szLogFileName ){

                GetSystemWindowsDirectory(szLogFileName, nRequired);

                szLogFileName[nRequired] = L'\0';

                lstrcat(szLogFileName, (bPlanningMode ? PLANNING_LOG_PATH : WINLOGON_LOG_PATH));

            }else{

                // should not occur
                // ignore this error, log is NULL}

            } // else ignore, log is NULL} // else log is NULL

        }
    }

    //
    // find out if this machine is a domain controller
    //

    if ( !bPlanningMode && !gbDCQueried ) {

        PDSROLE_PRIMARY_DOMAIN_INFO_BASIC pDsRole=NULL;

        HINSTANCE hDsRoleDll = LoadLibrary(TEXT("netapi32.dll"));

        if ( hDsRoleDll) {

            PVOID pfDsRole;

            pfDsRole = (PVOID)GetProcAddress(
                                            hDsRoleDll,
                                            "DsRoleGetPrimaryDomainInformation");

            if ( pfDsRole ) {
                rc = (*((PFGETDOMAININFO)pfDsRole))(
                                                   NULL,
                                                   DsRolePrimaryDomainInfoBasic,
                                                   (PBYTE *)&pDsRole
                                                   );

                if (rc == ERROR_SUCCESS) {

                    if ( pDsRole->MachineRole == DsRole_RolePrimaryDomainController ||
                         pDsRole->MachineRole == DsRole_RoleBackupDomainController ) {
                        gbThisIsDC = TRUE;

                        //
                        // stash the domain name in a buffer for use when canonicalizing group names in diagnosis mode
                        // should be freed similar to critical section
                        //

                        if (pDsRole->DomainNameFlat) {
                            if (gpwszDCDomainName = (PWSTR) LocalAlloc(LMEM_ZEROINIT,
                                                            (wcslen(pDsRole->DomainNameFlat) + 1) * sizeof (WCHAR))) {
                                wcscpy(gpwszDCDomainName, pDsRole->DomainNameFlat);
                            }
                        }
                    }

                    gbDCQueried = TRUE;

                    pfDsRole = (PVOID)GetProcAddress(
                                                    hDsRoleDll,
                                                    "DsRoleFreeMemory");

                    if ( pfDsRole ) {
                        (*((PFDSFREE)pfDsRole))( pDsRole );
                    }
                }
            }

            FreeLibrary(hDsRoleDll);

        }
    }

    //
    // check if system is shutdown, or dcpromo is going
    //
    if ( ScepShouldTerminateProcessing( pbAbort, FALSE ) ) {

        rcSave = ERROR_OPERATION_ABORTED;

        goto CleanUp;
    }

    //
    // set the MaxNoGPOListChangesInterval back
    //
    if ( !bPlanningMode &&  (ERROR_SUCCESS == ScepRegQueryIntValue(
                                                                  HKEY_LOCAL_MACHINE,
                                                                  SCE_ROOT_PATH,
                                                                  TEXT("GPOSavedInterval"),
                                                                  &nDays
                                                                  ) ) ) {

        ScepRegSetIntValue(
                          HKEY_LOCAL_MACHINE,
                          GPT_SCEDLL_NEW_PATH,
                          TEXT("MaxNoGPOListChangesInterval"),
                          nDays
                          );

        ScepRegDeleteValue(
                          HKEY_LOCAL_MACHINE,
                          SCE_ROOT_PATH,
                          TEXT("GPOSavedInterval")
                          );
    }

    //
    // process any policy filter temp files created in setup
    // (if this is the reboot after seutp on DC)
    //
    if (!bPlanningMode)
        ScepProcessPolicyFilterTempFiles(szLogFileName);


    //
    // prepare the log file
    //
    if ( !bPlanningMode && szLogFileName ) {

        //
        // check the log size and wrap it if it's over 1M
        //

        DWORD dwLogSize=0;

        HANDLE hFile = CreateFile(szLogFileName,
                            GENERIC_READ | GENERIC_WRITE,
                            FILE_SHARE_READ,
                            NULL,
                            OPEN_ALWAYS,  // OPEN_EXISTING
                            FILE_ATTRIBUTE_NORMAL,
                            NULL);

        if ( INVALID_HANDLE_VALUE != hFile ) {

            dwLogSize = GetFileSize(hFile, NULL);

            if ( dwLogSize < (0x1 << 20) ) {

                //
                // log a line to separate multiple propagation.
                //
                SetFilePointer (hFile, 0, NULL, FILE_END);
                ScepWriteSingleUnicodeLog(hFile, TRUE, L"**************************");

            }

            CloseHandle(hFile);
        }

        if ( dwLogSize >= (0x1 << 20) ) {

            nRequired = wcslen(szLogFileName);

            LPTSTR szTempName = (LPTSTR)LocalAlloc(0, (nRequired+1)*sizeof(TCHAR));

            if ( szTempName ) {
                wcscpy(szTempName, szLogFileName);
                szTempName[nRequired-3] = L'o';
                szTempName[nRequired-2] = L'l';
                szTempName[nRequired-1] = L'd';

                CopyFile( szLogFileName, szTempName, FALSE );
                LocalFree(szTempName);
            }

            DeleteFile(szLogFileName);

        }
    }

    //
    // check if system is shutdown, or dcpromo is going
    //
    if ( ScepShouldTerminateProcessing( pbAbort, FALSE ) ) {

        rcSave = ERROR_OPERATION_ABORTED;

        goto CleanUp;
    }


    if ( !ScepClearGPObjects(bPlanningMode) ) {

        rc = GetLastError();

        LogEvent(MyModuleHandle,
                 STATUS_SEVERITY_ERROR,
                 SCEPOL_ERROR_PROCESS_GPO,
                 IDS_ERR_DELETE_GP_CACHE,
                 rc
                );

        SetLastError(rc);

        rcSave = ERROR_OPERATION_ABORTED;

        goto CleanUp;

    }

    //
    // callback for status display
    //
    if (!bPlanningMode)

        ScepPolStatusCallback(pStatusCallback, FALSE, IDS_APPLY_SECURITY_POLICY);

    //
    // process each GPO in the changed gpo list
    // deleted GPOs are ignored for security policy
    //
    PGROUP_POLICY_OBJECT pGpo;

    rc = ERROR_SUCCESS;
    bSuspend=FALSE;

    for ( pGpo = pChangedGPOList; pGpo != NULL; pGpo=pGpo->pNext ) {

        //
        // callback for status display
        //
        if (!bPlanningMode && pStatusCallback ) {
            pStatusCallback(TRUE, pGpo->lpDisplayName);
        }

        //
        // we don't have security policy in local template. ignore it
        // the local security policy is stored in the ESE database.
        //
        if ( pGpo->GPOLink == GPLinkMachine ) {
            continue;
        }

        if (!bPlanningMode && !bSuspend ) {

            //
            // ready to copy GPOs from the sysvol location
            // should stop queue processing now
            //
            rc = ScepControlNotificationQProcess(szLogFileName, gbThisIsDC, 1);

            if ( gbThisIsDC && (ERROR_OVERRIDE_NOCHANGES == rc) ) {
                //
                // there is policy notification going on right now
                //
                rcSave = rc;
                break;
            }
            bSuspend = TRUE;
        }

        rc = ScepProcessSecurityPolicyInOneGPO( bPlanningMode,
                                                dwFlags,
                                                pGpo,
                                                szLogFileName,
                                                &AllAreas
                                                );

        if ( rc != ERROR_SUCCESS ) {
            //
            // continue logging for planning and diagnosis but do not config
            //
            rcSave = rc;
        }

        //
        // check if system is shutdown, or dcpromo is going
        //
        if ( ScepShouldTerminateProcessing( pbAbort, FALSE ) ) {

            //
            // clear callback status
            //
            if (!bPlanningMode)

                ScepPolStatusCallback(pStatusCallback, FALSE, 0);

            rcSave = rc = ERROR_OPERATION_ABORTED;

            break;
        }
    }

CleanUp:

    if (pb) *pb = b;

    if (pszLogFileName)
        *pszLogFileName = szLogFileName;
    else if (szLogFileName)
        LocalFree(szLogFileName);

    if (pAllAreas)  *pAllAreas = AllAreas;

    if (pdwWinlogonLog) *pdwWinlogonLog = dwLog;

    return rcSave;

}

DWORD
SceProcessAfterRSOPLogging(
    IN DWORD dwFlags,
    IN ASYNCCOMPLETIONHANDLE pHandle,
    IN BOOL *pbAbort,
    IN PFNSTATUSMESSAGECALLBACK pStatusCallback,
    IN AREA_INFORMATION ThisAreas,
    IN BOOL b,
    IN PWSTR *ppszLogFileName,
    IN DWORD dwWinlogonLog,
    IN DWORD dwDiagOptions
)
/*
Description:
    Routine that is called for diagnosis mode only where the actual configuration is done.
*/
{

    DWORD   rc = ERROR_SUCCESS;
    //
    // no error, process all policies on local machine
    //
    TCHAR Windir[MAX_PATH], Buffer[MAX_PATH+50];
    AREA_INFORMATION AllAreas=ThisAreas;

    Windir[0] = L'\0';
    GetSystemWindowsDirectory(Windir, MAX_PATH);
    Windir[MAX_PATH-1] = L'\0';

    wcscpy(Buffer, Windir);
    wcscat(Buffer, L"\\security\\templates\\policies\\gpt*.*");

    intptr_t            hFile;
    struct _wfinddata_t    FileInfo;
    LONG  NoMoreFiles=0;

    hFile = _wfindfirst(Buffer, &FileInfo);

    DWORD dConfigOpt=0;

    //
    // AllAreas contains the areas defined in current set of GPOs
    // query the areas in previous policy propagation
    //
    AREA_INFORMATION PrevAreas = 0;

    ScepRegQueryIntValue(
                        HKEY_LOCAL_MACHINE,
                        GPT_SCEDLL_NEW_PATH,
                        TEXT("PreviousPolicyAreas"),
                        &PrevAreas
                        );
    // there is no tattoo value for these areas
    PrevAreas &= ~(AREA_FILE_SECURITY | AREA_REGISTRY_SECURITY | AREA_DS_OBJECTS);

    AllAreas |= PrevAreas;

    if ( hFile != -1 && ThisAreas > 0 ) {


        //
        // query the configure frequency which is set by GPE on DC
        // do not care errors. Note, security policy is not controlled
        // by the configure frequency
        // not used
        //
        b = TRUE;   // the first template

        do {

            LogEventAndReport(MyModuleHandle,
                              (ppszLogFileName ? *ppszLogFileName : NULL),
                              0,
                              0,
                              IDS_PROCESS_TEMPLATE,
                              FileInfo.name
                             );

            Buffer[0] = L'\0';
            wcscpy(Buffer, Windir);
            wcscat(Buffer, L"\\security\\templates\\policies\\");
            wcscat(Buffer, FileInfo.name);

            NoMoreFiles = _wfindnext(hFile, &FileInfo);

            //
            // Buffer contains the real template name to process
            //
            //
            // if it's not the last template, just update the template
            // without really configuring
            //

            dConfigOpt = SCE_UPDATE_DB | SCE_POLICY_TEMPLATE;

            switch ( dwWinlogonLog ) {
            case 0:
                dConfigOpt |= SCE_DISABLE_LOG;
                break;
            case 1:
                dConfigOpt |= SCE_VERBOSE_LOG;
                break;
            default:
                dConfigOpt |= SCE_DEBUG_LOG;
            }

            if ( b ) {
                dConfigOpt |= SCE_POLICY_FIRST;
                if ( gbThisIsDC ) {
                    dConfigOpt |= SCE_NOCOPY_DOMAIN_POLICY;
                }
                b = FALSE;  // next tempalte is not the first one
            }

            //
            // check if system is shutdown, or dcpromo is going
            //
            if ( ScepShouldTerminateProcessing( pbAbort, TRUE ) ) {

                rc = GetLastError();

                if ( ppszLogFileName && *ppszLogFileName ) {
                    LocalFree(*ppszLogFileName);
                    *ppszLogFileName = NULL;
                }
                //
                // clear callback status
                //
                ScepPolStatusCallback(pStatusCallback, FALSE, 0);

                return(rc);
            }

            if ( NoMoreFiles == 0 ) {
                //
                // this is not the last one, import the template to engine
                // no matter if the current thread is background or foreground
                // NO_CONFIG yet.
                //

                dConfigOpt |= SCE_NO_CONFIG;

                if ( gbThisIsDC && wcsstr(Buffer, L".inf") != NULL ) {
                    //
                    // this is not a domain GPO
                    // since this machine is a DC, do not take domain policy from this GPO
                    //
                    dConfigOpt |= SCE_NO_DOMAIN_POLICY;

                    LogEventAndReport(MyModuleHandle,
                                      (ppszLogFileName ? *ppszLogFileName : NULL),
                                      0,
                                      0,
                                      IDS_NOT_LAST_GPO_DC,
                                      L""
                                     );
                } else {

                    LogEventAndReport(MyModuleHandle,
                                      (ppszLogFileName ? *ppszLogFileName : NULL),
                                      0,
                                      0,
                                      IDS_NOT_LAST_GPO,
                                      L""
                                     );
                }


                rc = ScepWaitConfigSystem(
                                         NULL, // local system
                                         Buffer,
                                         NULL,
                                         (ppszLogFileName ? *ppszLogFileName : NULL),
                                         dConfigOpt | SCE_POLBIND_NO_AUTH,
                                         AllAreas,   // not used when NO_CONFIG is specified
                                         NULL, // no callback
                                         NULL, // no callback window
                                         NULL  // no warning
                                         );

                if ( ERROR_NOT_SUPPORTED == rc ) {
                    //
                    // server is not ready
                    // log an event log to warn users
                    //

                    LogEvent(MyModuleHandle,
                             STATUS_SEVERITY_WARNING,
                             SCEPOL_ERROR_PROCESS_GPO,
                             IDS_PROPAGATE_NOT_READY,
                             rc
                            );
                    break;

                } else if ( ERROR_IO_PENDING == rc ) {

                    rc = ERROR_OVERRIDE_NOCHANGES;
                    break;

                } else if (ERROR_SUCCESS != rc ) {

                    //
                    // log an event log to warn users
                    //

                    LPVOID     lpMsgBuf=NULL;

                    FormatMessage( FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
                                   NULL,
                                   rc,
                                   MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
                                   (LPTSTR)&lpMsgBuf,
                                   0,
                                   NULL
                                 );

                    if ( !(dConfigOpt & SCE_NO_CONFIG) &&
                         (ERROR_SPECIAL_ACCOUNT == rc) ) {

                        LogEvent(MyModuleHandle,
                                 STATUS_SEVERITY_WARNING,
                                 SCEPOL_WARNING_PROCESS_GPO,
                                 IDS_WARNING_PROPAGATE_SPECIAL,
                                 rc,
                                 lpMsgBuf ? (PWSTR)lpMsgBuf : L"\r\n"
                                );

                        rc = ERROR_OVERRIDE_NOCHANGES;

                    } else {

                        switch (rc) {
                        case ERROR_NONE_MAPPED:
                            LogEvent(MyModuleHandle,
                                     STATUS_SEVERITY_WARNING,
                                     SCEPOL_WARNING_PROCESS_GPO,
                                     IDS_WARNING_PROPAGATE_NOMAP,
                                     rc,
                                     lpMsgBuf ? (PWSTR)lpMsgBuf : L"\r\n"
                                    );
                            break;

                        case ERROR_TIMEOUT:
                            LogEvent(MyModuleHandle,
                                     STATUS_SEVERITY_WARNING,
                                     SCEPOL_WARNING_PROCESS_GPO,
                                     IDS_WARNING_PROPAGATE_TIMEOUT,
                                     rc,
                                     lpMsgBuf ? (PWSTR)lpMsgBuf : L"\r\n"
                                    );
                            break;

                        default:
                            LogEvent(MyModuleHandle,
                                     STATUS_SEVERITY_WARNING,
                                     SCEPOL_WARNING_PROCESS_GPO,
                                     IDS_WARNING_PROPAGATE,
                                     rc,
                                     lpMsgBuf ? (PWSTR)lpMsgBuf : L"\r\n"
                                    );
                        }

                    }

                    if ( lpMsgBuf ) {
                        LocalFree(lpMsgBuf);
                    }

                    break;
                }

            } else {

                //
                // this is the last template in this cycle
                // should trigger configuration now
                //

                dConfigOpt |= SCE_POLICY_LAST;

                AREA_INFORMATION AreaSave, Area, AreaToConfigure;

                AreaSave = AllAreas & (AREA_FILE_SECURITY | AREA_REGISTRY_SECURITY | AREA_DS_OBJECTS ); // background areas
                Area = AllAreas & ~AreaSave;

                //
                // callback for status display
                //
                ScepPolStatusCallback(pStatusCallback, TRUE, IDS_CONFIGURE_POLICY);

                //
                // always use incremental modal to update security policy first
                //

                if ( dwFlags & GPO_INFO_FLAG_BACKGROUND ) {

                    //
                    // this GPT thread is currently running in the background
                    // so configure all security together
                    //

                    AreaToConfigure = Area | AreaSave;

                } else {

                    //
                    // this GPT thread is currently running in the foreground
                    // or configure frequency condition is not qualified for other areas
                    //
                    // configure security policy in this thread first
                    //

                    AreaToConfigure = Area;
                }

                if ( gbThisIsDC && wcsstr(Buffer, L".inf") != NULL ) {
                    //
                    // this is not a domain GPO, import the template first
                    // since this machine is a DC, do not take domain policy from this GPO
                    // this is the last one, we need to pass this GPO in
                    // without domain policy but domain policy should be configured
                    // if it come from the domain level
                    // so pass the GPO in first with NO_CONFIG, then call again
                    // to configure
                    //
                    dConfigOpt |= SCE_NO_DOMAIN_POLICY | SCE_NO_CONFIG;

                    LogEventAndReport(MyModuleHandle,
                                      (ppszLogFileName ? *ppszLogFileName : NULL),
                                      0,
                                      0,
                                      IDS_LAST_GPO_DC,
                                      L""
                                     );


                    rc = ScepWaitConfigSystem(
                                             NULL, // local system
                                             Buffer,
                                             NULL,
                                             (ppszLogFileName ? *ppszLogFileName : NULL),
                                             dConfigOpt | SCE_POLBIND_NO_AUTH,
                                             AreaToConfigure | AreaSave,
                                             NULL, // no callback
                                             NULL, // no callback window
                                             NULL  // no warning
                                             );

                    if ( ERROR_SUCCESS == rc ) {

                        //
                        // this is a DC and it's not been configured yet
                        // configure now
                        //
                        dConfigOpt = SCE_POLICY_TEMPLATE |
                                     SCE_UPDATE_DB;

                        switch ( dwWinlogonLog ) {
                        case 0:
                            dConfigOpt |= SCE_DISABLE_LOG;
                            break;
                        case 1:
                            dConfigOpt |= SCE_VERBOSE_LOG;
                            break;
                        default:
                            dConfigOpt |= SCE_DEBUG_LOG;
                            break;
                        }

                        if (dwDiagOptions & SCE_RSOP_CALLBACK)
                            dConfigOpt |= SCE_RSOP_CALLBACK;

                        rc = ScepSceStatusToDosError(
                                                    ScepConfigSystem(
                                                                    NULL, // local system
                                                                    NULL,
                                                                    NULL,
                                                                    (ppszLogFileName ? *ppszLogFileName : NULL),
                                                                    dConfigOpt | SCE_POLBIND_NO_AUTH,
                                                                    AreaToConfigure,
                                                                    NULL, // no callback
                                                                    NULL, // no callback window
                                                                    NULL  // no warning
                                                                    ));
                    }

                } else {
                    //
                    // import/configure the system
                    // Note, if it's running in foreground thread
                    // and this last template contains file/key policy
                    // we need to import file/key policy but not configure them.
                    // They will be configured in the background thread.
                    //

                    if ( (AreaSave > 0) &&
                         !(dwFlags & GPO_INFO_FLAG_BACKGROUND) ) {

                        dConfigOpt |=  SCE_NO_CONFIG_FILEKEY;
                    }

                    if (dwDiagOptions & SCE_RSOP_CALLBACK)
                        dConfigOpt |= SCE_RSOP_CALLBACK;

                    rc = ScepWaitConfigSystem(
                                             NULL, // local system
                                             Buffer,
                                             NULL,
                                             (ppszLogFileName ? *ppszLogFileName : NULL),
                                             dConfigOpt | SCE_POLBIND_NO_AUTH,
                                             AreaToConfigure | AreaSave,
                                             NULL, // no callback
                                             NULL, // no callback window
                                             NULL  // no warning
                                             );

                    LogEventAndReport(MyModuleHandle,
                                      (ppszLogFileName ? *ppszLogFileName : NULL),
                                      0,
                                      0,
                                      IDS_LAST_GPO,
                                      L""
                                     );
                }

                if ( ERROR_NOT_SUPPORTED == rc ) {
                    //
                    // server is not ready
                    // log an event log to warn users
                    //

                    LogEvent(MyModuleHandle,
                             STATUS_SEVERITY_WARNING,
                             SCEPOL_ERROR_PROCESS_GPO,
                             IDS_PROPAGATE_NOT_READY,
                             rc
                            );
                    break;

                } else if ( ERROR_IO_PENDING == rc ) {

                    rc = ERROR_OVERRIDE_NOCHANGES;
                    break;

                } else if ( ERROR_SUCCESS != rc ) {

                    //
                    // log an event log to warn users
                    //

                    LPVOID     lpMsgBuf=NULL;

                    FormatMessage( FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
                                   NULL,
                                   rc,
                                   MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
                                   (LPTSTR)&lpMsgBuf,
                                   0,
                                   NULL
                                 );

                    if ( !(dConfigOpt & SCE_NO_CONFIG) &&
                         (ERROR_SPECIAL_ACCOUNT == rc) ) {

                        LogEvent(MyModuleHandle,
                                 STATUS_SEVERITY_WARNING,
                                 SCEPOL_WARNING_PROCESS_GPO,
                                 IDS_WARNING_PROPAGATE_SPECIAL,
                                 rc,
                                 lpMsgBuf ? (PWSTR)lpMsgBuf : L"\r\n"
                                );

                        rc = ERROR_OVERRIDE_NOCHANGES;

                    } else {

                        switch ( rc ) {
                        case ERROR_NONE_MAPPED:
                            LogEvent(MyModuleHandle,
                                     STATUS_SEVERITY_WARNING,
                                     SCEPOL_WARNING_PROCESS_GPO,
                                     IDS_WARNING_PROPAGATE_NOMAP,
                                     rc,
                                     lpMsgBuf ? (PWSTR)lpMsgBuf : L"\r\n"
                                    );
                            break;

                        case ERROR_TIMEOUT:
                            LogEvent(MyModuleHandle,
                                     STATUS_SEVERITY_WARNING,
                                     SCEPOL_WARNING_PROCESS_GPO,
                                     IDS_WARNING_PROPAGATE_TIMEOUT,
                                     rc,
                                     lpMsgBuf ? (PWSTR)lpMsgBuf : L"\r\n"
                                    );
                            break;

                        default:
                            LogEvent(MyModuleHandle,
                                     STATUS_SEVERITY_WARNING,
                                     SCEPOL_WARNING_PROCESS_GPO,
                                     IDS_WARNING_PROPAGATE,
                                     rc,
                                     lpMsgBuf ? (PWSTR)lpMsgBuf : L"\r\n"
                                    );
                            break;
                        }
                    }

                    if ( lpMsgBuf ) {
                        LocalFree(lpMsgBuf);
                    }
                    break;
                }

                if ( (AreaSave > 0) &&
                     !(dwFlags & GPO_INFO_FLAG_BACKGROUND) ) {

                    //
                    // The current thread is on winlogon's main thread,
                    // Create a separate thread to run this "slow" stuff
                    // so winlogon is not blocked
                    //

                    LogEventAndReport(MyModuleHandle,
                                      (ppszLogFileName ? *ppszLogFileName : NULL),
                                      0,
                                      0,
                                      IDS_GPO_FOREGROUND_THREAD,
                                      L""
                                     );
                    //
                    // variables for the second thread
                    //

                    ULONG idThread;
                    HANDLE hThread;
                    ENGINEARGS *pEA;

                    pEA = (ENGINEARGS *)LocalAlloc(0, sizeof(ENGINEARGS));
                    if ( pEA ) {

                        LPSTREAM pStream = NULL;

                        //
                        // marshall the namespace parameter so the async
                        // thread can log RSOP data during callbacks
                        //

                        if (tg_pWbemServices)
                            CoMarshalInterThreadInterfaceInStream(IID_IWbemServices, tg_pWbemServices, &pStream);

                        pEA->szTemplateName = NULL;
                        pEA->szLogName = (ppszLogFileName ? *ppszLogFileName : NULL);
                        pEA->Area = AreaSave;
                        pEA->pHandle = pHandle;
                        pEA->dwDiagOptions = dwDiagOptions;
                        pEA->pStream = pStream;


                        hSceDll = LoadLibrary(TEXT("scecli.dll"));

                        //
                        // the second thread runs ScepWinlogonThreadFunc with
                        // arguments pEA
                        //

                        hThread = CreateThread(NULL,
                                               0,
                                               (PTHREAD_START_ROUTINE)ScepWinlogonThreadFunc,
                                               (LPVOID)pEA,
                                               0,
                                               &idThread);

                        ghAsyncThread = hThread;

                        if (hThread) {

                            gbAsyncWinlogonThread = TRUE;

                            //
                            // need not be freed in synch thread - the asynch thread will free it
                            //
                            if (ppszLogFileName)

                                *ppszLogFileName = NULL;
                            //
                            // do not wait, return to winlogon
                            // buffer will be freed by the other thread
                            //
                            //CloseHandle(hThread);

                            rc = (DWORD)E_PENDING;

                        } else {

                            rc = GetLastError();

                            LocalFree(pEA);

                            //
                            // error occurs to create the thread, the library won't
                            // be freed by the thread, so free it here
                            //

                            if ( hSceDll ) {
                                FreeLibrary(hSceDll);
                            }

                        }

                    } else {
                        rc = ERROR_NOT_ENOUGH_MEMORY;
                    }
                }
            }

        } while ( NoMoreFiles == 0 );

        _findclose(hFile);

    } else {

        //
        // there is no SCE GPOs but we still need to take the local policy
        //

        dConfigOpt = SCE_UPDATE_DB |
                     SCE_POLICY_TEMPLATE | SCE_POLICY_FIRST | SCE_POLICY_LAST;

        switch ( dwWinlogonLog ) {
        case 0:
            dConfigOpt |= SCE_DISABLE_LOG;
            break;
        case 1:
            dConfigOpt |= SCE_VERBOSE_LOG;
            break;
        default:
            dConfigOpt |= SCE_DEBUG_LOG;
            break;
        }

        if ( gbThisIsDC ) {//
            // this is not a domain GPO, no domain policy should be
            // set from the local policy table.
            //
            dConfigOpt |= SCE_NO_DOMAIN_POLICY |
                          SCE_NOCOPY_DOMAIN_POLICY;
        }

        //
        // callback for status display
        //
        ScepPolStatusCallback(pStatusCallback, TRUE, IDS_CONFIGURE_POLICY);

        //
        // the server may not be initialized yet
        // wait for some time and try again
        //
        rc = ScepWaitConfigSystem(
                                 NULL, // local system
                                 NULL,
                                 NULL,
                                 (ppszLogFileName ? *ppszLogFileName : NULL),
                                 dConfigOpt | SCE_POLBIND_NO_AUTH,
                                 AllAreas, //AREA_SECURITY_POLICY | AREA_PRIVILEGES,
                                 NULL, // no callback
                                 NULL, // no callback window
                                 NULL  // no warning
                                 );

        if ( ERROR_NOT_SUPPORTED == rc ) {
            //
            // server is not ready
            // log an event log to warn users
            //

            LogEvent(MyModuleHandle,
                     STATUS_SEVERITY_WARNING,
                     SCEPOL_ERROR_PROCESS_GPO,
                     IDS_PROPAGATE_NOT_READY,
                     rc
                    );

        } else if ( ERROR_IO_PENDING == rc ) {

            rc = ERROR_OVERRIDE_NOCHANGES;

        } else if ( ERROR_SUCCESS != rc ) {

            LPVOID     lpMsgBuf=NULL;

            FormatMessage( FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
                           NULL,
                           rc,
                           MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
                           (LPTSTR)&lpMsgBuf,
                           0,
                           NULL
                         );

            if ( !(dConfigOpt & SCE_NO_CONFIG) &&
                 (ERROR_SPECIAL_ACCOUNT == rc) ) {

                LogEvent(MyModuleHandle,
                         STATUS_SEVERITY_WARNING,
                         SCEPOL_WARNING_PROCESS_GPO,
                         IDS_WARNING_PROPAGATE_SPECIAL,
                         rc,
                         lpMsgBuf ? (PWSTR)lpMsgBuf : L"\r\n"
                        );

                rc = ERROR_OVERRIDE_NOCHANGES;

            } else {

                switch ( rc ) {
                case ERROR_NONE_MAPPED:
                    LogEvent(MyModuleHandle,
                             STATUS_SEVERITY_WARNING,
                             SCEPOL_WARNING_PROCESS_GPO,
                             IDS_WARNING_PROPAGATE_NOMAP,
                             rc,
                             lpMsgBuf ? (PWSTR)lpMsgBuf : L"\r\n"
                            );
                    break;

                case ERROR_TIMEOUT:
                    LogEvent(MyModuleHandle,
                             STATUS_SEVERITY_WARNING,
                             SCEPOL_WARNING_PROCESS_GPO,
                             IDS_WARNING_PROPAGATE_TIMEOUT,
                             rc,
                             lpMsgBuf ? (PWSTR)lpMsgBuf : L"\r\n"
                            );
                    break;

                default:
                    LogEvent(MyModuleHandle,
                             STATUS_SEVERITY_WARNING,
                             SCEPOL_WARNING_PROCESS_GPO,
                             IDS_WARNING_PROPAGATE,
                             rc,
                             lpMsgBuf ? (PWSTR)lpMsgBuf : L"\r\n"
                            );
                    break;
                }
            }

            if ( lpMsgBuf ) {
                LocalFree(lpMsgBuf);
            }
        }
    }

    //
    // save configuration time to registry, only care security policy status
    // error from the second thread won't be tracked
    //

    if ( ERROR_SUCCESS == rc ||
         E_PENDING == rc ) {

        ScepLogLastConfigTime();

        //
        // log an informational event to state security policy is applied
        //
        LogEvent(MyModuleHandle,
                 STATUS_SEVERITY_INFORMATIONAL,
                 SCEPOL_INFO_GPO_COMPLETED,
                 0,
                 TEXT("")
                );
        //
        // save ThisAreas for next policy prop (to reset tattoo)
        //
        ScepRegSetIntValue(
                          HKEY_LOCAL_MACHINE,
                          GPT_SCEDLL_NEW_PATH,
                          TEXT("PreviousPolicyAreas"),
                          ThisAreas
                          );
    } else {
        //
        // Something failed when propagate this set of policy
        // tattoo values from previous policy may not be reset yet.
        // To make sure undefined areas are covered in the next prop
        // we have to save AllAreas for next policy prop (to reset tattoo)
        //
        ScepRegSetIntValue(
                          HKEY_LOCAL_MACHINE,
                          GPT_SCEDLL_NEW_PATH,
                          TEXT("PreviousPolicyAreas"),
                          AllAreas
                          );
    }


    if ( rc == ERROR_DATABASE_FAILURE ) {

        //
        // policy propagation category error - log to eventlog
        //

        LogEvent(MyModuleHandle,
                 STATUS_SEVERITY_ERROR,
                 SCEEVENT_ERROR_JET_DATABASE,
                 IDS_ERROR_OPEN_JET_DATABASE,
                 L"%windir%\\security\\database\\secedit.sdb"
                );

    }

    return rc;

}

DWORD
ScepPolStatusCallback(
    IN PFNSTATUSMESSAGECALLBACK pStatusCallback OPTIONAL,
    IN BOOL bVerbose,
    IN INT nId
    )
{
    if ( NULL  == pStatusCallback ) {
        // no callback
        return ERROR_SUCCESS;
    }

    if ( nId > 0 ) {

        TCHAR szMsg[MAX_PATH];

        if (LoadString (MyModuleHandle, nId, szMsg, MAX_PATH)) {

            pStatusCallback(bVerbose, szMsg);

            return ERROR_SUCCESS;
        }
    }

    pStatusCallback(bVerbose, NULL);

    return ERROR_SUCCESS;
}

BOOL
ScepShouldTerminateProcessing(
    IN BOOL *pbAbort,
    IN BOOL bCheckDcpromo
    )
/*
    Check if the policy propagation should be terminated. There are two
    conditions: 1) system is requesting a shutdown
                2) dcpromo is going on
*/
{
    if ( pbAbort && *pbAbort ) {
        SetLastError( ERROR_OPERATION_ABORTED );
        return TRUE;
    }

    if ( bCheckDcpromo ) {

        DWORD dwPolicyPropOff=0;

        ScepRegQueryIntValue(
            HKEY_LOCAL_MACHINE,
            SCE_ROOT_PATH,
            TEXT("PolicyPropOff"),
            &dwPolicyPropOff
            );

        if ( dwPolicyPropOff ) {
            SetLastError( ERROR_SERVICE_ALREADY_RUNNING );
            return TRUE;
        }
    }

    return FALSE;
}


DWORD
ScepProcessSecurityPolicyInOneGPO(
    IN BOOL bPlanningMode,
    IN DWORD dwFlags,
    IN PGROUP_POLICY_OBJECT pGpoInfo,
    IN LPTSTR szLogFileName OPTIONAL,
    IN OUT AREA_INFORMATION *pTotalArea
    )
{
    //
    // build the template name and log name
    //
    if ( pGpoInfo == NULL || pGpoInfo->lpFileSysPath == NULL) {
        return(ERROR_INVALID_PARAMETER);
    }

    DWORD rc;
    DWORD nRequired=0;
    LPTSTR szTemplateName=NULL;

    //
    // build security template name for this GPO
    //
    nRequired = lstrlen(pGpoInfo->lpFileSysPath)+2+
                lstrlen(GPTSCE_TEMPLATE);
    szTemplateName = (LPTSTR)LocalAlloc(0, nRequired*sizeof(TCHAR));

    if ( szTemplateName ) {

        swprintf(szTemplateName, L"%s\\%s\0",
                 pGpoInfo->lpFileSysPath,
                 GPTSCE_TEMPLATE);

        //
        // detect what area is available in the template
        //

        AREA_INFORMATION Area = ScepGetAvailableArea(bPlanningMode,
                                                     pGpoInfo->lpFileSysPath,
                                                     pGpoInfo->lpDSPath,
                                                     szTemplateName,
                                                     pGpoInfo->GPOLink,
                                                     gbThisIsDC);

        //
        // if Area is 0, there must be an error occured to open the template
        //
        if ( Area == 0 ) {
            rc = GetLastError();
        } else {
            rc = 0;
        }

        *pTotalArea |= Area;

        //
        // log GPT header information into the log file
        //

        if ( Area == 0 && rc != 0 ) {
            //
            // template can't be accessed, log the error to event log
            // don't log it if this is a DC (so all GPOs are accessed locally)
            // bug the DC is too busy (rc = 1450)
            //
            if ( !gbThisIsDC || ( ERROR_NO_SYSTEM_RESOURCES != rc) ) {

                LogEventAndReport(MyModuleHandle,
                                  szLogFileName,
                                  STATUS_SEVERITY_ERROR,
                                  SCEPOL_ERROR_PROCESS_GPO,
                                  IDS_ERROR_ACCESS_TEMPLATE,
                                  rc,
                                  szTemplateName
                                  );
            }

        } else if ( szLogFileName ) {

            if ( Area == 0 ) {
                //
                // template not defined at this level
                //
                LogEventAndReport(MyModuleHandle,
                                  szLogFileName,
                                  0,
                                  0,
                                  IDS_INFO_NO_TEMPLATE,
                                  pGpoInfo->lpFileSysPath
                                  );

            } else{
                //
                // process the template
                //
                LogEventAndReport(MyModuleHandle,
                                  szLogFileName,
                                  0,
                                  0,
                                  IDS_INFO_COPY_TEMPLATE,
                                  szTemplateName
                                  );

                HANDLE hfTemp = CreateFile(szLogFileName,
                                           GENERIC_WRITE,
                                           FILE_SHARE_READ,
                                           NULL,
                                           OPEN_ALWAYS,
                                           FILE_ATTRIBUTE_NORMAL,
                                           NULL);

                if ( hfTemp != INVALID_HANDLE_VALUE ) {

                    DWORD dwBytesWritten;

                    SetFilePointer (hfTemp, 0, NULL, FILE_BEGIN);

                    BYTE TmpBuf[3];
                    TmpBuf[0] = 0xFF;
                    TmpBuf[1] = 0xFE;
                    TmpBuf[2] = 0;

                    WriteFile (hfTemp, (LPCVOID)TmpBuf, 2,
                               &dwBytesWritten,
                               NULL);

                    SetFilePointer (hfTemp, 0, NULL, FILE_END);

//                    ScepWriteVariableUnicodeLog( hfTemp, FALSE, "\tGPO Area %x Flag %x (", Area, dwFlags);

                    BOOL bCRLF;

                    if ( dwFlags & GPO_INFO_FLAG_BACKGROUND )
                        bCRLF = FALSE;
                    else
                        bCRLF = TRUE;

                    switch ( pGpoInfo->GPOLink ) {
                    case GPLinkDomain:
                        ScepWriteSingleUnicodeLog(hfTemp, bCRLF, L"GPLinkDomain ");
                        break;
                    case GPLinkMachine:
                        ScepWriteSingleUnicodeLog(hfTemp, bCRLF, L"GPLinkMachine ");
                        break;
                    case GPLinkSite:
                        ScepWriteSingleUnicodeLog(hfTemp, bCRLF, L"GPLinkSite ");
                        break;
                    case GPLinkOrganizationalUnit:
                        ScepWriteSingleUnicodeLog(hfTemp, bCRLF, L"GPLinkOrganizationUnit ");
                        break;
                    default:
                        ScepWriteVariableUnicodeLog(hfTemp, bCRLF, L"0x%x ", pGpoInfo->GPOLink);
                        break;
                    }

                    if ( dwFlags & GPO_INFO_FLAG_BACKGROUND )
                        ScepWriteSingleUnicodeLog(hfTemp, TRUE, L"GPO_INFO_FLAG_BACKGROUND )");

//                    if ( pGpoInfo->pNext == NULL )  // last one
//                        ScepWriteVariableUnicodeLog( hfTemp, FALSE, " Total area %x", *pTotalArea);

                    CloseHandle(hfTemp);

                }
            }
        }

        LocalFree(szTemplateName);

    } else {
        rc = ERROR_NOT_ENOUGH_MEMORY;
    }

    return rc;
}


AREA_INFORMATION
ScepGetAvailableArea(
    IN BOOL bPlanningMode,
    IN LPCTSTR SysPathRoot,
    IN LPCTSTR DSPath,
    IN LPTSTR InfName,
    IN GPO_LINK LinkInfo,
    IN BOOL bIsDC
    )
{
    int index=0;
    TCHAR Windir[MAX_PATH];
    TCHAR Buffer[MAX_PATH+50], Buf2[MAX_PATH+50];

    Windir[0] = L'\0';
    GetSystemWindowsDirectory(Windir, MAX_PATH);
    Windir[MAX_PATH-1] = L'\0';
    Buffer[MAX_PATH+49] = L'\0';
    Buf2[MAX_PATH+49] = L'\0';

    intptr_t            hFile;
    struct _wfinddata_t    FileInfo;

    if (bPlanningMode) {
        swprintf(Buf2,
                 L"%s"PLANNING_GPT_DIR L"tmpgptfl.inf\0",
                 Windir);
    }
    else {
        swprintf(Buf2,
                 L"%s"DIAGNOSIS_GPT_DIR L"tmpgptfl.inf\0",
                 Windir);
    }

    DeleteFile(Buf2);
    CopyFile( InfName, Buf2, FALSE );

    SetLastError(ERROR_SUCCESS);

    AREA_INFORMATION Area = SceGetAreas(Buf2);

    if ( Area != 0 ) {

        //
        // for diagnosis mode
        // copy the template to local machine %windir%\\security\\templates\\policies\gpt*.* (inf or dom)
        // for planning mode
        // copy the template to local machine %TMP%\\guid\gpt*.* (inf or dom)
        //

        if (bPlanningMode) {
            swprintf(Buffer,
                     L"%s"PLANNING_GPT_DIR L"gpt%05d.*\0",
                     Windir , index);
        }
        else {
            swprintf(Buffer,
                     L"%s"DIAGNOSIS_GPT_DIR L"gpt%05d.*\0",
                     Windir, index);
        }

        hFile = _wfindfirst(Buffer, &FileInfo);

        while ( hFile != -1 ) {

            _findclose(hFile);

            index++;

            if (bPlanningMode) {
                swprintf(Buffer,
                         L"%s"PLANNING_GPT_DIR L"gpt%05d.*\0",
                         Windir, index);
            }
            else {
                swprintf(Buffer,
                         L"%s"DIAGNOSIS_GPT_DIR L"gpt%05d.*\0",
                         Windir, index);
            }

            hFile = _wfindfirst(Buffer, &FileInfo);
        }

        DWORD Len=wcslen(Buffer);

        if ( LinkInfo == GPLinkDomain ) {
            //
            // this is a domain GPO
            //
            Buffer[Len-1] = L'd';
            Buffer[Len] = L'o';
            Buffer[Len+1] = L'm';
            Buffer[Len+2] = L'\0';
        } else {
            //
            // this is not domain GPO
            //
            Buffer[Len-1] = L'i';
            Buffer[Len] = L'n';
            Buffer[Len+1] = L'f';
            Buffer[Len+2] = L'\0';

            if ( bIsDC ) {
/*
                LogEvent(MyModuleHandle,
                         STATUS_SEVERITY_INFORMATIONAL,
                         SCEPOL_INFO_IGNORE_DOMAINPOLICY,
                         0,
                         SysPathRoot
                        );
*/
            }
        }

        if ( FALSE == CopyFile( Buf2, Buffer, FALSE ) ) {
            //
            // copy failed, report error (GetLastError)
            //
            Area = 0;
        } else {
            //
            // save the GPO sys path in this template
            //
            PWSTR pTemp = wcsstr(_wcsupr((LPTSTR)SysPathRoot), L"\\POLICIES");

            if ( pTemp && *(pTemp+10) != L'\0' ) {

                WritePrivateProfileString (TEXT("Version"),
                                           TEXT("GPOPath"),
                                           pTemp+10,
                                           Buffer);
            } else {
                WritePrivateProfileString (TEXT("Version"),
                                           TEXT("GPOPath"),
                                           NULL,
                                           Buffer);
            }

            //
            // save the stripped GPO DS path in this template to extract canonical GPOID later
            //
            UINT Len = 0;

            PWSTR GpoPath = NULL;

            if (DSPath &&
                (Len = wcslen(DSPath)) &&
                (GpoPath = (PWSTR) ScepAlloc(LMEM_ZEROINIT, (Len + 3) * sizeof(WCHAR)))){

                    swprintf(GpoPath,
                             L"\"%s\"",
                             ScepStripPrefix((LPTSTR)DSPath)
                            );

                    WritePrivateProfileString (TEXT("Version"),
                                               TEXT("DSPath"),
                                               GpoPath,
                                               Buffer);

                    ScepFree(GpoPath);

            }

            else

                WritePrivateProfileString (TEXT("Version"),
                                           TEXT("DSPath"),
                                           TEXT("NoName"),
                                           Buffer);

            //
            // save the GPO LinkInfo in this template to extract SOMID later
            //
            WCHAR   StringBuf[10];

            _itow((int)LinkInfo, StringBuf, 10);

            WritePrivateProfileString (TEXT("Version"),
                                       TEXT("SOMID"),
                                       StringBuf,
                                       Buffer);


        }

    } else if ( GetLastError() == ERROR_FILE_NOT_FOUND ||
                GetLastError() == ERROR_PATH_NOT_FOUND ) {
        //
        // two reasons that this will fail:
        // first, the template does not exist; second, FRS/sysvol/network failed
        //

        if ( 0xFFFFFFFF == GetFileAttributes((LPTSTR)SysPathRoot) ) {

            SetLastError(ERROR_PATH_NOT_FOUND);
        } else {
            //
            // the sysvol/network is ok so SCE template is not there (including sub directories)
            //
            SetLastError(ERROR_SUCCESS);

        }

    }

    return(Area);
}


AREA_INFORMATION
SceGetAreas(
    LPTSTR InfName
    )
{
    if ( InfName == NULL ) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return 0;
    }

    SCESTATUS rc;
    HINF hInf;
    INFCONTEXT    InfLine;
    AREA_INFORMATION Area=0;

    rc = SceInfpOpenProfile(
                InfName,
                &hInf
                );

    if ( SCESTATUS_SUCCESS == rc ) {

        //
        // policy attachments sections can't be determined here. So always take security policy section
        //

        if( SetupFindFirstLine(hInf, szSystemAccess, NULL, &InfLine) ||
            SetupFindFirstLine(hInf, szAuditSystemLog, NULL, &InfLine) ||
            SetupFindFirstLine(hInf, szAuditSecurityLog, NULL, &InfLine) ||
            SetupFindFirstLine(hInf, szAuditApplicationLog, NULL, &InfLine) ||
            SetupFindFirstLine(hInf, szAuditEvent, NULL, &InfLine) ||
            SetupFindFirstLine(hInf, szKerberosPolicy, NULL, &InfLine) ||
            SetupFindFirstLine(hInf, szRegistryValues, NULL, &InfLine) ) {

            Area |= AREA_SECURITY_POLICY;

        } else {

            PSCE_NAME_LIST pList=NULL, pTemp;

            rc = ScepEnumerateAttachments(&pList, SCE_ATTACHMENT_POLICY);

            if ( ERROR_SUCCESS == rc && pList ) {
                //
                // find policy attachments
                //
                for ( pTemp = pList; pTemp != NULL; pTemp = pTemp->Next ) {
                    if ( SetupFindFirstLine(hInf, pTemp->Name, NULL, &InfLine) ) {
                        Area |= AREA_SECURITY_POLICY;
                        break;
                    }
                }

                ScepFreeNameList(pList);
            }
        }

        if(SetupFindFirstLine(hInf,szPrivilegeRights,NULL,&InfLine)) {
            Area |= AREA_PRIVILEGES;
        }

        if(SetupFindFirstLine(hInf,szGroupMembership,NULL,&InfLine)) {
            Area |= AREA_GROUP_MEMBERSHIP;
        }

        if(SetupFindFirstLine(hInf,szRegistryKeys,NULL,&InfLine)) {
            Area |= AREA_REGISTRY_SECURITY;
        }

        if(SetupFindFirstLine(hInf,szFileSecurity,NULL,&InfLine)) {
            Area |= AREA_FILE_SECURITY;
        }
#if 0
        if(SetupFindFirstLine(hInf,szDSSecurity,NULL,&InfLine)) {
            Area |= AREA_DS_OBJECTS;
        }
#endif
        if(SetupFindFirstLine(hInf,szServiceGeneral,NULL,&InfLine)) {
            Area |= AREA_SYSTEM_SERVICE;

        } else {

            PSCE_NAME_LIST pList=NULL, pTemp;

            rc = ScepEnumerateAttachments(&pList, SCE_ATTACHMENT_SERVICE);

            if ( ERROR_SUCCESS == rc && pList ) {
                //
                // find policy attachments
                //
                for ( pTemp = pList; pTemp != NULL; pTemp = pTemp->Next ) {
                    if ( SetupFindFirstLine(hInf, pTemp->Name, NULL, &InfLine) ) {
                        Area |= AREA_SYSTEM_SERVICE;
                        break;
                    }
                }

                ScepFreeNameList(pList);
            }
        }

        //
        // close the inf file
        //
        SceInfpCloseProfile(hInf);

        SetLastError(ERROR_SUCCESS);
    }

    return Area;
}


BOOL
ScepClearGPObjects(
    IN BOOL bPlanningMode
    )
{

    TCHAR Windir[MAX_PATH], Buffer[MAX_PATH+50];
    DWORD   rc = ERROR_SUCCESS;

    Windir[0] = L'\0';
    GetSystemWindowsDirectory(Windir, MAX_PATH);
    Windir[MAX_PATH-1] = L'\0';

    // make sure policies or policies\planning directory exist
    // don't worry about errors - later it will be caught

    wcscpy(Buffer, Windir);
    wcscat(Buffer, DIAGNOSIS_GPT_DIR);
    CreateDirectory(Buffer, NULL);
    if (bPlanningMode) {
        wcscat(Buffer, L"planning");
        CreateDirectory(Buffer, NULL);
    }

    wcscpy(Buffer, Windir);
    wcscat(Buffer, (bPlanningMode ? PLANNING_GPT_DIR : DIAGNOSIS_GPT_DIR));

    if (!bPlanningMode)

        SetFileAttributes(Buffer, FILE_ATTRIBUTE_HIDDEN);

    wcscat(Buffer, L"gpt*.*");

    intptr_t            hFile;
    struct _wfinddata_t    FileInfo;

    hFile = _wfindfirst(Buffer, &FileInfo);

    if ( hFile != -1 ) {

        do {

            Buffer[0] = L'\0';
            wcscpy(Buffer, Windir);
            wcscat(Buffer, (bPlanningMode ? PLANNING_GPT_DIR : DIAGNOSIS_GPT_DIR));
            wcscat(Buffer, FileInfo.name);

            if ( !DeleteFile(Buffer) ){
                rc = GetLastError();
                break;
            }

        } while ( _wfindnext(hFile, &FileInfo) == 0 );

        _findclose(hFile);
    }

    if (rc != ERROR_SUCCESS) {
        SetLastError(rc);
        return(FALSE);
    }

    return(TRUE);

}


DWORD
ScepWinlogonThreadFunc(
    IN LPVOID lpv
    )
/*
Routine Description:

    The working thread to apply slow GPT polices. These policies include file
    security, registry security, DS object security if on a DC,
    system service security, and any other SCE extensions security.

    The SCE library is loaded before this thread is created (in order to keep
    the ref count non zero) so the SCE library is freed when this thread exits.
    Memory allocated in the input argument (by primary thread) are freed in this
    thread too.

Arguments:

    lpv     - the input info in ENGINEARGS structure, in which
                    szTemplateName is the group policy template name to apply
                    szLogName is the optional log file name

Return Value:

    Win32 errors
*/
{

    ENGINEARGS *pEA;
    DWORD rc;

    //
    // try-except block to ensure critical section is freed if this thread is entered
    // need two - due to two return's
    //

    if ( lpv ) {

        pEA = (ENGINEARGS *)lpv;


        if ( hSceDll ) {

            __try {

                //
                // need to initialize the COM library to use the unmarshalling functions
                //

                if (pEA->pStream) {

                    CoInitializeEx( NULL, COINIT_MULTITHREADED );

                    VOID *pV = NULL;

                    if (S_OK == CoGetInterfaceAndReleaseStream(pEA->pStream, IID_IWbemServices, &pV))
                        tg_pWbemServices = (IWbemServices *) pV;
                    else
                        tg_pWbemServices = NULL;
                }

                //
                // only apply template to the system if SCE library is loaded in memory
                // otherwise, access violation occurs when access code.
                //
                DWORD dConfigOpt = SCE_UPDATE_DB |
                                   SCE_POLICY_TEMPLATE |
                                   SCE_POLBIND_NO_AUTH;

                DWORD dwWinlogonLog=0;

                ScepRegQueryIntValue(
                                    HKEY_LOCAL_MACHINE,
                                    GPT_SCEDLL_NEW_PATH,
                                    TEXT("ExtensionDebugLevel"),
                                    &dwWinlogonLog
                                    );

                switch ( dwWinlogonLog ) {
                case 2:
                    dConfigOpt |= SCE_DEBUG_LOG;
                    break;
                case 1:
                    dConfigOpt |= SCE_VERBOSE_LOG;
                    break;
                default:
                    dConfigOpt |= SCE_DISABLE_LOG;
                }

                if (pEA->dwDiagOptions & SCE_RSOP_CALLBACK)
                    dConfigOpt |= SCE_RSOP_CALLBACK;

                rc = ScepSceStatusToDosError(
                                            ScepConfigSystem(
                                                            NULL,
                                                            pEA->szTemplateName,
                                                            NULL,
                                                            pEA->szLogName,
                                                            (tg_pWbemServices == NULL ? dConfigOpt & ~SCE_RSOP_CALLBACK : dConfigOpt), //rsop not supported
                                                            pEA->Area,
                                                            NULL,  // no callback
                                                            NULL,  // no callback window
                                                            NULL   // no warning
                                                            ));

                if (tg_pWbemServices) {
                    tg_pWbemServices->Release();
                    tg_pWbemServices = NULL;
                }

                if (pEA->pStream)
                    CoUninitialize();

                if (gpwszDCDomainName) {
                    LocalFree(gpwszDCDomainName);
                    gpwszDCDomainName = NULL;
                }

                if ( ERROR_SUCCESS == rc ) {
                    //
                    // Log the last config time
                    //
                    ScepLogLastConfigTime();
                }

                //
                // set status back to GP framework with the new API
                //

                ProcessGroupPolicyCompletedEx(
                                             &SceExtGuid,
                                             pEA->pHandle,
                                             rc,
                                             gHrAsynchRsopStatus); //WBEM_E_INVALID_PARAMETER

                //
                // free memory allocated by the primary thread
                //

                if ( pEA->szTemplateName ) {
                    LocalFree(pEA->szTemplateName);
                }
                if ( pEA->szLogName ) {
                    LocalFree(pEA->szLogName);
                }


                LocalFree(pEA);

            } __except(EXCEPTION_EXECUTE_HANDLER) {

                rc = (DWORD)EVENT_E_INTERNALEXCEPTION;

            }

            //
            // leave the cs before returning/exiting
            //

//            LeaveCriticalSection(&DiagnosisPolicypropSync);

            //
            // free library and exit the thread
            //

            FreeLibraryAndExitThread(hSceDll, rc );

            return(rc);

        } else {
            rc = ERROR_INVALID_PARAMETER;
        }


    } else {
        rc = ERROR_INVALID_PARAMETER;
    }

    //
    // the main spawner thread is relying on this thread to release the cs
    // before we exit this thread, under any circumstances, release the cs to enable other
    // diagnosis/policy prop threads to enter
    //

//    LeaveCriticalSection(&DiagnosisPolicypropSync);

    ExitThread(rc);

    return(rc);
}


DWORD
ScepLogLastConfigTime()
{

    DWORD  dCurrentSeconds=0;
    LARGE_INTEGER       CurrentTime;
    DWORD rc;
    NTSTATUS NtStatus;

    NtStatus = NtQuerySystemTime(&CurrentTime);

    if ( NT_SUCCESS(NtStatus) ) {

        //
        // Convert to seconds to save
        //

        if ( RtlTimeToSecondsSince1980 (&CurrentTime, &dCurrentSeconds) ) {

            rc = ScepRegSetIntValue(
                    HKEY_LOCAL_MACHINE,
                    SCE_ROOT_PATH,
                    TEXT("LastWinLogonConfig"),
                    dCurrentSeconds
                    );
        } else {
            rc = GetLastError();
        }

    } else {
        rc = RtlNtStatusToDosError(NtStatus);
    }

    return(rc);
}


DWORD
ScepEnumerateAttachments(
    OUT PSCE_NAME_LIST *pEngineList,
    IN SCE_ATTACHMENT_TYPE aType
    )
/*
Routine Description:

    Query all services which has a service engine for security manager
    The service engine information is in the registry:

    MACHINE\Software\Microsoft\Windows NT\CurrentVersion\SeCEdit

Arguments:

    pEngineList - the service engine name list

    aType - attachment type (service or policy)

Return Value:

    SCE status
*/
{
    if ( pEngineList == NULL ) {
        return(ERROR_INVALID_PARAMETER);
    }

    DWORD   Win32Rc;
    HKEY    hKey=NULL;

    switch ( aType ) {
    case SCE_ATTACHMENT_SERVICE:
        Win32Rc = RegOpenKeyEx(
                  HKEY_LOCAL_MACHINE,
                  SCE_ROOT_SERVICE_PATH,
                  0,
                  KEY_READ,
                  &hKey
                  );
        break;
    case SCE_ATTACHMENT_POLICY:

        Win32Rc = RegOpenKeyEx(
                  HKEY_LOCAL_MACHINE,
                  SCE_ROOT_POLICY_PATH,
                  0,
                  KEY_READ,
                  &hKey
                  );
        break;
    default:
        return ERROR_INVALID_PARAMETER;
    }

    if ( Win32Rc == ERROR_SUCCESS ) {

        TCHAR   Buffer[MAX_PATH];
        DWORD   BufSize;
        DWORD   index = 0;
        DWORD   EnumRc;

        //
        // enumerate all subkeys of the key
        //
        do {
            memset(Buffer, '\0', MAX_PATH*sizeof(WCHAR));
            BufSize = MAX_PATH;

            EnumRc = RegEnumKeyEx(
                            hKey,
                            index,
                            Buffer,
                            &BufSize,
                            NULL,
                            NULL,
                            NULL,
                            NULL);

            if ( EnumRc == ERROR_SUCCESS ) {
                index++;
                //
                // get the attachment name
                //

                Win32Rc = ScepAddToNameList(pEngineList, Buffer, BufSize+1);

                if ( Win32Rc != ERROR_SUCCESS ) {
                    break;
                }
            }

        } while ( EnumRc != ERROR_NO_MORE_ITEMS );

        RegCloseKey(hKey);

        //
        // remember the error code from enumeration
        //
        if ( EnumRc != ERROR_SUCCESS && EnumRc != ERROR_NO_MORE_ITEMS ) {
            if ( Win32Rc == ERROR_SUCCESS )
                Win32Rc = EnumRc;
        }

    }

    if ( Win32Rc != NO_ERROR && *pEngineList != NULL ) {
        //
        // free memory allocated for the list
        //

        ScepFreeNameList(*pEngineList);
        *pEngineList = NULL;
    }

    return( Win32Rc );

}


DWORD
WINAPI
SceProcessEFSRecoveryGPO(
    IN DWORD dwFlags,
    IN HANDLE hUserToken,
    IN HKEY hKeyRoot,
    IN PGROUP_POLICY_OBJECT pDeletedGPOList,
    IN PGROUP_POLICY_OBJECT pChangedGPOList,
    IN ASYNCCOMPLETIONHANDLE pHandle,
    IN BOOL *pbAbort,
    IN PFNSTATUSMESSAGECALLBACK pStatusCallback
    )
/*
Description:
    This is a interface called from winlogon/userenv to process GPOs. The dll
    name and procedure name are registered to winlogon under GpExtensions.

    This routine applies a EFS recovery policy to the current system. The EFS
    recovery policy is stored in registry as EfsBlob and will be loaded by
    the registry extension into hKeyRoot. So this extension requires that
    registry.pol must be loaded successfully by the registry extension.

    This interface can be called during system boot, or every GPFrequency hours
    after logon. The input argument contains info for where this interface is
    called and under which context (user, or machine) this interface is called.

    This interface shouldn't be called for user policy but within the routine,
    a checking is still made to make sure that user level policies is not processed.

Arguments:

    dwFlags     - the GPO Info flags
                        GPO_INFO_FLAG_MACHINE
                        GPO_INFO_FLAG_SLOWLINK
                        GPO_INFO_FLAG_BACKGROUND
                        GPO_INFO_FLAG_VERBOSE
                        GPO_INFO_FLAG_NOCHANGES

    hUserToken  - the user token for which the user policy should be applied
                    if it's the machine policy, hUserToken refers to system

    hKeyRoot    - the root for the policy in registry

    pDeletedGPOList - all deleted GPOs to process

    pChangedGPOList - all GPOs that are either changed or not changed

    pHandle     - for asynchronous processing

    pbAbort     - processing of GPO should be aborted if this is set to TRUE
                    (in case of system shutdown or user log off)

    pStatusCallback - Callback function for displaying status messages

Return Value:

    Win32 error
        ERROR_SUCCESS
        other errors

    Note, if error is returned, the previous cached GPO list will be used for
    next propagation (because it didn't succeed this time).

*/
{

    // validate input parameters
    if ( !hKeyRoot || !hUserToken ) {

        return(ERROR_INVALID_PARAMETER);
    }

    //Check if demote flag is set need to add Auth user and Interactive to users group.
    // group membership should be configured by SCE/demote via tattoo table. This is not needed
//    ScepCheckDemote();

    //
    // check if system is shutdown, or dcpromo is going
    //
    if ( ScepShouldTerminateProcessing( pbAbort, FALSE ) ) {

        return(ERROR_OPERATION_ABORTED);
    }

    DWORD rc;
    BOOL b;

    //
    // put a try except block in case arguments are invalid
    //

    __try {

        rc = RtlNtStatusToDosError( ScepIsSystemContext(hUserToken, &b) );

        (void) InitializeEvents(L"SceEfs");

        if ( !b ) {

            //
            // can't get current user SID or it's not system SID
            //

            if ( ERROR_SUCCESS != rc ) {

                //
                // error occurs when querying/comparing user token
                //

                LogEvent(MyModuleHandle,
                         STATUS_SEVERITY_ERROR,
                         SCEPOL_ERROR_PROCESS_GPO,
                         IDS_ERROR_GET_TOKEN_USER,
                         rc
                        );

                ShutdownEvents();

                return( rc );

            } else {

                //
                // this is not the machine (system) token, return
                //
                ShutdownEvents();

                return( ERROR_SUCCESS );
            }
        }

        //
        // check if system is shutdown, or dcpromo is going
        //
        if ( ScepShouldTerminateProcessing( pbAbort, FALSE ) ) {

            ShutdownEvents();
            return(ERROR_OPERATION_ABORTED);
        }

        //
        // check if debug log is requested
        //

        DWORD dwDebugLevel=0;
        ScepRegQueryIntValue(
                HKEY_LOCAL_MACHINE,  // always save the time in HKEY_LOCAL_MACHINE
                GPT_EFS_NEW_PATH,
                TEXT("ExtensionDebugLevel"),
                &dwDebugLevel
                );

        //
        // if there is no change to EFS policy
        //
        if ( dwFlags & GPO_INFO_FLAG_NOCHANGES ) {

            if ( dwDebugLevel ) {

                LogEvent(MyModuleHandle,
                        STATUS_SEVERITY_INFORMATIONAL,
                        SCEPOL_INFO_PROCESS_GPO,
                        IDS_EFS_NOT_CHANGE
                        );

                ShutdownEvents();
            }
            return(ERROR_SUCCESS);
        }

        //
        // process EFS policy
        //
        HKEY      hKey=NULL;
        DWORD     RegType=0;
        DWORD     dSize=0;

        PUCHAR    pEfsBlob=NULL;

        if ( (rc = RegOpenKeyEx(
                            hKeyRoot,
                            CERT_EFSBLOB_REGPATH,
                            0,
                            KEY_READ,
                            &hKey
                            )) == ERROR_SUCCESS ) {

            //
            // query value for EfsBlob
            //

            if(( rc = RegQueryValueEx(hKey,
                                 CERT_EFSBLOB_VALUE_NAME,
                                 0,
                                 &RegType,
                                 NULL,
                                 &dSize
                                )) == ERROR_SUCCESS ) {

                if ( REG_BINARY == RegType ) {

                    //
                    // must be binary type data
                    //

                    pEfsBlob = (PUCHAR)ScepAlloc( LMEM_ZEROINIT, dSize+1);

                    if ( !pEfsBlob ) {

                        rc = ERROR_NOT_ENOUGH_MEMORY;

                    } else {

                        rc = RegQueryValueEx(
                                   hKey,
                                   CERT_EFSBLOB_VALUE_NAME,
                                   0,
                                   &RegType,
                                   (BYTE *)pEfsBlob,
                                   &dSize
                                  );

                        if ( ERROR_SUCCESS != rc ) {

                            ScepFree(pEfsBlob);
                            pEfsBlob = NULL;
                            dSize = 0;

                        }

                    }

                } else {

                    rc = ERROR_INVALID_DATATYPE;

                }
            }

            RegCloseKey(hKey);
        }

        if ( rc == ERROR_FILE_NOT_FOUND ) {
            //
            // if the key or the value doesn't exist
            // ignore the error (no EFS policy)
            //
            rc = ERROR_SUCCESS;
        }

        //
        // if pEfsBlob is NULL, it means that there is no EFS policy defined
        //
        if ( ERROR_SUCCESS == rc ) {

            //
            // check if system is shutdown, or dcpromo is going
            //
            if ( !ScepShouldTerminateProcessing( pbAbort, FALSE ) ) {

                rc = ScepConfigureEFSPolicy( pEfsBlob, dSize, dwDebugLevel );
            } else {
                rc = GetLastError();
            }

            ScepFree(pEfsBlob);

        } else if ( dwDebugLevel ) {

            LogEvent(MyModuleHandle,
                     STATUS_SEVERITY_ERROR,
                     SCEPOL_INFO_PROCESS_GPO,
                     IDS_NO_EFS_TOTAL,
                     rc
                    );

        }

    } __except(EXCEPTION_EXECUTE_HANDLER) {

        rc = ERROR_INVALID_PARAMETER;
    }

    ShutdownEvents();

    return rc;
}

DWORD
ScepConfigureEFSPolicy(
    IN PUCHAR    pEfsBlob,
    IN DWORD dwSize,
    IN DWORD dwDebugLevel
    )
/*
Routine Description:

    This routine writes EFS recovery policy defined in the policy storage
    (all processed by the registry extension) to LSA storage.

Arguments:

    pEfsBlob - the EFS blob

Return Value:

    Win32 error code
*/
{

    DWORD     rc=ERROR_SUCCESS;
    NTSTATUS  NtStatus;
    BOOL      bSet;
    LSA_HANDLE              PolicyHandle=NULL;
    PPOLICY_DOMAIN_EFS_INFO Buffer=NULL;
    POLICY_DOMAIN_EFS_INFO  EfsInfo;

    //
    // only set to LSA if there is EFS policy defined in any level
    // NO EFS policy is defined as 0 certificated but the EFS blob shouldn't be NULL
    //
    // open LSA policy
    //

    bSet = TRUE;  // if to set EFS policy

    NtStatus = ScepOpenLsaPolicy(
                    MAXIMUM_ALLOWED, //GENERIC_ALL,
                    &PolicyHandle,
                    TRUE
                    );

    if (NT_SUCCESS(NtStatus)) {

         //
         // query existing EFS policy blob
         // ignore errors from query
         //

        NtStatus = LsaQueryDomainInformationPolicy(
                        PolicyHandle,
                        PolicyDomainEfsInformation,
                        (PVOID *)&Buffer
                        );
        if ( NT_SUCCESS(NtStatus) && Buffer ) {

            //
            // compare the length and/or buffer to determine if
            // blob is changed because every time data is set to LSA
            // EFS server will get notified even when policy
            // is changed.
            //

            if ( Buffer->InfoLength != dwSize ||
                 (Buffer->EfsBlob && pEfsBlob == NULL) ||
                 (Buffer->EfsBlob == NULL && pEfsBlob ) ||
                 (Buffer->EfsBlob &&
                  memcmp(pEfsBlob, Buffer->EfsBlob, (size_t)dwSize) != 0) ) {

                //
                // the new EFS blob is different than existing one
                //

                bSet = TRUE;

            } else {

                bSet = FALSE;
            }
        }

        //
        // free memory allocated by LSA
        //

        if ( Buffer ) {

            LsaFreeMemory((PVOID)Buffer);
            Buffer = NULL;
        }

        //
        // set EFS policy if bSet is TRUE
        //

        if ( bSet ) {

            EfsInfo.InfoLength = dwSize;
            EfsInfo.EfsBlob = pEfsBlob;

            NtStatus = LsaSetDomainInformationPolicy(
                            PolicyHandle,
                            PolicyDomainEfsInformation,
                            (PVOID)&EfsInfo
                            );

            rc = RtlNtStatusToDosError(NtStatus);

            if ( !NT_SUCCESS(NtStatus) ) {

                LogEvent(MyModuleHandle,
                        STATUS_SEVERITY_ERROR,
                        SCEPOL_ERROR_PROCESS_GPO,
                        IDS_SAVE_EFS,
                        rc,
                        dwSize
                        );

            } else if ( dwDebugLevel ) {

                LogEvent(MyModuleHandle,
                        STATUS_SEVERITY_INFORMATIONAL,
                        SCEPOL_INFO_PROCESS_GPO,
                        IDS_SAVE_EFS,
                        0,
                        dwSize
                        );
            }

        } else if ( dwDebugLevel ) {

            LogEvent(MyModuleHandle,
                    STATUS_SEVERITY_INFORMATIONAL,
                    SCEPOL_INFO_PROCESS_GPO,
                    IDS_EFS_NOT_CHANGE
                    );

        }

        //
        // close LSA policy
        //

        LsaClose(PolicyHandle);

    } else {

         rc = RtlNtStatusToDosError( NtStatus );

         LogEvent(MyModuleHandle,
                  STATUS_SEVERITY_ERROR,
                  SCEPOL_ERROR_PROCESS_GPO,
                  IDS_ERROR_OPEN_LSAEFS,
                  rc
                 );

    }

    return(rc);
}

DWORD
ScepWaitConfigSystem(
    IN LPTSTR SystemName OPTIONAL,
    IN PWSTR InfFileName OPTIONAL,
    IN PWSTR DatabaseName OPTIONAL,
    IN PWSTR LogFileName OPTIONAL,
    IN DWORD ConfigOptions,
    IN AREA_INFORMATION Area,
    IN PSCE_AREA_CALLBACK_ROUTINE pCallback OPTIONAL,
    IN HANDLE hCallbackWnd OPTIONAL,
    OUT PDWORD pdWarning OPTIONAL
    )
{

    INT cnt=0;
    DWORD rc;

    while (cnt < 24) {

        rc = ScepSceStatusToDosError(
                ScepConfigSystem(
                    SystemName,
                    InfFileName,
                    DatabaseName,
                    LogFileName,
                    ConfigOptions,
                    Area,
                    pCallback,
                    hCallbackWnd,
                    pdWarning
                    ));

        if ( rc != ERROR_NOT_SUPPORTED ) {
            //
            // the server is initialized now.
            //
            break;
        }

        LogEventAndReport(MyModuleHandle,
                          LogFileName,
                          0,
                          0,
                          IDS_POLICY_TIMEOUT,
                          cnt+1
                          );

        Sleep(5000);  // 5 second
        cnt++;
    }

    return(rc);
}

/*
BOOL
ScepCheckDemote()
{
    //
    // If sucess lets see if user just did demote and reboot.
    //
    DWORD dwDemoteInProgress=0;

    ScepRegQueryIntValue(
            HKEY_LOCAL_MACHINE,
            SCE_ROOT_PATH,
            TEXT("DemoteInProgress"),
            &dwDemoteInProgress
            );

    if (dwDemoteInProgress) {

        DWORD    rc1;

        //
        // Attempt to add Authenticated Users and Interactive back into Users group.
        //

        SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;
        PSID AuthenticatedUsers = NULL;
        PSID Interactive = NULL;
        WCHAR Name[36];
        BOOL b;
        LOCALGROUP_MEMBERS_INFO_0 lgrmi0[2];
        HMODULE hMod = GetModuleHandle(L"scecli.dll");

        LoadString(hMod, IDS_NAME_USERS, Name, 36);
        b = AllocateAndInitializeSid (
                &NtAuthority,
                1,
                SECURITY_AUTHENTICATED_USER_RID,
                0, 0, 0, 0, 0, 0, 0,
                &AuthenticatedUsers
                );

        if (b) {
            lgrmi0[0].lgrmi0_sid = AuthenticatedUsers;

            b = AllocateAndInitializeSid (
                    &NtAuthority,
                    1,
                    SECURITY_INTERACTIVE_RID,
                    0, 0, 0, 0, 0, 0, 0,
                    &Interactive
                    );

            if (b) {
                lgrmi0[1].lgrmi0_sid = Interactive;
                rc1 = NetLocalGroupAddMembers(
                         NULL,
                         Name,
                         0,
                         (PBYTE) &lgrmi0,
                         2
                         );
            }
            else {
                if ( AuthenticatedUsers ) {
                    FreeSid( AuthenticatedUsers );
                }
                return FALSE;
            }

            if ( AuthenticatedUsers ) {
                FreeSid( AuthenticatedUsers );
            }

            if ( Interactive ) {
                FreeSid( Interactive );
            }

            if (rc1 == ERROR_SUCCESS) {
                // Need to delete the value.
                rc1 = ScepRegDeleteValue(
                       HKEY_LOCAL_MACHINE,
                       SCE_ROOT_PATH,
                       TEXT("DemoteInProgress")
                       );

                if ( rc1 != ERROR_SUCCESS &&
                     rc1 != ERROR_FILE_NOT_FOUND &&
                     rc1 != ERROR_PATH_NOT_FOUND ) {

                    // if can't delete the value, set the value to 0
                    ScepRegSetIntValue( HKEY_LOCAL_MACHINE,
                                        SCE_ROOT_PATH,
                                        TEXT("DemoteInProgress"),
                                        0
                                        );
                }
            }
            else {
                return FALSE;
            }
        }
        else {
            return FALSE;
        }
    }

    return TRUE;
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\scerpc\client\logger.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    logger.h (cgenericlogger.h derivation)

Abstract:

    This file contains derived class prototypes for logging RSOP security extension data to WMI.
    There is one class defined for each schema RSOP security extension class (see .mof file).

Author:

    Vishnu Patankar    (VishnuP)  7-April-2000

Environment:

    User Mode - Win32

Revision History:


--*/

#ifndef _logger_
#define _logger_

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Includes                                                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include "CGenericLogger.h"


typedef class DiagnosisStatusLogger SCEP_DIAGNOSIS_LOGGER;

/////////////////////////////////////////////////////////////////////
// Derived logger class prototype
//////////////////////////////////////////////////////////////////////


class RSOP_SecuritySettingNumericLogger : public CGenericLogger
{
public:
    RSOP_SecuritySettingNumericLogger( IWbemServices *pNamespace, PWSTR pwszGPOName,  const PWSTR pwszSOMID);
    HRESULT  Log( WCHAR *wcKeyName, DWORD  dwValue, DWORD  dwPrecedence);
    ~RSOP_SecuritySettingNumericLogger();
private:

    // Data unique to this schema class


    XBStr   m_xbstrKeyName;
    XBStr   m_xbstrSetting;

};

class RSOP_SecuritySettingBooleanLogger : public CGenericLogger
{
public:
    RSOP_SecuritySettingBooleanLogger( IWbemServices *pNamespace, PWSTR pwszGPOName,  const PWSTR pwszSOMID);
    HRESULT  Log( WCHAR *wcKeyName, DWORD  dwValue, DWORD  dwPrecedence);
    ~RSOP_SecuritySettingBooleanLogger();
private:

    // Data unique to this schema class


    XBStr   m_xbstrKeyName;
    XBStr   m_xbstrSetting;
};

class RSOP_SecuritySettingStringLogger : public CGenericLogger
{
public:
    RSOP_SecuritySettingStringLogger( IWbemServices *pNamespace, PWSTR pwszGPOName,  const PWSTR pwszSOMID);
    HRESULT  Log( WCHAR *wcKeyName, PWSTR  pwszValue, DWORD  dwPrecedence);
    ~RSOP_SecuritySettingStringLogger();
private:

    // Data unique to this schema class


    XBStr   m_xbstrKeyName;
    XBStr   m_xbstrSetting;
};

class RSOP_AuditPolicyLogger : public CGenericLogger
{
public:
    RSOP_AuditPolicyLogger( IWbemServices *pNamespace, PWSTR pwszGPOName,  const PWSTR pwszSOMID);
    HRESULT  Log( WCHAR *wcCategory, DWORD  dwValue, DWORD  dwPrecedence);
    ~RSOP_AuditPolicyLogger();
private:

    // Data unique to this schema class


    XBStr   m_xbstrCategory;
    XBStr   m_xbstrSuccess;
    XBStr   m_xbstrFailure;
};

class RSOP_SecurityEventLogSettingNumericLogger : public CGenericLogger
{
public:
    RSOP_SecurityEventLogSettingNumericLogger( IWbemServices *pNamespace, PWSTR pwszGPOName,  const PWSTR pwszSOMID);
    HRESULT  Log( WCHAR *wcKeyName, PWSTR  pwszType, DWORD  dwValue, DWORD  dwPrecedence);
    ~RSOP_SecurityEventLogSettingNumericLogger();
private:

    // Data unique to this schema class


    XBStr   m_xbstrType;
    XBStr   m_xbstrKeyName;
    XBStr   m_xbstrSetting;
};

class RSOP_SecurityEventLogSettingBooleanLogger : public CGenericLogger
{
public:
    RSOP_SecurityEventLogSettingBooleanLogger( IWbemServices *pNamespace, PWSTR pwszGPOName,  const PWSTR pwszSOMID);
    HRESULT  Log( WCHAR *wcKeyName, PWSTR  pwszType, DWORD  dwValue, DWORD  dwPrecedence);
    ~RSOP_SecurityEventLogSettingBooleanLogger();
private:

    // Data unique to this schema class


    XBStr   m_xbstrType;
    XBStr   m_xbstrKeyName;
    XBStr   m_xbstrSetting;
};

class RSOP_RegistryValueLogger : public CGenericLogger
{
public:
    RSOP_RegistryValueLogger( IWbemServices *pNamespace, PWSTR pwszGPOName,  const PWSTR pwszSOMID);
    HRESULT  Log( WCHAR *wcPath, DWORD  dwType, PWSTR  pwszData, DWORD  dwPrecedence);
    ~RSOP_RegistryValueLogger();
private:

    // Data unique to this schema class


    XBStr   m_xbstrType;
    XBStr   m_xbstrPath;
    XBStr   m_xbstrData;

};

class RSOP_UserPrivilegeRightLogger : public CGenericLogger
{
public:
    RSOP_UserPrivilegeRightLogger( IWbemServices *pNamespace, PWSTR pwszGPOName,  const PWSTR pwszSOMID);
    HRESULT  Log( WCHAR *wcUserRight, PSCE_NAME_LIST  pList, DWORD  dwPrecedence);
    ~RSOP_UserPrivilegeRightLogger();
private:

    // Data unique to this schema class


    XBStr   m_xbstrUserRight;
    XBStr   m_xbstrAccountList;

};

class RSOP_RestrictedGroupLogger : public CGenericLogger
{
public:
    RSOP_RestrictedGroupLogger( IWbemServices *pNamespace, PWSTR pwszGPOName,  const PWSTR pwszSOMID);
    HRESULT  Log( WCHAR *wcGroupName, PSCE_NAME_LIST  pList, DWORD  dwPrecedence);
    ~RSOP_RestrictedGroupLogger();
private:

    // Data unique to this schema class


    XBStr   m_xbstrGroupName;
    XBStr   m_xbstrMembers;

};

class RSOP_SystemServiceLogger : public CGenericLogger
{
public:
    RSOP_SystemServiceLogger( IWbemServices *pNamespace, PWSTR pwszGPOName,  const PWSTR pwszSOMID);
    HRESULT  Log( WCHAR *wcService, BYTE  m_byStartupMode, PSECURITY_DESCRIPTOR pSecurityDescriptor, SECURITY_INFORMATION SeInfo, DWORD  dwPrecedence);
    ~RSOP_SystemServiceLogger();
private:

    // Data unique to this schema class


    XBStr   m_xbstrService;
    XBStr   m_xbstrStartupMode;
    XBStr   m_xbstrSDDLString;

};

class RSOP_FileLogger : public CGenericLogger
{
public:
    RSOP_FileLogger( IWbemServices *pNamespace, PWSTR pwszGPOName,  const PWSTR pwszSOMID);
    HRESULT  Log( WCHAR *wcPath, WCHAR *wcOriginalPath, BYTE  m_byMode, PSECURITY_DESCRIPTOR pSecurityDescriptor, SECURITY_INFORMATION SeInfo, DWORD  dwPrecedence);
    ~RSOP_FileLogger();
private:

    // Data unique to this schema class


    XBStr   m_xbstrPath;
    XBStr   m_xbstrOriginalPath;
    XBStr   m_xbstrMode;
    XBStr   m_xbstrSDDLString;

};

class RSOP_RegistryKeyLogger : public CGenericLogger
{
public:
    RSOP_RegistryKeyLogger( IWbemServices *pNamespace, PWSTR pwszGPOName,  const PWSTR pwszSOMID);
    HRESULT Log( WCHAR *wcPath, BYTE  m_byMode, PSECURITY_DESCRIPTOR pSecurityDescriptor, SECURITY_INFORMATION SeInfo, DWORD  dwPrecedence);
    ~RSOP_RegistryKeyLogger();
private:

    // Data unique to this schema class

    XBStr   m_xbstrPath;
    XBStr   m_xbstrMode;
    XBStr   m_xbstrSDDLString;
};

//
// this is the class used to log diagnosis data via the callback
//
class DiagnosisStatusLogger : public CGenericLogger
{
public:
    DiagnosisStatusLogger( IWbemServices *pNamespace, PWSTR pwszGPOName,  const PWSTR pwszSOMID);
//    HRESULT  Log( PWSTR pwszClassName,  PWSTR pwszPropertyName, PWSTR pwszPropertyValueName, DWORD  dwError);
    HRESULT  Log( PWSTR pwszClassName,  PWSTR pwszPropertyName1, PWSTR pwszPropertyValueName1, PWSTR pwszPropertyName2, PWSTR pwszPropertyValueName2, DWORD  dwError);
    HRESULT  Log( PWSTR pwszClassName,  PWSTR pwszPropertyName, PWSTR pwszPropertyValueName, DWORD  dwError, BOOL Merge);
    HRESULT  LogChild( PWSTR pwszClassName,  PWSTR pwszPropertyName, PWSTR pwszPropertyValueName, DWORD  dwError, int iChildStatus);
#ifdef _WIN64
    HRESULT  LogRegistryKey( PWSTR pwszClassName,  PWSTR pwszPropertyName, PWSTR pwszPropertyValueName, DWORD  dwError, BOOL bIsChild);
#endif
    ~DiagnosisStatusLogger();
private:

};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\scerpc\client\precedence.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    precedence.cpp

Abstract:

    This file contains the main routine to calculate precedences.
    This is called during planning/diagnosis.

Author:

    Vishnu Patankar    (VishnuP)  7-April-2000

Environment:

    User Mode - Win32

Revision History:


--*/

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Includes                                                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include "precedence.h"
#include "logger.h"
#include "infp.h"
#include "headers.h"
#include "align.h"
#include "..\sceutil.h"
#include <io.h>
#include "scerpc.h"

extern BOOL    gbAsyncWinlogonThread;
extern HRESULT gHrSynchRsopStatus;
extern HRESULT gHrAsynchRsopStatus;
extern BOOL gbThisIsDC;
extern BOOL gbDCQueried;
extern PWSTR gpwszDCDomainName;
extern HINSTANCE MyModuleHandle;
WCHAR   gpwszPlanOrDiagLogFile[MAX_PATH];

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Private defines                                                           //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#define SCEP_VALID_NAME(pName)  (pName[0] == L'\0' ? NULL : pName)

//
// prime nos are good for hashing
//

#define PRIVILEGE_TABLE_SIZE 7
#define GROUP_TABLE_SIZE 7
#define REGISTRY_SECURITY_TABLE_SIZE 43
#define FILE_SECURITY_TABLE_SIZE 43
#define REGISTRY_VALUE_TABLE_SIZE 43
#define SERVICES_TABLE_SIZE 5

//
// macro to gracefully handle errors
//

#define SCEP_RSOP_CONTINUE_OR_BREAK    if (rc != NO_ERROR ) {\
                                        rcSave = rc;\
                                        if (rc == ERROR_NOT_ENOUGH_MEMORY)\
                                            break;\
                                       }

//
// macro to gracefully handle errors
//

#define SCEP_RSOP_CONTINUE_OR_GOTO    if (rc != NO_ERROR ) {\
                                        rcSave = rc;\
                                        if (rc == ERROR_NOT_ENOUGH_MEMORY)\
                                            goto Done;\
                                      }


const UINT   NumSchemaClasses = sizeof ScepRsopSchemaClassNames/ sizeof(PWSTR);

const UINT   NumSettings = sizeof PrecedenceLookup/ sizeof(SCE_KEY_LOOKUP_PRECEDENCE);

DWORD SceLogSettingsPrecedenceGPOs(
                                  IN IWbemServices   *pWbemServices,
                                  IN BOOL bPlanningMode,
                                  IN PWSTR *ppwszLogFile
                                  )
///////////////////////////////////////////////////////////////////////////////
// precedence algorithm                                                     ///
// foreach GPO (parse all gpt*.* into SceProfileInfoBuffer)                 ///
//      foreach setting in a GPO (log the values and precedences if present)///
///////////////////////////////////////////////////////////////////////////////
{
    PSCE_PROFILE_INFO pSceProfileInfoBuffer = NULL;
    PWSTR   pwszGPOName = NULL;
    PWSTR   pwszSOMID = NULL;
    DWORD   rc = ERROR_SUCCESS;
    DWORD   rcSave = ERROR_SUCCESS;
    BOOL    bKerberosBlob = FALSE;
    TCHAR Windir[MAX_PATH], TemplatePath[MAX_PATH+50];

    SCEP_HASH_TABLE    PrivilegeHashTable(PRIVILEGE_TABLE_SIZE);
    SCEP_HASH_TABLE    GroupHashTable(GROUP_TABLE_SIZE);
    SCEP_HASH_TABLE    RegistrySecurityHashTable(REGISTRY_SECURITY_TABLE_SIZE);
    SCEP_HASH_TABLE    FileSecurityHashTable(FILE_SECURITY_TABLE_SIZE);
    SCEP_HASH_TABLE    RegistryValueHashTable(REGISTRY_VALUE_TABLE_SIZE);
    SCEP_HASH_TABLE    ServicesHashTable(SERVICES_TABLE_SIZE);


    //
    // get the path to the templates
    //

    GetSystemWindowsDirectory(Windir, MAX_PATH);
    Windir[MAX_PATH-1] = L'\0';

    if (bPlanningMode) {
        swprintf(TemplatePath,
                 L"%s"PLANNING_GPT_DIR L"gpt*.*",
                 Windir);
    } else {
        swprintf(TemplatePath,
                 L"%s"DIAGNOSIS_GPT_DIR L"gpt*.*",
                 Windir);
    }


    gpwszPlanOrDiagLogFile[MAX_PATH-1] = L'\0';

    //
    // old planning.log/diagnosis.log removed (*ppwszLogFile != NULL if verbose)
    //

    if (*ppwszLogFile) {

        if (bPlanningMode) {
            wcscpy(gpwszPlanOrDiagLogFile, *ppwszLogFile);
        } else {

            wcscpy(gpwszPlanOrDiagLogFile, Windir);
            wcscat(gpwszPlanOrDiagLogFile, DIAGNOSIS_LOG_FILE);
        }

        WCHAR   szTmpName[MAX_PATH];

        wcscpy(szTmpName, gpwszPlanOrDiagLogFile);

        UINT    Len = wcslen(szTmpName);

        szTmpName[Len-3] = L'o';
        szTmpName[Len-2] = L'l';
        szTmpName[Len-1] = L'd';

        CopyFile( gpwszPlanOrDiagLogFile, szTmpName, FALSE );

        DeleteFile(gpwszPlanOrDiagLogFile);
    } else {

        gpwszPlanOrDiagLogFile[0] = L'\0';

    }


    //
    // clear the database log - if something fails continue
    //

    for (UINT   schemaClassNum = 0; schemaClassNum < NumSchemaClasses ; schemaClassNum++ ) {

        rc = ScepWbemErrorToDosError(DeleteInstances(
                                                    ScepRsopSchemaClassNames[schemaClassNum],
                                                    pWbemServices
                                                    ));
        if (rc != NO_ERROR)
            rcSave = rc;
    }


    ScepLogEventAndReport(MyModuleHandle,
                          gpwszPlanOrDiagLogFile,
                          0,
                          0,
                          IDS_CLEAR_RSOP_DB,
                          rcSave,
                          NULL
                         );

    //
    // need to process the files from gpt9999*  -> gpt0000* (opposite of jetdb merge)
    // use LIFO linked stack of gpt* filenames
    //

    intptr_t            hFile;
    struct _wfinddata_t    FileInfo;
    HINF hInf;

    hFile = _wfindfirst(TemplatePath, &FileInfo);

    PSCE_NAME_STATUS_LIST   pGptNameList = NULL;

    if ( hFile != -1 ) {

        do {

            if (ERROR_NOT_ENOUGH_MEMORY ==  (rc = ScepAddToNameStatusList(
                                                                         &pGptNameList,
                                                                         FileInfo.name,
                                                                         wcslen(FileInfo.name),
                                                                         0))) {

                _findclose(hFile);

                if (pGptNameList)
                    ScepFreeNameStatusList(pGptNameList);

                return ERROR_NOT_ENOUGH_MEMORY;
            }

        } while ( _wfindnext(hFile, &FileInfo) == 0 );

        _findclose(hFile);
    }


    //
    // first get all the GPOs, and some other info needed for logging
    // this is the outermost loop (per gpt*.* template)
    //

    PSCE_NAME_STATUS_LIST pCurrFileName = pGptNameList;

    while (pCurrFileName) {

        DWORD   dwAuditLogRetentionPeriod[] = {SCE_NO_VALUE, SCE_NO_VALUE, SCE_NO_VALUE};
        DWORD   dwLockoutBadCount = SCE_NO_VALUE;

        if (bPlanningMode) {
            swprintf(TemplatePath,
                     L"%s"PLANNING_GPT_DIR L"%s",
                     Windir, pCurrFileName->Name);
        } else {
            swprintf(TemplatePath,
                     L"%s"DIAGNOSIS_GPT_DIR L"%s",
                     Windir, pCurrFileName->Name);
        }

        //
        // open template file
        //

        rc = SceInfpOpenProfile(
                               TemplatePath,
                               &hInf
                               );

        DWORD dSize = 0;
        INFCONTEXT    InfLine;

        //
        // get GPO name - default to "NoName" if unable to get it
        //

        if (rc == ERROR_SUCCESS) {

            if ( SetupFindFirstLine(hInf,L"Version",L"DSPath",&InfLine) ) {

                if (SetupGetStringField(&InfLine,1,NULL,0,&dSize) && dSize > 0) {

                    pwszGPOName = (PWSTR)ScepAlloc( 0, (dSize+1)*sizeof(WCHAR));

                    if (!pwszGPOName) {

                        rc = SCESTATUS_NOT_ENOUGH_RESOURCE;

                        SceInfpCloseProfile(hInf);

                        goto NextGPO;
                    }

                    pwszGPOName[dSize] = L'\0';

                    SetupGetStringField(&InfLine,1,pwszGPOName,dSize, NULL);

                }

                else
                    rc = GetLastError();
            }

            else
                rc = GetLastError();

            if (rc != ERROR_SUCCESS) {

                //
                // log this error and continue this GPO by initializing pwszGPOName to "NoGPOName"
                //

                if (pwszGPOName)
                    ScepFree(pwszGPOName);

                rcSave = rc;

                pwszGPOName = (PWSTR)ScepAlloc( 0, (9+1)*sizeof(WCHAR));

                if (!pwszGPOName) {

                    rc = SCESTATUS_NOT_ENOUGH_RESOURCE;

                    rcSave = rc;

                    SceInfpCloseProfile(hInf);

                    goto NextGPO;
                }

                wcscpy(pwszGPOName, L"NoGPOName");

                ScepLogEventAndReport(MyModuleHandle,
                                      gpwszPlanOrDiagLogFile,
                                      0,
                                      0,
                                      IDS_ERROR_OPEN_CACHED_GPO,
                                      rc,
                                      TemplatePath
                                     );

            }

        } else {


            rcSave = rc;

            ScepLogEventAndReport(MyModuleHandle,
                                  gpwszPlanOrDiagLogFile,
                                  0,
                                  0,
                                  IDS_ERROR_OPEN_CACHED_GPO,
                                  rc,
                                  TemplatePath
                                 );

            //
            // will continue with next GPO
            //
            goto NextGPO;
        }


        //
        // get SOMID - default to "NoSOMID" if unable to get it
        //

        if ( SetupFindFirstLine(hInf,L"Version",L"SOMID",&InfLine) ) {

            if (SetupGetStringField(&InfLine,1,NULL,0,&dSize) && dSize > 0) {

                pwszSOMID = (PWSTR)ScepAlloc( 0, (dSize+1)*sizeof(WCHAR));

                pwszSOMID[dSize] = L'\0';

                SetupGetStringField(&InfLine,1,pwszSOMID,dSize, NULL);

            } else
                rc = GetLastError();
        } else
            rc = GetLastError();


        if (rc != ERROR_SUCCESS) {

            //
            // log this error and continue this GPO by initializing pwszGPOName to "NoGPOName"
            //

            if (pwszSOMID)
                ScepFree(pwszSOMID);

            rcSave = rc;

            pwszSOMID = (PWSTR)ScepAlloc( 0, (7 + 1)*sizeof(WCHAR));

            if (!pwszSOMID) {

                rc = SCESTATUS_NOT_ENOUGH_RESOURCE;

                rcSave = rc;

                SceInfpCloseProfile(hInf);

                goto NextGPO;
            }

            wcscpy(pwszSOMID, L"NoSOMID");


            ScepLogEventAndReport(MyModuleHandle,
                                  gpwszPlanOrDiagLogFile,
                                  0,
                                  0,
                                  IDS_ERROR_OPEN_CACHED_GPO,
                                  rc,
                                  TemplatePath
                                 );

        }

        rc = SceInfpGetSecurityProfileInfo(
                                          hInf,
                                          AREA_ALL,
                                          &pSceProfileInfoBuffer,
                                          NULL
                                          );

        if (rc != ERROR_SUCCESS) {

            rcSave = rc;

            SceInfpCloseProfile(hInf);

            ScepLogEventAndReport(MyModuleHandle,
                                  gpwszPlanOrDiagLogFile,
                                  0,
                                  0,
                                  IDS_ERROR_OPEN_CACHED_GPO,
                                  rc,
                                  TemplatePath
                                 );


            //
            // will continue with next GPO
            //
            goto NextGPO;

        }

        SceInfpCloseProfile(hInf);


        ScepLogEventAndReport(MyModuleHandle,
                              gpwszPlanOrDiagLogFile,
                              0,
                              0,
                              IDS_INFO_RSOP_LOG,
                              rc,
                              pwszGPOName
                             );

        //
        // now the info buffer is successfully populated - need to
        // iterate over all settings for this GPO
        //

        //
        // to efficiently access fields(settings) in the info buffer, we use a lookup table of
        // precomputed offsets
        //

        //
        // a matrix holds precedence info for fields whose locations are well known in memory
        // and hash-tables hold precedence info for fields whose locations are dynamic
        //

        //
        // try except around each log attempt - intention is to continue with next setting if
        // logging for current setting fails
        // guarded code does not explicitly throw any exceptions - error codes are set instead
        // so, if we get an exception it is thrown by the system in which case we ignore and continue
        //

        //
        // this is the second loop (setting per gpt*.* template)
        //

        bKerberosBlob = FALSE;

        for (UINT settingNo = 0; settingNo < NumSettings; settingNo++) {

            CHAR    settingType = PrecedenceLookup[settingNo].KeyLookup.BufferType;
            PWSTR   pSettingName = PrecedenceLookup[settingNo].KeyLookup.KeyString;
            UINT    settingOffset = PrecedenceLookup[settingNo].KeyLookup.Offset;
            DWORD   *pSettingPrecedence = &PrecedenceLookup[settingNo].Precedence;
            BOOL    bLogErrorOutsideSwitch = TRUE;

            //
            // depending on the schema class being processed, we instantiate logger objects
            //

            switch (settingType) {

            case    RSOP_SecuritySettingNumeric:

                try {

                    {

                        RSOP_SecuritySettingNumericLogger    Log(pWbemServices, pwszGPOName, pwszSOMID);

                        //
                        // special case kerberos since it is dynamically allocated
                        //

                        if (_wcsicmp(pSettingName, L"pKerberosInfo") == 0)
                            bKerberosBlob = TRUE;

                        if (bKerberosBlob == FALSE &&
                            (bPlanningMode ||
                             !(gbDCQueried == TRUE && gbThisIsDC == TRUE) ||
                             ((gbDCQueried == TRUE && gbThisIsDC == TRUE) && wcsstr(pCurrFileName->Name, L".dom")))) {

                            DWORD   dwValue =  SCEP_TYPECAST(DWORD, pSceProfileInfoBuffer, settingOffset);

                            if (dwValue != SCE_NO_VALUE) {

                                //
                                // LockoutBadCount controls two other lockout settings - so remember
                                //
                                if (_wcsicmp(pSettingName, L"LockoutBadCount") == 0)
                                    dwLockoutBadCount = dwValue;

                                //
                                // skip if dwLockoutBadCount == 0
                                //
                                if (_wcsicmp(pSettingName, L"ResetLockoutCount") == 0 &&
                                    (dwLockoutBadCount == 0 || dwLockoutBadCount == SCE_NO_VALUE))
                                    continue;

                                if (_wcsicmp(pSettingName, L"LockoutDuration") == 0 &&
                                    (dwLockoutBadCount == 0 || dwLockoutBadCount == SCE_NO_VALUE))
                                    continue;


                                rc = ScepWbemErrorToDosError(Log.Log(
                                                                    pSettingName,
                                                                    dwValue,
                                                                    ++(*pSettingPrecedence)
                                                                    ));

                                if (rc == NO_ERROR)

                                    ScepLogEventAndReport(MyModuleHandle,
                                                          gpwszPlanOrDiagLogFile,
                                                          0,
                                                          0,
                                                          IDS_INFO_RSOP_LOG,
                                                          rc,
                                                          pSettingName
                                                         );

                                if (rc != NO_ERROR)
                                    break;
                            }

                        } else if (bKerberosBlob == TRUE &&
                                   (bPlanningMode ||
                                   ((gbDCQueried == TRUE && gbThisIsDC == TRUE) && wcsstr(pCurrFileName->Name, L".dom")))) {

                            //
                            // kerberos only if DC from *.dom. If planning mode don't care type of m/c
                            //

                            PSCE_KERBEROS_TICKET_INFO   pKerberosInfo =
                            SCEP_TYPECAST(PSCE_KERBEROS_TICKET_INFO, pSceProfileInfoBuffer, settingOffset);

                            bLogErrorOutsideSwitch = FALSE;

                            if (pKerberosInfo) {

                                //
                                // kerberos numeric
                                //
                                for (UINT NumericSubSetting = 1; NumericSubSetting < NUM_KERBEROS_SUB_SETTINGS; NumericSubSetting++ ) {

                                    pSettingName = PrecedenceLookup[settingNo + NumericSubSetting].KeyLookup.KeyString;
                                    settingOffset = PrecedenceLookup[settingNo + NumericSubSetting].KeyLookup.Offset;
                                    pSettingPrecedence = &PrecedenceLookup[settingNo + NumericSubSetting].Precedence;
                                    DWORD   dwValue =  SCEP_TYPECAST(DWORD, pKerberosInfo, settingOffset);

                                    if (dwValue != SCE_NO_VALUE) {

                                        rc = ScepWbemErrorToDosError(Log.Log(
                                                                            pSettingName,
                                                                            dwValue,
                                                                            ++(*pSettingPrecedence)
                                                                            ));

                                        ScepLogEventAndReport(MyModuleHandle,
                                                              gpwszPlanOrDiagLogFile,
                                                              0,
                                                              0,
                                                              IDS_INFO_RSOP_LOG,
                                                              rc,
                                                              pSettingName
                                                             );


                                        SCEP_RSOP_CONTINUE_OR_BREAK
                                    }
                                }

                                //
                                //kerberos boolean (moved here to incompatible case: statement - to avoid a goto)
                                //

                                pSettingName = PrecedenceLookup[settingNo + NUM_KERBEROS_SUB_SETTINGS].KeyLookup.KeyString;
                                settingOffset = PrecedenceLookup[settingNo + NUM_KERBEROS_SUB_SETTINGS].KeyLookup.Offset;
                                pSettingPrecedence = &PrecedenceLookup[settingNo + NUM_KERBEROS_SUB_SETTINGS].Precedence;
                                DWORD   dwValue =  SCEP_TYPECAST(DWORD, pKerberosInfo, settingOffset);

                                RSOP_SecuritySettingBooleanLogger    Log(pWbemServices, pwszGPOName, pwszSOMID);

                                if (rc != ERROR_NOT_ENOUGH_MEMORY &&
                                    dwValue != SCE_NO_VALUE) {

                                    rc = ScepWbemErrorToDosError(Log.Log(
                                                                        pSettingName,
                                                                        dwValue,
                                                                        ++(*pSettingPrecedence)
                                                                        ));

                                    ScepLogEventAndReport(MyModuleHandle,
                                                          gpwszPlanOrDiagLogFile,
                                                          0,
                                                          0,
                                                          IDS_INFO_RSOP_LOG,
                                                          rc,
                                                          pSettingName
                                                         );

                                    if (rc != NO_ERROR ) {

                                        rcSave = rc;

                                    }
                                }
                            }

                        }

                        //
                        // just processed NUM_KERBEROS_SUB_SETTINGS
                        //

                        if (bKerberosBlob)

                            settingNo += NUM_KERBEROS_SUB_SETTINGS;

                    }

                } catch (...) {
                    //
                    // system error  continue with next setting
                    //
                    rc = EVENT_E_INTERNALEXCEPTION;

                    bLogErrorOutsideSwitch = TRUE;
                }

                break;

            case    RSOP_SecuritySettingBoolean:


                try {

                    {

                        RSOP_SecuritySettingBooleanLogger    Log(pWbemServices, pwszGPOName, pwszSOMID);

                        DWORD   dwValue =  SCEP_TYPECAST(DWORD, pSceProfileInfoBuffer, settingOffset);

                        if (dwValue != SCE_NO_VALUE) {

                            rc = ScepWbemErrorToDosError(Log.Log(
                                                                pSettingName,
                                                                dwValue,
                                                                ++(*pSettingPrecedence)
                                                                ));

                            if (rc == NO_ERROR)

                                ScepLogEventAndReport(MyModuleHandle,
                                                      gpwszPlanOrDiagLogFile,
                                                      0,
                                                      0,
                                                      IDS_INFO_RSOP_LOG,
                                                      rc,
                                                      pSettingName
                                                     );

                            if (rc != NO_ERROR)
                                break;
                        }


                    }

                } catch (...) {
                    //
                    // system error  continue with next setting
                    //
                    rc = EVENT_E_INTERNALEXCEPTION;
                }

                break;

            case    RSOP_SecuritySettingString:

                try {

                    {

                        RSOP_SecuritySettingStringLogger    Log(pWbemServices, pwszGPOName, pwszSOMID);

                        PWSTR   pszValue =  SCEP_TYPECAST(PWSTR, pSceProfileInfoBuffer, settingOffset);

                        if (pszValue != NULL) {

                            rc = ScepWbemErrorToDosError(Log.Log(
                                                                pSettingName,
                                                                pszValue,
                                                                ++(*pSettingPrecedence)
                                                                ));

                            if (rc == NO_ERROR)

                                ScepLogEventAndReport(MyModuleHandle,
                                                      gpwszPlanOrDiagLogFile,
                                                      0,
                                                      0,
                                                      IDS_INFO_RSOP_LOG,
                                                      rc,
                                                      pSettingName
                                                     );

                            if (rc != NO_ERROR)
                                break;
                        }
                    }

                } catch (...) {
                    // system error  continue with next setting
                    rc = EVENT_E_INTERNALEXCEPTION;
                }
                break;

            case    RSOP_AuditPolicy:
                {
                    RSOP_AuditPolicyLogger    Log(pWbemServices, pwszGPOName, pwszSOMID);

                    DWORD   dwValue =  SCEP_TYPECAST(DWORD, pSceProfileInfoBuffer, settingOffset);

                    if (dwValue != SCE_NO_VALUE) {

                        rc = ScepWbemErrorToDosError(Log.Log(
                                                            pSettingName,
                                                            dwValue,
                                                            ++(*pSettingPrecedence)
                                                            ));
                        if (rc == NO_ERROR)

                            ScepLogEventAndReport(MyModuleHandle,
                                                  gpwszPlanOrDiagLogFile,
                                                  0,
                                                  0,
                                                  IDS_INFO_RSOP_LOG,
                                                  rc,
                                                  pSettingName
                                                 );

                        if (rc != NO_ERROR)
                            break;
                    }
                }

                break;

            case    RSOP_SecurityEventLogSettingNumeric:

                try {

                    {

                        RSOP_SecurityEventLogSettingNumericLogger    Log(pWbemServices, pwszGPOName, pwszSOMID);

                        bLogErrorOutsideSwitch = FALSE;

                        for (UINT   LogType = 0; LogType < NUM_EVENTLOG_TYPES ; LogType ++) {

                            settingOffset = PrecedenceLookup[settingNo + LogType].KeyLookup.Offset;
                            pSettingPrecedence = &PrecedenceLookup[settingNo + LogType].Precedence;
                            DWORD   dwValue =  SCEP_TYPECAST(DWORD, pSceProfileInfoBuffer, settingOffset);

                            //
                            // calculate dwValue depdending on dwAuditLogRetentionPeriod[]
                            //

                            if (_wcsicmp(pSettingName, L"RetentionDays") == 0) {

                                switch (dwAuditLogRetentionPeriod[LogType]) {
                                case 2:   // manually
                                    dwValue = MAXULONG;
                                    break;
                                case 1:   // number of days * seconds/day
                                    //if (dwValue != SCE_NO_VALUE)
                                    //dwValue = dwValue * 24 * 3600;
                                    //leave it in days
                                    break;
                                case 0:   // as needed
                                    dwValue = 0;
                                    break;
                                    // default should not happen
                                default:
                                    dwValue = SCE_NO_VALUE;
                                }
                            }

                            if (dwValue != SCE_NO_VALUE) {

                                WCHAR   pwszLogType[10];

                                _itow((int)LogType, pwszLogType, 10);

                                //
                                // AuditLogRetentionPeriod controls RetentionDays  - so remember
                                // also it is never logged since it is an artifact of the template spec
                                //

                                if (_wcsicmp(pSettingName, L"AuditLogRetentionPeriod") == 0) {

                                    dwAuditLogRetentionPeriod[LogType] = dwValue;
                                    ScepLogEventAndReport(MyModuleHandle,
                                                          gpwszPlanOrDiagLogFile,
                                                          0,
                                                          0,
                                                          IDS_INFO_RSOP_LOG,
                                                          LogType,
                                                          pSettingName
                                                         );

                                    continue;
                                }


                                rc = ScepWbemErrorToDosError(Log.Log(
                                                                    pSettingName,
                                                                    pwszLogType,
                                                                    dwValue,
                                                                    ++(*pSettingPrecedence)
                                                                    ));

                                ScepLogEventAndReport(MyModuleHandle,
                                                      gpwszPlanOrDiagLogFile,
                                                      0,
                                                      0,
                                                      IDS_INFO_RSOP_LOG,
                                                      LogType,
                                                      pSettingName
                                                     );

                                SCEP_RSOP_CONTINUE_OR_BREAK
                            }

                        }

                        //
                        // just processed NUM_EVENTLOG_TYPES - system, application, security, for this setting
                        //

                        settingNo +=  NUM_EVENTLOG_TYPES - 1;

                    }

                } catch (...) {
                    //
                    // system error  continue with next setting
                    //
                    rc = EVENT_E_INTERNALEXCEPTION;

                    bLogErrorOutsideSwitch = TRUE;
                }

                break;

            case    RSOP_SecurityEventLogSettingBoolean:

                try {

                    {

                        RSOP_SecurityEventLogSettingBooleanLogger    Log(pWbemServices, pwszGPOName, pwszSOMID);

                        bLogErrorOutsideSwitch = FALSE;

                        for (UINT   LogType = 0; LogType < NUM_EVENTLOG_TYPES ; LogType ++) {

                            settingOffset = PrecedenceLookup[settingNo + LogType].KeyLookup.Offset;
                            pSettingPrecedence = &PrecedenceLookup[settingNo + LogType].Precedence;
                            DWORD   dwValue =  SCEP_TYPECAST(DWORD, pSceProfileInfoBuffer, settingOffset);

                            if (dwValue != SCE_NO_VALUE) {

                                WCHAR   pwszLogType[10];

                                _itow((int)LogType, pwszLogType, 10);

                                rc = ScepWbemErrorToDosError(Log.Log(
                                                                    pSettingName,
                                                                    pwszLogType,
                                                                    dwValue,
                                                                    ++(*pSettingPrecedence)
                                                                    ));
                                ScepLogEventAndReport(MyModuleHandle,
                                                      gpwszPlanOrDiagLogFile,
                                                      0,
                                                      0,
                                                      IDS_INFO_RSOP_LOG,
                                                      rc,
                                                      pSettingName
                                                     );

                                SCEP_RSOP_CONTINUE_OR_BREAK
                            }

                        }

                        //
                        // processed NUM_EVENTLOG_TYPES - system, application, security, for this setting
                        //
                        settingNo +=  NUM_EVENTLOG_TYPES - 1;
                    }

                } catch (...) {
                    //
                    // system error  continue with next setting
                    //
                    rc = EVENT_E_INTERNALEXCEPTION;

                    bLogErrorOutsideSwitch = TRUE;

                }

                break;


            case    RSOP_RegistryValue:

                try {

                    {

                        RSOP_RegistryValueLogger    Log(pWbemServices, pwszGPOName, pwszSOMID);

                        DWORD   dwRegCount =  SCEP_TYPECAST(DWORD, pSceProfileInfoBuffer, settingOffset);

                        PSCE_REGISTRY_VALUE_INFO    aRegValues = NULL;

                        //
                        // 64-bit alignment fix (alternatively, have an entry for aRegValues in the offset table)
                        //

#ifdef _WIN64
//                        CHAR    *pAlign;

                        aRegValues = pSceProfileInfoBuffer->aRegValues;

//                        pAlign = (CHAR *)pSceProfileInfoBuffer + settingOffset + sizeof(DWORD);
//                        aRegValues = (PSCE_REGISTRY_VALUE_INFO)ROUND_UP_POINTER(pAlign,ALIGN_LPVOID);
#else
                        aRegValues =
                        SCEP_TYPECAST(PSCE_REGISTRY_VALUE_INFO, pSceProfileInfoBuffer, settingOffset + sizeof(DWORD));
#endif


                        bLogErrorOutsideSwitch = FALSE;

                        if ( aRegValues == NULL )
                            continue;

                        for (UINT   regNo = 0; regNo < dwRegCount; regNo++ ) {

                            if ((aRegValues)[regNo].FullValueName) {

                                pSettingPrecedence = NULL;

                                if (NO_ERROR != (rc = RegistryValueHashTable.LookupAdd(
                                                                                      (aRegValues)[regNo].FullValueName,
                                                                                      &pSettingPrecedence))) {
                                    rcSave = rc;

                                    ScepLogEventAndReport(MyModuleHandle,
                                                          gpwszPlanOrDiagLogFile,
                                                          0,
                                                          0,
                                                          IDS_ERROR_RSOP_LOG,
                                                          rc,
                                                          (aRegValues)[regNo].FullValueName
                                                         );


                                    //
                                    // if hash table fails for any reason, cannot
                                    // trust it for processing of other elements
                                    //

                                    break;
                                }

                                rc = ScepWbemErrorToDosError(Log.Log(
                                                                    (aRegValues)[regNo].FullValueName,
                                                                    (aRegValues)[regNo].ValueType,
                                                                    (aRegValues)[regNo].Value,
                                                                    ++(*pSettingPrecedence)
                                                                    ));

                                ScepLogEventAndReport(MyModuleHandle,
                                                      gpwszPlanOrDiagLogFile,
                                                      0,
                                                      0,
                                                      IDS_INFO_RSOP_LOG,
                                                      rc,
                                                      (aRegValues)[regNo].FullValueName
                                                     );

                                SCEP_RSOP_CONTINUE_OR_BREAK
                            }

                        }

                    }

                } catch (...) {
                    //
                    // system error  continue with next setting
                    //
                    rc = EVENT_E_INTERNALEXCEPTION;

                    bLogErrorOutsideSwitch = TRUE;
                }
                break;

            case    RSOP_UserPrivilegeRight:

                try {

                    {

                        RSOP_UserPrivilegeRightLogger    Log(pWbemServices, pwszGPOName, pwszSOMID);

                        PSCE_PRIVILEGE_ASSIGNMENT   pInfPrivilegeAssignedTo =
                        SCEP_TYPECAST(PSCE_PRIVILEGE_ASSIGNMENT, pSceProfileInfoBuffer, settingOffset);

                        bLogErrorOutsideSwitch = FALSE;


                        while (pInfPrivilegeAssignedTo) {

                            if (pInfPrivilegeAssignedTo->Name) {

                                pSettingPrecedence = NULL;


                                if (NO_ERROR != (rc = PrivilegeHashTable.LookupAdd(
                                                                                  pInfPrivilegeAssignedTo->Name,
                                                                                  &pSettingPrecedence))) {
                                    rcSave = rc;

                                    ScepLogEventAndReport(MyModuleHandle,
                                                          gpwszPlanOrDiagLogFile,
                                                          0,
                                                          0,
                                                          IDS_ERROR_RSOP_LOG,
                                                          rc,
                                                          pInfPrivilegeAssignedTo->Name
                                                         );


                                    //
                                    // if hash table fails for any reason, cannot
                                    // trust it for processing of other elements
                                    //
                                    break;
                                }

                                rc = ScepWbemErrorToDosError(Log.Log(
                                                                    pInfPrivilegeAssignedTo->Name,
                                                                    pInfPrivilegeAssignedTo->AssignedTo,
                                                                    ++(*pSettingPrecedence)
                                                                    ));

                                ScepLogEventAndReport(MyModuleHandle,
                                                      gpwszPlanOrDiagLogFile,
                                                      0,
                                                      0,
                                                      IDS_INFO_RSOP_LOG,
                                                      rc,
                                                      pInfPrivilegeAssignedTo->Name
                                                     );

                                SCEP_RSOP_CONTINUE_OR_BREAK
                            }

                            pInfPrivilegeAssignedTo = pInfPrivilegeAssignedTo->Next;
                        }

                    }

                } catch (...) {
                    //
                    // system error  continue with next setting
                    //
                    rc = EVENT_E_INTERNALEXCEPTION;

                    bLogErrorOutsideSwitch = TRUE;

                }
                break;

            case    RSOP_RestrictedGroup:

                try {

                    {

                        RSOP_RestrictedGroupLogger    Log(pWbemServices, pwszGPOName, pwszSOMID);

                        PSCE_GROUP_MEMBERSHIP   pGroupMembership =
                        SCEP_TYPECAST(PSCE_GROUP_MEMBERSHIP, pSceProfileInfoBuffer, settingOffset);

                        bLogErrorOutsideSwitch = FALSE;
                        PWSTR   pCanonicalGroupName = NULL;

                        while (pGroupMembership) {

                            if (pGroupMembership->GroupName) {

                                rc = ScepCanonicalizeGroupName(pGroupMembership->GroupName,
                                                               &pCanonicalGroupName
                                                               );

                                SCEP_RSOP_CONTINUE_OR_BREAK

                                pSettingPrecedence = NULL;

                                if (NO_ERROR != (rc = GroupHashTable.LookupAdd(
                                                                              pCanonicalGroupName,
                                                                              &pSettingPrecedence))) {
                                    rcSave = rc;

                                    ScepLogEventAndReport(MyModuleHandle,
                                                          gpwszPlanOrDiagLogFile,
                                                          0,
                                                          0,
                                                          IDS_ERROR_RSOP_LOG,
                                                          rc,
                                                          pCanonicalGroupName
                                                         );


                                    //
                                    // if hash table fails for any reason, cannot
                                    // trust it for processing of other elements
                                    //
                                    if (pCanonicalGroupName)
                                        ScepFree(pCanonicalGroupName);
                                    pCanonicalGroupName = NULL;

                                    break;
                                }

                                rc = ScepWbemErrorToDosError(Log.Log(
                                                                    pCanonicalGroupName,
                                                                    pGroupMembership->pMembers,
                                                                    ++(*pSettingPrecedence)
                                                                    ));

                                ScepLogEventAndReport(MyModuleHandle,
                                                      gpwszPlanOrDiagLogFile,
                                                      0,
                                                      0,
                                                      IDS_INFO_RSOP_LOG,
                                                      rc,
                                                      pCanonicalGroupName
                                                     );

                                if (pCanonicalGroupName)
                                    ScepFree(pCanonicalGroupName);
                                pCanonicalGroupName = NULL;

                                SCEP_RSOP_CONTINUE_OR_BREAK
                            }

                            pGroupMembership = pGroupMembership->Next;

                        }
                    }

                } catch (...) {
                    //
                    // system error  continue with next setting
                    //
                    rc = EVENT_E_INTERNALEXCEPTION;

                    bLogErrorOutsideSwitch = TRUE;
                }

                break;


            case    RSOP_SystemService:

                try {

                    {

                        RSOP_SystemServiceLogger    Log(pWbemServices, pwszGPOName, pwszSOMID);

                        PSCE_SERVICES   pServices =
                        SCEP_TYPECAST(PSCE_SERVICES, pSceProfileInfoBuffer, settingOffset);

                        bLogErrorOutsideSwitch = FALSE;

                        while (pServices) {

                            if (pServices->ServiceName) {

                                pSettingPrecedence = NULL;

                                if (NO_ERROR != (rc = ServicesHashTable.LookupAdd(
                                                                                 pServices->ServiceName,
                                                                                 &pSettingPrecedence))) {
                                    rcSave = rc;

                                    ScepLogEventAndReport(MyModuleHandle,
                                                          gpwszPlanOrDiagLogFile,
                                                          0,
                                                          0,
                                                          IDS_ERROR_RSOP_LOG,
                                                          rc,
                                                          pServices->ServiceName
                                                         );


                                    //
                                    // if hash table fails for any reason, cannot
                                    // trust it for processing of other elements
                                    //
                                    break;
                                }

                                rc = ScepWbemErrorToDosError(Log.Log(
                                                                    pServices->ServiceName,
                                                                    pServices->Startup,
                                                                    pServices->General.pSecurityDescriptor,
                                                                    pServices->SeInfo,
                                                                    ++(*pSettingPrecedence)
                                                                    ));

                                ScepLogEventAndReport(MyModuleHandle,
                                                      gpwszPlanOrDiagLogFile,
                                                      0,
                                                      0,
                                                      IDS_INFO_RSOP_LOG,
                                                      rc,
                                                      pServices->ServiceName
                                                     );

                                SCEP_RSOP_CONTINUE_OR_BREAK
                            }

                            pServices = pServices->Next;

                        }
                    }

                } catch (...) {
                    //
                    // system error  continue with next setting
                    //
                    rc = EVENT_E_INTERNALEXCEPTION;

                    bLogErrorOutsideSwitch = TRUE;
                }
                break;

            case    RSOP_File:

                try {

                    {

                        RSOP_FileLogger    Log(pWbemServices, pwszGPOName, pwszSOMID);

                        SCE_OBJECTS   pObjects =
                        SCEP_TYPECAST(SCE_OBJECTS, pSceProfileInfoBuffer, settingOffset);

                        BOOL bPathIsTranslated = FALSE;

                        bLogErrorOutsideSwitch = FALSE;



                        if (pObjects.pAllNodes) {

                            PSCE_OBJECT_SECURITY    *pObjectArray = pObjects.pAllNodes->pObjectArray;

                            for (DWORD rCount = 0; rCount < pObjects.pAllNodes->Count; rCount++) {

                                if (pObjectArray[rCount] && pObjectArray[rCount]->Name) {

                                    pSettingPrecedence = NULL;

                                    //
                                    // if diagnosis mode, translate env-vars and store
                                    //

                                    bPathIsTranslated = FALSE;

                                    PWSTR  pwszTranslatedPath = NULL;

                                    if (!bPlanningMode && (wcschr(pObjectArray[rCount]->Name, L'%') != NULL )) {

                                        bPathIsTranslated = TRUE;

                                        rc = ScepClientTranslateFileDirName( pObjectArray[rCount]->Name, &pwszTranslatedPath);

                                        if ( rc == ERROR_PATH_NOT_FOUND )
                                            rc = SCESTATUS_INVALID_DATA;
                                        else if ( rc != NO_ERROR )
                                            rc = ScepDosErrorToSceStatus(rc);

                                        SCEP_RSOP_CONTINUE_OR_BREAK

                                    } else {

                                        pwszTranslatedPath = pObjectArray[rCount]->Name;
                                    }



                                    if (NO_ERROR != (rc = FileSecurityHashTable.LookupAdd(
                                                                                         pwszTranslatedPath,
                                                                                         &pSettingPrecedence))) {
                                        rcSave = rc;

                                        ScepLogEventAndReport(MyModuleHandle,
                                                              gpwszPlanOrDiagLogFile,
                                                              0,
                                                              0,
                                                              IDS_ERROR_RSOP_LOG,
                                                              rc,
                                                              pwszTranslatedPath
                                                             );


                                        //
                                        // if hash table fails for any reason, cannot
                                        // trust it for processing of other elements
                                        //
                                        if (bPathIsTranslated && pwszTranslatedPath)

                                            LocalFree(pwszTranslatedPath);

                                        break;
                                    }

                                    rc = ScepWbemErrorToDosError(Log.Log(
                                                                        pwszTranslatedPath,
                                                                        (bPathIsTranslated ? pObjectArray[rCount]->Name : NULL),
                                                                        pObjectArray[rCount]->Status,
                                                                        pObjectArray[rCount]->pSecurityDescriptor,
                                                                        pObjectArray[rCount]->SeInfo,
                                                                        ++(*pSettingPrecedence)
                                                                        ));

                                    ScepLogEventAndReport(MyModuleHandle,
                                                          gpwszPlanOrDiagLogFile,
                                                          0,
                                                          0,
                                                          IDS_INFO_RSOP_LOG,
                                                          rc,
                                                          pwszTranslatedPath
                                                         );

                                    if (bPathIsTranslated && pwszTranslatedPath)

                                        LocalFree(pwszTranslatedPath);

                                    SCEP_RSOP_CONTINUE_OR_BREAK
                                }
                            }
                        }
                    }

                } catch (...) {
                    //
                    // system error  continue with next setting
                    //
                    rc = EVENT_E_INTERNALEXCEPTION;

                    bLogErrorOutsideSwitch = TRUE;
                }
                break;


            case    RSOP_RegistryKey:

                try {

                    {

                        RSOP_RegistryKeyLogger    Log(pWbemServices, pwszGPOName, pwszSOMID);

                        SCE_OBJECTS   pObjects =
                        SCEP_TYPECAST(SCE_OBJECTS, pSceProfileInfoBuffer, settingOffset);

                        bLogErrorOutsideSwitch = FALSE;

                        if (pObjects.pAllNodes) {

                            PSCE_OBJECT_SECURITY    *pObjectArray = pObjects.pAllNodes->pObjectArray;

                            for (DWORD rCount = 0; rCount < pObjects.pAllNodes->Count; rCount++) {

                                if (pObjectArray[rCount] && pObjectArray[rCount]->Name) {

                                    pSettingPrecedence = NULL;

                                    if (NO_ERROR != (rc = RegistrySecurityHashTable.LookupAdd(
                                                                                             pObjectArray[rCount]->Name,
                                                                                             &pSettingPrecedence))) {
                                        rcSave = rc;

                                        ScepLogEventAndReport(MyModuleHandle,
                                                              gpwszPlanOrDiagLogFile,
                                                              0,
                                                              0,
                                                              IDS_ERROR_RSOP_LOG,
                                                              rc,
                                                              pObjectArray[rCount]->Name
                                                             );


                                        //
                                        // if hash table fails for any reason, cannot
                                        // trust it for processing of other elements
                                        //
                                        break;
                                    }

                                    rc = ScepWbemErrorToDosError(Log.Log(
                                                                        pObjectArray[rCount]->Name,
                                                                        pObjectArray[rCount]->Status,
                                                                        pObjectArray[rCount]->pSecurityDescriptor,
                                                                        pObjectArray[rCount]->SeInfo,
                                                                        ++(*pSettingPrecedence)
                                                                        ));

                                    ScepLogEventAndReport(MyModuleHandle,
                                                          gpwszPlanOrDiagLogFile,
                                                          0,
                                                          0,
                                                          IDS_INFO_RSOP_LOG,
                                                          rc,
                                                          pObjectArray[rCount]->Name
                                                         );

                                    SCEP_RSOP_CONTINUE_OR_BREAK
                                }
                            }
                        }
                    }

                } catch (...) {
                    //
                    // system error  continue with next setting
                    //
                    rc = EVENT_E_INTERNALEXCEPTION;

                    bLogErrorOutsideSwitch = TRUE;
                }

                break;

            default:
                //
                // should not happen
                //

                rc = ERROR_INVALID_PARAMETER;

            }

            if (bLogErrorOutsideSwitch && rc != NO_ERROR ) {

                //
                // log error and continue
                //
                rcSave = rc;

                ScepLogEventAndReport(MyModuleHandle,
                                      gpwszPlanOrDiagLogFile,
                                      0,
                                      0,
                                      IDS_ERROR_RSOP_LOG,
                                      rc,
                                      pSettingName
                                     );

            }

            bLogErrorOutsideSwitch = TRUE;

            //
            // this is the only case in which we quit logging completely
            //
            if (rc == ERROR_NOT_ENOUGH_MEMORY)
                break;
        }

        NextGPO:

        if (pSceProfileInfoBuffer)
            SceFreeProfileMemory(pSceProfileInfoBuffer);
        pSceProfileInfoBuffer = NULL;

        if (pwszGPOName)
            ScepFree(pwszGPOName);
        pwszGPOName = NULL;

        if (pwszSOMID)
            ScepFree(pwszSOMID);
        pwszSOMID = NULL;

        if (rc == ERROR_NOT_ENOUGH_MEMORY)
            break;
        // this is the only case in which we quit logging completely

        pCurrFileName = pCurrFileName->Next;
    }


    if (pGptNameList)
        ScepFreeNameStatusList(pGptNameList);

    //
    // only log the final status to both event log and logfile
    // (all other statuses are logged to logfile only)
    //

    if (rcSave == ERROR_SUCCESS)

        ScepLogEventAndReport(MyModuleHandle,
                              gpwszPlanOrDiagLogFile,
                              0,
                              0,
                              IDS_SUCCESS_RSOP_LOG,
                              rcSave,
                              L""
                             );

    else

        ScepLogEventAndReport(MyModuleHandle,
                              gpwszPlanOrDiagLogFile,
                              0,
                              0,
                              IDS_ERROR_RSOP_LOG,
                              rcSave,
                              L""
                             );

    return rcSave;

}



SCEPR_STATUS
SceClientCallbackRsopLog(
                        IN AREAPR cbArea,
                        IN DWORD  ncbErrorStatus,
                        IN wchar_t *pSettingInfo OPTIONAL,
                        IN DWORD dwPrivLow OPTIONAL,
                        IN DWORD dwPrivHigh OPTIONAL
                        )

/////////////////////////////////////////////////////////////////////////////////////////////////////
// This function is called by the server via RPC when settings defined in the jet                  //
// db are applied (along with a status of application, and optional detailed information)          //
//                                                                                                 //
// The areas were decided based on the granularity of configuration in scesrv. cbArea can have     //
// more than one area encoded in it, again due to the resolution granularity of error in scesrv.   //
// Hence this is a massive "if" routine                                                            //
//                                                                                                 //
// configuration from jet db corresponds to precedence = "1" simulated configuration in the        //
// rsop database which was logged by the client. For each area, we try to log the status of        //
// configuration by querying the database for these precedence = "1" settings and updating the     //
// status fields per such instance found. We should find all called back settings in WMI db except //
// for local-policy                                                                                //
//                                                                                                 //
// if any error, update golbal Synch/Asynch statuses with the accumulated status                   //
/////////////////////////////////////////////////////////////////////////////////////////////////////

{

    DWORD rc = ERROR_SUCCESS;
    DWORD rcSave = ERROR_SUCCESS;

    //
    // instantiate a logger that logs status from callback (has overloaded log methods)
    //

    try {

        SCEP_DIAGNOSIS_LOGGER   Log(tg_pWbemServices, NULL, NULL);


        //
        // password policy
        //

        if (cbArea & SCE_RSOP_PASSWORD_INFO) {

            try {
                rc = ScepWbemErrorToDosError(Log.Log(L"RSOP_SecuritySettingNumeric",
                                                     L"KeyName",
                                                     L"MinimumPasswordAge",
                                                     ncbErrorStatus,
                                                     FALSE
                                                    ));
                ScepLogEventAndReport(MyModuleHandle,
                                      gpwszPlanOrDiagLogFile,
                                      0,
                                      0,
                                      IDS_ERROR_RSOP_DIAG_LOG,
                                      rc,
                                      L"MinimumPasswordAge"
                                     );

                SCEP_RSOP_CONTINUE_OR_GOTO

                rc = ScepWbemErrorToDosError(Log.Log(L"RSOP_SecuritySettingNumeric",
                                                     L"KeyName",
                                                     L"MaximumPasswordAge",
                                                     ncbErrorStatus,
                                                     FALSE
                                                    ));

                ScepLogEventAndReport(MyModuleHandle,
                                      gpwszPlanOrDiagLogFile,
                                      0,
                                      0,
                                      IDS_ERROR_RSOP_DIAG_LOG,
                                      rc,
                                      L"MaximumPasswordAge"
                                     );

                SCEP_RSOP_CONTINUE_OR_GOTO

                rc = ScepWbemErrorToDosError(Log.Log(L"RSOP_SecuritySettingNumeric",
                                                     L"KeyName",
                                                     L"MinimumPasswordLength",
                                                     ncbErrorStatus,
                                                     FALSE
                                                    ));

                ScepLogEventAndReport(MyModuleHandle,
                                      gpwszPlanOrDiagLogFile,
                                      0,
                                      0,
                                      IDS_ERROR_RSOP_DIAG_LOG,
                                      rc,
                                      L"MinimumPasswordLength"
                                     );

                SCEP_RSOP_CONTINUE_OR_GOTO

                rc = ScepWbemErrorToDosError(Log.Log(L"RSOP_SecuritySettingNumeric",
                                                     L"KeyName",
                                                     L"PasswordHistorySize",
                                                     ncbErrorStatus,
                                                     FALSE
                                                    ));

                ScepLogEventAndReport(MyModuleHandle,
                                      gpwszPlanOrDiagLogFile,
                                      0,
                                      0,
                                      IDS_ERROR_RSOP_DIAG_LOG,
                                      rc,
                                      L"PasswordHistorySize"
                                     );

                SCEP_RSOP_CONTINUE_OR_GOTO

                rc = ScepWbemErrorToDosError(Log.Log(L"RSOP_SecuritySettingBoolean",
                                                     L"KeyName",
                                                     L"ClearTextPassword",
                                                     ncbErrorStatus,
                                                     FALSE
                                                    ));

                ScepLogEventAndReport(MyModuleHandle,
                                      gpwszPlanOrDiagLogFile,
                                      0,
                                      0,
                                      IDS_ERROR_RSOP_DIAG_LOG,
                                      rc,
                                      L"ClearTextPassword"
                                     );

                SCEP_RSOP_CONTINUE_OR_GOTO

                rc = ScepWbemErrorToDosError(Log.Log(L"RSOP_SecuritySettingBoolean",
                                                     L"KeyName",
                                                     L"PasswordComplexity",
                                                     ncbErrorStatus,
                                                     FALSE
                                                    ));

                ScepLogEventAndReport(MyModuleHandle,
                                      gpwszPlanOrDiagLogFile,
                                      0,
                                      0,
                                      IDS_ERROR_RSOP_DIAG_LOG,
                                      rc,
                                      L"PasswordComplexity"
                                     );

                SCEP_RSOP_CONTINUE_OR_GOTO

                rc = ScepWbemErrorToDosError(Log.Log(L"RSOP_SecuritySettingBoolean",
                                                     L"KeyName",
                                                     L"RequireLogonToChangePassword",
                                                     ncbErrorStatus,
                                                     FALSE
                                                    ));
                ScepLogEventAndReport(MyModuleHandle,
                                      gpwszPlanOrDiagLogFile,
                                      0,
                                      0,
                                      IDS_ERROR_RSOP_DIAG_LOG,
                                      rc,
                                      L"RequireLogonToChangePassword"
                                     );

                SCEP_RSOP_CONTINUE_OR_GOTO

            } catch (...) {
                //
                // system error  continue with next setting
                //
                rcSave = EVENT_E_INTERNALEXCEPTION;
            }

        }

        //
        // account lockout policy
        //

        if (cbArea & SCE_RSOP_LOCKOUT_INFO) {

            try {
                rc = ScepWbemErrorToDosError(Log.Log(L"RSOP_SecuritySettingNumeric",
                                                     L"KeyName",
                                                     L"LockoutBadCount",
                                                     ncbErrorStatus,
                                                     FALSE
                                                    ));
                ScepLogEventAndReport(MyModuleHandle,
                                      gpwszPlanOrDiagLogFile,
                                      0,
                                      0,
                                      IDS_ERROR_RSOP_DIAG_LOG,
                                      rc,
                                      L"LockoutBadCount"
                                     );

                SCEP_RSOP_CONTINUE_OR_GOTO

                rc = ScepWbemErrorToDosError(Log.Log(L"RSOP_SecuritySettingNumeric",
                                                     L"KeyName",
                                                     L"ResetLockoutCount",
                                                     ncbErrorStatus,
                                                     FALSE
                                                    ));
                ScepLogEventAndReport(MyModuleHandle,
                                      gpwszPlanOrDiagLogFile,
                                      0,
                                      0,
                                      IDS_ERROR_RSOP_DIAG_LOG,
                                      rc,
                                      L"ResetLockoutCount"
                                     );

                SCEP_RSOP_CONTINUE_OR_GOTO

                rc = ScepWbemErrorToDosError(Log.Log(L"RSOP_SecuritySettingNumeric",
                                                     L"KeyName",
                                                     L"LockoutDuration",
                                                     ncbErrorStatus,
                                                     FALSE
                                                    ));
                ScepLogEventAndReport(MyModuleHandle,
                                      gpwszPlanOrDiagLogFile,
                                      0,
                                      0,
                                      IDS_ERROR_RSOP_DIAG_LOG,
                                      rc,
                                      L"LockoutDuration"
                                     );

                SCEP_RSOP_CONTINUE_OR_GOTO

            } catch (...) {
                //
                // system error  continue with next setting
                //
                rcSave = EVENT_E_INTERNALEXCEPTION;
            }

        }

        //
        // forcelogoff setting
        //

        if (cbArea & SCE_RSOP_LOGOFF_INFO) {

            try {
                rc = ScepWbemErrorToDosError(Log.Log(L"RSOP_SecuritySettingBoolean",
                                                     L"KeyName",
                                                     L"ForceLogoffWhenHourExpire",
                                                     ncbErrorStatus,
                                                     FALSE
                                                    ));
                ScepLogEventAndReport(MyModuleHandle,
                                      gpwszPlanOrDiagLogFile,
                                      0,
                                      0,
                                      IDS_ERROR_RSOP_DIAG_LOG,
                                      rc,
                                      L"ForceLogoffWhenHourExpire"
                                     );

                SCEP_RSOP_CONTINUE_OR_GOTO
            } catch (...) {
                //
                // system error  continue with next setting
                //
                rcSave = EVENT_E_INTERNALEXCEPTION;
            }
        }

        //
        // LSA policy setting
        //

        if (cbArea & SCE_RSOP_LSA_POLICY_INFO) {

            try {
                rc = ScepWbemErrorToDosError(Log.Log(L"RSOP_SecuritySettingBoolean",
                                                     L"KeyName",
                                                     L"LSAAnonymousNameLookup",
                                                     ncbErrorStatus,
                                                     FALSE
                                                    ));
                ScepLogEventAndReport(MyModuleHandle,
                                      gpwszPlanOrDiagLogFile,
                                      0,
                                      0,
                                      IDS_ERROR_RSOP_DIAG_LOG,
                                      rc,
                                      L"LSAAnonymousNameLookup"
                                     );

                SCEP_RSOP_CONTINUE_OR_GOTO
            } catch (...) {
                //
                // system error  continue with next setting
                //
                rcSave = EVENT_E_INTERNALEXCEPTION;
            }
        }


        //
        // disable admin account
        //

        if (cbArea & SCE_RSOP_DISABLE_ADMIN_INFO) {

            try {
                rc = ScepWbemErrorToDosError(Log.Log(L"RSOP_SecuritySettingBoolean",
                                                     L"KeyName",
                                                     L"EnableAdminAccount",
                                                     ncbErrorStatus,
                                                     FALSE
                                                    ));
                ScepLogEventAndReport(MyModuleHandle,
                                      gpwszPlanOrDiagLogFile,
                                      0,
                                      0,
                                      IDS_ERROR_RSOP_DIAG_LOG,
                                      rc,
                                      L"EnableAdminAccount"
                                     );

                SCEP_RSOP_CONTINUE_OR_GOTO
            } catch (...) {
                //
                // system error  continue with next setting
                //
                rcSave = EVENT_E_INTERNALEXCEPTION;
            }
        }

        //
        // disable guest account
        //

        if (cbArea & SCE_RSOP_DISABLE_GUEST_INFO) {

            try {
                rc = ScepWbemErrorToDosError(Log.Log(L"RSOP_SecuritySettingBoolean",
                                                     L"KeyName",
                                                     L"EnableGuestAccount",
                                                     ncbErrorStatus,
                                                     FALSE
                                                    ));
                ScepLogEventAndReport(MyModuleHandle,
                                      gpwszPlanOrDiagLogFile,
                                      0,
                                      0,
                                      IDS_ERROR_RSOP_DIAG_LOG,
                                      rc,
                                      L"EnableGuestAccount"
                                     );

                SCEP_RSOP_CONTINUE_OR_GOTO
            } catch (...) {
                //
                // system error  continue with next setting
                //
                rcSave = EVENT_E_INTERNALEXCEPTION;
            }
        }

        //
        // administratorname setting
        //

        if (cbArea & SCE_RSOP_ADMIN_INFO) {

            try {
                rc = ScepWbemErrorToDosError(Log.Log(L"RSOP_SecuritySettingString",
                                                     L"KeyName",
                                                     L"NewAdministratorName",
                                                     ncbErrorStatus,
                                                     FALSE
                                                    ));
                ScepLogEventAndReport(MyModuleHandle,
                                      gpwszPlanOrDiagLogFile,
                                      0,
                                      0,
                                      IDS_ERROR_RSOP_DIAG_LOG,
                                      rc,
                                      L"NewAdministratorName"
                                     );

                SCEP_RSOP_CONTINUE_OR_GOTO
            } catch (...) {
                //
                // system error  continue with next setting
                //
                rcSave = EVENT_E_INTERNALEXCEPTION;
            }
        }

        //
        // guestname setting
        //

        if (cbArea & SCE_RSOP_GUEST_INFO) {

            try {
                rc = ScepWbemErrorToDosError(Log.Log(L"RSOP_SecuritySettingString",
                                                     L"KeyName",
                                                     L"NewGuestName",
                                                     ncbErrorStatus,
                                                     FALSE
                                                    ));
                ScepLogEventAndReport(MyModuleHandle,
                                      gpwszPlanOrDiagLogFile,
                                      0,
                                      0,
                                      IDS_ERROR_RSOP_DIAG_LOG,
                                      rc,
                                      L"NewGuestName"
                                     );

                SCEP_RSOP_CONTINUE_OR_GOTO
            } catch (...) {
                //
                // system error  continue with next setting
                //
                rcSave = EVENT_E_INTERNALEXCEPTION;
            }
        }

        //
        // user groups settings
        //

        if (cbArea & SCE_RSOP_GROUP_INFO) {

            try {

                PWSTR pCanonicalGroupName = NULL;
                PWSTR pwszCanonicalDoubleSlashName = NULL;

                rc = ScepCanonicalizeGroupName(pSettingInfo,
                               &pCanonicalGroupName
                               );

                SCEP_RSOP_CONTINUE_OR_GOTO

                rc = ScepConvertSingleSlashToDoubleSlashPath(
                                                            pCanonicalGroupName,
                                                            &pwszCanonicalDoubleSlashName
                                                            );

                if (rc == ERROR_NOT_ENOUGH_MEMORY && pCanonicalGroupName) {
                    ScepFree(pCanonicalGroupName);
                    pCanonicalGroupName = NULL;
                }


                SCEP_RSOP_CONTINUE_OR_GOTO


                rc = ScepWbemErrorToDosError(Log.Log(L"RSOP_RestrictedGroup",
                                                     L"GroupName",
                                                     pwszCanonicalDoubleSlashName,
                                                     ncbErrorStatus,
                                                     FALSE
                                                    ));
                ScepLogEventAndReport(MyModuleHandle,
                                      gpwszPlanOrDiagLogFile,
                                      0,
                                      0,
                                      IDS_ERROR_RSOP_DIAG_LOG,
                                      rc,
                                      pCanonicalGroupName
                                     );

                if (pCanonicalGroupName)
                    ScepFree(pCanonicalGroupName);

                if (pwszCanonicalDoubleSlashName)
                    LocalFree(pwszCanonicalDoubleSlashName);

                SCEP_RSOP_CONTINUE_OR_GOTO

            } catch (...) {
                //
                // system error  continue with next setting
                //
                rcSave = EVENT_E_INTERNALEXCEPTION;
            }
        }

        //
        // user privileges settings
        //

        if (cbArea & SCE_RSOP_PRIVILEGE_INFO) {

            try {

                //
                // loop through all privileges to see which are set for this account and log status
                // only if existing status is already != some error
                //

                for ( UINT i=0; i<cPrivCnt; i++) {

                    if ( i < 32 ) {

                        if (dwPrivLow & (1 << i )) {

                            rc = ScepWbemErrorToDosError(Log.Log(L"RSOP_UserPrivilegeRight",
                                                                 L"UserRight",
                                                                 SCE_Privileges[i].Name,
                                                                 ncbErrorStatus,
                                                                 TRUE));
                            ScepLogEventAndReport(MyModuleHandle,
                                                  gpwszPlanOrDiagLogFile,
                                                  0,
                                                  0,
                                                  IDS_ERROR_RSOP_DIAG_LOG,
                                                  rc,
                                                  SCE_Privileges[i].Name
                                                 );

                            SCEP_RSOP_CONTINUE_OR_GOTO
                        }

                    } else {

                        if (dwPrivHigh & (1 << (i-32 ))) {

                            rc = ScepWbemErrorToDosError(Log.Log(L"RSOP_UserPrivilegeRight",
                                                                 L"UserRight",
                                                                 SCE_Privileges[i].Name,
                                                                 ncbErrorStatus,
                                                                 TRUE));
                            ScepLogEventAndReport(MyModuleHandle,
                                                  gpwszPlanOrDiagLogFile,
                                                  0,
                                                  0,
                                                  IDS_ERROR_RSOP_DIAG_LOG,
                                                  rc,
                                                  SCE_Privileges[i].Name
                                                 );

                            SCEP_RSOP_CONTINUE_OR_GOTO
                        }

                    }
                }

            } catch (...) {
                //
                // system error  continue with next setting
                //
                rcSave = EVENT_E_INTERNALEXCEPTION;
            }
        }

        //
        // file security settings
        //

        if (cbArea & SCE_RSOP_FILE_SECURITY_INFO) {

            PWSTR   pwszDoubleSlashPath = NULL;

            try {

                rc = ScepConvertSingleSlashToDoubleSlashPath(
                                                            pSettingInfo,
                                                            &pwszDoubleSlashPath
                                                            );


                SCEP_RSOP_CONTINUE_OR_GOTO

                //
                // the file itself
                //
                if (!(cbArea & SCE_RSOP_FILE_SECURITY_INFO_CHILD)) {

                    rc = ScepWbemErrorToDosError(Log.Log(L"RSOP_File",
                                                         L"Path",
                                                         pwszDoubleSlashPath,
                                                         ncbErrorStatus,
                                                         FALSE
                                                        ));
                    ScepLogEventAndReport(MyModuleHandle,
                                          gpwszPlanOrDiagLogFile,
                                          0,
                                          0,
                                          IDS_ERROR_RSOP_DIAG_LOG,
                                          rc,
                                          pSettingInfo
                                         );

                } else {

                    //
                    // the file was error free, but some child failed
                    //

                    rc = ScepWbemErrorToDosError(Log.LogChild(L"RSOP_File",
                                                              L"Path",
                                                              pwszDoubleSlashPath,
                                                              ncbErrorStatus,
                                                              4
                                                             ));
                    ScepLogEventAndReport(MyModuleHandle,
                                          gpwszPlanOrDiagLogFile,
                                          0,
                                          0,
                                          IDS_ERROR_RSOP_DIAG_LOG,
                                          rc,
                                          pSettingInfo
                                         );


                }

                if (pwszDoubleSlashPath)
                    LocalFree(pwszDoubleSlashPath);
                pwszDoubleSlashPath = NULL;


                SCEP_RSOP_CONTINUE_OR_GOTO
            } catch (...) {

                if (pwszDoubleSlashPath)
                    LocalFree(pwszDoubleSlashPath);
                //
                // system error  continue with next setting
                //
                rcSave = EVENT_E_INTERNALEXCEPTION;
            }

        }

        //
        // registry security settings
        //

        if (cbArea & SCE_RSOP_REGISTRY_SECURITY_INFO) {

            PWSTR   pwszDoubleSlashPath = NULL;

            try {

                rc = ScepConvertSingleSlashToDoubleSlashPath(
                                                            pSettingInfo,
                                                            &pwszDoubleSlashPath
                                                            );

                SCEP_RSOP_CONTINUE_OR_GOTO


                //
                // the registry key itself
                //
                if (!(cbArea & SCE_RSOP_REGISTRY_SECURITY_INFO_CHILD)) {

#ifdef _WIN64
                    rc = ScepWbemErrorToDosError(Log.LogRegistryKey(L"RSOP_RegistryKey",
                                                         L"Path",
                                                         pwszDoubleSlashPath,
                                                         ncbErrorStatus,
                                                         FALSE
                                                        ));

                    ScepLogEventAndReport(MyModuleHandle,
                                          gpwszPlanOrDiagLogFile,
                                          0,
                                          0,
                                          IDS_ERROR_RSOP_DIAG_LOG64_32KEY,
                                          rc,
                                          pSettingInfo
                                         );
#else
                    rc = ScepWbemErrorToDosError(Log.Log(L"RSOP_RegistryKey",
                                                         L"Path",
                                                         pwszDoubleSlashPath,
                                                         ncbErrorStatus,
                                                         FALSE
                                                        ));

                    ScepLogEventAndReport(MyModuleHandle,
                                          gpwszPlanOrDiagLogFile,
                                          0,
                                          0,
                                          IDS_ERROR_RSOP_DIAG_LOG,
                                          rc,
                                          pSettingInfo
                                         );
#endif

                } else {

                    //
                    // the registry-key was error free, but some child failed
                    //

#ifdef _WIN64
                    rc = ScepWbemErrorToDosError(Log.LogRegistryKey(L"RSOP_RegistryKey",
                                                              L"Path",
                                                              pwszDoubleSlashPath,
                                                              ncbErrorStatus,
                                                              TRUE
                                                             ));
                    ScepLogEventAndReport(MyModuleHandle,
                                          gpwszPlanOrDiagLogFile,
                                          0,
                                          0,
                                          IDS_ERROR_RSOP_DIAG_LOG64_32KEY,
                                          rc,
                                          pSettingInfo
                                         );

#else
                    rc = ScepWbemErrorToDosError(Log.LogChild(L"RSOP_RegistryKey",
                                                              L"Path",
                                                              pwszDoubleSlashPath,
                                                              ncbErrorStatus,
                                                              4
                                                             ));
                    ScepLogEventAndReport(MyModuleHandle,
                                          gpwszPlanOrDiagLogFile,
                                          0,
                                          0,
                                          IDS_ERROR_RSOP_DIAG_LOG,
                                          rc,
                                          pSettingInfo
                                         );
#endif

                }

                if (pwszDoubleSlashPath)
                    LocalFree(pwszDoubleSlashPath);
                pwszDoubleSlashPath = NULL;


                SCEP_RSOP_CONTINUE_OR_GOTO
            } catch (...) {

                if (pwszDoubleSlashPath)
                    LocalFree(pwszDoubleSlashPath);
                //
                // system error  continue with next setting
                //
                rcSave = EVENT_E_INTERNALEXCEPTION;
            }

        }

        //
        // auditlogmaxsize settings
        //

        if (cbArea & SCE_RSOP_AUDIT_LOG_MAXSIZE_INFO) {

            try {
                rc = ScepWbemErrorToDosError(Log.Log(L"RSOP_SecurityEventLogSettingNumeric",
                                                     L"KeyName",
                                                     L"MaximumLogSize",
                                                     L"Type",
                                                     pSettingInfo,
                                                     ncbErrorStatus
                                                    ));
                ScepLogEventAndReport(MyModuleHandle,
                                      gpwszPlanOrDiagLogFile,
                                      0,
                                      0,
                                      IDS_ERROR_RSOP_DIAG_LOG,
                                      rc,
                                      L"MaximumLogSize"
                                     );

                SCEP_RSOP_CONTINUE_OR_GOTO
            } catch (...) {
                //
                // system error  continue with next setting
                //
                rcSave = EVENT_E_INTERNALEXCEPTION;
            }
        }

        //
        // auditlogretention settings
        //

        if (cbArea & SCE_RSOP_AUDIT_LOG_RETENTION_INFO) {

            try {
                rc = ScepWbemErrorToDosError(Log.Log(L"RSOP_SecurityEventLogSettingNumeric",
                                                     L"KeyName",
                                                     L"RetentionDays",
                                                     L"Type",
                                                     pSettingInfo,
                                                     ncbErrorStatus
                                                    ));
                ScepLogEventAndReport(MyModuleHandle,
                                      gpwszPlanOrDiagLogFile,
                                      0,
                                      0,
                                      IDS_ERROR_RSOP_DIAG_LOG,
                                      rc,
                                      L"RetentionDays"
                                     );

                SCEP_RSOP_CONTINUE_OR_GOTO

            } catch (...) {
                //
                // system error  continue with next setting
                //
                rcSave = EVENT_E_INTERNALEXCEPTION;
            }
        }

        //
        // auditlogguest settings
        //

        if (cbArea & SCE_RSOP_AUDIT_LOG_GUEST_INFO) {

            try {
                rc = ScepWbemErrorToDosError(Log.Log(L"RSOP_SecurityEventLogSettingBolean",
                                                     L"KeyName",
                                                     L"RestrictGuestAccess",
                                                     L"Type",
                                                     pSettingInfo,
                                                     ncbErrorStatus
                                                    ));
                ScepLogEventAndReport(MyModuleHandle,
                                      gpwszPlanOrDiagLogFile,
                                      0,
                                      0,
                                      IDS_ERROR_RSOP_DIAG_LOG,
                                      rc,
                                      L"RestrictGuestAccess"
                                     );

                SCEP_RSOP_CONTINUE_OR_GOTO

            } catch (...) {
                //
                // system error  continue with next setting
                //
                rcSave = EVENT_E_INTERNALEXCEPTION;
            }
        }

        //
        // auditevent settings
        //

        if (cbArea & SCE_RSOP_AUDIT_EVENT_INFO) {

            try {
                rc = ScepWbemErrorToDosError(Log.Log(L"RSOP_AuditPolicy",
                                                     L"Category",
                                                     L"AuditSystemEvents",
                                                     ncbErrorStatus,
                                                     FALSE
                                                    ));
                ScepLogEventAndReport(MyModuleHandle,
                                      gpwszPlanOrDiagLogFile,
                                      0,
                                      0,
                                      IDS_ERROR_RSOP_DIAG_LOG,
                                      rc,
                                      L"AuditSystemEvents"
                                     );

                SCEP_RSOP_CONTINUE_OR_GOTO

                rc = ScepWbemErrorToDosError(Log.Log(L"RSOP_AuditPolicy",
                                                     L"Category",
                                                     L"AuditLogonEvents",
                                                     ncbErrorStatus,
                                                     FALSE
                                                    ));
                ScepLogEventAndReport(MyModuleHandle,
                                      gpwszPlanOrDiagLogFile,
                                      0,
                                      0,
                                      IDS_ERROR_RSOP_DIAG_LOG,
                                      rc,
                                      L"AuditLogonEvents"
                                     );

                SCEP_RSOP_CONTINUE_OR_GOTO

                rc = ScepWbemErrorToDosError(Log.Log(L"RSOP_AuditPolicy",
                                                     L"Category",
                                                     L"AuditObjectAccess",
                                                     ncbErrorStatus,
                                                     FALSE
                                                    ));
                ScepLogEventAndReport(MyModuleHandle,
                                      gpwszPlanOrDiagLogFile,
                                      0,
                                      0,
                                      IDS_ERROR_RSOP_DIAG_LOG,
                                      rc,
                                      L"AuditObjectAccess"
                                     );

                SCEP_RSOP_CONTINUE_OR_GOTO

                rc = ScepWbemErrorToDosError(Log.Log(L"RSOP_AuditPolicy",
                                                     L"Category",
                                                     L"AuditPrivilegeUse",
                                                     ncbErrorStatus,
                                                     FALSE
                                                    ));
                ScepLogEventAndReport(MyModuleHandle,
                                      gpwszPlanOrDiagLogFile,
                                      0,
                                      0,
                                      IDS_ERROR_RSOP_DIAG_LOG,
                                      rc,
                                      L"AuditPrivilegeUse"
                                     );

                SCEP_RSOP_CONTINUE_OR_GOTO

                rc = ScepWbemErrorToDosError(Log.Log(L"RSOP_AuditPolicy",
                                                     L"Category",
                                                     L"AuditPolicyChange",
                                                     ncbErrorStatus,
                                                     FALSE
                                                    ));
                ScepLogEventAndReport(MyModuleHandle,
                                      gpwszPlanOrDiagLogFile,
                                      0,
                                      0,
                                      IDS_ERROR_RSOP_DIAG_LOG,
                                      rc,
                                      L"AuditPolicyChange"
                                     );

                SCEP_RSOP_CONTINUE_OR_GOTO

                rc = ScepWbemErrorToDosError(Log.Log(L"RSOP_AuditPolicy",
                                                     L"Category",
                                                     L"AuditAccountManage",
                                                     ncbErrorStatus,
                                                     FALSE
                                                    ));
                ScepLogEventAndReport(MyModuleHandle,
                                      gpwszPlanOrDiagLogFile,
                                      0,
                                      0,
                                      IDS_ERROR_RSOP_DIAG_LOG,
                                      rc,
                                      L"AuditAccountManage"
                                     );

                SCEP_RSOP_CONTINUE_OR_GOTO

                rc = ScepWbemErrorToDosError(Log.Log(L"RSOP_AuditPolicy",
                                                     L"Category",
                                                     L"AuditProcessTracking",
                                                     ncbErrorStatus,
                                                     FALSE
                                                    ));
                ScepLogEventAndReport(MyModuleHandle,
                                      gpwszPlanOrDiagLogFile,
                                      0,
                                      0,
                                      IDS_ERROR_RSOP_DIAG_LOG,
                                      rc,
                                      L"AuditProcessTracking"
                                     );

                SCEP_RSOP_CONTINUE_OR_GOTO

                rc = ScepWbemErrorToDosError(Log.Log(L"RSOP_AuditPolicy",
                                                     L"Category",
                                                     L"AuditDSAccess",
                                                     ncbErrorStatus,
                                                     FALSE
                                                    ));
                ScepLogEventAndReport(MyModuleHandle,
                                      gpwszPlanOrDiagLogFile,
                                      0,
                                      0,
                                      IDS_ERROR_RSOP_DIAG_LOG,
                                      rc,
                                      L"AuditDSAccess"
                                     );

                SCEP_RSOP_CONTINUE_OR_GOTO

                rc = ScepWbemErrorToDosError(Log.Log(L"RSOP_AuditPolicy",
                                                     L"Category",
                                                     L"AuditAccountLogon",
                                                     ncbErrorStatus,
                                                     FALSE
                                                    ));
                ScepLogEventAndReport(MyModuleHandle,
                                      gpwszPlanOrDiagLogFile,
                                      0,
                                      0,
                                      IDS_ERROR_RSOP_DIAG_LOG,
                                      rc,
                                      L"AuditAccountLogon"
                                     );

                SCEP_RSOP_CONTINUE_OR_GOTO
            } catch (...) {
                //
                // system error  continue with next setting
                //
                rcSave = EVENT_E_INTERNALEXCEPTION;
            }
        }

        //
        // kerberos settings
        //

        if (cbArea & SCE_RSOP_KERBEROS_INFO) {

            try {
                rc = ScepWbemErrorToDosError(Log.Log(L"RSOP_SecuritySettingNumeric",
                                                     L"KeyName",
                                                     L"MaxTicketAge",
                                                     ncbErrorStatus,
                                                     FALSE
                                                    ));
                ScepLogEventAndReport(MyModuleHandle,
                                      gpwszPlanOrDiagLogFile,
                                      0,
                                      0,
                                      IDS_ERROR_RSOP_DIAG_LOG,
                                      rc,
                                      L"MaxTicketAge"
                                     );

                SCEP_RSOP_CONTINUE_OR_GOTO

                rc = ScepWbemErrorToDosError(Log.Log(L"RSOP_SecuritySettingNumeric",
                                                     L"KeyName",
                                                     L"MaxRenewAge",
                                                     ncbErrorStatus,
                                                     FALSE
                                                    ));
                ScepLogEventAndReport(MyModuleHandle,
                                      gpwszPlanOrDiagLogFile,
                                      0,
                                      0,
                                      IDS_ERROR_RSOP_DIAG_LOG,
                                      rc,
                                      L"MaxRenewAge"
                                     );

                SCEP_RSOP_CONTINUE_OR_GOTO

                rc = ScepWbemErrorToDosError(Log.Log(L"RSOP_SecuritySettingNumeric",
                                                     L"KeyName",
                                                     L"MaxServiceAge",
                                                     ncbErrorStatus,
                                                     FALSE
                                                    ));
                ScepLogEventAndReport(MyModuleHandle,
                                      gpwszPlanOrDiagLogFile,
                                      0,
                                      0,
                                      IDS_ERROR_RSOP_DIAG_LOG,
                                      rc,
                                      L"MaxServiceAge"
                                     );

                SCEP_RSOP_CONTINUE_OR_GOTO

                rc = ScepWbemErrorToDosError(Log.Log(L"RSOP_SecuritySettingNumeric",
                                                     L"KeyName",
                                                     L"MaxClockSkew",
                                                     ncbErrorStatus,
                                                     FALSE
                                                    ));
                ScepLogEventAndReport(MyModuleHandle,
                                      gpwszPlanOrDiagLogFile,
                                      0,
                                      0,
                                      IDS_ERROR_RSOP_DIAG_LOG,
                                      rc,
                                      L"MaxClockSkew"
                                     );

                SCEP_RSOP_CONTINUE_OR_GOTO

                rc = ScepWbemErrorToDosError(Log.Log(L"RSOP_SecuritySettingBoolean",
                                                     L"KeyName",
                                                     L"TicketValidateClient",
                                                     ncbErrorStatus,
                                                     FALSE
                                                    ));
                ScepLogEventAndReport(MyModuleHandle,
                                      gpwszPlanOrDiagLogFile,
                                      0,
                                      0,
                                      IDS_ERROR_RSOP_DIAG_LOG,
                                      rc,
                                      L"TicketValidateClient"
                                     );

                SCEP_RSOP_CONTINUE_OR_GOTO
            } catch (...) {
                //
                // system error  continue with next setting
                //
                rcSave = EVENT_E_INTERNALEXCEPTION;
            }
        }

        //
        // registryvalue settings
        //

        if (cbArea & SCE_RSOP_REGISTRY_VALUE_INFO) {

            PWSTR   pwszDoubleSlashPath = NULL;
            try {
                //
                // replace single slash with double slash for building valid WMI query
                //


                rc = ScepConvertSingleSlashToDoubleSlashPath(
                                                            pSettingInfo,
                                                            &pwszDoubleSlashPath
                                                            );

                SCEP_RSOP_CONTINUE_OR_GOTO


                rc = ScepWbemErrorToDosError(Log.Log(L"RSOP_RegistryValue",
                                                     L"Path",
                                                     pwszDoubleSlashPath,
                                                     ncbErrorStatus,
                                                     FALSE
                                                    ));


                if (pwszDoubleSlashPath)
                    LocalFree(pwszDoubleSlashPath);
                pwszDoubleSlashPath = NULL;

                ScepLogEventAndReport(MyModuleHandle,
                                      gpwszPlanOrDiagLogFile,
                                      0,
                                      0,
                                      IDS_ERROR_RSOP_DIAG_LOG,
                                      rc,
                                      pSettingInfo
                                     );

                SCEP_RSOP_CONTINUE_OR_GOTO
            } catch (...) {

                if (pwszDoubleSlashPath)
                    LocalFree(pwszDoubleSlashPath);
                //
                // system error  continue with next setting
                //
                rcSave = EVENT_E_INTERNALEXCEPTION;
            }

        }

        //
        // services settings
        //

        if (cbArea & SCE_RSOP_SERVICES_INFO) {

            try {
                rc = ScepWbemErrorToDosError(Log.Log(L"RSOP_SystemService",
                                                     L"Service",
                                                     pSettingInfo,
                                                     ncbErrorStatus,
                                                     FALSE
                                                    ));
                ScepLogEventAndReport(MyModuleHandle,
                                      gpwszPlanOrDiagLogFile,
                                      0,
                                      0,
                                      IDS_ERROR_RSOP_DIAG_LOG,
                                      rc,
                                      pSettingInfo
                                     );

                SCEP_RSOP_CONTINUE_OR_GOTO
            } catch (...) {
                //
                // system error  continue with next setting
                //
                rcSave = EVENT_E_INTERNALEXCEPTION;
            }
        }

        Done:

        //
        // if exception, haven't logged yet so log it
        //

        if (rcSave == EVENT_E_INTERNALEXCEPTION) {

            ScepLogEventAndReport(MyModuleHandle,
                                  gpwszPlanOrDiagLogFile,
                                  0,
                                  0,
                                  IDS_ERROR_RSOP_DIAG_LOG,
                                  rcSave,
                                  L""
                                 );
        }

        //
        // merge-update the synch/asynch global status, ignore not found instances
        //

        //
        // WBEM_E_NOT_FOUND maps to ERROR_NONE_MAPPED
        // have to mask this due to an artifact of callback granularity
        // however, diagnosis.log will have the errors for debugging
        //

        if (rcSave != ERROR_SUCCESS && rcSave != ERROR_NOT_FOUND ) {

            if (!gbAsyncWinlogonThread && gHrSynchRsopStatus == S_OK)
                gHrSynchRsopStatus = ScepDosErrorToWbemError(rcSave);
            if (gbAsyncWinlogonThread && gHrAsynchRsopStatus == S_OK)
               gHrAsynchRsopStatus = ScepDosErrorToWbemError(rcSave);
            }

    } catch (...) {

        rcSave = EVENT_E_INTERNALEXCEPTION;

    }

    return rcSave;
}

DWORD
ScepConvertSingleSlashToDoubleSlashPath(
                                       IN wchar_t *pSettingInfo,
                                       OUT  PWSTR *ppwszDoubleSlashPath
                                       )
/////////////////////////////////////////////////////////////////////////////////////////////////////
// This function converts single slashes to double slashes to suit WMI queries                     //
// If success is returned, caller should free the OUT parameter                                    //
/////////////////////////////////////////////////////////////////////////////////////////////////////
{
    if (ppwszDoubleSlashPath == NULL)
        return ERROR_NOT_ENOUGH_MEMORY;

    UINT Len = wcslen(pSettingInfo) + 1;
    PWSTR pwszSingleSlashPath=(PWSTR)LocalAlloc(LPTR, (Len)*sizeof(WCHAR));

    if (pwszSingleSlashPath == NULL)
        return ERROR_NOT_ENOUGH_MEMORY;

    //
    // max of 25 slashes per file/registry object
    //

    PWSTR pwszDoubleSlashPath=(PWSTR)LocalAlloc(LPTR, (Len + 50)*sizeof(WCHAR));

    if (pwszDoubleSlashPath == NULL) {
        LocalFree(pwszSingleSlashPath);
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    wcscpy(pwszSingleSlashPath, pSettingInfo);

    UINT    charNumDouble = 0;
    UINT    charNumSingle = 0;

    while (pwszSingleSlashPath[charNumSingle] != L'\0') {

        if (pwszSingleSlashPath[charNumSingle] == L'\\') {

            pwszDoubleSlashPath[charNumDouble] = L'\\';
            charNumDouble++;
            pwszDoubleSlashPath[charNumDouble] = L'\\';

        } else {
            pwszDoubleSlashPath[charNumDouble] = pwszSingleSlashPath[charNumSingle];
        }
        charNumDouble++;
        charNumSingle++;
    }

    if (pwszSingleSlashPath)
        LocalFree(pwszSingleSlashPath);


    *ppwszDoubleSlashPath = pwszDoubleSlashPath;

    return ERROR_SUCCESS;

}


DWORD
ScepClientTranslateFileDirName(
                              IN  PWSTR oldFileName,
                              OUT PWSTR *newFileName
                              )
/* ++
Routine Description:

   This routine converts a generic file/directory name to a real used name
   for the current system. The following generic file/directory names are handled:
         %systemroot%   - Windows NT root directory (e.g., c:\winnt)
         %systemDirectory% - Windows NT system32 directory (e.g., c:\winnt\system32)

Arguments:

   oldFileName - the file name to convert, which includes "%" to represent
                 some directory names

   newFileName - the real file name, in which the "%" name is replaced with
                 the real directory name

Return values:

   Win32 error code

-- */
{
    //
    // match for %systemroot%
    //
    PWSTR   pTemp=NULL, pStart, TmpBuf, szVar;
    DWORD   rc=NO_ERROR;
    DWORD   newFileSize, cSize;
    BOOL    bContinue;


    rc = ScepExpandEnvironmentVariable(oldFileName,
                                       L"%SYSTEMROOT%",
                                       SCE_FLAG_WINDOWS_DIR,
                                       newFileName);

    if ( rc != ERROR_FILE_NOT_FOUND ) {
        return rc;
    }

    //
    // match for %systemdirectory%
    //

    rc = ScepExpandEnvironmentVariable(oldFileName,
                                       L"%SYSTEMDIRECTORY%",
                                       SCE_FLAG_SYSTEM_DIR,
                                       newFileName);

    if ( rc != ERROR_FILE_NOT_FOUND ) {
        return rc;
    }

    //
    // match for systemdrive
    //

    rc = ScepExpandEnvironmentVariable(oldFileName,
                                       L"%SYSTEMDRIVE%",
                                       SCE_FLAG_WINDOWS_DIR,
                                       newFileName);

    if ( rc != ERROR_FILE_NOT_FOUND ) {
        return rc;
    }

    //
    // match for boot drive
    //

    rc = ScepExpandEnvironmentVariable(oldFileName,
                                       L"%BOOTDRIVE%",
                                       SCE_FLAG_BOOT_DRIVE,
                                       newFileName);

    if ( rc != ERROR_FILE_NOT_FOUND ) {
        return rc;
    }

    rc = ERROR_SUCCESS;

    //
    // search for environment variable in the current process
    //
    pStart = wcschr(oldFileName, L'%');

    if ( pStart ) {
        pTemp = wcschr(pStart+1, L'%');
        if ( pTemp ) {

            bContinue = TRUE;
            //
            // find a environment variable to translate
            //
            TmpBuf = (PWSTR)ScepAlloc(0, ((UINT)(pTemp-pStart))*sizeof(WCHAR));
            if ( TmpBuf ) {

                wcsncpy(TmpBuf, pStart+1, (size_t)(pTemp-pStart-1));
                TmpBuf[pTemp-pStart-1] = L'\0';

                //
                // try search in the client environment block
                //
                cSize = GetEnvironmentVariable( TmpBuf,
                                                NULL,
                                                0 );

                if ( cSize > 0 ) {

                    szVar = (PWSTR)ScepAlloc(0, (cSize+1)*sizeof(WCHAR));

                    if ( szVar ) {
                        cSize = GetEnvironmentVariable(TmpBuf,
                                                       szVar,
                                                       cSize);
                        if ( cSize > 0 ) {
                            //
                            // get info in szVar
                            //
                            bContinue = FALSE;

                            newFileSize = ((DWORD)(pStart-oldFileName))+cSize+wcslen(pTemp+1)+1;

                            *newFileName = (PWSTR)ScepAlloc(0, newFileSize*sizeof(TCHAR));

                            if (*newFileName ) {
                                if ( pStart != oldFileName )
                                    wcsncpy(*newFileName, oldFileName, (size_t)(pStart-oldFileName));

                                swprintf((PWSTR)(*newFileName+(pStart-oldFileName)), L"%s%s", szVar, pTemp+1);

                            } else
                                rc = ERROR_NOT_ENOUGH_MEMORY;
                        }

                        ScepFree(szVar);

                    } else
                        rc = ERROR_NOT_ENOUGH_MEMORY;

                }

                ScepFree(TmpBuf);

            } else
                rc = ERROR_NOT_ENOUGH_MEMORY;

            if ( NO_ERROR != rc || !bContinue ) {
                //
                // if errored, or do not continue
                //
                return(rc);
            }


            //
            // not found in process environment,
            // continue to search for DSDIT/DSLOG/SYSVOL in registry
            //
            if ( (gbDCQueried == TRUE && gbThisIsDC == TRUE) ) {

                //
                // search for DSDIT
                //

                rc = ScepExpandEnvironmentVariable(oldFileName,
                                                   L"%DSDIT%",
                                                   SCE_FLAG_DSDIT_DIR,
                                                   newFileName);

                if ( rc != ERROR_FILE_NOT_FOUND ) {
                    return rc;
                }

                //
                // search for DSLOG
                //

                rc = ScepExpandEnvironmentVariable(oldFileName,
                                                   L"%DSLOG%",
                                                   SCE_FLAG_DSLOG_DIR,
                                                   newFileName);

                if ( rc != ERROR_FILE_NOT_FOUND ) {
                    return rc;
                }

                //
                // search for SYSVOL
                //
                rc = ScepExpandEnvironmentVariable(oldFileName,
                                                   L"%SYSVOL%",
                                                   SCE_FLAG_SYSVOL_DIR,
                                                   newFileName);

                if ( rc != ERROR_FILE_NOT_FOUND ) {
                    return rc;
                }

            }

        }

    }

    //
    // Otherwise, just copy the old name to a new buffer and return ERROR_PATH_NOT_FOUND
    //
    *newFileName = (PWSTR)ScepAlloc(0, (wcslen(oldFileName)+1)*sizeof(TCHAR));

    if (*newFileName != NULL) {
        wcscpy(*newFileName, _wcsupr(oldFileName) );
        rc = ERROR_PATH_NOT_FOUND;
    } else
        rc = ERROR_NOT_ENOUGH_MEMORY;

    return(rc);
}

VOID
ScepLogEventAndReport(
                     IN HINSTANCE hInstance,
                     IN LPTSTR LogFileName,
                     IN DWORD LogLevel,
                     IN DWORD dwEventID,
                     IN UINT  idMsg,
                     IN DWORD  rc,
                     IN PWSTR  pwszMsg
                     )
/////////////////////////////////////////////////////////////////////////////////////////////////////
// Wrapper to log efficiently                                                                      //
/////////////////////////////////////////////////////////////////////////////////////////////////////
{

    if (SCEP_VALID_NAME(LogFileName)) {

        LogEventAndReport(hInstance,
                          LogFileName,
                          LogLevel,
                          dwEventID,
                          idMsg,
                          rc,
                          pwszMsg
                         );
    }

}

DWORD
ScepCanonicalizeGroupName(
    IN PWSTR    pwszGroupName,
    OUT PWSTR    *ppwszCanonicalGroupName
    )
//////////////////////////////////////////////////////////////////////////////////
// memory allocated here should be freed outside                                //
// if SID format, returns SID itself                                            //
// else if "BuiltinDomain\Administrator" convert to "Administrator"             //
// else if (it is DC) and "g" convert to "DomainName\g"                         //
//////////////////////////////////////////////////////////////////////////////////
{
    DWORD rc = NO_ERROR;

    if (pwszGroupName == NULL || ppwszCanonicalGroupName == NULL)
        return ERROR_INVALID_PARAMETER;

    PWSTR   pwszAfterSlash = NULL;

    if (pwszAfterSlash = wcsstr(pwszGroupName, L"\\"))
        ++ pwszAfterSlash;
    else
        pwszAfterSlash = pwszGroupName;

    if ( pwszGroupName[0] == L'*' ) {

        //
        // if sid, just copy as is
        //

        *ppwszCanonicalGroupName = (PWSTR)ScepAlloc(LMEM_ZEROINIT,
                                             (wcslen(pwszGroupName) + 1) * sizeof (WCHAR)
                                             );

        if (*ppwszCanonicalGroupName == NULL)
            rc = ERROR_NOT_ENOUGH_MEMORY;
        else
            wcscpy(*ppwszCanonicalGroupName, pwszGroupName);
    }
    else if (ScepRsopLookupBuiltinNameTable(pwszAfterSlash)) {

        //
        // example -  if "BuiltinDomainName\Administrator", we need "Administrator"
        //

        *ppwszCanonicalGroupName = (PWSTR)ScepAlloc(LMEM_ZEROINIT,
                                             (wcslen(pwszAfterSlash) + 1) * sizeof (WCHAR)
                                             );

        if (*ppwszCanonicalGroupName == NULL)
            rc = ERROR_NOT_ENOUGH_MEMORY;
        else
            wcscpy(*ppwszCanonicalGroupName, pwszAfterSlash);


    }
    else if (gbDCQueried == TRUE && gbThisIsDC == TRUE) {

        //
        // example -  if "g", we need "DomainName\g"
        //

        if (NULL == wcsstr(pwszGroupName, L"\\")){

            //
            // if domain name is not available, we continue since callback will have the same problem, so OK
            //

            if (gpwszDCDomainName){

                *ppwszCanonicalGroupName = (PWSTR)ScepAlloc(LMEM_ZEROINIT,
                                                     (wcslen(gpwszDCDomainName) + wcslen(pwszGroupName) + 2) * sizeof (WCHAR)
                                                     );

                if (*ppwszCanonicalGroupName == NULL)
                    rc = ERROR_NOT_ENOUGH_MEMORY;
                else {
                    wcscpy(*ppwszCanonicalGroupName, gpwszDCDomainName);
                    wcscat(*ppwszCanonicalGroupName, L"\\");
                    wcscat(*ppwszCanonicalGroupName, pwszGroupName);
                }

            }

        }
        else {

            //
            // already in "DomainName\g" format - simply copy
            //

            *ppwszCanonicalGroupName = (PWSTR)ScepAlloc(LMEM_ZEROINIT,
                                                 (wcslen(pwszGroupName) + 1) * sizeof (WCHAR)
                                                 );

            if (*ppwszCanonicalGroupName == NULL)
                rc = ERROR_NOT_ENOUGH_MEMORY;
            else
                wcscpy(*ppwszCanonicalGroupName, pwszGroupName);

        }

    }
    else {
        //
        // simply copy - workstation or none of the above matched
        //
        *ppwszCanonicalGroupName = (PWSTR)ScepAlloc(LMEM_ZEROINIT,
                                             (wcslen(pwszGroupName) + 1) * sizeof (WCHAR)
                                             );

        if (*ppwszCanonicalGroupName == NULL)
            rc = ERROR_NOT_ENOUGH_MEMORY;
        else
            wcscpy(*ppwszCanonicalGroupName, pwszGroupName);

    }

    return rc;

}

BOOL
ScepRsopLookupBuiltinNameTable(
    IN PWSTR pwszGroupName
    )
//////////////////////////////////////////////////////////////////////////////////
// returns TRUE if group is found in builtin groups, else returns FALSE         //
//////////////////////////////////////////////////////////////////////////////////
{
    for (int i = 0; i < TABLE_SIZE; i++) {
        if ( _wcsicmp(NameTable[i].Name, pwszGroupName) == 0 )
            return TRUE;
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\scerpc\client\polfiltr.cpp ===
/*++

Copyright (c) 1987-1997 Microsoft Corporation

Module Name:

    polfiltr.cpp

Abstract:

    Policy notification implementation to support down level API calls.

    This file implements the notification logic when down level APIs
    (LSA/SAM) are called by other apps to change security policies. The
    policy changes are written to LSA database or DS, and also they are
    required to be written to the policy storage on NT5 so policy
    propagation won't overwrite the settings.


Environment:

    User mode only.
    Contains NT-specific code.

Revision History:

--*/

//
// Common include files.
//

#include "headers.h"
#include "scerpc.h"
#include "scesetup.h"
#include "sceutil.h"
#include "clntutil.h"
#include "scedllrc.h"
#include <ntrpcp.h>
#include <ntsam.h>
#include <dsrole.h>
#include <sddl.h>

//#include <gpedit.h>
//#include <initguid.h>

//#include <winldap.h>
//#include <dsgetdc.h>
#include <ntdsapi.h>
#include <io.h>
//#include "infp.h"
#include <rpcasync.h>

#pragma hdrstop

extern HINSTANCE MyModuleHandle;

//typedef DWORD (WINAPI *PFNDSGETDCNAME)(LPCTSTR, LPCTSTR, GUID *, LPCTSTR, ULONG, PDOMAIN_CONTROLLER_INFO *);

typedef VOID (WINAPI *PFNDSROLEFREE)(PVOID);

typedef DWORD (WINAPI *PFNDSROLEGETINFO)(LPCWSTR,DSROLE_PRIMARY_DOMAIN_INFO_LEVEL,PBYTE *);

typedef struct _SCEP_NOTIFYARGS_NODE {
    LIST_ENTRY List;
    SECURITY_DB_TYPE DbType;
    SECURITY_DB_DELTA_TYPE DeltaType;
    SECURITY_DB_OBJECT_TYPE ObjectType;
    PSID ObjectSid;
} SCEP_NOTIFYARGS_NODE, *PSCEP_NOTIFYARGS_NODE;


static DSROLE_MACHINE_ROLE MachineRole;
static BOOL bRoleQueried=FALSE;
static ULONG DsRoleFlags=0;

static PSID                  BuiltinDomainSid=NULL;

CRITICAL_SECTION PolicyNotificationSync;
static DWORD SceNotifyCount=0;
static BOOL gSceNotificationThreadActive=FALSE;
LIST_ENTRY ScepNotifyList;

DWORD
ScepNotifyWorkerThread(
    PVOID Ignored
    );

DWORD
ScepNotifySaveInPolicyStorage(
    IN SECURITY_DB_TYPE DbType,
    IN SECURITY_DB_DELTA_TYPE DeltaType,
    IN SECURITY_DB_OBJECT_TYPE ObjectType,
    IN PSID ObjectSid
    );

DWORD
ScepNotifySaveChangeInServer(
    IN SECURITY_DB_TYPE DbType,
    IN SECURITY_DB_DELTA_TYPE DeltaType,
    IN SECURITY_DB_OBJECT_TYPE ObjectType,
    IN PSID ObjectSid OPTIONAL,
    IN BOOL bDCGPO,
    IN DWORD ExplicitLowRight,
    IN DWORD ExplicitHighRight
    );

DWORD
ScepNotifyFailureLog(
    IN DWORD ErrCode,
    IN UINT  idMsg,
    IN DWORD DbType,
    IN DWORD ObjectType,
    IN PWSTR Message
    );

DWORD
ScepNotificationRequest(
    PSCEP_NOTIFYARGS_NODE Node
    );

DWORD
ScepSendNotificationNodeToServer(
    PSCEP_NOTIFYARGS_NODE Node
    );

NTSTATUS
WINAPI
SceNotifyPolicyDelta (
    IN SECURITY_DB_TYPE DbType,
    IN SECURITY_DB_DELTA_TYPE DeltaType,
    IN SECURITY_DB_OBJECT_TYPE ObjectType,
    IN PSID ObjectSid
    )
/*++

Routine Description:

    This function is called by the SAM and LSA services after each
    change is made to the SAM and LSA databases.  The services describe
    the type of object that is modified, the type of modification made
    on the object, the serial number of this modification etc.  This
    information will be used to query the system settings and store
    in the policy storage (GPO on DC, LPO on workstaiton/server).

Arguments:

    DbType - Type of the database that has been modified.

    DeltaType - The type of modification that has been made on the object.

    ObjectType - The type of object that has been modified.

    ObjectSid - The SID of the object that has been modified.  If the object
        modified is in a SAM database, ObjectSid is the DomainId of the Domain
        containing the object.

Return Value:

    STATUS_SUCCESS - The Service completed successfully.

--*/
{
    DWORD dwPolicyFilterOff=0;

    ScepRegQueryIntValue(
        HKEY_LOCAL_MACHINE,
        SCE_ROOT_PATH,
        TEXT("PolicyFilterOff"),
        &dwPolicyFilterOff
        );

    if ( dwPolicyFilterOff ) {
        return STATUS_SUCCESS;
    }

    if ( DbType == SecurityDbLsa ) {
        //
        // LSA policy changes
        //
        if ( ObjectType != SecurityDbObjectLsaPolicy &&
             ObjectType != SecurityDbObjectLsaAccount ) {

            return STATUS_SUCCESS;
        }

    } else if ( DbType == SecurityDbSam ) {

        //
        // SAM policy changes is supported by the standard
        // SAM change notification mechanism
        // this parameter here is not used (should not be
        // called by LSA
        //

        return STATUS_SUCCESS;

    } else {

        //
        // unknown database, do nothing.
        //

        return STATUS_SUCCESS;
    }


    //
    // Map object type and delta type to NetlogonDeltaType
    //

    switch( ObjectType ) {
    case SecurityDbObjectLsaPolicy:

        switch (DeltaType) {
        case SecurityDbNew:
        case SecurityDbChange:
            break;

        // unknown delta type
        default:
            return STATUS_SUCCESS;
        }
        break;


    case SecurityDbObjectLsaAccount:

        switch (DeltaType) {
        case SecurityDbNew:
        case SecurityDbChange:
        case SecurityDbDelete:
            break;

        // unknown delta type
        default:
            return STATUS_SUCCESS;
        }

        if ( ObjectSid == NULL ) {
            // for privileges, must have a Sid
            return STATUS_SUCCESS;
        }

        break;


    default:

        // unknown object type
        // SAM policy is filtered in DeltaNotify routine
        //
        return STATUS_SUCCESS;

    }


    //
    // Save the change to SCE policy storage
    //

    (VOID) ScepNotifySaveInPolicyStorage(DbType,
                                        DeltaType,
                                        ObjectType,
                                        ObjectSid
                                        );

    return STATUS_SUCCESS;

}


DWORD
ScepNotifySaveInPolicyStorage(
    IN SECURITY_DB_TYPE DbType,
    IN SECURITY_DB_DELTA_TYPE DeltaType,
    IN SECURITY_DB_OBJECT_TYPE ObjectType,
    IN PSID ObjectSid
    )
{
    DWORD rc=ERROR_SUCCESS;

    if ( !bRoleQueried ||
         MachineRole == DsRole_RoleBackupDomainController ||
         MachineRole == DsRole_RolePrimaryDomainController ) {


    } else {

        //
        // no filter on non-DCs
        //
        return(rc);

    }

    //
    // make a structure to pass into the new asynchronous thread
    //

    SCEP_NOTIFYARGS_NODE *pEA = (SCEP_NOTIFYARGS_NODE *)LocalAlloc(LPTR, sizeof(SCEP_NOTIFYARGS_NODE));

    if ( pEA ) {

        pEA->DbType = DbType;
        pEA->DeltaType = DeltaType;
        pEA->ObjectType = ObjectType;

        if ( ObjectSid ) {
            //
            // need to make a new buffer for this SID because once it's returned
            // it will be freed.
            //
            DWORD Len = RtlLengthSid(ObjectSid);

            pEA->ObjectSid = (PSID)LocalAlloc(0, Len+1);
            if ( pEA->ObjectSid ) {

                RtlCopySid (
                    Len+1,
                    pEA->ObjectSid,
                    ObjectSid
                    );
            } else {

                rc = ERROR_NOT_ENOUGH_MEMORY;
                LocalFree(pEA);
            }

        } else {
            pEA->ObjectSid = NULL;
        }

    } else {

        rc = ERROR_NOT_ENOUGH_MEMORY;
    }

    if ( ERROR_SUCCESS == rc ) {

        //
        // create another thread to call to engine
        // (to make sure that the current LSA call is not blocked)
        // because in engine, it quries the same change using LSA apis.
        //
        // note, when this is called, LSA is not impersonating
        // so the current calling context is running under system
        // context. No need (no way) to impersonate.
        //
        rc = ScepNotificationRequest(pEA);

        if ( ERROR_SUCCESS != rc ) {

            //
            // error occurs to queue the work item, the memory won't
            // be freed by the thread, so free it here
            //

            if ( pEA->ObjectSid ) {
                LocalFree(pEA->ObjectSid);
            }
            LocalFree(pEA);

            ScepNotifyFailureLog(rc,
                                 IDS_ERROR_CREATE_THREAD,
                                 (DWORD)DbType,
                                 (DWORD)ObjectType,
                                 NULL
                                );

        }

    } else {

        ScepNotifyFailureLog(rc,
                             IDS_ERROR_CREATE_THREAD_PARAM,
                             (DWORD)DbType,
                             (DWORD)ObjectType,
                             NULL
                            );
    }

    return rc;
}


DWORD
ScepNotificationRequest(
    PSCEP_NOTIFYARGS_NODE Node
    )
{
    BOOL Ret = TRUE ;
    DWORD rCode = ERROR_SUCCESS;

    //
    // Increment the notification count
    //
    EnterCriticalSection(&PolicyNotificationSync);
    SceNotifyCount++;

    if ( gSceNotificationThreadActive == FALSE )
    {
        Ret = QueueUserWorkItem( ScepNotifyWorkerThread, NULL, 0 );
    }

    if ( Ret )
    {
        InsertTailList( &ScepNotifyList, &Node->List );

//        ScepNotifyFailureLog(0, 0, SceNotifyCount, 0, L"Add the request");

    } else {

        rCode = GetLastError();
        //
        // decrement the count
        //
        if ( SceNotifyCount > 0 ) SceNotifyCount--;

    }

    LeaveCriticalSection(&PolicyNotificationSync);

    return rCode ;
}


DWORD
ScepNotifyFailureLog(
    IN DWORD ErrCode,
    IN UINT  idMsg,
    IN DWORD DbType,
    IN DWORD ObjectType,
    IN PWSTR Message
    )
{
    //
    // build the log file name %windir%\security\logs\Notify.log
    //

    WCHAR LogName[MAX_PATH+51];
    WCHAR Msg[MAX_PATH];

    LogName[0] = L'\0';
    GetSystemWindowsDirectory(LogName, MAX_PATH);
    LogName[MAX_PATH] = L'\0';

    wcscat(LogName, L"\\security\\logs\\notify.log\0");

    HANDLE hFile = CreateFile(LogName,
                           GENERIC_WRITE,
                           FILE_SHARE_READ,
                           NULL,
                           OPEN_ALWAYS,
                           FILE_ATTRIBUTE_NORMAL,
                           NULL);

    if (hFile != INVALID_HANDLE_VALUE) {

        DWORD dwBytesWritten;

        SetFilePointer (hFile, 0, NULL, FILE_BEGIN);

        CHAR TmpBuf[3];
        TmpBuf[0] = (CHAR)0xFF;
        TmpBuf[1] = (CHAR)0xFE;
        TmpBuf[2] = '\0';
        WriteFile (hFile, (LPCVOID)TmpBuf, 2,
                   &dwBytesWritten,
                   NULL);

        SetFilePointer (hFile, 0, NULL, FILE_END);

        //
        // print a time stamp
        //
        LARGE_INTEGER CurrentTime;
        LARGE_INTEGER SysTime;
        TIME_FIELDS   TimeFields;
        NTSTATUS      NtStatus;

        NtStatus = NtQuerySystemTime(&SysTime);

        RtlSystemTimeToLocalTime (&SysTime,&CurrentTime);

        if ( NT_SUCCESS(NtStatus) &&
             (CurrentTime.LowPart != 0 || CurrentTime.HighPart != 0) ) {

            memset(&TimeFields, 0, sizeof(TIME_FIELDS));

            RtlTimeToTimeFields (
                        &CurrentTime,
                        &TimeFields
                        );
            if ( TimeFields.Month > 0 && TimeFields.Month <= 12 &&
                 TimeFields.Day > 0 && TimeFields.Day <= 31 &&
                 TimeFields.Year > 1600 ) {

                ScepWriteVariableUnicodeLog(hFile, TRUE,
                                            L"\r\n----------------%02d/%02d/%04d %02d:%02d:%02d",
                                            TimeFields.Month,
                                            TimeFields.Day,
                                            TimeFields.Year,
                                            TimeFields.Hour,
                                            TimeFields.Minute,
                                            TimeFields.Second);
            } else {
                ScepWriteVariableUnicodeLog(hFile, TRUE,
                                            L"\r\n----------------%08x 08x",
                                            CurrentTime.HighPart,
                                            CurrentTime.LowPart);
            }
        } else {
            ScepWriteSingleUnicodeLog(hFile, TRUE, L"\r\n----------------Unknown time");
        }

        //
        // print operation status code
        //
        if ( ErrCode ) {
            ScepWriteVariableUnicodeLog(hFile, FALSE,
                                        L"Thread %x\tError=%d",
                                        GetCurrentThreadId(),
                                        ErrCode
                                        );

        } else {
            ScepWriteVariableUnicodeLog(hFile, FALSE,
                                        L"Thread %x\t",
                                        GetCurrentThreadId()
                                        );
        }

        //
        // operation type
        //

        if (Message ) {
            swprintf(Msg, L"\t%x\0",DbType);
            ScepWriteSingleUnicodeLog(hFile, FALSE, Msg);
        } else {

            switch (DbType) {
            case SecurityDbLsa:
                ScepWriteSingleUnicodeLog(hFile, FALSE, L"\tLSA");
                break;
            case SecurityDbSam:
                ScepWriteSingleUnicodeLog(hFile, FALSE, L"\tSAM");
                break;
            default:
                ScepWriteSingleUnicodeLog(hFile, FALSE, L"\tUnknown");
                break;
            }
        }

        //
        // print object type
        //

        if (Message ) {
            swprintf(Msg, L"\t%x\0",ObjectType);
            ScepWriteSingleUnicodeLog(hFile, FALSE, Msg);
        } else {
            switch (ObjectType) {
            case SecurityDbObjectLsaPolicy:
                ScepWriteSingleUnicodeLog(hFile, FALSE, L"\tPolicy");
                break;
            case SecurityDbObjectLsaAccount:
                ScepWriteSingleUnicodeLog(hFile, FALSE, L"\tAccount");
                break;
            case SecurityDbObjectSamDomain:
                ScepWriteSingleUnicodeLog(hFile, FALSE, L"\tDomain");
                break;
            case SecurityDbObjectSamUser:
            case SecurityDbObjectSamGroup:
            case SecurityDbObjectSamAlias:
                ScepWriteSingleUnicodeLog(hFile, FALSE, L"\tAccount");
                break;
            default:
                ScepWriteSingleUnicodeLog(hFile, FALSE, L"\tUnknown");
                break;
            }
        }

        //
        // load message
        // print the name(s)
        //

        ScepWriteSingleUnicodeLog(hFile, FALSE, L"\t");

        if (idMsg != 0) {
            Msg[0] = L'\0';
            LoadString (MyModuleHandle, idMsg, Msg, MAX_PATH);

            ScepWriteSingleUnicodeLog(hFile, TRUE, Msg);

        } else if (Message ) {

            ScepWriteSingleUnicodeLog(hFile, FALSE, Message);
        }

        CloseHandle (hFile);

    } else {
        return(GetLastError());
    }

    return(ERROR_SUCCESS);
}


DWORD
ScepNotifyWorkerThread(
    PVOID Ignored
    )
{

    PSCEP_NOTIFYARGS_NODE Node;
    PLIST_ENTRY List ;
    DWORD rc=0;

    EnterCriticalSection(&PolicyNotificationSync);

    //
    // if there is already a work thread on the notification, just return
    //
    if ( gSceNotificationThreadActive )
    {

        LeaveCriticalSection(&PolicyNotificationSync);

        return 0 ;
    }

    //
    // set the flag to be active
    //
    gSceNotificationThreadActive = TRUE ;

    // count is incremented in the main thread when the item is queued.
    // it may be before or after this thread.
    // InitializeEvents will check if the event is already initialized

    (void) InitializeEvents(L"SceCli");

    while ( !IsListEmpty( &ScepNotifyList ) )
    {
        List = RemoveHeadList( &ScepNotifyList );

        LeaveCriticalSection(&PolicyNotificationSync);

        //
        // get the node
        //
        Node = CONTAINING_RECORD( List, SCEP_NOTIFYARGS_NODE, List );

        rc = ScepSendNotificationNodeToServer( Node );

        EnterCriticalSection(&PolicyNotificationSync);

        //
        // decrement the global count
        //

        if ( SceNotifyCount > 0 )
            SceNotifyCount--;

//        ScepNotifyFailureLog(0, 0, SceNotifyCount, rc, L"Send over to server");
    }

    gSceNotificationThreadActive = FALSE ;

    //
    // only shutdown events when there is no pending notification
    //
    if ( SceNotifyCount == 0 )
        (void) ShutdownEvents();

    LeaveCriticalSection(&PolicyNotificationSync);

    return 0 ;
}

DWORD
ScepSendNotificationNodeToServer(
    PSCEP_NOTIFYARGS_NODE Node
    )
{
    DWORD rc=ERROR_SUCCESS;

    //
    // get machine role. If it's a DC, policy is saved to
    // the group policy object; if it's a server or workstation
    // policy is saved into the local SCE database.
    //

    if ( !bRoleQueried ) {

         PDSROLE_PRIMARY_DOMAIN_INFO_BASIC pDsRole=NULL;

         HINSTANCE hLoadDll = LoadLibrary(TEXT("netapi32.dll"));

         if ( hLoadDll) {
             PFNDSROLEGETINFO pfnDsRoleGetInfo = (PFNDSROLEGETINFO)GetProcAddress(
                                                            hLoadDll,
                                                            "DsRoleGetPrimaryDomainInformation");

             if ( pfnDsRoleGetInfo ) {

                 PFNDSROLEFREE pfnDsRoleFree = (PFNDSROLEFREE)GetProcAddress(
                                                                hLoadDll,
                                                                "DsRoleFreeMemory");

                 if ( pfnDsRoleFree ) {

                     rc = (*pfnDsRoleGetInfo)(
                                  NULL,
                                  DsRolePrimaryDomainInfoBasic,
                                  (PBYTE *)&pDsRole
                                  );
                     if ( ERROR_SUCCESS == rc ) {

                         if ( pDsRole ) {

                             MachineRole = pDsRole->MachineRole;
                             DsRoleFlags = pDsRole->Flags;
                             bRoleQueried = TRUE;

                             (*pfnDsRoleFree)( pDsRole );
                         } else {
                             rc = ERROR_MOD_NOT_FOUND;
                         }
                     }

                 } else {

                     rc = ERROR_MOD_NOT_FOUND;
                 }

             } else {
                 rc = ERROR_MOD_NOT_FOUND;
             }

             FreeLibrary(hLoadDll);

         } else {
             rc = ERROR_MOD_NOT_FOUND;
         }
    }

    if (rc != ERROR_SUCCESS ) {

        //
        // This isn't supposed to happen.
        // if it really happens, assuming it's a workstation/server
        //

        MachineRole = DsRole_RoleStandaloneWorkstation;

        LogEvent(MyModuleHandle,
                 STATUS_SEVERITY_WARNING,
                 SCEEVENT_WARNING_MACHINE_ROLE,
                 IDS_ERROR_GET_ROLE,
                 rc
                 );
    }

    //
    // policy filter shouldn't run on non-DCs.
    //
    if ( MachineRole == DsRole_RoleBackupDomainController ||
         MachineRole == DsRole_RolePrimaryDomainController ) {

        //
        // if dcpromo upgrade in progress, any account policy
        // change should be ignored (because the SAM hive is temperatory)
        // any privilege change for account domain accounts (not well
        // known, and not builtin) should also be ignored.
        //
        if ( !(DsRoleFlags & DSROLE_UPGRADE_IN_PROGRESS) ||
             ( ( Node->DbType != SecurityDbSam ) &&
               ( ( Node->ObjectType != SecurityDbObjectLsaAccount ) ||
                 !ScepIsSidFromAccountDomain( Node->ObjectSid ) ) ) ) {

            //
            // ignore any policy changes within dcpromo upgrade
            //
            // domain controllers, write to the default GPOs
            //

            rc = ScepNotifySaveChangeInServer(
                              Node->DbType,
                              Node->DeltaType,
                              Node->ObjectType,
                              Node->ObjectSid,
                              TRUE,
                              0,
                              0
                              );

            if ( ERROR_SUCCESS != rc &&
                 RPC_S_SERVER_UNAVAILABLE != rc ) {

                LogEvent(MyModuleHandle,
                         STATUS_SEVERITY_ERROR,
                         SCEEVENT_ERROR_POLICY_QUEUE,
                         IDS_ERROR_SAVE_POLICY_GPO,
                         rc
                         );
            }
        }

    }  // turn off policy filter for non-DCs

    if ( Node->ObjectSid ) {
        LocalFree(Node->ObjectSid);
    }

    LocalFree(Node);

    return rc;
}


DWORD
ScepNotifySaveChangeInServer(
    IN SECURITY_DB_TYPE DbType,
    IN SECURITY_DB_DELTA_TYPE DeltaType,
    IN SECURITY_DB_OBJECT_TYPE ObjectType,
    IN PSID ObjectSid OPTIONAL,
    IN BOOL bDCGPO,
    IN DWORD ExplicitLowRight,
    IN DWORD ExplicitHighRight
    )
{

    //
    // call RPC interface to the server where query and set the changes
    // to the template or to the database
    //

    handle_t  binding_h;
    NTSTATUS NtStatus;
    DWORD rc;

    //
    // RPC bind to the server (secure is not required)
    //

    NtStatus = ScepBindRpc(
                    NULL,
                    L"scerpc",
                    0,
                    &binding_h
                    );

    rc = RtlNtStatusToDosError(NtStatus);

    if (NT_SUCCESS(NtStatus)){

        RpcTryExcept {

            //
            // send the changes to server side to determine
            // if and where to save it
            //

            if ( bDCGPO ) {

                rc = SceRpcNotifySaveChangesInGP(
                        binding_h,
                        (DWORD)DbType,
                        (DWORD)DeltaType,
                        (DWORD)ObjectType,
                        (PSCEPR_SID)ObjectSid,
                        ExplicitLowRight,
                        ExplicitHighRight
                        );
            } // else do not filter

        } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

            //
            // get exception code (DWORD)
            //

            rc = RpcExceptionCode();

        } RpcEndExcept;

        //
        // Free the binding handle
        //

        RpcpUnbindRpc( binding_h );

    }

    return(rc);

}

DWORD
ScepProcessPolicyFilterTempFiles(
    IN LPTSTR LogFileName OPTIONAL
    )
{

    DWORD dwpPolicy=0;

    ScepRegQueryIntValue(
            HKEY_LOCAL_MACHINE,
            SCE_ROOT_PATH,
            TEXT("PolicyChangedInSetup"),
            (DWORD *)&dwpPolicy
            );

    if ( dwpPolicy ) {

        LogEventAndReport(MyModuleHandle,
                          LogFileName,
                          0,
                          0,
                          IDS_FILTER_AFTER_SETUP,
                          L""
                          );
        //
        // this is the reboot after setup, no need to detect if this is a DC
        // because the above reg value shouldn't be set for other product types
        //

        //
        // build the temp file name
        //
        TCHAR TmpFileName[MAX_PATH+50];

        memset(TmpFileName, '\0', (MAX_PATH+50)*sizeof(TCHAR));

        GetSystemWindowsDirectory(TmpFileName, MAX_PATH);
        lstrcat(TmpFileName, TEXT("\\security\\filtemp.inf"));

        INT iNotify = GetPrivateProfileInt( L"Policies",
                                            L"LsaPolicy",
                                            0,
                                            TmpFileName
                                           );
        if ( iNotify == 1 ) {
            //
            // Lsa policy is changed in setup
            //

            LogEventAndReport(MyModuleHandle,
                              LogFileName,
                              0,
                              0,
                              IDS_LSA_CHANGED_IN_SETUP,
                              L""
                              );

            ScepNotifySaveChangeInServer(
                    SecurityDbLsa,
                    SecurityDbChange,
                    SecurityDbObjectLsaPolicy,
                    NULL,
                    TRUE,
                    0,
                    0
                    );
        }

        iNotify = GetPrivateProfileInt( L"Policies",
                                        L"SamPolicy",
                                        0,
                                        TmpFileName
                                       );
        if ( iNotify == 1 ) {

            //
            // SAM policy is changed in setup
            //
            LogEventAndReport(MyModuleHandle,
                              LogFileName,
                              0,
                              0,
                              IDS_SAM_CHANGED_IN_SETUP,
                              L""
                              );

            ScepNotifySaveChangeInServer(
                    SecurityDbSam,
                    SecurityDbChange,
                    SecurityDbObjectSamDomain,
                    NULL,
                    TRUE,
                    0,
                    0
                    );
        }

        //
        // process all the accounts for user right changes
        //

        DWORD nSize;
        DWORD rLen=0;
        PWSTR SidBuffer = NULL;

        iNotify = 1;

        do {

            if ( SidBuffer ) {
                LocalFree(SidBuffer);
            }

            iNotify++;
            nSize = MAX_PATH*iNotify;

            SidBuffer = (PWSTR)LocalAlloc(0, nSize*sizeof(TCHAR));

            if ( SidBuffer ) {

                SidBuffer[0] = L'\0';
                SidBuffer[1] = L'\0';

                rLen = GetPrivateProfileSection(
                            L"Accounts",
                            SidBuffer,
                            nSize,
                            TmpFileName
                            );

            } else {

                rLen = 0;
            }

        } while ( rLen == nSize - 2 );


        //
        // find accounts, search for the '=' sign
        //
        PWSTR pStart = SidBuffer;
        PWSTR pTemp, pTemp2;
        PSID ObjectSid=NULL;

        while ( pStart && pStart[0] != L'\0' ) {

            pTemp = wcschr(pStart, L'=');

            if ( pTemp ) {
                *pTemp = L'\0';

                LogEventAndReport(MyModuleHandle,
                                  LogFileName,
                                  0,
                                  0,
                                  0,
                                  pStart
                                  );

                if ( ConvertStringSidToSid(
                            pStart,
                            &ObjectSid
                            ) ) {

                    nSize = pTemp[1] - L'0';
                    rLen = _wtol(pTemp+3);

                    DWORD dwHigh=0;

                    // search for the high value
                    pTemp2 = wcschr(pTemp+3, L' ');

                    if ( pTemp2 ) {

                        dwHigh = _wtol(pTemp2+1);

                    }

                    LogEventAndReport(MyModuleHandle,
                                      LogFileName,
                                      0,
                                      0,
                                      IDS_FILTER_NOTIFY_SERVER,
                                      L""
                                      );

                    ScepNotifySaveChangeInServer(
                            SecurityDbLsa,
                            (SECURITY_DB_DELTA_TYPE)nSize,
                            SecurityDbObjectLsaAccount,
                            ObjectSid,
                            TRUE,
                            rLen,
                            dwHigh
                            );

                }

                if ( ObjectSid ) {
                    LocalFree(ObjectSid);
                    ObjectSid = NULL;
                }

                *pTemp = L'=';
            }

            pTemp = pStart + wcslen(pStart) + 1;
            pStart = pTemp;
        }

        if ( SidBuffer ) {
            LocalFree(SidBuffer);
        }

    }

    //
    // delete the key and the temp file
    // for debugging purpose, leave the file
    //

    ScepClearPolicyFilterTempFiles(TRUE);
//    ScepClearPolicyFilterTempFiles(FALSE);

    return ERROR_SUCCESS;
}


DWORD
ScepClearPolicyFilterTempFiles(
    BOOL bClearFile
    )
{

    if ( bClearFile ) {

        TCHAR               Buffer[MAX_PATH+1];
        TCHAR               szNewName[MAX_PATH+51];

        Buffer[0] = L'\0';
        GetSystemWindowsDirectory(Buffer, MAX_PATH);
        Buffer[MAX_PATH] = L'\0';

        szNewName[0] = L'\0';

        wcscpy(szNewName, Buffer);
        wcscat(szNewName, L"\\security\\filtemp.inf\0");

        DeleteFile(szNewName);
    }

    //
    // delete the registry value
    //

    DWORD rc = ScepRegDeleteValue(
                            HKEY_LOCAL_MACHINE,
                            SCE_ROOT_PATH,
                            TEXT("PolicyChangedInSetup")
                           );

    if ( rc != ERROR_SUCCESS &&
         rc != ERROR_FILE_NOT_FOUND &&
         rc != ERROR_PATH_NOT_FOUND ) {

        // if can't delete the value, set the value to 0
        ScepRegSetIntValue( HKEY_LOCAL_MACHINE,
                            SCE_ROOT_PATH,
                            TEXT("PolicyChangedInSetup"),
                            0
                            );
    }

    return ERROR_SUCCESS;
}

// *********************************************************
// SAM policy change notifications
// procedures required by SAM notify mechanism
//
// *********************************************************
BOOLEAN
WINAPI
InitializeChangeNotify()
{
    // inidicate this DLL support notifcation routines
    // nothing special to be initialized

    NTSTATUS                     NtStatus;
    SID_IDENTIFIER_AUTHORITY     NtAuthority = SECURITY_NT_AUTHORITY;

    NtStatus = RtlAllocateAndInitializeSid(
                    &NtAuthority,
                    1,
                    SECURITY_BUILTIN_DOMAIN_RID,
                    0, 0, 0, 0, 0, 0, 0,
                    &BuiltinDomainSid
                    );
    return(TRUE);
}

BOOL
UninitializeChangeNotify()
{

    if ( BuiltinDomainSid ) {

        RtlFreeSid(BuiltinDomainSid);
        BuiltinDomainSid = NULL;

    }

    return TRUE;
}

NTSTATUS
WINAPI
DeltaNotify(
    IN PSID DomainSid,
    IN SECURITY_DB_DELTA_TYPE DeltaType,
    IN SECURITY_DB_OBJECT_TYPE ObjectType,
    IN ULONG ObjectRid,
    IN PUNICODE_STRING ObjectName OPTIONAL,
    IN PLARGE_INTEGER ModifiedCount,
    IN PSAM_DELTA_DATA DeltaData OPTIONAL
    )
/*
Routine Description:

    SAM policy change notification routine. Prototype and procedure
    names are all required by SAM (see ntsam.h)

Arguments:

    Similar to SceNotifyPolicyDelta

Return:

    NT Status (should always return success)
*/
{
    //
    // we don't track other SAM policies except the domain
    // policy (password policy and account policy)
    //

    if ( DomainSid == NULL ) {

        return STATUS_SUCCESS;
    }

    PSID AccountSid=NULL;

    switch (DeltaType) {
    case SecurityDbNew:
    case SecurityDbChange:
        if ( ObjectType != SecurityDbObjectSamDomain )
            return STATUS_SUCCESS;
        break;

    case SecurityDbDelete:

        //
        // handle account deletion notifications
        //
        if ( ObjectType != SecurityDbObjectSamUser &&
             ObjectType != SecurityDbObjectSamGroup &&
             ObjectType != SecurityDbObjectSamAlias  ) {
            return STATUS_SUCCESS;
        }

        if ( !NT_SUCCESS(ScepDomainIdToSid( DomainSid, ObjectRid, &AccountSid) ) ) {
            return STATUS_SUCCESS;
        }
        break;

    default:
        // unknown delta type
        //
        return STATUS_SUCCESS;
    }

    DWORD dwPolicyFilterOff=0;

    ScepRegQueryIntValue(
        HKEY_LOCAL_MACHINE,
        SCE_ROOT_PATH,
        TEXT("PolicyFilterOff"),
        &dwPolicyFilterOff
        );

    if ( dwPolicyFilterOff ) {
        return STATUS_SUCCESS;
    }


    if ( BuiltinDomainSid &&
         RtlEqualSid( DomainSid, BuiltinDomainSid ) ) {
        //
        // no policy to filter in the BUILTIN domain
        //
        return STATUS_SUCCESS;
    }

    (VOID) ScepNotifySaveInPolicyStorage(SecurityDbSam,
                                        DeltaType,
                                        ObjectType,
                                        AccountSid
                                        );

    if ( AccountSid ) {
        ScepFree(AccountSid);
    }

    return STATUS_SUCCESS;

}


NTSTATUS
SceOpenPolicy()
/*
Description:

    This function is called to determine if LSA policy can be opened for
    exclusive access.

    This function will check SCE policy notification count and see if there
    is any pending notifications that have not been added to the queue on the server

    Note when this function is called by LSA, the WritePolicySemaphore in LSA
    has been locked for write so other writes can't modify any policy in this window.

Return Value:

    STATUS_SUCCESS indicates the count is successfully checked and it's 0.
    STATUS_TIMEOUT indicates the queue is not empty or it fails to check the queue.

*/
{

    //
    // check the global count
    //
    NTSTATUS Status=STATUS_TIMEOUT;
    DWORD cnt=0;

    while ( TRUE ) {

        EnterCriticalSection(&PolicyNotificationSync);

        if ( SceNotifyCount == 0 ) {
            //
            // there is no pending notification
            //
            if ( STATUS_SUCCESS == Status ) {
                //
                // double check for the count
                //
                LeaveCriticalSection(&PolicyNotificationSync);

                break;

            } else {
                Status = STATUS_SUCCESS;
            }

        } else
            Status = STATUS_TIMEOUT;

        LeaveCriticalSection(&PolicyNotificationSync);

        cnt++;
        if ( cnt > 10 ) {  // timeout 1 second.
            break;
        }
        Sleep(100);  // sleep for .1 second

    }

    if ( STATUS_SUCCESS != Status ) {

        ScepNotifyFailureLog(0,
                             0,
                             SceNotifyCount,
                             (DWORD)Status,
                             L"SceOpenPolicy"
                            );

    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\scerpc\client\precedence.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    precedence.h

Abstract:

    This file contains the prototype for the main routine to calculate precedences.
    This is called during planning/diagnosis.

Author:

    Vishnu Patankar    (VishnuP)  7-April-2000

Environment:

    User Mode - Win32

Revision History:


--*/

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Includes                                                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#ifndef _precedence_
#define _precedence_

#include "headers.h"
#include "..\hashtable.h"
#include "scedllrc.h"
#include "logger.h"

#include <userenv.h>


typedef enum _SCEP_RSOP_CLASS_TYPE_{
    RSOP_SecuritySettingNumeric = 0,
    RSOP_SecuritySettingBoolean,
    RSOP_SecuritySettingString,
    RSOP_AuditPolicy,
    RSOP_SecurityEventLogSettingNumeric,
    RSOP_SecurityEventLogSettingBoolean,
    RSOP_RegistryValue,
    RSOP_UserPrivilegeRight,
    RSOP_RestrictedGroup,
    RSOP_SystemService,
    RSOP_File,
    RSOP_RegistryKey
};

const static PWSTR ScepRsopSchemaClassNames [] = {
    L"RSOP_SecuritySettingNumeric",
    L"RSOP_SecuritySettingBoolean",
    L"RSOP_SecuritySettingString",
    L"RSOP_AuditPolicy",
    L"RSOP_SecurityEventLogSettingNumeric",
    L"RSOP_SecurityEventLogSettingBoolean",
    L"RSOP_RegistryValue",
    L"RSOP_UserPrivilegeRight",
    L"RSOP_RestrictedGroup",
    L"RSOP_SystemService",
    L"RSOP_File",
    L"RSOP_RegistryKey"
};

typedef struct _SCE_KEY_LOOKUP_PRECEDENCE {
    SCE_KEY_LOOKUP    KeyLookup;
    DWORD    Precedence;
}SCE_KEY_LOOKUP_PRECEDENCE;

#define SCEP_TYPECAST(type, bufptr, offset) (*((type *)((CHAR *)bufptr + offset)))
#define NUM_KERBEROS_SUB_SETTINGS   5
#define NUM_EVENTLOG_TYPES  3

#define PLANNING_GPT_DIR TEXT("\\security\\templates\\policies\\planning\\")
#define DIAGNOSIS_GPT_DIR TEXT("\\security\\templates\\policies\\")
#define WINLOGON_LOG_PATH TEXT("\\security\\logs\\winlogon.log")
#define PLANNING_LOG_PATH TEXT("\\security\\logs\\planning.log")
#define DIAGNOSIS_LOG_FILE TEXT("\\security\\logs\\diagnosis.log")

// matrix description
// first column has keyName / settingName
// second column has field offset in SCE_PROFILE_INFO - hardcoded
// third column has setting types - from _SCEP_RSOP_CLASS_TYPE_
// fourth column has current precedence - unused for dynamic types


static SCE_KEY_LOOKUP_PRECEDENCE PrecedenceLookup[] = {

    //RSOP_SecuritySettingNumeric
    {{(PWSTR)TEXT("MinimumPasswordAge"),                       offsetof(struct _SCE_PROFILE_INFO, MinimumPasswordAge),        RSOP_SecuritySettingNumeric}, (DWORD)0},
    {{(PWSTR)TEXT("MaximumPasswordAge"),                       offsetof(struct _SCE_PROFILE_INFO, MaximumPasswordAge),        RSOP_SecuritySettingNumeric}, (DWORD)0},
    {{(PWSTR)TEXT("MinimumPasswordLength"),                    offsetof(struct _SCE_PROFILE_INFO, MinimumPasswordLength),     RSOP_SecuritySettingNumeric}, (DWORD)0},
    {{(PWSTR)TEXT("PasswordHistorySize"),                      offsetof(struct _SCE_PROFILE_INFO, PasswordHistorySize),       RSOP_SecuritySettingNumeric}, (DWORD)0},

    {{(PWSTR)TEXT("LockoutBadCount"),                          offsetof(struct _SCE_PROFILE_INFO, LockoutBadCount),           RSOP_SecuritySettingNumeric}, (DWORD)0},
    {{(PWSTR)TEXT("ResetLockoutCount"),                        offsetof(struct _SCE_PROFILE_INFO, ResetLockoutCount),         RSOP_SecuritySettingNumeric}, (DWORD)0},
    {{(PWSTR)TEXT("LockoutDuration"),                          offsetof(struct _SCE_PROFILE_INFO, LockoutDuration),           RSOP_SecuritySettingNumeric}, (DWORD)0},


    // RSOP_SecuritySettingBoolean
    {{(PWSTR)TEXT("ClearTextPassword"),                        offsetof(struct _SCE_PROFILE_INFO, ClearTextPassword),                  RSOP_SecuritySettingBoolean}, (DWORD)0},
    {{(PWSTR)TEXT("PasswordComplexity"),                       offsetof(struct _SCE_PROFILE_INFO, PasswordComplexity),                 RSOP_SecuritySettingBoolean}, (DWORD)0},
    {{(PWSTR)TEXT("RequireLogonToChangePassword"),             offsetof(struct _SCE_PROFILE_INFO, RequireLogonToChangePassword),       RSOP_SecuritySettingBoolean}, (DWORD)0},
    {{(PWSTR)TEXT("ForceLogoffWhenHourExpire"),                offsetof(struct _SCE_PROFILE_INFO, ForceLogoffWhenHourExpire),          RSOP_SecuritySettingBoolean}, (DWORD)0},
    {{(PWSTR)TEXT("LSAAnonymousNameLookup"),                   offsetof(struct _SCE_PROFILE_INFO, LSAAnonymousNameLookup),             RSOP_SecuritySettingBoolean}, (DWORD)0},
    {{(PWSTR)TEXT("EnableAdminAccount"),                      offsetof(struct _SCE_PROFILE_INFO, EnableAdminAccount),                RSOP_SecuritySettingBoolean}, (DWORD)0},
    {{(PWSTR)TEXT("EnableGuestAccount"),                      offsetof(struct _SCE_PROFILE_INFO, EnableGuestAccount),                RSOP_SecuritySettingBoolean}, (DWORD)0},

    //RSOP_SecuritySettingString
    {{(PWSTR)TEXT("NewAdministratorName"),                     offsetof(struct _SCE_PROFILE_INFO, NewAdministratorName),                      RSOP_SecuritySettingString}, (DWORD)0},
    {{(PWSTR)TEXT("NewGuestName"),                             offsetof(struct _SCE_PROFILE_INFO, NewGuestName),                              RSOP_SecuritySettingString}, (DWORD)0},

    // RSOP_AuditPolicy
    {{(PWSTR)TEXT("AuditSystemEvents"),                        offsetof(struct _SCE_PROFILE_INFO, AuditSystemEvents),                     RSOP_AuditPolicy}, (DWORD)0},
    {{(PWSTR)TEXT("AuditLogonEvents"),                         offsetof(struct _SCE_PROFILE_INFO, AuditLogonEvents),                      RSOP_AuditPolicy}, (DWORD)0},
    {{(PWSTR)TEXT("AuditObjectAccess"),                        offsetof(struct _SCE_PROFILE_INFO, AuditObjectAccess),                     RSOP_AuditPolicy}, (DWORD)0},
    {{(PWSTR)TEXT("AuditPrivilegeUse"),                        offsetof(struct _SCE_PROFILE_INFO, AuditPrivilegeUse),                     RSOP_AuditPolicy}, (DWORD)0},
    {{(PWSTR)TEXT("AuditPolicyChange"),                        offsetof(struct _SCE_PROFILE_INFO, AuditPolicyChange),                     RSOP_AuditPolicy}, (DWORD)0},
    {{(PWSTR)TEXT("AuditAccountManage"),                       offsetof(struct _SCE_PROFILE_INFO, AuditAccountManage),                    RSOP_AuditPolicy}, (DWORD)0},
    {{(PWSTR)TEXT("AuditProcessTracking"),                     offsetof(struct _SCE_PROFILE_INFO, AuditProcessTracking),                  RSOP_AuditPolicy}, (DWORD)0},
    {{(PWSTR)TEXT("AuditDSAccess"),                            offsetof(struct _SCE_PROFILE_INFO, AuditDSAccess),                         RSOP_AuditPolicy}, (DWORD)0},
    {{(PWSTR)TEXT("AuditAccountLogon"),                        offsetof(struct _SCE_PROFILE_INFO, AuditAccountLogon),                     RSOP_AuditPolicy}, (DWORD)0},

    // RSOP_SecurityEventLogSettingNumeric
    // one each for system, application, security
    // following eventlog entries should be contiguous in the same order to resemble contiguous memory
    {{(PWSTR)TEXT("MaximumLogSize"),                           offsetof(struct _SCE_PROFILE_INFO, MaximumLogSize),                        RSOP_SecurityEventLogSettingNumeric}, (DWORD)0},
    {{(PWSTR)TEXT("MaximumLogSize"),                           offsetof(struct _SCE_PROFILE_INFO, MaximumLogSize) + sizeof(DWORD),        RSOP_SecurityEventLogSettingNumeric}, (DWORD)0},
    {{(PWSTR)TEXT("MaximumLogSize"),                           offsetof(struct _SCE_PROFILE_INFO, MaximumLogSize) + 2*sizeof(DWORD),      RSOP_SecurityEventLogSettingNumeric}, (DWORD)0},
    {{(PWSTR)TEXT("AuditLogRetentionPeriod"),                  offsetof(struct _SCE_PROFILE_INFO, AuditLogRetentionPeriod),               RSOP_SecurityEventLogSettingNumeric}, (DWORD)0},
    {{(PWSTR)TEXT("AuditLogRetentionPeriod"),                  offsetof(struct _SCE_PROFILE_INFO, AuditLogRetentionPeriod) + sizeof(DWORD),RSOP_SecurityEventLogSettingNumeric}, (DWORD)0},
    {{(PWSTR)TEXT("AuditLogRetentionPeriod"),                  offsetof(struct _SCE_PROFILE_INFO, AuditLogRetentionPeriod) + 2 * sizeof(DWORD),RSOP_SecurityEventLogSettingNumeric}, (DWORD)0},
    {{(PWSTR)TEXT("RetentionDays"),                            offsetof(struct _SCE_PROFILE_INFO, RetentionDays),                         RSOP_SecurityEventLogSettingNumeric}, (DWORD)0},
    {{(PWSTR)TEXT("RetentionDays"),                            offsetof(struct _SCE_PROFILE_INFO, RetentionDays) + sizeof(DWORD),         RSOP_SecurityEventLogSettingNumeric}, (DWORD)0},
    {{(PWSTR)TEXT("RetentionDays"),                            offsetof(struct _SCE_PROFILE_INFO, RetentionDays) + 2 * sizeof(DWORD),     RSOP_SecurityEventLogSettingNumeric}, (DWORD)0},

    // RSOP_SecurityEventLogSettingBoolean - one each for system, application, security
    {{(PWSTR)TEXT("RestrictGuestAccess"),          offsetof(struct _SCE_PROFILE_INFO, RestrictGuestAccess),                               RSOP_SecurityEventLogSettingBoolean}, (DWORD)0},
    {{(PWSTR)TEXT("RestrictGuestAccess"),          offsetof(struct _SCE_PROFILE_INFO, RestrictGuestAccess) + sizeof(DWORD),               RSOP_SecurityEventLogSettingBoolean}, (DWORD)0},
    {{(PWSTR)TEXT("RestrictGuestAccess"),          offsetof(struct _SCE_PROFILE_INFO, RestrictGuestAccess) + 2 * sizeof(DWORD),           RSOP_SecurityEventLogSettingBoolean}, (DWORD)0},

    // RSOP_RegistryValue
    // can compute offset of aRegValues from this
    {{(PWSTR)TEXT("RegValueCount"),                offsetof(struct _SCE_PROFILE_INFO, RegValueCount),                                     RSOP_RegistryValue}, (DWORD)0},

    // RSOP_UserPrivilegeRight
    {{(PWSTR)TEXT("pInfPrivilegeAssignedTo"),      offsetof(struct _SCE_PROFILE_INFO, OtherInfo) + sizeof(PSCE_NAME_LIST),                RSOP_UserPrivilegeRight}, (DWORD)0},

    // RSOP_RestrictedGroup
    {{(PWSTR)TEXT("pGroupMembership"),             offsetof(struct _SCE_PROFILE_INFO, pGroupMembership),                                  RSOP_RestrictedGroup}, (DWORD)0},

    // RSOP_SystemService
    {{(PWSTR)TEXT("pServices"),                    offsetof(struct _SCE_PROFILE_INFO, pServices),                                         RSOP_SystemService}, (DWORD)0},

    // RSOP_File
    {{(PWSTR)TEXT("pFiles"),                       offsetof(struct _SCE_PROFILE_INFO, pFiles),                                RSOP_File}, (DWORD)0},

    // RSOP_RegistryKey
    {{(PWSTR)TEXT("pRegistryKeys"),                offsetof(struct _SCE_PROFILE_INFO, pRegistryKeys),                         RSOP_RegistryKey}, (DWORD)0},

    // following kerberos entries should be contiguous in the same order to resemble contiguous memory
    {{(PWSTR)TEXT("pKerberosInfo"),                offsetof(struct _SCE_PROFILE_INFO, pKerberosInfo),                         RSOP_SecuritySettingNumeric}, (DWORD)0},

    //RSOP_SecuritySettingNumeric
    {{(PWSTR)TEXT("MaxTicketAge"),                 offsetof(struct _SCE_KERBEROS_TICKET_INFO_, MaxTicketAge),                  RSOP_SecuritySettingNumeric}, (DWORD)0},
    {{(PWSTR)TEXT("MaxRenewAge"),                  offsetof(struct _SCE_KERBEROS_TICKET_INFO_, MaxRenewAge),                  RSOP_SecuritySettingNumeric}, (DWORD)0},
    {{(PWSTR)TEXT("MaxServiceAge"),                offsetof(struct _SCE_KERBEROS_TICKET_INFO_, MaxServiceAge),                  RSOP_SecuritySettingNumeric}, (DWORD)0},
    {{(PWSTR)TEXT("MaxClockSkew"),                 offsetof(struct _SCE_KERBEROS_TICKET_INFO_, MaxClockSkew),                  RSOP_SecuritySettingNumeric}, (DWORD)0},

    // RSOP_SecuritySettingBoolean
    {{(PWSTR)TEXT("TicketValidateClient"),     offsetof(struct _SCE_KERBEROS_TICKET_INFO_, TicketValidateClient),              RSOP_SecuritySettingBoolean}, (DWORD)0}
};




DWORD SceLogSettingsPrecedenceGPOs(
    IN IWbemServices   *pWbemServices,
    IN BOOL bPlanningMode,
    IN PWSTR *ppwszLogFile
    );

DWORD
ScepConvertSingleSlashToDoubleSlashPath(
    IN wchar_t *pSettingInfo,
    OUT  PWSTR *ppwszDoubleSlashPath
    );

DWORD
ScepClientTranslateFileDirName(
   IN  PWSTR oldFileName,
   OUT PWSTR *newFileName
   );

VOID
ScepLogEventAndReport(
    IN HINSTANCE hInstance,
    IN LPTSTR LogFileName,
    IN DWORD LogLevel,
    IN DWORD dwEventID,
    IN UINT  idMsg,
    IN DWORD  rc,
    IN PWSTR  pwszMsg
    );

BOOL
ScepRsopLookupBuiltinNameTable(
    IN PWSTR pwszGroupName
    );

DWORD
ScepCanonicalizeGroupName(
    IN PWSTR    pwszGroupName,
    OUT PWSTR    *ppwszCanonicalGroupName
    );


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\scerpc\client\sceclnt.cpp ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    sceclnt.cpp

Abstract:

    SCE Client APIs

Author:

    Jin Huang (jinhuang) 23-Jun-1997 created

Revision History:

    jinhuang        23-Jan-1998   split to client-server model

--*/

#include "headers.h"
#include "scerpc.h"
#include "sceutil.h"
#include "clntutil.h"
#include "infp.h"
#include "scedllrc.h"
#include <ntrpcp.h>

#include <rpcasync.h>

#pragma hdrstop

extern PVOID theCallBack;
extern HWND  hCallbackWnd;
extern DWORD CallbackType;
extern HINSTANCE MyModuleHandle;
PVOID theBrowseCallBack = NULL;

#define SCE_REGISTER_REGVALUE_SECTION TEXT("Register Registry Values")
typedef BOOL (WINAPI *PFNREFRESHPOLICY)( BOOL );

SCESTATUS
ScepMergeBuffer(
    IN OUT PSCE_PROFILE_INFO pOldBuf,
    IN PSCE_PROFILE_INFO pNewBuf,
    IN AREA_INFORMATION Area
    );

SCESTATUS
ScepConvertServices(
    IN OUT PVOID *ppServices,
    IN BOOL bSRForm
    );

SCESTATUS
ScepFreeConvertedServices(
    IN PVOID pServices,
    IN BOOL bSRForm
    );

DWORD
ScepMakeSelfRelativeSD(
    IN PSECURITY_DESCRIPTOR pInSD,
    OUT PSECURITY_DESCRIPTOR *pOutSD,
    OUT PULONG pnLen
    );
//
// exported APIs in secedit.h (for secedit UI to use)
//


SCESTATUS
WINAPI
SceGetSecurityProfileInfo(
    IN  PVOID               hProfile OPTIONAL,
    IN  SCETYPE             ProfileType,
    IN  AREA_INFORMATION    Area,
    IN OUT PSCE_PROFILE_INFO   *ppInfoBuffer,
    OUT PSCE_ERROR_LOG_INFO *Errlog OPTIONAL
    )
/*
Routine Description:

    SceGetSecurityProfileInfo will return the following type based on the
    SCETYPE parameter and profile handle:

    Profile Handle      SCETYPE      USAGE           type field in SCE_PROFILE_INFO
    ---------------------------------------------------------------------------------------------------------------------------------------------------------
    JET         SCE_ENGINE_SCP               SCE_ENGINE_SCP
    JET         SCE_ENGINE_SAP               SCE_ENGINE_SAP
    JET         SCE_ENGINE_SMP               SCE_ENGINE_SMP
    JET         all other SCETYPEs   INVALID PARAMETER

    INF         SCE_ENGINE_SCP               SCE_STRUCT_INF
    INF         all other SCETYPEs   INVALID PARAMETER

Arguments:

    hProfile    - the Inf or SCE databas handle

    ProfileType - the profile type
    Area        - the Area to read info for
    ppInfoBuffer- the output buffer
    Errlog      - the error log buffer if there is any

Retuen Value:

    SCE status

*/
{
    SCESTATUS   rc;

    if ( !ppInfoBuffer || 0 == Area ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    if ( !hProfile && ProfileType != SCE_ENGINE_SYSTEM ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    BYTE dType;

    if ( hProfile ) {
        dType = *((BYTE *)hProfile);
    } else {
        dType = 0;
    }

    //
    // the first component in both INF and JET handle structures
    // is the ProfileFormat field - DWORD
    //

    switch ( dType ) {
    case SCE_INF_FORMAT:

        //
        // Inf format is only available to SCP type
        //

        if ( ProfileType != SCE_ENGINE_SCP ) {
            return(SCESTATUS_INVALID_PARAMETER);
        }

        //
        // initialize the error log buffer
        //

        if ( Errlog ) {
            *Errlog = NULL;
        }

        rc = SceInfpGetSecurityProfileInfo(
                    ((PSCE_HINF)hProfile)->hInf,
                    Area,
                    ppInfoBuffer,
                    Errlog
                    );
        break;

    default:

        if ( ProfileType != SCE_ENGINE_SCP &&
             ProfileType != SCE_ENGINE_SMP &&
             ProfileType != SCE_ENGINE_SAP &&
             ProfileType != SCE_ENGINE_SYSTEM &&
             ProfileType != SCE_ENGINE_GPO ) {
            return(SCESTATUS_INVALID_PARAMETER);
        }

        //
        // initialize the error log buffer
        //

        if ( Errlog ) {
            *Errlog = NULL;
        }

        PSCE_PROFILE_INFO   pWkBuffer=NULL;
        PSCE_ERROR_LOG_INFO pErrTmp=NULL;

        //
        // handle Rpc exceptions
        //

        RpcTryExcept {

            if ( ProfileType == SCE_ENGINE_SYSTEM ) {

                Area &= (AREA_SECURITY_POLICY | AREA_PRIVILEGES);

                if ( hProfile ) {
                    //
                    // the local policy database can be opened
                    //
                    rc = SceRpcGetSystemSecurityFromHandle(
                                (SCEPR_CONTEXT)hProfile,
                                (AREAPR)Area,
                                0,
                                (PSCEPR_PROFILE_INFO *)&pWkBuffer,
                                (PSCEPR_ERROR_LOG_INFO *)&pErrTmp
                                );
                } else {
                    //
                    // just get system settings
                    // for normal user, the local policy database
                    // can't be opened.
                    //

                    //
                    // RPC bind to the server
                    //

                    handle_t  binding_h;
                    NTSTATUS NtStatus = ScepBindSecureRpc(
                                                NULL,
                                                L"scerpc",
                                                0,
                                                &binding_h
                                                );

                    if (NT_SUCCESS(NtStatus)){

                        RpcTryExcept {

                            rc = SceRpcGetSystemSecurity(
                                        binding_h,
                                        (AREAPR)Area,
                                        0,
                                        (PSCEPR_PROFILE_INFO *)&pWkBuffer,
                                        (PSCEPR_ERROR_LOG_INFO *)&pErrTmp
                                        );

                        } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

                            //
                            // get exception code (DWORD)
                            //

                            rc = ScepDosErrorToSceStatus(RpcExceptionCode());

                        } RpcEndExcept;

                        //
                        // Free the binding handle
                        //

                        RpcpUnbindRpc( binding_h );

                    } else {

                        rc = ScepDosErrorToSceStatus(
                                 RtlNtStatusToDosError( NtStatus ));
                    }

                }

            } else {

                rc = SceRpcGetDatabaseInfo(
                            (SCEPR_CONTEXT)hProfile,
                            (SCEPR_TYPE)ProfileType,
                            (AREAPR)Area,
                            (PSCEPR_PROFILE_INFO *)&pWkBuffer,
                            (PSCEPR_ERROR_LOG_INFO *)&pErrTmp
                            );
            }

            if ( pWkBuffer ) {

                if ( ProfileType != SCE_ENGINE_SYSTEM ) {

                    //
                    // convert the service list first
                    //

                    for ( PSCE_SERVICES ps=pWkBuffer->pServices;
                          ps != NULL; ps = ps->Next ) {

                        if ( ps->General.pSecurityDescriptor ) {
                            //
                            // this is really the SCEPR_SR_SECURITY_DESCRIPTOR *
                            //
                            PSCEPR_SR_SECURITY_DESCRIPTOR pWrap;
                            pWrap = (PSCEPR_SR_SECURITY_DESCRIPTOR)(ps->General.pSecurityDescriptor);

                            ps->General.pSecurityDescriptor = (PSECURITY_DESCRIPTOR)(pWrap->SecurityDescriptor);

                            ScepFree(pWrap);

                        }
                    }
                }

                //
                // information is loaded ok, now merge them into ppInfoBuffer
                //

                if ( *ppInfoBuffer ) {

                    if ( AREA_ALL != Area ) {
                        //
                        // merge new data into this buffer
                        //
                        ScepMergeBuffer(*ppInfoBuffer, pWkBuffer, Area);

                    } else {

                        PSCE_PROFILE_INFO pTemp=*ppInfoBuffer;
                        *ppInfoBuffer = pWkBuffer;
                        pWkBuffer = pTemp;
                    }

                    //
                    // free the work buffer
                    //

                    SceFreeProfileMemory(pWkBuffer);

                } else {

                    //
                    // just assign it to the output buffer
                    //

                    *ppInfoBuffer = pWkBuffer;
                }
            }

            //
            // assign the error log
            //
            if ( Errlog ) {
                *Errlog = pErrTmp;
                pErrTmp = NULL;
            }

        } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

            //
            // get exception code (DWORD)
            //

            rc = ScepDosErrorToSceStatus(RpcExceptionCode());

        } RpcEndExcept;

        if ( pErrTmp ) {
            //
            // free this tmp buffer
            //
            ScepFreeErrorLog(pErrTmp);
        }

        break;

    }

    return(rc);
}


SCESTATUS
ScepMergeBuffer(
    IN OUT PSCE_PROFILE_INFO pOldBuf,
    IN PSCE_PROFILE_INFO pNewBuf,
    IN AREA_INFORMATION Area
    )
/*
Routine Description:

    Merge information for the area(s) from new buffer into old buffer.

Arguments:

Return Value:

*/
{
    if ( !pOldBuf || !pNewBuf || !Area ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    __try {
        if ( Area & AREA_SECURITY_POLICY ) {

            //
            // copy system access section,
            // note: free existing memory first
            //
            if ( pOldBuf->NewAdministratorName ) {
                ScepFree(pOldBuf->NewAdministratorName);
            }

            if ( pOldBuf->NewGuestName ) {
                ScepFree(pOldBuf->NewGuestName);
            }

            size_t nStart = offsetof(struct _SCE_PROFILE_INFO, MinimumPasswordAge);
            size_t nEnd = offsetof(struct _SCE_PROFILE_INFO, ClearTextPassword)+sizeof(DWORD);

            memcpy((PBYTE)pOldBuf+nStart, (PBYTE)pNewBuf+nStart, nEnd-nStart);

            //
            // set NULL to memory directly assigned to the old buffer
            //
            pNewBuf->NewAdministratorName = NULL;
            pNewBuf->NewGuestName = NULL;

            //
            // copy kerberos policy and local policy
            // free exist memory used by the old buffer
            //
            if ( pOldBuf->pKerberosInfo ) {
                ScepFree(pOldBuf->pKerberosInfo);
            }

            nStart = offsetof(struct _SCE_PROFILE_INFO, pKerberosInfo );
            nEnd = offsetof(struct _SCE_PROFILE_INFO, CrashOnAuditFull)+sizeof(DWORD);

            memcpy((PBYTE)pOldBuf+nStart, (PBYTE)pNewBuf+nStart, nEnd-nStart);

            //
            // set NULL to memory directly assigned to the old buffer
            //
            pNewBuf->pKerberosInfo = NULL;

            //
            // copy registry values info
            //
            if ( pOldBuf->aRegValues ) {
                ScepFreeRegistryValues(&(pOldBuf->aRegValues), pOldBuf->RegValueCount);
            }
            pOldBuf->RegValueCount = pNewBuf->RegValueCount;
            pOldBuf->aRegValues = pNewBuf->aRegValues;
            pNewBuf->aRegValues = NULL;

        }

        //
        // do not care user settings
        //

        if ( Area & AREA_PRIVILEGES ) {
            //
            // privilege section
            //

            SceFreeMemory(pOldBuf, AREA_PRIVILEGES);

            pOldBuf->OtherInfo.smp.pPrivilegeAssignedTo = pNewBuf->OtherInfo.smp.pPrivilegeAssignedTo;

            pNewBuf->OtherInfo.smp.pPrivilegeAssignedTo = NULL;
        }

        if ( Area & AREA_GROUP_MEMBERSHIP ) {
            //
            // group membership area
            //
            if ( pOldBuf->pGroupMembership ) {
                ScepFreeGroupMembership(pOldBuf->pGroupMembership);
            }

            pOldBuf->pGroupMembership = pNewBuf->pGroupMembership;
            pNewBuf->pGroupMembership = NULL;

        }

        if ( Area & AREA_REGISTRY_SECURITY ) {
            //
            // registry keys
            //
            if ( pOldBuf->pRegistryKeys.pOneLevel ) {
                 ScepFreeObjectList( pOldBuf->pRegistryKeys.pOneLevel );
            }
            pOldBuf->pRegistryKeys.pOneLevel = pNewBuf->pRegistryKeys.pOneLevel;
            pNewBuf->pRegistryKeys.pOneLevel = NULL;

        }

        if ( Area & AREA_FILE_SECURITY ) {
            //
            // file security
            //
            if ( pOldBuf->pFiles.pOneLevel ) {
                 ScepFreeObjectList( pOldBuf->pFiles.pOneLevel );
            }
            pOldBuf->pFiles.pOneLevel = pNewBuf->pFiles.pOneLevel;
            pNewBuf->pFiles.pOneLevel = NULL;

        }
#if 0
        if ( Area & AREA_DS_OBJECTS ) {
            //
            // ds objects
            //
            if ( pOldBuf->pDsObjects.pOneLevel ) {
                 ScepFreeObjectList( pOldBuf->pDsObjects.pOneLevel );
            }
            pOldBuf->pDsObjects.pOneLevel = pNewBuf->pDsObjects.pOneLevel;
            pNewBuf->pDsObjects.pOneLevel = NULL;

        }
#endif
        if ( Area & AREA_SYSTEM_SERVICE ) {
            //
            // system services
            //

            if ( pOldBuf->pServices ) {
                 SceFreePSCE_SERVICES( pOldBuf->pServices);
            }
            pOldBuf->pServices = pNewBuf->pServices;
            pNewBuf->pServices = NULL;
        }

    } __except (EXCEPTION_EXECUTE_HANDLER) {
        return (SCESTATUS_OTHER_ERROR);
    }

    return(SCESTATUS_SUCCESS);
}


SCESTATUS
WINAPI
SceGetObjectChildren(
    IN PVOID hProfile,
    IN SCETYPE ProfileType,
    IN AREA_INFORMATION Area,
    IN PWSTR ObjectPrefix,
    OUT PSCE_OBJECT_CHILDREN *Buffer,
    OUT PSCE_ERROR_LOG_INFO *Errlog OPTIONAL
    )
/*
Routine Description:

    Routine to get one level of children from the SCE database for the object
    named in ObjectPrefix.

Arguments:

    hProfile    - the database context handle
    ProfileType - the database type
    Area        - the area to request (files, registry, ds objects, ..)
    ObjectPrefix - the parent object name
    Buffer      - the output buffer for object list
    Errlog      - the error log buffer

Return Value:

    SCE status of this operation
*/
{
    SCESTATUS   rc;

    if ( hProfile == NULL ||
         Buffer == NULL ||
         ObjectPrefix == NULL ) {

        return(SCESTATUS_INVALID_PARAMETER);
    }

    if ( SCE_INF_FORMAT == *((BYTE *)hProfile) ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    if ( ProfileType != SCE_ENGINE_SCP &&
         ProfileType != SCE_ENGINE_SMP &&
         ProfileType != SCE_ENGINE_SAP ) {

        return(SCESTATUS_INVALID_PARAMETER);
    }

    //
    // initialize the error log buffer
    //

    if ( Errlog ) {
        *Errlog = NULL;
    }

    //
    // call RPC interface
    //
    PSCE_ERROR_LOG_INFO pErrTmp=NULL;

    RpcTryExcept {

        //
        // structure types must be casted for RPC data marshelling
        //

        rc = SceRpcGetObjectChildren(
                    (SCEPR_CONTEXT)hProfile,
                    (SCEPR_TYPE)ProfileType,
                    (AREAPR)Area,
                    (wchar_t *)ObjectPrefix,
                    (PSCEPR_OBJECT_CHILDREN *)Buffer,
                    (PSCEPR_ERROR_LOG_INFO *)&pErrTmp
                    );
        if ( Errlog ) {
            *Errlog = pErrTmp;

        } else if ( pErrTmp ) {
            ScepFreeErrorLog(pErrTmp);
        }

    } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

        //
        // get exception code (DWORD)
        //

        rc = ScepDosErrorToSceStatus(RpcExceptionCode());

    } RpcEndExcept;

    return(rc);

}


SCESTATUS
WINAPI
SceOpenProfile(
    IN PCWSTR ProfileName OPTIONAL, // for the system database
    IN SCE_FORMAT_TYPE  ProfileFormat,
    OUT PVOID *hProfile
    )
/*
Routine Description:

Arguments:

    ProfileName - the profile name to open, use UNC name for remote

    ProfileFormat   - the format of the profile
                        SCE_INF_FORMAT,
                        SCE_JET_FORMAT,
                        SCE_JET_ANALYSIS_REQUIRED

    hProfile        - the profile handle returned

Return Value:

    SCE status of this operation
*/
{
    SCESTATUS    rc;
    LPTSTR DefProfile=NULL;
    SCEPR_CONTEXT pContext = NULL;

    if ( hProfile == NULL ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    BOOL bEmptyName=FALSE;

    if ( ProfileName == NULL || wcslen(ProfileName) == 0 ) {
        bEmptyName = TRUE;
    }

    switch (ProfileFormat ) {
    case SCE_INF_FORMAT:

        if ( bEmptyName ) {
            return(SCESTATUS_INVALID_PARAMETER);
        }
        //
        // Inf format
        //
        *hProfile = ScepAlloc( LMEM_ZEROINIT, sizeof(SCE_HINF) );
        if ( *hProfile == NULL ) {
            return(SCESTATUS_NOT_ENOUGH_RESOURCE);
        }

        ((PSCE_HINF)(*hProfile))->Type = (BYTE)SCE_INF_FORMAT;

        rc = SceInfpOpenProfile(
                    ProfileName,
                    &(((PSCE_HINF)(*hProfile))->hInf)
                    );

        if ( rc != SCESTATUS_SUCCESS ) {

            //
            // free memory
            //

            ScepFree( *hProfile );
            *hProfile = NULL;
        }

        break;

    case SCE_JET_ANALYSIS_REQUIRED:
    case SCE_JET_FORMAT:

        BOOL bAnalysis;

        if ( SCE_JET_FORMAT == ProfileFormat ) {
            bAnalysis = FALSE;

            if ( bEmptyName ) {
                //
                // looking for the system database
                //

                rc = ScepGetProfileSetting(
                            L"DefaultProfile",
                            TRUE, // in order to get system db name. Access will be checked when opening the database
                            &DefProfile
                            );
                if ( rc != ERROR_SUCCESS || DefProfile == NULL ) {
                    return(SCESTATUS_INVALID_PARAMETER);
                }
            }
        } else {

            bAnalysis = TRUE;
            //
            // jet database name is required
            //
            if ( bEmptyName ) {
                return(SCESTATUS_ACCESS_DENIED);
            }
        }

        //
        // system database can't be opened for SCM mode
        //
        if ( bAnalysis &&
             SceIsSystemDatabase(ProfileName) ) {

            return(SCESTATUS_ACCESS_DENIED);
        }

        handle_t  binding_h;
        NTSTATUS NtStatus;

        //
        // RPC bind to the server
        //

        NtStatus = ScepBindSecureRpc(
                        NULL, // should use the system name embedded within the database name
                        L"scerpc",
                        0,
                        &binding_h
                        );

        if (NT_SUCCESS(NtStatus)){

            RpcTryExcept {

                rc = SceRpcOpenDatabase(
                            binding_h,
                            bEmptyName ? (wchar_t *)DefProfile : (wchar_t *)ProfileName,
                            bAnalysis ? SCE_OPEN_OPTION_REQUIRE_ANALYSIS : 0,
                            &pContext
                           );

            } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

                //
                // get exception code (DWORD)
                //

                rc = ScepDosErrorToSceStatus(RpcExceptionCode());

            } RpcEndExcept;

            //
            // Free the binding handle
            //

            RpcpUnbindRpc( binding_h );

        } else {

            rc = ScepDosErrorToSceStatus(
                     RtlNtStatusToDosError( NtStatus ));
        }

        if ( SCESTATUS_SUCCESS == rc ) {

            //
            // database is opened
            //

            *hProfile = (PVOID)pContext;

        } else {

            *hProfile = NULL;
        }

        break;

    default:
        rc = SCESTATUS_INVALID_PARAMETER;
        break;
    }

    if ( DefProfile ) {
        ScepFree(DefProfile);
    }

    return(rc);
}


SCESTATUS
WINAPI
SceCloseProfile(
    IN PVOID *hProfile
    )
/*
Routine Description:

    Close the profile handle

Arguments:

    hProfile    - the address of a profile handle

Return Value:

    SCE status of this operation

*/
{
    if ( hProfile == NULL ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    if ( *hProfile == NULL ) {
        return(SCESTATUS_SUCCESS);
    }

    SCESTATUS rc = SCESTATUS_SUCCESS;

    switch(*((BYTE *)(*hProfile)) ) {
    case SCE_INF_FORMAT:

        //
        // close the inf handle
        //

        SceInfpCloseProfile(((PSCE_HINF)(*hProfile))->hInf);

        ScepFree(*hProfile);
        *hProfile = NULL;

        break;

    default:

        //
        // jet database, call rpc to close it
        //

        RpcTryExcept {

            rc = SceRpcCloseDatabase((SCEPR_CONTEXT *)hProfile);

        } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

            //
            // get exception code (DWORD)
            //

            rc = ScepDosErrorToSceStatus(RpcExceptionCode());

        } RpcEndExcept;

        break;
    }

    return(rc);

}


SCESTATUS
WINAPI
SceGetScpProfileDescription(
    IN PVOID hProfile,
    OUT PWSTR *Description
    )
/*
Routine Descripton:

    Get profile description from the profile handle

Arguments:

    hProfile    - the profile handle

    Description - the description output buffer

Return Value:

    SCE status
*/
{
    SCESTATUS    rc;

    if ( hProfile == NULL || Description == NULL ) {

        return(SCESTATUS_SUCCESS);
    }

    switch( *((BYTE *)hProfile) ) {
    case SCE_INF_FORMAT:

        //
        // inf format of profile
        //

        rc = SceInfpGetDescription(
                     ((PSCE_HINF)hProfile)->hInf,
                     Description
                     );
        break;

    default:

        //
        // jet database, call rpc interface
        //

        RpcTryExcept {

            rc = SceRpcGetDatabaseDescription(
                         (SCEPR_CONTEXT)hProfile,
                         (wchar_t **)Description
                         );

        } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

            //
            // get exception code (DWORD)
            //

            rc = ScepDosErrorToSceStatus(RpcExceptionCode());

        } RpcEndExcept;

        break;

    }

    return(rc);
}

SCESTATUS
WINAPI
SceGetTimeStamp(
    IN PVOID hProfile,
    OUT PWSTR *ConfigTimeStamp OPTIONAL,
    OUT PWSTR *AnalyzeTimeStamp OPTIONAL
    )
/*
Routine Descripton:

    Get SCE database last config and last analysis time stamp

Arguments:

    hProfile    - the profile handle

    ConfigTimeStamp - the time stamp for last config

    AnalyzeTimeStamp - the time stamp for last analysis


Return Value:

    SCE status
*/
{
    SCESTATUS rc;
    LARGE_INTEGER TimeStamp1;
    LARGE_INTEGER TimeStamp2;
    LARGE_INTEGER ConfigTime;
    LARGE_INTEGER AnalyzeTime;
    TIME_FIELDS   TimeFields;

    if ( hProfile == NULL ||
         ( ConfigTimeStamp == NULL &&
         AnalyzeTimeStamp == NULL) ) {

        return(SCESTATUS_INVALID_PARAMETER);
    }

    //
    // call RPC interface
    //

    RpcTryExcept {

        rc = SceRpcGetDBTimeStamp(
                 (SCEPR_CONTEXT)hProfile,
                 &ConfigTime,
                 &AnalyzeTime
                 );

    } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

        //
        // get exception code (DWORD)
        //

        rc = ScepDosErrorToSceStatus(RpcExceptionCode());

    } RpcEndExcept;

    if ( rc == SCESTATUS_SUCCESS ) {

        if ( ConfigTimeStamp ) {

            *ConfigTimeStamp = NULL;

            if ( ConfigTime.HighPart != 0 || ConfigTime.LowPart != 0 ) {

                //
                // convert the config time stamp from LARGE_INTEGER to
                // string format
                //

                RtlSystemTimeToLocalTime(&ConfigTime, &TimeStamp1);

                if ( TimeStamp1.LowPart != 0 ||
                     TimeStamp1.HighPart != 0) {

                    memset(&TimeFields, 0, sizeof(TIME_FIELDS));

                    RtlTimeToTimeFields (
                                &TimeStamp1,
                                &TimeFields
                                );
                    if ( TimeFields.Month > 0 && TimeFields.Month <= 12 &&
                         TimeFields.Day > 0 && TimeFields.Day <= 31 &&
                         TimeFields.Year > 1600 ) {

                        *ConfigTimeStamp = (PWSTR)ScepAlloc(0, 60); //60 bytes

                        swprintf(*ConfigTimeStamp, L"%02d/%02d/%04d %02d:%02d:%02d",
                                 TimeFields.Month, TimeFields.Day, TimeFields.Year,
                                 TimeFields.Hour, TimeFields.Minute, TimeFields.Second);
                    } else {

                        *ConfigTimeStamp = (PWSTR)ScepAlloc(0, 40); //40 bytes
                        swprintf(*ConfigTimeStamp, L"%08x%08x", TimeStamp1.HighPart, TimeStamp1.LowPart);
                    }
                }
            }
        }

        if ( AnalyzeTimeStamp ) {

            *AnalyzeTimeStamp = NULL;

            if ( AnalyzeTime.HighPart != 0 || AnalyzeTime.LowPart != 0 ) {

                //
                // convert the analysis time stamp from LARGE_INTEGER
                // to string format
                //

                RtlSystemTimeToLocalTime(&AnalyzeTime, &TimeStamp2);

                if ( TimeStamp2.LowPart != 0 ||
                     TimeStamp2.HighPart != 0) {

                    memset(&TimeFields, 0, sizeof(TIME_FIELDS));

                    RtlTimeToTimeFields (
                                &TimeStamp2,
                                &TimeFields
                                );
                    if ( TimeFields.Month > 0 && TimeFields.Month <= 12 &&
                         TimeFields.Day > 0 && TimeFields.Day <= 31 &&
                         TimeFields.Year > 1600 ) {

                        *AnalyzeTimeStamp = (PWSTR)ScepAlloc(0, 60); //40 bytes

                        swprintf(*AnalyzeTimeStamp, L"%02d/%02d/%04d %02d:%02d:%02d",
                                 TimeFields.Month, TimeFields.Day, TimeFields.Year,
                                 TimeFields.Hour, TimeFields.Minute, TimeFields.Second);
                    } else {

                        *AnalyzeTimeStamp = (PWSTR)ScepAlloc(0, 40); //40 bytes
                        swprintf(*AnalyzeTimeStamp, L"%08x%08x", TimeStamp2.HighPart, TimeStamp2.LowPart);
                    }
                }
            }
        }
    }

    return(rc);
}

SCESTATUS
WINAPI
SceGetDbTime(
    IN PVOID hProfile,
    OUT SYSTEMTIME *ConfigDateTime,
    OUT SYSTEMTIME *AnalyzeDateTime
    )

/*
Routine Descripton:

    Get SCE database last config and last analysis time (in SYSTEMTIME structure)

Arguments:

    hProfile    - the profile handle

    ConfigDateTime  - the system time for last configuration

    AnalyzeDateTime - the system time for last analysis


Return Value:

    SCE status
*/
{
    SCESTATUS rc;
    LARGE_INTEGER TimeStamp;
    LARGE_INTEGER ConfigTimeStamp;
    LARGE_INTEGER AnalyzeTimeStamp;
    FILETIME      ft;

    if ( hProfile == NULL ||
         ( ConfigDateTime == NULL &&
         AnalyzeDateTime == NULL) ) {

        return(SCESTATUS_INVALID_PARAMETER);
    }

    //
    // call RPC interface
    //

    RpcTryExcept {

        rc = SceRpcGetDBTimeStamp(
                 (SCEPR_CONTEXT)hProfile,
                 &ConfigTimeStamp,
                 &AnalyzeTimeStamp
                 );

    } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

        //
        // get exception code (DWORD)
        //

        rc = ScepDosErrorToSceStatus(RpcExceptionCode());

    } RpcEndExcept;

    if ( rc == SCESTATUS_SUCCESS ) {

        if ( ConfigDateTime ) {

            memset(ConfigDateTime, '\0', sizeof(SYSTEMTIME));

            if ( ConfigTimeStamp.HighPart != 0 || ConfigTimeStamp.LowPart != 0 ) {

                //
                // convert the config time stamp from LARGE_INTEGER to
                // string format
                //

                RtlSystemTimeToLocalTime(&ConfigTimeStamp, &TimeStamp);

                if ( TimeStamp.LowPart != 0 ||
                     TimeStamp.HighPart != 0) {

                    ft.dwLowDateTime = TimeStamp.LowPart;
                    ft.dwHighDateTime = TimeStamp.HighPart;

                    if ( !FileTimeToSystemTime(&ft, ConfigDateTime) ) {

                        rc = ScepDosErrorToSceStatus(GetLastError());
                    }
                }
            }
        }

        if ( AnalyzeDateTime && (SCESTATUS_SUCCESS == rc) ) {

            memset(AnalyzeDateTime, '\0', sizeof(SYSTEMTIME));

            if ( AnalyzeTimeStamp.HighPart != 0 || AnalyzeTimeStamp.LowPart != 0 ) {

                //
                // convert the analysis time stamp from LARGE_INTEGER
                // to string format
                //

                RtlSystemTimeToLocalTime(&AnalyzeTimeStamp, &TimeStamp);

                if ( TimeStamp.LowPart != 0 ||
                     TimeStamp.HighPart != 0) {

                    ft.dwLowDateTime = TimeStamp.LowPart;
                    ft.dwHighDateTime = TimeStamp.HighPart;

                    if ( !FileTimeToSystemTime(&ft, AnalyzeDateTime) ) {

                        rc = ScepDosErrorToSceStatus(GetLastError());
                    }
                }
            }
        }
    }

    return(rc);

}


SCESTATUS
WINAPI
SceGetObjectSecurity(
    IN PVOID hProfile,
    IN SCETYPE ProfileType,
    IN AREA_INFORMATION Area,
    IN PWSTR ObjectName,
    OUT PSCE_OBJECT_SECURITY *ObjSecurity
    )
/*
Routine Descripton:

    Get security setting for an object from the SCE database

Arguments:

    hProfile    - the profile handle

    ProfileType - the database type

    Area        - the security area to get info (file, registry, ..)

    ObjectName  - the object's name (full path)

    ObjSecurity - the security settings (flag, SDDL)

Return Value:

    SCE status
*/
{
    SCESTATUS   rc;

    if ( hProfile == NULL ||
         ObjectName == NULL ||
         ObjSecurity == NULL ) {

        return(SCESTATUS_INVALID_PARAMETER);
    }

    if ( ProfileType != SCE_ENGINE_SCP &&
         ProfileType != SCE_ENGINE_SMP &&
         ProfileType != SCE_ENGINE_SAP ) {

        return(SCESTATUS_INVALID_PARAMETER);
    }

    //
    // call rpc interface
    //

    RpcTryExcept {

        rc = SceRpcGetObjectSecurity(
                    (SCEPR_CONTEXT)hProfile,
                    (SCEPR_TYPE)ProfileType,
                    (AREAPR)Area,
                    (wchar_t *)ObjectName,
                    (PSCEPR_OBJECT_SECURITY *)ObjSecurity
                    );

        //
        // convert the security descriptor
        //

        if ( *ObjSecurity && (*ObjSecurity)->pSecurityDescriptor ) {

            //
            // this is really the SCEPR_SR_SECURITY_DESCRIPTOR *
            //
            PSCEPR_SR_SECURITY_DESCRIPTOR pWrap = (PSCEPR_SR_SECURITY_DESCRIPTOR)((*ObjSecurity)->pSecurityDescriptor);

            (*ObjSecurity)->pSecurityDescriptor = (PSECURITY_DESCRIPTOR)(pWrap->SecurityDescriptor);

            ScepFree(pWrap);
        }

    } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

        //
        // get exception code (DWORD)
        //

        rc = ScepDosErrorToSceStatus(RpcExceptionCode());

    } RpcEndExcept;


    return(rc);

}


SCESTATUS
WINAPI
SceGetAnalysisAreaSummary(
    IN PVOID hProfile,
    IN AREA_INFORMATION Area,
    OUT PDWORD pCount
    )
/*
Routine Descripton:

    Get summary information for the security area from SCE database.

Arguments:

    hProfile    - the profile handle

    Area        - the security area to get info

    pCount      - the total object count

Return Value:

    SCE status
*/
{

    if ( hProfile == NULL || pCount == NULL ) {

        return(SCESTATUS_INVALID_PARAMETER);
    }

    //
    // call RPC interface
    //

    SCESTATUS rc;

    RpcTryExcept {

        rc = SceRpcGetAnalysisSummary(
                            (SCEPR_CONTEXT)hProfile,
                            (AREAPR)Area,
                            pCount
                            );

    } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

        //
        // get exception code (DWORD)
        //

        rc = ScepDosErrorToSceStatus(RpcExceptionCode());

    } RpcEndExcept;

    return(rc);
}



SCESTATUS
WINAPI
SceCopyBaseProfile(
    IN PVOID hProfile,
    IN SCETYPE ProfileType,
    IN PWSTR InfFileName,
    IN AREA_INFORMATION Area,
    OUT PSCE_ERROR_LOG_INFO *pErrlog OPTIONAL
    )
/* ++
Routine Description:

    Copy the base profile from Jet database into a inf profile.

Arguments:

    hProfile    - the database handle

    InfFileName - the inf template name to generate

    Area        - the area to generate

    pErrlog     - the error log buffer

Return Value:

    SCE status

-- */
{
    SCESTATUS    rc;
    PWSTR Description=NULL;
    PSCE_PROFILE_INFO pSmpInfo=NULL;
    SCE_PROFILE_INFO scpInfo;
    AREA_INFORMATION Area2;

    PSCE_ERROR_LOG_INFO pErrTmp=NULL;
    PSCE_ERROR_LOG_INFO errTmp;


    if ( hProfile == NULL || InfFileName == NULL ) {

        return(SCESTATUS_INVALID_PARAMETER);
    }

    if ( ProfileType != SCE_ENGINE_SCP &&
         ProfileType != SCE_ENGINE_SMP ) {

        return(SCESTATUS_INVALID_PARAMETER);
    }

    //
    // make RPC calls to query information
    //

    RpcTryExcept {

        //
        // read profile description, if fails here, continue
        //

        rc = SceRpcGetDatabaseDescription(
                     (SCEPR_CONTEXT)hProfile,
                     (wchar_t **)&Description
                     );

    } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

        //
        // get exception code (DWORD)
        //

        rc = ScepDosErrorToSceStatus(RpcExceptionCode());

    } RpcEndExcept;

    //
    // create a new inf profile with [Version] section and make it unicode
    //

    if ( !SetupINFAsUCS2(InfFileName) ) {
        //
        //if error continues
        //
        rc = ScepDosErrorToSceStatus(GetLastError());
    }

    if ( !WritePrivateProfileSection(
                        L"Version",
                        L"signature=\"$CHICAGO$\"\0Revision=1\0\0",
                        (LPCTSTR)InfFileName) ) {

        rc = ScepDosErrorToSceStatus(GetLastError());
        goto Cleanup;
    }

    //
    // create [description], if error, continue
    //

    if ( Description ) {

        //
        // empty the description section first.
        //

        WritePrivateProfileSection(
                            L"Profile Description",
                            NULL,
                            (LPCTSTR)InfFileName);

        WritePrivateProfileString(
                    L"Profile Description",
                    L"Description",
                    Description,
                    (LPCTSTR)InfFileName);

    }

    //
    // info for the following areas can be retrieved together
    //

    Area2 = Area & ( AREA_SECURITY_POLICY |
                     AREA_GROUP_MEMBERSHIP |
                     AREA_PRIVILEGES );

    rc = SCESTATUS_SUCCESS;

    //
    // initialize the error log buffer
    //

    if ( pErrlog ) {
        *pErrlog = NULL;
    }

    if ( Area2 != 0 ) {

        //
        // read base profile information
        //

        rc = SceGetSecurityProfileInfo(
                    hProfile,
                    ProfileType, // SCE_ENGINE_SMP,
                    Area2,
                    &pSmpInfo,
                    &pErrTmp
                    );

        if ( pErrlog ) {
            *pErrlog = pErrTmp;

        } else if ( pErrTmp ) {
            ScepFreeErrorLog(pErrTmp);
        }
        pErrTmp = NULL;

        if ( rc == SCESTATUS_SUCCESS && pSmpInfo != NULL ) {

            //
            // use a new error buffer if pErrlog is not NULL
            // because SceWriteSecurityProfileInfo reset the errlog buffer to NULL
            // at beginning
            //

            rc = SceWriteSecurityProfileInfo(
                    InfFileName,
                    Area2,
                    pSmpInfo,
                    &pErrTmp
                    );

            if ( pErrlog && pErrTmp ) {

                //
                // link the new error buffer to the end of pErrlog
                //

                if ( *pErrlog ) {

                    //
                    // find the end of the buffer
                    //

                    for ( errTmp=*pErrlog;
                          errTmp && errTmp->next;
                          errTmp=errTmp->next);

                    //
                    // when this loop is done, errTmp->next must be NULL
                    //

                    errTmp->next = pErrTmp;

                } else {
                    *pErrlog = pErrTmp;
                }
                pErrTmp = NULL;
            }

        }
        if ( rc != SCESTATUS_SUCCESS ) {
            goto Cleanup;
        }
    }

    //
    // copy privileges area
    //

    if ( Area & AREA_PRIVILEGES && pSmpInfo != NULL ) {

        //
        // write [Privileges] section
        // a new error buffer is used because the api below reset the error buffer
        //

        scpInfo.OtherInfo.scp.u.pInfPrivilegeAssignedTo = pSmpInfo->OtherInfo.smp.pPrivilegeAssignedTo;

        rc = SceWriteSecurityProfileInfo(
                    InfFileName,
                    AREA_PRIVILEGES,
                    &scpInfo,
                    &pErrTmp
                    );

        if ( pErrlog && pErrTmp ) {

            //
            // link the new error buffer to the end of pErrlog
            //

            if ( *pErrlog ) {

                //
                // find the end of the buffer
                //

                for ( errTmp=*pErrlog;
                      errTmp && errTmp->next;
                      errTmp=errTmp->next);

                //
                // when this loop is done, errTmp->next must be NULL
                //

                errTmp->next = pErrTmp;

            } else {
                *pErrlog = pErrTmp;
            }
            pErrTmp = NULL;
        }

        if ( rc != SCESTATUS_SUCCESS )
            goto Cleanup;
    }

    //
    // copy objects
    //

    Area2 = Area & ( AREA_REGISTRY_SECURITY |
                     AREA_FILE_SECURITY |
//                     AREA_DS_OBJECTS |
                     AREA_SYSTEM_SERVICE |
                     AREA_SECURITY_POLICY |
                     AREA_ATTACHMENTS);
    if ( Area2 ) {

        //
        // write objects section (szRegistryKeys, szFileSecurity,
        // szDSSecurity, szServiceGeneral)
        //

        RpcTryExcept {

            rc = SceRpcCopyObjects(
                        (SCEPR_CONTEXT)hProfile,
                        (SCEPR_TYPE)ProfileType,
                        (wchar_t *)InfFileName,
                        (AREAPR)Area2,
                        (PSCEPR_ERROR_LOG_INFO *)&pErrTmp
                        );

            if ( pErrlog && pErrTmp ) {

                //
                // link the new error buffer to the end of pErrlog
                //

                if ( *pErrlog ) {

                    //
                    // find the end of the buffer
                    //

                    for ( errTmp=*pErrlog;
                          errTmp && errTmp->next;
                          errTmp=errTmp->next);

                    //
                    // when this loop is done, errTmp->next must be NULL
                    //

                    errTmp->next = pErrTmp;

                } else {
                    *pErrlog = pErrTmp;
                }
                pErrTmp = NULL;
            }

        } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

            //
            // get exception code (DWORD)
            //

            rc = ScepDosErrorToSceStatus(RpcExceptionCode());

        } RpcEndExcept;

    }


Cleanup:

    if ( Description != NULL ) {

        ScepFree(Description);
    }

    if ( pSmpInfo != NULL ) {

        Area2 = Area & ( AREA_SECURITY_POLICY |
                         AREA_GROUP_MEMBERSHIP |
                         AREA_PRIVILEGES );

        SceFreeProfileMemory(pSmpInfo);
    }

    if ( pErrTmp ) {
        ScepFreeErrorLog(pErrTmp);
    }
    return(rc);

}


SCESTATUS
WINAPI
SceConfigureSystem(
    IN LPTSTR SystemName OPTIONAL,
    IN PCWSTR InfFileName OPTIONAL,
    IN PCWSTR DatabaseName,
    IN PCWSTR LogFileName OPTIONAL,
    IN DWORD ConfigOptions,
    IN AREA_INFORMATION Area,
    IN PSCE_AREA_CALLBACK_ROUTINE pCallback OPTIONAL,
    IN HANDLE hCallbackWnd OPTIONAL,
    OUT PDWORD pdWarning OPTIONAL
    )
// see ScepConfigSystem
{

    AREA_INFORMATION Area2=Area;

    if ( DatabaseName == NULL ||
         SceIsSystemDatabase(DatabaseName) ) {

        //
        // detect if this is system database (admin logon)
        // no configuration is allowed.
        //
        if ( DatabaseName == NULL ) {
            BOOL bAdminLogon=FALSE;
            ScepIsAdminLoggedOn(&bAdminLogon);

            if ( bAdminLogon ) {
                return(SCESTATUS_ACCESS_DENIED);
            }
        } else
            return(SCESTATUS_ACCESS_DENIED);

    }

    SCESTATUS rc;
    DWORD  dOptions;

    ScepSetCallback((PVOID)pCallback, hCallbackWnd, SCE_AREA_CALLBACK);

    //
    // filter out invalid options from clients
    // filter out areas other than security policy and user rights
    //
    dOptions = ConfigOptions & 0xFFL;

    rc = ScepConfigSystem(
              SystemName,
              InfFileName,
              DatabaseName,
              LogFileName,
              dOptions,
              Area2,
              pCallback,
              hCallbackWnd,
              pdWarning
              );

    ScepSetCallback(NULL, NULL, 0);

    if ( DatabaseName != NULL &&
         !SceIsSystemDatabase(DatabaseName) &&
         !(ConfigOptions & SCE_NO_CONFIG) &&
         (Area2 & AREA_SECURITY_POLICY) ) {

        //
        // private database, should trigger policy propagation
        // delete the last configuration time
        //
        HKEY hKey=NULL;

        if( RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                        SCE_ROOT_PATH,
                        0,
                        KEY_READ | KEY_WRITE,
                        &hKey
                        ) == ERROR_SUCCESS ) {

            RegDeleteValue(hKey, TEXT("LastWinlogonConfig"));

            RegCloseKey( hKey );

        }

        HINSTANCE hLoadDll = LoadLibrary(TEXT("userenv.dll"));

        if ( hLoadDll) {
            PFNREFRESHPOLICY pfnRefreshPolicy = (PFNREFRESHPOLICY)GetProcAddress(
                                                           hLoadDll,
                                                           "RefreshPolicy");
            if ( pfnRefreshPolicy ) {

                (*pfnRefreshPolicy )( TRUE );
            }

            FreeLibrary(hLoadDll);
        }

    }

    return(rc);
}

SCESTATUS
ScepConfigSystem(
    IN LPTSTR SystemName OPTIONAL,
    IN PCWSTR InfFileName OPTIONAL,
    IN PCWSTR DatabaseName OPTIONAL,
    IN PCWSTR LogFileName OPTIONAL,
    IN DWORD ConfigOptions,
    IN AREA_INFORMATION Area,
    IN PSCE_AREA_CALLBACK_ROUTINE pCallback OPTIONAL,
    IN HANDLE hCallbackWnd OPTIONAL,
    OUT PDWORD pdWarning OPTIONAL
    )
/* ++
Routine Description:

    Routine to configure a system or local system if SystemName is NULL.
    If DatabaseName is NULL, the default databae on the system is used.
    if InfFileName is provided, depending on the ConfigOptions, info in
    the InfFileName is either appended to the database (if exist), or used
    to create/overwrite the database.

    ConfigOptions can contain flags such as verbose log, no log, and overwrite
    /update database. When overwrite is specified, existing database info
    is overwritten by the inf template, and all analysis information is
    cleaned up.

    Callback pointers to the client can be registered as the arguments for
    progress indication.

    A warning code is also returned if there is any warning occurs during the
    operation while the SCESTATUS return code is SCESTATUS_SUCCESS. Examples
    such as ERROR_FILE_NOT_FOUND, or ERROR_ACCESS_DENIED when configuring
    the system won't be counted as error of this operation because the current
    user context may not have proper access to some of the resources specified
    in the template.

Arguments:

    SystemName  - the system name where this operation will run, NULL for local system

    InfFileName - optional inf template name, if NULL, existing info in the SCe
                  database is used to configure.

    DatabaseName - the SCE database name. if NULL, the default is used.

    LogFileName - optional log file name for the operation

    ConfigOptions - the options to configure
                          SCE_OVERWRITE_DB
                          SCE_UPDATE_DB
                          SCE_VERBOSE_LOG
                          SCE_DISABLE_LOG

    Area        - Area to configure

    pCallback   - optional client callback routine

    hCallbackWnd - a callback window handle

    pdWarning - the warning code

Return Value:

    SCE status

-- */
{

    SCESTATUS rc;
    handle_t  binding_h;
    NTSTATUS NtStatus;
    DWORD  dOptions;

    dOptions = ConfigOptions & ~(SCE_CALLBACK_DELTA |
                                 SCE_CALLBACK_TOTAL |
                                 SCE_POLBIND_NO_AUTH);

    if ( pCallback ) {
        dOptions |= SCE_CALLBACK_TOTAL;
    }

    //
    // check the input arguments
    //

    LPCTSTR NewInf = NULL;
    LPCTSTR NewDb = NULL;
    LPCTSTR NewLog = NULL;

    __try {
        if ( InfFileName && wcslen(InfFileName) > 0 ) {
            NewInf = InfFileName;
        }
    } __except (EXCEPTION_EXECUTE_HANDLER) {

    }

    __try {
        if ( DatabaseName && wcslen(DatabaseName) > 0 ) {
            NewDb = DatabaseName;
        }
    } __except (EXCEPTION_EXECUTE_HANDLER) {

    }

    __try {
        if ( LogFileName && wcslen(LogFileName) > 0 ) {
            NewLog = LogFileName;
        }
    } __except (EXCEPTION_EXECUTE_HANDLER) {

    }
/*
    if ( (ConfigOptions & SCE_POLICY_TEMPLATE) &&
         !(ConfigOptions & SCE_NO_CONFIG) &&
         (Area & (AREA_SECURITY_POLICY | AREA_PRIVILEGES)) ) {

        //
        // turn off policy filter
        //
        ScepRegSetIntValue(HKEY_LOCAL_MACHINE,
                           SCE_ROOT_PATH,
                           TEXT("PolicyFilterOff"),
                           1
                          );
    }
*/
    //
    // RPC bind to the server
    //
    if ( ConfigOptions & SCE_POLBIND_NO_AUTH ) {

        NtStatus = ScepBindRpc(
                        SystemName,
                        L"scerpc",
                        L"security=impersonation dynamic false",
                        &binding_h
                        );
    } else {

        NtStatus = ScepBindSecureRpc(
                        SystemName,
                        L"scerpc",
                        L"security=impersonation dynamic false",
                        &binding_h
                        );
    }

    if (NT_SUCCESS(NtStatus)){

        LPVOID pebClient = GetEnvironmentStrings();
        DWORD ebSize = ScepGetEnvStringSize(pebClient);

        RpcTryExcept {

            DWORD dWarn=0;

            rc = SceRpcConfigureSystem(
                           binding_h,
                           (wchar_t *)NewInf,
                           (wchar_t *)NewDb,
                           (wchar_t *)NewLog,
                           dOptions,
                           (AREAPR)Area,
                           ebSize,
                           (UCHAR *)pebClient,
                           &dWarn
                           );

            if ( pdWarning ) {
                *pdWarning = dWarn;
            }

        } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

            //
            // get exception code (DWORD)
            //

            rc = ScepDosErrorToSceStatus(RpcExceptionCode());

        } RpcEndExcept;

        //
        // Free the binding handle
        //

        RpcpUnbindRpc( binding_h );

    } else {

        rc = ScepDosErrorToSceStatus(
                 RtlNtStatusToDosError( NtStatus ));
    }

/*
    if ( (ConfigOptions & SCE_POLICY_TEMPLATE) &&
         !(ConfigOptions & SCE_NO_CONFIG) &&
         (Area & (AREA_SECURITY_POLICY | AREA_PRIVILEGES)) ) {

        //
        // delete the value
        //
        dOptions = ScepRegDeleteValue(HKEY_LOCAL_MACHINE,
                                     SCE_ROOT_PATH,
                                     TEXT("PolicyFilterOff")
                                     );

        if ( dOptions != ERROR_SUCCESS &&
            dOptions != ERROR_FILE_NOT_FOUND &&
            dOptions != ERROR_PATH_NOT_FOUND ) {

            ScepRegSetIntValue(HKEY_LOCAL_MACHINE,
                               SCE_ROOT_PATH,
                               TEXT("PolicyFilterOff"),
                               0
                              );
        }
    }
*/

    return(rc);
}


SCESTATUS
WINAPI
SceAnalyzeSystem(
    IN LPTSTR SystemName OPTIONAL,
    IN PCWSTR InfFileName OPTIONAL,
    IN PCWSTR DatabaseName,
    IN PCWSTR LogFileName OPTIONAL,
    IN DWORD AnalyzeOptions,
    IN AREA_INFORMATION Area,
    IN PSCE_AREA_CALLBACK_ROUTINE pCallback OPTIONAL,
    IN HANDLE hCallbackWnd OPTIONAL,
    OUT PDWORD pdWarning OPTIONAL
    )
/* ++
Routine Description:

    Routine to analyze a system or local system if SystemName is NULL.
    If DatabaseName is NULL, the default databae on the system is used.
    if InfFileName is provided with OVERWRITE flag in AnalyzeOptions,
    the database must NOT exist, otherwise, the Inf template is ignored
    and the system is analyzed based on the info in the database. When
    APPEND is specified in the flag, the InfFileName is appended to the
    database (if exist), or used to create the database, then overall
    information in the database is used to analyze the system.

    AnalyzeOptions can contain flags such as verbose log, no log, and overwrite
    /update database.

    Callback pointers to the client can be registered as the arguments for
    progress indication.

    A warning code is also returned if there is any warning occurs during the
    operation while the SCESTATUS return code is SCESTATUS_SUCCESS. Examples
    such as ERROR_FILE_NOT_FOUND, or ERROR_ACCESS_DENIED when configuring
    the system won't be counted as error of this operation because the current
    user context may not have proper access to some of the resources specified
    in the template.

Arguments:

    SystemName  - the system name where this operation will run, NULL for local system

    InfFileName - optional inf template name, if NULL, existing info in the SCe
                  database is used to configure.

    DatabaseName - the SCE database name. if NULL, the default is used.

    LogFileName - optional log file name for the operation

    AnalzyeOptions - the options to configure
                          SCE_OVERWRITE_DB
                          SCE_UPDATE_DB
                          SCE_VERBOSE_LOG
                          SCE_DISABLE_LOG

    Area        - reserved

    pCallback   - optional client callback routine

    hCallbackWnd - a callback window handle

    pdWarning - the warning code

Return Value:

    SCE status

-- */
{

    if ( DatabaseName == NULL ||
         SceIsSystemDatabase(DatabaseName) ) {

        //
        // detect if this is system database (admin logon)
        // no configuration is allowed.
        //
        if ( DatabaseName == NULL ) {
            BOOL bAdminLogon=FALSE;
            ScepIsAdminLoggedOn(&bAdminLogon);

            if ( bAdminLogon ) {
                return(SCESTATUS_ACCESS_DENIED);
            }
        } else
            return(SCESTATUS_ACCESS_DENIED);
    }

    SCESTATUS rc;
    handle_t  binding_h;
    NTSTATUS NtStatus;
    DWORD  dOptions;

    ScepSetCallback((PVOID)pCallback, hCallbackWnd, SCE_AREA_CALLBACK);

    //
    // filter out invalid options
    //
    dOptions = AnalyzeOptions & 0xFFL;
    dOptions = dOptions & ~(SCE_CALLBACK_DELTA | SCE_CALLBACK_TOTAL);

    if ( pCallback ) {
        dOptions |= SCE_CALLBACK_TOTAL;
    }

    //
    // check the input arguments
    //

    LPCTSTR NewInf = NULL;
    LPCTSTR NewDb = NULL;
    LPCTSTR NewLog = NULL;

    __try {
        if ( InfFileName && wcslen(InfFileName) > 0 ) {
            NewInf = InfFileName;
        }
    } __except (EXCEPTION_EXECUTE_HANDLER) {

    }

    __try {
        if ( DatabaseName && wcslen(DatabaseName) > 0 ) {
            NewDb = DatabaseName;
        }
    } __except (EXCEPTION_EXECUTE_HANDLER) {

    }

    __try {
        if ( LogFileName && wcslen(LogFileName) > 0 ) {
            NewLog = LogFileName;
        }
    } __except (EXCEPTION_EXECUTE_HANDLER) {

    }

    //
    // RPC bind to the server
    //

    NtStatus = ScepBindSecureRpc(
                    SystemName,
                    L"scerpc",
                    L"security=impersonation dynamic false",
                    &binding_h
                    );

    if (NT_SUCCESS(NtStatus)){

        LPVOID pebClient = GetEnvironmentStrings();
        DWORD ebSize = ScepGetEnvStringSize(pebClient);

        RpcTryExcept {

            DWORD dwWarn=0;

            rc = SceRpcAnalyzeSystem(
                               binding_h,
                               (wchar_t *)NewInf,
                               (wchar_t *)NewDb,
                               (wchar_t *)NewLog,
                               (AREAPR)Area,
                               dOptions,
                               ebSize,
                               (UCHAR *)pebClient,
                               &dwWarn
                               );

            if ( pdWarning ) {
                *pdWarning = dwWarn;
            }

        } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

            //
            // get exception code (DWORD)
            //

            rc = ScepDosErrorToSceStatus(RpcExceptionCode());

        } RpcEndExcept;

        //
        // Free the binding handle
        //

        RpcpUnbindRpc( binding_h );

    } else {

        rc = ScepDosErrorToSceStatus(
                 RtlNtStatusToDosError( NtStatus ));
    }


    ScepSetCallback(NULL, NULL, 0);

    return(rc);
}

SCESTATUS
WINAPI
SceGenerateRollback(
    IN LPTSTR SystemName OPTIONAL,
    IN PCWSTR InfFileName,
    IN PCWSTR InfRollback,
    IN PCWSTR LogFileName OPTIONAL,
    IN DWORD Options,
    IN AREA_INFORMATION Area,
    OUT PDWORD pdWarning OPTIONAL
    )
/* ++
Routine Description:

    Routine to generate a rollback template based on the input configuration
    template. Must be called by admins. System database is used to analyze
    system settings with the confgiuration template and mismatches are saved
    to the rollback template on top of the configuration.

    Options can contain flags such as verbose log and no log

    A warning code is also returned if there is any warning occurs during the
    operation while the SCESTATUS return code is SCESTATUS_SUCCESS. Examples
    such as ERROR_FILE_NOT_FOUND, or ERROR_ACCESS_DENIED when querying
    the system won't be counted as error of this operation

Arguments:

    SystemName  - the system name where this operation will run, NULL for local system

    InfFileName - optional inf template name, if NULL, existing info in the SCe
                  database is used to configure.

    InfRollback - the rollback template name

    LogFileName - optional log file name for the operation

    Options     - the options to configure
                          SCE_VERBOSE_LOG
                          SCE_DISABLE_LOG

    Area        - reserved

    pdWarning - the warning code

Return Value:

    SCE status

-- */
{

    if ( InfFileName == NULL || InfRollback == NULL )
        return (SCESTATUS_INVALID_PARAMETER);

    SCESTATUS rc;
    handle_t  binding_h;
    NTSTATUS NtStatus;
    DWORD  dOptions;

    //
    // filter out invalid options
    //
    dOptions = Options & 0xFFL;

    //
    // check the input arguments
    //

    LPCTSTR NewLog = NULL;

    if ( InfFileName[0] == L'\0' ||
         InfRollback[0] == L'\0' ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    __try {
        if ( LogFileName && wcslen(LogFileName) > 0 ) {
            NewLog = LogFileName;
        }
    } __except (EXCEPTION_EXECUTE_HANDLER) {

    }

    //
    // RPC bind to the server
    //

    NtStatus = ScepBindSecureRpc(
                    SystemName,
                    L"scerpc",
                    L"security=impersonation dynamic false",
                    &binding_h
                    );

    if (NT_SUCCESS(NtStatus)){

        LPVOID pebClient = GetEnvironmentStrings();
        DWORD ebSize = ScepGetEnvStringSize(pebClient);

        RpcTryExcept {

            DWORD dwWarn=0;

            rc = SceRpcAnalyzeSystem(
                               binding_h,
                               (wchar_t *)InfFileName,
                               (wchar_t *)InfRollback,
                               (wchar_t *)NewLog,
                               (AREAPR)Area,
                               dOptions | SCE_GENERATE_ROLLBACK,
                               ebSize,
                               (UCHAR *)pebClient,
                               &dwWarn
                               );

            if ( pdWarning ) {
                *pdWarning = dwWarn;
            }

        } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

            //
            // get exception code (DWORD)
            //

            rc = ScepDosErrorToSceStatus(RpcExceptionCode());

        } RpcEndExcept;

        //
        // Free the binding handle
        //

        RpcpUnbindRpc( binding_h );

    } else {

        rc = ScepDosErrorToSceStatus(
                 RtlNtStatusToDosError( NtStatus ));
    }

    return(rc);
}


SCESTATUS
WINAPI
SceUpdateSecurityProfile(
    IN PVOID cxtProfile OPTIONAL,
    IN AREA_INFORMATION Area,
    IN PSCE_PROFILE_INFO pInfo,
    IN DWORD dwMode
    )
/*
Routine Description:

    See description in SceRpcUpdateDatabaseInfo

*/
{
    if ( !pInfo ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    if ( !cxtProfile && !(dwMode & SCE_UPDATE_SYSTEM ) ) {
        //
        // if it's not update for system, profile context can't be NULL.
        //
        return(SCESTATUS_INVALID_PARAMETER);
    }

    if ( ( dwMode & (SCE_UPDATE_LOCAL_POLICY | SCE_UPDATE_SYSTEM) ) &&
         ( Area & ~(AREA_SECURITY_POLICY | AREA_PRIVILEGES) ) ) {

        //
        // local policy mode can only take security policy area and
        // privileges area
        //
        return(SCESTATUS_INVALID_PARAMETER);
    }

    SCESTATUS rc=SCESTATUS_SUCCESS;

    PSCE_SERVICES pOldServices=NULL;

    if ( pInfo && pInfo->pServices ) {

        //
        // save the old service structure
        //
        pOldServices = pInfo->pServices;
    }

    if ( Area & AREA_SYSTEM_SERVICE ) {

        //
        // now convert the security descriptor (within PSCE_SERVICES) to self
        // relative format and to the RPC structure.
        //

        rc = ScepConvertServices( (PVOID *)&(pInfo->pServices), FALSE );

    } else {
        //
        // if don't care service area, don't bother to convert the structures
        //
        pInfo->pServices = NULL;
    }

    if ( SCESTATUS_SUCCESS == rc ) {

        RpcTryExcept {

            if ( dwMode & SCE_UPDATE_SYSTEM ) {

                PSCE_ERROR_LOG_INFO pErrTmp=NULL;

                if ( cxtProfile ) {

                    rc = SceRpcSetSystemSecurityFromHandle(
                                    (SCEPR_CONTEXT)cxtProfile,
                                    (AREAPR)Area,
                                    0,
                                    (PSCEPR_PROFILE_INFO)pInfo,
                                    (PSCEPR_ERROR_LOG_INFO *)&pErrTmp
                                    );
                } else {

                    //
                    // set system settings
                    // for normal user, the local policy database can't be opened.
                    //
                    // RPC bind to the server
                    //

                    handle_t  binding_h;
                    NTSTATUS NtStatus = ScepBindSecureRpc(
                                                NULL,
                                                L"scerpc",
                                                0,
                                                &binding_h
                                                );

                    if (NT_SUCCESS(NtStatus)){

                        RpcTryExcept {

                            rc = SceRpcSetSystemSecurity(
                                            binding_h,
                                            (AREAPR)Area,
                                            0,
                                            (PSCEPR_PROFILE_INFO)pInfo,
                                            (PSCEPR_ERROR_LOG_INFO *)&pErrTmp
                                            );

                        } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

                            //
                            // get exception code (DWORD)
                            //

                            rc = ScepDosErrorToSceStatus(RpcExceptionCode());

                        } RpcEndExcept;

                        //
                        // Free the binding handle
                        //

                        RpcpUnbindRpc( binding_h );

                    } else {

                        rc = ScepDosErrorToSceStatus(
                                 RtlNtStatusToDosError( NtStatus ));
                    }
                }

                if ( pErrTmp ) {
                    //
                    // free this tmp buffer
                    //
                    ScepFreeErrorLog(pErrTmp);
                }

            } else {

                rc = SceRpcUpdateDatabaseInfo(
                                (SCEPR_CONTEXT)cxtProfile,
                                (SCEPR_TYPE)(pInfo->Type),
                                (AREAPR)Area,
                                (PSCEPR_PROFILE_INFO)pInfo,
                                dwMode
                                );
            }

        } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

            //
            // get exception code (DWORD)
            //

            rc = ScepDosErrorToSceStatus(RpcExceptionCode());

        } RpcEndExcept;
    }

    //
    // should free the new service security descriptor buffer
    //
    ScepFreeConvertedServices( (PVOID)(pInfo->pServices), TRUE );

    //
    // restore the old buffer
    //
    pInfo->pServices = pOldServices;

    return(rc);
}

SCESTATUS
WINAPI
SceUpdateObjectInfo(
    IN PVOID cxtProfile,
    IN AREA_INFORMATION Area,
    IN PWSTR ObjectName,
    IN DWORD NameLen, // number of characters
    IN BYTE ConfigStatus,
    IN BOOL  IsContainer,
    IN PSECURITY_DESCRIPTOR pSD,
    IN SECURITY_INFORMATION SeInfo,
    OUT PBYTE pAnalysisStatus
    )
/*
Routine Description:

    See description in SceRpcUpdateObjectInfo

*/
{

    if ( !cxtProfile || !ObjectName || 0 == Area ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    SCESTATUS rc=SCESTATUS_SUCCESS;

    //
    // handle RPC exceptions
    //

    PSCEPR_SR_SECURITY_DESCRIPTOR pNewWrap=NULL;
    PSECURITY_DESCRIPTOR pNewSrSD=NULL;

    //
    // there is a security descriptor, must be self relative
    // if the SD is not self relative, should convert it
    //

    if ( pSD ) {

        if ( !RtlValidSid (pSD) ) {
            return(SCESTATUS_INVALID_PARAMETER);
        }

        SECURITY_DESCRIPTOR_CONTROL ControlBits=0;
        ULONG Revision;
        ULONG nLen=0;

        RtlGetControlSecurityDescriptor ( pSD, &ControlBits, &Revision);

        if ( !(ControlBits & SE_SELF_RELATIVE) ) {
            //
            // if it's absolute format, convert it
            //
            rc = ScepDosErrorToSceStatus(
                     ScepMakeSelfRelativeSD( pSD, &pNewSrSD, &nLen ) );

            if ( SCESTATUS_SUCCESS != rc ) {
                return(rc);
            }

        } else {

            //
            // already self relative, just use it
            //
            nLen = RtlLengthSecurityDescriptor (pSD);
        }


        if ( nLen > 0 ) {
            //
            // create a wrapper node to contain the security descriptor
            //

            pNewWrap = (PSCEPR_SR_SECURITY_DESCRIPTOR)ScepAlloc(0, sizeof(SCEPR_SR_SECURITY_DESCRIPTOR));
            if ( pNewWrap ) {

                //
                // assign the wrap to the structure
                //
                if ( ControlBits & SE_SELF_RELATIVE ) {
                    pNewWrap->SecurityDescriptor = (UCHAR *)pSD;
                } else {
                    pNewWrap->SecurityDescriptor = (UCHAR *)pNewSrSD;
                }
                pNewWrap->Length = nLen;

            } else {
                //
                // no memory is available, but still continue to parse all nodes
                //
                rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
            }
        } else {
            //
            // something is wrong with the SD
            //
            rc = SCESTATUS_INVALID_PARAMETER;
        }

        if ( SCESTATUS_SUCCESS != rc ) {

            if ( pNewSrSD ) {
                ScepFree(pNewSrSD);
            }

            return(rc);
        }
    }

    RpcTryExcept {

        rc = SceRpcUpdateObjectInfo(
                    (SCEPR_CONTEXT)cxtProfile,
                    (AREAPR)Area,
                    (wchar_t *)ObjectName,
                    NameLen,
                    ConfigStatus,
                    IsContainer,
                    (SCEPR_SR_SECURITY_DESCRIPTOR *)pNewWrap,
                    SeInfo,
                    pAnalysisStatus
                    );

    } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

        //
        // get exception code (DWORD)
        //

        rc = ScepDosErrorToSceStatus(RpcExceptionCode());

    } RpcEndExcept;

    if ( pNewSrSD ) {
        ScepFree(pNewSrSD);
    }

    return(rc);
}


SCESTATUS
WINAPI
SceStartTransaction(
    IN PVOID cxtProfile
    )
{
    if ( cxtProfile == NULL ) {

        return(SCESTATUS_INVALID_PARAMETER);
    }

    SCESTATUS rc;

    RpcTryExcept {

        rc = SceRpcStartTransaction((SCEPR_CONTEXT)cxtProfile);

    } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

        //
        // get exception code (DWORD)
        //

        rc = ScepDosErrorToSceStatus(RpcExceptionCode());

    } RpcEndExcept;

    return(rc);
}

SCESTATUS
WINAPI
SceCommitTransaction(
    IN PVOID cxtProfile
    )
{
    if ( cxtProfile == NULL ) {

        return(SCESTATUS_INVALID_PARAMETER);
    }

    SCESTATUS rc;

    RpcTryExcept {

        rc = SceRpcCommitTransaction((SCEPR_CONTEXT)cxtProfile);

    } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

        //
        // get exception code (DWORD)
        //

        rc = ScepDosErrorToSceStatus(RpcExceptionCode());

    } RpcEndExcept;

    return(rc);

}


SCESTATUS
WINAPI
SceRollbackTransaction(
    IN PVOID cxtProfile
    )
{
    if ( cxtProfile == NULL ) {

        return(SCESTATUS_INVALID_PARAMETER);
    }

    SCESTATUS rc;
    RpcTryExcept {

        rc = SceRpcRollbackTransaction((SCEPR_CONTEXT)cxtProfile);

    } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

        //
        // get exception code (DWORD)
        //

        rc = ScepDosErrorToSceStatus(RpcExceptionCode());

    } RpcEndExcept;

    return(rc);
}


SCESTATUS
WINAPI
SceGetServerProductType(
   IN LPTSTR SystemName OPTIONAL,
   OUT PSCE_SERVER_TYPE pServerType
   )
/*
Routine Description:

    Query product type and NT version of the server where SCE server is
    running on

    See description of SceRpcGetServerProductType
*/
{

    if ( !SystemName ) {
        //
        // the local call
        //
        return(ScepGetProductType(pServerType));

    }

    handle_t  binding_h;
    NTSTATUS NtStatus;
    SCESTATUS rc;
    //
    // RPC bind to the server
    //

    NtStatus = ScepBindSecureRpc(
                    SystemName,
                    L"scerpc",
                    0,
                    &binding_h
                    );

    if (NT_SUCCESS(NtStatus)){

        //
        // handle RPC exceptions
        //

        RpcTryExcept {

            rc = SceRpcGetServerProductType(
                          binding_h,
                          (PSCEPR_SERVER_TYPE)pServerType
                          );

        } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

            //
            // get exception code (DWORD)
            //

            rc = ScepDosErrorToSceStatus(RpcExceptionCode());

        } RpcEndExcept;

        //
        // Free the binding handle
        //

        RpcpUnbindRpc( binding_h );

    } else {

        rc = ScepDosErrorToSceStatus(
                 RtlNtStatusToDosError( NtStatus ));
    }

    return(rc);
}


SCESTATUS
WINAPI
SceSvcUpdateInfo(
    IN PVOID     hProfile,
    IN PCWSTR    ServiceName,
    IN PSCESVC_CONFIGURATION_INFO Info
    )
/*
Routine Description:

    Load service's engine dll and pass the Info buffer to service engine's
    update API (SceSvcAttachmentUpdate). Currently security manager engine
    is not doing any processing for the service data.

    This routine triggers the update of configuration database and/or
    analysis information by the service engine. Info may contain the
    modifications only, or the whole configuratio data for the service,
    or partial configuration data, depending on the agreement between service
    extension and service engine.

    This routine does not really write info to security manager database directly,
    instead, it passes the info buffer to the service engine's update interface
    and service engine will determine what and when to write inot the database.

Arguments:

    hProfile - the security database handle (returned from SCE server)

    ServiceName - The service's name as used by service control manager

    Info - The information modified

*/
{

    if ( hProfile == NULL || ServiceName == NULL ||
        Info == NULL ) {

        return(SCESTATUS_INVALID_PARAMETER);

    }

    SCESTATUS rc;

    RpcTryExcept {

        //
        // call the RPC interface to update info.
        // the RPC interface loads service engine dll on the server site
        // and passes the info buffer to service engine to process
        //

        rc = SceSvcRpcUpdateInfo(
                    (SCEPR_CONTEXT)hProfile,
                    (wchar_t *)ServiceName,
                    (PSCEPR_SVCINFO)Info
                    );

    } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

        //
        // get exception code (DWORD) and convert it into SCESTATUS
        //

        rc = ScepDosErrorToSceStatus(
                      RpcExceptionCode());
    } RpcEndExcept;

    return(rc);
}


DWORD
WINAPI
SceRegisterRegValues(
    IN LPTSTR InfFileName
    )
/*
Routine Description:

    Register the registry values from the inf file into reg values location
    under SecEdit key

    This routine can be called from DllRegisterServer, or from the command
    line tool /register

Arguments:

    InfFileName - the inf file which contains the register values to register

Return Value:

    Win32 error code
*/
{
    if ( !InfFileName ) {
        return(ERROR_INVALID_PARAMETER);
    }

    SCESTATUS rc;
    HINF hInf;
    DWORD Win32rc;

    rc = SceInfpOpenProfile(
                InfFileName,
                &hInf
                );

    if ( SCESTATUS_SUCCESS == rc ) {

        INFCONTEXT  InfLine;
        HKEY hKeyRoot;
        DWORD dwDisp;

        if(SetupFindFirstLine(hInf,SCE_REGISTER_REGVALUE_SECTION,NULL,&InfLine)) {

            //
            // create the root key first
            //

            Win32rc = RegCreateKeyEx (HKEY_LOCAL_MACHINE,
                                 SCE_ROOT_REGVALUE_PATH,
                                 0,
                                 NULL,
                                 REG_OPTION_NON_VOLATILE,
                                 KEY_READ | KEY_WRITE,
                                 NULL,
                                 &hKeyRoot,
                                 &dwDisp);

            if ( ERROR_SUCCESS == Win32rc ||
                 ERROR_ALREADY_EXISTS == Win32rc ) {

                DWORD dSize;
                PWSTR RegKeyName, DisplayName;
                DWORD dType;
                HKEY hKey;

                do {

                    //
                    // Get key names, value type, diaply name, and display type.
                    //
                    if(SetupGetStringField(&InfLine,1,NULL,0,&dSize) && dSize > 0) {

                        RegKeyName = (PWSTR)ScepAlloc( 0, (dSize+1)*sizeof(WCHAR));

                        if( RegKeyName == NULL ) {
                            Win32rc = ERROR_NOT_ENOUGH_MEMORY;

                        } else {
                            RegKeyName[dSize] = L'\0';

                            if(SetupGetStringField(&InfLine,1,RegKeyName,dSize, NULL)) {

                                //
                                // make sure not \\ is specified, if there is
                                // change it to /
                                //
                                ScepConvertMultiSzToDelim(RegKeyName, dSize, L'\\', L'/');

                                //
                                // get the filed count
                                // if count is 1, this key should be deleted
                                //
                                dwDisp = SetupGetFieldCount( &InfLine );

                                if ( dwDisp <= 1 ) {
                                    //
                                    // delete this key, don't care error
                                    //
                                    RegDeleteKey ( hKeyRoot, RegKeyName );

                                    Win32rc = ERROR_SUCCESS;

                                } else {

                                    Win32rc = RegCreateKeyEx (hKeyRoot,
                                                         RegKeyName,
                                                         0,
                                                         NULL,
                                                         REG_OPTION_NON_VOLATILE,
                                                         KEY_WRITE,
                                                         NULL,
                                                         &hKey,
                                                         NULL);
                                }

                                if ( (dwDisp > 1) &&
                                     ERROR_SUCCESS == Win32rc ||
                                     ERROR_ALREADY_EXISTS == Win32rc ) {

                                    //
                                    // get registry value type
                                    //
                                    dType = REG_DWORD;
                                    SetupGetIntField( &InfLine, 2, (INT *)&dType );

                                    RegSetValueEx (hKey,
                                                   SCE_REG_VALUE_TYPE,
                                                   0,
                                                   REG_DWORD,
                                                   (LPBYTE)&dType,
                                                   sizeof(DWORD));

                                    //
                                    // get registry value display type
                                    //

                                    dType = SCE_REG_DISPLAY_ENABLE;
                                    SetupGetIntField( &InfLine, 4, (INT *)&dType );

                                    RegSetValueEx (hKey,
                                                   SCE_REG_DISPLAY_TYPE,
                                                   0,
                                                   REG_DWORD,
                                                   (LPBYTE)&dType,
                                                   sizeof(DWORD));

                                    //
                                    // get registry display name
                                    //
                                    if(SetupGetStringField(&InfLine,3,NULL,0,&dSize) && dSize > 0) {

                                        DisplayName = (PWSTR)ScepAlloc( 0, (dSize+1)*sizeof(WCHAR));

                                        if( DisplayName == NULL ) {
                                            Win32rc = ERROR_NOT_ENOUGH_MEMORY;

                                        } else {
                                            DisplayName[dSize] = L'\0';

                                            if(SetupGetStringField(&InfLine,3,DisplayName,dSize, NULL)) {

                                                RegSetValueEx (hKey,
                                                               SCE_REG_DISPLAY_NAME,
                                                               0,
                                                               REG_SZ,
                                                               (LPBYTE)DisplayName,
                                                               dSize*sizeof(TCHAR));
                                            }

                                            ScepFree(DisplayName);
                                            DisplayName = NULL;
                                        }
                                    }

                                    //
                                    // get registry display unit (optional)
                                    //

                                    if ( dType == SCE_REG_DISPLAY_NUMBER ||
                                         dType == SCE_REG_DISPLAY_CHOICE ||
                                         dType == SCE_REG_DISPLAY_FLAGS ) {

                                        if ( SetupGetMultiSzField(&InfLine,5,NULL,0,&dSize) && dSize > 0) {

                                            DisplayName = (PWSTR)ScepAlloc( 0, (dSize+1)*sizeof(WCHAR));

                                            if( DisplayName == NULL ) {
                                                Win32rc = ERROR_NOT_ENOUGH_MEMORY;

                                            } else {
                                                DisplayName[dSize] = L'\0';

                                                if(SetupGetMultiSzField(&InfLine,5,DisplayName,dSize, NULL)) {

                                                    if ( dType == SCE_REG_DISPLAY_NUMBER ) {
                                                        dSize = wcslen(DisplayName);
                                                    }


                                                    switch (dType) {

                                                    case SCE_REG_DISPLAY_NUMBER:

                                                        RegSetValueEx (hKey,
                                                                       SCE_REG_DISPLAY_UNIT,
                                                                       0,
                                                                       REG_SZ,
                                                                       (LPBYTE)DisplayName,
                                                                       dSize*sizeof(TCHAR));
                                                        break;

                                                    case SCE_REG_DISPLAY_CHOICE:

                                                        RegSetValueEx (hKey,
                                                                       SCE_REG_DISPLAY_CHOICES,
                                                                       0,
                                                                       REG_MULTI_SZ,
                                                                       (LPBYTE)DisplayName,
                                                                       dSize*sizeof(TCHAR));

                                                        break;

                                                    case SCE_REG_DISPLAY_FLAGS:

                                                        RegSetValueEx (hKey,
                                                                       SCE_REG_DISPLAY_FLAGLIST,
                                                                       0,
                                                                       REG_MULTI_SZ,
                                                                       (LPBYTE)DisplayName,
                                                                       dSize*sizeof(TCHAR));

                                                        break;

                                                    default:

                                                        break;

                                                    }
                                                }

                                                ScepFree(DisplayName);
                                                DisplayName = NULL;
                                            }
                                        }
                                    }

                                    RegCloseKey(hKey);
                                    hKey = NULL;

                                }
                            } else {
                                Win32rc = GetLastError();
                            }

                            ScepFree(RegKeyName);
                            RegKeyName = NULL;
                        }

                    } else {
                        Win32rc = GetLastError();
                    }

                    if ( ERROR_SUCCESS != Win32rc ) {
                        break;
                    }

                } while (SetupFindNextLine(&InfLine,&InfLine));

                RegCloseKey(hKeyRoot);
            }
        } else {
            Win32rc = GetLastError();
        }

        SceInfpCloseProfile(hInf);

    } else {
        Win32rc = ScepSceStatusToDosError(rc);
    }

    return(Win32rc);
}


//
// the RPC callback
//

SCEPR_STATUS
SceClientBrowseCallback(
    IN LONG GpoID,
    IN wchar_t *KeyName OPTIONAL,
    IN wchar_t *GpoName OPTIONAL,
    IN SCEPR_SR_SECURITY_DESCRIPTOR *Value OPTIONAL
    )
/*
Routine Description:

    The RPC client callback routine which is called from the server when
    the callback flag is set. This routine is registered in scerpc.idl.

    The callbacks are registered to SCE as arguments when calling from the
    browse API

Arguments:


Return Value:

    SCEPR_STATUS
*/
{
   //
   // the static variables holding callback pointer to client
   //

   if ( theBrowseCallBack != NULL ) {

       //
       // callback to browse progress
       //

       PSCE_BROWSE_CALLBACK_ROUTINE pcb;

       pcb = (PSCE_BROWSE_CALLBACK_ROUTINE)theBrowseCallBack;

       __try {

           //
           // callback
           //

           if ( !((*pcb)(GpoID,
                         KeyName,
                         GpoName,
                         ((Value && Value->Length) ? (PWSTR)(Value->SecurityDescriptor) : NULL),
                         Value ? (Value->Length)/sizeof(WCHAR) : 0
                        )) ) {

               return SCESTATUS_SERVICE_NOT_SUPPORT;
           }

       } __except(EXCEPTION_EXECUTE_HANDLER) {

           return(SCESTATUS_INVALID_PARAMETER);
       }

   }

   return(SCESTATUS_SUCCESS);

}


SCESTATUS
SceBrowseDatabaseTable(
    IN PWSTR       DatabaseName OPTIONAL,
    IN SCETYPE     ProfileType,
    IN AREA_INFORMATION Area,
    IN BOOL        bDomainPolicyOnly,
    IN PSCE_BROWSE_CALLBACK_ROUTINE pCallback OPTIONAL
    )
{
    if (  bDomainPolicyOnly &&
          (ProfileType != SCE_ENGINE_SCP) &&
          (ProfileType != SCE_ENGINE_SAP) ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    if ( bDomainPolicyOnly && (ProfileType == SCE_ENGINE_SAP) ) {
/*
        // No, should allow any database for debugging
        //
        // should only work for the system database
        //
        if ( DatabaseName != NULL && !SceIsSystemDatabase(DatabaseName) ) {
            return(SCESTATUS_INVALID_PARAMETER);
        }
*/
        if ( DatabaseName == NULL ) {
            //
            // if it's a normal user logon, should return invalid
            //
            BOOL bAdmin=FALSE;
            if ( ERROR_SUCCESS != ScepIsAdminLoggedOn(&bAdmin) || !bAdmin )
                return(SCESTATUS_INVALID_PARAMETER);
        }
    }

    if ( ProfileType != SCE_ENGINE_SCP &&
         ProfileType != SCE_ENGINE_SMP &&
         ProfileType != SCE_ENGINE_SAP ) {

        return(SCESTATUS_INVALID_PARAMETER);
    }

    NTSTATUS NtStatus;
    SCESTATUS rc;
    handle_t  binding_h;

    //
    // RPC bind to the server
    //

    NtStatus = ScepBindSecureRpc(
                    NULL,
                    L"scerpc",
                    0,
                    &binding_h
                    );

    if (NT_SUCCESS(NtStatus)){

        theBrowseCallBack = (PVOID)pCallback;

        RpcTryExcept {

            rc = SceRpcBrowseDatabaseTable(
                        binding_h,
                        (wchar_t *)DatabaseName,
                        (SCEPR_TYPE)ProfileType,
                        (AREAPR)Area,
                        bDomainPolicyOnly
                        );

        } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

            //
            // get exception code (DWORD)
            //

            rc = ScepDosErrorToSceStatus(RpcExceptionCode());

        } RpcEndExcept;

        theBrowseCallBack = NULL;

        //
        // Free the binding handle
        //

        RpcpUnbindRpc( binding_h );

    } else {

        rc = ScepDosErrorToSceStatus(
                 RtlNtStatusToDosError( NtStatus ));
    }

    return(rc);

}


SCESTATUS
ScepConvertServices(
    IN OUT PVOID *ppServices,
    IN BOOL bSRForm
    )
{
    if ( !ppServices ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    PSCE_SERVICES pTemp = (PSCE_SERVICES)(*ppServices);
    SCESTATUS rc=SCESTATUS_SUCCESS;

    PSCE_SERVICES pNewNode;
    PSCE_SERVICES pNewServices=NULL;

    while ( pTemp ) {

        pNewNode = (PSCE_SERVICES)ScepAlloc(0,sizeof(SCE_SERVICES));

        if ( pNewNode ) {

            pNewNode->ServiceName = pTemp->ServiceName;
            pNewNode->DisplayName = pTemp->DisplayName;
            pNewNode->Status = pTemp->Status;
            pNewNode->Startup = pTemp->Startup;
            pNewNode->SeInfo = pTemp->SeInfo;

            pNewNode->General.pSecurityDescriptor = NULL;

            pNewNode->Next = pNewServices;
            pNewServices = pNewNode;

            if ( bSRForm ) {
                //
                // Service node is in SCEPR_SERVICES structure
                // convert it to SCE_SERVICES structure
                // in this case, just use the self relative security descriptor
                //
                if ( pTemp->General.pSecurityDescriptor) {
                    pNewNode->General.pSecurityDescriptor = ((PSCEPR_SERVICES)pTemp)->pSecurityDescriptor->SecurityDescriptor;
                }

            } else {

                //
                // Service node is in SCE_SERVICES strucutre
                // convert it to SCEPR_SERVICES structure
                //
                // make the SD to self relative format and PSCEPR_SR_SECURITY_DESCRIPTOR
                //

                if ( pTemp->General.pSecurityDescriptor ) {

                    if ( !RtlValidSid ( pTemp->General.pSecurityDescriptor ) ) {
                        rc = SCESTATUS_INVALID_PARAMETER;
                        break;
                    }

                    DWORD nLen = 0;
                    PSECURITY_DESCRIPTOR pSD=NULL;

                    rc = ScepDosErrorToSceStatus(
                             ScepMakeSelfRelativeSD(
                                            pTemp->General.pSecurityDescriptor,
                                            &pSD,
                                            &nLen
                                          ));

                    if ( SCESTATUS_SUCCESS == rc ) {

                        //
                        // create a wrapper node to contain the security descriptor
                        //

                        PSCEPR_SR_SECURITY_DESCRIPTOR pNewWrap;

                        pNewWrap = (PSCEPR_SR_SECURITY_DESCRIPTOR)ScepAlloc(0, sizeof(SCEPR_SR_SECURITY_DESCRIPTOR));
                        if ( pNewWrap ) {

                            //
                            // assign the wrap to the structure
                            //
                            pNewWrap->SecurityDescriptor = (UCHAR *)pSD;
                            pNewWrap->Length = nLen;

                        } else {
                            rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
                            ScepFree(pSD);
                            break;
                        }

                        //
                        // now link the SR_SD to the list
                        //
                        ((PSCEPR_SERVICES)pNewNode)->pSecurityDescriptor = pNewWrap;

                    } else {
                        break;
                    }
                }
            }

        } else {
            //
            // all allocated buffer are in the list of pNewServices
            //
            rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
            break;
        }

        pTemp = pTemp->Next;
    }

    if ( SCESTATUS_SUCCESS != rc ) {

        //
        // free pNewServices
        //
        ScepFreeConvertedServices( (PVOID)pNewServices, !bSRForm );
        pNewServices = NULL;
    }

    *ppServices = (PVOID)pNewServices;

    return(rc);
}


SCESTATUS
ScepFreeConvertedServices(
    IN PVOID pServices,
    IN BOOL bSRForm
    )
{

    if ( pServices == NULL ) {
        return(SCESTATUS_SUCCESS);
    }

    PSCEPR_SERVICES pNewNode = (PSCEPR_SERVICES)pServices;

    PSCEPR_SERVICES pTempNode;

    while ( pNewNode ) {

        if ( bSRForm && pNewNode->pSecurityDescriptor ) {

            //
            // free this allocated buffer (PSCEPR_SR_SECURITY_DESCRIPTOR)
            //
            if ( pNewNode->pSecurityDescriptor->SecurityDescriptor ) {
                ScepFree( pNewNode->pSecurityDescriptor->SecurityDescriptor);
            }
            ScepFree(pNewNode->pSecurityDescriptor);
        }

        //
        // also free the PSCEPR_SERVICE node (but not the names referenced by this node)
        //
        pTempNode = pNewNode;
        pNewNode = pNewNode->Next;

        ScepFree(pTempNode);
    }

    return(SCESTATUS_SUCCESS);
}

DWORD
ScepMakeSelfRelativeSD(
    IN PSECURITY_DESCRIPTOR pInSD,
    OUT PSECURITY_DESCRIPTOR *pOutSD,
    OUT PULONG pnLen
    )
{

    if ( pInSD == NULL ||
         pOutSD == NULL ||
         pnLen == NULL ) {
        return(ERROR_INVALID_PARAMETER);
    }

    //
    // get the length
    //
    RtlMakeSelfRelativeSD( pInSD,
                           NULL,
                           pnLen
                         );

    if ( *pnLen > 0 ) {

        *pOutSD = (PSECURITY_DESCRIPTOR)ScepAlloc(LMEM_ZEROINIT, *pnLen);

        if ( !(*pOutSD) ) {
            return(ERROR_NOT_ENOUGH_MEMORY);
        }

        DWORD NewLen=*pnLen;

        DWORD rc = RtlNtStatusToDosError(
                       RtlMakeSelfRelativeSD( pInSD,
                                            *pOutSD,
                                            &NewLen
                                            ) );
        if ( rc != ERROR_SUCCESS ) {

            ScepFree(*pOutSD);
            *pOutSD = NULL;
            *pnLen = 0;
            return(rc);
        }

    } else {

        //
        // something is wrong with the SD
        //
        return(ERROR_INVALID_PARAMETER);
    }

    return(ERROR_SUCCESS);

}


SCESTATUS
WINAPI
SceGetDatabaseSetting(
    IN PVOID hProfile,
    IN SCETYPE ProfileType,
    IN PWSTR SectionName,
    IN PWSTR KeyName,
    OUT PWSTR *Value,
    OUT DWORD *pnBytes OPTIONAL
    )
/*
Routine Descripton:

    Get database setting (from SMP table) for the given key

Arguments:

    hProfile    - the profile handle

    ProfileType - the database type

    SectionName - the section to query data from

    KeyName     - the key name

    Value       - output buffer for the setting

    ValueLen    - the nubmer of bytes to output

Return Value:

    SCE status
*/
{
    SCESTATUS   rc;

    if ( hProfile == NULL ||
         KeyName == NULL ||
         SectionName == NULL ||
         Value == NULL ) {

        return(SCESTATUS_INVALID_PARAMETER);
    }

    if ( ProfileType != SCE_ENGINE_SMP ) {

        return(SCESTATUS_INVALID_PARAMETER);
    }

    //
    // call rpc interface
    //
    PSCEPR_VALUEINFO ValueInfo=NULL;

    RpcTryExcept {

        rc = SceRpcGetDatabaseSetting(
                    (SCEPR_CONTEXT)hProfile,
                    (SCEPR_TYPE)ProfileType,
                    (wchar_t *)SectionName,
                    (wchar_t *)KeyName,
                    &ValueInfo
                    );

        if ( ValueInfo && ValueInfo->Value ) {

            //
            // output the data
            //
            *Value = (PWSTR)ValueInfo->Value;
            if ( pnBytes )
                *pnBytes = ValueInfo->ValueLen;

            ValueInfo->Value = NULL;
        }

        //
        // free buffer
        if ( ValueInfo ) {
            if ( ValueInfo->Value ) ScepFree(ValueInfo->Value);
            ScepFree(ValueInfo);
        }

    } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

        //
        // get exception code (DWORD)
        //

        rc = ScepDosErrorToSceStatus(RpcExceptionCode());

    } RpcEndExcept;


    return(rc);

}

SCESTATUS
WINAPI
SceSetDatabaseSetting(
    IN PVOID hProfile,
    IN SCETYPE ProfileType,
    IN PWSTR SectionName,
    IN PWSTR KeyName,
    IN PWSTR Value OPTIONAL,
    IN DWORD nBytes
    )
/*
Routine Descripton:

    Set a setting to the database (SMP table) for the given key

Arguments:

    hProfile    - the profile handle

    ProfileType - the database type

    SectionName - the section name to write to

    KeyName     - the key name to write to or delete

    Value       - the value to write. If NULL, delete the key

    nBytes      - the number of bytes of the input Value buffer

Return Value:

    SCE status
*/
{
    SCESTATUS   rc;

    if ( hProfile == NULL ||
         SectionName == NULL ||
         KeyName == NULL ) {

        return(SCESTATUS_INVALID_PARAMETER);
    }

    if ( ProfileType != SCE_ENGINE_SMP ) {

        return(SCESTATUS_INVALID_PARAMETER);
    }

    //
    // call rpc interface
    //

    RpcTryExcept {

        SCEPR_VALUEINFO ValueInfo;

        ValueInfo.Value = (byte *)Value;
        ValueInfo.ValueLen = nBytes;

        rc = SceRpcSetDatabaseSetting(
                    (SCEPR_CONTEXT)hProfile,
                    (SCEPR_TYPE)ProfileType,
                    (wchar_t *)SectionName,
                    (wchar_t *)KeyName,
                    Value ? &ValueInfo : NULL
                    );


    } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

        //
        // get exception code (DWORD)
        //

        rc = ScepDosErrorToSceStatus(RpcExceptionCode());

    } RpcEndExcept;


    return(rc);

}

DWORD
ScepControlNotificationQProcess(
    IN PWSTR szLogFileName,
    IN BOOL bThisIsDC,
    IN DWORD ControlFlag
    )
/*
Description:

    To suspend or resume policy notification queue processing on DCs

    This routine is used to make sure that the latest group policy is
    being processed in policy proapgation (copied to the cache)

*/
{

    if ( !bThisIsDC ) return ERROR_SUCCESS;

    handle_t  binding_h;
    NTSTATUS NtStatus;
    DWORD rc;

    NtStatus = ScepBindRpc(
                    NULL,
                    L"scerpc",
                    L"security=impersonation dynamic false",
                    &binding_h
                    );

    rc = RtlNtStatusToDosError( NtStatus );

    if (NT_SUCCESS(NtStatus)){

        RpcTryExcept {

            rc = SceRpcControlNotificationQProcess(
                           binding_h,
                           ControlFlag
                           );

        } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

            //
            // get exception code (DWORD)
            //

            rc = RpcExceptionCode();

        } RpcEndExcept;
    }

    //
    // Free the binding handle
    //

    RpcpUnbindRpc( binding_h );

    //
    // log the operation
    //
    if ( szLogFileName ) {

        LogEventAndReport(MyModuleHandle,
                      szLogFileName,
                      1,
                      0,
                      IDS_CONTROL_QUEUE,
                      rc,
                      ControlFlag
                      );
    }

    return rc;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\scerpc\client\scedllrc.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    scedllrc.h

Abstract:

    This module defines resource IDs for strings

Author:

    Jin Huang (Jinhuang) 17-Sept.-1997

Revision History:

--*/
#ifndef __scedllrc__
#define __scedllrc__

#include "commonrc.h"

#define SCECLI_CALLBACK_PREFIX              7361
#define SCECLI_CREATE_GPO_PREFIX            7362

#define IDS_ERROR_BACKUP                    7501
#define IDS_ERROR_GENERATE                  7502
#define IDS_ERROR_LOADDLL                   7503
#define IDS_ERROR_GET_PROCADDR              7504
#define IDS_ERROR_GET_TOKEN_USER            7505
#define IDS_PREVIOUS_ERROR                  7506
#define IDS_ERROR_ACCESS_TEMPLATE           7507
#define IDS_INFO_NO_TEMPLATE                7508
#define IDS_INFO_COPY_TEMPLATE              7509
#define IDS_PROCESS_TEMPLATE                7510
#define IDS_WARNING_PROPAGATE               7511
#define IDS_EFS_DEFINED                     7512
#define IDS_NO_EFS_DEFINED                  7513
#define IDS_ERROR_SAVE_TEMP_EFS             7514
#define IDS_EFS_EXIST                       7515
#define IDS_SAVE_EFS                        7516
#define IDS_EFS_NOT_CHANGE                  7517
#define IDS_ERROR_OPEN_LSAEFS               7518
#define IDS_NO_EFS_TOTAL                    7519
#define IDS_ERROR_GET_DSROOT                7520
#define IDS_ERROR_BIND_DS                   7521
#define IDS_ERROR_SAVE_POLICY_DB            7522
#define IDS_ERROR_SAVE_POLICY_GPO           7523
#define IDS_SUCCESS_DEFAULT_GPO             7524
#define IDS_ERROR_COPY_TEMPLATE             7525
#define IDS_ERROR_CREATE_DIRECTORY          7526
#define IDS_ERROR_NO_MEMORY                 7527
#define IDS_ERROR_GETGPO_FILE_PATH          7528
#define IDS_ERROR_GET_ROLE                  7529
#define IDS_ERROR_OPEN_GPO                  7530
#define IDS_ERROR_READ_GPO                  7531
#define IDS_ERROR_OPEN_DATABASE             7532
#define IDS_ERROR_CREATE_THREAD_PARAM       7533
#define IDS_ERROR_CREATE_THREAD             7534
#define IDS_SNAPSHOT_SECURITY_POLICY        7535
#define IDS_ERROR_SNAPSHOT_SECURITY         7536
#define IDS_ERROR_REMOVE_DEFAULT_POLICY     7537

#define IDS_BACKUP_OUTBOX_DESCRIPTION       7538
#define IDS_BACKUP_DC_DESCRIPTION           7539
#define IDS_PROPAGATE_NOT_READY             7540

#define IDS_FILTER_AFTER_SETUP              7541
#define IDS_LSA_CHANGED_IN_SETUP            7542
#define IDS_SAM_CHANGED_IN_SETUP            7543
#define IDS_FILTER_NOTIFY_SERVER            7544
#define IDS_NOT_LAST_GPO_DC                 7545
#define IDS_NOT_LAST_GPO                    7546
#define IDS_LAST_GPO_DC                     7547
#define IDS_LAST_GPO                        7548
#define IDS_GPO_FOREGROUND_THREAD           7549

#define IDS_POLICY_TIMEOUT                  7550
#define IDS_APPLY_SECURITY_POLICY           7551
#define IDS_CONFIGURE_POLICY                7552
#define IDS_WARNING_PROPAGATE_NOMAP         7553
#define IDS_ERROR_PROMOTE_SECURITY          7554

#define IDS_ERROR_OPEN_JET_DATABASE         7555
#define IDS_WARNING_PROPAGATE_TIMEOUT       7556
#define IDS_WARNING_PROPAGATE_SPECIAL       7557

#define IDS_ERR_ADD_AUTH_USER               7581
#define IDS_ERR_RECONFIG_FILES              7582
#define IDS_ERR_ADD_INTERACTIVE             7583
#define IDS_ERR_DELETE_GP_CACHE             7584
#define IDS_ERROR_GPO_PRE_POLICY_PROP       7585
#define IDS_ERROR_OPEN_CACHED_GPO           7586

#define IDS_ERROR_RSOP_LOG                  7588
#define IDS_ERR_CREATE_GP_CACHE             7589
#define IDS_SUCCESS_RSOP_LOG                7590
#define IDS_ERROR_RSOP_DIAG_LOG             7591
#define IDS_ERROR_RSOP_DIAG_LOG64_32KEY     7592
#define IDS_CLEAR_RSOP_DB                   7593
#define IDS_INFO_RSOP_LOG                   7594

#define IDS_ROOT_NTFS_VOLUME                7595
#define IDS_ROOT_NOT_FIXED_VOLUME           7596
#define IDS_ROOT_ERROR_QUERY_VOLUME         7597
#define IDS_ROOT_NON_NTFS                   7598
#define IDS_ROOT_ERROR_CONVERT              7599
#define IDS_ROOT_INVALID_SDINFO             7600
#define IDS_ROOT_ERROR_QUERY_SECURITY       7601
#define IDS_ROOT_SECURITY_MODIFIED          7602
#define IDS_ROOT_SECURITY_DEFAULT           7603
#define IDS_ROOT_ERROR_DACL                 7604
#define IDS_ROOT_MARTA_RETURN               7605
#define IDS_ROOT_ERROR_INFWRITE             7606

#define IDS_CONTROL_QUEUE                   7610
#define IDS_ERROR_PROMOTE_IMPERSONATE       7611
#define IDS_ERROR_PROMOTE_REVERT            7612

#define IDS_ERROR_GET_TOKEN_MACHINE         7620

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\scerpc\client\scedll.cpp ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    scedll.cpp

Abstract:

    SCE Client dll initialization

Author:

    Jin Huang (jinhuang) 23-Jan-1998 created

--*/
#include "headers.h"
#include "sceutil.h"
#include <winsafer.h>
#include <winsaferp.h>
#include <alloca.h>
#include <objbase.h>
#include <initguid.h>
#include <wbemidl.h>
#include <wbemprov.h>
#include <atlbase.h>

CComModule _Module;

#include <atlcom.h>

extern HINSTANCE MyModuleHandle;
extern CRITICAL_SECTION DiagnosisPolicypropSync;
extern CRITICAL_SECTION PolicyNotificationSync;
extern LIST_ENTRY ScepNotifyList;

BOOL
UninitializeChangeNotify();

#define GPT_SCEDLL_PATH   TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\GPExtensions\\SceCli")

#define SCE_REGVALUE_DEFAULT_FILE  TEXT("sceregvl.inf")

#define SAM_FILTER_PATH   TEXT("System\\CurrentControlSet\\Control\\Lsa")
#define SAM_FILTER_VALUE  TEXT("Notification Packages")

DWORD
ScepQuerySamFilterValue(
    IN HKEY hKey,
    IN BOOL bAdd,
    OUT PWSTR *pmszValue,
    OUT DWORD *pcbSize,
    OUT BOOL *pbChanged
    );

VOID
ScepInitClientData(
    void
    );

VOID
ScepUnInitClientData(
    void
    );


DWORD
DllpModifySamFilterRegistration(
    IN BOOL bAdd
    )
{
    DWORD lResult;
    HKEY hKey=NULL;

    if(( lResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                              SAM_FILTER_PATH,
                              0,
                              KEY_READ | KEY_WRITE,
                              &hKey
                             )) == ERROR_SUCCESS ) {

        DWORD dSize=0;
        PWSTR mszValue=NULL;
        BOOL bChanged=FALSE;

        //
        // find out if "scecli" is registered already
        //

        lResult = ScepQuerySamFilterValue(hKey,
                                          bAdd,
                                          &mszValue,
                                          &dSize,
                                          &bChanged
                                         );

        if ( lResult == ERROR_SUCCESS &&
             bChanged && mszValue ) {
            //
            // set the value
            //
            lResult = RegSetValueEx (
                            hKey,
                            SAM_FILTER_VALUE,
                            0,
                            REG_MULTI_SZ,
                            (BYTE *)mszValue,
                            dSize
                            );
        }

        RegCloseKey(hKey);

    }

    return lResult;
}

DWORD
ScepQuerySamFilterValue(
    IN HKEY hKey,
    IN BOOL bAdd,
    OUT PWSTR *pmszValue,
    OUT DWORD *pcbSize,
    OUT BOOL *pbChanged
    )
/*
Routine Description:

    query the existing notification packages. Add or remove "scecli" to the
    packages depending on the flag "bAdd". The packages are in MULTI_SZ
    format.

Arguments:

   hKey  - the base key handle off where the packages are saved

   bAdd  - if TRUE, add "scecli" to the packages if it's not there
           if FALSE, remove "scecli" from the packages

   pmszValue   - the modified packages value (in MULTI_SZ format)

   pcbSize     - the size of the packages (in bytes)

   pbChanged   - TRUE if anything is changed

Return Value:


   Win32 error code

*/
{
    DWORD lResult;
    DWORD RegType=REG_MULTI_SZ;
    DWORD dSize=0;
    PWSTR msz=NULL;

    if(( lResult = RegQueryValueEx(hKey,
                                 SAM_FILTER_VALUE,
                                 0,
                                 &RegType,
                                 NULL,
                                 &dSize
                                )) == ERROR_SUCCESS ) {
        //
        // query existing registered packages
        //
        if ( RegType == REG_MULTI_SZ ) {

            msz = (PWSTR)LocalAlloc( LMEM_ZEROINIT, dSize+2*sizeof(TCHAR));

            if ( msz ) {

                lResult = RegQueryValueEx(hKey,
                                         SAM_FILTER_VALUE,
                                         0,
                                         &RegType,
                                         (UCHAR *)msz,
                                         &dSize
                                        );
            } else {
                lResult = ERROR_NOT_ENOUGH_MEMORY;
            }
        } else {

            lResult = ERROR_FILE_NOT_FOUND;
        }

    }

    if ( lResult == ERROR_FILE_NOT_FOUND ||
         lResult == ERROR_PATH_NOT_FOUND ) {
        //
        // if doesn't find the value, ignore the error
        //
        lResult = ERROR_SUCCESS;
    }

    *pbChanged = FALSE;
    *pcbSize = 0;
    *pmszValue = NULL;

    if ( lResult == ERROR_SUCCESS &&
         msz == NULL &&
         bAdd ) {

        //
        // add scecli to the multi-sz value
        // note, since msz is NULL, no need to remove scecli for unregister
        //
        *pmszValue = (PWSTR)LocalAlloc(0, 16);
        if ( *pmszValue ) {

            wcscpy(*pmszValue, L"scecli");
            (*pmszValue)[6] = L'\0';
            (*pmszValue)[7] = L'\0';
            *pcbSize = 16;

            *pbChanged = TRUE;

        } else {
            lResult = ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    if ( ERROR_SUCCESS == lResult &&
         msz != NULL ) {

        //
        // there are existing values in the field
        //

        PWSTR pStart=msz;
        DWORD Len=0, Len2;
        BOOL bFound = FALSE;

        while ( pStart && pStart[0] != L'\0' &&
                Len <= dSize/2 ) {

            if ( _wcsicmp(pStart, L"scecli") == 0 ) {
                bFound = TRUE;
                break;
            } else {
                Len2 = wcslen(pStart)+1;
                pStart = pStart + Len2;
                Len += Len2;
            }
        }

        //
        // add/remove scecli
        //
        if ( bFound ) {

            //
            // pStart is pointing to scecli, remove it
            //
            if ( !bAdd ) {

                Len = (DWORD)(pStart - msz);
                Len2 = wcslen(pStart);

                *pmszValue = (PWSTR)LocalAlloc(LPTR, dSize + 2*sizeof(TCHAR) - (Len2 + 1)*sizeof(TCHAR) );

                if ( *pmszValue ) {

                    memcpy(*pmszValue, msz, Len*sizeof(TCHAR));
                    memcpy(*pmszValue+Len, pStart+Len2+1, dSize - (Len+Len2+1)*sizeof(TCHAR));

                    *pcbSize = dSize - (Len2+1)*sizeof(TCHAR);

                    *pbChanged = TRUE;
                } else {

                    lResult = ERROR_NOT_ENOUGH_MEMORY;
                }
            }

        } else {

            //
            // not found, add scecli
            //
            if ( bAdd ) {

               *pmszValue = (PWSTR)LocalAlloc(LPTR, dSize + 2*sizeof(TCHAR) + 7*sizeof(TCHAR) );

               if ( *pmszValue ) {

                   memcpy(*pmszValue, msz, dSize);

                   Len2 = 1;
                   while ( msz[dSize/2-Len2] == L'\0' ) {
                      Len2++;
                   }

                   wcscpy(*pmszValue+dSize/2-Len2+2, L"scecli");

                   *pcbSize = dSize + (2-Len2+wcslen(TEXT("scecli"))+2)*sizeof(TCHAR);

                   *pbChanged = TRUE;

               } else {

                   lResult = ERROR_NOT_ENOUGH_MEMORY;
               }
            }
        }
    }

    if ( msz ) {
       LocalFree(msz);
    }


    return lResult;
}

/*=============================================================================
**  Procedure Name:     DllMain
**
**  Arguments:
**
**
**
**  Returns:    0 = SUCCESS
**             !0 = ERROR
**
**  Abstract:
**
**  Notes:
**
**===========================================================================*/
BOOL WINAPI DllMain(
    IN HANDLE DllHandle,
    IN ULONG ulReason,
    IN LPVOID Reserved )
{

    switch(ulReason) {

    case DLL_PROCESS_ATTACH:

        MyModuleHandle = (HINSTANCE)DllHandle;
        ScepInitNameTable();
        (VOID) ScepInitClientData();

        //
        // initialize dynamic stack allocation
        //

        SafeAllocaInitialize(SAFEALLOCA_USE_DEFAULT,
                             SAFEALLOCA_USE_DEFAULT,
                             NULL,
                             NULL
                            );
        //
        // Fall through to process first thread
        //

#if DBG
        DebugInitialize();
#endif

    case DLL_THREAD_ATTACH:

        break;

    case DLL_PROCESS_DETACH:

        UninitializeChangeNotify();
        (VOID) ScepUnInitClientData();

#if DBG
        DebugUninit();
#endif
        break;

    case DLL_THREAD_DETACH:

        break;
    }

    return TRUE;
}

VOID
ScepInitClientData()
/*
Routine Description:

    Initialize global data for the client

Arguments:

    None

Return Value:

    None
*/
{
    /*
     initialize critical section that protects global rsop pointers (namespace, status, logfilename)
     by serializing multiple diagnostic modes/policy prop (planning mode uses no globals and is synch)
     this is necessary because the asynch thread that calls back the client and needs the above
     globals to be preserved (simple thread variables will not do since the asynch thread doesn't know
     that it is calling back to the same client thread that it got spawned by)

     logic for the acquizition/release of the crit sec is as follows for two cases that arise:


     case (a) background thread (no asynch thread spawned)

        Exported Policy Function (grab cs) ---> all GPO processing is synch ---> client returns (release cs)

    case (b) foreground thread (asynch thread is spawned for slow config areas)

        Exported Policy Function (grab cs) ---> try to spawn asynch thread ---> IF asynch thread spawned succ-
                        essfully it (releases cs) ELSE the synch thread (releases cs)
     */

    InitializeCriticalSection(&DiagnosisPolicypropSync);

    //
    // Initialize critical section used by policy notification from LSA/SAM.
    // The critical section protects a global counter for the number of
    // notifications sent to SCE. If the count is 0, there is no pending
    // notification that has not been added to the queue in SCE server;
    // otherwise, some notifications have been sent but has not returned yet.
    //
    // The global count is used to control if policy propagation should be
    // allowed.
    //
    InitializeCriticalSection(&PolicyNotificationSync);

    InitializeListHead( &ScepNotifyList );
}

VOID
ScepUnInitClientData()
/*
Routine Description:

    Uninitialize global data for the client

Arguments:

    None

Return Value:

    None
*/
{

    DeleteCriticalSection(&DiagnosisPolicypropSync);

    DeleteCriticalSection(&PolicyNotificationSync);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    HKEY hKey;
    LONG lResult;
    DWORD dwDisp;
    FILETIME Time;
    
    WCHAR szBuffer[MAX_PATH];
    WCHAR szMofFile[MAX_PATH + 30];
    HRESULT hr;

/*  the old interface
    lResult = RegCreateKeyEx (HKEY_LOCAL_MACHINE, GPT_SCEDLL_PATH, 0, NULL,
                              REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                              &hKey, &dwDisp);

    if (lResult != ERROR_SUCCESS)
    {
        return lResult;
    }


    RegSetValueEx (hKey, TEXT("ProcessGPO"), 0, REG_SZ, (LPBYTE)TEXT("SceWinlogonConfigureSystem"),
                   (lstrlen(TEXT("SceWinlogonConfigureSystem")) + 1) * sizeof(TCHAR));

    RegSetValueEx (hKey, TEXT("DllName"), 0, REG_EXPAND_SZ, (LPBYTE)TEXT("scecli.dll"),
                   (lstrlen(TEXT("scecli.dll")) + 1) * sizeof(TCHAR));
*/

    //
    // delete the old interface registration
    //
    RegDeleteKey ( HKEY_LOCAL_MACHINE, GPT_SCEDLL_PATH );

    //
    // register the new interface
    //
    lResult = RegCreateKeyEx (HKEY_LOCAL_MACHINE, GPT_SCEDLL_NEW_PATH, 0, NULL,
                              REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                              &hKey, &dwDisp);

    if (lResult != ERROR_SUCCESS)
    {
        return lResult;
    }


    RegSetValueEx (hKey, TEXT("ProcessGroupPolicy"), 0, REG_SZ, (LPBYTE)TEXT("SceProcessSecurityPolicyGPO"),
                   (lstrlen(TEXT("SceProcessSecurityPolicyGPO")) + 1) * sizeof(TCHAR));

    // RSOP Planning mode API
    RegSetValueEx (hKey, TEXT("GenerateGroupPolicy"), 0, REG_SZ, (LPBYTE)TEXT("SceGenerateGroupPolicy"),
                   (lstrlen(TEXT("SceGenerateGroupPolicy")) + 1) * sizeof(TCHAR));

    // RSOP Planning mode logging default (planning.log) -
    // turn on logging (ignore any errors)
    dwDisp = 1;
    RegSetValueEx (hKey, TEXT("ExtensionRsopPlanningDebugLevel"), 0, REG_DWORD, (LPBYTE)&dwDisp, sizeof(DWORD));

    // RSOP Diagnosis mode API
    RegSetValueEx (hKey, TEXT("ProcessGroupPolicyEx"), 0, REG_SZ, (LPBYTE)TEXT("SceProcessSecurityPolicyGPOEx"),
                   (lstrlen(TEXT("SceProcessSecurityPolicyGPOEx")) + 1) * sizeof(TCHAR));

    // RSOP Diagnosis mode or regular Policy Propagation  logging default (diagnosis.log and/or winlogon.log)
    // turn on logging (ignore any errors)
    dwDisp = 1;
    RegSetValueEx (hKey, TEXT("ExtensionDebugLevel"), 0, REG_DWORD, (LPBYTE)&dwDisp, sizeof(DWORD));

    RegSetValueEx (hKey, TEXT("DllName"), 0, REG_EXPAND_SZ, (LPBYTE)TEXT("scecli.dll"),
                   (lstrlen(TEXT("scecli.dll")) + 1) * sizeof(TCHAR));

    RegSetValueEx (hKey, NULL, 0, REG_SZ, (LPBYTE)TEXT("Security"),
                   (lstrlen(TEXT("Security")) + 1) * sizeof(TCHAR));
    RegDeleteValue (hKey, TEXT("<No Name>"));

    dwDisp = 1;
    RegSetValueEx (hKey, TEXT("NoUserPolicy"), 0, REG_DWORD, (LPBYTE)&dwDisp, sizeof(DWORD));
    RegSetValueEx (hKey, TEXT("NoGPOListChanges"), 0, REG_DWORD, (LPBYTE)&dwDisp, sizeof(DWORD));
    RegSetValueEx (hKey, TEXT("EnableAsynchronousProcessing"), 0, REG_DWORD, (LPBYTE)&dwDisp, sizeof(DWORD));

    dwDisp = 960;
    RegSetValueEx (hKey, TEXT("MaxNoGPOListChangesInterval"), 0, REG_DWORD, (LPBYTE)&dwDisp, sizeof(DWORD));

    RegCloseKey (hKey);

    // EFS recovery policy extension
    lResult = RegCreateKeyEx (HKEY_LOCAL_MACHINE, GPT_EFS_NEW_PATH, 0, NULL,
                              REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                              &hKey, &dwDisp);

    if (lResult != ERROR_SUCCESS)
    {
        return lResult;
    }


    RegSetValueEx (hKey, TEXT("ProcessGroupPolicy"), 0, REG_SZ, (LPBYTE)TEXT("SceProcessEFSRecoveryGPO"),
                   (lstrlen(TEXT("SceProcessEFSRecoveryGPO")) + 1) * sizeof(TCHAR));

    RegSetValueEx (hKey, TEXT("DllName"), 0, REG_EXPAND_SZ, (LPBYTE)TEXT("scecli.dll"),
                   (lstrlen(TEXT("scecli.dll")) + 1) * sizeof(TCHAR));

    RegSetValueEx (hKey, NULL, 0, REG_SZ, (LPBYTE)TEXT("EFS recovery"),
                   (lstrlen(TEXT("EFS recovery")) + 1) * sizeof(TCHAR));
    RegDeleteValue (hKey, TEXT("<No Name>"));

    dwDisp = 1;
    RegSetValueEx (hKey, TEXT("NoUserPolicy"), 0, REG_DWORD, (LPBYTE)&dwDisp, sizeof(DWORD));
    RegSetValueEx (hKey, TEXT("NoGPOListChanges"), 0, REG_DWORD, (LPBYTE)&dwDisp, sizeof(DWORD));

    RegDeleteValue (hKey, TEXT("RequireSuccessfulRegistry") );
    RegSetValueEx (hKey, TEXT("RequiresSuccessfulRegistry"), 0, REG_DWORD, (LPBYTE)&dwDisp, sizeof(DWORD));

    RegCloseKey (hKey);

    //
    // register default SAFER policy to disable executables embedded in Outlook
    //

    lResult = RegCreateKeyEx (HKEY_LOCAL_MACHINE,
                              SAFER_HKLM_REGBASE,
                              0,
                              NULL,
                              REG_OPTION_NON_VOLATILE,
                              KEY_WRITE,
                              NULL,
                              &hKey,
                              &dwDisp);

    if (lResult != ERROR_SUCCESS)
    {
        return lResult;
    }

    RegCloseKey (hKey);

    lResult = RegCreateKeyEx (HKEY_LOCAL_MACHINE,
                              SAFER_HKLM_REGBASE SAFER_REGKEY_SEPERATOR SAFER_CODEIDS_REGSUBKEY,
                              0,
                              NULL,
                              REG_OPTION_NON_VOLATILE,
                              KEY_WRITE,
                              NULL,
                              &hKey,
                              &dwDisp);

    if (lResult != ERROR_SUCCESS)
    {
        return lResult;
    }


    RegSetValueEx (hKey,
                   SAFER_EXETYPES_REGVALUE,
                   0,
                   REG_MULTI_SZ,
                   (LPBYTE)SAFER_DEFAULT_EXECUTABLE_FILE_TYPES,
                   sizeof(SAFER_DEFAULT_EXECUTABLE_FILE_TYPES));

    dwDisp = 0x00000001;

    RegSetValueEx (hKey,
                   SAFER_TRANSPARENTENABLED_REGVALUE,
                   0,
                   REG_DWORD,
                   (LPBYTE)&dwDisp,
                   sizeof(DWORD));

    dwDisp = 0x00040000;

    RegSetValueEx (hKey,
                   SAFER_DEFAULTOBJ_REGVALUE,
                   0,
                   REG_DWORD,
                   (LPBYTE)&dwDisp,
                   sizeof(DWORD));

    dwDisp = 0x00000000;

    RegSetValueEx (hKey,
                   SAFER_AUTHENTICODE_REGVALUE,
                   0,
                   REG_DWORD,
                   (LPBYTE)&dwDisp,
                   sizeof(DWORD));

    dwDisp = 0x00000000;

    RegSetValueEx (hKey,
                   SAFER_POLICY_SCOPE,
                   0,
                   REG_DWORD,
                   (LPBYTE)&dwDisp,
                   sizeof(DWORD));

    RegCloseKey (hKey);

    lResult = RegCreateKeyEx (HKEY_LOCAL_MACHINE,
                              SAFER_HKLM_REGBASE SAFER_REGKEY_SEPERATOR SAFER_CODEIDS_REGSUBKEY \
                              SAFER_REGKEY_SEPERATOR SAFER_LEVEL_ZERO,
                              0,
                              NULL,
                              REG_OPTION_NON_VOLATILE,
                              KEY_WRITE,
                              NULL,
                              &hKey,
                              &dwDisp);

    if (lResult != ERROR_SUCCESS)
    {
        return lResult;
    }

    RegCloseKey (hKey);

    lResult = RegCreateKeyEx (HKEY_LOCAL_MACHINE,
                              SAFER_HKLM_REGBASE SAFER_REGKEY_SEPERATOR SAFER_CODEIDS_REGSUBKEY \
                              SAFER_REGKEY_SEPERATOR SAFER_LEVEL_ZERO SAFER_REGKEY_SEPERATOR SAFER_PATHS_REGSUBKEY,
                              0,
                              NULL,
                              REG_OPTION_NON_VOLATILE,
                              KEY_WRITE,
                              NULL,
                              &hKey,
                              &dwDisp);

    if (lResult != ERROR_SUCCESS)
    {
        return lResult;
    }

    RegCloseKey (hKey);

    lResult = RegCreateKeyEx (HKEY_LOCAL_MACHINE,
                              SAFER_HKLM_REGBASE SAFER_REGKEY_SEPERATOR SAFER_CODEIDS_REGSUBKEY \
                              SAFER_REGKEY_SEPERATOR SAFER_LEVEL_ZERO SAFER_REGKEY_SEPERATOR \
                              SAFER_PATHS_REGSUBKEY SAFER_REGKEY_SEPERATOR SAFER_DEFAULT_RULE_GUID,
                              0,
                              NULL,
                              REG_OPTION_NON_VOLATILE,
                              KEY_WRITE,
                              NULL,
                              &hKey,
                              &dwDisp);

    if (lResult != ERROR_SUCCESS)
    {
        return lResult;
    }

    RegSetValueEx (hKey,
                   SAFER_IDS_DESCRIPTION_REGVALUE,
                   0,
                   REG_SZ,
                   (LPBYTE)&L"",
                   sizeof(L""));


    dwDisp = 0x00000000;

    RegSetValueEx (hKey,
                   SAFER_IDS_SAFERFLAGS_REGVALUE,
                   0,
                   REG_DWORD,
                   (LPBYTE)&dwDisp,
                   sizeof(DWORD));

    RegSetValueEx (hKey,
                   SAFER_IDS_ITEMDATA_REGVALUE,
                   0,
                   REG_EXPAND_SZ,
                   (LPBYTE)&L"%HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders\\Cache%OLK*",
                   sizeof(L"%HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders\\Cache%OLK*"));

    GetSystemTimeAsFileTime(&Time);

    RegSetValueEx (hKey,
                   SAFER_IDS_LASTMODIFIED_REGVALUE,
                   0,
                   REG_QWORD,
                   (LPBYTE)&Time,
                   sizeof(FILETIME));

    RegCloseKey (hKey);

    //
    // turn on default logging for component installs
    //
    if ( ERROR_SUCCESS == RegCreateKeyEx (HKEY_LOCAL_MACHINE, SCE_ROOT_PATH, 0, NULL,
                                  REG_OPTION_NON_VOLATILE, KEY_WRITE | KEY_QUERY_VALUE | KEY_SET_VALUE, NULL,
                                  &hKey, &dwDisp) ) {
        dwDisp = 1;
        RegSetValueEx (hKey, TEXT("SetupCompDebugLevel"), 0, REG_DWORD, (LPBYTE)&dwDisp, sizeof(DWORD));

        //
        // create value DefaultTemplate = C:\Windows\Inf\SecRecs.INF
        //

        DWORD   dwType = REG_SZ;

        if (ERROR_FILE_NOT_FOUND == RegQueryValueEx(hKey, TEXT("DefaultTemplate"), NULL, &dwType, NULL, NULL) ){

            WCHAR   szFileName[MAX_PATH*2+1];

            szFileName[0] = L'\0';

            GetSystemWindowsDirectory(szFileName, MAX_PATH);

            wcscat(szFileName, L"\\inf\\secrecs.inf");

            if ((DWORD)-1 != GetFileAttributes( szFileName ) ) {

                RegSetValueEx (hKey,
                               TEXT("DefaultTemplate"),
                               0,
                               REG_SZ,
                               (LPBYTE)&szFileName,
                               (wcslen(szFileName) + 1) * sizeof(WCHAR));

            }
        }

        RegCloseKey (hKey);
    }


    //
    // compile scersop.mof
    //

    szBuffer[0] = L'\0';
    szMofFile[0] = L'\0';

    if ( GetSystemDirectory( szBuffer, MAX_PATH ) ) {

        LPWSTR sz = szBuffer + wcslen(szBuffer);
        if ( sz != szBuffer && *(sz-1) != L'\\') {
            *sz++ = L'\\';
            *sz = L'\0';
        }


        wcscpy(szMofFile, szBuffer);
        wcscat(szMofFile, L"Wbem\\SceRsop.mof");

        if ((DWORD)-1 != GetFileAttributes(szMofFile)) {


            hr = ::CoInitialize (NULL);

            if (SUCCEEDED(hr)) {

                //
                // Get the MOF compiler interface
                //

                CComPtr<IMofCompiler> srpMof;
                hr = ::CoCreateInstance (CLSID_MofCompiler, NULL, CLSCTX_INPROC_SERVER, IID_IMofCompiler, (void **)&srpMof);

                if (SUCCEEDED(hr)) {
                    WBEM_COMPILE_STATUS_INFO  stat;

                    //
                    // compile RSOP mof
                    //

                    hr = srpMof->CompileFile( szMofFile,
                                              NULL,
                                              NULL,
                                              NULL,
                                              NULL,
                                              0,
                                              0,
                                              0, 
                                              &stat
                                            );

                }

                ::CoUninitialize();
            }
        }
    }

    //
    // register the default registry values
    //

    SceRegisterRegValues(SCE_REGVALUE_DEFAULT_FILE);

    //
    // register SAM policy filter
    //

    DllpModifySamFilterRegistration(TRUE);

    return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    //
    // delete old interface
    //
    RegDeleteKey (HKEY_LOCAL_MACHINE, GPT_SCEDLL_PATH);

    //
    // delete new interfaces
    //
    RegDeleteKey (HKEY_LOCAL_MACHINE, GPT_SCEDLL_NEW_PATH);
    RegDeleteKey (HKEY_LOCAL_MACHINE, GPT_EFS_NEW_PATH);

    DllpModifySamFilterRegistration(FALSE);

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\scerpc\client\setupcln.cpp ===
//depot/private/vishnup_branch/DS/security/services/scerpc/client/setupcln.cpp#6 - edit change 1167 (text)
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    setupcln.cpp

Abstract:

    SCE setup Client APIs

Author:

    Jin Huang (jinhuang) 23-Jun-1997 created

Revision History:

    jinhuang        23-Jan-1998   split to client-server model

--*/

#include "headers.h"
#include "scerpc.h"
#include "scesetup.h"
#include "sceutil.h"
#include "clntutil.h"
#include "scedllrc.h"
#include "infp.h"
#include <ntrpcp.h>
#include <io.h>
//#include "gpedit.h"
//#include <initguid.h>
#include <lmaccess.h>
#include "commonrc.h"

#include <aclapi.h>
#include <rpcasync.h>

typedef HRESULT (*PFREGISTERSERVER)(void);

static SCEPR_CONTEXT hSceSetupHandle=NULL;

extern PVOID theCallBack;
extern HANDLE hCallbackWnd;
extern DWORD CallbackType;
extern HINSTANCE MyModuleHandle;
TCHAR szCallbackPrefix[MAX_PATH];

#define STR_GUID_LEN                    36
#define SCESETUP_BACKUP_SECURITY        0x40

#define PRODUCT_UNKNOWN                 0

#define EFS_NOTIFY_PATH   TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\Notify\\EFS")


DWORD dwThisMachine = PRODUCT_UNKNOWN;
WCHAR szUpInfFile[MAX_PATH*2+1] = {'\0'};
BOOL  bIsNT5 = TRUE;

DWORD
WhichNTProduct();

BOOL
ScepAddAuthUserToLocalGroup();

BOOL
ScepAddInteractiveToPowerUsersGroup();

DWORD dwCallbackTotal=0;

DWORD
ScepSetupOpenSecurityDatabase(
    IN BOOL bSystemOrAdmin
    );

DWORD
ScepSetupCloseSecurityDatabase();

typedef enum _SCESETUP_OPERATION_TYPE {

    SCESETUP_UPDATE=1,
    SCESETUP_MOVE

} SCESETUP_OPERATION_TYPE;

typedef enum _SCESETUP_OBJECT_TYPE {

    SCESETUP_FILE=1,
    SCESETUP_KEY,
    SCESETUP_SERVICE

} SCESETUP_OBJECT_TYPE;

DWORD
SceSetuppLogComponent(
    IN DWORD ErrCode,
    IN SCESETUP_OBJECT_TYPE ObjType,
    IN SCESETUP_OPERATION_TYPE OptType,
    IN PWSTR Name,
    IN PWSTR SDText OPTIONAL,
    IN PWSTR SecondName OPTIONAL
    );

SCESTATUS
ScepSetupWriteOneError(
    IN HANDLE hFile,
    IN DWORD rc,
    IN LPTSTR buf
    );

SCESTATUS
ScepSetupWriteError(
    IN LPTSTR LogFileName,
    IN PSCE_ERROR_LOG_INFO  pErrlog
    );

BOOL
pCreateDefaultGPOsInSysvol(
    IN LPTSTR DomainDnsName,
    IN LPTSTR szSysvolPath,
    IN DWORD Options,
    IN LPTSTR LogFileName
    );

BOOL
pCreateSysvolContainerForGPO(
    IN LPCTSTR strGuid,
    IN LPTSTR szPath,
    IN DWORD dwStart
    );

BOOL
pCreateOneGroupPolicyObject(
    IN PWSTR pszGPOSysPath,
    IN BOOL bDomainLevel,
    IN PWSTR LogFileName
    );

DWORD
ScepDcPromoSharedInfo(
    IN HANDLE ClientToken,
    IN BOOL bDeleteLog,
    IN BOOL bSetSecurity,
    IN DWORD dwPromoteOptions,
    IN PSCE_PROMOTE_CALLBACK_ROUTINE pScePromoteCallBack OPTIONAL
    );

NTSTATUS
ScepDcPromoRemoveUserRights();

NTSTATUS
ScepDcPromoRemoveTwoRights(
    IN LSA_HANDLE PolicyHandle,
    IN SID_IDENTIFIER_AUTHORITY *pIA,
    IN UCHAR SubAuthCount,
    IN DWORD Rid1,
    IN DWORD Rid2
    );

DWORD
ScepSystemSecurityInSetup(
    IN PWSTR InfName,
    IN PCWSTR LogFileName OPTIONAL,
    IN AREA_INFORMATION Area,
    IN UINT nFlag,
    IN PSCE_NOTIFICATION_CALLBACK_ROUTINE pSceNotificationCallBack OPTIONAL,
    IN OUT PVOID pValue OPTIONAL
    );

DWORD
ScepMoveRegistryValue(
    IN HKEY hKey,
    IN PWSTR KeyFrom,
    IN PWSTR ValueFrom,
    IN PWSTR KeyTo OPTIONAL,
    IN PWSTR ValueTo OPTIONAL
    );

DWORD
ScepBreakSDDLToMultiFields(
    IN  PWSTR   pszObjName,
    IN  PWSTR   pszSDDL,
    IN  DWORD   dwSDDLsize,
    IN  BYTE    ObjStatus,
    OUT PWSTR   *ppszAdjustedInfLine
    );

SCESTATUS
SceInfpBreakTextIntoMultiFields(
    IN PWSTR szText,
    IN DWORD dLen,
    OUT LPDWORD pnFields,
    OUT LPDWORD *arrOffset
    );

//
// Client APIs in scesetup.h (for setup integration)
//
DWORD
WINAPI
SceSetupUpdateSecurityFile(
     IN PWSTR FileFullName,
     IN UINT nFlag,
     IN PWSTR SDText
     )
/*
Routine Description:

    This routine applies the security specified in SDText to the file on
    local system and update the SDDL security information to the SCE
    database.

Arguments:

    FileFullName    - the full path name of the file to update

    nFlag           - reserved flag for file option

    SDText          - the SDDL format security descriptor


Return Value:

    WIN32 error code for the status of this operation
*/
{
    if ( FileFullName == NULL || SDText == NULL ) {

        return(ERROR_INVALID_PARAMETER);
    }

    //
    // global database handle
    //
    SCESTATUS rc = ScepSetupOpenSecurityDatabase(FALSE);

    if ( rc == NO_ERROR ) {

        RpcTryExcept {

            //
            // update the file
            //

            rc = SceRpcSetupUpdateObject(
                         hSceSetupHandle,
                         (wchar_t *)FileFullName,
                         (DWORD)SE_FILE_OBJECT,
                         nFlag,
                         (wchar_t *)SDText
                         );

        } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

            //
            // get exception code (DWORD)
            //

            rc = RpcExceptionCode();

        } RpcEndExcept;
    }

    SceSetuppLogComponent(rc,
                          SCESETUP_FILE,
                          SCESETUP_UPDATE,
                          FileFullName,
                          SDText,
                          NULL);

    return rc;
}


DWORD
WINAPI
SceSetupUpdateSecurityService(
     IN PWSTR ServiceName,
     IN DWORD StartType,
     IN PWSTR SDText
     )
/*
Routine Description:

    This routine applies the security specified in SDText to the service on
    local system and update the SDDL security information to the SCE
    database.

Arguments:

    ServiceName     - the name of the service to update

    StartType       - startup type of the service

    SDText          - the SDDL format security descriptor


Return Value:

    WIN32 error code for the status of this operation
*/
{
    if ( ServiceName == NULL || SDText == NULL )
        return(ERROR_INVALID_PARAMETER);

    //
    // global database handle
    //
    SCESTATUS rc = ScepSetupOpenSecurityDatabase(FALSE);

    if ( rc == NO_ERROR ) {

        RpcTryExcept {

            //
            // Update the object information
            //

            rc = SceRpcSetupUpdateObject(
                            hSceSetupHandle,
                            (wchar_t *)ServiceName,
                            (DWORD)SE_SERVICE,
                            (UINT)StartType,
                            (wchar_t *)SDText
                            );

        } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

            //
            // get exception code (DWORD)
            //

            rc = RpcExceptionCode();

        } RpcEndExcept;
    }

    SceSetuppLogComponent(rc,
                          SCESETUP_SERVICE,
                          SCESETUP_UPDATE,
                          ServiceName,
                          SDText,
                          NULL);

    return rc;
}

// Registry object names returned by NtQueryObject are prefixed by
// the following
#define REG_OBJ_TAG L"\\REGISTRY\\"
#define REG_OBJ_TAG_LEN (sizeof(REG_OBJ_TAG) / sizeof(WCHAR) - 1)

DWORD
WINAPI
SceSetupUpdateSecurityKey(
     IN HKEY hKeyRoot,
     IN PWSTR KeyPath,
     IN UINT nFlag,
     IN PWSTR SDText
     )
/*
Routine Description:

    This routine applies the security specified in SDText to the registry key
    on local system and update the SDDL security information to the SCE
    database.

Arguments:

    hKeyRoot        - root handle of the key

    KeyPath         - the subdir key path relative to the root

    nFlag           - reserved flag for key option

    SDText          - the SDDL format security descriptor


Return Value:

    WIN32 error code for the status of this operation
*/
{
    if ( hKeyRoot == NULL || SDText == NULL )
        return(ERROR_INVALID_PARAMETER);

    DWORD rc = ERROR_SUCCESS;
    PWSTR KeyFullName=NULL;

    DWORD Len= 16;
    DWORD cLen=0;

    POBJECT_NAME_INFORMATION pNI=NULL;
    NTSTATUS Status;

    LPWSTR pwszPath=NULL;
    DWORD cchPath=0;
    //
    // translate the root key first
    // to determine the length required for the full name
    //

    if ( hKeyRoot != HKEY_LOCAL_MACHINE &&
         hKeyRoot != HKEY_USERS &&
         hKeyRoot != HKEY_CLASSES_ROOT ) {

        //
        // First, determine the size of the buffer we need...
        //
        Status = NtQueryObject(hKeyRoot,
                               ObjectNameInformation,
                               pNI,
                               0,
                               &cLen);
        if ( NT_SUCCESS(Status) ||
             Status == STATUS_BUFFER_TOO_SMALL ||
             Status == STATUS_INFO_LENGTH_MISMATCH ||
             Status == STATUS_BUFFER_OVERFLOW ) {

            //
            // allocate a buffer to get name information
            //
            pNI = (POBJECT_NAME_INFORMATION)LocalAlloc(LPTR, cLen);
            if ( pNI == NULL ) {
                rc = ERROR_NOT_ENOUGH_MEMORY;
            } else {

                Status = NtQueryObject(hKeyRoot,
                                       ObjectNameInformation,
                                       pNI,
                                       cLen,
                                       NULL);

                if (!NT_SUCCESS(Status))
                {
                    rc = RtlNtStatusToDosError(Status);
                }
                else if ( pNI && pNI->Name.Buffer && pNI->Name.Length > 0 )
                {
                    //
                    // Server doesn't like \REGISTRY as a prefix -- get
                    // rid of it and the backslash that follows it.
                    //

                    DWORD  dwSize = sizeof(L"\\REGISTRY\\") - sizeof(WCHAR);
                    DWORD  dwLen  = dwSize / sizeof(WCHAR);

                    if (_wcsnicmp(pNI->Name.Buffer,
                                  L"\\REGISTRY\\",
                                  min(dwLen,
                                      pNI->Name.Length / sizeof(WCHAR))) == 0)
                    {
                        RtlMoveMemory(pNI->Name.Buffer,
                                      pNI->Name.Buffer + dwLen,
                                      pNI->Name.Length - dwSize);

                        pNI->Name.Length -= (USHORT) dwSize;
                    }

                    //
                    // get the required length, plus one space for the backslash,
                    // and one for null
                    //
                    Len = pNI->Name.Length/sizeof(WCHAR) + 2;
                }
                else
                {
                    rc = ERROR_INVALID_PARAMETER;
                }
            }

        } else {
            rc = RtlNtStatusToDosError(Status);
        }
    }

    if ( rc == ERROR_SUCCESS ) {

        //
        // make a full path name for the key
        //

        if ( KeyPath != NULL ) {
            Len += wcslen(KeyPath);
        }

        KeyFullName = (PWSTR)LocalAlloc(LMEM_ZEROINIT, Len*sizeof(WCHAR));

        if ( KeyFullName == NULL ) {
            rc = ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    if ( rc == ERROR_SUCCESS ) {

        //
        // translate the root key
        //

        if ( hKeyRoot == HKEY_LOCAL_MACHINE ) {
            wcscpy(KeyFullName, L"MACHINE");

        } else if ( hKeyRoot == HKEY_USERS ) {
            wcscpy(KeyFullName, L"USERS");

        } else if ( hKeyRoot == HKEY_CLASSES_ROOT ) {
            wcscpy(KeyFullName, L"CLASSES_ROOT");

        } else if ( pNI && pNI->Name.Buffer && pNI->Name.Length > 0 ) {
            //
            // copy the name of the key
            //
            memcpy(KeyFullName, pNI->Name.Buffer, pNI->Name.Length);
            KeyFullName[pNI->Name.Length/sizeof(WCHAR)] = L'\0';

        } else {
            rc = ERROR_INVALID_PARAMETER;
        }

        if ( rc == ERROR_SUCCESS && KeyPath != NULL ) {
            wcscat(KeyFullName, L"\\");
            wcscat(KeyFullName, KeyPath);
        }
    }

    if ( rc == ERROR_SUCCESS ) {

        //
        // global database handle
        //

        rc = ScepSetupOpenSecurityDatabase(FALSE);

        if ( NO_ERROR == rc ) {

            RpcTryExcept {

                //
                // update the object
                //

                rc = SceRpcSetupUpdateObject(
                                 hSceSetupHandle,
                                 (wchar_t *)KeyFullName,
                                 (DWORD)SE_REGISTRY_KEY,
                                 nFlag,
                                 (wchar_t *)SDText
                                 );

            } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

                //
                // get exception code (DWORD)
                //

                rc = RpcExceptionCode();

            } RpcEndExcept;
        }

    }

    SceSetuppLogComponent(rc,
                          SCESETUP_KEY,
                          SCESETUP_UPDATE,
                          KeyFullName ? KeyFullName : KeyPath,
                          SDText,
                          NULL);

    if ( KeyFullName )
        LocalFree(KeyFullName);

    if ( pNI )
        LocalFree(pNI);

    return(rc);
}

DWORD
WINAPI
SceSetupMoveSecurityFile(
    IN PWSTR FileToSetSecurity,
    IN PWSTR FileToSaveInDB OPTIONAL,
    IN PWSTR SDText OPTIONAL
    )
{

    if ( !FileToSetSecurity ) {
        return(ERROR_INVALID_PARAMETER);
    }

    //
    // if I am in setup, query the security policy/user rights for any
    // policy changes within setup (such as NT4 PDC upgrade where the policy
    // filter will fail to save the change)
    //

    DWORD dwInSetup=0;
    DWORD rc = ERROR_SUCCESS;

    ScepRegQueryIntValue(HKEY_LOCAL_MACHINE,
                TEXT("System\\Setup"),
                TEXT("SystemSetupInProgress"),
                &dwInSetup
                );

    if ( dwInSetup ) {

        rc = ScepSetupOpenSecurityDatabase(FALSE);

        if ( NO_ERROR == rc ) {

            RpcTryExcept {

                //
                // move the object
                //

                rc = SceRpcSetupMoveFile(
                             hSceSetupHandle,
                             (wchar_t *)FileToSetSecurity,
                             (wchar_t *)FileToSaveInDB,
                             (wchar_t *)SDText
                             );

            } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

                //
                // get exception code (DWORD)
                //

                rc = RpcExceptionCode();

            } RpcEndExcept;
        }

        if ( FileToSaveInDB == NULL &&
             rc != NO_ERROR ) {
            //
            // error occured to delete this file,
            // do not report error
            //
            rc = NO_ERROR;
        }
        SceSetuppLogComponent(rc,
                              SCESETUP_FILE,
                              SCESETUP_MOVE,
                              FileToSetSecurity,
                              SDText,
                              FileToSaveInDB
                              );

    } else {
        SceSetuppLogComponent(rc,
                              SCESETUP_FILE,
                              SCESETUP_MOVE,
                              FileToSetSecurity,
                              NULL,
                              L"Operation aborted - not in setup"
                              );

    }

    return(rc);

}


DWORD
WINAPI
SceSetupUnwindSecurityFile(
    IN PWSTR FileFullName,
    IN PSECURITY_DESCRIPTOR pSDBackup
    )
/*
Routine Description:

    This routine reset security settings for the file in SCE database (unwind)
    used by two-phase copy file process in setupapi.

Arguments:

    FileFullName  - The full path name for the file to undo.

    pSDBackup     - The backup security descriptor

Return Value:

    WIN32 error code for the status of this operation
*/
{
    if ( !FileFullName || !pSDBackup ) {
        return(ERROR_INVALID_PARAMETER);
    }

    DWORD dwInSetup=0;
    DWORD rc = ERROR_SUCCESS;

    ScepRegQueryIntValue(HKEY_LOCAL_MACHINE,
                TEXT("System\\Setup"),
                TEXT("SystemSetupInProgress"),
                &dwInSetup
                );

    if ( dwInSetup ) {

        rc = ScepSetupOpenSecurityDatabase(FALSE);

        PWSTR TextSD=NULL;
        DWORD TextSize;

        if ( NO_ERROR == rc ) {

            rc = ConvertSecurityDescriptorToText(
                              pSDBackup,
                              0xF,  // all security component
                              &TextSD,
                              &TextSize
                              );
        }

        if ( NO_ERROR == rc && TextSD ) {

            RpcTryExcept {

                //
                // update security in the database only
                //

                rc = SceRpcSetupUpdateObject(
                                 hSceSetupHandle,
                                 (wchar_t *)FileFullName,
                                 (DWORD)SE_FILE_OBJECT,
                                 SCESETUP_UPDATE_DB_ONLY,
                                 (wchar_t *)TextSD
                                 );

            } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

                //
                // get exception code (DWORD)
                //

                rc = RpcExceptionCode();

            } RpcEndExcept;
        }

        if ( TextSD ) {
            LocalFree(TextSD);
        }
    }

    return(rc);

}


DWORD
WINAPI
SceSetupGenerateTemplate(
    IN LPTSTR SystemName OPTIONAL,
    IN LPTSTR JetDbName OPTIONAL,
    IN BOOL bFromMergedTable,
    IN LPTSTR InfTemplateName,
    IN LPTSTR LogFileName OPTIONAL,
    IN AREA_INFORMATION Area
    )
/*
Routine Description:

    This routine generate a INF format template from the SCE database specified
    by JetDbName, or the default SCE database if JetDbName is NULL.

Arguments:

    JetDbName   - the SCE database name (optional) to get information from.
                    If NULL, the default security database is used.

    InfTemplateName - the inf template name to generate

    LogFileName - the log file name (optional)

    Area        - the security area to generate

Return Value:

    WIN32 error code for the status of this operation
*/
{

    DWORD rc;
    handle_t  binding_h;
    NTSTATUS NtStatus;
    PSCE_ERROR_LOG_INFO pErrlog=NULL;

    //
    // verify the InfTemplateName for invalid path error
    // or access denied error
    //

    rc = ScepVerifyTemplateName(InfTemplateName, &pErrlog);

    if ( NO_ERROR == rc ) {

        //
        // RPC bind to the server
        //

        NtStatus = ScepBindSecureRpc(
                        SystemName,
                        L"scerpc",
                        0,
                        &binding_h
                        );

        if ( NT_SUCCESS(NtStatus) ) {

            SCEPR_CONTEXT Context;

            RpcTryExcept {

                //
                // pass to the server site to generate template
                //

                rc = SceRpcGenerateTemplate(
                                binding_h,
                                (wchar_t *)JetDbName,
                                (wchar_t *)LogFileName,
                                (PSCEPR_CONTEXT)&Context
                                );

                if ( SCESTATUS_SUCCESS == rc) {
                    //
                    // a context handle is opened to generate this template
                    //

                    rc = SceCopyBaseProfile(
                                (PVOID)Context,
                                bFromMergedTable ? SCE_ENGINE_SCP : SCE_ENGINE_SMP,
                                (wchar_t *)InfTemplateName,
                                Area,
                                &pErrlog
                                );

                    ScepSetupWriteError(LogFileName, pErrlog);
                    ScepFreeErrorLog(pErrlog);

                    //
                    // close the context
                    //

                    SceRpcCloseDatabase(&Context);

                }

            } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

                //
                // get exception code (DWORD)
                //

                rc = RpcExceptionCode();

            } RpcEndExcept;

        } else {

            rc = RtlNtStatusToDosError( NtStatus );
        }

        if ( binding_h ) {
            //
            // Free the binding handle
            //

            RpcpUnbindRpc( binding_h );
        }

    } else {

        ScepSetupWriteError(LogFileName, pErrlog);
        ScepFreeErrorLog(pErrlog);
    }

    return(rc);

}

DWORD
ScepMoveRegistryValue(
    IN HKEY hKey,
    IN PWSTR KeyFrom,
    IN PWSTR ValueFrom,
    IN PWSTR KeyTo OPTIONAL,
    IN PWSTR ValueTo OPTIONAL
    )
/*
Some registry values are moved to new locations on NT5. This routine is to migrate
the registry values from their old location on NT4 (KeyFrom, ValueFrom) to their
new location on NT5 (KeyTo, ValueTo).

If destination key or value is not specified, the registry value is moved in the same
key or with different value name. Both KeyTo and ValueTo can't be NULL at the same
time.

*/
{
    if ( hKey == NULL || KeyFrom == NULL || ValueFrom == NULL ||
         (KeyTo == NULL && ValueTo == NULL) ) {
        return(ERROR_INVALID_PARAMETER);
    }

    DWORD rc=ERROR_SUCCESS;
    HKEY hKey1=NULL;
    HKEY hKey2=NULL;
    DWORD RegType=0;
    DWORD dSize=0;

    //
    // open the destination to see if the value already exist
    //

    if ( KeyTo ) {

        rc = RegOpenKeyEx(hKey,
                          KeyTo,
                          0,
                          KEY_READ | KEY_WRITE,
                          &hKey2);

        if ( ERROR_SUCCESS == rc ) {
            //
            // open the origin
            //
            rc = RegOpenKeyEx(hKey,
                              KeyFrom,
                              0,
                              KEY_READ,
                              &hKey1);
        }

    } else {

        //
        // if a reg value is moved to the same key as origin,
        // open the key with appropriate access
        //

        rc = RegOpenKeyEx(hKey,
                          KeyFrom,
                          0,
                          KEY_READ | KEY_WRITE,
                          &hKey2);
        hKey1 = hKey2;
    }


    if ( ERROR_SUCCESS == rc ) {

        // query destination
        rc = RegQueryValueEx(hKey2,
                            ValueTo ? ValueTo : ValueFrom,
                            0,
                            &RegType,
                            NULL,
                            &dSize
                            );

        if ( ERROR_FILE_NOT_FOUND == rc ) {
            //
            // only move value if the destination doesn't have the value
            //

            rc = RegQueryValueEx(hKey1,
                                ValueFrom,
                                0,
                                &RegType,
                                NULL,
                                &dSize
                                );

            if ( ERROR_SUCCESS == rc ) {

                PWSTR pValue = (PWSTR)ScepAlloc( LMEM_ZEROINIT, (dSize+1)*sizeof(TCHAR));

                if ( pValue != NULL ) {

                    rc = RegQueryValueEx(hKey1,
                                         ValueFrom,
                                         0,
                                         &RegType,
                                         (BYTE *)pValue,
                                         &dSize
                                        );

                    if ( ERROR_SUCCESS == rc ) {
                        //
                        // set the value to its new location
                        //

                        rc = RegSetValueEx( hKey2,
                                            ValueTo ? ValueTo : ValueFrom,
                                            0,
                                            RegType,
                                            (BYTE *)pValue,
                                            dSize
                                            );

                    }

                    ScepFree(pValue);
                }
            }

        }

    }

    if ( hKey1 && hKey1 != hKey2 ) {

        RegCloseKey(hKey1);
    }

    if ( hKey2 ) {
        RegCloseKey(hKey2);
    }

    return(rc);

}


DWORD
WINAPI
SceSetupSystemByInfName(
    IN PWSTR InfName,
    IN PCWSTR LogFileName OPTIONAL,
    IN AREA_INFORMATION Area,
    IN UINT nFlag,
    IN PSCE_NOTIFICATION_CALLBACK_ROUTINE pSceNotificationCallBack OPTIONAL,
    IN OUT PVOID pValue OPTIONAL
    )
/*
Routine Description:

    nFlag                           Operation

    SCESETUP_CONFIGURE_SECURITY     overwrite security with the template info
    SCESETUP_UPDATE_SECURITY        apply template on top of existing security
                                    (do not overwrite the security database)
    SCESETUP_QUERY_TICKS            query total number of ticks for the operation

Note: when nFlag is SCESETUP_QUERY_TICKS, pValue is PDWORD to output total number of ticks
    but when nFlag is the other two values, pValue is a input window handle used
    for setup's gauge window (required by the call back routine)
*/
{

    DWORD rc;
    LONG  Count=0;

    //
    // Initialize the SCP engine
    //
    if ( InfName == NULL ) {
        return(ERROR_INVALID_PARAMETER);
    }

    //
    // always configure security policy, user rights, but NO ds objects
    // (because this is in setup clean install, no DC available)
    //
    AREA_INFORMATION Area2;

    if ( (nFlag & SCESETUP_UPGRADE_SYSTEM) ||
         (nFlag & SCESETUP_UPDATE_FILE_KEY) ) {

        Area2 = 0;

        if ( nFlag & SCESETUP_UPGRADE_SYSTEM ) {

            Area2 = AREA_SECURITY_POLICY |
                    AREA_PRIVILEGES;
        }

        if ( nFlag & SCESETUP_UPDATE_FILE_KEY ) {

            Area2 |= (Area & ~AREA_DS_OBJECTS);
        }

    } else {

        //
        // LSA/SAM are initialized by now (starting 1823)
        // configure security policies
        //
        Area2 = AREA_SECURITY_POLICY |
                AREA_PRIVILEGES |
                AREA_GROUP_MEMBERSHIP |
                (Area & ~AREA_DS_OBJECTS);

//        Area2 = (Area & ~AREA_DS_OBJECTS);
    }

    if ( nFlag & SCESETUP_QUERY_TICKS ) {

        //
        // only queries ticks from the inf file.
        // for the case of updating security, there might be existing objects in
        // the SCE database.
        //

        if ( pValue == NULL ) {

            return(ERROR_INVALID_PARAMETER);
        }

        Count = 0;
        HINF InfHandle;

        if ( !(nFlag & SCESETUP_UPGRADE_SYSTEM) ||
             (nFlag & SCESETUP_UPDATE_FILE_KEY) ) {

            InfHandle = SetupOpenInfFile(
                                InfName,
                                NULL,
                                INF_STYLE_WIN4,
                                NULL
                                );

            if ( InfHandle != INVALID_HANDLE_VALUE ) {

                if ( Area2 & AREA_REGISTRY_SECURITY ) {

                    Count += SetupGetLineCount(InfHandle, szRegistryKeys);

                }
                if ( Area2 & AREA_FILE_SECURITY ) {

                    Count += SetupGetLineCount(InfHandle, szFileSecurity);
                }

                SetupCloseInfFile(InfHandle);

            } else {

                dwCallbackTotal = 0;

                return(GetLastError() );
            }
        }
        else {
            //Upgrade
            memset(szUpInfFile, 0, sizeof(WCHAR) * (MAX_PATH + 1));
            GetSystemWindowsDirectory(szUpInfFile, MAX_PATH);

            DWORD TsInstalled = 0;
            bIsNT5 = IsNT5();
            dwThisMachine = WhichNTProduct();

            switch (dwThisMachine) {
            case NtProductWinNt:
                wcscat(szUpInfFile, L"\\inf\\dwup.inf\0");
                break;
            case NtProductServer:
                //
                // determine if this is a terminal server in app mode
                //

                if ( bIsNT5 ) {
                    //
                    // on NT5, check the TSAppCompat value // TSEnabled value
                    //
                    ScepRegQueryIntValue(HKEY_LOCAL_MACHINE,
                                TEXT("System\\CurrentControlSet\\Control\\Terminal Server"),
                                TEXT("TSAppCompat"),
                                &TsInstalled
                                );
                    if ( TsInstalled != 1 ) {
                        //
                        // Terminal server is enabled when the value is set to 0x1
                        //
                        TsInstalled = 0;
                    }

                } else {
                    //
                    // on NT4, base on the ProductSuite value
                    //
                    PWSTR pSuite=NULL;
                    DWORD RegType=0;
                    DWORD   Rcode;
                    HKEY    hKey=NULL;
                    DWORD   dSize=0;

                    if(( Rcode = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                              TEXT("SYSTEM\\CurrentControlSet\\Control\\ProductOptions"),
                                              0,
                                              KEY_READ,
                                              &hKey
                                             )) == ERROR_SUCCESS ) {

                        if(( Rcode = RegQueryValueEx(hKey,
                                                     TEXT("ProductSuite"),
                                                     0,
                                                     &RegType,
                                                     NULL,
                                                     &dSize
                                                    )) == ERROR_SUCCESS ) {

                            pSuite = (PWSTR)ScepAlloc( LMEM_ZEROINIT, (dSize+1)*sizeof(TCHAR));

                            if ( pSuite != NULL ) {
                                Rcode = RegQueryValueEx(hKey,
                                                        TEXT("ProductSuite"),
                                                       0,
                                                       &RegType,
                                                       (BYTE *)pSuite,
                                                       &dSize
                                                      );

                                if ( Rcode == ERROR_SUCCESS ) {
                                    if ( RegType == REG_MULTI_SZ ) {

                                        //
                                        // check if the value contains "Terminal Server"
                                        //
                                        PWSTR pTemp=pSuite;
                                        while ( pTemp[0] != L'\0' ) {
                                            if ( lstrcmpi(TEXT("Terminal Server"),pTemp) == 0 ) {
                                                TsInstalled = 1;
                                                break;
                                            } else {
                                                pTemp += wcslen(pTemp)+1;
                                            }
                                        }

                                    } else if ( RegType == REG_SZ ) {

                                        if (lstrcmpi(TEXT("Terminal Server"), pSuite) == 0) {
                                            TsInstalled = 1;
                                        }
                                    }
                                }

                                ScepFree(pSuite);
                            }
                        }

                        RegCloseKey( hKey );

                    }

                }

                if ( TsInstalled ) {
                    //
                    // if terminal server is installed, use the
                    // special terminal server template
                    //
                    wcscat(szUpInfFile, L"\\inf\\dsupt.inf\0");
                } else {
                    wcscat(szUpInfFile, L"\\inf\\dsup.inf\0");
                }
                break;
            case NtProductLanManNt:
                if ( bIsNT5 ) {
                    wcscat(szUpInfFile, L"\\inf\\dcup5.inf\0");
                }
                else {
                    szUpInfFile[0] = L'\0';
                }
                break;
            default:
                szUpInfFile[0] = L'\0';
            }

            if (szUpInfFile[0] != L'\0') {
                InfHandle = SetupOpenInfFile(
                                szUpInfFile,
                                NULL,
                                INF_STYLE_WIN4,
                                NULL
                                );

                if ( InfHandle != INVALID_HANDLE_VALUE ) {

                    if ( Area2 & AREA_REGISTRY_SECURITY ) {

                        Count += SetupGetLineCount(InfHandle, szRegistryKeys);

                    }
                    if ( Area2 & AREA_FILE_SECURITY ) {

                        Count += SetupGetLineCount(InfHandle, szFileSecurity);
                    }

                    SetupCloseInfFile(InfHandle);

                } else {

                    dwCallbackTotal = 0;

                    return(GetLastError() );
                }
            }

            //
            // migrate registry values
            // should do this for both NT4 and NT5 upgrades since previous NT5
            // may be upgraded from NT4
            //
            // Having the registry value in the right place will help to fix
            // the tattoo problem in the new design
            //

            ScepMoveRegistryValue(
                HKEY_LOCAL_MACHINE,
                L"Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon",
                L"DisableCAD",
                L"Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\System",
                NULL
                );

            ScepMoveRegistryValue(
                HKEY_LOCAL_MACHINE,
                L"Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon",
                L"DontDisplayLastUserName",
                L"Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\System",
                NULL
                );

            ScepMoveRegistryValue(
                HKEY_LOCAL_MACHINE,
                L"Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon",
                L"LegalNoticeCaption",
                L"Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\System",
                NULL
                );

            ScepMoveRegistryValue(
                HKEY_LOCAL_MACHINE,
                L"Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon",
                L"LegalNoticeText",
                L"Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\System",
                NULL
                );

            ScepMoveRegistryValue(
                HKEY_LOCAL_MACHINE,
                L"Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon",
                L"ShutdownWithoutLogon",
                L"Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\System",
                NULL
                );

            ScepMoveRegistryValue(
                HKEY_LOCAL_MACHINE,
                L"System\\CurrentControlSet\\Services\\Rdr\\Parameters",
                L"EnableSecuritySignature",
                L"System\\CurrentControlSet\\Services\\LanmanWorkstation\\Parameters",
                NULL
                );

            ScepMoveRegistryValue(
                HKEY_LOCAL_MACHINE,
                L"System\\CurrentControlSet\\Services\\Rdr\\Parameters",
                L"RequireSecuritySignature",
                L"System\\CurrentControlSet\\Services\\LanmanWorkstation\\Parameters",
                NULL
                );

            ScepMoveRegistryValue(
                HKEY_LOCAL_MACHINE,
                L"System\\CurrentControlSet\\Services\\Rdr\\Parameters",
                L"EnablePlainTextPassword",
                L"System\\CurrentControlSet\\Services\\LanmanWorkstation\\Parameters",
                NULL
                );
        }

        if ( Area2 & AREA_SECURITY_POLICY )
            Count += TICKS_SECURITY_POLICY_DS + TICKS_SPECIFIC_POLICIES;

        if ( Area2 & AREA_GROUP_MEMBERSHIP )
            Count += TICKS_GROUPS;

        if ( Area2 & AREA_PRIVILEGES )
            Count += TICKS_PRIVILEGE;

        if ( Area2 & AREA_SYSTEM_SERVICE )
            Count += TICKS_GENERAL_SERVICES + TICKS_SPECIFIC_SERVICES;

        if ( nFlag & SCESETUP_UPGRADE_SYSTEM ) {
            Count += (4*TICKS_MIGRATION_SECTION+TICKS_MIGRATION_V11);
        }

        *(PDWORD)pValue = Count;

        dwCallbackTotal = Count;

        return(ERROR_SUCCESS);

    }

    //
    // delete the temp policy filter files and registry value
    //
    ScepClearPolicyFilterTempFiles(TRUE);

    //
    // make sure the log file is not too big
    //

    DWORD dwLogSize=0;

    HANDLE hFile = CreateFile(LogFileName,
                        GENERIC_READ | GENERIC_WRITE,
                        FILE_SHARE_READ,
                        NULL,
                        OPEN_ALWAYS,  // OPEN_EXISTING
                        FILE_ATTRIBUTE_NORMAL,
                        NULL);

    if ( INVALID_HANDLE_VALUE != hFile ) {

        dwLogSize = GetFileSize(hFile, NULL);

        CloseHandle(hFile);
    }

    if ( dwLogSize >= (0x1 << 23) ) {

        DWORD nRequired = wcslen(LogFileName);

        LPTSTR szTempName = (LPTSTR)LocalAlloc(0, (nRequired+1)*sizeof(TCHAR));

        if ( szTempName ) {
            wcscpy(szTempName, LogFileName);
            szTempName[nRequired-3] = L'o';
            szTempName[nRequired-2] = L'l';
            szTempName[nRequired-1] = L'd';

            CopyFile( LogFileName, szTempName, FALSE );
            LocalFree(szTempName);
        }

        DeleteFile(LogFileName);

    }

    //
    // configure the system now
    //
    rc = ScepSystemSecurityInSetup(
                InfName,
                LogFileName,
                Area,
                (nFlag & 0xFL),  // block out other flags such as BIND_NO_AUTH
                pSceNotificationCallBack,
                pValue
                );

    if ( rc == ERROR_DATABASE_FAILURE ) {

        //
        // setup category error - log to eventlog
        //

        (void) InitializeEvents(L"SceCli");

        LogEvent(MyModuleHandle,
                 STATUS_SEVERITY_ERROR,
                 SCEEVENT_ERROR_JET_DATABASE,
                 IDS_ERROR_OPEN_JET_DATABASE,
                 L"%windir%\\security\\database\\secedit.sdb"
                );

        (void) ShutdownEvents();

    }

    return rc;

}

DWORD
ScepSystemSecurityInSetup(
    IN PWSTR InfName,
    IN PCWSTR LogFileName OPTIONAL,
    IN AREA_INFORMATION Area,
    IN UINT nFlag,
    IN PSCE_NOTIFICATION_CALLBACK_ROUTINE pSceNotificationCallBack OPTIONAL,
    IN OUT PVOID pValue OPTIONAL
    )
{
    SCESTATUS           rc;
    DWORD               ConfigOptions;
    handle_t  binding_h;
    NTSTATUS NtStatus;

    //
    // always configure security policy, user rights, but NO ds objects
    // (because this is in setup clean install, no DC available)
    //
    AREA_INFORMATION Area2;

    if ( (nFlag & SCESETUP_UPGRADE_SYSTEM) ||
         (nFlag & SCESETUP_UPDATE_FILE_KEY) ) {
/*
        //
        // should allow policy filter on W2K DC upgrade (dcup5)
        // policy filter is ignored for non DCs in the filter code
        // so it's not needed to add condition here
        //
        // turn off policy filter if this is upgrade
        // clean install, policy filter has not been registered yet.
        //
        ScepRegSetIntValue(
                HKEY_LOCAL_MACHINE,
                SCE_ROOT_PATH,
                TEXT("PolicyFilterOff"),
                1
                );
*/
        ConfigOptions = SCE_UPDATE_DB | SCE_SETUP_SERVICE_NOSTARTTYPE;
        Area2 = 0;

        if ( nFlag & SCESETUP_UPGRADE_SYSTEM ) {

            Area2 = AREA_SECURITY_POLICY |
                    AREA_PRIVILEGES;
        }

        if ( nFlag & SCESETUP_UPDATE_FILE_KEY ) {

            Area2 |= (Area & ~AREA_DS_OBJECTS);
        }

    } else if ( nFlag & SCESETUP_BACKUP_SECURITY ) {

        ConfigOptions = SCE_UPDATE_DB | SCE_SETUP_SERVICE_NOSTARTTYPE;
        Area2 = Area;

    } else {

        ConfigOptions = SCE_OVERWRITE_DB;

        //
        // LSA/SAM are initialized by now (starting 1823)
        // configure security policies
        //
        Area2 = AREA_SECURITY_POLICY |
                AREA_PRIVILEGES |
                AREA_GROUP_MEMBERSHIP |
                (Area & ~AREA_DS_OBJECTS);

//        Area2 = (Area & ~AREA_DS_OBJECTS);
    }

    //
    // a callback routine is passed in
    //
    ScepSetCallback((PVOID)pSceNotificationCallBack,
                    (HANDLE)pValue,
                     SCE_SETUP_CALLBACK
                     );

    //
    // should we close the database opened by single
    // object update ?
    // ScepSetupCloseSecurityDatabase();

    //
    // RPC bind to the server
    //

    NtStatus = ScepBindRpc(
                    NULL,
                    L"scerpc",
                    L"security=impersonation dynamic false",
                    &binding_h
                    );
    
    /*
    if ( nFlag & SCESETUP_BIND_NO_AUTH ) {

        NtStatus = ScepBindRpc(
                        NULL,
                        L"scerpc",
                        L"security=impersonation dynamic false",
                        &binding_h
                        );
    } else {

        NtStatus = ScepBindSecureRpc(
                        NULL,
                        L"scerpc",
                        L"security=impersonation dynamic false",
                        &binding_h
                        );
    }*/

    if (NT_SUCCESS(NtStatus)){
        //
        // if there is notification handle, set the notify bit
        //

        if ( pSceNotificationCallBack ) {
            ConfigOptions |= SCE_CALLBACK_DELTA;
        }

        LPVOID pebClient = GetEnvironmentStrings();
        DWORD ebSize = ScepGetEnvStringSize(pebClient);

        RpcTryExcept {

            DWORD dWarn=0;

            if ( nFlag & SCESETUP_RECONFIG_SECURITY ) {

                ConfigOptions = SCE_UPDATE_DB;
                Area2 = AREA_FILE_SECURITY;//AREA_ALL;

                rc = SceRpcConfigureSystem(
                            binding_h,
                            (wchar_t *)InfName,
                            NULL,
                            (wchar_t *)LogFileName,
                            ConfigOptions | SCE_DEBUG_LOG,
                            (AREAPR)Area2,
                            ebSize,
                            (UCHAR *)pebClient,
                            &dWarn
                            );
            }
            else if ( (ConfigOptions & SCE_UPDATE_DB) &&
                 (nFlag & SCESETUP_UPGRADE_SYSTEM) ) {

                //
                // save a flag to indicate this is an upgrade
                //
                if ( ScepRegSetIntValue(
                        HKEY_LOCAL_MACHINE,
                        SCE_ROOT_PATH,
                        TEXT("SetupUpgraded"),
                        1
                        ) != ERROR_SUCCESS) {

                    //
                    // try again to create the key and then set the value
                    // don't worry about error this time around
                    //

                    HKEY hKey = NULL;
                    DWORD dwValue = 1;

                    if ( ERROR_SUCCESS == RegCreateKeyEx (HKEY_LOCAL_MACHINE,
                                                          SCE_ROOT_PATH,
                                                          0,
                                                          NULL,
                                                          REG_OPTION_NON_VOLATILE,
                                                          KEY_WRITE | KEY_SET_VALUE,
                                                          NULL,
                                                          &hKey,
                                                          NULL) ) {

                        RegSetValueEx( hKey,
                                       TEXT("SetupUpgraded"),
                                       0,
                                       REG_DWORD,
                                       (BYTE *)&dwValue,
                                       4
                                     );

                        RegCloseKey(hKey);
                    }

                }

                //
                // Migrate databases if necessary
                // if NT4 upgrade, create the database
                // this call will also empty the local policy table if necessary
                // ignore this error
                //

                if ( dwThisMachine == NtProductLanManNt &&
                     !bIsNT5 ) {
                    //
                    // NT4 DC upgrade. Should snapshot account policy into the database
                    // because SAM won't be available in dcpormo (later on)
                    //
                    rc = SceRpcAnalyzeSystem(
                                binding_h,
                                NULL,
                                NULL,
                                (wchar_t *)LogFileName,
                                AREA_SECURITY_POLICY,
                                ConfigOptions | SCE_DEBUG_LOG | SCE_NO_ANALYZE | SCE_RE_ANALYZE,
                                ebSize,
                                (UCHAR *)pebClient,
                                &dWarn
                                );
                } else {
                    //
                    // everything else, just create/migrate the database
                    //
                    rc = SceRpcAnalyzeSystem(
                                binding_h,
                                NULL,
                                NULL,
                                (wchar_t *)LogFileName,
                                0,
                                ConfigOptions | SCE_DEBUG_LOG | SCE_NO_ANALYZE,
                                ebSize,
                                (UCHAR *)pebClient,
                                &dWarn
                                );
                }

                rc = SCESTATUS_SUCCESS;

                if ( nFlag & SCESETUP_UPDATE_FILE_KEY ) {

                    Area2 = (Area & ~(AREA_DS_OBJECTS | AREA_SECURITY_POLICY | AREA_PRIVILEGES) );

                    rc = SceRpcConfigureSystem(
                                binding_h,
                                (wchar_t *)InfName,
                                NULL,
                                (wchar_t *)LogFileName,
                                ConfigOptions | SCE_DEBUG_LOG,
                                (AREAPR)Area2,
                                ebSize,
                                (UCHAR *)pebClient,
                                &dWarn
                                );
                }

                if ( !(nFlag & SCESETUP_BIND_NO_AUTH) ) {

                    if ( szUpInfFile[0] != L'\0' ) {

                        if (dwThisMachine == NtProductServer || dwThisMachine == NtProductWinNt) {
                            Area2 = AREA_ALL;
                        }
                        else {
                            Area2 = AREA_FILE_SECURITY | AREA_REGISTRY_SECURITY |
                                    AREA_PRIVILEGES | AREA_SECURITY_POLICY;

                            // DS is not running, do not configure account policies.
    //                        ConfigOptions |= SCE_NO_DOMAIN_POLICY;
                        }

                        rc = SceRpcConfigureSystem(
                                    binding_h,
                                    (wchar_t *)szUpInfFile,
                                    NULL,
                                    (wchar_t *)LogFileName,
                                    ConfigOptions | SCE_DEBUG_LOG,
                                    (AREAPR)Area2,
                                    ebSize,
                                    (UCHAR *)pebClient,
                                    &dWarn
                                    );

                        if ( !bIsNT5 && dwThisMachine == NtProductWinNt ) {
                            if (!ScepAddInteractiveToPowerUsersGroup()) {
                                LogEventAndReport(MyModuleHandle,
                                 (wchar_t *)LogFileName,
                                 STATUS_SEVERITY_WARNING,
                                 SCEEVENT_WARNING_BACKUP_SECURITY,
                                 IDS_ERR_ADD_INTERACTIVE );
                            }
                        }
                    }

                    // should add Authenticated Users to Users group on DC too
//                    if (dwThisMachine == NtProductServer || dwThisMachine == NtProductWinNt) {
                    if (!ScepAddAuthUserToLocalGroup()) {
                        LogEventAndReport(MyModuleHandle,
                         (wchar_t *)LogFileName,
                         STATUS_SEVERITY_WARNING,
                         SCEEVENT_WARNING_BACKUP_SECURITY,
                         IDS_ERR_ADD_AUTH_USER );
                    }
//                    }

                }
            } else {

                //
                // clean install, the upgraded flag should be 0
                // no need to set it; clear the log
                //
                if ( LogFileName ) {
                    DeleteFile(LogFileName);
                }

                rc = SceRpcConfigureSystem(
                            binding_h,
                            (wchar_t *)InfName,
                            NULL,
                            (wchar_t *)LogFileName,
                            ConfigOptions | SCE_DEBUG_LOG,
                            (AREAPR)Area2,
                            ebSize,
                            (UCHAR *)pebClient,
                            &dWarn
                            );
            }

            rc = ScepSceStatusToDosError(rc);

        } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

            //
            // get exception code (DWORD)
            //

            rc = RpcExceptionCode();

        } RpcEndExcept;

    } else {

        rc = RtlNtStatusToDosError(NtStatus);
    }

    if ( binding_h ) {

        //
        // Free the binding handle
        //

        RpcpUnbindRpc( binding_h );

    }

    ScepSetCallback(NULL, NULL, 0);
    dwCallbackTotal = 0;

/*
    //
    // should allow policy filter on W2K DC upgrade (dcup5)
    // policy filter is ignored for non DCs in the filter code
    // so it's not needed to add condition here
    //

    if ( (nFlag & SCESETUP_UPGRADE_SYSTEM) ||
         (nFlag & SCESETUP_UPDATE_FILE_KEY) ) {

        DWORD rCode = ScepRegDeleteValue(
                           HKEY_LOCAL_MACHINE,
                           SCE_ROOT_PATH,
                           TEXT("PolicyFilterOff")
                           );

        if ( rCode != ERROR_SUCCESS &&
             rCode != ERROR_FILE_NOT_FOUND &&
             rCode != ERROR_PATH_NOT_FOUND ) {

            // if can't delete the value, set the value to 0
            ScepRegSetIntValue( HKEY_LOCAL_MACHINE,
                               SCE_ROOT_PATH,
                               TEXT("PolicyFilterOff"),
                               0
                               );
        }
    }
*/

    return(rc);
}


DWORD
WINAPI
SceDcPromoteSecurity(
    IN DWORD dwPromoteOptions,
    IN PSCE_PROMOTE_CALLBACK_ROUTINE pScePromoteCallBack OPTIONAL
    )
{
    return SceDcPromoteSecurityEx(NULL, dwPromoteOptions, pScePromoteCallBack);

}

DWORD
WINAPI
SceDcPromoteSecurityEx(
    IN HANDLE ClientToken,
    IN DWORD dwPromoteOptions,
    IN PSCE_PROMOTE_CALLBACK_ROUTINE pScePromoteCallBack OPTIONAL
    )
/*
Routine Description:

    This routine promote security for a domain controller when a server is
    promoted to a DC.

Arguments:

    dwPromoteOptions       - options for the promotion, for example, create a new domain
                             or joining an existing domain
    pScePromoteCallBack    - the call back pointer

Return Value:

    WIN32 error code

*/
{
    BOOL bDeleteLog;

    if ( (dwPromoteOptions & SCE_PROMOTE_FLAG_REPLICA) ||
         (dwPromoteOptions & SCE_PROMOTE_FLAG_DEMOTE) ) {
        bDeleteLog = TRUE;
    } else {
        bDeleteLog = FALSE;
    }

    //
    // delete temporary filter file generated in setup if it hasn't been
    // processed by policy prop
    // because we are setting up a new product.
    // Note, this is a special case for NT4 DC upgrade
    //
    ScepClearPolicyFilterTempFiles(TRUE);

    //
    // configure security for both replica and first domain case.
    //

    DWORD rc32 = ScepDcPromoSharedInfo(ClientToken,
                                       bDeleteLog, // delete log
                                       TRUE, // not set security
                                       dwPromoteOptions,
                                       pScePromoteCallBack
                                      );

    TCHAR               Buffer[MAX_PATH+1];
    TCHAR               szNewName[MAX_PATH+51];

    Buffer[0] = L'\0';
    GetSystemWindowsDirectory(Buffer, MAX_PATH);
    Buffer[MAX_PATH] = L'\0';

    szNewName[0] = L'\0';

    //
    // make sure the log file is re-created
    //

    wcscpy(szNewName, Buffer);
    wcscat(szNewName, L"\\security\\logs\\scedcpro.log\0");

    DWORD rcSave = rc32;

    //
    // generate the updated database (for emergency repair)
    // even if there is an error configuring security
    //
    if ( dwPromoteOptions & SCE_PROMOTE_FLAG_DEMOTE ) {
        rc32 = SceSetupBackupSecurity(NULL);
    }
    else {
        rc32 = SceSetupBackupSecurity(szNewName);
    }

    //
    // re-register the notify dll (seclogon.dll) so that
    // at next logon after reboot, the group policy object
    // can be created.
    //
    // if it's a replica created, EFS policy should come from
    // the domain so no need to create group policy object
    //

    if ( !(dwPromoteOptions & SCE_PROMOTE_FLAG_REPLICA) &&
         !(dwPromoteOptions & SCE_PROMOTE_FLAG_DEMOTE) ) {

        (void) InitializeEvents(L"SceCli");

        HINSTANCE hNotifyDll = LoadLibrary(TEXT("sclgntfy.dll"));

        if ( hNotifyDll) {
            PFREGISTERSERVER pfRegisterServer = (PFREGISTERSERVER)GetProcAddress(
                                                           hNotifyDll,
                                                           "DllRegisterServer");

            if ( pfRegisterServer ) {
                //
                // do not care errors
                //
                (void) (*pfRegisterServer)();

                LogEvent(MyModuleHandle,
                         STATUS_SEVERITY_INFORMATIONAL,
                         SCEEVENT_INFO_REGISTER,
                         0,
                         TEXT("sclgntfy.dll")
                        );

            } else {

                LogEvent(MyModuleHandle,
                         STATUS_SEVERITY_WARNING,
                         SCEEVENT_WARNING_REGISTER,
                         IDS_ERROR_GET_PROCADDR,
                         GetLastError(),
                         TEXT("DllRegisterServer in sclgntfy.dll")
                        );
            }

            FreeLibrary(hNotifyDll);

        } else {

            LogEvent(MyModuleHandle,
                     STATUS_SEVERITY_WARNING,
                     SCEEVENT_WARNING_REGISTER,
                     IDS_ERROR_LOADDLL,
                     GetLastError(),
                     TEXT("sclgntfy.dll")
                    );
        }

        (void) ShutdownEvents();

    }

    if ( rcSave )
        return(rcSave);
    else
        return(rc32);
}


DWORD
WINAPI
SceDcPromoCreateGPOsInSysvol(
    IN LPTSTR DomainDnsName,
    IN LPTSTR SysvolRoot,
    IN DWORD dwPromoteOptions,
    IN PSCE_PROMOTE_CALLBACK_ROUTINE pScePromoteCallBack OPTIONAL
    )
{
    return SceDcPromoCreateGPOsInSysvolEx(NULL, DomainDnsName, SysvolRoot,
                                          dwPromoteOptions, pScePromoteCallBack
                                         );
}

DWORD
WINAPI
SceDcPromoCreateGPOsInSysvolEx(
    IN HANDLE ClientToken,
    IN LPTSTR DomainDnsName,
    IN LPTSTR SysvolRoot,
    IN DWORD dwPromoteOptions,
    IN PSCE_PROMOTE_CALLBACK_ROUTINE pScePromoteCallBack OPTIONAL
    )
{
    //
    // create default policy object for domain and domain controllers ou
    // if it's not an replica
    //
    if ( NULL == DomainDnsName || NULL == SysvolRoot ) {
        return ERROR_INVALID_PARAMETER;
    }

    DWORD  rc32=ERROR_SUCCESS;
    TCHAR  Buffer[MAX_PATH+1];
    TCHAR  szGenName[MAX_PATH+51];


    Buffer[0] = L'\0';
    GetSystemWindowsDirectory(Buffer, MAX_PATH);
    Buffer[MAX_PATH] = L'\0';


    if ( !(dwPromoteOptions & SCE_PROMOTE_FLAG_REPLICA) ) {

        rc32 = ScepDcPromoSharedInfo(ClientToken,
                                     TRUE, // delete log
                                     FALSE, // not set security
                                     dwPromoteOptions,
                                     pScePromoteCallBack
                                    );

        if ( rc32 == ERROR_SUCCESS ) {

            //
            // now create the GPOs in sysvol
            //

            (void) InitializeEvents(L"SceCli");

            TCHAR               szNewName[MAX_PATH+51];

            wcscpy(szNewName, Buffer);
            wcscat(szNewName, L"\\security\\logs\\scedcpro.log\0");

            wcscpy(szGenName, Buffer);
            wcscat(szGenName, L"\\security\\FirstDGPO.inf\0");

            intptr_t            hFile;
            struct _wfinddata_t    FileInfo;

            hFile = _wfindfirst(szGenName, &FileInfo);

            if ( hFile == -1 ) {

                rc32 = ERROR_OBJECT_NOT_FOUND;

                LogEventAndReport(MyModuleHandle,
                                  szNewName,
                                  STATUS_SEVERITY_ERROR,
                                  SCEEVENT_ERROR_CREATE_GPO,
                                  IDS_ERROR_GETGPO_FILE_PATH,
                                  rc32,
                                  szGenName
                                  );
            } else {
                _findclose(hFile);

                wcscpy(szGenName, Buffer);
                wcscat(szGenName, L"\\security\\FirstOGPO.inf\0");

                hFile = _wfindfirst(szGenName, &FileInfo);

                if ( hFile == -1 ) {
                    rc32 = ERROR_OBJECT_NOT_FOUND;

                    LogEventAndReport(MyModuleHandle,
                                      szNewName,
                                      STATUS_SEVERITY_ERROR,
                                      SCEEVENT_ERROR_CREATE_GPO,
                                      IDS_ERROR_GETGPO_FILE_PATH,
                                      rc32,
                                      szGenName
                                      );
                } else {

                    _findclose(hFile);

                    if ( FALSE == pCreateDefaultGPOsInSysvol( DomainDnsName,
                                                              SysvolRoot,
                                                            dwPromoteOptions,
                                                            szNewName ) ) {
                        rc32 = GetLastError();
                    }
                }
            }

            (void) ShutdownEvents();

        }

    }

    //
    // make sure the temp files are deleted
    //

    wcscpy(szGenName, Buffer);
    wcscat(szGenName, L"\\security\\FirstDGPO.inf\0");
    DeleteFile(szGenName);

    wcscpy(szGenName, Buffer);
    wcscat(szGenName, L"\\security\\FirstOGPO.inf\0");
    DeleteFile(szGenName);

    return rc32;
}


DWORD
ScepDcPromoSharedInfo(
    IN HANDLE ClientToken,
    IN BOOL bDeleteLog,
    IN BOOL bSetSecurity,
    IN DWORD dwPromoteOptions,
    IN PSCE_PROMOTE_CALLBACK_ROUTINE pScePromoteCallBack OPTIONAL
    )
{

    SCESTATUS           rc;
    DWORD               rc32=NO_ERROR;
    TCHAR               Buffer[MAX_PATH+1];
    TCHAR               szGenName[MAX_PATH+51];
    TCHAR               szNewName[MAX_PATH+51];

    handle_t  binding_h;
    NTSTATUS NtStatus;

    ScepRegSetIntValue(
            HKEY_LOCAL_MACHINE,
            SCE_ROOT_PATH,
            TEXT("PolicyFilterOff"),
            1
            );

    ScepRegSetIntValue(
            HKEY_LOCAL_MACHINE,
            SCE_ROOT_PATH,
            TEXT("PolicyPropOff"),
            1
            );
    //
    // a callback routine is passed in
    //

    ScepSetCallback((PVOID)pScePromoteCallBack,
                    NULL,
                    SCE_DCPROMO_CALLBACK
                    );

    //
    // should we close the database opened by single
    // object update ?
    // ScepSetupCloseSecurityDatabase();

    //
    // RPC bind to the server
    //

    NtStatus = ScepBindRpc(
                    NULL,
                    L"scerpc",
                    L"security=impersonation dynamic false",  // 0
                    &binding_h
                    );
    /*
    NtStatus = ScepBindSecureRpc(
                    NULL,
                    L"scerpc",
                    0,
                    &binding_h
                    );
    */

    if (NT_SUCCESS(NtStatus)){

        //
        // if there is notification handle, set the notify bit
        //

        DWORD ConfigOptions = SCE_UPDATE_DB | SCE_DEBUG_LOG;

        if ( pScePromoteCallBack ) {
            ConfigOptions |= SCE_CALLBACK_DELTA;
        }

        //
        // the following calls shouldn't fail because Buffer is big enough
        //

        Buffer[0] = L'\0';
        GetSystemWindowsDirectory(Buffer, MAX_PATH);
        Buffer[MAX_PATH] = L'\0';

        //
        // if it's not set security (then it's create GPOs)
        // make sure FirstOGPO and FirstDGPO are initialized properly
        //

        if ( bSetSecurity == FALSE ) {
            //
            // this code should be only called for non replica promotion
            //
            wcscpy(szNewName, Buffer);

            if ( dwPromoteOptions & SCE_PROMOTE_FLAG_UPGRADE ) {
                //
                // upgrade from NT4 DC to NT5 DC
                //
                wcscat(szNewName, L"\\inf\\dcup.inf\0");
            } else {
                wcscat(szNewName, L"\\inf\\defltdc.inf\0");
            }

            wcscpy(szGenName, Buffer);
            wcscat(szGenName, L"\\security\\FirstOGPO.inf\0");

//            DeleteFile(szGenName);
            CopyFile(szNewName, szGenName, FALSE);

            //
            // delete the sections do not belong to local policy object
            //
            WritePrivateProfileSection(
                                szSystemAccess,
                                NULL,
                                (LPCTSTR)szGenName);

            WritePrivateProfileSection(
                                szGroupMembership,
                                NULL,
                                (LPCTSTR)szGenName);

            WritePrivateProfileSection(
                                szAccountProfiles,
                                NULL,
                                (LPCTSTR)szGenName);

            WritePrivateProfileSection(
                                szRegistryKeys,
                                NULL,
                                (LPCTSTR)szGenName);

            WritePrivateProfileSection(
                                szFileSecurity,
                                NULL,
                                (LPCTSTR)szGenName);

            WritePrivateProfileSection(
                                szDSSecurity,
                                NULL,
                                (LPCTSTR)szGenName);

            WritePrivateProfileSection(
                                L"LanManServer",
                                NULL,
                                (LPCTSTR)szGenName);

            WritePrivateProfileSection(
                                szServiceGeneral,
                                NULL,
                                (LPCTSTR)szGenName);

            WritePrivateProfileSection(
                                szKerberosPolicy,
                                NULL,
                                (LPCTSTR)szGenName);
/*
            WritePrivateProfileSection(
                                szRegistryValues,
                                NULL,
                                (LPCTSTR)szGenName);
*/
            WritePrivateProfileSection(
                                szAuditSystemLog,
                                NULL,
                                (LPCTSTR)szGenName);

            WritePrivateProfileSection(
                                szAuditSecurityLog,
                                NULL,
                                (LPCTSTR)szGenName);

            WritePrivateProfileSection(
                                szAuditApplicationLog,
                                NULL,
                                (LPCTSTR)szGenName);

            wcscpy(szGenName, Buffer);
            wcscat(szGenName, L"\\security\\FirstDGPO.inf\0");

            //
            // prepare the temp domain and local policy template
            // write default kerberos policy into the temp domain template
            //

            szNewName[0] = L'\0';
            wcscpy(szNewName, Buffer);
            wcscat(szNewName, L"\\inf\\Dcfirst.inf\0");

            CopyFile(szNewName, szGenName, FALSE);
        }

        //
        // make sure the log file is re-created
        //

        wcscpy(szNewName, Buffer);
        wcscat(szNewName, L"\\security\\logs\\scedcpro.log\0");

        if ( bDeleteLog ) {
            DeleteFile(szNewName);
        }

        //
        // choose the template to use
        //
        szGenName[0] = L'\0';
        wcscpy(szGenName, Buffer);

        if ( dwPromoteOptions & SCE_PROMOTE_FLAG_UPGRADE ) {
            //
            // upgrade from NT4 DC to NT5 DC
            //
            wcscat(szGenName, L"\\inf\\dcup.inf\0");
        } else if ( dwPromoteOptions & SCE_PROMOTE_FLAG_DEMOTE ) {
            //
            // demote from DC to server
            //
            wcscat(szGenName, L"\\inf\\defltsv.inf\0");
        } else{
            wcscat(szGenName, L"\\inf\\defltdc.inf\0");
        }

        LPVOID pebClient = GetEnvironmentStrings();
        DWORD ebSize = ScepGetEnvStringSize(pebClient);

        //
        // impersonate
        //
        BOOL bImpersonated = FALSE;

        if ( ClientToken ) {
            if ( !ImpersonateLoggedOnUser(ClientToken) ) {
                LogEventAndReport(MyModuleHandle,
                                 (wchar_t *)szNewName,
                                 0,
                                 0,
                                 IDS_ERROR_PROMOTE_IMPERSONATE,
                                 GetLastError()
                                 );
            } else {
                bImpersonated = TRUE;
            }
        }

        szCallbackPrefix[0] = L'\0';

        LoadString( MyModuleHandle,
                bSetSecurity ? SCECLI_CALLBACK_PREFIX : SCECLI_CREATE_GPO_PREFIX,
                szCallbackPrefix,
                MAX_PATH
                );
        szCallbackPrefix[MAX_PATH-1] = L'\0';

        if ( szCallbackPrefix[0] == L'\0' ) {
            //
            // in case loadString fails
            //
            if ( bSetSecurity ) {
                wcscpy(szCallbackPrefix, L"Securing ");
            } else {
                wcscpy(szCallbackPrefix, L"Creating ");
            }
        }

        //
        // revert
        //
        if ( ClientToken && bImpersonated ) {
            if ( !RevertToSelf() ) {
                LogEventAndReport(MyModuleHandle,
                                 (wchar_t *)szNewName,
                                 0,
                                 0,
                                 IDS_ERROR_PROMOTE_REVERT,
                                 GetLastError()
                                 );
            }
        }

        //
        // configure security
        //
        DWORD dWarn;
        AREA_INFORMATION Area;

        RpcTryExcept {

            //
            // also make sure the builtin accounts for NT5 DC are
            // created if they are not there (which will be created in reboot after dcpromo)
            //

            LPTSTR pTemplateFile;

            if ( bSetSecurity == FALSE ) {

                Area = AREA_PRIVILEGES;

                if ( dwPromoteOptions & SCE_PROMOTE_FLAG_UPGRADE ) {
                    //
                    // upgrade from NT4 DC to NT5 DC, need copy the current policy setting
                    //
                    Area |= AREA_SECURITY_POLICY;
                }

                ConfigOptions |= (SCE_COPY_LOCAL_POLICY |
                                  SCE_NO_CONFIG |
                                  SCE_DCPROMO_WAIT |
                                  SCE_NO_DOMAIN_POLICY );

                pTemplateFile = NULL; // szGenName;

            } else {

                if ( dwPromoteOptions & SCE_PROMOTE_FLAG_DEMOTE ) {
                    //
                    // security policy, privileges, and group membership must be configured
                    // at reboot (in policy propagation) so these settings must
                    // be imported to the tattoo table first (when SCE_DC_DEMOTE is set)
                    // Plus SAM will be recreated at reboot
                    //
                    Area = AREA_SECURITY_POLICY | AREA_PRIVILEGES | AREA_GROUP_MEMBERSHIP |
                           AREA_FILE_SECURITY | AREA_REGISTRY_SECURITY | AREA_SYSTEM_SERVICE;
                    ConfigOptions |= SCE_NO_CONFIG | SCE_DCPROMO_WAIT | SCE_DC_DEMOTE;
                }
                else {
                    //
                    // remove "Power Users" explcitly
                    // since privileges are not configured anymore
                    //
                    ScepDcPromoRemoveUserRights();

                    Area = AREA_FILE_SECURITY | AREA_REGISTRY_SECURITY |
                           AREA_SYSTEM_SERVICE;
                    ConfigOptions |= (SCE_NO_DOMAIN_POLICY | SCE_SETUP_SERVICE_NOSTARTTYPE);

                    //
                    // user rights need to be configured for first DC as well as replica
                    // because there are new user rights that are not defined in group policies.
                    //
                    Area |= AREA_PRIVILEGES;
                    ConfigOptions |= (SCE_DCPROMO_WAIT | SCE_CREATE_BUILTIN_ACCOUNTS);

                }

                pTemplateFile = szGenName;
            }

            rc = SceRpcConfigureSystem(
                            binding_h,
                            (wchar_t *)pTemplateFile,
                            NULL,
                            (wchar_t *)szNewName,
                            ConfigOptions,
                            (AREAPR)Area,
                            ebSize,
                            (UCHAR *)pebClient,
                            &dWarn
                            );

            rc32 = ScepSceStatusToDosError(rc);


            if ( rc32 == NO_ERROR && (dwPromoteOptions & SCE_PROMOTE_FLAG_DEMOTE) ) {

                //
                // can't reset account policy since SAM is going away (re-created)
                //
                Area = AREA_FILE_SECURITY | AREA_REGISTRY_SECURITY | AREA_SYSTEM_SERVICE;
                ConfigOptions = SCE_DEBUG_LOG | SCE_DCPROMO_WAIT | SCE_NO_DOMAIN_POLICY | SCE_SETUP_SERVICE_NOSTARTTYPE;

                if ( pScePromoteCallBack ) {
                    ConfigOptions |= SCE_CALLBACK_DELTA;
                }

                rc = SceRpcConfigureSystem(
                                binding_h,
                                NULL,
                                NULL,
                                (wchar_t *)szNewName,
                                ConfigOptions,
                                (AREAPR)Area,
                                ebSize,
                                (UCHAR *)pebClient,
                                &dWarn
                                );

                rc32 = ScepSceStatusToDosError(rc);

                //
                // reset the previousPolicyArea so that at reboot after demotion
                // the above policy will get reset
                //

                ScepRegSetIntValue(
                                  HKEY_LOCAL_MACHINE,
                                  GPT_SCEDLL_NEW_PATH,
                                  TEXT("PreviousPolicyAreas"),
                                  AREA_SECURITY_POLICY | AREA_PRIVILEGES | AREA_GROUP_MEMBERSHIP
                                  );

            }


        } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

            //
            // get exception code (DWORD)
            //

            rc32 = RpcExceptionCode();

            LogEventAndReport(MyModuleHandle,
                             (wchar_t *)szNewName,
                             STATUS_SEVERITY_WARNING,
                             SCEEVENT_WARNING_PROMOTE_SECURITY,
                             IDS_ERROR_PROMOTE_SECURITY,
                             rc32
                             );


        } RpcEndExcept;

        //
        // Free the binding handle
        //

        RpcpUnbindRpc( binding_h );

    } else {

        rc32 = RtlNtStatusToDosError(NtStatus);
    }

    ScepSetCallback(NULL, NULL, 0);

    rc = ScepRegDeleteValue(
           HKEY_LOCAL_MACHINE,
           SCE_ROOT_PATH,
           TEXT("PolicyFilterOff")
           );

    if ( rc != ERROR_SUCCESS &&
         rc != ERROR_FILE_NOT_FOUND &&
         rc != ERROR_PATH_NOT_FOUND ) {

        // if can't delete the value, set the value to 0
        ScepRegSetIntValue( HKEY_LOCAL_MACHINE,
                           SCE_ROOT_PATH,
                           TEXT("PolicyFilterOff"),
                           0
                           );
    }

    rc = ScepRegDeleteValue(
           HKEY_LOCAL_MACHINE,
           SCE_ROOT_PATH,
           TEXT("PolicyPropOff")
           );

    if ( rc != ERROR_SUCCESS &&
         rc != ERROR_FILE_NOT_FOUND &&
         rc != ERROR_PATH_NOT_FOUND ) {

        // if can't delete the value, set the value to 0
        ScepRegSetIntValue( HKEY_LOCAL_MACHINE,
                           SCE_ROOT_PATH,
                           TEXT("PolicyPropOff"),
                           0
                           );
    }

    if ( dwPromoteOptions & SCE_PROMOTE_FLAG_DEMOTE ) {
        ScepRegSetIntValue(
                HKEY_LOCAL_MACHINE,
                SCE_ROOT_PATH,
                TEXT("DemoteInProgress"),
                1
                );
    }

    return(rc32);
}

NTSTATUS
ScepDcPromoRemoveUserRights()
{

    NTSTATUS        NtStatus;
    LSA_HANDLE      PolicyHandle=NULL;

    SID_IDENTIFIER_AUTHORITY ia=SECURITY_NT_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY ia2=SECURITY_WORLD_SID_AUTHORITY;
    PSID   AccountSid=NULL;

    //
    // open LSA policy
    //
    NtStatus = ScepOpenLsaPolicy(
                    MAXIMUM_ALLOWED, //GENERIC_ALL,
                    &PolicyHandle,
                    TRUE
                    );

    if ( NT_SUCCESS(NtStatus) ) {

        //
        // remove Power Users account totally
        //
        NtStatus = RtlAllocateAndInitializeSid (&ia,
                                                2,
                                                SECURITY_BUILTIN_DOMAIN_RID,
                                                DOMAIN_ALIAS_RID_POWER_USERS,
                                                0, 0, 0, 0, 0, 0,
                                                &AccountSid);

        if ( NT_SUCCESS(NtStatus) ) {

            NtStatus = LsaRemoveAccountRights(
                                PolicyHandle,
                                AccountSid,
                                TRUE,  // remove all rights
                                NULL,
                                0
                                );

            RtlFreeSid(AccountSid);
        }

        //
        // Users
        //
        ScepDcPromoRemoveTwoRights(PolicyHandle,
                                   &ia,
                                   2,
                                   SECURITY_BUILTIN_DOMAIN_RID,
                                   DOMAIN_ALIAS_RID_USERS
                                  );

        //
        // Guests
        //
        ScepDcPromoRemoveTwoRights(PolicyHandle,
                                   &ia,
                                   2,
                                   SECURITY_BUILTIN_DOMAIN_RID,
                                   DOMAIN_ALIAS_RID_GUESTS
                                  );
        //
        // Authenticated Users
        //
        ScepDcPromoRemoveTwoRights(PolicyHandle,
                                   &ia,
                                   1,
                                   SECURITY_AUTHENTICATED_USER_RID,
                                   0
                                  );
        //
        // Everyone
        //

        ScepDcPromoRemoveTwoRights(PolicyHandle,
                                   &ia2,
                                   1,
                                   SECURITY_WORLD_RID,
                                   0
                                  );

        LsaClose(PolicyHandle);
    }

    return NtStatus;
}

NTSTATUS
ScepDcPromoRemoveTwoRights(
    IN LSA_HANDLE PolicyHandle,
    IN SID_IDENTIFIER_AUTHORITY *pIA,
    IN UCHAR SubAuthCount,
    IN DWORD Rid1,
    IN DWORD Rid2
    )
{

    //
    // remove "logon locally" and "shutdown system" from the following accounts
    //
    LSA_UNICODE_STRING UserRightRemove[2];

    RtlInitUnicodeString(&(UserRightRemove[0]), SE_INTERACTIVE_LOGON_NAME);
    RtlInitUnicodeString(&(UserRightRemove[1]), SE_SHUTDOWN_NAME);

    PSID AccountSid=NULL;
    NTSTATUS NtStatus;

    NtStatus = RtlAllocateAndInitializeSid (pIA,
                                            SubAuthCount,
                                            Rid1,
                                            Rid2,
                                            0, 0, 0, 0, 0, 0,
                                            &AccountSid);

    if ( NT_SUCCESS(NtStatus) ) {

        NtStatus = LsaRemoveAccountRights(
                            PolicyHandle,
                            AccountSid,
                            FALSE,
                            UserRightRemove,
                            2
                            );

        RtlFreeSid(AccountSid);
    }

    return(NtStatus);
}


//
// private APIs
//

DWORD
ScepSetupOpenSecurityDatabase(
    IN BOOL bSystemOrAdmin
    )
{

    if ( hSceSetupHandle != NULL ) {
        return ERROR_SUCCESS;
    }

    //
    // get the default template name (on local system because setup only
    // runs on local system
    //

    SCESTATUS   rc;
    BOOL        bAdminLogon;
    PWSTR       DefProfile=NULL;

    //
    // don't care if error occurs to detect who is currently logged on
    // setup always work on local computer so no remoate is supported here
    //

    if ( bSystemOrAdmin ) {
        bAdminLogon = TRUE;
    } else {
        ScepIsAdminLoggedOn(&bAdminLogon);
    }

    rc = ScepGetProfileSetting(
            L"DefaultProfile",
            bAdminLogon,
            &DefProfile
            );
    if ( rc != NO_ERROR )  // return is Win32 error code
        return(rc);

    if (DefProfile == NULL ) {
        return(ERROR_FILE_NOT_FOUND);
    }

    handle_t  binding_h;
    NTSTATUS NtStatus;

    //
    // RPC bind to the server (secure is not required)
    //

    NtStatus = ScepBindRpc(
                    NULL,
                    L"scerpc",
                    0,
                    &binding_h
                    );
    /*
    NtStatus = ScepBindSecureRpc(
                    NULL,
                    L"scerpc",
                    0,
                    &binding_h
                    );
    */

    if (NT_SUCCESS(NtStatus)){

        RpcTryExcept {

            //
            // should create file if it does not exist
            //

            rc = SceRpcOpenDatabase(
                    binding_h,
                    (wchar_t *)DefProfile,
                    SCE_OPEN_OPTION_TATTOO,
                    &hSceSetupHandle
                    );

            rc = ScepSceStatusToDosError(rc);

        } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

            //
            // get exception code (DWORD)
            //

            rc = RpcExceptionCode();

        } RpcEndExcept;

        //
        // Free the binding handle
        //

        RpcpUnbindRpc( binding_h );

    } else {

        rc = RtlNtStatusToDosError( NtStatus );
    }

    ScepFree( DefProfile );

    return(rc);

}


DWORD
ScepSetupCloseSecurityDatabase()
{
    DWORD rc;

    if ( hSceSetupHandle != NULL ) {

        //
        // close the database, without terminating the jet engine
        //

        rc = ScepSceStatusToDosError(
                    SceCloseProfile((PVOID *)&hSceSetupHandle) );

        if ( rc != ERROR_SUCCESS ) {

           //
           // not valid handle, or can't close the database
           //

           return(rc);
        }
    }

    //
    // free other environments, if any
    //

    hSceSetupHandle = NULL;

    return(ERROR_SUCCESS);

}


//
// the RPC callback
//

SCEPR_STATUS
SceClientCallback(
   IN DWORD ncbTicks,
   IN DWORD ncbTotalTicks,
   IN AREAPR cbArea,
   IN wchar_t *szcbName OPTIONAL
   )
/*
Routine Description:

    The RPC client callback routine which is called from the server when
    the callback flag is set. This routine is registered in scerpc.idl.

    The callbacks are registered to SCE as arguments when calling from setup
    or from dcpromo, for progress indicating.

Arguments:

    ncbTicks    - the ticks has passed since last call back

    szcbName    - the item name to call back

Return Value:

    SCEPR_STATUS
*/
{
   //
   // the static variables holding callback pointer to client
   //

   if ( theCallBack != NULL ) {

       switch ( CallbackType ) {
       case SCE_SETUP_CALLBACK:

           //
           // callback to setup
           //

           if ( ncbTicks != (DWORD)-1 ) {

               PSCE_NOTIFICATION_CALLBACK_ROUTINE pcb;

               pcb = (PSCE_NOTIFICATION_CALLBACK_ROUTINE)theCallBack;

               DWORD cbCount;

               if ( dwCallbackTotal >= ncbTicks ) {

                   dwCallbackTotal -= ncbTicks;
                   cbCount = ncbTicks;

               } else {
                   cbCount = dwCallbackTotal;
                   dwCallbackTotal = 0;

               }

               if ( cbCount > 0 ) {

                   __try {

                       //
                       // calls the client procedure with the prarmeters.
                       //

                       if ( !((*pcb)(hCallbackWnd,
                                     SCESETUP_NOTIFICATION_TICKS,
                                     0,
                                     ncbTicks)) ) {

                           return SCESTATUS_SERVICE_NOT_SUPPORT;
                       }

                   } __except(EXCEPTION_EXECUTE_HANDLER) {

                       return(SCESTATUS_INVALID_PARAMETER);
                   }
               }
           }

           break;

       case SCE_DCPROMO_CALLBACK:

           //
           // callback to dcpromo
           //

           if ( szcbName ) {

               PSCE_PROMOTE_CALLBACK_ROUTINE pcb;

               pcb = (PSCE_PROMOTE_CALLBACK_ROUTINE)theCallBack;

               __try {

                   //
                   // callback to dcpromo process
                   //
                   PWSTR Buffer = (PWSTR)ScepAlloc(LPTR, (wcslen(szCallbackPrefix)+wcslen(szcbName)+1)*sizeof(WCHAR));
                   if ( Buffer ) {

                       if (wcsstr(szCallbackPrefix, L"%s")) {
                           //
                           // LoadString succeeded
                           //
                           swprintf(Buffer, szCallbackPrefix, szcbName);
                       }
                       else {

                           wcscpy(Buffer, szCallbackPrefix);
                           wcscat(Buffer, szcbName);
                       }

                       if ( (*pcb)(Buffer) != ERROR_SUCCESS ) {

                           ScepFree(Buffer);
                           Buffer = NULL;
                           return SCESTATUS_SERVICE_NOT_SUPPORT;
                       }

                       ScepFree(Buffer);
                       Buffer = NULL;

                   } else {
                       return SCESTATUS_NOT_ENOUGH_RESOURCE;
                   }

               } __except(EXCEPTION_EXECUTE_HANDLER) {

                   return(SCESTATUS_INVALID_PARAMETER);
               }
           }
           break;

       case SCE_AREA_CALLBACK:


           //
           // callback to SCE UI for area progress
           //

           PSCE_AREA_CALLBACK_ROUTINE pcb;

           pcb = (PSCE_AREA_CALLBACK_ROUTINE)theCallBack;

           __try {

               //
               // callback to UI process
               //

               if ( !((*pcb)(hCallbackWnd,
                             (AREA_INFORMATION)cbArea,
                             ncbTotalTicks,
                             ncbTicks)) ) {

                   return SCESTATUS_SERVICE_NOT_SUPPORT;
               }

           } __except(EXCEPTION_EXECUTE_HANDLER) {

               return(SCESTATUS_INVALID_PARAMETER);
           }

           break;
       }
   }

   return(SCESTATUS_SUCCESS);

}


SCESTATUS
ScepSetupWriteError(
    IN LPTSTR LogFileName,
    IN PSCE_ERROR_LOG_INFO  pErrlog
    )
/* ++
Routine Description:

   This routine outputs the error message in each node of the SCE_ERROR_LOG_INFO
   list to the log file

Arguments:

    LogFileName - the log file name

    pErrlog - the error list

Return value:

   None

-- */
{

    if ( !pErrlog ) {
        return(SCESTATUS_SUCCESS);
    }

    HANDLE hFile=INVALID_HANDLE_VALUE;

    if ( LogFileName ) {
        hFile = CreateFile(LogFileName,
                           GENERIC_WRITE,
                           FILE_SHARE_READ,
                           NULL,
                           OPEN_ALWAYS,
                           FILE_ATTRIBUTE_NORMAL,
                           NULL);
        if (hFile != INVALID_HANDLE_VALUE) {

            DWORD dwBytesWritten;

            SetFilePointer (hFile, 0, NULL, FILE_BEGIN);

            BYTE TmpBuf[3];
            TmpBuf[0] = 0xFF;
            TmpBuf[1] = 0xFE;
            TmpBuf[2] = 0;

            WriteFile (hFile, (LPCVOID)TmpBuf, 2,
                       &dwBytesWritten,
                       NULL);

            SetFilePointer (hFile, 0, NULL, FILE_END);
        }
    }

    PSCE_ERROR_LOG_INFO  pErr;

    for ( pErr=pErrlog; pErr != NULL; pErr = pErr->next ) {

        if ( pErr->buffer != NULL ) {

            ScepSetupWriteOneError( hFile, pErr->rc, pErr->buffer );
        }
    }

    if ( INVALID_HANDLE_VALUE != hFile ) {
        CloseHandle(hFile);
    }

    return(SCESTATUS_SUCCESS);

}


SCESTATUS
ScepSetupWriteOneError(
    IN HANDLE hFile,
    IN DWORD rc,
    IN LPTSTR buf
    )
{
    LPVOID     lpMsgBuf=NULL;

    if ( !buf ) {
        return(SCESTATUS_SUCCESS);
    }

    if ( rc != NO_ERROR ) {

        //
        // get error description of rc
        //

        FormatMessage( FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
                       NULL,
                       rc,
                       MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
                       (LPTSTR)&lpMsgBuf,
                       0,
                       NULL
                    );
    }

    if ( INVALID_HANDLE_VALUE != hFile ) {

        //
        // The log file is initialized
        //

        if ( lpMsgBuf != NULL )
            ScepWriteVariableUnicodeLog( hFile, TRUE, L"%s %s", (PWSTR)lpMsgBuf, buf );
        else
            ScepWriteSingleUnicodeLog(hFile, TRUE, buf);

    }

    if ( lpMsgBuf != NULL )
        LocalFree(lpMsgBuf);

    return(SCESTATUS_SUCCESS);
}


DWORD
SceSetuppLogComponent(
    IN DWORD ErrCode,
    IN SCESETUP_OBJECT_TYPE ObjType,
    IN SCESETUP_OPERATION_TYPE OptType,
    IN PWSTR Name,
    IN PWSTR SDText OPTIONAL,
    IN PWSTR SecondName OPTIONAL
    )
{
    //
    // check if this log should be generated
    //
    DWORD dwDebugLog=0;

    ScepRegQueryIntValue(HKEY_LOCAL_MACHINE,
                TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Secedit"),
                TEXT("SetupCompDebugLevel"),
                &dwDebugLog
                );

    if ( dwDebugLog == 0 ) {
        return(ERROR_SUCCESS);
    }

    //
    // build the component log file name %windir%\security\logs\scecomp.log
    //
    WCHAR LogName[MAX_PATH+51];

    GetSystemWindowsDirectory(LogName, MAX_PATH);
    LogName[MAX_PATH] = L'\0';

    wcscat(LogName, L"\\security\\logs\\scecomp.log\0");

    HANDLE hFile = CreateFile(LogName,
                           GENERIC_WRITE,
                           FILE_SHARE_READ,
                           NULL,
                           OPEN_ALWAYS,
                           FILE_ATTRIBUTE_NORMAL,
                           NULL);

    if ( INVALID_HANDLE_VALUE != hFile ) {

        DWORD dwBytesWritten;

        SetFilePointer (hFile, 0, NULL, FILE_BEGIN);

        BYTE TmpBuf[3];
        TmpBuf[0] = 0xFF;
        TmpBuf[1] = 0xFE;
        TmpBuf[2] = 0;

        WriteFile (hFile, (LPCVOID)TmpBuf, 2,
                   &dwBytesWritten,
                   NULL);

        SetFilePointer (hFile, 0, NULL, FILE_END);

        //
        // print a time stamp
        //

        LARGE_INTEGER CurrentTime;
        LARGE_INTEGER SysTime;
        TIME_FIELDS   TimeFields;
        NTSTATUS      NtStatus;

        NtStatus = NtQuerySystemTime(&SysTime);

        RtlSystemTimeToLocalTime (&SysTime,&CurrentTime);

        if ( NT_SUCCESS(NtStatus) &&
             (CurrentTime.LowPart != 0 || CurrentTime.HighPart != 0) ) {

            memset(&TimeFields, 0, sizeof(TIME_FIELDS));

            RtlTimeToTimeFields (
                        &CurrentTime,
                        &TimeFields
                        );
            if ( TimeFields.Month > 0 && TimeFields.Month <= 12 &&
                 TimeFields.Day > 0 && TimeFields.Day <= 31 &&
                 TimeFields.Year > 1600 ) {

                ScepWriteVariableUnicodeLog(hFile, FALSE,
                                            L"%02d/%02d/%04d %02d:%02d:%02d",
                             TimeFields.Month, TimeFields.Day, TimeFields.Year,
                             TimeFields.Hour, TimeFields.Minute, TimeFields.Second);
            } else {
                ScepWriteVariableUnicodeLog(hFile, FALSE, L"%08x08x",
                                            CurrentTime.HighPart, CurrentTime.LowPart);
            }
        } else {
            ScepWriteSingleUnicodeLog(hFile, FALSE, L"Unknown time");
        }

        //
        // print operation status code
        //
        if ( ErrCode ) {
            ScepWriteVariableUnicodeLog(hFile, FALSE, L"\tError=%d", ErrCode);
        } else {
            ScepWriteSingleUnicodeLog(hFile, FALSE, L"\tSucceed");
        }

        //
        // printf operation type
        //

        switch (OptType) {
        case SCESETUP_UPDATE:
            ScepWriteSingleUnicodeLog(hFile, FALSE, L"\tUpdate");
            break;
        case SCESETUP_MOVE:
            ScepWriteSingleUnicodeLog(hFile, FALSE, L"\tMove");
            break;
        default:
            ScepWriteSingleUnicodeLog(hFile, FALSE, L"\tUnknown");
            break;
        }

        //
        // print object type
        //

        switch (ObjType) {
        case SCESETUP_FILE:
            ScepWriteSingleUnicodeLog(hFile, TRUE, L"\tFile");
            break;
        case SCESETUP_KEY:
            ScepWriteSingleUnicodeLog(hFile, TRUE, L"\tKey");
            break;
        case SCESETUP_SERVICE:
            ScepWriteSingleUnicodeLog(hFile, TRUE, L"\tService");
            break;
        default:
            ScepWriteSingleUnicodeLog(hFile, TRUE, L"\tUnknown");
            break;
        }

        __try {

            //
            // print the name(s)
            //

            ScepWriteSingleUnicodeLog(hFile, FALSE, L"\t");

            if ( SecondName && Name ) {
                // Name\tSecondName\n
                ScepWriteSingleUnicodeLog(hFile, FALSE, Name);
                ScepWriteSingleUnicodeLog(hFile, FALSE, L"\t");
                ScepWriteSingleUnicodeLog(hFile, TRUE, SecondName);
            } else if ( Name ) {

                ScepWriteSingleUnicodeLog(hFile, TRUE, Name);
            }

            //
            // print the SDDL string
            //

            if ( SDText ) {
                ScepWriteSingleUnicodeLog(hFile, FALSE, L"\tSecurity=");
                ScepWriteSingleUnicodeLog(hFile, TRUE, SDText);
            }

        } __except(EXCEPTION_EXECUTE_HANDLER) {

            return(ERROR_INVALID_PARAMETER);
        }

        CloseHandle(hFile);

    } else {
        return(GetLastError());
    }

    return(ERROR_SUCCESS);
}


DWORD
WINAPI
SceSetupBackupSecurity(
    IN LPTSTR LogFileName OPTIONAL   // default to %windir%\security\logs\backup.log
    )
{

    TCHAR Buffer[MAX_PATH+1];
    DWORD rc32;
    TCHAR szGenName[MAX_PATH*2], szNewName[MAX_PATH+51];

    Buffer[0] = L'\0';
    GetSystemWindowsDirectory(Buffer, MAX_PATH);
    Buffer[MAX_PATH] = L'\0';

    szNewName[0] = L'\0';
    if ( LogFileName == NULL ) {
        wcscpy(szNewName, Buffer);
        wcscat(szNewName, L"\\security\\logs\\backup.log\0");
    }

    (void) InitializeEvents(L"SceCli");

    //
    // if I am in setup, query the security policy/user rights for any
    // policy changes within setup (such as NT4 PDC upgrade where the policy
    // filter will fail to save the change)
    //

    DWORD dwInSetup=0;
    DWORD dwUpgraded=0;

    ScepRegQueryIntValue(HKEY_LOCAL_MACHINE,
                TEXT("System\\Setup"),
                TEXT("SystemSetupInProgress"),
                &dwInSetup
                );

    if ( dwInSetup ) {

        //
        // delete the temp local group policy template
        //

        wcscpy(szGenName, Buffer);
        wcscat(szGenName, L"\\system32\\grouppolicy\\machine\\microsoft\\windows nt\\secedit\\gpttmpl.inf\0");

        DeleteFile(szGenName);

        ScepRegQueryIntValue(
                HKEY_LOCAL_MACHINE,
                SCE_ROOT_PATH,
                TEXT("SetupUpgraded"),
                (DWORD *)&dwUpgraded
                );
/*
        if ( dwUpgraded ) {

            //
            // in GUI setup, snapshot the system security/user rights
            // query the upgrade flag, only query the system (again) when
            // it's upgraded, because for the case of NT4 PDC upgrade to NT5
            // any back office apps installed in GUI setup (user rights) won't
            // get saved to the GPO storage correctly (ProductType is wrong)
            //

            rc32 = ScepSystemSecurityInSetup(
                        szNewName,  // not used
                        LogFileName ? LogFileName : szNewName,
                        0,
                        SCESETUP_UPGRADE_SYSTEM | SCESETUP_BIND_NO_AUTH,
                        NULL,
                        NULL
                        );

            if ( NO_ERROR != rc32 ) {
                LogEventAndReport(MyModuleHandle,
                                 LogFileName ? LogFileName : szNewName,
                                 0,
                                 0,
                                 IDS_ERROR_SNAPSHOT_SECURITY,
                                 rc32
                                );
            } else {
                LogEventAndReport(MyModuleHandle,
                                 LogFileName ? LogFileName : szNewName,
                                 0,
                                 0,
                                 IDS_SNAPSHOT_SECURITY_POLICY
                                 );
            }

        }

        //
        // reset the value
        //

        ScepRegSetIntValue(
                HKEY_LOCAL_MACHINE,
                SCE_ROOT_PATH,
                TEXT("SetupUpgraded"),
                0
                );
*/
    }

    //
    // open the database
    //
    rc32 = ScepSetupOpenSecurityDatabase(TRUE);

    BOOL    bUpgradeNt5 = (BOOL)(dwUpgraded && IsNT5());

    if ( NO_ERROR == rc32 ) {

        if ( !bUpgradeNt5 ) {

            wcscpy(szGenName, Buffer);
            wcscat(szGenName, L"\\security\\setup.inf\0");

            //
            // always generate the file (except NT5 upgrades)
            // generate the updated database (for emergency repair)
            // %windir%\security\templates\setup security.inf
            //

            PSCE_ERROR_LOG_INFO pErrlog=NULL;

            rc32 = ScepSceStatusToDosError(
                                          SceCopyBaseProfile(
                                                            (PVOID)hSceSetupHandle,
                                                            SCE_ENGINE_SMP,
                                                            (wchar_t *)szGenName,
                                                            dwInSetup ?
                                                            AREA_ALL :
                                                            (AREA_REGISTRY_SECURITY |
                                                             AREA_FILE_SECURITY |
                                                             AREA_SYSTEM_SERVICE),
                                                            &pErrlog
                                                            ));

            ScepSetupWriteError(LogFileName ? LogFileName : szNewName, pErrlog);
            ScepFreeErrorLog(pErrlog);

            if ( rc32 != NO_ERROR ) {

                LogEventAndReport(MyModuleHandle,
                                  LogFileName ? LogFileName : szNewName,
                                  STATUS_SEVERITY_ERROR,
                                  SCEEVENT_ERROR_BACKUP_SECURITY,
                                  IDS_ERROR_GENERATE,
                                  rc32,
                                  szGenName,
                                  LogFileName ? LogFileName : szNewName
                                 );
            }
        }

        //
        // check if we should trigger a policy propagation manually
        //
        DWORD dwResetOption=0;

        if ( dwInSetup && dwUpgraded )
            dwResetOption |= SCE_RESET_POLICY_ENFORCE_ATREBOOT;

        //
        // remove local policies from the database
        // for NT4 DC upgrade case, keep the local policy setting until dcpromo
        //

        if ( dwInSetup && dwUpgraded && !IsNT5() &&
             NtProductLanManNt == WhichNTProduct() )
            dwResetOption |= SCE_RESET_POLICY_KEEP_LOCAL;

        //
        // if it's after dcpromo, need to empty tattoo table
        // if LogFileName is NULL and it's not in setup, it's in DC demotion in which case
        // we want to leave the tattoo table (w/ reset settings)
        //
        if ( !dwInSetup && (LogFileName != NULL) )
            dwResetOption |= SCE_RESET_POLICY_TATTOO;

        DWORD rCode = SceRpcSetupResetLocalPolicy(
                                    (PVOID)hSceSetupHandle,
                                    AREA_ALL,
                                    NULL,
                                    dwResetOption
                                    );

        LogEventAndReport(MyModuleHandle,
                         LogFileName ? LogFileName : szNewName,
                         0,
                         0,
                         IDS_ERROR_REMOVE_DEFAULT_POLICY,
                         rCode,
                         dwResetOption
                        );
        //
        // close the context
        //

        ScepSetupCloseSecurityDatabase();


        if ( NO_ERROR == rc32 &&
             !bUpgradeNt5 ) {

            //
            // template is always generated, copy it to %windir%\security\templates and
            // to %windir%\repair
            //
            szNewName[0] = L'0';

            //
            // Load string for the description
            //
            LoadString( MyModuleHandle,
                    dwInSetup ? IDS_BACKUP_OUTBOX_DESCRIPTION : IDS_BACKUP_DC_DESCRIPTION,
                    szNewName,
                    MAX_PATH
                    );

            //
            // re-write descriptoin for there backup files.
            //

            WritePrivateProfileSection(
                                L"Profile Description",
                                NULL,
                                (LPCTSTR)szGenName);

            if ( szNewName[0] ) {

                WritePrivateProfileString(
                            L"Profile Description",
                            L"Description",
                            szNewName,
                            (LPCTSTR)szGenName);
            }

            //
            // copy the file to its destination
            //
            szNewName[0] = L'0';

            wcscpy(szNewName, Buffer);
            if ( dwInSetup || LogFileName == NULL ) {

                wcscat(szNewName, L"\\security\\templates\\setup security.inf\0");

                //
                // before setup security.inf gets copied over by setup.inf,
                // need to insert root SDDL into setup.inf that was saved in
                // setup security.inf when configuring root security
                //

                DWORD   dwSizeConsumed = 0;
                DWORD   dwSizeSupplied = MAX_PATH + 1;
                PWSTR   pszRootSDDLString = NULL;
                PWSTR   pszReallocHandle = NULL;

                pszRootSDDLString = (PWSTR) LocalAlloc(LMEM_ZEROINIT,
                                                       dwSizeSupplied * sizeof(WCHAR));

                if ( pszRootSDDLString ) {

                    dwSizeConsumed = GetPrivateProfileString(szFileSecurity,
                                                             L"0",
                                                             L"0",
                                                             pszRootSDDLString,
                                                             dwSizeSupplied,
                                                             szNewName);

                    while ( pszRootSDDLString &&
                            (dwSizeConsumed == (dwSizeSupplied - 1)) ) {

                        //
                        // potentially exhausted supplied buffer
                        //

                        dwSizeSupplied += MAX_PATH;

                        //
                        // if LocalReAlloc is successful, original buffer will be freed
                        // else we have to free it
                        //

                        pszReallocHandle = (PWSTR) LocalReAlloc(pszRootSDDLString,
                                                                dwSizeSupplied * sizeof(WCHAR),
                                                                LMEM_ZEROINIT);

                        if ( pszReallocHandle == NULL ) {

                            LocalFree(pszRootSDDLString);

                            pszRootSDDLString = NULL;

                        } else {

                            pszRootSDDLString = pszReallocHandle;

                            dwSizeConsumed = GetPrivateProfileString(szFileSecurity,
                                                                     L"0",
                                                                     L"0",
                                                                     pszRootSDDLString,
                                                                     dwSizeSupplied,
                                                                     szNewName);
                        }
                    }

                    if ( pszRootSDDLString ) {

                        if ( pszRootSDDLString[0] == L'\0' ) {

                            LogEvent(MyModuleHandle,
                                     STATUS_SEVERITY_WARNING,
                                     SCEEVENT_WARNING_BACKUP_SECURITY_ROOT_SDDL,
                                     0
                                    );
                        }

                        else  {

                            //
                            // make sure we have leading and trailing quotes so that we have
                            // 0="D:\", 0, "SDDL" instead of 0=D:\", 0, "SDDL
                            //

                            if (pszRootSDDLString[0] != L'\"') {

                                PWSTR   pszRootSDDLStringToFree = pszRootSDDLString;
                                DWORD   dwNewSize = 3 + wcslen(pszRootSDDLStringToFree);

                                pszRootSDDLString = (PWSTR) LocalAlloc(LMEM_ZEROINIT,
                                                                       sizeof(WCHAR) * dwNewSize);

                                //
                                // log an event if we're out of memory but still log to
                                // template since it's okay to log some value atleast
                                //

                                if (pszRootSDDLString) {

                                    wcscpy(pszRootSDDLString+1, pszRootSDDLStringToFree);

                                    LocalFree(pszRootSDDLStringToFree);

                                    pszRootSDDLString[0] = L'\"';
                                    pszRootSDDLString[dwNewSize-2] = L'\"';
                                }

                                else {

                                    pszRootSDDLString = pszRootSDDLStringToFree;

                                    LogEvent(MyModuleHandle,
                                             STATUS_SEVERITY_WARNING,
                                             SCEEVENT_WARNING_BACKUP_SECURITY_ROOT_SDDL,
                                             0
                                            );
                                }

                            }

                            if (!WritePrivateProfileString(szFileSecurity, L"0", pszRootSDDLString, szGenName) ) {

                                LogEvent(MyModuleHandle,
                                         STATUS_SEVERITY_WARNING,
                                         SCEEVENT_WARNING_BACKUP_SECURITY_ROOT_SDDL,
                                         0
                                        );
                            }

                        }


                        LocalFree(pszRootSDDLString);

                    } else {

                        LogEvent(MyModuleHandle,
                                 STATUS_SEVERITY_WARNING,
                                 SCEEVENT_WARNING_BACKUP_SECURITY_ROOT_SDDL,
                                 0
                                );

                    }

                } else {

                    LogEvent(MyModuleHandle,
                             STATUS_SEVERITY_WARNING,
                             SCEEVENT_WARNING_BACKUP_SECURITY_ROOT_SDDL,
                             0
                            );
                }

            } else {
                wcscat(szNewName, L"\\security\\templates\\DC security.inf\0");
            }

            if ( CopyFile( szGenName, szNewName, FALSE ) ) {

                LogEvent(MyModuleHandle,
                         STATUS_SEVERITY_INFORMATIONAL,
                         SCEEVENT_INFO_BACKUP_SECURITY,
                         0,
                         szNewName
                        );

                wcscpy(szNewName, Buffer);
                if ( dwInSetup || LogFileName == NULL ) {
                    wcscat(szNewName, L"\\repair\\secsetup.inf\0");
                } else {
                    wcscat(szNewName, L"\\repair\\secDC.inf\0");
                }

                CopyFile( szGenName, szNewName, FALSE );

            } else {

                rc32 = GetLastError();

                wcscpy(szNewName, Buffer);
                if ( dwInSetup || LogFileName == NULL ) {
                    wcscat(szNewName, L"\\repair\\secsetup.inf\0");
                } else {
                    wcscat(szNewName, L"\\repair\\secDC.inf\0");
                }

                if ( CopyFile( szGenName, szNewName, FALSE ) ) {

                    LogEvent(MyModuleHandle,
                             STATUS_SEVERITY_WARNING,
                             SCEEVENT_WARNING_BACKUP_SECURITY,
                             0,
                             szNewName
                            );
                    rc32 = ERROR_SUCCESS;

                } else {

                    rc32 = GetLastError();

                    LogEvent(MyModuleHandle,
                             STATUS_SEVERITY_ERROR,
                             SCEEVENT_ERROR_BACKUP_SECURITY,
                             IDS_ERROR_BACKUP,
                             rc32
                            );
                }

            }

            DeleteFile(szGenName);

        }

    } else {

        LogEventAndReport(MyModuleHandle,
                         LogFileName ? LogFileName : szNewName,
                         STATUS_SEVERITY_ERROR,
                         SCEEVENT_ERROR_BACKUP_SECURITY,
                         IDS_ERROR_OPEN_DATABASE,
                         rc32
                        );
    }

    if ( dwInSetup ) {

        dwThisMachine = WhichNTProduct();
        if (dwThisMachine == NtProductServer || dwThisMachine == NtProductWinNt) {
            //
            // reconfigure file
            //
            TCHAR szLogName[MAX_PATH+51], szTempName[MAX_PATH+51];

            wcscpy(szLogName, Buffer);
            wcscat(szLogName, L"\\security\\logs\\scesetup.log\0");
            wcscpy(szTempName, Buffer);
            wcscat(szTempName, L"\\inf\\syscomp.inf\0");

            rc32 = ScepSystemSecurityInSetup(
                        szTempName,
                        szLogName,
                        0,
                        SCESETUP_RECONFIG_SECURITY | SCESETUP_BIND_NO_AUTH,
                        NULL,
                        NULL
                        );

            if ( NO_ERROR != rc32 ) {
                LogEventAndReport(MyModuleHandle,
                              szLogName,
                              0,
                              0,
                              IDS_ERR_RECONFIG_FILES,
                              rc32
                              );
            }

            //
            // remove local policies from the database
            //
            rc32 = ScepSetupOpenSecurityDatabase(TRUE);

            if ( NO_ERROR == rc32 ) {

                (void)SceRpcSetupResetLocalPolicy(
                                            (PVOID)hSceSetupHandle,
                                            AREA_FILE_SECURITY,
                                            NULL,
                                            0
                                            );

                ScepSetupCloseSecurityDatabase();
            }

        }
    }

    (void) ShutdownEvents();

    return(rc32);

}



DWORD
WINAPI
SceSetupConfigureServices(
    IN UINT SetupProductType
    )
{

    TCHAR Buffer[MAX_PATH+1];
    DWORD rc32;
    TCHAR szNewName[MAX_PATH+51];

    Buffer[0] = L'\0';
    GetSystemWindowsDirectory(Buffer, MAX_PATH);
    Buffer[MAX_PATH] = L'\0';

    szNewName[0] = L'\0';
    wcscpy(szNewName, Buffer);
    wcscat(szNewName, L"\\security\\logs\\backup.log\0");

    //
    // if I am in setup, query the security policy/user rights for any
    // policy changes within setup (such as NT4 PDC upgrade where the policy
    // filter will fail to save the change)
    //

    DWORD dwInSetup=0;
    DWORD dwUpgraded=0;

    ScepRegQueryIntValue(HKEY_LOCAL_MACHINE,
                TEXT("System\\Setup"),
                TEXT("SystemSetupInProgress"),
                &dwInSetup
                );

    if ( dwInSetup ) {

        //
        // in GUI setup, snapshot the system security/user rights
        // query the upgrade flag, only query the system (again) when
        // it's upgraded, because for the case of NT4 PDC upgrade to NT5
        // any back office apps installed in GUI setup (user rights) won't
        // get saved to the GPO storage correctly (ProductType is wrong)
        //

        ScepRegQueryIntValue(
                HKEY_LOCAL_MACHINE,
                SCE_ROOT_PATH,
                TEXT("SetupUpgraded"),
                (DWORD *)&dwUpgraded
                );

        if ( !dwUpgraded ) {

            //
            // configure service area
            //
            rc32 = ScepSystemSecurityInSetup(
                            (SetupProductType == PRODUCT_WORKSTATION) ? L"defltwk.inf" : L"defltsv.inf",
                            szNewName,
                            AREA_SYSTEM_SERVICE,
                            SCESETUP_BACKUP_SECURITY | SCESETUP_BIND_NO_AUTH,
                            NULL,
                            NULL
                            );
        }

    }

    return(rc32);

}

BOOL
pCreateDefaultGPOsInSysvol(
    IN LPTSTR DomainDnsName,
    IN LPTSTR szSysvolPath,
    IN DWORD Options,
    IN LPTSTR LogFileName
    )
/*++

Routine Description:

    Creates the default domain-wide account policy object and the default
    policy object for local policies in sysvol.

    The GUID to use is queried from registry.

Arguments:

    DomainDnsName - the new domain's DNS name, e.g., JINDOM4.ntdev.microsoft.com

    Options - the promotion options

    LogFileName - the log file for debug info

Return:

    WIN32 error

--*/
{
/*
    //
    // get sysvol share location
    //
    TCHAR szSysvolPath[MAX_PATH+1];

    szSysvolPath[0] = L'\0';
    GetEnvironmentVariable( L"SYSVOL",
                            szSysvolPath,
                            MAX_PATH);
*/
    //
    // create \\?\%sysvol%\sysvol\<DnsName>\Policies directory
    // the \\?\ is for the case of longer than MAX_PATH chars
    //

    DWORD Len = 4 + wcslen(szSysvolPath) + wcslen(TEXT("\\sysvol\\Policies\\")) +
                wcslen(DomainDnsName);

    PWSTR pszPoliciesPath = (PWSTR)ScepAlloc(LPTR, (Len+wcslen(TEXT("\\{}\\MACHINE"))+
                                                    STR_GUID_LEN+1)*sizeof(WCHAR));

    if ( !pszPoliciesPath ) {

        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }

    swprintf(pszPoliciesPath, L"\\\\?\\%s\\sysvol\\%s\\Policies\0", szSysvolPath, DomainDnsName);

    DWORD Win32rc = ScepSceStatusToDosError(
                        ScepCreateDirectory(
                                pszPoliciesPath,
                                TRUE,
                                NULL
                                ));

    if ( ERROR_SUCCESS == Win32rc ) {

        //
        // create sub directory for the first GPO GUID1 and machine, user, GPT.ini
        //

        if ( pCreateSysvolContainerForGPO(STR_DEFAULT_DOMAIN_GPO_GUID,
                                       pszPoliciesPath,
                                       Len) ) {

            //
            // when it's returned success from the previous
            // pszPoliciesPath is already changed to the machine's root
            // with the guid info.
            //

            if ( pCreateOneGroupPolicyObject(
                                pszPoliciesPath,
                                TRUE,             // domain level
                                LogFileName) ) {

                //
                // create sub directory for the second GPO
                //

                if ( pCreateSysvolContainerForGPO(STR_DEFAULT_DOMAIN_CONTROLLER_GPO_GUID,
                                                   pszPoliciesPath,
                                                   Len) ) {

                    //
                    // when it's returned success from the previous
                    // pszPoliciesPath is already changed to the machine's root
                    // with the guid info.
                    //

                    if ( pCreateOneGroupPolicyObject(
                                        pszPoliciesPath,
                                        FALSE,            // not domain level
                                        LogFileName) ) {

                        //
                        // log a entry to the log
                        //
                        LogEventAndReport(MyModuleHandle,
                                         LogFileName,
                                         0,
                                         0,
                                         IDS_SUCCESS_DEFAULT_GPO,
                                         L"in sysvol"
                                         );

                    } else {

                        Win32rc = GetLastError();
                    }

                } else {

                    Win32rc = GetLastError();
                    LogEventAndReport(MyModuleHandle,
                                      LogFileName,
                                      STATUS_SEVERITY_ERROR,
                                      SCEEVENT_ERROR_CREATE_GPO,
                                      IDS_ERROR_CREATE_DIRECTORY,
                                      Win32rc,
                                      STR_DEFAULT_DOMAIN_CONTROLLER_GPO_GUID
                                      );
                }

            } else {

                Win32rc = GetLastError();
            }

        } else {

            Win32rc = GetLastError();
            LogEventAndReport(MyModuleHandle,
                              LogFileName,
                              STATUS_SEVERITY_ERROR,
                              SCEEVENT_ERROR_CREATE_GPO,
                              IDS_ERROR_CREATE_DIRECTORY,
                              Win32rc,
                              STR_DEFAULT_DOMAIN_GPO_GUID
                              );
        }

    } else {

        LogEventAndReport(MyModuleHandle,
                          LogFileName,
                          STATUS_SEVERITY_ERROR,
                          SCEEVENT_ERROR_CREATE_GPO,
                          IDS_ERROR_CREATE_DIRECTORY,
                          Win32rc,
                          pszPoliciesPath
                          );
    }

    ScepFree(pszPoliciesPath);

    SetLastError( Win32rc );

    //
    // if this function fails, it will fail DCPROMO and the sysvol directory
    // should be cleaned up by dcpromo/ntfrs
    //

    return ( ERROR_SUCCESS == Win32rc );
}

BOOL
pCreateSysvolContainerForGPO(
    IN LPCTSTR strGuid,
    IN LPTSTR szPath,
    IN DWORD dwStart
    )
{
    swprintf(szPath+dwStart, L"\\{%s}\\USER", strGuid);

    DWORD Win32rc = ScepSceStatusToDosError(
                        ScepCreateDirectory(
                                szPath,
                                TRUE,
                                NULL
                                ));

    if ( ERROR_SUCCESS == Win32rc ) {

        //
        // the directory for the GUID is created
        // now create the GPT.INI
        //

        swprintf(szPath+dwStart, L"\\{%s}\\GPT.INI", strGuid);

        WritePrivateProfileString (TEXT("General"), TEXT("Version"), TEXT("1"),
                                   szPath);  // does it work with prefix "\\?\" ?

        //
        // create the machine directory
        // since all the parent directories are already created by the call
        // to create USER directory, there is no need to loop again
        // call CreateDirectory directly
        //

        swprintf(szPath+dwStart, L"\\{%s}\\MACHINE", strGuid);

        SECURITY_ATTRIBUTES sa;
        sa.nLength = sizeof(SECURITY_ATTRIBUTES);
        sa.lpSecurityDescriptor = NULL;
        sa.bInheritHandle = FALSE;

        if ( CreateDirectory(
                szPath,
                &sa
                ) == FALSE ) {
            if ( GetLastError() != ERROR_ALREADY_EXISTS ) {
                Win32rc = GetLastError();
            }
        }

    }

    SetLastError(Win32rc);

    return (ERROR_SUCCESS == Win32rc);
}


BOOL
pCreateOneGroupPolicyObject(
    IN PWSTR pszGPOSysPath,
    IN BOOL bDomainLevel,
    IN PWSTR LogFileName
    )
/*++

Routine Description:

    Creates a group policy object in sysvol.

Arguments:

    pszGPOSysPath- the GPO's sysvol path (up to root of machine)

    bDomainLevel - create the object for domain level if TRUE, otherwise,
                   create the GPO for "domain controllers" OU

    LogFileName  - the dcpromo log file to track info

Return:

    TRUE - success
    FALSE - fail, use GetLastError()

--*/
{

    //
    // create the default domain policy object
    //

    LPTSTR SceTemplateName = (LPTSTR) LocalAlloc(LPTR,(lstrlen(pszGPOSysPath)+
                                                 lstrlen(GPTSCE_TEMPLATE)+2)*sizeof(TCHAR));

    DWORD Win32rc;
    if (SceTemplateName) {

        //
        // build the template path first
        //
        lstrcpy(SceTemplateName,pszGPOSysPath);
        lstrcat(SceTemplateName,L"\\");
        lstrcat(SceTemplateName, GPTSCE_TEMPLATE);

        //
        // Create the template directory if there isn't one already
        //

        Win32rc = ScepSceStatusToDosError(
                    ScepCreateDirectory(
                            SceTemplateName,
                            FALSE,
                            NULL
                            ));

        if ( ERROR_SUCCESS == Win32rc ) {

            TCHAR pszGPOTempName[MAX_PATH+51];

            pszGPOTempName[0] = L'\0';
            GetSystemWindowsDirectory(pszGPOTempName, MAX_PATH);
            pszGPOTempName[MAX_PATH] = L'\0';

            if ( bDomainLevel ) {

                //
                // create the default domain GPO
                // copy template from %windir%\security\FirstDGPO.inf
                //

                wcscat(pszGPOTempName, L"\\security\\FirstDGPO.inf\0");


            } else {

                //
                // create the default GPO for "domain controllers" OU
                // copy template from %windir%\security\FirstOGPO.inf
                //

                wcscat(pszGPOTempName, L"\\security\\FirstOGPO.inf\0");


            }

            DWORD rc=ERROR_SUCCESS;
            HINF hInf=NULL;
            AREA_INFORMATION Area = AREA_SECURITY_POLICY | AREA_PRIVILEGES;
            PSCE_PROFILE_INFO pSceInfo=NULL;

            rc = SceInfpOpenProfile(
                        pszGPOTempName,
                        &hInf
                        );

            if ( SCESTATUS_SUCCESS == rc ) {

                //
                // load informatin from the template
                //
                rc = SceInfpGetSecurityProfileInfo(
                            hInf,
                            Area,
                            &pSceInfo,
                            NULL
                            );

                if ( SCESTATUS_SUCCESS != rc ) {

                    LogEventAndReport(MyModuleHandle,
                                  LogFileName,
                                  STATUS_SEVERITY_ERROR,
                                  SCEEVENT_ERROR_CREATE_GPO,
                                  IDS_ERROR_GETGPO_FILE_PATH,
                                  rc,
                                  pszGPOTempName
                                    );
                }

                SceInfpCloseProfile(hInf);

            } else {

                LogEventAndReport(MyModuleHandle,
                              LogFileName,
                              STATUS_SEVERITY_ERROR,
                              SCEEVENT_ERROR_CREATE_GPO,
                              IDS_ERROR_GETGPO_FILE_PATH,
                              rc,
                              pszGPOTempName
                              );
            }

            if ( ERROR_SUCCESS == rc && pSceInfo ) {

                //
                // Write to GPO instead of copy, this way the GPO will be unicode.
                //
//???           pSceInfo->Type = SCE_ENGINE_SMP;

                rc = SceWriteSecurityProfileInfo(SceTemplateName,
                                      Area,
                                      (PSCE_PROFILE_INFO)pSceInfo,
                                      NULL
                                      );

                if ( SCESTATUS_SUCCESS != rc ) {

                    LogEventAndReport(MyModuleHandle,
                                  LogFileName,
                                  STATUS_SEVERITY_ERROR,
                                  SCEEVENT_ERROR_CREATE_GPO,
                                  IDS_ERROR_GETGPO_FILE_PATH,
                                  rc,
                                  pszGPOTempName
                                  );
                }


            }

            if ( pSceInfo != NULL ) {
                SceFreeProfileMemory(pSceInfo);
            }

#if 0
            if ( !CopyFile( pszGPOTempName,
                             SceTemplateName,
                             FALSE ) ) {

                Win32rc = GetLastError();

                LogEventAndReport(MyModuleHandle,
                                  LogFileName,
                                  STATUS_SEVERITY_ERROR,
                                  SCEEVENT_ERROR_CREATE_GPO,
                                  IDS_ERROR_COPY_TEMPLATE,
                                  Win32rc,
                                  SceTemplateName
                                  );
            }
#endif

            DeleteFile(pszGPOTempName);

        } else {

            LogEventAndReport(MyModuleHandle,
                              LogFileName,
                              STATUS_SEVERITY_ERROR,
                              SCEEVENT_ERROR_CREATE_GPO,
                              IDS_ERROR_CREATE_DIRECTORY,
                              Win32rc,
                              SceTemplateName
                              );
        }

        LocalFree(SceTemplateName);

    } else {

        Win32rc = ERROR_NOT_ENOUGH_MEMORY;

        LogEventAndReport(
                 MyModuleHandle,
                 LogFileName,
                 STATUS_SEVERITY_ERROR,
                 SCEEVENT_ERROR_CREATE_GPO,
                 IDS_ERROR_NO_MEMORY
                 );
    }

    SetLastError(Win32rc);

    return ( ERROR_SUCCESS == Win32rc);
}

//NT_PRODUCT_TYPE
DWORD
WhichNTProduct()
{
    HKEY hKey;
    DWORD dwBufLen=32;
    TCHAR szProductType[32];
    LONG lRet;

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                     TEXT("SYSTEM\\CurrentControlSet\\Control\\ProductOptions"),
                     0,
                     KEY_QUERY_VALUE,
                     &hKey) != ERROR_SUCCESS) {
        // return Unknown
        return PRODUCT_UNKNOWN;
    }

    lRet = RegQueryValueEx(hKey,
                       TEXT("ProductType"),
                       NULL,
                       NULL,
                       (LPBYTE)szProductType,
                       &dwBufLen);

    RegCloseKey(hKey);

    if(lRet != ERROR_SUCCESS) {
        // return Unknown
        return PRODUCT_UNKNOWN;
    }

    // check product options, in order of likelihood
    if (lstrcmpi(TEXT("WINNT"), szProductType) == 0) {
        return NtProductWinNt;
    }

    if (lstrcmpi(TEXT("SERVERNT"), szProductType) == 0) {
        return NtProductServer;
    }

    if (lstrcmpi(TEXT("LANMANNT"), szProductType) == 0) {
        return NtProductLanManNt;
    }

    // return Unknown
    return PRODUCT_UNKNOWN;
}

BOOL
ScepAddAuthUserToLocalGroup()
{
    //
    // Attempt to add Authenticated Users and Interactive back into Users group.
    //

    DWORD    rc1;
    SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;
    PSID AuthenticatedUsers = NULL;
    PSID Interactive = NULL;
    WCHAR Name[36];
    BOOL b;
    LOCALGROUP_MEMBERS_INFO_0 lgrmi0[2];
    HMODULE hMod = GetModuleHandle(L"scecli.dll");

    LoadString(hMod, IDS_NAME_USERS, Name, 36);
    b = AllocateAndInitializeSid (
                &NtAuthority,
                1,
                SECURITY_AUTHENTICATED_USER_RID,
                0, 0, 0, 0, 0, 0, 0,
                &AuthenticatedUsers
                );

    if (b) {
        lgrmi0[0].lgrmi0_sid = AuthenticatedUsers;

        b = AllocateAndInitializeSid (
                    &NtAuthority,
                    1,
                    SECURITY_INTERACTIVE_RID,
                    0, 0, 0, 0, 0, 0, 0,
                    &Interactive
                    );

        if (b) {
            lgrmi0[1].lgrmi0_sid = Interactive;
            rc1 = NetLocalGroupAddMembers(
                         NULL,
                         Name,
                         0,
                         (PBYTE) &lgrmi0,
                         2
                         );
        }
        else {
            if ( AuthenticatedUsers ) {
                FreeSid( AuthenticatedUsers );
            }
            return FALSE;
        }

        if ( AuthenticatedUsers ) {
            FreeSid( AuthenticatedUsers );
        }

        if ( Interactive ) {
            FreeSid( Interactive );
        }

        if ( rc1 != ERROR_SUCCESS && rc1 != ERROR_MEMBER_IN_ALIAS ) {
            return FALSE;
        }
    }
    else {
        return FALSE;
    }

    return TRUE;
}

BOOL
ScepAddInteractiveToPowerUsersGroup()
{
    //
    // Attempt to add Interactive into Power Users group.
    //

    DWORD    rc1;
    SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;
    PSID Interactive = NULL;
    WCHAR Name[36];
    BOOL b;
    LOCALGROUP_MEMBERS_INFO_0 lgrmi0[1];
    HMODULE hMod = GetModuleHandle(L"scecli.dll");

    LoadString(hMod, IDS_POWER_USERS, Name, 36);

    b = AllocateAndInitializeSid (
                    &NtAuthority,
                    1,
                    SECURITY_INTERACTIVE_RID,
                    0, 0, 0, 0, 0, 0, 0,
                    &Interactive
                    );

    if (b) {
        lgrmi0[0].lgrmi0_sid = Interactive;
        rc1 = NetLocalGroupAddMembers(
                         NULL,
                         Name,
                         0,
                         (PBYTE) &lgrmi0,
                         1
                         );
    }
    else {
        return FALSE;
    }

    if ( Interactive ) {
        FreeSid( Interactive );
    }

    if ( rc1 != ERROR_SUCCESS && rc1 != ERROR_MEMBER_IN_ALIAS ) {
        return FALSE;
    }

    return TRUE;
}


DWORD
SceSysPrep()
{

    SCESTATUS           rc=0;
    handle_t            binding_h=NULL;
    NTSTATUS            NtStatus;


    //
    // open system database
    //
    rc = ScepSetupOpenSecurityDatabase(TRUE);
    rc = ScepSceStatusToDosError(rc);

    if ( ERROR_SUCCESS == rc ) {

        RpcTryExcept {

            // reset policy
            // all tables
            rc = SceRpcSetupResetLocalPolicy(
                                (PVOID)hSceSetupHandle,
                                AREA_ALL,
                                NULL,
                                SCE_RESET_POLICY_SYSPREP
                                );

        } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

            //
            // get exception code (DWORD)
            //

            rc = RpcExceptionCode();

        } RpcEndExcept;

        //
        // close the database
        //

        ScepSetupCloseSecurityDatabase();
    }


    HKEY hKey;
    DWORD Interval;
    DWORD RegType;
    DWORD DataSize;

    if ( ERROR_SUCCESS == rc ) {
        //
        // update local policy version #
        // so policy will be propagated at reboot
        //

        ScepEnforcePolicyPropagation();

    }

    //
    // re-register seclogon.dll to recreate EFS recovery policy
    // at first logon
    //

    HINSTANCE hNotifyDll = LoadLibrary(TEXT("sclgntfy.dll"));

    if ( hNotifyDll) {
        PFREGISTERSERVER pfRegisterServer = (PFREGISTERSERVER)GetProcAddress(
                                                       hNotifyDll,
                                                       "DllRegisterServer");

        if ( pfRegisterServer ) {
            //
            // do not care errors - shouldn't fail
            //
            (void) (*pfRegisterServer)();

        }

        FreeLibrary(hNotifyDll);
    }


    if(( rc = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                           EFS_NOTIFY_PATH,
                          0,
                          MAXIMUM_ALLOWED,
                          &hKey
                         )) == ERROR_SUCCESS ) {
        //
        // set a flag to registry
        // this shouldn't fail since admin logon
        //
        Interval = 1;
        rc = RegSetValueEx( hKey,
                            TEXT("SystemCloned"),
                            0,
                            REG_DWORD,
                            (BYTE *)&Interval,
                            4
                            );

        RegCloseKey( hKey );

    }

    return(rc);
}

DWORD
WINAPI
SceSetupRootSecurity()
/*
Description:

    This function should be called in GUI setup after system security is
    configured (SceSetupSystemSecurityByName). The function calls to NTMARTA
    API to set security on the root of boot partition (where Windows is installed).
    This task will take quite long time depending on the size of the drive.
    Therefore, setup should call this function in a asynchronous thread.

    This function will NOT set security on the root drive if one of the following
    conditions is met:

        1) FAT partition
        2) Security on the root drive was modified by user in a previous install.
            This is determined by comparing the security on the root drive to the
            default security from NTFS format, NTFS convert tool on both NT4 and
            Windows 2000 systems.


*/
{

    DWORD rc=NO_ERROR;
    WCHAR szRootDir[MAX_PATH+1];
    WCHAR szSetupInfFile[MAX_PATH+1];
    WCHAR LogFileName[MAX_PATH+51];
    UINT  DriveType;
    DWORD FileSystemFlags;

    //
    // get the time stamp
    //
    TCHAR pvBuffer[100];

    pvBuffer[0] = L'\0';
    ScepGetTimeStampString(pvBuffer);

    szRootDir[0] = L'\0';
    //
    // get the root drive of Windows directory
    //
    if ( GetSystemWindowsDirectory( szRootDir, MAX_PATH ) == 0 ) {

        return(GetLastError());
    }

    szRootDir[MAX_PATH] = L'\0';

    wcscpy(LogFileName, szRootDir);
    wcscat(LogFileName, L"\\security\\logs\\SceRoot.log");

    //
    // attempt to write root SDDL so that it is useful for FAT->NTFS conversion
    // if default is different from hardcoded value, it will be overwritten later...
    //

    //
    // insert the root security SDDL into %windir%\security\templates\setup security.inf
    // this will be useful for the new API which implements convert behavior.
    //

    wcscpy(szSetupInfFile, szRootDir);
    wcscat(szSetupInfFile, L"\\security\\templates\\setup security.inf");

    // the first two letters are X:
    szRootDir[2] = L'\\';
    szRootDir[3] = L'\0';

    //
    // independent of future errors/file systemtypr etc., attempt to
    // write default root acl to %windir%\security\templates\setup security.inf
    // used in FAT->NTFS convert
    //

    PWSTR pszDefltInfStringToWrite = NULL;
    DWORD rcDefltRootBackup = ERROR_SUCCESS;

    rcDefltRootBackup = ScepBreakSDDLToMultiFields(
                                             szRootDir,
                                             SDDLRoot,
                                             sizeof(SDDLRoot)+1,
                                             0,
                                             &pszDefltInfStringToWrite
                                             );

    if ( rcDefltRootBackup == ERROR_SUCCESS && pszDefltInfStringToWrite) {

        if ( !WritePrivateProfileString(szFileSecurity, L"0", pszDefltInfStringToWrite, szSetupInfFile) ) {

            LogEventAndReport(MyModuleHandle,
                              (wchar_t *)LogFileName,
                              0,
                              0,
                              IDS_ROOT_ERROR_INFWRITE,
                              GetLastError(),
                              SDDLRoot
                             );

        }

        ScepFree(pszDefltInfStringToWrite);

    }

    else {

        LogEventAndReport(MyModuleHandle,
                 (wchar_t *)LogFileName,
                 0,
                 0,
                 IDS_ROOT_ERROR_INFWRITE,
                 rcDefltRootBackup,
                 SDDLRoot
                 );

    }

    //
    // log the time stamp
    //
    if ( pvBuffer[0] != L'\0' ) {
        LogEventAndReport(MyModuleHandle,
                 (wchar_t *)LogFileName,
                 0,
                 0,
                 0,
                 pvBuffer
                 );
    }

    //
    // detect if the partition is FAT
    //
    DriveType = GetDriveType(szRootDir);

    if ( DriveType == DRIVE_FIXED ||
         DriveType == DRIVE_RAMDISK ) {

        if ( GetVolumeInformation(szRootDir,
                                  NULL,
                                  0,
                                  NULL,
                                  NULL,
                                  &FileSystemFlags,
                                  NULL,
                                  0
                                ) == TRUE ) {

            if ( !(FileSystemFlags & FS_PERSISTENT_ACLS)  ) {
                //
                // only set security on NTFS partition
                //
                LogEventAndReport(MyModuleHandle,
                         (wchar_t *)LogFileName,
                         0,
                         0,
                         IDS_ROOT_NON_NTFS,
                         szRootDir
                         );


                return(rc);
            }

        } else {
            //
            // something is wrong
            //
            rc = GetLastError();

            LogEventAndReport(MyModuleHandle,
                     (wchar_t *)LogFileName,
                     0,
                     0,
                     IDS_ROOT_ERROR_QUERY_VOLUME,
                     rc,
                     szRootDir
                     );


            return rc;
        }

    } else {
        //
        // do not set security on remote drives
        //
        LogEventAndReport(MyModuleHandle,
                 (wchar_t *)LogFileName,
                 0,
                 0,
                 IDS_ROOT_NOT_FIXED_VOLUME,
                 szRootDir
                 );

        return(rc);
    }

    PSECURITY_DESCRIPTOR pSDSet=NULL, pSDOld=NULL;
    DWORD dwSize=0;
    SECURITY_INFORMATION SeInfo=0;
    PACL pDacl=NULL;
    ACCESS_ALLOWED_ACE      *pAce=NULL;
    SID_IDENTIFIER_AUTHORITY  Authority=SECURITY_WORLD_SID_AUTHORITY;
    PSID pSid;
    BYTE SidEveryone[20];
    BOOLEAN     tFlag;
    BOOLEAN     aclPresent;
    SECURITY_DESCRIPTOR_CONTROL Control=0;
    ULONG Revision;
    NTSTATUS NtStatus;
    BOOL bDefault;


    LogEventAndReport(MyModuleHandle,
             (wchar_t *)LogFileName,
             0,
             0,
             IDS_ROOT_NTFS_VOLUME,
             szRootDir
             );

    //
    // It's NTFS volume. Let's convert the security descriptor
    //

    rc = ConvertTextSecurityDescriptor (SDDLRoot,
                                        &pSDSet,
                                        &dwSize,
                                        &SeInfo
                                       );
    if ( rc != NO_ERROR ) {
        LogEventAndReport(MyModuleHandle,
                 (wchar_t *)LogFileName,
                 0,
                 0,
                 IDS_ROOT_ERROR_CONVERT,
                 rc,
                 SDDLRoot
                 );
        return(rc);
    }

    if ( !(SeInfo & DACL_SECURITY_INFORMATION) ) {
        LogEventAndReport(MyModuleHandle,
                 (wchar_t *)LogFileName,
                 0,
                 0,
                 IDS_ROOT_INVALID_SDINFO,
                 SDDLRoot
                 );
        LocalFree(pSDSet);
        return(ERROR_INVALID_PARAMETER);
    }

    //
    // It's NTFS volume. Now get existing security of the root drive
    //
    rc = GetNamedSecurityInfo(szRootDir,
                              SE_FILE_OBJECT,
                              DACL_SECURITY_INFORMATION,
                              NULL,
                              NULL,
                              &pDacl,
                              NULL,
                              &pSDOld
                             );

    if ( rc == ERROR_SUCCESS && pDacl ) {

        //
        // compare the security descriptor with the default (everyone full control)
        //
        bDefault=FALSE;

        if ( pDacl && pDacl->AceCount == 1 ) {

            NtStatus = RtlGetAce ( pDacl, 0, (PVOID *)&pAce );

            if ( NT_SUCCESS(NtStatus) ) {

                //
                // must be access allowed type, CIOI, FA or GA
                //
                if ( pAce->Header.AceType == ACCESS_ALLOWED_ACE_TYPE &&
                     pAce->Header.AceFlags == (CONTAINER_INHERIT_ACE | OBJECT_INHERIT_ACE) &&
                     (pAce->Mask == FILE_ALL_ACCESS || pAce->Mask == GENERIC_ALL ) ) {

                    pSid = (PSID)&(pAce->SidStart);

                    // SID must be Everyone (s-1-1-0)

                    RtlInitializeSid ( (PSID)&SidEveryone, &Authority, 1 );
                    *RtlSubAuthoritySid ( (PSID)&SidEveryone, 0 ) = SECURITY_WORLD_RID;

                    // compare the SIDs
                    if ( RtlEqualSid (pSid, (PSID)&SidEveryone) ) {
                        bDefault = TRUE;
                    }
                }

            } else {
                rc = RtlNtStatusToDosError(NtStatus);
            }
        }

        //
        // if any error occurs above, bDefault won't be set to TRUE
        //
        if ( bDefault && pSDSet ) {
            //
            // only set security if it's default
            //

            RtlGetControlSecurityDescriptor (
                    pSDSet,
                    &Control,
                    &Revision
                    );

            //
            // Get DACL address
            //

            pDacl = NULL;
            rc = RtlNtStatusToDosError(
                      RtlGetDaclSecurityDescriptor(
                                    pSDSet,
                                    &aclPresent,
                                    &pDacl,
                                    &tFlag));

            if (rc == NO_ERROR && !aclPresent )
                pDacl = NULL;


            //
            // if error occurs for this one, do not set. return
            //

            if ( rc == ERROR_SUCCESS ) {
                //
                // set permission
                //
                if ( Control & SE_DACL_PROTECTED ) {
                    SeInfo |= PROTECTED_DACL_SECURITY_INFORMATION;
                }

                pvBuffer[0] = L'\0';
                ScepGetTimeStampString(pvBuffer);

                LogEventAndReport(MyModuleHandle,
                         (wchar_t *)LogFileName,
                         0,
                         0,
                         IDS_ROOT_SECURITY_DEFAULT,
                         szRootDir,
                         pvBuffer
                         );

                rc = SetNamedSecurityInfo(szRootDir,
                                          SE_FILE_OBJECT,
                                          SeInfo,
                                          NULL,
                                          NULL,
                                          pDacl,
                                          NULL
                                         );

                pvBuffer[0] = L'\0';
                ScepGetTimeStampString(pvBuffer);

                LogEventAndReport(MyModuleHandle,
                         (wchar_t *)LogFileName,
                         0,
                         0,
                         IDS_ROOT_MARTA_RETURN,
                         rc,
                         pvBuffer,
                         szRootDir
                         );

            } else {

                LogEventAndReport(MyModuleHandle,
                         (wchar_t *)LogFileName,
                         0,
                         0,
                         IDS_ROOT_ERROR_DACL,
                         rc
                         );
            }

        } else {

            //
            // convert the old security descriptor to text and log it
            //

            PWSTR pszOldSDDL=NULL;
            PWSTR pszInfStringToWrite = NULL;
            DWORD rcRootBackup = ERROR_SUCCESS;

            ConvertSecurityDescriptorToText (
                            pSDOld,
                            DACL_SECURITY_INFORMATION,
                            &pszOldSDDL,
                            &dwSize
                            );

            //
            // also, overwrite this SDDL to %windir%\security\templates\setup security.inf
            // since this is the "default" root security. This will be used later if
            // SCE is invoked to do security configuration during NTFS->FAT->NTFS conversion.
            //

            if (pszOldSDDL) {

                rcRootBackup = ScepBreakSDDLToMultiFields(
                                                         szRootDir,
                                                         pszOldSDDL,
                                                         dwSize,
                                                         0,
                                                         &pszInfStringToWrite
                                                         );

                if (rcRootBackup == ERROR_SUCCESS && pszInfStringToWrite) {

                    if ( !WritePrivateProfileString(szFileSecurity, L"0", pszInfStringToWrite, szSetupInfFile) ) {

                        LogEventAndReport(MyModuleHandle,
                                          (wchar_t *)LogFileName,
                                          0,
                                          0,
                                          IDS_ROOT_ERROR_INFWRITE,
                                          GetLastError(),
                                          pszOldSDDL
                                         );
                    }

                    ScepFree(pszInfStringToWrite);

                } else {

                    LogEventAndReport(MyModuleHandle,
                                      (wchar_t *)LogFileName,
                                      0,
                                      0,
                                      IDS_ROOT_ERROR_INFWRITE,
                                      rcRootBackup,
                                      pszOldSDDL
                                     );

                }
            }


            LogEventAndReport(MyModuleHandle,
                              (wchar_t *)LogFileName,
                              0,
                              0,
                              IDS_ROOT_SECURITY_MODIFIED,
                              szRootDir,
                              pszOldSDDL ? pszOldSDDL : L""
                             );

            if ( pszOldSDDL ) {
                LocalFree(pszOldSDDL);
            }
        }

        LocalFree(pSDOld);

    } else {

        LogEventAndReport(MyModuleHandle,
                 (wchar_t *)LogFileName,
                 0,
                 0,
                 IDS_ROOT_ERROR_QUERY_SECURITY,
                 rc,
                 szRootDir
                 );
    }

    LocalFree(pSDSet);

    return(rc);
}


DWORD
WINAPI
SceEnforceSecurityPolicyPropagation()
{

    return(ScepEnforcePolicyPropagation());
}

DWORD
WINAPI
SceConfigureConvertedFileSecurity(
    IN  PWSTR   pszDriveName,
    IN  DWORD   dwConvertDisposition
    )
/*++

Routine Description:

    Exported API called by convert.exe to configure setup style security for drives converted from FAT to NTFS.

    Briefly, this API will
    EITHER (dwConvertDisposition == 0)
    convert the volume in question immediately (in an asynchronous thread after RPC'ing over to the server)
    OR (dwConvertDisposition == 1)
    will schedule a conversion to happen at the time of reboot (in an asynchronous thread during reboot).
    Scheduling is done by entering pszDriveName(s) in a REG_MULTI_SZ registry value
    SCE_ROOT_PATH\FatNtfsConvertedDrives.

Arguments:

    pszDriveName           -   Name of the volume to be converted

    dwConvertDisposition    -   0 implies volume can be converted immediately
                                1 implies volume cannot be converted immediately and is scheduled for conversion


Return:

    win32 error code
--*/
{

    DWORD       rc = ERROR_SUCCESS;

    if ( pszDriveName == NULL ||
         wcslen(pszDriveName) == 0 ||
          (dwConvertDisposition != 0 && dwConvertDisposition != 1) ) {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // validate drive name - has to end in ":"
    //

    if ( pszDriveName [wcslen( pszDriveName ) - 1] != L':') {
        return ERROR_INVALID_PARAMETER;
    }

    if (dwConvertDisposition == 0) {

        //
        // configure setup-style security immediately
        // RPC over to scesrv
        //

        NTSTATUS    NtStatus = NO_ERROR;
        handle_t    binding_h = NULL;

        //
        // RPC bind to the server - don't use secure RPC
        //


        NtStatus = ScepBindRpc(
                        NULL,
                        L"scerpc",
                        0,
                        &binding_h
                        );

        /*
        NtStatus = ScepBindSecureRpc(
                                    NULL,
                                    L"scerpc",
                                    0,
                                    &binding_h
                                    );
        */

        if (NT_SUCCESS(NtStatus)) {

            RpcTryExcept {

                //
                // make the RPC call
                //

                rc = SceRpcConfigureConvertedFileSecurityImmediately(
                                                                    binding_h,
                                                                    pszDriveName
                                                                    );

            } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

                //
                // get exception code
                //

                rc = RpcExceptionCode();

            } RpcEndExcept;

            //
            // Free the binding handle
            //

            RpcpUnbindRpc( binding_h );

        } else {

            rc = RtlNtStatusToDosError( NtStatus );
        }

    }

    else if (dwConvertDisposition == 1) {

        //
        // schedule conversion for reboot time - i.e. enter into MULTI_SZ registry value
        //

        rc = ScepAppendCreateMultiSzRegValue(HKEY_LOCAL_MACHINE,
                                             SCE_ROOT_PATH,
                                             L"FatNtfsConvertedDrives",
                                             pszDriveName
                                             );

    }

    return rc;

}

DWORD
ScepBreakSDDLToMultiFields(
    IN  PWSTR   pszObjName,
    IN  PWSTR   pszSDDL,
    IN  DWORD   dwSDDLsize,
    IN  BYTE    ObjStatus,
    OUT PWSTR   *ppszAdjustedInfLine
    )
/*++

Routine Description:

    Inf files have a limitation w.r.t. line size - so break up SDDL if need be

Arguments:

    pszObjName  -   name of the object
    pszSDDL     -   SDDL string that might be velry long
    dwSDDLsize  -   size of pszSDDL
    ObjStatus   -   0/1/2
    ppszAdjustedInfLine  -   ptr to adjusted string

Return:

    win32 error code
--*/
{

    DWORD         rc;
    PWSTR         Strvalue=NULL;
    DWORD         nFields;
    DWORD         *aFieldOffset=NULL;
    DWORD         i;
    DWORD         dwObjSize = 0;

    if ( pszObjName == NULL ||
         pszSDDL == NULL ||
         ppszAdjustedInfLine == NULL )

        return ERROR_INVALID_PARAMETER;

    rc = SceInfpBreakTextIntoMultiFields(pszSDDL, dwSDDLsize, &nFields, &aFieldOffset);

    if ( SCESTATUS_SUCCESS != rc ) {

        rc = ScepSceStatusToDosError(rc);
        goto Done;
    }
    //
    // each extra field will use 3 more chars : ,"<field>"
    //
    dwObjSize = wcslen(pszObjName)+8 + dwSDDLsize;
    if ( nFields ) {
        dwObjSize += 3*nFields;
    } else {
        dwObjSize += 2;
    }
    //
    // allocate the output buffer
    //
    Strvalue = (PWSTR)ScepAlloc(LMEM_ZEROINIT, (dwObjSize+1) * sizeof(WCHAR) );

    if ( Strvalue == NULL ) {
        rc = ERROR_NOT_ENOUGH_MEMORY;
        goto Done;
    }
    //
    // copy data into the buffer
    //
    if ( nFields == 0 || !aFieldOffset ) {
        swprintf(Strvalue, L"\"%s\",%1d,\"%s\"", pszObjName, ObjStatus, pszSDDL);
    } else {
        //
        // loop through the fields
        //
        swprintf(Strvalue, L"\"%s\",%1d\0", pszObjName, ObjStatus);

        for ( i=0; i<nFields; i++ ) {

            if ( aFieldOffset[i] < dwSDDLsize ) {

                wcscat(Strvalue, L",\"");
                if ( i == nFields-1 ) {
                    //
                    // the last field
                    //
                    wcscat(Strvalue, pszSDDL+aFieldOffset[i]);
                } else {

                    wcsncat(Strvalue, pszSDDL+aFieldOffset[i],
                            aFieldOffset[i+1]-aFieldOffset[i]);
                }
                wcscat(Strvalue, L"\"");
            }
        }
    }

    *ppszAdjustedInfLine = Strvalue;

Done:

    if ( aFieldOffset ) {
        ScepFree(aFieldOffset);
    }

    return(rc);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\scerpc\client\smartptr.h ===
//*************************************************************
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1998
//
// File:        smartptr.h
//
// Contents:    Classes for smart pointers
//
// History:     7-Jun-99       SitaramR    Created
//
//              2-Dec-99       LeonardM    Major revision and cleanup.
//
//*************************************************************

#ifndef SMARTPTR_H
#define SMARTPTR_H

#include <comdef.h>
#include "userenv.h"

#pragma once
#pragma warning(disable:4284)


//*************************************************************
//
//  Class:      XPtrST
//
//  Purpose:    Smart pointer template to wrap pointers to a single type.
//
//*************************************************************

template<class T> class XPtrST
{

private:

    XPtrST (const XPtrST<T>& x);
    XPtrST<T>& operator=(const XPtrST<T>& x);

    T* _p;

public:

    XPtrST(T* p = NULL) : _p(p){}

    ~XPtrST(){ delete _p; }

    T* operator->(){ return _p; }
    T** operator&(){ return &_p; }
    operator T*(){ return _p; }

    void operator=(T* p)
    {
        if(_p)
        {
            delete _p;
        }
        _p = p;
    }

    T* Acquire()
    {
        T* p = _p;
        _p = 0;
        return p;
    }

};


//*************************************************************
//
//  Class:      XPtrArray
//
//  Purpose:    Smart pointer template to wrap pointers to an array .
//
//*************************************************************

template<class T> class XPtrArray
{

private:

    XPtrArray (const XPtrArray<T>& x);
    XPtrArray<T>& operator=(const XPtrArray<T>& x);

    T* _p;

public:

    XPtrArray(T* p = NULL) : _p(p){}

    ~XPtrArray(){ delete[] _p; }

    T* operator->(){ return _p; }
    T** operator&(){ return &_p; }
    operator T*(){ return _p; }

    void operator=(T* p)
    {
        if(_p)
        {
            delete[] _p;
        }
        _p = p;
    }

    T* Acquire()
    {
        T* p = _p;
        _p = 0;
        return p;
    }

};



//*************************************************************
//
//  Class:      XInterface
//
//  Purpose:    Smart pointer template for items Release()'ed, not ~'ed
//
//*************************************************************

template<class T> class XInterface
{

private:

    XInterface(const XInterface<T>& x);
    XInterface<T>& operator=(const XInterface<T>& x);

    T* _p;

public:

    XInterface(T* p = NULL) : _p(p){}

    ~XInterface()
    {
        if (_p)
        {
            _p->Release();
        }
    }

    T* operator->(){ return _p; }
    T** operator&(){ return &_p; }
    operator T*(){ return _p; }

    void operator=(T* p)
    {
        if (_p)
        {
            _p->Release();
        }
        _p = p;
    }

    T* Acquire()
    {
        T* p = _p;
        _p = 0;
        return p;
    }

};



//*************************************************************
//
//  Class:      XBStr
//
//  Purpose:    Smart pointer class for BSTRs
//
//*************************************************************

class XBStr
{

private:

    XBStr(const XBStr& x);
    XBStr& operator=(const XBStr& x);

    BSTR _p;

public:

    XBStr(WCHAR* p = 0) : _p(0)
    {
        if(p)
        {
            _p = SysAllocString(p);
        }
    }

    ~XBStr()
    {
        SysFreeString(_p);
    }

    operator BSTR(){ return _p; }

    void operator=(WCHAR* p)
    {
        SysFreeString(_p);
        _p = p ? SysAllocString(p) : NULL;
    }

    BSTR Acquire()
    {
        BSTR p = _p;
        _p = 0;
        return p;
    }

};


//*************************************************************
//
//  Class:      XSafeArray
//
//  Purpose:    Smart pointer class for SafeArrays
//
//*************************************************************

class XSafeArray
{

private:

    XSafeArray(const XSafeArray& x);
    XSafeArray& operator=(const XSafeArray& x);

    SAFEARRAY* _p;

public:

    XSafeArray(SAFEARRAY* p = 0) : _p(p){}

    ~XSafeArray()
    {
        if (_p)
        {
            SafeArrayDestroy(_p);
        }
    }

    operator SAFEARRAY*(){ return _p; }

    void operator=(SAFEARRAY* p)
    {
        if(_p)
        {
            SafeArrayDestroy(_p);
        }

        _p = p;
    }

    SAFEARRAY* Acquire()
    {
        SAFEARRAY* p = _p;
        _p = 0;
        return p;
    }

};


//*************************************************************
//
//  Class:      XVariant
//
//  Purpose:    Smart pointer class for Variants
//
//*************************************************************

class XVariant
{

private:

    XVariant(const XVariant& x);
    XVariant& operator=(const XVariant& x);

    VARIANT* _p;

public:

    XVariant(VARIANT* p = 0) : _p(p){}

    ~XVariant()
    {
        if (_p)
        {
            VariantClear(_p);
        }
    }

    void operator=(VARIANT* p)
    {
        if(_p)
        {
            VariantClear(_p);
        }
        _p = p;
    }

    operator VARIANT*(){ return _p; }

    VARIANT* Acquire()
    {
        VARIANT* p = _p;
        _p = 0;
        return p;
    }

};

//*************************************************************
//
//  Class:      XPtrLF
//
//  Purpose:    Smart pointer template for pointers that should be LocalFree()'d
//
//*************************************************************

template <typename T> class XPtrLF
{

private:

    XPtrLF(const XPtrLF<T>& x);
    XPtrLF<T>& operator=(const XPtrLF<T>& x);

    T* _p;

public:

    XPtrLF(HLOCAL p = 0 ) :
            _p((T*)p)
    {
    }

    ~XPtrLF()
    {
        if(_p)
        {
            LocalFree(_p);
        }
    }

    T* operator->(){ return _p; }
    T** operator&(){ return &_p; }
    operator T*(){ return _p; }

    void operator=(T* p)
    {
        if(_p)
        {
            LocalFree(_p);
        }
        _p = p;
    }

    T* Acquire()
    {
        T* p = _p;
        _p = NULL;
        return p;
    }

};

//*************************************************************
//
//  Class:      XPtr
//
//  Purpose:    Smart pointer template for pointers that provide
//              a custom free memory routine
//
//*************************************************************

typedef HLOCAL (__stdcall *PFNFREE)(HLOCAL);

//
// usage : XPtr<SID, FreeSid> xptrSid;
//

template <typename T, PFNFREE _f> class XPtr
{
private:
    XPtr(const XPtr<T, _f>& x);
    XPtr<T, _f>& operator=(const XPtr<T, _f>& x);
    T* _p;

public:

    XPtr( HLOCAL p = 0 ) :
            _p( reinterpret_cast<T*>( p ) )
    {
    }

    ~XPtr()
    {
        if(_p)
        {
            _f(_p);
        }
    }

    T* operator->(){ return _p; }
    T** operator&(){ return &_p; }
    operator T*(){ return _p; }

    void operator=(T* p)
    {
        if(_p)
        {
            _f(_p);
        }
        _p = p;
    }

    T* Acquire()
    {
        T* p = _p;
        _p = NULL;
        return p;
    }
};

//*************************************************************
//
//  Class:      XArray
//
//  Purpose:    Smart pointer template for pointers that provide
//              a custom free memory routine
//
//*************************************************************

typedef HLOCAL (__stdcall *PFNARRAYFREE)(HLOCAL, int);

//
// usage : XArray<EXPLICIT_ACCESS, 10> xaExplicitAccess( FreeAccessArray );
//

template <typename T, int nElements> class XArray
{
private:
    XArray(const XArray<T,nElements>& x);
    XArray<T,nElements>& operator=(const XArray<T,nElements>& x);
    T* _p;
    int _n;
    PFNARRAYFREE _f;

public:

    XArray( PFNARRAYFREE pfnFree, HLOCAL p = 0 ) :
            _p( reinterpret_cast<T*>( p ) ), _f( pfnFree ), _n( nElements )
    {
    }

    ~XArray()
    {
        if(_p)
        {
            _f(_p, _n);
        }
    }

    T* operator->(){ return _p; }
    T** operator&(){ return &_p; }
    operator T*(){ return _p; }

    void operator=(T* p)
    {
        if(_p)
        {
            _f(_p, _n);
        }
        _p = p;
    }

    T* Acquire()
    {
        T* p = _p, _p = 0;
        return p;
    }
};

//******************************************************************************
//
// Class:
//
// Description:
//
// History:        8/20/99        leonardm    Created.
//
//******************************************************************************
class XHandle
{
private:
    HANDLE _h;

public:
    XHandle(HANDLE h = NULL) : _h(h) {}
    ~XHandle()
    {
        if(_h && _h != INVALID_HANDLE_VALUE)
        {
            CloseHandle(_h);
        }
    }
    HANDLE* operator&(){return &_h;}
    operator HANDLE(){return _h;}

    void operator=(HANDLE h)
    {
        if(_h && _h != INVALID_HANDLE_VALUE)
        {
            CloseHandle(_h);
        }
        _h = h;
    }
};


class XCoInitialize
{
public:
    XCoInitialize()
    {
        m_hr = CoInitializeEx( 0, COINIT_MULTITHREADED );
    };

    ~XCoInitialize()
    {
        if ( SUCCEEDED( m_hr ) )
        {
            CoUninitialize();
        }
    };

    HRESULT Status()
    {
        return m_hr;
    };

private:
    HRESULT      m_hr;
};

class XImpersonate
{
public:
    XImpersonate() : m_hImpToken( 0 ), m_hThreadToken( 0 )
    {
        m_hr = CoImpersonateClient();
    };

    XImpersonate( HANDLE hToken ) : m_hThreadToken( 0 ), m_hImpToken( hToken )
    {
        OpenThreadToken( GetCurrentThread(), TOKEN_IMPERSONATE, TRUE, &m_hThreadToken );
        ImpersonateLoggedOnUser( hToken );
        m_hr = GetLastError();
    };

    ~XImpersonate()
    {
        if ( SUCCEEDED( m_hr ) )
        {
            if ( m_hImpToken )
            {
                SetThreadToken( 0, m_hThreadToken);
            }
            else
            {
                CoRevertToSelf();
            }
        }
    };

    HRESULT Status()
    {
        return m_hr;
    };

private:
    HRESULT     m_hr;
    XHandle     m_hThreadToken;
    HANDLE      m_hImpToken;   // we don't own this
};


//*************************************************************
//
//  Class:      XCriticalPolicySection
//
//  Purpose:    Smart pointer for freeing Group Policy critical section
//
//*************************************************************

class XCriticalPolicySection
{
private:
    HANDLE _h;

public:
    XCriticalPolicySection(HANDLE h) : _h(h){}
    ~XCriticalPolicySection()
    {
        if(_h)
        {
            LeaveCriticalPolicySection (_h);
        }
    }

    operator bool() {return _h ? true : false;}
};


// critical section smartptr
class XCritSec
{
public:
    XCritSec()
    {
        lpCritSec = &CritSec;
        __try {
            InitializeCriticalSectionAndSpinCount(&CritSec, 0x80001000);
        }            
        __except (EXCEPTION_EXECUTE_HANDLER) {
            // assumption, exception is out of memory
            // this is used in spewing debug messages. so cannot add a debug spew.
            lpCritSec = NULL;
        }            
    }

    ~XCritSec()
    {
        if (lpCritSec)
            DeleteCriticalSection(lpCritSec);
    }

    operator LPCRITICAL_SECTION(){return lpCritSec;}

    
private:
    CRITICAL_SECTION      CritSec;    
    LPCRITICAL_SECTION    lpCritSec;
};



// enter and exit critical section
class XEnterCritSec
{
public:
    XEnterCritSec(LPCRITICAL_SECTION lpCritSec) : m_lpCritSec( lpCritSec )
    {
        if (lpCritSec)
            EnterCriticalSection(lpCritSec);
    };

    
    ~XEnterCritSec()
    {
        if (m_lpCritSec)
            LeaveCriticalSection(m_lpCritSec);
    };


private:
    LPCRITICAL_SECTION      m_lpCritSec;   // we don't own this
};


#endif SMARTPTR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\scerpc\client\scerpc_c_stub.c ===
#include "scerpc_c.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\scerpc\client\svcclnt.cpp ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    svcclnt.cpp

Abstract:

    SCE service Client APIs

Author:

    Jin Huang (jinhuang) 23-Jun-1997 created

Revision History:

    jinhuang        23-Jan-1998   split to client-server model

--*/

#include "headers.h"
#include "scesvc.h"
#include "scerpc.h"
#include <rpcasync.h>

#pragma hdrstop

//
// prototypes exported in scesvc.h (public\sdk)
//

SCESTATUS
WINAPI
SceSvcQueryInfo(
    IN SCE_HANDLE   sceHandle,
    IN SCESVC_INFO_TYPE sceType,
    IN PWSTR        lpPrefix OPTIONAL,
    IN BOOL         bExact,
    OUT PVOID       *ppvInfo,
    OUT PSCE_ENUMERATION_CONTEXT  psceEnumHandle
    )
/*
Routine Description:

    Query information for the service in the configuration/analysis database
    which contains the modified configuration and last analysis information.

    One enumeration returns maximum SCESVC_ENUMERATION_MAX lines (key/value)
    matching the lpPrefix for the service. If lpPrefix is NULL, all information
    for the service is enumerated. If there is more information, psceEnumHandle
    must be used to get next set of keys/values, until *ppvInfo is NULL or Count is 0.

    When bExact is set and lpPrefix is not NULL, exact match on the lpPrefix is
    searched and only one line is returned.

    The output buffer must be freed by SceSvcFree

Arguments:

    sceHandle   - the opaque handle obtained from SCE

    sceType     - the information type to query

    lpPrefix    - the optional key name prefix for the query

    bExact      - TRUE = exact match on key

    ppvInfo     - the output buffer

    psceEnumHandle  - the output enumeration handle for next enumeartion

Return Value:

    SCE status for this operation

*/
{
    if ( sceHandle == NULL || ppvInfo == NULL ||
         psceEnumHandle == NULL ) {

        return(SCESTATUS_INVALID_PARAMETER);

    }

    SCESTATUS rc=SCESTATUS_SUCCESS;

    //
    // Validate sceHandle
    //

    PVOID hProfile=NULL;

    __try {

        hProfile = ((SCEP_HANDLE *)sceHandle)->hProfile;

        if ( !hProfile ||
            ((SCEP_HANDLE *)sceHandle)->ServiceName == NULL ) {

            rc = SCESTATUS_INVALID_PARAMETER;
        }
    } __except(EXCEPTION_EXECUTE_HANDLER) {

        rc = SCESTATUS_INVALID_PARAMETER;
    }


    if ( SCESTATUS_SUCCESS == rc ) {

        RpcTryExcept {

            //
            // call the RPC interface to query info from the database.
            //

            rc = SceSvcRpcQueryInfo(
                        (SCEPR_CONTEXT)hProfile,
                        (SCEPR_SVCINFO_TYPE)sceType,
                        (wchar_t *)(((SCEP_HANDLE *)sceHandle)->ServiceName),
                        (wchar_t *)lpPrefix,
                        bExact,
                        (PSCEPR_SVCINFO *)ppvInfo,
                        (PSCEPR_ENUM_CONTEXT)psceEnumHandle
                        );

        } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

            //
            // get exception code (DWORD) and convert it into SCESTATUS
            //

            rc = ScepDosErrorToSceStatus(
                          RpcExceptionCode());
        } RpcEndExcept;
    }

    return(rc);
}


SCESTATUS
WINAPI
SceSvcSetInfo(
    IN SCE_HANDLE  sceHandle,
    IN SCESVC_INFO_TYPE sceType,
    IN PWSTR      lpPrefix OPTIONAL,
    IN BOOL       bExact,
    IN PVOID      pvInfo OPTIONAL
    )
/*
Routine Description:

    Save information of a service into security manager internal database. It's up
    to the service to collect/decide the information to write.

    Type indicates the type of internal database: CONFIGURATION or ANALYSIS.
    If the service section does not exist, create it.

Arguments:

    sceHandle   - the opaque handle obtained from SCE

    sceType     - the service information type to set

    lpPrefix    - the key prefix to overwrite

    bExact      - TRUE = only overwrite if there is exact match, insert if no match
                  FALSE = overwrite all information for the service then add all
                            info in the pvInfo buffer
    pvInfo      - the information to set

Return Value:

    SCE status

*/
{
    if ( sceHandle == NULL ) {

        return(SCESTATUS_INVALID_PARAMETER);
    }

    SCESTATUS rc=SCESTATUS_SUCCESS;

    //
    // Validate sceHandle
    //

    PVOID hProfile=NULL;

    __try {

        hProfile = ((SCEP_HANDLE *)sceHandle)->hProfile;

        if ( !hProfile ||
             ((SCEP_HANDLE *)sceHandle)->ServiceName == NULL ) {

            rc = SCESTATUS_INVALID_PARAMETER;
        }
    } __except(EXCEPTION_EXECUTE_HANDLER) {

        rc = SCESTATUS_INVALID_PARAMETER;
    }

    if ( SCESTATUS_SUCCESS == rc ) {
        RpcTryExcept {

            //
            // call the RPC interface to query info from the database.
            //

            rc = SceSvcRpcSetInfo(
                        (SCEPR_CONTEXT)hProfile,
                        (SCEPR_SVCINFO_TYPE)sceType,
                        (wchar_t *)(((SCEP_HANDLE *)sceHandle)->ServiceName),
                        (wchar_t *)lpPrefix,
                        bExact,
                        (PSCEPR_SVCINFO)pvInfo
                        );

        } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

            //
            // get exception code (DWORD) and convert it into SCESTATUS
            //

            rc = ScepDosErrorToSceStatus(
                          RpcExceptionCode());
        } RpcEndExcept;
    }

    return(rc);
}



SCESTATUS
WINAPI
SceSvcFree(
    IN PVOID pvServiceInfo
    )
{
    return (SceSvcpFreeMemory(pvServiceInfo) );

}


SCESTATUS
WINAPI
SceSvcConvertTextToSD (
    IN  PWSTR                   pwszTextSD,
    OUT PSECURITY_DESCRIPTOR   *ppSD,
    OUT PULONG                  pulSDSize,
    OUT PSECURITY_INFORMATION   psiSeInfo
    )
{
    DWORD Win32rc;

    Win32rc = ConvertTextSecurityDescriptor(
                      pwszTextSD,
                      ppSD,
                      pulSDSize,
                      psiSeInfo
                      );

    return(ScepDosErrorToSceStatus(Win32rc));

}

SCESTATUS
WINAPI
SceSvcConvertSDToText (
    IN PSECURITY_DESCRIPTOR   pSD,
    IN SECURITY_INFORMATION   siSecurityInfo,
    OUT PWSTR                  *ppwszTextSD,
    OUT PULONG                 pulTextSize
    )
{

    DWORD Win32rc;

    Win32rc = ConvertSecurityDescriptorToText(
                      pSD,
                      siSecurityInfo,
                      ppwszTextSD,
                      pulTextSize
                      );

    return(ScepDosErrorToSceStatus(Win32rc));

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\scerpc\escprov\attachment.cpp ===
// attachment.cpp: implementation of the Sce_PodData class.
//
// Copyright (c)1997-1999 Microsoft Corporation
//
//////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "attachment.h"
#include "persistmgr.h"
#include <io.h>
#include "requestobject.h"

/*
Routine Description: 

Name:

    CPodData::CPodData

Functionality:

    This is the constructor. Pass along the parameters to the base class

Virtual:
    
    No (you know that, constructor won't be virtual!)

Arguments:

    pKeyChain - Pointer to the ISceKeyChain COM interface which is prepared
        by the caller who constructs this instance.

    pNamespace - Pointer to WMI namespace of our provider (COM interface).
        Passed along by the caller. Must not be NULL.

    pCtx - Pointer to WMI context object (COM interface). Passed along
        by the caller. It's up to WMI whether this interface pointer is NULL or not.

Return Value:

    None as any constructor

Notes:
    if you create any local members, think about initialize them here

*/

CPodData::CPodData (
    IN ISceKeyChain     * pKeyChain, 
    IN IWbemServices    * pNamespace,     
    IN IWbemContext     * pCtx
    )
    : 
    CGenericClass(pKeyChain, pNamespace, pCtx)
{
}

/*
Routine Description: 

Name:

    CPodData::~CPodData

Functionality:
    
    Destructor. Necessary as good C++ discipline since we have virtual functions.

Virtual:
    
    Yes.
    
Arguments:

    none as any destructor

Return Value:

    None as any destructor

Notes:
    if you create any local members, think about whether
    there is any need for a non-trivial destructor

*/

CPodData::~CPodData()
{
}

/*
Routine Description: 

Name:

    CPodData::CreateObject

Functionality:
    
    Create WMI objects (Sce_PodData). Depending on parameter atAction,
    this creation may mean:
        (a) Get a single instance (atAction == ACTIONTYPE_GET)
        (b) Get several instances satisfying some criteria (atAction == ACTIONTYPE_QUERY)
        (c) Delete an instance (atAction == ACTIONTYPE_DELETE)

Virtual:
    
    Yes.
    
Arguments:

    pHandler - COM interface pointer for notifying WMI for creation result.
    atAction -  Get single instance ACTIONTYPE_GET
                Get several instances ACTIONTYPE_QUERY
                Delete a single instance ACTIONTYPE_DELETE

Return Value:

    Success: it must return success code (use SUCCEEDED to test). It is
    not guaranteed to return WBEM_NO_ERROR. The returned objects are indicated to WMI,
    not directly passed back via parameters.

    Failure: Various errors may occurs. Except WBEM_E_NOT_FOUND, any such error should indicate 
    the failure of getting the wanted instance. If WBEM_E_NOT_FOUND is returned in querying
    situations, this may not be an error depending on caller's intention.

Notes:

*/

HRESULT 
CPodData::CreateObject (
    IN IWbemObjectSink  * pHandler, 
    IN ACTIONTYPE         atAction
    )
{
    // 
    // we know how to:
    //      Get single instance ACTIONTYPE_GET
    //      Delete a single instance ACTIONTYPE_DELETE
    //      Get several instances ACTIONTYPE_QUERY
    //

    if ( ACTIONTYPE_GET != atAction &&
         ACTIONTYPE_DELETE != atAction &&
         ACTIONTYPE_QUERY != atAction ) {

        return WBEM_E_NOT_SUPPORTED;
    }

    HRESULT hr = WBEM_S_NO_ERROR;

    //
    // enumerate all properties
    //
    
    //
    // We must have a store to get/delete an Sce_PodData object(s).
    // Note: GetKeyPropertyValue will return WBEM_S_FALSE if the key is not recognized.
    // That is why we check against it and return failure as long as it is not querying.
    // 

    CComVariant varStorePath;  
    hr = m_srpKeyChain->GetKeyPropertyValue(pStorePath, &varStorePath);
    if (FAILED(hr))
    {
        return hr;
    }
    else if (hr == WBEM_S_FALSE)
    {
        return WBEM_E_NOT_FOUND;
    }

    //
    // Pod ID is a key property. We must also have Pod ID, unless we are querying.
    //

    CComVariant varPodID;
    hr = m_srpKeyChain->GetKeyPropertyValue(pPodID, &varPodID);
    if (FAILED(hr))
    {
        return hr;
    }
    else if (hr == WBEM_S_FALSE && (ACTIONTYPE_QUERY != atAction) ) 
    {
        return WBEM_E_NOT_FOUND;
    }
    
    CComVariant varPodSection;
    hr = m_srpKeyChain->GetKeyPropertyValue(pPodSection, &varPodSection);
    if (FAILED(hr))
    {
        return hr;
    }
    else if (hr == WBEM_S_FALSE && (ACTIONTYPE_QUERY != atAction) ) 
    {
        return WBEM_E_NOT_FOUND;
    }

    CComVariant varKey;
    hr = m_srpKeyChain->GetKeyPropertyValue(pKey, &varKey); 
    if (FAILED(hr))
    {
        return hr;
    }
    else if (hr == WBEM_S_FALSE && (ACTIONTYPE_QUERY != atAction) )
    {
        return WBEM_E_NOT_FOUND;
    }

    if (SUCCEEDED(hr)) 
    {
        //
        // Prepare a store (for persistence) for this store path (file)
        //

        CSceStore SceStore;
        hr = SceStore.SetPersistPath(varStorePath.bstrVal);

        if ( SUCCEEDED(hr) ) {

            //
            // make sure the store (just a file) really exists. The raw path
            // may contain env variables, so we need the expanded path
            //

            DWORD dwAttrib = GetFileAttributes(SceStore.GetExpandedPath());

            if ( dwAttrib != -1 ) 
            {
                //
                // the file exist
                //

                BOOL bPostFilter=TRUE;
                DWORD dwCount = 0;
                m_srpKeyChain->GetKeyPropertyCount(&dwCount);

                if ( varKey.vt == VT_BSTR ) 
                {
                    //
                    // doesn't matter if this comes from QUERY, GET, or DELETE
                    // do the same logic for QUERY and GET
                    //

                    if ( ACTIONTYPE_DELETE == atAction )
                    {
                        hr = DeleteInstance(&SceStore, varPodID.bstrVal, varPodSection.bstrVal, varKey.bstrVal );
                    }
                    else {

                        if ( ACTIONTYPE_QUERY == atAction && dwCount == 2 ) {
                            bPostFilter = FALSE;
                        }
                        hr = ConstructInstance(pHandler, &SceStore, 
                                               varStorePath.bstrVal,
                                               (varPodID.vt == VT_BSTR)         ? varPodID.bstrVal      : NULL,
                                               (varPodSection.vt == VT_BSTR)    ? varPodSection.bstrVal : NULL,
                                               (varKey.vt == VT_BSTR)           ? varKey.bstrVal        : NULL, 
                                               bPostFilter );
                    }

                } else if ( ACTIONTYPE_QUERY == atAction ) 
                {
                    //
                    // this is only valid for QUERY type
                    //

                    if ( dwCount == 1 ) {
                        bPostFilter = FALSE;
                    }
                    hr = ConstructQueryInstances(pHandler, &SceStore,
                                                varStorePath.bstrVal,
                                                (varPodID.vt == VT_BSTR) ? varPodID.bstrVal : NULL,
                                                (varPodSection.vt == VT_BSTR) ? varPodSection.bstrVal : NULL,
                                                bPostFilter
                                               );

                }

            } else {

                hr = WBEM_E_NOT_FOUND;
            }
        }
    }

    return hr;
}

/*
Routine Description: 

Name:

    CPodData::PutInst

Functionality:
    
    Put an instance as instructed by WMI. Since this class implements Sce_PodData,
    which is persistence oriented, this will cause the Sce_PodData object's property 
    information to be saved in our store.

Virtual:
    
    Yes.
    
Arguments:

    pInst - COM interface pointer to the WMI class (Sce_PodData) object.

    pHandler - COM interface pointer for notifying WMI of any events.

    pCtx - COM interface pointer. This interface is just something we pass around.
            WMI may mandate it (not now) in the future. But we never construct
            such an interface and so, we just pass around for various WMI API's

Return Value:

    Success: it must return success code (use SUCCEEDED to test). It is
    not guaranteed to return WBEM_NO_ERROR.

    Failure: Various errors may occurs. Any such error should indicate the failure of persisting
    the instance.

Notes:
    Since GetProperty will return a success code (WBEM_S_RESET_TO_DEFAULT) when the
    requested property is not present, don't simply use SUCCEEDED or FAILED macros
    to test for the result of retrieving a property.

*/

HRESULT 
CPodData::PutInst (
    IN IWbemClassObject     * pInst, 
    IN IWbemObjectSink      * pHandler,
    IN IWbemContext         * pCtx
    )
{
    //
    // this property manager will help us gain access to the properties of the WMI object
    //

    CScePropertyMgr ScePropMgr;

    //
    // This property manager is for this object (pInst) only! 
    // Will always succeed
    //

    ScePropMgr.Attach(pInst);

    //
    // The store is used to persist the information. Since
    // we have a whole bunch of goto's, we are forced to define
    // the store here.
    //

    CSceStore SceStore;

    //
    // we manage the memory of this variable. need to free it
    //

    LPWSTR pszSectionName = NULL;
    
    // the memory for these bstrs are automatically managed by the CComBSTR class
    CComBSTR bstrPodID;
    CComBSTR bstrPodSuffix;
    CComBSTR bstrKey;
    CComBSTR bstrValue;

    //
    // we consider each property of the Sce_PodData non-optional.
    // For the entire duration of this save action, if missing property
    // will thus cause us to quit
    //

    HRESULT hr = ScePropMgr.GetProperty(pPodID, &bstrPodID);
    if (FAILED(hr) || hr == WBEM_S_RESET_TO_DEFAULT)
    {
        goto CleanUp;
    }

    hr = ScePropMgr.GetProperty(pPodSection, &bstrPodSuffix);
    if (FAILED(hr) || hr == WBEM_S_RESET_TO_DEFAULT)
    {
        goto CleanUp;
    }

    hr = ValidatePodID(bstrPodID);
    if (FAILED(hr))
    {
        goto CleanUp;
    }

    hr = ScePropMgr.GetProperty(pKey, &bstrKey);
    if (FAILED(hr) || hr == WBEM_S_RESET_TO_DEFAULT)
    {
        goto CleanUp;
    }

    hr = ScePropMgr.GetProperty(pValue, &bstrValue);
    if (FAILED(hr) || hr == WBEM_S_RESET_TO_DEFAULT)
    {
        goto CleanUp;
    }

    //
    // now build the section name
    //

    pszSectionName = new WCHAR[wcslen(bstrPodID) + wcslen(bstrPodSuffix) + 2];
    if ( NULL == pszSectionName ) 
    { 
        hr = WBEM_E_OUT_OF_MEMORY;
        goto CleanUp;
    }

    //
    // this won't overrun the buffer. See the size allocated above
    //

    wcscpy(pszSectionName, bstrPodID); 
    wcscat(pszSectionName, L"_");
    wcscat(pszSectionName, bstrPodSuffix);

    //
    // Attach the WMI object instance to the store and let the store know that
    // it's store is given by the pStorePath property of the instance.
    //

    hr = SceStore.SetPersistProperties(pInst, pStorePath);

    if (SUCCEEDED(hr))
    {
        hr = SceStore.SavePropertyToStore(pszSectionName, bstrKey, bstrValue);
    }

CleanUp:

    //
    // We consider the object invalid if there is any missing property.
    //

    if (hr == WBEM_S_RESET_TO_DEFAULT)
    {
        hr = WBEM_E_INVALID_OBJECT;
    }

    delete [] pszSectionName;
    return hr;
}

/*
Routine Description: 

Name:

    CPodData::ConstructInstance

Functionality:
    
    This is private function to create an instance of Sce_PodData.

Virtual:
    
    No.
    
Arguments:

    pHandler        - COM interface pointer for notifying WMI of any events.

    pSceStore       - Pointer to our store. It must have been appropriately set up.

    wszLogStorePath - store path, a key property of Sce_PodData class.

    wszPodID        - a corresponding key property of Sce_PodData class.

    wszSection      - another corresponding property of the Sce_PodData class.

    wszKey          - another corresponding property of the Sce_PodData class.

    bPostFilter     - Controls how WMI will be informed with pHandler->SetStatus.

Return Value:

    Success: it must return success code (use SUCCEEDED to test). It is
    not guaranteed to return WBEM_NO_ERROR.

    Failure: Various errors may occurs. Any such error should indicate the creating the instance.

Notes:

*/

HRESULT 
CPodData::ConstructInstance (
    IN IWbemObjectSink  * pHandler,
    IN CSceStore        * pSceStore,
    IN LPCWSTR            wszLogStorePath,
    IN LPCWSTR            wszPodID,
    IN LPCWSTR            wszSection,
    IN LPCWSTR            wszKey,
    IN BOOL               bPostFilter
    )
{

    HRESULT hr=WBEM_S_NO_ERROR;
    SCESTATUS rc;

    hr = ValidatePodID(wszPodID);
    if ( FAILED(hr) ) 
    {
        return hr;
    }

    //
    // we need to construct a more complicated section name based on the wszPodID and wszSection.
    //

    PWSTR wszSectionName = new WCHAR[wcslen(wszPodID) + wcslen(wszSection) + 2];
    if ( !wszSectionName ) 
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    //
    // this won't overrun the buffer. See the size allocated above
    //

    wcscpy(wszSectionName, wszPodID); 
    wcscat(wszSectionName, L"_");
    wcscat(wszSectionName, wszSection);

    //
    // this will hold the information read by Sce 
    //

    PSCESVC_CONFIGURATION_INFO pPodInfo=NULL;

    //
    // wszValue's memory is very strangely obtained. Be aware.
    // (1) When the information is from INF file, the wszValue points
    // to a memory already managed by pPodInfo. Hence, its release
    // is done by the release of pPodInfo.
    // (2) When the information is from a database, then we need to 
    // release the memory pointed to by wszValue.
    //

    PWSTR wszValue=NULL;
    DWORD dwValueLen=0;

    if ( pSceStore->GetStoreType() == SCE_INF_FORMAT ) 
    {
        //
        // ask SCE to read the information
        //

        rc = SceSvcGetInformationTemplate(pSceStore->GetExpandedPath(),
                                        wszSectionName,
                                        wszKey,
                                        &pPodInfo
                                        );

        //
        // SCE returned errors needs to be translated to HRESULT.
        // In case this is not an error, hr will be assigned to WBEM_NO_ERROR
        //

        hr = ProvDosErrorToWbemError(ProvSceStatusToDosError(rc));

        if (rc == SCESTATUS_SUCCESS && pPodInfo && pPodInfo->Lines ) {
                wszValue = pPodInfo->Lines[0].Value; 
                dwValueLen = pPodInfo->Lines[0].ValueLen;
        }
    } 
    else 
    {
        //
        // get information from the database
        //

        PVOID hProfile=NULL;

        rc = SceOpenProfile(pSceStore->GetExpandedPath(), SCE_JET_FORMAT, &hProfile);

        if ( SCESTATUS_SUCCESS == rc ) {
            rc = SceGetDatabaseSetting(
                                       hProfile,
                                       SCE_ENGINE_SMP,
                                       (PWSTR)wszSectionName,
                                       (PWSTR)wszKey,
                                       &wszValue, 
                                       &dwValueLen
                                      );

            SceCloseProfile(&hProfile);
        }

        //
        // SCE returned errors needs to be translated to HRESULT.
        // In case this is not an error, hr will be assigned to WBEM_NO_ERROR
        //

        hr = ProvDosErrorToWbemError(ProvSceStatusToDosError(rc));
    }

    if ( SUCCEEDED(hr) ) 
    {

        CComBSTR bstrLogOut;
        hr = MakeSingleBackSlashPath(wszLogStorePath, L'\\', &bstrLogOut);
        if ( FAILED(hr) )
        {
            goto CleanUp;
        }

        hr = PutPodDataInstance(pHandler,
                                bstrLogOut,
                                wszPodID,
                                wszSection,
                                wszKey,
                                wszValue,
                                bPostFilter
                               );
    }

CleanUp:

    //
    // only Sce knows how to free a PSCESVC_CONFIGURATION_INFO
    //

    if ( pPodInfo ) 
    {
        SceSvcFree(pPodInfo);
    }

    delete [] wszSectionName;

    if ( pSceStore->GetStoreType() != SCE_INF_FORMAT && wszValue ) 
    {
        ::LocalFree(wszValue);
    }

    return hr;
}

/*
Routine Description: 

Name:

    CPodData::DeleteInstance

Functionality:
    
    remove an instance of Sce_PodData from the specified store.

Virtual:
    
    No.
    
Arguments:

    pSceStore   - Pointer to our store. It must have been appropriately set up.

    wszPodID    - a corresponding key property of Sce_PodData class.

    wszSection  - another corresponding property of the Sce_PodData class.

    wszKey      - another corresponding property of the Sce_PodData class.

Return Value:

    Success: it must return success code (use SUCCEEDED to test). It is
    not guaranteed to return WBEM_NO_ERROR.

    Failure: Various errors may occurs. Any such error should indicate the operation is not carried out

Notes:

*/

HRESULT 
CPodData::DeleteInstance (
    IN CSceStore   * pSceStore,
    IN LPCWSTR       wszPodID,
    IN LPCWSTR       wszSection,
    IN LPCWSTR       wszKey
    )
{
    HRESULT hr = WBEM_S_NO_ERROR;

    hr = ValidatePodID(wszPodID);

    if ( FAILED(hr) ) 
    {
        return hr;
    }

    //
    // Our store needs a section name. But for Sce_PodData, the store section name
    // is composed by the supplied section name and the PodID.
    // Don't forget to free the memory!
    //

    PWSTR wszSectionName = new WCHAR[wcslen(wszPodID) + wcslen(wszSection) + 2];
    if ( !wszSectionName ) 
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    //
    // this won't overrun the buffer. See the size allocated above
    // Real composition happens here: the store's section name is wszPodID_wszSection
    //

    wcscpy(wszSectionName, wszPodID); 
    wcscat(wszSectionName, L"_");
    wcscat(wszSectionName, wszSection);

    hr = pSceStore->DeletePropertyFromStore(wszSectionName, wszKey);

    delete [] wszSectionName;

    return hr;
}

/*
Routine Description: 

Name:

    CPodData::ConstructQueryInstances

Functionality:
    
    Querying instances of Sce_PodData whose key properties meet the specified parameters.

Virtual:
    
    No.
    
Arguments:

    pHandler    - COM interface pointer used to notify WMI when instances are created.

    pSceStore   - Pointer to our store. It must have been appropriately set up.

    wszLogStorePath - Log's store path.

    wszPodID    - may be NULL.

    wszSection  - may be NULL.

    bPostFilter - 

Return Value:

    Success: it must return success code (use SUCCEEDED to test). It is
    not guaranteed to return WBEM_NO_ERROR.

    Failure: Various errors may occurs. Any such error should indicate the operation is not carried out

Notes:

*/

HRESULT 
CPodData::ConstructQueryInstances (
    IWbemObjectSink * pHandler,
    CSceStore       * pSceStore,
    LPCWSTR           wszLogStorePath,
    LPCWSTR           wszPodID,
    LPCWSTR           wszSection,
    BOOL              bPostFilter
    )
{
    // 
    // make sure that we have a valid store
    //

    if ( pSceStore == NULL ||
         pSceStore->GetStoreType() < SCE_INF_FORMAT ||
         pSceStore->GetStoreType() > SCE_JET_ANALYSIS_REQUIRED ) 
    {

        return WBEM_E_INVALID_PARAMETER;
    }

    //
    // we can't do anything if we don't have pszPodID or wszSection
    //

    if (wszPodID == NULL || wszSection == NULL)
    {
        return WBEM_E_NOT_SUPPORTED;
    }

    HRESULT hr=WBEM_S_NO_ERROR;
    SCESTATUS rc;

    PSCESVC_CONFIGURATION_INFO pPodInfo=NULL;
    LPWSTR wszSectionName = NULL;
    PVOID hProfile=NULL;
    CComBSTR bstrLogOut;
    LPWSTR pszNewValue=NULL;

    try {

        hr = ValidatePodID(wszPodID);
        if ( FAILED(hr) ) 
        {
            return hr;
        }

        //
        // build section name for the POD
        //

        wszSectionName = new WCHAR[wcslen(wszPodID) + wcslen(wszSection) + 2];

        if ( !wszSectionName ) 
        {
            return WBEM_E_OUT_OF_MEMORY;
        }

        //
        // this won't overrun the buffer. See the size allocated above
        //

        wcscpy(wszSectionName, wszPodID); 
        wcscat(wszSectionName, L"_");
        wcscat(wszSectionName, wszSection);

        DWORD i;

        hr = MakeSingleBackSlashPath(wszLogStorePath, L'\\', &bstrLogOut);

        if ( FAILED(hr) )
        {
            goto CleanUp;
        }

        if ( pSceStore->GetStoreType() == SCE_INF_FORMAT ) {

            //
            // INF template, query info
            //

            rc = SceSvcGetInformationTemplate(pSceStore->GetExpandedPath(),
                                            wszSectionName,
                                            NULL,
                                            &pPodInfo
                                            );

            //
            // SCE returned errors needs to be translated to HRESULT.
            // In case this is not an error, hr will be assigned to WBEM_NO_ERROR
            //

            hr = ProvDosErrorToWbemError(ProvSceStatusToDosError(rc));

            if ( SUCCEEDED(hr) ) 
            {
                if ( !pPodInfo || pPodInfo->Count == 0 || pPodInfo->Lines == NULL )
                {
                    hr = WBEM_E_NOT_FOUND;
                }
            }

            if ( SUCCEEDED(hr) ) {
                for ( i=0; SUCCEEDED(hr) && i<pPodInfo->Count; i++ ) {

                    //
                    // create instance for each one
                    //
                    // since this PSCESVC_CONFIGURATION_INFO is from INF template, pPodInfo->Lines[i].Value
                    // is guaranteed to be 0 terminated. See comments of next block about using pPodInfo->Lines[i].Value.
                    //

                    hr = PutPodDataInstance(pHandler,
                                            bstrLogOut,
                                            wszPodID,
                                            wszSection,
                                            pPodInfo->Lines[i].Key,
                                            pPodInfo->Lines[i].Value,
                                            bPostFilter
                                           );
                }
            }

        } else {

            //
            // get information from the database
            //

            rc = SceOpenProfile(pSceStore->GetExpandedPath(), SCE_JET_FORMAT, &hProfile);

            if ( SCESTATUS_SUCCESS == rc ) {

                SCEP_HANDLE scepHandle;
                scepHandle.hProfile = hProfile;
                scepHandle.SectionName = wszSectionName;

                SCE_ENUMERATION_CONTEXT EnumHandle=0;
                DWORD CountReturned;

                do {

                    //
                    // enumerate the info
                    //

                    CountReturned = 0;

                    rc = SceSvcQueryInfo((SCE_HANDLE)&scepHandle,
                                         SceSvcConfigurationInfo,
                                         NULL,
                                         FALSE,
                                         (PVOID *)&pPodInfo,
                                         &EnumHandle
                                        );
                    //
                    // SCE returned errors needs to be translated to HRESULT.
                    // In case this is not an error, hr will be assigned to WBEM_NO_ERROR
                    //

                    hr = ProvDosErrorToWbemError(ProvSceStatusToDosError(rc));

                    if ( SUCCEEDED(hr) ) {
                        if ( !pPodInfo || pPodInfo->Count == 0 || pPodInfo->Lines == NULL )
                        {
                            hr = WBEM_E_NOT_FOUND;
                        }
                    }

                    if ( SUCCEEDED(hr) ) {

                        //
                        // got something
                        //

                        CountReturned = pPodInfo->Count;

                        for ( i=0; SUCCEEDED(hr) && i<pPodInfo->Count; i++ ) {

                            //
                            // create instance for each one
                            //
                            // pPodInfo->Lines[i].Value may not be 0 terminated
                            // pPodInfo->Lines[i].ValueLen is the BYTE size of the buffer pPodInfo->Lines[i].Value
                            //

                            LPWSTR pNewVal = new WCHAR[pPodInfo->Lines[i].ValueLen/2 + 1];

                            if (pNewVal != NULL)
                            {
                                memcpy(pNewVal, pPodInfo->Lines[i].Value, pPodInfo->Lines[i].ValueLen);
                                pNewVal[pPodInfo->Lines[i].ValueLen/2] = L'\0';

                                hr = PutPodDataInstance(pHandler,
                                                    bstrLogOut,
                                                    wszPodID,
                                                    wszSection,
                                                    pPodInfo->Lines[i].Key,
                                                    pNewVal,
                                                    bPostFilter
                                                   );
                                delete [] pNewVal;
                            }
                            else
                            {
                                hr = WBEM_E_OUT_OF_MEMORY;
                            }
                        }
                    }

                    if ( pPodInfo ) {
                        SceSvcFree(pPodInfo);
                        pPodInfo = NULL;
                    }

                } while ( SUCCEEDED(hr) && CountReturned >= SCESVC_ENUMERATION_MAX );

                SceCloseProfile(&hProfile);

            } else {

                //
                // SCE returned errors needs to be translated to HRESULT.
                // In case this is not an error, hr will be assigned to WBEM_NO_ERROR
                //

                hr = ProvDosErrorToWbemError(ProvSceStatusToDosError(rc));
            }

        }

    }
    catch(...)
    {
    }

CleanUp:

    if (hProfile)
    {
        SceCloseProfile(&hProfile);
    }

    if ( pPodInfo )
    {
        SceSvcFree(pPodInfo);
    }

    delete [] wszSectionName;

    return hr;
}

/*
Routine Description: 

Name:

    CPodData::ValidatePodID

Functionality:
    
    validate the PodID with registered Pods.

Virtual:
    
    No.
    
Arguments:

    wszPodID    - string representing the Pod ID to be verified.

Return Value:

    Success: it must return success code (use SUCCEEDED to test). It is
    not guaranteed to return WBEM_NO_ERROR.

    Failure: Various errors may occurs:
        (1) WBEM_E_NOT_FOUND if we successfully carry out the validation task and confirmed
            that we don't recognize the pod ID.
        (2) Other errors means that we can't carry out the validation at all. This doesn't mean
            that the Pod ID is invalid. It's just that the means to verify is not available.

Notes:
*/

HRESULT 
CPodData::ValidatePodID (
    LPCWSTR     wszPodID
    )
{
    //
    // no namespace means no access to WMI
    //

    if ( m_srpNamespace == NULL ) 
    {
        return WBEM_E_CRITICAL_ERROR;
    }

    if ( wszPodID == NULL ) 
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    //
    // we will create a "select" query and ask WMI to return the pods
    //

    DWORD Len = wcslen(wszPodID);

    //
    // pQuery has an open quote that needs to be matched (and closed)
    //

    LPCWSTR pQuery = L"SELECT * FROM Sce_Pod WHERE PodID=\"";

    //
    // we need two extra WCHAR: one for the encloding quote, and other for the 0 terminator
    //

    LPWSTR pszQuery= new WCHAR[Len + wcslen(pQuery) + 2];
    if ( pszQuery == NULL ) 
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    //
    // no danger of overrun the buffer. See the size allocated above
    // Compose the query by appending the pod ID and the ending quote
    //

    wcscpy(pszQuery, pQuery);
    wcscat(pszQuery, wszPodID);
    wcscat(pszQuery, L"\"");

    //
    // Ask WMI to return all Pods. ExecQuery returns a enumerator.
    //

    CComPtr<IEnumWbemClassObject> srpEnum;

    HRESULT hr = m_srpNamespace->ExecQuery(L"WQL",
                               pszQuery,
                               WBEM_FLAG_RETURN_IMMEDIATELY | WBEM_FLAG_FORWARD_ONLY,
                               NULL,
                               &srpEnum);

    if (SUCCEEDED(hr))
    {
        //
        // should only get one instance because we are given its key (PodID)
        //

        CComPtr<IWbemClassObject> srpObj;
        ULONG n = 0;

        //
        // srpEnum->Next will return WBEM_NO_ERROR together with the WMI object
        // and a count (n) > 0. We only ask for 1 instance.
        //

        hr = srpEnum->Next(WBEM_INFINITE, 1, &srpObj, &n);

        if ( hr == WBEM_S_FALSE ) 
        {
            hr = WBEM_E_NOT_FOUND;   // not find any
        }

        if (SUCCEEDED(hr))
        {
            if (n > 0)
            {
                //
                // find the instance
                //
            } 
            else 
            {
                hr = WBEM_E_NOT_FOUND;
            }
        }
    }

    delete [] pszQuery;

    return hr;
}

/*
Routine Description: 

Name:

    CPodData::PutPodDataInstance

Functionality:
    
    With all the properties of a Sce_PodData, this function just creates a new
    instance and populate the properties and then hand it back to WMI.

Virtual:
    
    No.
    
Arguments:

    pHandler        - COM interface pointer for notifying WMI of any events.

    wszStoreName    - store path, a key property of Sce_PodData class.

    wszPodID        - a corresponding key property of Sce_PodData class.

    wszSection      - another corresponding property of the Sce_PodData class.

    wszKey          - another corresponding property of the Sce_PodData class.

    wszValue        - The payload of the Sce_PodData class, where the information really is.

    bPostFilter     - Controls how WMI will be informed with pHandler->SetStatus.

Return Value:

    Success: it must return success code (use SUCCEEDED to test). It is
    not guaranteed to return WBEM_NO_ERROR.

    Failure: Various errors may occurs. Any error indicates the failure to create the instance.

Notes:
*/

HRESULT 
CPodData::PutPodDataInstance (
    IN IWbemObjectSink * pHandler,
    IN LPCWSTR           wszStoreName,
    IN LPCWSTR           wszPodID,
    IN LPCWSTR           wszSection,
    IN LPCWSTR           wszKey,
    IN LPCWSTR           wszValue,
    IN BOOL              bPostFilter
    )
{
    HRESULT hr = WBEM_S_NO_ERROR;

    //
    // need a blank instance that can be used to fill in properties
    //

    CComPtr<IWbemClassObject> srpObj;
    if (SUCCEEDED(hr = SpawnAnInstance(&srpObj)))
    {
        CScePropertyMgr ScePropMgr;
        ScePropMgr.Attach(srpObj);

        //
        // the property fillup is repeatitive and boring. here we use two arrays
        // (pszProperties is the property names, and pszValues the the values of
        // the corresponding properties)
        //

        LPCWSTR pszProperties[] = {pStorePath,      pPodID,     pPodSection,    pKey,   pValue};
        LPCWSTR pszValues[]     = {wszStoreName,    wszPodID,   wszSection,     wszKey, wszValue};

        // 
        // SCEPROV_SIZEOF_ARRAY is a macro that returns the array's size
        //
        
        for (int i = 0; i < SCEPROV_SIZEOF_ARRAY(pszProperties); i++)
        {
            if (FAILED(hr = ScePropMgr.PutProperty(pszProperties[i], pszValues[i])))
            {
                return hr;
            }
        }

        //
        // do the necessary gestures to WMI.
        // the use of WBEM_STATUS_REQUIREMENTS in SetStatus is not documented by WMI
        // at this point. Consult WMI team for detail if you suspect problems with
        // the use of WBEM_STATUS_REQUIREMENTS
        //

        hr = pHandler->SetStatus(WBEM_STATUS_REQUIREMENTS, (bPostFilter ? S_OK : S_FALSE), NULL, NULL);

        //
        // give the new instance to WMI
        //

        if (SUCCEEDED(hr))
        {
            hr = pHandler->Indicate(1, &srpObj);
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\scerpc\escprov\attachment.h ===
// attachment.h: interface for the CAttachmentData class.
//
// Copyright (c)1997-1999 Microsoft Corporation
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_ATTACHMENT_H__BD7570F7_9F0E_4C6B_B525_E078691B6D0E__INCLUDED_)
#define AFX_ATTACHMENT_H__BD7570F7_9F0E_4C6B_B525_E078691B6D0E__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "GenericClass.h"

/*

Class description
    
    Naming: 

        CPodData stands for a Pod of Data.
    
    Base class: 
        
        CGenericClass, because it is a class representing a WMI  
        object - its WMI class name is Sce_PodData
    
    Purpose of class:

        (1) Sce_PodData is one of the extension models we hope to establish so that
            other providers can deposit their object information into our store.
            Basically, we give other providers a payload member called "Value" where
            they package their data in a string. See class definition in sceprov.mof.

        (2) This is not in active use as our extension model. The biggest problem
            with this model is that we force other providers to do: (a) their instance
            must become store-oriented - PutInstance really means to persist the object.
            That is not most providers do. (b) they have to come up with a three of the
            four key properties (section, pod id, and key). It's challenging for them
            to do this because together with the store path, these four properties must
            form the key of the instance. (c) they have to pacakge their data into one
            string.
    
    Design:

        (1) it implements all pure virtual functions declared in CGenericClass
            so that it is a concrete class to create.
        (2) Since it has virtual functions, the desctructor should be virtual.
    
    Use:

        (1) We probably will never directly use this class. All its use is driven by
            CGenericClass's interface (its virtual functions).

*/

class CPodData : public CGenericClass
{
public:
        CPodData(
                ISceKeyChain *pKeyChain, 
                IWbemServices *pNamespace, 
                IWbemContext *pCtx = NULL
                );

        virtual ~CPodData();

        virtual HRESULT PutInst(
                                IWbemClassObject *pInst, 
                                IWbemObjectSink *pHandler, 
                                IWbemContext *pCtx
                                );

        virtual HRESULT CreateObject(
                                    IWbemObjectSink *pHandler, 
                                    ACTIONTYPE atAction
                                    );

private:
        HRESULT ConstructInstance(
                                  IWbemObjectSink   * pHandler,
                                  CSceStore         * pSceStore,
                                  LPCWSTR             wszLogStorePath,
                                  LPCWSTR             wszPodID,
                                  LPCWSTR             wszSection,
                                  LPCWSTR             wszKey, 
                                  BOOL                bPostFilter
                                  );

        HRESULT DeleteInstance(
                               CSceStore* pSceStore,
                               LPCWSTR wszPodID,
                               LPCWSTR wszSection,
                               LPCWSTR wszKey
                               );

        HRESULT ValidatePodID(LPCWSTR wszPodID);

        HRESULT ConstructQueryInstances(
                                        IWbemObjectSink *pHandler,
                                        CSceStore* pSceStore, 
                                        LPCWSTR wszLogStorePath, 
                                        LPCWSTR wszPodID,
                                        LPCWSTR wszSection, 
                                        BOOL bPostFilter
                                        );

        HRESULT PutPodDataInstance(
                                   IWbemObjectSink *pHandler, 
                                   LPCWSTR wszStoreName,
                                   LPCWSTR wszPodID,
                                   LPCWSTR wszSection,
                                   LPCWSTR wszKey,
                                   LPCWSTR wszValue, 
                                   BOOL bPostFilter
                                   );

};

#endif // !defined(AFX_ATTACHMENT_H__BD7570F7_9F0E_4C6B_B525_E078691B6D0E__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\scerpc\escprov\audit.cpp ===
// audit.cpp: implementation of the CAuditSettings class.
//
// Copyright (c)1997-1999 Microsoft Corporation
//
//////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "audit.h"
#include "persistmgr.h"
#include <io.h>
#include "requestobject.h"

/*
Routine Description: 

Name:

    CAuditSettings::CAuditSettings

Functionality:

    This is the constructor. Pass along the parameters to the base class

Virtual:
    
    No (you know that, constructor won't be virtual!)

Arguments:

    pKeyChain - Pointer to the ISceKeyChain COM interface which is prepared
        by the caller who constructs this instance.

    pNamespace - Pointer to WMI namespace of our provider (COM interface).
        Passed along by the caller. Must not be NULL.

    pCtx - Pointer to WMI context object (COM interface). Passed along
        by the caller. It's up to WMI whether this interface pointer is NULL or not.

Return Value:

    None as any constructor

Notes:
    if you create any local members, think about initialize them here

*/

CAuditSettings::CAuditSettings (
    IN ISceKeyChain *pKeyChain, 
    IN IWbemServices *pNamespace,
    IN IWbemContext *pCtx
    )
    :
    CGenericClass(pKeyChain, pNamespace, pCtx)
{
}

/*
Routine Description: 

Name:

    CAuditSettings::~CAuditSettings

Functionality:
    
    Destructor. Necessary as good C++ discipline since we have virtual functions.

Virtual:
    
    Yes.
    
Arguments:

    none as any destructor

Return Value:

    None as any destructor

Notes:
    if you create any local members, think about whether
    there is any need for a non-trivial destructor

*/
    
CAuditSettings::~CAuditSettings()
{
}

/*
Routine Description: 

Name:

    CAuditSettings::CreateObject

Functionality:
    
    Create WMI objects (Sce_AuditPolicy). Depending on parameter atAction,
    this creation may mean:
        (a) Get a single instance (atAction == ACTIONTYPE_GET)
        (b) Get several instances satisfying some criteria (atAction == ACTIONTYPE_QUERY)
        (c) Delete an instance (atAction == ACTIONTYPE_DELETE)

Virtual:
    
    Yes.
    
Arguments:

    pHandler - COM interface pointer for notifying WMI for creation result.
    atAction -  Get single instance ACTIONTYPE_GET
                Get several instances ACTIONTYPE_QUERY
                Delete a single instance ACTIONTYPE_DELETE

Return Value:

    Success: it must return success code (use SUCCEEDED to test). It is
    not guaranteed to return WBEM_NO_ERROR. The returned objects are indicated to WMI,
    not directly passed back via parameters.

    Failure: Various errors may occurs. Except WBEM_E_NOT_FOUND, any such error should indicate 
    the failure of getting the wanted instance. If WBEM_E_NOT_FOUND is returned in querying
    situations, this may not be an error depending on caller's intention.

Notes:

*/

HRESULT
CAuditSettings::CreateObject (
    IN IWbemObjectSink * pHandler, 
    IN ACTIONTYPE        atAction
    )
{
    // 
    // we know how to:
    //      Get single instance ACTIONTYPE_GET
    //      Delete a single instance ACTIONTYPE_DELETE
    //      Get several instances ACTIONTYPE_QUERY
    //

    if ( ACTIONTYPE_GET != atAction &&
         ACTIONTYPE_DELETE != atAction &&
         ACTIONTYPE_QUERY != atAction ) {

        return WBEM_E_NOT_SUPPORTED;
    }

    //
    // We must have the pStorePath property because that is where
    // our instance is stored. 
    // m_srpKeyChain->GetKeyPropertyValue WBEM_S_FALSE if the key is not recognized
    // So, we need to test against WBEM_S_FALSE if the property is mandatory
    //

    CComVariant varStorePath;
    HRESULT hr = m_srpKeyChain->GetKeyPropertyValue(pStorePath, &varStorePath);

    if (SUCCEEDED(hr) && hr != WBEM_S_FALSE && varStorePath.vt == VT_BSTR)
    {
        //
        // we must also have category property unless we are querying
        //

        CComVariant varCategory;
        hr = m_srpKeyChain->GetKeyPropertyValue(pCategory, &varCategory);

        if (FAILED(hr))
        {
            return hr;
        }
        else if (hr == WBEM_S_FALSE && (ACTIONTYPE_QUERY != atAction) ) 
        {
            return WBEM_E_NOT_FOUND;
        }

        // 
        // prepare a store to read the properties
        //

        CSceStore SceStore;
        hr = SceStore.SetPersistPath(varStorePath.bstrVal);

        if ( SUCCEEDED(hr) ) {

            //
            // make sure the store (just a file) really exists. The raw path
            // may contain env variables, so we need the expanded path
            //

            DWORD dwAttrib = GetFileAttributes(SceStore.GetExpandedPath());

            if ( dwAttrib != -1 ) {

                //
                // this file exists
                //

                //
                // the key property count determines the post filter
                //

                BOOL bPostFilter=TRUE;
                DWORD dwCount = 0;
                m_srpKeyChain->GetKeyPropertyCount(&dwCount);

                //
                // if we have a valid category
                //

                if ( varCategory.vt == VT_BSTR && varCategory.bstrVal ) 
                {

                    if ( ACTIONTYPE_DELETE == atAction )
                    {
                        hr = DeleteInstance(pHandler, &SceStore,varCategory.bstrVal);
                    }
                    else 
                    {
                        if ( ACTIONTYPE_QUERY == atAction && dwCount == 2 ) 
                        {
                            bPostFilter = FALSE;
                        }
                        hr = ConstructInstance(pHandler, 
                                               &SceStore, 
                                               varStorePath.bstrVal, 
                                               (varStorePath.vt == VT_BSTR) ? varCategory.bstrVal : NULL, 
                                               bPostFilter);
                    }

                }
                
                //
                // if not valid category, we will do a query
                //

                else 
                {
                    if ( dwCount == 1 ) 
                    {
                        bPostFilter = FALSE;
                    }

                    //
                    // query support
                    //

                    hr = ConstructInstance(pHandler, &SceStore, varStorePath.bstrVal, NULL, bPostFilter);
                }

            } 
            else 
            {
                hr = WBEM_E_NOT_FOUND;
            }
        }
    }

    return hr;
}

/*
Routine Description: 

Name:

    CAuditSettings::PutInst

Functionality:
    
    Put an instance as instructed by WMI. Since this class implements Sce_AuditPolicy,
    which is persistence oriented, this will cause the Sce_AuditPolicy object's property 
    information to be saved in our store.

Virtual:
    
    Yes.
    
Arguments:

    pInst       - COM interface pointer to the WMI class (Sce_AuditPolicy) object.

    pHandler    - COM interface pointer for notifying WMI of any events.

    pCtx        - COM interface pointer. This interface is just something we pass around.
                  WMI may mandate it (not now) in the future. But we never construct
                  such an interface and so, we just pass around for various WMI API's

Return Value:

    Success: it must return success code (use SUCCEEDED to test). It is
    not guaranteed to return WBEM_NO_ERROR.

    Failure: Various errors may occurs. Any such error should indicate the failure of persisting
    the instance.

Notes:
    Since GetProperty will return a success code (WBEM_S_RESET_TO_DEFAULT) when the
    requested property is not present, don't simply use SUCCEEDED or FAILED macros
    to test for the result of retrieving a property.

*/

HRESULT 
CAuditSettings::PutInst (
    IN IWbemClassObject * pInst, 
    IN IWbemObjectSink  * pHandler,
    IN IWbemContext     * pCtx
    )
{
    HRESULT hr = WBEM_E_INVALID_PARAMETER;
    CComBSTR bstrCategory;
 
    DWORD *pAddress=NULL;
    bool bValue=FALSE;
    DWORD dwValue = 0;

    //
    // This is our store for saving information
    //

    CSceStore SceStore;

    //
    // this is our property manager for easy access to properties
    //

    CScePropertyMgr ScePropMgr;

    //
    // attach the property manager to this WMI object
    //

    ScePropMgr.Attach(pInst);

    //
    // the use of the macro SCE_PROV_IfErrorGotoCleanup cause
    // a "goto CleanUp;" with hr set to the return value from
    // the function (macro parameter)
    //

    //
    // we don't support an object without the category proeprty
    //

    SCE_PROV_IfErrorGotoCleanup(ScePropMgr.GetProperty(pCategory, &bstrCategory));

    //
    // check if the category is valid
    //

    SCE_PROV_IfErrorGotoCleanup(ValidateCategory(bstrCategory, NULL, &pAddress));

    //
    // We can tolerate the Success property to be missing. In that
    // case, we just don't set the bit (take it as FALSE)
    //

    SCE_PROV_IfErrorGotoCleanup(ScePropMgr.GetProperty(pSuccess, &bValue));
    if ( hr != WBEM_S_RESET_TO_DEFAULT) 
    {
        dwValue |= bValue ? SCE_AUDIT_EVENT_SUCCESS : 0;
    }

    //
    // we want to re-use bValue, set it to FALSE - our default
    //

    bValue = FALSE;

    //
    // We can tolerate the Failure property to be missing. In that
    // case, we just don't set the bit (take it as FALSE)
    //

    SCE_PROV_IfErrorGotoCleanup(ScePropMgr.GetProperty(pFailure, &bValue));
    if ( hr != WBEM_S_RESET_TO_DEFAULT) 
    {
        dwValue |= bValue? SCE_AUDIT_EVENT_FAILURE : 0;
    }

    //
    // Attach the WMI object instance to the store and let the store know that
    // it's store is given by the pStorePath property of the instance.
    //

    SceStore.SetPersistProperties(pInst, pStorePath);

    //
    // For a new .inf file. Write an empty buffer to the file
    // will creates the file with right header/signature/unicode format
    // this is harmless for existing files.
    // For database store, this is a no-op.
    //

    DWORD dwDump;
    hr = SceStore.WriteSecurityProfileInfo(
                                    AreaBogus,                      // a bogus area info
                                    (PSCE_PROFILE_INFO)&dwDump,     // a dump buffer
                                    NULL,
                                    false
                                    );

    //
    // now save the info to file
    //

    if (SUCCEEDED(hr))
    {
        hr = SceStore.SavePropertyToStore(
                                 szAuditEvent,
                                 bstrCategory,
                                 dwValue
                                );
    }

CleanUp:
    return hr;
}

/*
Routine Description: 

Name:

    CAuditSettings::ConstructInstance

Functionality:
    
    This is private function to create an instance of Sce_AuditPolicy.

Virtual:
    
    No.
    
Arguments:

    pHandler        - COM interface pointer for notifying WMI of any events.

    pSceStore       - Pointer to our store. It must have been appropriately set up.

    wszLogStorePath - store path, a key property of Sce_AuditPolicy class.

    wszCategory     - a property of Sce_AuditPolicy class.

    bPostFilter     - Controls how WMI will be informed with pHandler->SetStatus.

Return Value:

    Success: it must return success code (use SUCCEEDED to test). It is
    not guaranteed to return WBEM_NO_ERROR.

    Failure: Various errors may occurs. Any such error should indicate the creating the instance.

Notes:

*/
HRESULT 
CAuditSettings::ConstructInstance (
    IN IWbemObjectSink  * pHandler,
    IN CSceStore        * pSceStore,
    IN LPWSTR             wszLogStorePath,
    IN LPCWSTR            wszCategory       OPTIONAL,
    IN BOOL               bPostFilter
    )
{
    // 
    // make sure that our store is valid
    //

    if ( pSceStore == NULL || pSceStore->GetStoreType() < SCE_INF_FORMAT ||
         pSceStore->GetStoreType() > SCE_JET_ANALYSIS_REQUIRED ) {

        return WBEM_E_INVALID_PARAMETER;
    }

    //
    // ask SCE to read a gigantic structure out from the store. Only SCE
    // knows now to release the memory. Don't just delete it! Use our CSceStore
    // to do the releasing (FreeSecurityProfileInfo)
    //

    PSCE_PROFILE_INFO pInfo=NULL;
    HRESULT hr = pSceStore->GetSecurityProfileInfo(
                                   AREA_SECURITY_POLICY,
                                   &pInfo,
                                   NULL
                                   );

    if (SUCCEEDED(hr))
    {
        //
        // the use of the macro SCE_PROV_IfErrorGotoCleanup cause
        // a "goto CleanUp;" with hr set to the return value from
        // the function (macro parameter)
        //

        CComBSTR bstrLogOut;
        SCE_PROV_IfErrorGotoCleanup(MakeSingleBackSlashPath(wszLogStorePath, L'\\', &bstrLogOut));

        if ( wszCategory ) 
        {
            //
            // make sure that the category is valid
            //

            DWORD *pdwValue=NULL;
            SCE_PROV_IfErrorGotoCleanup(ValidateCategory(wszCategory, pInfo, &pdwValue));

            if ( *pdwValue == SCE_NO_VALUE )
            {
                goto CleanUp;
            }

            //
            // ask our helper to create it
            //

            hr = PutDataInstance(pHandler,
                                 bstrLogOut,
                                 wszCategory,
                                 *pdwValue,
                                 bPostFilter
                                 );

        } 
        else 
        {
            //
            // query support, create all instances for audit policy
            //

            if ( pInfo->AuditSystemEvents != SCE_NO_VALUE ) 
            {
                hr = PutDataInstance(pHandler,
                                    bstrLogOut,
                                    pwAuditSystemEvents,
                                    pInfo->AuditSystemEvents,
                                    bPostFilter
                                    );
            }

            if ( SUCCEEDED(hr) && pInfo->AuditLogonEvents != SCE_NO_VALUE ) 
            {
                hr = PutDataInstance(pHandler,
                                    bstrLogOut,
                                    pwAuditLogonEvents,
                                    pInfo->AuditLogonEvents,
                                    bPostFilter
                                    );
            }

            if ( SUCCEEDED(hr) && pInfo->AuditObjectAccess != SCE_NO_VALUE ) 
            {
                hr = PutDataInstance(pHandler,
                                    bstrLogOut,
                                    pwAuditObjectAccess,
                                    pInfo->AuditObjectAccess,
                                    bPostFilter
                                    );
            }

            if ( SUCCEEDED(hr) && pInfo->AuditPrivilegeUse != SCE_NO_VALUE ) 
            {
                hr = PutDataInstance(pHandler,
                                    bstrLogOut,
                                    pwAuditPrivilegeUse,
                                    pInfo->AuditPrivilegeUse,
                                    bPostFilter
                                    );
            }

            if ( SUCCEEDED(hr) && pInfo->AuditPolicyChange != SCE_NO_VALUE ) 
            {
                hr = PutDataInstance(pHandler,
                                    bstrLogOut,
                                    pwAuditPolicyChange,
                                    pInfo->AuditPolicyChange,
                                    bPostFilter
                                    );
            }

            if ( SUCCEEDED(hr) && pInfo->AuditAccountManage != SCE_NO_VALUE ) 
            {
                hr = PutDataInstance(pHandler,
                                    bstrLogOut,
                                    pwAuditAccountManage,
                                    pInfo->AuditAccountManage,
                                    bPostFilter
                                    );
            }

            if ( SUCCEEDED(hr) && pInfo->AuditProcessTracking != SCE_NO_VALUE ) 
            {
                hr = PutDataInstance(pHandler,
                                    bstrLogOut,
                                    pwAuditProcessTracking,
                                    pInfo->AuditProcessTracking,
                                    bPostFilter
                                    );
            }

            if ( SUCCEEDED(hr) && pInfo->AuditDSAccess != SCE_NO_VALUE ) 
            {
                hr = PutDataInstance(pHandler,
                                    bstrLogOut,
                                    pwAuditDSAccess,
                                    pInfo->AuditDSAccess,
                                    bPostFilter
                                    );
            }

            if ( SUCCEEDED(hr) && pInfo->AuditAccountLogon != SCE_NO_VALUE ) 
            {
                hr = PutDataInstance(pHandler,
                                    bstrLogOut,
                                    pwAuditAccountLogon,
                                    pInfo->AuditAccountLogon,
                                    bPostFilter
                                    );
            }
        }
    }

CleanUp:

    pSceStore->FreeSecurityProfileInfo(pInfo);

    return hr;
}

/*
Routine Description: 

Name:

    CAuditSettings::PutDataInstance

Functionality:
    
    With all the properties of a Sce_AuditPolicy, this function just creates a new
    instance and populate the properties and then hand it back to WMI.

Virtual:
    
    No.
    
Arguments:

    pHandler        - COM interface pointer for notifying WMI of any events.

    wszStoreName    - store path, a key property of Sce_AuditPolicy class.

    wszCategory     - a corresponding key property of Sce_AuditPolicy class.

    dwValue         - DWORD that encodes both other boolean members of
                      Sce_AuditPolicy: "Success" and "Failure".

    bPostFilter     - Controls how WMI will be informed with pHandler->SetStatus.

Return Value:

    Success: it must return success code (use SUCCEEDED to test). It is
    not guaranteed to return WBEM_NO_ERROR.

    Failure: Various errors may occurs. Any error indicates the failure to create the instance.

Notes:
*/

HRESULT 
CAuditSettings::PutDataInstance (
     IN IWbemObjectSink * pHandler,
     IN PWSTR             wszStoreName,
     IN PCWSTR            wszCategory,
     IN DWORD             dwValue,
     IN BOOL              bPostFilter
     )
{ 
    HRESULT hr=WBEM_S_NO_ERROR;

    CScePropertyMgr ScePropMgr;
    CComPtr<IWbemClassObject> srpObj;

    //
    // the use of the macro SCE_PROV_IfErrorGotoCleanup cause
    // a "goto CleanUp;" with hr set to the return value from
    // the function (macro parameter)
    //

    SCE_PROV_IfErrorGotoCleanup(SpawnAnInstance(&srpObj));

    ScePropMgr.Attach(srpObj);

    SCE_PROV_IfErrorGotoCleanup(ScePropMgr.PutProperty(pStorePath, wszStoreName));
    SCE_PROV_IfErrorGotoCleanup(ScePropMgr.PutProperty(pCategory,  wszCategory));

    SCE_PROV_IfErrorGotoCleanup(ScePropMgr.PutProperty(pSuccess, ( dwValue & SCE_AUDIT_EVENT_SUCCESS ) ? true : false));
    
    SCE_PROV_IfErrorGotoCleanup(ScePropMgr.PutProperty(pFailure, (dwValue & SCE_AUDIT_EVENT_FAILURE) ? true: false));

    //
    // do the necessary gestures to WMI.
    // the use of WBEM_STATUS_REQUIREMENTS in SetStatus is not documented by WMI
    // at this point. Consult WMI team for detail if you suspect problems with
    // the use of WBEM_STATUS_REQUIREMENTS
    //

    if ( !bPostFilter ) {
        pHandler->SetStatus(WBEM_STATUS_REQUIREMENTS, S_FALSE, NULL, NULL);
    } else {
        pHandler->SetStatus(WBEM_STATUS_REQUIREMENTS, S_OK, NULL, NULL);
    }

    //
    // pass the new instance to WMI
    //

    hr = pHandler->Indicate(1, &srpObj);

CleanUp:
    return hr;
}

/*
Routine Description: 

Name:

    CAuditSettings::DeleteInstance

Functionality:
    
    remove an instance of Sce_AuditPolicy from the specified store.

Virtual:
    
    No.
    
Arguments:

    pHandler    - COM interface pointer for notifying WMI of any events.

    pSceStore   - Pointer to our store. It must have been appropriately set up.

    wszCategory - a corresponding property of the Sce_AuditPolicy class.

Return Value:

    Success: it must return success code (use SUCCEEDED to test). It is
    not guaranteed to return WBEM_NO_ERROR.

    Failure: Various errors may occurs. Any such error should indicate the operation is not carried out

Notes:

*/

HRESULT 
CAuditSettings::DeleteInstance (
    IN IWbemObjectSink  * pHandler,
    IN CSceStore        * pSceStore,
    IN LPCWSTR            wszCategory
    )
{
    // 
    // make sure that we have a valid store
    //

    if ( pSceStore == NULL ||
         pSceStore->GetStoreType() < SCE_INF_FORMAT ||
         pSceStore->GetStoreType() > SCE_JET_ANALYSIS_REQUIRED ) {

        return WBEM_E_INVALID_PARAMETER;
    }

    //
    // our store knows how to delete
    //

    return pSceStore->SavePropertyToStore(szAuditEvent, wszCategory, (LPCWSTR)NULL);
}

/*
Routine Description: 

Name:

    CAuditSettings::ValidateCategory

Functionality:
    
    Validate the auditing category.

Virtual:
    
    No.
    
Arguments:

    wszCategory    - string representing category to be verified.

Return Value:

    Success: it must return WBEM_NO_ERROR if the category is recognized.

    Failure: Various errors may occurs:
        (1) WBEM_E_INVALID_PARAMETER if we successfully carry out the validation task and confirmed
            that we don't recognize the Category (wszCategory).
        (2) Other errors means that we can't carry out the validation at all. This doesn't mean
            that the category is invalid. It's just that the means to verify is not available.

Notes:
*/


HRESULT 
CAuditSettings::ValidateCategory (
    IN LPCWSTR              wszCategory,
    IN PSCE_PROFILE_INFO    pInfo        OPTIONAL,
    OUT DWORD            ** pReturn
    )
{

    if ( wszCategory == NULL || pReturn == NULL ) 
    {
        return WBEM_E_INVALID_PARAMETER;
    }
    else if ( pInfo == NULL )
    {
        *pReturn = NULL;
        return WBEM_NO_ERROR;
    }

    HRESULT hr = WBEM_NO_ERROR;    
    
    if ( _wcsicmp(wszCategory, pwAuditSystemEvents) == 0 ) 
    {
        *pReturn = &(pInfo->AuditSystemEvents);
    } 
    else if ( _wcsicmp(wszCategory, pwAuditLogonEvents) == 0 ) 
    {
        *pReturn = &(pInfo->AuditLogonEvents);

    } 
    else if ( _wcsicmp(wszCategory, pwAuditObjectAccess) == 0 ) 
    {
        *pReturn = &(pInfo->AuditObjectAccess);

    } 
    else if ( _wcsicmp(wszCategory, pwAuditPrivilegeUse) == 0 ) 
    {
        *pReturn = &(pInfo->AuditPrivilegeUse);

    } 
    else if ( _wcsicmp(wszCategory, pwAuditPolicyChange) == 0 ) 
    {
        *pReturn = &(pInfo->AuditPolicyChange);

    } 
    else if ( _wcsicmp(wszCategory, pwAuditAccountManage) == 0 ) 
    {
        *pReturn = &(pInfo->AuditAccountManage);

    } 
    else if ( _wcsicmp(wszCategory, pwAuditProcessTracking) == 0 ) 
    {
        *pReturn = &(pInfo->AuditProcessTracking);

    } 
    else if ( _wcsicmp(wszCategory, pwAuditDSAccess) == 0 ) 
    {
        *pReturn = &(pInfo->AuditDSAccess);

    } 
    else if ( _wcsicmp(wszCategory, pwAuditAccountLogon) == 0 ) 
    {
        *pReturn = &(pInfo->AuditAccountLogon);
    } 
    else 
    {
        *pReturn = NULL;
        hr = WBEM_E_INVALID_PARAMETER;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\scerpc\escprov\audit.h ===
// audit.h: interface for the CAuditSettings class.
//
// Copyright (c)1997-1999 Microsoft Corporation
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_AUDIT_H__BD7570F7_9F0E_4C6B_B525_E078691B6D0E__INCLUDED_)
#define AFX_AUDIT_H__BD7570F7_9F0E_4C6B_B525_E078691B6D0E__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "GenericClass.h"

/*

Class description
    
    Naming: 

        CAuditSettings stands for Audit Policy.
    
    Base class: 

        CGenericClass, because it is a class representing a WMI  
        object - its WMI class name is Sce_AuditPolicy
    
    Purpose of class:
        
        (1) implement support for our WMI class Sce_AuditPolicy.
    
    Design:

        (1) it implements all pure virtual functions declared in CGenericClass
            so that it is a concrete class to create.

        (2) Since it has virtual functions, the desctructor should be virtual.
    
    Use:

        (1) We probably will never directly use this class. All its use is driven by
            CGenericClass's interface (its virtual functions).

*/

class CAuditSettings : public CGenericClass
{
public:
        CAuditSettings(
                       ISceKeyChain *pKeyChain, 
                       IWbemServices *pNamespace, 
                       IWbemContext *pCtx = NULL
                       );

        virtual ~CAuditSettings();

        virtual HRESULT PutInst(
                                IWbemClassObject *pInst, 
                                IWbemObjectSink *pHandler, 
                                IWbemContext *pCtx
                                );

        virtual HRESULT CreateObject(
                                    IWbemObjectSink *pHandler, 
                                    ACTIONTYPE atAction
                                    );

private:

        HRESULT ConstructInstance(
                                  IWbemObjectSink *pHandler, 
                                  CSceStore* pSceStore, 
                                  LPWSTR wszLogStorePath, 
                                  LPCWSTR wszCategory, 
                                  BOOL bPostFilter 
                                  );

        HRESULT DeleteInstance(
                               IWbemObjectSink *pHandler,
                               CSceStore* pSceStore, 
                               LPCWSTR wszCategory 
                               );

        HRESULT ValidateCategory(
                                 LPCWSTR wszCategory, 
                                 PSCE_PROFILE_INFO pInfo, 
                                 DWORD **pReturn
                                 );

        HRESULT PutDataInstance(
                                IWbemObjectSink *pHandler,
                                PWSTR wszStoreName,
                                PCWSTR wszCategory,
                                DWORD dwValue, 
                                BOOL bPostFilter
                                );

};

#endif // !defined(AFX_AUDIT_H__BD7570F7_9F0E_4C6B_B525_E078691B6D0E__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\scerpc\escprov\database.h ===
// database.h: interface for the CSecurityDatabase class.
//
// Copyright (c)1997-1999 Microsoft Corporation
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_DATABASE_H__BD7570F7_9F0E_4C6B_B525_E078691B6D0E__INCLUDED_)
#define AFX_DATABASE_H__BD7570F7_9F0E_4C6B_B525_E078691B6D0E__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000


#include "GenericClass.h"
#define DMTFLEN 25

//
// helper
//

HRESULT GetDMTFTime(SYSTEMTIME t_SysTime, BSTR *bstrOut);


/*

Class description
    
    Naming: 
    
        CSecurityDatabase.
    
    Base class: 
    
        CGenericClass. 
    
    Purpose of class:
    
        (1) Implement Sce_Database WMI class.
    
    Design:
         
        (1) Almost trivial other than implementing necessary method as a concrete class
    
    Use:
        (1) Almost never used directly. Always through the common interface defined by
            CGenericClass.
    
    Original note:

        In V1, this class is provided strictly for query support.
        To create or otherwise work with data in a database, use one of the
        methods in the SCE_Operation class.

*/

class CSecurityDatabase : public CGenericClass
{
public:
        CSecurityDatabase(
                          ISceKeyChain *pKeyChain, 
                          IWbemServices *pNamespace, 
                          IWbemContext *pCtx = NULL
                          );

        virtual ~CSecurityDatabase();

        virtual HRESULT PutInst(
                                IWbemClassObject *pInst, 
                                IWbemObjectSink *pHandler, 
                                IWbemContext *pCtx
                                )
                {
                    return WBEM_E_NOT_SUPPORTED;
                }

        virtual HRESULT CreateObject(
                                     IWbemObjectSink *pHandler, 
                                     ACTIONTYPE atAction
                                     );

private:

        HRESULT ConstructInstance(
                                  IWbemObjectSink *pHandler,
                                  LPCWSTR wszDatabaseName, 
                                  LPCWSTR wszLogDatabasePath
                                  );

};

#endif // !defined(AFX_DATABASE_H__BD7570F7_9F0E_4C6B_B525_E078691B6D0E__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\scerpc\escprov\database.cpp ===
// database.cpp, implementation of CSecurityDatabase class
// Copyright (c)1997-1999 Microsoft Corporation
//
//////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "database.h"
#include "persistmgr.h"
//#include <io.h>
#include <time.h>
#include "requestobject.h"

const DWORD dwSecDBVersion = 1;

/*
Routine Description: 

Name:

    CSecurityDatabase::CSecurityDatabase

Functionality:

    This is the constructor. Pass along the parameters to the base class

Virtual:
    
    No (you know that, constructor won't be virtual!)

Arguments:

    pKeyChain - Pointer to the ISceKeyChain COM interface which is prepared
        by the caller who constructs this instance.

    pNamespace - Pointer to WMI namespace of our provider (COM interface).
        Passed along by the caller. Must not be NULL.

    pCtx - Pointer to WMI context object (COM interface). Passed along
        by the caller. It's up to WMI whether this interface pointer is NULL or not.

Return Value:

    None as any constructor

Notes:
    if you create any local members, think about initialize them here

*/

CSecurityDatabase::CSecurityDatabase (
    IN ISceKeyChain *pKeyChain, 
    IN IWbemServices *pNamespace,
    IN IWbemContext *pCtx
    )
    :
    CGenericClass(pKeyChain, pNamespace, pCtx)
{
}

/*
Routine Description: 

Name:

    CSecurityDatabase::~CSecurityDatabase

Functionality:
    
    Destructor. Necessary as good C++ discipline since we have virtual functions.

Virtual:
    
    Yes.
    
Arguments:

    none as any destructor

Return Value:

    None as any destructor

Notes:
    if you create any local members, think about whether
    there is any need for a non-trivial destructor

*/

CSecurityDatabase::~CSecurityDatabase ()
{
}

//Sce_Database
/*
Routine Description: 

Name:

    CSecurityDatabase::CreateObject

Functionality:
    
    Create WMI objects (Sce_Database). Depending on parameter atAction,
    this creation may mean:
        (a) Get a single instance (atAction == ACTIONTYPE_GET)
        (b) Get several instances satisfying some criteria (atAction == ACTIONTYPE_QUERY)

Virtual:
    
    Yes.
    
Arguments:

    pHandler - COM interface pointer for notifying WMI for creation result.
    atAction -  Get single instance ACTIONTYPE_GET
                Get several instances ACTIONTYPE_QUERY

Return Value:

    Success: it must return success code (use SUCCEEDED to test). It is
    not guaranteed to return WBEM_NO_ERROR. The returned objects are indicated to WMI,
    not directly passed back via parameters.

    Failure: Various errors may occurs. Except WBEM_E_NOT_FOUND, any such error should indicate 
    the failure of getting the wanted instance. If WBEM_E_NOT_FOUND is returned in querying
    situations, this may not be an error depending on caller's intention.

Notes:

    for Sce_Database, we don't support delete!

*/

HRESULT 
CSecurityDatabase::CreateObject (
    IN IWbemObjectSink *pHandler, 
    IN ACTIONTYPE atAction
    )
{
    // 
    // we know how to:
    //      Get single instance ACTIONTYPE_GET
    //      Get several instances ACTIONTYPE_QUERY
    //

    if ( ACTIONTYPE_GET != atAction &&
         ACTIONTYPE_QUERY != atAction ) {
        return WBEM_E_NOT_SUPPORTED;
    }

    //
    // Sce_Database class has only one key property (path)
    //

    DWORD dwCount = 0;
    HRESULT hr = m_srpKeyChain->GetKeyPropertyCount(&dwCount);

    if (SUCCEEDED(hr) && dwCount == 1)
    {
        //
        // We must have the pPath key property. 
        // m_srpKeyChain->GetKeyPropertyValue WBEM_S_FALSE if the key is not recognized
        // So, we need to test against WBEM_S_FALSE if the property is mandatory
        //

        CComVariant varPath;
        hr = m_srpKeyChain->GetKeyPropertyValue(pPath, &varPath);

        if (FAILED(hr) || hr == WBEM_S_FALSE) 
        {
            return WBEM_E_NOT_FOUND;
        }

        if (SUCCEEDED(hr) && hr != WBEM_S_FALSE && varPath.vt == VT_BSTR)
        {
            //
            // Create the database instance
            //


            //
            // expand those env variable tokens inside a path
            //

            CComBSTR bstrExpandedPath;

            //
            // bDb will be returned true if the the path is pointing to a database type file
            //

            BOOL bDb=FALSE;

            hr = CheckAndExpandPath(varPath.bstrVal, &bstrExpandedPath, &bDb);

            if ( !bDb ) 
            {
                hr = WBEM_E_INVALID_OBJECT_PATH;
            }
            else 
            {
                //
                // make sure the store (just a file) really exists
                //

                DWORD dwAttrib = GetFileAttributes(bstrExpandedPath);

                if ( dwAttrib != -1 ) 
                {
                    hr = ConstructInstance(pHandler, bstrExpandedPath, varPath.bstrVal);
                } 
                else 
                {
                    hr = WBEM_E_NOT_FOUND;
                }
            }
        }
    }
    else if (SUCCEEDED(hr))
    {
        //
        // the object says that it has more than one key properties,
        // we know that is incorrect
        //

        hr = WBEM_E_INVALID_OBJECT;
    }

    return hr;
}


/*
Routine Description: 

Name:

    CSecurityDatabase::ConstructInstance

Functionality:
    
    This is private function to create an instance of Sce_Database.

Virtual:
    
    No.
    
Arguments:

    pHandler            - COM interface pointer for notifying WMI of any events.

    wszDatabaseName     - file path to the database.

    wszLogDatabasePath  - Log path.

Return Value:

    Success: it must return success code (use SUCCEEDED to test). It is
    not guaranteed to return WBEM_NO_ERROR.

    Failure: Various errors may occurs. Any such error should indicate the creating the instance.

Notes:

*/

HRESULT 
CSecurityDatabase::ConstructInstance (
    IN IWbemObjectSink *pHandler,
    IN LPCWSTR wszDatabaseName,
    IN LPCWSTR wszLogDatabasePath
    )
{
    // Get information from the database
    // ==================

    HRESULT hr = WBEM_S_NO_ERROR;
    SCESTATUS rc;

    //
    // hProfile is where SCE reads info to
    //

    PVOID hProfile=NULL;

    rc = SceOpenProfile(wszDatabaseName, SCE_JET_FORMAT, &hProfile);
    if ( rc != SCESTATUS_SUCCESS ) 
    {
        //
        // SCE returned errors needs to be translated to HRESULT.
        //

        return ProvDosErrorToWbemError(ProvSceStatusToDosError(rc));
    }

    PWSTR wszDescription = NULL;

    SYSTEMTIME stConfig;
    SYSTEMTIME stAnalyze;

    CComBSTR bstrConfig;
    CComBSTR bstrAnalyze;

    //
    // need to free wszDescription
    //

    rc = SceGetScpProfileDescription(hProfile, &wszDescription);
    if ( SCESTATUS_SUCCESS == rc ) 
    {
        rc = SceGetDbTime(hProfile, &stConfig, &stAnalyze);
    }

    //
    // SCE returned errors needs to be translated to HRESULT.
    // In case this is not an error, hr will be assigned to WBEM_NO_ERROR
    //

    hr = ProvDosErrorToWbemError(ProvSceStatusToDosError(rc));

    SceCloseProfile( &hProfile );

    //
    // now log it
    //

    CComBSTR bstrLogOut;

    //
    // the use of the macro SCE_PROV_IfErrorGotoCleanup cause
    // a "goto CleanUp;" with hr set to the return value from
    // the function (macro parameter)
    //

    if ( SUCCEEDED(hr) ) 
    {
        SCE_PROV_IfErrorGotoCleanup(MakeSingleBackSlashPath((PWSTR)wszLogDatabasePath, L'\\', &bstrLogOut));

        //
        // convert the time stamp
        //

        SCE_PROV_IfErrorGotoCleanup(GetDMTFTime(stConfig, &bstrConfig));
        SCE_PROV_IfErrorGotoCleanup(GetDMTFTime(stAnalyze, &bstrAnalyze));

        //
        // create a blank object that can be filled with properties
        //

        CComPtr<IWbemClassObject> srpObj;
        SCE_PROV_IfErrorGotoCleanup(SpawnAnInstance(&srpObj));

        //
        // create a property mgr for this new object to put properties
        //

        CScePropertyMgr ScePropMgr;
        ScePropMgr.Attach(srpObj);

        //
        // put properties: path, description, analyze, and configuration
        //

        SCE_PROV_IfErrorGotoCleanup(ScePropMgr.PutProperty(pPath, bstrLogOut));
        
        SCE_PROV_IfErrorGotoCleanup(ScePropMgr.PutProperty(pDescription, wszDescription));

        if (bstrAnalyze)
        {
            SCE_PROV_IfErrorGotoCleanup(ScePropMgr.PutProperty(pLastAnalysis, bstrAnalyze));
        }

        if (bstrConfig)
        {
            SCE_PROV_IfErrorGotoCleanup(ScePropMgr.PutProperty(pLastConfiguration, bstrConfig));
        }

        //
        // put version
        //
        
        SCE_PROV_IfErrorGotoCleanup(ScePropMgr.PutProperty(pVersion, dwSecDBVersion));

        //
        // inform WMI of the new instance it requests
        //

        SCE_PROV_IfErrorGotoCleanup(pHandler->Indicate(1, &srpObj));
    }

CleanUp:

    delete [] wszDescription;

    return hr;
}

/*
Routine Description: 

Name:

    GetDMTFTime

Functionality:
    
    Helper to format a string version time stamp.

Virtual:
    
    No.
    
Arguments:

    t_Systime   - the system time to format.

    bstrOut     - out parameter to return the string version of the time.

Return Value:

    Success: WBEM_NO_ERROR.

    Failure: Various errors may occurs. Any such error should indicate failure to format.

Notes:

*/

HRESULT 
GetDMTFTime (
    IN SYSTEMTIME t_Systime, 
    IN BSTR *bstrOut
    )
{
    if ( !bstrOut ) 
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    *bstrOut = SysAllocStringLen(NULL, DMTFLEN + 1);

    if ( ! (*bstrOut) ) 
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    HRESULT hr = WBEM_NO_ERROR;

    FILETIME t_ft;
    LONG micros=0;

    if ( SystemTimeToFileTime(&t_Systime, &t_ft) ) 
    {
        ULONGLONG uTime=0;

        uTime = t_ft.dwHighDateTime;
        uTime = uTime << 32;
        uTime |= t_ft.dwLowDateTime;

        LONGLONG tmpMicros = uTime % 10000000;
        micros = (LONG)(tmpMicros / 10);
    }

    swprintf((*bstrOut),
        L"%04.4d%02.2d%02.2d%02.2d%02.2d%02.2d.%06.6d%c%03.3ld",
        t_Systime.wYear,
        t_Systime.wMonth,
        t_Systime.wDay,
        t_Systime.wHour,
        t_Systime.wMinute,
        t_Systime.wSecond,
        micros,
        L'-',
        0
        );

    return hr;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\scerpc\escprov\eventlog.cpp ===
// eventlog.cpp: implementation of the CEventLogSettings class.
//
// Copyright (c)1997-1999 Microsoft Corporation
//
//////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "eventlog.h"
#include "persistmgr.h"
#include <io.h>
#include "requestobject.h"

#define KeySize     L"MaximumLogSize"
#define KeyRet      L"RetentionPeriod"
#define KeyDays     L"RetentionDays"
#define KeyRestrict L"RestrictGuestAccess"

/*
Routine Description: 

Name:

    CEventLogSettings::CEventLogSettings

Functionality:

    This is the constructor. Pass along the parameters to the base class

Virtual:
    
    No (you know that, constructor won't be virtual!)

Arguments:

    pKeyChain - Pointer to the ISceKeyChain COM interface which is prepared
        by the caller who constructs this instance.

    pNamespace - Pointer to WMI namespace of our provider (COM interface).
        Passed along by the caller. Must not be NULL.

    pCtx - Pointer to WMI context object (COM interface). Passed along
        by the caller. It's up to WMI whether this interface pointer is NULL or not.

Return Value:

    None as any constructor

Notes:
    if you create any local members, think about initialize them here

*/

CEventLogSettings::CEventLogSettings (
    IN ISceKeyChain     * pKeyChain, 
    IN IWbemServices    * pNamespace,
    IN IWbemContext     * pCtx
    )
  :
    CGenericClass(pKeyChain, pNamespace, pCtx)
{

}

/*
Routine Description: 

Name:

    CEventLogSettings::~CEventLogSettings

Functionality:
    
    Destructor. Necessary as good C++ discipline since we have virtual functions.

Virtual:
    
    Yes.
    
Arguments:

    none as any destructor

Return Value:

    None as any destructor

Notes:
    if you create any local members, think about whether
    there is any need for a non-trivial destructor

*/

CEventLogSettings::~CEventLogSettings()
{
}

/*
Routine Description: 

Name:

    CEventLogSettings::CreateObject

Functionality:
    
    Create WMI objects (Sce_EventLog). Depending on parameter atAction,
    this creation may mean:
        (a) Get a single instance (atAction == ACTIONTYPE_GET)
        (b) Get several instances satisfying some criteria (atAction == ACTIONTYPE_QUERY)
        (c) Delete an instance (atAction == ACTIONTYPE_DELETE)

Virtual:
    
    Yes.
    
Arguments:

    pHandler - COM interface pointer for notifying WMI for creation result.
    atAction -  Get single instance ACTIONTYPE_GET
                Get several instances ACTIONTYPE_QUERY
                Delete a single instance ACTIONTYPE_DELETE

Return Value:

    Success: it must return success code (use SUCCEEDED to test). It is
    not guaranteed to return WBEM_NO_ERROR. The returned objects are indicated to WMI,
    not directly passed back via parameters.

    Failure: Various errors may occurs. Except WBEM_E_NOT_FOUND, any such error should indicate 
    the failure of getting the wanted instance. If WBEM_E_NOT_FOUND is returned in querying
    situations, this may not be an error depending on caller's intention.

Notes:

*/

HRESULT 
CEventLogSettings::CreateObject (
    IN IWbemObjectSink * pHandler, 
    IN ACTIONTYPE        atAction
    )
{

    // 
    // we know how to:
    //      Get single instance ACTIONTYPE_GET
    //      Delete a single instance ACTIONTYPE_DELETE
    //      Get several instances ACTIONTYPE_QUERY
    //

    if ( ACTIONTYPE_GET != atAction &&
         ACTIONTYPE_DELETE != atAction &&
         ACTIONTYPE_QUERY != atAction ) {

        return WBEM_E_NOT_SUPPORTED;
    }

    //
    // We must have the pStorePath property because that is where
    // our instance is stored. 
    // m_srpKeyChain->GetKeyPropertyValue WBEM_S_FALSE if the key is not recognized
    // So, we need to test against WBEM_S_FALSE if the property is mandatory
    //

    CComVariant varStorePath;
    HRESULT hr = m_srpKeyChain->GetKeyPropertyValue(pStorePath, &varStorePath);

    if (SUCCEEDED(hr) && hr != WBEM_S_FALSE && varStorePath.vt == VT_BSTR)
    {
        CComVariant varType;
        hr = m_srpKeyChain->GetKeyPropertyValue(pType, &varType);

        if (FAILED(hr))
        {
            return hr;
        }
        else if (hr == WBEM_S_FALSE && (ACTIONTYPE_QUERY != atAction) ) 
        {
            return WBEM_E_NOT_FOUND;
        }

        //
        // Create the event log instance
        //

        CSceStore SceStore;
        hr = SceStore.SetPersistPath(varStorePath.bstrVal);

        if ( SUCCEEDED(hr) ) {

            //
            // make sure the store (just a file) really exists. The raw path
            // may contain env variables, so we need the expanded path
            //

            DWORD dwAttrib = GetFileAttributes(SceStore.GetExpandedPath());

            if ( dwAttrib != -1 ) 
            {
                if ( ACTIONTYPE_DELETE == atAction )
                {
                    hr = DeleteInstance(pHandler, &SceStore, varType.bstrVal);
                }
                else 
                {
                    BOOL bPostFilter=TRUE;
                    DWORD dwCount = 0;
                    m_srpKeyChain->GetKeyPropertyCount(&dwCount);

                    if ( varType.vt == VT_EMPTY && dwCount == 1 ) 
                    {
                        bPostFilter = FALSE;
                    }

                    hr = ConstructInstance(pHandler, &SceStore, 
                                           varStorePath.bstrVal,
                                           (varType.vt == VT_BSTR) ? varType.bstrVal : NULL,
                                           bPostFilter 
                                           );
                }

            } 
            else 
            {
                hr = WBEM_E_NOT_FOUND;
            }
        }
    }

    return hr;
}

/*
Routine Description: 

Name:

    CEventLogSettings::PutInst

Functionality:
    
    Put an instance as instructed by WMI. Since this class implements Sce_EventLog,
    which is persistence oriented, this will cause the Sce_EventLog object's property 
    information to be saved in our store.

Virtual:
    
    Yes.
    
Arguments:

    pInst - COM interface pointer to the WMI class (Sce_EventLog) object.

    pHandler - COM interface pointer for notifying WMI of any events.

    pCtx - COM interface pointer. This interface is just something we pass around.
            WMI may mandate it (not now) in the future. But we never construct
            such an interface and so, we just pass around for various WMI API's

Return Value:

    Success: it must return success code (use SUCCEEDED to test). It is
    not guaranteed to return WBEM_NO_ERROR.

    Failure: Various errors may occurs. Any such error should indicate the failure of persisting
    the instance.

Notes:
    Since GetProperty will return a success code (WBEM_S_RESET_TO_DEFAULT) when the
    requested property is not present, don't simply use SUCCEEDED or FAILED macros
    to test for the result of retrieving a property.

*/

HRESULT 
CEventLogSettings::PutInst (
    IN IWbemClassObject * pInst, 
    IN IWbemObjectSink  * pHandler,
    IN IWbemContext     * pCtx
    )
{
    HRESULT hr = WBEM_E_INVALID_PARAMETER;
    CComBSTR bstrLogType;

    DWORD dwSize=SCE_NO_VALUE;
    DWORD dwRet=SCE_NO_VALUE;
    DWORD dwDays=SCE_NO_VALUE;
    DWORD dwRestrict=SCE_NO_VALUE;
    DWORD idxLog=0;
    
    //
    // our CSceStore class manages the persistence.
    //

    CSceStore SceStore;

    //
    // CScePropertyMgr helps us to access wbem object's properties
    // create an instance and attach the wbem object to it.
    // This will always succeed.
    //

    CScePropertyMgr ScePropMgr;
    ScePropMgr.Attach(pInst);

    //
    // the use of the macro SCE_PROV_IfErrorGotoCleanup cause
    // a "goto CleanUp;" with hr set to the return value from
    // the function (macro parameter)
    //

    SCE_PROV_IfErrorGotoCleanup(ScePropMgr.GetProperty(pOverwritePolicy, &dwRet));

    if ( dwRet == 1 ) 
    { 
        //
        // by days
        //

        SCE_PROV_IfErrorGotoCleanup(ScePropMgr.GetProperty(pRetentionPeriod, &dwDays));

        //
        // SCE_NO_VALUE indicates that the property is not properly set.
        //

        if ( dwDays == SCE_NO_VALUE ) 
        {
            hr = WBEM_E_ILLEGAL_NULL;
            goto CleanUp;
        } 
        else if ( dwDays == 0 || dwDays > 365 ) 
        {
            hr = WBEM_E_VALUE_OUT_OF_RANGE;
            goto CleanUp;
        }
    } 

    //
    // otherwise ignore the RetentionPeriod parameter
    //

    //
    // if the property doesn't exist (NULL or empty), WBEM_S_RESET_TO_DEFAULT is returned
    //

    SCE_PROV_IfErrorGotoCleanup(ScePropMgr.GetProperty(pSize, &dwSize));

    if ( dwSize != SCE_NO_VALUE ) 
    {
        //
        // min 64K, max 4194240K, increment by 64K
        //

        if ( dwSize < 64 || dwSize > 4194240L ) 
        {
            hr = WBEM_E_VALUE_OUT_OF_RANGE;
            goto CleanUp;
        } 
        else 
        {
            if ( dwSize % 64 ) 
            {
                dwSize = (dwSize/64 + 1) * 64;
            }
        }
    }

    SCE_PROV_IfErrorGotoCleanup(ScePropMgr.GetProperty(pType, &bstrLogType));

    //
    // check if the category is valid. Won't allow invalid category
    //

    SCE_PROV_IfErrorGotoCleanup(ValidateEventlogType(bstrLogType, &idxLog));

    SCE_PROV_IfErrorGotoCleanup(ScePropMgr.GetProperty(pRestrictGuestAccess, &dwRestrict));

    //
    // Attach the WMI object instance to the store and let the store know that
    // it's store is given by the pStorePath property of the instance.
    //

    hr = SceStore.SetPersistProperties(pInst, pStorePath);

    //
    // now save the info to file
    //

    if ( SUCCEEDED(hr) )
    {
        hr = SaveSettingsToStore(&SceStore,
                                      (PCWSTR)bstrLogType,
                                      dwSize,
                                      dwRet,
                                      dwDays,
                                      dwRestrict
                                      );
    }

CleanUp:
    return hr;
}

/*
Routine Description: 

Name:

    CEventLogSettings::ConstructInstance

Functionality:
    
    This is private function to create an instance of Sce_EventLog.

Virtual:
    
    No.
    
Arguments:

    pHandler        - COM interface pointer for notifying WMI of any events.

    pSceStore       - Pointer to our store. It must have been appropriately set up.

    wszLogStorePath - store path, a key property of Sce_EventLog class.

    wszLogType      - another corresponding property of the Sce_EventLog class.

    bPostFilter     - Controls how WMI will be informed with pHandler->SetStatus.

Return Value:

    Success: it must return success code (use SUCCEEDED to test). It is
    not guaranteed to return WBEM_NO_ERROR.

    Failure: Various errors may occurs. Any such error should indicate the creating the instance.

Notes:

*/

HRESULT 
CEventLogSettings::ConstructInstance (
    IN IWbemObjectSink  * pHandler,
    IN CSceStore        * pSceStore,
    IN LPCWSTR            wszLogStorePath,
    IN LPCWSTR            wszLogType,
    IN BOOL               bPostFilter
    )
{
    // 
    // make sure that we have a valid store
    //

    if ( pSceStore == NULL ||
         pSceStore->GetStoreType() < SCE_INF_FORMAT ||
         pSceStore->GetStoreType() > SCE_JET_ANALYSIS_REQUIRED ) {

        return WBEM_E_INVALID_PARAMETER;
    }

    HRESULT hr = WBEM_S_NO_ERROR;
    DWORD idxLog=0;

    if ( wszLogType ) 
    {
        hr = ValidateEventlogType(wszLogType, &idxLog);

        if ( FAILED(hr) ) 
        {
            return hr;
        }
    }

    //
    // ask SCE to read a gigantic structure out from the store. Only SCE
    // knows now to release the memory. Don't just delete it! Use our CSceStore
    // to do the releasing (FreeSecurityProfileInfo)
    //

    PSCE_PROFILE_INFO pInfo = NULL;

    hr = pSceStore->GetSecurityProfileInfo(
                                   AREA_SECURITY_POLICY,
                                   &pInfo,
                                   NULL
                                   );

    //
    // the use of the macro SCE_PROV_IfErrorGotoCleanup cause
    // a "goto CleanUp;" with hr set to the return value from
    // the function (macro parameter)
    //

    if (SUCCEEDED(hr))
    {
        CComBSTR bstrLogOut;
        SCE_PROV_IfErrorGotoCleanup(MakeSingleBackSlashPath(wszLogStorePath, L'\\', &bstrLogOut));

        //
        // CScePropertyMgr helps us to access WMI object's properties.
        //

        CScePropertyMgr ScePropMgr;

        for ( DWORD i=idxLog; SUCCEEDED(hr) && i<3; i++) 
        {

            if ( pInfo->MaximumLogSize[i] == SCE_NO_VALUE &&
                 pInfo->AuditLogRetentionPeriod[i] == SCE_NO_VALUE &&
                 pInfo->RetentionDays[i] == SCE_NO_VALUE &&
                 pInfo->RestrictGuestAccess[i] == SCE_NO_VALUE ) 
            {

                if ( wszLogType ) 
                {
                    hr = WBEM_E_NOT_FOUND;
                }

                continue;
            }

            PCWSTR szType = GetEventLogType(i);

            if ( !szType ) 
            {
                continue;
            }

            CComPtr<IWbemClassObject> srpObj;
            SCE_PROV_IfErrorGotoCleanup(SpawnAnInstance(&srpObj));

            //
            // attach a different WMI object to the property manager.
            // This will always succeed.
            //

            ScePropMgr.Attach(srpObj);

            //
            // we won't allow the store path and type info to be missing
            //

            SCE_PROV_IfErrorGotoCleanup(ScePropMgr.PutProperty(pStorePath, bstrLogOut));
            SCE_PROV_IfErrorGotoCleanup(ScePropMgr.PutProperty(pType,  szType));

            //
            // SCE_NO_VALUE indicates that the pInfo doesn't have that value
            // for the rest of the properties, we will allow them to be missing.
            //

            if ( pInfo->MaximumLogSize[i] != SCE_NO_VALUE )
            {
                SCE_PROV_IfErrorGotoCleanup(ScePropMgr.PutProperty(pSize, pInfo->MaximumLogSize[i]) );
            }

            if ( pInfo->AuditLogRetentionPeriod[i] != SCE_NO_VALUE )
            {
                SCE_PROV_IfErrorGotoCleanup(ScePropMgr.PutProperty(pOverwritePolicy, pInfo->AuditLogRetentionPeriod[i]) );
            }

            if ( pInfo->RetentionDays[i] != SCE_NO_VALUE )
            {
                SCE_PROV_IfErrorGotoCleanup(ScePropMgr.PutProperty(pRetentionPeriod, pInfo->RetentionDays[i]) );
            }

            if ( pInfo->RestrictGuestAccess[i] != SCE_NO_VALUE ) 
            {
                SCE_PROV_IfErrorGotoCleanup(ScePropMgr.PutProperty(pRestrictGuestAccess, pInfo->RestrictGuestAccess[i]) );
            }

            //
            // do the necessary gestures to WMI.
            // the use of WBEM_STATUS_REQUIREMENTS in SetStatus is not documented by WMI
            // at this point. Consult WMI team for detail if you suspect problems with
            // the use of WBEM_STATUS_REQUIREMENTS
            //

            if ( !bPostFilter ) 
            {
                pHandler->SetStatus(WBEM_STATUS_REQUIREMENTS, S_FALSE, NULL, NULL);
            } 
            else 
            {
                pHandler->SetStatus(WBEM_STATUS_REQUIREMENTS, S_OK, NULL, NULL);
            }

            //
            // pass the new instance to WMI
            //

            hr = pHandler->Indicate(1, &srpObj);

            // if it's not query, do one instance only
            if ( wszLogType ) 
            {
                break;
            }
        }
    }

CleanUp:
    pSceStore->FreeSecurityProfileInfo(pInfo);

    return hr;
}

/*
Routine Description: 

Name:

    CEventLogSettings::DeleteInstance

Functionality:
    
    remove an instance of Sce_EventLog from the specified store.

Virtual:
    
    No.
    
Arguments:

    pHandler    - COM interface pointer for notifying WMI of any events.

    pSceStore   - Pointer to our store. It must have been appropriately set up.

    wszLogType  - another corresponding property of the Sce_EventLog class.

Return Value:

    Success: WBEM_NO_ERROR.

    Failure: WBEM_E_INVALID_PARAMETER

Notes:

*/

HRESULT 
CEventLogSettings::DeleteInstance (
    IN IWbemObjectSink  * pHandler,
    IN CSceStore        * pSceStore,
    IN LPCWSTR            wszLogType
    )
{
    // 
    // make sure that we have a valid store
    //

    if ( pSceStore == NULL ||
         pSceStore->GetStoreType() < SCE_INF_FORMAT ||
         pSceStore->GetStoreType() > SCE_JET_ANALYSIS_REQUIRED ) {

        return WBEM_E_INVALID_PARAMETER;
    }

    pSceStore->DeleteSectionFromStore(wszLogType);

    return WBEM_NO_ERROR;
}


/*
Routine Description: 

Name:

    CEventLogSettings::ValidateEventlogType

Functionality:
    
    Validate the event log type.

Virtual:
    
    No.
    
Arguments:

    wszLogType  - string representing the log type.

    pIndex      - passing back DWORD representation about type of log

Return Value:

    Success: WBEM_NO_ERROR.

    Failure: WBEM_E_INVALID_PARAMETER.

Notes:
*/

HRESULT 
CEventLogSettings::ValidateEventlogType (
     IN LPCWSTR   wszLogType,
     IN DWORD   * pIndex
     )
{
    HRESULT hr = WBEM_NO_ERROR;

    if ( wszLogType == NULL || pIndex == NULL ) {
        return WBEM_E_INVALID_PARAMETER;
    }

    if ( _wcsicmp(wszLogType, pwApplication) == 0 ) {
        *pIndex = 2;

    } else if ( _wcsicmp(wszLogType, pwSystem) == 0 ) {
        *pIndex = 0;

    } else if ( _wcsicmp(wszLogType, pwSecurity) == 0 ) {
        *pIndex = 1;

    } else {

        *pIndex = 10;
        hr = WBEM_E_INVALID_PARAMETER;
    }

    return hr;
}

/*
Routine Description: 

Name:

    CEventLogSettings::SaveSettingsToStore

Functionality:
    
    Validate the event log type.

Virtual:
    
    No.
    
Arguments:
    
    pSceStore   - the store pointer to do the saving.

    Section     - the section name where the information will be saved.

    dwSize      - corresponding property of the Sce_EvengLog class.

    dwRet       - corresponding property of the Sce_EvengLog class. 

    dwDays      - corresponding property of the Sce_EvengLog class.

    dwRestrict  - corresponding property of the Sce_EvengLog class.

Return Value:

    Success: WBEM_NO_ERROR.

    Failure: WBEM_E_INVALID_PARAMETER.

Notes:
*/

HRESULT 
CEventLogSettings::SaveSettingsToStore (
    IN CSceStore  * pSceStore, 
    IN LPCWSTR      Section,
    IN DWORD        dwSize, 
    IN DWORD        dwRet, 
    IN DWORD        dwDays, 
    IN DWORD        dwRestrict
    )
{
    HRESULT hr = WBEM_S_NO_ERROR;
    HRESULT hrTmp;

    DWORD dwDump;

    //
    // the use of the macro SCE_PROV_IfErrorGotoCleanup cause
    // a "goto CleanUp;" with hr set to the return value from
    // the function (macro parameter)
    //

    //
    // For a new .inf file. Write an empty buffer to the file
    // will creates the file with right header/signature/unicode format
    // this is harmless for existing files.
    // For database store, this is a no-op.
    //

    SCE_PROV_IfErrorGotoCleanup(pSceStore->WriteSecurityProfileInfo(
                                                                    AreaBogus,  
                                                                    (PSCE_PROFILE_INFO)&dwDump, 
                                                                    NULL,
                                                                    false
                                                                    )
                                );


    //
    // Size
    //

    SCE_PROV_IfErrorGotoCleanup(pSceStore->SavePropertyToStore(
                                                               Section,
                                                               KeySize,
                                                               dwSize
                                                               )
                                );

    //
    // Retention
    //

    SCE_PROV_IfErrorGotoCleanup(pSceStore->SavePropertyToStore(
                                                               Section,
                                                               KeyRet,
                                                               dwRet
                                                               )
                                );

    //
    // Days
    //

    SCE_PROV_IfErrorGotoCleanup(pSceStore->SavePropertyToStore(
                                                               Section,
                                                               KeyDays,
                                                               dwDays
                                                               )
                                );

    //
    // Restrict
    //

    SCE_PROV_IfErrorGotoCleanup(pSceStore->SavePropertyToStore(
                                                               Section,
                                                               KeyRestrict,
                                                               dwRestrict
                                                               )
                                );
CleanUp:

    return hr;
}

/*
Routine Description: 

Name:

    GetEventLogType

Functionality:
    
    Helper to get the string representation of log type from dword representation.

Virtual:
    
    No.
    
Arguments:
    
    idx   - DWORD representation of the log type

Return Value:

    Success: string representation of log type

    Failure: NULL

Notes:
*/

PCWSTR GetEventLogType (
    IN DWORD idx
    )
{
    switch ( idx ) {
    case 0:
        return pwSystem;
        break;
    case 1:
        return pwSecurity;
        break;
    case 2:
        return pwApplication;
        break;
    default:
        return NULL;
        break;
    }

    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\scerpc\escprov\compkey.h ===
// compkey.h: interface for the CCompoundKey class
// Copyright (c)1997-2001 Microsoft Corporation
//
//////////////////////////////////////////////////////////////////////
#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

/*

Class description
    
    Naming: 
    
        CCompoundKey stands for a key that is compounded by many properties.
    
    Base class: 
    
        None. This is not a class that implements a WMI class. 
        It is not derived from CGenericClass.
    
    Purpose of class:
    
        (1) Comparing two instances of the same WMI class is not an easy job because
            most of time we need to look up an instance based on its key. Ideally, if
            WMI provides some canonical name, it will be very easy. The closest thing
            WMI gives us regarding the identify of instance is the instance path.
            But WMI gives inconsistent paths for the same instance. At least, we've
            found that if a boolean property is part of the key, then sometimes WMI
            gives its path containing a string portion like "BoolPropName=1" and other
            times (for the same instance) it gives "BoolPropName=TRUE". For this reason,
            we are forced to create a robust identify lookup mechanism.
        
        (2) This class serves two purposes: 

            (a) the key for our map of instance lookup. Potentially, we may have tens of 
                thousands of instances (like random ports). We need an efficient way to
                find an instance.

            (b) provide access (GetPropertyValue) for key properties of an instance.
        
        (3) This is part of the effort to implement another open extension model (embedding)
    
    Design:

        (1) We only store the key property's values (m_pValues). In other words, we rely
            on user to know the order properties are put into the class. The reasons for
            this design are:

            (a) Efficiency.

            (b) Don't want to store the property names because one class only needs one
                copy of the property names.

            (c) For each embedded class, we already have to find out all its key property names.
    
    Use:

        (1) Create an instance. Our constructor strictly requires the count for key properties
            at construction time. This is because you have to know each class (and their key
            property names, even the names particular order) at this point.

        (2) Call AddKeyPropertyValue to add a property value. Please note: for efficiency reasons,
            the variant pointer passed into the call is owned by this class (so that no copy needs
            to be made).

        (3) most likely, you will add this newly created instance to a map.

*/

class CCompoundKey
{

public:

    CCompoundKey(DWORD dwSize);

    ~CCompoundKey();

    HRESULT AddKeyPropertyValue (DWORD dwIndex, VARIANT** ppVar);

    bool operator < (const CCompoundKey& right)const;

    HRESULT GetPropertyValue (DWORD dwIndex, VARIANT* pVar)const;

protected:

    int CompareVariant (VARIANT* pVar1, VARIANT* pVar2)const;

    VARIANT** m_pValues;

    DWORD m_dwSize;
};

//=========================================================================

/*

Class description
    
    Naming: 
    
        CompKeyLessThan.
    
    Base class: 
    
        None. 
    
    Purpose of class:
    
        (1) This is the functor for our map that uses CCompoundKey as key.
    
    Design:

        (1) Just one operator ()
    
    Use:
        (1) Give it to the map's comparison parameter.

*/

struct CompKeyLessThan
{
    bool operator()( const CCompoundKey* pX, const CCompoundKey* pY ) const;

};

//=========================================================================

//
// declarations for the ease of use for maps using CCompoundKey
//

typedef std::map<CCompoundKey*, DWORD, CompKeyLessThan > MapExtClassCookie;
typedef MapExtClassCookie::iterator ExtClassCookieIterator;

//=========================================================================

//
// forward declaration for the use in CExtClassInstCookieList
//

class CSceStore;

//=========================================================================

/*

Class description
    
    Naming: 
    
        CExtClassInstCookieList.
    
    Base class: 
    
        None. 
    
    Purpose of class:
    
        (1) To support multiple instance persistence, we need a mechanism to tell
            instances apart in the persistence store. Due to the limitations of INF
            format file API, this is not an easy job. All instances of a particular
            class must be written into one section of the INF file. We have absolutely
            no control as what order the key=value pair will be written. To make things
            worse, the key in the key=value pair is not allowed to repeat. In other
            words, if we don't know anything, we can only persist one single instance.
            To solve this problem, we invent the notation of cookies for instances.
            For each class (and thus a section bearing the class's name), we have
            cookie arrays in the following form (the numbers are cookies):

                A1 = 12 : 2 : 3 : 6 :
                A2 = 1 : 5 : 8 : 10 : 24 : 112233 : 7 :

            For a particular instance, it is associated with a cookie. In order for us
            to persist or read an instance's properties, we must obtain the cookie, say, 5.
            Then all key properties of this instance is saved in the value of

                K5 = value

            and all non-key properties are all saved in

                5PropertyName = value
    
    Design:
         
        (1) Instancce lookup (given a compound key CCompoundKey to find its cookie) must
            efficient. So, a map is used (m_mapCookies).

        (2) We want to control the order an instance is used. Map doesn't work well in this
            case. So, we create a vector (m_vecCookies) to link cookies back to its compound key.
            This way when the access starts, we can traverse the vector using index.

        (3) We don't want to blindly continue to look for cookie arrays (A1, A2, etc.) when we
            need to create the cookie list for a particular class. And we don't want to
            write one cookie array to be so long that it is very hard to read. So, we adopt
            a strategy that we increment the A_i count and continue try to read A_(i+1) only
            if A_i exists. But then, if instances are deleted, we will need to have less cookie
            arrays. To know how many cookie arrays were read out (and potentially remove the
            unwanted ones when updating the store with the new cookie list), we have m_dwCookieArrayCount.

        (4) New cookie are assign by increment the current maximum cookie m_dwMaxCookie. To avoid
            DWORD overflow, we also have a function (GetNextFreeCookie) to look fora  newer cookie
            when the 0xFFFFFFFFF is already used.

        (5) We also defined a cookie called INVALID_COOKIE = 0.
    
    Use:

        (1) Instantiate an instance of the class.

        (2) Call Create function to populate its contents.

        (3) Ready for your use.

*/

class CExtClassInstCookieList
{
public:
    CExtClassInstCookieList();
    ~CExtClassInstCookieList();
    
    HRESULT Create(
                   CSceStore* pSceStore, 
                   LPCWSTR pszSectionName, 
                   std::vector<BSTR>* pvecNames
                   );

    HRESULT Save(
                 CSceStore* pSceStore, 
                 LPCWSTR pszSectionName
                 );
    
    DWORD GetCompKeyCookie(
                           LPCWSTR pszComKey, 
                           ExtClassCookieIterator* pIt
                           );

    HRESULT AddCompKey(
                       LPCWSTR pszCompKey, 
                       DWORD dwDefCookie, 
                       DWORD *pdwNewCookie
                       );

    DWORD RemoveCompKey(
                        CSceStore* pSceStore, 
                        LPCWSTR pszSectionName, 
                        LPCWSTR pszCompKey
                        );
    
    HRESULT Next(
                BSTR* pbstrCompoundKey, 
                DWORD* pdwCookie, 
                DWORD* pdwResumeHandle
                );

    //
    // return the count of cookies
    //

    DWORD 
    GetCookieCount ()
    {
        return m_vecCookies.size();
    }

private:
    HRESULT DeleteKeyFromStore(
                               CSceStore* pSceStore, 
                               LPCWSTR pszSectionName, 
                               DWORD dwCookie
                               );

    HRESULT GetNextFreeCookie(
                              DWORD* pdwCookie
                              );

    HRESULT CreateCompoundKeyFromString(
                                        LPCWSTR pszCompKeyStr, 
                                        CCompoundKey** ppCompKey
                                        );

    HRESULT CreateCompoundKeyString(
                                    BSTR* pbstrCompKey, 
                                    const CCompoundKey* pKey
                                    );

    void Cleanup();

    DWORD m_dwMaxCookie;
    MapExtClassCookie m_mapCookies;

    //
    // memories (pKey) is not managed by this struct CookieKeyPair
    // pKey is taken care of somewhere else (actually m_mapCookies does it)
    //

    struct CookieKeyPair
    {
        DWORD dwCookie;
        CCompoundKey* pKey;
    };

    typedef std::vector<CookieKeyPair*> CookieKeyVector;
    typedef CookieKeyVector::iterator CookieKeyIterator;

    CookieKeyVector m_vecCookies;

    std::vector<BSTR>* m_pVecNames;

    DWORD m_dwCookieArrayCount;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\scerpc\escprov\compkey.cpp ===
// compkey.cpp: implementation of the CCompoundKey class
// Copyright (c)1997-2001 Microsoft Corporation
//
//////////////////////////////////////////////////////////////////////
// original author: shawnwu
// creation date: 4/18/2001

#include "precomp.h"
#include "compkey.h"
#include "persistmgr.h"

/*
Routine Description: 

Name:

    CompKeyLessThan::operator()

Functionality:
    
    override () operator

Virtual:
    
    No.
    
Arguments:

    pX  - left.
    pY  - right.

Return Value:

    read code. It's easier that way.

Notes:
    We are not really doing much other than call CCompoundKey's operator <.

*/

bool CompKeyLessThan::operator() ( 
    IN const CCompoundKey* pX, 
    IN const CCompoundKey* pY 
    ) const
{
    if (pX == NULL && pY != NULL)
        return true;
    else if (pX != NULL && pY == NULL)
        return false;
    else
        return *pX < *pY;
}

/*
Routine Description: 

Name:

    CCompoundKey::CCompoundKey

Functionality:
    
    constructor.

Virtual:
    
    No.
    
Arguments:

    dwSize  - This will be size of the compound key's capacity to hold values.
              you can't change it.

Return Value:

    none

Notes:
    If dwSize == 0, it's considered a null key. Null keys are useful for identifying
    static method calls, and singletons (because they don't have keys)

*/

CCompoundKey::CCompoundKey (
    IN DWORD dwSize
    ) 
    : 
    m_dwSize(dwSize), 
    m_pValues(NULL)
{
    if (m_dwSize > 0)
    {
        m_pValues = new VARIANT*[m_dwSize];
        if (m_pValues == NULL)
        {
            m_dwSize = 0;
        }
        else
        {
            //
            // make sure that we initialize those VARIANT* to NULL
            // because we are going to own them and delete them!
            //

            ::memset(m_pValues, 0, m_dwSize * sizeof(VARIANT*));
        }
    }
}

/*
Routine Description: 

Name:

    CCompoundKey::~CCompoundKey

Functionality:
    
    destructor.

Virtual:
    
    No.
    
Arguments:

    none

Return Value:

    none

Notes:
    Just need to know how to delete a VARIANT*

*/

CCompoundKey::~CCompoundKey()
{
    for (DWORD i = 0; i < m_dwSize; i++)
    {
        if (m_pValues[i])
        {
            ::VariantClear(m_pValues[i]);
            delete m_pValues[i];
        }
    }
    delete [] m_pValues;
}

/*
Routine Description: 

Name:

    CCompoundKey::AddKeyPropertyValue

Functionality:
    
    Add a key property value to this compound key.

Virtual:
    
    No.
    
Arguments:

    none

Return Value:

    WBEM_NO_ERROR if succeeded.

    WBEM_E_INVALID_PARAMETER if ppVar == NULL;
    
    WBEM_E_VALUE_OUT_OF_RANGE is the given index is not in range.

Notes:
    CCompoundKey doesn't keep track of property names. Instead, it simply records
    its values. The order this function is called determines what value belongs to
    what property. Caller must keep track of that order. Different compound keys
    become comparable only if they have the same order.
    Also, the in coming parameter *ppVar is owned by the this object after this call

*/

HRESULT 
CCompoundKey::AddKeyPropertyValue (
    IN DWORD           dwIndex,
    IN OUT VARIANT  ** ppVar 
    )
{
    if (ppVar == NULL)
    {
        return WBEM_E_INVALID_PARAMETER;
    }
    else if (dwIndex >= m_dwSize)
    {
        return WBEM_E_VALUE_OUT_OF_RANGE;
    }

    //
    // if there is already a value, then we need to delete the old one
    //

    if (m_pValues[dwIndex])
    {
        ::VariantClear(m_pValues[dwIndex]);
        delete m_pValues[dwIndex];
    }

    //
    // attach to the new one
    //

    m_pValues[dwIndex] = *ppVar;

    //
    // hey, we own it now
    //

    *ppVar = NULL;

    return WBEM_NO_ERROR;
}

/*
Routine Description: 

Name:

    CCompoundKey::GetPropertyValue

Functionality:
    
    Retrieve a key property value by key property index (caller must know that).

Virtual:
    
    No.
    
Arguments:

    none

Return Value:

    Read code.

Notes:
    See AddKeyPropertyValue's notes

*/

HRESULT 
CCompoundKey::GetPropertyValue (
    IN  DWORD     dwIndex,
    OUT VARIANT * pVar
    )const
{
    if (pVar == NULL)
    {
        return WBEM_E_INVALID_PARAMETER;
    }
    else if (dwIndex >= m_dwSize)
    {
        return WBEM_E_VALUE_OUT_OF_RANGE;
    }

    //
    // make sure that our out-bound parameter is in a empty state
    //

    ::VariantInit(pVar);

    if (m_pValues[dwIndex])
    {
        return ::VariantCopy(pVar, m_pValues[dwIndex]);
    }
    else
    {
        return WBEM_E_NOT_AVAILABLE;
    }
}

/*
Routine Description: 

Name:

    CCompoundKey::operator < 

Functionality:
    
    Compare this object with the in-bound parameter and see which compound key
    key is greater. Ultimately, the relation is determined by the variant values
    of each corresponding key property.

Virtual:
    
    No.
    
Arguments:

    none

Return Value:

    Read code.

Notes:
    (1) See AddKeyPropertyValue's notes.
    (2) See CompareVariant's notes

*/

bool 
CCompoundKey::operator < (
    IN const CCompoundKey& right
    )const
{
    //
    // defensive against potential erroneous comparison.
    // This shouldn't happen in our correct use. But sometimes we write
    // less-than-correct code.
    //

    if (m_dwSize != right.m_dwSize)
    {
        return (m_dwSize < right.m_dwSize);
    }

    int iComp = 0;
    
    //
    // The first less than or greater than result wins
    //

    for (int i = 0; i < m_dwSize; i++)
    {
        //
        // if both variants are valid
        //

        if (m_pValues[i] != NULL && right.m_pValues[i] != NULL)
        {
            //
            // CompareVariant returns the exact same int value
            // as string comparison results
            //

            iComp = CompareVariant(m_pValues[i], right.m_pValues[i]);
            if (iComp > 0)
            {
                return false;
            }
            else if (iComp < 0)
            {
                return true;
            }

            //
            // else is equal! need to continue comparing the rest of the values
            //
        }
        else if (m_pValues[i] == NULL)
        {
            return true;
        }
        else 
        {
            //
            // right.m_pValues[i] == NULL
            //

            return false;
        }
    }

    //
    // if reach here, this must be an equal case
    //

    return false;
}

/*
Routine Description: 

Name:

    CCompoundKey::CompareVariant 

Functionality:
    
    Compare two variants

Virtual:
    
    No.
    
Arguments:

    pVar1   - must not be NULL
    pVar2   - must not be NULL

Return Value:

    less than 0 if pVar1 < pVar2
    Greater than 0 if pVar1 < pVar2
    0 if they are considered equal

Notes:
    (1) for efficiency reasons, we don't check the parameters.
    (2) The reason we are doing this is due the fact that WMI will give us inconsistent
        path when boolean are used. Sometimes it gives boolVal=TRUE, sometimes it gives
        boolVal=1. This creates problems for us.
    (3) This function currently only works for our supported vt types.
    (4) type mismatch will only be dealt with if one of them is boolean.

*/

int 
CCompoundKey::CompareVariant (
    IN VARIANT* pVar1, 
    IN VARIANT* pVar2
    )const
{
    //
    // default to equal because that is the only consistent value
    // in case of failure
    //

    int iResult = 0;

    VARIANT varCoerced1;
    ::VariantInit(&varCoerced1);

    VARIANT varCoerced2;
    ::VariantInit(&varCoerced2);

    //
    // if both are strings, then use case-insensitive comparison
    //

    if (pVar1->vt == pVar2->vt && pVar1->vt == VT_BSTR)
    {
        iResult = _wcsicmp(pVar1->bstrVal, pVar2->bstrVal);
    }

    //
    // if one is boolean, then coerced both to boolean
    //
    else if (pVar1->vt == VT_BOOL || pVar2->vt == VT_BOOL)
    {
        //
        // in case the coersion fails, we will call the failed one less then the succeeded one.
        // Don't use the WBEM_NO_ERROR even though they are defined to be S_OK. WMI may change it
        // later. So, use the MSDN documented hresult values
        //

        HRESULT hr1 = ::VariantChangeType(&varCoerced1, pVar1, VARIANT_LOCALBOOL, VT_BOOL);
        HRESULT hr2 = ::VariantChangeType(&varCoerced2, pVar2, VARIANT_LOCALBOOL, VT_BOOL);

        if (hr1 == S_OK && hr2 == S_OK)
        {
            if (varCoerced1.boolVal == varCoerced2.lVal)
            {
                //
                // equal
                //

                iResult = 0;
            }
            else if (varCoerced1.boolVal == VARIANT_TRUE)
            {
                //
                // greater
                //

                iResult = 1;
            }
            else
            {
                //
                // less 
                //

                iResult = -1;
            }
        }
        else if (hr1 == S_OK)
        {
            //
            // second coersion fails, we say the second is greater
            //

            iResult = 1;
        }
        else if (hr2 == S_OK)
        {
            //
            // first coersion fails, we say the first is greater
            //

            iResult = -1;
        }
        else
        {
            //
            // both fails. We are out of luck.
            //

            iResult = 0;
        }
    }

    //
    // everything else, coerced both to VI_I4
    //

    else
    {
        
        HRESULT hr1 = ::VariantChangeType(&varCoerced1, pVar1, VARIANT_LOCALBOOL, VT_I4);
        HRESULT hr2 = ::VariantChangeType(&varCoerced2, pVar2, VARIANT_LOCALBOOL, VT_I4);

        if (hr1 == S_OK && hr2 == S_OK)
        {
            iResult = varCoerced1.lVal - varCoerced2.lVal;
        }
        else if (hr1 == S_OK)
        {
            //
            // second coersion fails, we say the second is greater
            //

            iResult = 1;
        }
        else if (hr2 == S_OK)
        {
            //
            // first coersion fails, we say the first is greater
            //

            iResult = -1;
        }
        else
        {
            //
            // both fails. We are out of luck.
            //

            iResult = 0;
        }
    }

    ::VariantClear(&varCoerced1);
    ::VariantClear(&varCoerced2);

    return iResult;
}

//
// implementation of CExtClassInstCookieList
//

/*
Routine Description: 

Name:

    CExtClassInstCookieList::CExtClassInstCookie

Functionality:
    
    constructor.

Virtual:
    
    No.
    
Arguments:

    none

Return Value:

    none

Notes:
    (1) INVALID_COOKIE is the invalid cookie value.
    (2) No thread safety. Caller must be aware.

*/

CExtClassInstCookieList::CExtClassInstCookieList () 
    : 
    m_dwMaxCookie(INVALID_COOKIE), 
    m_pVecNames(NULL), 
    m_dwCookieArrayCount(0)
{
}

/*
Routine Description: 

Name:

    CExtClassInstCookieList::~CExtClassInstCookieList

Functionality:
    
    destructor.

Virtual:
    
    No.
    
Arguments:

    none

Return Value:

    none

Notes:
    (1) No thread safety. Caller must be aware.

*/
    
CExtClassInstCookieList::~CExtClassInstCookieList ()
{
    Cleanup();
}

/*
Routine Description: 

Name:

    CExtClassInstCookieList::Create

Functionality:
    
    Given a store and a section name (each class has a section corresponding to it, as
    a matter of fact, the section name is, in current implementation, the class name),
    this function populates its contents.

Virtual:
    
    No.
    
Arguments:

    pSceStore       - pointer to the CSceStore object prepared to read

    pszSectionName  - section name where this cookie list is to be created.

    pvecNames       - the vector that holds the key property names in order. We rely
                      on this vector as our order guidence to push values into our own vector.
                      Remember? those two things must match in their order.
                      A NULL in-bounding value means it intends to create a NULL key cookie

Return Value:

    Success: WBEM_NO_ERROR
    
    Failure: Various HRESULT code. In particular, if the cookie array is incorrectly formated
    ( it must be a integer number delimited by : (including the trailing : at the end), then
    we return WBEM_E_INVALID_SYNTAX. 

    Any failure indicates that the cookie list is not created.

Notes:
    (1) No thread safety. Caller must be aware.

*/

HRESULT 
CExtClassInstCookieList::Create (
    IN CSceStore          * pSceStore,
    IN LPCWSTR              pszSectionName,
    IN std::vector<BSTR>  * pvecNames
    )
{
    //
    // we must have a valid store and a valid section name
    //

    if (pSceStore == NULL || pszSectionName == NULL)
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    m_pVecNames = pvecNames;

    //
    // 1 is reserved for pszListPrefix
    //

    WCHAR szCookieList[MAX_INT_LENGTH + 1];
    WCHAR szCompKey[MAX_INT_LENGTH + 1];

    HRESULT hr = WBEM_NO_ERROR;

    //
    // Assume that we have no cookie array
    //

    m_dwCookieArrayCount = 0;

    //
    // cookie list is persisted in the following fashion: "A1=n:m:k:", "A2=n:m:k:", "A3=n:m:k:"
    // where 'A' == pszListPrefix.
    //

    //
    // enumerate all such possiblilities until we see a non-existent Ai (i is a integer).
    //

    DWORD dwCount = 1;
    while (SUCCEEDED(hr))
    {
        //
        // First, we need to create the cookie list name
        //

        wsprintf(szCookieList, L"%s%d", pszListPrefix, dwCount++);
        DWORD dwRead = 0;

        //
        // pszBuffer will hold the contents read from the store. 
        // Need to free the memory allocated for pszBuffer
        //

        LPWSTR pszBuffer = NULL;
        hr = pSceStore->GetPropertyFromStore(pszSectionName, szCookieList, &pszBuffer, &dwRead);

        if (SUCCEEDED(hr) && pszBuffer)
        {
            //
            // so far, we have this many cookie arrays
            //

            m_dwCookieArrayCount += 1;

            LPCWSTR pszCur = pszBuffer;
            DWORD dwCookie = 0;

            //
            // as long as it is a digit
            //

            while (iswdigit(*pszCur))
            {
                //
                // conver the first portion as a number
                //

                dwCookie = _wtol(pszCur);

                //
                // First, prepare the composite key's name (K1, K2, depending on the dwCookie.)
                //

                wsprintf(szCompKey, L"%s%d", pszKeyPrefix, dwCookie);

                //
                // read the composite key of this cookie
                // need to free the memory allocated for pszCompKeyBuffer
                //
                
                LPWSTR pszCompKeyBuffer = NULL;
                DWORD dwCompKeyLen = 0;

                hr = pSceStore->GetPropertyFromStore(pszSectionName, szCompKey, &pszCompKeyBuffer, &dwCompKeyLen);
                if (SUCCEEDED(hr))
                {
                    //
                    // AddCompKey can be called for two purposes (simply adding, or adding and requesting a new cookie)
                    // Here, we are just adding. But we need a place holder.
                    //
                    DWORD dwNewCookie = INVALID_COOKIE;

                    //
                    // we are truly adding the (compound key, cookie) pair
                    //

                    hr = AddCompKey(pszCompKeyBuffer, dwCookie, &dwNewCookie);

                    //
                    // increate the max used cookie member if appropriate
                    //

                    if (dwCookie > m_dwMaxCookie)
                    {
                        m_dwMaxCookie = dwCookie;
                    }
                }

                delete [] pszCompKeyBuffer;

                //
                //skip the current portion of the integer
                //

                while (iswdigit(*pszCur))
                {
                    ++pszCur;
                }

                if (*pszCur == wchCookieSep)
                {
                    //
                    // skip the ':'
                    //

                    ++pszCur;
                }
                else if (*pszCur == L'\0')
                {
                    //
                    // see the end
                    //

                    break;
                }
                else
                {
                    //
                    // see an invalid character
                    //

                    hr = WBEM_E_INVALID_SYNTAX;
                    break;
                }
            }
        }
        else if (hr == WBEM_E_NOT_FOUND)
        {
            // if Ai doesn't exist, we no longer look for A(i+1). For example, if A3 doesn't exist, then we
            // no longer look for A4, A5, etc. So, if property manager fails to get Ai, we consider this as
            // no more data.

            delete [] pszBuffer;
            pszBuffer = NULL;
            hr = WBEM_NO_ERROR;
            break;
        }

        delete [] pszBuffer;
    }

    //
    // in case of failure, set proper default
    //

    if (FAILED(hr))
    {
        //
        // maybe partial construction, so clean it up
        //
        
        Cleanup();
    }

    return hr;
}

/*
Routine Description: 

Name:

    CExtClassInstCookieList::Save

Functionality:
    
    save the cookie list into a store.

Virtual:
    
    No.
    
Arguments:

    pSceStore       - pointer to the CSceStore object prepared for save

    pszSectionName  - section name where this cookie list is to be created.

Return Value:

    Success: various potential success code. Use SUCCEEDED to test.
    
    Failure: Various HRESULT code.

    Any failure indicates that the cookie list is not saved properly.

Notes:
    (1) No thread safety. Caller must be aware.

*/

HRESULT 
CExtClassInstCookieList::Save (
    IN CSceStore* pSceStore,  
    IN LPCWSTR pszSectionName
    )
{
    //
    // pszBuffer will hold upto MAX_COOKIE_COUNT_PER_LINE count of cookie info = <cookie number> plus separater
    //

    LPWSTR pszBuffer = new WCHAR [(MAX_INT_LENGTH + 1) * MAX_COOKIE_COUNT_PER_LINE + 1];
    if (pszBuffer == NULL)
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    //
    // allocate a generous buffer to hold the key name and cookie array name
    //

    LPWSTR pszKey = new WCHAR[MAX_INT_LENGTH + wcslen(pszKeyPrefix) + wcslen(pszListPrefix) + 1];
    if (pszKey == NULL)
    {
        delete [] pszBuffer;
        return WBEM_E_OUT_OF_MEMORY;
    }

    DWORD dwCookieArrayCount = 1;

    int iLenKey = wcslen(pszKeyPrefix);
    int iLen = wcslen(pszListPrefix);

    if (iLen < iLenKey)
    {
        iLen = iLenKey;
    }

    HRESULT hr = WBEM_NO_ERROR;
    DWORD dwCookieCount = m_vecCookies.size();

    //
    // going through all cookies. Since we want to preserve the order
    // this time, we need to use the m_vecCookies to enumerate.
    //

    DWORD dwIndex = 0;

    while (dwIndex < dwCookieCount)
    {
        //
        // this loop is to:
        // (1) write the string version of each compound key
        // (2) pack enough cookies into the cookie list (but won't write it)
        //

        LPWSTR pCur = pszBuffer;

        for (int i = 0; (i < MAX_COOKIE_COUNT_PER_LINE) && (dwIndex < dwCookieCount); ++i, dwIndex++)
        {
            //
            // packing the cookies into the cookie list. We need to advance our
            // pCur to the next position (of pszBuffer) to write
            //

            wsprintf(pCur, L"%d%c", m_vecCookies[dwIndex]->dwCookie, wchCookieSep);
            pCur += wcslen(pCur);

            //
            // now, write Knnn=<compound key>
            //

            wsprintf(pszKey, L"%s%d", pszKeyPrefix, m_vecCookies[dwIndex]->dwCookie);
            CComBSTR bstrCompKey;

            //
            // create the string version of the composite key (the <compound key>)
            //

            hr = CreateCompoundKeyString(&bstrCompKey, m_vecCookies[dwIndex]->pKey);

            if (SUCCEEDED(hr))
            {
                hr = pSceStore->SavePropertyToStore(pszSectionName, pszKey, (LPCWSTR)bstrCompKey);
            }

            if (FAILED(hr))
            {
                break;
            }
        }

        //
        // if everything is alright, now is time to write the cookie list prepared by
        // the previous loop
        //

        if (SUCCEEDED(hr))
        {
            //
            // prepare the cookie list name
            //

            wsprintf(pszKey, L"%s%d", pszListPrefix, dwCookieArrayCount);

            hr = pSceStore->SavePropertyToStore(pszSectionName, pszKey, pszBuffer);

            if (FAILED(hr))
            {
                break;
            }
        }
        else
        {
            break;
        }

        ++dwCookieArrayCount;
    }

    //
    // if everything goes well (all cookie arrays have been saved), then, we need to remove
    // any potential extra cookie arrays Axxx, where the count starts from dwCookieArrayCount to m_dwCookieArrayCount
    //

    if (SUCCEEDED(hr))
    {
        //
        // we will delete all left over cookie arrays. 
        // In case of error during deleting, we will continue the deletion, but will report the error
        //

        while (dwCookieArrayCount <= m_dwCookieArrayCount)
        {
            //
            // prepare the cookie list name
            //

            wsprintf(pszKey, L"%s%d", pszListPrefix, dwCookieArrayCount++);

            HRESULT hrDelete = pSceStore->DeletePropertyFromStore(pszSectionName, pszKey);

            //
            // we won't stop the deletion in case of error. 
            // But we will report it.
            //

            if (FAILED(hrDelete))
            {
                hr = hrDelete;
            }
        }
    }

    delete [] pszBuffer;
    delete [] pszKey;

    return hr;
}

/*
Routine Description: 

Name:

    CExtClassInstCookieList::DeleteKeyFromStore

Functionality:
    
    Delete all key properties (Key=<Compound Key String>)

Virtual:
    
    No.
    
Arguments:

    pSceStore       - pointer to the CSceStore object prepared for save

    pszSectionName  - section name where this cookie list is to be created.

    dwCookie        - the cookie to of the key to be deleted

Return Value:

    Success: WBEM_NO_ERROR.
    
    Failure: Various HRESULT code.

    Any failure indicates that the cookie list is not delete properly.

Notes:
    (1) No thread safety. Caller must be aware.

*/

HRESULT 
CExtClassInstCookieList::DeleteKeyFromStore (
    IN CSceStore* pSceStore,  
    IN LPCWSTR pszSectionName, 
    IN DWORD dwCookie
    )
{
    int iLen = wcslen(pszKeyPrefix);

    //
    // 1 for pszKeyPrefix
    //

    WCHAR szKey[MAX_INT_LENGTH + 1];

    wsprintf(szKey, L"%s%d", pszKeyPrefix, dwCookie);

    return pSceStore->DeletePropertyFromStore(pszSectionName, szKey);
}

/*
Routine Description: 

Name:

    CExtClassInstCookieList::GetCompKeyCookie

Functionality:
    
    Given a string version of the compound key (what is really stored in our template),
    find the cookie. If found, also give an interator of the map to that element.

Virtual:
    
    No.
    
Arguments:

    pszCompKey  - string version of the compound key

    pIt         - The iterator to the map that points to the CCompoundKey
                  whose key properties match what is encoded in the pszCompKey

Return Value:

    the cookie if found.
    
    INVALID_COOKIE if not found.

Notes:
    (1) No thread safety. Caller must be aware.

*/

DWORD 
CExtClassInstCookieList::GetCompKeyCookie (
    IN LPCWSTR                    pszCompKey,
    OUT ExtClassCookieIterator  * pIt
    )
{
    CCompoundKey* pKey = NULL;

    //
    // we need a CCompoundKey to lookup. Convert the string version
    // to a CCompoundKey instance. Need to delete it.
    //

    HRESULT hr = CreateCompoundKeyFromString(pszCompKey, &pKey);
    if (FAILED(hr))
    {
        *pIt = m_mapCookies.end();
        return INVALID_COOKIE;
    }

    *pIt = m_mapCookies.find(pKey);

    DWORD cookie = INVALID_COOKIE;

    if (*pIt != m_mapCookies.end())
    {
        cookie = (*((ExtClassCookieIterator)(*pIt))).second;
    }

    delete pKey;

    return cookie;
}

/*
Routine Description: 

Name:

    CExtClassInstCookieList::AddCompKey

Functionality:
    
    Add a string version of the compound key (what is really stored in our template) to
    this object. Since our store really only give string version of the compound key,
    this method is what is used during creation upon reading the compound key string.

Virtual:
    
    No.
    
Arguments:

    pszCompKey      - string version of the compound key. pszCompKey == pszNullKey means
                      to add a static function call instance or a singleton

    dwDefCookie     - Default value for the cookie it is called to add.
                      If dwDefCookie == INVALID_COOKIE, we will create a new cookie while adding

    *pdwNewCookie   - pass back the new cookie for the just added compound key

Return Value:

    Will return the cookie for the compound key

Notes:
    (1) No thread safety. Caller must be aware.
    (2) Calling this function multiple times for the same cookie is safe because we will
         prevent it from being added more than once.

*/

HRESULT 
CExtClassInstCookieList::AddCompKey (
    IN LPCWSTR  pszCompKey, 
    IN DWORD    dwDefCookie,
    OUT DWORD * pdwNewCookie
    )
{
    if (pdwNewCookie == NULL || pszCompKey == NULL || *pszCompKey == L'\0')
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    