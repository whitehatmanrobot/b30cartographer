Conn1);
        }

        //
        // Level 2 info
        //

        // Authentication, Encryption and Compression
        tstring strAuthentication   = c_szEmpty;
        tstring strEncryption       = c_szEmpty;
        tstring strCompression      = c_szEmpty;
        tstring strIPSECEncryption  = c_szEmpty;

        RAS_CONNECTION_2 * pConn2;
        dwError = MprAdminConnectionGetInfo(hMprAdmin,
                                            2,
                                            m_hRasConn,
                                            (LPBYTE*)&pConn2);
        if (dwError == NO_ERROR)
        {
            PPP_INFO_2 * pInfo2 = &(pConn2->PppInfo2);

            // PPP_LCP_INFO
            if (!(pInfo2->lcp).dwError)
            {
                TraceTag(ttidStatMon, "Getting PPP_LCP_INFO");
                TraceTag(ttidStatMon, "lcp.dwAuthenticationProtocol = %d", (pInfo2->lcp).dwAuthenticationProtocol);
                TraceTag(ttidStatMon, "lcp.dwAuthenticationData = %d", (pInfo2->lcp).dwAuthenticationData);
                TraceTag(ttidStatMon, "lcp.dwOptions = %d", (pInfo2->lcp).dwOptions);

                switch((pInfo2->lcp).dwAuthenticationProtocol)
                {
                case PPP_LCP_PAP:
                    strAuthentication = SzLoadIds(IDS_PAP);
                    break;

                case PPP_LCP_SPAP:
                    strAuthentication = SzLoadIds(IDS_SPAP);
                    break;

                case PPP_LCP_CHAP:
                    {
                        // get more specifics
                        switch((pInfo2->lcp).dwAuthenticationData)
                        {
                        case RASLCPAD_CHAP_MS:
                            strAuthentication = SzLoadIds(IDS_CHAP);
                            break;

                        case RASLCPAD_CHAP_MD5:
                            strAuthentication = SzLoadIds(IDS_CHAP_MD5);
                            break;

                        case RASLCPAD_CHAP_MSV2:
                            strAuthentication = SzLoadIds(IDS_CHAP_V2);
                            break;
                        }
                    }
                    break;

                case PPP_LCP_EAP:
                    strAuthentication = SzLoadIds(IDS_EAP);
                    break;
                }

                if ((pInfo2->lcp).dwOptions & PPP_LCP_DES_56)
                {
                    strIPSECEncryption = SzLoadIds(IDS_EncryptionDES56);
                }
                else if ((pInfo2->lcp).dwOptions & PPP_LCP_3_DES)
                {
                    strIPSECEncryption = SzLoadIds(IDS_Encryption3DES);
                }
            }

            // PPP_CCP_INFO
            if (!(pInfo2->ccp).dwError)
            {
                TraceTag(ttidStatMon, "Getting PPP_CCP_INFO");
                TraceTag(ttidStatMon, "ccp.dwOptions = %x", pInfo2->ccp.dwOptions);
                TraceTag(ttidStatMon, "ccp.dwCompressionAlgorithm = %d", pInfo2->ccp.dwCompressionAlgorithm);

                if ((pInfo2->ccp.dwOptions) & PPP_CCP_ENCRYPTION56BIT)
                {
                    strEncryption = SzLoadIds(IDS_Encryption56bit);
                }
                else if ((pInfo2->ccp.dwOptions) & PPP_CCP_ENCRYPTION40BIT)
                {
                    strEncryption = SzLoadIds(IDS_Encryption40bit);
                }
                else if ((pInfo2->ccp.dwOptions) & PPP_CCP_ENCRYPTION128BIT)
                {
                    strEncryption = SzLoadIds(IDS_Encryption128bit);
                }

                if ((pInfo2->ccp.dwOptions) & PPP_CCP_COMPRESSION)
                {
                    switch(pInfo2->ccp.dwCompressionAlgorithm)
                    {
                    case RASCCPCA_MPPC:
                        strCompression = SzLoadIds(IDS_MPPC);
                        break;

                    case RASCCPCA_STAC:
                        strCompression = SzLoadIds(IDS_STAC);
                        break;
                    }
                }
            }

            MprAdminBufferFree(pConn2);
        }

        MprAdminServerDisconnect(hMprAdmin);

        // Now add to the list view

        // Server type
        InsertProperty(&iItem, IDS_ServerType, strServerType);

        // Transports
        InsertProperty(&iItem, IDS_Transports, strProtocolList);

        // Authentication
        InsertProperty(&iItem, IDS_Authentication, strAuthentication);

        // Encryption
        InsertProperty(&iItem, IDS_Encryption, strEncryption);

        // IPSEC Encryption
        InsertProperty(&iItem, IDS_IPSECEncryption, strIPSECEncryption);

        // Compression
        InsertProperty(&iItem, IDS_Compression, strCompression);

        // Server IP address
        InsertProperty(&iItem, IDS_ServerIP, strServerIp);

        // Client IP address
        InsertProperty(&iItem, IDS_ClientIP, strClientIp);

        // Client IPX address
        InsertProperty(&iItem, IDS_ClientIPX, strClientIpx);

        // Client computer name
        InsertProperty(&iItem, IDS_ComputerName, strComputerName);
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CPspStatusMonitorRas::InsertProperty
//
//  Purpose:    Fill one RAS properties to the list
//
//  Arguments:  piItem    - the index ofthe item
//              unId     - the property name
//              strValue - the property value
//
//  Returns:    Nil
//
int CPspStatusMonitorRas::InsertProperty(int * piItem,
                                          UINT  unId,
                                          tstring& strValue)
{
    TraceFileFunc(ttidStatMon);

    int lres = 0;

    if (!strValue.empty())
    {
        int iItem = *piItem;

        LV_ITEM lvItem;
        lvItem.mask = LVIF_TEXT;

        lvItem.iItem=iItem;
        lvItem.iSubItem=0;
        lvItem.pszText = (PWSTR) SzLoadIds(unId);
        lres = static_cast<int>(SendDlgItemMessage(IDC_LVW_RAS_PROPERTY, LVM_INSERTITEM,
                           iItem, (LPARAM)&lvItem));

        lvItem.iSubItem=1;
        lvItem.pszText=(PWSTR)strValue.c_str();

        SendDlgItemMessage(IDC_LVW_RAS_PROPERTY, LVM_SETITEMTEXT,
                           iItem, (LPARAM)&lvItem);
        ++(*piItem);
    }
    return lres;
}

//+---------------------------------------------------------------------------
//
//  Member:     CPspStatusMonitorRas::FillDeviceDropDown
//
//  Purpose:    Do the initialization required when the page has just been created
//
//  Arguments:  None
//
//  Returns:    Nil
//
VOID CPspStatusMonitorRas::FillDeviceDropDown(VOID)
{
    TraceFileFunc(ttidStatMon);

    INT                             iCmb    = 0;
    list<CRasDeviceInfo*>::iterator iterLstprdi;

    // Clear out the control
    //
    SendDlgItemMessage(IDC_CMB_SM_RAS_DEVICES, CB_RESETCONTENT, 0, 0L);

    // Put the devices in our list
    //
    iterLstprdi = m_lstprdi.begin();
    while (iterLstprdi != m_lstprdi.end())
    {
        // Create a new entry in the list
        //
        iCmb = SendDlgItemMessage(IDC_CMB_SM_RAS_DEVICES, CB_ADDSTRING, 0,
                (LPARAM)((*iterLstprdi)->PszGetDeviceName()));

        if (CB_ERR != iCmb)
        {
            // Store the vaule on the selection to make it easy to read later
            //
            SendDlgItemMessage(IDC_CMB_SM_RAS_DEVICES, CB_SETITEMDATA, iCmb,
                    (LPARAM)(*iterLstprdi));
        }

        iterLstprdi++;
    }

    // Set the first selection
    //
    SendDlgItemMessage(IDC_CMB_SM_RAS_DEVICES, CB_SETCURSEL, 0L, 0L);

    // Make sure the state of the button is correct
    //
    iCmb = SendDlgItemMessage(IDC_CMB_SM_RAS_DEVICES, CB_GETCURSEL,
            0L, 0L);
    if (CB_ERR != iCmb)
    {
        CRasDeviceInfo* prdiSelect  = NULL;

        // Get the object from the selection
        //
        prdiSelect = reinterpret_cast<CRasDeviceInfo*>(
                SendDlgItemMessage(
                    IDC_CMB_SM_RAS_DEVICES,
                    CB_GETITEMDATA,
                    iCmb,
                    0L));

        SetButtonStatus(prdiSelect);
    }

    // If the number of devices is less than or equal to one then
    // hide the device related group of controls
    //
    if (m_lstprdi.size() <= 1)
    {
        int nrgIdc[] = {IDC_CMB_SM_RAS_DEVICES, IDC_TXT_SM_NUM_DEVICES,
                        IDC_TXT_SM_NUM_DEVICES_VAL, IDC_BTN_SM_SUSPEND_DEVICE,
                        IDC_GB_SM_DEVICES};

        for (int nIdx=0; nIdx < celems(nrgIdc); nIdx++)
            ::ShowWindow(GetDlgItem(nrgIdc[nIdx]), SW_HIDE);

        // We can now display a larger properties window
        RECT rcRectDialog;
        if (GetWindowRect(&rcRectDialog))
        {
            RECT rcRectRasProperty;
            if (::GetWindowRect(GetDlgItem(IDC_LVW_RAS_PROPERTY), &rcRectRasProperty))
            {
                DWORD dwTopDiff    = rcRectRasProperty.top - rcRectDialog.top;
                DWORD dwLeftDiff   = rcRectRasProperty.left - rcRectDialog.left;
                DWORD dwRightDiff  = rcRectDialog.right  - rcRectRasProperty.right;
                DWORD dwBottomDiff = rcRectDialog.bottom - rcRectRasProperty.bottom;
                DWORD dwDialogWidth  = rcRectDialog.right - rcRectDialog.left;
                DWORD dwDialogHeight = rcRectDialog.bottom - rcRectDialog.top;

                rcRectRasProperty.top    = dwTopDiff;
                rcRectRasProperty.left   = dwLeftDiff;
                rcRectRasProperty.right  = dwDialogWidth  - dwRightDiff;
                rcRectRasProperty.bottom = dwDialogHeight - dwRightDiff;

                ::MoveWindow(GetDlgItem(IDC_LVW_RAS_PROPERTY), rcRectRasProperty.left, rcRectRasProperty.top, 
                    rcRectRasProperty.right - rcRectRasProperty.left, rcRectRasProperty.bottom - rcRectRasProperty.top, TRUE);
            }
        }

        // Disable the suspend button, so no one can activate it by keystroke
        //
        ::EnableWindow(GetDlgItem(IDC_BTN_SM_SUSPEND_DEVICE), FALSE);
    }
    else
    {
        // Set the number of active devices
        //
        UINT unActiveDeviceCount = GetActiveDeviceCount();

        SetDlgItemInt(
                IDC_TXT_SM_NUM_DEVICES_VAL,
                unActiveDeviceCount,
                FALSE);
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CPspStatusMonitorRas::OnSuspendDevice
//
//  Purpose:    Suspend the device that is in the combo box
//
//  Arguments:  Standard window message
//
//  Returns:    Standard return.
//
LRESULT CPspStatusMonitorRas::OnSuspendDevice(WORD wNotifyCode, WORD wID,
                                              HWND hWndCtl, BOOL& fHandled)
{
    TraceFileFunc(ttidStatMon);

    HRESULT hr = S_OK;

    if (BN_CLICKED == wNotifyCode)
    {
        // Get the item in the drop down
        //
        INT iCmb = SendDlgItemMessage(IDC_CMB_SM_RAS_DEVICES, CB_GETCURSEL,
                0L, 0L);
        if (CB_ERR != iCmb)
        {
            CRasDeviceInfo* prdiSelect  = NULL;
            NETCON_STATUS   ncsTemp     = NCS_DISCONNECTED;

            // Get the object from the selection
            //
            prdiSelect = reinterpret_cast<CRasDeviceInfo*>(
                        SendDlgItemMessage(
                        IDC_CMB_SM_RAS_DEVICES,
                        CB_GETITEMDATA,
                        iCmb,
                        0L));

            AssertSz(prdiSelect, "We should have a prdiSelect");
            AssertSz(m_hRasConn, "We should have a m_hRasConn");

            // Disable the button till the suspend/resume is done
            ::EnableWindow(GetDlgItem(IDC_BTN_SM_SUSPEND_DEVICE), FALSE);

            ncsTemp = NcsGetDeviceStatus(prdiSelect);
            if (fIsConnectedStatus(ncsTemp))
            {
                // If more than one active link exists, allow the hang up
                //
                UINT unActiveDeviceCount = GetActiveDeviceCount();
                if ( unActiveDeviceCount >1)
                {
                    HRASCONN        hrasconnSub = NULL;

                    // Get the handle to the sub entry and hangup
                    //
                    hr = ::HrRasGetSubEntryHandle(m_hRasConn,
                            prdiSelect->DwGetSubEntry(), &hrasconnSub);
                    if (SUCCEEDED(hr))
                    {
                        hr = ::HrRasHangUp(hrasconnSub);
                    }
                }
                else
                {
                    // Only one active link exists, prompt the user if
                    // they really wish to disconnect
                    //
                    HWND hwndPS = ::GetParent(m_hWnd);

                    if (IDYES == ::NcMsgBox(hwndPS,
                         IDS_SM_ERROR_CAPTION, IDS_SM_DISCONNECT_PROMPT,
                         MB_ICONEXCLAMATION | MB_YESNO | MB_DEFBUTTON2,
                         m_strConnectionName.c_str()))
                    {
                        AssertSz(m_pGenPage, "We should have a pointer to the general page.");

                        if (m_pGenPage)
                        {
                            hr = m_pGenPage->HrDisconnectConnection(TRUE);
                        }
                    }
                }
            }
            else
            {
                // if the link was disconnected, "resume"

                BOOL        fRet    = FALSE;
                RASDIALDLG  rdiTemp = { 0 };

                // Initialize the structure
                //
                rdiTemp.dwSize      = sizeof(RASDIALDLG);
                rdiTemp.hwndOwner   = m_hWnd;
                rdiTemp.dwSubEntry  = prdiSelect->DwGetSubEntry();

                // Dial the entry
                //
                fRet = RasDialDlg(
                        const_cast<PWSTR>(m_strPbkFile.c_str()),
                        const_cast<PWSTR>(m_strEntryName.c_str()),
                        NULL,
                        &rdiTemp);

                // We have an error.  See if the user canceled
                //
                if (ERROR_CANCELLED != rdiTemp.dwError)
                {
                    hr = HRESULT_FROM_WIN32(rdiTemp.dwError);
                }
            }

            // Regardless of what happened, set the status to it's new
            // state
            //
            SetButtonStatus(prdiSelect);

            // Re-Enable the button till the suspend/resume is done
            ::EnableWindow(GetDlgItem(IDC_BTN_SM_SUSPEND_DEVICE), TRUE);

            // Also update the active device count
            UINT unActiveDeviceCount = GetActiveDeviceCount();

            SetDlgItemInt(
                    IDC_TXT_SM_NUM_DEVICES_VAL,
                    unActiveDeviceCount,
                    FALSE);
        }
    }

    return 0;
}

//+---------------------------------------------------------------------------
//
//  Member:     CPspStatusMonitorRas::OnDeviceDropDown
//
//  Purpose:    Update the push button text when the combo-box selection changes
//
//  Arguments:  Standard window messsage parameters
//
//  Returns:    Standard window message return value
//
LRESULT CPspStatusMonitorRas::OnDeviceDropDown(WORD wNotifyCode, WORD wID,
        HWND hWndCtl, BOOL& fHandled)
{
    TraceFileFunc(ttidStatMon);

    if (CBN_SELCHANGE ==  wNotifyCode)
    {
        INT iCmb = SendDlgItemMessage(IDC_CMB_SM_RAS_DEVICES, CB_GETCURSEL,
                        0L, 0L);
        if (CB_ERR != iCmb)
        {
            CRasDeviceInfo*     prdiSelect  = NULL;
            INT                 idsButton   = 0;

            prdiSelect = reinterpret_cast<CRasDeviceInfo*>(
                    SendDlgItemMessage(
                        IDC_CMB_SM_RAS_DEVICES,
                        CB_GETITEMDATA,
                        iCmb,
                        0L));

            AssertSz(prdiSelect, "We should have a prdiSelect");

            if (fIsConnectedStatus(NcsGetDeviceStatus(prdiSelect)))
            {
                idsButton = IDS_SM_SUSPEND;
            }
            else
            {
                idsButton = IDS_SM_RESUME;
            }

            // Set the new name
            //
            SetDlgItemText(IDC_BTN_SM_SUSPEND_DEVICE,
                    ::SzLoadIds(idsButton));
        }
    }

    return 0;
}

//+---------------------------------------------------------------------------
//
//  Member:     CPspStatusMonitorRas::NcsGetDeviceStatus
//
//  Purpose:    Gets the status of one of the RAS subentries
//
//  Arguments:  prdiStatus -    Device to get status of
//
//  Returns:    The status of the device
//

LRESULT CPspStatusMonitorRas::OnUpdateRasLinkList(UINT uMsg, WPARAM wParam,
                                                 LPARAM lParam, BOOL& bHandled)
{
    TraceFileFunc(ttidStatMon);

    // Get the item in the drop down
    //
    INT iCmb = SendDlgItemMessage(IDC_CMB_SM_RAS_DEVICES, CB_GETCURSEL,
                                  0L, 0L);
    if (CB_ERR != iCmb)
    {
        CRasDeviceInfo* prdiSelect  = NULL;

        // Get the object from the selection
        //
        prdiSelect = reinterpret_cast<CRasDeviceInfo*>(
                        SendDlgItemMessage(
                        IDC_CMB_SM_RAS_DEVICES,
                        CB_GETITEMDATA,
                        iCmb,
                        0L));

        if (prdiSelect)
        {
            // Regardless of what happened, set the status to it's new
            // state
            //
            SetButtonStatus(prdiSelect);

            // Also update the active device count
            UINT unActiveDeviceCount = GetActiveDeviceCount();

            SetDlgItemInt(
                    IDC_TXT_SM_NUM_DEVICES_VAL,
                    unActiveDeviceCount,
                    FALSE);
        }
    }

    return 0;
}


//+---------------------------------------------------------------------------
//
//  Member:     CPspStatusMonitorRas::NcsGetDeviceStatus
//
//  Purpose:    Gets the status of one of the RAS subentries
//
//  Arguments:  prdiStatus -    Device to get status of
//
//  Returns:    The status of the device
//
NETCON_STATUS
CPspStatusMonitorRas::NcsGetDeviceStatus(
        CRasDeviceInfo* prdiStatus)
{
    TraceFileFunc(ttidStatMon);

    NETCON_STATUS   ncsStatus   = NCS_DISCONNECTED;
    HRESULT         hr          = S_OK;
    HRASCONN        hrasconnSub = NULL;

    TraceTag(ttidStatMon, " === Calling NcsGetDeviceStatus on device: %S, subentry: %d ===",
             prdiStatus->PszGetDeviceName(), prdiStatus->DwGetSubEntry());

    // Get the handle to the subentry so that we can
    // tell what state the connection is in.  If we
    // can't do that, assume it is disconnected
    //
    hr = HrRasGetSubEntryHandle(m_hRasConn,
            prdiStatus->DwGetSubEntry(), &hrasconnSub);

    TraceTag(ttidStatMon, "HrRasGetSubEntryHandle returns, hr = %x", hr);

    if (SUCCEEDED(hr))
    {
        hr = HrRasGetNetconStatusFromRasConnectStatus (
                hrasconnSub, &ncsStatus);

        TraceTag(ttidStatMon, "HrRasGetNetconStatusFromRasConnectStatus returns hr = %x, Status = %d",
                 hr, ncsStatus);
    }

    return ncsStatus;
}

//+---------------------------------------------------------------------------
//
//  Member:     CPspStatusMonitorRas::SetButtonStatus
//
//  Purpose:    Change the suspend/resume button to the correct state
//
//  Arguments:  prdiSelect -    The device that is selected
//
//  Returns:    Nil
//
VOID CPspStatusMonitorRas::SetButtonStatus(CRasDeviceInfo* prdiSelect)
{
    TraceFileFunc(ttidStatMon);

    //$ REVIEW : CWill : 02/25/98 : Common function?
    INT idsButton   = 0;

    if (fIsConnectedStatus(NcsGetDeviceStatus(prdiSelect)))
    {
        idsButton = IDS_SM_SUSPEND;
    }
    else
    {
        idsButton = IDS_SM_RESUME;
    }

    // Set the new name
    //
    SetDlgItemText(IDC_BTN_SM_SUSPEND_DEVICE,
            ::SzLoadIds(idsButton));
}

//+---------------------------------------------------------------------------
//
//  Function:   HrRasGetSubEntryHandle
//
//  Purpose:    Wrapper around RasGetSubEntryHandle
//
//  Arguments:  RasGetSubEntryHandle arguements
//
//  Returns:    Error code
//
HRESULT HrRasGetSubEntryHandle(HRASCONN hrasconn, DWORD dwSubEntry,
        HRASCONN* prasconnSub)
{
    TraceFileFunc(ttidStatMon);

    HRESULT hr      = S_OK;

    DWORD dwRet = ::RasGetSubEntryHandle(hrasconn, dwSubEntry,
            prasconnSub);
    if (dwRet)
    {
        hr = HRESULT_FROM_WIN32(dwRet);
    }

    TraceError("HrRasGetSubEntryHandle", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrRasHangUp
//
//  Purpose:    Wrapper around RasHangUp
//
//  Arguments:  RasHangUp arguements
//
//  Returns:    Error code
//
HRESULT HrRasHangUp(HRASCONN hrasconn)
{
    TraceFileFunc(ttidStatMon);
    
    HRESULT hr = S_OK;

    DWORD dwRet = ::RasHangUp(hrasconn);
    if (dwRet)
    {
        hr = HRESULT_FROM_WIN32(dwRet);
    }

    TraceError("HrRasHangUp", hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\statmon\smgenpsp.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998.
//
//  File:       S M G E N P S P . C P P
//
//  Contents:   The rendering of the UI for the network status monitor.
//
//  Notes:
//
//  Author:     CWill   6 Oct 1997
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

#include "foldinc.h"

#include "ncatlui.h"
#include "ncnetcon.h"
#include "ncperms.h"
#include "ncui.h"
#include "ncreg.h"
#include "nsres.h"
#include "sminc.h"
#include "smpsh.h"
#include "windutil.h"

#include "conprops.h"
#include "oncommand.h"

#include "pidlutil.h"

#include "openfold.h"
#include "..\folder\confold.h"
#include "cfpidl.h"

DWORD  MapRSSIToWirelessSignalStrength(int iRSSI);
PCWSTR PszGetRSSIString(int iRSSI);

//
//  Function Prototypes
//

VOID CompressionToSz(UINT uiCompression, WCHAR* pchbuffer);

//
//  Common Strings
//
extern const WCHAR c_szNetShellDll[];

//
//  Constants
//

const UINT  c_unLocalRefreshTimerID = 817;

//
//  ShowLanErrors
//
static const WCHAR  c_szRegKeyStatmonRoot[] = L"System\\CurrentControlSet\\Control\\Network\\Connections\\StatMon";
static const WCHAR  c_szShowLanErrors[]     = L"ShowLanErrors";

// forward declaration
DWORD PropertyThread(CNetStatisticsEngine * pnse);


//+---------------------------------------------------------------------------
//
//  Member:     CPspStatusMonitorGen::CPspStatusMonitorGen
//
//  Purpose:    Creator
//
//  Arguments:  None
//
//  Returns:    Nil
//
CPspStatusMonitorGen::CPspStatusMonitorGen() :
    m_psmEngineData(NULL),
    m_pnseStat(NULL),
    m_dwConPointCookie(0),
    m_fStats(FALSE),
    m_ncmType(NCM_LAN),
    m_ncsmType(NCSM_LAN),
    m_dwCharacter(0),
    m_dwLastUpdateStatusDisplayTick(0),
    m_fProcessingTimerEvent(FALSE),
    m_fIsFirstPage(FALSE),
    m_iLastSignalStrength(-100)
{
    TraceFileFunc(ttidStatMon);
}


//+---------------------------------------------------------------------------
//
//  Member:     CPspStatusMonitorGen::FinalRelease
//
//  Purpose:    Called after last Release.
//
//  Arguments:  None
//
//  Returns:    Nil
//
VOID
CPspStatusMonitorGen::FinalRelease(VOID)
{
    TraceFileFunc(ttidStatMon);
    
    (VOID) HrCleanupGenPage();
}

//+---------------------------------------------------------------------------
//
//  Member:     CPspStatusMonitorGen::HrInitGenPage
//
//  Purpose:    Before the property page is populated, we have to make sure
//              that we have some of the required data.  This method
//              initializes the page so that it is ready to be shown.
//
//  Arguments:  pnseNew - The statistics engine associated with this page
//              pncNew  - The connection the page is being created for
//
//  Returns:    Error code
//
HRESULT
CPspStatusMonitorGen::HrInitGenPage (
    CNetStatisticsEngine*   pnseNew,
    INetConnection*         pncNew,
    const DWORD *           adwHelpIDs)
{
    TraceFileFunc(ttidStatMon);

    HRESULT                     hr              = S_OK;
    INetStatisticsEngine*       pnseInter       = pnseNew;
              
    AssertSz(pnseNew, "We don't have a pnseNew");

    // Set context help ID
    m_adwHelpIDs = adwHelpIDs;

    // Initialize the engine data
    //
    AssertSz(!m_psmEngineData, "We should't have a m_psmEngineData");

    DWORD dwBytes = sizeof(STATMON_ENGINEDATA);
    PVOID pbBuf;
    hr = HrCoTaskMemAlloc(dwBytes, &pbBuf);
    if (SUCCEEDED(hr))
    {
        m_psmEngineData = reinterpret_cast<STATMON_ENGINEDATA *>(pbBuf);
        ZeroMemory(m_psmEngineData, sizeof(STATMON_ENGINEDATA));
    }

    // Advise the interface
    //
    if (SUCCEEDED(hr))
    {
        IConnectionPoint*   pcpStat = NULL;

        hr = ::HrGetPcpFromPnse(pnseInter, &pcpStat);
        if (SUCCEEDED(hr))
        {
            INetConnectionStatisticsNotifySink* pncsThis = this;

            hr = pcpStat->Advise(pncsThis, &m_dwConPointCookie);

            ::ReleaseObj(pcpStat);
        }
    }

    // Keep track of our owner
    //
    if (SUCCEEDED(hr))
    {
        AssertSz(!m_pnseStat, "We should't have a m_pnseStat");
        m_pnseStat = pnseNew;
        ::AddRefObj(pnseInter);
    }

    TraceError("CPspStatusMonitorGen::HrInitGenPage", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CPspStatusMonitorGen::OnInitDialog
//
//  Purpose:    When the page comes up, initialize the fields
//
//  Arguments:  Standard command parameters
//
//  Returns:    Standard return
//
LRESULT
CPspStatusMonitorGen::OnInitDialog (
    UINT    uMsg,
    WPARAM  wParam,
    LPARAM  lParam,
    BOOL&   bHandled)
{
    TraceFileFunc(ttidStatMon);
    
    // initialize data member
    m_iStatTrans = Stat_Unknown;

    // Initialize the icon in the dialog by forcing it to change
    //
    UpdatePageIcon(SMDCF_TRANSMITTING | SMDCF_RECEIVING);
    UpdatePageIcon(SMDCF_NULL);

    UpdateSignalStrengthIcon(0);

    // Tell the CNetStatisticsEngine about our parent property sheet
    // so if someone attempts to bring up a statistics monitor we
    // can utilize the existing one
    //
    Assert(m_pnseStat);
    m_pnseStat->SetPropsheetWindow(GetParent());

    // Start our local refresh timer with a 1 second period.
    //
    SetTimer (c_unLocalRefreshTimerID, 1000, NULL);

    // leaving creating mode
    m_pnseStat->UnSetCreatingDialog();

    BOOL fEnableDisconnect = TRUE;  // Should we disable the Disconnect button
    BOOL fEnableProperties = TRUE;  // Should we disable the Properties button
    BOOL fShowErrorCount = TRUE;
    
    switch(m_ncmType)
    {
    case NCM_LAN:
    case NCM_BRIDGE:
        fEnableDisconnect = FHasPermission(NCPERM_LanConnect);
        fEnableProperties = FHasPermission(NCPERM_LanProperties);
        if(!FIsShowLanErrorRegKeySet())
        {
            fShowErrorCount = FALSE;
        }
        ::ShowWindow(GetDlgItem(IDC_TXT_ERROR), fShowErrorCount);
        ::ShowWindow(GetDlgItem(IDC_TXT_SM_ERROR_TRANS), fShowErrorCount);
        ::ShowWindow(GetDlgItem(IDC_TXT_SM_ERROR_RECV), fShowErrorCount);
        ::ShowWindow(GetDlgItem(IDC_FRM_LONG), fShowErrorCount);
        ::ShowWindow(GetDlgItem(IDC_FRM_SHORT), !fShowErrorCount); // reversed...
        break;
    
    case NCM_SHAREDACCESSHOST_RAS:
        ::SetWindowText(GetDlgItem(IDC_PSB_DISCONNECT), ::SzLoadIds(IDS_SM_PSH_DISCONNECT)); // If RAS connection, change the "Disable" button to "Disconnect"
        //fallthru
    case NCM_SHAREDACCESSHOST_LAN:
        {
            // TODO fEnableDisconnect
            // TODO fEnableProperties
            HRESULT hr;

            fShowErrorCount = FALSE; // no error stuff in spec
        }
        break;
    
    case NCM_TUNNEL:
        ::ShowWindow(GetDlgItem(IDC_TXT_SM_SPEED_LABEL), FALSE);
        ::ShowWindow(GetDlgItem(IDC_TXT_SM_SPEED), FALSE);
        //fallthru
    
    case NCM_DIRECT: // REVIEW correct?
    case NCM_ISDN:
    case NCM_PHONE:
    case NCM_PPPOE:
        fEnableDisconnect = FHasPermission(NCPERM_RasConnect);
        if (
            (m_dwCharacter & NCCF_INCOMING_ONLY) ||
            ((m_dwCharacter & NCCF_ALL_USERS) && !FHasPermission(NCPERM_RasAllUserProperties)) ||
            (!(m_dwCharacter & NCCF_ALL_USERS) && !FHasPermission(NCPERM_RasMyProperties)) 
           )
        {
            fEnableProperties = FALSE;
        }
        ::SetWindowText(GetDlgItem(IDC_PSB_DISCONNECT), ::SzLoadIds(IDS_SM_PSH_DISCONNECT)); // If RAS connection, change the "Disable" button to "Disconnect"

        ::ShowWindow(GetDlgItem(IDC_TXT_ERROR), fShowErrorCount);
        ::ShowWindow(GetDlgItem(IDC_TXT_SM_ERROR_TRANS), fShowErrorCount);
        ::ShowWindow(GetDlgItem(IDC_TXT_SM_ERROR_RECV), fShowErrorCount);
        ::ShowWindow(GetDlgItem(IDC_FRM_LONG), fShowErrorCount);
        ::ShowWindow(GetDlgItem(IDC_FRM_SHORT), !fShowErrorCount); // reversed...
        break;
    
    default:
        AssertSz(FALSE, "Unknown media type");
        break;
    }
    
    ::EnableWindow(::GetDlgItem(m_hWnd, IDC_PSB_DISCONNECT), fEnableDisconnect);
    ::EnableWindow(::GetDlgItem(m_hWnd, IDC_PSB_PROPERTIES), fEnableProperties);

    if (m_fIsFirstPage)
    {
        // get window handle to propertysheet
        HWND hwndParent=GetParent();
        Assert(hwndParent);

        // center the property sheet on desktop
        FCenterWindow (hwndParent, NULL);
        
        // hide the "ok" button
        //
        ::ShowWindow(::GetDlgItem(hwndParent, IDOK), FALSE);
    }
	

    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CPspStatusMonitorGen::OnSetActive
//
//  Purpose:    Enable statistics when the page has focus
//
//  Arguments:  Standard notification parameters
//
//  Returns:    Standard return
//
LRESULT
CPspStatusMonitorGen::OnSetActive (
    INT     idCtrl,
    LPNMHDR pnmh,
    BOOL&   bHandled)
{
    TraceFileFunc(ttidStatMon);

    HRESULT     hr  = S_OK;

    // Only turn them on if they are not running
    //
    if (!m_fStats)
    {
        hr = m_pnseStat->StartStatistics();
        m_fStats = TRUE;
    }

    // User's intent is to view statistics, so give them an immediate
    // refreshed view of them.
    //
    ::PostMessage (m_hWnd, PWM_UPDATE_STATUS_DISPLAY, 0, SMDCF_NULL);

    TraceError("CPspStatusMonitorGen::OnSetActive", hr);
    return LresFromHr(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CPspStatusMonitorGen::OnKillActive
//
//  Purpose:    Disable statistics when the page is changed
//
//  Arguments:  Standard notification parameters
//
//  Returns:    Standard return
//
LRESULT
CPspStatusMonitorGen::OnKillActive (
    INT     idCtrl,
    LPNMHDR pnmh,
    BOOL&   bHandled)
{
    TraceFileFunc(ttidStatMon);

    HRESULT     hr  = S_OK;

    // Only turn them off if they are running
    //
    if (m_fStats)
    {
        hr = m_pnseStat->StopStatistics();
        m_fStats = FALSE;
    }

    TraceError("CPspStatusMonitorGen::OnKillActive", hr);
    return LresFromHr(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CPspStatusMonitorGen::OnClose
//
//  Purpose:    Cleans up the items in the page when the dialog is being
//              closed
//
//  Arguments:  Standard command parameters
//
//  Returns:    Standard return
//
LRESULT
CPspStatusMonitorGen::OnClose (
    UINT    uMsg,
    WPARAM  wParam,
    LPARAM  lParam,
    BOOL&   bHandled)
{
    return DestroyWindow();
}

//+---------------------------------------------------------------------------
//
//  Member:     CPspStatusMonitorGen::OnDestroy
//
//  Purpose:    Cleans up the items in the page when the dialog is being
//              destroyed
//
//  Arguments:  Standard command parameters
//
//  Returns:    Standard return
//
LRESULT
CPspStatusMonitorGen::OnDestroy (
    UINT    uMsg,
    WPARAM  wParam,
    LPARAM  lParam,
    BOOL&   bHandled)
{
    TraceFileFunc(ttidStatMon);

    HWND  hwndIcon = ::GetDlgItem(m_hWnd, IDI_SM_STATUS_ICON);
    HICON hOldIcon = reinterpret_cast<HICON>(::SendMessage(
            hwndIcon,
            STM_GETICON,
            0,
            0));

    if (hOldIcon)
    {
        DestroyIcon(hOldIcon);
    }


    HRESULT                 hr          = S_OK;

    AssertSz(m_pnseStat, "We should have a m_pnseStat");

    // Make sure we don't get released during our destroy
    //
    ::AddRefObj(this);

    // Stop our local refresh timer
    //
    KillTimer (c_unLocalRefreshTimerID);

    // Make sure stats are in a happy state
    //
    if (m_fStats)
    {
        (VOID) m_pnseStat->StopStatistics();
        m_fStats = FALSE;
    }

    //
    //  *** Do this last ***
    //
    //  It is very likely this will result in the this page being destroyed
    //  if it is the window closing
    //

    m_pnseStat->SetPropsheetWindow(NULL);

    // Clean up all the interfaces
    //
    hr = HrCleanupGenPage();

    ::ReleaseObj(this);

    TraceError("CPspStatusMonitorGen::OnDestroy", hr);
    return 0;
}

//+---------------------------------------------------------------------------
//
//  Member:     CPspStatusMonitorGen::HrCleanupGenPage
//
//  Purpose:    Cleans out all the interfaces that are used by the open page
//
//  Arguments:  None
//
//  Returns:    Error code
//
HRESULT
CPspStatusMonitorGen::HrCleanupGenPage (
    VOID)
{
    TraceFileFunc(ttidStatMon);

    HRESULT                 hr          = S_OK;
    INetStatisticsEngine*   pnseStat    = m_pnseStat;

    // Only disconnect if we haven't already.
    //
    if (pnseStat)
    {
        // Unadvise the interface
        //
        IConnectionPoint*       pcpStat     = NULL;

        if (m_dwConPointCookie
            && (SUCCEEDED(::HrGetPcpFromPnse(pnseStat, &pcpStat))))
        {
            (VOID) pcpStat->Unadvise(m_dwConPointCookie);

            ::ReleaseObj(pcpStat);

            // Very important to zero the cookie.  This tells
            // OnStatisticsChanged that we're no longer interested in updates.
            //
            m_dwConPointCookie = 0;
        }

        if (m_psmEngineData)
        {
            CoTaskMemFree(m_psmEngineData);
            m_psmEngineData = NULL;
        }

        //
        //  *** Do this last ***
        //
        //  It is very likely this will result in the this page being destroyed
        //  if it is the window closing
        //

        m_pnseStat = NULL;
        ::ReleaseObj(pnseStat);
    }

    TraceError("CPspStatusMonitorGen::HrCleanupGenPage", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CPspStatusMonitorGen::OnContextMenu
//
//  Purpose:    When right click a control, bring up help
//
//  Arguments:  Standard command parameters
//
//  Returns:    Standard return
//
LRESULT
CPspStatusMonitorGen::OnContextMenu(UINT uMsg,
                                    WPARAM wParam,
                                    LPARAM lParam,
                                    BOOL& fHandled)
{
    TraceFileFunc(ttidStatMon);

    if (m_adwHelpIDs != NULL)
    {
        ::WinHelp(m_hWnd,
                  c_szNetCfgHelpFile,
                  HELP_CONTEXTMENU,
                  (ULONG_PTR)m_adwHelpIDs);
    }
    return 0;
}

//+---------------------------------------------------------------------------
//
//  Member:     CPspStatusMonitorGen::OnHelp
//
//  Purpose:    When drag context help icon over a control, bring up help
//
//  Arguments:  Standard command parameters
//
//  Returns:    Standard return
//
LRESULT
CPspStatusMonitorGen::OnHelp(UINT uMsg,
                             WPARAM wParam,
                             LPARAM lParam,
                             BOOL& fHandled)
{
    TraceFileFunc(ttidStatMon);

    LPHELPINFO lphi = reinterpret_cast<LPHELPINFO>(lParam);
    Assert(lphi);

    if ((m_adwHelpIDs != NULL) && (HELPINFO_WINDOW == lphi->iContextType))
    {
        ::WinHelp(static_cast<HWND>(lphi->hItemHandle),
                  c_szNetCfgHelpFile,
                  HELP_WM_HELP,
                  (ULONG_PTR)m_adwHelpIDs);
    }

    return 0;
}

//+---------------------------------------------------------------------------
//
//  Member:     CPspStatusMonitorGen::OnDisconnect
//
//  Purpose:    When the disconnect button is hit, disconnect the connection
//              and closes the dialog
//
//  Arguments:  Standard notification parameters
//
//  Returns:    Standard return
//
LRESULT CPspStatusMonitorGen::OnDisconnect(WORD wNotifyCode, WORD wID,
                                           HWND hWndCtl, BOOL& fHandled)
{
    TraceFileFunc(ttidStatMon);

    HRESULT hr  = S_OK;

    switch (wNotifyCode)
    {
    case BN_CLICKED:
    case BN_DOUBLECLICKED:
        {
            hr = HrDisconnectConnection();
        }
    }

    TraceError("CPspStatusMonitorGen::OnDisconnect", hr);
    return 0;
}

//+---------------------------------------------------------------------------
//
//  Member:     CPspStatusMonitorGen::OnRaiseproperties
//
//  Purpose:    Bring up the property of this connection
//
//  Arguments:  Standard notification parameters
//
//  Returns:    Standard return
//
LRESULT CPspStatusMonitorGen::OnRaiseProperties(WORD wNotifyCode, WORD wID,
                                                HWND hWndCtl, BOOL& fHandled)
{
    TraceFileFunc(ttidStatMon);

    HRESULT hr  = S_OK;

    switch (wNotifyCode)
    {
    case BN_CLICKED:
    case BN_DOUBLECLICKED:
        {

            // Addref m_pnseStat object
            //
            AddRefObj(static_cast<INetStatisticsEngine *>(m_pnseStat));

            // Make sure the netshell.dll is not unloaded
            //
            HINSTANCE hInst = LoadLibrary(c_szNetShellDll);
            HANDLE hthrd = NULL;

            // Create the property sheet on a different thread
            //
            if (hInst)
            {
                DWORD  dwThreadId;
                hthrd = CreateThread(NULL, STACK_SIZE_TINY,
                                     (LPTHREAD_START_ROUTINE)PropertyThread,
                                     (LPVOID)m_pnseStat, 0, &dwThreadId);
            }

            if (NULL != hthrd)
            {
                CloseHandle(hthrd);
            }
            else
            {
                /// Release m_pnseStat object on failure
                //
                ReleaseObj(static_cast<INetStatisticsEngine *>(m_pnseStat));

                // release the dll 
                //
                if (hInst)
                    FreeLibrary(hInst);

                hr = HrFromLastWin32Error();
            }
        }
    }

    TraceError("CPspStatusMonitorGen::OnRaiseproperties", hr);
    return 0;
}

DWORD PropertyThread(CNetStatisticsEngine * pnse)
{
    TraceFileFunc(ttidStatMon);

    HRESULT hr = S_OK;
    BOOL    fUninitCom = TRUE;

    // Initialize COM on this thread
    //
    hr = CoInitializeEx(NULL, COINIT_DISABLE_OLE1DDE | COINIT_APARTMENTTHREADED);
    if (RPC_E_CHANGED_MODE == hr)
    {
        hr = S_OK;
        fUninitCom = FALSE;
    }

    if (SUCCEEDED(hr))
    {
        INetConnection* pncMonitor  = NULL;

        // Get the INetConnection
        //
        Assert (pnse);
        hr = pnse->HrGetConnectionFromBlob(&pncMonitor);

        if (SUCCEEDED(hr))
        {
            hr = HrRaiseConnectionProperties(NULL, pncMonitor);
        }
        ReleaseObj(pncMonitor);
    }

    if (fUninitCom)
    {
        CoUninitialize();
    }

    // release input interface
    ReleaseObj(static_cast<INetStatisticsEngine *>(pnse));

    // release the library we loaded
    FreeLibraryAndExitThread(GetModuleHandle(c_szNetShellDll), hr);

    TraceError("PropertyThread", hr);
    return 1;
}

//+---------------------------------------------------------------------------
//
//  Member:     CPspStatusMonitorGen::HrDisconnectConnection
//
//  Purpose:    disconnect the connection and closes the dialog if succeeded
//
//  Arguments:  fConfirmed  TRUE if the user has confirmed to disconnect the connection
//
//  Returns:    Standard return
//
HRESULT CPspStatusMonitorGen::HrDisconnectConnection(BOOL   fConfirmed)
{
    TraceFileFunc(ttidStatMon);

    HRESULT hr;

    Assert (m_pnseStat);

    // Get the INetConnection
    //
    INetConnection* pncMonitor;

    hr = m_pnseStat->HrGetConnectionFromBlob(&pncMonitor);
    if (SUCCEEDED(hr))
    {
        PCONFOLDPIDL pidlConnection;

        hr = HrCreateConFoldPidl(WIZARD_NOT_WIZARD, pncMonitor, pidlConnection);
        if (SUCCEEDED(hr))
        {
            CONFOLDENTRY ccfe;

            hr = pidlConnection.ConvertToConFoldEntry(ccfe);
            if (SUCCEEDED(hr))
            {
                // Get the pidl for the Connections Folder
                //
                PCONFOLDPIDLFOLDER pidlFolder;
                hr = HrGetConnectionsFolderPidl(pidlFolder);
                if (SUCCEEDED(hr))
                {
                    // Get the Connections Folder object
                    //
                    LPSHELLFOLDER psfConnections;

                    hr = HrGetConnectionsIShellFolder(pidlFolder, &psfConnections);
                    if (SUCCEEDED(hr))
                    {
                        hr = HrOnCommandDisconnectInternal(ccfe,
                                                           m_hWnd,
                                                           psfConnections);
                        ReleaseObj(psfConnections);
                    }
                }
            }
        }

        // release INetConnection interface
        ReleaseObj(pncMonitor);
    }

    // If anything above failed.
    //
    if (SUCCEEDED(hr))
    {
        if (S_OK == hr)
        {
            // close the property sheet
            HWND hwndPS = ::GetParent(m_hWnd);

            // Push the Close ("Cancel") button to close dialog
            //
            ::PostMessage(hwndPS, WM_COMMAND, MAKEWPARAM(IDCANCEL, 0),
                          (LPARAM)::GetDlgItem(hwndPS, IDCANCEL));
        }
        else
        {
            // Disconnect confirmation canceled. Do nothing (don't close
            // statmon, anyway).
            //
            AssertSz(S_FALSE == hr, "Disconnect != S_OK or S_FALSE, but succeeded? What is it then?");
        }
    }
    else
    {
        TraceError("pncMonitor->Disconnect", hr);

        // Warn the user and don't close if we couldn't disconnect
        //
        ::NcMsgBox( m_hWnd,
                    IDS_SM_ERROR_CAPTION,
                    IDS_SM_ERROR_CANNOT_DISCONNECT,
                    MB_ICONWARNING);
    }

    TraceError("CPspStatusMonitorGen::HrDisconnectConnection", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CPspStatusMonitorGen::OnSetCursor
//
//  Purpose:    Ensure the mouse cursor over the Property Sheet is an Arrow.
//
//  Arguments:  Standard command parameters
//
//  Returns:    Standard return
//

LRESULT
CPspStatusMonitorGen::OnSetCursor (
    UINT    uMsg,
    WPARAM  wParam,
    LPARAM  lParam,
    BOOL&   bHandled)
{
    TraceFileFunc(ttidStatMon);

    if (LOWORD(lParam) == HTCLIENT)
    {
        SetCursor(LoadCursor(NULL, IDC_ARROW));
    }

    return FALSE;
}

LRESULT
CPspStatusMonitorGen::OnTimer (
    UINT    uMsg,
    WPARAM  wParam,
    LPARAM  lParam,
    BOOL&   bHandled)
{
    TraceFileFunc(ttidStatMon);

    // Prevent same-thread re-entrancy.  Any Win32 call made while
    // processing this event that return control to the message
    // loop may cause this timer to fire again.
    //
    if (!m_fProcessingTimerEvent)
    {
        m_fProcessingTimerEvent = TRUE;

        // If we're within 200 milliseconds of the last time we updated the
        // status display, don't bother doing it again.  This covers the case
        // where our timer coincides with the timer in smcent which would
        // would cause us to update the status display twice in rapid
        // succession each time the timers fire.
        //
        DWORD dwTick = GetTickCount ();
        if (dwTick > m_dwLastUpdateStatusDisplayTick + 200)
        {
            OnUpdateStatusDisplay (uMsg, 0, m_dwChangeFlags, bHandled);
        }

        m_fProcessingTimerEvent = FALSE;
    }
    return 0;
}

LRESULT
CPspStatusMonitorGen::OnUpdateStatusDisplay(
    UINT    uMsg,
    WPARAM  wParam,
    LPARAM  lParam,
    BOOL&   bHandled)
{
    TraceFileFunc(ttidStatMon);

    HRESULT hr = S_OK;
    DWORD dwChangeFlags = lParam;

    // We may be in the process of disconnecting the statistics page in
    // which case m_dwConPointCookie will be zero.
    //
    if (m_dwConPointCookie)
    {
        Assert (m_psmEngineData);

        STATMON_ENGINEDATA*  psmNewData = NULL;
        hr = m_pnseStat->GetStatistics(&psmNewData);

        if (SUCCEEDED(hr) && psmNewData)
        {
            if (m_psmEngineData)
            {
                //
                // Display the new stats
                //
                UpdatePage(m_psmEngineData, psmNewData);

                // Update the icon image
                //
                UpdatePageIcon(dwChangeFlags);

                UpdateSignalStrengthIcon(psmNewData->SMED_802_11_SIGNAL_STRENGTH);

                // Note the clock tick of when we last updated
                // the status display.
                //
                m_dwLastUpdateStatusDisplayTick = GetTickCount();

                // Replace the old data with the new
                //
                CoTaskMemFree(m_psmEngineData);
            }

            m_psmEngineData = psmNewData;
        }
    }
    else
    {
        TraceTag (ttidStatMon,
            "CPspStatusMonitorGen::OnStatisticsChanged called but we've "
            "been closed.  Ignoring.");
    }
    TraceError("CPspStatusMonitorGen::OnUpdateStatusDisplay", hr);
    return 0;
}

//+---------------------------------------------------------------------------
//
//  Member:     CPspStatusMonitorGen::OnStatisticsChanged
//
//  Purpose:    This is the callback that tell the property page that the
//              data on the page has changed
//
//  Arguments:  dwCookie -      The cookie of the connection that has changed
//              dwChangeFlags - What has changed
//
//  Returns:    Error code
//
STDMETHODIMP
CPspStatusMonitorGen::OnStatisticsChanged(
    DWORD dwChangeFlags)
{
    TraceFileFunc(ttidStatMon);

    ::PostMessage (m_hWnd, PWM_UPDATE_STATUS_DISPLAY, 0, dwChangeFlags);
    return S_OK;
}


//+---------------------------------------------------------------------------
//
//  Member:     CPspStatusMonitorGen::UpdatePage
//
//  Purpose:    Fill the fields on the page with new data
//
//  Arguments:  pseOldData -    The old stats being displayed on the page
//              pseNewData -    The new stats being displayed on the page
//
//  Returns:    Nothing
//
VOID
CPspStatusMonitorGen::UpdatePage (
    STATMON_ENGINEDATA* pseOldData,
    const STATMON_ENGINEDATA* pseNewData)
{
    TraceFileFunc(ttidStatMon);

    AssertSz(pseOldData, "We don't have a puiOld");
    AssertSz(pseNewData, "We don't have a puiNew");

    //
    // Update the dialog fields
    //
    UpdatePageConnectionStatus(pseOldData, pseNewData);

    UpdatePageDuration(pseOldData, pseNewData);

    UpdatePageSpeed(pseOldData, pseNewData);

    // If the StatMon is not getting any bytes (a common problem with net
    // cards), display packets instead
    //
    if (ShouldShowPackets(pseNewData))
    {
        // Only change the label if we have to
        //
        if (Stat_Packets != m_iStatTrans)
        {
            SetDlgItemText(IDC_TXT_SM_BYTES_LABEL, ::SzLoadIds(IDS_SM_PACKETS));
            m_iStatTrans = Stat_Packets;

            // Force a refresh
            //
            pseOldData->SMED_PACKETSTRANSMITTING = 0;
            pseOldData->SMED_PACKETSRECEIVING = 0;
        }

        UpdatePageBytesTransmitting(pseOldData, pseNewData, Stat_Packets);
        UpdatePageBytesReceiving(pseOldData, pseNewData, Stat_Packets);
    }
    else
    {
        // Only change the label if we have to
        //
        if (Stat_Bytes != m_iStatTrans)
        {
            SetDlgItemText(IDC_TXT_SM_BYTES_LABEL, ::SzLoadIds(IDS_SM_BYTES));
            m_iStatTrans = Stat_Bytes;

            // Force a refresh
            //
            pseOldData->SMED_BYTESTRANSMITTING = 0;
            pseOldData->SMED_BYTESRECEIVING = 0;
        }

        UpdatePageBytesTransmitting(pseOldData, pseNewData, Stat_Bytes);
        UpdatePageBytesReceiving(pseOldData, pseNewData, Stat_Bytes);
    }

    UpdatePageCompTransmitting(pseOldData, pseNewData);
    UpdatePageCompReceiving(pseOldData, pseNewData);

    UpdatePageErrorsTransmitting(pseOldData, pseNewData);
    UpdatePageErrorsReceiving(pseOldData, pseNewData);
}

//+---------------------------------------------------------------------------
//
//  Member:     CPspStatusMonitorGen::ShouldShowPackets
//
//  Purpose:    Decided whether to show bytes or packets
//
//  Arguments:  pseNewData -    The new stats being displayed on the page
//
//  Returns:    Nothing
//

BOOL CPspStatusMonitorGen::ShouldShowPackets(const STATMON_ENGINEDATA* pseNewData)
{
    TraceFileFunc(ttidStatMon);

    return (0 == pseNewData->SMED_BYTESTRANSMITTING) && (0 == pseNewData->SMED_BYTESRECEIVING);
}


//+---------------------------------------------------------------------------
//
//  Member:     CPspStatusMonitorGen::UpdatePageSpeed
//
//  Purpose:    Updates the speed display on the general page
//
//  Arguments:  pseOldData -    The old stats being displayed on the page
//              pseNewData -    The new stats being displayed on the page
//
//  Returns:    Nothing
//
VOID
CPspStatusMonitorGen::UpdatePageSpeed(
    const STATMON_ENGINEDATA* pseOldData,
    const STATMON_ENGINEDATA* pseNewData)
{
    TraceFileFunc(ttidStatMon);

    AssertSz(pseOldData, "We don't have a pseOldData");
    AssertSz(pseNewData, "We don't have a pseNewData");

    // Get the data and see if either is different
    //
    if ((pseOldData->SMED_SPEEDTRANSMITTING != pseNewData->SMED_SPEEDTRANSMITTING)
        || (pseOldData->SMED_SPEEDRECEIVING != pseNewData->SMED_SPEEDRECEIVING))
    {
        WCHAR achBuffer[MAX_PATH];

        FormatTransmittingReceivingSpeed (
            pseNewData->SMED_SPEEDTRANSMITTING,
            pseNewData->SMED_SPEEDRECEIVING,
            achBuffer);

        // Set the control text.
        //
        SetDlgItemText(IDC_TXT_SM_SPEED, achBuffer);
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CPspStatusMonitorGen::UpdatePageConnectionStatus
//
//  Purpose:    Update the connections field on the property page
//
//  Arguments:  puiOldData -    The old stats being displayed on the page
//              puiNewData -    The new stats being displayed on the page
//
//  Returns:    Nothing
//
VOID
CPspStatusMonitorGen::UpdatePageConnectionStatus(
    const STATMON_ENGINEDATA* pseOldData,
    const STATMON_ENGINEDATA* pseNewData)
{
    TraceFileFunc(ttidStatMon);

    AssertSz(pseOldData, "We don't have a pseOldData");
    AssertSz(pseNewData, "We don't have a pseNewdata");

    // Update the Connection Status
    //
    if ((pseNewData->SMED_CONNECTIONSTATUS == NCS_DISCONNECTED) ||
        (pseOldData->SMED_CONNECTIONSTATUS != pseNewData->SMED_CONNECTIONSTATUS))
    {
        INT idsConnection   = IDS_SM_CS_DISCONNECTED;

        // Make sure our strings are still intact
        AssertSz((((IDS_SM_CS_DISCONNECTED + 1) == IDS_SM_CS_CONNECTING)
            && ((IDS_SM_CS_DISCONNECTED + 2) == IDS_SM_CS_CONNECTED)
            && ((IDS_SM_CS_DISCONNECTED + 3) == IDS_SM_CS_DISCONNECTING)
            && ((IDS_SM_CS_DISCONNECTED + 4) == IDS_SM_CS_HARDWARE_NOT_PRESENT)
            && ((IDS_SM_CS_DISCONNECTED + 5) == IDS_SM_CS_HARDWARE_DISABLED)
            && ((IDS_SM_CS_DISCONNECTED + 6) == IDS_SM_CS_HARDWARE_MALFUNCTION)),
                "Some one has been messing with connection status strings");

        idsConnection = (IDS_SM_CS_DISCONNECTED
                        + pseNewData->SMED_CONNECTIONSTATUS);

        if (idsConnection == IDS_SM_CS_DISCONNECTED)
        {
            // close the property sheet
            HWND hwndPS = ::GetParent(m_hWnd);

            TraceTag(ttidStatMon, "Closing Status Monitor page because status was: DISCONNECTED");
            // Push the Close ("Cancel") button to close dialog
            //
            ::PostMessage(hwndPS, WM_COMMAND, MAKEWPARAM(IDCANCEL, 0),
                          (LPARAM)::GetDlgItem(hwndPS, IDCANCEL));
        }
        else
        {
            SetDlgItemText(IDC_TXT_SM_STATUS, ::SzLoadIds(idsConnection));
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CPspStatusMonitorGen::UpdatePageIcon
//
//  Purpose:    Update the icon on the property page
//
//  Arguments:  dwChangeFlags -  The new changed state
//
//  Returns:    Nothing
//
VOID
CPspStatusMonitorGen::UpdatePageIcon (
    DWORD dwChangeFlags)
{
    TraceFileFunc(ttidStatMon);

    // If either of these have changed, change the icon
    // so we'll know to update the icon
    //
    if (((SMDCF_TRANSMITTING | SMDCF_RECEIVING) & m_dwChangeFlags)
        != ((SMDCF_TRANSMITTING | SMDCF_RECEIVING) & dwChangeFlags))
    {
        HICON   hStatusIcon    = 0;
        HWND    hwndIcon       = NULL;

        //  Get the new icon
        //
        hStatusIcon = GetCurrentConnectionStatusIconId(m_ncmType, m_ncsmType, m_dwCharacter, dwChangeFlags);
        if (hStatusIcon)
        {
            hwndIcon = ::GetDlgItem(m_hWnd, IDI_SM_STATUS_ICON);

            // Set the icon to the new one
            //
            HICON hOldIcon = reinterpret_cast<HICON>(::SendMessage(
                    hwndIcon,
                    STM_SETICON,
                    (WPARAM)hStatusIcon,
                    0));

            DestroyIcon(hOldIcon);
        }
    }

    // Keep the flags for the next update
    //
    m_dwChangeFlags = dwChangeFlags;
}

//+---------------------------------------------------------------------------
//
//  Member:     CPspStatusMonitorGen::UpdateSignalStrengthIcon
//
//  Purpose:    Update the icon on the property page
//
//  Arguments:  iRSSI -  The new signal strenghth
//
//  Returns:    Nothing
//
inline
VOID
CPspStatusMonitorGen::UpdateSignalStrengthIcon (
    INT iRSSI)
{
    TraceFileFunc(ttidStatMon);

    if (0 == iRSSI)
    {
        if (0 != m_iLastSignalStrength)
        {
            ::ShowWindow(::GetDlgItem(m_hWnd, IDC_TXT_SM_SIGNAL_STRENGTH),  SW_HIDE);
            ::ShowWindow(::GetDlgItem(m_hWnd, IDI_SM_SIGNAL_STRENGTH_ICON), SW_HIDE);
        }

        m_iLastSignalStrength = iRSSI;

        return;
    }
    else
    {
        if (0 == m_iLastSignalStrength)
        {
            ::ShowWindow(::GetDlgItem(m_hWnd, IDC_TXT_SM_SIGNAL_STRENGTH),  SW_SHOW);
            ::ShowWindow(::GetDlgItem(m_hWnd, IDI_SM_SIGNAL_STRENGTH_ICON), SW_SHOW);
        }
    }
    
    INT     idStatusIcon    = 0;
    m_iLastSignalStrength   = iRSSI;

    //  Get the new icon
    //
    idStatusIcon = IDI_802_11_LEVEL0 + MapRSSIToWirelessSignalStrength(iRSSI);

    HWND hwndSignalStrength = ::GetDlgItem(m_hWnd, IDI_SM_SIGNAL_STRENGTH_ICON);
    Assert(hwndSignalStrength);
    if (hwndSignalStrength) 
    {
        HDC hdcSignalStrength = ::GetDC(hwndSignalStrength);
        Assert(hdcSignalStrength);
        if (hdcSignalStrength)
        {

            HICON hIconSignalStrength = LoadIconTile(_Module.GetResourceInstance(), MAKEINTRESOURCE(idStatusIcon));
            Assert(hIconSignalStrength);
            if (hIconSignalStrength)
            {
                ::DrawIconEx(hdcSignalStrength, 0, 0, hIconSignalStrength, 48, 48, 0, NULL, DI_IMAGE | DI_MASK);
                DestroyIcon(hIconSignalStrength);
            }

            ::ReleaseDC(hwndSignalStrength, hdcSignalStrength);
        }
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CPspStatusMonitorGen::UpdateSignalStrengthIcon
//
//  Purpose:    Update the icon on the property page
//
//  Arguments:  iRSSI -  The new signal strenghth
//
//  Returns:    Nothing
//
LRESULT CPspStatusMonitorGen::OnPaint (
    UINT    uMsg,
    WPARAM  wParam,
    LPARAM  lParam,
    BOOL&   bHandled)
{
    TraceFileFunc(ttidStatMon);

    PAINTSTRUCT ps;
    BeginPaint(&ps);
    
    UpdateSignalStrengthIcon(m_iLastSignalStrength);
    
    EndPaint(&ps);

    bHandled = TRUE;
    return 0;
}

//+---------------------------------------------------------------------------
//
//  Member:     CPspStatusMonitorGen::UpdatePageDuration
//
//  Purpose:    Updates the duration display on the general page
//
//  Arguments:  pseOldData -    The old stats being displayed on the page
//              pseNewData -    The new stats being displayed on the page
//
//  Returns:    Nothing
//
VOID
CPspStatusMonitorGen::UpdatePageDuration(
    const STATMON_ENGINEDATA* pseOldData,
    const STATMON_ENGINEDATA* pseNewData)
{
    TraceFileFunc(ttidStatMon);

    AssertSz(pseOldData, "We don't have a pseOldData");
    AssertSz(pseNewData, "We don't have a pseNewData");

    // Get the see if either is different
    //
    if (pseOldData->SMED_DURATION != pseNewData->SMED_DURATION)
    {
        tstring strDuration;

        // Format the time duration as a string
        //
        FormatTimeDuration(pseNewData->SMED_DURATION, &strDuration);

        // Set the control
        //
        SetDlgItemText(IDC_TXT_SM_DURATION, strDuration.c_str());
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CPspStatusMonitorGen::UpdatePageBytesTransmitting
//
//  Purpose:    Updates the bytes Transmitting display on the general page
//
//  Arguments:  pseOldData -    The old stats being displayed on the page
//              pseNewData -    The new stats being displayed on the page
//              iStat      -    The which stats to display
//
//  Returns:    Nothing
//
VOID
CPspStatusMonitorGen::UpdatePageBytesTransmitting(
    const STATMON_ENGINEDATA* pseOldData,
    const STATMON_ENGINEDATA* pseNewData,
    StatTrans    iStat)
{
    TraceFileFunc(ttidStatMon);

    AssertSz(pseOldData, "We don't have a pseOldData");
    AssertSz(pseNewData, "We don't have a pseNewData");

    AssertSz(((Stat_Packets == iStat) || (Stat_Bytes == iStat)), "We have an invalid iStat");

    UINT64 ui64Old;
    UINT64 ui64New;

    if (Stat_Bytes == iStat)
    {
        ui64Old = pseOldData->SMED_BYTESTRANSMITTING;
        ui64New = pseNewData->SMED_BYTESTRANSMITTING;
    }
    else
    {
        ui64Old = pseOldData->SMED_PACKETSTRANSMITTING;
        ui64New = pseNewData->SMED_PACKETSTRANSMITTING;
    }

    // See if either is different
    //
    if (ui64Old != ui64New)
    {
        SetDlgItemFormatted64bitInteger(
            m_hWnd,
            IDC_TXT_SM_BYTES_TRANS,
            ui64New, FALSE);
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CPspStatusMonitorGen::UpdatePageBytesReceiving
//
//  Purpose:    Updates the bytes receiving display on the general page
//
//  Arguments:  puiOld -    The old stats being displayed on the page
//              puiNew -    The new stats being displayed on the page
//              iStat -     The which stats to display
//
//  Returns:    Nothing
//
VOID
CPspStatusMonitorGen::UpdatePageBytesReceiving(
    const STATMON_ENGINEDATA* pseOldData,
    const STATMON_ENGINEDATA* pseNewData,
    StatTrans    iStat)
{
    TraceFileFunc(ttidStatMon);

    AssertSz(pseOldData, "We don't have a puiOld");
    AssertSz(pseNewData, "We don't have a puiNew");
    AssertSz(((Stat_Packets == iStat) || (Stat_Bytes == iStat)), "We have an invalid iStat");

    UINT64 ui64Old;
    UINT64 ui64New;

    if (Stat_Bytes == iStat)
    {
        ui64Old = pseOldData->SMED_BYTESRECEIVING;
        ui64New = pseNewData->SMED_BYTESRECEIVING;
    }
    else
    {
        ui64Old = pseOldData->SMED_PACKETSRECEIVING;
        ui64New = pseNewData->SMED_PACKETSRECEIVING;
    }

    // See if either is different
    //
    if (ui64Old != ui64New)
    {
        SetDlgItemFormatted64bitInteger(
            m_hWnd,
            IDC_TXT_SM_BYTES_RCVD,
            ui64New, FALSE);
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CPspStatusMonitorGen::UpdatePageCompTransmitting
//
//  Purpose:    Updates the compression transmitting display on the general
//              page
//
//  Arguments:  pseOldData -    The old stats being displayed on the page
//              pseNewData -    The new stats being displayed on the page
//
//  Returns:    Nothing
//
VOID
CPspStatusMonitorGen::UpdatePageCompTransmitting(
    const STATMON_ENGINEDATA* pseOldData,
    const STATMON_ENGINEDATA* pseNewData)
{
    TraceFileFunc(ttidStatMon);

    AssertSz(pseOldData, "We don't have a pseOldData");
    AssertSz(pseNewData, "We don't have a pseNewData");

    // See if either is different
    //
    if (pseOldData->SMED_COMPRESSIONTRANSMITTING
            != pseNewData->SMED_COMPRESSIONTRANSMITTING)
    {
        WCHAR   achBuf[20];

        CompressionToSz(pseNewData->SMED_COMPRESSIONTRANSMITTING, achBuf);

        SetDlgItemText(IDC_TXT_SM_COMP_TRANS, achBuf);
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CPspStatusMonitorGen::UpdatePageCompReceiving
//
//  Purpose:    Updates the compression receiving display on the general page
//
//  Arguments:  pseOldData -    The old stats being displayed on the page
//              pseNewData -    The new stats being displayed on the page
//
//  Returns:    Nothing
//
VOID
CPspStatusMonitorGen::UpdatePageCompReceiving(
    const STATMON_ENGINEDATA* pseOldData,
    const STATMON_ENGINEDATA* pseNewData)
{
    TraceFileFunc(ttidStatMon);

    AssertSz(pseOldData, "We don't have a puiOld");
    AssertSz(pseNewData, "We don't have a puiNew");

    // see if either is different
    //
    if (pseOldData->SMED_COMPRESSIONRECEIVING != pseNewData->SMED_COMPRESSIONRECEIVING)
    {
        WCHAR   achBuf[20];

        CompressionToSz(pseNewData->SMED_COMPRESSIONRECEIVING, achBuf);

        SetDlgItemText(IDC_TXT_SM_COMP_RCVD, achBuf);
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CPspStatusMonitorGen::UpdatePageErrorsTransmitting
//
//  Purpose:    Updates the compression transmitting display on the general
//              page
//
//  Arguments:  pseOldData -    The old stats being displayed on the page
//              pseNewData -    The new stats being displayed on the page
//
//  Returns:    Nothing
//
VOID
CPspStatusMonitorGen::UpdatePageErrorsTransmitting(
    const STATMON_ENGINEDATA* pseOldData,
    const STATMON_ENGINEDATA* pseNewData)
{
    TraceFileFunc(ttidStatMon);

    AssertSz(pseOldData, "We don't have a pseOldData");
    AssertSz(pseNewData, "We don't have a pseNewData");

    // See if either is different
    //
    if (pseOldData->SMED_ERRORSTRANSMITTING
            != pseNewData->SMED_ERRORSTRANSMITTING)
    {
        SetDlgItemFormatted32bitInteger (
                m_hWnd,
                IDC_TXT_SM_ERROR_TRANS,
                pseNewData->SMED_ERRORSTRANSMITTING,
                FALSE);
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CPspStatusMonitorGen::UpdatePageErrorsReceiving
//
//  Purpose:    Updates the compression receiving display on the general page
//
//  Arguments:  pseOldData -    The old stats being displayed on the page
//              pseNewData -    The new stats being displayed on the page
//
//  Returns:    Nothing
//
VOID
CPspStatusMonitorGen::UpdatePageErrorsReceiving(
    const STATMON_ENGINEDATA* pseOldData,
    const STATMON_ENGINEDATA* pseNewData)
{
    TraceFileFunc(ttidStatMon);

    AssertSz(pseOldData, "We don't have a pseOldData");
    AssertSz(pseNewData, "We don't have a pseNewData");

    // see if either is different
    //
    if (pseOldData->SMED_ERRORSRECEIVING != pseNewData->SMED_ERRORSRECEIVING)
    {
        SetDlgItemFormatted32bitInteger (
                m_hWnd,
                IDC_TXT_SM_ERROR_RECV,
                pseNewData->SMED_ERRORSRECEIVING,
                FALSE);
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   CompressionToSz
//
//  Purpose:    To format nicely BPS into a readable string
//
//  Arguments:  uiCompression   - The amount of compression
//              pchBuffer       - The Buffer to receive the string
//
//  Returns:    Nothing
//
VOID
CompressionToSz (
    UINT    uiCompression,
    WCHAR*  pchBuffer)
{
    TraceFileFunc(ttidStatMon);

    AssertSz((((INT)uiCompression >= 0) && ((INT)uiCompression <= 100)),
        "Invalid compression");

    wsprintfW(pchBuffer, L"%lu %%", uiCompression);
}

//+---------------------------------------------------------------------------
//
//  Function:   FIsShowLanErrorRegKeySet
//
//  Purpose:    Check if the registry key is set:
//              System\CurrentControlSet\Control\Network\Connections\StatMon\ShowLanErrors
//
//  Arguments:
//
//  Returns:    Nothing
//
BOOL CPspStatusMonitorGen::FIsShowLanErrorRegKeySet()
{
    TraceFileFunc(ttidStatMon);

    BOOL fRet = FALSE;

    HKEY hkeyStatmonRoot = NULL;
    HRESULT hr = S_OK;

    // "System\\CurrentControlSet\\Control\\Network\\Connections\\StatMon\\ShowLanErrors"
    hr = ::HrRegOpenKeyEx(
            HKEY_LOCAL_MACHINE,
            c_szRegKeyStatmonRoot,
            KEY_READ,
            &hkeyStatmonRoot);

    if (SUCCEEDED(hr))
    {
        Assert(hkeyStatmonRoot);

        DWORD dwValue =0;
        hr = HrRegQueryDword(hkeyStatmonRoot, c_szShowLanErrors, &dwValue);

        if SUCCEEDED(hr)
        {
            fRet = !!dwValue;
        }
        RegCloseKey(hkeyStatmonRoot);
    }

    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\statmon\smsa.cpp ===
#include "pch.h"
#pragma hdrstop
#include "sminc.h"
#include "smpsh.h"
#include "ncui.h"
#include "ndispnp.h"

extern const WCHAR c_szDevice[];

#include "initguid.h"
DEFINE_GUID(CLSID_SharedAccessConnectionManager,            0xBA126AE0,0x2166,0x11D1,0xB1,0xD0,0x00,0x80,0x5F,0xC1,0x27,0x0E); // REMOVE

//+---------------------------------------------------------------------------
//
//  Member:     CSharedAccessStatEngine::CSharedAccessStatEngine
//
//  Purpose:    Creator
//
//  Arguments:  None
//
//  Returns:    Nil                                                                                                                             
//
CSharedAccessStatEngine::CSharedAccessStatEngine(VOID)
{
    
    m_ncmType = NCM_SHAREDACCESSHOST_LAN;
    m_ncsmType = NCSM_NONE;
    
    m_dwCharacter = 0;

    m_pGlobalInterfaceTable = NULL;
    m_dwCommonInterfaceCookie = 0;
    m_dwWANConnectionCookie = 0;

    m_bRequested = FALSE;
    m_Status = NCS_CONNECTED;
    m_ulTotalBytesSent = 0;
    m_ulTotalBytesReceived = 0;
    m_ulTotalPacketsSent = 0;
    m_ulTotalPacketsReceived = 0;
    m_ulUptime = 0;
    m_ulSpeedbps = 0;

    
    return;
}

HRESULT CSharedAccessStatEngine::FinalConstruct(VOID)
{
    HRESULT hr = S_OK;
    TraceError("CSharedAccessStatEngine::FinalConstruct", hr);
    return hr;    
}

HRESULT CSharedAccessStatEngine::FinalRelease(VOID)
{
    if(0 != m_dwCommonInterfaceCookie)
    {
        m_pGlobalInterfaceTable->RevokeInterfaceFromGlobal(m_dwCommonInterfaceCookie);
    }
    
    if(0 != m_dwWANConnectionCookie)
    {
        m_pGlobalInterfaceTable->RevokeInterfaceFromGlobal(m_dwWANConnectionCookie);
    }
    
    if(NULL != m_pGlobalInterfaceTable)
    {
        ReleaseObj(m_pGlobalInterfaceTable);
    }

    return S_OK;
}

HRESULT CSharedAccessStatEngine::Initialize(NETCON_MEDIATYPE MediaType, INetSharedAccessConnection* pNetSharedAccessConnection)
{
    HRESULT hr;
    
    m_ncmType = MediaType;
    m_ncsmType = NCSM_NONE;
    
    IGlobalInterfaceTable* pGlobalInterfaceTable;
    hr = HrCreateInstance(CLSID_StdGlobalInterfaceTable, CLSCTX_INPROC_SERVER, &m_pGlobalInterfaceTable);
    if(SUCCEEDED(hr))
    {
        GUID LocalDeviceGuid;
        hr = pNetSharedAccessConnection->GetLocalAdapterGUID(&LocalDeviceGuid);
        if(SUCCEEDED(hr))
        {
            const WCHAR c_szDevicePrefix[] = L"\\DEVICE\\";
            lstrcpy(m_szLocalDeviceGuidStorage, c_szDevicePrefix);
            SIZE_T DeviceLength = (sizeof(c_szDevicePrefix) / sizeof(WCHAR)) - 1;

            StringFromGUID2(LocalDeviceGuid, m_szLocalDeviceGuidStorage + DeviceLength, (sizeof(m_szLocalDeviceGuidStorage) / sizeof(WCHAR)) - DeviceLength);
            ::RtlInitUnicodeString(&m_LocalDeviceGuid, m_szLocalDeviceGuidStorage);
        
        }
        if(SUCCEEDED(hr))
        {
            IUPnPService* pWANCommonInterfaceConfigService;
            hr = pNetSharedAccessConnection->GetService(SAHOST_SERVICE_WANCOMMONINTERFACECONFIG, &pWANCommonInterfaceConfigService);
            if(SUCCEEDED(hr))
            {
                IUPnPService* pWANConnectionService;
                hr = pNetSharedAccessConnection->GetService(NCM_SHAREDACCESSHOST_LAN == m_ncmType ? SAHOST_SERVICE_WANIPCONNECTION : SAHOST_SERVICE_WANPPPCONNECTION, &pWANConnectionService);
                if(SUCCEEDED(hr))
                {
                    hr = m_pGlobalInterfaceTable->RegisterInterfaceInGlobal(pWANCommonInterfaceConfigService, IID_IUPnPService, &m_dwCommonInterfaceCookie);
                    if(SUCCEEDED(hr))
                    {
                        hr = m_pGlobalInterfaceTable->RegisterInterfaceInGlobal(pWANConnectionService, IID_IUPnPService, &m_dwWANConnectionCookie);
                    }
                    pWANConnectionService->Release();
                }
                pWANCommonInterfaceConfigService->Release();
            }
        }
    }
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CSharedAccessStatEngine::HrUpdateData
//
//  Purpose:    Get new statistics from the devices.  This data is used to be
//              displayed in the UI.
//
//  Arguments:  pdwChangeFlags -    Where to modify the changed flags.  This
//                      param may be NULL.
//
//  Returns:    Error code
//
HRESULT
CSharedAccessStatEngine::HrUpdateData (
                                       DWORD* pdwChangeFlags,
                                       BOOL*  pfNoLongerConnected)
{
    HRESULT hr  = S_OK;
    
    // Initialize the output parameter.
    //
    *pfNoLongerConnected = FALSE;
    
    EnterCriticalSection(&g_csStatmonData);
    
    // Make sure we have a statistics structure
    //
    if (!m_psmEngineData)
    {
        m_psmEngineData = new STATMON_ENGINEDATA;
        if (m_psmEngineData)
        {
            ZeroMemory(m_psmEngineData, sizeof(STATMON_ENGINEDATA));
        }
    }
    
    if (m_psmEngineData)
    {
        if(FALSE == m_bRequested) // protected statmondata critsec
        {
            InternalAddRef(); // bump the refcount so the callback will have a valid ref
            m_bRequested = TRUE;

            if(0 == QueueUserWorkItem(StaticUpdateStats, this, WT_EXECUTEDEFAULT))
            {
                InternalRelease(); 
                m_bRequested = FALSE;
            }
        }
        
        if (fIsConnectedStatus(m_Status))
        {
            m_psmEngineData->SMED_CONNECTIONSTATUS          =     NCS_CONNECTED;
            
            // Update shared access data
            UINT64 uOldPacketsTransmitting = m_psmEngineData->SMED_PACKETSTRANSMITTING;
            UINT64 uOldPacketsReceiving = m_psmEngineData->SMED_PACKETSRECEIVING;
            
            m_psmEngineData->SMED_BYTESTRANSMITTING = static_cast<UINT64>(m_ulTotalBytesSent);
            m_psmEngineData->SMED_BYTESRECEIVING = static_cast<UINT64>(m_ulTotalBytesReceived);
            m_psmEngineData->SMED_PACKETSTRANSMITTING = static_cast<UINT64>(m_ulTotalPacketsSent);
            m_psmEngineData->SMED_PACKETSRECEIVING = static_cast<UINT64>(m_ulTotalPacketsReceived);
            m_psmEngineData->SMED_DURATION = static_cast<UINT>(m_ulUptime);
            m_psmEngineData->SMED_SPEEDTRANSMITTING = static_cast<UINT>(m_ulSpeedbps);
            m_psmEngineData->SMED_SPEEDRECEIVING = static_cast<UINT>(m_ulSpeedbps);
            // update the change flags
            if (pdwChangeFlags)
            {
                
                *pdwChangeFlags = SMDCF_NULL;
                
                if(uOldPacketsTransmitting != m_psmEngineData->SMED_PACKETSTRANSMITTING)
                {
                    *pdwChangeFlags |= SMDCF_TRANSMITTING;
                }
                
                if(uOldPacketsReceiving != m_psmEngineData->SMED_PACKETSRECEIVING)
                {
                    *pdwChangeFlags |= SMDCF_RECEIVING;
                }
            }
            
            HrGetAutoNetSetting(m_guidId, &(m_psmEngineData->SMED_DHCP_ADDRESS_TYPE) );
            m_psmEngineData->SMED_INFRASTRUCTURE_MODE = IM_NOT_SUPPORTED;            
            
            NIC_STATISTICS  nsNewLanStats;
            ZeroMemory(&nsNewLanStats, sizeof(nsNewLanStats));
            nsNewLanStats.Size = sizeof(NIC_STATISTICS);
            if(::NdisQueryStatistics(&m_LocalDeviceGuid, &nsNewLanStats))
            {
                m_psmEngineData->SMED_SALOCAL_BYTESTRANSMITTING = nsNewLanStats.BytesSent;
                m_psmEngineData->SMED_SALOCAL_BYTESRECEIVING = nsNewLanStats.DirectedBytesReceived;
                m_psmEngineData->SMED_SALOCAL_PACKETSTRANSMITTING =  nsNewLanStats.PacketsSent;
                m_psmEngineData->SMED_SALOCAL_PACKETSRECEIVING = nsNewLanStats.DirectedPacketsReceived;
            }
        }
        else
        {
            *pfNoLongerConnected = TRUE;
            m_psmEngineData->SMED_CONNECTIONSTATUS = NCS_DISCONNECTED;
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    LeaveCriticalSection(&g_csStatmonData);

    TraceError("CSharedAccessStatEngine::HrUpdateData", hr);
    return hr;
}

HRESULT CSharedAccessStatEngine::UpdateStats()
{
    HRESULT hr = S_OK;
    
    IUPnPService* pWANConnection;
    hr = m_pGlobalInterfaceTable->GetInterfaceFromGlobal(m_dwWANConnectionCookie, IID_IUPnPService, reinterpret_cast<void**>(&pWANConnection));
    if(SUCCEEDED(hr))
    {
        IUPnPService* pWANCommonInterfaceConfig;
        hr = m_pGlobalInterfaceTable->GetInterfaceFromGlobal(m_dwCommonInterfaceCookie, IID_IUPnPService, reinterpret_cast<void**>(&pWANCommonInterfaceConfig));
        if(SUCCEEDED(hr))
        {
            
            BSTR ConnectionStatus;
            hr = GetStringStateVariable(pWANConnection, L"ConnectionStatus", &ConnectionStatus);
            if(SUCCEEDED(hr))
            {
                if(0 == lstrcmp(ConnectionStatus, L"Connected"))
                {
                    m_Status = NCS_CONNECTED;
                    
                    VARIANT OutArgs;
                    hr = InvokeVoidAction(pWANCommonInterfaceConfig, L"X_GetICSStatistics", &OutArgs);
                    if(SUCCEEDED(hr))
                    {
                        SAFEARRAY* pArray = V_ARRAY(&OutArgs);
                        
                        LONG lIndex = 0;
                        VARIANT Param;
                        
                        lIndex = 0;
                        hr = SafeArrayGetElement(pArray, &lIndex, &Param);
                        if(SUCCEEDED(hr))
                        {
                            if(V_VT(&Param) == VT_UI4)
                            {
                                m_ulTotalBytesSent = V_UI4(&Param);
                            }
                            VariantClear(&Param);
                        }
                        
                        lIndex = 1;
                        hr = SafeArrayGetElement(pArray, &lIndex, &Param);
                        if(SUCCEEDED(hr))
                        {
                            if(V_VT(&Param) == VT_UI4)
                            {
                                m_ulTotalBytesReceived = V_UI4(&Param);
                            }
                            VariantClear(&Param);
                        }
                        
                        lIndex = 2;
                        hr = SafeArrayGetElement(pArray, &lIndex, &Param);
                        if(SUCCEEDED(hr))
                        {
                            if(V_VT(&Param) == VT_UI4)
                            {
                                m_ulTotalPacketsSent = V_UI4(&Param);
                            }
                            VariantClear(&Param);
                        }
                        
                        lIndex = 3;
                        hr = SafeArrayGetElement(pArray, &lIndex, &Param);
                        if(SUCCEEDED(hr))
                        {
                            if(V_VT(&Param) == VT_UI4)
                            {
                                m_ulTotalPacketsReceived = V_UI4(&Param);
                            }
                            VariantClear(&Param);
                        }
                        
                        lIndex = 4;
                        hr = SafeArrayGetElement(pArray, &lIndex, &Param);
                        if(SUCCEEDED(hr))
                        {
                            if(V_VT(&Param) == VT_UI4)
                            {
                                m_ulSpeedbps = V_UI4(&Param);
                            }
                            VariantClear(&Param);
                        }
                        
                        lIndex = 5;
                        hr = SafeArrayGetElement(pArray, &lIndex, &Param);
                        if(SUCCEEDED(hr))
                        {
                            if(V_VT(&Param) == VT_UI4)
                            {
                                m_ulUptime = V_UI4(&Param);
                            }
                            VariantClear(&Param);
                        }
                        
                        VariantClear(&OutArgs);
                    }
                    else if(UPNP_E_INVALID_ACTION == hr) // gateway does not support our custom action, revert to default chatty behavior
                    {
                        VARIANT OutArgs;
                        LONG lIndex = 0;
                        VARIANT Param;
                        
                        hr = InvokeVoidAction(pWANCommonInterfaceConfig, L"GetTotalBytesSent", &OutArgs);
                        if(SUCCEEDED(hr))
                        {
                            lIndex = 0;
                            hr = SafeArrayGetElement(V_ARRAY(&OutArgs), &lIndex, &Param);
                            if(SUCCEEDED(hr))
                            {
                                if(V_VT(&Param) == VT_UI4)
                                {
                                    m_ulTotalBytesSent = V_UI4(&Param);
                                }
                                VariantClear(&Param);
                            }
                            VariantClear(&OutArgs);
                        }
                        
                        if(SUCCEEDED(hr))
                        {
                            lIndex = 0;
                            hr = InvokeVoidAction(pWANCommonInterfaceConfig, L"GetTotalBytesReceived", &OutArgs);
                            if(SUCCEEDED(hr))
                            {
                                hr = SafeArrayGetElement(V_ARRAY(&OutArgs), &lIndex, &Param);
                                if(SUCCEEDED(hr))
                                {
                                    if(V_VT(&Param) == VT_UI4)
                                    {
                                        m_ulTotalBytesReceived = V_UI4(&Param);
                                    }
                                    VariantClear(&Param);
                                }
                                VariantClear(&OutArgs);
                            }
                        }
                        if(SUCCEEDED(hr))
                        {
                            lIndex = 0;
                            hr = InvokeVoidAction(pWANCommonInterfaceConfig, L"GetTotalPacketsSent", &OutArgs);
                            if(SUCCEEDED(hr))
                            {
                                hr = SafeArrayGetElement(V_ARRAY(&OutArgs), &lIndex, &Param);
                                if(SUCCEEDED(hr))
                                {
                                    if(V_VT(&Param) == VT_UI4)
                                    {
                                        m_ulTotalPacketsSent = V_UI4(&Param);
                                    }
                                    VariantClear(&Param);
                                }
                                VariantClear(&OutArgs);
                            }
                        }
                        if(SUCCEEDED(hr))
                        {
                            hr = InvokeVoidAction(pWANCommonInterfaceConfig, L"GetTotalPacketsReceived", &OutArgs);
                            if(SUCCEEDED(hr))
                            {
                                lIndex = 0;
                                hr = SafeArrayGetElement(V_ARRAY(&OutArgs), &lIndex, &Param);
                                if(SUCCEEDED(hr))
                                {
                                    if(V_VT(&Param) == VT_UI4)
                                    {
                                        m_ulTotalPacketsReceived = V_UI4(&Param);
                                    }
                                    VariantClear(&Param);
                                }
                                VariantClear(&OutArgs);
                            }
                        }
                        if(SUCCEEDED(hr))
                        {
                            hr = InvokeVoidAction(pWANCommonInterfaceConfig, L"GetCommonLinkProperties", &OutArgs);
                            if(SUCCEEDED(hr))
                            {
                                lIndex = 2;
                                hr = SafeArrayGetElement(V_ARRAY(&OutArgs), &lIndex, &Param);
                                if(SUCCEEDED(hr))
                                {
                                    if(V_VT(&Param) == VT_UI4)
                                    {
                                        m_ulSpeedbps = V_UI4(&Param);
                                    }
                                    VariantClear(&Param);
                                }
                                VariantClear(&OutArgs);
                            }
                        }
                        if(SUCCEEDED(hr))
                        {
                            hr = InvokeVoidAction(pWANConnection, L"GetStatusInfo", &OutArgs);
                            if(SUCCEEDED(hr))
                            {
                                lIndex = 2;
                                hr = SafeArrayGetElement(V_ARRAY(&OutArgs), &lIndex, &Param);
                                if(SUCCEEDED(hr))
                                {
                                    if(V_VT(&Param) == VT_UI4)
                                    {
                                        m_ulUptime = V_UI4(&Param);
                                    }
                                    VariantClear(&Param);
                                }
                                VariantClear(&OutArgs);
                            }
                        }
                        
                        if(UPNP_E_INVALID_ACTION == hr)
                        {
                            hr = S_OK; // server does not support statistics
                            
                            m_ulTotalBytesSent = 0;
                            m_ulTotalBytesReceived = 0;
                            m_ulTotalPacketsSent = 0;
                            m_ulTotalPacketsReceived = 0;
                            m_ulSpeedbps = 0;
                            m_ulUptime = 0;
                        }
                    }
                    
                    if(FAILED(hr))
                    {
                        m_Status = NCS_DISCONNECTED;
                    }
                }
                else
                {
                    m_Status = NCS_DISCONNECTED;
                }
                SysFreeString(ConnectionStatus);
            }
            ReleaseObj(pWANCommonInterfaceConfig);
        }
        ReleaseObj(pWANConnection);
    }

    m_bRequested = FALSE;
    InternalRelease(); // release ref given to us in HrUpdateData
    
    return hr;
}

DWORD CSharedAccessStatEngine::StaticUpdateStats(LPVOID lpParameter)
{
    HRESULT hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);
    if(SUCCEEDED(hr))
    {
        CSharedAccessStatEngine* pThis = reinterpret_cast<CSharedAccessStatEngine*>(lpParameter);
        hr = pThis->UpdateStats();        

        CoUninitialize();
    }
    return 0;
}

HRESULT CSharedAccessStatEngine::GetStringStateVariable(IUPnPService* pService, LPWSTR pszVariableName, BSTR* pString)
{
    HRESULT hr = S_OK;
    
    VARIANT Variant;
    VariantInit(&Variant);

    BSTR VariableName; 
    VariableName = SysAllocString(pszVariableName);
    if(NULL != VariableName)
    {
        hr = pService->QueryStateVariable(VariableName, &Variant);
        if(SUCCEEDED(hr))
        {
            if(V_VT(&Variant) == VT_BSTR)
            {
                *pString = V_BSTR(&Variant);
            }
            else
            {
                hr = E_UNEXPECTED;
            }
        }
        
        if(FAILED(hr))
        {
            VariantClear(&Variant);
        }
        
        SysFreeString(VariableName);
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    TraceHr (ttidError, FAL, hr, FALSE, "CSharedAccessConnection::GetStringStateVariable");

    return hr;

}

   
HRESULT CSharedAccessStatEngine::InvokeVoidAction(IUPnPService * pService, LPTSTR pszCommand, VARIANT* pOutParams)
{
    HRESULT hr;
    BSTR bstrActionName;

    bstrActionName = SysAllocString(pszCommand);
    if (NULL != bstrActionName)
    {
        SAFEARRAYBOUND  rgsaBound[1];
        SAFEARRAY       * psa = NULL;

        rgsaBound[0].lLbound = 0;
        rgsaBound[0].cElements = 0;

        psa = SafeArrayCreate(VT_VARIANT, 1, rgsaBound);

        if (psa)
        {
            LONG    lStatus;
            VARIANT varInArgs;
            VARIANT varReturnVal;

            VariantInit(&varInArgs);
            VariantInit(pOutParams);
            VariantInit(&varReturnVal);

            varInArgs.vt = VT_VARIANT | VT_ARRAY;

            V_ARRAY(&varInArgs) = psa;

            hr = pService->InvokeAction(bstrActionName,
                                        varInArgs,
                                        pOutParams,
                                        &varReturnVal);
            if(SUCCEEDED(hr))
            {
                VariantClear(&varReturnVal);
            }

            SafeArrayDestroy(psa);
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }   

        SysFreeString(bstrActionName);
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }
    return hr;
}

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
//  CPspSharedAccessGen                                                              //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

CPspSharedAccessGen::CPspSharedAccessGen(VOID)
{
    m_ncmType = NCM_SHAREDACCESSHOST_LAN;
    m_ncsmType = NCSM_NONE;

    m_dwCharacter =0;
    m_adwHelpIDs = NULL;
    return;
}

//+---------------------------------------------------------------------------
//
//  Member:     CPspSharedAccessGen::put_MediaType
//
//  Purpose:    Set the media typew
//
//  Arguments:  ncm  -    the media type
//              ncsm -    the submedia type
//
//  Returns:    Nothing
//

void CPspSharedAccessGen::put_MediaType(NETCON_MEDIATYPE ncm, NETCON_SUBMEDIATYPE ncsm)
{
    m_ncmType  = ncm;
    m_ncsmType = ncsm;
}

//+---------------------------------------------------------------------------
//
//  Member:     CPspSharedAccessGen::ShouldShowPackets
//
//  Purpose:    Decided whether to show bytes or packets
//
//  Arguments:  pseNewData -    The new stats being displayed on the page
//
//  Returns:    Nothing
//

BOOL CPspSharedAccessGen::ShouldShowPackets(const STATMON_ENGINEDATA* pseNewData)
{
    return (((0 == pseNewData->SMED_BYTESTRANSMITTING) && (0 == pseNewData->SMED_BYTESRECEIVING)) || 
        ((0 == pseNewData->SMED_SALOCAL_BYTESTRANSMITTING) && (0 == pseNewData->SMED_SALOCAL_BYTESRECEIVING))); // REVIEW assuming all adapters can show packets
}
    
//+---------------------------------------------------------------------------
//
//  Member:     CPspSharedAccessGen::UpdatePageBytesTransmitting
//
//  Purpose:    Updates the bytes Transmitting display for the ICS host on the general page
//
//  Arguments:  pseOldData -    The old stats being displayed on the page
//              pseNewData -    The new stats being displayed on the page
//              iStat      -    The which stats to display
//
//  Returns:    Nothing
//
VOID
CPspSharedAccessGen::UpdatePageBytesTransmitting(
    const STATMON_ENGINEDATA* pseOldData,
    const STATMON_ENGINEDATA* pseNewData,
    StatTrans    iStat)
{
    if(0 != pseNewData->SMED_SPEEDTRANSMITTING) // we use 0 in the speed field to indicate that statistics are not valid
    {
        CPspStatusMonitorGen::UpdatePageBytesTransmitting(pseOldData, pseNewData, iStat);  // First update the local data
    }
    else
    {
        SetDlgItemText(IDC_TXT_SM_BYTES_TRANS, SzLoadIds(IDS_SM_NOTAVAILABLE));
    }
    
    UINT64 ui64Old;
    UINT64 ui64New;

    if (Stat_Bytes == iStat)
    {
        ui64Old = pseOldData->SMED_SALOCAL_BYTESTRANSMITTING;
        ui64New = pseNewData->SMED_SALOCAL_BYTESTRANSMITTING;
    }
    else
    {
        ui64Old = pseOldData->SMED_SALOCAL_PACKETSTRANSMITTING;
        ui64New = pseNewData->SMED_SALOCAL_PACKETSTRANSMITTING;
    }

    // See if either is different
    //
    if (ui64Old != ui64New)
    {
        SetDlgItemFormatted64bitInteger(
            m_hWnd,
            IDC_TXT_SM_SALOCAL_BYTES_TRANS,
            ui64New, FALSE);
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CPspSharedAccessGen::UpdatePageBytesReceiving
//
//  Purpose:    Updates the bytes receiving display for the ICS host on the general page
//
//  Arguments:  puiOld -    The old stats being displayed on the page
//              puiNew -    The new stats being displayed on the page
//              iStat -     The which stats to display
//
//  Returns:    Nothing
//
VOID
CPspSharedAccessGen::UpdatePageBytesReceiving(
    const STATMON_ENGINEDATA* pseOldData,
    const STATMON_ENGINEDATA* pseNewData,
    StatTrans    iStat)
{
    if(0 != pseNewData->SMED_SPEEDTRANSMITTING) // we use 0 in the speed field to indicate that statistics are not valid
    {
        CPspStatusMonitorGen::UpdatePageBytesReceiving(pseOldData, pseNewData, iStat);  // First update the local data
    }
    else
    {
        SetDlgItemText(IDC_TXT_SM_BYTES_RCVD, SzLoadIds(IDS_SM_NOTAVAILABLE));
    }
    
    UINT64 ui64Old;
    UINT64 ui64New;

    if (Stat_Bytes == iStat)
    {
        ui64Old = pseOldData->SMED_SALOCAL_BYTESRECEIVING;
        ui64New = pseNewData->SMED_SALOCAL_BYTESRECEIVING;
    }
    else
    {
        ui64Old = pseOldData->SMED_SALOCAL_PACKETSRECEIVING;
        ui64New = pseNewData->SMED_SALOCAL_PACKETSRECEIVING;
    }

    // See if either is different
    //
    if (ui64Old != ui64New)
    {
        SetDlgItemFormatted64bitInteger(
            m_hWnd,
            IDC_TXT_SM_SALOCAL_BYTES_RCVD,
            ui64New, FALSE);
    }
}

VOID CPspSharedAccessGen::UpdatePageIcon(DWORD dwChangeFlags)
{
    // Keep the flags for the next update
    //
    m_dwChangeFlags = dwChangeFlags;
}

VOID CPspSharedAccessGen::UpdatePageSpeed(
    const STATMON_ENGINEDATA* pseOldData,
    const STATMON_ENGINEDATA* pseNewData)
{
    if(0 != pseNewData->SMED_SPEEDTRANSMITTING)  // we use 0 in the speed field to indicate that statistics are not valid
    {
        CPspStatusMonitorGen::UpdatePageSpeed(pseOldData, pseNewData);
    }
    else
    {
        SetDlgItemText(IDC_TXT_SM_SPEED, SzLoadIds(IDS_SM_NOTAVAILABLE));
    }
}

VOID
CPspSharedAccessGen::UpdatePageDuration(
    const STATMON_ENGINEDATA* pseOldData,
    const STATMON_ENGINEDATA* pseNewData)
{
    if(0 != pseNewData->SMED_SPEEDTRANSMITTING)  // we use 0 in the speed field to indicate that statistics are not valid
    {
        CPspStatusMonitorGen::UpdatePageDuration(pseOldData, pseNewData);
    }
    else
    {
        SetDlgItemText(IDC_TXT_SM_DURATION, SzLoadIds(IDS_SM_NOTAVAILABLE));
    }
}




//////////////////////////////////////////////////////////////////////////////
//                                                                          //
//  CPspSharedAccessTool                                                             //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

CPspSharedAccessTool::CPspSharedAccessTool(VOID)
{
    m_ncmType = NCM_SHAREDACCESSHOST_LAN;
    m_ncsmType = NCSM_NONE;
    m_dwCharacter = 0;

    return;
}

//+---------------------------------------------------------------------------
//
//  Member:     CPspSharedAccessTool::HrInitToolPageType
//
//  Purpose:    Gets from the connection any information that is relevant to
//              this particular connection type.
//
//  Arguments:  pncInit -   The connection assocatied with this dialog
//
//  Returns:    Error code
//
HRESULT CPspSharedAccessTool::HrInitToolPageType(INetConnection* pncInit)
{
    HRESULT hr  = S_OK;


    TraceError("CPspSharedAccessTool::HrInitToolPageType", hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Member:     CPspSharedAccessTool::HrAddCommandLineFlags
//
//  Purpose:    Adds the flags for this selection to the command line for the
//              tool being launched.
//
//  Arguments:  pstrFlags - The command line that the flags have to be
//                      appended to
//              psmteSel    - The tool entry associated with this selection
//
//  Returns:    Error code
//
HRESULT CPspSharedAccessTool::HrAddCommandLineFlags(tstring* pstrFlags,
        CStatMonToolEntry* psmteSel)
{
    HRESULT hr  = S_OK;
    DWORD   dwFlags = 0x0;

    // Same some indirections
    //
    dwFlags = psmteSel->dwFlags;

    //
//    //  Check what flags are asked for and provide them if we can
//    //
//
//    if (SCLF_ADAPTER & dwFlags)
//    {
//        pstrFlags->append(c_szCmdLineFlagPrefix);
//        pstrFlags->append(g_asmtfMap[STFI_ADAPTER].pszFlag);
//        pstrFlags->append(c_szSpace);
//        pstrFlags->append(m_strLocalDeviceName);
//    }

    TraceError("CPspStatusMonitorTool::HrAddCommandLineFlags", hr);
    return hr;
}

HRESULT CPspSharedAccessTool::HrGetDeviceType(INetConnection* pncInit)
{
    UINT            uiRet           = 0;

    // Set the default type
    m_strDeviceType = L"Ethernet";


    return S_OK;
}

HRESULT CPspSharedAccessTool::HrGetComponentList(INetConnection* pncInit)
{
    // Get a readonly INetCfg, enumerate components bound to this adapter
    HRESULT   hr = S_OK;
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\statmon\smutil.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998.
//
//  File:       S M U T I L . C P P
//
//  Contents:   Utility functions to help out the status monitor
//
//  Notes:
//
//  Author:     CWill   2 Dec 1997
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "netcon.h"
#include "nsres.h"
#include "sminc.h"

const UINT  c_uiKilo    = 1000;
const UINT  c_cmsSecond = 1;
const UINT  c_cmsMinute = (c_cmsSecond * 60);
const UINT  c_cmsHour   = (c_cmsMinute * 60);
const UINT  c_cmsDay    = (c_cmsHour * 24);

static const WCHAR c_szZero[]  = L"0";
extern const WCHAR c_szSpace[];

struct StatusIconMapEntry
{
    NETCON_MEDIATYPE    ncm;
    BOOL                fInbound;
    BOOL                fTransmitting;
    BOOL                fReceiving;
    INT                 iStatusIcon;
};

static const StatusIconMapEntry c_SIMEArray[] =
{
// Mediatype
//  |           Inbound
//  |           |       Transmitting
//  |           |       |       Receiving
//  |           |       |       |       32x32 Status Icon
//  |           |       |       |       |
//  v           v       v       v       v
    // Dial-up
    NCM_PHONE,  FALSE,  FALSE,  FALSE,  IDI_PO_NON_M_16,
    NCM_PHONE,  FALSE,  FALSE,  TRUE,   IDI_PO_RCV_M_16,
    NCM_PHONE,  FALSE,  TRUE,   FALSE,  IDI_PO_TRN_M_16,
    NCM_PHONE,  FALSE,  TRUE,   TRUE,   IDI_PO_CON_M_16,
    NCM_PHONE,  TRUE,   FALSE,  FALSE,  IDI_PI_NON_M_16,
    NCM_PHONE,  TRUE,   FALSE,  TRUE,   IDI_PI_RCV_M_16,
    NCM_PHONE,  TRUE,   TRUE,   FALSE,  IDI_PI_TRN_M_16,
    NCM_PHONE,  TRUE,   TRUE,   TRUE,   IDI_PI_CON_M_16,

    // LAN
    NCM_LAN,    FALSE,  FALSE,  FALSE,  IDI_LB_NON_M_16,
    NCM_LAN,    FALSE,  FALSE,  TRUE,   IDI_LB_RCV_M_16,
    NCM_LAN,    FALSE,  TRUE,   FALSE,  IDI_LB_TRN_M_16,
    NCM_LAN,    FALSE,  TRUE,   TRUE,   IDI_LB_CON_M_16,

    // Direct connect
    NCM_DIRECT, FALSE,  FALSE,  FALSE,  IDI_DO_NON_M_16,
    NCM_DIRECT, FALSE,  FALSE,  TRUE,   IDI_DO_RCV_M_16,
    NCM_DIRECT, FALSE,  TRUE,   FALSE,  IDI_DO_TRN_M_16,
    NCM_DIRECT, FALSE,  TRUE,   TRUE,   IDI_DO_CON_M_16,
    NCM_DIRECT, TRUE,   FALSE,  FALSE,  IDI_DI_NON_M_16,
    NCM_DIRECT, TRUE,   FALSE,  TRUE,   IDI_DI_RCV_M_16,
    NCM_DIRECT, TRUE,   TRUE,   FALSE,  IDI_DI_TRN_M_16,
    NCM_DIRECT, TRUE,   TRUE,   TRUE,   IDI_DI_CON_M_16,

    // Tunnel
    NCM_TUNNEL, FALSE,  FALSE,  FALSE,  IDI_TO_NON_M_16,
    NCM_TUNNEL, FALSE,  FALSE,  TRUE,   IDI_TO_RCV_M_16,
    NCM_TUNNEL, FALSE,  TRUE,   FALSE,  IDI_TO_TRN_M_16,
    NCM_TUNNEL, FALSE,  TRUE,   TRUE,   IDI_TO_CON_M_16,
    NCM_TUNNEL, TRUE,   FALSE,  FALSE,  IDI_TI_NON_M_16,
    NCM_TUNNEL, TRUE,   FALSE,  TRUE,   IDI_TI_RCV_M_16,
    NCM_TUNNEL, TRUE,   TRUE,   FALSE,  IDI_TI_TRN_M_16,
    NCM_TUNNEL, TRUE,   TRUE,   TRUE,   IDI_TI_CON_M_16,

    // ISDN
    NCM_ISDN,   FALSE,  FALSE,  FALSE,  IDI_PO_NON_M_16,
    NCM_ISDN,   FALSE,  FALSE,  TRUE,   IDI_PO_RCV_M_16,
    NCM_ISDN,   FALSE,  TRUE,   FALSE,  IDI_PO_TRN_M_16,
    NCM_ISDN,   FALSE,  TRUE,   TRUE,   IDI_PO_CON_M_16,
    NCM_ISDN,   TRUE,   FALSE,  FALSE,  IDI_PI_NON_M_16,
    NCM_ISDN,   TRUE,   FALSE,  TRUE,   IDI_PI_RCV_M_16,
    NCM_ISDN,   TRUE,   TRUE,   FALSE,  IDI_PI_TRN_M_16,
    NCM_ISDN,   TRUE,   TRUE,   TRUE,   IDI_PI_CON_M_16,

    // PPPoE
    NCM_PPPOE,  FALSE,  FALSE,  FALSE,  IDI_BR_NON_M_16,
    NCM_PPPOE,  FALSE,  FALSE,  TRUE,   IDI_BR_RCV_M_16,
    NCM_PPPOE,  FALSE,  TRUE,   FALSE,  IDI_BR_TRN_M_16,
    NCM_PPPOE,  FALSE,  TRUE,   TRUE,   IDI_BR_CON_M_16,

    // SHAREDACCESSHOST
    NCM_SHAREDACCESSHOST_LAN,    FALSE,  FALSE,  FALSE,  IDI_LB_NON_M_16,
    NCM_SHAREDACCESSHOST_LAN,    FALSE,  FALSE,  TRUE,   IDI_LB_RCV_M_16,
    NCM_SHAREDACCESSHOST_LAN,    FALSE,  TRUE,   FALSE,  IDI_LB_TRN_M_16,
    NCM_SHAREDACCESSHOST_LAN,    FALSE,  TRUE,   TRUE,   IDI_LB_CON_M_16,

    NCM_SHAREDACCESSHOST_RAS,    FALSE,  FALSE,  FALSE,  IDI_LB_NON_M_16,
    NCM_SHAREDACCESSHOST_RAS,    FALSE,  FALSE,  TRUE,   IDI_LB_RCV_M_16,
    NCM_SHAREDACCESSHOST_RAS,    FALSE,  TRUE,   FALSE,  IDI_LB_TRN_M_16,
    NCM_SHAREDACCESSHOST_RAS,    FALSE,  TRUE,   TRUE,   IDI_LB_CON_M_16,

};

const DWORD g_dwStatusIconMapEntryCount = celems(c_SIMEArray);


//+---------------------------------------------------------------------------
//
//  Function:   HrGetPcpFromPnse
//
//  Purpose:    Gets the connection point off of an INetStatistics Engine
//
//  Arguments:  pnseSrc     - The interface we want to get the connection
//                          point off of
//              ppcpStatEng - Where to return the connection point
//
//  Returns:    Error code.
//
HRESULT HrGetPcpFromPnse(
    INetStatisticsEngine*   pnseSrc,
    IConnectionPoint**      ppcpStatEng)
{
    HRESULT                     hr              = S_OK;
    IConnectionPointContainer*  pcpcStatEng     = NULL;

    AssertSz(pnseSrc, "We should have a pnseSrc");
    AssertSz(ppcpStatEng, "We should have a ppcpStatEng");

    hr = pnseSrc->QueryInterface(IID_IConnectionPointContainer,
            reinterpret_cast<VOID**>(&pcpcStatEng));
    if (SUCCEEDED(hr))
    {
        // Find the interface
        hr = pcpcStatEng->FindConnectionPoint(
                IID_INetConnectionStatisticsNotifySink,
                ppcpStatEng);

        // Release the connection point
        ReleaseObj(pcpcStatEng);
    }

    TraceError("HrGetPcpFromPnse", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     IGetCurrentConnectionTrayIconId
//
//  Purpose:    Get the INetConnection pointer from the persisted data
//
//  Arguments:  ncmType -       Media type
//              dwChangeFlags - What states have changed
//
//  Returns:    The id of the small icon for the connection or -1 on failure
//
//  Notes:
//
INT IGetCurrentConnectionTrayIconId(NETCON_MEDIATYPE ncmType, NETCON_STATUS ncsStatus, DWORD dwChangeFlags)
{
    INT     iBaseIcon   = -1;

    // Check the trans/recv flags to see what our base icon is.
    //
    if (ncsStatus == NCS_INVALID_ADDRESS)
    {
        iBaseIcon = IDI_CFT_INVALID_ADDRESS;
    }
    else
    {
        if (SMDCF_TRANSMITTING & dwChangeFlags)
        {
            if (SMDCF_RECEIVING & dwChangeFlags)
            {
                // Transmitting and receiving
                iBaseIcon = IDI_CFT_XMTRECV;
            }
            else
            {
                // Transmitting only
                iBaseIcon = IDI_CFT_XMT;
            }
        }
        else
        {
            if (SMDCF_RECEIVING & dwChangeFlags)
            {
                // Receiving only
                iBaseIcon = IDI_CFT_RECV;
            }
            else
            {
                // Neither transmitting nor receiving
                iBaseIcon = IDI_CFT_BLANK;
            }
        }
    }

    return iBaseIcon;
}

//+---------------------------------------------------------------------------
//
//  Member:     GetCurrentConnectionStatusIconId
//
//  Purpose:    Get the INetConnection pointer from the persisted data
//
//  Arguments:  ncmType             - Media type
//              ncsmType            - SubMedia type
//              dwCharacteristics   - Connection characteristics
//              dwChangeFlags       - What states have changed
//
//  Returns:    The id of the small icon for the connection or -1 on failure
//
//  Notes:
//
HICON GetCurrentConnectionStatusIconId(
    NETCON_MEDIATYPE    ncmType,
    NETCON_SUBMEDIATYPE ncsmType,
    DWORD               dwCharacteristics,
    DWORD               dwChangeFlags)
{
    HICON   hMyIcon         = NULL;
    DWORD   dwLoop          = 0;
    BOOL    fValidIcon      = FALSE;
    BOOL    fTransmitting   = !!(dwChangeFlags & SMDCF_TRANSMITTING);
    BOOL    fReceiving      = !!(dwChangeFlags & SMDCF_RECEIVING);
    INT     iStatusIcon     = -1;

    // Loop through the map and find the appropriate icon
    //
    
    DWORD   dwConnectionIcon = 0x4;
    dwConnectionIcon |= fTransmitting  ? 0x2 : 0;
    dwConnectionIcon |= fReceiving     ? 0x1 : 0;

    HRESULT hr = HrGetIconFromMediaType(GetSystemMetrics(SM_CXICON), ncmType, ncsmType, dwConnectionIcon, (dwCharacteristics & NCCF_INCOMING_ONLY), &hMyIcon);
    if (FAILED(hr))
    {
        return NULL;
    }

    return hMyIcon;
}

//+---------------------------------------------------------------------------
//
//  Member:     FIsStringInList
//
//  Purpose:    To see if a string is in a string list
//
//  Arguments:  plstpstrList    - The list in which the string is to be found
//              szString        - The string being looked for
//
//  Returns:    TRUE if the string is in the list
//              FALSE otherwise (including the case where the list is empty)
//
//  Notes:      It is an case insensitive search
//
BOOL FIsStringInList(list<tstring*>* plstpstrList, const WCHAR* szString)
{
    BOOL    fRet    = FALSE;

    // Only look in non-empty lists
    //
    if (!plstpstrList->empty())
    {
        list<tstring*>::iterator    iterLstpstr;

        iterLstpstr = plstpstrList->begin();
        while ((!fRet)
            && (iterLstpstr != plstpstrList->end()))
        {
            // See if the string in the list matches the string we are
            // comparing against
            //
            if (!lstrcmpiW((*iterLstpstr)->c_str(), szString))
            {
                fRet = TRUE;
            }

            iterLstpstr++;
        }
    }

    return fRet;
}

//+---------------------------------------------------------------------------
//
//  Function:   FormatBytesPerSecond
//
//  Purpose:    To format nicely BPS into a readable string.
//
//  Arguments:
//      uiBps     []
//      pchBuffer []
//
//  Returns:    Number of characters put into the buffer.
//
INT
FormatBytesPerSecond (
    UINT    uiBps,
    WCHAR*  pchBuffer)
{
    enum            {eZero = 0, eKilo, eMega, eGiga, eTera, eMax};
    const WCHAR*    pszBPSFormat        = NULL;
    INT             iOffset             = 0;
    UINT            uiDecimal           = 0;

    // Make sure our resources are still in the correct order
    //
    AssertSz(((((IDS_SM_BPS_ZERO + eKilo) == IDS_SM_BPS_KILO)
        && (IDS_SM_BPS_ZERO + eMega) == IDS_SM_BPS_MEGA)
        && ((IDS_SM_BPS_ZERO + eGiga) == IDS_SM_BPS_GIGA)
        && ((IDS_SM_BPS_ZERO + eTera) == IDS_SM_BPS_TERA)),
            "Someone's been messing with the BPS format strings");

    for (iOffset = eZero; iOffset < eMax; iOffset++)
    {

        // If we still have data, increment the counter
        //
        if (c_uiKilo > uiBps)
        {
            break;
        }

        // Divide up the string
        //
        uiDecimal   = (uiBps % c_uiKilo);
        uiBps       /= c_uiKilo;
    }

    // We only want one digit for the decimal
    //
    uiDecimal /= (c_uiKilo/10);

    // Get the string used to display
    //
    pszBPSFormat = SzLoadIds(IDS_SM_BPS_ZERO + iOffset);
    AssertSz(pszBPSFormat, "We need a format string for BPS");

    // Create the string
    //
    return wsprintfW(pchBuffer, pszBPSFormat, uiBps, uiDecimal);
}

INT
FormatTransmittingReceivingSpeed(
    UINT    nTransmitSpeed,
    UINT    nRecieveSpeed,
    WCHAR*  pchBuf)
{
    WCHAR* pch = pchBuf;

    pch += FormatBytesPerSecond(nTransmitSpeed, pch);

    if (nTransmitSpeed != nRecieveSpeed)
    {
        // Separate with a backslash.
        //
        lstrcatW(pch, L"\\");
        pch += 1;

        pch += FormatBytesPerSecond(nRecieveSpeed, pch);
    }

    return lstrlenW(pchBuf);
}

//+---------------------------------------------------------------------------
//
//  Function:   FormatTimeDuration
//
//  Purpose:    Takes a millisecond count and formats a string with the
//              duration represented by the millisecond count.
//
//  Arguments:
//      uiMilliseconds []
//      pstrOut        []
//
//  Returns:    nothing
//
VOID FormatTimeDuration(UINT uiSeconds, tstring* pstrOut)
{
    WCHAR   achSep[4];
    WCHAR   achBuf[64];
    UINT    uiNumTemp;

    AssertSz(pstrOut, "We should have a pstrOut");

    // Get the seperator for the locale.
    //
    SideAssert(GetLocaleInfo(
                    LOCALE_USER_DEFAULT,
                    LOCALE_STIME,
                    achSep,
                    celems(achSep)));

    //
    // Concatenate the strings together
    //

    // Add the days if there are more than zero
    //
    uiNumTemp = (uiSeconds / c_cmsDay);
    if (uiNumTemp > 0)
    {
        pstrOut->append(_itow(uiNumTemp, achBuf, 10));
        uiSeconds %= c_cmsDay;

        if (uiNumTemp>1)
            pstrOut->append(SzLoadIds(IDS_Days));
        else
            pstrOut->append(SzLoadIds(IDS_Day));

        pstrOut->append(c_szSpace);
    }

    // Append hours
    //
    uiNumTemp = (uiSeconds / c_cmsHour);
    if (10 > uiNumTemp)
    {
        pstrOut->append(c_szZero);
    }
    pstrOut->append(_itow(uiNumTemp, achBuf, 10));
    pstrOut->append(achSep);
    uiSeconds %= c_cmsHour;

    // Append minutes
    //
    uiNumTemp = (uiSeconds / c_cmsMinute);
    if (10 > uiNumTemp)
    {
        pstrOut->append(c_szZero);
    }
    pstrOut->append(_itow(uiNumTemp, achBuf, 10));
    pstrOut->append(achSep);
    uiSeconds %= c_cmsMinute;

    // Append seconds
    //
    uiNumTemp = (uiSeconds / c_cmsSecond);
    if (10 > uiNumTemp)
    {
        pstrOut->append(c_szZero);
    }
    pstrOut->append(_itow(uiNumTemp, achBuf, 10));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\wanui\directui.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       D I R E C T U I . C P P
//
//  Contents:   Direct Connection UI object.
//
//  Notes:
//
//  Author:     shaunco   15 Oct 1997
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "directui.h"



//+---------------------------------------------------------------------------
// INetConnectionUI
//

STDMETHODIMP
CDirectConnectionUi::SetConnection (
    INetConnection* pCon)
{
    return HrSetConnection (pCon, this);
}

STDMETHODIMP
CDirectConnectionUi::Connect (
    HWND    hwndParent,
    DWORD   dwFlags)
{
    HRESULT hr = HrConnect (hwndParent, dwFlags, this,
                    static_cast<INetConnectionConnectUi*>(this));
    TraceError ("CDirectConnectionUi::Connect", hr);
    return hr;
}

STDMETHODIMP
CDirectConnectionUi::Disconnect (
    HWND    hwndParent,
    DWORD   dwFlags)
{
    return HrDisconnect (hwndParent, dwFlags);
}

//+---------------------------------------------------------------------------
// INetConnectionPropertyUi2
//
STDMETHODIMP
CDirectConnectionUi::AddPages (
    HWND                    hwndParent,
    LPFNADDPROPSHEETPAGE    pfnAddPage,
    LPARAM                  lParam)
{
    HRESULT hr = HrAddPropertyPages (hwndParent, pfnAddPage, lParam);
    TraceError ("CDirectConnectionUi::AddPages (INetConnectionPropertyUi)", hr);
    return hr;
}

STDMETHODIMP
CDirectConnectionUi::GetIcon (
    DWORD dwSize,
    HICON *phIcon )
{
    HRESULT hr;
    Assert (phIcon);

    hr = HrGetIconFromMediaType(dwSize, NCM_DIRECT, NCSM_NONE, 7, 0, phIcon);
    
    TraceError ("CLanConnectionUi::GetIcon (INetConnectionPropertyUi2)", hr);
    return hr;
}

//+---------------------------------------------------------------------------
// INetConnectionWizardUi
//
STDMETHODIMP
CDirectConnectionUi::QueryMaxPageCount (
    INetConnectionWizardUiContext*  pContext,
    DWORD*                          pcMaxPages)
{
    HRESULT hr = HrQueryMaxPageCount (pContext, pcMaxPages);
    TraceError ("CDirectConnectionUi::QueryMaxPageCount", hr);
    return hr;
}

STDMETHODIMP
CDirectConnectionUi::AddPages (
    INetConnectionWizardUiContext*  pContext,
    LPFNADDPROPSHEETPAGE            pfnAddPage,
    LPARAM                          lParam)
{
    HRESULT hr = HrAddWizardPages (pContext, pfnAddPage, lParam,
                    RASEDFLAG_NewDirectEntry);
    TraceError ("CDirectConnectionUi::AddPages (INetConnectionWizardUi)", hr);
    return hr;
}

STDMETHODIMP
CDirectConnectionUi::GetSuggestedConnectionName (
    PWSTR* ppszwSuggestedName)
{
    HRESULT hr = HrGetSuggestedConnectionName (ppszwSuggestedName);
    TraceError ("CDirectConnectionUi::GetSuggestedConnectionName", hr);
    return hr;
}


STDMETHODIMP
CDirectConnectionUi::SetConnectionName (
    PCWSTR pszwConnectionName)
{
    HRESULT hr = HrSetConnectionName (pszwConnectionName);
    TraceError ("CDirectConnectionUi::SetConnectionName", hr);
    return hr;
}

STDMETHODIMP
CDirectConnectionUi::GetNewConnection (
    INetConnection**    ppCon)
{
    HRESULT hr = HrGetNewConnection (ppCon);
    TraceError ("CDirectConnectionUi::GetNewConnection", hr);
    return hr;
}

STDMETHODIMP
CDirectConnectionUi::GetNewConnectionInfo (
    DWORD*              pdwFlags,
    NETCON_MEDIATYPE*   pMediaType)
{
    BOOL  fAllowRename;

    Assert (m_ShellCtx.pvWizardCtx);

    *pdwFlags = 0;
    *pMediaType = NCM_DIRECT;

    HRESULT hr;
    *pdwFlags = 0;
    hr = HrGetNewConnectionInfo(pdwFlags);
    if (SUCCEEDED(hr))
    {
        if (!(*pdwFlags & NCWF_INCOMINGCONNECTION))
        {
            *pdwFlags |= NCWF_SHORTCUT_ENABLE;
        }
    
        DWORD dwErr = RasWizIsEntryRenamable (m_dwRasWizType,
                            m_ShellCtx.pvWizardCtx,
                            &fAllowRename);

        hr = HRESULT_FROM_WIN32 (dwErr);
        TraceError ("RasWizIsEntryRenamable", hr);

        if (SUCCEEDED(hr) && !fAllowRename)
        {
            *pdwFlags |= NCWF_RENAME_DISABLE;
        }
    }

    TraceError ("CDirectConnectionUi::GetNewConnectionInfo", hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\wanui\intnetui.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       I N T N E T U I . C P P
//
//  Contents:   Dial-up Connection UI object for inernet connection.
//
//  Notes:
//
//  Author:     asinha   13 Dec 2000
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "intnetui.h"



//+---------------------------------------------------------------------------
// INetConnectionConnectUi
//

STDMETHODIMP
CInternetConnectionUi::SetConnection (
    INetConnection* pCon)
{
    return HrSetConnection (pCon, this);
}

STDMETHODIMP
CInternetConnectionUi::Connect (
    HWND    hwndParent,
    DWORD   dwFlags)
{
    HRESULT hr = HrConnect (hwndParent, dwFlags, this,
                    static_cast<INetConnectionConnectUi*>(this));
    TraceError ("CInternetConnectionUi::Connect", (S_FALSE == hr) ? S_OK : hr);
    return hr;
}

STDMETHODIMP
CInternetConnectionUi::Disconnect (
    HWND    hwndParent,
    DWORD   dwFlags)
{
    return HrDisconnect (hwndParent, dwFlags);
}

//+---------------------------------------------------------------------------
// INetConnectionPropertyUi2
//
STDMETHODIMP
CInternetConnectionUi::AddPages (
    HWND                    hwndParent,
    LPFNADDPROPSHEETPAGE    pfnAddPage,
    LPARAM                  lParam)
{
    HRESULT hr = HrAddPropertyPages (hwndParent, pfnAddPage, lParam);
    TraceError ("CInternetConnectionUi::AddPages (INetConnectionPropertyUi)", hr);
    return hr;
}

STDMETHODIMP
CInternetConnectionUi::GetIcon (
    DWORD dwSize,
    HICON *phIcon )
{
    HRESULT hr;
    Assert (phIcon);

    hr = HrGetIconFromMediaType(dwSize, NCM_PHONE, NCSM_NONE, 7, 0, phIcon);

    TraceError ("CLanConnectionUi::GetIcon (INetConnectionPropertyUi2)", hr);
    return hr;
}

//+---------------------------------------------------------------------------
// INetConnectionWizardUi
//
STDMETHODIMP
CInternetConnectionUi::QueryMaxPageCount (
    INetConnectionWizardUiContext*  pContext,
    DWORD*                          pcMaxPages)
{
    HRESULT hr = HrQueryMaxPageCount (pContext, pcMaxPages);
    TraceError ("CInternetConnectionUi::QueryMaxPageCount", hr);
    return hr;
}

STDMETHODIMP
CInternetConnectionUi::AddPages (
    INetConnectionWizardUiContext*  pContext,
    LPFNADDPROPSHEETPAGE            pfnAddPage,
    LPARAM                          lParam)
{
    HRESULT hr = HrAddWizardPages (pContext, pfnAddPage, lParam,
                    RASEDFLAG_NewPhoneEntry | RASEDFLAG_InternetEntry);
    TraceError ("CInternetConnectionUi::AddPages (INetConnectionWizardUi)", hr);
    return hr;
}

STDMETHODIMP
CInternetConnectionUi::GetSuggestedConnectionName (
    PWSTR* ppszwSuggestedName)
{
    HRESULT hr = HrGetSuggestedConnectionName (ppszwSuggestedName);
    TraceError ("CInternetConnectionUi::GetSuggestedConnectionName", hr);
    return hr;
}

STDMETHODIMP
CInternetConnectionUi::GetNewConnectionInfo (
    DWORD*              pdwFlags,
    NETCON_MEDIATYPE*   pMediaType)
{
    HRESULT hr;
    *pdwFlags = 0;
    hr = HrGetNewConnectionInfo(pdwFlags);
    if (SUCCEEDED(hr))
    {
        *pdwFlags  |= NCWF_SHORTCUT_ENABLE;
        *pMediaType = NCM_PHONE;
    }

    return hr;
}


STDMETHODIMP
CInternetConnectionUi::SetConnectionName (
    PCWSTR pszwConnectionName)
{
    HRESULT hr = HrSetConnectionName (pszwConnectionName);
    TraceError ("CInternetConnectionUi::SetConnectionName", hr);
    return hr;
}

STDMETHODIMP
CInternetConnectionUi::GetNewConnection (
    INetConnection**    ppCon)
{
    HRESULT hr = HrGetNewConnection (ppCon);
    TraceError ("CInternetConnectionUi::GetNewConnection", hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\wanui\dialupui.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       D I A L U P U I . C P P
//
//  Contents:   Dial-up Connection UI object.
//
//  Notes:
//
//  Author:     shaunco   15 Oct 1997
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "dialupui.h"



//+---------------------------------------------------------------------------
// INetConnectionConnectUi
//

STDMETHODIMP
CDialupConnectionUi::SetConnection (
    INetConnection* pCon)
{
    return HrSetConnection (pCon, this);
}

STDMETHODIMP
CDialupConnectionUi::Connect (
    HWND    hwndParent,
    DWORD   dwFlags)
{
    HRESULT hr = HrConnect (hwndParent, dwFlags, this,
                    static_cast<INetConnectionConnectUi*>(this));
    TraceError ("CDialupConnectionUi::Connect", (S_FALSE == hr) ? S_OK : hr);
    return hr;
}

STDMETHODIMP
CDialupConnectionUi::Disconnect (
    HWND    hwndParent,
    DWORD   dwFlags)
{
    return HrDisconnect (hwndParent, dwFlags);
}

//+---------------------------------------------------------------------------
// INetConnectionPropertyUi2
//
STDMETHODIMP
CDialupConnectionUi::AddPages (
    HWND                    hwndParent,
    LPFNADDPROPSHEETPAGE    pfnAddPage,
    LPARAM                  lParam)
{
    HRESULT hr = HrAddPropertyPages (hwndParent, pfnAddPage, lParam);
    TraceError ("CDialupConnectionUi::AddPages (INetConnectionPropertyUi)", hr);
    return hr;
}

STDMETHODIMP
CDialupConnectionUi::GetIcon (
    DWORD dwSize,
    HICON *phIcon )
{
    HRESULT hr;
    Assert (phIcon);

    hr = HrGetIconFromMediaType(dwSize, NCM_PHONE, NCSM_NONE, 7, 0, phIcon);

    TraceError ("CLanConnectionUi::GetIcon (INetConnectionPropertyUi2)", hr);
    return hr;
}

//+---------------------------------------------------------------------------
// INetConnectionWizardUi
//
STDMETHODIMP
CDialupConnectionUi::QueryMaxPageCount (
    INetConnectionWizardUiContext*  pContext,
    DWORD*                          pcMaxPages)
{
    HRESULT hr = HrQueryMaxPageCount (pContext, pcMaxPages);
    TraceError ("CDialupConnectionUi::QueryMaxPageCount", hr);
    return hr;
}

STDMETHODIMP
CDialupConnectionUi::AddPages (
    INetConnectionWizardUiContext*  pContext,
    LPFNADDPROPSHEETPAGE            pfnAddPage,
    LPARAM                          lParam)
{
    HRESULT hr = HrAddWizardPages (pContext, pfnAddPage, lParam,
                    RASEDFLAG_NewPhoneEntry);
    TraceError ("CDialupConnectionUi::AddPages (INetConnectionWizardUi)", hr);
    return hr;
}

STDMETHODIMP
CDialupConnectionUi::GetSuggestedConnectionName (
    PWSTR* ppszwSuggestedName)
{
    HRESULT hr = HrGetSuggestedConnectionName (ppszwSuggestedName);
    TraceError ("CDialupConnectionUi::GetSuggestedConnectionName", hr);
    return hr;
}

STDMETHODIMP
CDialupConnectionUi::GetNewConnectionInfo (
    DWORD*              pdwFlags,
    NETCON_MEDIATYPE*   pMediaType)
{
    HRESULT hr;
    *pdwFlags = 0;
    hr = HrGetNewConnectionInfo(pdwFlags);
    if (SUCCEEDED(hr))
    {
        *pdwFlags |= NCWF_SHORTCUT_ENABLE;
    }

    *pMediaType = NCM_PHONE;
    return hr;
}


STDMETHODIMP
CDialupConnectionUi::SetConnectionName (
    PCWSTR pszwConnectionName)
{
    HRESULT hr = HrSetConnectionName (pszwConnectionName);
    TraceError ("CDialupConnectionUi::SetConnectionName", hr);
    return hr;
}

STDMETHODIMP
CDialupConnectionUi::GetNewConnection (
    INetConnection**    ppCon)
{
    HRESULT hr = HrGetNewConnection (ppCon);
    TraceError ("CDialupConnectionUi::GetNewConnection", hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\statmon\smtlpsp.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       S M T L P S P . C P P
//
//  Contents:   The rendering of the UI for the network status monitor
//
//  Notes:
//
//  Author:     CWill   10/06/1997
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

#include "sminc.h"
#include "smpsh.h"
#include "smutil.h"
#include "ncnetcon.h"

//
//  External data
//

extern const WCHAR c_szSpace[];

//
//  Global Data
//

WCHAR c_szCmdLineFlagPrefix[] = L" -";

// The tool flags we can have registered
//
SM_TOOL_FLAGS g_asmtfMap[] =
{
    {SCLF_CONNECTION, L"connection"},
    {SCLF_ADAPTER, L"adapter"},
};
INT c_cAsmtfMap   = celems(g_asmtfMap);


// The strings associated with the connection media type
//
WCHAR* g_pszNcmMap[] =
{
    L"NCT_NONE",
    L"NCT_DIRECT",
    L"NCT_ISDN",
    L"NCT_LAN",
    L"NCT_PHONE",
    L"NCT_TUNNEL"
};

//+---------------------------------------------------------------------------
//
//  Member:     CPspStatusMonitorTool::CPspStatusMonitorTool
//
//  Purpose:    Creator
//
//  Arguments:  None
//
//  Returns:    Nil
//
CPspStatusMonitorTool::CPspStatusMonitorTool(VOID) :
    m_hwndToolList(NULL)
{
}

//+---------------------------------------------------------------------------
//
//  Member:     CPspStatusMonitorTool::~CPspStatusMonitorTool
//
//  Purpose:    Destructor
//
//  Arguments:  None
//
//  Returns:    Nil
//
CPspStatusMonitorTool::~CPspStatusMonitorTool(VOID)
{
    // Note : We don't want to try and destroy the objects in m_lstpsmte as
    // they are owned by g_ncsCentral

    //
    // Free the items we own
    //
    ::FreeCollectionAndItem(m_lstpstrCompIds);
}

//+---------------------------------------------------------------------------
//
//  Member:     CPspStatusMonitorTool::HrInitToolPage
//
//  Purpose:    Initialize the tools page class before the page has been
//              created
//
//  Arguments:  pncInit -   The connection associated with this monitor
//
//  Returns:    Error code
//
HRESULT CPspStatusMonitorTool::HrInitToolPage(INetConnection* pncInit,
                                              const DWORD * adwHelpIDs)
{
    // set context help ID
    m_adwHelpIDs = adwHelpIDs;

    // Find out what media type the connection is over
    //
    NETCON_PROPERTIES* pProps;
    HRESULT hr = pncInit->GetProperties(&pProps);
    if (SUCCEEDED(hr))
    {
        m_guidId = pProps->guidId;
        m_dwCharacter = pProps->dwCharacter;

        FreeNetconProperties(pProps);
        pProps = NULL;

        // Initialize m_strDeviceType
        hr = HrGetDeviceType(pncInit);
        if (S_OK != hr)
        {
            TraceError("CPspStatusMonitorTool::HrInitToolPage did not get MediaType info", hr);
            hr = S_OK;
        }

        // Now choose what tools should be in the list
        //
        hr = HrCreateToolList(pncInit);
        if (SUCCEEDED(hr))
        {
            hr = HrInitToolPageType(pncInit);
        }
    }

    TraceError("CPspStatusMonitorTool::HrInitToolPage",hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CPspStatusMonitorTool::HrCreateToolList
//
//  Purpose:    From the global list of all possible tools, select the ones
//              that should be shown in this monitor
//
//  Arguments:  pncInit  The connection we are showing status on
//
//  Returns:    Nil
//
HRESULT CPspStatusMonitorTool::HrCreateToolList(INetConnection* pncInit)
{
    HRESULT                             hr              = S_OK;
    list<CStatMonToolEntry*>*           plstpsmteCent   = NULL;
    list<CStatMonToolEntry*>::iterator  iterPsmte;

    CNetStatisticsCentral * pnsc = NULL;

    hr = CNetStatisticsCentral::HrGetNetStatisticsCentral(&pnsc, FALSE);
    if (SUCCEEDED(hr))
    {
        // Get the list of all the possible tools
        //
        plstpsmteCent = pnsc->PlstsmteRegEntries();
        AssertSz(plstpsmteCent, "We should have a plstpsmteCent");

        // Find out what tools should be in the dialog
        //
        if (plstpsmteCent->size() >0) // if at least one tool is registered
        {
            // Initialize m_lstpstrCompIds
            // We should only do this if some of the tools do have a component list
            BOOL fGetComponentList = FALSE;

            iterPsmte = plstpsmteCent->begin();
            while (!fGetComponentList && (iterPsmte != plstpsmteCent->end()))
            {
                if ((*iterPsmte)->lstpstrComponentID.size()>0)
                    fGetComponentList = TRUE;

                iterPsmte++;
            }

            if (fGetComponentList)
            {
                hr = HrGetComponentList(pncInit);
                if (S_OK != hr)
                {
                    TraceError("CPspStatusMonitorTool::HrCreateToolList did not get Component list", hr);
                    hr = S_OK;
                }
            }

            iterPsmte = plstpsmteCent->begin();
            while (iterPsmte != plstpsmteCent->end())
            {
                // If this is a tool we should show in this dialog, add it to the
                // tool page's list.
                //
                if (FToolToAddToList(*iterPsmte))
                {
                    // Note : There is no ownership on this list, the central
                    // structure is responsible for destroying the tool objects
                    //
                    m_lstpsmte.push_back(*iterPsmte);
                }

                iterPsmte++;
            }
        }

        ::ReleaseObj(pnsc);
    }

    TraceError("CPspStatusMonitorTool::HrCreateToolList",hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CPspStatusMonitorTool::FToolToAddToList
//
//  Purpose:    Determines wheither a tool should validly be added to the
//              tool list for this particular monitor
//
//  Arguments:  psmteTest - The tool entry that is to be tested to see if it
//                      matches the criteria to be added to the list
//
//  Returns:    TRUE if the tool should be added, FALSE if it should not
//
BOOL CPspStatusMonitorTool::FToolToAddToList(CStatMonToolEntry* psmteTest)
{
    BOOL fRet = TRUE;

    AssertSz(psmteTest, "We should have a psmteTest");

    // 1) Check connection type
    AssertSz(((NCM_NONE   == 0)
        && (NCM_DIRECT             == NCM_NONE + 1)
        && (NCM_ISDN            == NCM_DIRECT + 1)
        && (NCM_LAN                 == NCM_ISDN + 1)
        && (NCM_PHONE               == NCM_LAN + 1)
        && (NCM_TUNNEL              == NCM_PHONE + 1)),
            "Someone has been mucking with NETCON_MEDIATYPE");

    // See if this tools should only be on certain connections.  If no
    // specific connection is listed, the tool is valid for all
    //
    if (!(psmteTest->lstpstrConnectionType).empty())
    {
        fRet = ::FIsStringInList(&(psmteTest->lstpstrConnectionType),
                                 g_pszNcmMap[m_ncmType]);
    }

    // 2) Check device type
    //
    if ((fRet) && !(psmteTest->lstpstrConnectionType).empty())
    {
        fRet = ::FIsStringInList(&(psmteTest->lstpstrMediaType),
                m_strDeviceType.c_str());
    }

    // 3) Check component list
    //
    if ((fRet) && !(psmteTest->lstpstrComponentID).empty())
    {
        BOOL                        fValid  = FALSE;
        list<tstring*>::iterator    iterLstpstr;

        iterLstpstr = m_lstpstrCompIds.begin();
        while ((!fValid)
            && (iterLstpstr != m_lstpstrCompIds.end()))
        {
            // See if the component is also on the tools component list
            //
            fValid = ::FIsStringInList(&(psmteTest->lstpstrComponentID),
                (*iterLstpstr)->c_str());

            iterLstpstr++;
        }

        // Give back the result
        //
        fRet = fValid;
    }

    return fRet;
}

//+---------------------------------------------------------------------------
//
//  Member:     CPspStatusMonitorTool::OnInitDialog
//
//  Purpose:    Do the initialization required when the page has just been created
//
//  Arguments:  Standard window messsage parameters
//
//  Returns:    Standard window message return value
//
LRESULT CPspStatusMonitorTool::OnInitDialog(UINT uMsg, WPARAM wParam,
        LPARAM lParam, BOOL& bHandled)
{
    HRESULT     hr              = S_OK;
    LVCOLUMN    lvcTemp         = { 0 };
    RECT        rectToolList;

    m_hwndToolList = GetDlgItem(IDC_LST_SM_TOOLS);
    AssertSz(m_hwndToolList, "We don't have a tool list window");

    //
    // Set up the column
    //

    lvcTemp.mask        = LVCF_FMT | LVCF_WIDTH | LVCF_SUBITEM;
    lvcTemp.fmt         = LVCFMT_LEFT;

    // Set the width of the column to the width of the window (minus a bit
    // for the borders)
    //
    ::GetWindowRect(m_hwndToolList, &rectToolList);
    lvcTemp.cx          = (rectToolList.right - rectToolList.left - 4);

//    lvcTemp.pszText     = NULL;
//    lvcTemp.cchTextMax  = 0;
//    lvcTemp.iSubItem    = 0;
//    lvcTemp.iImage      = 0;
//    lvcTemp.iOrder      = 0;

    // Add the column to the list
    //
    if (-1 == ListView_InsertColumn(m_hwndToolList, 0, &lvcTemp))
    {
        hr = ::HrFromLastWin32Error();
    }

    //  Fill out the dialog
    //
    if (SUCCEEDED(hr))
    {
        hr = HrFillToolList();
    }

    TraceError("CPspStatusMonitorTool::OnInitDialog", hr);
    return 0;
}

//+---------------------------------------------------------------------------
//
//  Member:     CPspStatusMonitorTool::HrFillToolList
//
//  Purpose:    Fills the tool list with correct items
//
//  Arguments:  None
//
//  Returns:    Error code
//
HRESULT CPspStatusMonitorTool::HrFillToolList(VOID)
{
    HRESULT                             hr          = S_OK;
    INT                                 iItem       = 0;
    list<CStatMonToolEntry*>::iterator  iterSmte;

    // Tell the control how many items are being inserted so it can do a
    // better job allocating internal structures.
    ListView_SetItemCount(m_hwndToolList, m_lstpsmte.size());

    //
    // Fill in the combo box with subnet entries.
    //

    iterSmte = m_lstpsmte.begin();

    while ((SUCCEEDED(hr)) && (iterSmte != m_lstpsmte.end()))
    {
        // Save some indirections
        hr = HrAddOneEntryToToolList(*iterSmte, iItem);

        // Move on the the next person.
        iterSmte++;
        iItem++;
    }

    // Selete the first item
    if (SUCCEEDED(hr))
    {
        ListView_SetItemState(m_hwndToolList, 0, LVIS_FOCUSED,  LVIS_FOCUSED);
    }

    // Enable/Disable the "Open" button based on whether tools are present
    //
    ::EnableWindow(GetDlgItem(IDC_BTN_SM_TOOLS_OPEN), (0 != iItem));

    TraceError("CPspStatusMonitorTool::HrFillToolList", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CPspStatusMonitorTool::HrAddOneEntryToToolList
//
//  Purpose:    Take a tool associated with the connection and put it
//              in the listview control
//
//  Arguments:  psmteAdd    - The tool to add
//              iItem       - Where to put in in the list control
//
//  Returns:    Error code.
//
HRESULT CPspStatusMonitorTool::HrAddOneEntryToToolList(
        CStatMonToolEntry* psmteAdd, INT iItem)
{
    HRESULT     hr          = S_OK;
    LVITEM      lviTemp;

    lviTemp.mask        = LVIF_TEXT | LVIF_PARAM;
    lviTemp.iItem       = iItem;
    lviTemp.iSubItem    = 0;
    lviTemp.state       = 0;
    lviTemp.stateMask   = 0;
    lviTemp.pszText     = const_cast<PWSTR>(
            psmteAdd->strDisplayName.c_str());
    lviTemp.cchTextMax  = psmteAdd->strDisplayName.length();
    lviTemp.iImage      = -1;
    lviTemp.lParam      = reinterpret_cast<LPARAM>(psmteAdd);
    lviTemp.iIndent     = 0;

    //$ REVIEW : CWill : 10/16/97 : Return values

    // Set up the item
    //
    ListView_InsertItem(m_hwndToolList, &lviTemp);

    TraceError("CPspStatusMonitorTool::HrAddOneEntryToToolList", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CPspStatusMonitorTool::OnContextMenu
//
//  Purpose:    When right click a control, bring up help
//
//  Arguments:  Standard command parameters
//
//  Returns:    Standard return
//
LRESULT
CPspStatusMonitorTool::OnContextMenu(UINT uMsg,
                                    WPARAM wParam,
                                    LPARAM lParam,
                                    BOOL& fHandled)
{
    if (m_adwHelpIDs != NULL)
    {
        ::WinHelp(m_hWnd,
                  c_szNetCfgHelpFile,
                  HELP_CONTEXTMENU,
                  (ULONG_PTR)m_adwHelpIDs);
    }

    return 0;
}

//+---------------------------------------------------------------------------
//
//  Member:     CPspStatusMonitorTool::OnHelp
//
//  Purpose:    When drag context help icon over a control, bring up help
//
//  Arguments:  Standard command parameters
//
//  Returns:    Standard return
//
LRESULT
CPspStatusMonitorTool::OnHelp(UINT uMsg,
                             WPARAM wParam,
                             LPARAM lParam,
                             BOOL& fHandled)
{
    LPHELPINFO lphi = reinterpret_cast<LPHELPINFO>(lParam);
    Assert(lphi);

    if ((m_adwHelpIDs != NULL) && (HELPINFO_WINDOW == lphi->iContextType))
    {
        ::WinHelp(static_cast<HWND>(lphi->hItemHandle),
                  c_szNetCfgHelpFile,
                  HELP_WM_HELP,
                  (ULONG_PTR)m_adwHelpIDs);
    }

    return 0;
}

//+---------------------------------------------------------------------------
//
//  Member:     CPspStatusMonitorTool::OnDestroy
//
//  Purpose:    Clean up the dialog before the window goes away
//
//  Arguments:  Standard window messsage parameters
//
//  Returns:    Standard window message return value
//
LRESULT CPspStatusMonitorTool::OnDestroy(UINT uMsg, WPARAM wParam,
        LPARAM lParam, BOOL& bHandled)
{
    // Clean out the old items when the dialog closes
    //
    ::FreeCollectionAndItem(m_lstpstrCompIds);

    // Don't free the entries, because we don't own them
    //
    m_lstpsmte.erase(m_lstpsmte.begin(), m_lstpsmte.end());
    return 0;
}

//+---------------------------------------------------------------------------
//
//  Member:     CPspStatusMonitorTool::OnToolOpen
//
//  Purpose:    Open the tool that is selected
//
//  Arguments:  Standard window message
//
//  Returns:    Standard return.
//
LRESULT CPspStatusMonitorTool::OnToolOpen(WORD wNotifyCode, WORD wID,
        HWND hWndCtl, BOOL& fHandled)
{
    HRESULT hr = S_OK;

    switch (wNotifyCode)
    {
    case BN_CLICKED:
        hr = HrLaunchTool();
        break;
    }

    return 0;
}

//+---------------------------------------------------------------------------
//
//  Member:     CPspStatusMonitorTool::OnItemActivate
//
//  Purpose:    When an item is acivated in the tool list, launch the tool
//
//  Arguments:  Standard notification messages
//
//  Returns:    Stadard return
//
LRESULT CPspStatusMonitorTool::OnItemActivate(INT idCtrl, LPNMHDR pnmh,
        BOOL& bHandled)
{
    // Launch the tool
    //
    HRESULT hr = HrLaunchTool();

    return 0;
}

//+---------------------------------------------------------------------------
//
//  Member:     CPspStatusMonitorTool::OnItemChanged
//
//  Purpose:    When one of the items change, see if it is the focus and set
//              the description accordingly
//
//  Arguments:  Standard notification messages
//
//  Returns:    Stadard return
//
LRESULT CPspStatusMonitorTool::OnItemChanged(INT idCtrl, LPNMHDR pnmh,
        BOOL& bHandled)
{
    HRESULT             hr              = S_OK;
    NMLISTVIEW*         pnmlvChange     = NULL;

    // Cast to the right header
    //
    pnmlvChange = reinterpret_cast<NMLISTVIEW*>(pnmh);

    // If the item now has the focus, display its description
    //
    if (LVIS_FOCUSED & pnmlvChange->uNewState)
    {
        CStatMonToolEntry*  psmteItem   = NULL;

        psmteItem = reinterpret_cast<CStatMonToolEntry*>(pnmlvChange->lParam);
        AssertSz(psmteItem, "We haven't got any data in changing item");

        // Set the manufacturer
        SetDlgItemText(IDC_TXT_SM_TOOL_MAN,
                psmteItem->strManufacturer.c_str());

        // Set the commandline
        //
        tstring strCommandLineAndFlags = psmteItem->strCommandLine;
        tstring strFlags;

        hr = HrAddAllCommandLineFlags(&strFlags, psmteItem);
        if (SUCCEEDED(hr))
        {
            strCommandLineAndFlags.append(c_szSpace);;
            strCommandLineAndFlags += strFlags;
        }

        SetDlgItemText(IDC_TXT_SM_TOOL_COMMAND,
                       strCommandLineAndFlags.c_str());

        // Show the description
        SetDlgItemText( IDC_TXT_SM_TOOL_DESC,
                        psmteItem->strDescription.c_str());
    }

    TraceError("CPspStatusMonitorTool::OnItemChanged", hr);
    return 0;
}

//+---------------------------------------------------------------------------
//
//  Member:     CPspStatusMonitorTool::HrLaunchTool
//
//  Purpose:    Launches the tool that is selected in the tools list
//
//  Arguments:  None
//
//  Returns:    Error code
//
HRESULT CPspStatusMonitorTool::HrLaunchTool(VOID)
{
    HRESULT             hr              = S_OK;

    // We can only launch one tool at a time
    //
    if (1 == ListView_GetSelectedCount(m_hwndToolList))
    {
        INT                 iSelect         = -1;
        LV_ITEM             lviTemp         = { 0 };
        CStatMonToolEntry*  psmteSelection  = NULL;
        tstring             strFlags;

        //
        // Extract the data associated with the selection.
        //

        iSelect = ListView_GetSelectionMark(m_hwndToolList);
        AssertSz((0 <= iSelect), "I thought we were supposed to have a selection");

        // Set up the data item to get back to the parameter
        //
        lviTemp.iItem = iSelect;
        lviTemp.mask = LVIF_PARAM;

        ListView_GetItem(m_hwndToolList, &lviTemp);

        psmteSelection = reinterpret_cast<CStatMonToolEntry*>(lviTemp.lParam);
        AssertSz(psmteSelection, "We haven't got any data in a selection");

        // Get all the flags
        //
        hr = HrAddAllCommandLineFlags(&strFlags, psmteSelection);
        if (SUCCEEDED(hr))
        {
            SHELLEXECUTEINFO seiTemp    = { 0 };

            //
            //  Fill in the data structure
            //

            seiTemp.cbSize          = sizeof(SHELLEXECUTEINFO);
            seiTemp.fMask           = SEE_MASK_DOENVSUBST;
            seiTemp.hwnd            = NULL;
            seiTemp.lpVerb          = NULL;
            seiTemp.lpFile          = psmteSelection->strCommandLine.c_str();
            seiTemp.lpParameters    = strFlags.c_str();
            seiTemp.lpDirectory     = NULL;
            seiTemp.nShow           = SW_SHOW;
            seiTemp.hInstApp        = NULL;
            seiTemp.hProcess        = NULL;

            // Launch the tool
            //
            if (!::ShellExecuteEx(&seiTemp))
            {
                hr = ::HrFromLastWin32Error();
            }
        }
    }

    TraceError("CPspStatusMonitorTool::HrLaunchTool", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CPspStatusMonitorTool::HrAddAllCommandLineFlags
//
//  Purpose:    Adds the flags for this selection to the command line for the
//              tool being launched.  Include the private and the connection
//              specific flags.
//
//  Arguments:  pstrFlags - The command line that the flags have to be
//                      appended to
//              psmteSel    - The tool entry associated with this selection
//
//  Returns:    Error code
//
HRESULT CPspStatusMonitorTool::HrAddAllCommandLineFlags(tstring* pstrFlags,
        CStatMonToolEntry* psmteSel)
{
    HRESULT hr  = S_OK;

    //$ REVIEW : CWill : 02/24/98 : Will there be default command line flags
    //$ REVIEW : that the user will want to have to launch the tool?  If so,
    //$ REIVEW : an entry should be added to as a REG_SZ to the tools subkey.

    // Add both the commom and the conneciton specific command line flags
    //
    hr = HrAddCommonCommandLineFlags(pstrFlags, psmteSel);
    if (SUCCEEDED(hr))
    {
        hr = HrAddCommandLineFlags(pstrFlags, psmteSel);
    }

    TraceError("CPspStatusMonitorTool::HrAddCommandLineFlags", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CPspStatusMonitorTool::HrAddCommonCommandLineFlags
//
//  Purpose:    Adds the flags that all types of connections share.
//
//  Arguments:  pstrFlags - The command line that the flags have to be
//                      appended to
//              psmteSel    - The tool entry associated with this selection
//
//  Returns:    Error code
//
HRESULT CPspStatusMonitorTool::HrAddCommonCommandLineFlags(tstring* pstrFlags,
        CStatMonToolEntry* psmteSel)
{
    HRESULT hr  = S_OK;
    DWORD   dwFlags = 0x0;

    // Same some indirections
    //
    dwFlags = psmteSel->dwFlags;

    //
    //  Check what flags are asked for and provide them if we can
    //

    if (SCLF_CONNECTION & dwFlags)
    {
        WCHAR achConnGuid[c_cchGuidWithTerm];

        pstrFlags->append(c_szCmdLineFlagPrefix);
        pstrFlags->append(g_asmtfMap[STFI_CONNECTION].pszFlag);
        pstrFlags->append(c_szSpace);

        // Make a GUID string
        //
        ::StringFromGUID2 (m_guidId, achConnGuid,
                c_cchGuidWithTerm);

        pstrFlags->append(achConnGuid);
    }

    TraceError("CPspStatusMonitorTool::HrAddCommandLineFlags", hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\wanui\pppoeui.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       P P P O E U I . C P P
//
//  Contents:   PPPoE connection UI object.
//
//  Notes:
//
//  Author:     mbend   10 May 2000
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "pppoeui.h"



//+---------------------------------------------------------------------------
// INetConnectionConnectUi
//

STDMETHODIMP
CPPPoEUi::SetConnection (
    INetConnection* pCon)
{
    return HrSetConnection (pCon, this);
}

STDMETHODIMP
CPPPoEUi::Connect (
    HWND    hwndParent,
    DWORD   dwFlags)
{
    HRESULT hr = HrConnect (hwndParent, dwFlags, this,
                    static_cast<INetConnectionConnectUi*>(this));
    TraceError ("CPPPoEUi::Connect", (S_FALSE == hr) ? S_OK : hr);
    return hr;
}

STDMETHODIMP
CPPPoEUi::Disconnect (
    HWND    hwndParent,
    DWORD   dwFlags)
{
    return HrDisconnect (hwndParent, dwFlags);
}

//+---------------------------------------------------------------------------
// INetConnectionPropertyUi2
//
STDMETHODIMP
CPPPoEUi::AddPages (
    HWND                    hwndParent,
    LPFNADDPROPSHEETPAGE    pfnAddPage,
    LPARAM                  lParam)
{
    HRESULT hr = HrAddPropertyPages (hwndParent, pfnAddPage, lParam);
    TraceError ("CPPPoEUi::AddPages (INetConnectionPropertyUi)", hr);
    return hr;
}

STDMETHODIMP
CPPPoEUi::GetIcon (
    DWORD dwSize,
    HICON *phIcon )
{
    HRESULT hr;
    Assert (phIcon);

    hr = HrGetIconFromMediaType(dwSize, NCM_PPPOE, NCSM_NONE, 7, 0, phIcon);

    TraceError ("CLanConnectionUi::GetIcon (INetConnectionPropertyUi2)", hr);
    return hr;
}

//+---------------------------------------------------------------------------
// INetConnectionWizardUi
//
STDMETHODIMP
CPPPoEUi::QueryMaxPageCount (
    INetConnectionWizardUiContext*  pContext,
    DWORD*                          pcMaxPages)
{
    HRESULT hr = HrQueryMaxPageCount (pContext, pcMaxPages);
    TraceError ("CPPPoEUi::QueryMaxPageCount", hr);
    return hr;
}

STDMETHODIMP
CPPPoEUi::AddPages (
    INetConnectionWizardUiContext*  pContext,
    LPFNADDPROPSHEETPAGE            pfnAddPage,
    LPARAM                          lParam)
{
    HRESULT hr = HrAddWizardPages (pContext, pfnAddPage, lParam,
                    RASEDFLAG_NewBroadbandEntry | RASEDFLAG_InternetEntry);
    TraceError ("CPPPoEUi::AddPages (INetConnectionWizardUi)", hr);
    return hr;
}

STDMETHODIMP
CPPPoEUi::GetSuggestedConnectionName (
    PWSTR* ppszwSuggestedName)
{
    HRESULT hr = HrGetSuggestedConnectionName (ppszwSuggestedName);
    TraceError ("CPPPoEUi::GetSuggestedConnectionName", hr);
    return hr;
}

STDMETHODIMP
CPPPoEUi::GetNewConnectionInfo (
    DWORD*              pdwFlags,
    NETCON_MEDIATYPE*   pMediaType)
{
    HRESULT hr;
    *pdwFlags = 0;
    hr = HrGetNewConnectionInfo(pdwFlags);
    if (SUCCEEDED(hr))
    {
        *pdwFlags  |= NCWF_SHORTCUT_ENABLE;
        *pMediaType = NCM_PPPOE;
    }
    return S_OK;
}


STDMETHODIMP
CPPPoEUi::SetConnectionName (
    PCWSTR pszwConnectionName)
{
    HRESULT hr = HrSetConnectionName (pszwConnectionName);
    TraceError ("CPPPoEUi::SetConnectionName", hr);
    return hr;
}

STDMETHODIMP
CPPPoEUi::GetNewConnection (
    INetConnection**    ppCon)
{
    HRESULT hr = HrGetNewConnection (ppCon);
    TraceError ("CPPPoEUi::GetNewConnection", hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\wanui\inbui.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       I N B U I . C P P
//
//  Contents:   Inbound Connection UI object.
//
//  Notes:
//
//  Author:     shaunco   15 Nov 1997
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "inbui.h"
#include "nccom.h"
#include "rasui.h"



//+---------------------------------------------------------------------------
//
//  Member:     CInboundConnectionUi::CInboundConnectionUi
//
//  Purpose:    Constructor/Destructor
//
//  Arguments:
//      (none)
//
//  Returns:
//
//  Author:     shaunco   20 Oct 1997
//
//  Notes:
//
CInboundConnectionUi::CInboundConnectionUi ()
{
    m_pCon          = NULL;
    m_hRasSrvConn   = NULL;
    m_pvContext     = NULL;
    m_dwRasWizType  = RASWIZ_TYPE_INCOMING;
}

CInboundConnectionUi::~CInboundConnectionUi ()
{
    ReleaseObj (m_pCon);
}

//+---------------------------------------------------------------------------
// INetConnectionPropertyUi2
//
STDMETHODIMP
CInboundConnectionUi::SetConnection (
    INetConnection* pCon)
{
    // Enter our critical section to protect the use of m_pCon.
    //
    CExceptionSafeComObjectLock EsLock (this);

    HRESULT     hr          = S_OK;
    HRASSRVCONN hRasSrvConn = NULL;

    // If we were given a connection, verify it by QI'ing for
    // INetInboundConnection and calling the GetServerConnectionHandle method.
    // This also gives us m_hRasSrvConn which we need later anyway.
    //
    if (pCon)
    {
        INetInboundConnection* pInboundCon;
        hr = HrQIAndSetProxyBlanket(pCon, &pInboundCon);
        if (SUCCEEDED(hr))
        {
            hr = pInboundCon->GetServerConnectionHandle (
                    reinterpret_cast<ULONG_PTR*>(&hRasSrvConn));

            ReleaseObj (pInboundCon);
        }
        else if (E_NOINTERFACE == hr)
        {
            // If the connection object, doesn't support the interface, it's
            // not our object.  The client has messed up and passed us a bogus
            // argument.
            //
            hr = E_INVALIDARG;
        }
    }

    // Only change our state if the above succeeded.
    //
    if (SUCCEEDED(hr))
    {
        ReleaseObj (m_pCon);
        m_pCon = pCon;
        AddRefObj (m_pCon);
        m_hRasSrvConn = hRasSrvConn;
    }

    TraceError ("CInboundConnectionUi::SetConnection", hr);
    return hr;
}

STDMETHODIMP
CInboundConnectionUi::AddPages (
    HWND                    hwndParent,
    LPFNADDPROPSHEETPAGE    pfnAddPage,
    LPARAM                  lParam)
{
    HRESULT hr;

    // Validate parameters.
    //
    if (!pfnAddPage)
    {
        hr = E_POINTER;
    }
    // Must have called SetConnection prior to this.
    //
    else if (!m_pCon)
    {
        hr = E_UNEXPECTED;
    }
    else
    {
        DWORD dwErr = RasSrvAddPropPages (
                        m_hRasSrvConn,
                        hwndParent,
                        pfnAddPage,
                        lParam,
                        &m_pvContext);

        hr = HRESULT_FROM_WIN32 (dwErr);
        TraceError ("RasSrvAddPropPages", hr);
    }
    TraceError ("CInboundConnectionUi::AddPages (INetConnectionPropertyUi)", hr);
    return hr;
}

STDMETHODIMP
CInboundConnectionUi::GetIcon (
    DWORD dwSize,
    HICON *phIcon )
{
    HRESULT hr;
    Assert (phIcon);

    hr = HrGetIconFromMediaType(dwSize, NCM_NONE, NCSM_NONE, 7, 0, phIcon);

    TraceError ("CLanConnectionUi::GetIcon (INetConnectionPropertyUi2)", hr);
    return hr;
}

//+---------------------------------------------------------------------------
// INetConnectionWizardUi
//
STDMETHODIMP
CInboundConnectionUi::QueryMaxPageCount (
    INetConnectionWizardUiContext*  pContext,
    DWORD*                          pcMaxPages)
{
    HRESULT hr = S_OK;

    // Validate parameters.
    //
    if (!pcMaxPages)
    {
        hr = E_POINTER;
    }
    else
    {
        *pcMaxPages = RasWizQueryMaxPageCount (m_dwRasWizType);
    }
    TraceError ("CInboundConnectionUi::QueryMaxPageCount", hr);
    return hr;
}

STDMETHODIMP
CInboundConnectionUi::AddPages (
    INetConnectionWizardUiContext*  pContext,
    LPFNADDPROPSHEETPAGE            pfnAddPage,
    LPARAM                          lParam)
{
    HRESULT hr;

    // Validate parameters.
    //
    if (!pfnAddPage)
    {
        hr = E_POINTER;
    }
    else
    {
        DWORD dwErr = RasSrvAddWizPages (pfnAddPage, lParam, &(m_pvContext));

        hr = HRESULT_FROM_WIN32 (dwErr);
        TraceError ("RasSrvAddWizPages", hr);
    }
    TraceError ("CInboundConnectionUi::AddPages (INetConnectionWizardUi)", hr);
    return hr;
}

STDMETHODIMP
CInboundConnectionUi::GetSuggestedConnectionName (
    PWSTR* ppszwSuggestedName)
{
    HRESULT hr;

    // Validate parameters.
    //
    if (!ppszwSuggestedName)
    {
        hr = E_POINTER;
    }
    else
    {
        *ppszwSuggestedName = NULL;

        WCHAR pszName[MAX_PATH];
        DWORD dwErr;
        dwErr = RasWizGetSuggestedEntryName (
                    m_dwRasWizType, m_pvContext, pszName);

        hr = HRESULT_FROM_WIN32 (dwErr);
        TraceError ("RasWizGetSuggestedEntryName", hr);

        if (SUCCEEDED(hr))
        {
            hr = HrCoTaskMemAllocAndDupSz (
                    pszName,
                    ppszwSuggestedName);
        }

    }
    TraceError ("CInboundConnectionUi::GetSuggestedConnectionName", hr);
    return hr;
}

STDMETHODIMP
CInboundConnectionUi::GetNewConnectionInfo (
    DWORD*              pdwFlags,
    NETCON_MEDIATYPE*   pMediaType)
{
    HRESULT hr = S_OK;

    *pMediaType = NCM_NONE;

    if (!pdwFlags)
    {
        hr = E_POINTER;
    }
    else
    {
        *pdwFlags = 0;

        Assert (m_pvContext);

        DWORD dwRasFlags;
        DWORD dwErr = RasWizGetNCCFlags (
                            m_dwRasWizType, 
                            m_pvContext,
                            &dwRasFlags);

        hr = HRESULT_FROM_WIN32 (dwErr);
        TraceError ("RasWizGetNCCFlags", hr);

        if (SUCCEEDED(hr))
        {
            if (dwRasFlags & NCC_FLAG_CREATE_INCOMING)
            {
                *pdwFlags |= NCWF_INCOMINGCONNECTION;
            }
            
            if (dwRasFlags & NCC_FLAG_FIREWALL)
            {
                *pdwFlags |= NCWF_FIREWALLED;
            }
            
            if (dwRasFlags & NCC_FLAG_SHARED)
            {
                *pdwFlags |= NCWF_SHARED;
            }

            if (dwRasFlags & NCC_FLAG_ALL_USERS)
            {
                *pdwFlags |= NCWF_ALLUSER_CONNECTION;
            }
            
            if (dwRasFlags & NCC_FLAG_GLOBALCREDS)
            {
                *pdwFlags |= NCWF_GLOBAL_CREDENTIALS;
            }

            if (dwRasFlags & NCC_FLAG_DEFAULT_INTERNET)
            {
                *pdwFlags |= NCWF_DEFAULT;
            }
        }
        else if (E_INVALIDARG == hr)
        {
            hr = E_UNEXPECTED;
        }
    }

    BOOL  fAllowRename;
    DWORD dwErr = RasWizIsEntryRenamable (
                    m_dwRasWizType,
                    m_pvContext,
                    &fAllowRename);

    hr = HRESULT_FROM_WIN32 (dwErr);
    TraceError ("RasWizIsEntryRenamable", hr);

    if (SUCCEEDED(hr))
    {
        if (!fAllowRename)
        {
            *pdwFlags |= NCWF_RENAME_DISABLE;
        }
    }

    TraceError ("CInboundConnectionUi::GetNewConnectionInfo", hr);

    return hr;
}


STDMETHODIMP
CInboundConnectionUi::SetConnectionName (
    PCWSTR     pszwConnectionName)
{
    HRESULT hr;

    // Validate parameters.
    //
    if (!pszwConnectionName)
    {
        hr = E_POINTER;
    }
    else
    {
        DWORD dwErr = RasWizSetEntryName (
                        m_dwRasWizType,
                        m_pvContext,
                        pszwConnectionName);

        hr = HRESULT_FROM_WIN32 (dwErr);
        TraceError ("RasWizSetEntryName", hr);
    }
    TraceError ("CInboundConnectionUi::SetConnectionName", hr);
    return hr;
}

STDMETHODIMP
CInboundConnectionUi::GetNewConnection (
    INetConnection**    ppCon)
{
    HRESULT hr;

    // Validate parameters.
    //
    if (!ppCon)
    {
        hr = E_POINTER;
    }
/*
    // Must have called SetConnectionName prior to this.
    //
    else if (m_strConnectionName.empty())
    {
        hr = E_UNEXPECTED;
    }
*/
    else
    {
        *ppCon = NULL;

        // Commit the settings made in the wizard.
        //
        DWORD dwErr = RasWizCreateNewEntry (
                        m_dwRasWizType,
                        m_pvContext, NULL, NULL, NULL);

        hr = HRESULT_FROM_WIN32 (dwErr);
        TraceError ("RasWizCreateNewEntry", hr);

        if (SUCCEEDED(hr))
        {
            hr = HrCreateInboundConfigConnection (ppCon);
        }
    }
    TraceError ("CInboundConnectionUi::GetNewConnection", hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\wanui\vpnui.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       V P N U I . C P P
//
//  Contents:   VPN Connection UI object.
//
//  Notes:
//
//  Author:     shaunco   17 Dec 1997
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "vpnui.h"

//+---------------------------------------------------------------------------
// INetConnectionUI
//

STDMETHODIMP
CVpnConnectionUi::SetConnection (
    INetConnection* pCon)
{
    return HrSetConnection (pCon, this);
}

STDMETHODIMP
CVpnConnectionUi::Connect (
    HWND    hwndParent,
    DWORD   dwFlags)
{
    HRESULT hr = HrConnect (hwndParent, dwFlags, this,
                    static_cast<INetConnectionConnectUi*>(this));
    TraceError ("CVpnConnectionUi::Connect", (S_FALSE == hr) ? S_OK : hr);
    return hr;
}

STDMETHODIMP
CVpnConnectionUi::Disconnect (
    HWND    hwndParent,
    DWORD   dwFlags)
{
    return HrDisconnect (hwndParent, dwFlags);
}

//+---------------------------------------------------------------------------
// INetConnectionPropertyUi2
//
STDMETHODIMP
CVpnConnectionUi::AddPages (
    HWND                    hwndParent,
    LPFNADDPROPSHEETPAGE    pfnAddPage,
    LPARAM                  lParam)
{
    HRESULT hr = HrAddPropertyPages (hwndParent, pfnAddPage, lParam);
    TraceError ("CVpnConnectionUi::AddPages (INetConnectionPropertyUi)", hr);
    return hr;
}

STDMETHODIMP
CVpnConnectionUi::GetIcon (
    DWORD dwSize,
    HICON *phIcon )
{
    HRESULT hr;
    Assert (phIcon);

    hr = HrGetIconFromMediaType(dwSize, NCM_TUNNEL, NCSM_NONE, 7, 0, phIcon);

    TraceError ("CLanConnectionUi::GetIcon (INetConnectionPropertyUi2)", hr);
    return hr;
}

//+---------------------------------------------------------------------------
// INetConnectionWizardUi
//
STDMETHODIMP
CVpnConnectionUi::QueryMaxPageCount (
    INetConnectionWizardUiContext*  pContext,
    DWORD*                          pcMaxPages)
{
    HRESULT hr = HrQueryMaxPageCount (pContext, pcMaxPages);
    TraceError ("CVpnConnectionUi::QueryMaxPageCount", hr);
    return hr;
}

STDMETHODIMP
CVpnConnectionUi::AddPages (
    INetConnectionWizardUiContext*  pContext,
    LPFNADDPROPSHEETPAGE            pfnAddPage,
    LPARAM                          lParam)
{
    HRESULT hr = HrAddWizardPages (pContext, pfnAddPage, lParam,
                    RASEDFLAG_NewTunnelEntry);
    TraceError ("CVpnConnectionUi::AddPages (INetConnectionWizardUi)", hr);
    return hr;
}

STDMETHODIMP
CVpnConnectionUi::GetSuggestedConnectionName (
    PWSTR* ppszwSuggestedName)
{
    HRESULT hr = HrGetSuggestedConnectionName (ppszwSuggestedName);
    TraceError ("CVpnConnectionUi::GetSuggestedConnectionName", hr);
    return hr;
}


STDMETHODIMP
CVpnConnectionUi::SetConnectionName (
    PCWSTR pszwConnectionName)
{
    HRESULT hr = HrSetConnectionName (pszwConnectionName);
    TraceError ("CVpnConnectionUi::SetConnectionName", hr);
    return hr;
}

STDMETHODIMP
CVpnConnectionUi::GetNewConnection (
    INetConnection**    ppCon)
{
    HRESULT hr = HrGetNewConnection (ppCon);
    TraceError ("CVpnConnectionUi::GetNewConnection", hr);
    return hr;
}

STDMETHODIMP
CVpnConnectionUi::GetNewConnectionInfo (
    DWORD*              pdwFlags,
    NETCON_MEDIATYPE*   pMediaType)
{
    HRESULT hr;
    *pdwFlags = 0;
    hr = HrGetNewConnectionInfo(pdwFlags);
    if (SUCCEEDED(hr))
    {
        *pdwFlags  |= NCWF_SHORTCUT_ENABLE;
        *pMediaType = NCM_TUNNEL;
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\tools\dllquery\dllquery.cpp ===
#include "pch.h"
#pragma hdrstop
#include "modset.h"
#include "persist.h"

EXTERN_C
VOID
__cdecl
wmain (
    IN INT argc,
    IN PCWSTR argv[])
{
    CModuleTree Tree;
    const CModuleTreeEntry* pEntry;
    CModuleList::const_iterator iter;
    const CModule* pMod;

    HrLoadModuleTree (&Tree);

    for (pEntry = Tree.begin(); pEntry != Tree.end(); pEntry++)
    {
        printf("%8d  %-16s  %-16s  %s\n",
            pEntry->m_pModule->m_cbFileSize,
            pEntry->m_pModule->m_pszFileName,
            pEntry->m_pImportModule->m_pszFileName,
            (pEntry->m_dwFlags & MTE_DELAY_LOADED) ? "delayed" : "static");
    }


    // List modules only imported by one other module.
    //
    CModuleList List;
    const CModuleTreeEntry* pScan;

    printf("\nModules only imported by one other module:\n");
    printf("--------------------------------------------------\n");

    for (pEntry = Tree.begin(); pEntry != Tree.end(); pEntry++)
    {
        UINT CountImported = 1;

        for (pScan = Tree.begin(); pScan != Tree.end(); pScan++)
        {
            if (pScan == pEntry)
            {
                continue;
            }

            if (pScan->m_pImportModule == pEntry->m_pImportModule)
            {
                CountImported++;
                break;
            }
        }

        if (1 == CountImported)
        {
            printf("%-16s  only imported by  %-16s  %s\n",
                pEntry->m_pImportModule->m_pszFileName,
                pEntry->m_pModule->m_pszFileName,
                (pEntry->m_dwFlags & MTE_DELAY_LOADED) ? "delayed" : "static");
        }
    }

    // List modules with circular references to other modules.
    //
    printf("\nModules with circular references to other modules:\n");
    printf("--------------------------------------------------\n");

    for (pEntry = Tree.begin(); pEntry != Tree.end(); pEntry++)
    {
        pScan = Tree.PBinarySearchEntry (
                    pEntry->m_pImportModule,
                    pEntry->m_pModule, NULL);
        if (pScan != Tree.end())
        {
            Assert (pScan->m_pModule == pEntry->m_pImportModule);
            Assert (pScan->m_pImportModule == pEntry->m_pModule);

            printf("%-16s  <->  %-16s  %s\n",
                pEntry->m_pModule->m_pszFileName,
                pEntry->m_pImportModule->m_pszFileName,
                (pEntry->m_dwFlags & MTE_DELAY_LOADED) ? "delayed" : "static");
        }
    }
/*
    CModuleListSet Set;

    for (iter  = Tree.Modules.begin();
         iter != Tree.Modules.end();
         iter++)
    {
        pMod = *iter;
        Assert (pMod);

        Tree.HrGetModuleBindings (pMod, GMBF_ADD_TO_MLSET, &Set);
    }

    Set.DumpSetToConsole();
*/
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\tools\dllquery\mod.h ===
#pragma once

class CModule
{
public:
    // The names of the file.  Does not include any path information.
    //
    PSTR    m_pszFileName;

    // The size of the file.
    //
    ULONG   m_cbFileSize;

public:
    static HRESULT
    HrCreateInstance (
        IN PCSTR pszFileName,
        IN ULONG cbFileSize,
        OUT CModule** ppMod);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\tools\dllquery\mod.cpp ===
#include "pch.h"
#pragma hdrstop
#include "mod.h"
#include "ncstring.h"

//static
HRESULT
CModule::HrCreateInstance (
    IN PCSTR pszFileName,
    IN ULONG cbFileSize,
    OUT CModule** ppMod)
{
    HRESULT hr;
    ULONG cbFileName;
    CModule* pMod;

    Assert (pszFileName && *pszFileName);
    Assert (ppMod);

    cbFileName = CbOfSzaAndTerm (pszFileName);
    hr = E_OUTOFMEMORY;

    pMod = new(extrabytes, cbFileName) CModule;
    if (pMod)
    {
        hr = S_OK;
        ZeroMemory (pMod, sizeof(CModule));

        pMod->m_pszFileName = (PSTR)(pMod + 1);
        strcpy (pMod->m_pszFileName, pszFileName);

        pMod->m_cbFileSize = cbFileSize;
    }

    *ppMod = pMod;
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\wanui\rasui.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       R A S U I . C P P
//
//  Contents:   Implements the base class used to implement the Dialup,
//              Direct, Internet, and Vpn connection UI objects.
//
//  Notes:
//
//  Author:     shaunco   17 Dec 1997  (and that's the code complete date!)
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "netshell.h"
#include "nsbase.h"
#include "nccom.h"
#include "ncras.h"
#include "rasui.h"
#include "rasuip.h"

//+---------------------------------------------------------------------------
//
//  Function:   HrCreateInboundConfigConnection
//
//  Purpose:    Create and return the Inbound configuration connection object.
//              This is called from inbui.cpp and rasui.cpp.
//
//  Arguments:
//      ppCon [out] Returned connection object.
//
//  Returns:    S_OK or an error code
//
//  Author:     shaunco   25 Feb 1998
//
//  Notes:      This commonizes this operation which may be performed from
//              the direct connect wizard as well as the incoming connections
//              wizard.
//
HRESULT
HrCreateInboundConfigConnection (
    INetConnection** ppCon)
{
    static const CLSID CLSID_InboundConnection =
        {0xBA126AD9,0x2166,0x11D1,{0xB1,0xD0,0x00,0x80,0x5F,0xC1,0x27,0x0E}};

    Assert (ppCon);

    // Initialize the output parameter.
    //
    *ppCon = NULL;

    // Create an uninitialized inbound connection object.
    // Ask for the INetInboundConnection interface so we can
    // initialize it as the configuration connection.
    //
    HRESULT hr;
    INetInboundConnection* pInbCon;

    hr = HrCreateInstance(
            CLSID_InboundConnection,
            CLSCTX_LOCAL_SERVER | CLSCTX_NO_CODE_DOWNLOAD,
            &pInbCon);

    TraceHr(ttidError, FAL, hr, FALSE, "HrCreateInstance");

    if (SUCCEEDED(hr))
    {
        // Initialize the connection object and return the
        // INetConnection interface on it to the caller.
        // Pass TRUE so that the remoteaccess service is started.
        //
        hr = pInbCon->InitializeAsConfigConnection (TRUE);
        if (SUCCEEDED(hr))
        {
            hr = HrQIAndSetProxyBlanket(pInbCon, ppCon);
        }
        ReleaseObj (pInbCon);
    }
    TraceHr (ttidError, FAL, hr, FALSE, "HrCreateInboundConfigConnection");
    return hr;
}



//+---------------------------------------------------------------------------
//
//  Member:     CRasUiBase::CRasUiBase
//
//  Purpose:    Constructor/Destructor
//
//  Arguments:
//      (none)
//
//  Returns:
//
//  Author:     shaunco   20 Oct 1997
//
//  Notes:
//
CRasUiBase::CRasUiBase ()
{
    m_pCon = NULL;
    m_dwRasWizType = 0;
    ZeroMemory (&m_RasConInfo, sizeof(m_RasConInfo));
}

CRasUiBase::~CRasUiBase ()
{
    RciFree (&m_RasConInfo);
    ReleaseObj (m_pCon);
}

//+---------------------------------------------------------------------------
// INetConnectionUI
//

HRESULT
CRasUiBase::HrSetConnection (
    INetConnection*                             pCon,
    CComObjectRootEx <CComObjectThreadModel>*    pObj)
{
    // Enter our critical section to protect the use of m_pCon.
    //
    CExceptionSafeComObjectLock EsLock (pObj);

    ReleaseObj (m_pCon);
    m_pCon = pCon;
    AddRefObj (m_pCon);

    return S_OK;
}

HRESULT
CRasUiBase::HrConnect (
    HWND                                        hwndParent,
    DWORD                                       dwFlags,
    CComObjectRootEx <CComObjectThreadModel>*    pObj,
    IUnknown*                                   punk)
{
    HRESULT hr = S_OK;

    if (!m_pCon)
    {
        hr = E_UNEXPECTED;
    }
    else
    {
        RASCON_INFO RasConInfo;

        hr = HrRciGetRasConnectionInfo (m_pCon, &RasConInfo);
        if (S_OK == hr)
        {
            // Dial the entry.
            //
            RASDIALDLG info;
            ZeroMemory (&info, sizeof(info));
            info.dwSize = sizeof (RASDIALDLG);
            info.hwndOwner = hwndParent;

            BOOL fRet = RasDialDlg (
                            RasConInfo.pszwPbkFile,
                            RasConInfo.pszwEntryName, NULL, &info);

            if (!fRet)
            {
                // If the fRet was FALSE, but the dwError is zero,
                // then the user cancelled. Else it was an error
                //
                if (0 == info.dwError)
                {
                    hr = S_FALSE;
                }
                else
                {
                    hr = HRESULT_FROM_WIN32(info.dwError);
                }

                TraceError ("RasDialDlg", (S_FALSE == hr) ? S_OK : hr);
            }

            RciFree (&RasConInfo);
        }
    }
    TraceError ("CRasUiBase::HrConnect", (S_FALSE == hr) ? S_OK : hr);
    return hr;
}

HRESULT
CRasUiBase::HrDisconnect (
    IN HWND hwndParent,
    IN DWORD dwFlags)
{
    HRESULT hr = S_OK;

    if (!m_pCon)
    {
        hr = E_UNEXPECTED;
    }
    else
    {
        // Note that we do not call m_pCon->Disconnect.  This is because
        // CM has some bad architecture w.r.t. knowing when they have
        // disconnected the connection vs. the connection being dropped
        // and they need to redial.  Thus, for CM's sake, the RasHangup
        // call has to take place inside of explorer and not from netman.
        // (Tough noogies for clients of INetConnection::Disconnect who
        // would like CM connections to be hungup correctly.  But, that's
        // the nature of a messed up architecture and no one willing to make
        // it right -- the hacks start to creep into good code too.)
        //
        RASCON_INFO RasConInfo;

        hr = HrRciGetRasConnectionInfo (m_pCon, &RasConInfo);
        if (S_OK == hr)
        {
            HRASCONN hRasConn;

            hr = HrFindRasConnFromGuidId (&RasConInfo.guidId, &hRasConn, NULL);
            if (S_OK == hr)
            {
                hr = HrRasHangupUntilDisconnected (hRasConn);
            }
            else if (S_FALSE == hr)
            {
                // Not connected.
                //
                hr = S_OK;
            }

            RciFree (&RasConInfo);
        }
    }
    TraceHr (ttidError, FAL, hr, FALSE, "CRasUiBase::HrDisconnect");
    return hr;
}

//+---------------------------------------------------------------------------
// INetConnectionPropertyUi2
//
HRESULT
CRasUiBase::HrAddPropertyPages (
    HWND                    hwndParent,
    LPFNADDPROPSHEETPAGE    pfnAddPage,
    LPARAM                  lParam)
{
    HRESULT hr = S_OK;

    // Validate parameters.
    //
    if ((hwndParent && !IsWindow (hwndParent)) ||
        !pfnAddPage)
    {
        hr = E_POINTER;
    }
    // Must have called SetConnection prior to this.
    //
    else if (!m_pCon)
    {
        hr = E_UNEXPECTED;
    }
    else
    {
        RciFree (&m_RasConInfo);
        hr = HrRciGetRasConnectionInfo (m_pCon, &m_RasConInfo);
        if (S_OK == hr)
        {
            ZeroMemory (&m_RasEntryDlg, sizeof(m_RasEntryDlg));
            m_RasEntryDlg.dwSize     = sizeof(m_RasEntryDlg);
            m_RasEntryDlg.hwndOwner  = hwndParent;
            m_RasEntryDlg.dwFlags    = RASEDFLAG_ShellOwned;
            m_RasEntryDlg.reserved2  = reinterpret_cast<ULONG_PTR>
                                            (&m_ShellCtx);

            ZeroMemory (&m_ShellCtx, sizeof(m_ShellCtx));
            m_ShellCtx.pfnAddPage = pfnAddPage;
            m_ShellCtx.lparam     = lParam;

            BOOL fRet = RasEntryDlgW (
                            m_RasConInfo.pszwPbkFile,
                            m_RasConInfo.pszwEntryName,
                            &m_RasEntryDlg);
            if (!fRet)
            {
                TraceError ("CRasUiBase::AddPropertyPages: RasEntryDlg "
                            "returned an error",
                            HRESULT_FROM_WIN32 (m_RasEntryDlg.dwError));
            }
        }

        hr = S_OK;
    }
    TraceError ("CRasUiBase::HrAddPropertyPages", hr);
    return hr;
}

//+---------------------------------------------------------------------------
// INetConnectionWizardUi
//
HRESULT
CRasUiBase::HrQueryMaxPageCount (
    INetConnectionWizardUiContext*  pContext,
    DWORD*                          pcMaxPages)
{
    HRESULT hr;

    // Validate parameters.
    //
    if (!pcMaxPages)
    {
        hr = E_POINTER;
    }
    else
    {
        *pcMaxPages = RasWizQueryMaxPageCount (m_dwRasWizType);
        hr = S_OK;
    }
    TraceError ("CRasUiBase::HrQueryMaxPageCount", hr);
    return hr;
}

BOOL bCallRasDlgEntry = TRUE;

HRESULT
CRasUiBase::HrAddWizardPages (
    INetConnectionWizardUiContext*  pContext,
    LPFNADDPROPSHEETPAGE            pfnAddPage,
    LPARAM                          lParam,
    DWORD                           dwFlags)
{
    HRESULT hr = S_OK;

    if (!bCallRasDlgEntry)
    {
        return E_ABORT;
    }
    
    // Validate parameters.
    //
    if (!pfnAddPage)
    {
        hr = E_POINTER;
    }
    else
    {
        ZeroMemory (&m_ShellCtx, sizeof(m_ShellCtx));
        m_ShellCtx.pfnAddPage = pfnAddPage;
        m_ShellCtx.lparam     = lParam;

        ZeroMemory (&m_RasEntryDlg, sizeof(m_RasEntryDlg));
        m_RasEntryDlg.dwSize     = sizeof(m_RasEntryDlg);
        m_RasEntryDlg.dwFlags    = dwFlags | RASEDFLAG_ShellOwned;
        m_RasEntryDlg.reserved2  = reinterpret_cast<ULONG_PTR>(&m_ShellCtx);

        BOOL fRet = RasEntryDlgW (NULL, NULL, &m_RasEntryDlg);
        if (fRet)
        {
            Assert (m_ShellCtx.pvWizardCtx);
        }
        else
        {
            TraceError ("CRasUiBase::HrAddWizardPages: RasEntryDlg "
                        "returned an error",
                        HRESULT_FROM_WIN32 (m_RasEntryDlg.dwError));

            if (0 == m_RasEntryDlg.dwError)
            {
                bCallRasDlgEntry = FALSE; 
                // Don't call this again if user cancelled out of TAPI phone dialog box.
            }
            // RAS may not be installed or may otherwise have a problem.
            // We can safely ignore any errors.
        }

    }
    TraceError ("CRasUiBase::HrAddWizardPages", hr);
    return hr;
}

HRESULT
CRasUiBase::HrGetSuggestedConnectionName (
    PWSTR*   ppszwSuggestedName)
{
    HRESULT hr;

    // Validate parameters.
    //
    if (!ppszwSuggestedName)
    {
        hr = E_POINTER;
    }
    else
    {
        Assert (m_ShellCtx.pvWizardCtx);

        WCHAR pszwSuggestedName [MAX_PATH];
        DWORD dwErr = RasWizGetUserInputConnectionName (
                            m_ShellCtx.pvWizardCtx,
                            pszwSuggestedName);

        hr = HRESULT_FROM_WIN32 (dwErr);
        TraceError ("RasWizGetUserInputConnectionName", hr);

        if (SUCCEEDED(hr))
        {
            hr = HrCoTaskMemAllocAndDupSz (
                    pszwSuggestedName,
                    ppszwSuggestedName);
        }
    }
    TraceError ("CRasUiBase::HrGetSuggestedConnectionName", hr);
    return hr;
}

HRESULT
CRasUiBase::HrSetConnectionName (
    PCWSTR pszwConnectionName)
{
    HRESULT hr;

    // Validate parameters.
    //
    if (!pszwConnectionName)
    {
        hr = E_POINTER;
    }
    else
    {
        Assert (m_ShellCtx.pvWizardCtx);

        m_strConnectionName = pszwConnectionName;
        DWORD dwErr = RasWizSetEntryName (m_dwRasWizType,
                            m_ShellCtx.pvWizardCtx,
                            pszwConnectionName);

        hr = HRESULT_FROM_WIN32 (dwErr);
        TraceError ("RasWizSetEntryName", hr);
    }
    TraceError ("CRasUiBase::HrSetConnectionName", hr);
    return hr;
}

HRESULT
CRasUiBase::HrGetNewConnection (
    INetConnection**    ppCon)
{
    static const CLSID CLSID_DialupConnection =
        {0xBA126AD7,0x2166,0x11D1,{0xB1,0xD0,0x00,0x80,0x5F,0xC1,0x27,0x0E}};

    HRESULT hr;

    // Validate parameters.
    //
    if (!ppCon)
    {
        hr = E_POINTER;
    }
    // Must have called SetConnectionName prior to this.
    //
    else if (m_strConnectionName.empty())
    {
        hr = E_UNEXPECTED;
    }
    else
    {
        Assert (m_ShellCtx.pvWizardCtx);

        // Call into rasdlg to finish creating the entry and to return
        // us the phonebook and entry name.  We'll use them to create
        // the connection object.
        //
        WCHAR pszwPbkFile [MAX_PATH];
        WCHAR pszwEntryName [MAX_PATH];
        DWORD dwFlags;
        DWORD dwErr = RasWizCreateNewEntry (m_dwRasWizType,
                        m_ShellCtx.pvWizardCtx,
                        pszwPbkFile, pszwEntryName, &dwFlags);

        hr = HRESULT_FROM_WIN32 (dwErr);
        TraceError ("RasWizCreateNewEntry", hr);

        if (SUCCEEDED(hr))
        {
            // Create the inbound configuration connection if requested.
            // This will happen when the direct connect wizard is invoked
            // and the user chooses to be the host.
            //
            if (dwFlags & NCC_FLAG_CREATE_INCOMING)
            {
                hr = HrCreateInboundConfigConnection (ppCon);
            }
            else
            {
                // Create an uninitialized dialup connection object.
                // Ask for the INetRasConnection interface so we can
                // initialize it.
                //
                INetRasConnection* pRasCon;

				hr = HrCreateInstance(
					CLSID_DialupConnection,
					CLSCTX_LOCAL_SERVER | CLSCTX_NO_CODE_DOWNLOAD,
					&pRasCon);

                TraceHr(ttidError, FAL, hr, FALSE, "HrCreateInstance");

                if (SUCCEEDED(hr))
                {
                    NcSetProxyBlanket (pRasCon);

                    // Initialize the connection object and return the
                    // INetConnection interface on it to the caller.
                    //
                    RASCON_INFO RasConInfo;

                    ZeroMemory (&RasConInfo, sizeof(RasConInfo));
                    RasConInfo.pszwPbkFile   = pszwPbkFile;
                    RasConInfo.pszwEntryName = pszwEntryName;

                    hr = pRasCon->SetRasConnectionInfo (&RasConInfo);
                    if (SUCCEEDED(hr))
                    {
                        hr = HrQIAndSetProxyBlanket(pRasCon, ppCon);

                        if (S_OK == hr)
                        {
                            NcSetProxyBlanket (*ppCon);
                        }
                    }

                    ReleaseObj (pRasCon);
                }
            }
        }
    }
    TraceError ("CRasUiBase::HrGetNewConnection", hr);
    return hr;
}

HRESULT
CRasUiBase::HrGetNewConnectionInfo (
        OUT DWORD* pdwFlags)
{
    HRESULT hr;

    // Validate parameters.
    //
    if (!pdwFlags)
    {
        hr = E_POINTER;
    }
    else
    {
        *pdwFlags = 0;

        Assert (m_ShellCtx.pvWizardCtx);

        DWORD dwRasFlags;
        DWORD dwErr = RasWizGetNCCFlags (
                            m_dwRasWizType, m_ShellCtx.pvWizardCtx,
                            &dwRasFlags);

        hr = HRESULT_FROM_WIN32 (dwErr);
        TraceError ("RasWizGetNCCFlags", hr);

        if (SUCCEEDED(hr))
        {
            if (dwRasFlags & NCC_FLAG_CREATE_INCOMING)
            {
                *pdwFlags |= NCWF_INCOMINGCONNECTION;
            }
            
            if (dwRasFlags & NCC_FLAG_FIREWALL)
            {
                *pdwFlags |= NCWF_FIREWALLED;
            }
            
            if (dwRasFlags & NCC_FLAG_SHARED)
            {
                *pdwFlags |= NCWF_SHARED;
            }

            if (dwRasFlags & NCC_FLAG_ALL_USERS)
            {
                *pdwFlags |= NCWF_ALLUSER_CONNECTION;
            }
            
            if (dwRasFlags & NCC_FLAG_GLOBALCREDS)
            {
                *pdwFlags |= NCWF_GLOBAL_CREDENTIALS;
            }

            if (dwRasFlags & NCC_FLAG_DEFAULT_INTERNET)
            {
                *pdwFlags |= NCWF_DEFAULT;
            }
        }
        else if (E_INVALIDARG == hr)
        {
            hr = E_UNEXPECTED;
        }
    }
    TraceError ("CRasUiBase::HrGetNewConnectionInfo", hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\tools\dllquery\modlist.cpp ===
#include "pch.h"
#pragma hdrstop
#include "modlist.h"

BOOL
CModuleList::FDumpToString (
    OUT PSTR pszBuf,
    IN OUT ULONG* pcchBuf) const
{
    const_iterator iter;
    const CModule* pMod;
    ULONG cch;
    ULONG cchIn;
    BOOL fFirstTime;

    Assert (this);
    Assert (pcchBuf);

    cch = 0;
    cchIn = *pcchBuf;

    for (iter = begin(), fFirstTime = TRUE; iter != end(); iter++)
    {
        if (!fFirstTime)
        {
            cch += 2;
            if (pszBuf && (cch <= cchIn))
            {
                strcat (pszBuf, "->");
            }
        }
        else
        {
            fFirstTime = FALSE;
            if (pszBuf && (cch <= cchIn))
            {
                *pszBuf = 0;
            }
        }

        pMod = *iter;
        Assert (pMod);

        cch += strlen (pMod->m_pszFileName);
        if (pszBuf && (cch <= cchIn))
        {
            strcat (pszBuf, pMod->m_pszFileName);
        }
    }

    // If we ran out of room, erase the partial stuff we wrote.
    //
    if (pszBuf && cchIn && (cch > cchIn))
    {
        *pszBuf = 0;
    }

    *pcchBuf = cch;
    return cch <= cchIn;
}

BOOL
CModuleList::FIsSameModuleListAs (
    IN const CModuleList* pOtherList) const
{
    UINT unThisSize;
    UINT unOtherSize;
    UINT cb;

    Assert (this);
    Assert (pOtherList);

    unThisSize = this->size();
    unOtherSize = pOtherList->size();

    if ((0 == unThisSize) || (0 == unOtherSize) || (unThisSize != unOtherSize))
    {
        return FALSE;
    }

    // Sizes are non-zero and equal.  Compare the data.
    //
    cb = (BYTE*)(end()) - (BYTE*)(begin());
    Assert (cb == unThisSize * sizeof(CModule*));

    return (0 == memcmp (
                    (BYTE*)(this->begin()),
                    (BYTE*)(pOtherList->begin()),
                    cb));
}

VOID
CModuleList::GrowBufferIfNeeded ()
{
    if (m_Granularity && (size() == capacity()))
    {
        //fprintf(stderr, "growing module list buffer\n");

        __try
        {
            reserve (size() + m_Granularity);
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            ;
        }
    }
}

HRESULT
CModuleList::HrInsertModule (
    IN const CModule* pMod,
    IN DWORD dwFlags /* INS_FLAGS */)
{
    HRESULT hr;

    Assert (this);
    Assert (pMod);
    Assert (dwFlags);
    Assert (dwFlags & (INS_ASSERT_IF_DUP | INS_IGNORE_IF_DUP));
    Assert (!(dwFlags & (INS_SORTED | INS_NON_SORTED)));
    Assert (dwFlags & (INS_APPEND | INS_INSERT));

    if (FLinearFindModuleByPointer (pMod))
    {
        Assert (dwFlags & INS_IGNORE_IF_DUP);
        return S_OK;
    }

    GrowBufferIfNeeded ();

    __try
    {
        iterator InsertPosition = begin();

        if (dwFlags & INS_APPEND)
        {
            InsertPosition = end();
        }

        insert (InsertPosition, (CModule*)pMod);
        hr = S_OK;
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}

HRESULT
CModuleList::HrInsertNewModule (
    IN PCSTR pszFileName,
    IN ULONG cbFileSize,
    IN DWORD dwFlags, /* INS_FLAGS */
    OUT CModule** ppMod)
{
    HRESULT hr;
    iterator InsertPosition = NULL;
    CModule* pMod;
    CHAR szLowerCaseFileName [MAX_PATH];

    Assert (dwFlags);
    Assert (dwFlags & (INS_ASSERT_IF_DUP | INS_IGNORE_IF_DUP));
    Assert (dwFlags & INS_SORTED);
    Assert (!(dwFlags & (INS_APPEND | INS_INSERT)));

    GrowBufferIfNeeded ();

    hr = S_OK;

    strcpy (szLowerCaseFileName, pszFileName);
    _strlwr (szLowerCaseFileName);

    pMod = PBinarySearchModuleByName (szLowerCaseFileName, &InsertPosition);

    if (!pMod)
    {
        Assert (!PLinearFindModuleByName (szLowerCaseFileName));

        hr = CModule::HrCreateInstance (szLowerCaseFileName, cbFileSize, &pMod);

        if (S_OK == hr)
        {
            if (dwFlags & INS_NON_SORTED)
            {
                InsertPosition = (dwFlags & INS_APPEND) ? end() : begin();
            }
            __try
            {
                Assert (InsertPosition);
                insert (InsertPosition, pMod);
                Assert (S_OK == hr);

                DbgVerifySorted();
            }
            __except(EXCEPTION_EXECUTE_HANDLER)
            {
                hr = E_OUTOFMEMORY;
                delete pMod;
                pMod = NULL;
            }
        }
    }
    else
    {
        Assert (dwFlags & INS_IGNORE_IF_DUP);

        // Update the file size of the module if we didn't have it
        // when it was first created.
        //
        if (0 == pMod->m_cbFileSize)
        {
            pMod->m_cbFileSize = cbFileSize;
        }
    }

    *ppMod = pMod;

    return hr;
}

CModule*
CModuleList::PBinarySearchModuleByName (
    IN PCSTR pszFileName,
    OUT CModuleList::iterator* pInsertPosition OPTIONAL)
{
    // Find the module using a binary search.
    //
    if (size())
    {
        LONG Lo;
        LONG Hi;
        LONG Mid;
        INT Result;
        CModule* pScan;

        Lo = 0;
        Hi = size() - 1;

        while (Hi >= Lo)
        {
            Mid = (Lo + Hi) / 2;
            pScan = at(Mid);

            Result = strcmp (pszFileName, pScan->m_pszFileName);

            if (Result < 0)
            {
                Hi = Mid - 1;
            }
            else if (Result > 0)
            {
                Lo = Mid + 1;
            }
            else
            {
                return pScan;
            }
        }

        // If we make it to here, the module was not found.
        //
        if (pInsertPosition)
        {
            *pInsertPosition = begin() + Lo;
            Assert (*pInsertPosition >= begin());
            Assert (*pInsertPosition <= end());
        }
    }
    else if (pInsertPosition)
    {
        // Empty collection.  Insert position is at the beginning.
        //
        *pInsertPosition = begin();
    }

    return NULL;
}

CModule*
CModuleList::PLinearFindModuleByName (
    IN PCSTR pszFileName)
{
    const_iterator iter;
    CModule* pScan;

    for (iter = begin(); iter != end(); iter++)
    {
        pScan = *iter;
        Assert (pScan);

        if (0 == strcmp(pszFileName, pScan->m_pszFileName))
        {
            return pScan;
        }
    }
    return NULL;
}

CModule*
CModuleList::RemoveLastModule ()
{
    CModule* pMod = NULL;
    if (size() > 0)
    {
        pMod = back();
        AssertH(pMod);
        pop_back();
    }
    return pMod;
}

#if DBG
VOID
CModuleList::DbgVerifySorted ()
{
    const_iterator iter;
    CModule* pScan;
    CModule* pPrev = NULL;

    if (size() > 1)
    {
        for (pPrev = *begin(), iter = begin() + 1; iter != end(); iter++)
        {
            pScan = *iter;
            Assert (pScan);

            Assert (strcmp(pPrev->m_pszFileName, pScan->m_pszFileName) < 0);

            pPrev = pScan;
        }
    }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\tools\dllquery\modlist.h ===
#pragma once
#include "mod.h"

class CModuleList : public vector <CModule*>
{
public:
    USHORT  m_Granularity;
    USHORT  m_fCircular;

private:
    VOID
    GrowBufferIfNeeded ();

public:
    CModuleList()
    {
        m_Granularity = 8;
        m_fCircular = FALSE;
    }

    BOOL
    FDumpToString (
        OUT PSTR pszBuf,
        IN OUT ULONG* pcchBuf) const;

    BOOL
    FIsSameModuleListAs (
        IN const CModuleList* pList) const;

    HRESULT
    HrInsertModule (
        IN const CModule* pMod,
        IN DWORD dwFlags /* INS_FLAGS */);

    HRESULT
    HrInsertNewModule (
        IN PCSTR pszFileName,
        IN ULONG cbFileSize,
        IN DWORD dwFlags, /* INS_FLAGS */
        OUT CModule** ppMod);

    CModule*
    PBinarySearchModuleByName (
        IN PCSTR pszFileName,
        OUT CModuleList::iterator* pInsertPosition OPTIONAL);

    BOOL
    FLinearFindModuleByPointer (
        IN const CModule* pMod) const
    {
        Assert (this);
        Assert (pMod);

        return (find (begin(), end(), pMod) != end());
    }

    CModule*
    PLinearFindModuleByName (
        IN PCSTR pszFileName);

    CModule*
    RemoveLastModule ();

#if DBG
    VOID DbgVerifySorted ();
#else
    VOID DbgVerifySorted () {}
#endif
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\tools\dllquery\modset.h ===
#pragma once
#include "modlist.h"

class CModuleListSet : public vector<CModuleList>
{
public:
    VOID
    DumpSetToConsole ();

    BOOL
    FContainsModuleList (
        IN const CModuleList* pList) const;

    HRESULT
    HrAddModuleList (
        IN const CModuleList* pList,
        IN DWORD dwFlags /* INS_FLAGS */);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\tools\dllquery\modset.cpp ===
#include "pch.h"
#pragma hdrstop
#include "modset.h"

VOID
CModuleListSet::DumpSetToConsole ()
{
    static CHAR pszBuf [4096];
    CHAR* pch;
    ULONG cch;
    ULONG cchLeft;
    const CModuleList* pScan;

    Assert (this);

    *pszBuf = 0;
    pch = pszBuf;
    cchLeft = celems(pszBuf);

    for (pScan = begin(); pScan != end(); pScan++)
    {
        cch = cchLeft - 1;

        if (pScan->FDumpToString (pch, &cch))
        {
            strcat (pch, "\n");
            cch++;

            Assert (cchLeft >= cch);
            pch += cch;
            cchLeft -= cch;
        }
        else
        {
            // Not enough room, time to flush the buffer.
            //
            printf(pszBuf);
            *pszBuf = 0;
            pch = pszBuf;
            cchLeft = celems(pszBuf);

            // Redo this entry
            pScan--;
        }
    }

    if (pch > pszBuf)
    {
        printf(pszBuf);
    }
}

BOOL
CModuleListSet::FContainsModuleList (
    IN const CModuleList* pList) const
{
    const CModuleList* pScan;

    Assert (this);
    Assert (pList);

    for (pScan = begin(); pScan != end(); pScan++)
    {
        if (pScan->FIsSameModuleListAs (pList))
        {
            return TRUE;
        }
    }
    return FALSE;
}

HRESULT
CModuleListSet::HrAddModuleList (
    IN const CModuleList* pList,
    IN DWORD dwFlags /* INS_FLAGS */)
{
    HRESULT hr;

    Assert (this);
    Assert (pList);
    Assert (!pList->empty());
    Assert ((dwFlags & INS_ASSERT_IF_DUP) || (dwFlags & INS_IGNORE_IF_DUP));
    Assert ((dwFlags & INS_APPEND) || (dwFlags & INS_INSERT));
    Assert (!(INS_SORTED & dwFlags) && !(INS_NON_SORTED & dwFlags));

    if (FContainsModuleList (pList))
    {
        // If the caller didn't tell us to ignore duplicates, we assert
        // if there is one.
        //
        // If we have a dup, we want the caller to be aware that it
        // is possible, and pass us the flag telling us to ignore it.
        // Otherwise, we assert to let them know. (And we still ignore
        // it.)
        Assert (dwFlags & INS_IGNORE_IF_DUP);

        return S_OK;
    }

    __try
    {
        // Either insert the bindpath or append it.
        //
        iterator iter = begin();

        if (dwFlags & INS_APPEND)
        {
            iter = end();
        }

        insert (iter, *pList);
        hr = S_OK;
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\tools\dllquery\peimage.h ===
#pragma once

// NT's PE file
//
class CPeImage
{
public:
    HANDLE  m_hFile;
    HANDLE  m_hMapping;
    PVOID   m_pvImage;

public:
    HRESULT
    HrOpenFile (
        IN PCSTR pszFileName);

    VOID
    CloseFile ();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\tools\dllquery\pch.h ===
#pragma once

#define COM_NO_WINDOWS_H
#define RPC_NO_WINDOWS_H
#define NOCOMM
#define NOCRYPT
#define NOHELP
#define NOICONS
#define NOIME
#define NOMCX
#define NOMDI
#define NOMENUS
#define NOMETAFILE
#define NOSOUND
#define NOSYSPARAMSINFO
#define NOWH
#define NOWINABLE
#define NOWINRES

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <objbase.h>

#include <cfgmgr32.h>
#include <devguid.h>
#include <infstr.h>
#include <regstr.h>
#include <setupapi.h>
#include <stdio.h>
#include <wchar.h>

#include "stlalgor.h"
#include "stllist.h"
#include "stlvec.h"
using namespace std;

#include "ncmem.h"
#include "ncbase.h"
#include "ncdebug.h"
#include "ncdefine.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\tools\dllquery\modtree.h ===
#pragma once
#include "modlist.h"

class CModuleListSet;

enum MTE_FLAGS
{
    MTE_DEFAULT         = 0x00000000,
    MTE_DELAY_LOADED    = 0x00000001,
};

class CModuleTreeEntry
{
public:
    CModule*    m_pModule;
    CModule*    m_pImportModule;

    DWORD       m_dwFlags;  // MTE_FLAGS
};


// Flags for HrGetModuleBindings.
//
enum GMB_FLAGS
{
    GMBF_DEFAULT      = 0x00000000,
    GMBF_ADD_TO_MLSET = 0x00000001,
};

class CModuleTree : public vector<CModuleTreeEntry>
{
public:
    CModuleList Modules;

public:
    ~CModuleTree ();

    HRESULT
    HrAddEntry (
        IN CModule* pMod,
        IN CModule* pImport,
        IN DWORD dwFlags);

    HRESULT
    HrGetModuleBindings (
        IN const CModule* pMod,
        IN DWORD dwFlags /* GMB_FLAGS */,
        OUT CModuleListSet* pSet) const;

    CModuleTreeEntry*
    PFindFirstEntryWithModule (
        IN const CModule* pMod) const;

    CModuleTreeEntry*
    PFindFirstEntryAfterModuleGroup (
        IN const CModule* pMod) const;

    CModuleTreeEntry*
    PBinarySearchEntry (
        IN const CModule* pMod,
        IN const CModule* pImport,
        OUT CModuleTreeEntry** pInsertPosition OPTIONAL) const;

private:
    CModuleTreeEntry*
    PBinarySearchEntryByModule (
        IN const CModule* pMod,
        OUT CModuleTreeEntry** pInsertPosition OPTIONAL) const;

#if DBG
    VOID DbgVerifySorted ();
#else
    VOID DbgVerifySorted () {}
#endif
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\tools\dllquery\modtree.cpp ===
#include "pch.h"
#pragma hdrstop
#include "modset.h"
#include "modtree.h"
#include "ncstl.h"

struct GMBCONTEXT
{
    // The tree to reference for generating the set.
    //
    IN const CModuleTree*   pTree;

    // The module to start with when generating the set.
    //
    IN const CModule*       pSourceMod;

    // INS_FLAGS to use when adding DepChain to the set.
    //
    IN DWORD                dwFlags;

    // The module list set to generate based on pSourceMod.
    //
    IN OUT CModuleListSet*  pSet;

    // The result of the operation.
    //
    OUT HRESULT             hr;

    // This module list is built up via recursion.  It is
    // temporary.  It represents a depenedency chain sourced
    // at pSourceMod.  It is added to the set when the depth
    // of the chain (or a circular reference) is detected.
    //
    CModuleList             DepChain;
};

VOID
GetModuleBindings (
    IN const CModule* pMod,
    IN OUT GMBCONTEXT* pCtx)
{
    BOOL fFoundOne = FALSE;
    const CModuleTreeEntry* pScan;

    Assert (pCtx);
    Assert (pCtx->pSourceMod);
    Assert (pCtx->pSet);
    Assert (pCtx->pTree);

    // Append this module to te end of the context's working
    // dependency chain.
    //
    pCtx->hr = pCtx->DepChain.HrInsertModule (pMod,
                                INS_ASSERT_IF_DUP | INS_APPEND);
    if (S_OK != pCtx->hr)
    {
        return;
    }

    // For all rows in the tree where the module is the one passed in...
    //
    for (pScan  = pCtx->pTree->PFindFirstEntryWithModule (pMod);
         (pScan != pCtx->pTree->end()) && (pScan->m_pModule == pMod);
         pScan++)
    {
        fFoundOne = TRUE;

        // Detect circular import chains.
        //
        if (pCtx->DepChain.FLinearFindModuleByPointer (pScan->m_pImportModule))
        {
            pCtx->DepChain.m_fCircular = TRUE;
            continue;
        }

        GetModuleBindings (pScan->m_pImportModule, pCtx);
        if (S_OK != pCtx->hr)
        {
            return;
        }
    }

    // If we didnt find any rows with pMod as a module, it means we
    // hit the depth of the dependency chain.  Time to add it to the set
    // unless this is the original module we were asked to find the
    // set for.
    //
    if (!fFoundOne && (pMod != pCtx->pSourceMod))
    {

    CHAR pszBuf [4096];
    ULONG cch = celems(pszBuf);
    pCtx->DepChain.FDumpToString (pszBuf, &cch);
    strcat(pszBuf, "\n");
    printf(pszBuf);

        pCtx->hr = pCtx->pSet->HrAddModuleList (&pCtx->DepChain,
                        INS_APPEND | pCtx->dwFlags);
    }

    const CModule* pRemoved;

    pRemoved = pCtx->DepChain.RemoveLastModule();

    // This should be the component we appened above.
    //
    Assert (pRemoved == pMod);
}


CModuleTree::~CModuleTree ()
{
    FreeCollectionAndItem (Modules);
}

HRESULT
CModuleTree::HrAddEntry (
    IN CModule* pMod,
    IN CModule* pImport,
    IN DWORD dwFlags)
{
    HRESULT hr;
    iterator InsertPosition = NULL;
    CModuleTreeEntry* pEntry;

    Assert (pMod);
    Assert (pImport);

    if (size() == capacity())
    {
        //fprintf(stderr, "growing module tree buffer\n");

        __try
        {
            reserve (size() + 16384);
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            return E_OUTOFMEMORY;
        }
    }

    hr = S_OK;
    //pEntry = PFindFirstEntryAfterModuleGroup (pMod);

    pEntry = PBinarySearchEntryByModule (pMod, &InsertPosition);

    if (pEntry != end())
    {
        Assert (pEntry);

        CModuleTreeEntry* pScan;

        // Found an entry with a matching module.  Need to scan backwards
        // in the module group looking for a duplicate.  If not found,
        // Scan to the end looking for a duplicate and if we reach the
        // end of the group, we can insert this entry there.
        //
        pScan = pEntry;

        while (pScan != begin())
        {
            pScan--;

            if (pScan->m_pModule != pMod)
            {
                // Left the group without finding a dupliate.
                //
                break;
            }

            if (pScan->m_pImportModule == pImport)
            {
                // Don't insert duplicate entries.
                //
                return S_OK;
            }
        }

        Assert (pMod == pEntry->m_pModule);
        while (pEntry != end() && pEntry->m_pModule == pMod)
        {
            // Don't insert duplicate entries.
            //
            if (pEntry->m_pImportModule == pImport)
            {
                return S_OK;
            }
            pEntry++;
        }

        // Looks like we'll be inserting it.
        //
        InsertPosition = pEntry;
    }
    else
    {
        // InsertPosition is the correct insertion point.
        //
        Assert (InsertPosition);
    }

    __try
    {
        CModuleTreeEntry Entry;

        Entry.m_pModule = pMod;
        Entry.m_pImportModule = pImport;
        Entry.m_dwFlags = dwFlags;

        Assert (InsertPosition);
        insert (InsertPosition, Entry);
        Assert (S_OK == hr);

        DbgVerifySorted();
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}

HRESULT
CModuleTree::HrGetModuleBindings (
    IN const CModule* pMod,
    IN DWORD dwFlags /* GMB_FLAGS */,
    OUT CModuleListSet* pSet) const
{
    GMBCONTEXT Ctx;

    Assert (pMod);
    Assert (dwFlags);
    Assert (pSet);

    // Initialize the output parameter.
    //
    if (!(dwFlags & GMBF_ADD_TO_MLSET))
    {
        pSet->clear();
    }

    // Initialize members of the context structure for recursion.
    //
    ZeroMemory (&Ctx, sizeof(Ctx));
    Ctx.pTree = this;
    Ctx.pSourceMod = pMod;
    Ctx.dwFlags = (dwFlags & GMBF_ADD_TO_MLSET)
                    ? INS_IGNORE_IF_DUP
                    : INS_ASSERT_IF_DUP;
    Ctx.pSet = pSet;

    GetModuleBindings (pMod, &Ctx);

    return Ctx.hr;
}


CModuleTreeEntry*
CModuleTree::PBinarySearchEntryByModule (
    IN const CModule* pMod,
    OUT CModuleTreeEntry** pInsertPosition OPTIONAL) const
{
    Assert (pMod);

    // Find the module using a binary search.
    //
    if (size())
    {
        LONG Lo;
        LONG Hi;
        LONG Mid;
        INT Result;
        const CModuleTreeEntry* pScan;
        PCSTR pszFileName = pMod->m_pszFileName;

        Lo = 0;
        Hi = size() - 1;

        while (Hi >= Lo)
        {
            Mid = (Lo + Hi) / 2;

            Assert ((UINT)Mid < size());
            pScan = (begin() + Mid);

            Result = strcmp (pszFileName, pScan->m_pModule->m_pszFileName);

            if (Result < 0)
            {
                Hi = Mid - 1;
            }
            else if (Result > 0)
            {
                Lo = Mid + 1;
            }
            else
            {
                Assert (pMod == pScan->m_pModule);
                return const_cast<CModuleTreeEntry*>(pScan);
            }
        }

        // If we make it to here, the module was not found.
        //
        if (pInsertPosition)
        {
            CModule* pGroupMod;
            const CModuleTreeEntry* pPrev;

            // Seek to the beginning of this group.  We need to insert
            // before the entire group, not just the one item we last found.
            //
            pScan = begin() + Lo;

            if (pScan != begin())
            {
                pGroupMod = pScan->m_pModule;

                do
                {
                    pPrev = pScan - 1;

                    if (pPrev->m_pModule == pGroupMod)
                    {
                        pScan = pPrev;
                    }
                    else
                    {
                        break;
                    }

                } while (pPrev != begin());
            }

            *pInsertPosition = const_cast<CModuleTreeEntry*>(pScan);
            Assert (*pInsertPosition >= begin());
            Assert (*pInsertPosition <= end());
        }
    }
    else if (pInsertPosition)
    {
        // Empty collection.  Insert position is at the beginning.
        //
        *pInsertPosition = const_cast<CModuleTreeEntry*>(begin());
    }

    return const_cast<CModuleTreeEntry*>(end());
}

CModuleTreeEntry*
CModuleTree::PFindFirstEntryWithModule (
    IN const CModule* pMod) const
{
    CModuleTreeEntry* pEntry;

    Assert (pMod);

    pEntry = PBinarySearchEntryByModule (pMod, NULL);

    if (pEntry != end())
    {
        Assert (pEntry);

        if (pEntry != begin())
        {
            CModuleTreeEntry* pPrev;

            Assert (pMod == pEntry->m_pModule);

            while (1)
            {
                pPrev = pEntry - 1;

                if (pPrev->m_pModule == pMod)
                {
                    pEntry = pPrev;
                }
                else
                {
                    break;
                }

                if (pPrev == begin())
                {
                    break;
                }
            }
        }
    }

    return pEntry;
}

CModuleTreeEntry*
CModuleTree::PFindFirstEntryAfterModuleGroup (
    IN const CModule* pMod) const
{
    CModuleTreeEntry* pEntry;

    Assert (pMod);

    pEntry = PBinarySearchEntryByModule (pMod, NULL);

    if (pEntry != end())
    {
        Assert (pEntry);
        Assert (pMod == pEntry->m_pModule);

        while (pEntry != end() && pEntry->m_pModule == pMod)
        {
            pEntry++;
        }
    }

    return pEntry;
}

CModuleTreeEntry*
CModuleTree::PBinarySearchEntry (
    IN const CModule* pMod,
    IN const CModule* pImport,
    OUT CModuleTreeEntry** pInsertPosition OPTIONAL) const
{
    CModuleTreeEntry* pEntry;

    Assert (this);
    Assert (pMod);
    Assert (pImport);

    pEntry = PBinarySearchEntryByModule (pMod, pInsertPosition);

    if (pEntry != end())
    {
        Assert (pEntry);

        const CModuleTreeEntry* pScan;

        // Found an entry with a matching module.  Need to scan backwards
        // in the module group looking for a match.  If not found,
        // Scan to the end looking for a match and if we reach the
        // end of the group, that will be the insert position (if specified).
        //
        pScan = pEntry;
        while (pScan != begin())
        {
            pScan--;

            if (pScan->m_pModule != pMod)
            {
                // Left the group without finding a dupliate.
                //
                break;
            }

            if (pScan->m_pImportModule == pImport)
            {
                Assert (pScan->m_pModule == pMod);
                return const_cast<CModuleTreeEntry*>(pScan);
            }
        }

        pScan = pEntry;
        Assert (pMod == pScan->m_pModule);
        while (pScan != end() && pScan->m_pModule == pMod)
        {
            if (pScan->m_pImportModule == pImport)
            {
                Assert (pScan->m_pModule == pMod);
                return const_cast<CModuleTreeEntry*>(pScan);
            }

            pScan++;
        }

        if (pInsertPosition)
        {
            *pInsertPosition = const_cast<CModuleTreeEntry*>(pScan);
        }

        // No match.
        pEntry = const_cast<CModuleTreeEntry*>(end());
    }

    return pEntry;
}

#if DBG
VOID
CModuleTree::DbgVerifySorted ()
{
    CModuleTreeEntry* pScan;
    CModuleTreeEntry* pPrev = NULL;

    if (size() > 1)
    {
        for (pPrev = begin(), pScan = begin() + 1; pScan != end(); pScan++)
        {
            Assert (strcmp(pPrev->m_pModule->m_pszFileName,
                           pScan->m_pModule->m_pszFileName) <= 0);

            pPrev = pScan;
        }
    }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\tools\dllquery\peimage.cpp ===
#include "pch.h"
#pragma hdrstop
#include <ntimage.h>
#include "peimage.h"

HRESULT
CPeImage::HrOpenFile (
    IN PCSTR pszFileName)
{
    HRESULT hr;
    Assert (pszFileName && *pszFileName);

    hr = E_UNEXPECTED;

    Assert (!m_hFile);

    m_hFile = CreateFileA (pszFileName, GENERIC_READ,
                FILE_SHARE_READ, NULL, OPEN_EXISTING,
                FILE_ATTRIBUTE_NORMAL, NULL);

    if (INVALID_HANDLE_VALUE != m_hFile)
    {
        Assert (!m_hMapping);

        m_hMapping = CreateFileMapping (m_hFile, NULL,
                        PAGE_READONLY, 0, 0, NULL);
        if (m_hMapping)
        {
            Assert (!m_pvImage);

            m_pvImage = MapViewOfFile (m_hMapping, FILE_MAP_READ, 0, 0, 0);

            if (m_pvImage)
            {
                __try
                {
/*
                    PIMAGE_DOS_HEADER pIdh;
                    PIMAGE_NT_HEADERS pInh;

                    // Check for the DOS signature.
                    //
                    pIdh = (PIMAGE_DOS_HEADER)m_pvImage;
                    if (IMAGE_DOS_SIGNATURE != pIdh->e_magic)
                    {
                        __leave;
                    }

                    // Check for the NT/PE signature.
                    //
                    pInh = (PIMAGE_NT_HEADERS)((DWORD_PTR)m_pvImage + pIdh->e_lfanew);
                    if (IMAGE_NT_SIGNATURE != pInh->Signature)
                    {
                        __leave;
                    }
*/
                    PIMAGE_NT_HEADERS pNtHeaders;

                    pNtHeaders = RtlImageNtHeader (m_pvImage);
                    if (pNtHeaders)
                    {
                        hr = S_OK;
                    }
                    else
                    {
                        Assert (S_OK != hr);
                    }
                }
                __except(EXCEPTION_EXECUTE_HANDLER)
                {
                    // Not a PE image.
                    //
                    hr = E_UNEXPECTED;
                }
            }
        }
    }

    if (S_OK != hr)
    {
        CloseFile ();
    }

    return hr;
}

VOID
CPeImage::CloseFile ()
{
    if (m_pvImage)
    {
        UnmapViewOfFile (m_pvImage);
        m_pvImage = NULL;
    }

    if (m_hMapping)
    {
        CloseHandle (m_hMapping);
        m_hMapping = NULL;
    }

    if (m_hFile && (INVALID_HANDLE_VALUE != m_hFile))
    {
        CloseHandle (m_hFile);
    }
    m_hFile = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\tools\dllquery\persist.h ===
#pragma once
#include "modtree.h"

HRESULT
HrLoadModuleTree (
    OUT CModuleTree* pTree);

HRESULT
HrLoadModuleTreeFromBuffer (
    IN const BYTE* pbBuf,
    IN ULONG cbBuf,
    OUT CModuleTree* pTree);

HRESULT
HrLoadModuleTreeFromFileSystem (
    OUT CModuleTree* pTree);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\tools\dllquery\persist.cpp ===
#include "pch.h"
#pragma hdrstop
#include <delayimp.h>
#include "peimage.h"
#include "persist.h"

//-------------------------------------------------------------------------
// Purpose:
//    Returns true if the current state of the passed in
//    WIN32_FIND_DATA structure represents a child directory.
//
BOOL
IsChildDir (
    IN const WIN32_FIND_DATAA* pFindData)
{
   return (pFindData->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) &&
          (*pFindData->cFileName != '.');
}

BOOL
FFindNextChildDir (
    IN HANDLE hFind,
    IN OUT WIN32_FIND_DATAA* pFindData)
{
    BOOL fFound;

    do
    {
        fFound = !!FindNextFileA (hFind, pFindData);
    }
    while (fFound && !IsChildDir (pFindData));

    return fFound;
}

HANDLE
FFindFirstChildDir (
    IN PCSTR pszFileSpec,
    OUT WIN32_FIND_DATAA* pFindData)
{
    HANDLE hFind;

    hFind = FindFirstFileA (pszFileSpec, pFindData);

    if (INVALID_HANDLE_VALUE != hFind)
    {
        BOOL fFound = IsChildDir (pFindData);

        if (!fFound)
        {
            fFound = FFindNextChildDir (hFind, pFindData);
        }

        if (!fFound)
        {
            FindClose (hFind);
            hFind = INVALID_HANDLE_VALUE;
        }
    }

    return hFind;
}


// pszFilePath must be at least MAX_PATH characters
//
VOID
GetIndexFilePath (
    OUT PWSTR pszFilePath,
    IN UINT cchFilePath)
{
    GetSystemWindowsDirectory (pszFilePath, cchFilePath);
    wcscat (pszFilePath, L"dllquery.dat");
}

HRESULT
HrLoadModuleTree (
    OUT CModuleTree* pTree)
{
    HRESULT hr;
    WCHAR szIndexFile [MAX_PATH];
    HANDLE hFile;

    hr = E_UNEXPECTED;

    pTree->Modules.m_Granularity = 2048;

    // Open the index file if it exists.
    //
    GetIndexFilePath (szIndexFile, celems(szIndexFile));

    hFile = CreateFile (szIndexFile, GENERIC_READ, FILE_SHARE_READ,
                NULL, OPEN_EXISTING,
                FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN,
                NULL);

    if (INVALID_HANDLE_VALUE != hFile)
    {
        HANDLE hMapping;

        hMapping = CreateFileMapping (hFile, NULL, PAGE_READONLY, 0, 0, NULL);

        if (hMapping)
        {
            BYTE* pbBuf;
            UINT  cbBuf;
            DWORD cbSizeHi;

            pbBuf = (BYTE*)MapViewOfFile (hMapping, FILE_MAP_READ, 0, 0, 0);

            if (pbBuf)
            {
                cbBuf = GetFileSize (hFile, &cbSizeHi);
                hr = HrLoadModuleTreeFromBuffer (pbBuf, cbBuf, pTree);

                UnmapViewOfFile (pbBuf);
            }

            CloseHandle (hMapping);
        }

        CloseHandle (hFile);
    }
    else
    {
        hr = HrLoadModuleTreeFromFileSystem (pTree);
    }

    return hr;
}

HRESULT
HrLoadModuleTreeFromBuffer (
    IN const BYTE* pbBuf,
    IN ULONG cbBuf,
    OUT CModuleTree* pTree)
{
    HRESULT hr = S_OK;
    return hr;
}



HRESULT
HrLoadImportsForModule (
    IN CModule* pMod,
    IN CModuleTree* pTree,
    IN PVOID pvImage)
{
    HRESULT hr;
    PIMAGE_NT_HEADERS pNtHeaders;
    PIMAGE_SECTION_HEADER pNtSection = NULL;
    PIMAGE_IMPORT_DESCRIPTOR pImportDescriptor;
    PIMAGE_THUNK_DATA pThunk;
    ULONG cbImportDescriptor;
    PCSTR pszImportFileName;
    CModule* pImportMod;

    hr = S_OK;

    pNtHeaders = RtlImageNtHeader(pvImage);
    Assert (pNtHeaders);

    pImportDescriptor = (PIMAGE_IMPORT_DESCRIPTOR)
        RtlImageDirectoryEntryToData (
            pvImage,
            FALSE,
            IMAGE_DIRECTORY_ENTRY_IMPORT,
            &cbImportDescriptor);

    if (pImportDescriptor)
    {
        // Characteristics is zero for the terminating descriptor.
        //
        while (pImportDescriptor->Characteristics &&
               pImportDescriptor->FirstThunk)
        {
            Assert ((ULONG_PTR)pImportDescriptor <
                    (ULONG_PTR)pImportDescriptor + cbImportDescriptor);

            Assert (pImportDescriptor->Name);

            pszImportFileName = (PCSTR)RtlImageRvaToVa (pNtHeaders,
                                        pvImage,
                                        pImportDescriptor->Name,
                                        &pNtSection);

            Assert(*pszImportFileName);

            // Add this import to the list if we don't already have it
            // present.
            //
            hr = pTree->Modules.HrInsertNewModule (
                            pszImportFileName,
                            0,
                            INS_IGNORE_IF_DUP | INS_SORTED,
                            &pImportMod);

            if (S_OK == hr)
            {
                PSZ Function = NULL;

                hr = pTree->HrAddEntry (pMod, pImportMod, MTE_DEFAULT);

                if (S_OK != hr)
                {
                    break;
                }

                pThunk = (PIMAGE_THUNK_DATA)RtlImageRvaToVa (pNtHeaders,
                                                pvImage,
                                                pImportDescriptor->OriginalFirstThunk,
                                                &pNtSection);
                if (!IMAGE_SNAP_BY_ORDINAL(pThunk->u1.Ordinal))
                {
                    PIMAGE_IMPORT_BY_NAME ImportName =
                        (PIMAGE_IMPORT_BY_NAME)RtlImageRvaToVa (pNtHeaders,
                                                pvImage,
                                                pThunk->u1.AddressOfData,
                                                &pNtSection);
                    Function = (PSZ)ImportName->Name;

                }

                pThunk++;
                if (!pThunk->u1.AddressOfData)
                {
                    printf("%-16s  only imports 1 function from  %s  (%s)\n",
                        pMod->m_pszFileName,
                        pImportMod->m_pszFileName,
                        Function);
                }
            }

            pImportDescriptor++;
        }
    }

    return hr;
}

HRESULT
HrLoadDelayImportsForModule (
    IN CModule* pMod,
    IN CModuleTree* pTree,
    IN PVOID pvImage)
{
    HRESULT hr;
    PIMAGE_NT_HEADERS pNtHeaders;
    PIMAGE_SECTION_HEADER pNtSection = NULL;
    PImgDelayDescr pDelayDescriptor;
    ULONG cbDelayDescriptor;
    PCSTR pszImportFileName;
    CModule* pImportMod;

    hr = S_OK;

    pNtHeaders = RtlImageNtHeader(pvImage);
    Assert (pNtHeaders);

    pDelayDescriptor = (PImgDelayDescr)
        RtlImageDirectoryEntryToData (
            pvImage,
            FALSE,
            IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT,
            &cbDelayDescriptor);

    if (pDelayDescriptor)
    {
        Assert (pNtHeaders->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT].Size);

        ULONG_PTR ImageBase = pNtHeaders->OptionalHeader.ImageBase;

        // Characteristics is zero for the terminating descriptor.
        //
        while (pDelayDescriptor->pIAT &&
               pDelayDescriptor->pINT &&
               pDelayDescriptor->phmod)
        {
            Assert ((ULONG_PTR)pDelayDescriptor <
                    (ULONG_PTR)pDelayDescriptor + cbDelayDescriptor);

            Assert (pDelayDescriptor->szName);

            pNtSection = IMAGE_FIRST_SECTION (pNtHeaders);
            ULONG_PTR Rva = (ULONG_PTR)pDelayDescriptor->szName;
            ULONG_PTR Base = 0;

            for (INT i = 0; i < pNtHeaders->FileHeader.NumberOfSections; i++)
            {
                if ((Rva >= (ImageBase + pNtSection->VirtualAddress)) &&
                    (Rva <  (ImageBase + pNtSection->VirtualAddress + pNtSection->SizeOfRawData)))
                {
                    Base = (ULONG_PTR)pvImage
                        + pNtSection->PointerToRawData
                        - pNtSection->VirtualAddress - ImageBase;
                    break;
                }
                pNtSection++;
            }

            if (0 == Base)
            {
                break;
            }

            pszImportFileName = (PCSTR)(Base + Rva);

            Assert(*pszImportFileName);

            // Add this import to the list if we don't already have it
            // present.
            //
            hr = pTree->Modules.HrInsertNewModule (
                            pszImportFileName,
                            0,
                            INS_IGNORE_IF_DUP | INS_SORTED,
                            &pImportMod);

            if (S_OK == hr)
            {
                hr = pTree->HrAddEntry (pMod, pImportMod, MTE_DELAY_LOADED);

                if (S_OK != hr)
                {
                    break;
                }
            }

            pDelayDescriptor++;
        }
    }

    return hr;
}

HRESULT
HrLoadModuleTreeFromCurrentDirectory (
    OUT CModuleTree* pTree)
{
    HRESULT hr;
    HANDLE hFind;
    WIN32_FIND_DATAA FindData;

    hr = S_OK;

    // Enumerate all of the files in the current directory.
    //
    hFind = FindFirstFileA ("*", &FindData);

    if (INVALID_HANDLE_VALUE != hFind)
    {
        CPeImage PeImage;
        ZeroMemory (&PeImage, sizeof(PeImage));

        do
        {
            CModule* pMod;

            // Don't process directories.
            //
            if (FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
            {
                continue;
            }

            hr = PeImage.HrOpenFile (FindData.cFileName);

            if (S_OK == hr)
            {
                // Add this module to the list if we don't already have it
                // present.  (We can already have it if, while procesing the
                // imports of an earlier module, this module was one of those
                // imports.)
                //
                hr = pTree->Modules.HrInsertNewModule (
                                FindData.cFileName,
                                FindData.nFileSizeLow,
                                INS_IGNORE_IF_DUP | INS_SORTED,
                                &pMod);
                if (S_OK == hr)
                {
                    (VOID) HrLoadImportsForModule (
                                pMod, pTree, PeImage.m_pvImage);

                    (VOID) HrLoadDelayImportsForModule (
                                pMod, pTree, PeImage.m_pvImage);

                }

                PeImage.CloseFile ();
            }
        }
        while (FindNextFileA (hFind, &FindData));

        FindClose (hFind);
    }

    // Now recurse into subdirectories.
    //
    hFind = FFindFirstChildDir("*", &FindData);

    if (INVALID_HANDLE_VALUE != hFind)
    {
        do
        {
            fprintf(stderr, "Processing %s...\n", FindData.cFileName);

            if (SetCurrentDirectoryA (FindData.cFileName))
            {
                (VOID) HrLoadModuleTreeFromCurrentDirectory (pTree);

                SetCurrentDirectoryA ("..");
            }
        }
        while (FFindNextChildDir (hFind, &FindData));

        FindClose (hFind);
    }

    return hr;
}

HRESULT
HrLoadModuleTreeFromFileSystem (
    OUT CModuleTree* pTree)
{
    HRESULT hr;
    WCHAR szCurrentDir [MAX_PATH];
    WCHAR szSystemDir [MAX_PATH];

    // Save the current directory because we will be changing it.
    //
    GetCurrentDirectory (celems(szCurrentDir), szCurrentDir);
    GetSystemWindowsDirectory (szSystemDir, celems(szSystemDir));
    //wcscat (szSystemDir, L"\\system32");
    SetCurrentDirectory (szSystemDir);

    hr = HrLoadModuleTreeFromCurrentDirectory (pTree);

    SetCurrentDirectory (szCurrentDir);

    fprintf(stderr, "Processed %d PE modules.  (%d total imports)\n",
        pTree->Modules.size(),
        pTree->size());

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\tools\dllquery\version.h ===
#pragma once

#include <ntverp.h>
#include <winver.h>

#define VER_FILETYPE                    VFT_APP
#define VER_FILESUBTYPE                 VFT2_UNKNOWN
#define VER_FILEDESCRIPTION_STR         "DLL Query Tool"
#define VER_INTERNALNAME_STR            "dllquery.exe"

#include <common.ver>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\tools\enumdevs\enumdevs.c ===
// Private nt headers.
//
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <objbase.h>    // CLSIDFromString
#include <setupapi.h>
#include <conio.h>      // _kbhit
#include <stdio.h>      // printf

BOOL
FGetClassGuidFromCmdLineParam (
    PCWSTR     pszParam,
    GUID*       pguidClass)
{
    static const struct
    {
        GUID        guidClass;
        PCWSTR     pszName;
    } MapClassGuidToName [] =
    {
        { {0xad498944, 0x762f, 0x11d0, 0x8d, 0xcb, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c},
          L"ndislan" },
    };


    if (TEXT('{' == *pszParam))
    {
        return SUCCEEDED(CLSIDFromString ((LPOLESTR)pszParam, pguidClass));
    }
    else
    {
        INT i;
        for (i = 0;
             i < sizeof(MapClassGuidToName) / sizeof(MapClassGuidToName[0]);
             i++)
        {
            if (0 == lstrcmpiW (pszParam, MapClassGuidToName[i].pszName))
            {
                *pguidClass = MapClassGuidToName[i].guidClass;
                return TRUE;
            }
        }
    }
    return FALSE;
}

void
__cdecl
wmain (
    int     argc,
    PCWSTR argv[])
{
    GUID        guidClass;
    HDEVINFO    hdi;

    // Argument check
    //
    if (2 != argc)
    {
        printf ("%S {class guid}\n", argv[0]);
        return;
    }

    // Conver the string argument for the guid into a GUID.
    //
    if (!FGetClassGuidFromCmdLineParam (argv[1], &guidClass))
    {
        printf ("error: invalid class guid.\n");
    }

    // Get the devices in this class.
    //
    hdi = SetupDiGetClassDevs (&guidClass, NULL, NULL,
            DIGCF_PRESENT | DIGCF_DEVICEINTERFACE);
    if (hdi)
    {
        BYTE abBuffer [ sizeof(SP_DEVICE_INTERFACE_DETAIL_DATA) +
                        (MAX_PATH * sizeof(WCHAR)) ];

        SP_DEVICE_INTERFACE_DATA            did;
        PSP_DEVICE_INTERFACE_DETAIL_DATA    pDetail;
        DWORD                               i;

        ZeroMemory (&did, sizeof(did));
        did.cbSize = sizeof(did);

        pDetail = (PSP_DEVICE_INTERFACE_DETAIL_DATA)abBuffer;

        // Enumerate the device interfaces of the class.
        //
        for (i = 0;
             SetupDiEnumDeviceInterfaces (hdi, NULL, &guidClass, i, &did);
             i++)
        {
            pDetail->cbSize = sizeof(*pDetail);

            if (SetupDiGetDeviceInterfaceDetail (hdi, &did,
                    pDetail, sizeof(abBuffer), NULL, NULL))
            {
                HANDLE  hFile;

                printf ("opening %S\n", pDetail->DevicePath);

                hFile = CreateFile (pDetail->DevicePath,
                            GENERIC_READ | GENERIC_WRITE,
                            0, NULL, OPEN_EXISTING,
                            FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED,
                            NULL);
                if (hFile && (INVALID_HANDLE_VALUE != hFile))
                {
                    printf ("press any key to close device...");
                    while (!_kbhit())
                    {
                        Sleep (20);
                    }
                    _getch ();
                    printf ("\n\n");

                    CloseHandle (hFile);
                }
                else
                {
                    printf ("error: CreateFile failed. (%d)\n\n",
                        GetLastError ());
                }
            }
            else
            {
                printf ("error: SetupDiGetDeviceInterfaceDetail failed "
                    "for item %d. (%d)\n", i, GetLastError ());
            }
        }

        SetupDiDestroyDeviceInfoList (hdi);
    }
    else
    {
        printf ("error: SetupDiGetClassDevs returned %d", GetLastError ());
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\tools\enumdevs\version.h ===
#pragma once

#include <ntverp.h>
#include <winver.h>

#define VER_FILETYPE                    VFT_APP
#define VER_FILESUBTYPE                 VFT2_UNKNOWN
#define VER_FILEDESCRIPTION_STR         "Enumerate Devices on an Interface"
#define VER_INTERNALNAME_STR            "enumdevs.exe"

#include <common.ver>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\tools\icomerge\implinc.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       I M P L I N C . C P P
//
//  Contents:
//
//  Notes:
//
//  Author:     shaunco   25 Nov 1997
//
//----------------------------------------------------------------------------

#pragma hdrstop

#include "netcfgx.h"
//#include "netcfgxp.h"
#include "netcfgp.h"
//#include "netcfgx_i.c"
//#include "netcfgxp_i.c"
//#include "netcfgp_i.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\tools\icomerge\icomerge.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       I C O M E R G E . C P P
//
//  Contents:   Utility functions for loading and merging icons
//
//  Notes:
//
//  Author:     jeffspr   18 Nov 1998
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

#include "ncdebug.h"
#include "icomerge.h"

#define WIDTHBYTES(bits)    (((bits) + 31) / 32 * 4)

UINT ReadICOHeader( HANDLE hFile )
{
    WORD    Input;
    DWORD   dwBytesRead;      // Read the 'reserved' WORD

    if( ! ReadFile( hFile, &Input, sizeof( WORD ), &dwBytesRead, NULL ) )
        return (UINT)-1;     // Did we get a WORD?
    if( dwBytesRead != sizeof( WORD ) )
        return (UINT)-1;     // Was it 'reserved' ?   (ie 0)
    if( Input != 0 )
        return (UINT)-1;     // Read the type WORD
    if( ! ReadFile( hFile, &Input, sizeof( WORD ), &dwBytesRead, NULL ) )
        return (UINT)-1;     // Did we get a WORD?
    if( dwBytesRead != sizeof( WORD ) )
        return (UINT)-1;     // Was it type 1?
    if( Input != 1 )
        return (UINT)-1;     // Get the count of images
    if( ! ReadFile( hFile, &Input, sizeof( WORD ), &dwBytesRead, NULL ) )
        return (UINT)-1;     // Did we get a WORD?
    if( dwBytesRead != sizeof( WORD ) )
        return (UINT)-1;     // Return the count

    return Input;
}

DWORD BytesPerLine( LPBITMAPINFOHEADER lpBMIH )
{
    return WIDTHBYTES(lpBMIH->biWidth * lpBMIH->biPlanes * lpBMIH->biBitCount);
}

WORD DIBNumColors( PSTR lpbi )
{
    WORD wBitCount;
    DWORD dwClrUsed;
    dwClrUsed = ((LPBITMAPINFOHEADER) lpbi)->biClrUsed;

    if (dwClrUsed)
        return (WORD) dwClrUsed;

    wBitCount = ((LPBITMAPINFOHEADER) lpbi)->biBitCount;
    switch (wBitCount)
    {
        case 1:
            return 2;
        case 4:
            return 16;
        case 8:
            return 256;
        default:
            return 0;
    }

    return 0;

}

WORD PaletteSize( PSTR lpbi )
{
    return ( DIBNumColors( lpbi ) * sizeof( RGBQUAD ) );
}

PSTR FindDIBBits( PSTR lpbi )
{
    return ( lpbi + *(LPDWORD)lpbi + PaletteSize( lpbi ) );
}

BOOL AdjustIconImagePointers( LPICONIMAGE lpImage )
{     // Sanity check
    if( lpImage==NULL )
        return FALSE;     // BITMAPINFO is at beginning of bits
    lpImage->lpbi = (LPBITMAPINFO)lpImage->lpBits;     // Width - simple enough
    lpImage->Width = lpImage->lpbi->bmiHeader.biWidth;     // Icons are stored in funky format where height is doubled - account for it
    lpImage->Height = (lpImage->lpbi->bmiHeader.biHeight)/2;     // How many colors?
    lpImage->Colors = lpImage->lpbi->bmiHeader.biPlanes * lpImage->lpbi->bmiHeader.biBitCount;     // XOR bits follow the header and color table
    lpImage->lpXOR = (unsigned char *)FindDIBBits((PSTR)lpImage->lpbi);     // AND bits follow the XOR bits
    lpImage->lpAND = lpImage->lpXOR + (lpImage->Height*BytesPerLine((LPBITMAPINFOHEADER)(lpImage->lpbi)));
    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Function:   ReadIconFromICOFile
//
//  Purpose:    Load an icon into memory
//
//  Arguments:
//      szFileName [in]     ICO file to read
//
//  Returns:
//
//  Author:     jeffspr   18 Nov 1998
//
//  Notes:
//
LPICONRESOURCE ReadIconFromICOFile( PCWSTR szFileName )
{
    LPICONRESOURCE    lpIR = NULL, lpNew = NULL;
    HANDLE            hFile = NULL;
    UINT                i;
    DWORD            dwBytesRead;
    LPICONDIRENTRY    lpIDE = NULL;
    // Open the file
    if( (hFile = CreateFile( szFileName, GENERIC_READ, 0, NULL,
                             OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL )) == INVALID_HANDLE_VALUE )
    {
        MessageBox( NULL, L"Error Opening File for Reading", szFileName, MB_OK );
        return NULL;
    }

    // Allocate memory for the resource structure
    if( (lpIR = (LPICONRESOURCE) malloc( sizeof(ICONRESOURCE) )) == NULL )
    {
        MessageBox( NULL, L"Error Allocating Memory", szFileName, MB_OK );
        CloseHandle( hFile );
        return NULL;
    }

    // Read in the header
    if( (lpIR->nNumImages = ReadICOHeader( hFile )) == (UINT)-1 )
    {
        MessageBox( NULL, L"Error Reading File Header", szFileName, MB_OK );
        CloseHandle( hFile );
        free( lpIR );
        return NULL;
    }

    // Adjust the size of the struct to account for the images
    if( (lpNew = (LPICONRESOURCE) realloc( lpIR, sizeof(ICONRESOURCE) +
                          ((lpIR->nNumImages-1) * sizeof(ICONIMAGE)) )) == NULL )
    {
        MessageBox( NULL, L"Error Allocating Memory", szFileName, MB_OK );
        CloseHandle( hFile );
        free( lpIR );
        return NULL;
    }

    lpIR = lpNew;

    // Store the original name
    lstrcpyW( lpIR->szOriginalICOFileName, szFileName );
    lstrcpyW( lpIR->szOriginalDLLFileName, L"" );

    // Allocate enough memory for the icon directory entries
    if( (lpIDE = (LPICONDIRENTRY) malloc( lpIR->nNumImages * sizeof( ICONDIRENTRY ) ) ) == NULL )
    {
        MessageBox( NULL, L"Error Allocating Memory", szFileName, MB_OK );
        CloseHandle( hFile );
        free( lpIR );
        return NULL;
    }

    // Read in the icon directory entries
    if( ! ReadFile( hFile, lpIDE, lpIR->nNumImages * sizeof( ICONDIRENTRY ), &dwBytesRead, NULL ) )
    {
        MessageBox( NULL, L"Error Reading File", szFileName, MB_OK );
        CloseHandle( hFile );
        free( lpIR );
        return NULL;
    }

    if( dwBytesRead != lpIR->nNumImages * sizeof( ICONDIRENTRY ) )
    {
        MessageBox( NULL, L"Error Reading File", szFileName, MB_OK );
        CloseHandle( hFile );
        free( lpIR );
        return NULL;
    }

    // Loop through and read in each image
    for( i = 0; i < lpIR->nNumImages; i++ )
    {
        // Allocate memory for the resource
        if( (lpIR->IconImages[i].lpBits = (LPBYTE) malloc(lpIDE[i].dwBytesInRes)) == NULL )
        {
            MessageBox( NULL, L"Error Allocating Memory", szFileName, MB_OK );
            CloseHandle( hFile );
            free( lpIR );
            free( lpIDE );
            return NULL;
        }

        lpIR->IconImages[i].dwNumBytes = lpIDE[i].dwBytesInRes;

        // Seek to beginning of this image
        if( SetFilePointer( hFile, lpIDE[i].dwImageOffset, NULL, FILE_BEGIN ) == 0xFFFFFFFF )
        {
            MessageBox( NULL, L"Error Seeking in File", szFileName, MB_OK );
            CloseHandle( hFile );
            free( lpIR );
            free( lpIDE );
            return NULL;
        }

        // Read it in
        if( ! ReadFile( hFile, lpIR->IconImages[i].lpBits, lpIDE[i].dwBytesInRes, &dwBytesRead, NULL ) )
        {
            MessageBox( NULL, L"Error Reading File", szFileName, MB_OK );
            CloseHandle( hFile );
            free( lpIR );
            free( lpIDE );
            return NULL;
        }

        if( dwBytesRead != lpIDE[i].dwBytesInRes )
        {
            MessageBox( NULL, L"Error Reading File", szFileName, MB_OK );
            CloseHandle( hFile );
            free( lpIDE );
            free( lpIR );
            return NULL;
        }

        // Set the internal pointers appropriately
        if( ! AdjustIconImagePointers( &(lpIR->IconImages[i]) ) )
        {
            MessageBox( NULL, L"Error Converting to INternal format", szFileName, MB_OK );
            CloseHandle( hFile );
            free( lpIDE );
            free( lpIR );
            return NULL;
        }
    }

    // Clean up
    free( lpIDE );
    CloseHandle( hFile );
    return lpIR;
}

UINT GetBits(UINT uiNumber, INT iStart, INT iBits)
{
    return (uiNumber >> (iStart+1-iBits)) & ~(~0 << iBits);
}

VOID DebugPrintIconMasks(LPICONRESOURCE pIR)
{
    UINT    uiColorLoop = 0;
    UINT    uiColors = pIR->IconImages[0].Colors;
    UINT    uiBitCount = pIR->IconImages[0].lpbi->bmiHeader.biBitCount;

    printf("Num images: %d\n", pIR->nNumImages);
    printf("Name: %S\n", pIR->szOriginalICOFileName);

#if 0
    UINT Width, Height, Colors; // Width, Height and bpp
    LPBYTE lpBits;                // ptr to DIB bits
    DWORD dwNumBytes;            // how many bytes?
    LPBITMAPINFO lpbi;                  // ptr to header
    LPBYTE lpXOR;                 // ptr to XOR image bits
    LPBYTE lpAND;                 // ptr to AND image bits
#endif

    printf("Width: %d, Height: %d\n", pIR->IconImages[0].Width, pIR->IconImages[0].Height);
    printf("Color Depth: %d\n", uiBitCount);
    printf("Colors: %d, Bytes: %d\n", uiColors, pIR->IconImages[0].dwNumBytes);

    for (uiColorLoop = 0; uiColorLoop < uiColors; uiColorLoop++)
    {
        printf("Color %d, R: %d  G: %d  B: %d\n",
            uiColorLoop,
            pIR->IconImages[0].lpbi->bmiColors[uiColorLoop].rgbRed,
            pIR->IconImages[0].lpbi->bmiColors[uiColorLoop].rgbGreen,
            pIR->IconImages[0].lpbi->bmiColors[uiColorLoop].rgbBlue);
    }

    UINT uiNewLine = 0;
    UINT uiNewByte = 0;
    UINT uiByteLoop = 0;
    UINT uiPixel = 0;

    printf("XOR map:\n");
    while(uiPixel < (pIR->IconImages[0].Width * pIR->IconImages[0].Height))
    {
        BYTE bCurrentByte = pIR->IconImages[0].lpXOR[uiByteLoop];

        if (uiBitCount == 4)
        {
            BYTE bXOR = (bCurrentByte & 0xF0);
            if (bXOR > 0)
                printf("*");
            else
                printf(" ");

            if (++uiNewLine >= pIR->IconImages[0].Width)
            {
                uiNewLine = 0;
                printf("\n");
            }

            bXOR = (bCurrentByte & 0x0F);
            if (bXOR > 0)
                printf("*");
            else
                printf(" ");

            if (++uiNewLine >= pIR->IconImages[0].Width)
            {
                uiNewLine = 0;
                printf("\n");
            }

            uiByteLoop++;
            uiPixel += 2;
        }
        else
        {
            Assert(uiBitCount == 8);

            BYTE bXOR = pIR->IconImages[0].lpXOR[uiPixel];

            if (bXOR > 0)
                printf("*");
            else
                printf(" ");

            if (++uiNewLine >= pIR->IconImages[0].Width)
            {
                uiNewLine = 0;
                printf("\n");
            }

            uiPixel++;
        }
    }

    uiNewLine = 0;
    UINT uiANDBytes = (pIR->IconImages[0].Width * pIR->IconImages[0].Height) / 8;

    printf("AND map:\n");
    for (uiPixel = 0; uiPixel < uiANDBytes; uiPixel++)
    {
        UINT uiCurrentByte = pIR->IconImages[0].lpAND[uiPixel];
        UINT uiCurrentBit = 0;

        for (uiCurrentBit = 0; uiCurrentBit < 8; uiCurrentBit++)
        {
            if (GetBits(uiCurrentByte, 7-uiCurrentBit, 1))
            {
                printf("*");
            }
            else
            {
                printf(" ");
            }

            if (++uiNewLine >= pIR->IconImages[0].Width)
            {
                uiNewLine = 0;
                printf("\n");
            }
        }
    }
}

VOID OverlayIcons(LPICONRESOURCE pIRBase, LPICONRESOURCE pIROverlay)
{
    UINT uiANDLoop = 0;
    UINT uiXORByte = 0;
    UINT uiANDBytes = (pIROverlay->IconImages[0].Width * pIROverlay->IconImages[0].Height) / 8;
    UINT uiNewLine = 0;
    UINT uiBitCountBase = pIRBase->IconImages[0].lpbi->bmiHeader.biBitCount;
    UINT uiBitCountOverlay = pIROverlay->IconImages[0].lpbi->bmiHeader.biBitCount;

    if (uiBitCountBase != uiBitCountOverlay)
    {
        AssertSz(uiBitCountBase == uiBitCountOverlay, "Non-compatible bitcounts");
        printf("*** ERROR ***  Icon bitcounts different in OverlayIcons, base: %d, overlay: %d",
               uiBitCountBase, uiBitCountOverlay);
        goto Exit;
    }

    for (uiANDLoop = 0; uiANDLoop < uiANDBytes; uiANDLoop++)
    {
        BYTE uiCurrentByte = pIROverlay->IconImages[0].lpAND[uiANDLoop];
        UINT uiCurrentBit = 0;

        for (uiCurrentBit = 0; uiCurrentBit < 8; uiCurrentBit++)
        {
            if (!GetBits(uiCurrentByte, 7-uiCurrentBit, 1))
            {
//                printf("$");
                BYTE bNewANDBits = 1;
                BYTE bXORBaseMask = 0x00;
                BYTE bXOROverlayMask = 0x00;
                BYTE bNewXORBits = 0x00;

                bNewANDBits <<= (7-uiCurrentBit);
                bNewANDBits = ~bNewANDBits;
                pIRBase->IconImages[0].lpAND[uiANDLoop] &= bNewANDBits;

                switch(uiBitCountBase)
                {
                    case 4:
                        // If even number, use the first set of bits
                        //
                        if ((uiCurrentBit % 2) == 0)
                        {
                            bXORBaseMask = 0x0F;
                            bXOROverlayMask = 0xF0;
                        }
                        else
                        {
                            bXORBaseMask = 0xF0;
                            bXOROverlayMask = 0x0F;
                        }
                        break;
                    case 8:
                        bXORBaseMask = 0x00;
                        bXOROverlayMask = 0xFF;
                        break;
                    default:
                        AssertSz(FALSE, "Unsupported bitcount in OverlayIcons. What's up with that?");
                        printf("*** ERROR ***  Non-supported bitcount, bits: %d\n", uiBitCountBase);
                        break;
                }

                bNewXORBits = (pIRBase->IconImages[0].lpXOR[uiXORByte] & bXORBaseMask) |
                                (pIROverlay->IconImages[0].lpXOR[uiXORByte] & bXOROverlayMask);
                pIRBase->IconImages[0].lpXOR[uiXORByte] = bNewXORBits;

            }
            else
            {
//                printf(" ");
            }

            switch(uiBitCountBase)
            {
                case 4:
                    if ((uiCurrentBit % 2))
                    {
                        uiXORByte++;
                    }
                    break;
                case 8:
                    uiXORByte++;
                    break;
            }

            if (++uiNewLine >= pIROverlay->IconImages[0].Width)
            {
                uiNewLine = 0;
//                printf("\n");
            }
        }
    }

Exit:
    return;
}

BOOL WriteICOHeader( HANDLE hFile, UINT nNumEntries )
{
    WORD    Output;
    DWORD   dwBytesWritten;

    // Write 'reserved' WORD
    Output = 0;
    if( ! WriteFile( hFile, &Output, sizeof( WORD ), &dwBytesWritten, NULL ) )
        return FALSE;
    // Did we write a WORD?
    if( dwBytesWritten != sizeof( WORD ) )
        return FALSE;
    // Write 'type' WORD (1)
    Output = 1;
    if( ! WriteFile( hFile, &Output, sizeof( WORD ), &dwBytesWritten, NULL ) )
        return FALSE;
    // Did we write a WORD?
    if( dwBytesWritten != sizeof( WORD ) )
        return FALSE;
    // Write Number of Entries
    Output = (WORD)nNumEntries;
    if( ! WriteFile( hFile, &Output, sizeof( WORD ), &dwBytesWritten, NULL ) )
        return FALSE;
    // Did we write a WORD?
    if( dwBytesWritten != sizeof( WORD ) )
        return FALSE;
    return TRUE;
}

/****************************************************************************
*
*     FUNCTION: CalculateImageOffset
*
*     PURPOSE:  Calculates the file offset for an icon image
*
*     PARAMS:   LPICONRESOURCE lpIR   - pointer to icon resource
*               UINT           nIndex - which image?
*
*     RETURNS:  DWORD - the file offset for that image
*
* History:
*                July '95 - Created
*
\****************************************************************************/
DWORD CalculateImageOffset( LPICONRESOURCE lpIR, UINT nIndex )
{
    DWORD   dwSize;
    UINT    i;

    // Calculate the ICO header size
    dwSize = 3 * sizeof(WORD);
    // Add the ICONDIRENTRY's
    dwSize += lpIR->nNumImages * sizeof(ICONDIRENTRY);
    // Add the sizes of the previous images
    for(i=0;i<nIndex;i++)
        dwSize += lpIR->IconImages[i].dwNumBytes;
    // we're there - return the number
    return dwSize;
}


/****************************************************************************
*
*     FUNCTION: WriteIconToICOFile
*
*     PURPOSE:  Writes the icon resource data to an ICO file
*
*     PARAMS:   LPICONRESOURCE lpIR       - pointer to icon resource
*               PCWSTR        szFileName - name for the ICO file
*
*     RETURNS:  BOOL - TRUE for success, FALSE for failure
*
* History:
*                July '95 - Created
*
\****************************************************************************/
BOOL WriteIconToICOFile( LPICONRESOURCE lpIR, PCWSTR szFileName )
{
    HANDLE    hFile;
    UINT        i;
    DWORD    dwBytesWritten;

    // open the file
    if( (hFile = CreateFile( szFileName, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL )) == INVALID_HANDLE_VALUE )
    {
        MessageBox( NULL, L"Error Opening File for Writing", szFileName, MB_OK );
        return FALSE;
    }
    // Write the header
    if( ! WriteICOHeader( hFile, lpIR->nNumImages ) )
    {
        MessageBox( NULL, L"Error Writing ICO File", szFileName, MB_OK );
        CloseHandle( hFile );
        return FALSE;
    }
    // Write the ICONDIRENTRY's
    for( i=0; i<lpIR->nNumImages; i++ )
    {
        ICONDIRENTRY    ide;

        // Convert internal format to ICONDIRENTRY
        ide.bWidth = (BYTE)lpIR->IconImages[i].Width;
        ide.bHeight = (BYTE)lpIR->IconImages[i].Height;
        ide.bReserved = 0;
        ide.wPlanes = lpIR->IconImages[i].lpbi->bmiHeader.biPlanes;
        ide.wBitCount = lpIR->IconImages[i].lpbi->bmiHeader.biBitCount;
        if( (ide.wPlanes * ide.wBitCount) >= 8 )
            ide.bColorCount = 0;
        else
            ide.bColorCount = 1 << (ide.wPlanes * ide.wBitCount);
        ide.dwBytesInRes = lpIR->IconImages[i].dwNumBytes;
        ide.dwImageOffset = CalculateImageOffset( lpIR, i );
        // Write the ICONDIRENTRY out to disk
        if( ! WriteFile( hFile, &ide, sizeof( ICONDIRENTRY ), &dwBytesWritten, NULL ) )
            return FALSE;
        // Did we write a full ICONDIRENTRY ?
        if( dwBytesWritten != sizeof( ICONDIRENTRY ) )
            return FALSE;
    }
    // Write the image bits for each image
    for( i=0; i<lpIR->nNumImages; i++ )
    {
        DWORD dwTemp = lpIR->IconImages[i].lpbi->bmiHeader.biSizeImage;

        // Set the sizeimage member to zero
        lpIR->IconImages[i].lpbi->bmiHeader.biSizeImage = 0;
        // Write the image bits to file
        if( ! WriteFile( hFile, lpIR->IconImages[i].lpBits, lpIR->IconImages[i].dwNumBytes, &dwBytesWritten, NULL ) )
            return FALSE;
        if( dwBytesWritten != lpIR->IconImages[i].dwNumBytes )
            return FALSE;
        // set it back
        lpIR->IconImages[i].lpbi->bmiHeader.biSizeImage = dwTemp;
    }
    CloseHandle( hFile );
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\tools\icomerge\icomerge.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       I C O M E R G E . H
//
//  Contents:   Utility functions for merging icons
//
//  Notes:
//
//  Author:     jeffspr   18 Nov 1998
//
//----------------------------------------------------------------------------

#ifndef _ICOMERGE_H_
#define _ICOMERGE_H_

#pragma once

/****************************************************************************\
*  *     FILE:     Icons.H
* *     PURPOSE:  IconPro Project Icon handling header file
* *     COMMENTS:  *
* *     Copyright 1995 - 1998 Microsoft Corp. *
* * History:
*                July '95 - Created
* \****************************************************************************/
/****************************************************************************/

// Structs
// These first two structs represent how the icon information is stored
// when it is bound into a EXE or DLL file. Structure members are WORD
// aligned and the last member of the structure is the ID instead of
// the imageoffset.

#pragma pack( push )
#pragma pack( 2 )

typedef struct
{
    BYTE bWidth;               // Width of the image
    BYTE bHeight;              // Height of the image (times 2)
    BYTE bColorCount;          // Number of colors in image (0 if >=8bpp)
    BYTE bReserved;            // Reserved
    WORD wPlanes;              // Color Planes
    WORD wBitCount;            // Bits per pixel
    DWORD dwBytesInRes;        // how many bytes in this resource?
    WORD nID;                  // the ID
} MEMICONDIRENTRY, *LPMEMICONDIRENTRY;

typedef struct
{
    WORD idReserved;   // Reserved
    WORD idType;       // resource type (1 for icons)
    WORD idCount;      // how many images?
    MEMICONDIRENTRY idEntries[1]; // the entries for each image
} MEMICONDIR, *LPMEMICONDIR;

#pragma pack( pop )

// These next two structs represent how the icon information is stored
// in an ICO file.

typedef struct
{
    BYTE bWidth;               // Width of the image
    BYTE bHeight;              // Height of the image (times 2)
    BYTE bColorCount;          // Number of colors in image (0 if >=8bpp)
    BYTE bReserved;            // Reserved
    WORD wPlanes;              // Color Planes
    WORD wBitCount;            // Bits per pixel
    DWORD dwBytesInRes;         // how many bytes in this resource?
    DWORD dwImageOffset;        // where in the file is this image
} ICONDIRENTRY, *LPICONDIRENTRY;

typedef struct
{
    WORD idReserved;   // Reserved
    WORD idType;       // resource type (1 for icons)
    WORD idCount;      // how many images?
    ICONDIRENTRY idEntries[1]; // the entries for each image
} ICONDIR, *LPICONDIR;

// The following two structs are for the use of this program in
// manipulating icons. They are more closely tied to the operation
// of this program than the structures listed above. One of the
// main differences is that they provide a pointer to the DIB
// information of the masks.

typedef struct
{
    UINT Width, Height, Colors; // Width, Height and bpp
    LPBYTE lpBits;                // ptr to DIB bits
    DWORD dwNumBytes;            // how many bytes?
    LPBITMAPINFO lpbi;                  // ptr to header
    LPBYTE lpXOR;                 // ptr to XOR image bits
    LPBYTE lpAND;                 // ptr to AND image bits
} ICONIMAGE, *LPICONIMAGE;

typedef struct
{
    BOOL bHasChanged;                     // Has image changed?
    WCHAR szOriginalICOFileName[MAX_PATH]; // Original name
    WCHAR szOriginalDLLFileName[MAX_PATH]; // Original name
    UINT nNumImages;                      // How many images?
    ICONIMAGE IconImages[1];                   // Image entries
} ICONRESOURCE, *LPICONRESOURCE;

/****************************************************************************/
/****************************************************************************/
// Exported function prototypes

LPICONRESOURCE ReadIconFromICOFile( PCWSTR szFileName );
BOOL WriteIconToICOFile( LPICONRESOURCE lpIR, PCWSTR szFileName );
HICON MakeIconFromResource( LPICONIMAGE lpIcon );
LPICONRESOURCE ReadIconFromEXEFile( PCWSTR szFileName );
BOOL IconImageToClipBoard( LPICONIMAGE lpii );
BOOL IconImageFromClipBoard( LPICONIMAGE lpii, BOOL bStretchToFit );
BOOL CreateBlankNewFormatIcon( LPICONIMAGE lpii );
BOOL DrawXORMask( HDC hDC, RECT Rect, LPICONIMAGE lpIcon );
BOOL DrawANDMask( HDC hDC, RECT Rect, LPICONIMAGE lpIcon );
RECT GetXORImageRect( RECT Rect, LPICONIMAGE lpIcon );
BOOL MakeNewANDMaskBasedOnPoint( LPICONIMAGE lpIcon, POINT pt );
BOOL IconImageFromBMPFile( PCWSTR szFileName, LPICONIMAGE lpii, BOOL bStretchToFit );
BOOL IconImageToBMPFile( PCWSTR szFileName, LPICONIMAGE lpii );

VOID DebugPrintIconMasks(LPICONRESOURCE pIR);
VOID OverlayIcons(LPICONRESOURCE pIR1, LPICONRESOURCE pIR2);

LPICONRESOURCE ReadIconFromICOFile( PCWSTR szFileName );

#endif // _ICOMERGE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\tools\icomerge\version.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       V E R S I O N . H 
//
//  Contents:   Provides version info
//
//  Notes:      
//
//  Author:     jeffspr   18 Nov 1998
//
//----------------------------------------------------------------------------

#include <ntverp.h>
#include <winver.h>

#define VER_FILETYPE                    VFT_DLL
#define VER_FILESUBTYPE                 VFT2_UNKNOWN
#define VER_FILEDESCRIPTION_STR         "Icon Merging Tool"
#define VER_INTERNALNAME_STR            "icomerge.exe"

#include "common.ver"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\tools\lanacfg\lanacfg.cpp ===
#include "pch.h"
#pragma hdrstop
#include "diag.h"
#include "nb30.h"

#define SZ_CMD_SHOW_LANA_DIAG           L"showlanadiag"
#define SZ_CMD_SHOW_LANA_PATHS          L"showlanapaths"
#define SZ_CMD_SET_LANA_NUMBER          L"setlananumber"
#define SZ_CMD_REWRITE_LANA_INFO        L"rewritelanainfo"

// Parameter strings for SZ_CMD_FULL_DIAGNOSTIC
//
#define SZ_PARAM_LEAK_CHECK             L"leakcheck"

VOID
Usage (
    IN PCTSTR pszProgramName,
    IN COMMAND Command)
{
    switch (Command)
    {
        case CMD_SHOW_LANA_DIAG:
            break;

        case CMD_SHOW_LANA_PATHS:
            break;

        case CMD_SET_LANA_NUMBER:
            g_pDiagCtx->Printf (ttidNcDiag,
                "\n"
                "%S %S <old lana number> <new lana number>\n"
                "\n",
                pszProgramName,
                SZ_CMD_SET_LANA_NUMBER);
            break;

        case CMD_REWRITE_LANA_INFO:
            break;

        default:
            g_pDiagCtx->Printf (ttidNcDiag,
                "\n"
                "Network Configuration Diagnostic\n"
                "   View, manipulate, or test network configuration.\n"
                "\n"
                "%S [options]\n"
                "   %-15S - Show bind paths and component descriptions for each exported lana\n"
                "   %-15S - Change the lana number of a bind path\n"
                "   %-15S - Verify and write out lana info to the registry\n"
                "   %-15S - Show lana diagnostic info\n"
                "\n\n",
                pszProgramName,
                SZ_CMD_SHOW_LANA_PATHS,
                SZ_CMD_SET_LANA_NUMBER,
                SZ_CMD_REWRITE_LANA_INFO,
                SZ_CMD_SHOW_LANA_DIAG);
            break;
    }
}

#define NthArgIsPresent(_i) (_i < argc)
#define NthArgIs(_i, _sz)   ((_i < argc) && (0 == _wcsicmp(argv[_i], _sz)))


EXTERN_C
VOID
__cdecl
wmain (
    IN INT     argc,
    IN PCWSTR argv[])
{
    CDiagContext DiagCtx;
    DIAG_OPTIONS Options;
    INT iArg;

    DiagCtx.SetFlags (DF_SHOW_CONSOLE_OUTPUT);
    g_pDiagCtx = &DiagCtx;

    ZeroMemory (&Options, sizeof(Options));
    Options.pDiagCtx = g_pDiagCtx;
    Options.Command = CMD_INVALID;

    if (argc < 2)
    {
        Usage (argv[0], Options.Command);
        return;
    }

    iArg = 1;

    if (NthArgIs (iArg, SZ_CMD_SHOW_LANA_DIAG))
    {
        Options.Command = CMD_SHOW_LANA_DIAG;
    }
    else if (NthArgIs (iArg, SZ_CMD_SHOW_LANA_PATHS))
    {
        Options.Command = CMD_SHOW_LANA_PATHS;
        iArg++;
        if (NthArgIs (iArg, SZ_PARAM_LEAK_CHECK))
        {
            Options.fLeakCheck = TRUE;
        }
    }
    else if (NthArgIs (iArg, SZ_CMD_SET_LANA_NUMBER))
    {
        Options.Command = CMD_SET_LANA_NUMBER;
        iArg++;
        if (NthArgIsPresent (iArg) &&
            NthArgIsPresent (iArg+1))
        {
            ULONG Lana;
            PWSTR pszStop;
            BOOL fBadLana = FALSE;
            Lana = wcstoul (argv[iArg], &pszStop, 10);

            if ((MAX_LANA < Lana) || !pszStop || *pszStop)
            {
                fBadLana = TRUE;
            }
            else
            {
                Options.OldLanaNumber = Lana;
                Lana = wcstoul (argv[iArg+1], &pszStop, 10);

                if ((MAX_LANA < Lana) || !pszStop || *pszStop)
                {
                    fBadLana = TRUE;
                }
                else
                {
                    Options.NewLanaNumber = Lana;
                }

            }

            if (fBadLana)
            {
                g_pDiagCtx->Printf (ttidNcDiag,
                    "\n"
                    "Lana Numbers must be in 0-%u range, inclusive.\n"
                    "\n", MAX_LANA);
                return;
            }
        }
        else
        {
            Usage (argv[0], Options.Command);
            return;
        }

    }
    else if (NthArgIs (iArg, SZ_CMD_REWRITE_LANA_INFO))
    {
        Options.Command = CMD_REWRITE_LANA_INFO;
    }
    else
    {
        Usage (argv[0], Options.Command);
        return;
    }

    HRESULT hr = CoInitializeEx (
                NULL,
                COINIT_DISABLE_OLE1DDE | COINIT_APARTMENTTHREADED);

    if (FAILED(hr))
    {
            g_pDiagCtx->Printf (ttidNcDiag,
                "Problem 0x%08x initializing COM library", hr);
            return;
    }

    LanaCfgFromCommandArgs (&Options);

    g_pDiagCtx->Printf (ttidNcDiag, "\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\tools\lanacfg\version.h ===
#pragma once

#include <ntverp.h>
#include <winver.h>

#define VER_FILETYPE                    VFT_APP
#define VER_FILESUBTYPE                 VFT2_UNKNOWN
#define VER_FILEDESCRIPTION_STR         "Lana Configuration"
#define VER_INTERNALNAME_STR            "lanacfg.exe"

#include <common.ver>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\tools\icomerge\main.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       M A I N . C P P
//
//  Contents:   Tool for merging icons
//
//  Author:     jeffspr     Nov-18-98
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

#include "ncdebug.h"
#include "icomerge.h"
#include "tchar.h"

//---[ Globals ]--------------------------------------------------------------

BOOL    g_fVerbose      = FALSE;
BOOL    g_fDebugOnly    = FALSE;

WCHAR   g_szInput1[MAX_PATH+1];
WCHAR   g_szInput2[MAX_PATH+1];
WCHAR   g_szOutput[MAX_PATH+1];

//---[ Prototypes ]-----------------------------------------------------------

BOOL WINAPI IcoMergeConsoleCrtlHandler(IN DWORD dwCtrlType);
BOOL FParseCmdLine(INT argc, WCHAR* argv[]);
void ShowUsage();

//+---------------------------------------------------------------------------
//
//  Function:   wmain
//
//  Purpose:    Standard main
//
//  Arguments:
//      argc [in]   Count of args
//      argv [in]   args
//
//  Returns:
//
//  Author:     jeffspr   18 Nov 1998
//
//  Notes:
//
EXTERN_C int __cdecl wmain(int argc, WCHAR* argv[])
{
    HRESULT         hr          = S_OK;
    BOOL            fVerbose    = FALSE;
    LPICONRESOURCE  pIR1        = NULL;
    LPICONRESOURCE  pIR2        = NULL;

    InitializeDebugging();

    if (FParseCmdLine(argc, argv))
    {
        SetConsoleCtrlHandler(IcoMergeConsoleCrtlHandler, TRUE);

        if(g_fDebugOnly)
        {
            pIR1 = ReadIconFromICOFile(g_szInput1);
            if (pIR1)
                DebugPrintIconMasks(pIR1);
        }
        else
        {
            pIR1 = ReadIconFromICOFile(g_szInput1);
            if (pIR1)
            {
                if (g_fVerbose)
                {
                    printf("Icon1:\n");
                    DebugPrintIconMasks(pIR1);
                }
            }

            pIR2 = ReadIconFromICOFile(g_szInput2);
            if (pIR2)
            {
                if (g_fVerbose)
                {
                    printf("Icon2:\n");
                    DebugPrintIconMasks(pIR2);
                }
            }

            if (pIR1 && pIR2)
            {
                OverlayIcons(pIR1, pIR2);

                if (g_fVerbose)
                {
                    DebugPrintIconMasks(pIR1);
                }

                WriteIconToICOFile(pIR1, g_szOutput);
            }
            else
            {
                printf("*** ERROR *** Not all icons were loaded. Can't generate overlay\n");
            }
        }
    }
    else
    {
        ShowUsage();
    }

    if (pIR1)
        free(pIR1);
    if (pIR2)
        free(pIR2);

    UnInitializeDebugging();

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   FParseCmdLine
//
//  Purpose:    Parse command line arguments
//
//  Arguments:
//      argc [in]   Count of args
//      argv [in]   Args
//
//  Returns:
//
//  Author:     jeffspr   18 Nov 1998
//
//  Notes:
//

BOOL FParseCmdLine(IN  int argc,
                   IN  WCHAR* argv[])
{
    BOOL    fReturn     = FALSE;
    INT     iParamLoop  = 0;

    if (argc < 4)
    {
        if (argc == 3)
        {
            if ((argv[2][0] == '/') &&
                ((argv[2][1] == 'd') || (argv[2][1] == 'D')))
            {
                g_fDebugOnly = TRUE;
                lstrcpyW(g_szInput1, argv[1]);
                fReturn = TRUE;
            }
            else
            {
                ShowUsage();
                goto Exit;
            }
        }
        else
        {
            ShowUsage();
            goto Exit;
        }
    }
    else
    {
        lstrcpyW(g_szInput1, argv[1]);
        lstrcpyW(g_szInput2, argv[2]);
        lstrcpyW(g_szOutput, argv[3]);

        for (iParamLoop = 4; iParamLoop < argc; iParamLoop++)
        {
            if (argv[iParamLoop][0] == '/')
            {
                switch(argv[iParamLoop][1])
                {
                    case '?':
                        ShowUsage();
                        goto Exit;
                    case 'v':
                        g_fVerbose = TRUE;
                        break;
                    default:
                        AssertSz(FALSE, "Unknown parameter");
                        ShowUsage();
                        goto Exit;
                }
            }
        }

        fReturn = TRUE;
    }

Exit:
    return fReturn;
}



#if 0
BOOL FParseCmdLine(IN  int argc,
                   IN  WCHAR* argv[])
{
    AssertValidReadPtr(argv);

    BOOL fStatus=FALSE;
    CHAR ch;

    static const WCHAR c_szValidOptions[] = L"f:vVlLhH?";
    WCHAR szFileFullPath[MAX_PATH+1];
    PWSTR szFileComponent;

    while ((ch = getopt(argc, argv, (WCHAR*) c_szValidOptions)) != EOF)
    {
        switch (ch)
        {
#if 0
        case 'f':
            int nChars;
            nChars = GetFullPathName(optarg, MAX_PATH,
                                     szFileFullPath, &szFileComponent);
            if (nChars)
            {
                pnaOptions->m_strAFileName = szFileFullPath;
            }
            fStatus = TRUE;
            break;
#endif
        case 'v':
        case 'V':
            g_fVerbose = TRUE;
            break;

        default:
        case 'h':
        case 'H':
        case '?':
        case 0:
            fStatus = FALSE;
            break;
        }
    }

    return fStatus;
}
#endif

//+---------------------------------------------------------------------------
//
//  Function:   ShowUsage
//
//  Purpose:    Show the cmd-line usage
//
//  Arguments:
//      (none)
//
//  Returns:
//
//  Author:     jeffspr   18 Nov 1998
//
//  Notes:
//
void ShowUsage()
{
static const WCHAR c_szUsage[] =
    L"\n"
    L"icomerge <input_file1> <input_file2> <output_file> [/v]\n"
    L"  or\n"
    L"icomerge /?\n"
    L"\n"
    L"  input_file1 and input_file2 are icon files with transparency\n"
    L"  output_file is the destination icon for the merged icons\n"
    L"\n"
    L"  /?\t  Displays this help\n";

    _tprintf(c_szUsage);
}

// ----------------------------------------------------------------------
//
// Function:  IcoMergeConsoleCrtlHandler
//
// Purpose:   Release resources on abnormal exit
//
// Arguments:
//    dwCtrlType [in]  reason of abnormal exit
//
// Returns:   FALSE --> so that netafx will be terminated
//
// Author:    kumarp 15-April-98
//
// Notes:
//
BOOL WINAPI IcoMergeConsoleCrtlHandler(IN DWORD dwCtrlType)
{
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\tools\ncbrowse\leftview.cpp ===
// LeftView.cpp : implementation of the CLeftView class
//

#include "stdafx.h"
#include "ncbrowse.h"

#include "ncbrowseDoc.h"
#include "LeftView.h"
#include "ncbrowseView.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CLeftView

IMPLEMENT_DYNCREATE(CLeftView, CTreeView)

BEGIN_MESSAGE_MAP(CLeftView, CTreeView)
    //{{AFX_MSG_MAP(CLeftView)
    ON_NOTIFY_REFLECT(TVN_SELCHANGED, OnSelchanged)
    ON_WM_CREATE()
    //}}AFX_MSG_MAP
    // Standard printing commands
    ON_COMMAND(ID_FILE_PRINT, CTreeView::OnFilePrint)
    ON_COMMAND(ID_FILE_PRINT_DIRECT, CTreeView::OnFilePrint)
    ON_COMMAND(ID_FILE_PRINT_PREVIEW, CTreeView::OnFilePrintPreview)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CLeftView construction/destruction

const DWORD dwNumIcons = 3;
CLeftView::CLeftView()
{
    // TODO: add construction code here

}

CLeftView::~CLeftView()
{
}

BOOL CLeftView::PreCreateWindow(CREATESTRUCT& cs)
{
    // TODO: Modify the Window class or styles here by modifying
    //  the CREATESTRUCT cs

    return CTreeView::PreCreateWindow(cs);
}

/////////////////////////////////////////////////////////////////////////////
// CLeftView drawing

void CLeftView::OnDraw(CDC* pDC)
{
    CNcbrowseDoc* pDoc = GetDocument();
    ASSERT_VALID(pDoc);
    
    // TODO: add draw code for native data here
}


/////////////////////////////////////////////////////////////////////////////
// CLeftView printing

BOOL CLeftView::OnPreparePrinting(CPrintInfo* pInfo)
{
    // default preparation
    return DoPreparePrinting(pInfo);
}

void CLeftView::OnBeginPrinting(CDC* /*pDC*/, CPrintInfo* /*pInfo*/)
{
    // TODO: add extra initialization before printing
}

void CLeftView::OnEndPrinting(CDC* /*pDC*/, CPrintInfo* /*pInfo*/)
{
    // TODO: add cleanup after printing
}

void CLeftView::OnInitialUpdate()
{
    CTreeView::OnInitialUpdate();
    CTreeCtrl& refTreeCtrl = GetTreeCtrl();
    
    CNcbrowseDoc* pDoc = GetDocument();
    ASSERT_VALID(pDoc);
    
    CNCSpewFile& NCSpewFile = pDoc->GetSpewFile();

    if (&NCSpewFile)
    {
        HTREEITEM hti = TVI_LAST;
        DWORD dwLevel = 0;
        for (CSpewList::const_iterator i = NCSpewFile.m_Spews.begin(); i != NCSpewFile.m_Spews.end(); i++)
        {
            dwLevel++;
            TCHAR szItemName[MAX_PATH];
            _stprintf(szItemName, _T("%s"), i->second.szSpewName.c_str());
            
            TVINSERTSTRUCT TvSpew;
            ZeroMemory(&TvSpew, sizeof(TvSpew));
            TvSpew.hParent = TVI_ROOT;
            TvSpew.hInsertAfter = hti;
            TvSpew.itemex.mask = TVIF_PARAM | TVIF_TEXT | TVIF_IMAGE | TVIF_SELECTEDIMAGE; 
            TvSpew.itemex.pszText = szItemName;
            TvSpew.itemex.cchTextMax = _tcslen(szItemName);
            TvSpew.itemex.lParam  = dwLevel;
            TvSpew.itemex.iImage  = 0;
            TvSpew.itemex.iSelectedImage = TvSpew.itemex.iImage + dwNumIcons;
            hti = refTreeCtrl.InsertItem(&TvSpew);
            
            HTREEITEM htsi = TVI_LAST;
            CNCTagMap::const_iterator iTags;
            for (iTags = i->second.m_Tags.begin(); iTags != i->second.m_Tags.end(); iTags++)
            {
                DWORD dwLineCount = iTags->second;
                TCHAR szItemName[MAX_PATH];
                _stprintf(szItemName, _T("%s (%d)"), iTags->first.c_str(), iTags->second);
                
                TVINSERTSTRUCT TvThread;
                ZeroMemory(&TvThread, sizeof(TvThread));
                TvThread.hParent = hti;
                TvThread.hInsertAfter = htsi;
                TvThread.itemex.mask = TVIF_PARAM | TVIF_TEXT | TVIF_IMAGE | TVIF_SELECTEDIMAGE; 
                TvThread.itemex.pszText = szItemName;
                TvThread.itemex.cchTextMax = _tcslen(szItemName);
                TvThread.itemex.lParam  = 0;
                TvThread.itemex.iImage  = 2;
                TvThread.itemex.iSelectedImage  = TvThread.itemex.iImage + dwNumIcons;
                htsi = refTreeCtrl.InsertItem(&TvThread);
                
                CNCThreadList::const_iterator iThread;
                for (iThread = i->second.m_NCThreadList.begin(); iThread != i->second.m_NCThreadList.end(); iThread++)
                {
                    if (iThread->second.m_Tags.find(iTags->first) != iThread->second.m_Tags.end())
                    {
                        DWORD dwLineCount = iThread->second.m_lsLines.size();
                        TCHAR szItemName[MAX_PATH];
                        _stprintf(szItemName, _T("%03x.%03x"), iThread->second.m_dwProcessId, iThread->second.m_dwThreadID);
                        
                        TVINSERTSTRUCT TvThread;
                        ZeroMemory(&TvThread, sizeof(TvThread));
                        TvThread.hParent = htsi;
                        TvThread.hInsertAfter = TVI_LAST;
                        TvThread.itemex.mask = TVIF_PARAM | TVIF_TEXT | TVIF_IMAGE | TVIF_SELECTEDIMAGE; 
                        TvThread.itemex.pszText = szItemName;
                        TvThread.itemex.cchTextMax = _tcslen(szItemName);
                        TvThread.itemex.lParam  = iThread->first;
                        TvThread.itemex.iImage  = 1;
                        TvThread.itemex.iSelectedImage  = TvThread.itemex.iImage + dwNumIcons;
                        refTreeCtrl.InsertItem(&TvThread);
                    }
                }
            }
            
            htsi = TVI_LAST;
            DWORD dwTotalLines = 0;
            CNCThreadList::const_iterator iThread;
            for (iThread = i->second.m_NCThreadList.begin(); iThread != i->second.m_NCThreadList.end(); iThread++)
            {
                DWORD dwLineCount = iThread->second.m_lsLines.size();
                dwTotalLines += dwLineCount;
                TCHAR szItemName[MAX_PATH];
                _stprintf(szItemName, _T("%03x.%03x (%d)"), iThread->second.m_dwProcessId, iThread->second.m_dwThreadID, dwLineCount);
                
                TVINSERTSTRUCT TvThread;
                ZeroMemory(&TvThread, sizeof(TvThread));
                TvThread.hParent = hti;
                TvThread.hInsertAfter = htsi;
                TvThread.itemex.mask = TVIF_PARAM | TVIF_TEXT | TVIF_IMAGE | TVIF_SELECTEDIMAGE; 
                TvThread.itemex.pszText = szItemName;
                TvThread.itemex.cchTextMax = _tcslen(szItemName);
                TvThread.itemex.lParam  = iThread->first;
                TvThread.itemex.iImage  = 1;
                TvThread.itemex.iSelectedImage  = TvThread.itemex.iImage + dwNumIcons;
                htsi = refTreeCtrl.InsertItem(&TvThread);
                
                CNCTagMap::const_iterator iTags;
                for (iTags = iThread->second.m_Tags.begin(); iTags != iThread->second.m_Tags.end(); iTags++)
                {
                    DWORD dwLineCount = iTags->second;
                    TCHAR szItemName[MAX_PATH];
                    _stprintf(szItemName, _T("%s (%d)"), iTags->first.c_str(), iTags->second);
                    
                    TVINSERTSTRUCT TvThread;
                    ZeroMemory(&TvThread, sizeof(TvThread));
                    TvThread.hParent = htsi;
                    TvThread.hInsertAfter = TVI_LAST;
                    TvThread.itemex.mask = TVIF_PARAM | TVIF_TEXT | TVIF_IMAGE | TVIF_SELECTEDIMAGE; 
                    TvThread.itemex.pszText = szItemName;
                    TvThread.itemex.cchTextMax = _tcslen(szItemName);
                    TvThread.itemex.lParam  = 0;
                    TvThread.itemex.iImage  = 2;
                    TvThread.itemex.iSelectedImage  = TvThread.itemex.iImage + dwNumIcons;
                    refTreeCtrl.InsertItem(&TvThread);
                }
            }
            

            _stprintf(szItemName, _T("%s (%d)"), i->second.szSpewName.c_str(), dwTotalLines);
            refTreeCtrl.SetItemText(hti, szItemName);

            refTreeCtrl.Expand(hti, TVE_EXPAND);
        }
    }
    // TODO: You may populate your TreeView with items by directly accessing
    //  its tree control through a call to GetTreeCtrl().
}

/////////////////////////////////////////////////////////////////////////////
// CLeftView diagnostics

#ifdef _DEBUG
void CLeftView::AssertValid() const
{
    CTreeView::AssertValid();
}

void CLeftView::Dump(CDumpContext& dc) const
{
    CTreeView::Dump(dc);
}

CNcbrowseDoc* CLeftView::GetDocument() // non-debug version is inline
{
    ASSERT(m_pDocument->IsKindOf(RUNTIME_CLASS(CNcbrowseDoc)));
    return (CNcbrowseDoc*)m_pDocument;
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CLeftView message handlers

void CLeftView::OnSelchanged(NMHDR* pNMHDR, LRESULT* pResult) 
{
    NM_TREEVIEW* pNMTreeView = (NM_TREEVIEW*)pNMHDR;
    // TODO: Add your control notification handler code here
    
    DWORD lParam = pNMTreeView->itemNew.lParam;
    LPCTSTR szFilter = NULL;
    CString ItemText;
    if (!lParam)
    {
        CTreeCtrl& refTreeCtrl = GetTreeCtrl();
        HTREEITEM hParent = refTreeCtrl.GetParentItem( pNMTreeView->itemNew.hItem);
        lParam = refTreeCtrl.GetItemData(hParent);
        ItemText = refTreeCtrl.GetItemText(pNMTreeView->itemNew.hItem);
        ItemText += _T(' ');
        DWORD dwSpace = ItemText.Find(_T(' '));
        ItemText = ItemText.Left(dwSpace);
        szFilter = ItemText;
    }
    else
    {
        CTreeCtrl& refTreeCtrl = GetTreeCtrl();
        HTREEITEM hParent = refTreeCtrl.GetParentItem( pNMTreeView->itemNew.hItem);
        if (hParent)
        {
            if (!refTreeCtrl.GetItemData(hParent))
            {
                ItemText = refTreeCtrl.GetItemText(hParent);
                ItemText += _T(' ');
                DWORD dwSpace = ItemText.Find(_T(' '));
                ItemText = ItemText.Left(dwSpace);
                szFilter = ItemText;
            }
        }
    }

    GetDocument()->m_pListView->UpdateInfo(lParam, szFilter);

     *pResult = 0;
}

int CLeftView::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
    lpCreateStruct->style |= TVS_SHOWSELALWAYS | TVS_HASLINES | TVS_LINESATROOT | TVS_HASBUTTONS;
    if (CTreeView::OnCreate(lpCreateStruct) == -1)
        return -1;
    
    // Give the document a pointer to this view
    GetDocument()->m_pTreeView = this;
    
    
    CImageList *MyImageList = new CImageList;
    MyImageList->Create(16, 16, ILC_COLOR32, 0, 4);
    MyImageList->Add(AfxGetApp()->LoadIcon(IDI_SPEW));
    MyImageList->Add(AfxGetApp()->LoadIcon(IDI_THREAD));
    MyImageList->Add(AfxGetApp()->LoadIcon(IDI_FILTER));
        
    MyImageList->Add(AfxGetApp()->LoadIcon(IDI_SPEW_SEL));
    MyImageList->Add(AfxGetApp()->LoadIcon(IDI_THREAD_SEL));
    MyImageList->Add(AfxGetApp()->LoadIcon(IDI_FILTER_SEL));

    CTreeCtrl& refTreeCtrl = GetTreeCtrl();
    refTreeCtrl.SetImageList(MyImageList, TVSIL_NORMAL);
    refTreeCtrl.SetImageList(MyImageList, TVSIL_STATE);
    
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\tools\ncbrowse\childfrm.h ===
// ChildFrm.h : interface of the CChildFrame class
//
/////////////////////////////////////////////////////////////////////////////

#if !defined(AFX_CHILDFRM_H__47783F71_48FC_40B7_94DC_B11386CF7100__INCLUDED_)
#define AFX_CHILDFRM_H__47783F71_48FC_40B7_94DC_B11386CF7100__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

class CNcbrowseView;
class CNCEditView;

class CChildFrame : public CMDIChildWnd
{
	DECLARE_DYNCREATE(CChildFrame)
public:
	CChildFrame();

// Attributes
protected:
    CSplitterWnd m_wndSplitterTB;
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CChildFrame)
	public:
	virtual BOOL OnCreateClient(LPCREATESTRUCT lpcs, CCreateContext* pContext);
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CChildFrame();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:
	CNcbrowseView* GetRightPane();
    CNCEditView* GetLowerPane();
// Generated message map functions
protected:
	//{{AFX_MSG(CChildFrame)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG
	afx_msg void OnUpdateViewStyles(CCmdUI* pCmdUI);
	afx_msg void OnViewStyle(UINT nCommandID);
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_CHILDFRM_H__47783F71_48FC_40B7_94DC_B11386CF7100__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\tools\ncbrowse\childfrm.cpp ===
// ChildFrm.cpp : implementation of the CChildFrame class
//

#include "stdafx.h"
#include "ncbrowse.h"

#include "ChildFrm.h"
#include "LeftView.h"
#include "NCEditView.h"
#include "ncbrowseView.h"
#include <afxext.h>
#include "SplitterView.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CChildFrame

IMPLEMENT_DYNCREATE(CChildFrame, CMDIChildWnd)

BEGIN_MESSAGE_MAP(CChildFrame, CMDIChildWnd)
	//{{AFX_MSG_MAP(CChildFrame)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG_MAP
	ON_UPDATE_COMMAND_UI_RANGE(AFX_ID_VIEW_MINIMUM, AFX_ID_VIEW_MAXIMUM, OnUpdateViewStyles)
	ON_COMMAND_RANGE(AFX_ID_VIEW_MINIMUM, AFX_ID_VIEW_MAXIMUM, OnViewStyle)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CChildFrame construction/destruction

CChildFrame::CChildFrame()
{
	// TODO: add member initialization code here
	
}

CChildFrame::~CChildFrame()
{
}

BOOL CChildFrame::OnCreateClient( LPCREATESTRUCT /*lpcs*/,
	CCreateContext* pContext)
{
    // create splitter window
    if (!m_wndSplitterTB.CreateStatic(this, 2, 1))
        return FALSE;

    if (!m_wndSplitterTB.CreateView(0, 0, RUNTIME_CLASS(CSplitterView), CSize(500, 250), pContext) ||
        !m_wndSplitterTB.CreateView(1, 0, RUNTIME_CLASS(CNCEditView), CSize(200, 250), pContext) )
    {
        m_wndSplitterTB.DestroyWindow();
        return FALSE;
    }
    
	return TRUE;
}

BOOL CChildFrame::PreCreateWindow(CREATESTRUCT& cs)
{
	// TODO: Modify the Window class or styles here by modifying
	//  the CREATESTRUCT cs

	if( !CMDIChildWnd::PreCreateWindow(cs) )
		return FALSE;

	return TRUE;
}



/////////////////////////////////////////////////////////////////////////////
// CChildFrame diagnostics

#ifdef _DEBUG
void CChildFrame::AssertValid() const
{
	CMDIChildWnd::AssertValid();
}

void CChildFrame::Dump(CDumpContext& dc) const
{
	CMDIChildWnd::Dump(dc);
}

#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CChildFrame message handlers
CNcbrowseView* CChildFrame::GetRightPane()
{
    CWnd* pWnd = m_wndSplitterTB.GetPane(0, 0);
    CSplitterView* pSplitterView = DYNAMIC_DOWNCAST(CSplitterView, pWnd);

    CWnd* pWndSplitter = pSplitterView->m_wndSplitterLR.GetPane(0, 1);
    CNcbrowseView* pView = DYNAMIC_DOWNCAST(CNcbrowseView, pWndSplitter);

    return pView;
}

CNCEditView* CChildFrame::GetLowerPane()
{
    CWnd* pWnd = m_wndSplitterTB.GetPane(1, 0);
    CNCEditView* pView = DYNAMIC_DOWNCAST(CNCEditView, pWnd);
    return pView;
}

void CChildFrame::OnUpdateViewStyles(CCmdUI* pCmdUI)
{
	// TODO: customize or extend this code to handle choices on the
	// View menu.

	CNcbrowseView* pView = GetRightPane(); 

	// if the right-hand pane hasn't been created or isn't a view,
	// disable commands in our range

	if (pView == NULL)
		pCmdUI->Enable(FALSE);
	else
	{
		DWORD dwStyle = pView->GetStyle() & LVS_TYPEMASK;

		// if the command is ID_VIEW_LINEUP, only enable command
		// when we're in LVS_ICON or LVS_SMALLICON mode

		if (pCmdUI->m_nID == ID_VIEW_LINEUP)
		{
			if (dwStyle == LVS_ICON || dwStyle == LVS_SMALLICON)
				pCmdUI->Enable();
			else
				pCmdUI->Enable(FALSE);
		}
		else
		{
			// otherwise, use dots to reflect the style of the view
			pCmdUI->Enable();
			BOOL bChecked = FALSE;

			switch (pCmdUI->m_nID)
			{
			case ID_VIEW_DETAILS:
				bChecked = (dwStyle == LVS_REPORT);
				break;

			case ID_VIEW_SMALLICON:
				bChecked = (dwStyle == LVS_SMALLICON);
				break;

			case ID_VIEW_LARGEICON:
				bChecked = (dwStyle == LVS_ICON);
				break;

			case ID_VIEW_LIST:
				bChecked = (dwStyle == LVS_LIST);
				break;

			default:
				bChecked = FALSE;
				break;
			}

			pCmdUI->SetRadio(bChecked ? 1 : 0);
		}
	}
}


void CChildFrame::OnViewStyle(UINT nCommandID)
{
	// TODO: customize or extend this code to handle choices on the
	// View menu.
	CNcbrowseView* pView = GetRightPane();

	// if the right-hand pane has been created and is a CNcbrowseView,
	// process the menu commands...
	if (pView != NULL)
	{
		DWORD dwStyle = -1;

		switch (nCommandID)
		{
		case ID_VIEW_LINEUP:
			{
				// ask the list control to snap to grid
				CListCtrl& refListCtrl = pView->GetListCtrl();
				refListCtrl.Arrange(LVA_SNAPTOGRID);
			}
			break;

		// other commands change the style on the list control
		case ID_VIEW_DETAILS:
			dwStyle = LVS_REPORT;
			break;

		case ID_VIEW_SMALLICON:
			dwStyle = LVS_SMALLICON;
			break;

		case ID_VIEW_LARGEICON:
			dwStyle = LVS_ICON;
			break;

		case ID_VIEW_LIST:
			dwStyle = LVS_LIST;
			break;
		}

		// change the style; window will repaint automatically
		if (dwStyle != -1)
			pView->ModifyStyle(LVS_TYPEMASK, dwStyle);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\tools\ncbrowse\leftview.h ===
// LeftView.h : interface of the CLeftView class
//
/////////////////////////////////////////////////////////////////////////////

#if !defined(AFX_LEFTVIEW_H__DBCC210E_E89D_4DC3_A848_899355925C06__INCLUDED_)
#define AFX_LEFTVIEW_H__DBCC210E_E89D_4DC3_A848_899355925C06__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

class CNcbrowseDoc;

class CLeftView : public CTreeView
{
protected: // create from serialization only
	CLeftView();
	DECLARE_DYNCREATE(CLeftView)

// Attributes
public:
	CNcbrowseDoc* GetDocument();

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CLeftView)
	public:
	virtual void OnDraw(CDC* pDC);  // overridden to draw this view
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
	protected:
	virtual BOOL OnPreparePrinting(CPrintInfo* pInfo);
	virtual void OnBeginPrinting(CDC* pDC, CPrintInfo* pInfo);
	virtual void OnEndPrinting(CDC* pDC, CPrintInfo* pInfo);
	virtual void OnInitialUpdate(); // called first time after construct
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CLeftView();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:

// Generated message map functions
protected:
	//{{AFX_MSG(CLeftView)
	afx_msg void OnSelchanged(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

#ifndef _DEBUG  // debug version in LeftView.cpp
inline CNcbrowseDoc* CLeftView::GetDocument()
   { return (CNcbrowseDoc*)m_pDocument; }
#endif

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_LEFTVIEW_H__DBCC210E_E89D_4DC3_A848_899355925C06__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\tools\ncbrowse\ncbrowse.h ===
// ncbrowse.h : main header file for the NCBROWSE application
//

#if !defined(AFX_NCBROWSE_H__085B372E_9C97_4978_90B8_D5D463EBEC4C__INCLUDED_)
#define AFX_NCBROWSE_H__085B372E_9C97_4978_90B8_D5D463EBEC4C__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CNcbrowseApp:
// See ncbrowse.cpp for the implementation of this class
//

class CNcbrowseApp : public CWinApp
{
public:
	CNcbrowseApp();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CNcbrowseApp)
	public:
	virtual BOOL InitInstance();
	//}}AFX_VIRTUAL

// Implementation
	//{{AFX_MSG(CNcbrowseApp)
	afx_msg void OnAppAbout();
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_NCBROWSE_H__085B372E_9C97_4978_90B8_D5D463EBEC4C__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\tools\ncbrowse\ncbrowsedoc.cpp ===
// ncbrowseDoc.cpp : implementation of the CNcbrowseDoc class
//

#include "stdafx.h"
#include "ncbrowse.h"

#include "ncbrowseDoc.h"
#include "nceditview.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CNcbrowseDoc

IMPLEMENT_DYNCREATE(CNcbrowseDoc, CDocument)

BEGIN_MESSAGE_MAP(CNcbrowseDoc, CDocument)
	//{{AFX_MSG_MAP(CNcbrowseDoc)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CNcbrowseDoc construction/destruction

CNcbrowseDoc::CNcbrowseDoc()
{
	// TODO: add one-time construction code here
    m_pNCSpewFile = NULL;
}

CNcbrowseDoc::~CNcbrowseDoc()
{
}

CNCSpewFile &CNcbrowseDoc::GetSpewFile()
{
    return *m_pNCSpewFile;
}

BOOL CNcbrowseDoc::OnNewDocument()
{
	if (!CDocument::OnNewDocument())
		return FALSE;

	// TODO: add reinitialization code here
	// (SDI documents will reuse this document)

	return FALSE;
}



/////////////////////////////////////////////////////////////////////////////
// CNcbrowseDoc serialization

void CNcbrowseDoc::Serialize(CArchive& ar)
{
	if (ar.IsStoring())
	{
		// TODO: add storing code here
        ASSERT(FALSE);
	}
	else
	{
        m_pNCSpewFile = new CNCSpewFile(ar);
        // TODO: add loading code here
        ar.GetFile()->SeekToBegin();

        POSITION p = m_viewList.GetHeadPosition();
        CView *pView;
        while (p)
        {
            pView = (CView*)m_viewList.GetNext(p);

            if (pView->IsKindOf(RUNTIME_CLASS(CEditView)))
            {
                if (ar.GetFile()->GetLength() <= CEditView::nMaxSize)
                {
                    ((CNCEditView *)pView)->SerializeRaw(ar);
                }   
                else
                {
                    ((CNCEditView *)pView)->GetEditCtrl().Clear();
                    ((CNCEditView *)pView)->GetEditCtrl().SetSel(-1);
                    ((CNCEditView *)pView)->GetEditCtrl().ReplaceSel(_T("File is too large for this puny little MFC CEditView"));
                }
            }
        }
    }
}

/////////////////////////////////////////////////////////////////////////////
// CNcbrowseDoc diagnostics

#ifdef _DEBUG
void CNcbrowseDoc::AssertValid() const
{
	CDocument::AssertValid();
}

void CNcbrowseDoc::Dump(CDumpContext& dc) const
{
	CDocument::Dump(dc);
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CNcbrowseDoc commands

void CNcbrowseDoc::OnCloseDocument() 
{
	// TODO: Add your specialized code here and/or call the base class
	delete m_pNCSpewFile;
	CDocument::OnCloseDocument();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\tools\ncbrowse\ncbrowsedoc.h ===
// ncbrowseDoc.h : interface of the CNcbrowseDoc class
//
/////////////////////////////////////////////////////////////////////////////

#if !defined(AFX_NCBROWSEDOC_H__1E78AE56_354D_4B11_AF48_A3D07DA3AC47__INCLUDED_)
#define AFX_NCBROWSEDOC_H__1E78AE56_354D_4B11_AF48_A3D07DA3AC47__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

using namespace std;
#include "ncspewfile.h"

class CLeftView;
class CNcbrowseView;
class CNCEditView;

class CNcbrowseDoc : public CDocument
{
protected: // create from serialization only
	CNcbrowseDoc();
	DECLARE_DYNCREATE(CNcbrowseDoc)

// Attributes
public:
    CNCSpewFile *m_pNCSpewFile;
    CLeftView* m_pTreeView;
    CNcbrowseView* m_pListView;
    CNCEditView *m_pEditView;
// Operations
public:

    CNCSpewFile &GetSpewFile();
// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CNcbrowseDoc)
	public:
	virtual BOOL OnNewDocument();
	virtual void Serialize(CArchive& ar);
	virtual void OnCloseDocument();
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CNcbrowseDoc();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:

// Generated message map functions
protected:
	//{{AFX_MSG(CNcbrowseDoc)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_NCBROWSEDOC_H__1E78AE56_354D_4B11_AF48_A3D07DA3AC47__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\tools\ncbrowse\ncbrowseview.cpp ===
// ncbrowseView.cpp : implementation of the CNcbrowseView class
//

#include "stdafx.h"
#include "ncbrowse.h"

#include "ncbrowseDoc.h"
#include "ncbrowseView.h"
#include "LeftView.h"
#include "NCEditView.h"
#include <commctrl.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CNcbrowseView

IMPLEMENT_DYNCREATE(CNcbrowseView, CListView)

BEGIN_MESSAGE_MAP(CNcbrowseView, CListView)
	//{{AFX_MSG_MAP(CNcbrowseView)
	ON_WM_CREATE()
	ON_NOTIFY_REFLECT(LVN_ITEMCHANGED, OnItemchanged)
	ON_WM_KEYUP()
	//}}AFX_MSG_MAP
	// Standard printing commands
	ON_COMMAND(ID_FILE_PRINT, CListView::OnFilePrint)
	ON_COMMAND(ID_FILE_PRINT_DIRECT, CListView::OnFilePrint)
	ON_COMMAND(ID_FILE_PRINT_PREVIEW, CListView::OnFilePrintPreview)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CNcbrowseView construction/destruction

CNcbrowseView::CNcbrowseView()
{
	// TODO: add construction code here
    dwCurrentItems = 0;
}

CNcbrowseView::~CNcbrowseView()
{
}

BOOL CNcbrowseView::PreCreateWindow(CREATESTRUCT& cs)
{
	// TODO: Modify the Window class or styles here by modifying
	//  the CREATESTRUCT cs

	return CListView::PreCreateWindow(cs);
}

/////////////////////////////////////////////////////////////////////////////
// CNcbrowseView drawing

void CNcbrowseView::OnDraw(CDC* pDC)
{
 	// TODO: add draw code for native data here
}

void CNcbrowseView::OnInitialUpdate()
{
	CListView::OnInitialUpdate();

	// TODO: You may populate your ListView with items by directly accessing
	//  its list control through a call to GetListCtrl().
}

/////////////////////////////////////////////////////////////////////////////
// CNcbrowseView printing

BOOL CNcbrowseView::OnPreparePrinting(CPrintInfo* pInfo)
{
	// default preparation
	return DoPreparePrinting(pInfo);
}

void CNcbrowseView::OnBeginPrinting(CDC* /*pDC*/, CPrintInfo* /*pInfo*/)
{
	// TODO: add extra initialization before printing
}

void CNcbrowseView::OnEndPrinting(CDC* /*pDC*/, CPrintInfo* /*pInfo*/)
{
	// TODO: add cleanup after printing
}

/////////////////////////////////////////////////////////////////////////////
// CNcbrowseView diagnostics

#ifdef _DEBUG
void CNcbrowseView::AssertValid() const
{
	CListView::AssertValid();
}

void CNcbrowseView::Dump(CDumpContext& dc) const
{
	CListView::Dump(dc);
}

CNcbrowseDoc* CNcbrowseView::GetDocument() // non-debug version is inline
{
	ASSERT(m_pDocument->IsKindOf(RUNTIME_CLASS(CNcbrowseDoc)));
	return (CNcbrowseDoc*)m_pDocument;
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CNcbrowseView message handlers
void CNcbrowseView::OnStyleChanged(int nStyleType, LPSTYLESTRUCT lpStyleStruct)
{
	//TODO: add code to react to the user changing the view style of your window
}

int CNcbrowseView::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
	if (CListView::OnCreate(lpCreateStruct) == -1)
		return -1;
	
    // Give the document a pointer to this view
    GetDocument()->m_pListView = this;
    
    CImageList *MyImageList = new CImageList;
    MyImageList->Create(32,32, ILC_COLOR8, 0, 4);
    MyImageList->Add(AfxGetApp()->LoadIcon(IDI_LINE));

    CImageList *MyImageList2 = new CImageList;
    MyImageList2->Create(16, 16, ILC_COLOR8, 0, 4);
    MyImageList2->Add(AfxGetApp()->LoadIcon(IDI_LINE));

    CListCtrl& refListCtrl = GetListCtrl();
    refListCtrl.SetImageList(MyImageList, LVSIL_NORMAL);
    refListCtrl.SetImageList(MyImageList2, LVSIL_SMALL);

    refListCtrl.ModifyStyle(LVS_TYPEMASK, LVS_REPORT | LVS_SHOWSELALWAYS);

    refListCtrl.SetExtendedStyle
        (refListCtrl.GetExtendedStyle()|LVS_EX_FULLROWSELECT );
    
        
    HWND hwndListCtrl = refListCtrl.GetSafeHwnd();
    HFONT hFont;
    hFont = (HFONT)GetStockObject(SYSTEM_FIXED_FONT);
    refListCtrl.SendMessage(WM_SETFONT, (WPARAM)hFont, FALSE);
    
    refListCtrl.InsertColumn(0, _T("Line#"));
    refListCtrl.InsertColumn(1, _T("Proc.Thrd"));
    refListCtrl.InsertColumn(2, _T("Tag"));
    refListCtrl.InsertColumn(3, _T("Description"));
    
    refListCtrl.SetColumnWidth( 0, 75);
    refListCtrl.SetColumnWidth( 1, 90);
    refListCtrl.SetColumnWidth( 2, 150);
    refListCtrl.SetColumnWidth( 3, 2000);
    
    m_dwOldThreadColWidth = 90;
    m_dwOldTagColWidth    = 150;
    return 0;
}

void CNcbrowseView::UpdateInfo(DWORD dwProcThread, LPCTSTR pszFilter)
{
    CNcbrowseDoc* pDoc = GetDocument();
    ASSERT_VALID(pDoc);
    
    CListCtrl& refListCtrl = GetListCtrl();
    
    CNCSpewFile& NCSpewFile = pDoc->GetSpewFile();

    if (dwProcThread)
    {
        const CNCEntryList *pEntryList = NULL;

        DWORD dwNewThreadColWidth = 0;
        DWORD dwNewTagColWidth = 0;

        refListCtrl.SetRedraw(FALSE);
        if (dwProcThread & 0xffff0000)
        {
            for (CSpewList::const_iterator i = NCSpewFile.m_Spews.begin(); i != NCSpewFile.m_Spews.end(); i++)
            {
                CNCThreadList::const_iterator pThread = i->second.m_NCThreadList.find(dwProcThread);
                if (pThread != i->second.m_NCThreadList.end())
                {
                    pEntryList = &(pThread->second.m_lsLines);
                    break;
                }
            }
            DWORD dwThreadColWidth = refListCtrl.GetColumnWidth( 1 );
            if (dwThreadColWidth)
            {
                m_dwOldThreadColWidth = dwThreadColWidth;
            }
            dwNewThreadColWidth = 0;
        }
        else
        {
            pEntryList = &(NCSpewFile.m_Spews[dwProcThread].m_lsLines);
            dwNewThreadColWidth = m_dwOldThreadColWidth;
        }
        
        if (pszFilter)
        {
            DWORD dwTagColWidth = refListCtrl.GetColumnWidth( 2 );
            if (dwTagColWidth)
            {
                m_dwOldTagColWidth = dwTagColWidth;
            }
            dwNewTagColWidth = 0;
        }        
        else
        {
            dwNewTagColWidth    = m_dwOldTagColWidth;
        }            
        
        if (pEntryList)
        {
            HCURSOR hPrevCursor;
            if ( (pEntryList->size() > 100) || (dwCurrentItems > 100) )
            {
                hPrevCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));
            }

            refListCtrl.DeleteAllItems();
            CNCEntryList::const_iterator iLines;
            for (iLines = pEntryList->begin(); iLines != pEntryList->end(); iLines++)
            {
                if ( (!pszFilter) || (!_tcscmp(pszFilter, iLines->m_szTag.c_str())) )
                {
                    TCHAR szItemName[8192];
                    _stprintf(szItemName, _T("%d"), iLines->m_dwLineNumber);
                    
                    LVITEM LvItem;
                    ZeroMemory(&LvItem, sizeof(LVITEM));
                    LvItem.mask = LVIF_TEXT | LVIF_INDENT | LVIF_IMAGE | LVIF_PARAM;
                    LvItem.pszText = szItemName;
                    LvItem.iSubItem = 0;
                    LvItem.iItem    = iLines->m_dwLineNumber;
                    LvItem.iIndent  = iLines->m_dwLevel;
                    LvItem.iImage   = 0;
                    LvItem.lParam = iLines->m_dwLineNumber;
                    
                    DWORD dwItem = refListCtrl.InsertItem(&LvItem);
                    
                    _stprintf(szItemName, _T("%03x.%03x"), iLines->m_dwProcessId, iLines->m_dwThreadId);
                    ZeroMemory(&LvItem, sizeof(LVITEM));
                    LvItem.mask = LVIF_TEXT;
                    LvItem.pszText = szItemName;
                    LvItem.iItem    = dwItem;
                    LvItem.iSubItem = 1;
                    refListCtrl.SetItem(&LvItem);
                    
                    _stprintf(szItemName, _T("%s"), iLines->m_szTag.c_str());
                    ZeroMemory(&LvItem, sizeof(LVITEM));
                    LvItem.mask = LVIF_TEXT;
                    LvItem.pszText = szItemName;
                    LvItem.iItem    = dwItem;
                    LvItem.iSubItem = 2;
                    refListCtrl.SetItem(&LvItem);
                    
                    _stprintf(szItemName, _T("%s"), iLines->m_szDescription.c_str());
                    ZeroMemory(&LvItem, sizeof(LVITEM));
                    LvItem.mask = LVIF_TEXT;
                    LvItem.pszText = szItemName;
                    LvItem.iItem    = dwItem;
                    LvItem.iSubItem = 3;
                    refListCtrl.SetItem(&LvItem);
                }
            }

            if ( (pEntryList->size() > 100) || (dwCurrentItems > 100) )
            {
                SetCursor(hPrevCursor);
            }

            dwCurrentItems = pEntryList->size();

        }
        refListCtrl.SetRedraw(TRUE);
        refListCtrl.SetColumnWidth( 1, dwNewThreadColWidth);
        refListCtrl.SetColumnWidth( 2, dwNewTagColWidth);
    }

    return;
}

void CNcbrowseView::OnItemchanged(NMHDR* pNMHDR, LRESULT* pResult) 
{
	NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;
	// TODO: Add your control notification handler code here

    CListCtrl& refListCtrl = GetListCtrl();
    
    DWORD dwLineNum = refListCtrl.GetItemData(pNMListView->iItem);
    GetDocument()->m_pEditView->ScrollToLine(dwLineNum);

	*pResult = 0;
}

void CNcbrowseView::OnKeyUp(UINT nChar, UINT nRepCnt, UINT nFlags) 
{
	// TODO: Add your message handler code here and/or call default
	
	CListView::OnKeyUp(nChar, nRepCnt, nFlags);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\tools\ncbrowse\mainfrm.cpp ===
// MainFrm.cpp : implementation of the CMainFrame class
//

#include "stdafx.h"
#include "ncbrowse.h"

#include "MainFrm.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CMainFrame

IMPLEMENT_DYNAMIC(CMainFrame, CMDIFrameWnd)

BEGIN_MESSAGE_MAP(CMainFrame, CMDIFrameWnd)
	//{{AFX_MSG_MAP(CMainFrame)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	ON_WM_CREATE()
	//}}AFX_MSG_MAP
	// Global help commands
	ON_COMMAND(ID_HELP_FINDER, CMDIFrameWnd::OnHelpFinder)
	ON_COMMAND(ID_HELP, CMDIFrameWnd::OnHelp)
	ON_COMMAND(ID_CONTEXT_HELP, CMDIFrameWnd::OnContextHelp)
	ON_COMMAND(ID_DEFAULT_HELP, CMDIFrameWnd::OnHelpFinder)
END_MESSAGE_MAP()

static UINT indicators[] =
{
	ID_SEPARATOR,           // status line indicator
	ID_INDICATOR_CAPS,
	ID_INDICATOR_NUM,
	ID_INDICATOR_SCRL,
};

/////////////////////////////////////////////////////////////////////////////
// CMainFrame construction/destruction

CMainFrame::CMainFrame()
{
	// TODO: add member initialization code here
	
}

CMainFrame::~CMainFrame()
{
}

int CMainFrame::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	if (CMDIFrameWnd::OnCreate(lpCreateStruct) == -1)
		return -1;
	
	if (!m_wndToolBar.CreateEx(this) ||
		!m_wndToolBar.LoadToolBar(IDR_MAINFRAME))
	{
		TRACE0("Failed to create toolbar\n");
		return -1;      // fail to create
	}
	if (!m_wndDlgBar.Create(this, IDR_MAINFRAME, 
		CBRS_ALIGN_TOP, AFX_IDW_DIALOGBAR))
	{
		TRACE0("Failed to create dialogbar\n");
		return -1;		// fail to create
	}

	if (!m_wndReBar.Create(this) ||
		!m_wndReBar.AddBar(&m_wndToolBar) ||
		!m_wndReBar.AddBar(&m_wndDlgBar))
	{
		TRACE0("Failed to create rebar\n");
		return -1;      // fail to create
	}

	if (!m_wndStatusBar.Create(this) ||
		!m_wndStatusBar.SetIndicators(indicators,
		  sizeof(indicators)/sizeof(UINT)))
	{
		TRACE0("Failed to create status bar\n");
		return -1;      // fail to create
	}

	// TODO: Remove this if you don't want tool tips
	m_wndToolBar.SetBarStyle(m_wndToolBar.GetBarStyle() |
		CBRS_TOOLTIPS | CBRS_FLYBY);

	return 0;
}

BOOL CMainFrame::PreCreateWindow(CREATESTRUCT& cs)
{
	if( !CMDIFrameWnd::PreCreateWindow(cs) )
		return FALSE;
	// TODO: Modify the Window class or styles here by modifying
	//  the CREATESTRUCT cs

	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CMainFrame diagnostics

#ifdef _DEBUG
void CMainFrame::AssertValid() const
{
	CMDIFrameWnd::AssertValid();
}

void CMainFrame::Dump(CDumpContext& dc) const
{
	CMDIFrameWnd::Dump(dc);
}

#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CMainFrame message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\tools\ncbrowse\mainfrm.h ===
// MainFrm.h : interface of the CMainFrame class
//
/////////////////////////////////////////////////////////////////////////////

#if !defined(AFX_MAINFRM_H__C83E36A4_372B_403B_804E_99881418E51E__INCLUDED_)
#define AFX_MAINFRM_H__C83E36A4_372B_403B_804E_99881418E51E__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

class CMainFrame : public CMDIFrameWnd
{
	DECLARE_DYNAMIC(CMainFrame)
public:
	CMainFrame();

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CMainFrame)
	public:
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CMainFrame();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

public:
    CStatusBar  m_wndStatusBar;

protected:  // control bar embedded members
	CToolBar    m_wndToolBar;
	CReBar      m_wndReBar;
	CDialogBar      m_wndDlgBar;

// Generated message map functions
protected:
	//{{AFX_MSG(CMainFrame)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_MAINFRM_H__C83E36A4_372B_403B_804E_99881418E51E__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\tools\ncbrowse\ncbrowse.cpp ===
// ncbrowse.cpp : Defines the class behaviors for the application.
//

#include "stdafx.h"
#include "ncbrowse.h"

#include "MainFrm.h"
#include "ChildFrm.h"
#include "ncbrowseDoc.h"
#include "LeftView.h"
#include "SplitterView.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CNcbrowseApp

BEGIN_MESSAGE_MAP(CNcbrowseApp, CWinApp)
	//{{AFX_MSG_MAP(CNcbrowseApp)
	ON_COMMAND(ID_APP_ABOUT, OnAppAbout)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG_MAP
	// Standard file based document commands
    ON_COMMAND(ID_FILE_NEW, CWinApp::OnFileNew)
    ON_COMMAND(ID_FILE_OPEN, CWinApp::OnFileOpen)
	// Standard print setup command
	ON_COMMAND(ID_FILE_PRINT_SETUP, CWinApp::OnFilePrintSetup)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CNcbrowseApp construction

CNcbrowseApp::CNcbrowseApp()
{
	// TODO: add construction code here,
	// Place all significant initialization in InitInstance
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CNcbrowseApp object

CNcbrowseApp theApp;

/////////////////////////////////////////////////////////////////////////////
// CNcbrowseApp initialization

class CNCMultiDocTemplate : public CMultiDocTemplate
{
public:
    CNCMultiDocTemplate(UINT nIDResource, CRuntimeClass* pDocClass, CRuntimeClass* pFrameClass, CRuntimeClass* pViewClass) :
        CMultiDocTemplate(nIDResource, pDocClass, pFrameClass, pViewClass) {}

    BOOL GetDocString(CString& rString,enum DocStringIndex i) const
    {
        CString strTemp,strLeft,strRight;
        int nFindPos;
        AfxExtractSubString(strTemp, m_strDocStrings, (int)i);
        
        if(i == CDocTemplate::filterExt)  {
            nFindPos=strTemp.Find(';');
            if(-1 != nFindPos) {
                //string contains two extensions
                strLeft=strTemp.Left(nFindPos+1);
                strRight="*"+strTemp.Right(lstrlen((LPCTSTR)strTemp)-nFindPos-1);
                strTemp=strLeft+strRight;
            }
        }
        rString = strTemp;
        return TRUE;
    } 

    CDocTemplate::Confidence MatchDocType(const char* pszPathName, CDocument*& rpDocMatch)
    {
        ASSERT(pszPathName != NULL);
        rpDocMatch = NULL;
        
        // go through all documents
        POSITION pos = GetFirstDocPosition();
        while (pos != NULL)
        {
            CDocument* pDoc = GetNextDoc(pos);
            if (pDoc->GetPathName() == pszPathName) {
                // already open
                rpDocMatch = pDoc;
                return yesAlreadyOpen;
            }
        }  // end while
        
        // see if it matches either suffix
        CString strFilterExt;
        if (GetDocString(strFilterExt, CDocTemplate::filterExt) &&
            !strFilterExt.IsEmpty())
        {
            // see if extension matches
            ASSERT(strFilterExt[0] == '.');
            CString ext1,ext2;
            int nDot = CString(pszPathName).ReverseFind('.');
            const char* pszDot = nDot < 0 ? NULL : pszPathName + nDot;
            
            int nSemi = strFilterExt.Find(';');
            if(-1 != nSemi)   {
                // string contains two extensions
                ext1=strFilterExt.Left(nSemi);
                ext2=strFilterExt.Mid(nSemi+2);
                // check for a match against either extension
                if (nDot >= 0 && (lstrcmpi((LPCTSTR)pszPathName+nDot, ext1) == 0
                    || lstrcmpi((LPCTSTR)pszPathName+nDot,ext2) ==0))
                    return yesAttemptNative; // extension matches
            }
            else
            { // string contains a single extension
                if (nDot >= 0 && (lstrcmpi((LPCTSTR)pszPathName+nDot,
                    strFilterExt)==0))
                    return yesAttemptNative;  // extension matches
            }
        }
        return yesAttemptForeign; //unknown document type
    } 
};

BOOL CNcbrowseApp::InitInstance()
{
	AfxEnableControlContainer();

	// Standard initialization
	// If you are not using these features and wish to reduce the size
	//  of your final executable, you should remove from the following
	//  the specific initialization routines you do not need.

#ifdef _AFXDLL
	Enable3dControls();			// Call this when using MFC in a shared DLL
#else
	Enable3dControlsStatic();	// Call this when linking to MFC statically
#endif

	// Change the registry key under which our settings are stored.
	// TODO: You should modify this string to be something appropriate
	// such as the name of your company or organization.
	SetRegistryKey(_T("Local AppWizard-Generated Applications"));

	LoadStdProfileSettings(6);  // Load standard INI file options (including MRU)

	// Register the application's document templates.  Document templates
	//  serve as the connection between documents, frame windows and views.

	CMultiDocTemplate* pDocTemplate;
	pDocTemplate = new CMultiDocTemplate(
		IDR_NCSPEWTYPE,
		RUNTIME_CLASS(CNcbrowseDoc),
		RUNTIME_CLASS(CChildFrame), // custom MDI child frame
		RUNTIME_CLASS(CSplitterView));
	AddDocTemplate(pDocTemplate);

	// create main MDI Frame window
	CMainFrame* pMainFrame = new CMainFrame;
	if (!pMainFrame->LoadFrame(IDR_MAINFRAME))
    {
        ASSERT("Could not load main frame");
		return FALSE;
    }
	m_pMainWnd = pMainFrame;

	// Enable drag/drop open
	m_pMainWnd->DragAcceptFiles();

	// Enable DDE Execute open
	EnableShellOpen();
	RegisterShellFileTypes(TRUE);

	// Parse command line for standard shell commands, DDE, file open
	CCommandLineInfo cmdInfo;
	ParseCommandLine(cmdInfo);

	// Dispatch commands specified on the command line
	if (!ProcessShellCommand(cmdInfo))
		return FALSE;

	// The main window has been initialized, so show and update it.
	pMainFrame->ShowWindow(m_nCmdShow);
	pMainFrame->UpdateWindow();

	return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
// CAboutDlg dialog used for App About

class CAboutDlg : public CDialog
{
public:
	CAboutDlg();

// Dialog Data
	//{{AFX_DATA(CAboutDlg)
	enum { IDD = IDD_ABOUTBOX };
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAboutDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	//{{AFX_MSG(CAboutDlg)
		// No message handlers
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

CAboutDlg::CAboutDlg() : CDialog(CAboutDlg::IDD)
{
	//{{AFX_DATA_INIT(CAboutDlg)
	//}}AFX_DATA_INIT
}

void CAboutDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAboutDlg)
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CAboutDlg, CDialog)
	//{{AFX_MSG_MAP(CAboutDlg)
		// No message handlers
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

// App command to run the dialog
void CNcbrowseApp::OnAppAbout()
{
	CAboutDlg aboutDlg;
	aboutDlg.DoModal();
}

/////////////////////////////////////////////////////////////////////////////
// CNcbrowseApp message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\tools\ncbrowse\ncbrowseview.h ===
// ncbrowseView.h : interface of the CNcbrowseView class
//
/////////////////////////////////////////////////////////////////////////////

#if !defined(AFX_NCBROWSEVIEW_H__CE6A4E4A_2AB4_4140_8879_7EF2DE7163F9__INCLUDED_)
#define AFX_NCBROWSEVIEW_H__CE6A4E4A_2AB4_4140_8879_7EF2DE7163F9__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000


class CNcbrowseView : public CListView
{
protected: // create from serialization only
	CNcbrowseView();
	DECLARE_DYNCREATE(CNcbrowseView)

// Attributes
public:
	CNcbrowseDoc* GetDocument();
    DWORD dwCurrentItems;
    DWORD m_dwOldThreadColWidth;
    DWORD m_dwOldTagColWidth;
// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CNcbrowseView)
	public:
	virtual void OnDraw(CDC* pDC);  // overridden to draw this view
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
	protected:
	virtual void OnInitialUpdate(); // called first time after construct
	virtual BOOL OnPreparePrinting(CPrintInfo* pInfo);
	virtual void OnBeginPrinting(CDC* pDC, CPrintInfo* pInfo);
	virtual void OnEndPrinting(CDC* pDC, CPrintInfo* pInfo);
	//}}AFX_VIRTUAL

// Implementation
public:
	void UpdateInfo(DWORD dwProcThread, LPCTSTR pszFilter);
	virtual ~CNcbrowseView();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:

// Generated message map functions
protected:
	//{{AFX_MSG(CNcbrowseView)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnItemchanged(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnKeyUp(UINT nChar, UINT nRepCnt, UINT nFlags);
	//}}AFX_MSG
	afx_msg void OnStyleChanged(int nStyleType, LPSTYLESTRUCT lpStyleStruct);
	DECLARE_MESSAGE_MAP()
};

#ifndef _DEBUG  // debug version in ncbrowseView.cpp
inline CNcbrowseDoc* CNcbrowseView::GetDocument()
   { return (CNcbrowseDoc*)m_pDocument; }
#endif

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_NCBROWSEVIEW_H__CE6A4E4A_2AB4_4140_8879_7EF2DE7163F9__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\tools\ncbrowse\nceditview.cpp ===
// NCEditView.cpp : implementation file
//

#include "stdafx.h"
#include "ncbrowse.h"
#include "NCEditView.h"
#include "ncbrowsedoc.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CNCEditView

IMPLEMENT_DYNCREATE(CNCEditView, CEditView)

CNCEditView::CNCEditView()
{
}

CNCEditView::~CNCEditView()
{
}


BEGIN_MESSAGE_MAP(CNCEditView, CEditView)
	//{{AFX_MSG_MAP(CNCEditView)
	ON_WM_CREATE()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CNCEditView drawing

void CNCEditView::OnDraw(CDC* pDC)
{
	CNcbrowseDoc* pDoc = GetDocument();
	// TODO: add draw code here
}

/////////////////////////////////////////////////////////////////////////////
// CNCEditView diagnostics

#ifdef _DEBUG
void CNCEditView::AssertValid() const
{
	CEditView::AssertValid();
}

void CNCEditView::Dump(CDumpContext& dc) const
{
	CEditView::Dump(dc);
}

CNcbrowseDoc* CNCEditView::GetDocument() // non-debug version is inline
{
    ASSERT(m_pDocument->IsKindOf(RUNTIME_CLASS(CNcbrowseDoc)));
    return (CNcbrowseDoc*)m_pDocument;
}

#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CNCEditView message handlers

void CNCEditView::OnInitialUpdate() 
{
	CEditView::OnInitialUpdate();
	
    GetEditCtrl().SetReadOnly(TRUE);
}

int CNCEditView::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
	if (CEditView::OnCreate(lpCreateStruct) == -1)
		return -1;
	
    GetDocument()->m_pEditView = this; 
	// TODO: Add your specialized creation code here

    HFONT hFont;
    hFont = (HFONT)GetStockObject(SYSTEM_FIXED_FONT);

    SendMessage(WM_SETFONT, (WPARAM)hFont, FALSE);

    CEdit &editCtrlRef = GetEditCtrl();
        
	return 0;
}

BOOL CNCEditView::ScrollToLine(DWORD dwLineNum)
{
    CEdit &editCtrlRef = GetEditCtrl();
    int nFirstVisible = editCtrlRef.GetFirstVisibleLine();

    int nLinesToScroll = (dwLineNum - nFirstVisible) - 5;
    editCtrlRef.LineScroll(nLinesToScroll, 0);

    int nBegin, nEnd, nLen;
    
    if ((nBegin = editCtrlRef.LineIndex(dwLineNum-1)) != -1)
    {
        nLen = editCtrlRef.LineLength(nBegin); 
        nEnd = nBegin + nLen + 2;
        editCtrlRef.SetSel(nBegin, nEnd);
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\tools\ncbrowse\ncspewfile.cpp ===
// NCSpewFile.cpp: implementation of the CNCSpewFile class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "ncbrowse.h"
#include "mainfrm.h"

using namespace std;
#include "NCSpewFile.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////
CNCEntry::CNCEntry(DWORD dwLineNumber, tstring szTag, time_t tmTime, tstring szDescription, DWORD dwProcessID, DWORD dwThreadID)
{
    m_dwLineNumber = dwLineNumber;
    m_szTag = szTag;
    m_tmTime = tmTime;
    m_szDescription = szDescription;
    m_dwLevel = 0;
    m_dwProcessId = dwProcessID;
    m_dwThreadId  = dwThreadID;
}

CNCThread::CNCThread()
{
    m_dwProcessId = 0;
    m_dwThreadID  = 0;
}

class CProtectedArchive : public CArchive
{
public:
    LPTSTR ReadString(LPTSTR lpsz, UINT nMax);
};

#ifdef _DEBUG
#define DELETE_EXCEPTION(e) do { e->Delete(); } while (0)
#else  
#define DELETE_EXCEPTION(e)
#endif

LPTSTR CProtectedArchive::ReadString(LPTSTR lpsz, UINT nMax)
{
    // if nMax is negative (such a large number doesn't make sense given today's
    // 2gb address space), then assume it to mean "keep the newline".
    int nStop = (int)nMax < 0 ? -(int)nMax : (int)nMax;
    ASSERT(AfxIsValidAddress(lpsz, (nStop+1) * sizeof(TCHAR)));
    
    _TUCHAR ch;
    int nRead = 0;
    
    TRY
    {
        while (nRead < nStop)
        {
            *this >> ch;
            
            // stop and end-of-line (trailing '\n' is ignored)
            if (ch == '\n' || ch == '\r')
            {
                BOOL bBreak = TRUE;
                if (ch == '\r')
                {
                    BYTE by;
                    if (m_lpBufCur + sizeof(BYTE) > m_lpBufMax)
                    {
                        FillBuffer(sizeof(BYTE) - (UINT)(m_lpBufMax - m_lpBufCur));
                    }
                    by = *(UNALIGNED BYTE*)m_lpBufCur; 

                    if (by == '\n')
                    {
                        ch = by;
                        m_lpBufCur += sizeof(BYTE); 
                    }
                    else
                    {
                        ch = by;
                        bBreak = FALSE;
                    }
                }
                // store the newline when called with negative nMax
                if ((int)nMax != nStop)
                {
                    lpsz[nRead++] = ch;
                }
                if (bBreak)
                {
                    break;
                }
            }
            lpsz[nRead++] = ch;
        }
    }
    CATCH(CArchiveException, e)
    {
        if (e->m_cause == CArchiveException::endOfFile)
        {
            DELETE_EXCEPTION(e);

            if (nRead == 0)
                return NULL;
        }
        else
        {
            THROW_LAST();
        }
    }
    END_CATCH
        
        lpsz[nRead] = '\0';
    return lpsz;
}

enum NETCFG_LOGTYPE
{
    LOGTYPE_UNKNOWN = 0,
    LOGTYPE_PROC_THREAD      = 1,
    LOGTYPE_PROC_THREAD_TIME = 2,
};

CNCSpewFile::CNCSpewFile(CArchive& ar)
{
    TCHAR szCurrentLine[8192];
    DWORD   dwLineNum = 0;
    const CFile &fp = *(ar.GetFile());
    
    DWORD dwTotalSize = fp.GetLength();
    
    DWORD dwTotalSpews = 1;
    CSpew spew;
    spew.szSpewName = _T("01. Unknown O/S");
    m_Spews[1] = spew;
    
    CSpew *m_pCurrentSpew = &(m_Spews[1]);
    m_pCNCurrentThread = &(m_pCurrentSpew->m_NCThreadList);

    NETCFG_LOGTYPE ncfLogType = LOGTYPE_UNKNOWN;

    CProtectedArchive &arP = *reinterpret_cast<CProtectedArchive *>(&ar);
    while (arP.ReadString(szCurrentLine, 8192))
    {
        dwLineNum++;

        LPCTSTR sztstring = szCurrentLine;

        rpattern *pPat = NULL;
        switch (ncfLogType)
        {
            case LOGTYPE_UNKNOWN:
            case LOGTYPE_PROC_THREAD:
                pPat = new rpattern( _T(".*(ETCFG) ([0-9a-fA-F]*)\\.([0-9a-fA-F]*) (?:\\(|\\*)((?:\\s|\\w)*)(?:\\)|\\*)(.*)") );
                break;

            case LOGTYPE_PROC_THREAD_TIME:
                pPat = new rpattern( _T(".*(ETCFG) ([0-9a-fA-F]*)\\.([0-9a-fA-F]*) \\[.*\\] (?:\\(|\\*)((?:\\s|\\w)*)(?:\\)|\\*)(.*)") );
                break;

            default:
                ASSERT(FALSE);
                return;
        }

        
        //rpattern pat( _T("NETCFG (\\{a-f0-9}+)\\.(\\{a-f0-9}+)") );
    
        DWORD dwPosition = fp.GetPosition();
        TCHAR szStatusBarText[MAX_PATH];
      
        DWORD dwPercentage = 100 * dwPosition / dwTotalSize;
        _stprintf(szStatusBarText, _T("%d%% complete"), dwPercentage);

        CStatusBar &StatusBar = ((CMainFrame *)AfxGetMainWnd())->m_wndStatusBar;
        StatusBar.SetPaneText (0, szStatusBarText, TRUE);
        
        BOOL bProcessed = FALSE;
        BOOL bMatched = FALSE;
        BOOL bHalfMatched = FALSE;

        regexpr::backref_vector rgbackrefs;
        if (regexpr::match( sztstring, *pPat, &rgbackrefs ) )
        {
            bMatched   = TRUE;
            if (LOGTYPE_UNKNOWN == ncfLogType)
            {
                ncfLogType = LOGTYPE_PROC_THREAD;
            }
        }
        else
        {
            if (LOGTYPE_UNKNOWN == ncfLogType)
            {
                delete pPat;

                pPat = new rpattern( _T(".*(ETCFG) ([0-9a-fA-F]*)\\.([0-9a-fA-F]*) \\[.*\\] (?:\\(|\\*)((?:\\s|\\w)*)(?:\\)|\\*)(.*)") );
                if (regexpr::match( sztstring, *pPat, &rgbackrefs ) )
                {
                    bMatched = TRUE;
                    ncfLogType = LOGTYPE_PROC_THREAD_TIME;
                }
            }
        }

        if (!bMatched)
        {
            rpattern pat( _T(".*(ETCFG) ([0-9a-fA-F]*)\\.([0-9a-fA-F]*)(.*)") );
            if( regexpr::match( sztstring, pat, &rgbackrefs ) )
            {
                bHalfMatched = TRUE;
            }
        }

        delete pPat;

        if (bMatched | bHalfMatched)
        {
           // Backref 0 -> Full tstring
           // Backref 1 -> NETCFG
           // Backref 2 -> ProcId
           // Backref 3 -> ThreadId
           // Backref 4 -> TagName
           // Backref 5 -> tstring

           ASSERT(rgbackrefs.size() >= 5);
           TCHAR szProcID[MAX_PATH];
           TCHAR szThreadID[MAX_PATH];
           TCHAR szTagName[MAX_PATH];
           TCHAR szDescription[8192];

           bProcessed = TRUE;
           regexpr::backref_type br = rgbackrefs[2];
           _stprintf(szProcID, _T("%.*s"), br.second - br.first, br.first );
           StrTrim(szProcID, _T(" "));
           LPTSTR szEndChar;
           DWORD dwProcId = _tcstoul(szProcID, &szEndChar, 16);
       
           br = rgbackrefs[3];
           _stprintf(szThreadID, _T("%.*s"), br.second - br.first, br.first );
           StrTrim(szThreadID, _T(" "));
           DWORD dwThreadId = _tcstoul(szThreadID, &szEndChar, 16);

           DWORD iProcThread = (dwProcId << 16) | dwThreadId;
       
           if (bMatched)
           {
               br = rgbackrefs[4];
               _stprintf(szTagName, _T("%.*s"), br.second - br.first, br.first );
               StrTrim(szTagName, _T(" "));

               br = rgbackrefs[5];
               _stprintf(szDescription, _T("%.*s"), br.second - br.first, br.first );
               StrTrim(szDescription, _T(" "));

               if (!_tcscmp(szTagName, _T("ERROR")))
               {
                   _tcscpy(szTagName, _T("*ERROR*"));
                   StrTrim(szDescription, _T(":"));
                   StrTrim(szDescription, _T(" "));
               }
           }
           else
           {
               _tcscpy(szTagName, _T("*Unknown*"));
               br = rgbackrefs[4];
               _stprintf(szDescription, _T("%.*s"), br.second - br.first, br.first );
               StrTrim(szDescription, _T(" "));
           }
       
           CNCEntry NCEntry(dwLineNum, szTagName, 0, szDescription, dwProcId, dwThreadId);

           CNCThread &NCThread = (*m_pCNCurrentThread)[iProcThread];
           if (!NCThread.m_dwProcessId)
           {
                NCThread.m_dwProcessId = dwProcId;
                NCThread.m_dwThreadID  = dwThreadId;
           }
           else
           {
               ASSERT(NCThread.m_dwProcessId == dwProcId);
               ASSERT(NCThread.m_dwThreadID  == dwThreadId);
           }
           NCThread.m_lsLines.push_back(NCEntry);
           NCThread.m_Tags[szTagName]++;

           m_pCurrentSpew->m_lsLines.push_back(NCEntry);
           m_pCurrentSpew->m_Tags[szTagName]++;
        }

        if (*szCurrentLine == _T('C'))
        {
            rpattern connPat( _T("Connected to Windows (.*) compatible target") );
            regexpr::backref_vector rgbackrefs;
            if( regexpr::match( sztstring, connPat, &rgbackrefs ) ) 
            {    
                bProcessed = TRUE;
                dwTotalSpews++;

                ASSERT(rgbackrefs.size() >= 2);
                regexpr::backref_type br = rgbackrefs[1];
                TCHAR szDescription[MAX_PATH];
                _stprintf(szDescription, _T("%02d. %.*s"), dwTotalSpews, br.second - br.first, br.first );

                CSpew spew;
                spew.szSpewName = szDescription;

                m_Spews[dwTotalSpews] = spew;
                m_pCurrentSpew = &(m_Spews[dwTotalSpews]);

                m_pCNCurrentThread = &(m_pCurrentSpew->m_NCThreadList);
            }
        }
        
        if (!bProcessed)
        {
            m_pCurrentSpew->m_SpareLines[dwLineNum] = szCurrentLine;
        }
    }
}

CNCSpewFile::~CNCSpewFile()
{

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\tools\ncbrowse\ncspewfile.h ===
// NCSpewFile.h: interface for the CNCSpewFile class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_NCSPEWFILE_H__B512E73A_7E4E_4018_B009_A4925E007FB5__INCLUDED_)
#define AFX_NCSPEWFILE_H__B512E73A_7E4E_4018_B009_A4925E007FB5__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "regexpr.h"
using namespace regex;

typedef map<DWORD, tstring> CNCSpareLineMap;

class CNCEntry
{
public:
    CNCEntry(DWORD dwLineNumber, tstring szTag, time_t m_tmTime, tstring szDescription, DWORD dwProcessID, DWORD dwThreadID);
    // CNCEntry(const CNCEntry&);
    DWORD  m_dwLineNumber;
    tstring m_szTag;
    time_t m_tmTime;
    DWORD  m_dwLevel;
    tstring m_szDescription;
    DWORD  m_dwThreadId;
    DWORD  m_dwProcessId;
};

typedef list<CNCEntry> CNCEntryList;
typedef map<tstring, DWORD> CNCTagMap;

class CNCThread
{
public:
    CNCThread();
    DWORD m_dwProcessId;
    DWORD m_dwThreadID;
    CNCEntryList m_lsLines;
    CNCTagMap    m_Tags;
};

typedef map<DWORD, CNCThread> CNCThreadList;

class CSpew
{
public:
    tstring       szSpewName;
    CNCThreadList m_NCThreadList;
    CNCEntryList  m_lsLines;
    CNCTagMap     m_Tags;
    CNCSpareLineMap m_SpareLines;
};

typedef map<DWORD, CSpew> CSpewList;

class CNCSpewFile  
{
public:
    CNCThreadList *m_pCNCurrentThread;
    CSpewList m_Spews;

public:
	CNCSpewFile(CArchive& ar);
	virtual ~CNCSpewFile();
    
};

#endif // !defined(AFX_NCSPEWFILE_H__B512E73A_7E4E_4018_B009_A4925E007FB5__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\tools\ncbrowse\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by ncbrowse.rc
//
#define IDD_ABOUTBOX                    100
#define ID_VIEW_ARRANGE                 127
#define IDR_MAINFRAME                   128
#define IDR_NCSPEWTYPE                  129
#define IDI_THREAD                      130
#define IDI_LINE                        131
#define IDI_SPEW                        132
#define IDI_FILTER                      133
#define IDI_FILTER_SEL                  134
#define IDI_SPEW_SEL                    135
#define IDI_THREAD_SEL                  136
#define IDI_LINE_SEL                    137
#define IDI_THREADBACK                  138
#define IDI_THREADBACK_SEL              139


// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_3D_CONTROLS                     1
#define _APS_NEXT_RESOURCE_VALUE        140
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\tools\ncbrowse\nceditview.h ===
#if !defined(AFX_NCEDITVIEW_H__DCB4F926_F391_4DDC_B0F6_5ACED6173607__INCLUDED_)
#define AFX_NCEDITVIEW_H__DCB4F926_F391_4DDC_B0F6_5ACED6173607__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// NCEditView.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CNCEditView view

class CNcbrowseDoc;

class CNCEditView : public CEditView
{
protected:
	CNCEditView();           // protected constructor used by dynamic creation
	DECLARE_DYNCREATE(CNCEditView)

// Attributes
public:
    CNcbrowseDoc* GetDocument();
    BOOL ScrollToLine(DWORD dwLineNum);
// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CNCEditView)
	public:
	virtual void OnInitialUpdate();
	protected:
	virtual void OnDraw(CDC* pDC);      // overridden to draw this view
	//}}AFX_VIRTUAL

// Implementation
protected:
	virtual ~CNCEditView();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

	// Generated message map functions
protected:
	//{{AFX_MSG(CNCEditView)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

#ifndef _DEBUG  // debug version in LeftView.cpp
inline CNcbrowseDoc* CNCEditView::GetDocument()
{ return (CNcbrowseDoc*)m_pDocument; }
#endif

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_NCEDITVIEW_H__DCB4F926_F391_4DDC_B0F6_5ACED6173607__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\tools\ncbrowse\regexpr.cpp ===
//+---------------------------------------------------------------------------
//
//  File:       basic_regexpr.cxx
//
//  Contents:   
//
//  Classes:    
//
//  Functions:  
//
//  Coupling:   
//
//  Notes:      
//
//  History:    1-11-1999   ericne   Created
//
//----------------------------------------------------------------------------
#include "stdafx.h"
#pragma hdrstop
// unlimited inline expansion (compile with /Ob1 or /Ob2)
#pragma inline_depth(255)

// C4355 'this' : used in base member initializer list
// C4660 template-class specialization 'foo<bar>' is already instantiated
// C4786 identifier was truncated to '255' characters in the debug information
// C4800 'int' : forcing value to bool 'true' or 'false' (performance warning)
#pragma warning( disable : 4355 4660 4786 4800 )

#include <assert.h>
#include <malloc.h> // for _alloca	
#include <algorithm>
#include <minmax.h>
#include "regexpr.h"

using namespace std;

namespace regex 
{

#ifdef _MT
// Global critical section used to synchronize the creation of static const patterns
CRegExCritSect g_objRegExCritSect;
#endif

// For use while doing uppercase/lowercase conversions:
// For use while doing uppercase/lowercase conversions:
inline  char   to_upper(  char   ch ) { return ( char  )toupper(ch); }
inline  char   to_lower(  char   ch ) { return ( char  )tolower(ch); }
inline wint_t to_upper( wint_t ch ) { return (wint_t)towupper(ch); }
inline wint_t to_lower( wint_t ch ) { return (wint_t)towlower(ch); }
template< typename II, typename CI > 
void to_upper( II ibegin, CI iend )
{
    for( ; (CI)ibegin != iend; ++ibegin )
        *ibegin = to_upper( *ibegin );
}
template< typename II, typename CI > 
void to_lower( II ibegin, CI iend )
{
    for( ; (CI)ibegin != iend; ++ibegin )
        *ibegin = to_lower( *ibegin );
}

template< typename II, typename CI >
unsigned parse_int( II & istr, CI iend, const unsigned m_max = -1 )
{
    unsigned retval = 0;
    while( (CI)istr != iend && '0' <= *istr && '9' >= *istr && m_max > retval )
    {
        retval = retval * 10 + ( (unsigned)*istr++ - (unsigned)'0' );
    }
    if( m_max < retval )
    {
        retval /= 10;
        --istr;
    }
    return retval;
}

// This class is used to speed up character set matching by providing
// a bitset that spans the ASCII range. std::bitset is not used because
// the range-checking slows it down.
// Note: The division and modulus operations are optimized by the compiler
// into bit-shift operations.
class ascii_bitvector
{
    typedef unsigned __int32 elem_type;   // use 32-bit ints on 32-bit platforms
    //typedef unsigned __int64 elem_type; // use 64-bit ints on 64-bit platforms

    enum { CBELEM = 8 * sizeof elem_type,     // count of bytes per element
           CELEMS = (UCHAR_MAX+1) / CBELEM }; // number of element in array
    elem_type m_rg[ CELEMS ];

    // Used to inline operations like: bv1 |= ~bv2; without creating temp bit vectors.
    struct not_ascii_bitvector
    {
        const ascii_bitvector & m_ref;
        not_ascii_bitvector( const ascii_bitvector & ref ) throw()
            : m_ref(ref) {}
    };
public:
    ascii_bitvector() throw()
        { memset( m_rg, 0, CELEMS * sizeof elem_type ); }
    
    inline void set( unsigned char ch ) throw()
        { m_rg[ ( ch / CBELEM ) ] |= ( (elem_type)1U << ( ch % CBELEM ) ); }
    
    inline bool operator[]( unsigned char ch ) const throw()
        { return 0 != ( m_rg[ ( ch / CBELEM ) ] & ( (elem_type)1U << ( ch % CBELEM ) ) ); }
    
    inline not_ascii_bitvector operator~() const throw()
        { return not_ascii_bitvector(*this); }
    
    inline ascii_bitvector & operator|=( const ascii_bitvector & that ) throw()
        { for( int i=0; i<CELEMS; ++i )
              m_rg[i] |= that.m_rg[i];
          return *this; }
    
    inline ascii_bitvector & operator|=( const not_ascii_bitvector & that ) throw()
        { for( int i=0; i<CELEMS; ++i )
              m_rg[i] |= ~that.m_ref.m_rg[i];
          return *this; }
};

const ascii_bitvector & get_digit_vector(void)
{
    // 0-9
    class digit_vector : public ascii_bitvector
    {
    public:
        digit_vector()
        {
            unsigned char ich;
            for( ich ='0'; ich <= '9'; ++ich )
                set(ich);
        }
    };

    static const digit_vector s_digit_vector;
    return s_digit_vector;
}

const ascii_bitvector & get_word_vector(void)
{
    // a-zA-Z_0-9
    class word_vector : public ascii_bitvector
    {
    public:
        word_vector()
        {
            unsigned char ich;
            for( ich = 'a'; ich <= 'z'; ++ich )
                set(ich);
            for( ich = 'A'; ich <= 'Z'; ++ich )
                set(ich);
            for( ich = '0'; ich <= '9'; ++ich )
                set(ich);
            set('_');
        }
    };

    static const word_vector s_word_vector;
    return s_word_vector;
}

const ascii_bitvector & get_space_vector(void)
{
    // " \t\r\n\f"
    class space_vector : public ascii_bitvector
    {
    public:
        space_vector()
        {
            set(' ');
            set('\t');
            set('\v');
            set('\r');
            set('\n');
            set('\f');
        }
    };

    static const space_vector s_space_vector;
    return s_space_vector;
}

//
// Operator implementations
//

// Base type used so that all derived operators share typedefs.
template< typename CI >
struct op_t : public binary_function<match_param<CI>,CI,bool>
{
    typedef CI const_iterator;
    typedef typename iterator_traits<CI>::value_type char_type;
};

// Evaluates the beginning-of-string condition
template< typename CI >
struct bos_t : public op_t<CI>
{
    inline bool operator()( const match_param<CI> & param, CI iter ) const
    {
        return param.ibegin == iter;
    }
};

// Find the beginning of a line, either beginning of a string, or the character
// immediately following a newline
template< typename CI >
struct bol_t : public bos_t<CI>
{
    inline bool operator()( const match_param<CI> & param, CI iter ) const
    {
        return bos_t<CI>::operator()(param,iter) || char_type('\n') == *--iter;
    }
};

// Evaluates end-of-string condition for string's
template< typename CI >
struct eos_t : public op_t<CI>
{
    inline bool operator()( const match_param<CI> & param, CI iter ) const
    {
        return param.istop == iter;
    }
};

// Evaluates end-of-string condidition for C-style string's when the length is unknown by
// looking for the null-terminator.
template< typename CI >
struct eocs_t : public op_t<CI>
{
    inline bool operator()( const match_param<CI> & param, CI iter ) const
    {
        return char_type('\0') == *iter;
    }
};

// Evaluates end-of-line conditions, either the end of the string, or a
// return or newline character.
template< typename EOS >
struct eol_t_t : public EOS
{
    typedef typename EOS::const_iterator CI;
    inline bool operator()( const match_param<CI> & param, CI iter ) const
    {
        return EOS::operator()(param,iter) || char_type('\n') == *iter || char_type('\r') == *iter;
    }
};

template< typename CI > struct eol_t  : public eol_t_t<eos_t<CI> >  {};
template< typename CI > struct eocl_t : public eol_t_t<eocs_t<CI> > {};

// Evaluates perl's end-of-string conditions, either the end of the string, or a
// newline character followed by end of string. (Only used by $ and /Z assertions)
template< typename EOS >
struct peos_t_t : public EOS
{
    typedef typename EOS::const_iterator CI;
    inline bool operator()( const match_param<CI> & param, CI iter ) const
    {
        return EOS::operator()(param,iter) || ( ( char_type('\n') == *iter ) && EOS::operator()(param,++iter) );
    }
};

template< typename CI > struct peos_t  : public peos_t_t<eos_t<CI> >  {};
template< typename CI > struct peocs_t : public peos_t_t<eocs_t<CI> > {};

// compare two characters, case-sensitive
template< typename CH >
struct ch_neq_t : public binary_function<CH, CH, bool>
{
    typedef CH char_type;
    inline bool operator()( register CH ch1, register CH ch2 ) const
    {
        return ch1 != ch2;
    }
};

// Compare two characters, disregarding case
template< typename CH >
struct ch_neq_nocase_t : public binary_function<CH, CH, bool>
{
    typedef CH char_type;
    inline bool operator()( register CH ch1, register CH ch2 ) const
    {
        return to_upper(ch1) != to_upper(ch2);
    }
};

//
// Helper functions for match and substitute
//

template< typename CI >
size_t string_length( CI iter )
{
    size_t n = 0;
    while( 0 != *iter++ )
        ++n;
    return n;
}

template< typename CI >
backref_tag<CI> _do_match( const basic_rpattern_base<CI> & pat, match_param<CI> & param ) throw()
{
    typedef typename iterator_traits<CI>::value_type char_type;
    
    bool       floop  = pat.loops();
    unsigned   flags  = pat.flags();
    width_type nwidth = pat.get_width();

    const sub_expr<CI> * pfirst = pat.get_first_subexpression();

    try
    {
        vector<backref_tag<CI> > rgbackrefs; // dummy backref vector

        if( NULL == param.prgbackrefs )
            param.prgbackrefs = & rgbackrefs;

        param.prgbackrefs->resize( pat._cgroups_total() ); 
        fill( param.prgbackrefs->begin(), param.prgbackrefs->end(), backref_tag<CI>() );

        // If a pattern is optimized for CSTRINGS, it can save a call
        // to calculate the length of the string.
        if( CI(0) == param.istop && ( ( RIGHTMOST & flags ) || ( 0 == ( CSTRINGS & flags ) ) ) )
            param.istop = param.istart + string_length( param.istart );

        if( CI(0) != param.istop )
        {
            // If the minimum width of the pattern exceeds the width of the
            // string, a succesful match is impossible
            if( nwidth.m_min <= (size_t)distance( param.istart, param.istop ) )
            {
                CI local_istop = param.istop;
                advance( local_istop, -int( nwidth.m_min ) );

                if( RIGHTMOST & flags )
                {
                    // begin trying to match after the last character.
                    // Continue to the beginning
                    for( CI icur = local_istop; icur >= param.istart; --icur )
                        if( pfirst->domatch( param, icur ) ) 
                            break; // m_floop not used for rightmost matches
                }
                else
                {
                    // begin trying to match before the first character.
                    // Continue to the end
                    for( CI icur = param.istart; icur <= local_istop; ++icur )
                        if( pfirst->domatch( param, icur ) || ! floop )
                            break;
                }
            }
        }
        else
        {
            // begin trying to match before the first character.
            // Continue to the end
            for( CI icur = param.istart; ; ++icur )
            {
                if( pfirst->domatch( param, icur ) || ! floop )
                    break;
                if( char_type('\0') == *icur )
                    break;
            }
        }
    }
    catch(...) // bad alloc, stack overflow?
    {
        fill( param.prgbackrefs->begin(), param.prgbackrefs->end(), backref_tag<CI>() );
    }

    // Shrink the backref vector to chop off information about the "invisible" groups
    param.prgbackrefs->resize( pat.cgroups() );

    return (*param.prgbackrefs)[0];
}

template< typename CI, typename CH, typename TR, typename AL >
size_t _do_subst( basic_regexpr<CH,TR,AL> & str, const basic_rpattern_base<CI> & pat, size_t strpos, size_t strlen ) throw(bad_alloc)
{
    typedef iterator_traits<CI>::value_type char_type;
    typedef list<subst_node>::const_iterator LCI;
    enum { UPPER = -1, NIL, LOWER } next = NIL, rest = NIL;
    bool first = true;
    size_t old_strpos = strpos;
    const list<subst_node> & subst_list = pat.get_subst_list();
    basic_string<CH,TR,AL>::iterator itstrlen = str.begin();
    advance( itstrlen, strpos + strlen );
    const basic_string<char_type> & subst = pat.get_subst();
    push_new_handler pnh( &my_new_handler );
    
    for( LCI isubst = subst_list.begin(); isubst != subst_list.end(); ++isubst )
    {
        size_t sublen;
        basic_string<CH,TR,AL>::const_iterator  itsubpos1; // iter into str
        basic_string<CH,TR,AL>::const_iterator  itsublen1;
        basic_string<char_type>::const_iterator itsubpos2; // iter into subst string
        basic_string<char_type>::const_iterator itsublen2;
        basic_string<CH,TR,AL>::iterator itstrpos = str.begin();
        advance( itstrpos, strpos );

        switch( isubst->stype )
        {
            case subst_node::SUBST_STRING:
                itsubpos2 = subst.begin();
                advance( itsubpos2, isubst->subst_string.rstart );
                itsublen2 = itsubpos2;
                advance( itsublen2, isubst->subst_string.rlength );

                first ? str.replace( itstrpos, itstrlen, itsubpos2, itsublen2 ) : 
                        str.insert( itstrpos, itsubpos2, itsublen2 );
                sublen = distance( itsubpos2, itsublen2 );
                break;

            case subst_node::SUBST_BACKREF:
                switch( isubst->subst_backref )
                {
                case subst_node::PREMATCH:
                    itsubpos1 = str.backref_str().begin();
                    itsublen1 = itsubpos1;
                    advance( itsublen1, sublen = str.rstart() );
                    break;
                case subst_node::POSTMATCH:
                    itsubpos1 = str.backref_str().begin();
                    advance( itsubpos1, str.rstart() + str.rlength() );
                    itsublen1 = str.backref_str().end();
                    break;
                default:
                    itsubpos1 = str.backref_str().begin();
                    advance( itsubpos1, str.rstart( isubst->subst_backref ) );
                    itsublen1 = itsubpos1;
                    advance( itsublen1, str.rlength( isubst->subst_backref ) );
                    break;
                }

                first ? str.replace( itstrpos, itstrlen, itsubpos1, itsublen1 ) : 
                        str.insert( itstrpos, itsubpos1, itsublen1 );
                sublen = distance( itsubpos1, itsublen1 );
                break;

            case subst_node::SUBST_OP:
                switch( isubst->op )
                {
                case subst_node::UPPER_ON:
                    rest = UPPER;
                    break;
                case subst_node::UPPER_NEXT:
                    next = UPPER;
                    break;
                case subst_node::LOWER_ON:
                    rest = LOWER;
                    break;
                case subst_node::LOWER_NEXT:
                    next = LOWER;
                    break;
                case subst_node::ALL_OFF:
                    rest = NIL;
                    break;
                default:
                    __assume(0);
                }
                continue; // jump to the next item in the list

            default:
                __assume(0);
        }

        first = false;

        // Are we upper- or lower-casing this string?
        if( rest )
        {
            basic_string<CH,TR,AL>::iterator istart = str.begin();
            advance( istart, strpos );
            basic_string<CH,TR,AL>::const_iterator istop = istart;
            advance( istop, sublen );
            switch( rest )
            {
            case UPPER:
                to_upper( istart, istop );
                break;
            case LOWER:
                to_lower( istart, istop );
                break;
            default:
                __assume(0);
            }
        }

        // Are we upper- or lower-casing the next character?
        if( next )
        {
            switch( next )
            {
            case UPPER:
                str[strpos] = to_upper(str[strpos]);
                break;
            case LOWER:
                str[strpos] = to_lower(str[strpos]);
                break;
            default:
                __assume(0);
            }
            next = NIL;
        }

        strpos += sublen;
    }

    // If *first* is still true, then we never called str.replace, and the substitution
    // string is empty. Erase the part of the string that the pattern matched.
    if( first )
        str.erase( strpos, strlen );

    // return length of the substitution
    return strpos - old_strpos;
}

//
// Implementation of basic_regexpr
//

template< typename CH, typename TR, typename AL >
size_t basic_regexpr<CH,TR,AL>::substitute( 
    const basic_rpattern_base<basic_regexpr<CH,TR,AL>::const_iterator> & pat, 
    size_type pos, 
    size_type len ) throw(bad_alloc)
{
    if( pat.flags() & CSTRINGS )
    {
        assert( ! "You can't use a pattern optimized for CSTRINGS with regexpr::substitute" );
        return 0;
    }

    backref_vector rgbackrefs; // dummy backref vector
    backref_vector * prgbackrefs = & rgbackrefs;
    const bool fsave_backrefs = ( pat.uses_backrefs() || !( pat.flags() & NOBACKREFS ) );

    if( fsave_backrefs )
    {
        prgbackrefs = & m_rgbackrefs;
        m_pbackref_str = & ( m_backref_str = *this );
    }
    else
    {
        m_backref_str.erase();
        m_pbackref_str = this;
        m_rgbackrefs.resize( 0 );
    }

    backref_type br;
    size_t csubst = 0;
    long stop_offset = ( len == npos ? 
                         m_pbackref_str->size() : 
                         min( pos + len, m_pbackref_str->size() ) );

    match_param<const_iterator> param( m_pbackref_str->begin(),
                                       m_pbackref_str->begin(),
                                       prgbackrefs );
    advance( param.istart, pos );
    advance( param.istop, stop_offset );
    param.ibegin = param.istart;

    if( GLOBAL & pat.flags() )
    {
        const bool fAll   = ( ALLBACKREFS   == ( ALLBACKREFS   & pat.flags() ) );
        const bool fFirst = ( FIRSTBACKREFS == ( FIRSTBACKREFS & pat.flags() ) );
        backref_vector rgtempbackrefs; // temporary vector used if fsave_backrefs

        long pos_offset = 0; // keep track of how much the backref_str and
                             // the current string are out of sync

        while( br = _do_match( pat, param ) )
        {
            ++csubst;
            size_type match_length = distance( br.first, br.second );
            pos = distance( m_pbackref_str->begin(), br.first );
            size_type subst_length = _do_subst( *this, pat, pos + pos_offset, match_length );

            if( fsave_backrefs )
            {
                pos += match_length;
                pos_offset += ( subst_length - match_length );

                // Handle specially the backref flags
                if( fFirst )
                    rgtempbackrefs.push_back( br );
                else if( fAll )
                    rgtempbackrefs.insert( rgtempbackrefs.end(),
                                           param.prgbackrefs->begin(), 
                                           param.prgbackrefs->end() );
                else
                    rgtempbackrefs.swap( *param.prgbackrefs );
            }
            else
            {
                pos += subst_length;
                stop_offset += ( subst_length - match_length );

                // we're not saving backref information, so we don't
                // need to do any special backref maintenance here
            }
            
            // prevent a pattern that matches 0 characters from matching
            // again at the same point in the string
            if( 0 == match_length )
            {
                if( br.first == param.istop ) // We're at the end, so we're done
                    break;
                ++pos;
            }

            param.istart = m_pbackref_str->begin();
            advance( param.istart, pos ); // ineffecient for bidirectional iterators.

            param.istop = m_pbackref_str->begin();
            advance( param.istop, stop_offset ); // ineffecient for bidirectional iterators.
        }

        // If we did special backref handling, swap the backref vectors
        if( fsave_backrefs && ( !br || fFirst || fAll ) )
            param.prgbackrefs->swap( rgtempbackrefs );
        else if( ! (*param.prgbackrefs)[0] )
            param.prgbackrefs->clear();
    }
    else if( br = _do_match( pat, param ) )
    {
        ++csubst;
        _do_subst( *this, pat,
                   distance( m_pbackref_str->begin(), br.first ),
                   distance( br.first, br.second ) );
    }

    if( NOBACKREFS == ( pat.flags() & NOBACKREFS ) )
        param.prgbackrefs->clear();

    return csubst;
}

//
// Helper functions called from both basic_regexpr match methods
//

template< typename EOS >
backref_tag< typename EOS::const_iterator > _match_helper( 
    const basic_rpattern_base<typename EOS::const_iterator> & pat,
    match_param<typename EOS::const_iterator> & param,
    EOS eos )
{
    typedef typename EOS::const_iterator CI;

    if( GLOBAL & pat.flags() ) // do a global find
    {
        // The NOBACKREFS flag is ignored in the match method.
        const bool fAll   = ( ALLBACKREFS   == ( ALLBACKREFS   & pat.flags() ) );
        const bool fFirst = ( FIRSTBACKREFS == ( FIRSTBACKREFS & pat.flags() ) );

        backref_tag<CI>  br;
        vector<backref_tag<CI> > rgtempbackrefs;
        
        while( br = _do_match( pat, param ) )
        {
            // Handle specially the backref flags
            if( fFirst )
                rgtempbackrefs.push_back( br );
            else if( fAll )
                rgtempbackrefs.insert( rgtempbackrefs.end(),
                                       param.prgbackrefs->begin(),
                                       param.prgbackrefs->end() );
            else
                rgtempbackrefs.swap( *param.prgbackrefs );

            if( br.first == ( param.istart = br.second ) )
            {
                if( eos( param, param.istart ) )
                    break;
                ++param.istart;
            }
        }

        // restore the backref vectors
        if( !br || fFirst || fAll )
            param.prgbackrefs->swap( rgtempbackrefs );
        else if( ! (*param.prgbackrefs)[0] )
            param.prgbackrefs->clear();

        return param.prgbackrefs->empty() ? backref_tag<CI>() : (*param.prgbackrefs)[0];
    }
    else 
        return _do_match( pat, param );
}

template< typename CH, typename TR, typename AL >
basic_regexpr<CH,TR,AL>::backref_type basic_regexpr<CH,TR,AL>::match( 
    const basic_rpattern_base<const_iterator> & pat,
    size_type pos, size_type len ) const throw()
{
    if( pat.flags() & CSTRINGS )
    {
        assert( ! "A pattern optimized for CSTRINGS can only be used with the static regexpr::match method" );
        return backref_type();
    }

    m_pbackref_str = this;
    m_backref_str.erase(); // free up unused memory

    const_iterator istart = begin();
    advance( istart, pos );

    const_iterator istop;
    if( len == npos || pos + len >= size() )
        istop = end();
    else
        advance( istop = begin(), pos + len );

    match_param<const_iterator> param( istart, istop, & m_rgbackrefs );
    return _match_helper<eos_t<const_iterator> >( pat, param, eos_t<const_iterator>() );
}

template< typename CH >
backref_tag<const CH *> _static_match_helper( 
    const CH * szstr, 
    const basic_rpattern_base<const CH *> & pat,
    vector< backref_tag< const CH * > > * prgbackrefs ) throw()
{
    vector< backref_tag< const CH * > > rgdummyvector;
    if( NULL == prgbackrefs )
        prgbackrefs = &rgdummyvector;

    match_param<const CH *> param( szstr, NULL, prgbackrefs );
    return _match_helper<eocs_t<const CH *> >( pat, param, eocs_t<const CH *>() );
}

//
// Helper function called from both basic_regexpr::count methods
//
template< typename EOS >
size_t _count_helper( 
    const basic_rpattern_base<typename EOS::const_iterator> & pat,
    match_param<typename EOS::const_iterator> & param,
    EOS eos )
{
    typedef typename EOS::const_iterator CI;

    size_t cmatches = 0;
    vector<backref_tag<CI> > rgbackrefs; // dummy backref vector
    backref_tag<CI>          br;
    param.prgbackrefs = &rgbackrefs;

    while( br = _do_match( pat, param ) )
    {
        ++cmatches;

        if( br.first == ( param.istart = br.second ) )
        {
            if( eos( param, param.istart ) )
                break;
            ++param.istart;
        }
    }
    return cmatches;
}

template< typename CH, typename TR, typename AL >
size_t basic_regexpr<CH,TR,AL>::count( 
    const basic_rpattern_base<basic_regexpr<CH,TR,AL>::const_iterator> & pat,
    size_type pos, 
    size_type len ) const throw()
{
    if( pat.flags() & CSTRINGS )
    {
        assert( ! "A pattern optimized for CSTRINGS can only be used with the static regexpr::count method" );
        return backref_type();
    }

    m_pbackref_str = this;

    const_iterator istart = begin();
    advance( istart, pos );

    const_iterator istop;
    if( len == npos || pos + len >= size() )
        istop = end();
    else
        advance( istop = begin(), pos + len );

    match_param<const_iterator> param( istart, istop, NULL );
    return _count_helper<eos_t<const_iterator> >( pat, param, eos_t<const_iterator>() );
}

template< typename CH >
size_t _static_count_helper( 
    const CH * szstr, 
    const basic_rpattern_base<const CH *> & pat ) throw()
{
    match_param<const CH *> param( szstr, NULL, NULL );
    return _count_helper<eocs_t<const CH *> >( pat, param, eocs_t<const CH *>() );
}

// Base class for sub-expressions which are zero-width 
// (i.e., assertions eat no characters during matching)
// Assertions cannot be quantified.
template< typename CI >
class assertion : public sub_expr<CI>
{
public:
    virtual ~assertion() {}
    virtual bool is_assertion() const throw() { return true; }
protected:
    virtual width_type _width_this() throw() { return width_type(0,0); }
};

template< typename OP >
class assert_op : public assertion<typename OP::const_iterator>
{
public:
    typedef OP op_type;
    typedef typename OP::const_iterator CI;
    virtual ~assert_op() {}
protected:
    virtual bool _match_this( match_param<CI> & param, CI & icur ) const throw()
    {
        return m_op( param, icur );
    }
    op_type m_op;
};

template< typename CI >
assertion<CI> * create_bos( unsigned /*flags*/ )
{
    return new assert_op<bos_t<CI> >();
}

template< typename CI >
assertion<CI> * create_eos( unsigned flags )
{
    switch( CSTRINGS & flags )
    {
    case 0:
        return new assert_op<peos_t<CI> >();
    case CSTRINGS:
        return new assert_op<peocs_t<CI> >();
    default:
        __assume(0); // tells the compiler that this is unreachable
    }
}

template< typename CI >
assertion<CI> * create_eoz( unsigned flags )
{
    switch( CSTRINGS & flags )
    {
    case 0:
        return new assert_op<eos_t<CI> >();
    case CSTRINGS:
        return new assert_op<eocs_t<CI> >();
    default:
        __assume(0); // tells the compiler that this is unreachable
    }
}

template< typename CI >
assertion<CI> * create_bol( unsigned flags )
{
    switch( MULTILINE & flags )
    {
    case 0:
        return new assert_op<bos_t<CI> >();
    case MULTILINE:
        return new assert_op<bol_t<CI> >();
    default:
        __assume(0); // tells the compiler that this is unreachable
    }
}

template< typename CI >
assertion<CI> * create_eol( unsigned flags )
{
    switch( ( MULTILINE | CSTRINGS ) & flags )
    {
    case 0:
        return new assert_op<peos_t<CI> >();
    case MULTILINE:
        return new assert_op<eol_t<CI> >();
    case CSTRINGS:
        return new assert_op<peocs_t<CI> >();
    case MULTILINE | CSTRINGS:
        return new assert_op<eocl_t<CI> >();
    default:
        __assume(0); // tells the compiler that this is unreachable
    }
}

template< typename CI >
class match_atom : public sub_expr<CI>
{
public:
    match_atom( const basic_string<sub_expr<CI>::char_type>::iterator istart, 
                basic_string<sub_expr<CI>::char_type>::const_iterator istop ) 
        : m_istart( istart ), m_istop( istop ) {}
    virtual ~match_atom() {}

    const basic_string<sub_expr<CI>::char_type>::iterator m_istart;
    basic_string<sub_expr<CI>::char_type>::const_iterator m_istop;
protected:
    virtual width_type _width_this() throw() 
    { 
        size_t width = distance( (basic_string<sub_expr<CI>::char_type>::const_iterator)m_istart, m_istop ); 
        return width_type( width, width );
    }
};

template< typename EOS >
class match_atom_t : public match_atom<typename EOS::const_iterator>
{
public:
    typedef EOS eos_type;
    typedef typename EOS::const_iterator CI;
    match_atom_t( const basic_string<sub_expr<CI>::char_type>::iterator istart,
                  basic_string<sub_expr<CI>::char_type>::const_iterator istop ) 
        : match_atom<CI>( istart, istop ) {}
    virtual ~match_atom_t() {}
protected:
    virtual bool _match_this( match_param<CI> & param, CI & icur ) const throw()
    {
        CI icur_tmp = icur;
        basic_string<sub_expr<CI>::char_type>::const_iterator ithis = m_istart;
        for( ; ithis != m_istop; ++icur_tmp, ++ithis )
        {
            if( m_eos( param, icur_tmp ) || *ithis != *icur_tmp )
                return false;
        }
        icur = icur_tmp;
        return true;
    }
    eos_type  m_eos;
};

template< typename EOS >
class match_atom_nocase_t : public match_atom<typename EOS::const_iterator>
{
public:
    typedef EOS eos_type;
    typedef typename EOS::const_iterator CI;
    match_atom_nocase_t( const basic_string<sub_expr<CI>::char_type>::iterator istart, 
                         basic_string<sub_expr<CI>::char_type>::const_iterator istop ) 
        : match_atom<CI>( istart, istop ), m_strlower( (basic_string<sub_expr<CI>::char_type>::const_iterator)istart, istop ) 
    {
        // Store the uppercase version of the atom in [m_istart,m_istop).
        to_upper( m_istart, m_istop );
        // Store the lowercase version of the atom in m_strlower.
        to_lower( m_strlower.begin(), m_strlower.end() );
    }
    virtual ~match_atom_nocase_t() {}

protected:
    virtual bool _match_this( match_param<CI> & param, CI & icur ) const throw()
    {
        CI icur_tmp = icur;
        basic_string<sub_expr<CI>::char_type>::const_iterator ithisu   = m_istart;           // uppercase
        basic_string<sub_expr<CI>::char_type>::const_iterator ithisl   = m_strlower.begin(); // lowercase
        for( ; ithisu != m_istop; ++icur_tmp, ++ithisu, ++ithisl )
        {
            if( m_eos( param, icur_tmp ) || ( *ithisu != *icur_tmp && *ithisl != *icur_tmp ) )
                return false;
        }
        icur = icur_tmp;
        return true;
    }
    eos_type                 m_eos;
    basic_string<sub_expr<CI>::char_type>  m_strlower;
};

template< typename CI >
match_atom<CI> * create_atom(
    const basic_string<iterator_traits<CI>::value_type>::iterator istart,
    basic_string<iterator_traits<CI>::value_type>::const_iterator istop, 
    unsigned flags )
{
    switch( ( NOCASE | CSTRINGS ) & flags )
    {
    case 0:
        return new match_atom_t<eos_t<CI> >( istart, istop );
    case NOCASE:
        return new match_atom_nocase_t<eos_t<CI> >( istart, istop );
    case CSTRINGS:
        return new match_atom_t<eocs_t<CI> >( istart, istop );
    case NOCASE | CSTRINGS:
        return new match_atom_nocase_t<eocs_t<CI> >( istart, istop );
    default:
        __assume(0); // tells the compiler that this is unreachable
    }
}

template< typename CI >
match_atom<CI> * create_atom( 
    const basic_string<iterator_traits<CI>::value_type>::iterator istart, 
    unsigned flags )
{
    basic_string<iterator_traits<CI>::value_type>::const_iterator istop = istart;
    return create_atom<CI>( istart, ++istop, flags );
}

template< typename CI >
class match_any : public sub_expr<CI>
{
public:
    virtual ~match_any() {}
protected:
    virtual width_type _width_this() throw() { return width_type(1,1); }
};

template< typename EOS >
class match_any_t : public match_any<typename EOS::const_iterator>
{
public:
    typedef EOS eos_type;
    typedef typename EOS::const_iterator CI;
    virtual ~match_any_t() {}
protected:
    virtual bool _match_this( match_param<CI> & param, CI & icur ) const throw()
    {
        if( m_eos( param, icur ) )
            return false;
        ++icur;
        return true;
    }
    eos_type m_eos;
};

template< typename CI >
match_any<CI> * create_any( unsigned flags ) 
{
    switch( ( SINGLELINE | CSTRINGS ) & flags )
    {
    case 0:
        return new match_any_t<eol_t<CI> >();
    case SINGLELINE:
        return new match_any_t<eos_t<CI> >();
    case CSTRINGS:
        return new match_any_t<eocl_t<CI> >();
    case SINGLELINE | CSTRINGS:
        return new match_any_t<eocs_t<CI> >();
    default:
        __assume(0); // tells the compiler that this is unreachable
    }
}

typedef pair<wint_t,wint_t> range_type;
const vector<range_type> g_rgranges; // empty

template< typename CI >
class match_charset : public sub_expr<CI>
{
public:
    match_charset( bool fcomplement,
                   const ascii_bitvector & bvect )
        : m_fcomplement( fcomplement ),
          m_rgascii( bvect ),
          m_rgranges( g_rgranges ),
          m_ncharflags(0) {}

    // Note that only the references are copied here -- they are not ref counted.
    // Beware of variable lifetime issues.
    match_charset( const match_charset<CI> & that )
        : m_fcomplement( that.m_fcomplement ),
          m_rgascii( that.m_rgascii ),
          m_rgranges( that.m_rgranges ),
          m_ncharflags( that.m_ncharflags ) {}

    virtual ~match_charset() {}

    const bool                 m_fcomplement;
    const ascii_bitvector    & m_rgascii;  // bitmap for chars in range 0-255
    const vector<range_type> & m_rgranges; // vector of included character ranges 256-65535
    int                        m_ncharflags; // Parameter to isctype()

    // The case-sensitivity of a character set is "compiled" into the ascii_bitvector
    // but not into the range vector because it is too computationally expensive. Instead,
    // when doing a unicode case-insensitive match on the ranges vector, two lookups
    // must be performed -- one lowercase and one uppercase. By contrast, only one lookup
    // is needed for the ascii_bitvector.

protected:

    match_charset( bool fcomplement, 
                   const ascii_bitvector & bvect,
                   const vector<range_type> & rgranges )
        : m_fcomplement( fcomplement ),
          m_rgascii( bvect ),
          m_rgranges( rgranges ),
          m_ncharflags(0) {}

    // this method should never be called. match_charset is only a base class
    // for match_charset_t
    virtual bool _match_this( match_param<CI> & param, CI & icur ) const throw()
    {
        assert(false);
        return true;
    }

    template< typename SY >
    match_charset<CI> * get_altern_charset( char_type ch, unsigned flags, SY /*sy*/ ) const throw()
    {
        return basic_rpattern<CI,SY>::s_charset_map.get( ch, flags );
    }
    virtual width_type _width_this() throw() { return width_type(1,1); }
};

// Used as a template parameter to find a unicode character in an array of ranges.
class match_range : public unary_function<wint_t,bool>
{
protected:
    const vector<range_type> & m_rgranges;

    // determines if one range is less then another.
    // used in binary search of range vector
    inline static bool _range_less( const range_type & rg1,
                                    const range_type & rg2 ) throw()
    {
        return rg1.second < rg2.first;
    }

    match_range( const vector<range_type> & rgranges )
        : m_rgranges( rgranges ) {}
};

class match_range_with_case : public match_range
{
public:
    match_range_with_case( const vector<range_type> & rgranges )
        : match_range( rgranges ) {}
    inline bool operator()( wint_t ch ) const throw()
    {
        return binary_search( m_rgranges.begin(), m_rgranges.end(), 
                              range_type(ch,ch), _range_less );
    }
};

class match_range_no_case : public match_range
{
public:
    match_range_no_case( const vector<range_type> & rgranges )
        : match_range( rgranges ) {}
    inline bool operator()( wint_t ch ) const throw()
    {
        const wint_t chup = towupper( ch );
        if( binary_search( m_rgranges.begin(), m_rgranges.end(), 
                           range_type(chup,chup), _range_less ) )
            return true;

        const wint_t chlo = towlower( ch );
        if( chup != chlo &&
            binary_search( m_rgranges.begin(), m_rgranges.end(), 
                           range_type(chlo,chlo), _range_less ) )
            return true;

        return false;    
    }
};

template< typename EOS, typename RGM >
class match_charset_t : public match_charset<typename EOS::const_iterator>
{
public:
    typedef EOS eos_type;
    typedef RGM range_match_type;
    typedef typename EOS::const_iterator CI;

    match_charset_t( const match_charset<CI> & that )
        : match_charset<CI>( that ), m_rgm( m_rgranges ) {}
    virtual ~match_charset_t() {}

    inline bool is_in_charset( char_type ch ) const throw()
    {
        return m_fcomplement != _is_in_charset( ch );
    }

protected:
    match_charset_t( bool fcomplement,
                     const ascii_bitvector & bvect,
                     const vector<range_type> & rgranges )
        : match_charset<CI>( fcomplement, bvect, rgranges ), m_rgm( m_rgranges ) {}

    // Note overloading based on parameter
    inline bool _is_in_charset( char ch ) const throw()
    {
        return ( m_rgascii[ unsigned char(ch) ] ) || 
               ( m_ncharflags && ( _pctype[unsigned char(ch)] & m_ncharflags ) );
    }

    // Note overloading based on parameter
    inline bool _is_in_charset( wint_t ch ) const throw()
    {
        if( UCHAR_MAX >= ch )
            return _is_in_charset( char(ch) );

        // use range_match_type to see if this character is within one of the
        // ranges stored in m_rgranges.
        return ( ! m_rgranges.empty() && m_rgm( ch ) ) || 
               ( m_ncharflags && iswctype( ch, (int)m_ncharflags ) );
    }

    virtual bool _match_this( match_param<CI> & param, CI & icur ) const throw()
    {
        if( m_eos( param, icur ) || ! is_in_charset( *icur ) )
            return false;
        ++icur;
        return true;
    }

    // range_match_type encapsulates the case-sensitivity
    // issues with doing a unicode lookup on the ranges vector.
    range_match_type m_rgm;
    eos_type         m_eos;
};

template< typename EOS, typename RGM >
class match_custom_charset_t : public match_charset_t<EOS,RGM>
{
public:
    template< typename SY >
    match_custom_charset_t( bool fcomplement,
                            basic_string<char_type>::iterator & icur,
                            basic_string<char_type>::const_iterator istop,
                            unsigned flags, SY /*sy*/ ) throw(bad_regexpr,bad_alloc)
        : match_charset_t<EOS,RGM>( fcomplement, m_rgasciicustom, m_rgrangescustom )
    {
        _parse_charset( icur, istop, flags, SY() );
        _optimize();
    }

    virtual ~match_custom_charset_t() {}
    
    // for including one character set in another
    match_custom_charset_t<EOS,RGM> & operator|=( const match_charset<CI> & that )
    {
        assert( 0 == that.m_ncharflags );
        if( that.m_fcomplement )
        {
            m_rgasciicustom |= ~ that.m_rgascii;
            
            // append the inverse of that.m_rgranges to this->m_rgrangescustom
            wint_t chlow = UCHAR_MAX;
            typedef vector<range_type>::const_iterator VCI;
            for( VCI prg = that.m_rgranges.begin(); prg != that.m_rgranges.end(); ++prg )
            {
                if( UCHAR_MAX + 1 != prg->first )
                    m_rgrangescustom.push_back( range_type( chlow + 1, prg->first - 1 ) );
                chlow = prg->second;
            }
            if( WCHAR_MAX != chlow )
                m_rgrangescustom.push_back( range_type( chlow + 1, WCHAR_MAX ) );
        }
        else
        {
            m_rgasciicustom |= that.m_rgascii;
            m_rgrangescustom.insert( m_rgrangescustom.end(),
                                     that.m_rgranges.begin(), 
                                     that.m_rgranges.end() );
        }
        return *this;
    }

protected:

    template< typename SY >
    void _parse_charset( basic_string<char_type>::iterator & icur,
                         basic_string<char_type>::const_iterator istop,
                         unsigned flags, SY /*sy*/ ) throw(bad_regexpr,bad_alloc)
    {
        TOKEN tok;
        char_type ch_prev = 0;
        match_charset<CI> * pcharset;
        basic_string<char_type>::iterator iprev = icur;
        const bool fnocase = ( NOCASE == ( NOCASE & flags ) );

        if( (basic_string<char_type>::const_iterator)icur == istop )
            throw bad_regexpr("expecting end of character set");

        // remember the current position and grab the next token
        tok = SY::charset_token( icur, istop );
        do
        {
            // If we reached the end of the string before finding the end of the
            // character set, then this is an ill-formed regex
            if( (basic_string<char_type>::const_iterator)icur == istop )
                throw bad_regexpr("expecting end of character set");

            if( CHARSET_RANGE == tok && ch_prev )
            {
                // remember the current position
                basic_string<char_type>::iterator iprev2 = icur;
                char_type old_ch = ch_prev;
                ch_prev = 0;

                // old_ch is lower bound of a range
                switch( SY::charset_token( icur, istop ) )
                {
                case CHARSET_RANGE:
                case CHARSET_NEGATE:
                    icur = iprev2; // un-get these tokens and fall through
                case NO_TOKEN:
                case CHARSET_ESCAPE: // BUGBUG user-defined charset?
                    _set_bit_range( old_ch, *icur++, fnocase );
                    continue;
                case CHARSET_BACKSPACE:
                    _set_bit_range( old_ch, char_type(8), fnocase ); // backspace
                    continue;
                case CHARSET_END: // fall through
                default:          // not a range.
                    icur = iprev; // backup to range token
                    _set_bit( old_ch, fnocase );
                    _set_bit( *icur++, fnocase );
                    continue;
                }
            }

            if( ch_prev )
                _set_bit( ch_prev, fnocase );
            ch_prev = 0;

            switch( tok )
            {
            // None of the intrinsic charsets are case-sensitive,
            // so no special handling must be done when the NOCASE 
            // flag is set.
            case CHARSET_RANGE:
            case CHARSET_NEGATE:
            case CHARSET_END:
                icur = iprev; // un-get these tokens
                ch_prev = *icur++;
                continue;
            case CHARSET_BACKSPACE:
                ch_prev = char_type(8); // backspace
                continue;
            case ESC_DIGIT:
                *this |= match_charset<CI>( false, get_digit_vector() );
                continue;
            case ESC_NOT_DIGIT:
                *this |= match_charset<CI>( true,  get_digit_vector() );
                continue;
            case ESC_SPACE:
                *this |= match_charset<CI>( false, get_space_vector() );
                continue;
            case ESC_NOT_SPACE:
                *this |= match_charset<CI>( true,  get_space_vector() );
                continue;
            case ESC_WORD:
                *this |= match_charset<CI>( false, get_word_vector() );
                continue;
            case ESC_NOT_WORD:
                *this |= match_charset<CI>( true,  get_word_vector() );
                continue;
            case CHARSET_ALNUM:
                m_ncharflags |= (_ALPHA|_DIGIT);
                continue;
            case CHARSET_ALPHA:
                m_ncharflags |= (_ALPHA);
                continue;
            case CHARSET_BLANK:
                m_ncharflags |= (_BLANK);
                continue;
            case CHARSET_CNTRL:
                m_ncharflags |= (_CONTROL);
                continue;
            case CHARSET_DIGIT:
                m_ncharflags |= (_DIGIT);
                continue;
            case CHARSET_GRAPH:
                m_ncharflags |= (_PUNCT|_ALPHA|_DIGIT);
                continue;
            case CHARSET_LOWER:
                m_ncharflags |= (_LOWER);
                if( NOCASE == ( NOCASE & flags ) )
                    m_ncharflags |= (_UPPER);
                continue;
            case CHARSET_PRINT:
                m_ncharflags |= (_BLANK|_PUNCT|_ALPHA|_DIGIT);
                continue;
            case CHARSET_PUNCT:
                m_ncharflags |= (_PUNCT);
                continue;
            case CHARSET_SPACE:
                m_ncharflags |= (_SPACE);
                continue;
            case CHARSET_UPPER:
                m_ncharflags |= (_UPPER);
                if( NOCASE == ( NOCASE & flags ) )
                    m_ncharflags |= (_LOWER);
                continue;
            case CHARSET_XDIGIT:
                m_ncharflags |= (_HEX);
                continue;
            case CHARSET_ESCAPE:
                // Maybe this is a user-defined intrinsic charset
                pcharset = get_altern_charset( *icur, flags, SY() );
                if( NULL != pcharset )
                {
                    *this |= *pcharset;
                    ++icur;
                    continue;
                }
                // else fall through
            default:
                ch_prev = *icur++;
                continue;
            }
        }
        while( iprev = icur, CHARSET_END != ( tok = SY::charset_token( icur, istop ) ) );

        if( ch_prev )
            _set_bit( ch_prev, fnocase );
    }

    void _optimize()
    {
        // this sorts on range_type.first (uses operator<() for pair templates)
        sort( m_rgrangescustom.begin(), m_rgrangescustom.end() ); 
        
        // This merges ranges that overlap
        for( size_t index = 1; index < m_rgrangescustom.size(); )
        {
            if( m_rgrangescustom[index].first <= m_rgrangescustom[index-1].second + 1 )
            {
                m_rgrangescustom[index-1].second = max( 
                    m_rgrangescustom[index-1].second, m_rgrangescustom[index].second );
                m_rgrangescustom.erase( m_rgrangescustom.begin() + index );
            }
            else
                ++index;
        }
    }

    // Note overloading based on second parameter
    void _set_bit( char ch, const bool fnocase ) throw()
    { 
        if( fnocase )
        {
            m_rgasciicustom.set( unsigned char(tolower(ch)) );
            m_rgasciicustom.set( unsigned char(toupper(ch)) );
        }
        else
        {
            m_rgasciicustom.set( unsigned char(ch) ); 
        }
    }

    // Note overloading based on second parameter
    void _set_bit( wint_t ch, const bool fnocase ) throw(bad_alloc)
    { 
        if( UCHAR_MAX >= ch )
            _set_bit( char(ch), fnocase );
        else
            m_rgrangescustom.push_back( range_type( ch, ch ) ); 
    }

    // Note overloading based on second parameter
    void _set_bit_range( char ch1, char ch2, const bool fnocase ) throw(bad_regexpr)
    {
        if( unsigned char(ch1) > unsigned char(ch2) )
            throw bad_regexpr("invalid range specified in character set");

        if( fnocase )
        {
            // i is unsigned int to prevent overflow if ch2 is UCHAR_MAX
            for( unsigned int i = unsigned char(ch1); i <= unsigned char(ch2); ++i )
            {
                m_rgasciicustom.set( unsigned char( toupper(i) ) );
                m_rgasciicustom.set( unsigned char( tolower(i) ) );
            }
        }
        else
        {
            // i is unsigned int to prevent overflow if ch2 is UCHAR_MAX
            for( unsigned int i = unsigned char(ch1); i <= unsigned char(ch2); ++i )
                m_rgasciicustom.set( unsigned char(i) );
        }
    }

    // Note overloading based on second parameter
    void _set_bit_range( wint_t ch1, wint_t ch2, const bool fnocase ) throw(bad_regexpr,bad_alloc)
    {
        if( ch1 > ch2 )
            throw bad_regexpr("invalid range specified in character set");

        if( UCHAR_MAX >= ch1 )
            _set_bit_range( char(ch1), char( min(wint_t(UCHAR_MAX),ch2) ), fnocase );

        if( UCHAR_MAX < ch2 )
            m_rgrangescustom.push_back( range_type( max(wint_t(UCHAR_MAX+1),ch1), ch2 ) );
    }

    ascii_bitvector    m_rgasciicustom;
    vector<range_type> m_rgrangescustom;
};


template< typename CI >
match_charset<CI> * create_charset( 
    const match_charset<CI> & that,
    unsigned flags )
{
    switch( ( NOCASE | CSTRINGS ) & flags )
    {
    case 0:
        return new match_charset_t<eos_t<CI>,match_range_with_case>( that );
    case NOCASE:
        return new match_charset_t<eos_t<CI>,match_range_no_case>( that );
    case CSTRINGS:
        return new match_charset_t<eocs_t<CI>,match_range_with_case>( that );
    case NOCASE | CSTRINGS:
        return new match_charset_t<eocs_t<CI>,match_range_no_case>( that );
    default:
        __assume(0); // tells the compiler that this is unreachable
    }
}

template< typename EOS >
class word_assertion_t : public assertion<typename EOS::const_iterator>
{
public:
    typedef EOS eos_type;
    typedef typename EOS::const_iterator CI;
    word_assertion_t() 
        : m_isword( match_charset<CI>( false, get_word_vector() ) ) {}
    virtual ~word_assertion_t() {}
protected:
    bos_t<CI>  m_bos;
    eos_type   m_eos;
    match_charset_t<eos_type,match_range_with_case> m_isword;
};

template< typename EOS >
class word_boundary_t : public word_assertion_t<EOS>
{
public:
    word_boundary_t( const bool fisboundary ) 
        : m_fisboundary( fisboundary ) {}
    virtual ~word_boundary_t() {}
protected:
    virtual bool _match_this( match_param<CI> & param, CI & icur ) const throw()
    {
        CI iprev = icur;
        --iprev;

        const bool fprevword = ! m_bos( param, icur ) && m_isword.is_in_charset( *iprev );
        const bool fthisword = ! m_eos( param, icur ) && m_isword.is_in_charset( *icur  );

        return ( m_fisboundary == ( fprevword != fthisword ) );
    }
    const bool m_fisboundary;
};

template< typename EOS >
class word_start_t : public word_assertion_t<EOS>
{
public:
    word_start_t() {}
    virtual ~word_start_t() {}
protected:
    virtual bool _match_this( match_param<CI> & param, CI & icur ) const throw()
    {
        CI iprev = icur;
        --iprev;

        const bool fprevword = ! m_bos( param, icur ) && m_isword.is_in_charset( *iprev );
        const bool fthisword = ! m_eos( param, icur ) && m_isword.is_in_charset( *icur  );

        return ! fprevword && fthisword;
    }
};

template< typename EOS >
class word_stop_t : public word_assertion_t<EOS>
{
public:
    word_stop_t() {}
    virtual ~word_stop_t() {}
protected:
    virtual bool _match_this( match_param<CI> & param, CI & icur ) const throw()
    {
        CI iprev = icur;
        --iprev;

        const bool fprevword = ! m_bos( param, icur ) && m_isword.is_in_charset( *iprev );
        const bool fthisword = ! m_eos( param, icur ) && m_isword.is_in_charset( *icur  );

        return fprevword && ! fthisword;
    }
};

template< typename CI >
assertion<CI> * create_word_boundary( const bool fisboundary, unsigned flags )
{
    switch( CSTRINGS & flags )
    {
    case 0:
        return new word_boundary_t<eos_t<CI> >( fisboundary );
    case CSTRINGS:
        return new word_boundary_t<eocs_t<CI> >( fisboundary );
    default:
        __assume(0); // tells the compiler that this is unreachable
    }
}

template< typename CI >
assertion<CI> * create_word_start( unsigned flags )
{
    switch( CSTRINGS & flags )
    {
    case 0:
        return new word_start_t<eos_t<CI> >();
    case CSTRINGS:
        return new word_start_t<eocs_t<CI> >();
    default:
        __assume(0); // tells the compiler that this is unreachable
    }
}

template< typename CI >
assertion<CI> * create_word_stop( unsigned flags )
{
    switch( CSTRINGS & flags )
    {
    case 0:
        return new word_stop_t<eos_t<CI> >();
    case CSTRINGS:
        return new word_stop_t<eocs_t<CI> >();
    default:
        __assume(0); // tells the compiler that this is unreachable
    }
}

template< typename CI > class group_quantifier;

template< typename CI >
class match_group : public sub_expr<CI>
{
public:
    friend class group_quantifier<CI>;

    match_group( size_t cgroup )
        : m_rgalternates(), m_cgroup( cgroup ),
          m_pptail(NULL), m_end_group( this ), m_nwidth(uninit_width) {}

    virtual ~match_group() {}

    virtual bool domatch( match_param<CI> & param, CI icur ) const throw()
    {
        CI old_istart;
        
        if( -1 != m_cgroup ) // could be -1 if this is a lookahead_assertion
        {
            old_istart = (*param.prgbackrefs)[ m_cgroup ].first;
            (*param.prgbackrefs)[ m_cgroup ].first = icur;
        }

        typedef vector<sub_expr<CI>*>::const_iterator VCI;
        for( VCI ialt = m_rgalternates.begin(); ialt != m_rgalternates.end(); ++ialt )
        {
            if( (*ialt)->domatch( param, icur ) )
                return true;
        }

        if( -1 != m_cgroup )
            (*param.prgbackrefs)[ m_cgroup ].first = old_istart;

        return false;
    }
    
    virtual void _delete()
    {
        typedef vector<sub_expr<CI>*>::iterator VI;
        for( VI ialt = m_rgalternates.begin(); ialt != m_rgalternates.end(); ++ialt )
            delete_sub_expr( *ialt );
        sub_expr<CI>::_delete();
    }

    size_t group_number() const 
    { 
        return m_cgroup; 
    }

    void group_number( size_t cgroup ) 
    { 
        m_cgroup = cgroup; 
    }

    void add_item( sub_expr<CI> * pitem )
    {
        *m_pptail = pitem;
        m_pptail = & pitem->next();
    }

    void add_alternate()
    {
        m_rgalternates.push_back( NULL );
        m_pptail = & m_rgalternates.back();
    }

    void end_alternate()
    {
        *m_pptail = & m_end_group;
    }

    size_t calternates() const 
    {
        return m_rgalternates.size();
    }

    width_type group_width()
    {
        (void) match_group<CI>::_width_this();
        return m_nwidth;
    }

protected:

    virtual bool _call_back( match_param<CI> & param, CI icur ) const throw()
    {
        CI old_iend;

        if( -1 != m_cgroup )
        {
            old_iend = (*param.prgbackrefs)[ m_cgroup ].second;
            (*param.prgbackrefs)[ m_cgroup ].second = icur;
        }

        if( match_next( param, icur ) )
            return true;

        if( -1 != m_cgroup )
            (*param.prgbackrefs)[ m_cgroup ].second = old_iend;

        return false;
    }

    virtual width_type _width_this() throw()
    {
        typedef vector<sub_expr<CI>*>::const_iterator VCI;
        if( uninit_width == m_nwidth )
        {
            m_nwidth = width_type(-1,0);
            for( VCI ialt = m_rgalternates.begin(); worst_width != m_nwidth && ialt != m_rgalternates.end(); ++ialt )
            {
                width_type temp_width = (*ialt)->get_width();
                m_nwidth.m_min = min( m_nwidth.m_min, temp_width.m_min );
                m_nwidth.m_max = max( m_nwidth.m_max, temp_width.m_max );
            }
        }
        return m_nwidth;
    }

    class end_group;
    friend class end_group;
    class end_group : public sub_expr<CI>
    {
        void * operator new( size_t );
    public:
        end_group( match_group * pgroup ) 
            : m_pgroup( pgroup ) {}
        virtual ~end_group() {}
        virtual void _delete() {} // don't delete this, because it was never alloc'ed

        virtual bool domatch( match_param<CI> & param, CI icur ) const throw()
        {
            return m_pgroup->_call_back( param, icur );
        }
    protected:
        // since m_pnext is always NULL for end_groups, get_width() stops recursing here
        virtual width_type _width_this() throw() 
        {
            return width_type(0,0); 
        }
        match_group<CI> * m_pgroup;
    };

    vector<sub_expr<CI>*> m_rgalternates;
    sub_expr<CI>       ** m_pptail; // only used when adding elements
    size_t                m_cgroup;
    end_group             m_end_group;
    width_type            m_nwidth;
};

// Behaves like a lookahead assertion if m_cgroup is -1, or like
// an independent group otherwise.
template< typename CI >
class independent_group : public match_group<CI>
{
public:
    independent_group() 
        : match_group<CI>( -1 ), m_fexpected(true) {}
    virtual ~independent_group() {}

    virtual bool domatch( match_param<CI> & param, CI icur ) const throw()
    {
        // Copy the entire backref vector onto the stack
        backref_tag<CI> * prgbr =  (backref_tag<CI>*)_alloca( param.prgbackrefs->size() * sizeof backref_tag<CI> );
        copy( param.prgbackrefs->begin(), param.prgbackrefs->end(), 
              raw_storage_iterator<backref_tag<CI>*,backref_tag<CI> >(prgbr) );

        // Match until the end of this group and then return
        const bool fdomatch = match_group<CI>::domatch( param, icur );

        if( m_fexpected == fdomatch )
        {
            // If m_cgroup != 1, then this is not a zero-width assertion.
            if( -1 != m_cgroup )
                icur = (*param.prgbackrefs)[ m_cgroup ].second;

            if( match_next( param, icur ) )
                return true;
        }

        // if match_group::domatch returned true, the backrefs must be restored
        if( fdomatch )
            copy( prgbr, prgbr + param.prgbackrefs->size(), param.prgbackrefs->begin() );

        return false;
    }

protected:

    independent_group( const bool fexpected ) 
        : match_group<CI>( -1 ), m_fexpected(fexpected) {}

    virtual bool _call_back( match_param<CI> & param, CI icur ) const throw()
    {
        if( -1 != m_cgroup )
            (*param.prgbackrefs)[ m_cgroup ].second = icur;
        return true;
    }

    const bool m_fexpected;
};

template< typename CI >
class lookahead_assertion : public independent_group<CI>
{
public:
    lookahead_assertion( const bool fexpected )
        : independent_group<CI>( fexpected ) {}
    virtual ~lookahead_assertion() {}
    virtual bool is_assertion() const throw() { return true; }
protected:
    virtual width_type _width_this() throw() { return width_type(0,0); }
};

template< typename CI >
class lookbehind_assertion : public independent_group<CI>
{
public:
    lookbehind_assertion( const bool fexpected )
        : independent_group<CI>( fexpected ) {}
    virtual ~lookbehind_assertion() {}

    virtual bool domatch( match_param<CI> & param, CI icur ) const throw()
    {
        // This is the room in the string from the start to the current position
        size_t room = distance( param.ibegin, icur );

        // If we don't have enough room to match the lookbehind, the match fails.
        // If we wanted the match to fail, try to match the rest of the pattern.
        if( m_nwidth.m_min > room )
            return m_fexpected ? false : match_next( param, icur );

        // Copy the entire backref vector onto the stack
        backref_tag<CI> * prgbr = (backref_tag<CI>*)_alloca( param.prgbackrefs->size() * sizeof backref_tag<CI> );
        copy( param.prgbackrefs->begin(), param.prgbackrefs->end(), 
              raw_storage_iterator<backref_tag<CI>*,backref_tag<CI> >(prgbr) );

        CI local_istart  = icur;
        advance( local_istart, -int( min( m_nwidth.m_max, room ) ) );

        CI local_istop = icur;
        advance( local_istop, -int( m_nwidth.m_min ) );

        // Create a local param struct that has icur as param.iend
        match_param<CI> local_param(param.ibegin,param.istart,icur,param.prgbackrefs);

        // Find the rightmost match that ends at icur.
        for( CI local_icur = local_istart; local_icur <= local_istop; ++local_icur )
        {
            // Match until the end of this group and then return
            const bool fmatched = match_group<CI>::domatch( local_param, local_icur );

            // If the match results were what we were expecting, try to match the
            // rest of the pattern. If that succeeds, return true.
            if( m_fexpected == fmatched && match_next( param, icur ) )
                return true;

            // if match_group::domatch returned true, the backrefs must be restored
            if( fmatched )
            {
                copy( prgbr, prgbr + param.prgbackrefs->size(), param.prgbackrefs->begin() );

                // Match succeeded. If this is a negative lookbehind, we didn't want it
                // to succeed, so return false.
                if( ! m_fexpected )
                    return false;
            }
        }

        // No variation of the lookbehind was satisfied in a way that permited
        // the rest of the pattern to match successfully, so return false.
        return false;
    }
    virtual bool is_assertion() const throw() { return true; }
protected:
    virtual bool _call_back( match_param<CI> & param, CI icur ) const throw()
    {
        return param.istop == icur;
    }
    virtual width_type _width_this() throw() { return width_type(0,0); }
};

// Corresponds to the (?:foo) extension, which has grouping semantics, but 
// does not store any backref information.
template< typename CI >
class group_nobackref : public match_group<CI>
{
public:
    group_nobackref( ) 
        : match_group( -1 ) {} // will be assigned a group number in basic_rpattern::basic_rpattern()
    virtual ~group_nobackref() {}
};

template< typename CI >
class match_wrapper : public sub_expr<CI>
{
public:
    match_wrapper( sub_expr<CI> * psub ) 
        : m_psub(psub) {}
    virtual ~match_wrapper() {}

    virtual void _delete()
    {
        delete_sub_expr( m_psub );
        sub_expr<CI>::_delete();
    }

protected:

    bool _wrapped_match_this( match_param<CI> & param, CI & icur ) const throw()
    {
        return m_psub->_match_this( param, icur );
    }
    
    virtual width_type _width_this() throw()
    {
        return m_psub->_width_this();
    }

    sub_expr<CI> * m_psub;
};

template< typename CI >
class match_quantifier : public match_wrapper<CI>
{
public:    
    match_quantifier( sub_expr<CI> * psub, size_t lbound, size_t ubound ) 
        : match_wrapper<CI>( psub ), m_lbound(lbound), m_ubound(ubound) {}

    virtual ~match_quantifier() {}

protected:

    virtual width_type _width_this() throw()
    {
        width_type this_width = match_wrapper<CI>::_width_this();

        return this_width * width_type( m_lbound, m_ubound );
    }

    const size_t m_lbound;
    const size_t m_ubound;
};

template< typename CI >
class max_atom_quantifier : public match_quantifier<CI>
{
public:
    max_atom_quantifier( sub_expr<CI> * psub, size_t lbound, size_t ubound ) 
        : match_quantifier<CI>( psub, lbound, ubound ) {}

    virtual ~max_atom_quantifier() {}

    virtual bool domatch( match_param<CI> & param, CI icur ) const throw()
    {
        size_t cmatches = 0;
        int    cdiff    = 0; // must be a signed quantity for advance() below

        if( cmatches < m_ubound )
        {
            CI istart = icur;
            if( _wrapped_match_this( param, icur ) )
            {
                ++cmatches;
                cdiff = distance( istart, icur );
            
                if( 0 == cdiff )
                    return ( match_next( param, icur ) );

                while( cmatches < m_ubound && 
                       _wrapped_match_this( param, icur ) )
                {
                    ++cmatches;
                }
            }
        }

        if( cmatches >= m_lbound )
        {
            if( ! next() )
                return true;
    
            for(;;)
            {
                if( next()->domatch( param, icur ) )
                    return true;
                
                if( cmatches-- <= m_lbound )
                    break;
                
                advance( icur, -cdiff );
            }
        }

        return false;
    }
};

template< typename CI >
class min_atom_quantifier : public match_quantifier<CI>
{
public:    
    min_atom_quantifier( sub_expr<CI> * psub, size_t lbound, size_t ubound ) 
        : match_quantifier<CI>( psub, lbound, ubound ) {}

    virtual ~min_atom_quantifier() {}

    virtual bool domatch( match_param<CI> & param, CI icur ) const throw()
    {
        size_t cmatches = 0;
        bool   fsuccess = true;
        CI icur_tmp = icur;

        if( _wrapped_match_this( param, icur_tmp ) )
        {
            if( icur_tmp == icur )
                return ( match_next( param, icur ) );

            if( m_lbound )
            {
                icur = icur_tmp;
                ++cmatches;
            }
            
            while( ( cmatches < m_lbound ) &&
                   ( fsuccess = _wrapped_match_this( param, icur ) ) )
            {
                ++cmatches;
            }
        }
        else
        {
            fsuccess = ! m_lbound;
        }

        if( fsuccess && next() )
        {
            do
            {
                if( next()->domatch( param, icur ) )
                    break;
            } while( fsuccess = ( cmatches++ < m_ubound && 
                                  _wrapped_match_this( param, icur ) ) );
        }

        return fsuccess;
    }
};

template< typename CI >
class group_quantifier : public match_quantifier<CI>
{
public:
    
    group_quantifier( match_group<CI> * psub, size_t lbound, size_t ubound ) 
        : match_quantifier<CI>( psub, lbound, ubound ),
          m_group( *psub ), m_end_quantifier( this )
    {
        psub->next() = & m_end_quantifier;
    }

    virtual ~group_quantifier() {}

    virtual bool domatch( match_param<CI> & param, CI icur ) const throw()
    {
        // group_number is only -1 for assertions, which can't be quantified
        assert( -1 != group_number() );

        backref_tag<CI> & br = (*param.prgbackrefs)[ group_number() ];
        backref_tag<CI> old_backref = br;
        br = backref_tag<CI>( icur, icur ); // sets cmatches (reserved) to 0

        if( _recurse( param, icur ) )
            return true;

        br = old_backref;
        return false;
    }

protected:

    class end_quantifier;
    friend class end_quantifier;
    class end_quantifier : public sub_expr<CI>
    {
        void * operator new( size_t );
    public:
        end_quantifier( group_quantifier<CI> * pquant ) 
            : m_pquant( pquant ) {}

        virtual ~end_quantifier() {}
        virtual void _delete() {} // don't delete this, since it wasn't alloc'ed
        
        virtual bool domatch( match_param<CI> & param, CI icur ) const throw()
        {
            // group_number is only -1 for assertions, which can't be quantified
            assert( -1 != m_pquant->group_number() );

            // handle special the case where a group matches 0 characters
            backref_tag<CI> & br = (*param.prgbackrefs)[ m_pquant->group_number() ];
            if( icur == br.first )
            {
                size_t old_cmatches = br.reserved;
                br.reserved = m_pquant->m_ubound;
                if( m_pquant->_recurse( param, icur ) )
                    return true;
                br.reserved = old_cmatches;
                return false;
            }
            return m_pquant->_recurse( param, icur );
        }

    protected:
        virtual width_type _width_this() throw() { return width_type(0,0); }
        group_quantifier<CI>             * m_pquant;
    };

    size_t group_number() const 
    { 
        return m_group.group_number(); 
    }

    size_t & cmatches( match_param<CI> & param ) const 
    { 
        return (*param.prgbackrefs)[ group_number() ].reserved; 
    }

    virtual bool _recurse( match_param<CI> & param, CI icur )  const throw() = 0;

    match_group<CI> & m_group;
    end_quantifier    m_end_quantifier;
};

template< typename CI >
class max_group_quantifier : public group_quantifier<CI>
{
public:
    max_group_quantifier( match_group<CI> * psub, size_t lbound, size_t ubound ) 
        : group_quantifier<CI>( psub, lbound, ubound ) {}

    virtual ~max_group_quantifier() {}

protected:

    virtual bool _recurse( match_param<CI> & param, CI icur ) const throw()
    {
        if( m_ubound == cmatches( param ) )
            return match_next( param, icur );

        ++cmatches( param );
        if( m_psub->domatch( param, icur ) )
            return true;

        if( --cmatches( param ) < m_lbound )
            return false;

        return match_next( param, icur );
    }
};

template< typename CI >
class min_group_quantifier : public group_quantifier<CI>
{
public:
    min_group_quantifier( match_group<CI> * psub, size_t lbound, size_t ubound ) 
        : group_quantifier<CI>( psub, lbound, ubound ) {}

    virtual ~min_group_quantifier() {}

protected:

    virtual bool _recurse( match_param<CI> & param, CI icur ) const throw()
    {
        if( m_lbound > cmatches( param ) )
        {
            ++cmatches( param );
            return m_psub->domatch( param, icur );
        }

        if( match_next( param, icur ) )
            return true;

        if( cmatches( param )++ == m_ubound )
            return false;
            
        return m_psub->domatch( param, icur );
    }
};

template< typename CI >
class match_backref : public sub_expr<CI>
{
public:
    match_backref( size_t cbackref, const width_type & group_width ) 
        : m_cbackref( cbackref ), m_nwidth(group_width) {}
    virtual ~match_backref() {}
protected:
    // Return the width specifications of the group to which this backref refers
    virtual width_type _width_this() throw() { return m_nwidth; }
    const size_t m_cbackref;
    const width_type m_nwidth;
};

template< typename CMP, typename EOS >
class match_backref_t : public match_backref<typename EOS::const_iterator>
{
public:
    typedef CMP cmp_type;
    typedef EOS eos_type;
    typedef typename EOS::const_iterator CI;
    match_backref_t( size_t cbackref, const width_type & group_width ) 
        : match_backref<CI>( cbackref, group_width ) {}
    virtual ~match_backref_t() {}
protected:
    virtual bool _match_this( match_param<CI> & param, CI & icur ) const throw()
    {
        CI ithis     = (*param.prgbackrefs)[ m_cbackref ].first;
        CI istop     = (*param.prgbackrefs)[ m_cbackref ].second;
        CI icur_tmp  = icur;

        // Don't match a backref that hasn't match anything
        if( ! (*param.prgbackrefs)[ m_cbackref ] )
            return false;

        for( ; ithis != istop; ++icur_tmp, ++ithis )
        {
            if( m_eos( param, icur_tmp ) || m_cmp( *icur_tmp, *ithis ) )
                return false;
        }
        icur = icur_tmp;
        return true;
    }
    cmp_type m_cmp;
    eos_type m_eos;
};

template< typename CI >
match_backref<CI> * create_backref( 
    size_t cbackref, 
    const width_type & group_width, 
    unsigned flags ) 
{
    typedef typename iterator_traits<CI>::value_type char_type;

    switch( ( NOCASE | CSTRINGS ) & flags )
    {
    case 0:
        return new match_backref_t<ch_neq_t<char_type>,eos_t<CI> >( cbackref, group_width );
    case NOCASE:
        return new match_backref_t<ch_neq_nocase_t<char_type>,eos_t<CI> >( cbackref, group_width );
    case CSTRINGS:
        return new match_backref_t<ch_neq_t<char_type>,eocs_t<CI> >( cbackref, group_width );
    case NOCASE | CSTRINGS:
        return new match_backref_t<ch_neq_nocase_t<char_type>,eocs_t<CI> >( cbackref, group_width );
    default:
        __assume(0); // tells the compiler that this is unreachable
    }
}

// Replace some escape sequences with the actual characters
// they represent
template< typename CI >
void basic_rpattern_base<CI>::_normalize_string( basic_string<basic_rpattern_base<CI>::char_type> & str )
{
    size_t i = 0;

    // Don't do pattern normalization if the user didn't ask for it.
    if( NORMALIZE != ( NORMALIZE & m_flags ) )
        return;

    while( basic_string<char_type>::npos != ( i = str.find( char_type('\\'), i ) ) )
    {
        if( str.size() - 1 == i )
            return;

        switch( str[i+1] )
        {
        case char_type('f'):
            str.replace( i, 2, 1, char_type('\f') );
            break;
        case char_type('n'):
            str.replace( i, 2, 1, char_type('\n') );
            break;
        case char_type('r'):
            str.replace( i, 2, 1, char_type('\r') );
            break;
        case char_type('t'):
            str.replace( i, 2, 1, char_type('\t') );
            break;
        case char_type('v'):
            str.replace( i, 2, 1, char_type('\v') );
            break;
        case char_type('\\'):
            str.replace( i, 2, 1, char_type('\\') );
            break;
        default:
            ++i;
            break;
        }
        ++i;
        if( str.size() <= i )
            return;
    }
}

//
// Implementation of basic_rpattern:
//
template< typename CI, typename SY >
basic_rpattern<CI,SY>::basic_rpattern() throw()
    : basic_rpattern_base<CI>( 0 )
{
}

template< typename CI, typename SY >
basic_rpattern<CI,SY>::basic_rpattern( 
    const basic_string<basic_rpattern<CI,SY>::char_type> & pat, 
    unsigned flags ) throw(bad_regexpr,bad_alloc)
    : basic_rpattern_base<CI>( flags, pat )
{
    push_new_handler pnh( &my_new_handler );
    _normalize_string( m_pat );
    _common_init( flags );
}

template< typename CI, typename SY >
basic_rpattern<CI,SY>::basic_rpattern( 
    const basic_string<basic_rpattern<CI,SY>::char_type> & pat, 
    const basic_string<basic_rpattern<CI,SY>::char_type> & subst, 
    unsigned flags ) throw(bad_regexpr,bad_alloc)
    : basic_rpattern_base<CI>( flags, pat, subst )
{
    push_new_handler pnh( &my_new_handler );
    _normalize_string( m_pat );
    _common_init( flags );
    _normalize_string( m_subst );    
    _parse_subst(); // must come after _common_init
}

template< typename CI, typename SY >
void basic_rpattern<CI,SY>::init( 
    const basic_string<basic_rpattern<CI,SY>::char_type> & pat, 
    unsigned flags ) throw(bad_regexpr,bad_alloc)
{
    push_new_handler pnh( &my_new_handler );
    _reset();
    m_flags = flags;
    m_pat   = pat;
    _normalize_string( m_pat );
    _common_init( m_flags );
}

template< typename CI, typename SY >
void basic_rpattern<CI,SY>::init(
    const basic_string<basic_rpattern<CI,SY>::char_type> & pat, 
    const basic_string<basic_rpattern<CI,SY>::char_type> & subst, 
    unsigned flags ) throw(bad_regexpr,bad_alloc)
{
    push_new_handler pnh( &my_new_handler );
    _reset();
    m_flags = flags;
    m_pat   = pat;
    m_subst = subst;
    _normalize_string( m_pat );
    _common_init( m_flags );
    _normalize_string( m_subst );    
    _parse_subst(); // must come after _common_init
}

template< typename CI, typename SY >
void basic_rpattern<CI,SY>::_common_init( unsigned flags )
{
    m_cgroups = 0;
    vector<match_group<CI>*> rggroups;
    basic_string<char_type>::iterator ipat = m_pat.begin();
    match_group<CI> * pgroup = _find_next_group( ipat, flags, rggroups );

    m_pfirst = pgroup;
    m_nwidth = pgroup->group_width();

    // Number the invisible groups
    m_cgroups_visible = m_cgroups;
    while( ! m_invisible_groups.empty() )
    {
        m_invisible_groups.front()->group_number( _get_next_group_nbr() );
        m_invisible_groups.pop_front();
    }

    //
    // determine if we can get away with only calling m_pfirst->domatch only once
    //

    m_floop = true;

    // Optimization: if first character of pattern string is '^'
    // and we are not doing a multiline match, then we only 
    // need to try domatch once
    basic_string<char_type>::iterator icur = m_pat.begin();
    if( MULTILINE != ( MULTILINE & m_flags ) &&
        1 == pgroup->calternates() && 
        icur != m_pat.end() && 
        BEGIN_LINE == SY::reg_token( icur, m_pat.end() ) )
    {
        m_flags &= ~RIGHTMOST;
        m_floop = false;
    }

    // Optimization: if first 2 characters of pattern string are ".*" or ".+",
    // then we only need to try domatch once
    icur = m_pat.begin();
    if( RIGHTMOST != ( RIGHTMOST & m_flags ) &&
        SINGLELINE == ( SINGLELINE & m_flags ) &&
        1 == pgroup->calternates() &&
        icur != m_pat.end() && 
        MATCH_ANY == SY::reg_token( icur, m_pat.end() ) &&
        icur != m_pat.end() )
    {
        switch( SY::quant_token( icur, m_pat.end() ) )
        {
            case ONE_OR_MORE:
            case ZERO_OR_MORE:
            case ONE_OR_MORE_MIN:
            case ZERO_OR_MORE_MIN:
                m_floop = false;
        }
    }
}

template< typename CI, typename SY >
void basic_rpattern<CI,SY>::_reset() throw()
{
    basic_rpattern_base<CI>::_reset();

    m_cgroups = m_cgroups_visible = 0;
    m_floop   = true;

    m_subst.erase();
    m_pat.erase();

    m_pfirst.free_ptr();
    m_nwidth = uninit_width;
    m_subst_list.clear();
    m_invisible_groups.clear();
}

template< typename CI, typename SY >
void basic_rpattern<CI,SY>::set_flags( unsigned flags ) throw(bad_regexpr,bad_alloc)
{
    push_new_handler pnh( &my_new_handler );
    m_pfirst.free_ptr();
    m_flags = flags;
    _common_init( m_flags );
}

template< typename CI, typename SY >
void basic_rpattern<CI,SY>::set_substitution( const basic_string<basic_rpattern<CI,SY>::char_type> & subst )
{
    push_new_handler pnh( &my_new_handler );
    m_subst_list.clear();
    m_subst = subst;
    _normalize_string( m_subst );
    _parse_subst();
}

template< typename CI, typename SY >
match_group<CI> * basic_rpattern<CI,SY>::_find_next_group( 
    basic_string<basic_rpattern<CI,SY>::char_type>::iterator & ipat, 
    unsigned & flags,
    vector<match_group<CI>*> & rggroups )
{
    auto_sub_ptr<match_group<CI> > pgroup;
    basic_string<char_type>::iterator itemp = ipat;
    unsigned old_flags = flags;
    TOKEN tok;

    // Look for group extensions. (This could change the value of the flags variable.)
    if( ipat != m_pat.end() && NO_TOKEN != ( tok = SY::ext_token( ipat, m_pat.end(), flags ) ) )
    {
        if( itemp == m_pat.begin() || ipat == m_pat.end() )
            throw bad_regexpr("ill-formed regular expression");

        // Don't process empty groups
        if( END_GROUP != SY::reg_token( itemp = ipat, m_pat.end() ) )
        {
            switch( tok )
            {
            case EXT_NOBACKREF:
                // invisible groups are numbered only after all
                // visible groups have been numbererd
                pgroup = new match_group<CI>( -1 );
                m_invisible_groups.push_back( pgroup.get() );
                break;

            case EXT_INDEPENDENT:
                pgroup = new independent_group<CI>();
                m_invisible_groups.push_back( pgroup.get() );
                break;

            case EXT_POS_LOOKAHEAD:
                pgroup = new lookahead_assertion<CI>( true );
                break;
            
            case EXT_NEG_LOOKAHEAD:
                pgroup = new lookahead_assertion<CI>( false );
                break;
            
            case EXT_POS_LOOKBEHIND:
                // For look-behind assertions, turn off the CSTRINGs optimization
                flags &= ~CSTRINGS;
                pgroup = new lookbehind_assertion<CI>( true );
                break;
            
            case EXT_NEG_LOOKBEHIND:
                // For look-behind assertions, turn off the CSTRINGs optimization
                flags &= ~CSTRINGS;
                pgroup = new lookbehind_assertion<CI>( false );
                break;
            
            default:
                throw bad_regexpr("bad extension sequence");
            }
        }
        else
        {
            // Skip over the END_GROUP token
            ipat = itemp;
        }
    }
    else
    {
        pgroup = new match_group<CI>( _get_next_group_nbr() );
    }

    if( NULL != pgroup.get() )
    {
        pgroup->add_alternate();
        while( _find_next( ipat, pgroup.get(), flags, rggroups ) );
        pgroup->end_alternate();

        // Add this group to the rggroups array
        if( -1 != pgroup->group_number() )
        {
            if( pgroup->group_number() >= rggroups.size() )
                rggroups.resize( pgroup->group_number() + 1, NULL );
            rggroups[ pgroup->group_number() ] = pgroup.get();
        }

        // The group should calculate its own width now and 
        // save the result for later.
        pgroup->group_width();

        // If this is not a pattern modifier, restore the 
        // flags to their previous settings.  This causes 
        // pattern modifiers to have the scope of their 
        // enclosing group.
        flags = old_flags;
    }

    return pgroup.release();
}

//
// Read ahead through the pattern and treat sequential atoms
// as a single atom, making sure to handle quantification
// correctly. Warning: dense code ahead.
//
template< typename CI, typename SY >
void basic_rpattern<CI,SY>::_find_atom( 
    basic_string<basic_rpattern<CI,SY>::char_type>::iterator & ipat,
    match_group<CI> * pgroup, 
    unsigned flags )
{
    basic_string<char_type>::iterator itemp = ipat, istart = ipat;

    do
    {
        switch( SY::quant_token( itemp, m_pat.end() ) )
        {
        // if {,} can't be interpreted as quantifiers, treat them as regular chars
        case BEGIN_RANGE:
            if( istart != ipat ) // treat as a quantifier
                goto quantify;
        case NO_TOKEN:
        case END_RANGE:
        case END_RANGE_MIN:
        case RANGE_SEPARATOR:
            break;

        default: 
            if( istart == ipat ) // must be able to quantify something.
                throw bad_regexpr("quantifier not expected");
quantify:   if( istart != --ipat )
                pgroup->add_item( create_atom<CI>( istart, ipat, flags ) );
            auto_sub_ptr<sub_expr<CI> > pnew( create_atom<CI>( ipat++, flags ) );
            _quantify( pnew, NULL, ipat );
            pgroup->add_item( pnew.release() );
            return;
        }
    } while( m_pat.end() != ++ipat && ! SY::reg_token( itemp = ipat, m_pat.end() ) );

    assert( ipat != istart );
    pgroup->add_item( create_atom<CI>( istart, ipat, flags ) );
}

template< typename CI, typename SY >
bool basic_rpattern<CI,SY>::_find_next( 
    basic_string<basic_rpattern<CI,SY>::char_type>::iterator & ipat,
    match_group<CI> * pgroup, 
    unsigned & flags,
    vector<match_group<CI>*> & rggroups )
{
    match_group<CI> * pnew_group = NULL;
    auto_sub_ptr<sub_expr<CI> > pnew;
    basic_string<char_type>::iterator istart, itemp;
    bool fdone;

    if( ipat == m_pat.end() )
    {
        if( 0 != pgroup->group_number() )
            throw bad_regexpr( "mismatched parenthesis" );
        return false;
    }

    switch( SY::reg_token( ipat, m_pat.end() ) )
    {
    case NO_TOKEN: // not a token. Must be an atom
        _find_atom( ipat, pgroup, flags );
        return true;
    
    case END_GROUP:
        if( 0 == pgroup->group_number() )
            throw bad_regexpr( "mismatched parenthesis" );
        return false;

    case ALTERNATION:
        pgroup->end_alternate();
        pgroup->add_alternate();
        return true;
    
    case BEGIN_GROUP:
        // Find next group could return NULL if the group is really
        // a pattern modifier, like: (?s-i)
        pnew = pnew_group = _find_next_group( ipat, flags, rggroups );
        break;

    case BEGIN_LINE:
        pnew = create_bol<CI>( flags );
        break;

    case END_LINE:
        pnew = create_eol<CI>( flags );
        break;

    case BEGIN_CHARSET:
        pnew = create_charset_helper<CI,SY>::create_charset_aux( m_pat, ipat, flags );
        break;

    case MATCH_ANY:
        pnew = create_any<CI>( flags );
        break;

    case ESC_WORD_BOUNDARY:
        pnew = create_word_boundary<CI>( true, flags );
        break;
    
    case ESC_NOT_WORD_BOUNDARY:
        pnew = create_word_boundary<CI>( false, flags );
        break;
    
    case ESC_WORD_START:
        pnew = create_word_start<CI>( flags );
        break;
    
    case ESC_WORD_STOP:
        pnew = create_word_stop<CI>( flags );
        break;
    
    case ESC_DIGIT:
        pnew = create_charset<CI>( match_charset<CI>( false,
                                                    get_digit_vector() ),
                                                    flags );
        break;

    case ESC_NOT_DIGIT:
        pnew = create_charset<CI>( match_charset<CI>( true,
                                                    get_digit_vector() ),
                                                    flags );
        break;

    case ESC_WORD:
        pnew = create_charset<CI>( match_charset<CI>( false,
                                                    get_word_vector() ),
                                                    flags );
        break;

    case ESC_NOT_WORD:
        pnew = create_charset<CI>( match_charset<CI>( true,
                                                    get_word_vector() ),
                                                    flags );
        break;

    case ESC_SPACE:
        pnew = create_charset<CI>( match_charset<CI>( false,
                                                    get_space_vector() ),
                                                    flags );
        break;

    case ESC_NOT_SPACE:
        pnew = create_charset<CI>( match_charset<CI>( true,
                                                    get_space_vector() ),
                                                    flags );
        break;

    case ESC_BEGIN_STRING:
        pnew = create_bos<CI>( flags );
        break;

    case ESC_END_STRING:
        pnew = create_eos<CI>( flags );
        break;

    case ESC_END_STRING_z:
        pnew = create_eoz<CI>( flags );
        break;

    case ESCAPE:

        if( char_type('0') <= *ipat && char_type('9') >= *ipat )
        {
            // use _cgroups_total here since the invisible groups have not been numbered yet.
            unsigned nbackref = parse_int( ipat, m_pat.end(), _cgroups_total() - 1 );// always at least 1 group
            if( 0 == nbackref || rggroups.size() <= nbackref || NULL == rggroups[ nbackref ] )
                throw bad_regexpr( "invalid backreference" );
            pnew = create_backref<CI>( nbackref, rggroups[nbackref]->group_width(), flags );
        }
        else
        {
            // Is this a user-defined intrinsic character set?
            match_charset<CI> * pcharset = s_charset_map.get( *ipat, flags );
            if( NULL != pcharset )
                pnew = create_charset<CI>( *pcharset, flags );
            else
                pnew = create_atom<CI>( ipat, flags );
            ++ipat;
        }
        break;

    // If quotemeta, loop until we find quotemeta off or end of string
    case ESC_QUOTE_META_ON:
        for( istart = itemp = ipat, fdone = false; !fdone && ipat != m_pat.end(); )
        {
            switch( SY::reg_token( ipat, m_pat.end() ) )
            {
            case ESC_QUOTE_META_OFF:
                fdone = true;
                break;
            case NO_TOKEN:
                ++ipat; // fallthrough
            default:
                itemp = ipat;
                break;
            }
        }
        if( itemp != istart )
            pgroup->add_item( create_atom<CI>( istart, itemp, flags ) );

        // skip the quantification code below
        return true;

    // Should never get here for valid patterns
    case ESC_QUOTE_META_OFF:
        throw bad_regexpr("quotemeta turned off, but was never turned on");

    default:
        assert( ! "Unhandled token type" );
        break;
    }
    
    // If pnew is null, then the current subexpression is a no-op.
    if( pnew.get() )
    {
        // Look for quantifiers
        _quantify( pnew, pnew_group, ipat );

        // Add the item to the group
        pgroup->add_item( pnew.release() );
    }
    return true;
}

template< typename CI, typename SY >
void basic_rpattern<CI,SY>::_quantify( 
    auto_sub_ptr<sub_expr<CI> > & pnew,
    match_group<CI> * pnew_group,
    basic_string<basic_rpattern<CI,SY>::char_type>::iterator & ipat )
{
    if( ipat != m_pat.end() && ! pnew->is_assertion() )
    {
        basic_string<char_type>::iterator itemp = ipat;
        bool fmin = false;
        
        // Since size_t is unsigned, -1 is really the largest size_t
        size_t lbound = (size_t)-1;
        size_t ubound = (size_t)-1;
        size_t ubound_tmp;

        switch( SY::quant_token( itemp, m_pat.end() ) )
        {
        case ZERO_OR_MORE_MIN:
            fmin = true;
        case ZERO_OR_MORE:
            lbound = 0;
            break;

        case ONE_OR_MORE_MIN:
            fmin = true;
        case ONE_OR_MORE:
            lbound = 1;
            break;

        case ZERO_OR_ONE_MIN:
            fmin = true;
        case ZERO_OR_ONE:
            lbound = 0;
            ubound = 1; 
            break;

        case BEGIN_RANGE:
            lbound = parse_int( itemp, m_pat.end() );
            if( itemp == m_pat.end() )
                throw bad_regexpr( "expecting end of range" );

            switch( SY::quant_token( itemp, m_pat.end() ) )
            {
            case END_RANGE_MIN:
                fmin = true;
            case END_RANGE:
                ubound = lbound;
                break;

            case RANGE_SEPARATOR:
                ipat = itemp;
                ubound_tmp = parse_int( itemp, m_pat.end() );
                if( itemp != ipat )
                    ubound = ubound_tmp;
                if( itemp == m_pat.end() )
                    throw bad_regexpr( "expecting end of range" );
                switch( SY::quant_token( itemp, m_pat.end() ) )
                {
                case END_RANGE_MIN:
                    fmin = true;
                case END_RANGE:
                    break;
                default:
                    throw bad_regexpr( "expecting end of range" );
                }
                break;

            default:
                throw bad_regexpr( "ill-formed quantifier" );
            }

            if( ubound < lbound  )
                throw bad_regexpr( "ill-formed quantifier" );

            break;
        }

        if( (size_t)-1 != lbound )
        {
            auto_sub_ptr<match_quantifier<CI> > pquant;

            // a group quantifier is less efficient than an atom quantifier
            if( fmin )
            {
                if( pnew_group )
                    pquant = new min_group_quantifier<CI>( pnew_group, 
                                                                 lbound, ubound );
                else
                    pquant = new min_atom_quantifier<CI>( pnew.get(), 
                                                                lbound, ubound );
            }
            else
            {
                if( pnew_group )
                    pquant = new max_group_quantifier<CI>( pnew_group, 
                                                                 lbound, ubound );
                else
                    pquant = new max_atom_quantifier<CI>( pnew.get(),
                                                                lbound, ubound );
            }

            pnew.release();
            pnew = pquant.release();
            ipat = itemp;
        }
    }
}

template< typename CI, typename SY >
void basic_rpattern<CI,SY>::_add_subst_backref( subst_node & snode, size_t nbackref, size_t rstart )
{
    m_fuses_backrefs = true;
    assert( subst_node::SUBST_STRING == snode.stype );
    if( snode.subst_string.rlength )
        m_subst_list.push_back( snode );

    snode.stype = subst_node::SUBST_BACKREF;
    snode.subst_backref = nbackref;
    m_subst_list.push_back( snode );

    // re-initialize the subst_node
    snode.stype = subst_node::SUBST_STRING;
    snode.subst_string.rstart = rstart;
    snode.subst_string.rlength = 0;
}

template< typename CI, typename SY >
void basic_rpattern<CI,SY>::_parse_subst()
{
    TOKEN tok;
    subst_node snode;
    basic_string<char_type>::iterator icur = m_subst.begin();
    size_t nbackref;
    basic_string<char_type>::iterator itemp;
    bool fdone;

    m_fuses_backrefs = false;

    // Initialize the subst_node
    snode.stype = subst_node::SUBST_STRING;
    snode.subst_string.rstart = 0;
    snode.subst_string.rlength = 0;

    while( icur != m_subst.end() )
    {
        switch( tok = SY::subst_token( icur, m_subst.end() ) )
        {
        case SUBST_MATCH:
            _add_subst_backref( snode, 0, distance( m_subst.begin(), icur ) );
            break;

        case SUBST_PREMATCH:
            _add_subst_backref( snode, subst_node::PREMATCH, distance( m_subst.begin(), icur ) );
            break;

        case SUBST_POSTMATCH:
            _add_subst_backref( snode, subst_node::POSTMATCH, distance( m_subst.begin(), icur ) );
            break;

        case SUBST_BACKREF:
            nbackref = parse_int( icur, m_subst.end(), cgroups() - 1 ); // always at least 1 group
            if( 0 == nbackref )
                throw bad_regexpr( "invalid backreference in substitution" );

            _add_subst_backref( snode, nbackref, distance( m_subst.begin(), icur ) );
            break;

        case SUBST_QUOTE_META_ON:
            assert( subst_node::SUBST_STRING == snode.stype );
            if( snode.subst_string.rlength )
                m_subst_list.push_back( snode );

            snode.subst_string.rstart = distance( m_subst.begin(), icur );
            for( itemp = icur, fdone = false; !fdone && icur != m_subst.end(); )
            {
                switch( tok = SY::subst_token( icur, m_subst.end() ) )
                {
                case SUBST_ALL_OFF:
                    fdone = true;
                    break;
                case NO_TOKEN:
                    ++icur; // fall-through
                default:
                    itemp = icur;
                    break;
                }
            }
            snode.subst_string.rlength = distance( m_subst.begin(), itemp ) - snode.subst_string.rstart;
            if( snode.subst_string.rlength )
                m_subst_list.push_back( snode );

            if( tok == SUBST_ALL_OFF )
            {
                snode.stype = subst_node::SUBST_OP;
                snode.op    = subst_node::ALL_OFF;
                m_subst_list.push_back( snode );
            }

            // re-initialize the subst_node
            snode.stype = subst_node::SUBST_STRING;
            snode.subst_string.rstart = distance( m_subst.begin(), icur );
            snode.subst_string.rlength = 0;
            break;

        case SUBST_UPPER_ON:
        case SUBST_UPPER_NEXT:
        case SUBST_LOWER_ON:
        case SUBST_LOWER_NEXT:
        case SUBST_ALL_OFF:
            assert( subst_node::SUBST_STRING == snode.stype );
            if( snode.subst_string.rlength )
                m_subst_list.push_back( snode );

            snode.stype = subst_node::SUBST_OP;
            snode.op    = (subst_node::op_type) tok;
            m_subst_list.push_back( snode );

            // re-initialize the subst_node
            snode.stype = subst_node::SUBST_STRING;
            snode.subst_string.rstart = distance( m_subst.begin(), icur );
            snode.subst_string.rlength = 0;
            break;
        
        case SUBST_ESCAPE:
            if( icur == m_subst.end() )
                throw bad_regexpr("expecting escape sequence in substitution string");
            assert( subst_node::SUBST_STRING == snode.stype );
            if( snode.subst_string.rlength )
                m_subst_list.push_back( snode );
            snode.subst_string.rstart = distance( m_subst.begin(), icur++ );
            snode.subst_string.rlength = 1;
            break;

        case NO_TOKEN:
        default:
            ++snode.subst_string.rlength;
            ++icur;
            break;
        }
    }
    assert( subst_node::SUBST_STRING == snode.stype );
    if( snode.subst_string.rlength )
        m_subst_list.push_back( snode );
}

template< typename CI, typename SY >
basic_rpattern<CI,SY>::charset_map basic_rpattern<CI,SY>::s_charset_map;

// Pass in an interator to one after the opening bracket of the character set.
// On return, icur points to one character after the closing bracket
template< typename CI, typename SY >
sub_expr<CI> * create_charset_helper<CI,SY>::create_charset_aux(
    basic_string<iterator_traits<CI>::value_type> & str,
    basic_string<iterator_traits<CI>::value_type>::iterator & icur,
    unsigned flags )
{
    bool fcomplement = false;
    match_charset<CI> * pnew = NULL;
    basic_string<iterator_traits<CI>::value_type>::iterator itemp = icur;

    if( itemp != str.end() && CHARSET_NEGATE == SY::charset_token( itemp, str.end() ) )
    {
        fcomplement = true;
        icur = itemp;
    }

    switch( ( NOCASE | CSTRINGS ) & flags )
    {
    case 0:
        pnew = new match_custom_charset_t<eos_t<CI>,match_range_with_case>( fcomplement, icur, str.end(), flags, SY() );
        break;
    case NOCASE:
        pnew = new match_custom_charset_t<eos_t<CI>,match_range_no_case>( fcomplement, icur, str.end(), flags, SY() );
        break;
    case CSTRINGS:
        pnew = new match_custom_charset_t<eocs_t<CI>,match_range_with_case>( fcomplement, icur, str.end(), flags, SY() );
        break;
    case NOCASE | CSTRINGS:
        pnew = new match_custom_charset_t<eocs_t<CI>,match_range_no_case>( fcomplement, icur, str.end(), flags, SY() );
        break;
    default:
        __assume(0); // tells the compiler that this is unreachable
    }

    return pnew;
}

#pragma warning( disable : 4660 )

// Explicit instantiation
#ifdef REGEX_FORCE_INSTANTIATION
 template class basic_regexpr<char>;
 template class basic_regexpr<wint_t>;
#else
 template class basic_regexpr<TCHAR>;
#endif

#ifndef NO_PERL_RE
 #ifdef REGEX_FORCE_INSTANTIATION
  template class basic_rpattern<const char *>;
  template class basic_rpattern<const wint_t *>;
  template class basic_rpattern<string::const_iterator>;
  template class basic_rpattern<wstring::const_iterator>;
 #else
  template class basic_rpattern<const TCHAR *>;
  template class basic_rpattern<tstring::const_iterator>;
 #endif
#endif

#ifdef POSIX_RE
 #ifdef REGEX_FORCE_INSTANTIATION
  template class basic_rpattern<const char *,posix_syntax<char> >;
  template class basic_rpattern<const wint_t *,posix_syntax<wint_t> >;
  template class basic_rpattern<string::const_iterator,posix_syntax<char> >;
  template class basic_rpattern<wstring::const_iterator,posix_syntax<wint_t> >;
 #else
  template class basic_rpattern<const TCHAR *,posix_syntax<TCHAR> >;
  template class basic_rpattern<tstring::const_iterator,posix_syntax<TCHAR> >;
 #endif
#endif

} // namespace regex
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\tools\ncbrowse\regexpr.h ===
//+---------------------------------------------------------------------------
//
//  File:       basic_regexpr.hxx
//
//  Contents:   classes for regular expression pattern matching a-la perl
//
//  Classes:    basic_rpattern, basic_regexpr
//
//  Functions:  basic_regexpr::match
//              basic_regexpr::substitute
//              basic_regexpr::cbackrefs
//              basic_regexpr::backref
//              basic_regexpr::all_backrefs
//              basic_regexpr::backref_str
//
//  Coupling:   
//
//  History:    12-11-1998   ericne   Created
//              01-05-2001   ericne   Removed dependency on VC's choice
//                                    of STL iterator types.
//
//----------------------------------------------------------------------------

#pragma once

// C4786 identifier was truncated to '255' characters in the debug information
#pragma warning( disable : 4290 4786 )

#ifdef _MT
#include <windows.h> // for CRITICAL_SECTION
#endif

#include <string>
#include <stdexcept>
#include <vector>
#include <list>
#include <map>
#include <iostream>
#include <tchar.h>
#include <new.h> // for _set_new_handler
#include <crtdbg.h>
#include "syntax.h"

namespace regex
{

// Called when an allocation fails
inline int __cdecl my_new_handler( size_t )
{
    throw std::bad_alloc();
}

// For pushing and popping the new handler
class push_new_handler
{
   _PNH m_pnh;
public:
   push_new_handler( _PNH pnh )
   {
      m_pnh = _set_new_handler( pnh );
   }
   ~push_new_handler()
   {
      (void)_set_new_handler( m_pnh );
   }
};

class bad_regexpr : public std::runtime_error
{
public:
    explicit bad_regexpr(const std::string& _S)
        : std::runtime_error(_S) {}
    virtual ~bad_regexpr() {}
};

//
// Flags to control how matching occurs
//
enum REGEX_FLAGS
{      
    NOCASE        = 0x0001, // ignore case
    GLOBAL        = 0x0002, // match everywhere in the string
    MULTILINE     = 0x0004, // ^ and $ can match internal line breaks
    SINGLELINE    = 0x0008, // . can match newline character
    RIGHTMOST     = 0x0010, // start matching at the right of the string
    NOBACKREFS    = 0x0020, // only meaningful when used with GLOBAL and substitute
    FIRSTBACKREFS = 0x0040, // only meaningful when used with GLOBAL
    ALLBACKREFS   = 0x0080, // only meaningful when used with GLOBAL
    CSTRINGS      = 0x0100, // optimize pattern for use with null-terminated strings
    NORMALIZE     = 0x0200  // Preprocess patterns: "\\n" => "\n", etc.
};

// Forward declarations
template< typename CI > struct match_param;
template< typename CI > class  match_group;
template< typename CI > class  match_wrapper;
template< typename CI > class  match_charset;
template< typename CI > class  basic_rpattern_base;

// --------------------------------------------------------------------------
// 
// Class:       width_type
// 
// Description: represents the width of a sub-expression
// 
// Methods:     width_add  - add two widths
//              width_mult - multiply two widths
//              width_type - ctor
//              width_type - ctor
//              operator=  - assign a width
//              operator== - are widths equal
//              operator!= - are widths now equal
//              operator+  - add two widths
//              operator*  - multiply two widths
// 
// Members:     m_min      - smallest number of characters a sub-expr can span
//              m_max      - largest number of characters a sub-expr can span
// 
// History:     8/14/2000 - ericne - Created
// 
// --------------------------------------------------------------------------
struct width_type
{
    size_t m_min;
    size_t m_max;

    static size_t width_add( size_t a, size_t b )
    {
        return ( -1 == a || -1 == b ? -1 : a + b );
    }

    static size_t width_mult( size_t a, size_t b )
    {
        return ( -1 == a || -1 == b ? -1 : a * b );
    }

    width_type( size_t _min = 0, size_t _max = -1 ) 
        : m_min(_min), m_max(_max) 
    {
    }
    
    width_type( const width_type & that ) 
        : m_min(that.m_min), m_max(that.m_max) 
    {
    }
    
    width_type & operator=( const width_type & that )
    {
        m_min = that.m_min;
        m_max = that.m_max;
        return *this;
    }

    bool operator==( const width_type & that ) const
    {
        return ( m_min == that.m_min && m_max == that.m_max );
    }

    bool operator!=( const width_type & that ) const
    {
        return ( m_min != that.m_min || m_max != that.m_max );
    }

    width_type operator+( const width_type & that ) const
    {
        return width_type( width_add( m_min, that.m_min ), width_add( m_max, that.m_max ) );
    }

    width_type operator*( const width_type & that ) const
    {
        return width_type( width_mult( m_min, that.m_min ), width_mult( m_max, that.m_max ) );
    }
};

const width_type worst_width(0,-1);
const width_type uninit_width(-1,-1);

// --------------------------------------------------------------------------
// 
// Class:       sub_expr
// 
// Description: patterns are "compiled" into a directed graph of sub_expr
//              structs.  Matching is accomplished by traversing this graph.
// 
// Methods:     sub_expr     - construct a sub_expr
//              _match_this  - does this sub_expr match at the given location
//              _width_this  - what is the width of this sub_expr
//              ~sub_expr    - virt dtor so cleanup happens correctly
//              _delete      - delete this node in the graph and all nodes linked
//              next         - pointer to the next node in the graph
//              next         - pointer to the next node in the graph
//              match_next   - match the rest of the graph
//              domatch      - match_this and match_next
//              is_assertion - true if this sub_expr is a zero-width assertion
//              get_width    - find the width of the graph at this sub_expr
// 
// Members:     m_pnext      - pointer to the next node in the graph
// 
// History:     8/14/2000 - ericne - Created
// 
// --------------------------------------------------------------------------
template< typename CI > 
class sub_expr
{
    sub_expr * m_pnext;

protected:
    
    // Only derived classes and basic_rpattern can instantiate sub_expr's
    sub_expr( ) 
        : m_pnext(NULL) 
    {
    }
    
    // match this object only
    virtual bool _match_this( match_param<CI> & param, CI & icur ) const throw()
    { 
        return true; 
    }

    virtual width_type _width_this() throw() = 0;

public:

    typedef typename std::iterator_traits<CI>::value_type char_type;

    friend class match_wrapper<CI>;  // wrappers can access _match_this method

    virtual ~sub_expr() {}
    
    virtual void _delete() 
    { 
        if( m_pnext )
            m_pnext->_delete();
        delete this;
    }

    inline const sub_expr *const   next() const { return m_pnext; }
    inline       sub_expr *      & next()       { return m_pnext; }

    // Match all subsequent objects
    inline bool match_next( match_param<CI> & param, CI icur ) const throw()
    {
        return NULL == m_pnext || m_pnext->domatch( param, icur );
    }

    // Match this object and all subsequent objects
    // If domatch returns false, it must not change any internal state
    virtual bool domatch( match_param<CI> & param, CI icur ) const throw()
    {
        return ( _match_this(param,icur) && match_next(param,icur) );
    }

    virtual bool is_assertion() const throw() 
    { 
        return false; 
    }

    width_type get_width() throw()
    {
        width_type this_width = _width_this();
        
        if( NULL == m_pnext )
            return this_width;
        
        width_type that_width = m_pnext->get_width();

        return ( this_width + that_width );
    }
};

template< typename CI >
void delete_sub_expr( sub_expr<CI> * psub )
{
    if( psub )
        psub->_delete();
}

template< typename CI, typename SY = perl_syntax<std::iterator_traits<CI>::value_type> >
class create_charset_helper
{
public:
    typedef std::iterator_traits<CI>::value_type char_type;

    static sub_expr<CI> * create_charset_aux(
        std::basic_string<char_type> & str,
        std::basic_string<char_type>::iterator & icur,
        unsigned flags );
};


// --------------------------------------------------------------------------
// 
// Class:       auto_sub_ptr
// 
// Description: Class for automatically cleaning up the structure associated
//              with a parsed pattern
// 
// Methods:     auto_sub_ptr  - private copy ctor - not used
//              operator=     - private assign operator - not used
//              operator T*   - private implicit cast operator - not used
//              auto_sub_ptr  - ctor
//              ~auto_sub_ptr - dtor, frees ptr
//              free_ptr      - explicitly free pointer
//              release       - relinquish ownership of ptr
//              operator=     - take ownership of ptr
//              get           - return ptr
//              get           - return ptr
//              operator->    - method call through ptr
//              operator->    - method call through ptr
// 
// Members:     m_psub        - sub_expr pointer
// 
// History:     8/14/2000 - ericne - Created
// 
// --------------------------------------------------------------------------
template< typename T >
class auto_sub_ptr
{
    T * m_psub;

    // hide these methods
    auto_sub_ptr( const auto_sub_ptr<T> & ) {}
    auto_sub_ptr & operator=( const auto_sub_ptr<T> & ) { return *this; }
    operator T*() const { return m_psub; }

public:
    auto_sub_ptr( T * psub = NULL ) : m_psub( psub ) {}
    
    ~auto_sub_ptr() 
    { 
        free_ptr();
    }

    void free_ptr() // deallocate
    {
        delete_sub_expr( m_psub );
    }

    T * release() // relinquish ownership, but don't deallocate
    { 
        T * psub = m_psub; 
        m_psub = NULL; 
        return psub; 
    }

    auto_sub_ptr<T> & operator=( T * psub ) 
    { 
        delete_sub_expr( m_psub );
        m_psub = psub;
        return *this;
    }

    inline const T*const   get()        const { return m_psub; }
    inline       T*      & get()              { return m_psub; }
    inline const T*const   operator->() const { return m_psub; }
    inline       T*        operator->()       { return m_psub; }
};

template< typename CI >
struct backref_tag : public std::pair<CI,CI>
{
    backref_tag( CI i1 = CI(0), CI i2 = CI(0) )
        : std::pair<CI,CI>(i1,i2), reserved(0) {}
    operator bool() const throw() { return first != CI(0) && second != CI(0); }
    bool operator!() const throw() { return ! operator bool(); }
    size_t reserved; // used for internal book-keeping
};

template< typename CH >
backref_tag< const CH * > _static_match_helper(
    const CH * szstr,
    const basic_rpattern_base< const CH * > & pat,
    std::vector< backref_tag< const CH * > > * prgbackrefs ) throw();

template< typename CH >
size_t _static_count_helper( 
    const CH * szstr,
    const basic_rpattern_base< const CH * > & pat ) throw();

// --------------------------------------------------------------------------
// 
// Class:       basic_regexpr
// 
// Description: string class that allows regular expression pattern matching
// 
// Methods:     basic_regexpr  - ctor
//              match          - static method for matching C-style strings
//              match          - non-static method for matching C++-style strings
//              count          - static method for couting matches in C-style strings
//              count          - non-static method for counting matches in C++-style strin
//              substitute     - perform substitutions in C++-style strings
//              cbackrefs      - return the count of internally stored back-references
//              rstart         - offset to start of n-th backref
//              rlength        - lenght of n-th backref
//              backref        - return the n-th backref
//              all_backrefs   - return a vector of all saved backrefs
//              backref_str    - return the string to which the backreferences refer
// 
// Members:     m_rgbackrefs   - vector of backrefs
//              m_backref_str  - temp string buffer
//              m_pbackref_str - pointer to the string containing the string to which
//                               the backreferences refer (either *this or m_backref_str)
// 
// Typedefs:    backref_type   - 
//              backref_vector - 
// 
// History:     8/14/2000 - ericne - Created
// 
// --------------------------------------------------------------------------
template< typename CH, typename TR = std::char_traits<CH>, typename AL = std::allocator<CH> >
class basic_regexpr : public std::basic_string<CH,TR,AL>
{
public:

    basic_regexpr( const allocator_type & a = allocator_type() )
        : std::basic_string<CH,TR,AL>( a ), m_pbackref_str( & m_backref_str ) {}
    
    basic_regexpr( const CH * p,
                   const allocator_type & a = allocator_type() )
        : std::basic_string<CH,TR,AL>( p, a ), m_pbackref_str( & m_backref_str ) {}
    
    basic_regexpr( const CH * p, size_type n,
                   const allocator_type & a = allocator_type() )
        : std::basic_string<CH,TR,AL>( p, n, a ), m_pbackref_str( & m_backref_str ) {}
    
    basic_regexpr( const std::basic_string<CH,TR,AL> & s, size_type pos = 0, size_type n = npos,
                   const allocator_type & a = allocator_type() )
        : std::basic_string<CH,TR,AL>( s, pos, n, a ), m_pbackref_str( & m_backref_str ) {}
    
    basic_regexpr( size_type n, CH ch,
                   const allocator_type & a = allocator_type() )
        : std::basic_string<CH,TR,AL>( n, ch, a ), m_pbackref_str( & m_backref_str ) {}
    
    basic_regexpr( const_iterator begin, const_iterator end,
                   const allocator_type & a = allocator_type() )
        : std::basic_string<CH,TR,AL>( begin, end, a ), m_pbackref_str( & m_backref_str ) {}

    // actually stores iterators into *m_pbackref_str:
    typedef backref_tag<const_iterator> backref_type;
    typedef std::vector< backref_type > backref_vector;

    // stores pointers into the null-terminated C-stype string
    typedef backref_tag< const CH * >     backref_type_c;
    typedef std::vector< backref_type_c > backref_vector_c;

    // returns $0, the first backref
    static backref_type_c match( const CH * szstr,
                                 const basic_rpattern_base< const CH * > & pat,
                                 backref_vector_c * prgbackrefs = NULL ) throw()
    {
        return _static_match_helper<CH>( szstr, pat, prgbackrefs );
    }

    // returns $0, the first backref
    backref_type match( const basic_rpattern_base< const_iterator > & pat,
                        size_type pos = 0,
                        size_type len = npos ) const throw();

    static size_t count( const CH * szstr,
                         const basic_rpattern_base< const CH * > & pat ) throw()
    {
        return _static_count_helper<CH>( szstr, pat );
    }

    size_t count( const basic_rpattern_base< const_iterator > & pat,
                  size_type pos = 0,
                  size_type len = npos ) const throw();

    size_t substitute( const basic_rpattern_base< const_iterator > & pat,
                       size_type pos = 0,
                       size_type len = npos ) throw(std::bad_alloc);

    size_t cbackrefs() const throw()
    { 
        return m_rgbackrefs.size(); 
    }

    size_type rstart( size_t cbackref = 0 ) const throw(std::out_of_range)
    {
        return std::distance( m_pbackref_str->begin(), m_rgbackrefs.at( cbackref ).first );
    }

    size_type rlength( size_t cbackref = 0 ) const throw(std::out_of_range)
    {
        return std::distance( m_rgbackrefs.at( cbackref ).first, m_rgbackrefs.at( cbackref ).second );
    }

    backref_type backref( size_t cbackref ) const throw(std::out_of_range)
    {
        return m_rgbackrefs.at( cbackref );
    }

    const backref_vector & all_backrefs() const throw()
    {
        return m_rgbackrefs;
    }

    const std::basic_string<CH,TR,AL> & backref_str() const throw()
    {
        return *m_pbackref_str;
    }

protected:

    // save information about the backrefs
    // mutable because these can change in the "const" match() method.
    mutable backref_vector m_rgbackrefs;
    mutable std::basic_string<CH,TR,AL> m_backref_str;
    mutable const std::basic_string<CH,TR,AL> * m_pbackref_str;
};

// --------------------------------------------------------------------------
// 
// Class:       match_param
// 
// Description: Struct that contains the state of the matching operation.
//              Passed by reference to all domatch and _match_this routines.
// 
// Methods:     match_param - ctor
//              match_param - ctor
// 
// Members:     ibegin      - start of the string
//              istart      - start of this iteration
//              istop       - end of the string
//              prgbackrefs - pointer to backref array0
// 
// History:     8/14/2000 - ericne - Created
// 
// --------------------------------------------------------------------------
template< typename CI >
struct match_param
{
    CI ibegin;
    CI istart;
    CI istop;
    std::vector< backref_tag< CI > > * prgbackrefs;

    match_param( CI _istart,
                 CI _istop,
                 std::vector< backref_tag< CI > > * _prgbackrefs )
    : ibegin(_istart),
      istart(_istart),
      istop(_istop),
      prgbackrefs(_prgbackrefs)
    {
    }
    match_param( CI _ibegin,
                 CI _istart,
                 CI _istop,
                 std::vector< backref_tag< CI > > * _prgbackrefs )
    : ibegin(_ibegin),
      istart(_istart),
      istop(_istop),
      prgbackrefs(_prgbackrefs)
    {
    }
};

// --------------------------------------------------------------------------
// 
// Class:       subst_node
// 
// Description: Substitution strings are parsed into an array of these
//              structures in order to speed up subst operations.
// 
// Members:     stype         - type of this struct
//              subst_string  - do a string substitution
//              subst_backref - do a bacref substitution
//              op            - execute an operation
// 
// History:     8/14/2000 - ericne - Created
// 
// --------------------------------------------------------------------------
struct subst_node
{
    enum subst_type { SUBST_STRING, SUBST_BACKREF, SUBST_OP };
    enum         { PREMATCH = -1, POSTMATCH = -2 };
    enum op_type { UPPER_ON   = SUBST_UPPER_ON,
                   UPPER_NEXT = SUBST_UPPER_NEXT, 
                   LOWER_ON   = SUBST_LOWER_ON, 
                   LOWER_NEXT = SUBST_LOWER_NEXT, 
                   ALL_OFF    = SUBST_ALL_OFF };
    subst_type stype;
    union
    {
        struct
        {
            size_t rstart;
            size_t rlength;
        } subst_string;
        size_t  subst_backref;
        op_type op;
    };
};

// --------------------------------------------------------------------------
// 
// Class:       basic_rpattern_base
// 
// Description: 
// 
// Methods:     basic_rpattern_base     - ctor
//              flags                   - get the state of the flags
//              uses_backrefs           - true if the backrefs are referenced
//              get_first_subexpression - return ptr to first sub_expr struct
//              get_width               - get min/max nbr chars this pattern can match
//              loops                   - if false, we only need to try to match at 1st position
//              cgroups                 - number of visible groups
//              _cgroups_total          - total number of groups, including hidden (?:) groups
//              get_pat                 - get string representing the pattern
//              get_subst               - get string representing the substitution string
//              get_subst_list          - get the list of subst nodes
//              _normalize_string       - perform character escaping
//              _reset                  - reinitialize the pattern
// 
// Members:     m_fuses_backrefs        - 
//              m_floop                 - 
//              m_cgroups               - 
//              m_cgroups_visible       - 
//              m_flags                 - 
//              m_nwidth                - 
//              m_pat                   - 
//              m_subst                 - 
//              m_subst_list            - 
//              m_pfirst                - 
// 
// Typedefs:    char_type               - 
// 
// History:     8/14/2000 - ericne - Created
// 
// --------------------------------------------------------------------------
template< typename CI >
class basic_rpattern_base
{
public:
    typedef std::iterator_traits<CI>::value_type char_type;

    basic_rpattern_base( unsigned flags = 0, 
                         const std::basic_string<char_type> & pat   = std::basic_string<char_type>(),
                         const std::basic_string<char_type> & subst = std::basic_string<char_type>() ) throw()
        : m_fuses_backrefs( false ),
          m_floop( true ),
          m_cgroups( 0 ),
          m_cgroups_visible( 0 ),
          m_flags( flags ),
          m_nwidth( uninit_width ),
          m_pat( pat ),
          m_subst( subst ),
          m_pfirst( NULL )
    {
    }

    unsigned flags() const throw() 
    { 
        return m_flags; 
    }

    bool uses_backrefs() const throw()
    {
        return m_fuses_backrefs;
    }

    const sub_expr<CI> * get_first_subexpression() const throw()
    {
        return m_pfirst.get();
    }

    width_type get_width() const throw()
    {
        return m_nwidth;
    }

    bool loops() const throw()
    {
        return m_floop;
    }

    size_t cgroups() const throw() 
    { 
        return m_cgroups_visible; 
    }
    
    size_t _cgroups_total() const throw() 
    { 
        return m_cgroups; 
    }

    const std::basic_string<char_type> & get_pat() const throw()
    {
        return m_pat;
    }

    const std::basic_string<char_type> & get_subst() const throw()
    {
        return m_subst;
    }

    const std::list<subst_node> & get_subst_list() const throw()
    {
        return m_subst_list;
    }

protected:
    
    void     _normalize_string( std::basic_string<char_type> & str );

    void     _reset()
    {
        m_fuses_backrefs = false;
        m_flags          = 0;
    }

    bool        m_fuses_backrefs;  // true if the substitution uses backrefs
    bool        m_floop;           // false if m_pfirst->domatch only needs to be called once
    size_t      m_cgroups;         // number of groups (always at least one)
    size_t      m_cgroups_visible; // number of visible groups
    unsigned    m_flags;           // flags used to customize search/replace
    width_type  m_nwidth;          // width of the pattern

    std::basic_string<char_type>  m_pat;   // contains the unparsed pattern
    std::basic_string<char_type>  m_subst; // contains the unparsed substitution

    std::list<subst_node>         m_subst_list; // used to speed up substitution
    auto_sub_ptr<sub_expr<CI> >   m_pfirst;     // first subexpression in pattern
};

// --------------------------------------------------------------------------
// 
// Class:       basic_rpattern
// 
// Description: 
// 
// Methods:     basic_rpattern             - ctor
//              basic_rpattern             - 
//              basic_rpattern             - 
//              init                       - for (re)initializing a pattern
//              init                       - 
//              set_substitution           - set the substitution string
//              set_flags                  - set the flags
//              register_intrinsic_charset - bind an escape sequence to a user-def'd charset
//              purge_intrinsic_charsets   - delete all user-def'd charsets
//              _get_next_group_nbr        - return a monotomically increasing id
//              _find_next_group           - parse the next group of the pattern
//              _find_next                 - parse the next sub_expr of the pattern
//              _find_atom                 - parse the next atom of the pattern
//              _quantify                  - quantify the sub_expr
//              _common_init               - perform some common initialization tasks
//              _parse_subst               - parse the substitution string
//              _add_subst_backref         - add a backref node to the subst list
//              _reset                     - reinitialize the pattern
// 
// Members:     s_charset_map              - for maintaining user-defined charsets
//              m_invisible_groups         - list of hidden groups to be numbered last
// 
// Typedefs:    syntax_type                - 
// 
// History:     8/14/2000 - ericne - Created
// 
// --------------------------------------------------------------------------
template< typename CI, typename SY = perl_syntax<std::iterator_traits<CI>::value_type> >
class basic_rpattern : public basic_rpattern_base<CI>
{
public:

    friend class match_charset<CI>;

    typedef SY syntax_type;

    basic_rpattern() throw();

    basic_rpattern( const std::basic_string<char_type> & pat, unsigned flags=0 ) throw(bad_regexpr,std::bad_alloc);
    
    basic_rpattern( const std::basic_string<char_type> & pat, const std::basic_string<char_type> & subst, unsigned flags=0 ) throw(bad_regexpr,std::bad_alloc);

    void init( const std::basic_string<char_type> & pat, unsigned flags=0 ) throw(bad_regexpr,std::bad_alloc);

    void init( const std::basic_string<char_type> & pat, const std::basic_string<char_type> & subst, unsigned flags=0 ) throw(bad_regexpr,std::bad_alloc);

    void set_substitution( const std::basic_string<char_type> & subst ) throw(bad_regexpr,std::bad_alloc);
    
    void set_flags( unsigned flags ) throw(bad_regexpr,std::bad_alloc);
    
    class charset_map
    {
        struct charsets
        {
            sub_expr<CI>                 * rgpcharsets[2];
            std::basic_string<char_type>   str_charset;

            charsets() throw()
            {
                memset( rgpcharsets, 0, sizeof( rgpcharsets ) ); 
            }
            ~charsets() throw()
            {
                clean();
            }
            void clean() throw()
            {
                for( int i=0; i < (sizeof(rgpcharsets)/sizeof(*rgpcharsets)); ++i )
                    delete_sub_expr( rgpcharsets[i] );
            }
            match_charset<CI> * get_charset( unsigned flags ) throw(bad_regexpr,std::bad_alloc)
            {
                push_new_handler pnh( &my_new_handler );
                // Since these charsets are only used while creating other charsets,
                // all flags besides NOCASE can safely be ignored here.
                bool index = ( NOCASE == ( NOCASE & flags ) );
                if( NULL == rgpcharsets[ index ] )
                {
                    std::basic_string<char_type>::iterator istart = str_charset.begin();
                    rgpcharsets[ index ] = create_charset_helper<CI,SY>::create_charset_aux( str_charset, ++istart, flags );
                }
                return (match_charset<CI>*) rgpcharsets[ index ];
            }
        };

        typedef std::map<char_type,charsets> map_type;
        std::auto_ptr<map_type> m_pmap;

    public:

	    void put( char_type ch, const std::basic_string<char_type> & str ) throw(bad_regexpr,std::bad_alloc)
	    {
	        // These characters cannot be bound to a user-defined intrinsic character set
	        static const char_type rgIllegal[] = 
	        {
	            '0','1','2','3','4','5','6','7','8','9','A','Z','z','Q',
	            'b','B','d','D','f','n','r','s','S','t','v','w','W','E'
	        };

	        // So operator new throws bad_alloc on failure.
	        push_new_handler pnh( &my_new_handler );

	        if( std::char_traits<char_type>::find( rgIllegal, ARRAYSIZE( rgIllegal ), ch ) )
	            throw bad_regexpr( "illegal character specified for intrinsic character set." );

	        if( NULL == m_pmap.get() )
	            m_pmap = auto_ptr<map_type>( new map_type );

	        // creates an empty entry if one does not already exist
	        charsets & chrsts = (*m_pmap)[ch];
	        chrsts.clean();
	        chrsts.str_charset = str;

	        // Try compiling the character set once to make sure it is properly formed:
	        (void) chrsts.get_charset( 0 );
	    }

	    match_charset<CI> * get( char_type ch, unsigned flags ) throw()
	    {
	        match_charset<CI> * pRet = NULL;
	        if( NULL != m_pmap.get() )
	        {
	            try
	            {
	                push_new_handler pnh( &my_new_handler );
	                map_type::iterator iter = m_pmap->find( ch );
	                if( iter != m_pmap->end() )
	                    pRet = iter->second.get_charset( flags );
	            }
	            catch(...) {}
	        }

	        return pRet;
	    }

	    void purge() throw()
	    {
	        if( NULL != m_pmap.get() )
	            delete m_pmap.release();
	    }
    };

    static void register_intrinsic_charset( 
        char_type ch, const std::basic_string<char_type> & str ) throw(bad_regexpr,std::bad_alloc)
    {
        s_charset_map.put( ch, str );
    }

    static void purge_intrinsic_charsets() throw()
    {
        s_charset_map.purge();
    }

protected:
    
    static charset_map s_charset_map;

    size_t _get_next_group_nbr() 
    { 
        return m_cgroups++; 
    }

    match_group<CI> * _find_next_group( std::basic_string<char_type>::iterator & ipat, 
                                        unsigned & flags,
                                        std::vector<match_group<CI>*> & rggroups );
    
    bool _find_next( std::basic_string<char_type>::iterator & ipat,
                     match_group<CI> * pgroup, unsigned & flags,
                     std::vector<match_group<CI>*> & rggroups );
    
    void _find_atom( std::basic_string<char_type>::iterator & ipat,
                     match_group<CI> * pgroup, unsigned flags );
    
    void _quantify( auto_sub_ptr<sub_expr<CI> > & pnew,
                    match_group<CI> * pnew_group,
                    std::basic_string<char_type>::iterator & ipat );

    void _common_init( unsigned flags );
    
    void _parse_subst();
    
    void _add_subst_backref( subst_node & snode, size_t nbackref, size_t rstart );

    void _reset();

    std::list<match_group<CI>*>   m_invisible_groups; // groups w/o backrefs

};

inline std::ostream & operator<<( std::ostream & sout, 
                                  const basic_regexpr<char>::backref_type & br )
{
    for( std::string::const_iterator ithis = br.first; ithis != br.second; ++ithis )
        sout.put( *ithis );
    return sout;
}

inline std::wostream & operator<<( std::wostream & sout, 
                                   const basic_regexpr<wchar_t>::backref_type & br )
{
    for( std::wstring::const_iterator ithis = br.first; ithis != br.second; ++ithis )
        sout.put( *ithis > UCHAR_MAX ? L'?' : *ithis );
    return sout;
}

typedef basic_regexpr<TCHAR>     regexpr;
typedef std::basic_string<TCHAR> tstring;

typedef basic_rpattern<const TCHAR *,perl_syntax<TCHAR> >  perl_rpattern_c;
typedef basic_rpattern<const TCHAR *,posix_syntax<TCHAR> > posix_rpattern_c;
typedef basic_rpattern<tstring::const_iterator,perl_syntax<TCHAR> >  perl_rpattern;
typedef basic_rpattern<tstring::const_iterator,posix_syntax<TCHAR> > posix_rpattern;

typedef perl_rpattern            rpattern;   // matches against std::string
typedef perl_rpattern_c          rpattern_c; // matches against null-terminated, c-style strings

#ifdef _MT

//
// Define some classes and macros for creating function-local 
// static const rpatterns in a thread-safe way
//

template< typename PAT >
class rpattern_destroyer
{
    const bool & m_fConstructed;
    const PAT  & m_refPat;
public:
    rpattern_destroyer( const bool & fConstructed, const PAT & refPat )
        : m_fConstructed( fConstructed ), m_refPat( refPat )
    {
    }
    ~rpattern_destroyer()
    {
        if( m_fConstructed )
            _Destroy( & m_refPat );
    }
};

class CRegExCritSect : private CRITICAL_SECTION
{
public:
    CRegExCritSect()  { InitializeCriticalSection(this); }
    ~CRegExCritSect() { DeleteCriticalSection(this); }
    void Enter()      { EnterCriticalSection(this); }
    void Leave()      { LeaveCriticalSection(this); }
};

extern CRegExCritSect g_objRegExCritSect;

class CRegExLock
{
public:
    CRegExLock()  { g_objRegExCritSect.Enter(); }
    ~CRegExLock() { g_objRegExCritSect.Leave(); }
};

#define STATIC_RPATTERN_EX( type, var, params ) \
    static unsigned char s_rgb_##var[ sizeof type ]; \
    static bool s_f_##var = false; \
    static const type & var = *reinterpret_cast<type*>( s_rgb_##var ); \
    static const regex::rpattern_destroyer<type> s_des_##var( s_f_##var, var ); \
    if( ! s_f_##var ) \
    { \
        regex::CRegExLock objLock; \
        if( ! s_f_##var ) \
        { \
            new( s_rgb_##var ) type params; \
            s_f_##var = true; \
        } \
    }

#else

#define STATIC_RPATTERN_EX( type, var, params ) \
    static const type var params;

#endif

#define STATIC_RPATTERN( var, params ) \
    STATIC_RPATTERN_EX( regex::rpattern, var, params )

} // namespace regex
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\tools\ncbrowse\splitterview.h ===
#if !defined(AFX_SPLITTERVIEW_H__B912CF6F_F183_4821_BAC1_D82D257B44FF__INCLUDED_)
#define AFX_SPLITTERVIEW_H__B912CF6F_F183_4821_BAC1_D82D257B44FF__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// SplitterView.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CSplitterView view

class CNcbrowseView;
class CNCEditView;

class CSplitterView : public CView
{
protected:
	CSplitterView();           // protected constructor used by dynamic creation
	DECLARE_DYNCREATE(CSplitterView)
    BOOL m_bInitialized;
    BOOL m_bShouldSetXColumn;
// Attributes
public:
    CSplitterWnd m_wndSplitterLR;
    
   
// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CSplitterView)
	public:
	virtual void OnInitialUpdate();
	protected:
	virtual void OnDraw(CDC* pDC);      // overridden to draw this view
	//}}AFX_VIRTUAL

// Implementation
protected:
	virtual ~CSplitterView();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

	// Generated message map functions
protected:
	//{{AFX_MSG(CSplitterView)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnSize(UINT nType, int cx, int cy);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_SPLITTERVIEW_H__B912CF6F_F183_4821_BAC1_D82D257B44FF__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\tools\ncbrowse\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__082CDABA_9BF5_4E32_94F1_2157224CBE3D__INCLUDED_)
#define AFX_STDAFX_H__082CDABA_9BF5_4E32_94F1_2157224CBE3D__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#pragma warning (disable : 4786)

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxcview.h>
#include <afxdisp.h>        // MFC Automation classes
#include <afxdtctl.h>		// MFC support for Internet Explorer 4 Common Controls
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT
#include <shlwapi.h>
#include <list>
#include <string>
#include <map>
#include <tchar.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__082CDABA_9BF5_4E32_94F1_2157224CBE3D__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\tools\ncbrowse\syntax.cpp ===
//+---------------------------------------------------------------------------
//
//  File:       syntax.cpp
//
//  Contents:   data definitions for the syntax modules
//
//  Classes:    
//
//  Functions:  
//
//  Coupling:   
//
//  Notes:      
//
//  History:    3-29-00   ericne   Created
//
//----------------------------------------------------------------------------
#include "stdafx.h"
#pragma hdrstop

#include <memory.h>
#include "syntax.h"

namespace regex
{

// Initialize the perl syntax look-up tables
perl_syntax_base::init_perl_syntax::init_perl_syntax()
{
    memset( perl_syntax_base::s_rgreg, 0, sizeof( perl_syntax_base::s_rgreg ) );
    memset( perl_syntax_base::s_rgreg, 0, sizeof( perl_syntax_base::s_rgreg ) );

    // REGULAR TOKENS
    perl_syntax_base::s_rgreg[ (unsigned char)'(' ] = BEGIN_GROUP;
    perl_syntax_base::s_rgreg[ (unsigned char)')' ] = END_GROUP;
    perl_syntax_base::s_rgreg[ (unsigned char)'|' ] = ALTERNATION;
    perl_syntax_base::s_rgreg[ (unsigned char)'^' ] = BEGIN_LINE;
    perl_syntax_base::s_rgreg[ (unsigned char)'$' ] = END_LINE;
    perl_syntax_base::s_rgreg[ (unsigned char)'[' ] = BEGIN_CHARSET;
    perl_syntax_base::s_rgreg[ (unsigned char)'.' ] = MATCH_ANY;
    perl_syntax_base::s_rgreg[ (unsigned char)'\\' ] = ESCAPE;

    // ESCAPE TOKENS
    perl_syntax_base::s_rgescape[ (unsigned char)'d' ] = ESC_DIGIT;
    perl_syntax_base::s_rgescape[ (unsigned char)'D' ] = ESC_NOT_DIGIT;
    perl_syntax_base::s_rgescape[ (unsigned char)'s' ] = ESC_SPACE;
    perl_syntax_base::s_rgescape[ (unsigned char)'S' ] = ESC_NOT_SPACE;
    perl_syntax_base::s_rgescape[ (unsigned char)'w' ] = ESC_WORD;
    perl_syntax_base::s_rgescape[ (unsigned char)'W' ] = ESC_NOT_WORD;

    perl_syntax_base::s_rgescape[ (unsigned char)'A' ] = ESC_BEGIN_STRING;
    perl_syntax_base::s_rgescape[ (unsigned char)'Z' ] = ESC_END_STRING;
    perl_syntax_base::s_rgescape[ (unsigned char)'z' ] = ESC_END_STRING_z;
    perl_syntax_base::s_rgescape[ (unsigned char)'b' ] = ESC_WORD_BOUNDARY;
    perl_syntax_base::s_rgescape[ (unsigned char)'B' ] = ESC_NOT_WORD_BOUNDARY;
    perl_syntax_base::s_rgescape[ (unsigned char)'Q' ] = ESC_QUOTE_META_ON;
    perl_syntax_base::s_rgescape[ (unsigned char)'E' ] = ESC_QUOTE_META_OFF;
}
TOKEN perl_syntax_base::s_rgreg[ UCHAR_MAX + 1 ];
TOKEN perl_syntax_base::s_rgescape[ UCHAR_MAX + 1 ];
perl_syntax_base::init_perl_syntax perl_syntax_base::s_init_perl_syntax;

extern const posix_charset_type g_rgposix_charsets[] = 
{
    posix_charset_type("[:alnum:]",9),
    posix_charset_type("[:alpha:]",9),
    posix_charset_type("[:blank:]",9),
    posix_charset_type("[:cntrl:]",9),
    posix_charset_type("[:digit:]",9),
    posix_charset_type("[:graph:]",9),
    posix_charset_type("[:lower:]",9),
    posix_charset_type("[:print:]",9),
    posix_charset_type("[:punct:]",9),
    posix_charset_type("[:space:]",9),
    posix_charset_type("[:upper:]",9),
    posix_charset_type("[:xdigit:]",10)
};

extern const size_t g_cposix_charsets = ARRAYSIZE(g_rgposix_charsets);

} // namespace regex
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\tools\ncbrowse\splitterview.cpp ===
// SplitterView.cpp : implementation file
//

#include "stdafx.h"
#include "ncbrowse.h"
#include "SplitterView.h"

#include "ncbrowsedoc.h"
#include "NcbrowseView.h"
#include "LeftView.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CSplitterView

IMPLEMENT_DYNCREATE(CSplitterView, CView)

CSplitterView::CSplitterView()
{
    m_bInitialized = FALSE;
    m_bShouldSetXColumn = TRUE;
}

CSplitterView::~CSplitterView()
{
}


BEGIN_MESSAGE_MAP(CSplitterView, CView)
	//{{AFX_MSG_MAP(CSplitterView)
	ON_WM_CREATE()
	ON_WM_SIZE()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CSplitterView drawing

void CSplitterView::OnDraw(CDC* pDC)
{
	CDocument* pDoc = GetDocument();
	// TODO: add draw code here
}

/////////////////////////////////////////////////////////////////////////////
// CSplitterView diagnostics

#ifdef _DEBUG
void CSplitterView::AssertValid() const
{
	CView::AssertValid();
}

void CSplitterView::Dump(CDumpContext& dc) const
{
	CView::Dump(dc);
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CSplitterView message handlers

int CSplitterView::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
	if (CView::OnCreate(lpCreateStruct) == -1)
		return -1;
    
    CCreateContext* pContext = (CCreateContext*)lpCreateStruct->lpCreateParams;
    lpCreateStruct->style |= WS_OVERLAPPED;
    
    if (!m_wndSplitterLR.CreateStatic(this, 1, 2))
        return -1;
    
    if (!m_wndSplitterLR.CreateView(0, 0, RUNTIME_CLASS(CLeftView), CSize(225, 100), pContext) ||
        !m_wndSplitterLR.CreateView(0, 1, RUNTIME_CLASS(CNcbrowseView), CSize(225, 100), pContext))
    {
        m_wndSplitterLR.DestroyWindow();
        return -1;
    }
    
	return 0;
}

void CSplitterView::OnInitialUpdate() 
{
    CView::OnInitialUpdate();
    //Because of the structure of this app, this function can be called more than once. 
    //The following flag insures the code after is only run once:
    if(m_bInitialized)
        return;

    m_bInitialized = true;
}

void CSplitterView::OnSize(UINT nType, int cx, int cy) 
{
	CView::OnSize(nType, cx, cy);
	
    m_wndSplitterLR.MoveWindow(0, 0, cx, cy);
    
    //We just want to set the X column upon creation of the view. This way the user can  
    //move the splitter bar to how they like it and still resize the frame window 
    //without it snapping back:
    if (m_bShouldSetXColumn)
    {
        m_wndSplitterLR.SetColumnInfo(0, cx/3, 0);
        m_bShouldSetXColumn = FALSE;
    }
    
    m_wndSplitterLR.RecalcLayout();  
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\tools\ncbrowse\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	ncbrowse.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\tools\ncdiag\version.h ===
#pragma once

#include <ntverp.h>
#include <winver.h>

#define VER_FILETYPE                    VFT_APP
#define VER_FILESUBTYPE                 VFT2_UNKNOWN
#define VER_FILEDESCRIPTION_STR         "Network Configuration Diagnostic"
#define VER_INTERNALNAME_STR            "ncdiag.exe"

#include <common.ver>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\tools\ncbrowse\syntax.h ===
//+---------------------------------------------------------------------------
//
//  File:       syntax.h
//
//  Contents:   syntax modules for regexpr
//
//  Classes:    perl_syntax, posix_syntax
//
//  History:    3-29-00   ericne   Created
//
//----------------------------------------------------------------------------

#pragma once

#include <string>
#include <cwchar>
#include <iterator>

#ifndef ARRAYSIZE
#define ARRAYSIZE(x) (sizeof(x)/sizeof(*(x)))
#endif

#ifndef UCHAR_MAX
#define UCHAR_MAX 0xff
#endif

#ifndef WCHAR_MAX
#define WCHAR_MAX ((wchar_t)-1)
#endif

template<>
struct std::iterator_traits< const char * >
{	// get traits from iterator _Iter
	typedef random_access_iterator_tag iterator_category;
	typedef char value_type;
	typedef ptrdiff_t difference_type;
	typedef difference_type distance_type;	// retained
	typedef char * pointer;
	typedef char & reference;
};

template<>
struct std::iterator_traits< const wchar_t * >
{	// get traits from iterator _Iter
	typedef random_access_iterator_tag iterator_category;
	typedef wchar_t value_type;
	typedef ptrdiff_t difference_type;
	typedef difference_type distance_type;	// retained
	typedef wchar_t * pointer;
	typedef wchar_t & reference;
};

namespace regex
{

//
// The following are the tokens that can be emitted by the syntax module.
// Don't reorder this list!!!
//
enum TOKEN
{ 
    NO_TOKEN = 0,

    // REGULAR TOKENS
    BEGIN_GROUP,
    END_GROUP,
    ALTERNATION,
    BEGIN_LINE,
    END_LINE,
    BEGIN_CHARSET,
    MATCH_ANY,
    ESCAPE,

    // QUANTIFICATION TOKENS
    ONE_OR_MORE,
    ZERO_OR_MORE,
    ZERO_OR_ONE,
    ONE_OR_MORE_MIN,
    ZERO_OR_MORE_MIN,
    ZERO_OR_ONE_MIN,
    BEGIN_RANGE,
    RANGE_SEPARATOR,
    END_RANGE,
    END_RANGE_MIN,

    // ESCAPE SEQUENCES
    ESC_DIGIT,
    ESC_NOT_DIGIT,
    ESC_SPACE,
    ESC_NOT_SPACE,
    ESC_WORD,
    ESC_NOT_WORD,
    ESC_BEGIN_STRING,
    ESC_END_STRING,
    ESC_END_STRING_z,
    ESC_WORD_BOUNDARY,
    ESC_NOT_WORD_BOUNDARY,
    ESC_WORD_START,
    ESC_WORD_STOP,
    ESC_QUOTE_META_ON,
    ESC_QUOTE_META_OFF,

    // SUBSTITUTION TOKENS
    SUBST_BACKREF,
    SUBST_PREMATCH,
    SUBST_POSTMATCH,
    SUBST_MATCH,
    SUBST_ESCAPE,
    SUBST_QUOTE_META_ON,
    SUBST_UPPER_ON,
    SUBST_UPPER_NEXT,
    SUBST_LOWER_ON,
    SUBST_LOWER_NEXT,
    SUBST_ALL_OFF,

    // CHARSET TOKENS
    CHARSET_NEGATE,
    CHARSET_ESCAPE,
    CHARSET_RANGE,
    CHARSET_BACKSPACE,
    CHARSET_END,
    CHARSET_ALNUM,
    CHARSET_ALPHA,
    CHARSET_BLANK,
    CHARSET_CNTRL,
    CHARSET_DIGIT,
    CHARSET_GRAPH,
    CHARSET_LOWER,
    CHARSET_PRINT,
    CHARSET_PUNCT,
    CHARSET_SPACE,
    CHARSET_UPPER,
    CHARSET_XDIGIT,

    // EXTENSION TOKENS
    EXT_NOBACKREF,
    EXT_POS_LOOKAHEAD,
    EXT_NEG_LOOKAHEAD,
    EXT_POS_LOOKBEHIND,
    EXT_NEG_LOOKBEHIND,
    EXT_INDEPENDENT,
    EXT_UNKNOWN
};

struct posix_charset_type
{
    const char * const szcharset;
    const size_t       cchars;

    posix_charset_type( const char * const sz, const size_t c )
        : szcharset(sz), cchars(c) {}
};

extern const posix_charset_type g_rgposix_charsets[];
extern const size_t g_cposix_charsets;

template< typename const_iterator >
bool is_posix_charset( const_iterator icur, const_iterator iend, const char * szcharset )
{
    for( ; icur != iend && '\0' != *szcharset; ++icur, ++szcharset )
    {
        if( *icur != *szcharset )
            return false;
    }
    return '\0' == *szcharset;
}

//
// The perl_syntax class encapsulates the Perl 5 regular expression syntax. It is 
// used as a template parameter to basic_rpattern.  To customize regex syntax, create 
// your own syntax class and use it as a template parameter instead.
//

class perl_syntax_base
{
protected:
    static TOKEN s_rgreg[ UCHAR_MAX + 1 ];
    static TOKEN s_rgescape[ UCHAR_MAX + 1 ];

    struct init_perl_syntax;
    friend struct init_perl_syntax;
    static struct init_perl_syntax
    {
        init_perl_syntax();
    } s_init_perl_syntax;

    static inline TOKEN look_up( char ch, TOKEN rg[] ) { return rg[ (unsigned char)ch ]; }
    static inline TOKEN look_up( wchar_t ch, TOKEN rg[] ) { return UCHAR_MAX < ch ? NO_TOKEN : rg[ (unsigned char)ch ]; }
};

template< typename CH >
class perl_syntax : protected perl_syntax_base
{
public:
    typedef std::basic_string<CH>::iterator iterator;
    typedef std::basic_string<CH>::const_iterator const_iterator;
    typedef CH char_type;

private:
    static bool min_quant( iterator & icur, const_iterator iend )
    {
        return ( (const_iterator)++icur != iend && CH('?') == *icur ? (++icur,true) : false );
    }

public:
    static TOKEN reg_token( iterator & icur, const_iterator iend )
    { 
        assert( (const_iterator)icur != iend );
        TOKEN tok = look_up( *icur, s_rgreg );
        if( tok )
            ++icur;
        if( ESCAPE == tok && (const_iterator)icur != iend )
        {
            tok = look_up( *icur, s_rgescape );
            if( tok )
                ++icur;
            else
                tok = ESCAPE;
        }
        return tok;
    }
    static TOKEN quant_token( iterator & icur, const_iterator iend )
    {
        assert( (const_iterator)icur != iend );
        TOKEN tok = NO_TOKEN;
        switch( *icur )
        {
        case CH('*'):
            tok = min_quant( icur, iend ) ? ZERO_OR_MORE_MIN : ZERO_OR_MORE;
            break;
        case CH('+'):
            tok = min_quant( icur, iend ) ? ONE_OR_MORE_MIN : ONE_OR_MORE;
            break;
        case CH('?'):
            tok = min_quant( icur, iend ) ? ZERO_OR_ONE_MIN : ZERO_OR_ONE;
            break;
        case CH('}'):
            tok = min_quant( icur, iend ) ? END_RANGE_MIN : END_RANGE;
            break;
        case CH('{'):
            tok = BEGIN_RANGE;
            ++icur;
            break;
        case CH(','):
            tok = RANGE_SEPARATOR;
            ++icur;
            break;
        }
        return tok;
    }
    static TOKEN charset_token( iterator & icur, const_iterator iend )
    {
        assert( (const_iterator)icur != iend );
        TOKEN tok = NO_TOKEN;
        switch( *icur )
        {
        case CH('-'):
            tok = CHARSET_RANGE;
            ++icur;
            break;
        case CH('^'):
            tok = CHARSET_NEGATE;
            ++icur;
            break;
        case CH(']'):
            tok = CHARSET_END;
            ++icur;
            break;
        case CH('\\'):
            tok = CHARSET_ESCAPE;
            if( (const_iterator)++icur == iend )
                break;
            switch( *icur )
            {
			case CH('b'):
			    tok = CHARSET_BACKSPACE;
				++icur;
				break;
            case CH('d'):
                tok = ESC_DIGIT;
                ++icur;
                break;
            case CH('D'):
                tok = ESC_NOT_DIGIT;
                ++icur;
                break;
            case CH('s'):
                tok = ESC_SPACE;
                ++icur;
                break;
            case CH('S'):
                tok = ESC_NOT_SPACE;
                ++icur;
                break;
            case CH('w'):
                tok = ESC_WORD;
                ++icur;
                break;
            case CH('W'):
                tok = ESC_NOT_WORD;
                ++icur;
                break;
            }
            break;
        case CH('['):
            for( size_t i=0; !tok && i < g_cposix_charsets; ++i )
            {
                if( is_posix_charset<const_iterator>( icur, iend, g_rgposix_charsets[i].szcharset ) )
                {
                    tok = TOKEN(CHARSET_ALNUM + i);
                    std::advance( icur, g_rgposix_charsets[i].cchars );
                }
            }
            break;
        }
        return tok;
    }
    static TOKEN subst_token( iterator & icur, const_iterator iend )
    {
        assert( (const_iterator)icur != iend );
        TOKEN tok = NO_TOKEN;
        switch( *icur )
        {
        case CH('\\'):
            tok = SUBST_ESCAPE;
            if( (const_iterator)++icur != iend )
                switch( *icur )
                {
                case CH('Q'):
                    tok = SUBST_QUOTE_META_ON;
                    ++icur;
                    break;
                case CH('U'):
                    tok = SUBST_UPPER_ON;
                    ++icur;
                    break;
                case CH('u'):
                    tok = SUBST_UPPER_NEXT;
                    ++icur;
                    break;
                case CH('L'):
                    tok = SUBST_LOWER_ON;
                    ++icur;
                    break;
                case CH('l'):
                    tok = SUBST_LOWER_NEXT;
                    ++icur;
                    break;
                case CH('E'):
                    tok = SUBST_ALL_OFF;
                    ++icur;
                    break;
                }
            break;
        case CH('$'):
            tok = SUBST_BACKREF;
            if( (const_iterator)++icur != iend )
                switch( *icur )
                {
                case CH('&'):
                    tok = SUBST_MATCH;
                    ++icur;
                    break;
                case CH('`'):
                    tok = SUBST_PREMATCH;
                    ++icur;
                    break;
                case CH('\''):
                    tok = SUBST_POSTMATCH;
                    ++icur;
                    break;
                }
            break;
        }
        return tok;
    }
    static TOKEN ext_token( iterator & icur, const_iterator iend, unsigned & flags )
    {
        assert( (const_iterator)icur != iend );
        bool finclude;
        TOKEN tok = NO_TOKEN;
        if( CH('?') == *icur )
        {
            tok = EXT_UNKNOWN;
            if( (const_iterator)++icur != iend )
            {
                switch( *icur )
                {
                case CH(':'):
                    tok = EXT_NOBACKREF;
                    ++icur;
                    break;
                case CH('='):
                    tok = EXT_POS_LOOKAHEAD;
                    ++icur;
                    break;
                case CH('!'):
                    tok = EXT_NEG_LOOKAHEAD;
                    ++icur;
                    break;
                case CH('<'):
                    if( (const_iterator)++icur == iend )
                        break;
                    switch( *icur )
                    {
                    case CH('='):
                        tok = EXT_POS_LOOKBEHIND;
                        ++icur;
                        break;
                    case CH('!'):
                        tok = EXT_NEG_LOOKBEHIND;
                        ++icur;
                        break;
                    }
                    break;
                case CH('>'):
                    tok = EXT_INDEPENDENT;
                    ++icur;
                    break;
                default:
                    finclude = true;
                    do 
                    {
                        if( CH(':') == *icur )
                        {
                            tok = EXT_NOBACKREF;
                            ++icur;
                            break;
                        }
                        if( CH(')') == *icur )
                        {
                            tok = EXT_NOBACKREF;
                            break;
                        }
                        if( CH('-') == *icur && finclude )
                            finclude = false;
                        else if( CH('i') == *icur )
                            flags = finclude ? ( flags | NOCASE )     : ( flags & ~NOCASE );
                        else if( CH('m') == *icur )
                            flags = finclude ? ( flags | MULTILINE )  : ( flags & ~MULTILINE );
                        else if( CH('s') == *icur )
                            flags = finclude ? ( flags | SINGLELINE ) : ( flags & ~SINGLELINE );
                        else
                            break;
                    } while( (const_iterator)++icur != iend );
                    break;
                }
            }
        }
        return tok;
    }
};

//
// Implements the basic POSIX regular expression syntax
//
template< typename CH >
class posix_syntax
{
public:
    typedef std::basic_string<CH>::iterator iterator;
    typedef std::basic_string<CH>::const_iterator const_iterator;
    typedef CH char_type;

    static TOKEN reg_token( iterator & icur, const_iterator iend )
    {
        TOKEN tok = NO_TOKEN;
        switch( *icur )
        {
        case '.':
            tok = MATCH_ANY;
            ++icur;
            break;
        case '^':
            tok = BEGIN_LINE;
            ++icur;
            break;
        case '$':
            tok = END_LINE;
            ++icur;
            break;
        case '[':
            tok = BEGIN_CHARSET;
            ++icur;
            break;
        case '\\':
            tok = ESCAPE;
            ++icur;
            if( (const_iterator)icur != iend )
            {
                switch( *icur )
                {
                case '(':
                    tok = BEGIN_GROUP;
                    ++icur;
                    break;
                case ')':
                    tok = END_GROUP;
                    ++icur;
                    break;
                case '|':
                    tok = ALTERNATION;
                    ++icur;
                    break;
                }
            }
            break;
        }
        return tok;
    }
    static TOKEN quant_token( iterator & icur, const_iterator iend )
    {
        TOKEN tok = NO_TOKEN;
        switch( *icur )
        {
        case '*':
            tok = ZERO_OR_MORE;
            ++icur;
            break;
        case ',':
            tok = RANGE_SEPARATOR;
            ++icur;
            break;
        case '\\':
            ++icur;
            if( (const_iterator)icur != iend )
            {
                switch( *icur )
                {
                case '?':
                    tok = ZERO_OR_ONE;
                    ++icur;
                    break;
                case '+':
                    tok = ONE_OR_MORE;
                    ++icur;
                    break;
                case '{':
                    tok = BEGIN_RANGE;
                    ++icur;
                    break;
                case '}':
                    tok = END_RANGE;
                    ++icur;
                    break;
                default:
                    --icur;
                    break;
                }
            }
            else
            {
                --icur;
            }
        }
        return tok;
    }
    static TOKEN charset_token( iterator & icur, const_iterator iend )
    {
        TOKEN tok = NO_TOKEN;
        switch( *icur )
        {
        case '^':
            tok = CHARSET_NEGATE;
            ++icur;
            break;
        case '-':
            tok = CHARSET_RANGE;
            ++icur;
            break;
        case ']':
            tok = CHARSET_END;
            ++icur;
            break;
        case '[':
            for( size_t i=0; !tok && i < g_cposix_charsets; ++i )
            {
                if( is_posix_charset<const_iterator>( icur, iend, g_rgposix_charsets[i].szcharset ) )
                {
                    tok = TOKEN(CHARSET_ALNUM + i);
                    std::advance( icur, g_rgposix_charsets[i].cchars );
                }
            }
            break;
        }
        return tok;
    }
    static TOKEN subst_token( iterator & icur, const_iterator iend )
    {
        TOKEN tok = NO_TOKEN;
        if( '\\' == *icur )
        {
            tok = SUBST_ESCAPE;
            ++icur;
            if( (const_iterator)icur != iend && '0' <= *icur && '9' >= *icur )
            {
                tok = SUBST_BACKREF;
            }
        }
        return tok;
    }
    static TOKEN ext_token( iterator & icur, const_iterator iend, unsigned & flags )
    {
        return NO_TOKEN;
    }
};

} // namespace regex
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\tools\ncdiag\ncdiag.cpp ===
#include "pch.h"
#pragma hdrstop
#include "diag.h"

// Command strings
//
#define SZ_CMD_SHOW_BINDINGS            L"showbindings"
#define SZ_CMD_SHOW_COMPONENTS          L"showcomponents"
#define SZ_CMD_SHOW_STACK_TABLE         L"showstacktable"
#define SZ_CMD_SHOW_LAN_ADAPTER_PNPIDS  L"showlanpnpids"
#define SZ_CMD_ADD_COMPONENT            L"addcomponent"
#define SZ_CMD_REMOVE_COMPONENT         L"removecomponent"
#define SZ_CMD_UPDATE_COMPONENT         L"updatecomponent"
#define SZ_CMD_REMOVE_REFS              L"removerefs"
#define SZ_CMD_ENABLE_BINDING           L"enablebinding"
#define SZ_CMD_DISABLE_BINDING          L"disablebinding"
#define SZ_CMD_MOVE_BINDING             L"movebinding"
#define SZ_CMD_WRITE_BINDINGS           L"writebindings"
#define SZ_CMD_SET_WANORDER             L"setwanorder"
#define SZ_CMD_FULL_DIAGNOSTIC          L"full"
#define SZ_CMD_CLEANUP                  L"cleanup"
#define SZ_CMD_ADD_REMOVE_STRESS        L"arstress"

#define SZ_CMD_SHOW_LAN_CONNECTIONS     L"showlan"
#define SZ_CMD_SHOW_LAN_DETAILS         L"showlandetails"
#define SZ_CMD_LAN_CHANGE_STATE         L"changelanstate"
#define SZ_CMD_SHOW_ALL_DEVICES         L"showalldevices"

#define SZ_PARAM_CONNECT                L"connect"
#define SZ_PARAM_DISCONNECT             L"disconnect"

// Parameter strings for SZ_CMD_SHOW_BINDINGS
//
#define SZ_PARAM_BELOW      L"below"
#define SZ_PARAM_INVOLVING  L"involving"
#define SZ_PARAM_UPPER      L"upper"
#define SZ_PARAM_DISABLED   L"disabled"

// Parameter strings for SZ_CMD_ADD_COMPONENT
//
#define SZ_PARAM_NET        L"net"
#define SZ_PARAM_INFRARED   L"irda"
#define SZ_PARAM_TRANS      L"trans"
#define SZ_PARAM_CLIENT     L"client"
#define SZ_PARAM_SERVICE    L"service"

// Parameter strings for SZ_CMD_MOVE_BINDING
//
#define SZ_PARAM_BEFORE     L"before"
#define SZ_PARAM_AFTER      L"after"

// Parameter strings for SZ_CMD_SET_WANORDER
//
#define SZ_PARAM_FIRST      L"first"
#define SZ_PARAM_LAST       L"last"

// Parameter strings for SZ_CMD_FULL_DIAGNOSTIC
//
#define SZ_PARAM_LEAK_CHECK L"leakcheck"

// Aliases used when refering to components
//
#define SZ_ALIAS_ALL        L"all"

VOID
Usage (
    IN PCTSTR pszProgramName,
    IN COMMAND Command)
{
    switch (Command)
    {
        case CMD_SHOW_BINDINGS:
            g_pDiagCtx->Printf (ttidNcDiag,
                "\n"
                "%S %S [below | involving | upper | disabled] [all | <infid> | <pnpid>]\n"
                "\n"
                "    below     : show bindings below component\n"
                "    involving : show bindings involving component\n"
                "    upper     : show adapter's upper bindings\n"
                "    disabled  : show disabled bindings\n"
                "\n"
                "  to specify the component:\n"
                "    all       : matches all components\n"
                "    <infid>   : matches component with specified Inf Id\n"
                "    <pnpid>   : matches component with specified PpP Id\n"
                "\n",
                pszProgramName,
                SZ_CMD_SHOW_BINDINGS);
            break;

        case CMD_SHOW_COMPONENTS:
            break;

        case CMD_SHOW_STACK_TABLE:
            break;

        case CMD_SHOW_LAN_ADAPTER_PNPIDS:
            break;

        case CMD_ADD_COMPONENT:
            g_pDiagCtx->Printf (ttidNcDiag,
                "\n"
                "%S %S <class> <infid>\n"
                "\n"
                "    <class>   : one of 'net', 'irda', 'trans', 'client', 'service'\n"
                "    <infid>   : the Inf ID of the component to add\n"
                "\n",
                pszProgramName,
                SZ_CMD_ADD_COMPONENT);
            break;

        case CMD_REMOVE_COMPONENT:
            g_pDiagCtx->Printf (ttidNcDiag,
                "\n"
                "%S %S [<infid> | <pnpid>]\n"
                "\n"
                "    <infid>   : matches component with specified Inf Id\n"
                "    <pnpid>   : matches component with specified PnP Id\n"
                "\n",
                pszProgramName,
                SZ_CMD_REMOVE_COMPONENT);
            break;

        case CMD_UPDATE_COMPONENT:
            g_pDiagCtx->Printf (ttidNcDiag,
                "\n"
                "%S %S [<infid> | <pnpid>]\n"
                "\n"
                "    <infid>   : matches component with specified Inf Id\n"
                "    <pnpid>   : matches component with specified PnP Id\n"
                "\n",
                pszProgramName,
                SZ_CMD_UPDATE_COMPONENT);
            break;

        case CMD_REMOVE_REFS:
            g_pDiagCtx->Printf (ttidNcDiag,
                "\n"
                "%S %S <infid>\n"
                "\n"
                "    <infid>   : matches component with specified Inf Id\n"
                "\n",
                pszProgramName,
                SZ_CMD_REMOVE_REFS);
            break;


        case CMD_ENABLE_BINDING:
        case CMD_DISABLE_BINDING:
            g_pDiagCtx->Printf (ttidNcDiag,
                "\n"
                "%S %S <bindpath>\n"
                "\n"
                "    <bindpath> : bindpath as specified like output of 'showbindings'\n"
                "\n",
                pszProgramName,
                (CMD_ENABLE_BINDING == Command)
                    ? SZ_CMD_ENABLE_BINDING
                    : SZ_CMD_DISABLE_BINDING);
            break;

        case CMD_MOVE_BINDING:
            g_pDiagCtx->Printf (ttidNcDiag,
                "\n"
                "%S %S <srcbindpath> [before | after] <dstbindpath>\n"
                "\n"
                "    <srcbindpath> : bindpath as specified like output of 'showbindings'\n"
                "    <dstbindpath> : bindpath as specified like output of 'showbindings'\n"
                "                    or 'null' to make srcbindpath first if 'before'\n"
                "                    is specified, or last if 'after' is specified\n"
                "\n",
                pszProgramName,
                SZ_CMD_MOVE_BINDING);
            break;

        case CMD_SET_WANORDER:
            g_pDiagCtx->Printf (ttidNcDiag,
                "\n"
                "%S %S [first | last]\n"
                "\n"
                "    first : order WAN adapters before LAN adapters\n"
                "    last  : order WAN adapters after LAN adapters\n"
                "\n",
                pszProgramName,
                SZ_CMD_SET_WANORDER);
            break;

        case CMD_FULL_DIAGNOSTIC:
            break;

        case CMD_ADD_REMOVE_STRESS:
            break;

        case CMD_SHOW_LAN_CONNECTIONS:
            break;

        case CMD_SHOW_ALL_DEVICES:
            break;

        case CMD_SHOW_LAN_DETAILS:
            g_pDiagCtx->Printf (ttidNcDiag,
                "\n"
                "%S %S <lan connection name>\n"
                "\n"
                "    <lan connection name> : friendly name of LAN connection\n"
                "         (note: use quotes if name contains spaces\n"
                "\n",
                pszProgramName,
                SZ_CMD_SHOW_LAN_DETAILS);
            break;

        case CMD_LAN_CHANGE_STATE:
            g_pDiagCtx->Printf (ttidNcDiag,
                "\n"
                "%S %S <lan connection name> [connect | disconnect]\n"
                "\n"
                "    <lan connection name> : friendly name of LAN connection\n"
                "         (note: use quotes if name contains spaces\n\n"
                "    <connect>    : connects the given lan connection\n"
                "    <disconnect> : disconnects the given lan connection\n"
                "\n",
                pszProgramName,
                SZ_CMD_LAN_CHANGE_STATE);
            break;

        default:
            g_pDiagCtx->Printf (ttidNcDiag,
                "\n"
                "Network Configuration Diagnostic\n"
                "   View, manipulate, or test network configuration.\n"
                "\n"
                "%S [options]\n"
                "   %-15S - Show the current bindings\n"
                "   %-15S - Show the currently installed components\n"
                "   %-15S - Show the current stack table\n"
                "   %-15S - Show PnP ids of LAN adapters\n"
                "   %-15S - Add a component\n"
                "   %-15S - Remove a component\n"
                "   %-15S - Update a component\n"
                "   %-15S - Enable a binding\n"
                "   %-15S - Disable a binding\n"
                "   %-15S - Change binding order\n"
                "   %-15S - Rewrite all bindings\n"
                "   %-15S - Change WAN adapter order\n"
                "   %-15S - Perform a full (non-destructive) diagnostic\n"
                "   %-15S - Perform Add/Remove component stress\n"
                "   %-15S - Show the current LAN connections\n"
                "   %-15S - Show details for a specific LAN connection\n"
                "   %-15S - Connects or disconnects a specific LAN connection\n"
                "   %-15S - Lists all devices\n"
                "\n\n",
                pszProgramName,
                SZ_CMD_SHOW_BINDINGS,
                SZ_CMD_SHOW_COMPONENTS,
                SZ_CMD_SHOW_STACK_TABLE,
                SZ_CMD_SHOW_LAN_ADAPTER_PNPIDS,
                SZ_CMD_ADD_COMPONENT,
                SZ_CMD_REMOVE_COMPONENT,
                SZ_CMD_UPDATE_COMPONENT,
                SZ_CMD_ENABLE_BINDING,
                SZ_CMD_DISABLE_BINDING,
                SZ_CMD_MOVE_BINDING,
                SZ_CMD_WRITE_BINDINGS,
                SZ_CMD_SET_WANORDER,
                SZ_CMD_FULL_DIAGNOSTIC,
                SZ_CMD_ADD_REMOVE_STRESS,
                SZ_CMD_SHOW_LAN_CONNECTIONS,
                SZ_CMD_SHOW_LAN_DETAILS,
                SZ_CMD_LAN_CHANGE_STATE,
                SZ_CMD_SHOW_ALL_DEVICES);
            break;
    }
}

#define NthArgIsPresent(_i) (_i < argc)
#define NthArgIs(_i, _sz)   ((_i < argc) && (0 == _wcsicmp(argv[_i], _sz)))

EXTERN_C
VOID
__cdecl
wmain (
    IN INT     argc,
    IN PCWSTR argv[])
{
    CDiagContext DiagCtx;
    DIAG_OPTIONS Options;
    INT iArg;

    DiagCtx.SetFlags (DF_SHOW_CONSOLE_OUTPUT);
    g_pDiagCtx = &DiagCtx;

    ZeroMemory (&Options, sizeof(Options));
    Options.pDiagCtx = g_pDiagCtx;
    Options.Command = CMD_INVALID;

    if (argc < 2)
    {
        Usage (argv[0], Options.Command);
        return;
    }

    iArg = 1;

    if (NthArgIs (iArg, SZ_CMD_SHOW_BINDINGS))
    {
        Options.Command = CMD_SHOW_BINDINGS;
        iArg++;

        if (NthArgIs (iArg, SZ_PARAM_BELOW))
        {
            Options.ShowBindParam = SHOW_BELOW;
        }
        else if (NthArgIs (iArg, SZ_PARAM_INVOLVING))
        {
            Options.ShowBindParam = SHOW_INVOLVING;
        }
        else if (NthArgIs (iArg, SZ_PARAM_UPPER))
        {
            Options.ShowBindParam = SHOW_UPPER;
        }
        else if (NthArgIs (iArg, SZ_PARAM_DISABLED))
        {
            Options.ShowBindParam = SHOW_DISABLED;
        }
        else
        {
            Usage (argv[0], Options.Command);
            return;
        }

        if (SHOW_DISABLED != Options.ShowBindParam)
        {
            iArg++;
            if (NthArgIs (iArg, SZ_ALIAS_ALL))
            {
                Options.CompSpecifier.Type = CST_ALL;
            }
            else if (NthArgIsPresent (iArg))
            {
                Options.CompSpecifier.Type = CST_BY_NAME;
                Options.CompSpecifier.pszInfOrPnpId = argv[iArg];
            }
            else
            {
                Usage (argv[0], Options.Command);
                return;
            }
        }
    }
    else if (NthArgIs (iArg, SZ_CMD_SHOW_COMPONENTS))
    {
        Options.Command = CMD_SHOW_COMPONENTS;
    }
    else if (NthArgIs (iArg, SZ_CMD_SHOW_STACK_TABLE))
    {
        Options.Command = CMD_SHOW_STACK_TABLE;
    }
    else if (NthArgIs (iArg, SZ_CMD_SHOW_LAN_ADAPTER_PNPIDS))
    {
        Options.Command = CMD_SHOW_LAN_ADAPTER_PNPIDS;
    }
    else if (NthArgIs (iArg, SZ_CMD_ADD_COMPONENT))
    {
        Options.Command = CMD_ADD_COMPONENT;
        iArg++;

        if (NthArgIs (iArg, SZ_PARAM_NET))
        {
            Options.ClassGuid = GUID_DEVCLASS_NET;
        }
        else if (NthArgIs (iArg, SZ_PARAM_INFRARED))
        {
            Options.ClassGuid = GUID_DEVCLASS_INFRARED;
        }
        else if (NthArgIs (iArg, SZ_PARAM_TRANS))
        {
            Options.ClassGuid = GUID_DEVCLASS_NETTRANS;
        }
        else if (NthArgIs (iArg, SZ_PARAM_CLIENT))
        {
            Options.ClassGuid = GUID_DEVCLASS_NETCLIENT;
        }
        else if (NthArgIs (iArg, SZ_PARAM_SERVICE))
        {
            Options.ClassGuid = GUID_DEVCLASS_NETSERVICE;
        }
        else
        {
            Usage (argv[0], Options.Command);
            return;
        }

        iArg++;
        if (NthArgIsPresent (iArg))
        {
            Options.pszInfId = argv[iArg];

            iArg++;
            if (NthArgIs (iArg, SZ_PARAM_LEAK_CHECK))
            {
                Options.fLeakCheck = TRUE;
            }
        }
        else
        {
            Usage (argv[0], Options.Command);
            return;
        }
    }
    else if (NthArgIs (iArg, SZ_CMD_REMOVE_COMPONENT))
    {
        Options.Command = CMD_REMOVE_COMPONENT;

        iArg++;
        if (NthArgIsPresent (iArg))
        {
            Options.pszInfId = argv[iArg];

            iArg++;
            if (NthArgIs (iArg, SZ_PARAM_LEAK_CHECK))
            {
                Options.fLeakCheck = TRUE;
            }
        }
        else
        {
            Usage (argv[0], Options.Command);
            return;
        }
    }
    else if (NthArgIs (iArg, SZ_CMD_UPDATE_COMPONENT))
    {
        Options.Command = CMD_UPDATE_COMPONENT;

        iArg++;
        if (NthArgIsPresent (iArg))
        {
            Options.pszInfId = argv[iArg];

            iArg++;
            if (NthArgIs (iArg, SZ_PARAM_LEAK_CHECK))
            {
                Options.fLeakCheck = TRUE;
            }
        }
        else
        {
            Usage (argv[0], Options.Command);
            return;
        }
    }
    else if (NthArgIs (iArg, SZ_CMD_REMOVE_REFS))
    {
        Options.Command = CMD_REMOVE_REFS;

        iArg++;
        if (NthArgIsPresent (iArg))
        {
            Options.pszInfId = argv[iArg];

            iArg++;
            if (NthArgIs (iArg, SZ_PARAM_LEAK_CHECK))
            {
                Options.fLeakCheck = TRUE;
            }
        }
        else
        {
            Usage (argv[0], Options.Command);
            return;
        }
    }
    else if (NthArgIs (iArg, SZ_CMD_ENABLE_BINDING))
    {
        Options.Command = CMD_ENABLE_BINDING;
        iArg++;
        if (NthArgIsPresent (iArg))
        {
            Options.pszBindPath = argv[iArg];

            iArg++;
            if (NthArgIs (iArg, SZ_PARAM_LEAK_CHECK))
            {
                Options.fLeakCheck = TRUE;
            }
        }
        else
        {
            Usage (argv[0], Options.Command);
            return;
        }
    }
    else if (NthArgIs (iArg, SZ_CMD_DISABLE_BINDING))
    {
        Options.Command = CMD_DISABLE_BINDING;
        iArg++;
        if (NthArgIsPresent (iArg))
        {
            Options.pszBindPath = argv[iArg];

            iArg++;
            if (NthArgIs (iArg, SZ_PARAM_LEAK_CHECK))
            {
                Options.fLeakCheck = TRUE;
            }
        }
        else
        {
            Usage (argv[0], Options.Command);
            return;
        }
    }
    else if (NthArgIs (iArg, SZ_CMD_MOVE_BINDING))
    {
        Options.Command = CMD_MOVE_BINDING;
        iArg++;
        if (NthArgIsPresent (iArg) &&
            NthArgIsPresent (iArg+1) &&
            NthArgIsPresent (iArg+2))
        {
            Options.pszBindPath = argv[iArg];
            Options.pszOtherBindPath = argv[iArg+2];

            if (NthArgIs (iArg+1, SZ_PARAM_BEFORE))
            {
                Options.fMoveBefore = TRUE;
            }
            else if (NthArgIs (iArg+1, SZ_PARAM_AFTER))
            {
                Options.fMoveBefore = FALSE;
            }
            else
            {
                Usage (argv[0], Options.Command);
                return;
            }
        }
        else
        {
            Usage (argv[0], Options.Command);
            return;
        }
    }
    else if (NthArgIs (iArg, SZ_CMD_WRITE_BINDINGS))
    {
        Options.Command = CMD_WRITE_BINDINGS;

        iArg++;
        if (NthArgIs (iArg, SZ_PARAM_LEAK_CHECK))
        {
            Options.fLeakCheck = TRUE;
        }
    }
    else if (NthArgIs (iArg, SZ_CMD_SET_WANORDER))
    {
        Options.Command = CMD_SET_WANORDER;
        iArg++;
        if (NthArgIs (iArg+1, SZ_PARAM_FIRST))
        {
            Options.fWanAdaptersFirst = TRUE;
        }
        else if (NthArgIs (iArg+1, SZ_PARAM_LAST))
        {
            Options.fWanAdaptersFirst = FALSE;
        }
        else
        {
            Usage (argv[0], Options.Command);
            return;
        }
    }
    else if (NthArgIs (iArg, SZ_CMD_FULL_DIAGNOSTIC))
    {
        Options.Command = CMD_FULL_DIAGNOSTIC;

        iArg++;
        if (NthArgIs (iArg, SZ_PARAM_LEAK_CHECK))
        {
            Options.fLeakCheck = TRUE;
        }
    }
    else if (NthArgIs (iArg, SZ_CMD_CLEANUP))
    {
        Options.Command = CMD_CLEANUP;
    }
    else if (NthArgIs (iArg, SZ_CMD_ADD_REMOVE_STRESS))
    {
        Options.Command = CMD_ADD_REMOVE_STRESS;

        iArg++;
        if (NthArgIs (iArg, SZ_PARAM_LEAK_CHECK))
        {
            Options.fLeakCheck = TRUE;
        }
    }
    else if (NthArgIs (iArg, SZ_CMD_SHOW_LAN_CONNECTIONS))
    {
        Options.Command = CMD_SHOW_LAN_CONNECTIONS;
    }
    else if (NthArgIs (iArg, SZ_CMD_SHOW_ALL_DEVICES))
    {
        Options.Command = CMD_SHOW_ALL_DEVICES;
    }
    else if (NthArgIs (iArg, SZ_CMD_SHOW_LAN_DETAILS))
    {
        Options.Command = CMD_SHOW_LAN_DETAILS;
        iArg++;

        if (NthArgIsPresent (iArg))
        {
            Options.szLanConnection = argv[iArg];
        }
        else
        {
            Usage (argv[0], Options.Command);
            return;
        }
    }
    else if (NthArgIs (iArg, SZ_CMD_LAN_CHANGE_STATE))
    {
        Options.Command = CMD_LAN_CHANGE_STATE;
        iArg++;

        if (NthArgIsPresent (iArg))
        {
            Options.szLanConnection = argv[iArg];

            if (NthArgIs (iArg + 1, SZ_PARAM_CONNECT))
            {
                Options.fConnect = TRUE;
            }
            else if (NthArgIs (iArg + 1, SZ_PARAM_DISCONNECT))
            {
                Options.fConnect = FALSE;
            }
            else
            {
                Usage (argv[0], Options.Command);
                return;
            }
        }
        else
        {
            Usage (argv[0], Options.Command);
            return;
        }
    }
    else
    {
        Usage (argv[0], Options.Command);
        return;
    }

    // If we're doing leak checking, preload some DLLs that are delayloaded.
    // If we don't do this, we see a buncn of "leaks" associated with
    // the loader bringing in DLLs in the middle of our tests.
    //
    if (Options.fLeakCheck)
    {
        LoadLibraryW (L"mswsock.dll");
        LoadLibraryW (L"comctl32.dll");
        LoadLibraryW (L"comdlg32.dll");
        LoadLibraryW (L"mprapi.dll");
        LoadLibraryW (L"mswsock.dll");
        LoadLibraryW (L"netapi32.dll");
        LoadLibraryW (L"rtutils.dll");
        LoadLibraryW (L"setupapi.dll");
        LoadLibraryW (L"shell32.dll");
        LoadLibraryW (L"userenv.dll");
        LoadLibraryW (L"winspool.drv");
        LoadLibraryW (L"ws2_32.dll");
    }

    HRESULT hr = CoInitializeEx (
                NULL,
                COINIT_DISABLE_OLE1DDE | COINIT_APARTMENTTHREADED);

    if (FAILED(hr))
    {
            g_pDiagCtx->Printf (ttidNcDiag,
                "Problem 0x%08x initializing COM library", hr);
            return;
    }

    // Call each of the external command processors
    //
    NetCfgDiagFromCommandArgs (&Options);
    NetManDiagFromCommandArgs (&Options);

    g_pDiagCtx->Printf (ttidNcDiag, "\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\tools\netafx\implinc.cpp ===
#pragma hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\tools\netafx\getopt.h ===
#pragma once

extern WCHAR* optarg;

EXTERN_C WCHAR  getopt (ULONG Argc, WCHAR* Argv[], WCHAR* Opts);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\tools\netafx\version.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       V E R S I O N . H
//
//  Contents:   Provides version info
//
//  Author:     kumarp    10-December-97
//
//----------------------------------------------------------------------------

#include <ntverp.h>
#include <winver.h>

#define VER_FILETYPE                    VFT_DLL
#define VER_FILESUBTYPE                 VFT2_UNKNOWN
#define VER_FILEDESCRIPTION_STR         "Network Configuration Tool"
#define VER_INTERNALNAME_STR            "netafx.exe"

#include "common.ver"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\tools\netafx\getopt.cpp ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    getopt.c

Abstract:

    Utility function to parse command line options.
    Inspired by UNIX getopt - but coded from scratch.
    Not thread-safe currently (don't call this from
    multiple threads simultaneously)

Author:

    Ravisankar Pudipeddi (ravisp) 27 June 1997

Environment:

    User

Notes:

Revision History:

--*/

#include "pch.h"
#pragma hdrstop


#include "getopt.h"

WCHAR*  optarg;
ULONG  optind=1;
static ULONG optcharind;
static ULONG hyphen=0;

WCHAR
getopt (ULONG Argc, WCHAR* Argv[], WCHAR* Opts)

/*++

Routine Description:

    Parses command line arguments.
    This function should be repeatedly called
    to parse all the supplied command line options.
    A command line argument prefixed with a hyphen/slash
    ('-' or '/') is treated as a command line option(s).
    The set of options the caller is interested in
    is passed via the Opts argument.

    The format of this desired options list is:

    "<option-letter1>[:]<option-letter2>[:]......."

    Examples: "ds:g",  "x:o:r" etc.
    Each letter in this string is an option the
    caller is interested in.
    If there is a colon (':') after the option letter,
    then the caller expects an argument with this option
    letter.
    On each call, successive options are processed and
    the next matching option in the list of desired options
    is returned. If the option requires an argument, then
    the option argument is in the global 'optarg'.
    If all the options have been processed then the value
    EOF is returned at which point caller should desist
    calling this function again for the lifetime of the process.

    A single hyphen/slash ('-' or '/) unaccompanied by any option
    letter in the command line indicates  getopt to stop processing
    command line options and treat the rest of the arguments
    as regular command line arguments.

    After all the options have been processed (i.e. getopt
    returned EOF), the global 'optind' contains the index
    to the start of the non-option arguments which may be
    processed by the caller.

    Note: This function *does not* return an error code if
    an non-desired option is encountered in the command line.

Arguments:

    Argc  -  number of command line arguments
    Argv  -  pointer to array of command line arguments
             (Argv[0] is skipped in processing the options,
              treated as the base filename of the executable)

    Opts  -  String containing the desired options

Return Value:

    EOF   - No more options. Don't call this function again.
            The global 'optind' points to index of the first argument
            following the options on the command line

    0     - Error in specifying command line options

    Any other character -  Next option on the command line.
                           The value 'optarg' points to the command line
                           argument string following this option, if
                           the option was indicated as requiring an argument
                           (i.e. preceding a colon in the Opts string)

--*/
{
    WCHAR  ch;
    WCHAR* indx;

    do {
        if (optind >= Argc) {
            return EOF;
        }

        ch = Argv[optind][optcharind++];
        if (ch == '\0') {
            optind++; optcharind=0;
            hyphen = 0;
            continue;
        }

        if ( hyphen || (ch == '-') || (ch == '/')) {
            if (!hyphen) {
                ch = Argv[optind][optcharind++];
                if (ch == '\0') {
                    //
                    // just a '-' (or '/')  without any other
                    // char after it indicates to stop
                    // processing options, the rest are
                    // regular command line arguments
                    // optind points to the arguments after
                    // this lone hyphen
                    //
                    optind++;
                    return EOF;
                }
            } else if (ch == '\0') {
                //
                // End of options on this arg.
                // continue to next...
                optind++;
                optcharind = 0;
                continue;
            }
            //indx = strchr(Opts, ch);
            indx = wcschr(Opts, ch);
            if (indx == NULL) {
                //
                // Non-desired option encountered
                // We just ignore it
                //
                continue;
            }
            if (*(indx+1) == ':') {
                if (Argv[optind][optcharind] != '\0'){
                    optarg = &Argv[optind][optcharind];
                } else {
                    if ((optind + 1) >= Argc ||
                        (Argv[optind+1][0] == '-' ||
                         Argv[optind+1][0] == '/' )) {
                        //
                        // This is a case when one of the following error
                        // condition exists:
                        //  1. The user didn't supply an argument to an option
                        //     which requires one (ie, this option was the last
                        //     command line argument on the line)
                        //  2. The  supplied another option as an argument to this
                        //     option. Currently we treat this as an error
                        //
                        return 0;
                    }
                    optarg = Argv[++optind];
                }
                optind++;
                hyphen = optcharind = 0;
                return ch;
            }
            //
            // Argument not required for this option
            // So any other characters in the same
            // argument would be other valid options
            //
            hyphen = 1;
            return ch;
        } else {
            //
            // Non option encountered.
            // No more options present..
            //
            return EOF;
        }
    } while (1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\tools\rasbindc\version.h ===
#pragma once

#include <ntverp.h>
#include <winver.h>

#define VER_FILETYPE                    VFT_APP
#define VER_FILESUBTYPE                 VFT2_UNKNOWN
#define VER_FILEDESCRIPTION_STR         "RAS Binding Config"
#define VER_INTERNALNAME_STR            "rasbindc.exe"

#include <common.ver>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\tools\svchostc\svchostc.c ===
// Private nt headers.
//
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <netcfgp.h>
#include <stdio.h>      // printf


VOID
__cdecl
wmain (
    int     argc,
    PCWSTR argv[])
{
    HRESULT hr;
    PCWSTR pszService;
    PCWSTR pszNewGroup;

    // Argument check
    //
    if (3 != argc)
    {
        printf ("%S <service> <svchost group>\n", argv[0]);
        return;
    }

    pszService  = argv[1];
    pszNewGroup = argv[2];

    hr = SvchostChangeSvchostGroup (
            pszService,
            pszNewGroup);

    if (FAILED(hr))
    {
        printf ("error: SvchostChangeSvchostGroup failed. (0x%08x)\n\n",
            hr);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\tools\netafx\netafx.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       N E T A F X . C P P
//
//  Contents:   Tool for applying answerfile
//
//  Author:     kumarp    10-December-97
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

#include "getopt.h"
#include "ncstring.h"
#include "kkutils.h"
#include "ncnetcfg.h"
#include "ncerror.h"
#include "nceh.h"
#include "nsexports.h"

class CNetAfxOptions
{
public:
    tstring m_strAFileName;
    BOOL    m_fVerbose;
    BOOL    m_fShowComponents;

    CNetAfxOptions()
    {
        m_fVerbose = FALSE;
        m_fShowComponents = FALSE;
    }
};

// ----------------------------------------------------------------------
// Global vars
//
BOOL     g_fVerbose=FALSE;
INetCfg* g_pINetCfg=NULL;
BOOL     g_fInitCom=TRUE;

// ----------------------------------------------------------------------
BOOL FParseCmdLine(IN  int argc,
                   IN  WCHAR* argv[],
                   OUT CNetAfxOptions* pnaOptions);
void ShowUsage();
HRESULT HrApplyAnswerFile(IN INetCfg* pnc,
                          IN PCWSTR szAnswerFileName,
                          IN BOOL fVerbose);
void ShowAnswerFileErrors(IN TStringList* pslErrors);
void ShowMsgIfVerbose(IN BOOL fVerbose, IN PCWSTR szMsg, ...);
void ShowMsgIfGlobalVerboseV(IN PCWSTR szMsg, IN va_list arglist);
void ShowMsgIfVerboseV(IN BOOL fVerbose, IN PCWSTR szMsg, IN va_list arglist);
HRESULT HrGetInstalledComponentList(IN  INetCfg* pnc,
                                    IN  const GUID*    pguidClass,
                                    OUT TStringList* pslComponents,
                                    OUT TStringList* pslDescriptions);
HRESULT HrShowInstalledComponentList(IN INetCfg* pnc,
                                     IN const GUID*    pguidClass);
HRESULT HrDoNetAfx(IN CNetAfxOptions* pnaOptions);
BOOL WINAPI NetAfxConsoleCrtlHandler(IN DWORD dwCtrlType);


// ----------------------------------------------------------------------
//
// Function:  wmain
//
// Purpose:   The main function
//
// Arguments: standard main args
//
// Returns:   0 on success, non-zero otherwise
//
// Author:    kumarp 25-December-97
//
// Notes:
//
EXTERN_C int __cdecl wmain(int argc, WCHAR* argv[])
{
    tstring strAFileName;
    BOOL fVerbose;
    HRESULT hr=S_OK;
    CNetAfxOptions naOptions;

    InitializeDebugging();

    if (FParseCmdLine(argc, argv, &naOptions))
    {
        SetConsoleCtrlHandler(NetAfxConsoleCrtlHandler, TRUE);

        hr = HrDoNetAfx(&naOptions);
    }
    else
    {
        ShowUsage();
    }

    UnInitializeDebugging();

    return hr;
}

// ----------------------------------------------------------------------
//
// Function:  HrDoNetAfx
//
// Purpose:   Perform actions specified by pnaOptions
//
// Arguments:
//    pnaOptions [in]  pointer to CNetAfxOptions object
//
// Returns:   S_OK on success, otherwise an error code
//
// Author:    kumarp 19-February-98
//
// Notes:
//
HRESULT HrDoNetAfx(IN CNetAfxOptions* pnaOptions)
{
    AssertValidReadPtr(pnaOptions);

    DefineFunctionName("HrDoNetAfx");

    static const WCHAR c_szNetAfxName[] = L"netafx.exe";

    HRESULT hr=S_OK;
    PCWSTR szAnswerFileName;

    g_fVerbose = pnaOptions->m_fVerbose;

    szAnswerFileName = pnaOptions->m_strAFileName.c_str();


    PWSTR     pszwClientDesc  = NULL;
    const UINT c_cmsWaitForINetCfgWrite = 120000;
    BOOL fNeedWriteLock=FALSE;

    ShowMsgIfVerbose(pnaOptions->m_fVerbose, L"Trying to get INetCfg...");

    fNeedWriteLock = !pnaOptions->m_strAFileName.empty();

    hr = HrCreateAndInitializeINetCfg(&g_fInitCom, &g_pINetCfg, fNeedWriteLock,
                                      c_cmsWaitForINetCfgWrite,
                                      c_szNetAfxName,
                                      &pszwClientDesc);
    if (S_OK == hr)
    {
        Assert(!pszwClientDesc);
        ShowMsgIfVerbose(pnaOptions->m_fVerbose, L"...got it");

        if (pnaOptions->m_fShowComponents)
        {
            (void) HrShowInstalledComponentList(g_pINetCfg,
                                                &GUID_DEVCLASS_NET);
            (void) HrShowInstalledComponentList(g_pINetCfg,
                                                &GUID_DEVCLASS_NETTRANS);
            (void) HrShowInstalledComponentList(g_pINetCfg,
                                                &GUID_DEVCLASS_NETCLIENT);
            (void) HrShowInstalledComponentList(g_pINetCfg,
                                                &GUID_DEVCLASS_NETSERVICE);
        }

        if (!pnaOptions->m_strAFileName.empty())
        {
            hr = HrApplyAnswerFile(g_pINetCfg, szAnswerFileName,
                                   pnaOptions->m_fVerbose);
        }

        TraceTag(ttidNetAfx, "%s: releasing INetCfg...", __FUNCNAME__);
        (void) HrUninitializeAndReleaseINetCfg(g_fInitCom, g_pINetCfg, TRUE);
        g_pINetCfg = NULL;
    }
    else if (NETCFG_E_NO_WRITE_LOCK == hr)
    {
        Assert (pszwClientDesc);
        ShowMsgIfVerbose(pnaOptions->m_fVerbose,
                         L"... failed to lock INetCfg. "
                         L"It is already locked by '%s'", pszwClientDesc);
        CoTaskMemFree(pszwClientDesc);
    }
    else
    {
        Assert(!pszwClientDesc);
        ShowMsgIfVerbose(pnaOptions->m_fVerbose,
                         L"...error getting INetCfg, "
                         L"error code: 0x%x", hr);
    }

    TraceError(__FUNCNAME__, hr);

    return hr;
}


// ----------------------------------------------------------------------
//
// Function:  HrApplyAnswerFile
//
// Purpose:   Run & apply the specified answerfile
//
// Arguments:
//    szAnswerFileName [in]  name of answerfile
//    fVerbose         [in]  display verbose messages when TRUE
//
// Returns:   S_OK on success, otherwise an error code
//
// Author:    kumarp 24-December-97
//
// Notes:
//
HRESULT HrApplyAnswerFile(IN INetCfg* pnc,
                          IN PCWSTR szAnswerFileName,
                          IN BOOL fVerbose)
{
    DefineFunctionName("HrApplyAnswerFile");

    static const WCHAR c_szAFileDll[] =
        L"netshell.dll";
    static const CHAR  c_szNetSetupSetProgressCallback[] =
        "NetSetupSetProgressCallback";
    static const CHAR  c_szNetSetupApplyAnswerFile[] =
        "HrNetSetupApplyAnswerFile";


    ShowMsgIfVerbose(fVerbose, L"Applying answerfile: %s",
                     szAnswerFileName);

    BOOL fRebootRequired=FALSE;
    HRESULT hr=S_OK;
    HMODULE hDll;
    NetSetupSetProgressCallbackFn pfNetSetupSetProgressCallback;
    HrNetSetupApplyAnswerFileFn   pfHrNetSetupApplyAnswerFileFn;
    TStringList* pslErrors;

    hr = HrLoadLibAndGetProcsV(c_szAFileDll,
                               &hDll,
                               c_szNetSetupSetProgressCallback,
                               (FARPROC*) &pfNetSetupSetProgressCallback,
                               c_szNetSetupApplyAnswerFile,
                               (FARPROC*) &pfHrNetSetupApplyAnswerFileFn,
                               NULL);


    if (S_OK == hr)
    {
        NC_TRY
        {
            pfNetSetupSetProgressCallback(ShowMsgIfGlobalVerboseV);

            hr = pfHrNetSetupApplyAnswerFileFn(pnc,
                                               szAnswerFileName,
                                               &pslErrors);
            fRebootRequired = NETCFG_S_REBOOT == hr;
        }

        NC_CATCH_ALL
        {
            hr = E_FAIL;
            ShowMsgIfVerbose(fVerbose,
                             L"...unhandled exception in netshell.dll");
        }

        FreeLibrary(hDll);
    }

    if (SUCCEEDED(hr))
    {
        ShowMsgIfVerbose(fVerbose,
                         L"answerfile '%s' successfully applied",
                         szAnswerFileName);
    }
    else
    {
        if (NETSETUP_E_ANS_FILE_ERROR == hr)
        {
            ShowAnswerFileErrors(pslErrors);
        }
        else
        {
            ShowMsgIfVerbose(fVerbose,
                             L"answerfile '%s' could not be "
                             L"successfully applied. error code: 0x%x",
                             szAnswerFileName, hr);
        }
    }

    if (fRebootRequired)
    {
        ShowMsgIfVerbose(TRUE,
                         L"You must shut down and restart your computer "
                         L"before the new settings will take effect.");
    }

    TraceError(__FUNCNAME__, hr);

    return hr;
}

// ----------------------------------------------------------------------
//
// Function:  ShowAnswerFileErrors
//
// Purpose:   Display errors in the answerfile
//
// Arguments:
//    pslErrors [in]  pointer to list of
//
// Returns:   None
//
// Author:    kumarp 24-December-97
//
// Notes:
//
void ShowAnswerFileErrors(IN TStringList* pslErrors)
{
    TStringListIter pos;
    PCWSTR szError;

    wprintf(L"Answerfile has the following errors. Cannot continue...");

    for (pos = pslErrors->begin(); pos != pslErrors->end(); pos++)
    {
        szError = (*pos)->c_str();
        wprintf(L"%s\n", szError);
    }
}

// ----------------------------------------------------------------------
//
// Function:  ShowMsgIfVerboseV
//
// Purpose:   Show the passed message if we are in verbose mode
//            otherwise do nothing.
//
// Arguments:
//    szMsg    [in]  message
//    arglist  [in]  list of arguments
//
// Returns:   None
//
// Author:    kumarp 15-April-98
//
// Notes:
//
void ShowMsgIfGlobalVerboseV(IN PCWSTR szMsg, IN va_list arglist)
{
    ShowMsgIfVerboseV(g_fVerbose, szMsg, arglist);
}

// ----------------------------------------------------------------------
//
// Function:  ShowMsgIfVerboseV
//
// Purpose:   Show the passed message if we are in verbose mode
//            otherwise do nothing.
//
// Arguments:
//    fVerbose [in]  flag indicating verbose mode
//    szMsg    [in]  message
//    arglist  [in]  list of arguments
//
// Returns:   None
//
// Author:    kumarp 15-April-98
//
// Notes:
//
void ShowMsgIfVerboseV(IN BOOL fVerbose, IN PCWSTR szMsg, IN va_list arglist)
{
    static WCHAR szTempBuf[1024];

    vswprintf(szTempBuf, szMsg, arglist);

    if (fVerbose)
    {
        wprintf(L"%s\n", szTempBuf);
        fflush(stdout);
    }

    TraceTag(ttidNetAfx, "%S", szTempBuf);
}

// ----------------------------------------------------------------------
//
// Function:  ShowMsgIfVerbose
//
// Purpose:   Show the passed message only if Verbose mode is on
//
// Arguments:
//    szMsg    [in]  message to be displayed
//    fVerbose [in]  flag controlling the verbose mode
//
// Returns:   None
//
// Author:    kumarp 24-December-97
//
// Notes:
//
void ShowMsgIfVerbose(IN BOOL fVerbose, IN PCWSTR szMsg, ...)
{
    va_list arglist;

    va_start(arglist, szMsg);
    ShowMsgIfVerboseV(fVerbose, szMsg, arglist);
    va_end(arglist);
}


// ----------------------------------------------------------------------
//
// Function:  FParseCmdLine
//
// Purpose:   Parse command line arguments
//
// Arguments:
//    argc          [in]  number of arguments
//    argv          [in]  pointer to array of command line arguments
//    pstrAFileName [out] name of answerfile
//    pfVerbose     [out] flag controlling the verbose mode
//
// Returns:   TRUE if all cmd line arguments correct, FALSE otherwise
//
// Author:    kumarp 24-December-97
//
// Notes:
//
BOOL FParseCmdLine(IN  int argc,
                   IN  WCHAR* argv[],
                   OUT CNetAfxOptions* pnaOptions)
{
    DefineFunctionName("FParseCmdLine");

    AssertValidReadPtr(argv);
    AssertValidWritePtr(pnaOptions);

    BOOL fStatus=FALSE;
    CHAR ch;

    static const WCHAR c_szValidOptions[] = L"f:vVlLhH?";
    WCHAR szFileFullPath[MAX_PATH+1];
    PWSTR szFileComponent;

    while ((ch = getopt(argc, argv, (WCHAR*) c_szValidOptions)) != EOF)
    {
        switch (ch)
        {
        case 'f':
            int nChars;
            nChars = GetFullPathName(optarg, MAX_PATH,
                                     szFileFullPath, &szFileComponent);
            if (nChars)
            {
                pnaOptions->m_strAFileName = szFileFullPath;
            }
            fStatus = TRUE;
            break;

        case 'v':
        case 'V':
            pnaOptions->m_fVerbose = TRUE;
            break;

        case 'l':
        case 'L':
            pnaOptions->m_fShowComponents = TRUE;
            fStatus = TRUE;
            break;

        default:
        case 'h':
        case 'H':
        case '?':
        case 0:
            fStatus = FALSE;
            break;
        }
    }

    return fStatus;
}

// ----------------------------------------------------------------------
//
// Function:  ShowUsage
//
// Purpose:   Display program usage help
//
// Arguments: None
//
// Returns:   None
//
// Author:    kumarp 24-December-97
//
// Notes:
//
void ShowUsage()
{
static const WCHAR c_szUsage[] =
    L"Command syntax\n"
    L"--------------\n"
    L"netafx [/f [drive:][path]filename ] [/v] [/l]\n"
    L"  or\n"
    L"netafx /?\n"
    L"\n"
    L"  /f [drive:][path]filename\n"
    L"\t      Specifies the answerfile name.\n"
    L"\n"
    L"  /V\t  Turns on the verbose mode that dumps what is being applied and\n"
    L"    \t  what result is returned.  The default is off.\n"
    L"  /l\t  Displays list of installed networking components\n"
    L"  /?\t  Displays this help\n"
    L"\n"
    L"\n"
    L"General Overview\n"
    L"----------------\n"
    L"netafx is a tool that you can use for listing, installing, "
    L"configuring and uninstalling networking components. To list  "
    L"installed components use the /l option. For other operations you "
    L"need to provide a text file (also called AnswerFile) that describes "
    L"the actions that you want to perform. "
    L"For more information on the syntax of the AnswerFile, please refer "
    L"to the document 'Unattended Setup Parameters'"
    L"\n";

    wprintf(c_szUsage);
}

// ----------------------------------------------------------------------
//
// Function:  HrGetInstalledComponentList
//
// Purpose:   Get list of installed networking components
//
// Arguments:
//    pnc             [in]  pointer to INetCfg object
//    pguidClass      [in]  pointer to class whose components are requested
//    pslComponents   [out] pointer to list of components
//    pslDescriptions [out] pointer to list of descriptions
//
// Returns:   S_OK on success, otherwise an error code
//
// Author:    kumarp 15-April-98
//
// Notes:
//
HRESULT HrGetInstalledComponentList(IN  INetCfg* pnc,
                                    IN  const GUID*    pguidClass,
                                    OUT TStringList* pslComponents,
                                    OUT TStringList* pslDescriptions)
{
    DefineFunctionName("HrGetInstalledComponentList");

    AssertValidReadPtr(pnc);
    AssertValidReadPtr(pguidClass);
    AssertValidWritePtr(pslComponents);
    AssertValidWritePtr(pslDescriptions);

    static const WCHAR c_szErrorGettingDisplayName[] =
        L"<Error getting display name>";

    HRESULT hr=S_OK;
    CIterNetCfgComponent nccIter(pnc, pguidClass);
    PWSTR pszwInfId;
    DWORD dwcc;

    INetCfgComponent* pINetCfgComponent;
    while (SUCCEEDED(hr) && (S_OK == (hr = nccIter.HrNext(&pINetCfgComponent))))
    {
        if (pguidClass == &GUID_DEVCLASS_NET)
        {
            // we are interested only in physical netcards
            //
            hr = pINetCfgComponent->GetCharacteristics(&dwcc);

            if (FAILED(hr) || !(dwcc & NCF_PHYSICAL))
            {
                hr = S_OK;
                ReleaseObj(pINetCfgComponent);
                continue;
            }
        }

        hr = pINetCfgComponent->GetId(&pszwInfId);

        if (S_OK == hr)
        {
            pslComponents->push_back(new tstring(pszwInfId));

            PWSTR pszwDisplayName;
            hr = pINetCfgComponent->GetDisplayName(&pszwDisplayName);
            if (SUCCEEDED(hr))
            {
                pslDescriptions->push_back(new tstring(pszwDisplayName));
                CoTaskMemFree(pszwDisplayName);
            }
            else
            {
                pslDescriptions->push_back(new tstring(c_szErrorGettingDisplayName));
            }

            CoTaskMemFree(pszwInfId);
        }
        // we dont want to quit upgrade just because 1 component
        // failed OsUpgrade, therefore reset hr to S_OK
        hr = S_OK;

        ReleaseObj(pINetCfgComponent);
    }

    if (S_FALSE == hr)
    {
        hr = S_OK;
    }

    TraceError(__FUNCNAME__, hr);
    return hr;
}

// ----------------------------------------------------------------------
//
// Function:  HrShowInstalledComponentList
//
// Purpose:   Display list of installed networking componetns
//
// Arguments:
//    pnc        [in]  pointer to INetCfg object
//    pguidClass [in]  class whose components are to be listed
//
// Returns:   S_OK on success, otherwise an error code
//
// Author:    kumarp 15-April-98
//
// Notes:
//
HRESULT HrShowInstalledComponentList(IN INetCfg* pnc,
                                     IN const GUID*    pguidClass)
{
    DefineFunctionName("HrShowInstalledComponentList");

    HRESULT hr=S_OK;
    PCWSTR szClassName;

    static const WCHAR c_szNetCards[]     = L"Network Adapters";
    static const WCHAR c_szNetProtocols[] = L"Network Protocols";
    static const WCHAR c_szNetServices[]  = L"Network Services";
    static const WCHAR c_szNetClients[]   = L"Network Clients";

    if (pguidClass == &GUID_DEVCLASS_NET)
    {
        szClassName = c_szNetCards;
    }
    else if (pguidClass == &GUID_DEVCLASS_NETTRANS)
    {
        szClassName = c_szNetProtocols;
    }
    else if (pguidClass == &GUID_DEVCLASS_NETSERVICE)
    {
        szClassName = c_szNetServices;
    }
    else if (pguidClass == &GUID_DEVCLASS_NETCLIENT)
    {
        szClassName = c_szNetClients;
    }
    else
    {
        szClassName = NULL;
    }

    Assert(szClassName);

    wprintf(L"\n%s\n-----------------\n", szClassName);

    TStringList slComponents;
    TStringList slDisplayNames;

    hr = HrGetInstalledComponentList(pnc, pguidClass, &slComponents,
                                     &slDisplayNames);
    if (S_OK == hr)
    {
        TStringListIter pos1, pos2;
        PCWSTR szComponentId;
        PCWSTR szDisplayName;

        pos1 = slComponents.begin();
        pos2 = slDisplayNames.begin();

        while (pos1 != slComponents.end())
        {
            Assert(pos2 != slDisplayNames.end());

            szComponentId = (*pos1++)->c_str();
            szDisplayName   = (*pos2++)->c_str();

            wprintf(L"%-26s %s\n", szComponentId, szDisplayName);
        }
    }

    TraceError(__FUNCNAME__, hr);

    return hr;
}

// ----------------------------------------------------------------------
//
// Function:  NetAfxConsoleCrtlHandler
//
// Purpose:   Release resources on abnormal exit
//
// Arguments:
//    dwCtrlType [in]  reason of abnormal exit
//
// Returns:   FALSE --> so that netafx will be terminated
//
// Author:    kumarp 15-April-98
//
// Notes:
//
BOOL WINAPI NetAfxConsoleCrtlHandler(IN DWORD dwCtrlType)
{
    DefineFunctionName("NetAfxConsoleCrtlHandler");

    // Handles all dwCtrlType i.e. ignore the passed type

    if (g_pINetCfg)
    {
        TraceTag(ttidNetAfx, "%s: abnormal exit, releasing INetCfg...",
                 __FUNCNAME__);
        (void) HrUninitializeAndReleaseINetCfg(g_fInitCom, g_pINetCfg, TRUE);
        g_pINetCfg = NULL;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\tools\rasbindc\rasbindc.c ===
// Private nt headers.
//
//#include <nt.h>
//#include <ntrtl.h>
//#include <nturtl.h>

#include <stdio.h>
#include <tchar.h>

#include <windows.h>
#include <rasapip.h>


#define SZ_CMD_COUNT    L"count"
#define SZ_CMD_ADD      L"add"
#define SZ_CMD_REMOVE   L"remove"

#define SZ_PARAM_IPOUT  L"ipout="
#define SZ_PARAM_NBFIN  L"nbfin="
#define SZ_PARAM_NBFOUT L"nbfout="

typedef enum _COMMAND
{
    CMD_INVALID = 0,
    CMD_COUNT,
    CMD_ADD,
    CMD_REMOVE,
} COMMAND;

typedef struct _OPTIONS
{
    COMMAND Command;
    UINT    cIpOut;
    UINT    cNbfIn;
    UINT    cNbfOut;
} OPTIONS;

VOID
ExecuteCommand (
    IN const OPTIONS* pOptions)
{
    HRESULT hr;
    UINT    cIpOut, cNbfIn, cNbfOut;

    switch (pOptions->Command)
    {
        case CMD_COUNT:
            hr = RasCountBindings (
                    &cIpOut,
                    &cNbfIn,
                    &cNbfOut);

            printf (
                "TCP/IP Dial-Out:  %u\n"
                "NetBEUI Dial-In:  %u\n"
                "NetBEUI Dial-Out: %u\n",
                cIpOut, cNbfIn, cNbfOut);
            break;

        case CMD_ADD:
            cIpOut  = pOptions->cIpOut;
            cNbfIn  = pOptions->cNbfIn;
            cNbfOut = pOptions->cNbfOut;

            hr = RasAddBindings (
                    &cIpOut,
                    &cNbfIn,
                    &cNbfOut);

            if (SUCCEEDED(hr))
            {
                printf (
                    "TCP/IP Dial-Out:  %u\n"
                    "NetBEUI Dial-In:  %u\n"
                    "NetBEUI Dial-Out: %u\n",
                    cIpOut, cNbfIn, cNbfOut);
            }
            break;

        case CMD_REMOVE:
            printf ("Net yet implemented.\n");
            break;

        default:
            break;
    }
}

BOOL
ParseCounts (
    IN  INT         argc,
    IN  PCWSTR     argv[],
    OUT OPTIONS*    pOptions)
{
    BOOL    fRet;
    INT     i;

    // We must have an even number of parameters if we have a chance
    // of being correct.  (We're parsing 'param= value' pairs.)
    //
    if (!argc || (argc % 2 != 0))
    {
        return FALSE;
    }

    fRet = TRUE;

    for (i = 0; i < argc - 1; i++)
    {
        if (0 == _wcsicmp (argv[i], SZ_PARAM_IPOUT))
        {
            pOptions->cIpOut = wcstoul (argv[++i], NULL, 10);
        }
        else if (0 == _wcsicmp (argv[i], SZ_PARAM_NBFIN))
        {
            pOptions->cNbfIn = wcstoul (argv[++i], NULL, 10);
        }
        else if (0 == _wcsicmp (argv[i], SZ_PARAM_NBFOUT))
        {
            pOptions->cNbfOut = wcstoul (argv[++i], NULL, 10);
        }
        else
        {
            fRet = FALSE;
        }
    }

    return fRet;
}

VOID
Usage (
    IN PCWSTR pszProgramName,
    IN COMMAND Command)
{
    switch (Command)
    {
        case CMD_COUNT:
            printf (
                "%S count\n",
                pszProgramName);
            break;

        case CMD_ADD:
            printf (
                "\n"
                "%S add [ipout= i] [nbfin= j] [nbfout= k]\n"
                "\n"
                "    add 'i' TCP/IP Dial-Out bindings\n"
                "        'j' NetBEUI Dial-In bindings\n"
                "        'k' NetBEUI Dial-Out bindings\n"
                "\n"
                "    (i, j, and k all default to zero)\n"
                "\n",
                pszProgramName);
            break;

        case CMD_REMOVE:
            printf (
                "\n"
                "%S remove [ipout= i] [nbfin= j] [nbfout= k]\n"
                "\n"
                "    remove 'i' TCP/IP Dial-Out bindings\n"
                "           'j' NetBEUI Dial-In bindings\n"
                "           'k' NetBEUI Dial-Out bindings\n"
                "\n"
                "    (i, j, and k all default to zero)\n"
                "\n",
                pszProgramName);
            break;

        default:
            printf (
                "\n"
                "RAS Binding Configuration (shaunco)\n"
                "   View or change RAS bindings.\n"
                "\n"
                "%S [count | add | remove]\n",
                pszProgramName);
            break;
    }
}

VOID
__cdecl
wmain (
    IN INT     argc,
    IN PCWSTR argv[])
{
    HRESULT hr;
    OPTIONS Options;

    ZeroMemory (&Options, sizeof(Options));
    Options.Command = CMD_INVALID;

    if (argc < 2)
    {
        Usage (argv[0], Options.Command);
        return;
    }

    if (0 == _wcsicmp (argv[1], SZ_CMD_COUNT))
    {
        Options.Command = CMD_COUNT;
    }
    else if (0 == _wcsicmp (argv[1], SZ_CMD_ADD))
    {
        Options.Command = CMD_ADD;
        if (!ParseCounts (argc-2, &argv[2], &Options))
        {
            Usage (argv[0], CMD_ADD);
            return;
        }
    }
    else if (0 == _wcsicmp (argv[1], SZ_CMD_REMOVE))
    {
        Options.Command = CMD_REMOVE;
        if (!ParseCounts (argc-2, &argv[2], &Options))
        {
            Usage (argv[0], CMD_REMOVE);
            return;
        }
    }
    else
    {
        Usage (argv[0], Options.Command);
        return;
    }

    ExecuteCommand (&Options);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\tools\winipcfg\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by winipcfg.rc
//
#define IDS_WINIPCFG_MESSAGE            100
#define IDS_WINIPCFG_CAPTION            101

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        103
#define _APS_NEXT_COMMAND_VALUE         32773
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\tools\svchostc\version.h ===
#pragma once

#include <ntverp.h>
#include <winver.h>

#define VER_FILETYPE                    VFT_APP
#define VER_FILESUBTYPE                 VFT2_UNKNOWN
#define VER_FILEDESCRIPTION_STR         "Svchost Configuration"
#define VER_INTERNALNAME_STR            "svchostc.exe"

#include <common.ver>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\tools\winipcfg\winipcfg.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2001.
//
//  File:       W I N I P C F G . C P P
//
//  Contents:   The simple APP that points the new location of 
//              winipcfg functionality -- the "Support" tab of the connection
//              status dialog
//
//  Notes:      
//
//  Author:     Ning Sun   Feb 2001
//
//----------------------------------------------------------------------------

#include <windows.h>
#include "resource.h"

/////////////////////////////////////////////////////////////////////////////
//
//extern "C" int WINAPI _tWinMain(HINSTANCE hInstance, 
int WINAPI WinMain(HINSTANCE hInstance, 
    HINSTANCE /*hPrevInstance*/, LPSTR lpCmdLine, int /*nShowCmd*/)
{
	TCHAR szMsg[1024] = {0};
	TCHAR szCap[256] = {0};
	LoadString(hInstance, IDS_WINIPCFG_MESSAGE, szMsg, sizeof(szMsg)/sizeof(szMsg[0]));
	LoadString(hInstance, IDS_WINIPCFG_CAPTION, szCap, sizeof(szCap)/sizeof(szCap[0]));
	MessageBox(NULL, szMsg, szCap, MB_OK);
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\upgrade\digiupg\upgtest.c ===
//============================================================================
// Copyright (c) 1995, Microsoft Corporation
//
// File: Upgtest.c
//
// History:
//      V Raman  July-1-1997  Created.
//
// Test program for digi updates
//============================================================================

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <malloc.h>
#include <tchar.h>

#include "upgrade.h"


WCHAR       c_tszCCS[]              = TEXT( "System\\CurrentControlSet\\Services" );
WCHAR       c_tszPcimac[]           = TEXT( "Pcimac15" );
WCHAR       c_tszPar[]              = TEXT( "Parameters" );



INT __cdecl main(INT iArgc, PSTR ppszArgv[])
{

    DWORD       dwErr = ERROR_SUCCESS, dwInd = 0;
    WCHAR       tszKey[ MAX_PATH ], tszAdapterName[ MAX_PATH ];
    HKEY        hKey;

    PWSTR *    lplpText = NULL;
    DWORD       dwNumLines;



    wsprintf( tszKey, TEXT( "%s\\%s\\%s" ), c_tszCCS, c_tszPcimac, c_tszPar );

    dwErr = RegOpenKeyEx(
                HKEY_LOCAL_MACHINE,
                (PCWSTR) tszKey,
                0,
                KEY_READ,
                &hKey
                );

    if ( dwErr != ERROR_SUCCESS )
    {
        printf ( "Failed to open key %s : error %d\n", tszKey, dwErr );
        return dwErr;
    }


    dwErr = NetWriteDIGIISDNRegistry(
                hKey, TEXT( "Datafire" ), TEXT( "DataFireIsa4st" ),
                TEXT( "Datafire" ), &lplpText, &dwNumLines );

    if ( dwErr != ERROR_SUCCESS )
    {
        printf( "Failed NetWriteDIGIISDNRegistry : error %d\n", dwErr );
    }

    for ( dwInd = 0; dwInd < dwNumLines; dwInd++ )
    {
        _tprintf( TEXT( "%s" ), lplpText[ dwInd ] );
    }

    LocalFree( lplpText );

    return dwErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\upgrade\digiupg\upgrade.h ===
//============================================================================
// Copyright (c) 1995, Microsoft Corporation
//
// File: Upgrade.h
//
// History:
//      V Raman  July-1-1997  Created.
//
// Entry points for ISDN upgrade
//============================================================================


DWORD
NetWriteDIGIISDNRegistry(
    IN          HKEY                hKeyInstanceParameters,
    IN          PCWSTR             szPreNT5IndId,
    IN          PCWSTR             szNT5InfId,
    IN          PCWSTR             szSectionName,
    OUT         PWSTR  **          lplplpBuffer,
    IN  OUT     PDWORD              pdwNumLines
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\upgrade\digiupg\upgrade.c ===
//============================================================================
// Copyright (c) 1995, Microsoft Corporation
//
// File: Upgrade.c
//
// History:
//      V Raman  July-1-1997  Created.
//
// Entry points for ISDN upgrade
//============================================================================


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <setupapi.h>
#include <tchar.h>
#include <stdio.h>
#include <string.h>

#include "upgrade.h"

//
// upgrade inf section name
//


#define MAX_CHARS_PER_LINE                      128

#define ALIGN_SIZE                              0x00000008
#define ALIGN_SHIFT                             (ALIGN_SIZE - 0x00000001)   // 0x00000007
#define ALIGN_MASK                              (~ALIGN_SHIFT)              // 0xfffffff8

#define ALIGN_POINTER(ptr) {                \
    ((DWORD) (ptr)) += ALIGN_SHIFT;     \
    ((DWORD) (ptr)) &= ALIGN_MASK;      \
}


typedef struct _ISDN_STATIC_PARAMS
{
    WCHAR   ptszInfId[ MAX_PATH ];
    DWORD   dwWanEndPoints;
    DWORD   dwNumDChannels;
    DWORD   dwNumBChannelsPerDChannel;

} ISDN_STATIC_PARAMS, *PISDN_STATIC_PARAMS;



//
// New inf Key names
//

WCHAR       c_ptszIsdnNumDChannels[]             = L"IsdnNumDChannels";
WCHAR       c_ptszIsdnSwitchType[]               = L"IsdnSwitchType";

WCHAR       c_ptszIsdnNumBChannels[]             = L"IsdnNumBChannels";
WCHAR       c_ptszIsdnSpid[]                     = L"IsdnSpid";
WCHAR       c_ptszIsdnPhoneNumber[]              = L"IsdnPhoneNumber";


//============================================================================
// Values for DIGI Datafire ISDN cards.
//
//
//============================================================================

#define     DIGI_MAX_ADAPTERS                   3
#define     DIGI_MAX_SWITCH_TYPES               12

ISDN_STATIC_PARAMS g_ispDigiParams[] =
{
    { TEXT( "DataFireIsa1U" ), 2, 1, 2 },
    { L "DataFireIsa1ST" , 2, 1, 2 },
    { L "DataFireIsa4ST" , 8, 4, 2 }
};


PWSTR g_ptszDigiSwitchTypes[] =
{
    L "Auto Detect" ,
    L "Generic" ,
    L "ATT" ,
    L "DEFINITY" ,
    L "NTI" ,
    L "NI1" ,
    L "NET3" ,
    L "1TR6" ,
    L "VN3" ,
    L "INS64" ,
    L "AUSTEL" ,
    L "Singapore"
};


//
// registry keys for DIGI Datafire ISDN card.
//

WCHAR       c_ptszNumberOfLines[]                = L "NumberOfLines" ;

WCHAR       c_ptszLine[]                         = L "Line" ;
WCHAR       c_ptszSwitchStyle[]                  = L "SwitchStyle" ;
WCHAR       c_ptszLogicalTerminals[]             = L "LogicalTerminals" ;
WCHAR       c_ptszTerminalManagement[]           = L "TerminalManagement" ;

WCHAR       c_ptszLTerm[]                        = L "LTerm" ;
WCHAR       c_ptszSPID[]                         = L "SPID" ;
WCHAR       c_ptszAddress[]                      = L "Address" ;



//----------------------------------------------------------------------------
// Function:    DLLMAIN
//
// This is the DLL entrypoint handler.
//----------------------------------------------------------------------------

BOOL
WINAPI
DLLMAIN(
    HINSTANCE hInstance,
    DWORD dwReason,
    PVOID pUnused
    )
{

    switch(dwReason) {
        case DLL_PROCESS_ATTACH:

            DisableThreadLibraryCalls(hInstance);

            break;

        case DLL_PROCESS_DETACH:

            break;

        default:

            break;
    }

    return TRUE;
}


//----------------------------------------------------------------------------
// Function:        NetWriteDIGIISDNRegistry
//
//  reads the registry layout of DIGI PCIMAC card and write the key
//  values that need to be updated in the 5.0 setup.
//----------------------------------------------------------------------------

DWORD
NetWriteDIGIISDNRegistry(
    IN          HKEY                hKeyInstanceParameters,
    IN          PCWSTR             szPreNT5IndId,
    IN          PCWSTR             szNT5InfId,
    IN          PCWSTR             szSectionName,
    OUT         PWSTR  **          lplplpBuffer,
    IN  OUT     PDWORD              pdwNumLines
    )
{

    DWORD       dwInd = 0, dwInd1 = 0, dwErr = ERROR_SUCCESS;

    DWORD       dwMaxKeyLen = 0, dwMaxValueLen = 0, dwType = 0, dwSize = 0,
                dwNumSubKeys = 0;

    DWORD       dwValue = 0, dwNumDChannels = 0, dwNumLogTerm = 0;
    DWORD       dwMaxLines = 0, dwNumLines = 0;

    PTCHAR      ptszKey = NULL, ptszValue = NULL;

    PTCHAR      ptszBuffer = NULL;

    WCHAR       ptszSubKey[ MAX_PATH ];

    PBYTE       pb = NULL, pbLine = NULL;

    PWSTR *    lplpOffset;

    PISDN_STATIC_PARAMS pisp = NULL;



    do
    {

        //
        // Create IsdnNumDChannel entry
        //
        // for each D channel
        //   Create IsdnSwitchType (index into the mulptsz)
        //   Create VendorSpecific\TerminalManagement
        //   Create VendorSpecific\LogicalTerminals
        //
        //   For each B Channel
        //      Create IsdnSpid
        //      Create IsdnPhoneNumber
        //


        //
        // figure out which card this is
        //


        for ( dwInd = 0; dwInd < DIGI_MAX_ADAPTERS; dwInd++ )
        {
            if ( !_wcsicmp( g_ispDigiParams[ dwInd ].ptszInfId, szNT5InfId ) )
            {
                break;
            }
        }

        if ( dwInd >= DIGI_MAX_ADAPTERS )
        {
            break;
        }

        pisp = &(g_ispDigiParams[ dwInd ]);



        // Compute number of lines in buffer as
        //
        //  4 (section name, Addreg line, blank line, Addreg section name) +
        //  1 (IsdnNumDChannels) +
        //  IsdnNumDChannels * ( 3 +
        //      ( IsdnNumBChannels * 2 )
        //

        dwMaxLines = 5 +
                     ( pisp-> dwNumDChannels *
                        ( 3 + pisp-> dwNumBChannelsPerDChannel * 2 ) );



        //
        // allocate buffer big enough to hold these many lines of entries
        //

        dwSize = sizeof( PWSTR ) * dwMaxLines + ALIGN_SIZE +
                 dwMaxLines * sizeof( WCHAR ) * MAX_CHARS_PER_LINE;


        pb = LocalAlloc( 0, dwSize );

        if ( pb == NULL )
        {
            break;
        }

        ZeroMemory( pb, dwSize );


        lplpOffset = (PWSTR *) pb;

        pbLine = pb + sizeof( PWSTR ) * dwMaxLines;

        ALIGN_POINTER( pbLine );


        //
        // set the pointers
        //

        for ( dwInd = 0; dwInd < dwMaxLines; dwInd++ )
        {
            lplpOffset[ dwInd ] = (PWSTR) ( pbLine +
                dwInd * sizeof( WCHAR ) * MAX_CHARS_PER_LINE );
        }


        //
        // write section name
        //

        dwNumLines = 0;

        ptszBuffer = lplpOffset[ dwNumLines++ ];

        wsprintfW( ptszBuffer, L"[%s]", szSectionName );


        ptszBuffer = lplpOffset[ dwNumLines++ ];

        wsprintfW(
            ptszBuffer,
            L"AddReg\t= %s.%s.reg",
            szSectionName,
            szNT5InfId
            );


        //
        // Start registry section name
        //

        ptszBuffer = lplpOffset[ dwNumLines++ ];

        wsprintfW(
            ptszBuffer,
            L"[%s.%s.reg]",
            szSectionName,
            szNT5InfId
            );


        //
        // Find size of longest sub key and the size of max value
        // Allocate buffers for them.
        //

        dwErr = RegQueryInfoKey(
                    hKeyInstanceParameters,
                    NULL,
                    NULL,
                    NULL,
                    NULL,
                    NULL,
                    NULL,
                    NULL,
                    &dwMaxKeyLen,
                    &dwMaxValueLen,
                    NULL,
                    NULL
                    );

        if ( dwErr != ERROR_SUCCESS )
        {
            dwErr = GetLastError();
            break;
        }


        ptszKey = HeapAlloc(
                        GetProcessHeap(),
                        0,
                        (dwMaxKeyLen + 1) * sizeof( WCHAR )
                        );

        if ( ptszKey == NULL )
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        ptszValue = HeapAlloc(
                        GetProcessHeap(),
                        0,
                        (dwMaxValueLen + 1) * sizeof( WCHAR )
                        );

        if ( ptszValue == NULL )
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }


        //
        // Find number of D channels
        //

        dwSize = sizeof( DWORD );

        dwErr = RegQueryValueEx(
                    hKeyInstanceParameters,
                    c_ptszNumberOfLines,
                    NULL,
                    &dwType,
                    (PBYTE) &dwNumDChannels,
                    &dwSize
                    );

        if ( dwErr != ERROR_SUCCESS )
        {
            break;
        }

        ptszBuffer = lplpOffset[ dwNumLines++ ];

        wsprintfW(
            ptszBuffer,
            L "HKR, , %s, %#.8lx, %d" ,
            c_ptszIsdnNumDChannels,
            FLG_ADDREG_TYPE_DWORD,
            dwNumDChannels
            );

        ptszBuffer = lplpOffset[ dwNumLines++ ];


        //
        // for each D channel
        //

        for ( dwInd = 0; dwInd < dwNumDChannels; dwInd++ )
        {
            //
            // Sub key for D channels under which all the info
            // is to written
            //

            wsprintfW( ptszSubKey, L"%d" , dwInd );


            //
            // create switch type key name
            //

            wsprintfW( ptszKey, L"%s%d.%s" , c_ptszLine, dwInd, c_ptszSwitchStyle );


            //
            // query protocol key and use look up to determine switch type.
            //

            dwSize = dwMaxValueLen * sizeof( WCHAR );

            dwErr = RegQueryValueEx(
                        hKeyInstanceParameters,
                        ptszKey,
                        NULL,
                        &dwType,
                        (LPBYTE) ptszValue,
                        &dwSize
                        );

            if ( dwErr != ERROR_SUCCESS )
            {
                break;
            }


            //
            // lookup the switchtype in the list of switch types
            //

            for ( dwInd1 = 0; dwInd1 < DIGI_MAX_SWITCH_TYPES; dwInd1++ )
            {
                if ( !_wcsicmp( g_ptszDigiSwitchTypes[ dwInd1 ], ptszValue ) )
                {
                    break;
                }
            }

            if ( dwInd1 >= DIGI_MAX_SWITCH_TYPES )
            {
                dwInd1 = 1;
            }


            wsprintfW(
                ptszBuffer,
                L "HKR, %s, %s, %#.8lx, %d" ,
                ptszSubKey,
                c_ptszIsdnSwitchType,
                FLG_ADDREG_TYPE_DWORD,
                dwInd1
                );

            ptszBuffer = lplpOffset[ dwNumLines++ ];


            //
            // Create key for number of B channels
            //

            wsprintfW(
                ptszKey,
                L"%s%d.%s" ,
                c_ptszLine, dwInd, c_ptszLogicalTerminals
                );


            //
            // Find and write number of logical terminals
            //

            dwSize = sizeof( DWORD );

            dwErr = RegQueryValueEx(
                        hKeyInstanceParameters,
                        ptszKey,
                        NULL,
                        &dwType,
                        (LPBYTE) &dwNumLogTerm,
                        &dwSize
                        );

            if ( dwErr != ERROR_SUCCESS )
            {
                break;
            }

            wsprintfW(
                ptszBuffer,
                L "HKR, %s\\VendorSpecific, %s, %#.8lx, %d" ,
                ptszSubKey,
                c_ptszLogicalTerminals,
                FLG_ADDREG_TYPE_DWORD,
                dwNumLogTerm
                );

            ptszBuffer = lplpOffset[ dwNumLines++ ];


            //
            // Create key for Terminal management
            //

            wsprintfW(
                ptszKey,
                L"%s%d.%s" ,
                c_ptszLine, dwInd, c_ptszTerminalManagement
                );


            //
            // Find and write terminal management value
            //

            dwSize = dwMaxValueLen * sizeof( WCHAR );

            dwErr = RegQueryValueEx(
                        hKeyInstanceParameters,
                        ptszKey,
                        NULL,
                        &dwType,
                        (LPBYTE) ptszValue,
                        &dwSize
                        );

            if ( dwErr != ERROR_SUCCESS )
            {
                break;
            }

            wsprintfW(
                ptszBuffer,
                L "HKR, %s\\VendorSpecific, %s, %#.8lx, %s" ,
                ptszSubKey,
                c_ptszTerminalManagement,
                FLG_ADDREG_TYPE_SZ,
                ptszValue
                );

            ptszBuffer = lplpOffset[ dwNumLines++ ];


            //
            // for each B Channel for this D channels write the
            // B channel info.
            //

            for ( dwInd1 = 0; dwInd1 < pisp-> dwNumBChannelsPerDChannel; dwInd1++ )
            {
                //
                // sub key for B channel under which all the info. is to
                // be written.
                //

                wsprintfW( ptszSubKey, L"%d\\%d" , dwInd, dwInd1 );


                //
                // create key for SPID
                //

                wsprintfW(
                    ptszKey, L"%s%d.%s%d.%s" ,
                    c_ptszLine, dwInd, c_ptszLTerm, dwInd1, c_ptszSPID
                    );

                //
                // retrieve and write value of SPID key
                //

                dwSize = dwMaxValueLen * sizeof( WCHAR );

                dwErr = RegQueryValueEx(
                            hKeyInstanceParameters,
                            ptszKey,
                            NULL,
                            &dwType,
                            (LPBYTE) ptszValue,
                            &dwSize
                            );

                if ( dwErr != ERROR_SUCCESS )
                {
                    dwErr = ERROR_SUCCESS;
                    break;
                }


                wsprintfW(
                    ptszBuffer,
                    L "HKR, %s, %s, %#.8lx, %s" ,
                    ptszSubKey,
                    c_ptszIsdnSpid,
                    FLG_ADDREG_TYPE_SZ,
                    ptszValue
                    );

                ptszBuffer = lplpOffset[ dwNumLines++ ];


                //
                // create key for Phone Number
                //

                wsprintfW(
                    ptszKey, L"%s%d.%s%d.%s" ,
                    c_ptszLine, dwInd, c_ptszLTerm, dwInd1, c_ptszAddress
                    );

                //
                // retrieve and write value of phone number key
                //

                dwSize = dwMaxValueLen * sizeof( WCHAR );

                dwErr = RegQueryValueEx(
                            hKeyInstanceParameters,
                            ptszKey,
                            NULL,
                            &dwType,
                            (LPBYTE) ptszValue,
                            &dwSize
                            );

                if ( dwErr != ERROR_SUCCESS )
                {
                    dwErr = ERROR_SUCCESS;
                    break;
                }


                wsprintfW(
                    ptszBuffer,
                    L"HKR, %s, %s, %#.8lx, %s" ,
                    ptszSubKey,
                    c_ptszIsdnPhoneNumber,
                    FLG_ADDREG_TYPE_SZ,
                    ptszValue
                    );

                ptszBuffer = lplpOffset[ dwNumLines++ ];
            }

            if ( dwErr != ERROR_SUCCESS )
            {
                break;
            }
        }

    } while ( FALSE );


    //
    // clean up
    //

    if ( ptszKey ) { HeapFree( GetProcessHeap(), 0, ptszKey ); }

    if ( ptszValue ) { HeapFree( GetProcessHeap(), 0, ptszValue ); }


    if ( dwErr == ERROR_SUCCESS )
    {
        *lplplpBuffer =(PWSTR *) pb;
        *pdwNumLines = dwNumLines;
    }

    return dwErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\upgrade\modemshr\dll\mdmshrup.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT4.0
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       MdmShrUp.C
//
//  Contents:   OEM DLL for Modem sharing upgrade from NT4 to NT5 (Server/Client)
//
//  Notes:
//
//  Author:     erany       18-May-98
//
//----------------------------------------------------------------------------
#include <windows.h>
#include <stdio.h>
#include <tchar.h>
#include <setupapi.h>   // For HINF definition
#include <oemupgex.h>

#define CLIENT_HIVE_FILE                L"\\C_MdmShr"
#define SERVER_HIVE_FILE                L"\\S_MdmShr"
#define CLIENT_NT5_SYSTEM_NAME          L"MS_SERRDR"

//----------------------------------------------------------------------------
// Prototypes:
//----------------------------------------------------------------------------

    // Reads NT4 registry and stores in a file
LONG RegistryToFile (HKEY hKeyParams, PCWSTR szConfigFile);

    // Reads a file and stores in NT5 registry
LONG FileToRegistry (HKEY hKeyParams, PCWSTR szConfigFile);

    // Sets privilege in an access token
LONG SetSpecificPrivilegeInAccessToken (PCWSTR lpwcsPrivType, BOOL bEnabled);

    // Display detailed error message in a message box
LONG DisplayErrorMsg (HWND hParent,
                      PCWSTR szOperation,
                      BOOL bIsClient,
                      LONG lErrCode);

    // Display debug message
void DebugMsg (PCWSTR lpStr);

    // Copy constant vendor info into a buffer
void FillVendorInfo (VENDORINFO*     pviVendorInfo);

//----------------------------------------------------------------------------
// Globals:
//----------------------------------------------------------------------------

    // Registry hive dump file name (client)
WCHAR g_szClientConfigFile[MAX_PATH];

    // Registry hive dump file name (server)
WCHAR g_szServerConfigFile[MAX_PATH];

    // OEM Working directory
WCHAR g_szOEMDir[MAX_PATH];

    // Vendor information constants
WCHAR g_szConstCompanyName[] =        L"Microsoft";
WCHAR g_szConstSupportNumber[] =      L"<Place microsoft support phone number here>";
WCHAR g_szConstSupportUrl[] =         L"<Place microsoft support URL here>";
WCHAR g_szConstInstructionsToUser[] = L"<Place instructions to user here>";


//----------------------------------------------------------------------------
// DLL exports:
//----------------------------------------------------------------------------

//+---------------------------------------------------------------------------
//
//  Function:   DllMain
//
//  Purpose:    DLL entry and exit point
//
//  Arguments:
//      hInst              [in]   Handle of process instance
//      ul_reason_for_call [in]   Reason for function call
//      lpReserved         [out]  reserved
//
//  Returns:    TRUE in case of success.
//
//  Author:     erany   5-May-98
//
//  Notes:
//      Does nothing. Always returns TRUE.
//
BOOL WINAPI DllMain (HANDLE hInst,
                     ULONG ul_reason_for_call,
                     LPVOID lpReserved)
{
    return TRUE;
}


//----------------------------------------------------------------------------
// DLL exports - Windows NT 4 stage:
//----------------------------------------------------------------------------

//+---------------------------------------------------------------------------
//
//  Function:   PreUpgradeInitialize
//
//  Purpose:    Intialize OEM DLL
//
//  Arguments:
//      szWorkingDir     [in]   name of temporary directory to be used
//      pNetUpgradeInfo  [in]   pointer to NetUpgradeInfo structure
//      szProductId      [out]  Description of component being upgraded  - NOT IN USE
//      pviVendorInfo    [out]  information about OEM
//      pvReserved       [out]  reserved
//
//  Returns:    ERROR_SUCCESS in case of success, win32 error otherwise
//
//  Author:     erany   5-May-98
//
//  Notes:
//      This function is called before any other function in this dll.
//      The main purpose of calling this function is to obtain
//      identification information and to allow the DLL to initialize
//      its internal data
//
EXTERN_C LONG  __stdcall
PreUpgradeInitialize(IN  PCWSTR         szWorkingDir,
                     IN  NetUpgradeInfo* pNetUpgradeInfo,
                     OUT VENDORINFO*     pviVendorInfo,
                     OUT DWORD*          pdwFlags,
                     OUT NetUpgradeData* pNetUpgradeData)
{
    FillVendorInfo (pviVendorInfo);

    *pdwFlags = 0;  // No special flags

        // Create registry hive file name for the client:
    wcscpy (g_szOEMDir, szWorkingDir); // Save config path
    wcscpy (g_szClientConfigFile, szWorkingDir); // Save registry dump full path
    wcscat (g_szClientConfigFile, CLIENT_HIVE_FILE);
        // Create registry hive file name for the server:
    wcscpy (g_szServerConfigFile, szWorkingDir); // Save registry dump full path
    wcscat (g_szServerConfigFile, SERVER_HIVE_FILE);

#ifdef _DEBUG   // Test code:
    {
        WCHAR dbgMsg[2048];
        _stprintf (dbgMsg,
            L"PreUpgradeInitialize called.\nszClientConfigFile=%s\nszServerConfigFile=%s",
            g_szClientConfigFile, g_szServerConfigFile);
        DebugMsg (dbgMsg);
    }
#endif      //   End of test code

    return ERROR_SUCCESS;
}

//+---------------------------------------------------------------------------
//
//  Function:   DoPreUpgradeProcessing
//
//  Purpose:    Intialize OEM DLL
//
//  Arguments:
//      hParentWindow    [in]  window handle for showing UI
//      hkeyParams       [in]  handle to parameters key in registry
//      szPreNT5InfId    [in]  pre-NT5 InfID
//      szPreNT5Instance [in]  pre-NT5 instance name
//      szNT5InfId       [in]  NT5 InfId
//      szSectionName    [in]  section name to be used for writing info
//      dwFlags          [out] flags
//      pvReserve        [in]  reserved
//
//  Returns:    ERROR_SUCCESS in case of success, win32 error otherwise
//
//  Author:     erany   5-May-98
//
//  Notes:
//      This function is called once per component to be upgraded.
//
EXTERN_C LONG  __stdcall
DoPreUpgradeProcessing(IN   HWND        hParentWindow,
                       IN   HKEY        hkeyParams,
                       IN   PCWSTR     szPreNT5InfId,
                       IN   PCWSTR     szPreNT5Instance,
                       IN   PCWSTR     szNT5InfId,
                       IN   PCWSTR     szSectionName,
                       OUT  VENDORINFO* pviVendorInfo,
                       OUT  DWORD*      pdwFlags,
                       IN   LPVOID      pvReserved)
{
    LONG lRes;
    //WCHAR szLine[MAX_PATH];
    BOOL bIsClient = FALSE; // Is this a client upgrade ?

    *pdwFlags = NUA_LOAD_POST_UPGRADE;  // Ask to be activated in post stage (GUI NT5)
    FillVendorInfo (pviVendorInfo);

    if (!_wcsicmp(szNT5InfId, CLIENT_NT5_SYSTEM_NAME))
        bIsClient=TRUE; // Client is being upgraded now


#ifdef _DEBUG       // Test code:
    {
        WCHAR dbgMsg[2048];
        WCHAR key[1024];
        RegEnumKey (hkeyParams,0,key,MAX_PATH);
        _stprintf (dbgMsg,
                      L"DoPreUpgradeProcessing called: 1st key=%s\n"
                      L"PreNT5InfId=%s\n"
                      L"PreNT5Instance=%s\n"
                      L"NT5InfId=%s\n"
                      L"SectionName=%s",key, szPreNT5InfId, szPreNT5Instance, szNT5InfId, szSectionName);
        DebugMsg (dbgMsg);
    }
#endif  // End of test code

        // Dump registry hive to a file
    lRes = RegistryToFile (hkeyParams,
                           bIsClient ? g_szClientConfigFile : g_szServerConfigFile);
    if (lRes != ERROR_SUCCESS)  // Error dumping our registry section to a file
        return DisplayErrorMsg (hParentWindow,
                                L"attempting to save registry section to a file",
                                bIsClient,
                                lRes);

    return ERROR_SUCCESS;
}

//----------------------------------------------------------------------------
// DLL exports - Windows NT 5 stage:
//----------------------------------------------------------------------------

//+---------------------------------------------------------------------------
//
//  Function:   PostUpgradeInitialize
//
//  Purpose:    Intialize OEM DLL during GUI mode setup
//
//  Arguments:
//      szWorkingDir     [in]   name of temporary directory to be used
//      pNetUpgradeInfo  [in]   pointer to NetUpgradeInfo structure
//      szProductId      [out]  Description of component being upgraded - NOT IN USE
//      pviVendorInfo    [out]  information about OEM
//      pvReserved       [out]  reserved
//
//  Returns:    ERROR_SUCCESS in case of success, win32 error otherwise
//
//  Author:     erany   5-May-98
//
//  Notes:
//      This function is called in GUI mode setup before
//      any other function in this dll .
//      The main purpose of calling this function is to obtain
//      identification information and to allow the DLL to initialize
//      its internal data
//
EXTERN_C LONG  __stdcall
PostUpgradeInitialize(IN PCWSTR          szWorkingDir,
                      IN  NetUpgradeInfo* pNetUpgradeInfo,
                      //OUT PCWSTR*        szProductId,
                      OUT VENDORINFO*     pviVendorInfo,
                      OUT LPVOID          pvReserved)
{
    FillVendorInfo (pviVendorInfo);

        // Create registry hive file name for the client:
    wcscpy (g_szOEMDir, szWorkingDir); // Save config path
    wcscpy (g_szClientConfigFile, szWorkingDir); // Save registry dump full path
    wcscat (g_szClientConfigFile, CLIENT_HIVE_FILE);
        // Create registry hive file name for the server:
    wcscpy (g_szServerConfigFile, szWorkingDir); // Save registry dump full path
    wcscat (g_szServerConfigFile, SERVER_HIVE_FILE);

#ifdef _DEBUG        // Test code:
    {
        WCHAR dbgMsg[MAX_PATH*2];
        _stprintf (dbgMsg,
            L"PostUpgradeInitialize called.\nszClientConfigFile=%s\nszServerConfigFile=%s",
            g_szClientConfigFile, g_szServerConfigFile);
        DebugMsg (dbgMsg);
    }
#endif  // End of test code

    return ERROR_SUCCESS;
}

//+---------------------------------------------------------------------------
//
//  Function:   DoPostUpgradeProcessing
//
//  Purpose:    Intialize OEM DLL
//
//  Arguments:
//      hParentWindow    [in]  window handle for showing UI
//      hkeyParams       [in]  handle to parameters key in registry
//      szPreNT5InfId    [in]  pre-NT5 InfID
//      szPreNT5Instance [in]  pre-NT5 instance name
//      szNT5InfId       [in]  NT5 InfId
//      hinfAnswerFile   [in]  handle to answer-file
//      szSectionName    [in]  name of section having component parameters
//      pvReserve        [in]  reserved
//
//  Returns:    ERROR_SUCCESS in case of success, win32 error otherwise
//
//  Author:     erany   5-May-98
//
//  Notes:
//      This function is called once per component upgraded.
//
EXTERN_C LONG  __stdcall
DoPostUpgradeProcessing(IN  HWND    hParentWindow,
                        IN  HKEY    hkeyParams,
                        IN  PCWSTR szPreNT5Instance,
                        IN  PCWSTR szNT5InfId,
                        IN  HINF    hinfAnswerFile,
                        IN  PCWSTR szSectionName,
                        OUT VENDORINFO* pviVendorInfo,
                        IN  LPVOID  pvReserved)
{
    LONG lRes;
    BOOL bIsClient = FALSE; // Is this a client upgrade ?

    if (!_wcsicmp(szNT5InfId, CLIENT_NT5_SYSTEM_NAME))
        bIsClient=TRUE; // Client is being upgraded now

    FillVendorInfo (pviVendorInfo);

#ifdef _DEBUG        // Test code:
    {
        WCHAR dbgMsg[MAX_PATH*4];
        WCHAR key[MAX_PATH];
        RegEnumKey (hkeyParams,0,key,MAX_PATH);
        _stprintf (dbgMsg,
                   L"DoPostUpgradeProcessing called: 1st key=%s\n"
                   L"PreNT5Instance=%s\n"
                   L"NT5InfId=%s\n"
                   L"SectionName=%s",key, szPreNT5Instance, szNT5InfId, szSectionName);
        DebugMsg (dbgMsg);
    }
#endif  // End of test code

        // read back registry hive from the dump file
    lRes = FileToRegistry (hkeyParams,
                           bIsClient ? g_szClientConfigFile : g_szServerConfigFile);
    if (lRes != ERROR_SUCCESS)  // Error dumping our registry section to a file
        return DisplayErrorMsg (hParentWindow,
                                L"attempting to read registry section from a file",
                                bIsClient,
                                lRes);

    return ERROR_SUCCESS;
}

//+---------------------------------------------------------------------------
//
//  Function:   RegistryToFile
//
//  Purpose:    Reads NT4 registry and stores in a file
//
//  Arguments:
//      hKeyParames      [in]  handle to parameters key in registry
//      szConfigFile     [in]  Name of configuration file
//
//  Returns:    ERROR_SUCCESS in case of success, win32 error otherwise
//
//  Author:     erany   10-March-98
//
//  Notes:
//      This function is called once per component upgraded.
//      It recursively calls itself (with an open file handle)
//      for every registry key it meets.
//
LONG RegistryToFile (HKEY hKeyParams, PCWSTR szConfigFile)
{
    LONG lRes;

    if (!DeleteFile (szConfigFile) && GetLastError() != ERROR_FILE_NOT_FOUND)
    {
    //
    // The hive file is there but I can't delete it
    //
        return GetLastError();
    }
    lRes = SetSpecificPrivilegeInAccessToken (SE_BACKUP_NAME, TRUE);
    if (lRes != ERROR_SUCCESS)
    {
        return lRes;
    }
    lRes = RegSaveKey (hKeyParams, szConfigFile, NULL);
    SetSpecificPrivilegeInAccessToken (SE_BACKUP_NAME, FALSE);
    return lRes;
}

//+---------------------------------------------------------------------------
//
//  Function:   FileToRegistry
//
//  Purpose:    Reads a file and stores in NT5 registry
//
//  Arguments:
//      hKeyParames      [in]  handle to parameters key in registry
//      szConfigFile     [in]  Name of configuration file
//
//  Returns:    ERROR_SUCCESS in case of success, win32 error otherwise
//
//  Author:     erany   10-March-98
//
//  Notes:
//      This function is called once per component upgraded (in NT5 GUI mode).
//      It recursively calls itself (with an open file handle)
//      for every registry key it meets.
//
LONG FileToRegistry (HKEY hKeyParams, PCWSTR szConfigFile)
{
    LONG lRes;

    lRes = SetSpecificPrivilegeInAccessToken (SE_RESTORE_NAME, TRUE);
    if (lRes != ERROR_SUCCESS)
    {
        return lRes;
    }
    lRes = RegRestoreKey (hKeyParams, szConfigFile, 0);
    SetSpecificPrivilegeInAccessToken (SE_RESTORE_NAME, FALSE);
    return lRes;
}


//+---------------------------------------------------------------------------
//
//  Function:   SetSpecificPrivilegeInAccessToken
//
//  Purpose:    Sets a privilege in an access token
//
//  Arguments:
//      lpwcsPrivType   [in]  Type of privilege
//      bEnabled        [in]  Enable / Disable flag
//
//  Returns:    ERROR_SUCCESS in case of success, win32 error otherwise
//
//  Author:     erany   10-March-98
//
//  Notes:
//      Copied from an example by boazf
//
LONG SetSpecificPrivilegeInAccessToken (PCWSTR lpwcsPrivType, BOOL bEnabled)
{
    LUID             luidPrivilegeLUID;
    TOKEN_PRIVILEGES tpTokenPrivilege;
    HANDLE hAccessToken;
    BOOL bRet;

    //
    // 1st, Try to get a handle to the current thread.
    // If not successful, get a handle to the current process token.
    //
    if (!OpenThreadToken(GetCurrentThread(), TOKEN_ADJUST_PRIVILEGES, TRUE, &hAccessToken) &&
        !OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES, &hAccessToken))
        return GetLastError ();

    //
    // Get the LUID of the privilege.
    //
    if (!LookupPrivilegeValue(NULL,
                              lpwcsPrivType,
                              &luidPrivilegeLUID))
    {
        CloseHandle(hAccessToken);
        return GetLastError ();
    }

    //
    // Enable/Disable the privilege.
    //
    tpTokenPrivilege.PrivilegeCount = 1;
    tpTokenPrivilege.Privileges[0].Luid = luidPrivilegeLUID;
    tpTokenPrivilege.Privileges[0].Attributes = bEnabled ?SE_PRIVILEGE_ENABLED : 0;
    bRet = AdjustTokenPrivileges (hAccessToken,
                                  FALSE,  // Do not disable all
                                  &tpTokenPrivilege,
                                  sizeof(TOKEN_PRIVILEGES),
                                  NULL,   // Ignore previous info
                                  NULL);  // Ignore previous info

    //
    // Free the process token.
    //
    CloseHandle(hAccessToken);
    if (!bRet)
        return GetLastError();
    return ERROR_SUCCESS;
}


//+---------------------------------------------------------------------------
//
//  Function:   DisplayErrorMsg
//
//  Purpose:    Displays a detailed error mesaage in a message box
//
//  Arguments:
//      hParent         [in]  Window hanlde of parent window
//      szOperation     [in]  Description of operation that caused error
//      bIsClient       [in]  Did it happend while upgrading modem sharing client?
//      lErrCode        [in]  Win32 error code
//
//  Returns:    lErrCode unchanged
//
//  Author:     erany   10-March-98
//
//  Notes:
//      Returns the input error code unchanged.
//
LONG DisplayErrorMsg (HWND      hParent,
                      PCWSTR   szOperation,
                      BOOL      bIsClient,
                      LONG      lErrCode)
{
    WCHAR   szMsg[256],
            szHdr[256];
    PWSTR  lpszError=NULL;
    BOOL    bGotErrorDescription = TRUE;

    //
    // Create message box title
    //
    _stprintf (szHdr,L"Modem sharing %s NT5 upgrade",
               bIsClient ? L"client" : L"server");

    // Create descriptive error text
    if (0 == FormatMessage (   FORMAT_MESSAGE_ALLOCATE_BUFFER |
                               FORMAT_MESSAGE_FROM_SYSTEM,
                               NULL,
                               lErrCode,
                               0,
                               lpszError,
                               0,
                               NULL))
    {
        //
        // Failure to format the message
        //
        bGotErrorDescription = FALSE;
    }

    if (bGotErrorDescription)
    {
        //
        // We successfully created a descriptive error string from the error code
        //
        _stprintf (szMsg, L"Error while %s.\n%s.", szOperation, lpszError);
    }
    else
    {
        //
        // We failed to created a descriptive error string from the error code
        //
        _stprintf (szMsg, L"Error while %s.\nError code: %ld.", szOperation, lErrCode);
    }
    MessageBox (hParent, szMsg, szHdr, MB_OK | MB_ICONSTOP);
    if (bGotErrorDescription)
    {
        LocalFree (lpszError);
    }
    return lErrCode;
}

//+---------------------------------------------------------------------------
//
//  Function:   FillVendorInfo
//
//  Purpose:    Fills global constant strings into the vendor info buffer.
//
//  Arguments:
//      pviVendorInfo     [out]  Points to vendor info buffer
//
//  Returns:    None.
//
//  Author:     erany   10-March-98
//
//  Notes:
//      Consts are global, they effect all calls.
//
void FillVendorInfo (VENDORINFO*     pviVendorInfo)
{
    wcscpy (pviVendorInfo->szCompanyName,          g_szConstCompanyName);
    wcscpy (pviVendorInfo->szSupportNumber,        g_szConstSupportNumber);
    wcscpy (pviVendorInfo->szSupportUrl,           g_szConstSupportUrl);
    wcscpy (pviVendorInfo->szInstructionsToUser,   g_szConstInstructionsToUser);
}

//+---------------------------------------------------------------------------
//
//  Function:   DebugMsg
//
//  Purpose:    Displays a debug message to the debugger
//
//  Arguments:
//      lpStr     [in]  String to output
//
//  Returns:    None.
//
//  Author:     erany   14-July-98
//
//
void DebugMsg (PCWSTR lpStr)
{
    static PCWSTR szDbgHeader =
        L"-------------------- Modem sharing client / server upgrade DLL --------------------\n";

    OutputDebugString (szDbgHeader);
    OutputDebugString (lpStr);
    OutputDebugString (L"\n");
    OutputDebugString (szDbgHeader);
    OutputDebugString (L"\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\upgrade\netupgrd\conflict.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       C O N F L I C T . H
//
//  Contents:   Code to handle and display software/hardware conflicts
//              during upgrade
//
//  Notes:
//
//  Author:     kumarp 04/12/97 17:17:27
//
//----------------------------------------------------------------------------

#pragma once
#include "kkstl.h"

HRESULT HrGenerateConflictList(OUT UINT* pcNumConflicts);

void UninitConflictList();
BOOL UpgradeConflictsFound();
HRESULT HrUpdateConflictList(IN BOOL fDeleteResolvedItemsFromList,
                             IN HINF hinfNetMap,
                             OUT DWORD* pdwNumConflictsResolved,
                             OUT BOOL*  pfHasUpgradeHelpInfo);

HRESULT HrGetConflictsList(OUT TPtrList** ppplNetComponents);
BOOL ShouldRemoveDLC (OUT OPTIONAL tstring *strDLCDesc,
                      OUT OPTIONAL BOOL *fInstalled);

typedef enum EComponentTypeEnum
{
    CT_Unknown,
    CT_Software,
    CT_Hardware
} EComponentType;

class CNetComponent
{
public:
    EComponentType m_eType;

    tstring m_strPreNT5InfId;
    tstring m_strServiceName;
    tstring m_strDescription;
    tstring m_strNT5InfId;

    CNetComponent(PCWSTR   szPreNT5InfId,
                  PCWSTR   szPreNT5Instance,
                  PCWSTR   szDescription,
                  EComponentType eType);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\upgrade\netupgrd\netreg.h ===
#pragma once
#include "kkcwinf.h"

HRESULT
HrInitNetUpgrade(
    VOID);

BOOL
ShouldIgnoreComponent(
    IN PCWSTR szComponentName);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\upgrade\netupgrd\netreg.cpp ===
// ----------------------------------------------------------------------
//
//  Microsoft Windows NT
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:      N E T R E G . C P P
//
//  Contents:  Windows NT4.0 & 3.51 Network Registry Info Dumper
//
//  Notes:
//
//  Author:    kumarp 22-December-97
//
// ----------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include <ntsecapi.h>

#include "afilestr.h"
#include "conflict.h"
#include "infmap.h"
#include "kkcwinf.h"
#include "kkenet.h"
#include "kkreg.h"
#include "kkstl.h"
#include "kkutils.h"
#include "ncipaddr.h"
#include "ncmisc.h"
#include "ncreg.h"
#include "ncsetup.h"
#include "netreg.h"
#include "netupgrd.h"
#include "nustrs.h"
#include "nuutils.h"
#include "oemupg.h"
#include "resource.h"
#include "ipafval.h"
#include "winsock2.h"
#include "ws2spi.h"
#include "dhcpupg.h"

// for WLBS stuff
#include "wlbsparm.h"

// ----------------------------------------------------------------------
// external string constants

extern const WCHAR c_szAfWins[];
extern const WCHAR c_szAfForceStrongEncryption[];
extern const WCHAR c_szDrives[];
extern const WCHAR c_szInfId_MS_AppleTalk[];
extern const WCHAR c_szInfId_MS_Isotpsys[];
extern const WCHAR c_szInfId_MS_MSClient[];
extern const WCHAR c_szInfId_MS_NWIPX[];
extern const WCHAR c_szInfId_MS_NWNB[];
extern const WCHAR c_szInfId_MS_NWSPX[];
extern const WCHAR c_szInfId_MS_NetBIOS[];
extern const WCHAR c_szInfId_MS_NetBT[];
extern const WCHAR c_szInfId_MS_NwSapAgent[];
extern const WCHAR c_szInfId_MS_RasCli[];
extern const WCHAR c_szInfId_MS_RasSrv[];
extern const WCHAR c_szInfId_MS_Streams[];
extern const WCHAR c_szInfId_MS_TCPIP[];
extern const WCHAR c_szInfId_MS_WLBS[];
extern const WCHAR c_szNdisWan[];
extern const WCHAR c_szNo[];
extern const WCHAR c_szParameters[];
extern const WCHAR c_szRegKeyComponentClasses[];
extern const WCHAR c_szRegKeyServices[];
extern const WCHAR c_szRegValDependOnGroup[];
extern const WCHAR c_szRegValDependOnService[];
extern const WCHAR c_szRegValServiceName[];
extern const WCHAR c_szRegValStart[];
extern const WCHAR c_szShares[];
extern const WCHAR c_szSvcBrowser[];
extern const WCHAR c_szSvcDhcpRelayAgent[];
extern const WCHAR c_szSvcDhcpServer[];
extern const WCHAR c_szSvcLmServer[];
extern const WCHAR c_szSvcNWCWorkstation[];
extern const WCHAR c_szSvcNetBIOS[];
extern const WCHAR c_szSvcNetLogon[];
extern const WCHAR c_szSvcRasAuto[];
extern const WCHAR c_szSvcRipForIp[];
extern const WCHAR c_szSvcRipForIpx[];
extern const WCHAR c_szSvcRouter[];
extern const WCHAR c_szSvcSapAgent[];
extern const WCHAR c_szSvcWorkstation[];
extern const WCHAR c_szYes[];


// ----------------------------------------------------------------------
// string constants

const WCHAR c_szRAS[]    = L"RAS";
const WCHAR c_szRasMan[] = L"RasMan";
const WCHAR c_szRouter[] = L"Router";
const WCHAR c_szServer[] = L"Server";
const WCHAR sz_DLC[]     = L"DLC";
const WCHAR sz_MS_DLC[]  = L"MS_DLC";

// WLBS:
const WCHAR c_szWLBS[]    = L"WLBS";
const WCHAR c_szConvoy[]  = L"Convoy";
const WCHAR c_szMSWLBS[]  = L"MS_WLBS";
const WCHAR c_szMSTCPIP[] = L"MS_TCPIP";
// end WLBS:

// ----------------------------------------------------------------------
// variables

//Global

// Novell Client32 upgrades
BOOL g_fForceNovellDirCopy = FALSE;

//File scope
static TStringList *g_pslNetCard, *g_pslNetCardInstance, *g_pslNetCardAFileName;
static PCWInfSection g_pwisBindings;

// WLBS:
static WCHAR pszWlbsClusterAdapterName[16], pszWlbsVirtualAdapterName[16];
// end WLBS:

// static PCWInfSection g_pwisMSNetClient;
// static PCWInfSection g_pwisNetClients;

// used by WriteRASParams
static BOOL g_fAtLeastOneDialIn=FALSE;
static BOOL g_fAtLeastOneDialOut=FALSE;
static BOOL g_fAtLeastOneDialInUsingNdisWan=FALSE;
static BOOL g_fAtLeastOneDialOutUsingNdisWan=FALSE;


static PCWSTR g_pszServerOptimization[] =
{
    c_szAfUnknown,
    c_szAfMinmemoryused,
    c_szAfBalance,
    c_szAfMaxthroughputforfilesharing,
    c_szAfMaxthrouputfornetworkapps
};

static PCWSTR g_szNetComponentSectionName[] =
{
    c_szAfUnknown,
    c_szAfSectionNetAdapters,
    c_szAfSectionNetProtocols,
    c_szAfSectionNetServices,
    c_szAfSectionNetClients
};

// ----------------------------------------------------------------------
// Forward Declarations


BOOL WriteIdentificationInfo(IN CWInfFile *pwifAnswerFile);

BOOL WriteNetAdaptersInfo(IN CWInfFile *pwifAnswerFile);

HRESULT HrWriteNetComponentsInfo(IN CWInfFile* pwifAnswerFile);

//Protocols
BOOL WriteTCPIPParams(PCWInfFile pwifAnswerFile, PCWInfSection pwisTCPIPGlobalParams,
                      OUT TStringList& slAdditionalParamsSections);
BOOL WriteTCPIPAdapterParams(PCWInfFile pwifAnswerFile, PCWSTR pszAdapterDriver,
                             OUT TStringList& slAdditionalParamsSections,
                             BOOL fDisabledToDhcpServer,
                             BOOL fDisableNetbios);

BOOL WriteIPXParams(PCWInfFile pwifAnswerFile, PCWInfSection pwisIPXGlobalParams,
                    OUT TStringList& slAdditionalParamsSections);

BOOL WriteAppleTalkParams(PCWInfFile pwifAnswerFile, PCWInfSection pwisGlobalParams,
                          OUT TStringList& slAdditionalParamsSections);

BOOL WritePPTPParams(PCWInfFile pwifAnswerFile, PCWInfSection pwisParams);

//Services
BOOL WriteRASParams(PCWInfFile pwifAnswerFile,
                    PCWInfSection pwisNetServices,
                    PCWInfSection pwisRASParams);
HRESULT HrWritePreSP3ComponentsToSteelHeadUpgradeParams(
        IN CWInfFile* pwifAnswerFile);

BOOL WriteNWCWorkstationParams(PCWInfFile pwifAnswerFile, PCWInfSection pwisParams);
BOOL WriteDhcpServerParams(PCWInfFile pwifAnswerFile, PCWInfSection pwisParams);
BOOL WriteTp4Params(PCWInfFile pwifAnswerFile, PCWInfSection pwisParams);
BOOL WriteWLBSParams(PCWInfFile pwifAnswerFile, PCWInfSection pwisParams);
BOOL WriteConvoyParams(PCWInfFile pwifAnswerFile, PCWInfSection pwisParams);

// the following four actually write into [params.MS_NetClient] section
BOOL WriteNetBIOSParams(PCWInfFile pwifAnswerFile, PCWInfSection pwisParams);
BOOL WriteBrowserParams(PCWInfFile pwifAnswerFile, PCWInfSection pwisParams);
BOOL WriteLanmanServerParams(PCWInfFile pwifAnswerFile, PCWInfSection pwisParams);
BOOL WriteLanmanWorkstationParams(PCWInfFile pwifAnswerFile, PCWInfSection pwisParams);
BOOL WriteRPCLocatorParams(PCWInfFile pwifAnswerFile, PCWInfSection pwisParams);

//Bindings
BOOL WriteBindings(IN PCWSTR pszComponentName);

//Helper Functions

inline WORD SwapHiLoBytes(WORD w)
{
    return ((w & 0xff) << 8) | (w >> 8);
}

BOOL
FIsDontExposeLowerComponent (
    IN PCWSTR pszInfId)
{
    return ((0 == lstrcmpiW(pszInfId, c_szInfId_MS_NWIPX) ||
        (0 == lstrcmpiW(pszInfId, c_szInfId_MS_NWNB) ||
        (0 == lstrcmpiW(pszInfId, c_szInfId_MS_NWSPX)))));
}

BOOL
WriteRegValueToAFile(
    IN PCWInfSection pwisSection,
    IN HKEY hKey,
    IN PCWSTR pszSubKey,
    IN PCWSTR pszValueName,
    IN WORD wValueType = REG_SZ,
    IN PCWSTR pszValueNewName = NULL,
    IN BOOL fDefaultProvided = FALSE,
    IN ...);

BOOL
WriteRegValueToAFile(
    IN PCWInfSection pwisSection,
    IN HKEY hKey,
    IN PCWSTR pszSubKey,
    IN PCWSTR pszValueName,
    IN WORD wValueType,
    IN PCWSTR pszValueNewName,
    IN BOOL fDefaultProvided,
    IN va_list arglist);

BOOL
WriteRegValueToAFile(
    IN PCWInfSection pwisSection,
    IN CORegKey& rk,
    IN PCWSTR pszValueName,
    IN WORD wValueType = REG_SZ,
    IN PCWSTR pszValueNewName = NULL,
    IN BOOL fDefaultProvided = FALSE,
    ...);

BOOL
WriteRegValueToAFile(
    IN PCWInfSection pwisSection,
    IN CORegKey& rk,
    IN PCWSTR pszValueName,
    IN WORD wValueType,
    IN PCWSTR pszValueNewName,
    IN BOOL fDefaultProvided,
    IN va_list arglist);

BOOL
WriteServiceRegValueToAFile(
    IN PCWInfSection pwisSection,
    IN PCWSTR pszServiceKey,
    IN PCWSTR pszValueName,
    IN WORD wValueType = REG_SZ,
    IN PCWSTR pszValueNewName = NULL,
    IN BOOL fDefaultProvided = FALSE,
    ...);

//PCWSTR GetBusTypeName(DWORD dwBusType);
PCWSTR GetBusTypeName(INTERFACE_TYPE eBusType);
void AddToNetCardDB(IN PCWSTR pszAdapterName,
                    IN PCWSTR pszProductName,
                    IN PCWSTR pszAdapterDriver);
BOOL IsNetCardProductName(IN PCWSTR pszName);
BOOL IsNetCardInstance(IN PCWSTR pszName);
PCWSTR MapNetCardInstanceToAFileName(IN PCWSTR pszNetCardInstance);
void MapNetCardInstanceToAFileName(IN PCWSTR pszNetCardInstance,
                                   OUT tstring& strMappedName);

OUT BOOL IsNetworkComponent(IN CORegKey *prkSoftwareMicrosoft,
                            IN const tstring strComponentName);
BOOL GetServiceKey(IN PCWSTR pszServiceName, OUT PCORegKey &prkService);
BOOL GetServiceParamsKey(IN PCWSTR pszServiceName, OUT PCORegKey &prkServiceParams);
BOOL GetServiceSubkey(IN PCWSTR pszServiceName,
                      IN PCWSTR pszSubKeyName,
                      OUT PCORegKey &prkServiceSubkey);
BOOL GetServiceSubkey(IN const PCORegKey prkService,
                      IN PCWSTR pszSubKeyName,
                      OUT PCORegKey &prkServiceSubkey);
void ConvertRouteToStringList (PCWSTR pszRoute,
                               TStringList &slRoute );
BOOL StringListsIntersect(const TStringList& sl1, const TStringList& sl2);

QWORD ConvertToQWord(TByteArray ab);
VOID ConvertToByteList(TByteArray ab, tstring& str);
void ReplaceCharsInString(IN OUT PWSTR szString,
                          IN PCWSTR szFindChars, IN WCHAR chReplaceWith);
HRESULT HrNetRegSaveKey(IN HKEY hkeyBase, IN PCWSTR szSubKey,
                        IN PCWSTR szComponent,
                        OUT tstring* pstrFileName);
HRESULT HrNetRegSaveKeyAndAddToSection(IN HKEY hkeyBase, IN PCWSTR szSubKey,
                                       IN PCWSTR szComponent,
                                       IN PCWSTR szKeyName,
                                       IN CWInfSection* pwisSection);
HRESULT HrNetRegSaveServiceSubKeyAndAddToSection(IN PCWSTR szServiceName,
                                                 IN PCWSTR szServiceSubKeyName,
                                                 IN PCWSTR szKeyName,
                                                 IN CWInfSection* pwisSection);

HRESULT HrProcessOemComponentAndUpdateAfSection(
        IN  CNetMapInfo* pnmi,
        IN  HWND      hParentWindow,
        IN  HKEY      hkeyParams,
        IN  PCWSTR   szPreNT5InfId,
        IN  PCWSTR   szPreNT5Instance,
        IN  PCWSTR   szNT5InfId,
        IN  PCWSTR   szDescription,
        IN  CWInfSection* pwisParams);

HRESULT HrGetNumPhysicalNetAdapters(OUT UINT* puNumAdapters);
HRESULT HrHandleMiscSpecialCases(IN CWInfFile* pwifAnswerFile);
VOID WriteWinsockOrder(IN CWInfFile* pwifAnswerFile);

// ----------------------------------------------------------------------


static const WCHAR c_szCleanMainSection[]       = L"Clean";
static const WCHAR c_szCleanAddRegSection[]     = L"Clean.AddReg";
static const WCHAR c_szCleanDelRegSection[]     = L"Clean.DelReg";
static const WCHAR c_szCleanServicesSection[]   = L"Clean.Services";
static const WCHAR c_szAddReg[]                 = L"AddReg";
static const WCHAR c_szDelReg[]                 = L"DelReg";
static const WCHAR c_szDelService[]             = L"DelService";
static const WCHAR c_szDelRegFromSoftwareKey[]  = L"HKLM, \"Software\\Microsoft\\";
static const WCHAR c_szDelRegFromServicesKey[]  = L"HKLM, \"SYSTEM\\CurrentControlSet\\Services\\";
static const WCHAR c_szTextModeFlags[]          = L"TextModeFlags";
static const WCHAR c_szDelRegNCPA[]             = L"HKLM, \"Software\\Microsoft\\NCPA\"";

//
// List of software key names that are optional components. These are either
// new names OR old names of optional components.
//
static const PCWSTR c_aszOptComp[] =
{
    L"SNMP",
    L"WINS",
    L"SFM",
    L"DNS",
    L"SimpTcp",
    L"LPDSVC",
    L"DHCPServer",
    L"ILS",
    L"TCPUTIL",
    L"NETMONTOOLS",
    L"DSMIGRAT",
    L"MacPrint",
    L"MacSrv"
};

static const WCHAR c_szBloodHound[]  = L"Bh";
static const WCHAR c_szInfOption[]   = L"InfOption";
static const WCHAR c_szNetMonTools[] = L"NETMONTOOLS";

static const WCHAR  c_szIas[]               = L"IAS";
static const WCHAR  c_szIasVersion[]        = L"Version";


// ----------------------------------------------------------------------
//
// Function:  HrInitNetUpgrade
//
// Purpose:   Initialize netupgrd data structures.
//
// Arguments: None
//
// Returns:   S_OK on success, otherwise an error code
//
// Author:    kumarp 02-December-97
//
HRESULT HrInitNetUpgrade()
{
    DefineFunctionName("HrInitNetUpgrade");

    HRESULT hr;
    DWORD   dwErrorMessageCode = IDS_E_SetupCannotContinue;

    hr = HrInitNetMapInfo();
    if (S_OK != hr)
    {
        dwErrorMessageCode = IDS_E_NetMapInfError;
    }

    //
    //  Detect presence of Novell client to trigger special-case upgrade actions
    //
    if (S_OK == hr)
    {
        if (g_NetUpgradeInfo.From.dwBuildNumber > wWinNT4BuildNumber)
        {
            // now see if client32 is installed.

            static const WCHAR c_szNovell[] = L"NetWareWorkstation";

            HKEY hkeyServices, hkeyNovell;

            hr = HrRegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szRegKeyServices, KEY_READ, &hkeyServices);
            if (S_OK == hr)
            {
                // CONSIDER: is it better to check to see if some service is running?
                // see if Services\NetwareWorkstation key exists
                if (S_OK == HrRegOpenKeyEx(hkeyServices, c_szNovell, KEY_READ, &hkeyNovell))
                {
                    RegCloseKey(hkeyNovell);
                    g_fForceNovellDirCopy = TRUE;
                }
                RegCloseKey(hkeyServices);
            }
            else
            {
                hr = S_OK;      // no NetWare.
            }
        }
    }

    if (S_OK == hr)
    {
        UINT cNumConflicts;

        hr = HrGenerateConflictList(&cNumConflicts);

        if (S_OK == hr)
        {
            if ((cNumConflicts > 0) || g_fForceNovellDirCopy)
            {
                hr = HrInitAndProcessOemDirs();
                if (FAILED(hr))
                {
                    dwErrorMessageCode = IDS_E_InitAndProcessOemDirs;
                }
            }
        }
        else
        {
            dwErrorMessageCode = IDS_E_GenUpgradeConflictList;
        }
    }

    if( S_OK == hr )
    {
        //
        // Handle special-cased DHCP upgrade code to convert from
        // old format databases to current ESE format.
        //

        dwErrorMessageCode = DhcpUpgConvertDhcpDbToTemp();
        hr = HRESULT_FROM_WIN32(dwErrorMessageCode);
        TraceError( "DhcpUpgConvertDhcpDbToTemp", hr );

        if( FAILED(hr) )
        {
            dwErrorMessageCode = IDS_E_DhcpServerUpgradeError;
        }
    }
            
        
    if (FAILED(hr))
    {
        AbortUpgradeId(DwWin32ErrorFromHr(hr), dwErrorMessageCode);
    }

    TraceError(__FUNCNAME__, hr);
    return hr;
}

// ----------------------------------------------------------------------
//
// Function:  MapNetComponentNameForBinding
//
// Purpose:   Map component name to proper answerfile token so that it can
//            be used in a binding path
//            (e.g. IEEPRO3 --> Adapter02)
//
// Arguments:
//    pszComponentName [in]  constTString object name of name of
//    strMappedName    [out] name of name of
//
// Returns:   None
//
// Author:    kumarp 17-December-97
//
VOID
MapNetComponentNameForBinding (
    IN PCWSTR pszComponentName,
    OUT tstring &strMappedName)
{
    if (IsNetCardInstance(pszComponentName))
    {
        MapNetCardInstanceToAFileName(pszComponentName, strMappedName);
    }
    else
    {
        HRESULT hr;

        hr = HrMapPreNT5NetComponentServiceNameToNT5InfId(
                pszComponentName,
                &strMappedName);
        if (S_OK != hr)
        {
            strMappedName = c_szAfUnknown;
        }
    }
}

// ----------------------------------------------------------------------
//
// Function:  FIsOptionalComponent
//
// Purpose:   Determine if a component is an optional component
//
// Arguments:
//    pszName [in]  name of component
//
// Returns:   TRUE on success, FALSE otherwise
//
// Author:    kumarp 02-December-97
//
BOOL FIsOptionalComponent(
    PCWSTR pszName)
{
    BOOL    fIsOc;

    fIsOc = FIsInStringArray(c_aszOptComp, celems(c_aszOptComp), pszName);
    if (!fIsOc)
    {
        // BUG #148890 (danielwe) 13 Mar 1998: Special case check for NetMon
        // (bloodhound). If component name is "Bh", open its NetRules key (if
        // it exists) and see if it was installed as NETMONTOOLS which means
        // it was the NetMon tools optional component

        if (!lstrcmpiW (pszName, c_szBloodHound))
        {
            tstring strNetRules;
            HKEY    hkeyBh;

            strNetRules = L"Software\\Microsoft\\";
            strNetRules += pszName;
            strNetRules += L"\\CurrentVersion\\NetRules";

            if (SUCCEEDED(HrRegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                         strNetRules.c_str(), KEY_READ,
                                         &hkeyBh)))
            {
                tstring     strOption;

                if (SUCCEEDED(HrRegQueryString(hkeyBh, c_szInfOption,
                                               &strOption)))
                {
                    if (!lstrcmpiW(strOption.c_str(), c_szNetMonTools))
                    {
                        fIsOc = TRUE;
                    }
                }

                RegCloseKey(hkeyBh);
            }
        }
    }

    return fIsOc;
}

static const WCHAR c_szRegKeyOc[]           = L"Software\\Microsoft\\Windows\\CurrentVersion\\Setup\\OptionalComponents";
static const WCHAR c_szInstalled[]          = L"Installed";
static const WCHAR c_szOcIsInstalled[]      = L"1";
extern const WCHAR c_szOcMainSection[];

static const WCHAR c_szSfm[]                = L"SFM";
static const WCHAR c_szMacSrv[]             = L"MacSrv";
static const WCHAR c_szMacPrint[]           = L"MacPrint";
static const WCHAR c_szRegKeyOcmSubComp[]   = L"Software\\Microsoft\\Windows\\CurrentVersion\\Setup\\OC Manager\\Subcomponents";
static const WCHAR c_szRegKeyCmak[]         = L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\App Paths\\CMAK.EXE";
static const WCHAR c_szRegValueCpsSrv[]     = L"CPSSRV";
static const WCHAR c_szRegValueCpsAd[]      = L"CPSAD";
static const WCHAR c_szNetCm[]              = L"NETCM";

static const TCHAR c_szRegKeyIAS[]          = TEXT("SYSTEM\\CurrentControlSet\\Services\\AuthSrv\\Parameters");

//+---------------------------------------------------------------------------
//
//  Function:   WriteNt5OptionalComponentList
//
//  Purpose:    Writes the list of optional components that were installed
//              prior to upgrading from an NT5 build.
//
//  Arguments:
//      pwifAnswerFile [in]     Answer file object
//
//  Returns:    TRUE if success, FALSE if not.
//
//  Author:     danielwe   8 Jan 1998
//
//  Notes:
//
BOOL WriteNt5OptionalComponentList(IN CWInfFile *pwifAnswerFile)
{
    HRESULT         hr = S_OK;
    PCWInfSection   pwisMain;

    // Add section "[OldOptionalComponents]"
    pwisMain = pwifAnswerFile->AddSectionIfNotPresent(c_szOcMainSection);
    if (!pwisMain)
    {
        hr = E_FAIL;
    }

    if (SUCCEEDED(hr))
    {
        CORegKey        rkOc(HKEY_LOCAL_MACHINE, c_szRegKeyOc, KEY_READ);
        CORegKeyIter    rkOcIter(rkOc);
        tstring         strOcName;

        // loop over each subkey in the OptionalComponents tree
        while (!rkOcIter.Next(&strOcName))
        {
            if (!FIsOptionalComponent(strOcName.c_str()))
            {
                continue;
            }

            HKEY    hkeyOc;
            hr = HrRegOpenKeyEx(rkOc.HKey(), strOcName.c_str(),
                                KEY_READ, &hkeyOc);
            if (SUCCEEDED(hr))
            {
                ULONG   fInstalled;

                hr = HrRegQueryStringAsUlong(hkeyOc, c_szInstalled, 10,
                                             &fInstalled);
                if (SUCCEEDED(hr) ||
                    HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr)
                {
                    hr = S_OK;

                    if (fInstalled)
                    {
                        if (!lstrcmpiW(strOcName.c_str(), c_szSfm))
                        {
                            // Special case the SFM component because
                            // it got split into 2
                            pwisMain->AddKey(c_szMacSrv,
                                             c_szOcIsInstalled);
                            pwisMain->AddKey(c_szMacPrint,
                                             c_szOcIsInstalled);
                        }
                        else
                        {
                            pwisMain->AddKey(strOcName.c_str(),
                                             c_szOcIsInstalled);
                        }
                    }
                }

                RegCloseKey(hkeyOc);
            }
        }
    }

    TraceError("WriteNt5OptionalComponentList", hr);
    return SUCCEEDED(hr);
}

//+---------------------------------------------------------------------------
//
//  Function:   HandlePostConnectionsSfmOcUpgrade
//
//  Purpose:    Handles the upgrade of the SFM optional component which was
//              split into 2 different components. This only applies to
//              post connections builds (1740+).
//
//  Arguments:
//      pwifAnswerFile [in]      Answer file object
//
//  Returns:    TRUE
//
//  Author:     danielwe   3 Feb 1998
//
//  Notes:      If SFM was previously installed, write out MacSrv and MacPrint
//              to the answer file in its place.
//
BOOL HandlePostConnectionsSfmOcUpgrade(IN CWInfFile *pwifAnswerFile)
{
    HKEY    hkeyOc;

    if (SUCCEEDED(HrRegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szRegKeyOcmSubComp,
                                 KEY_READ, &hkeyOc)))
    {
        DWORD   dwSfm;

        if (SUCCEEDED(HrRegQueryDword(hkeyOc, c_szSfm, &dwSfm)))
        {
            if (dwSfm == 1)
            {
                PCWInfSection   pwisMain;

                pwisMain = pwifAnswerFile->AddSectionIfNotPresent(c_szOcMainSection);
                if (pwisMain)
                {
                    pwisMain->AddKey(c_szMacSrv, c_szOcIsInstalled);
                    pwisMain->AddKey(c_szMacPrint, c_szOcIsInstalled);
                }
            }
        }

        RegCloseKey(hkeyOc);
    }

    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrWriteConfigManagerOptionalComponents
//
//  Purpose:    Special case for writing config manager components to the
//              answer file.
//
//  Arguments:
//      pwifAnswerFile [in]      Answer file object
//
//  Returns:    S_OK if success, otherwise an error code
//
//  Author:     danielwe   1 May 1998
//
//  Notes:
//
HRESULT HrWriteConfigManagerOptionalComponents(CWInfFile *pwifAnswerFile)
{
    HRESULT         hr = S_OK;
    HKEY            hkeyCmak;
    HKEY            hkeyOcm;
    PCWInfSection   pwisMain;
    BOOL            fFoundCmComponent = FALSE;

    pwisMain = pwifAnswerFile->FindSection(c_szOcMainSection);

    if (SUCCEEDED(HrRegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szRegKeyCmak, KEY_READ,
                                 &hkeyCmak)))
    {
        fFoundCmComponent = TRUE;
        RegCloseKey(hkeyCmak);
    }

    if (SUCCEEDED(HrRegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szRegKeyOcmSubComp,
                                 KEY_READ, &hkeyOcm)))
    {
        DWORD   dwValue;

        if (SUCCEEDED(HrRegQueryDword(hkeyOcm, c_szRegValueCpsSrv, &dwValue)))
        {
            if (dwValue)
            {
                fFoundCmComponent = TRUE;
            }
        }

        if (SUCCEEDED(HrRegQueryDword(hkeyOcm, c_szRegValueCpsAd, &dwValue)))
        {
            if (dwValue)
            {
                fFoundCmComponent = TRUE;
            }
        }

        RegCloseKey(hkeyOcm);
    }

    //  If we found any one of the three CM components, then we want to install the suite of
    //  all three components.
    //
    if (fFoundCmComponent)
    {
        pwisMain->AddKey(c_szNetCm, c_szOcIsInstalled);
    }

    TraceError("HrWriteConfigManagerOptionalComponents", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrWriteIASOptionalComponents
//
//  Purpose:    Special case for writing IAS component to the
//              answer file.
//
//  Arguments:
//      pwifAnswerFile [in]      Answer file object
//
//  Returns:    S_OK if success, otherwise an error code
//
//  Author:     tperraut (T.P. comments) Feb 22 1999
//
//  Notes:      03/31/2000 tperraut: do not check the content of the Version 
//              string anymore: all NT4 IAS should get upgraded
//
HRESULT HrWriteIASOptionalComponents(CWInfFile *pwifAnswerFile)
{
    HRESULT         hr;
    HKEY            hkeyIAS;

    PCWInfSection pwisMain = pwifAnswerFile->FindSection(c_szOcMainSection);

    if (SUCCEEDED(HrRegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szRegKeyIAS, KEY_READ,
                                 &hkeyIAS)))
    {
        tstring     strVersion;
        hr = HrRegQueryString(hkeyIAS, c_szIasVersion, &strVersion);

        if (S_OK == hr)
        {
            pwisMain->AddKey(c_szIas, c_szOcIsInstalled);
        }

        RegCloseKey(hkeyIAS);
    }
    else
    {
        hr = E_FAIL;
    }

    TraceError("HrWriteIASOptionalComponents", hr);
    return      hr;
}

// ----------------------------------------------------------------------
//
// Function:  HrWriteNt4OptionalComponentList
//
// Purpose:   Writes the list of optional components that were installed
//            if upgrading from NT4.
//
// Arguments:
//    pwifAnswerFile [in]  pointer to CWInfFile object
//    slNetOcList    [in]  list of optional components
//
// Returns:   S_OK on success, otherwise an error code
//
// Author:    kumarp 02-December-97
//
HRESULT
HrWriteNt4OptionalComponentList (
    IN CWInfFile *pwifAnswerFile,
    IN const TStringList &slNetOcList)
{
    HRESULT         hr = S_OK;
    PCWInfSection   pwisMain;

    pwisMain = pwifAnswerFile->AddSectionIfNotPresent(c_szOcMainSection);
    if (!pwisMain)
    {
        hr = E_FAIL;
    }
    if (SUCCEEDED(hr))
    {
        TStringListIter     iter;
        tstring             strTemp;

        for (iter = slNetOcList.begin(); iter != slNetOcList.end(); iter++)
        {
            strTemp = **iter;
            if (!lstrcmpiW(strTemp.c_str(), c_szSfm))
            {
                // Special case the SFM component because it got split into 2
                pwisMain->AddKey(c_szMacSrv, c_szOcIsInstalled);
            }
            else if (!lstrcmpiW(strTemp.c_str(), c_szBloodHound))
            {
                // Special case NetMon. If tools were installed via the "Bh"
                // component of NT4, write this out as NETMONTOOLS=1 in the
                // answer file.
                pwisMain->AddKey(c_szNetMonTools, c_szOcIsInstalled);
            }
            else
            {
                pwisMain->AddKey(strTemp.c_str(), c_szOcIsInstalled);
            }
        }
        // tperraut
        hr = HrWriteIASOptionalComponents(pwifAnswerFile);

        hr = HrWriteConfigManagerOptionalComponents(pwifAnswerFile);
    }

    TraceError("HrWriteNt4OptionalComponentList", hr);
    return hr;
}

// ----------------------------------------------------------------------
//
// Function:  HrWriteMainCleanSection
//
// Purpose:   Write [Clean] section in the answerfile
//
// Arguments:
//    pwifAnswerFile [in]  pointer to CWInfFile object
//
// Returns:   S_OK on success, otherwise an error code
//
// Author:    kumarp 02-December-97
//
// Notes:     The [Clean] section holds data that controls what is deleted
//            at the start of GUI mode setup
//
HRESULT
HrWriteMainCleanSection (
    IN CWInfFile *pwifAnswerFile)
{
    HRESULT         hr = S_OK;
    PCWInfSection   pwisMain;

    // Add section "[Clean]"
    pwisMain = pwifAnswerFile->AddSection(c_szCleanMainSection);
    if (!pwisMain)
    {
        hr = E_FAIL;
    }

    if (SUCCEEDED(hr))
    {
        pwisMain->AddKey(c_szDelReg, c_szCleanDelRegSection);
    }

    TraceError("HrWriteMainCleanSection", hr);
    return hr;
}

// ----------------------------------------------------------------------
//
// Function:  HrGetListOfServicesNotToBeDeleted
//
// Purpose:   Generate list of services that should not be deleted
//            during upgrade.
//
// Arguments:
//    pmszServices [out] pointer to multisz list of services
//
// Returns:   S_OK on success, otherwise an error code
//
// Author:    kumarp 02-December-97
//
// Notes:     This info is read from netupg.inf file
//
HRESULT
HrGetListOfServicesNotToBeDeleted (
    OUT PWSTR* pmszServices)
{
    AssertValidWritePtr(pmszServices);

    HRESULT hr;
    HINF hinf;

    *pmszServices = NULL;

    hr = HrOpenNetUpgInfFile(&hinf);
    if (S_OK == hr)
    {
        INFCONTEXT ic;

        hr = HrSetupFindFirstLine(
                hinf,
                L"UpgradeData",
                L"ServicesNotToBeDeletedDuringUpgrade",
                &ic);

        if (S_OK == hr)
        {
            hr = HrSetupGetMultiSzFieldWithAlloc(ic, 1, pmszServices);
        }

        SetupCloseInfFile(hinf);
    }

    return hr;
}

// ----------------------------------------------------------------------
//
// Function:  GetNetworkServicesList
//
// Purpose:   Generate list of net services
//
// Arguments:
//    slNetServices           [out] list of net services
//    slNetOptionalComponents [out] list of optional components found
//
// Returns:   None
//
// Author:    kumarp 02-December-97
//
void
GetNetworkServicesList (
    OUT TStringList& slNetServices,
    OUT TStringList& slNetOptionalComponents)
{
    DefineFunctionName("GetNetworkServicesList");

    HRESULT hr=S_OK;

    tstring strNetComponentName;
    tstring strServiceName;

    Assert (g_NetUpgradeInfo.From.dwBuildNumber);
    if (g_NetUpgradeInfo.From.dwBuildNumber <= wWinNT4BuildNumber)
    {
        // found Pre-NT5 networking, collect list by enumerating over
        // the registry

        CORegKey rkSoftwareMicrosoft(HKEY_LOCAL_MACHINE, c_szRegKeySoftwareMicrosoft,
                                     KEY_READ);
        if (!rkSoftwareMicrosoft.HKey())
        {
            TraceTag(ttidError, "%s: Error reading HKLM\\%S", __FUNCNAME__,
                     c_szRegKeySoftwareMicrosoft);
            hr = E_FAIL;
            goto return_from_function;
        }

        CORegKeyIter* prkiNetComponents = new CORegKeyIter(rkSoftwareMicrosoft);

        if(prkiNetComponents) {
            // mbend - this is not great, but it should get Prefix to shutup

            while (!prkiNetComponents->Next(&strNetComponentName))
            {
                if (FIsOptionalComponent(strNetComponentName.c_str()))
                {
                    AddAtEndOfStringList(slNetOptionalComponents, strNetComponentName);
                }

                // any software that has a NetRules key under the CurrentVersion
                // key is a network component
                if (!IsNetworkComponent(&rkSoftwareMicrosoft, strNetComponentName))
                {
                    continue;
                }

                CORegKey rkNetComponent(rkSoftwareMicrosoft,
                                        (strNetComponentName +
                                         L"\\CurrentVersion").c_str());
                if (!((HKEY) rkNetComponent))
                {
                    continue;
                }

                strServiceName.erase();
                rkNetComponent.QueryValue(c_szRegValServiceName, strServiceName);

                if (!strServiceName.empty())
                {
                    AddAtEndOfStringList(slNetServices, strServiceName);
                }
            }
        }
        hr = S_OK;
    }

    // with the above algorithm we do not catch all networking components
    // because there are certain networking servies such as NetBIOSInformation
    // that have entry under service but not under software\microsoft
    // for such components, we use the following rule
    // if a serice under CurrentControlSet\Sevices has a Linkage sub key
    // then it is considered as a networking service
    //
    HKEY hkeyServices;
    hr = HrRegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szRegKeyServices,
                        KEY_READ, &hkeyServices);
    if (S_OK == hr)
    {
        WCHAR szBuf[MAX_PATH];
        FILETIME time;
        DWORD dwSize;
        DWORD dwRegIndex;
        HKEY hkeyService;
        HKEY hkeyLinkage;
        BOOL fHasLinkageKey;

        for (dwRegIndex = 0, dwSize = celems(szBuf);
             S_OK == HrRegEnumKeyEx(hkeyServices, dwRegIndex, szBuf,
                        &dwSize, NULL, NULL, &time);
             dwRegIndex++, dwSize = celems(szBuf))
        {
            Assert(*szBuf);

            hr = HrRegOpenKeyEx(hkeyServices, szBuf, KEY_READ, &hkeyService);
            if (hr == S_OK)
            {
                //
                // 399641: instead of using Linkage, we use Linkage\Disabled.
                //
                hr = HrRegOpenKeyEx(hkeyService, c_szLinkageDisabled, KEY_READ, &hkeyLinkage);
                fHasLinkageKey = (S_OK == hr);
                RegSafeCloseKey(hkeyLinkage);

                if (fHasLinkageKey && !FIsInStringList(slNetServices, szBuf))
                {
                    slNetServices.push_back(new tstring(szBuf));
                }

                RegCloseKey (hkeyService);
            }
        }

        RegCloseKey(hkeyServices);
    }

return_from_function:
    TraceError(__FUNCNAME__, hr);
}

// REVIEW$ (shaunco)
// This is a list of drivers/services that were disabled (via TextModeFlags)
// but not deleted.  Thus, the purpose was just to prevent these from
// starting during GUI mode.  That is now handled automatically by the
// service controller, so the only things from this list which we might have
// an issue with are those that are system-start.
//
static const PCWSTR c_aszServicesToDisable[] =
{
    L"Afd",
    L"CiFilter",
    L"ClipSrv",
    L"DHCP",
    L"DigiFEP5",
    L"IpFilterDriver"
    L"LicenseService",
    L"NdisTapi",
    L"NetDDE",
    L"NetDDEdsdm",
    L"Pcimac",
    L"RasAcd",
    L"RasArp",
    L"Telnet",
    L"ftpsvc",
    L"gophersvc",
    L"msftpsvc",
    L"ntcx",
    L"ntepc",
    L"ntxall",
    L"ntxem",
    L"raspptpf",
    L"w3svc",
    L"wuser32",
};

HRESULT
HrPrepareServiceForUpgrade (
    IN PCWSTR pszServiceName,
    IN PCWSTR pmszServicesNotToBeDeleted,
    IN CWInfSection* pwisDelReg,
    IN CWInfSection* pwisDelService,
    IN CWInfSection* pwisStartTypes)
{
    Assert (pszServiceName);
    Assert (pmszServicesNotToBeDeleted);
    Assert (pwisDelReg);
    Assert (pwisDelService);
    Assert (pwisStartTypes);

    HRESULT hr;
    HKEY hkey;
    DWORD dwValue;
    WCHAR szBuf [_MAX_PATH];
    BOOL fDelete;

    fDelete = !FIsSzInMultiSzSafe (pszServiceName, pmszServicesNotToBeDeleted) &&
              FCanDeleteOemService (pszServiceName);

    if (fDelete)
    {
        // Remove from the software hive if present.
        //
        wcscpy (szBuf, c_szDelRegFromSoftwareKey);
        wcscat (szBuf, pszServiceName);
        wcscat (szBuf, L"\"");
        pwisDelReg->AddRawLine (szBuf);
    }

    hr = HrRegOpenServiceKey (pszServiceName, KEY_READ_WRITE, &hkey);
    if (S_OK == hr)
    {
        // Save the start type so that we can restore it after we reinstall
        // the service for Windows 2000.
        //
        hr = HrRegQueryDword (hkey, c_szRegValStart, &dwValue);
        if (S_OK == hr)
        {
            pwisStartTypes->AddKey (pszServiceName, dwValue);
        }

        if (fDelete)
        {
            hr = HrRegQueryDword (hkey, c_szType, &dwValue);
            if (S_OK == hr)
            {
                if (dwValue & SERVICE_ADAPTER)
                {
                    // Pseudo service on NT4.  We have to delete this with
                    // a DelReg, not a DelService.
                    //
                    wcscpy (szBuf, c_szDelRegFromServicesKey);
                    wcscat (szBuf, pszServiceName);
                    wcscat (szBuf, L"\"");
                    pwisDelReg->AddRawLine (szBuf);
                }
                else
                {
                    pwisDelService->AddKey(c_szDelService, pszServiceName);
                }

                // Since we will be deleting it during GUI mode, we need to
                // ensure that it gets set to disabled during text mode so
                // that (in the event it is a SYSTEM_START driver) it does
                // not get started during GUI mode before we can delete it.
                //
                (VOID) HrRegSetDword (hkey, c_szTextModeFlags, 0x4);
            }
        }

        RegCloseKey (hkey);
    }
    else if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr)
    {
        // Not a service.  We'll remove from the software key.
        //
        hr = S_OK;
    }

    TraceHr (ttidError, FAL, hr, FALSE, "HrPrepareServiceForUpgrade");
    return hr;
}

// ----------------------------------------------------------------------
//
// Function:  WriteDisableServicesList
//
// Purpose:   Determine which services need to be disabled during ugprade and
//            write proper info to the answerfile to make that happen.
//            The set of such services consists of
//            - network component services AND
//            - services that depend of atleast one net-service
//
// Arguments:
//    pwifAnswerFile [in]  pointer to CWInfFile object
//
// Returns:   TRUE on success, FALSE otherwise
//
// Author:    kumarp 03-December-97
//
BOOL
WriteDisableServicesList (
    IN CWInfFile *pwifAnswerFile)
{
    HRESULT hr = S_OK;
    TStringList slNetServices;
    TStringList slNetOcList;
    TStringListIter iter;
    tstring* pstrServiceName;
    CWInfSection* pwisDelReg;
    CWInfSection* pwisDelService;
    CWInfSection* pwisStartTypes;
    PWSTR pmszServicesNotToBeDeleted;

    // We should only be here if we are upgrading from from NT4 or earlier.
    //
    Assert (g_NetUpgradeInfo.From.dwBuildNumber);
    Assert (g_NetUpgradeInfo.From.dwBuildNumber <= wWinNT4BuildNumber)

    // First, collect all network services and optional components.
    //
    GetNetworkServicesList(slNetServices, slNetOcList);

    hr = HrWriteNt4OptionalComponentList(pwifAnswerFile, slNetOcList);
    if (FAILED(hr))
    {
        goto finished;
    }

    pwisDelReg     = pwifAnswerFile->AddSectionIfNotPresent(c_szCleanDelRegSection);
    pwisDelService = pwifAnswerFile->AddSectionIfNotPresent(c_szCleanServicesSection);
    pwisStartTypes = pwifAnswerFile->AddSectionIfNotPresent(c_szAfServiceStartTypes);

    if (!pwisDelReg || !pwisDelService || !pwisStartTypes)
    {
        hr = E_OUTOFMEMORY;
        goto finished;
    }

    hr = HrGetListOfServicesNotToBeDeleted(&pmszServicesNotToBeDeleted);

    if (S_OK == hr)
    {
        pwisDelReg->AddRawLine(c_szDelRegNCPA);

        for (iter =  slNetServices.begin();
             iter != slNetServices.end();
             iter++)
        {
            pstrServiceName = *iter;
            Assert (pstrServiceName);

            hr = HrPrepareServiceForUpgrade (
                    pstrServiceName->c_str(),
                    pmszServicesNotToBeDeleted,
                    pwisDelReg,
                    pwisDelService,
                    pwisStartTypes);

            if (S_OK != hr)
            {
                break;
            }
        }

        MemFree (pmszServicesNotToBeDeleted);
    }

finished:
    EraseAndDeleteAll(&slNetOcList);
    EraseAndDeleteAll(&slNetServices);

    TraceError("WriteDisableServicesList", hr);
    return SUCCEEDED(hr);
}

extern const DECLSPEC_SELECTANY WCHAR c_szRegNetKeys[] = L"System\\CurrentControlSet\\Control\\Network\\{4D36E972-E325-11CE-BFC1-08002BE10318}";
extern const DECLSPEC_SELECTANY WCHAR c_szRegKeyConFmt[] = L"System\\CurrentControlSet\\Control\\Network\\{4D36E972-E325-11CE-BFC1-08002BE10318}\\%s\\Connection";
extern const DECLSPEC_SELECTANY WCHAR c_szafNICsWithIcons[] = L"NetworkAdaptersWithIcons";
static const WCHAR c_szShowIcon[]  = L"ShowIcon";


// ----------------------------------------------------------------------
//
// Function:  WritePerAdapterInfoForNT5
//
// Purpose:   Determine which services need to be disabled during ugprade from 
//            Windows 2000 and write proper info to the answerfile to make that happen.
//            The set of such services consists of
//            - network component services
//
// Arguments:
//    pwifAnswerFile [in]  pointer to CWInfFile object
//
// Returns:   TRUE on success, FALSE otherwise
//
// Author:    deonb  10-July-2000
//
BOOL
WritePerAdapterInfoForNT5 (
    IN CWInfFile *pwifAnswerFile)
{
    HRESULT hr = S_OK;
    HKEY    hkey;
    
    // Check for the existence of the connection sub-key
    hr = HrRegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szRegNetKeys, KEY_READ, &hkey);
    if (SUCCEEDED(hr))
    {
        DWORD    dwIndex(0);
        TCHAR    szName[MAX_PATH+1];
        DWORD    dwSize(MAX_PATH);
        FILETIME ftLastWriteTime;
        DWORD    dwRetVal(0);

        do
        {
            dwRetVal = RegEnumKeyEx(hkey, dwIndex, szName, &dwSize, NULL, NULL, NULL, &ftLastWriteTime);
            if ( ERROR_SUCCESS == dwRetVal )
            {
                TCHAR szRegKey[MAX_PATH+1];
                swprintf(szRegKey, c_szRegKeyConFmt, szName);

                HKEY hkeyConnection;
                hr = HrRegOpenKeyEx(HKEY_LOCAL_MACHINE, szRegKey, KEY_READ, &hkeyConnection);
                if (SUCCEEDED(hr))
                {
                    DWORD dwValue;
                    HRESULT hr = HrRegQueryDword(hkeyConnection, c_szShowIcon, &dwValue);
                    if (SUCCEEDED(hr) && dwValue)
                    {
                        CWInfSection* pwisStartTypes;
                        pwisStartTypes = pwifAnswerFile->AddSectionIfNotPresent(c_szafNICsWithIcons);
                        if (!pwisStartTypes)
                        {
                            hr = E_OUTOFMEMORY;
                        }
                        else
                        {
                            pwisStartTypes->AddKey (szName, 1);
                        }
                        
                    }
                    RegSafeCloseKey(hkeyConnection);
                }
            }
        } while ( (ERROR_SUCCESS == dwRetVal) && (SUCCEEDED(hr)) );


        RegSafeCloseKey(hkey);
    }

    TraceError("WritePerAdapterInfoForNT5", hr);
    return SUCCEEDED(hr);
}

// ----------------------------------------------------------------------
//
// Function:  WriteDisableServicesListForNT5
//
// Purpose:   Determine which services need to be disabled during ugprade from 
//            Windows 2000 and write proper info to the answerfile to make that happen.
//            The set of such services consists of
//            - network component services
//
// Arguments:
//    pwifAnswerFile [in]  pointer to CWInfFile object
//
// Returns:   TRUE on success, FALSE otherwise
//
// Author:    deonb  10-July-2000
//
BOOL
WriteDisableServicesListForNT5 (
    IN CWInfFile *pwifAnswerFile)
{
    static PCWSTR c_aszNT5UpgrdCheckComponents[] =
    {
        L"Browser",
        L"LanmanServer",
        c_szSvcDhcpServer
    };

    HRESULT hr = S_OK;

    PCWSTR pstrServiceName;
    CWInfSection* pwisStartTypes;
    PWSTR pmszServicesNotToBeDeleted;

    // We should only be here if we are upgrading from NT5 or later.
    //
    Assert (g_NetUpgradeInfo.From.dwBuildNumber);
    Assert (g_NetUpgradeInfo.From.dwBuildNumber > wWinNT4BuildNumber)

    // First, collect all network services and optional components.
    //
    pwisStartTypes = pwifAnswerFile->AddSectionIfNotPresent(c_szAfServiceStartTypes);
    if (!pwisStartTypes)
    {
        hr = E_OUTOFMEMORY;
        goto finished;
    }

    if (S_OK == hr)
    {
        DWORD x;
        for (x = 0, pstrServiceName = c_aszNT5UpgrdCheckComponents[0];
                   x < sizeof(c_aszNT5UpgrdCheckComponents)/sizeof(c_aszNT5UpgrdCheckComponents[0]); 
                   x++, pstrServiceName = c_aszNT5UpgrdCheckComponents[x])
        {
            Assert (pstrServiceName);

            HKEY hkey;
            hr = HrRegOpenServiceKey (pstrServiceName, KEY_READ, &hkey);
            if (S_OK == hr)
            {
                // Save the start type (only if disabled) so that we can restore it after we install
                // the service for Windows 2000.
                DWORD dwValue;
                hr = HrRegQueryDword (hkey, c_szRegValStart, &dwValue);
                if ( (S_OK == hr) && (SERVICE_DISABLED == dwValue) )
                {
                    pwisStartTypes->AddKey (pstrServiceName, dwValue);
                }
                
                RegCloseKey (hkey);
            }
        }
    }

finished:
    TraceError("WriteDisableServicesListNT5", hr);
    return SUCCEEDED(hr);
}


// ----------------------------------------------------------------------
//
// Function:  GetProductTypeStr
//
// Purpose:   Get string representation of PRODUCTTYPE
//
// Arguments:
//    pt [in]  Product type
//
// Returns:   pointer to string representation of PRODUCTTYPE
//
// Author:    kumarp 03-December-97
//
PCWSTR
GetProductTypeStr (
    IN PRODUCTTYPE pt)
{
    PCWSTR szProductType;

    switch(pt)
    {
    case NT_WORKSTATION:
        szProductType = c_szAfNtWorkstation;
        break;

    case NT_SERVER:
        szProductType = c_szAfNtServer;
        break;

    default:
        szProductType = NULL;
        break;
    }

    return szProductType;
}

// ----------------------------------------------------------------------
//
// Function:  WriteNetComponentsToRemove
//
// Purpose:   Write the network components in the answerfile
//            that will be removed.
//
// Arguments:
//    pwisNetworking [in]  pointer to [Networking] section
//
// Returns:   none
//
// Author:    asinha 29-March-2001
//
void WriteNetComponentsToRemove (IN CWInfSection* pwisNetworking)
{

    DefineFunctionName("WriteNetComponentsToRemove");
    TraceFunctionEntry(ttidNetUpgrade);

    TraceTag(ttidNetUpgrade, "netupgrd.dll: WriteNetComponentsToRemove");

    if ( ShouldRemoveDLC(NULL, NULL) )
    {
        PCWInfKey  pwisKey;
        TStringList slNetComponentsToRemove;

        pwisKey = pwisNetworking->FindKey(c_szAfNetComponentsToRemove,
                                          ISM_FromBeginning);

        if ( pwisKey )
        {
            // Read the old value of NetComponentsToRemove

            pwisKey->GetStringListValue(slNetComponentsToRemove);
        }
        else
        {
            pwisKey = pwisNetworking->AddKey(c_szAfNetComponentsToRemove);
        }

        // Make sure to write the new infId/PnpId.

        AddAtEndOfStringList(slNetComponentsToRemove,
                             sz_MS_DLC);

        pwisKey->SetValue( slNetComponentsToRemove );
    }

    return;
}



// ----------------------------------------------------------------------
//
// Function:  WriteProductTypeInfo
//
// Purpose:   Write product-type info to the answerfile
//
// Arguments:
//    pwisNetworking [in]  pointer to [Networking] section
//
// Returns:   none
//
// Author:    kumarp 03-December-97
//
void
WriteProductTypeInfo (
    IN CWInfSection* pwisNetworking)
{
    PCWSTR pszProduct;

    pszProduct = GetProductTypeStr(g_NetUpgradeInfo.From.ProductType);

    Assert(pszProduct);

    //UpgradeFromProduct
    pwisNetworking->AddKey(c_szAfUpgradeFromProduct, pszProduct);

    //BuildNumber
    Assert (g_NetUpgradeInfo.From.dwBuildNumber);
    pwisNetworking->AddKey(c_szAfBuildNumber, g_NetUpgradeInfo.From.dwBuildNumber);
}

// ----------------------------------------------------------------------
//
// Function:  WriteNetworkInfoToAnswerFile
//
// Purpose:   Write information about current network components
//            to the answerfile
//
// Arguments:
//    pwifAnswerFile [in]  pointer to CWInfFile object
//
// Returns:   TRUE on success, FALSE otherwise
//
// Author:    kumarp 03-December-97
//
BOOL
WriteNetworkInfoToAnswerFile (
    IN CWInfFile *pwifAnswerFile)
{
    DefineFunctionName("WriteNetworkInfoToAnswerFile");

    BOOL status=FALSE;

    g_pslNetCard = new TStringList;
    g_pslNetCardInstance = new TStringList;
    g_pslNetCardAFileName = new TStringList;

    Assert (g_NetUpgradeInfo.From.dwBuildNumber);
    if ((g_NetUpgradeInfo.From.dwBuildNumber <= wWinNT4BuildNumber) &&
        !FIsPreNT5NetworkingInstalled())
    {
        // this is NT4 or earlier and networking is not installed
        // dont need to dump answerfile

        TraceTag(ttidNetUpgrade, "%s: Networking is not installed, "
                 "answerfile will not be dumped", __FUNCNAME__);

        goto return_from_function;
    }

    CWInfSection* pwisNetworking;

    pwisNetworking =
        pwifAnswerFile->AddSectionIfNotPresent(c_szAfSectionNetworking);

    //The order in which these functions are called is important
    //DO NOT change it
    WriteProductTypeInfo(pwisNetworking);
    status = WriteNt5OptionalComponentList(pwifAnswerFile);
    status = HandlePostConnectionsSfmOcUpgrade(pwifAnswerFile);

    WriteNetComponentsToRemove(pwisNetworking);

    if (g_NetUpgradeInfo.From.dwBuildNumber > wWinNT4BuildNumber)
    {
        status = WriteDisableServicesListForNT5(pwifAnswerFile);
        status = WritePerAdapterInfoForNT5(pwifAnswerFile);

        // we dont want netsetup to process other sections
        //
        pwisNetworking->AddBoolKey(c_szAfProcessPageSections, FALSE);

        //for NT5 to NT5 upgrade, no need to dump other info
        //
        goto return_from_function;
    }

    //  we want netsetup to process other sections
    //
    pwisNetworking->AddBoolKey(c_szAfProcessPageSections, TRUE);

    (void) HrWriteMainCleanSection(pwifAnswerFile);

    status = WriteIdentificationInfo(pwifAnswerFile);
    status = WriteNetAdaptersInfo(pwifAnswerFile);

    pwifAnswerFile->GotoEnd();

    g_pwisBindings = pwifAnswerFile->AddSection(c_szAfSectionNetBindings);
    g_pwisBindings->AddComment(L"Only the disabled bindings are listed");

    HrWriteNetComponentsInfo(pwifAnswerFile);

    status = WriteDisableServicesList(pwifAnswerFile);

    (void) HrHandleMiscSpecialCases(pwifAnswerFile);

    WriteWinsockOrder(pwifAnswerFile);

return_from_function:
    EraseAndDeleteAll(g_pslNetCard);
    EraseAndDeleteAll(g_pslNetCardInstance);
    EraseAndDeleteAll(g_pslNetCardAFileName);

    DeleteIfNotNull(g_pslNetCard);
    DeleteIfNotNull(g_pslNetCardInstance);
    DeleteIfNotNull(g_pslNetCardAFileName);

    return status;
}

//+---------------------------------------------------------------------------
//
//  Function:   WriteWinsockOrder
//
//  Purpose:    Records the order of winsock providers in NT4 so that they
//              can be restored after upgrade.
//
//  Arguments:
//      pwifAnswerFile [in]     Answer file structure
//
//  Returns:    Nothing
//
//  Author:     danielwe   1 Jun 1999
//
//  Notes:
//
VOID WriteWinsockOrder (
    IN CWInfFile* pwifAnswerFile)
{
    AssertValidReadPtr(pwifAnswerFile);
    DefineFunctionName("WriteWinsockOrder");

    CWInfSection* pwisWinsock;

    pwisWinsock = pwifAnswerFile->AddSection(c_szAfSectionWinsock);
    if (pwisWinsock)
    {
        tstring             strWinsockOrder;
        INT                 nErr;
        ULONG               ulRes;
        DWORD               cbInfo = 0;
        WSAPROTOCOL_INFO*   pwpi = NULL;
        WSAPROTOCOL_INFO*   pwpiInfo = NULL;
        LPWSCENUMPROTOCOLS  pfnWSCEnumProtocols = NULL;
        HMODULE             hmod;

        if (SUCCEEDED(HrLoadLibAndGetProc(L"ws2_32.dll",
                                 "WSCEnumProtocols",
                                 &hmod,
                                 reinterpret_cast<FARPROC *>(&pfnWSCEnumProtocols))))
        {
            // First get the size needed
            //
            ulRes = pfnWSCEnumProtocols(NULL, NULL, &cbInfo, &nErr);
            if ((SOCKET_ERROR == ulRes) && (WSAENOBUFS == nErr))
            {
                pwpi = reinterpret_cast<WSAPROTOCOL_INFO*>(new BYTE[cbInfo]);
                if (pwpi)
                {
                    // Find out all the protocols on the system
                    //
                    ulRes = pfnWSCEnumProtocols(NULL, pwpi, &cbInfo, &nErr);

                    if (SOCKET_ERROR != ulRes)
                    {
                        ULONG   cProt;
                        WCHAR   szCatId[64];

                        for (pwpiInfo = pwpi, cProt = ulRes;
                             cProt;
                             cProt--, pwpiInfo++)
                        {
                            wsprintfW(szCatId, L"%lu", pwpiInfo->dwCatalogEntryId);
                            if (cProt < ulRes)
                            {
                                // prepend a semicolon if not first time through
                                // we can't use a comma because setup will munge
                                // this string into separate strings and we don't
                                // want that
                                //
                                strWinsockOrder.append(L".");
                            }
                            strWinsockOrder.append(szCatId);
                        }
                    }

                    delete pwpi;
                }
            }

            pwisWinsock->AddKey(c_szAfKeyWinsockOrder, strWinsockOrder.c_str());

            FreeLibrary(hmod);
        }
    }
}

//+---------------------------------------------------------------------------
//
// Function:  HrHandleMiscSpecialCases
//
// Purpose:   Handle misc. special cases for upgrade
//
// Arguments:
//    pwifAnswerFile [in]  pointer to CWInfFile object
//
// Returns:   S_OK on success, otherwise an error code
//
// Author:    kumarp 28-January-99
//
HRESULT
HrHandleMiscSpecialCases (
    IN CWInfFile* pwifAnswerFile)
{
    AssertValidReadPtr(pwifAnswerFile);
    DefineFunctionName("HrHandleMiscSpecialCases");

    HRESULT hr=S_OK;

    CWInfSection* pwisMiscUpgradeData;
    pwisMiscUpgradeData = pwifAnswerFile->AddSection(c_szAfMiscUpgradeData);

    // -------------------------------------------------------
    // Tapi server upgrade
    //
    static const WCHAR c_szRegKeyTapiServer[] =
        L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Telephony\\Server";
    static const WCHAR c_szDisableSharing[] = L"DisableSharing";
    HKEY hkeyTapiServer;
    DWORD dwDisableSharing;

    hr = HrRegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szRegKeyTapiServer,
                        KEY_READ, &hkeyTapiServer);
    if (S_OK == hr)
    {
        hr = HrRegQueryDword(hkeyTapiServer, c_szDisableSharing,
                             &dwDisableSharing);
        if ((S_OK == hr) && !dwDisableSharing)
        {
            pwisMiscUpgradeData->AddBoolKey(c_szAfTapiSrvRunInSeparateInstance,
                                            TRUE);
        }

        RegCloseKey(hkeyTapiServer);
    }
    // -------------------------------------------------------

    TraceErrorOptional(__FUNCNAME__, hr,
                       (hr == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND)));

    return hr;
}

// ----------------------------------------------------------------------
// Computer Identification Page
// ----------------------------------------------------------------------


// ----------------------------------------------------------------------
//
// Function:  GetDomainMembershipInfo
//
// Purpose:   Determine domain membership status
//
// Arguments:
//    fDomainMember [out]  pointer to
//    strName       [out]  name of name of
//
// Returns:   TRUE on success, FALSE otherwise
//
// Author:    kumarp 03-December-97
//
// Notes:     Information on the APIs used in this function is in the file:
//            public\spec\se\lsa\lsaapi.doc
//
BOOL
GetDomainMembershipInfo (
    OUT BOOL* fDomainMember,
    OUT tstring& strName)
{
    BOOL status=FALSE;
    LSA_HANDLE h=0;
    POLICY_PRIMARY_DOMAIN_INFO* ppdi;

    LSA_OBJECT_ATTRIBUTES loa;
    ZeroMemory (&loa, sizeof(loa));
    loa.Length = sizeof(LSA_OBJECT_ATTRIBUTES);

    NTSTATUS ntstatus;
    ntstatus = LsaOpenPolicy(NULL, &loa, POLICY_VIEW_LOCAL_INFORMATION, &h);
    if (FALSE == LSA_SUCCESS(ntstatus))
        return FALSE;

    ntstatus = LsaQueryInformationPolicy(h, PolicyPrimaryDomainInformation,
                                         (VOID **) &ppdi);
    if (LSA_SUCCESS(ntstatus))
    {
        *fDomainMember = ppdi->Sid > 0;
        strName = ppdi->Name.Buffer;
        status = TRUE;
    }

    LsaClose(h);

    return status;
}


// ----------------------------------------------------------------------
//
// Function:  WriteIdentificationInfo
//
// Purpose:   Write computer identification info to the answerfile
//
// Arguments:
//    pwifAnswerFile [in]  pointer to CWInfFile object
//
// Returns:   TRUE on success, FALSE otherwise
//
// Author:    kumarp 03-December-97
//
BOOL
WriteIdentificationInfo (
    IN CWInfFile *pwifAnswerFile)
{
    DefineFunctionName("WriteIdentificationInfo");

    TraceFunctionEntry(ttidNetUpgrade);

    BOOL fStatus=FALSE;

    PCWInfSection pwisIdentification =
    pwifAnswerFile->AddSectionIfNotPresent(c_szAfSectionIdentification);
    CORegKey *prkComputerName =
        new CORegKey(HKEY_LOCAL_MACHINE, c_szRegValComputerName);

    tstring strValue, strComment;

    if(!prkComputerName) 
    {
        goto error_cleanup;
    }

    //ComputerName
    prkComputerName->QueryValue(c_szComputerName, strValue);
    strComment = L"Computer '" + strValue + L"' is a member of the ";

    BOOL fDomainMember;
    fStatus = GetDomainMembershipInfo(&fDomainMember, strValue);
    if (!fStatus)
        goto error_cleanup;

    strComment = strComment + L"'" + strValue + L"' ";

    if (fDomainMember)
    {
        strComment = strComment + L"domain ";
    }
    else
    {
        strComment = strComment + L"workgroup ";
    }

    pwisIdentification->AddComment(strComment.c_str());

    fStatus=TRUE;
    goto cleanup;

  error_cleanup:
    fStatus = FALSE;

  cleanup:
    DeleteIfNotNull(prkComputerName);

    return fStatus;
}


// ----------------------------------------------------------------------
// Net Cards Page
// ----------------------------------------------------------------------

//$ REVIEW  kumarp 10-September-97
//  this is a temporary fix only
//
//  we want to avoid queryin the mac addr for these drivers because
//  the drivers are faulty. the query never returns and it hangs netupgrd.dll
//
static const PCWSTR c_aszDriversToIgnoreWhenGettingMacAddr[] =
{
    L"Diehl_ISDNSDI",
};

static const PCWSTR c_aszIrq[] =
{
    L"IRQ",
    L"INTERRUPT",
    L"InterruptNumber",
    L"IRQLevel"
};

static const PCWSTR c_aszIoAddr[] =
{
    L"IOADDRESS",
    L"IoBaseAddress",
    L"BaseAddr"
};

static const PCWSTR c_aszMem[] =
{
    L"Mem",
    L"MemoryMappedBaseAddress"
};

static const PCWSTR c_aszDma[] =
{
    L"DMA",
    L"DMALevel"
};

static const PCWSTR c_aszAdapterParamsToIgnore[] =
{
    L"BusType"
};


// ----------------------------------------------------------------------
//
// Function:  WriteNetAdaptersInfo
//
// Purpose:   Write information about installed net-adapters to the answerfile
//
// Arguments:
//    pwifAnswerFile [in]  pointer to CWInfFile object
//
// Returns:   TRUE on success, FALSE otherwise
//
// Author:    kumarp 03-December-97
//
BOOL
WriteNetAdaptersInfo (
    IN CWInfFile *pwifAnswerFile)
{
    DefineFunctionName("WriteNetAdaptersInfo");

    TraceFunctionEntry(ttidNetUpgrade);

    HRESULT hr=E_FAIL;
    BOOL fStatus=FALSE;
    UINT cNumPhysicalAdapters=0;

    // ignore the errror, it is a non-error if we cannot find
    // the cNumPhysicalAdapters
    (void) HrGetNumPhysicalNetAdapters(&cNumPhysicalAdapters);

    CORegKey *prkNetworkCards = NULL;
    tstring strNetAdapterInstance;
    tstring strUnsupportedMessage;
    CORegKeyIter *prkiNetAdapters = NULL;
    CORegKey *prkNetAdapterInstance=NULL, *prkNetRules=NULL;

    CWInfSection *pwisNetAdapters;
    CWInfSection *pwisNetAdapterParams=NULL;
    CWInfSection *pwisNetAdapterAdditionalParams=NULL;

    tstring strNT5InfId;
    tstring strAdapterType;

    // WLBS: find out which netcard WLBS is bound to

    pszWlbsClusterAdapterName[0] = pszWlbsVirtualAdapterName[0] = 0;

    tstring strWlbsClusterAdapterDriver, strWlbsVirtualAdapterDriver;

    TStringList slWlbsLinkage;

    CORegKey *prkWlbsLinkage =
        new CORegKey(HKEY_LOCAL_MACHINE, c_szRegWlbsLinkage, KEY_READ);

    if(!prkWlbsLinkage) {
        return false;
    }

    CORegKey *prkConvoyLinkage =
        new CORegKey(HKEY_LOCAL_MACHINE, c_szRegConvoyLinkage, KEY_READ);

    if(!prkConvoyLinkage) {
        delete prkWlbsLinkage;
        return false;
    }

    if ((prkWlbsLinkage->HKey() != NULL && prkWlbsLinkage->QueryValue(c_szRegValBind, slWlbsLinkage) == ERROR_SUCCESS) ||
        (prkConvoyLinkage->HKey() != NULL && prkConvoyLinkage->QueryValue(c_szRegValBind, slWlbsLinkage) == ERROR_SUCCESS))
    {
        TraceTag(ttidNetUpgrade, "%s: WLBS found - iterating", __FUNCNAME__);

        TStringListIter iter;
        tstring         strTmp;
        DWORD           i;

        // proper WLBS configuration will have only two bindings - one to the
        // wlbs virtual NIC, the other to the cluster NIC

        for (i = 0, iter = slWlbsLinkage.begin();
               i < 2 && iter != slWlbsLinkage.end(); i++, iter++)
        {
            strTmp = **iter;

            TraceTag(ttidNetUpgrade, "%s: WLBS bound to %S",
                     __FUNCNAME__, strTmp.c_str());

            strTmp.erase(0, 8);

            TraceTag(ttidNetUpgrade, "%s: WLBS now bound to %S",
                     __FUNCNAME__, strTmp.c_str());

            if (strTmp.find(c_szWLBS) != tstring::npos ||
                strTmp.find(c_szConvoy) != tstring::npos)
            {
                strWlbsVirtualAdapterDriver = strTmp;
            }
            else
            {
                strWlbsClusterAdapterDriver = strTmp;
            }
        }

        if (iter != slWlbsLinkage.end())
        {
            TraceTag(ttidNetUpgrade, "%s: WLBS bound to more than one NIC!",
                     __FUNCNAME__);
        }

        TraceTag(ttidNetUpgrade, "%s: WLBS is bound to %S and %S", __FUNCNAME__,
                 strWlbsVirtualAdapterDriver.c_str(),
                 strWlbsClusterAdapterDriver.c_str());
    }

    delete prkWlbsLinkage;
    delete prkConvoyLinkage;

    // end WLBS:

    pwisNetAdapters = pwifAnswerFile->AddSection(c_szAfSectionNetAdapters);

    prkNetworkCards =
        new CORegKey(HKEY_LOCAL_MACHINE, c_szRegKeyAdapterHome, KEY_READ);

    if(prkNetworkCards)
    {
        prkiNetAdapters = new CORegKeyIter(*prkNetworkCards);
        prkiNetAdapters->Reset();
    }
    WORD wNumAdapters = 0;
    CORegKey *prkAdapterDriverParams=NULL;
    BOOL fAbortFunction=FALSE;

    // This determines if we will write the line under NetAdapters to
    // reference the params section for this adapter.
    //
    BOOL fWriteNetAdaptersReference;

    while (!fAbortFunction && prkiNetAdapters && !prkiNetAdapters->Next(&strNetAdapterInstance))
    {
        DWORD dwHidden=0, err=0;
        WCHAR pszAdapterName[16], pszAdapterSectionName[256];
        WCHAR pszAdapterAdditionalParamsSectionName[256];

        tstring strPreNT5InfId, strAdapterDescription, strAdapterDescComment;

        fWriteNetAdaptersReference = FALSE;

        prkNetAdapterInstance =
            new CORegKey(*prkNetworkCards, strNetAdapterInstance.c_str());

        // for REAL netcards, "Hidden" is absent or if present the value is 0
        BOOL fRealNetCard;
        err = prkNetAdapterInstance->QueryValue(L"Hidden", dwHidden);
        fRealNetCard = (err != ERROR_SUCCESS) || (dwHidden == 0);

        prkNetAdapterInstance->QueryValue(c_szRegValDescription,
                                          strAdapterDescription);
        swprintf(pszAdapterName, L"Adapter%02d", ++wNumAdapters);

        TraceTag(ttidNetUpgrade, "%s: writing info for adapter %S (%S)",
                 __FUNCNAME__, pszAdapterName, strNetAdapterInstance.c_str());

        // Now, create adapter parameters sections
        swprintf(pszAdapterSectionName, L"%s%s", c_szAfParams, pszAdapterName);
        //pwisNetAdapters->AddKey(pszAdapterName, pszAdapterSectionName);
        swprintf(pszAdapterAdditionalParamsSectionName, L"%s%s.Additional",
                  c_szAfParams, pszAdapterName);

        if (NULL != pwisNetAdapterParams)
            pwifAnswerFile->GotoEndOfSection(pwisNetAdapterParams);

        pwisNetAdapterParams = pwifAnswerFile->AddSection(pszAdapterSectionName);
        pwisNetAdapterAdditionalParams =
            pwifAnswerFile->AddSection(pszAdapterAdditionalParamsSectionName);

        // moved up here from below so that for WLBS adapter we can set
        // fRealNetCard to FALSE

        tstring strAdapterDriver;

        prkNetAdapterInstance->QueryValue(c_szRegValServiceName,
                                          strAdapterDriver);

        // WLBS: based on pre-upgrade instance, find out virtual and cluster
        // NIC adapter instances

        if (_wcsicmp (strAdapterDriver.c_str(),
                      strWlbsVirtualAdapterDriver.c_str()) == 0)
        {
            TraceTag(ttidNetUpgrade, "%s: WLBS virtual adapter is %S",
                     __FUNCNAME__, pszAdapterName);

            wcscpy(pszWlbsVirtualAdapterName, pszAdapterName);
            fRealNetCard = FALSE;
        }
        else if (_wcsicmp (strAdapterDriver.c_str(),
                           strWlbsClusterAdapterDriver.c_str()) == 0)
        {
            TraceTag(ttidNetUpgrade, "%s: WLBS cluster adapter is %S",
                     __FUNCNAME__, pszAdapterName);

            wcscpy(pszWlbsClusterAdapterName, pszAdapterName);
        }

        // end WLBS:

        prkNetRules = new CORegKey(*prkNetAdapterInstance, c_szRegKeyNetRules);
        prkNetRules->QueryValue(c_szRegValInfOption, strPreNT5InfId);

        if (fRealNetCard)
        {
            strAdapterDescComment =
                tstring(L"Net Card: ") + strPreNT5InfId +
                tstring(L"  (") + strAdapterDescription + tstring(L")");
        }
        else
        {
            strAdapterDescComment =
                tstring(L"Pseudo Adapter: ") + strAdapterDescription;
        }
        ReplaceCharsInString((PWSTR) strAdapterDescComment.c_str(),
                             L"\n\r", L' ');

        pwisNetAdapterParams->AddComment(strAdapterDescComment.c_str());
        pwisNetAdapterParams->AddKey(c_szAfAdditionalParams,
                                     pszAdapterAdditionalParamsSectionName);
        pwisNetAdapterParams->AddBoolKey(c_szAfPseudoAdapter, !fRealNetCard);

        pwisNetAdapterParams->AddKey(c_szAfPreUpgradeInstance,
                                     strAdapterDriver.c_str());

        tstring strProductName;
        prkNetAdapterInstance->QueryValue(L"ProductName", strProductName);
        AddToNetCardDB(pszAdapterName, strProductName.c_str(),
                       strAdapterDriver.c_str());

        // We need to look at the ndiswan instances (if any) to decide
        // which RAS components we need to install.
        // the algorithm is like this
        //
        // - for each <instance> in
        //   software\microsoft\windows nt\currentversion\networkcards\<instance>
        // - if atleast one <intance>\ProductName
        //   - begins with "ndiswan" AND
        //   - has string "in" in it --> install ms_rassrv
        //   - has string "out" in it --> install ms_rascli
        //
        PCWSTR pszProductName;
        pszProductName = strProductName.c_str();
        if (FIsPrefix(c_szNdisWan, pszProductName))
        {
            static const WCHAR c_szIn[] = L"in";
            static const WCHAR c_szOut[] = L"out";

            if (wcsstr(pszProductName, c_szIn))
            {
                TraceTag(ttidNetUpgrade,
                         "%s: g_fAtLeastOneDialInUsingNdisWan set to TRUE because of %S",
                         __FUNCNAME__, pszProductName);
                g_fAtLeastOneDialInUsingNdisWan = TRUE;
            }
            if (wcsstr(pszProductName, c_szOut))
            {
                TraceTag(ttidNetUpgrade,
                         "%s: g_fAtLeastOneDialOutUsingNdisWan set to TRUE because of %S",
                         __FUNCNAME__, pszProductName);
                g_fAtLeastOneDialOutUsingNdisWan = TRUE;
            }
        }

        if (!fRealNetCard)
        {
            pwisNetAdapterParams->AddKey(c_szAfInfid, strPreNT5InfId.c_str());

            //The rest of the keys are for real net cards only
            goto cleanup_for_this_iteration;
        }

        //EthernetAddress
        if (!FIsInStringArray(c_aszDriversToIgnoreWhenGettingMacAddr,
                              celems(c_aszDriversToIgnoreWhenGettingMacAddr),
                              strProductName.c_str()))
        {
            QWORD qwEthernetAddress;

            // ignore the error if we cannot get the netcard address
            // this error is non-fatal

            // Based on what build we are on, we call a different API to
            // get netcard address.  Currently, this code path isn't executed
            // on any NT5 to NT5 upgrade, but if it changes, we want to use
            // the newer api.
            //
            if (g_NetUpgradeInfo.From.dwBuildNumber < 2031) // Pre-Beta3
            {
                (VOID) HrGetNetCardAddrOld(strAdapterDriver.c_str(), &qwEthernetAddress);
            }
            else
            {
                (VOID) HrGetNetCardAddr(strAdapterDriver.c_str(), &qwEthernetAddress);
            }
            pwisNetAdapterParams->AddQwordKey(c_szAfNetCardAddr, qwEthernetAddress);

            fWriteNetAdaptersReference = (0 != qwEthernetAddress);
        }
        else
        {
            TraceTag(ttidNetUpgrade, "%s: did not query %S for mac address",
                     __FUNCNAME__, strProductName.c_str());
        }

        GetServiceParamsKey(strAdapterDriver.c_str(), prkAdapterDriverParams);

        //write INFID key
        HKEY hkeyAdapterDriverParams;
        if (prkAdapterDriverParams)
        {
            hkeyAdapterDriverParams = prkAdapterDriverParams->HKey();
        }
        else
        {
            hkeyAdapterDriverParams = NULL;
        }

        BOOL fIsOemAdapter;
        CNetMapInfo* pnmi;

        fIsOemAdapter = FALSE;
        pnmi = NULL;

        hr = HrMapPreNT5NetCardInfIdToNT5InfId(hkeyAdapterDriverParams,
                                               strPreNT5InfId.c_str(),
                                               &strNT5InfId,
                                               &strAdapterType,
                                               &fIsOemAdapter, &pnmi);

        if (S_OK == hr)
        {
            if (!lstrcmpiW(strAdapterType.c_str(), c_szAsyncAdapters) ||
                !lstrcmpiW(strAdapterType.c_str(), c_szOemAsyncAdapters))
            {
                CWInfSection* pwisAsyncCards;
                pwisAsyncCards =
                    pwifAnswerFile->AddSectionIfNotPresent(c_szAsyncAdapters);
                if (pwisAsyncCards)
                {
                    pwisAsyncCards->AddKey(pszAdapterName,
                                           pszAdapterSectionName);
                }
            }
            else
            {
                fWriteNetAdaptersReference = TRUE;
            }
        }
        else
        {
            GetUnsupportedMessage(c_szNetCard, strAdapterDescription.c_str(),
                                  strPreNT5InfId.c_str(), &strUnsupportedMessage);
            pwisNetAdapterParams->AddComment(strUnsupportedMessage.c_str());
            strNT5InfId = c_szAfUnknown;
            TraceTag(ttidNetUpgrade, "WriteNetAdaptersInfo: %S",
                     strUnsupportedMessage.c_str());
        }

        if (fWriteNetAdaptersReference)
        {
            // We have enough information to determine which adapter goes
            // with this section so write out the reference.
            //
            pwisNetAdapters->AddKey(pszAdapterName, pszAdapterSectionName);
        }


        if (1 == cNumPhysicalAdapters)
        {
            TraceTag(ttidNetUpgrade, "%s: dumped '*' as InfID for %S",
                     __FUNCNAME__, strNT5InfId.c_str());
            pwisNetAdapterParams->AddKey(c_szAfInfid, L"*");
            pwisNetAdapterParams->AddKey(c_szAfInfidReal, strNT5InfId.c_str());
        }
        else
        {
            pwisNetAdapterParams->AddKey(c_szAfInfid, strNT5InfId.c_str());
        }

        if (!prkAdapterDriverParams)
        {
            // since we could not open the driver params key
            // we cant dump parameters. just skip this card and continue
            goto cleanup_for_this_iteration;
        }

        // -----------------------------------------------------------------
        // OEM upgrade code
        //

        if (fIsOemAdapter)
        {
            hr = HrProcessOemComponentAndUpdateAfSection(
                    pnmi, NULL,
                    prkAdapterDriverParams->HKey(),
                    strPreNT5InfId.c_str(),
                    strAdapterDriver.c_str(),
                    strNT5InfId.c_str(),
                    strAdapterDescription.c_str(),
                    pwisNetAdapterParams);

            // OEM upgrade may be aborted because of a fatal error or
            // if an OEM DLL requests it. in both cases we need to stop
            // our current answerfile generation
            //
            if (FIsUpgradeAborted())
            {
                fAbortFunction = TRUE;
                goto cleanup_for_this_iteration;
            }
        }
        // -----------------------------------------------------------------

        //BusType
        DWORD dwBusType;
        INTERFACE_TYPE eBusType;
        prkAdapterDriverParams->QueryValue(L"BusType", dwBusType);
        eBusType = (INTERFACE_TYPE) dwBusType;
        pwisNetAdapterParams->AddKey(c_szAfBusType,
                                     GetBusTypeName(eBusType));

        // for certain ISA cards the driver parameters store EISA as the bus type
        // when these cards are installed in EISA slots. Thus we have to dump parameters
        // when BusType is Eisa.
        //
        BOOL fDumpResources;
        fDumpResources = ((eBusType == Isa) || (eBusType == Eisa));

        // kumarp    14-July-97
        // this fix has been requested by billbe.
        // we do not dump hardware resources for the ISAPNP cards
        //
        if (!lstrcmpiW(strPreNT5InfId.c_str(), L"IEEPRO") ||
            !lstrcmpiW(strPreNT5InfId.c_str(), L"ELNK3ISA509"))
        {
            fDumpResources = FALSE;
        }

        DWORD dwIndex;
        dwIndex = 0;
        DWORD dwValueNameLen, dwValueType;

        WCHAR szValueName[REGSTR_MAX_VALUE_LENGTH+1];
        PCWSTR pszResourceName;
        DWORD dwValueDumpFormat;
        do
        {
            dwValueNameLen = REGSTR_MAX_VALUE_LENGTH;
            hr = HrRegEnumValue(prkAdapterDriverParams->HKey(),
                                dwIndex, szValueName, &dwValueNameLen,
                                &dwValueType, NULL, NULL);

            if (hr == S_OK)
            {
                pszResourceName = NULL;
                dwValueDumpFormat = REG_HEX;

                dwIndex++;
                if (FIsInStringArray(c_aszIrq,
                                     celems(c_aszIrq), szValueName))
                {
                    pszResourceName = c_szAfIrq;
                    dwValueDumpFormat = REG_DWORD;
                }
                else if (FIsInStringArray(c_aszIoAddr,
                                          celems(c_aszIoAddr), szValueName))
                {
                    pszResourceName = c_szAfIoAddr;
                }
                else if (FIsInStringArray(c_aszMem,
                                          celems(c_aszMem), szValueName))
                {
                    pszResourceName = c_szAfMem;
                }
                else if (FIsInStringArray(c_aszDma,
                                          celems(c_aszDma), szValueName))
                {
                    pszResourceName = c_szAfDma;
                }

                if (pszResourceName)
                {
                    if (fDumpResources)
                    {
                        WriteRegValueToAFile(pwisNetAdapterParams,
                                             *prkAdapterDriverParams,
                                             szValueName, dwValueDumpFormat,
                                             pszResourceName);
                    }
                }
                else if (!FIsInStringArray(c_aszAdapterParamsToIgnore,
                                           celems(c_aszAdapterParamsToIgnore),
                                           szValueName))
                {
                    WriteRegValueToAFile(pwisNetAdapterAdditionalParams,
                                         *prkAdapterDriverParams,
                                         szValueName, dwValueType);
                }
            }
        }
        while (hr == S_OK);

      cleanup_for_this_iteration:
        DeleteIfNotNull(prkNetAdapterInstance);
        DeleteIfNotNull(prkNetRules);
        DeleteIfNotNull(prkAdapterDriverParams);
    }

    // WLBS: if either cluster or virtual adapter were not matched - blow off
    // WLBS-specific upgrade code

    if (pszWlbsClusterAdapterName[0] == 0 || pszWlbsVirtualAdapterName[0] ==0)
    {
        pszWlbsClusterAdapterName[0] = pszWlbsVirtualAdapterName[0] = 0;
    }

    // end WLBS:

    fStatus=TRUE;
    goto cleanup;

    fStatus=FALSE;

  cleanup:
    DeleteIfNotNull(prkNetworkCards);
    DeleteIfNotNull(prkiNetAdapters);

    return fStatus;
}

// ----------------------------------------------------------------------
//
// Function:  HrGetNumPhysicalNetAdapters
//
// Purpose:   Count and return number of physical adapters installed
//
// Arguments:
//    puNumAdapters [out] pointer to num adapters
//
// Returns:   S_OK on success, otherwise an error code
//
// Author:    kumarp 29-May-98
//
HRESULT
HrGetNumPhysicalNetAdapters (
    OUT UINT* puNumAdapters)
{
    AssertValidWritePtr(puNumAdapters);
    DefineFunctionName("HrGetNumPhysicalNetAdapters");

    HRESULT hr;
    HKEY hkeyAdapters;
    HKEY hkeyAdapter;
    DWORD dwHidden;
    BOOL  fRealNetCard = FALSE;

    *puNumAdapters = 0;

    hr = HrRegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szRegKeyAdapterHome,
                        KEY_READ, &hkeyAdapters);
    if (S_OK == hr)
    {
        WCHAR szBuf[MAX_PATH];
        FILETIME time;
        DWORD dwSize;
        DWORD dwRegIndex;

        for (dwRegIndex = 0, dwSize = celems(szBuf);
             S_OK == HrRegEnumKeyEx(hkeyAdapters, dwRegIndex, szBuf,
                        &dwSize, NULL, NULL, &time);
             dwRegIndex++, dwSize = celems(szBuf))
        {
            Assert(*szBuf);

            hr = HrRegOpenKeyEx(hkeyAdapters, szBuf, KEY_READ, &hkeyAdapter);
            if (hr == S_OK)
            {
                hr = HrRegQueryDword(hkeyAdapter, c_szHidden, &dwHidden);

                // for REAL netcards, "Hidden" is absent or if present the value is 0
                if (S_OK == hr)
                {
                    fRealNetCard = (0 == dwHidden);
                }
                else if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr)
                {
                    fRealNetCard = TRUE;
                    hr = S_OK;
                }

                if ((S_OK == hr) && fRealNetCard)
                {
                    (*puNumAdapters)++;
                }
                RegCloseKey(hkeyAdapter);
            }
        }

        RegCloseKey(hkeyAdapters);
    }

    TraceTag(ttidNetUpgrade, "%s: Found %d physical net adapters",
             __FUNCNAME__, *puNumAdapters);

    TraceError(__FUNCNAME__, hr);
    return hr;
}

// ----------------------------------------------------------------------
//
// Function:  IsNetworkComponent
//
// Purpose:   Determine if a component is a net-component
//
// Arguments:
//    prkSoftwareMicrosoft [in]  pointer to CORegKey object
//    strComponentName     [in]  constTString object name of
//
// Returns:
//
// Author:    kumarp 03-December-97
//
// Notes:     any software that has a NetRules key under the CurrentVersion
//            key is considered a network component
//
BOOL
IsNetworkComponent (
    IN CORegKey *prkSoftwareMicrosoft,
    IN const tstring strComponentName)
{
    tstring strNetRules = strComponentName + L"\\CurrentVersion\\NetRules";
    CORegKey rkNetRules((HKEY) *prkSoftwareMicrosoft, strNetRules.c_str());
    return (((HKEY) rkNetRules) != NULL);
}

// ----------------------------------------------------------------------
// Network components (protocols, services)
// ----------------------------------------------------------------------

typedef BOOL (*WriteNetComponentParamsFn)(
        IN CWInfFile*    pwifAnswerFile,
        IN CWInfSection* pwisGlobalParams);

static PCWSTR c_aszNetComponents[] =
{
    L"RASPPTP",
    L"Browser",
    c_szSvcWorkstation,
    L"RpcLocator",
    L"LanmanServer",
    c_szSvcNetBIOS,
    c_szSvcNWCWorkstation,
    c_szSvcDhcpServer,
    L"ISOTP",
    c_szWLBS,
    c_szConvoy
};

static WriteNetComponentParamsFn c_afpWriteParamsFns[] =
{
    WritePPTPParams,
    WriteBrowserParams,
    WriteLanmanWorkstationParams,
    WriteRPCLocatorParams,
    WriteLanmanServerParams,
    WriteNetBIOSParams,
    WriteNWCWorkstationParams,
    WriteDhcpServerParams,
    WriteTp4Params,
    WriteWLBSParams,
    WriteConvoyParams
};

typedef BOOL (*WriteNetComponentParamsAndAdapterSectionsFn)(
        IN CWInfFile*    pwifAnswerFile,
        IN CWInfSection* pwisGlobalParams,
        OUT TStringList& slAdditionalParamsSections);

static const PCWSTR c_aszNetComponentsWithAdapterSpecificParams[] =
{
    L"Tcpip",
    L"NwlnkIpx",
    L"AppleTalk"
};

static WriteNetComponentParamsAndAdapterSectionsFn
c_afpWriteParamsAndAdapterSectionsFns[] =
{
    WriteTCPIPParams,
    WriteIPXParams,
    WriteAppleTalkParams
};

// ----------------------------------------------------------------------
//
// Function:  HrWriteNetComponentInfo
//
// Purpose:   Write info of the specified component to the answerfile
//
// Arguments:
//    szNetComponent     [in]  net component
//    pwifAnswerFile     [in]  pointer to CWInfFile object (answerfile)
//    hkeyCurrentVersion [in]  handle of CurrentVersion regkey
//
// Returns:   S_OK on success, otherwise an error code
//
// Author:    kumarp 13-May-98
//
HRESULT
HrWriteNetComponentInfo (
    IN PCWSTR szNetComponent,
    IN CWInfFile* pwifAnswerFile,
    IN HKEY hkeyCurrentVersion)
{
    DefineFunctionName("HrWriteNetComponentInfo");

    HRESULT hr=S_OK;

    tstring strPreNT5InfId;
    tstring strNT5InfId;
    tstring strProductCurrentVersion;
    tstring strDescription;
    tstring strSoftwareType;
    tstring strParamsSectionName;

    TStringList slAdditionalParamsSections;
    BOOL  fIsOemComponent;
    UINT  uIndex;

    CWInfSection* pwisNetComponents;
    CWInfSection* pwisNetComponentParams;
    ENetComponentType nct=NCT_Unknown;
    PCWSTR szNetComponentsSection;
    CNetMapInfo* pnmi;
    static BOOL fRasParamsDumped=FALSE;

    hr = HrGetPreNT5InfIdAndDesc(hkeyCurrentVersion,
                                 &strPreNT5InfId, &strDescription,
                                 NULL);

    if (S_OK == hr)
    {
        TraceTag(ttidNetUpgrade, "%s: processing '[%S] %S'",
                 __FUNCNAME__, strPreNT5InfId.c_str(), strDescription.c_str());

        hr = HrMapPreNT5NetComponentInfIDToNT5InfID(
                strPreNT5InfId.c_str(), &strNT5InfId,
                &fIsOemComponent, &nct, &pnmi);

        if (S_OK == hr)
        {
            Assert((nct >= NCT_Adapter) &&
                   (nct <= NCT_Client));

            // add the top level section [Net*] if not present

            szNetComponentsSection =
                g_szNetComponentSectionName[nct];
            pwisNetComponents =
                pwifAnswerFile->AddSectionIfNotPresent(
                        szNetComponentsSection);

            strParamsSectionName = c_szAfParams + strNT5InfId;

            if (!pwisNetComponents->FindKey(strNT5InfId.c_str(),
                                            ISM_FromBeginning))
            {
                pwisNetComponentParams =
                    pwifAnswerFile->AddSection(strParamsSectionName.c_str());

                // RAS is a special case.
                if (0 != _wcsicmp(strNT5InfId.c_str(), c_szRAS))
                {
                    pwisNetComponents->AddKey(strNT5InfId.c_str(),
                                              strParamsSectionName.c_str());
                }

            }
            else
            {
                pwisNetComponentParams =
                    pwifAnswerFile->FindSection(strParamsSectionName.c_str());
            }

            AssertSz(pwisNetComponentParams,
                     "HrWriteNetComponentInfo: Need a section to add key to!");

            if (FIsInStringArray(c_aszNetComponents,
                                 celems(c_aszNetComponents),
                                 szNetComponent, &uIndex))
            {
                c_afpWriteParamsFns[uIndex](pwifAnswerFile,
                                            pwisNetComponentParams);
            }
            else if (FIsInStringArray(
                    c_aszNetComponentsWithAdapterSpecificParams,
                    celems(c_aszNetComponentsWithAdapterSpecificParams),
                    szNetComponent, &uIndex))
            {
                EraseAndDeleteAll(slAdditionalParamsSections);
                c_afpWriteParamsAndAdapterSectionsFns[uIndex]
                    (pwifAnswerFile,
                     pwisNetComponentParams,
                     slAdditionalParamsSections);
                if (!slAdditionalParamsSections.empty())
                {
                    pwisNetComponentParams->AddKey(c_szAfAdapterSections,
                                                   slAdditionalParamsSections);
                }
            }
            else if (!lstrcmpiW(strNT5InfId.c_str(), c_szRAS) &&
                     !fRasParamsDumped)
            {
                fRasParamsDumped = TRUE;
                WriteRASParams(pwifAnswerFile,
                               pwisNetComponents,
                               pwisNetComponentParams);
            }
            else if (fIsOemComponent)
            {
                HKEY hkeyServiceParams=NULL;
                tstring strServiceName;
                hr = HrRegQueryString(hkeyCurrentVersion,
                                      c_szRegValServiceName,
                                      &strServiceName);
                if (S_OK == hr)
                {
                    AssertSz(!strServiceName.empty(),
                             "Service name is empty for OEM component!!");
                    hr = HrRegOpenServiceSubKey(strServiceName.c_str(),
                                                c_szParameters,
                                                KEY_READ,
                                                &hkeyServiceParams);
                    if (S_OK == hr)
                    {
                        hr = HrProcessOemComponentAndUpdateAfSection(
                                pnmi, NULL,
                                hkeyServiceParams,       // Parameters reg key
                                strPreNT5InfId.c_str(),
                                strServiceName.c_str(),
                                strNT5InfId.c_str(),
                                strDescription.c_str(),
                                pwisNetComponentParams);

                        // OEM upgrade may be aborted because of a fatal error or
                        // if an OEM DLL requests it. in both cases we need to
                        // stop our current answerfile generation
                        if (FIsUpgradeAborted())
                        {
                            TraceTag(ttidNetUpgrade,
                                     "%s: upgrade aborted by %S",
                                     __FUNCNAME__, strNT5InfId.c_str());
                        }
                    }
                    else
                    {
                        TraceTag(ttidNetUpgrade,
                                 "%s: could not open Parameters key for '%S'",
                                 __FUNCNAME__, strServiceName.c_str());
                    }
                }
            }
            else
            {
                TraceTag(ttidNetUpgrade, "%s: '%S' Unknown component!!",
                         __FUNCNAME__, strPreNT5InfId.c_str());
            }
        }
        else if (S_FALSE == hr)
        {
            CWInfSection* pwisNetworking;
            pwisNetworking = pwifAnswerFile->FindSection(c_szAfSectionNetworking);
            if (pwisNetworking)
            {
                tstring strUnsupportedMessage;

                GetUnsupportedMessage(NULL,
                                      strDescription.c_str(),
                                      strPreNT5InfId.c_str(),
                                      &strUnsupportedMessage);
                pwisNetworking->AddComment(strUnsupportedMessage.c_str());
            }
        }
        else if (FAILED(hr))
        {
            TraceTag(ttidNetUpgrade,
                     "%s: mapping failed, skipped '%S'",
                     __FUNCNAME__, szNetComponent);
            hr = S_OK;
        }
    }
    else
    {
        TraceTag(ttidNetUpgrade,
                 "%s: HrGetPreNT5InfIdAndDesc failed, "
                 "skipped '%S'", __FUNCNAME__, szNetComponent);
        hr = S_OK;
    }

    TraceError(__FUNCNAME__, hr);

    return hr;
}


// ----------------------------------------------------------------------
//
// Function:  WriteNetComponentInfoForProvider
//
// Purpose:   Write info on installed net components (except net cards)
//            of the specified provider to the answerfile
//
// Arguments:
//    pszSoftwareProvider [in]  name of provider
//    pwifAnswerFile    [in]  pointer to CWInfFile object (answerfile)
//
// Returns:   S_OK on success, otherwise an error code
//
// Author:    kumarp 13-May-98
//
VOID
WriteNetComponentInfoForProvider(
    IN HKEY hkeyProvider,
    IN PCWSTR pszSoftwareProvider,
    IN CWInfFile* pwifAnswerFile)
{
    AssertValidReadPtr(pszSoftwareProvider);
    AssertValidReadPtr(pwifAnswerFile);

    HRESULT hr;
    HKEY hkeyProductCurrentVersion;

    tstring strProductCurrentVersion;
    tstring strSoftwareType;

    WCHAR szNetComponent[MAX_PATH];
    FILETIME time;
    DWORD dwSize;
    DWORD dwRegIndex;

    for (dwRegIndex = 0, dwSize = celems(szNetComponent);
         !FIsUpgradeAborted() &&
         (S_OK == HrRegEnumKeyEx(hkeyProvider, dwRegIndex, szNetComponent,
                    &dwSize, NULL, NULL, &time));
         dwRegIndex++, dwSize = celems(szNetComponent))
    {
        Assert(*szNetComponent);

        strProductCurrentVersion = szNetComponent;
        AppendToPath(&strProductCurrentVersion, c_szRegKeyCurrentVersion);

        hr = HrRegOpenKeyEx(hkeyProvider, strProductCurrentVersion.c_str(),
                            KEY_READ, &hkeyProductCurrentVersion);
        if (S_OK == hr)
        {
            hr = HrRegQueryString(hkeyProductCurrentVersion,
                                  c_szRegValSoftwareType,
                                  &strSoftwareType);

            // ignore components of type "driver"

            if ((S_OK == hr) &&
                (0 != lstrcmpiW(strSoftwareType.c_str(), c_szSoftwareTypeDriver)))
            {
                // Don't write disabled bindings of NdisWan and NetBT.
                // They should always be enabled on upgrade.
                //
                if ((0 != lstrcmpiW(szNetComponent, L"NdisWan")) &&
                    (0 != lstrcmpiW(szNetComponent, L"NetBT")))
                {
                    WriteBindings(szNetComponent);
                }

                if (!ShouldIgnoreComponent(szNetComponent))
                {
                    (VOID) HrWriteNetComponentInfo(
                                szNetComponent, pwifAnswerFile,
                                hkeyProductCurrentVersion);
                }
            }

            RegCloseKey(hkeyProductCurrentVersion);
        }
    }
}

// ----------------------------------------------------------------------
//
// Function:  HrWriteNetComponentsInfo
//
// Purpose:   Write info on installed net components (except net cards)
//            of all providers to the answerfile
//
// Arguments:
//    pwifAnswerFile [in]  pointer to CWInfFile object (answerfile)
//
// Returns:   S_OK on success, otherwise an error code
//
// Author:    kumarp 13-May-98
//
HRESULT
HrWriteNetComponentsInfo(
    IN CWInfFile* pwifAnswerFile)
{
    AssertValidReadPtr(pwifAnswerFile);

    HRESULT hr;
    HKEY hkeySoftware;

    hr = HrRegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szRegKeySoftware,
                        KEY_READ, &hkeySoftware);
    if (S_OK == hr)
    {
        WCHAR szBuf[MAX_PATH];
        FILETIME time;
        DWORD dwSize;
        DWORD dwRegIndex;

        for (dwRegIndex = 0, dwSize = celems(szBuf);
             S_OK == HrRegEnumKeyEx(hkeySoftware, dwRegIndex, szBuf,
                        &dwSize, NULL, NULL, &time);
             dwRegIndex++, dwSize = celems(szBuf))
        {
            Assert(*szBuf);

            HKEY hkeyProvider;

            hr = HrRegOpenKeyEx(hkeySoftware, szBuf, KEY_READ, &hkeyProvider);

            if (S_OK == hr)
            {
                // We want to continue even if there is any error dumping info
                // of one provider
                //
                WriteNetComponentInfoForProvider(
                        hkeyProvider,
                        szBuf,
                        pwifAnswerFile);

                if (0 == _wcsicmp(szBuf, L"Microsoft"))
                {
                    (VOID) HrWritePreSP3ComponentsToSteelHeadUpgradeParams(
                            pwifAnswerFile);
                }

                RegCloseKey(hkeyProvider);
            }

        }

        RegCloseKey(hkeySoftware);
    }

    return hr;
}


// ----------------------------------------------------------------------
// TCPIP related
// ----------------------------------------------------------------------

static const WCHAR c_szTcpipParams[] = L"Tcpip\\Parameters";

VOID
WriteRegValueToAFile(
    IN PCWInfSection pwisSection,
    IN CORegKey& rk,
    IN const ValueTypePair* prgVtp,
    IN ULONG crg)
{
    for (ULONG idx = 0; idx < crg; idx++)
    {
        if (REG_FILE == prgVtp[idx].dwType)
        {
            //This is just for "PersistentRoute" which we handle specifically
            continue;
        }

        WriteRegValueToAFile(pwisSection, rk, prgVtp[idx].pszValueName,
                             prgVtp[idx].dwType);
    }
}

// ----------------------------------------------------------------------
//
// Function:  WriteTCPIPParams
//
// Purpose:   Write parameters of TCPIP to the answerfile
//
// Arguments:
//    pwifAnswerFile             [in]  pointer to CWInfFile object
//    pwisTCPIPGlobalParams      [in]  pointer to TCPIP global params section
//    slAdditionalParamsSections [out] list of adapter sections
//
// Returns:   TRUE on success, FALSE otherwise
//
// Author:    kumarp 03-December-97
//
BOOL
WriteTCPIPParams (
    IN PCWInfFile pwifAnswerFile,
    IN PCWInfSection pwisTCPIPGlobalParams,
    OUT TStringList& slAdditionalParamsSections)
{
    DefineFunctionName("WriteTCPIPParams");

    TraceFunctionEntry(ttidNetUpgrade);

    HRESULT hr;
    TStringList slList;
    PCORegKey prkRouter=NULL;
    PCORegKey prkTCPIP=NULL;
    PCORegKey prkTcpipParams=NULL;
    PCORegKey prkTCPIPLinkage=NULL;
    PCORegKey prkNetBT=NULL;
    DWORD dwEnableDNS=0;
    BOOL fEnableDNS=FALSE;

    GetServiceKey(c_szSvcTcpip, prkTCPIP);
    prkTcpipParams = new CORegKey(*prkTCPIP, c_szParameters);

    tstring strValue;
    DWORD dwValue;

    //first write the global parameters

    // UseDomainNameDevolution
    WriteServiceRegValueToAFile(pwisTCPIPGlobalParams,
                                L"DnsCache\\Parameters",
                                L"UseDomainNameDevolution",
                                REG_BOOL,
                                NULL,       // dont change value name
                                TRUE,       // use default
                                (BOOL) TRUE); // default value

    // EnableSecurity
    dwValue = 0;
    if (0 == prkTcpipParams->QueryValue(L"EnableSecurityFilters", dwValue))
    pwisTCPIPGlobalParams->AddBoolKey(c_szAfEnableSecurity, dwValue);

    // DNS
    GetServiceParamsKey(c_szSvcNetBT, prkNetBT);
    if (prkNetBT)
    {
        if (0 == prkNetBT->QueryValue(L"EnableDNS", dwEnableDNS))
        {
            fEnableDNS = dwEnableDNS;
        }

        // EnableLMHosts
        WriteRegValueToAFile(pwisTCPIPGlobalParams, *prkNetBT, NULL,
                             c_szAfEnableLmhosts, REG_BOOL,
                             NULL, TRUE, (BOOL)FALSE);

        // Write any present optional parameters to the answerfile
        //
        WriteRegValueToAFile(pwisTCPIPGlobalParams, *prkNetBT,
                             rgVtpNetBt, celems(rgVtpNetBt));
    }

    pwisTCPIPGlobalParams->AddBoolKey(c_szAfDns, fEnableDNS);

    // DNSDomain
    // Fix bug 349343, if the Domain value is empty, don't upgrade it
    strValue.erase();
    prkTcpipParams->QueryValue(c_szDomain, strValue);
    if (!strValue.empty())
    {
        pwisTCPIPGlobalParams->AddKey(c_szAfDnsDomain, strValue.c_str());
    }

    // HostName
    // 391590: save the hostname so we can maintain the capitalization
    strValue.erase();
    prkTcpipParams->QueryValue(c_szHostname, strValue);
    if (!strValue.empty())
    {
        pwisTCPIPGlobalParams->AddKey(c_szAfDnsHostname, strValue.c_str());
    }

    // --------------------------------------------------
    //$ ISSUE:  kumarp 12-December-97
    //
    // this should be removed for Connections
    // (they have been moved to adapter specific sections
    //
    //DNSServerSearchOrder
    strValue.erase();
    prkTcpipParams->QueryValue(c_szNameServer, strValue);
    ConvertDelimitedListToStringList(strValue, ' ', slList);
    pwisTCPIPGlobalParams->AddKey(c_szAfDnsServerSearchOrder, slList);
    // --------------------------------------------------

    // DNSSuffixSearchOrder
    strValue.erase();
    prkTcpipParams->QueryValue(L"SearchList", strValue);
    ConvertDelimitedListToStringList(strValue, ' ', slList);
    pwisTCPIPGlobalParams->AddKey(c_szAfDnsSuffixSearchOrder, slList);

    // ImportLMHostsFile
    // REVIEW: how to migrate the user-modified-lmhosts file ?

    // Per AmritanR, drop the upgrade support of IpEnableRouter (EnableIPForwarding in the answer file) to fix bug 345700
    // EnableIPForwarding (i.e. IpEnableRouter)
    

    // If Steelhead is installed then write the following otherwise do nothing
    //
    if (TRUE == GetServiceKey(c_szRouter, prkRouter))
    {
        pwisTCPIPGlobalParams->AddBoolKey(c_szAfEnableICMPRedirect, FALSE);
        pwisTCPIPGlobalParams->AddBoolKey(c_szAfDeadGWDetectDefault, FALSE);
        pwisTCPIPGlobalParams->AddBoolKey(c_szAfDontAddDefaultGatewayDefault, TRUE);
    }

    // DatabasePath  (REG_EXPAND_SZ)
    strValue.erase();
    prkTcpipParams->QueryValue(c_szDatabasePath, strValue);
    if (!strValue.empty())
    {
        pwisTCPIPGlobalParams->AddKey(c_szDatabasePath, strValue.c_str());
    }

    // Write any present optional parameters to the answerfile
    //
    WriteRegValueToAFile(pwisTCPIPGlobalParams, *prkTcpipParams,
                         rgVtpIp, celems(rgVtpIp));

    //PersistentRoutes
    (void) HrNetRegSaveKeyAndAddToSection(prkTcpipParams->HKey(),
                                          c_szPersistentRoutes,
                                          c_szAfTcpip,
                                          c_szPersistentRoutes,
                                          pwisTCPIPGlobalParams);

    //Write Adapter specific parameters
    prkTCPIPLinkage = new CORegKey(*prkTCPIP, c_szLinkage);
    prkTCPIPLinkage->QueryValue(L"Bind", slList);

    TraceStringList(ttidNetUpgrade, L"TCPIP: enabled adapters", slList);
    CORegKey* prkTCPIPLinkageDisabled;
    TStringList slDisabled;

    prkTCPIPLinkageDisabled = new CORegKey(*prkTCPIP, c_szLinkageDisabled);
    prkTCPIPLinkageDisabled->QueryValue(L"Bind", slDisabled);
    TraceStringList(ttidNetUpgrade, L"TCPIP: disabled adapters", slDisabled);
    slList.splice(slList.end(), slDisabled);
    delete prkTCPIPLinkageDisabled;

    // $REVIEW(tongl 2/18/99): Added for bug #192576
    // Get the list of disabled adapters to DHCP server, if it is installed
    HKEY hkey;
    ListStrings lstDisabledToDhcp;
    ListStrings lstDisabledNetbt;

    hr = HrRegOpenKeyEx(HKEY_LOCAL_MACHINE,
            c_szDhcpServerLinkageDisabled, KEY_READ, &hkey);

    if (S_OK == hr)
    {
        hr = HrRegQueryColString(hkey, L"Bind", &lstDisabledToDhcp);

        RegCloseKey (hkey);
    }

    hr = HrRegOpenKeyEx(HKEY_LOCAL_MACHINE,
            L"SYSTEM\\CurrentControlSet\\Services\\Netbt\\Linkage\\Disabled",
            KEY_READ,
            &hkey);

    if (S_OK == hr)
    {
        hr = HrRegQueryColString(hkey, L"Bind", &lstDisabledNetbt);

        RegCloseKey (hkey);
    }

    TStringListIter iter;

    for (iter  = slList.begin();
         iter != slList.end();
         iter++)
    {
        static WCHAR szAdapterDriver[256];

        if (swscanf((*iter)->c_str(), L"\\Device\\%s", szAdapterDriver) == 1)
        {
            // $REVIEW(tongl 2/18/99): Added for bug #192576
            // If this adapter was on the disabled list to DHCP server,
            // set this to FALSE, otherwise, don't do anything
            BOOL fDisabledToDhcpServer = FALSE;
            BOOL fDisableNetbios = FALSE;

            if (lstDisabledToDhcp.size())
            {
                TraceTag(ttidNetUpgrade, "szAdapterDriver: %S", szAdapterDriver);

                TStringListIter iterD;
                for (iterD  = lstDisabledToDhcp.begin();
                     iterD != lstDisabledToDhcp.end();
                     iterD++)
                {
                    TraceTag(ttidNetUpgrade, "binding string: %S",
                        (*iterD)->c_str());

                    if (FIsSubstr(szAdapterDriver, (*iterD)->c_str()))
                    {
                        TraceTag(ttidNetUpgrade,
                            "Adapter %S is disabled to Dhcp Server",
                            szAdapterDriver);
                        fDisabledToDhcpServer = TRUE;
                        break;
                    }
                }
            }

            if (lstDisabledNetbt.size())
            {
                TraceTag(ttidNetUpgrade, "szAdapterDriver: %S", szAdapterDriver);

                TStringListIter iterD;
                for (iterD  = lstDisabledNetbt.begin();
                     iterD != lstDisabledNetbt.end();
                     iterD++)
                {
                    TraceTag(ttidNetUpgrade, "binding string: %S",
                        (*iterD)->c_str());

                    if (FIsSubstr(szAdapterDriver, (*iterD)->c_str()))
                    {
                        TraceTag(ttidNetUpgrade,
                            "Adapter %S is disabled for NetBIOS over TCP/IP",
                            szAdapterDriver);
                        fDisableNetbios = TRUE;
                        break;
                    }
                }
            }

            WriteTCPIPAdapterParams(
                pwifAnswerFile,
                szAdapterDriver,
                slAdditionalParamsSections,
                fDisabledToDhcpServer,
                fDisableNetbios);
        }
    }

    DeleteIfNotNull(prkTCPIP);
    DeleteIfNotNull(prkTcpipParams);
    DeleteIfNotNull(prkNetBT);
    DeleteIfNotNull(prkTCPIPLinkage);
    DeleteIfNotNull(prkRouter);

    EraseAndDeleteAll(slList);

    return TRUE;
}

// ----------------------------------------------------------------------
//
// Function:  WriteTCPIPAdapterParams
//
// Purpose:   Write adapter-specific parameters of TCPIP to the answerfile
//
// Arguments:
//    pwifAnswerFile             [in]  pointer to answerfile
//    pszAdapterDriver           [in]  instance name of the adapter driver
//                                     (e.g. ieepro2)
//    slAdditionalParamsSections [out] list of adapter sections
//
// Returns:   TRUE on success, FALSE otherwise
//
// Author:    kumarp 03-December-97
//
BOOL
WriteTCPIPAdapterParams (
    IN PCWInfFile pwifAnswerFile,
    IN PCWSTR pszAdapterDriver,
    OUT TStringList& slAdditionalParamsSections,
    BOOL fDisabledToDhcpServer,
    BOOL fDisableNetbios)
{
    DefineFunctionName("WriteTCPIPAdapterParams");

    TraceFunctionEntry(ttidNetUpgrade);

    BOOL fStatus=FALSE;
    PCORegKey prkNetBTParams=NULL;
    tstring strValue;
    TStringList slList;
    tstring strAdapterParamsSectionName;
    PCWInfSection pwisParams;
    tstring strParamsKeyName;
    PCORegKey prkParams = NULL;

    PCWSTR pszAdapter = MapNetCardInstanceToAFileName(pszAdapterDriver);

    if (!pszAdapter)
    {
        // this is most likely due to corrupt or inconsistent registry
        //
        TraceTag(ttidNetUpgrade, "%s: skipped writing adapter specific ",
                 "parameters for %S", __FUNCNAME__, pszAdapterDriver);
        goto error_cleanup;
    }

    // WLBS: write WLBS TCP/IP parameters under the name of the cluster adapter,
    // and skip cluster adapter TCP/IP parameters alltogether.

    if (pszWlbsClusterAdapterName[0] != 0)
    {
        if (_wcsicmp(pszAdapter, pszWlbsClusterAdapterName) == 0)
        {
            TraceTag(ttidNetUpgrade, "%s: skipping %S section",
                     __FUNCNAME__, pszAdapter);

            goto error_cleanup;
        }
        else if (_wcsicmp(pszAdapter, pszWlbsVirtualAdapterName) == 0)
        {
            TraceTag(ttidNetUpgrade, "%s: replacing %S section with %S",
                     __FUNCNAME__, pszAdapter, pszWlbsClusterAdapterName);

            pszAdapter = pszWlbsClusterAdapterName;
        }
    }

    // end WLBS:

    strAdapterParamsSectionName = tstring(c_szAfParams) +
                                  c_szInfId_MS_TCPIP + L"." + pszAdapter;
    AddAtEndOfStringList(slAdditionalParamsSections, strAdapterParamsSectionName);

    pwisParams = pwifAnswerFile->AddSection(strAdapterParamsSectionName.c_str());
    pwisParams->AddKey(c_szAfSpecificTo, pszAdapter);

    //  TCPIP parameters for <adapter> are found at
    //  Services\<adapter-driver>\Parameters\Tcpip
    strParamsKeyName = tstring(c_szRegKeyServices) + L"\\" +
                       pszAdapterDriver + L"\\Parameters\\Tcpip";

    prkParams = new CORegKey(HKEY_LOCAL_MACHINE, strParamsKeyName.c_str());
    if (!prkParams)
        goto error_cleanup;

    //DNSServerSearchOrder
    //
    HRESULT hr;
    HKEY hkeyTcpipParams;

    hr = HrRegOpenServiceKey(c_szTcpipParams, KEY_READ, &hkeyTcpipParams);
    if (S_OK == hr)
    {
        tstring strDnsServerSearchOrder;

        hr = HrRegQueryString(hkeyTcpipParams, c_szNameServer,
                              &strDnsServerSearchOrder);
        if (S_OK == hr)
        {
            TStringList slDnsServerSearchOrder;

            ConvertDelimitedListToStringList(strDnsServerSearchOrder,
                                             ' ', slDnsServerSearchOrder);
            pwisParams->AddKey(c_szAfDnsServerSearchOrder,
                               slDnsServerSearchOrder);
        }
    }

    //DNSDomain
    WriteServiceRegValueToAFile(pwisParams,
                                c_szTcpipParams,
                                c_szDomain,
                                REG_SZ,
                                c_szAfDnsDomain);


    DWORD dwValue;
    prkParams->QueryValue(L"EnableDHCP", dwValue);
    pwisParams->AddBoolKey(c_szAfDhcp, dwValue);
    if (!dwValue)
    {
        //IPAddress
        WriteRegValueToAFile(pwisParams, *prkParams,
                             c_szAfIpaddress, REG_MULTI_SZ);

        //SubnetMask
        WriteRegValueToAFile(pwisParams, *prkParams,
                             c_szAfSubnetmask, REG_MULTI_SZ);
    }

    //Gateway
    WriteRegValueToAFile(pwisParams, *prkParams,
                         c_szAfDefaultGateway, REG_MULTI_SZ);

    // TcpAllowedPorts
    WriteRegValueToAFile(pwisParams, *prkParams,
                         L"TcpAllowedPorts",
                         REG_MULTI_SZ,
                         c_szAfTcpAllowedPorts);

    // UdpAllowedPorts
    WriteRegValueToAFile(pwisParams, *prkParams,
                         L"UdpAllowedPorts",
                         REG_MULTI_SZ,
                         c_szAfUdpAllowedPorts);

    // IpAllowedProtocols
    WriteRegValueToAFile(pwisParams, *prkParams,
                         L"RawIPAllowedProtocols",
                         REG_MULTI_SZ,
                         c_szAfIpAllowedProtocols);

    // Write any present optional parameters to the answerfile
    //
    WriteRegValueToAFile(pwisParams, *prkParams,
                         rgVtpIpAdapter, celems(rgVtpIpAdapter));


    strValue = L"Adapters\\";
    strValue += pszAdapterDriver;

    GetServiceSubkey(c_szSvcNetBT, strValue.c_str(), prkNetBTParams);
    if (!prkNetBTParams)
        goto error_cleanup;

    strValue.erase();
    prkNetBTParams->QueryValue(c_szNameServer, strValue);
    if (strValue.empty())
    {
        //WINS=No
        pwisParams->AddKey(c_szAfWins, c_szNo);
    }
    else
    {
        //WINS=Yes
        pwisParams->AddKey(c_szAfWins, c_szYes);

        tstring strWinsServerList;
        strWinsServerList = strValue;

        prkNetBTParams->QueryValue(L"NameServerBackup", strValue);
        if (!strValue.empty())
        {
            strWinsServerList += L",";
            strWinsServerList += strValue;
        }
        pwisParams->AddKey(c_szAfWinsServerList, strWinsServerList.c_str());
    }

    // BindToDhcpServer
    // $REVIEW(tongl 2/18/99): Added for bug #192576
    // If this adapter was on the disabled list to DHCP server, set this to FALSE
    // otherwise, don't do anything
    if (fDisabledToDhcpServer)
    {
        pwisParams->AddBoolKey(c_szAfBindToDhcpServer, !fDisabledToDhcpServer);
    }

    if (fDisableNetbios)
    {
        // Value of 2 means disable netbios over tcpip for this interface.
        pwisParams->AddKey(c_szAfNetBIOSOptions, 2);
    }

    fStatus=TRUE;
    goto cleanup;

error_cleanup:
    fStatus = FALSE;

cleanup:
    DeleteIfNotNull(prkParams);
    DeleteIfNotNull(prkNetBTParams);

    return fStatus;
}

// ----------------------------------------------------------------------
//
// Function:  WriteAppleTalkParams
//
// Purpose:   Write parameters of AppleTalk protocol
//
// Arguments:
//    pwifAnswerFile             [in]  pointer to answerfile
//    pwisGlobalParams           [in]  pointer to global params section
//    slAdditionalParamsSections [out] list of adapter params sections
//
// Returns:   TRUE on success, FALSE otherwise
//
// Author:    kumarp 11-December-97
//
BOOL
WriteAppleTalkParams (
    IN PCWInfFile pwifAnswerFile,
    IN PCWInfSection pwisGlobalParams,
    OUT TStringList& slAdditionalParamsSections)
{
    DefineFunctionName("WriteAppleTalkParams");

    TraceFunctionEntry(ttidNetUpgrade);

    BOOL fStatus=FALSE;

    tstring strTemp;
    CORegKeyIter *prkiAdapters=NULL;
    tstring strAdapterInstance;
    PCORegKey prkAdapters=NULL;
    tstring strDefaultPort;

    PCORegKey prkParams=NULL;
    GetServiceSubkey(L"AppleTalk", L"Parameters", prkParams);
    if (!prkParams)
        goto error_cleanup;

    //Write Global Parameters

    // DefaultPort
    prkParams->QueryValue(L"DefaultPort", strDefaultPort);
    WCHAR szTemp[256];
    PCWSTR pszNetCardAFileName;
    if ((swscanf(strDefaultPort.c_str(), L"\\Device\\%s", szTemp) == 1) &&
        ((pszNetCardAFileName = MapNetCardInstanceToAFileName(szTemp)) != NULL))
    {
        pwisGlobalParams->AddKey(L"DefaultPort", pszNetCardAFileName);
    }

    // DesiredZone
    WriteRegValueToAFile(pwisGlobalParams,
                         *prkParams,
                         L"DesiredZone");

    // EnableRouter
    WriteRegValueToAFile(pwisGlobalParams,
                         *prkParams,
                         L"EnableRouter",
                         REG_BOOL,
                         NULL,       // dont change value name
                         TRUE,       // use default
                         (BOOL) FALSE); // default value


    //Write Adapter specific parameters
    GetServiceSubkey(L"AppleTalk", L"Adapters", prkAdapters);
    DoErrorCleanupIf(!prkAdapters);

    prkiAdapters = new CORegKeyIter(*prkAdapters);
    prkiAdapters->Reset();

    strTemp = tstring(c_szAfParams) + c_szInfId_MS_AppleTalk + L".";
    while (!prkiAdapters->Next(&strAdapterInstance))
    {
        ContinueIf(strAdapterInstance.empty());

        CORegKey rkAdapterInstance(*prkAdapters, strAdapterInstance.c_str());

        PCWSTR pszNetCardAFileName =
            MapNetCardInstanceToAFileName(strAdapterInstance.c_str());
        ContinueIf(!pszNetCardAFileName);

        tstring strAdapterParamsSection = strTemp + pszNetCardAFileName;
        AddAtEndOfStringList(slAdditionalParamsSections, strAdapterParamsSection);

        PCWInfSection pwisAdapterParams;
        pwisAdapterParams =
            pwifAnswerFile->AddSection(strAdapterParamsSection.c_str());

        //SpecificTo
        pwisAdapterParams->AddKey(c_szAfSpecificTo, pszNetCardAFileName);

        // DefaultZone
        WriteRegValueToAFile(pwisAdapterParams,
                             rkAdapterInstance,
                             L"DefaultZone");

        // NetworkRangeLowerEnd
        WriteRegValueToAFile(pwisAdapterParams,
                             rkAdapterInstance,
                             L"NetworkRangeLowerEnd",
                             REG_DWORD);

        // NetworkRangeUpperEnd
        WriteRegValueToAFile(pwisAdapterParams,
                             rkAdapterInstance,
                             L"NetworkRangeUpperEnd",
                             REG_DWORD);

        // PortName
        //
        //$ REVIEW  kumarp 24-May-97
        //  the value is of the form ieepro2@kumarp1
        //  this may need to be changed to Adapter03@kumarp1
        //
        WriteRegValueToAFile(pwisAdapterParams,
                             rkAdapterInstance,
                             L"PortName");

        // SeedingNetwork
        WriteRegValueToAFile(pwisAdapterParams,
                             rkAdapterInstance,
                             L"SeedingNetwork",
                             REG_DWORD,
                             NULL,       // dont change value name
                             TRUE,       // use default
                             (DWORD) 0); // default value

        // ZoneList
        WriteRegValueToAFile(pwisAdapterParams,
                             rkAdapterInstance,
                             L"ZoneList",
                             REG_MULTI_SZ);

    }

    fStatus = TRUE;
    goto cleanup;

error_cleanup:
    fStatus = FALSE;

cleanup:
    DeleteIfNotNull(prkParams);
    DeleteIfNotNull(prkAdapters);
    DeleteIfNotNull(prkiAdapters);

    return fStatus;
}

// ----------------------------------------------------------------------
//
// Function:  WritePPTPParams
//
// Purpose:   Write parameters of PPTP protocol
//
// Arguments:
//    pwifAnswerFile             [in]  pointer to answerfile
//    pwisParams                 [in]  pointer to global params section
//
// Returns:   TRUE on success, FALSE otherwise
//
// Author:    kumarp 11-December-97
//
BOOL
WritePPTPParams (
    PCWInfFile pwifAnswerFile,
    PCWInfSection pwisParams)
{
    DefineFunctionName("WritePPTPParams");

    TraceFunctionEntry(ttidNetUpgrade);

    //NumberLineDevices
    WriteServiceRegValueToAFile(pwisParams,
                                L"RASPPTPE\\Parameters\\Configuration",
                                L"NumberLineDevices",
                                REG_DWORD);

    return TRUE;
}

// ----------------------------------------------------------------------
//
// Function:  WriteIPXParams
//
// Purpose:   Write parameters of IPX protocol
//
// Arguments:
//    pwifAnswerFile             [in]  pointer to answerfile
//    pwisIPXGlobalParams        [in]  pointer to global params section
//    slAdditionalParamsSections [out] list of adapter params sections
//
// Returns:   TRUE on success, FALSE otherwise
//
// Author:    kumarp 11-December-97
//
BOOL
WriteIPXParams (
    IN PCWInfFile pwifAnswerFile,
    IN PCWInfSection pwisIPXGlobalParams,
    OUT TStringList& slAdditionalParamsSections)
{
    DefineFunctionName("WriteIPXParams");

    TraceFunctionEntry(ttidNetUpgrade);

    BOOL fStatus=FALSE;

    tstring strTemp;
    CORegKeyIter *prkiNetConfig=NULL;

    //InternalNetworkNumber
    WriteServiceRegValueToAFile(pwisIPXGlobalParams,
                                L"NwlnkIpx\\Parameters",
                                L"VirtualNetworkNumber",
                                REG_HEX,
                                c_szAfInternalNetworkNumber);

    // DedicatedRouter
    WriteServiceRegValueToAFile(pwisIPXGlobalParams,
                                L"NwlnkIpx\\Parameters",
                                L"DedicatedRouter",
                                REG_BOOL,
                                NULL,     // dont change value name
                                TRUE,     // use default
                                (BOOL) FALSE);   // default value

    // EnableWANRouter
    WriteServiceRegValueToAFile(pwisIPXGlobalParams,
                                L"NwlnkIpx\\Parameters",
                                L"EnableWANRouter",
                                REG_BOOL,
                                NULL,     // dont change value name
                                TRUE,     // use default
                                TRUE);    // default value

    // RipRoute
    WriteServiceRegValueToAFile(pwisIPXGlobalParams,
                                L"NwlnkIpx\\Parameters",
                                L"RipRoute",
                                REG_DWORD);

    // ------------------------------------------------------------------------------



    //Write Adapter specific parameters
    tstring strAdapterInstance;
    PCORegKey prkNetConfig=NULL;
    GetServiceSubkey(L"NwlnkIpx", L"NetConfig", prkNetConfig);
    if (!prkNetConfig)
        goto error_cleanup;

    prkiNetConfig = new CORegKeyIter(*prkNetConfig);
    prkiNetConfig->Reset();

    strTemp = tstring(c_szAfParams) + c_szInfId_MS_NWIPX + L".";
    while (!prkiNetConfig->Next(&strAdapterInstance))
    {
        ContinueIf(strAdapterInstance.empty());

        CORegKey rkAdapterInstance(*prkNetConfig, strAdapterInstance.c_str());

        PCWSTR pszNetCardAFileName =
            MapNetCardInstanceToAFileName(strAdapterInstance.c_str());
        ContinueIf(!pszNetCardAFileName);

        tstring strAdapterParamsSection = strTemp + pszNetCardAFileName;
        AddAtEndOfStringList(slAdditionalParamsSections, strAdapterParamsSection);

        PCWInfSection pwisAdapterParams;
        pwisAdapterParams =
            pwifAnswerFile->AddSection(strAdapterParamsSection.c_str());

        //SpecificTo
        pwisAdapterParams->AddKey(c_szAfSpecificTo, pszNetCardAFileName);

        // PktType
        WriteRegValueToAFile(pwisAdapterParams,
                             rkAdapterInstance,
                             L"PktType",
                             REG_MULTI_SZ);

        // MaxPktSize
        WriteRegValueToAFile(pwisAdapterParams,
                             rkAdapterInstance,
                             L"MaxPktSize",
                             REG_DWORD,
                             NULL,       // dont change value name
                             TRUE,       // use default
                             (DWORD) 0); // default value

        // NetworkNumber
        WriteRegValueToAFile(pwisAdapterParams,
                             rkAdapterInstance,
                             L"NetworkNumber",
                             REG_MULTI_SZ);

        // BindSap
        WriteRegValueToAFile(pwisAdapterParams,
                             rkAdapterInstance,
                             L"BindSap",
                             REG_HEX,
                             NULL,       // dont change value name
                             TRUE,       // use default
                             (DWORD) 0x8137); // default value

        // EnableFuncAddr
        WriteRegValueToAFile(pwisAdapterParams,
                             rkAdapterInstance,
                             L"EnableFuncaddr",
                             REG_BOOL,
                             NULL,       // dont change value name
                             TRUE,       // use default
                             TRUE);      // default value

        // SourceRouteDef
        WriteRegValueToAFile(pwisAdapterParams,
                             rkAdapterInstance,
                             L"SourceRouteDef",
                             REG_DWORD,
                             NULL,       // dont change value name
                             TRUE,       // use default
                             (DWORD) 0); // default value

        // SourceRouteMcast
        WriteRegValueToAFile(pwisAdapterParams,
                             rkAdapterInstance,
                             L"SourceRouteMcast",
                             REG_BOOL,
                             NULL,       // dont change value name
                             TRUE,       // use default
                             (BOOL) FALSE);     // default value

        // SourceRouting
        WriteRegValueToAFile(pwisAdapterParams,
                             rkAdapterInstance,
                             L"SourceRouting",
                             REG_BOOL,
                             NULL,       // dont change value name
                             TRUE,       // use default
                             (BOOL) FALSE);     // default value



        strAdapterInstance.erase();
    }

    fStatus=TRUE;
    goto cleanup;

  error_cleanup:
    fStatus=FALSE;

  cleanup:
    //    DeleteIfNotNull(prkParams);
    DeleteIfNotNull(prkNetConfig);
    DeleteIfNotNull(prkiNetConfig);

    return fStatus;
}

static const WCHAR c_szRegKeyRas[]      = L"Software\\Microsoft\\RAS";
static const WCHAR c_szRegKeyRasMan[]   = L"System\\CurrentControlSet\\Services\\Rasman\\PPP";
static const WCHAR c_szRegKeyRasManSH[] = L"System\\CurrentControlSet\\Services\\Rasman\\PPP\\COMPCP";
static const WCHAR c_szRegKeyUnimodem[] = L"TAPI DEVICES\\Unimodem";
static const WCHAR c_szAddress[]        = L"Address";
static const WCHAR c_szUsage[]          = L"Usage";

// ----------------------------------------------------------------------
//
// Function:  HrGetRasPortsInfo
//
// Purpose:   Find out ports' usage info from registry.
//            If the registry does not have this info (in case of NT3.51)
//            then try to get it from serial.ini file
//
// Arguments:
//    pslPorts [out] list of ports
//    pslUsage [out] usage of ports in the above list
//
// Returns:   S_OK on success, otherwise an error code
//
// Author:    kumarp 17-December-97
//
HRESULT
HrGetRasPortsInfo (
    OUT TStringList* pslPorts,
    OUT TStringList* pslUsage)
{
    DefineFunctionName("HrGetRasPortsInfo");

    HRESULT hr=S_OK;

    HKEY hkeyUnimodem;
    tstring strUnimodem;
    strUnimodem = c_szRegKeyRas;
    strUnimodem += '\\';
    strUnimodem += c_szRegKeyUnimodem;

    hr = HrRegOpenKeyEx(HKEY_LOCAL_MACHINE, strUnimodem.c_str(),
                        KEY_READ, &hkeyUnimodem);
    if (S_OK == hr)
    {
        hr = HrRegQueryColString(hkeyUnimodem, c_szAddress, pslPorts);
        if (S_OK == hr)
        {
            hr = HrRegQueryColString(hkeyUnimodem, c_szUsage, pslUsage);
        }
    }

    if (pslPorts->empty())
    {
        TraceTag(ttidNetUpgrade, "%s: there are no entries found under %S",
                 __FUNCNAME__, strUnimodem.c_str());
        TraceTag(ttidNetUpgrade, "%s: trying to get port usage info from serial.ini file", __FUNCNAME__);

        HINF hinf;
        tstring strSerialIni;
        hr = HrGetWindowsDir(&strSerialIni);
        if (S_OK == hr)
        {
            static const WCHAR c_szSystem32SerialIni[] =
                L"\\system32\\ras\\serial.ini";
            strSerialIni += c_szSystem32SerialIni;

            hr = HrSetupOpenInfFile(strSerialIni.c_str(), NULL,
                                    INF_STYLE_OLDNT, NULL, &hinf);
            if (S_OK == hr)
            {
                tstring strUsage;
                WCHAR szPortName[16];
                INFCONTEXT ic;

                for (int i=1; i<=255; i++)
                {
                    swprintf(szPortName, L"COM%d", i);

                    hr = HrSetupFindFirstLine(hinf, szPortName, c_szUsage, &ic);
                    if (S_OK == hr)
                    {
                        hr = HrSetupGetStringField(ic, 1, &strUsage);
                        if (S_OK == hr)
                        {
                            TraceTag(ttidNetUpgrade,
                                     "%s: as per serial.ini file: %S --> %S",
                                     __FUNCNAME__, szPortName, strUsage.c_str());
                            pslPorts->push_back(new tstring(szPortName));
                            pslUsage->push_back(new tstring(strUsage.c_str()));
                        }
                    }
                }

                hr = S_OK;
                SetupCloseInfFile(hinf);
            }
        }
    }

    TraceError(__FUNCNAME__, hr);

    return hr;
}

// ----------------------------------------------------------------------
//
// Function:  ConvertIpAddrRangeToAddrAndMask
//
// Purpose:   Convert a range of IP addr specified using Start/End to
//            equivalent Start+Mask combination
//
// Arguments:
//    pszIpBegin  [in]  Start addr
//    pszIpEnd    [in]  End addr
//    pstrIpAddr [out] pointer to Start addr
//    pstrIpMask [out] pointer to Mask
//
// Returns:   None
//
// Author:    kumarp 27-April-98
//
void
ConvertIpAddrRangeToAddrAndMask(
    IN PCWSTR pszIpBegin,
    IN PCWSTR pszIpEnd,
    OUT tstring* pstrIpAddr,
    OUT tstring* pstrIpMask)
{
    WCHAR szBuf[16];

    DWORD dwIpBegin = IpPszToHostAddr(pszIpBegin);
    DWORD dwIpEnd   = IpPszToHostAddr(pszIpEnd);

    // dwTemp will have a bit set for each common bit between
    // dwIpBegin and dwIpEnd.
    //
    DWORD dwTemp = ~(dwIpBegin ^ dwIpEnd);

    // Compute the subnet mask as the longest run of 1s from
    // the highest order down.
    //
    DWORD dwIpMask = 0;
    while (dwTemp & 0x80000000)
    {
        dwTemp <<= 1;   // Eventually shifts a zero to the high bit
        // so the loop will stop.

        // Form the mask by shifting 1 right from the high bit.
        dwIpMask = 0x80000000 | (dwIpMask >> 1);
    }

    // Reset the begin address (if needed) to the base of the subnet mask.
    //
    dwIpBegin &= dwIpMask;

    IpHostAddrToPsz(dwIpBegin, szBuf);
    *pstrIpAddr = szBuf;

    IpHostAddrToPsz(dwIpMask, szBuf);
    *pstrIpMask = szBuf;
}


// ----------------------------------------------------------------------
//
// Function:  ConvertAddrAndMaskToIpAddrRange
//
// Purpose:   Convert a IP address Start + Mask combination into the
//            equivalent IP address range
//
// Arguments:
//    pszIpAddr   [in]  Start
//    pszIpMask   [in]  Mask
//    pstrIpBegin [out] pointer to Start addr
//    pstrIpEnd   [out] pointer to End addr
//
// Returns:   None
//
// Author:    SumitC    28-Jul-99
//
void
ConvertAddrAndMaskToIpAddrRange(
    IN PCWSTR pszIpAddr,
    IN PCWSTR pszIpMask,
    OUT tstring* pstrIpBegin,
    OUT tstring* pstrIpEnd)
{
    WCHAR szBuf[16];

    DWORD dwIpBegin = IpPszToHostAddr(pszIpAddr);

    // dwEnd is generated by inverting the mask and adding to IpBegin
    //
    DWORD dwIpEnd = dwIpBegin + (~ IpPszToHostAddr(pszIpMask));

    *pstrIpBegin = pszIpAddr;

    IpHostAddrToPsz(dwIpEnd, szBuf);
    *pstrIpEnd = szBuf;
}


//+---------------------------------------------------------------------------
//
// Function:  RasGetDialInUsage
//
// Purpose:   Find out if at least one RAS port is configured for dialin.
//
// Returns:   TRUE if at least one port configured for dial in.
//
// Author:    kumarp 28-January-99
//
BOOL
RasGetDialInUsage (VOID)
{
    static const WCHAR c_szTapiDevices[] =
        L"Software\\Microsoft\\RAS\\TAPI DEVICES";
    HRESULT hr=S_OK;
    HKEY hkeyTapiDevices;
    HKEY hkeyTapiDevice;

    BOOL fAtLeastOneDialin = FALSE;

    hr = HrRegOpenKeyEx(HKEY_LOCAL_MACHINE,
                        c_szTapiDevices, KEY_READ,
                        &hkeyTapiDevices);
    if (S_OK == hr)
    {
        WCHAR szBuf[MAX_PATH];
        FILETIME time;
        DWORD dwSize;
        DWORD dwRegIndex;

        for (dwRegIndex = 0, dwSize = celems(szBuf);
             !fAtLeastOneDialin &&
             (S_OK == HrRegEnumKeyEx(hkeyTapiDevices, dwRegIndex, szBuf,
                        &dwSize, NULL, NULL, &time));
             dwRegIndex++, dwSize = celems(szBuf))
        {
            Assert(*szBuf);

            hr = HrRegOpenKeyEx(hkeyTapiDevices,
                                szBuf, KEY_READ,
                                &hkeyTapiDevice);
            if (S_OK == hr)
            {
                PWSTR pmszUsage;

                hr = HrRegQueryMultiSzWithAlloc(hkeyTapiDevice, c_szUsage,
                                                &pmszUsage);
                if ((S_OK == hr) && pmszUsage)
                {
                    PCWSTR pszScan;

                    for (pszScan = pmszUsage;
                         *pszScan;
                         pszScan += wcslen(pszScan) + 1)
                    {
                        if (FIsSubstr(c_szServer, pszScan) ||
                            FIsSubstr(c_szRouter, pszScan))
                        {
                            fAtLeastOneDialin = TRUE;
                            break;
                        }
                    }

                    MemFree(pmszUsage);
                }

                RegCloseKey(hkeyTapiDevice);
            }
        }

        RegCloseKey(hkeyTapiDevices);
    }

    return fAtLeastOneDialin;
}

//+---------------------------------------------------------------------------
//
// Function:  WriteRouterUpgradeInfo
//
// Purpose:   Write info required for upgrading Router to answerfile.
//
// Arguments:
//    pwifAnswerFile [in]  pointer to CWInfFile object
//
// Returns:   None
//
// Author:    kumarp 16-June-98
//
void
WriteRouterUpgradeInfo (
    IN CWInfFile* pwifAnswerFile)
{
    DefineFunctionName("HrWriteRouterUpgradeInfo");

    TraceTag(ttidNetUpgrade, "-----> entering %s", __FUNCNAME__);

    tstring strParamsSectionName;
    CWInfSection* pwisNetServices;
    CWInfSection* pwisRouter;

    strParamsSectionName = c_szAfParams;
    strParamsSectionName = strParamsSectionName + L"ms_rasrtr";

    pwisNetServices = pwifAnswerFile->FindSection(c_szAfSectionNetServices);

    AssertSz(pwisNetServices, "No [NetServices] section ??");

    pwisNetServices->AddKey(L"ms_rasrtr", strParamsSectionName.c_str());
    pwisRouter = pwifAnswerFile->AddSection(strParamsSectionName.c_str());
    pwisRouter->AddKey(c_szAfInfid, L"ms_rasrtr");
    pwisRouter->AddKey(c_szAfParamsSection, strParamsSectionName.c_str());

    (void) HrNetRegSaveServiceSubKeyAndAddToSection(c_szSvcRouter, NULL,
                                                    c_szAfPreUpgradeRouter,
                                                    pwisRouter);

    (void) HrNetRegSaveServiceSubKeyAndAddToSection(c_szSvcSapAgent,
                                                    c_szParameters,
                                                    c_szAfNwSapAgentParams,
                                                    pwisRouter);

    (void) HrNetRegSaveServiceSubKeyAndAddToSection(c_szSvcRipForIp,
                                                    c_szParameters,
                                                    c_szAfIpRipParameters,
                                                    pwisRouter);

    (void) HrNetRegSaveServiceSubKeyAndAddToSection(c_szSvcDhcpRelayAgent,
                                                    c_szParameters,
                                                    c_szAfDhcpRelayAgentParameters,
                                                    pwisRouter);

    (void) HrNetRegSaveKeyAndAddToSection(HKEY_LOCAL_MACHINE,
                                          L"Software\\Microsoft\\Ras\\Radius",
                                          L"Radius",
                                          c_szAfRadiusParameters,
                                          pwisRouter);
}

// ----------------------------------------------------------------------
//
// Function:  WriteRASParams
//
// Purpose:   Write RAS parameters to the answerfile
//
// Arguments:
//    pwifAnswerFile  [in]  pointer to answerfile
//    pwisNetServices [in]  pointer to NetServices section
//    pwisParams      [in]  pointer to global params section
//
// Returns:   TRUE on success, FALSE otherwise
//
// Author:    kumarp 11-December-97
//
BOOL
WriteRASParams (
    IN PCWInfFile pwifAnswerFile,
    IN PCWInfSection pwisNetServices,
    IN PCWInfSection pwisParams)
{
    DefineFunctionName("WriteRASParams");

    TraceFunctionEntry(ttidNetUpgrade);

    PCORegKey prkRAS = new CORegKey(HKEY_LOCAL_MACHINE, c_szRegKeyRas);
    PCORegKey prkProtocols = new CORegKey(*prkRAS, L"Protocols");

    if(!prkRAS || !prkProtocols) 
    {
        return false;
    }

    WriteRegValueToAFile(pwisParams, *prkProtocols, c_szAfRouterType, REG_DWORD);

    TStringList slPorts, slUsage, slTemp;
    tstring strPorts, strValue, strTemp, strPortSections;
    tstring strIpAddrStart;
    tstring strIpAddrEnd;
    DWORD dwValue=0;
    BOOL  fSteelHeadInstalled=FALSE;
    HRESULT hr=S_OK;
    LONG err;

    // find out if SteelHead is installed.
    // if the service "Router" is found --> SteelHead is installed
    fSteelHeadInstalled = FIsServiceKeyPresent(c_szSvcRouter);

    PCWInfSection pwisPort;

    (void) HrGetRasPortsInfo(&slPorts, &slUsage);

    TStringListIter pos1 = slPorts.begin();
    TStringListIter pos2 = slUsage.begin();
    //Write parameters for each port
    while ((pos1 != slPorts.end()) && (pos2 != slUsage.end()))
    {
        strValue = **pos1++;
        strTemp = c_szAfParams;
        strTemp += strValue;
        if (!strPortSections.empty())
        strPortSections += c_szAfListDelimiter;
        strPortSections += strTemp;

        pwisPort = pwifAnswerFile->AddSection(strTemp.c_str());

        //PortName
        pwisPort->AddKey(c_szAfPortname, strValue.c_str());

        //PortUsage
        strValue = **pos2++;
        //MapPortUsageRegValueToAFileValue(strValue, strValue);
        pwisPort->AddKey(c_szAfPortUsage, strValue.c_str());

        //this decides what we need to install
        // i.e a combination of MS_RasCli / MS_RasSrv
        //
        if (wcsstr(strValue.c_str(), L"Client"))
        {
            TraceTag(ttidNetUpgrade,
                     "%s: g_fAtLeastOneDialOut set to TRUE because of PortUsage %S",
                     __FUNCNAME__, strValue.c_str());
            g_fAtLeastOneDialOut = TRUE;
        }


        if (wcsstr(strValue.c_str(), c_szServer))
        {
            TraceTag(ttidNetUpgrade,
                     "%s: g_fAtLeastOneDialIn set to TRUE because of PortUsage %S",
                     __FUNCNAME__, strValue.c_str());
            g_fAtLeastOneDialIn = TRUE;
        }

    }

    // if the Port usage cannot be determined using the ports list
    // then we need to use the values found using ndiswan ProductName
    //
    if (slPorts.size() == 0)
    {
        TraceTag(ttidNetUpgrade, "%s: Since PortUsage is not defined, using flags generated by inspecting ndiswan ProductName",
                 __FUNCNAME__);
        g_fAtLeastOneDialIn = g_fAtLeastOneDialInUsingNdisWan;
        g_fAtLeastOneDialOut = g_fAtLeastOneDialOutUsingNdisWan;
    }

    //Now write RAS Global parameters
    ValueTypePair rgVtpRasParams[] = {
        {L"ForceEncryptedPassword", REG_DWORD},
        {L"ForceEncryptedData",REG_BOOL},
        {L"Multilink", REG_BOOL}};

    WriteRegValueToAFile(pwisParams, *prkProtocols,
                         rgVtpRasParams, celems(rgVtpRasParams));

    //PortSections
    pwisParams->AddKey(c_szAfPortSections, strPortSections.c_str());

    //DialoutProtocols
    err = prkProtocols->QueryValue(L"fIpxSelected", dwValue);
    if ((0 == err) && dwValue)
    {
        AddAtEndOfStringList(slTemp, c_szAfIpx);
    }
    err = prkProtocols->QueryValue(L"fNetbeuiSelected", dwValue);
    if ((0 == err) && dwValue)
    {
        AddAtEndOfStringList(slTemp, c_szAfNetbeui);
    }
    err = prkProtocols->QueryValue(L"fTcpIpSelected", dwValue);
    if ((0 == err) && dwValue)
    {
        AddAtEndOfStringList(slTemp, c_szAfTcpip);
    }
    if (!slTemp.empty())
        pwisParams->AddKey(L"DialoutProtocols", slTemp);


    //DialinProtocols
    DWORD dwIpxAllowed, dwNetBEUIAllowed, dwTcpIpAllowed;

    EraseAndDeleteAll(slTemp);
    err = prkProtocols->QueryValue(L"fIpxAllowed", dwIpxAllowed);
    if ((0 == err) && dwIpxAllowed)
    {
        AddAtEndOfStringList(slTemp, c_szAfIpx);
    }
    err = prkProtocols->QueryValue(L"fNetbeuiAllowed", dwNetBEUIAllowed);
    if ((0 == err) && dwNetBEUIAllowed)
    {
        AddAtEndOfStringList(slTemp, c_szAfNetbeui);
    }
    err = prkProtocols->QueryValue(L"fTcpIpAllowed", dwTcpIpAllowed);
    if ((0 == err) && dwTcpIpAllowed)
    {
        AddAtEndOfStringList(slTemp, c_szAfTcpip);
    }
    if (!slTemp.empty())
        pwisParams->AddKey(L"DialinProtocols", slTemp);

    if (dwNetBEUIAllowed)
    {
        //NetBEUIClientAccess
        PCORegKey prkNetBEUI = new CORegKey(*prkProtocols, L"NBF");
        err = prkNetBEUI->QueryValue(L"NetbiosGatewayEnabled", dwValue);
        if (0 == err)
        {
            if (dwValue)
            {
                pwisParams->AddKey(c_szAfNetbeuiClientAccess, c_szAfNetwork);
            }
            else
            {
                pwisParams->AddKey(c_szAfNetbeuiClientAccess, c_szAfThisComputer);
            }
        }
        DeleteIfNotNull(prkNetBEUI);
    }

    if (dwTcpIpAllowed)
    {
        //TcpIpClientAccess
        PCORegKey prkTcpIp = new CORegKey(*prkProtocols, L"IP");
        err = prkTcpIp->QueryValue(L"AllowNetworkAccess", dwValue);
        if (0 == err)
        {
            if (dwValue)
            {
                pwisParams->AddKey(c_szAfTcpipClientAccess, c_szAfNetwork);
            }
            else
            {
                pwisParams->AddKey(c_szAfTcpipClientAccess, c_szAfThisComputer);
            }
        }

        //UseDHCP
        err = prkTcpIp->QueryValue(L"UseDHCPAddressing", dwValue);
        if (0 == err)
        {
            pwisParams->AddBoolKey(c_szAfUseDhcp, dwValue);
            if (!dwValue)
            {
                // registry values for NT4
                static const WCHAR c_szIpAddressStart[] = L"IpAddressStart";
                static const WCHAR c_szIpAddressEnd[]   = L"IpAddressEnd";

                err = prkTcpIp->QueryValue(c_szIpAddressStart, strIpAddrStart);
                if (0 == err)
                {
                    err = prkTcpIp->QueryValue(c_szIpAddressEnd, strIpAddrEnd);
                    if (0 == err)
                    {
                        pwisParams->AddKey(c_szAfIpAddressStart, strIpAddrStart.c_str());
                        pwisParams->AddKey(c_szAfIpAddressEnd,  strIpAddrEnd.c_str());
                    }
                }
                else if (ERROR_FILE_NOT_FOUND == err)
                {
                    // IpAddressStart value not found, try for IpAddress/Mask

                    static const WCHAR c_szIpAddress[]      = L"IpAddress";
                    static const WCHAR c_szIpMask[]         = L"IpMask";
                    tstring strIpAddr;
                    tstring strIpMask;

                    err = prkTcpIp->QueryValue(c_szIpAddress, strIpAddr);
                    if (0 == err)
                    {
                        err = prkTcpIp->QueryValue(c_szIpMask, strIpMask);
                        if (0 == err)
                        {
                            ConvertAddrAndMaskToIpAddrRange(strIpAddr.c_str(),
                                                            strIpMask.c_str(),
                                                            &strIpAddrStart,
                                                            &strIpAddrEnd);
                            pwisParams->AddKey(c_szAfIpAddressStart, strIpAddrStart.c_str());
                            pwisParams->AddKey(c_szAfIpAddressEnd,  strIpAddrEnd.c_str());
                        }
                    }   
                }
            }
        }

        //ClientCanRequestIPAddress
        if (0 == prkTcpIp->QueryValue(L"AllowClientIPAddresses", dwValue))
        {
            pwisParams->AddBoolKey(c_szAfClientCanReqIpaddr, dwValue);
        }

        DeleteIfNotNull(prkTcpIp);
    }

    if (dwIpxAllowed)
    {
        //IpxClientAccess
        PCORegKey prkIpx = new CORegKey(*prkProtocols, L"IPX");
        err = prkIpx->QueryValue(L"AllowNetworkAccess", dwValue);
        if (0 == err)
        {
            if (dwValue)
            {
                pwisParams->AddKey(c_szAfIpxClientAccess, c_szAfNetwork);
            }
            else
            {
                pwisParams->AddKey(c_szAfIpxClientAccess, c_szAfThisComputer);
            }
        }

        //AutomaticNetworkNumbers
        err = prkIpx->QueryValue(L"AutoWanNetAllocation", dwValue);
        if (0 == err)
        {
            pwisParams->AddBoolKey(c_szAfAutoNetworkNumbers, dwValue);
        }

        //NetworkNumberFrom
        err = prkIpx->QueryValue(L"FirstWanNet", dwValue);
        if (0 == err)
        {
            pwisParams->AddKey(c_szAfNetNumberFrom, dwValue);
        }

        // WanNetPoolSize
        err = prkIpx->QueryValue(L"WanNetPoolSize", dwValue);
        if (0 == err)
        {
            pwisParams->AddKey(c_szAfWanNetPoolSize, dwValue);
        }

        //AssignSameNetworkNumber
        err = prkIpx->QueryValue(L"GlobalWanNet", dwValue);
        if (0 == err)
        {
            pwisParams->AddBoolKey(c_szAfSameNetworkNumber, dwValue);
        }

        //ClientsCanRequestIpxNodeNumber
        err = prkIpx->QueryValue(L"AcceptRemoteNodeNumber", dwValue);
        if (0 == err)
        {
            pwisParams->AddBoolKey(c_szAfClientReqNodeNumber, dwValue);
        }

        DeleteIfNotNull(prkIpx);
    }

    {
        //SecureVPN

        PCORegKey prkRasman = new CORegKey(HKEY_LOCAL_MACHINE, c_szRegKeyRasMan);

        err = prkRasman->QueryValue(L"SecureVPN", dwValue);
        if (0 == err)
        {
            pwisParams->AddKey(c_szAfSecureVPN, dwValue);
        }

        //ForceStrongEncryption
        // 398632: write this value, for both regular RAS case & steelhead case

        dwValue = 0;    // to avoid fall-thru problem (writing 0 to the answerfile is ok)
        if (fSteelHeadInstalled)
        {
            err = prkRasman->QueryValue(L"ForceStrongEncryption", dwValue);
        }
        else
        {
            PCORegKey prkComPCP = new CORegKey(HKEY_LOCAL_MACHINE, c_szRegKeyRasManSH);
            err = prkComPCP->QueryValue(L"ForceStrongEncryption", dwValue);
            DeleteIfNotNull(prkComPCP);
        }

        if (0 == err)
        {
            pwisParams->AddBoolKey(c_szAfForceStrongEncryption, dwValue);
        }

        DeleteIfNotNull(prkRasman);
    }

    pwifAnswerFile->GotoEnd();
    tstring strParamsSectionName;
    PCWInfSection pwisRasComponent;

    if (g_fAtLeastOneDialOut)
    {
        strParamsSectionName = c_szAfParams;
        strParamsSectionName = strParamsSectionName + c_szInfId_MS_RasCli;
        pwisNetServices->AddKey(c_szInfId_MS_RasCli, strParamsSectionName.c_str());
        pwisRasComponent = pwifAnswerFile->AddSection(strParamsSectionName.c_str());
        pwisRasComponent->AddKey(c_szAfInfid, c_szInfId_MS_RasCli);
        pwisRasComponent->AddKey(c_szAfParamsSection, pwisParams->Name());
    }

    if (g_fAtLeastOneDialIn)
    {
        strParamsSectionName = c_szAfParams;
        strParamsSectionName = strParamsSectionName + c_szInfId_MS_RasSrv;
        pwisNetServices->AddKey(c_szInfId_MS_RasSrv, strParamsSectionName.c_str());
        pwisRasComponent = pwifAnswerFile->AddSection(strParamsSectionName.c_str());
        pwisRasComponent->AddKey(c_szAfInfid, c_szInfId_MS_RasSrv);
        pwisRasComponent->AddKey(c_szAfParamsSection, pwisParams->Name());
    }

    // SetDialInUsage
    BOOL fSetDialInUsage = TRUE;

    if (g_NetUpgradeInfo.To.ProductType != NT_SERVER)
    {
        fSetDialInUsage = RasGetDialInUsage ();
    }
    pwisParams->AddKey(c_szAfSetDialinUsage, (UINT) fSetDialInUsage);

    if (fSteelHeadInstalled)
    {
        WriteRouterUpgradeInfo(pwifAnswerFile);
    }
    else
    {
        TraceTag(ttidNetUpgrade, "%s: Router is not installed", __FUNCNAME__);
    }

    DeleteIfNotNull(prkRAS);
    DeleteIfNotNull(prkProtocols);

    EraseAndDeleteAll(slTemp);
    EraseAndDeleteAll(slPorts);
    EraseAndDeleteAll(slUsage);

    return TRUE;
}
// ----------------------------------------------------------------------
//
// Function:  HrWritePreSP3ComponentsToSteelHeadUpgradeParams
//
// Purpose:   Write parameters of pre-SP3 steelhead components to answerfile
//
// Arguments:
//    pwifAnswerFile [in]  pointer to answerfile
//
// Returns:   S_OK on success, otherwise an error code
//
// Author:    kumarp 11-December-97
//
// Notes:     DHCPRelayAgent, Rip for Ip(x), SapAgent --> Steelhead upgrade
//
HRESULT
HrWritePreSP3ComponentsToSteelHeadUpgradeParams(
    IN CWInfFile* pwifAnswerFile)
{
    DefineFunctionName("HrWritePreSP3ComponentsToSteelHeadUpgradeParams");

    TraceFunctionEntry(ttidNetUpgrade);

    HRESULT hr=S_OK;
    CWInfSection* pwisServices;
    pwisServices = pwifAnswerFile->FindSection(c_szAfSectionNetServices);
    if (!pwisServices)
    {
        hr = E_FAIL;
        goto return_from_function;
    }

    if (FIsServiceKeyPresent(c_szSvcRouter))
    {
        hr = S_OK;
        TraceTag(ttidNetUpgrade, "%s: SteelHead is found to be installed, individual components will not be upgraded", __FUNCNAME__);
        goto return_from_function;
    }

    BOOL fSrv2SrvUpgrade;
        
    fSrv2SrvUpgrade = FALSE;

    if (g_NetUpgradeInfo.From.ProductType == NT_SERVER)
    {
        if (g_NetUpgradeInfo.To.ProductType == NT_WORKSTATION)
        {
            AssertSz(FALSE, "Cannot upgrade from srv to wks!!");
        }
        else if (g_NetUpgradeInfo.To.ProductType == NT_SERVER)
        {
            fSrv2SrvUpgrade = TRUE;
        }
    }

    BOOL fInstallSteelHead;
    BOOL fInstallSapAgent;

    fInstallSteelHead = FALSE;
    fInstallSapAgent = FALSE;

    BOOL fSapAgentInstalled;
    BOOL fRipForIpInstalled;
    BOOL fRipForIpxInstalled;
    BOOL fDhcpRelayAgentInstalled;

    fSapAgentInstalled = FALSE;
    fRipForIpInstalled = FALSE;
    fRipForIpxInstalled = FALSE;
    fDhcpRelayAgentInstalled = FALSE;

    // first find out which components are installed.
    //
    fSapAgentInstalled = FIsServiceKeyPresent(c_szSvcSapAgent);
    fRipForIpInstalled = FIsServiceKeyPresent(c_szSvcRipForIp);
    fRipForIpxInstalled = FIsServiceKeyPresent(c_szSvcRipForIpx);
    fDhcpRelayAgentInstalled = FIsServiceKeyPresent(c_szSvcDhcpRelayAgent);

#ifdef ENABLETRACE
    if (fSapAgentInstalled)
    {
        TraceTag(ttidNetUpgrade, "%s: %S is installed", __FUNCNAME__,
                 c_szSvcSapAgent);
    }

    if (fRipForIpInstalled)
    {
        TraceTag(ttidNetUpgrade, "%s: %S is installed", __FUNCNAME__,
                 c_szSvcRipForIp);
    }

    if (fRipForIpxInstalled)
    {
        TraceTag(ttidNetUpgrade, "%s: %S is installed", __FUNCNAME__,
                 c_szSvcRipForIpx);
    }

    if (fDhcpRelayAgentInstalled)
    {
        TraceTag(ttidNetUpgrade, "%s: %S is installed", __FUNCNAME__,
                 c_szSvcDhcpRelayAgent);
    }
#endif
    // now separate out cases to consider
    //
    if (fSapAgentInstalled &&
        !(fRipForIpxInstalled || fRipForIpInstalled || fDhcpRelayAgentInstalled))
    {
        fInstallSapAgent = TRUE;
    }
    else if (fRipForIpInstalled &&
             !(fRipForIpxInstalled || fSapAgentInstalled ||
               fDhcpRelayAgentInstalled))
    {
        if (fSrv2SrvUpgrade)
        {
            fInstallSteelHead = TRUE;
        }
    }
    else if ((fRipForIpInstalled && fSapAgentInstalled) &&
             !(fRipForIpxInstalled || fDhcpRelayAgentInstalled))
    {
        if (fSrv2SrvUpgrade)
        {
            fInstallSteelHead = TRUE;
        }
        else
        {
            fInstallSapAgent = TRUE;
        }
    }
    else if (fRipForIpxInstalled || fDhcpRelayAgentInstalled)
    {
        fInstallSteelHead = TRUE;
    }
    else
    {
        TraceTag(ttidNetUpgrade, "%s: no pre-SP3 steelhead components found",
                 __FUNCNAME__);
    }

    AssertSz(!(fInstallSapAgent && fInstallSteelHead),
             "Both fInstallSteelHead && fInstallSapAgent cannot be TRUE");


    // now go ahead and output the right information for the right case
    // in the answerfile
    //
    if (fInstallSteelHead)
    {
        TraceTag(ttidNetUpgrade,
                 "%s: The component(s) found will be upgraded to SteelHead",
                 __FUNCNAME__);

        WriteRouterUpgradeInfo(pwifAnswerFile);
    }
    else if (fInstallSapAgent)
    {
        TraceTag(ttidNetUpgrade, "%s: dumping data to upgrade SAP agent", __FUNCNAME__);

        CWInfSection* pwisServices;
        pwisServices = pwifAnswerFile->FindSection(c_szAfSectionNetServices);
        AssertSz(pwisServices, "[NetServices] section missing!!");

        if (pwisServices)
        {
            tstring strSapSection;
            strSapSection  = c_szAfParams;
            strSapSection += c_szInfId_MS_NwSapAgent;

            CWInfSection* pwisSap;
            pwisSap = pwifAnswerFile->AddSection(strSapSection.c_str());
            if (pwisSap)
            {
                pwisServices->AddKey(c_szInfId_MS_NwSapAgent,
                                     strSapSection.c_str());
                (void) HrNetRegSaveServiceSubKeyAndAddToSection(
                        c_szSvcSapAgent,
                        c_szParameters,
                        c_szAfNwSapAgentParams,
                        pwisSap);
            }
        }
    }

return_from_function:
    TraceError(__FUNCNAME__, hr);

    return hr;
}


// ----------------------------------------------------------------------
//
// Function:  WriteNetBIOSParams
//
// Purpose:   Write parameters of NetBIOS to the specified section
//
// Arguments:
//    pwifAnswerFile [in]  pointer to answerfile
//    pwisParams     [in]  section where to write this info
//
// Returns:   TRUE on success, FALSE otherwise
//
// Author:    kumarp 17-December-97
//
BOOL
WriteNetBIOSParams (
    IN PCWInfFile pwifAnswerFile,
    IN PCWInfSection pwisParams)
{
    DefineFunctionName("WriteNetBIOSParams");

    TraceFunctionEntry(ttidNetUpgrade);

    PCORegKey prkLinkage;

    // The netbios section will be used to apply lana config but since
    // MSClient installs NetBIOS we don't want to install it
    // via the answerfilein GUI mode.
    //
    pwisParams->AddBoolKey(c_szAfSkipInstall, TRUE);

    GetServiceSubkey(c_szSvcNetBIOS, c_szLinkage, prkLinkage);
    if (!prkLinkage)
        return FALSE;

    TStringList     slRoutes, slRoute, slLanaPath;
    tstring         strRoute, strLanaPath, strTemp;
    TStringListIter iter;
    TByteArray baLanaMap;

    prkLinkage->QueryValue(L"LanaMap", baLanaMap);

    BYTE* pbData=NULL;

    if (baLanaMap.size() > 0)
    {
        GetDataFromByteArray(baLanaMap, pbData);

        WORD* pwLanaCodes;
        WORD wLanaNumber;
        WORD wRouteNum;

        pwLanaCodes = (WORD *) pbData;

        prkLinkage->QueryValue(c_szRegValRoute, slRoutes);

        iter = slRoutes.begin();
        wRouteNum=0;

        while (iter != slRoutes.end())
        {
            strRoute = **iter++;
            TraceTag(ttidNetUpgrade, "%s: processing: %S",
                     __FUNCNAME__, strRoute.c_str());

            EraseAndDeleteAll(slLanaPath);
            ConvertRouteToStringList(strRoute.c_str(), slRoute);
            TStringListIter pos2 = slRoute.begin();
            while (pos2 != slRoute.end())
            {
                strTemp = **pos2++;
                TraceTag(ttidNetUpgrade, "%s: route component: %S",
                         __FUNCNAME__, strTemp.c_str());
                if (IsNetCardProductName(strTemp.c_str()))
                    continue;
                MapNetComponentNameForBinding(strTemp.c_str(), strTemp);
                AddAtEndOfStringList(slLanaPath, strTemp.c_str());

                // Stop adding components if the last one soesn't
                // expose its lower components.
                if (FIsDontExposeLowerComponent (strTemp.c_str()))
                {
                    break;
                }
            }

            // Note: The following must be written out exactly!!!  The
            // consumer of this information expects each LanaPath key to be
            // followed by the corresponding LanaNumber key.
            //
            TraceStringList(ttidNetUpgrade, L"LanaPath: ", slLanaPath);
            pwisParams->AddKey(L"LanaPath", slLanaPath);

            wLanaNumber = HIBYTE (pwLanaCodes[wRouteNum]);

            TraceTag(ttidNetUpgrade, "%s: LanaNumber: 0x%x", __FUNCNAME__, wLanaNumber);
            pwisParams->AddHexKey(L"LanaNumber", wLanaNumber);

            wRouteNum++;
        }
        pwisParams->AddKey (L"NumberOfPaths", wRouteNum);
    }
    else
    {
        TraceTag(ttidNetUpgrade, "%s: LanaMap has no entries!!, skipped LanaMap dump", __FUNCNAME__);
    }

    DeleteIfNotNull(prkLinkage);

    EraseAndDeleteAll(slRoute);
    EraseAndDeleteAll(slRoutes);
    EraseAndDeleteAll(slLanaPath);

    delete pbData;

    return TRUE;
}

// ----------------------------------------------------------------------
//
// Function:  WriteDhcpServerParams
//
// Purpose:   Write parameters of DHCPServer to the specified section
//
// Arguments:
//    pwifAnswerFile [in]  pointer to answerfile
//    pwisParams     [in]  section where to write the parameters
//
// Returns:   TRUE on success, FALSE otherwise
//
// Author:    kumarp 17-December-97
//
BOOL
WriteDhcpServerParams (
    IN PCWInfFile pwifAnswerFile,
    IN PCWInfSection pwisParams)
{
    DefineFunctionName("WriteDhcpServerParams");

    TraceFunctionEntry(ttidNetUpgrade);

    static const WCHAR c_szConfiguration[] = L"Configuration";

    HrNetRegSaveServiceSubKeyAndAddToSection(c_szSvcDhcpServer,
                                             c_szParameters,
                                             c_szAfDhcpServerParameters,
                                             pwisParams);

    HrNetRegSaveServiceSubKeyAndAddToSection(c_szSvcDhcpServer,
                                             c_szConfiguration,
                                             c_szAfDhcpServerConfiguration,
                                             pwisParams);

    return TRUE;
}

// ----------------------------------------------------------------------
//
// Function:  WriteTp4Params
//
// Purpose:   Write parameters of Tp4 to the specified section
//
// Arguments:
//    pwifAnswerFile [in]  pointer to answerfile
//    pwisParams     [in]  section where to write the parameters
//
// Returns:   TRUE on success, FALSE otherwise
//
// Author:    kumarp 01-October-98
//
BOOL
WriteTp4Params (
    IN PCWInfFile pwifAnswerFile,
    IN PCWInfSection pwisParams)
{
    static const WCHAR c_szCLNP[] = L"IsoTp\\Parameters\\CLNP";
    static const WCHAR c_szLocalMachineName[] = L"LocalMachineName";
    static const WCHAR c_szLocalMachineNSAP[] = L"LocalMachineNSAP";

    WriteServiceRegValueToAFile(pwisParams, c_szCLNP, c_szLocalMachineName);
    WriteServiceRegValueToAFile(pwisParams, c_szCLNP, c_szLocalMachineNSAP);

    return TRUE;
}


// ----------------------------------------------------------------------
//
// Function:WriteWLBSParams
//
// Purpose: Write parameters of WLBS (windows load balancing service)
//          to the specified section
//
// Arguments:
//    pwifAnswerFile [in]  pointer to answerfile
//    pwisParams     [in]  section where to write the parameters
//
// Returns:   TRUE on success, FALSE otherwise
//
// Author:    SumitC    04-Mar-99   created
//
BOOL
WriteWLBSParams(
    IN PCWInfFile pwifAnswerFile,
    IN PCWInfSection pwisParams)
{
    DefineFunctionName("WriteWLBSParams");

    TraceFunctionEntry(ttidNetUpgrade);

    /* We should get here only for upgrades from NT4 or earlier */
    Assert (g_NetUpgradeInfo.From.dwBuildNumber);
    Assert (g_NetUpgradeInfo.From.dwBuildNumber <= wWinNT4BuildNumber);

    HRESULT hr = S_OK;

    static const struct
    {
        PCWSTR     szName;
        WORD        wType;
    } aParams[] =
    {
        { CVY_NAME_VERSION,        CVY_TYPE_VERSION          },
        { CVY_NAME_DED_IP_ADDR,    CVY_TYPE_DED_IP_ADDR      },
        { CVY_NAME_DED_NET_MASK,   CVY_TYPE_DED_NET_MASK     },
        { CVY_NAME_HOST_PRIORITY,  CVY_TYPE_HOST_PRIORITY    },
        { CVY_NAME_NETWORK_ADDR,   CVY_TYPE_NETWORK_ADDR     },
        { CVY_NAME_CL_IP_ADDR,     CVY_TYPE_CL_IP_ADDR       },
        { CVY_NAME_CL_NET_MASK,    CVY_TYPE_CL_NET_MASK      },
        { CVY_NAME_CLUSTER_MODE,   CVY_TYPE_CLUSTER_MODE     },
        { CVY_NAME_ALIVE_PERIOD,   CVY_TYPE_ALIVE_PERIOD     },
        { CVY_NAME_ALIVE_TOLER,    CVY_TYPE_ALIVE_TOLER      },
        { CVY_NAME_NUM_ACTIONS,    CVY_TYPE_NUM_ACTIONS      },
        { CVY_NAME_NUM_PACKETS,    CVY_TYPE_NUM_PACKETS      },
        { CVY_NAME_NUM_SEND_MSGS,  CVY_TYPE_NUM_SEND_MSGS    },
        { CVY_NAME_DOMAIN_NAME,    CVY_TYPE_DOMAIN_NAME      },
        { CVY_NAME_LICENSE_KEY,    CVY_TYPE_LICENSE_KEY      },
        { CVY_NAME_RMT_PASSWORD,   CVY_TYPE_RMT_PASSWORD     },
        { CVY_NAME_RCT_PASSWORD,   CVY_TYPE_RCT_PASSWORD     },
        { CVY_NAME_RCT_PORT,       CVY_TYPE_RCT_PORT         },
        { CVY_NAME_RCT_ENABLED,    CVY_TYPE_RCT_ENABLED      },
        { CVY_NAME_NUM_RULES,      CVY_TYPE_NUM_RULES        },
        { CVY_NAME_CUR_VERSION,    CVY_TYPE_CUR_VERSION      },
        { CVY_NAME_PORT_RULES,     CVY_TYPE_PORT_RULES       },
        { CVY_NAME_DSCR_PER_ALLOC, CVY_TYPE_DSCR_PER_ALLOC   },
        { CVY_NAME_MAX_DSCR_ALLOCS,CVY_TYPE_MAX_DSCR_ALLOCS  },
        { CVY_NAME_SCALE_CLIENT,   CVY_TYPE_SCALE_CLIENT     },
        { CVY_NAME_CLEANUP_DELAY,  CVY_TYPE_CLEANUP_DELAY    },
        { CVY_NAME_NBT_SUPPORT,    CVY_TYPE_NBT_SUPPORT      },
        { CVY_NAME_MCAST_SUPPORT,  CVY_TYPE_MCAST_SUPPORT    },
        { CVY_NAME_MCAST_SPOOF,    CVY_TYPE_MCAST_SPOOF      },
        { CVY_NAME_MASK_SRC_MAC,   CVY_TYPE_MASK_SRC_MAC     },
        { CVY_NAME_CONVERT_MAC,    CVY_TYPE_CONVERT_MAC      },
    };

    // Verify that we have the name of the adapter to which NLB should be bound
    if (0 == pszWlbsClusterAdapterName[0])
    {
        hr = E_UNEXPECTED;
    }

    if (SUCCEEDED(hr))
    {
        static const WCHAR c_szWLBSParams[] = L"WLBS\\Parameters";
        tstring szSectionName = pwisParams->Name();
        // Adapter01 is hardcoded is for an NT4 to Whistler upgrade, we will always only have one WLBS adapter
        szSectionName += L".Adapter01";
        pwisParams->AddKey(c_szAfAdapterSections, szSectionName.c_str());
        PCWInfSection pWlbsAdapterSection = pwifAnswerFile->AddSection(szSectionName.c_str());
        if (!pWlbsAdapterSection)
        {
            hr = E_FAIL;
        }

        if (SUCCEEDED(hr))
        {
            pWlbsAdapterSection->AddKey(c_szAfSpecificTo, pszWlbsClusterAdapterName);

            for (UINT i = 0 ; i < celems(aParams); ++i)
            {
                WriteServiceRegValueToAFile(pWlbsAdapterSection,
                                            c_szWLBSParams,
                                            aParams[i].szName,
                                            aParams[i].wType);
            }
        }
    }
    
    if (FAILED(hr))
    {
        TraceError("WriteWLBSParams", hr );
    }

    return SUCCEEDED(hr);

}


// ----------------------------------------------------------------------
//
// Function:WriteConvoyParams
//
// Purpose: Write parameters of Convoy (windows load balancing service)
//          to the specified section
//
// Arguments:
//    pwifAnswerFile [in]  pointer to answerfile
//    pwisParams     [in]  section where to write the parameters
//
// Returns:   TRUE on success, FALSE otherwise
//
// Author:    SumitC    04-Mar-99   created
//
BOOL
WriteConvoyParams(
    IN PCWInfFile pwifAnswerFile,
    IN PCWInfSection pwisParams)
{
    DefineFunctionName("WriteConvoyParams");

    TraceFunctionEntry(ttidNetUpgrade);

    HRESULT hr = S_OK;

    static const struct
    {
        PCWSTR     szName;
        WORD        wType;
    } aParams[] =
    {
        { CVY_NAME_VERSION,        CVY_TYPE_VERSION          },
        { CVY_NAME_DED_IP_ADDR,    CVY_TYPE_DED_IP_ADDR      },
        { CVY_NAME_DED_NET_MASK,   CVY_TYPE_DED_NET_MASK     },
        { CVY_NAME_HOST_PRIORITY,  CVY_TYPE_HOST_PRIORITY    },
        { CVY_NAME_NETWORK_ADDR,   CVY_TYPE_NETWORK_ADDR     },
        { CVY_NAME_CL_IP_ADDR,     CVY_TYPE_CL_IP_ADDR       },
        { CVY_NAME_CL_NET_MASK,    CVY_TYPE_CL_NET_MASK      },
        { CVY_NAME_CLUSTER_MODE,   CVY_TYPE_CLUSTER_MODE     },
        { CVY_NAME_ALIVE_PERIOD,   CVY_TYPE_ALIVE_PERIOD     },
        { CVY_NAME_ALIVE_TOLER,    CVY_TYPE_ALIVE_TOLER      },
        { CVY_NAME_NUM_ACTIONS,    CVY_TYPE_NUM_ACTIONS      },
        { CVY_NAME_NUM_PACKETS,    CVY_TYPE_NUM_PACKETS      },
        { CVY_NAME_NUM_SEND_MSGS,  CVY_TYPE_NUM_SEND_MSGS    },
        { CVY_NAME_DOMAIN_NAME,    CVY_TYPE_DOMAIN_NAME      },
        { CVY_NAME_LICENSE_KEY,    CVY_TYPE_LICENSE_KEY      },
        { CVY_NAME_RMT_PASSWORD,   CVY_TYPE_RMT_PASSWORD     },
        { CVY_NAME_RCT_PASSWORD,   CVY_TYPE_RCT_PASSWORD     },
        { CVY_NAME_RCT_PORT,       CVY_TYPE_RCT_PORT         },
        { CVY_NAME_RCT_ENABLED,    CVY_TYPE_RCT_ENABLED      },
        { CVY_NAME_NUM_RULES,      CVY_TYPE_NUM_RULES        },
        { CVY_NAME_CUR_VERSION,    CVY_TYPE_CUR_VERSION      },
        { CVY_NAME_PORT_RULES,     CVY_TYPE_PORT_RULES       },
        { CVY_NAME_DSCR_PER_ALLOC, CVY_TYPE_DSCR_PER_ALLOC   },
        { CVY_NAME_MAX_DSCR_ALLOCS,CVY_TYPE_MAX_DSCR_ALLOCS  },
        { CVY_NAME_SCALE_CLIENT,   CVY_TYPE_SCALE_CLIENT     },
        { CVY_NAME_CLEANUP_DELAY,  CVY_TYPE_CLEANUP_DELAY    },
        { CVY_NAME_NBT_SUPPORT,    CVY_TYPE_NBT_SUPPORT      },
        { CVY_NAME_MCAST_SUPPORT,  CVY_TYPE_MCAST_SUPPORT    },
        { CVY_NAME_MCAST_SPOOF,    CVY_TYPE_MCAST_SPOOF      },
        { CVY_NAME_MASK_SRC_MAC,   CVY_TYPE_MASK_SRC_MAC     },
        { CVY_NAME_CONVERT_MAC,    CVY_TYPE_CONVERT_MAC      },
    };
    static const WCHAR c_szConvoyParams[] = L"Convoy\\Parameters";

    for (UINT i = 0 ; i < celems(aParams); ++i)
    {
        WriteServiceRegValueToAFile(pwisParams,
                                    c_szConvoyParams,
                                    aParams[i].szName,
                                    aParams[i].wType);
    }

    return SUCCEEDED(hr);

}


// ----------------------------------------------------------------------
//
// Function:  WriteNWCWorkstationParams
//
// Purpose:   Write parameters of Netware Client to the answerfile
//
// Arguments:
//    pwifAnswerFile [in]  pointer to answerfile
//    pwisParams     [in]  section where to write the parameters
//
// Returns:   TRUE on success, FALSE otherwise
//
// Author:    kumarp 17-December-97
//
BOOL
WriteNWCWorkstationParams (
    IN PCWInfFile pwifAnswerFile,
    IN PCWInfSection pwisParams)
{
    DefineFunctionName("WriteNWCWorkstationParams");

    TraceFunctionEntry(ttidNetUpgrade);

    HrNetRegSaveServiceSubKeyAndAddToSection(c_szSvcNWCWorkstation,
                                             c_szParameters,
                                             c_szAfNWCWorkstationParameters,
                                             pwisParams);

    HrNetRegSaveServiceSubKeyAndAddToSection(c_szSvcNWCWorkstation,
                                             c_szShares,
                                             c_szAfNWCWorkstationShares,
                                             pwisParams);
    HrNetRegSaveServiceSubKeyAndAddToSection(c_szSvcNWCWorkstation,
                                             c_szDrives,
                                             c_szAfNWCWorkstationDrives,
                                             pwisParams);

    return TRUE;

    // we want to retain this code till jeffspr makes up his mind
    //
/*    PCORegKey prkParams;
    PCWInfSection pwisLogonInfo;
    tstring strId;

    GetServiceParamsKey(c_szSvcNWCWorkstation, prkParams);
    if (!prkParams)
        return FALSE;

    CORegKey rkLogon(*prkParams, L"Logon");
    CORegKey rkOption(*prkParams, L"Option");
    //CORegKeyIter rkiLogon(rkLogon);
    CORegKeyIter rkiOption(rkOption);

    while (!rkiOption.Next(&strId))
    {
        CORegKey rkId(rkLogon, strId.c_str());
        ContinueIf(!rkId.HKey());

        TByteArray abLogonID;
        rkId.QueryValue(L"LogonID", abLogonID);
        QWORD qwLogonID = ConvertToQWord(abLogonID);

        pwisParams->AddKey(L"LogonInfo", strId.c_str());
        pwisLogonInfo = pwifAnswerFile->AddSection(strId.c_str());
        ContinueIf(!pwisParams);

        CORegKey rkOptionLogonId(rkOption, strId.c_str());
        if (!rkOption.HKey())
        {
            continue;
        }

        // LogonId
        pwisLogonInfo->AddQwordKey(L"LogonID", qwLogonID);

        // LogonScript
        WriteRegValueToAFile(pwisLogonInfo, rkOptionLogonId, L"LogonScript",
                             REG_DWORD, NULL, TRUE, (DWORD) 0);

        // PreferredServer
        WriteRegValueToAFile(pwisLogonInfo, rkOptionLogonId, L"PreferredServer");

        // PrintOption
        WriteRegValueToAFile(pwisLogonInfo, rkOptionLogonId,
                             L"PrintOption", REG_DWORD);
    }

    return TRUE;
*/
}

// ----------------------------------------------------------------------
//
// Function:  WriteBrowserParams
//
// Purpose:   Write parameters of Browser to the specified section
//
// Arguments:
//    pwifAnswerFile [in]  pointer to answerfile
//    pwisParams     [in]  section where to write the parameters
//
// Returns:   TRUE on success, FALSE otherwise
//
// Author:    kumarp 17-December-97
//
BOOL
WriteBrowserParams (
    IN PCWInfFile pwifAnswerFile,
    IN PCWInfSection pwisParams)
{
    DefineFunctionName("WriteBrowserParams");

    TraceFunctionEntry(ttidNetUpgrade);

    PCORegKey prkParams;
    //Browser stores its parameters under the LanmanWorkstation key!
    GetServiceParamsKey(c_szSvcWorkstation, prkParams);

    TStringList slDomains;

    prkParams->QueryValue(L"OtherDomains", slDomains);
    pwisParams->AddKey(c_szAfBrowseDomains, slDomains);

    DeleteIfNotNull(prkParams);

    // now write reg-dump keys
    tstring strFileName;
    tstring strServices = c_szRegKeyServices;
    strServices += L"\\";

    HrNetRegSaveServiceSubKeyAndAddToSection(c_szSvcBrowser,
                                             c_szParameters,
                                             c_szAfBrowserParameters,
                                             pwisParams);

    HrNetRegSaveServiceSubKeyAndAddToSection(c_szSvcNetLogon,
                                             c_szParameters,
                                             c_szAfNetLogonParameters,
                                             pwisParams);

    EraseAndDeleteAll(slDomains);

    return TRUE;
}

// ----------------------------------------------------------------------
//
// Function:  WriteLanmanServerParams
//
// Purpose:   Write parameters of LanmanServer to the specified section
//
// Arguments:
//    pwifAnswerFile [in]  pointer to answerfile
//    pwisParams     [in]  section where to write the parameters
//
// Returns:   TRUE on success, FALSE otherwise
//
// Author:    kumarp 17-December-97
//
BOOL
WriteLanmanServerParams (
    IN PCWInfFile pwifAnswerFile,
    IN PCWInfSection pwisParams)
{
    DefineFunctionName("WriteLanmanServerParams");

    TraceFunctionEntry(ttidNetUpgrade);

    PCORegKey prkParams;
    static const WCHAR c_szShares[] = L"Shares";
    static const WCHAR c_szAutotunedParameters[] = L"AutotunedParameters";
    static const WCHAR c_szMemoryManagement[] = L"System\\CurrentControlSet\\Control\\Session Manager\\Memory Management";
    static const WCHAR c_szLargeSystemCache[] = L"LargeSystemCache";

    GetServiceParamsKey(c_szSvcLmServer, prkParams);

    DWORD dwValue=3;
    HRESULT hr=S_OK;

    //Optimization
    prkParams->QueryValue(L"Size", dwValue);
    if ((dwValue >= 1) && (dwValue <= 3))
    {
        if (dwValue == 3)
        {
            HKEY hkey;
            // need to inspect one more key
            hr = HrRegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szMemoryManagement,
                                KEY_READ, &hkey);
            if (S_OK == hr)
            {
                DWORD dw;

                hr = HrRegQueryDword(hkey, c_szLargeSystemCache, &dw);
                if (S_OK == hr)
                {
                    if (dw == 0)
                    {
                        dwValue = 4;
                    }
                }
                RegCloseKey(hkey);
            }
        }
        pwisParams->AddKey(c_szAfLmServerOptimization, g_pszServerOptimization[dwValue]);
    }

    //BroadcastsToLanman2Clients
    dwValue=0;
    prkParams->QueryValue(L"Lmannounce", dwValue);
    pwisParams->AddBoolKey(c_szAfBroadcastToClients, dwValue);

    // now write reg-dump keys
    tstring strFileName;
    tstring strServices = c_szRegKeyServices;
    strServices += L"\\";

    // ignore the error codes so that we can dump whatever is available/present
    //
    hr = HrNetRegSaveServiceSubKeyAndAddToSection(c_szSvcLmServer,
                                                  c_szParameters,
                                                  c_szAfLmServerParameters,
                                                  pwisParams);

    hr = HrNetRegSaveServiceSubKeyAndAddToSection(c_szSvcLmServer,
                                                  c_szShares,
                                                  c_szAfLmServerShares,
                                                  pwisParams);

    hr = HrNetRegSaveServiceSubKeyAndAddToSection(c_szSvcLmServer,
                                                  c_szAutotunedParameters,
                                                  c_szAfLmServerAutotunedParameters,
                                                  pwisParams);

    DeleteIfNotNull(prkParams);

    return TRUE;
}

// ----------------------------------------------------------------------
//
// Function:  WriteLanmanWorkstationParams
//
// Purpose:   Write parameters of LanmanWorkstation to the specified section
//
// Arguments:
//    pwifAnswerFile [in]  pointer to answerfile
//    pwisParams     [in]  section where to write the parameters
//
// Returns:   TRUE on success, FALSE otherwise
//
// Author:    kumarp 17-December-97
//
BOOL
WriteLanmanWorkstationParams (
    IN PCWInfFile pwifAnswerFile,
    IN PCWInfSection pwisParams)
{
    DefineFunctionName("WriteLanmanWorkstationParams");

    TraceFunctionEntry(ttidNetUpgrade);

    //    pwisParams->AddComment(c_szNoParamsRequired);

    return TRUE;
}


// ----------------------------------------------------------------------
//
// Function:  WriteRPCLocatorParams
//
// Purpose:   Write parameters of RPCLOCATOR to the specified section
//
// Arguments:
//    pwifAnswerFile [in]  pointer to answerfile
//    pwisParams     [in]  section where to write the parameters
//
// Returns:   TRUE on success, FALSE otherwise
//
// Author:    kumarp 17-December-97
//
BOOL
WriteRPCLocatorParams (
    IN PCWInfFile pwifAnswerFile,
    IN PCWInfSection pwisParams)
{
    DefineFunctionName("WriteRPCLocatorParams");

    TraceFunctionEntry(ttidNetUpgrade);

    //DefaultSecurityProvider
    WriteRegValueToAFile(pwisParams,
                         HKEY_LOCAL_MACHINE,
                         L"SOFTWARE\\Microsoft\\Rpc\\SecurityService",
                         L"DefaultProvider", REG_SZ,
                         c_szAfDefaultProvider);

    //NameServiceNetworkAddress
    WriteRegValueToAFile(pwisParams,
                         HKEY_LOCAL_MACHINE,
                         L"SOFTWARE\\Microsoft\\Rpc\\NameService",
                         L"NetworkAddress", REG_SZ,
                         c_szAfNameServiceAddr);

    //NameServiceProtocol
    WriteRegValueToAFile(pwisParams,
                         HKEY_LOCAL_MACHINE,
                         L"SOFTWARE\\Microsoft\\Rpc\\NameService",
                         L"Protocol", REG_SZ,
                         c_szAfNameServiceProtocol);

    return TRUE;
}


// ----------------------------------------------------------------------
//
// Function:  IsNetComponentBindable
//
// Purpose:   Determine if a component is bindable
//            (it has Bind value under the Linkage key)
//
// Arguments:
//    prkNetComponentLinkage [in]  Linkage key of the component
//
// Returns:   TRUE on success, FALSE otherwise
//
// Author:    kumarp 17-December-97
//
BOOL
IsNetComponentBindable (
    IN const PCORegKey prkNetComponentLinkage)
{
    BOOL status;
    TStringList slTemp;

    status = prkNetComponentLinkage->QueryValue(c_szRegValBind, slTemp) == ERROR_SUCCESS;

    EraseAndDeleteAll(slTemp);

    return status;
}

// ----------------------------------------------------------------------
//
// Function:  ConvertRouteToStringList
//
// Purpose:   Convert Linkage\Route value to a tstring list
//
// Arguments:
//    pszRoute [in]   route
//    slRoute  [out]  list of route elements
//
// Returns:   None
//
// Author:    kumarp 17-December-97
//
void
ConvertRouteToStringList (
    IN PCWSTR pszRoute,
    OUT TStringList &slRoute )
{
    EraseAndDeleteAll(slRoute);
    const WCHAR CHQUOTE = '"';
    tstring str;

    INT cQuote;

    for ( cQuote = 0 ; *pszRoute ; pszRoute++ )
    {
        if ( *pszRoute == CHQUOTE )
        {
            if ( cQuote++ & 1 )  // If it's a closing quote...
            {
                if ( str.size() )
                {
                    if (FIsDontExposeLowerComponent(str.c_str()))
                    {
                        break;
                    }

                    AddAtEndOfStringList(slRoute, str.c_str());

                    // If the route contains NetBT, then add in TCPIP
                    // because TCPIP is in the bind string in Windows 2000.
                    // e.g. a binding of NetBT->Adapter will become
                    // NetBT->TCPIP->Adapter.
                    //
                    if (0 == _wcsicmp (str.c_str(), L"NetBT"))
                    {
                        AddAtEndOfStringList(slRoute, L"TCPIP");
                    }
                }
            }
            str.erase();
        }
        else
        {
            str += *pszRoute;
        }
    }
}

// ----------------------------------------------------------------------
//
// Function:  IsMSNetClientComponent
//
// Purpose:   Determine if the specified component is a subcomponent
//            of MS_MSClient
//
// Arguments:
//    pszComponentName [in]  name of component
//
// Returns:   TRUE on success, FALSE otherwise
//
// Author:    kumarp 17-December-97
//
BOOL
IsMSNetClientComponent (
    IN PCWSTR pszComponentName)
{
    Assert (pszComponentName && *pszComponentName);

    return ((!_wcsicmp(pszComponentName, c_szSvcBrowser)) ||
            (!_wcsicmp(pszComponentName, c_szSvcWorkstation)) ||
            (!_wcsicmp(pszComponentName, L"RpcLocator")));
}

// ----------------------------------------------------------------------
//
// Function:  WriteBindings
//
// Purpose:   Write disabled bindings of a component to [NetBindings] section
//
// Arguments:
//    pszComponentName [in]  name of component
//
// Returns:   TRUE on success, FALSE otherwise
//
// Author:    kumarp 17-December-97
//
BOOL
WriteBindings (
    IN PCWSTR pszComponentName)
{
    Assert (pszComponentName && *pszComponentName);

    DefineFunctionName("WriteBindings");

    BOOL            fStatus=TRUE;
    TStringList     slBindings, slRoute;
    tstring         strRoute, strBindings, strTemp;
    TStringListIter iter;

    // we want to write bindings only for LanmanWorkstation among the
    // MSClient components
    //
    if (IsMSNetClientComponent(pszComponentName) &&
        (lstrcmpiW(pszComponentName, c_szSvcWorkstation)))
    {
        return TRUE;
    }

    TraceTag(ttidNetUpgrade, "%s: writing bindings of '%S'...",
             __FUNCNAME__, pszComponentName);

    PCORegKey prkNetComponentLinkage=NULL,
        prkNetComponentLinkageDisabled=NULL;
    GetServiceSubkey(pszComponentName, c_szLinkage, prkNetComponentLinkage);

    if (!prkNetComponentLinkage || !IsNetComponentBindable(prkNetComponentLinkage))
        goto error_cleanup;

    GetServiceSubkey(pszComponentName,
                     c_szLinkageDisabled,
                     prkNetComponentLinkageDisabled);
    if (!prkNetComponentLinkageDisabled)
        goto error_cleanup;

    //We write only those bindings that are disabled, others by default are enabled
    //    prkNetComponentLinkage->QueryValue(c_szRegValRoute, slBindings);
    prkNetComponentLinkageDisabled->QueryValue(c_szRegValRoute, slBindings);

    for (iter = slBindings.begin(); iter != slBindings.end(); iter++)
    {
        strRoute = **iter;

        MapNetComponentNameForBinding(pszComponentName, strBindings);
        if (!lstrcmpiW(strBindings.c_str(), c_szInfId_MS_NetBT))
        {
            strBindings += L",";
            strBindings += c_szInfId_MS_TCPIP;
        }
        ConvertRouteToStringList(strRoute.c_str(), slRoute);
        TStringListIter iterComponentsInRoute;

        for (iterComponentsInRoute = slRoute.begin();
             iterComponentsInRoute != slRoute.end();
             iterComponentsInRoute++)
        {
            strTemp = **iterComponentsInRoute;

            if (IsNetCardProductName(strTemp.c_str()))
                continue;
            MapNetComponentNameForBinding(strTemp.c_str(), strTemp);

            // pre-NT5 code stores bindings such that MS_NetBT appears to
            // bind directly to a netcard. in NT5 MS_NetBT binds to MS_TCPIP
            // which then binds to a netcard.
            // thus for any binding path having MS_NetBT in it, we need to
            // convert this to MS_NetBT,MS_TCPIP
            //

            // NTRAID9:210426@20001130#deonb. 
            // This is redundant. ConvertRouteToStringList already add MS_TCPIP after encountering NETBT,
            // Adding it again will result in a bindpath of MS_NetBT,ms_tcpip,MS_TCPIP which will not be matched
            // by GUI setup. Removing this check.
            // if (!lstrcmpiW(strTemp.c_str(), c_szInfId_MS_NetBT))
            // {
            //      strTemp += L",";
            //      strTemp += c_szInfId_MS_TCPIP;
            // }

            // 306866: pre-NT5 code stores ISO/TP4 bindings in the form
            // isotp4->streams->adapter.  In NT5, each of these binds
            // directly to the adapter.  So if we find an isotp Route for
            // which the first component is Streams, we skip it.
            //
            if (!lstrcmpiW(strBindings.c_str(), c_szInfId_MS_Isotpsys) &&
                !lstrcmpiW(strTemp.c_str(), c_szInfId_MS_Streams))
            {
                continue;
            }

            strBindings += L"," + strTemp;

            // 243906: if the component is DONT_EXPOSE_LOWER, terminate the bindpath

            if (!lstrcmpiW(strTemp.c_str(), c_szInfId_MS_NWIPX) ||
                !lstrcmpiW(strTemp.c_str(), c_szInfId_MS_NWNB) ||
                !lstrcmpiW(strTemp.c_str(), c_szInfId_MS_NWSPX))
            {
                break;
            }
        }
        EraseAndDeleteAll(slRoute);

        // WLBS: don't write Disable bindings that contain MS_TCPIP and WLBS
        // cluster adapter.

        if (pszWlbsClusterAdapterName[0] != 0 &&
            (strBindings.find(c_szInfId_MS_TCPIP) != tstring::npos ||
             strBindings.find(c_szMSTCPIP) != tstring::npos) &&
            strBindings.find(pszWlbsClusterAdapterName) != tstring::npos)
        {
            TraceTag(ttidNetUpgrade, "%s: skipping Disable=%S",
                     __FUNCNAME__, strBindings.c_str());

            continue;
        }

        // end WLBS:

        g_pwisBindings->AddKey(c_szAfDisable, strBindings.c_str());
        TraceTag(ttidNetUpgrade, "%s: Disable=%S",
                 __FUNCNAME__, strBindings.c_str());
    }

    // WLBS: if WLBS is bound to a NIC, then write explicit Enable binding to it.
    // by default, WLBS notifier object will disable all bindings on install.

    if ((_wcsicmp(pszComponentName, c_szWLBS) == 0 ||
         _wcsicmp(pszComponentName, c_szConvoy) == 0)
        && pszWlbsClusterAdapterName[0] != 0)
    {
        strBindings  = c_szMSWLBS;
        strBindings += L",";
        strBindings += pszWlbsClusterAdapterName;
        g_pwisBindings->AddKey(c_szAfEnable, strBindings.c_str());

        TraceTag(ttidNetUpgrade, "%s: Enable=%S",
                 __FUNCNAME__, strBindings.c_str());
    }

    // end WLBS:

    fStatus=TRUE;
    goto cleanup;

  error_cleanup:
    fStatus = FALSE;

  cleanup:
    DeleteIfNotNull(prkNetComponentLinkage);
    DeleteIfNotNull(prkNetComponentLinkageDisabled);

    EraseAndDeleteAll(slBindings);

    return fStatus;
}


// ----------------------------------------------------------------------
// Misc. Helper Functions
// ----------------------------------------------------------------------

// ----------------------------------------------------------------------
//
// Function:  WriteServiceRegValueToAFile
//
// Purpose:   Write specified value in registry to the specified section
//            in the answerfile, renaming if required
//
// Arguments:
//    pwisSection      [in]  section to which the value is written
//    pszServiceKey    [in]  name of service
//    pszValueName     [in]  name of value under Parameters subkey
//    wValueType       [in]  type of value
//    pszValueNewName  [in]  change name to this
//    fDefaultProvided [in]  is a default value provided ?
//    ...              [in]  use this default value if the specified value is
//                           not found in the registry
//
// Returns:   TRUE on success, FALSE otherwise
//
// Author:    kumarp 17-December-97
//
BOOL
WriteServiceRegValueToAFile(
    IN PCWInfSection pwisSection,
    IN PCWSTR pszServiceKey,
    IN PCWSTR pszValueName,
    IN WORD wValueType,
    IN PCWSTR pszValueNewName,
    IN BOOL fDefaultProvided,
    ...)
{
    AssertValidReadPtr(pwisSection);
    AssertValidReadPtr(pszValueName);

    tstring strKeyFullPath;
    strKeyFullPath = tstring(L"System\\CurrentControlSet\\Services\\")
        + pszServiceKey;

    va_list arglist;

    va_start (arglist, fDefaultProvided);
    BOOL fStatus =
        WriteRegValueToAFile(pwisSection, HKEY_LOCAL_MACHINE,
                             strKeyFullPath.c_str(), pszValueName, wValueType,
                             pszValueNewName, fDefaultProvided, arglist);
    va_end(arglist);

    return fStatus;
}

// ----------------------------------------------------------------------
//
// Function:  WriteServiceRegValueToAFile
//
// Purpose:   Write specified value in registry to the specified section
//            in the answerfile, renaming if required
//
// Arguments:
//    pwisSection      [in]  section to which the value is written
//    hkey             [in]  handle to a regkey
//    pszSubKey        [in]  name of subkey
//    pszValueName     [in]  name of value
//    wValueType       [in]  type of value
//    pszValueNewName  [in]  change name to this
//    fDefaultProvided [in]  is a default value provided ?
//    ...              [in]  use this default value if the specified value is
//                           not found in the registry
//
// Returns:   TRUE on success, FALSE otherwise
//
// Author:    kumarp 17-December-97
//
BOOL
WriteRegValueToAFile(
    IN PCWInfSection pwisSection,
    IN HKEY hKey,
    IN PCWSTR pszSubKey,
    IN PCWSTR pszValueName,
    IN WORD wValueType,
    IN PCWSTR pszValueNewName,
    IN BOOL fDefaultProvided,
    ...)
{
    BOOL fStatus;
    va_list arglist;

    va_start (arglist, fDefaultProvided);
    fStatus = WriteRegValueToAFile(pwisSection, hKey, pszSubKey,
                                   pszValueName, wValueType,
                                   pszValueNewName, fDefaultProvided, arglist);
    va_end(arglist);

    return fStatus;
}

// ----------------------------------------------------------------------
//
// Function:  WriteServiceRegValueToAFile
//
// Purpose:   Write specified value in registry to the specified section
//            in the answerfile, renaming if required
//
// Arguments:
//    pwisSection      [in]  section to which the value is written
//    hkey             [in]  handle to a regkey
//    pszSubKey        [in]  name of subkey
//    pszValueName     [in]  name of value
//    wValueType       [in]  type of value
//    pszValueNewName  [in]  change name to this
//    fDefaultProvided [in]  is a default value provided ?
//    arglist          [in]  use this default value if the specified value is
//                           not found in the registry
//
// Returns:   TRUE on success, FALSE otherwise
//
// Author:    kumarp 17-December-97
//
BOOL
WriteRegValueToAFile(
    IN PCWInfSection pwisSection,
    IN HKEY hKey,
    IN PCWSTR pszSubKey,
    IN PCWSTR pszValueName,
    IN WORD wValueType,
    IN PCWSTR pszValueNewName,
    IN BOOL fDefaultProvided,
    va_list arglist)
{
    CORegKey rk(hKey, pszSubKey);
    BOOL fKeyNotFound = (((HKEY) rk) == NULL);

    if (fKeyNotFound && !fDefaultProvided)
    {
        return FALSE;
    }
    else
    {
        //even if key is not found, we need to write the default value

        return WriteRegValueToAFile(pwisSection, rk, pszValueName, wValueType,
                                    pszValueNewName, fDefaultProvided, arglist);
    }
}

// ----------------------------------------------------------------------
//
// Function:  WriteServiceRegValueToAFile
//
// Purpose:   Write specified value in registry to the specified section
//            in the answerfile, renaming if required
//
// Arguments:
//    pwisSection      [in]  section to which the value is written
//    rk               [in]  regkey
//    pszValueName     [in]  name of value
//    wValueType       [in]  type of value
//    pszValueNewName  [in]  change name to this
//    fDefaultProvided [in]  is a default value provided ?
//    ...              [in]  use this default value if the specified value is
//                           not found in the registry
//
// Returns:   TRUE on success, FALSE otherwise
//
// Author:    kumarp 17-December-97
//
BOOL
WriteRegValueToAFile(
    IN PCWInfSection pwisSection,
    IN CORegKey& rk,
    IN PCWSTR pszValueName,
    IN WORD wValueType,
    IN PCWSTR pszValueNewName,
    IN BOOL fDefaultProvided,
    ...)
{
    BOOL fStatus;
    va_list arglist;

    va_start (arglist, fDefaultProvided);
    fStatus = WriteRegValueToAFile(pwisSection, rk,
                                   pszValueName, wValueType,
                                   pszValueNewName, fDefaultProvided, arglist);
    va_end(arglist);

    return fStatus;
}

// ----------------------------------------------------------------------
//
// Function:  WriteServiceRegValueToAFile
//
// Purpose:   Write specified value in registry to the specified section
//            in the answerfile, renaming if required
//
// Arguments:
//    pwisSection      [in]  section to which the value is written
//    rk               [in]  regkey
//    pszValueName     [in]  name of value
//    wValueType       [in]  type of value
//    pszValueNewName  [in]  change name to this
//    fDefaultProvided [in]  is a default value provided ?
//    arglist          [in]  use this default value if the specified value is
//                           not found in the registry
//
// Returns:   TRUE on success, FALSE otherwise
//
// Author:    kumarp 17-December-97
//
BOOL
WriteRegValueToAFile(
    IN PCWInfSection pwisSection,
    IN CORegKey& rk,
    IN PCWSTR pszValueName,
    IN WORD wValueType,
    IN PCWSTR pszValueNewName,
    IN BOOL fDefaultProvided,
    IN va_list arglist)
{
    if (!pwisSection)
    {
        return FALSE;
    }

    BOOL fValue, fDefault=FALSE;
    DWORD dwValue, dwDefault=0;
    PCWSTR pszValue, pszDefault=NULL;
    TStringList slValue;
    tstring strValue;

    if (pszValueNewName == NULL)
    {
        pszValueNewName = pszValueName;
    }

    if (fDefaultProvided)
    {
        switch (wValueType)
        {
        default:
            AssertSz(FALSE, "WriteRegValueToAFile: Invalid wValueType");
            break;

        case REG_SZ:
            pszDefault = va_arg(arglist, PCWSTR);
            break;

        case REG_HEX:
        case REG_DWORD:
            dwDefault =  va_arg(arglist, DWORD);
            break;

        case REG_BOOL:
            fDefault = va_arg(arglist, BOOL);
            break;

        }
    }

    LONG err;
    BOOL fStatus=FALSE;

    switch(wValueType)
    {
        default:
            AssertSz(FALSE, "WriteRegValueToAFile: Invalid wValueType");
            break;

        case REG_SZ:
            err = rk.QueryValue(pszValueName, strValue);
            if (err)
            {
                if (fDefaultProvided)
                {
                    pszValue = pszDefault;
                }
                else
                {
                    return FALSE;
                }
            }
            else
            {
                pszValue = strValue.c_str();
            }
            pwisSection->AddKey(pszValueNewName, pszValue);
            fStatus = TRUE;
            break;

        case REG_HEX:
        case REG_DWORD:
            err = rk.QueryValue(pszValueName, dwValue);
            if (err)
            {
                if (fDefaultProvided)
                {
                    dwValue = dwDefault;
                }
                else
                {
                    return FALSE;
                }
            }
            if (wValueType == REG_HEX)
            {
                pwisSection->AddHexKey(pszValueNewName, dwValue);
            }
            else
            {
                pwisSection->AddKey(pszValueNewName, dwValue);
            }
            fStatus = TRUE;
            break;

        case REG_BOOL:
            err = rk.QueryValue(pszValueName, dwValue);
            if (err)
            {
                if (fDefaultProvided)
                {
                    dwValue = fDefault;
                }
                else
                {
                    return FALSE;
                }
            }
            fValue = dwValue != 0;
            pwisSection->AddBoolKey(pszValueNewName, fValue);
            fStatus = TRUE;
            break;

        case REG_MULTI_SZ:
            err = rk.QueryValue(pszValueName, slValue);
            if (err)
            {
                // cant specify default for REG_MULTI_SZ, just return FALSE
                return FALSE;
            }
            pwisSection->AddKey(pszValueNewName, slValue);
            EraseAndDeleteAll(slValue);
            fStatus = TRUE;
            break;

        case REG_BINARY:
        {
            TByteArray ab;

            err = rk.QueryValue(pszValueName, ab);
            if (err)
            {
                // cant specify default for REG_BINARY, just return FALSE
                return FALSE;
            }

            ConvertToByteList(ab, strValue);

            pszValue = strValue.c_str();
            pwisSection->AddKey(pszValueNewName, pszValue);

            break;
        }
    }

    return fStatus;
}


// ----------------------------------------------------------------------
//
// Function:  GetBusTypeName
//
// Purpose:   Get name string for the specify bus-type
//
// Arguments:
//    eBusType [in]  bus type
//
// Returns:   name string for the bus-type
//
// Author:    kumarp 17-December-97
//
PCWSTR
GetBusTypeName (
    IN INTERFACE_TYPE eBusType)
{
    switch (eBusType)
    {
    case Internal:
        return c_szAfBusInternal;

    case Isa:
        return c_szAfBusIsa;

    case Eisa:
        return c_szAfBusEisa;

    case MicroChannel:
        return c_szAfBusMicrochannel;

    case TurboChannel:
        return c_szAfBusTurbochannel;

    case PCIBus:
        return c_szAfBusPci;

    case VMEBus:
        return c_szAfBusVme;

    case NuBus:
        return c_szAfBusNu;

    case PCMCIABus:
        return c_szAfBusPcmcia;

    case CBus:
        return c_szAfBusC;

    case MPIBus:
        return c_szAfBusMpi;

    case MPSABus:
        return c_szAfBusMpsa;

    case ProcessorInternal:
        return c_szAfBusProcessorinternal;

    case InternalPowerBus:
        return c_szAfBusInternalpower;

    case PNPISABus:
        return c_szAfBusPnpisa;

    default:
        return c_szAfUnknown;
    }
};


// ----------------------------------------------------------------------
//
// Function:  AddToNetCardDB
//
// Purpose:   Add the given adapter token to a list. This list is later
//            used to map token <--> drivername
//
// Arguments:
//    pszAdapterName   [in]  adapter token (e.g. Adapter01)
//    pszProductName   [in]  adapter ID (e.g. IEEPRO)
//    pszAdapterDriver [in]  instance ID (e.g. IEEPRO3)
//
// Returns:   None
//
// Author:    kumarp 17-December-97
//
void
AddToNetCardDB (
    IN PCWSTR pszAdapterName,
    IN PCWSTR pszProductName,
    IN PCWSTR pszAdapterDriver)
{
    Assert(pszAdapterName   && *pszAdapterName);
    Assert(pszProductName   && *pszProductName);
    Assert(pszAdapterDriver && *pszAdapterDriver);

    AddAtEndOfStringList(*g_pslNetCardAFileName, pszAdapterName);
    AddAtEndOfStringList(*g_pslNetCard, pszProductName);
    AddAtEndOfStringList(*g_pslNetCardInstance, pszAdapterDriver);
}

// ----------------------------------------------------------------------
//
// Function:  IsNetCardProductName
//
// Purpose:   Determine if the specified name represents an adapter
//
// Arguments:
//    pszName [in]  name of a component
//
// Returns:   TRUE on success, FALSE otherwise
//
// Author:    kumarp 17-December-97
//
BOOL
IsNetCardProductName (
    IN PCWSTR pszName)
{
    AssertValidReadPtr(pszName);

    return FIsInStringList(*g_pslNetCard, pszName);
}


// ----------------------------------------------------------------------
//
// Function:  IsNetCardInstance
//
// Purpose:   Determine if the specified instance represents an adapter
//
// Arguments:
//    pszName [in]  instance name of a component
//
// Returns:   TRUE on success, FALSE otherwise
//
// Author:    kumarp 17-December-97
//
BOOL
IsNetCardInstance(
    IN PCWSTR pszName)
{
    AssertValidReadPtr(pszName);

    return FIsInStringList(*g_pslNetCardInstance, pszName);
}

// ----------------------------------------------------------------------
//
// Function:  MapNetCardInstanceToAFileName
//
// Purpose:   Map netcard instance name to its answerfile token
//
// Arguments:
//    pszNetCardInstance  [in]  net card instance
//    strNetCardAFileName [out] answerfile token for that net card
//
// Returns:   None
//
// Author:    kumarp 17-December-97
//
VOID
MapNetCardInstanceToAFileName (
    IN PCWSTR pszNetCardInstance,
    OUT tstring& strNetCardAFileName)
{
    strNetCardAFileName = MapNetCardInstanceToAFileName(pszNetCardInstance);
}

// ----------------------------------------------------------------------
//
// Function:  MapNetCardInstanceToAFileName
//
// Purpose:   Map netcard instance name to its answerfile token
//
// Arguments:
//    pszNetCardInstance [in]  net card instance
//
// Returns:   answerfile token for that net card
//
// Author:    kumarp 17-December-97
//
PCWSTR
MapNetCardInstanceToAFileName (
    IN PCWSTR pszNetCardInstance)
{
    DefineFunctionName("MapNetCardInstanceToAFileName");

    Assert(pszNetCardInstance && *pszNetCardInstance);

    tstring strTemp;
    TStringListIter iter = g_pslNetCardInstance->begin();
    TStringListIter pos2;
    DWORD index=0;
    PCWSTR pszNetCardAFileName=NULL;

    while (iter != g_pslNetCardInstance->end())
    {
        strTemp = **iter++;
        if (0 == _wcsicmp(strTemp.c_str(), pszNetCardInstance))
        {
            pszNetCardAFileName = GetNthItem(*g_pslNetCardAFileName, index)->c_str();
            break;
        }
        index++;
    }

    if (!pszNetCardAFileName)
    {
        TraceTag(ttidError, "%s: Couldnt locate %S in g_pslNetCardAFileName",
                 __FUNCNAME__, pszNetCardInstance);
    }

    return pszNetCardAFileName;
}

// ----------------------------------------------------------------------
//
// Function:  GetServiceKey
//
// Purpose:   Get regkey object for the specified service
//
// Arguments:
//    pszServiceName [in]  name of service
//    prkService     [out] pointer to CORegKey object
//
// Returns:   TRUE on success, FALSE otherwise
//
// Author:    kumarp 17-December-97
//
BOOL
GetServiceKey (
    IN PCWSTR pszServiceName,
    OUT PCORegKey &prkService)
{
    DefineFunctionName("GetServiceKey");

    tstring strServiceFullName = tstring(c_szRegKeyServices) + L"\\" +
        pszServiceName;
    prkService = new CORegKey(HKEY_LOCAL_MACHINE, strServiceFullName.c_str());

    if(!prkService) 
    {
        return false;
    }

    if (!prkService->HKey())
    {
        delete prkService;
        prkService = NULL;
        TraceHr (ttidError, FAL,
                HRESULT_FROM_WIN32(ERROR_SERVICE_DOES_NOT_EXIST), FALSE,
                 "GetServiceKey for service %S", pszServiceName);
        return FALSE;
    }

    return TRUE;
}

// ----------------------------------------------------------------------
//
// Function:  GetServiceParamsKey
//
// Purpose:   Get regkey object for the Parameters subkey of the specified service
//
// Arguments:
//    pszServiceName   [in]  name of a service
//    prkServiceParams [out] pointer to CORegKey object
//
// Returns:   TRUE on success, FALSE otherwise
//
// Author:    kumarp 17-December-97
//
BOOL
GetServiceParamsKey (
    IN PCWSTR pszServiceName,
    OUT PCORegKey &prkServiceParams)
{
    return GetServiceSubkey(pszServiceName, c_szParameters, prkServiceParams);
}

// ----------------------------------------------------------------------
//
// Function:  GetServiceSubkey
//
// Purpose:   Get subkey of a service
//
// Arguments:
//    pszServiceName   [in]  name of service
//    pszSubKeyName    [in]  name of subkey
//    prkServiceSubkey [out] pointer to CORegKey object
//
// Returns:   TRUE on success, FALSE otherwise
//
// Author:    kumarp 17-December-97
//
BOOL
GetServiceSubkey (
    IN PCWSTR pszServiceName,
    IN PCWSTR pszSubKeyName,
    OUT PCORegKey &prkServiceSubkey)
{
    DefineFunctionName("GetServiceSubkey(PCWSTR pszServiceName, )");

    tstring strServiceSubkeyFullName = tstring(c_szRegKeyServices) + L"\\" +
    pszServiceName + L"\\" + pszSubKeyName;

    prkServiceSubkey = new CORegKey(HKEY_LOCAL_MACHINE, strServiceSubkeyFullName.c_str());

    if(!prkServiceSubkey)
    {
        return false;
    }

    if (!prkServiceSubkey->HKey())
    {
        delete prkServiceSubkey;
        prkServiceSubkey = NULL;
        TraceTag(ttidError, "%s: error opening service sub key for %S -- %S",
                 __FUNCNAME__, pszServiceName, pszServiceName);
        return FALSE;
    }

    return TRUE;
}

// ----------------------------------------------------------------------
//
// Function:  GetServiceSubkey
//
// Purpose:   Get subkey of a service
//
// Arguments:
//    prkService       [in]  service regkey
//    pszSubKeyName    [in]  name of subkey
//    prkServiceSubkey [out] pointer to CORegKey object
//
// Returns:   TRUE on success, FALSE otherwise
//
// Author:    kumarp 17-December-97
//
BOOL
GetServiceSubkey (
    IN const PCORegKey prkService,
    IN PCWSTR pszSubKeyName,
    OUT PCORegKey &prkServiceSubkey)
{
    DefineFunctionName("GetServiceSubkey(PCORegKey prkService, )");

    prkServiceSubkey = new CORegKey(*prkService, pszSubKeyName);

    if(!prkServiceSubkey)
    {
        return false;
    }

    if (!prkServiceSubkey->HKey())
    {
        delete prkServiceSubkey;
        prkServiceSubkey = NULL;
        TraceWin32FunctionError(ERROR_SERVICE_DOES_NOT_EXIST);
        return FALSE;
    }

    return TRUE;
}

#pragma BEGIN_CONST_SECTION
static const PCWSTR c_aszComponentsToIgnore[] =
{
    // These are installed automatically when TCPIP is installed
    // and has no user settable parameters of its own
    //
    L"NetBT",
    L"TcpipCU",
    L"Wins",

    // This is installed automatically when RAS is installed
    // and has no user settable parameters of its own
    //
    L"NdisWan",

    // Parameters of RAS are under Software\Microsoft\RAS
    // and not under the service key as with other net components
    //
    L"RASPPTPE",
    L"RASPPTPM",
    L"RasAuto",
    L"RemoteAccess",
    L"Router",

    // These are installed automatically when MS_IPX is installed
    // and has no user settable parameters of its own
    //
    L"NwlnkNb",
    L"NwlnkSpx",

    // This is installed automatically when MS_MSClient is installed
    // and has no user settable parameters of its own
    //
    L"RpcBanyan",

    // we dont install this using answer-file
    //
    L"Inetsrv",
    L"DFS",

    // this will be cleaned up by the IIS setup guys.
    // contact "Linan Tong" if you have any questions:
    //
    L"FTPD",

    // these are installed when SFM is installed
    //
    L"MacPrint",
    L"MacFile",

    // pre-sp3 SteelHead components
    //
    L"NwSapAgent",
    L"IPRIP",
    L"NWLNKRIP",
    L"RelayAgent",
};
#pragma END_CONST_SECTION


// ----------------------------------------------------------------------
//
// Function:  ShouldIgnoreComponent
//
// Purpose:   Determine if a components should be ignored when
//            writing parameters to answerfile
//
// Arguments:
//    pszComponentName [in]  name of component
//
// Returns:   TRUE on success, FALSE otherwise
//
// Author:    kumarp 17-December-97
//
BOOL
ShouldIgnoreComponent (
    IN PCWSTR pszComponentName)
{
    BOOL fRet=TRUE;

    DefineFunctionName("ShouldIgnoreComponent");
    TraceFunctionEntry(ttidNetUpgrade);

    TraceTag(ttidNetUpgrade, "%s: Checking if %S should be ignored.",
             __FUNCNAME__, pszComponentName);

    fRet = !FIsInStringArray(c_aszComponentsToIgnore,
                             celems(c_aszComponentsToIgnore),
                             pszComponentName) &&
        (!FIsOptionalComponent(pszComponentName) ||
         // even though DHCPServer is an optional component,
         // we need to treat it differently and thus must write its
         // parameters
         !lstrcmpiW(pszComponentName, c_szSvcDhcpServer));

    // If none of the above net components then, check if it is DLC.

    if ( fRet == TRUE )
    {
        if ( lstrcmpiW(pszComponentName, sz_DLC) == 0 )
        {
           return ShouldRemoveDLC( NULL, NULL );
        }
    }

    return !fRet;
}

// ----------------------------------------------------------------------
//
// Function:  StringListsIntersect
//
// Purpose:   Determine if at least one item of sl1 matches with
//            at least one item of sl2
//
// Arguments:
//    sl1 [in]  list 1
//    sl2 [in]  list 2
//
// Returns:   TRUE on success, FALSE otherwise
//
// Author:    kumarp 17-December-97
//
BOOL
StringListsIntersect (
    IN const TStringList& sl1,
    IN const TStringList& sl2)
{
    if ((sl1.size() == 0) || (sl2.size() == 0))
        return FALSE;

    tstring s1, s2;
    TStringListIter pos1, pos2;

    pos1 = sl1.begin();
    while (pos1 != sl1.end())
    {
        s1 = **pos1++;
        pos2 = sl2.begin();
        while (pos2 != sl2.end())
        {
            s2 = **pos2++;
            if (s1 == s2)
            {
                return TRUE;
            }
        }
    }

    return FALSE;
}

// ----------------------------------------------------------------------
//
// Function:  ConvertToQWord
//
// Purpose:   Convert a size 8 byte array to a qword
//
// Arguments:
//    ab [in]  byte array
//
// Returns:
//
// Author:    kumarp 17-December-97
//
QWORD
ConvertToQWord (
    IN TByteArray ab)
{
    Assert(ab.size() == 8);

    QWORD qwRet = 0;
    WORD wShiftBy=0;
    for (int i=0; i<8; i++)
    {
        qwRet |= ((QWORD) ab[i]) << wShiftBy;
        wShiftBy += 8;
    }

    return qwRet;
}


// ----------------------------------------------------------------------
//
// Function:  ConvertToByteList
//
// Purpose:   Convert TByteArray to comma-separated byte list
//
// Arguments:
//    ab [in]  byte array
//
// Returns:
//
// Author:    kyrilf 2-April-99
//
VOID
ConvertToByteList (
    IN TByteArray ab,
    OUT tstring& str)
{
    WCHAR    byte [3];
    DWORD    size = ab.size();

    for (DWORD i=0; i < size; i++)
    {
        swprintf(byte, L"%0.2X", ab[i]);

        str += byte;

        if (i == size - 1)
            break;
        else
            str += ',';
    }
}

// ----------------------------------------------------------------------
//
// Function:  ReplaceCharsInString
//
// Purpose:   Replace all occurrances of chFindChar in the specified string
//            by chReplaceWith charater
//
// Arguments:
//    pszString      [in]  string
//    pszFindChars   [in]  set of chars to find
//    chReplaceWith [in]  char to replace with
//
// Returns:   None
//
// Author:    kumarp 17-December-97
//
void
ReplaceCharsInString (
    IN OUT PWSTR pszString,
    IN PCWSTR pszFindChars,
    IN WCHAR chReplaceWith)
{
    UINT uLen = wcslen(pszString);
    UINT uPos;

    while ((uPos = wcscspn(pszString, pszFindChars)) < uLen)
    {
        pszString[uPos] = chReplaceWith;
        pszString += uPos + 1;
        uLen -= uPos + 1;
    }
}

// ----------------------------------------------------------------------
//
// Function:  HrNetRegSaveKey
//
// Purpose:   Save the entire specified registry tree to a file
//
// Arguments:
//    hkeyBase     [in]  handle of base key
//    pszSubKey     [in]  name of subkey
//    pszComponent  [in]  file name prefix to use
//    pstrFileName [out] name of file written
//
// Returns:   S_OK on success, otherwise an error code
//
// Author:    kumarp 17-December-97
//
HRESULT
HrNetRegSaveKey (
    IN HKEY hkeyBase,
    IN PCWSTR pszSubKey,
    IN PCWSTR pszComponent,
    OUT tstring* pstrFileName)
{
    DefineFunctionName("HrNetRegSaveKey");

    Assert(hkeyBase);
    AssertValidReadPtr(pszComponent);
    AssertValidWritePtr(pstrFileName);

    HRESULT hr;
    HKEY hkey;

    hr = HrRegOpenKeyEx(hkeyBase, pszSubKey, KEY_READ, &hkey);

    if (S_OK == hr)
    {
        tstring strFileName;
        strFileName = pszComponent;
        if (pszSubKey)
        {
            AssertValidReadPtr(pszSubKey);

            strFileName += L"-";
            strFileName += pszSubKey;
            ReplaceCharsInString((PWSTR) strFileName.c_str(), L"\\/", '-');
        }
        strFileName += L".reg";

        tstring strFullPath;

        hr = HrGetNetUpgradeTempDir(&strFullPath);
        if (S_OK == hr)
        {
            strFullPath += strFileName;

            TraceTag(ttidNetUpgrade, "%s: dumping key %S to file %S",
                     __FUNCNAME__, pszSubKey ? pszSubKey : L"", strFullPath.c_str());

            DeleteFile(strFullPath.c_str());

            extern LONG EnableAllPrivileges ( VOID );
            EnableAllPrivileges();

            DWORD err = ::RegSaveKey(hkey, strFullPath.c_str(), NULL);
            if (err == ERROR_SUCCESS)
            {
                *pstrFileName = strFullPath;
                hr = S_OK;
            }
            else
            {
                hr = HrFromLastWin32Error();
            }
        }

        RegCloseKey(hkey);
    }

    TraceErrorOptional(__FUNCNAME__, hr,
                       (hr == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND)));

    return hr;
}

// ----------------------------------------------------------------------
//
// Function:  HrNetRegSaveKeyAndAddToSection
//
// Purpose:   Save the entire specified registry tree to a file and
//            add a key in the specified section to indicate where
//            this file is located
//
// Arguments:
//    hkeyBase     [in]  handle of base key
//    pszSubKey     [in]  name of subkey
//    pszComponent  [in]  file name prefix to use
//    pszKeyName    [in]  name of key to write
//    pwisSection  [in]  section to write to
//
// Returns:   S_OK on success, otherwise an error code
//
// Author:    kumarp 17-December-97
//
HRESULT
HrNetRegSaveKeyAndAddToSection (
    IN HKEY hkeyBase,
    IN PCWSTR pszSubKey,
    IN PCWSTR pszComponent,
    IN PCWSTR pszKeyName,
    IN CWInfSection* pwisSection)
{
    DefineFunctionName("HrNetRegSaveKeyAndAddToSection");

    Assert(hkeyBase);
    AssertValidReadPtr(pszComponent);
    AssertValidReadPtr(pszKeyName);
    AssertValidReadPtr(pwisSection);

    HRESULT hr;
    tstring strFileName;

    hr = HrNetRegSaveKey(hkeyBase, pszSubKey, pszComponent, &strFileName);
    if (SUCCEEDED(hr))
    {
        pwisSection->AddKey(pszKeyName, strFileName.c_str());
    }

    if (S_OK != hr)
    {
        TraceTag(ttidNetUpgrade, "%s: failed for %S in [%S] -- %S: hr: 0x%08X",
                 __FUNCNAME__, pszKeyName, pwisSection->Name(), pszSubKey, hr);
    }

    return hr;
}

// ----------------------------------------------------------------------
//
// Function:  HrNetRegSaveKeyAndAddToSection
//
// Purpose:   Save the entire specified registry tree to a file and
//            add a key in the specified section to indicate where
//            this file is located
//
// Arguments:
//    pszServiceName [in]  name of service
//    pszSubKey      [in]  name of subkey
//    pszKeyName     [in]  name of key to write
//    pwisSection   [in]  section to write to
//
// Returns:   S_OK on success, otherwise an error code
//
// Author:    kumarp 17-December-97
//
HRESULT
HrNetRegSaveServiceSubKeyAndAddToSection (
    IN PCWSTR pszServiceName,
    IN PCWSTR pszServiceSubKeyName,
    IN PCWSTR pszKeyName,
    IN CWInfSection* pwisSection)
{
    AssertValidReadPtr(pszServiceName);
    AssertValidReadPtr(pszKeyName);
    AssertValidWritePtr(pwisSection);

    HRESULT hr;
    tstring strServiceSubKey = c_szRegKeyServices;

    strServiceSubKey += L"\\";
    strServiceSubKey += pszServiceName;
    if (pszServiceSubKeyName)
    {
        strServiceSubKey += L"\\";
        strServiceSubKey += pszServiceSubKeyName;
    }

    // we ignore the return code
    hr = HrNetRegSaveKeyAndAddToSection(HKEY_LOCAL_MACHINE,
                                        strServiceSubKey.c_str(),
                                        pszServiceName,
                                        pszKeyName, pwisSection);

    return hr;
}

// ----------------------------------------------------------------------
//
// Function:  HrProcessOemComponentAndUpdateAfSection
//
// Purpose:   Process the specified OEM component in the following steps:
//            - Load an OEM DLL
//            - call PreUpgradeInitialize once
//            - call DoPreUpgradeProcessing
//            - if the above steps are successful,
//              add the right sections in the answerfile
//
// Arguments:
//    pnmi             [in]  pointer to CNetMapInfo object
//    hParentWindow    [in]  handle of parent window
//    hkeyParams       [in]  handle of Parameters registry key
//    pszPreNT5InfId    [in]  pre-NT5 InfID of a component (e.g. IEEPRO)
//    pszPreNT5Instance [in]  pre-NT5 instance of a component (e.g. IEEPRO2)
//    pszNT5InfId       [in]  NT5 InfID of the component
//    pszDescription    [in]  description of the component
//    pwisParams       [in]  pointer to params section of this component
//
// Returns:   S_OK on success, otherwise an error code
//
// Author:    kumarp 13-May-98
//
HRESULT HrProcessOemComponentAndUpdateAfSection(
    IN  CNetMapInfo* pnmi,
    IN  HWND      hParentWindow,
    IN  HKEY      hkeyParams,
    IN  PCWSTR   pszPreNT5InfId,
    IN  PCWSTR   pszPreNT5Instance,
    IN  PCWSTR   pszNT5InfId,
    IN  PCWSTR   pszDescription,
    IN  CWInfSection* pwisParams)
{
    AssertValidReadPtr(pnmi);
    //Assert(hParentWindow);
    Assert(hkeyParams);
    AssertValidReadPtr(pszPreNT5InfId);
    AssertValidReadPtr(pszPreNT5Instance);
    AssertValidReadPtr(pszNT5InfId);
    AssertValidReadPtr(pszDescription);
    AssertValidReadPtr(pwisParams);

    DefineFunctionName("HrProcessOemComponentAndUpdateAfSection");

    HRESULT hr;
    tstring strOemSectionName;
    DWORD dwFlags = 0;
    PCWSTR pszOemSection;

    TraceTag(ttidNetUpgrade, "%s: Component %S (%S) is an OEM component",
             __FUNCNAME__, pszDescription, pszPreNT5Instance);

    strOemSectionName = pwisParams->Name();
    strOemSectionName += L".";
    strOemSectionName += c_szAfOemSection;
    pszOemSection = strOemSectionName.c_str();

    hr = HrProcessOemComponent(pnmi, &g_NetUpgradeInfo,
                               hParentWindow,
                               hkeyParams,
                               pszPreNT5InfId,
                               pszPreNT5Instance,
                               pszNT5InfId,
                               pszDescription,
                               pszOemSection,
                               &dwFlags);

    if (S_OK == hr)
    {
        tstring strOemInf;

        pwisParams->AddKey(c_szAfOemSection, pszOemSection);

        AssertSz(!pnmi->m_strOemDir.empty(), "Did not get OemDir!!");

        pwisParams->AddKey(c_szAfOemDir, pnmi->m_strOemDir.c_str());

        hr = pnmi->HrGetOemInfName(pszNT5InfId, &strOemInf);
        if (S_OK == hr)
        {
            pwisParams->AddKey(c_szAfOemInf, strOemInf.c_str());
        }

        if (dwFlags & NUA_LOAD_POST_UPGRADE)
        {
            pwisParams->AddKey(c_szAfOemDllToLoad,
                               pnmi->m_strOemDllName.c_str());
        }

        // currently the SkipInstall feature is used only by
        // SNA and MS_NetBios for their peculiar upgrade requirements.
        // This may or may not become a documented feature.
        //
        if (dwFlags & NUA_SKIP_INSTALL_IN_GUI_MODE)
        {
            pwisParams->AddBoolKey(c_szAfSkipInstall, TRUE);
        }
    }

    TraceError(__FUNCNAME__, hr);

    return hr;
}


/*******************************************************************

    NAME:       EnableAllPrivileges

    SYNOPSIS:   Enxable all privileges on the current process token.  This
                is used just prior to attempting to shut down the system.

    ENTRY:      Nothing

    EXIT:       Nothing

    RETURNS:    LONG error code

    NOTES:

    HISTORY:

********************************************************************/

LONG EnableAllPrivileges ( VOID )
{
    HANDLE Token = NULL ;
    ULONG ReturnLength = 4096,
          Index ;
    PTOKEN_PRIVILEGES NewState = NULL ;
    BOOL Result = FALSE ;
    LONG Error = 0 ;

    do
    {
        Result = OpenProcessToken( GetCurrentProcess(),
                                   TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
                                   & Token ) ;
        if (! Result)
        {
           Error = GetLastError() ;
           break;
        }

        Result = (NewState = (PTOKEN_PRIVILEGES) MemAlloc( ReturnLength )) != NULL ;

        if (! Result)
        {
           Error = ERROR_NOT_ENOUGH_MEMORY ;
           break;
        }

        Result = GetTokenInformation( Token,            // TokenHandle
                                      TokenPrivileges,  // TokenInformationClass
                                      NewState,         // TokenInformation
                                      ReturnLength,     // TokenInformationLength
                                      &ReturnLength     // ReturnLength
                                     );
        if (! Result)
        {
           Error = GetLastError() ;
           break;
        }

        //
        // Set the state settings so that all privileges are enabled...
        //

        if ( NewState->PrivilegeCount > 0 )
        {
                for (Index = 0; Index < NewState->PrivilegeCount; Index++ )
            {
                NewState->Privileges[Index].Attributes = SE_PRIVILEGE_ENABLED ;
            }
        }

        Result = AdjustTokenPrivileges( Token,          // TokenHandle
                                        FALSE,          // DisableAllPrivileges
                                        NewState,       // NewState (OPTIONAL)
                                        ReturnLength,   // BufferLength
                                        NULL,           // PreviousState (OPTIONAL)
                                        &ReturnLength   // ReturnLength
                                      );

        if (! Result)
        {
           Error = GetLastError() ;
           break;
        }
    }
    while ( FALSE ) ;

    if ( Token != NULL )
        CloseHandle( Token );

    MemFree( NewState ) ;

    return Result ? Error : 0 ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\upgrade\netupgrd\infmap.cpp ===
// ----------------------------------------------------------------------
//
//  Microsoft Windows NT
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:      I N F M A P . C P P
//
//  Contents:  Functions that work on netmap.inf file.
//
//  Notes:
//
//  Author:    kumarp 22-December-97
//
// ----------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

#include "infmap.h"
#include "kkcwinf.h"
#include "kkutils.h"
#include "ncreg.h"
#include "ncsetup.h"
#include "netupgrd.h"
#include "nustrs.h"
#include "nuutils.h"
#include "oemupg.h"


extern const WCHAR c_szNetUpgradeDll[];

// -----------------------------------------------------------------
// Structure of netmap.inf file
//
// We use netmap.inf file to map pre-NT5 InfID of a netcard to its
// NT5 InfID (PnPID).
//
// This file has a number of top-level sections.
// Each top-level section holds entries for mapping netcards of a particular
// bus type. the format of each line is
//
// <pre-NT5 InfID>=<NT5 InfID>
// OR
// <pre-NT5 InfID>=<mapping-method-#>,<section-name>
//
// the former is a 1-1 mapping while the latter offers a way to map a single
// preNT5 InfID to multiple InfIDs
//
//  Mapping method 0
//  ----------------
//  This method is used when a single pre-NT5 InfID represents more than one
//  net card which means that a single pre-NT5 InfID is mapped onto many
//  NT5 PnPIDs. The only way to differentiate between the different types of
//  net cards is to inspect a single value under the parameters key.
//
//  In this mapping method, two keys are required to be specified for
//  each net card.
//  - ValueName: this specifies the value to be inspected under the Parameters key
//  - ValueType: this specifies the type of ValueName
//
//  there can be any number of additional keys in this section.
//  each such line is of the form
//  <NT5 InfID>=<some value of type ValueType>
//
//  we first find out the value of ValueName
//  then we enumerate each key in this section to see if the value matches the
//  value of any of the keys.
//  if we find a match, then the name of the found key represents <NT5 InfID>
//
//  e.g.
//  5 flavors of the ELNK3MCA card are represented by the same InfID in NT4
//  the only way to distinguish between them is to inspect the McaPosId value
//  for this card we have the mapping section defined as follows:
//
//  [McaAdapters]
//  ELNK3MCA    = 0,ELNK3MCA   ; 0 --> mapping method 0
//  ... other mca card entries ...
//
//  [ELNK3MCA]
//  ValueName= McaPosId
//  ValueType= 4             ; REG_DWORD
//  mca_627c = 0x0000627c    ; if value of McaPosId is 0x627c then PnPID == mca_627c
//  mca_627d = 0x0000627d
//  mca_61db = 0x000061db
//  mca_62f6 = 0x000062f6
//  mca_62f7 = 0x000062f7
//
//  Note: a special keyword "ValueNotPresent" can be used to make a mapping
//        for the case when a value is not present.

// List of sections that can appear in the netmap.inf
//
const WCHAR c_szIsaAdapters[]    = L"IsaAdapters";
const WCHAR c_szEisaAdapters[]   = L"EisaAdapters";
const WCHAR c_szPciAdapters[]    = L"PciAdapters";
const WCHAR c_szMcaAdapters[]    = L"McaAdapters";
const WCHAR c_szPcmciaAdapters[] = L"PcmciaAdapters";
const WCHAR c_szOemNetAdapters[] = L"OemNetAdapters";
const WCHAR c_szAsyncAdapters[]  = L"AsyncAdapters";
const WCHAR c_szOemAsyncAdapters[]  = L"OemAsyncAdapters";

static PCWSTR g_aszInfMapNetCardSections[] =
{
    c_szIsaAdapters,
    c_szEisaAdapters,
    c_szPciAdapters,
    c_szMcaAdapters,
    c_szPcmciaAdapters,
    c_szOemNetAdapters,
    c_szAsyncAdapters,
    c_szOemAsyncAdapters
};
const BYTE g_cNumNetCardSections = celems(g_aszInfMapNetCardSections);


const WCHAR c_szNetProtocols[]    = L"NetProtocols";
const WCHAR c_szOemNetProtocols[] = L"OemNetProtocols";
const WCHAR c_szNetServices[]     = L"NetServices";
const WCHAR c_szOemNetServices[]  = L"OemNetServices";
const WCHAR c_szNetClients[]      = L"NetClients";
const WCHAR c_szOemNetClients[]   = L"OemNetClients";

const WCHAR c_szOemUpgradeSupport[] = L"OemUpgradeSupport";

// value in netmap.inf indicating the absence of a value in the registry
//
const WCHAR c_szValueNotPresent[] = L"ValueNotPresent";

// ----------------------------------------------------------------------
// prototypes
//
HRESULT HrMapPreNT5InfIdToNT5InfIdInSection(IN  HINF     hinf,
                                            IN  HKEY     hkeyAdapterParams,
                                            IN  PCWSTR  pszSectionName,
                                            IN  PCWSTR  pszPreNT5InfId,
                                            OUT tstring* pstrNT5InfId,
                                            OUT BOOL*    pfOemComponent);

HRESULT HrMapPreNT5InfIdToNT5InfIdUsingMethod0(IN HKEY hkeyAdapterParams,
                                               IN HINF hInf,
                                               IN PCWSTR pszAdapterSection,
                                               OUT tstring* pstrNT5InfId);
HRESULT HrSetupFindKeyWithStringValue(IN  HINF     hInf,
                                      IN  PCWSTR  pszSection,
                                      IN  PCWSTR  pszValue,
                                      OUT tstring* pstrKey);
// ----------------------------------------------------------------------

#pragma BEGIN_CONST_SECTION

const WCHAR c_szNetMapInf[] = L"netmap.inf";
const WCHAR c_szKeyValueName[] = L"ValueName";
const WCHAR c_szKeyValueType[] = L"ValueType";

const WCHAR c_szInfId_MS_ATMUNI[] = L"MS_ATMUNI";
const WCHAR c_szInfId_MS_ATMARPS[] = L"MS_ATMARPS";

#pragma END_CONST_SECTION

//+---------------------------------------------------------------------------
//
// Function:  HrMapPreNT5NetCardInfIdInInf
//
//  Purpose:  Maps using hinf, pre-NT5 InfID of a net card to its NT5 equivalent
//
//  Arguments:
//    hinf              [in]  handle of netmap.inf file
//    hkeyAdapterParams [in]  handle to Parameters key under the netcard driver key
//    pszPreNT5InfId     [in]  pre-NT5 InfID
//    pstrNT5InfId      [out] NT5 InfID
//    pstrAdapterType   [out] section in which the map was found
//    pfOemComponent    [out] set to TRUE if it is an OEM card
//
//  Returns:    S_OK if found, S_FALSE if not,
//              otherwise HRESULT_FROM_WIN32 error code.
//
//  Author:     kumarp    24-July-97
//
//  Notes:
//
HRESULT HrMapPreNT5NetCardInfIdInInf(IN  HINF     hinf,
                                     IN  HKEY     hkeyAdapterParams,
                                     IN  PCWSTR  pszPreNT5InfId,
                                     OUT tstring* pstrNT5InfId,
                                     OUT tstring* pstrAdapterType,
                                     OUT BOOL*    pfOemComponent)
{
    DefineFunctionName("HrMapPreNT5InfIdToNT5InfId");

    Assert(hinf);
    Assert(hkeyAdapterParams);
    AssertValidReadPtr(pszPreNT5InfId);
    AssertValidWritePtr(pstrNT5InfId);
    AssertValidWritePtr(pfOemComponent);

    HRESULT hr=S_FALSE;
    PCWSTR pszSectionName;

    for (int iSection=0; iSection < g_cNumNetCardSections; iSection++)
    {
        pszSectionName = g_aszInfMapNetCardSections[iSection];
        hr = HrMapPreNT5InfIdToNT5InfIdInSection(hinf, hkeyAdapterParams,
                                                 pszSectionName,
                                                 pszPreNT5InfId, pstrNT5InfId,
                                                 pfOemComponent);
        if (hr == S_OK)
        {

            if (pstrAdapterType)
            {
                *pstrAdapterType = pszSectionName;
            }

            if (!lstrcmpiW(pszSectionName, c_szOemNetAdapters) ||
                !lstrcmpiW(pszSectionName, c_szAsyncAdapters) ||
                !lstrcmpiW(pszSectionName, c_szOemAsyncAdapters))
            {
                *pfOemComponent = TRUE;
            }
            else
            {
                *pfOemComponent = FALSE;
            }
            break;
        }
    }

    TraceErrorOptional(__FUNCNAME__, hr, (hr == S_FALSE));

    return hr;
}

//+---------------------------------------------------------------------------
//
// Function:  HrMapPreNT5NetCardInfIdToNT5InfId
//
// Purpose:  Maps pre-NT5 InfID of a net card to its NT5 equivalent
//
// Arguments:
//    hkeyAdapterParams [in]  handle to Parameters key under the netcard driver key
//    pszPreNT5InfId     [in]  pre-NT5 InfID
//    pstrNT5InfId      [out] NT5 InfID
//    pstrAdapterType   [out] section in which the map was found
//    pfOemComponent    [out] set to TRUE if it is an OEM card
//    ppnmi             [out] CNetMapInfo object representing the map found
//
// Returns:    S_OK if found, S_FALSE if not,
//             otherwise HRESULT_FROM_WIN32 error code.
//
// Author:     kumarp    24-July-97
//
// Notes:
//
HRESULT HrMapPreNT5NetCardInfIdToNT5InfId(IN  HKEY     hkeyAdapterParams,
                                          IN  PCWSTR  pszPreNT5InfId,
                                          OUT tstring* pstrNT5InfId,
                                          OUT tstring* pstrAdapterType,
                                          OUT BOOL*    pfOemComponent,
                                          OUT CNetMapInfo** ppnmi)
{
    DefineFunctionName("HrMapPreNT5NetCardInfIdToNT5InfId");

    Assert(hkeyAdapterParams);
    AssertValidReadPtr(pszPreNT5InfId);
    AssertValidWritePtr(pstrNT5InfId);
    AssertValidWritePtr(pstrAdapterType);
    AssertValidWritePtr(pfOemComponent);
    AssertValidReadPtr(g_pnmaNetMap);

    HRESULT hr=E_FAIL;

    TraceTag(ttidNetUpgrade, "finding mapping for %S...", pszPreNT5InfId);

    if (g_pnmaNetMap)
    {
        CNetMapInfo* pnmi;
        size_t cNumNetMapEntries = g_pnmaNetMap->size();

        for (size_t i = 0; i < cNumNetMapEntries; i++)
        {
            pnmi = (CNetMapInfo*) (*g_pnmaNetMap)[i];

            hr = HrMapPreNT5NetCardInfIdInInf(pnmi->m_hinfNetMap,
                                              hkeyAdapterParams,
                                              pszPreNT5InfId,
                                              pstrNT5InfId,
                                              pstrAdapterType,
                                              pfOemComponent);
            if (S_OK == hr)
            {
                if (ppnmi)
                {
                    *ppnmi = pnmi;
                }

                TraceTag(ttidNetUpgrade, "%s: %S --> %S (type: %S)", __FUNCNAME__,
                         pszPreNT5InfId, pstrNT5InfId->c_str(),
                         pstrAdapterType->c_str());
                break;
            }
        }
    }

    TraceErrorOptional(__FUNCNAME__, hr, (hr == S_FALSE));

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrMapPreNT5InfIdToNT5InfIdInSection
//
//  Purpose:    Searches in szSectionName section to
//              map pre-NT5 InfID of a net card to its NT5 equivalent
//
//  Arguments:
//    hinf              [in]  handle of netmap.inf file
//    hkeyAdapterParams [in]  handle to Parameters key under the netcard driver key
//    pszSectionName     [in]  name of section to search
//    pszPreNT5InfId     [in]  pre-NT5 InfID
//    pstrNT5InfId      [out] NT5 InfID
//    pfOemComponent    [out] set to TRUE if it is an OEM card
//
//  Returns:    S_OK if found, S_FALSE if not,
//              otherwise HRESULT_FROM_WIN32 error code.
//
//  Author:     kumarp    24-July-97
//
//  Notes:
//
HRESULT HrMapPreNT5InfIdToNT5InfIdInSection(IN  HINF     hinf,
                                            IN  HKEY     hkeyAdapterParams,
                                            IN  PCWSTR  pszSectionName,
                                            IN  PCWSTR  pszPreNT5InfId,
                                            OUT tstring* pstrNT5InfId,
                                            OUT BOOL*    pfOemComponent)

{
    DefineFunctionName("HrMapPreNT5InfIdToNT5InfIdInSection");

    Assert(hinf);
    AssertValidReadPtr(pszSectionName);
    AssertValidReadPtr(pszPreNT5InfId);
    AssertValidWritePtr(pstrNT5InfId);

    HRESULT hr=S_FALSE;
    INFCONTEXT ic;

    hr = HrSetupFindFirstLine(hinf, pszSectionName, pszPreNT5InfId, &ic);

    if (SUCCEEDED(hr))
    {
        DWORD dwMappingMethod=-1;

        // key found, get value

        // we do not use the common function HrSetupGetIntField because it causes
        // tons of TraceError messages for 1-1 mapping where the first value
        // is not an integer
        if (::SetupGetIntField(&ic, 1, (int*) &dwMappingMethod))
        {
            // value begins with a number --> this is a special case mapping
            //
            if (dwMappingMethod == 0)
            {
                // use mapping method 0
                Assert(hkeyAdapterParams);

                tstring strAdapterSection;
                hr = HrSetupGetStringField(ic, 2, &strAdapterSection);

                if (S_OK == hr)
                {
                    hr = HrMapPreNT5InfIdToNT5InfIdUsingMethod0(hkeyAdapterParams,
                            hinf, strAdapterSection.c_str(), pstrNT5InfId);
                }
            }
            else
            {
                // currently we support only mapping-method 0
                //
                hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
            }
        }
        else
        {
            // the first field was not an integer which means
            // this is a straight forward (1 to 1) mapping
            //
            hr = HrSetupGetStringField(ic, 1, pstrNT5InfId);
        }
    }

    if (HRESULT_FROM_SETUPAPI(ERROR_LINE_NOT_FOUND) == hr)
    {
        hr = S_FALSE;
    }

    TraceErrorOptional(__FUNCNAME__, hr, (hr == S_FALSE));

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrMapPreNT5InfIdToNT5InfIdUsingMethod0
//
//  Purpose:    map pre-NT5 InfID of a net card to its NT5 equivalent
//              using mapping method 0
//
//  Arguments:
//    hkeyAdapterParams [in]  handle to Parameters key under the netcard driver key
//    hInf              [in]  handle of netmap.inf
//    pszSectionName     [in]  name of section to search
//    pstrNT5InfId      [out] NT5 InfID
//
//  Returns:    S_OK if found, S_FALSE if not, otherwise HRESULT_FROM_WIN32 error code.
//
//  Author:     kumarp    24-July-97
//
//  Notes:
//
//  Mapping method 0
//  ----------------
//  This method is used when a single pre-NT5 InfID represents more than one
//  net card which means that a single pre-NT5 InfID is mapped onto many
//  NT5 PnPIDs. The only way to differentiate between the different types of
//  net cards is to inspect a single value under the parameters key.
//
//  In this mapping method, two keys are required to be specified for
//  each net card.
//  - ValueName: this specifies the value to be inspected under the Parameters key
//  - ValueType: this specifies the type of ValueName
//
//  there can be any number of additional keys in this section.
//  each such line is of the form
//  <NT5 InfID>=<some value of type ValueType>
//
//  we first find out the value of ValueName
//  then we enumerate each key in this section to see if the value matches the
//  value of any of the keys.
//  if we find a match, then the name of the found key represents <NT5 InfID>
//
//  e.g.
//  5 flavors of the ELNK3MCA card are represented by the same InfID in NT4
//  the only way to distinguish between them is to inspect the McaPosId value
//  for this card we have the mapping section defined as follows:
//
//  [McaAdapters]
//  ELNK3MCA    = 0,ELNK3MCA   ; 0 --> mapping method 0
//  ... other mca card entries ...
//
//  [ELNK3MCA]
//  ValueName= McaPosId
//  ValueType= 4             ; REG_DWORD
//  mca_627c = 0x0000627c    ; if value of McaPosId is 0x627c then PnPID == mca_627c
//  mca_627d = 0x0000627d
//  mca_61db = 0x000061db
//  mca_62f6 = 0x000062f6
//  mca_62f7 = 0x000062f7
//
//  Note: a special keyword "ValueNotPresent" can be used to make a mapping
//        for the case when a value is not present.
//
HRESULT HrMapPreNT5InfIdToNT5InfIdUsingMethod0(IN HKEY hkeyAdapterParams,
                                               IN HINF hInf,
                                               IN PCWSTR pszAdapterSection,
                                               OUT tstring* pstrNT5InfId)
{
    DefineFunctionName("HrMapPreNT5InfIdToNT5InfIdUsingMethod0");
    Assert(hkeyAdapterParams);
    Assert(hInf);
    AssertValidReadPtr(pszAdapterSection);
    AssertValidWritePtr(pstrNT5InfId);

    HRESULT hr=S_FALSE;

    INFCONTEXT ic;
    tstring strValueName;

    // get ValueName
    hr = HrSetupGetFirstString(hInf, pszAdapterSection,
                               c_szKeyValueName, &strValueName);
    if (SUCCEEDED(hr))
    {
        DWORD dwRegValue=0;
        DWORD dwInfValue=0;
        DWORD dwValueType;
        tstring strRegValue;
        tstring strInfValue;
        tstring strValue;

        // get ValueType
        hr = HrSetupGetFirstDword(hInf, pszAdapterSection,
                                  c_szKeyValueType, &dwValueType);

        if (SUCCEEDED(hr))
        {
            switch (dwValueType)
            {
            case REG_DWORD:
                // find the value in under adapter driver parameters key
                //
                hr = HrRegQueryDword(hkeyAdapterParams,
                                     strValueName.c_str(), &dwRegValue);
                if (SUCCEEDED(hr))
                {
                    // goto the ValueType line
                    hr = HrSetupFindFirstLine(hInf, pszAdapterSection,
                                              c_szKeyValueType, &ic);
                    if (S_OK == hr)
                    {
                        // move the context from the ValueType line to
                        // the next line, where values begin
                        hr = HrSetupFindNextLine(ic, &ic);
                    }
                    while (S_OK == hr)
                    {
                        // now enumerate over all keys in this section and
                        // try to locate the key with dwRegValue in the infmap

                        hr = HrSetupGetIntField(ic, 1, (int*) &dwInfValue);
                        if ((S_OK == hr) && (dwRegValue == dwInfValue))
                        {
                            // value matches, now find the key name
                            hr = HrSetupGetStringField(ic, 0, pstrNT5InfId);
                            if (S_OK == hr)
                            {
                                // the key name (NT5 infid)
                                // is returned in pstrNT5InfId
                                break;
                            }
                        }
                        hr = HrSetupFindNextLine(ic, &ic);
                    }
                }
                else if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr)
                {
                    hr = HrSetupFindKeyWithStringValue(hInf, pszAdapterSection,
                                                       c_szValueNotPresent,
                                                       pstrNT5InfId);
                }
                break;

            case REG_SZ:

                // find the value in under adapter driver parameters key
                //
                hr = HrRegQueryString(hkeyAdapterParams,
                                      strValueName.c_str(), &strRegValue);
                if (SUCCEEDED(hr))
                {
                    // goto the ValueType line
                    hr = HrSetupFindFirstLine(hInf, pszAdapterSection,
                                              c_szKeyValueType, &ic);
                    if (S_OK == hr)
                    {
                        // move the context from the ValueType line to
                        // the next line, where values begin
                        hr = HrSetupFindNextLine(ic, &ic);
                    }
                    while (S_OK == hr)
                    {
                        // now enumerate over all keys in this section and
                        // try to locate the key with dwRegValue in the infmap

                        hr = HrSetupGetStringField(ic, 1, &strInfValue);
                        if ((S_OK == hr) &&
                            !lstrcmpiW(strRegValue.c_str(), strInfValue.c_str()))
                        {
                            // value matches, now find the key name
                            hr = HrSetupGetStringField(ic, 0, pstrNT5InfId);
                            if (S_OK == hr)
                            {
                                // the key name (NT5 infid)
                                // is returned in pstrNT5InfId
                                break;
                            }
                        }
                        hr = HrSetupFindNextLine(ic, &ic);
                    }
                }
                else if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr)
                {
                    hr = HrSetupFindKeyWithStringValue(hInf, pszAdapterSection,
                                                       c_szValueNotPresent,
                                                       pstrNT5InfId);
                }
                break;

            default:
                hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
                // currently we support only REG_DWORD and REG_SZ type values
                TraceTag(ttidError, "%s: ValueType %d is not supported",
                         __FUNCNAME__, dwValueType);
                break;
            }
        }
    }

    TraceError(__FUNCNAME__, hr);

    return hr;
}

// ----------------------------------------------------------------------
//
// Function:  HrMapPreNT5NetComponentInfIDUsingInfHelper
//
// Purpose:
//
// Arguments:
//    hinf           [in]  handle of netmap.inf file
//    pszOldInfID     [in]  pre NT5 InfID
//    pszMSSection    [in]  section having MS components
//    pszOemSection   [in]  section having OEM components
//    pstrNT5InfId   [out] mapped NT5 InfID
//    pfOemComponent [out] set to TRUE for OEM component
//
// Returns:   S_OK on success,
//            S_FALSE if a mapping is not found
//            otherwise an error code
//
// Author:    kumarp 17-December-97
//
// Notes:
//
HRESULT HrMapPreNT5NetComponentInfIDUsingInfHelper(IN HINF hinf,
                                                   IN PCWSTR pszOldInfID,
                                                   IN PCWSTR pszMSSection,
                                                   IN PCWSTR pszOemSection,
                                                   OUT tstring* pstrNT5InfId,
                                                   OUT BOOL* pfOemComponent)
{
    DefineFunctionName("HrMapPreNT5NetComponentInfIDUsingInfHelper");

    Assert(hinf);
    AssertValidReadPtr(pszOldInfID);
    AssertValidReadPtr(pszMSSection);
    AssertValidReadPtr(pszOemSection);
    AssertValidWritePtr(pstrNT5InfId);
    AssertValidWritePtr(pfOemComponent);

    HRESULT hr=S_FALSE;
    INFCONTEXT ic;

    hr = HrSetupFindFirstLine(hinf, pszMSSection, pszOldInfID, &ic);
    if (S_OK == hr)
    {
        *pfOemComponent = FALSE;
    }
    else
    {
        hr = HrSetupFindFirstLine(hinf, pszOemSection, pszOldInfID, &ic);
        if (S_OK == hr)
        {
            *pfOemComponent = TRUE;
        }
    }

    if (S_OK == hr)
    {
        hr = HrSetupGetStringField(ic, 1, pstrNT5InfId);
        if (S_OK == hr)
        {
            if (*pfOemComponent)
            {
                tstring strOemDll;
                tstring strOemInf;
                HRESULT hrT;

                hrT = HrGetOemUpgradeInfoInInf(hinf,
                                              pstrNT5InfId->c_str(),
                                              &strOemDll, &strOemInf);
                if ((S_OK == hrT) &&
                    !lstrcmpiW(strOemDll.c_str(), c_szNotSupported))
                {
                    TraceTag(ttidNetUpgrade, "%s: %S --> %S",__FUNCNAME__,
                             pszOldInfID, c_szNotSupported);
                    hr = S_FALSE;
                }
            }
        }
    }
    else if (HRESULT_FROM_SETUPAPI(ERROR_LINE_NOT_FOUND) == hr)
    {
        hr = S_FALSE;
    }

    TraceErrorOptional(__FUNCNAME__, hr, (hr == S_FALSE));

    return hr;
}

// ----------------------------------------------------------------------
//
// Function:  HrMapPreNT5NetComponentInfIDInInf
//
// Purpose:   Search the specified netmap.inf file for mapping
//            the specified pre-NT5 InfID of a s/w component to its NT5 value
//
// Arguments:
//    hinf           [in]  handle of netmap.inf file
//    pszOldInfID     [in]  pre-NT5 InfID
//    pstrNT5InfId   [out] mapped ID
//    pfOemComponent [out] set to TRUE for OEM component
//
// Returns:   S_OK on success,
//            S_FALSE if a mapping is not found
//            otherwise an error code
//
// Author:    kumarp 17-December-97
//
// Notes:
//
HRESULT HrMapPreNT5NetComponentInfIDInInf(IN HINF hinf,
                                          IN PCWSTR pszOldInfID,
                                          OUT tstring* pstrNT5InfId,
                                          OUT ENetComponentType* pnct,
                                          OUT BOOL* pfOemComponent)
{
    DefineFunctionName("HrMapPreNT5NetComponentInfIDUsingInf");

    Assert(hinf);
    AssertValidReadPtr(pszOldInfID);
    AssertValidWritePtr(pstrNT5InfId);
    AssertValidWritePtr(pfOemComponent);

    HRESULT hr=S_FALSE;
    ENetComponentType nct = NCT_Unknown;

    hr = HrMapPreNT5NetComponentInfIDUsingInfHelper(hinf, pszOldInfID,
                                                    c_szNetProtocols,
                                                    c_szOemNetProtocols,
                                                    pstrNT5InfId,
                                                    pfOemComponent);
    if (S_OK == hr)
    {
        nct = NCT_Protocol;
    }
    else
    {
        hr = HrMapPreNT5NetComponentInfIDUsingInfHelper(hinf, pszOldInfID,
                                                    c_szNetServices,
                                                    c_szOemNetServices,
                                                    pstrNT5InfId,
                                                    pfOemComponent);
        if (S_OK == hr)
        {
            nct = NCT_Service;
        }
        else
        {
            hr = HrMapPreNT5NetComponentInfIDUsingInfHelper(hinf, pszOldInfID,
                                                            c_szNetClients,
                                                            c_szOemNetClients,
                                                            pstrNT5InfId,
                                                            pfOemComponent);
            if (S_OK == hr)
            {
                nct = NCT_Client;
            }
        }
    }

    if ((S_OK == hr) && pnct)
    {
        *pnct = nct;
    }

    TraceErrorOptional(__FUNCNAME__, hr, (hr == S_FALSE));

    return hr;
}


// ----------------------------------------------------------------------
//
// Function:  HrMapPreNT5NetComponentInfIDToNT5InfID
//
// Purpose:   maps pre-NT5 InfID of a service or protocol to its NT5 equivalent
//
// Arguments:
//    pszPreNT5InfId  [in]  pre-NT5 InfID
//    pstrNT5InfId   [out] mapped ID
//    pfOemComponent [out] set to TRUE for OEM component
//    pdwNetMapIndex [out] the index in netmap array for which map was found
//
// Returns:   S_OK on success,
//            S_FALSE if a mapping is not found
//            otherwise an error code
//
// Author:    kumarp 17-December-97
//
// Notes:
//
HRESULT HrMapPreNT5NetComponentInfIDToNT5InfID(IN PCWSTR   pszPreNT5InfId,
                                               OUT tstring* pstrNT5InfId,
                                               OUT BOOL* pfOemComponent,
                                               OUT ENetComponentType* pnct,
                                               OUT CNetMapInfo** ppnmi)
{
    DefineFunctionName("HrMapPreNT5NetComponentInfIDToNT5InfID");

    AssertValidReadPtr(pszPreNT5InfId);
    AssertValidWritePtr(pstrNT5InfId);
    AssertValidReadPtr(g_pnmaNetMap);

    HRESULT hr=E_FAIL;

    TraceTag(ttidNetUpgrade, "finding mapping for %S...", pszPreNT5InfId);

    if (g_pnmaNetMap)
    {
        CNetMapInfo* pnmi;
        size_t cNumNetMapEntries = g_pnmaNetMap->size();

        for (size_t i = 0; i < cNumNetMapEntries; i++)
        {
            pnmi = (CNetMapInfo*) (*g_pnmaNetMap)[i];

            hr = HrMapPreNT5NetComponentInfIDInInf(pnmi->m_hinfNetMap,
                                                   pszPreNT5InfId,
                                                   pstrNT5InfId,
                                                   pnct,
                                                   pfOemComponent);
            if (SUCCEEDED(hr))
            {
                if (ppnmi)
                {
                    *ppnmi = pnmi;
                }

                if (S_OK == hr)
                {
                    TraceTag(ttidNetUpgrade, "%s: %S --> %S", __FUNCNAME__,
                             pszPreNT5InfId, pstrNT5InfId->c_str());
                    break;
                }
            }
        }
    }

    TraceErrorOptional(__FUNCNAME__, hr, (hr == S_FALSE));

    return hr;
}

// ----------------------------------------------------------------------
//
// Function:  HrGetSoftwareProductKey
//
// Purpose:   Get handle to registry key for a software product of a provider
//
// Arguments:
//    pszProvider [in]  name of provider
//    pszProduct  [in]  name of product
//    phkey      [out] pointer to handle of regkey
//
// Returns:   S_OK on success, otherwise an error code
//
// Author:    kumarp 17-December-97
//
// Notes:
//
HRESULT HrGetSoftwareProductKey(IN  PCWSTR pszProvider,
                                IN  PCWSTR pszProduct,
                                OUT HKEY*   phkey)
{
    DefineFunctionName("HrGetSoftwareProductKey");

    AssertValidReadPtr(pszProvider);
    AssertValidReadPtr(pszProduct);
    AssertValidWritePtr(phkey);

    HRESULT hr=S_OK;

    tstring strProduct;
    strProduct = c_szRegKeySoftware;
    AppendToPath(&strProduct, pszProvider);
    AppendToPath(&strProduct, pszProduct);
    AppendToPath(&strProduct, c_szRegKeyCurrentVersion);

    hr = HrRegOpenKeyEx(HKEY_LOCAL_MACHINE, strProduct.c_str(),
                        KEY_READ, phkey);

    TraceErrorOptional(__FUNCNAME__, hr, (hr == S_FALSE));

    return hr;
}

// ----------------------------------------------------------------------
//
// Function:  HrMapPreNT5NetComponentServiceNameToNT5InfId
//
// Purpose:   Map pre-NT5 InfID of a service to its NT5 value
//
// Arguments:
//    pszServiceName [in]  name of service
//    pstrNT5InfId  [out] mapped ID
//
// Returns:   S_OK on success,
//            S_FALSE if a mapping is not found
//            otherwise an error code
//
// Author:    kumarp 17-December-97
//
// Notes:
//
HRESULT HrMapPreNT5NetComponentServiceNameToNT5InfId(IN  PCWSTR pszServiceName,
                                                     OUT tstring* pstrNT5InfId)
{
    DefineFunctionName("HrMapPreNT5NetComponentServiceNameToNT5InfId");

    AssertValidReadPtr(pszServiceName);
    AssertValidWritePtr(pstrNT5InfId);

    tstring strPreNT5InfId;
    HKEY hkey;
    HRESULT hr=S_OK;

    hr = HrGetSoftwareProductKey(c_szRegKeyMicrosoft, pszServiceName, &hkey);
    if (S_OK == hr)
    {
        hr = HrGetPreNT5InfIdAndDesc(hkey, &strPreNT5InfId, NULL, NULL);
        if (S_OK == hr)
        {
            BOOL fIsOemComponent;
            hr = HrMapPreNT5NetComponentInfIDToNT5InfID(strPreNT5InfId.c_str(),
                                                        pstrNT5InfId,
                                                        &fIsOemComponent, NULL,
                                                        NULL);
#ifdef ENABLETRACE
            if (FAILED(hr))
            {
                TraceTag(ttidNetUpgrade, "%s: could not map %S to NT5 InfID",
                         __FUNCNAME__, pszServiceName);
            }
#endif
        }
        RegCloseKey(hkey);
    }

    TraceErrorOptional(__FUNCNAME__, hr, (hr == S_FALSE));

    return hr;
}

// ----------------------------------------------------------------------
//
// Function:  HrGetOemUpgradeInfoInInf
//
// Purpose:   Find out which OEM DLL to load for a component
//
// Arguments:
//    hinf               [in]  handle of netmap.inf file
//    pszNT5InfId         [in]  NT5 InfID of a component
//    pstrUpgradeDllName [out] name of the upgrade DLL found
//    pstrInf            [out] INF file for this component
//
// Returns:   S_OK on success, otherwise an error code
//
// Author:    kumarp 17-December-97
//
// Notes:
//
HRESULT HrGetOemUpgradeInfoInInf(IN  HINF hinf,
                                 IN  PCWSTR pszNT5InfId,
                                 OUT tstring* pstrUpgradeDllName,
                                 OUT tstring* pstrInf)
{
    DefineFunctionName("HrGetOemUpgradeInfoInInf");

    Assert(hinf);
    AssertValidReadPtr(pszNT5InfId);
    AssertValidWritePtr(pstrUpgradeDllName);
    AssertValidWritePtr(pstrInf);

    HRESULT hr=S_FALSE;
    INFCONTEXT ic;

    pstrUpgradeDllName->erase();
    pstrInf->erase();

    // each line in this section is of the format
    // <NT5-InfId>=<oem-upgrade-dll-name>[,<inf-file-name>]

    hr = HrSetupFindFirstLine(hinf, c_szOemUpgradeSupport,
                              pszNT5InfId, &ic);
    if (S_OK == hr)
    {
        hr = HrSetupGetStringField(ic, 1, pstrUpgradeDllName);
        if (S_OK == hr)
        {
            // the value OemInfFile is optional, so we dont
            // complain if we cannot find it.

            if (HRESULT_FROM_SETUPAPI(ERROR_INVALID_PARAMETER)
                == HrSetupGetStringField(ic, 2, pstrInf))
            {
                TraceTag(ttidNetUpgrade, "%s: OemInf is not specified for %S",
                         __FUNCNAME__, pszNT5InfId);
            }
        }
    }

    TraceTag(ttidNetUpgrade, "%s: OemDll: %S, OemInf: %S",
             __FUNCNAME__, pstrUpgradeDllName->c_str(), pstrInf->c_str());

    TraceErrorOptional(__FUNCNAME__, hr, (hr == S_FALSE));

    return hr;
}

// ----------------------------------------------------------------------
//
// Function:  HrGetOemUpgradeDllInfo
//
// Purpose:   Find out which OEM DLL to load for a component
//
// Arguments:
//    pszNT5InfId         [in]  InfID of OEM component
//    pstrUpgradeDllName [out] name of OEM DLL found
//
// Returns:   S_OK on success, otherwise an error code
//
// Author:    kumarp 17-December-97
//
// Notes:
//
HRESULT HrGetOemUpgradeInfo(IN  PCWSTR pszNT5InfId,
                            OUT tstring* pstrUpgradeDllName,
                            OUT tstring* pstrInf)
{
    DefineFunctionName("HrGetOemUpgradeInfo");

    AssertValidReadPtr(pszNT5InfId);
    AssertValidWritePtr(pstrUpgradeDllName);

    Assert(g_pnmaNetMap);

    HRESULT hr=E_FAIL;

    TraceTag(ttidNetUpgrade, "finding upgrade dll info for %S...",
             pszNT5InfId);

    if (g_pnmaNetMap)
    {
        CNetMapInfo* pnmi;
        size_t cNumNetMapEntries = g_pnmaNetMap->size();

        for (size_t i = 0; i < cNumNetMapEntries; i++)
        {
            pnmi = (CNetMapInfo*) (*g_pnmaNetMap)[i];

            hr = HrGetOemUpgradeInfoInInf(pnmi->m_hinfNetMap, pszNT5InfId,
                                          pstrUpgradeDllName, pstrInf);

            if (S_OK == hr)
            {
                TraceTag(ttidNetUpgrade, "%s: %S --> Dll: %S, Inf: %S",
                         __FUNCNAME__, pszNT5InfId,
                         pstrUpgradeDllName->c_str(),
                         pstrInf->c_str());
                break;
            }
        }
    }


    TraceErrorOptional(__FUNCNAME__, hr, (hr == S_FALSE));

    return hr;
}

// ----------------------------------------------------------------------
//
// Function:  HrSetupFindKeyWithStringValue
//
// Purpose:   Find the key in a section that has the specified value
//
// Arguments:
//    hInf      [in]  handle of netmap.inf file
//    szSection [in]  name of section
//    szValue   [in]  value to find
//    pstrKey   [out] name of the key found
//
// Returns:   S_OK on success, otherwise an error code
//
// Author:    kumarp 17-December-97
//
// Notes:
//
HRESULT HrSetupFindKeyWithStringValue(IN  HINF     hInf,
                                      IN  PCWSTR  szSection,
                                      IN  PCWSTR  szValue,
                                      OUT tstring* pstrKey)
{
    DefineFunctionName("HrSetupFindKeyWithStringValue");

    HRESULT hr=S_OK;
    INFCONTEXT ic;
    tstring strValue;

    hr = HrSetupFindFirstLine(hInf, szSection, NULL, &ic);

    while (S_OK == hr)
    {
        // now enumerate over all keys in this section and
        // try to locate the key with value szValue

        hr = HrSetupGetStringField(ic, 1, &strValue);
        if ((S_OK == hr) && !lstrcmpiW(strValue.c_str(), szValue))
        {
            // value matches, now find the key name
            hr = HrSetupGetStringField(ic, 0, pstrKey);
            break;
        }
        hr = HrSetupFindNextLine(ic, &ic);
    }

    if (HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS) == hr)
    {
        hr = S_FALSE;
    }

    TraceError(__FUNCNAME__, hr);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\upgrade\netupgrd\netupgrd.h ===
#pragma once

#include <winnt32p.h>
#include "oemupgex.h"

extern WINNT32_PLUGIN_INIT_INFORMATION_BLOCK g_PlugInInfo;
extern NetUpgradeInfo g_NetUpgradeInfo;
extern HINSTANCE g_hinst;

extern const WCHAR c_szNetUpgradeDllName[];

// Entry points. See winnt32p.h for explanation of these
//
DWORD
Winnt32PluginInit(
    BOOL    *CancelledFlag,
    BOOL    *UpgradeFlag,
    PCWSTR  SourcePath);

DWORD
Winnt32PluginGetPages(
    PUINT            PageCount1,
    LPPROPSHEETPAGE *Pages1,
    PUINT            PageCount2,
    LPPROPSHEETPAGE *Pages2);

DWORD
Winnt32WriteParams(
    PCWSTR FileName);

DWORD
Winnt32Cleanup(
    VOID);


class CWInfFile;

//Private entry points

BOOL WriteNetworkInfoToAnswerFile (
    IN CWInfFile *pwifAnswerFile);

HRESULT HrInitNetUpgrade();

void AbortUpgradeFn(IN DWORD dwErrorCode, IN PCWSTR szMessage);
void AbortUpgradeSz(IN DWORD dwErrorCode, IN PCWSTR szMessage);
void AbortUpgradeId(IN DWORD dwErrorCode, IN DWORD dwResourceId);
BOOL FIsUpgradeAborted();
BOOL FGetConfirmationAndAbortUpgrade(IN PCWSTR szMessage);
BOOL FGetConfirmationAndAbortUpgradeId(IN DWORD dwErrorMessageId);


#ifdef DBG
__declspec(dllexport) void SetNuAfile(CWInfFile* afile);

__declspec(dllexport) void NuDumpAFile();
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\upgrade\netupgrd\conflict.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       C O N F L I C T . C P P
//
//  Contents:   Code to handle and display software/hardware conflicts
//              during upgrade
//
//  Notes:
//
//  Author:     kumarp 04/12/97 17:17:27
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "conflict.h"
#include "infmap.h"
#include "kkreg.h"
#include "kkstl.h"
#include "kkutils.h"
#include "ncreg.h"
#include "netreg.h"
#include "nustrs.h"
#include "nuutils.h"
#include "oemupg.h"
#include "ncsvc.h"

// ----------------------------------------------------------------------
// External string constants
//
extern const WCHAR c_szRegValServiceName[];
extern const WCHAR c_szParameters[];

// ----------------------------------------------------------------------
// String constants
//
const WCHAR sz_DLC[] = L"DLC";
const WCHAR sz_NBF[] = L"NBF";
const WCHAR sz_SNAServerKey[]     = L"SOFTWARE\\Microsoft\\Sna Server\\CurrentVersion";
const WCHAR sz_SNAServerVersion[] = L"SNAVersion";

// ----------------------------------------------------------------------
TPtrList* g_pplNetComponents=NULL;

// ----------------------------------------------------------------------
//
// Function:  UpgradeConflictsFound
//
// Purpose:   Find out if upgrade conflicts have been detected
//
// Arguments: None
//
// Returns:   TRUE if found, FALSE otherwise
//
// Author:    kumarp 17-December-97
//
// Notes:
//
BOOL UpgradeConflictsFound()
{
    return (g_pplNetComponents && g_pplNetComponents->size());
}

// ----------------------------------------------------------------------
//
// Function:  CNetComponent::CNetComponent
//
// Purpose:   constructor for class CNetComponent
//
// Arguments:
//    pszPreNT5InfId        [in]  pre NT5 InfID (e.g. IEEPRO)
//    pszPreNT5Instance     [in]  pre NT5 instance name (e.g. IEEPRO2)
//    pszDescription        [in]  description
//    eType                [in]  type (software / hardware)
//
// Author:    kumarp 17-December-97
//
// Notes:
//
CNetComponent::CNetComponent(PCWSTR   pszPreNT5InfId,
                             PCWSTR   pszPreNT5Instance,
                             PCWSTR   pszDescription,
                             EComponentType eType)
    : m_strPreNT5InfId(pszPreNT5InfId),
      m_strServiceName(pszPreNT5Instance),
      m_strDescription(pszDescription),
      m_eType(eType)
{
}

// ----------------------------------------------------------------------
//
// Function:  AddToComponentList
//
// Purpose:   Construct and add a CNetComponent to the specified list
//
// Arguments:
//    pplComponents        [in]  pointer to list of
//    pszPreNT5InfId        [in]  pre NT5 InfID (e.g. IEEPRO)
//    pszPreNT5Instance     [in]  pre NT5 instance name (e.g. IEEPRO2)
//    pszDescription        [in]  description
//    eType                [in]  type (software / hardware)
//
// Returns:   None
//
// Author:    kumarp 17-December-97
//
// Notes:
//
void AddToComponentList(IN TPtrList* pplComponents,
                        IN PCWSTR   pszPreNT5InfId,
                        IN PCWSTR   pszPreNT5Instance,
                        IN PCWSTR   pszDescription,
                        EComponentType eType)
{
    AssertValidReadPtr(pplComponents);
    AssertValidReadPtr(pszPreNT5InfId);
    AssertValidReadPtr(pszPreNT5Instance);
    AssertValidReadPtr(pszDescription);

    if (pplComponents)
    {
        CNetComponent* pnc;
        pnc = new CNetComponent(pszPreNT5InfId, pszPreNT5Instance,
                                pszDescription, eType);
        if (pnc)
        {
            pplComponents->push_back(pnc);
        }
    }
#ifdef ENABLETRACE
    tstring strMessage;

    GetUnsupportedMessageBool((eType == CT_Hardware), pszPreNT5InfId,
                              pszDescription, &strMessage);
    TraceTag(ttidNetUpgrade, "%S", strMessage.c_str());
#endif
}

// ----------------------------------------------------------------------
//
// Function:  AddToConflictsList
//
// Purpose:   Construct and add a CNetComponent to the conflict list
//
// Arguments:
//    pszPreNT5InfId        [in]  pre NT5 InfID (e.g. IEEPRO)
//    pszPreNT5Instance     [in]  pre NT5 instance name (e.g. IEEPRO2)
//    pszDescription        [in]  description
//    eType                [in]  type (software / hardware)
//
// Returns:   None
//
// Author:    kumarp 17-December-97
//
// Notes:
//
void AddToConflictsList(IN PCWSTR pszPreNT5InfId,
                        IN PCWSTR pszPreNT5Instance,
                        IN PCWSTR pszDescription,
                        EComponentType eType)
{
    if (!g_pplNetComponents)
    {
        g_pplNetComponents = new TPtrList;
    }

    AddToComponentList(g_pplNetComponents, pszPreNT5InfId,
                       pszPreNT5Instance, pszDescription, eType);
}

// ----------------------------------------------------------------------
//
// Function:  HrGetAdapterParamsKeyFromInstance
//
// Purpose:   Get handle of Parameters key using adapter instace key
//
// Arguments:
//    hkeyAdapterInstance [in]  handle of
//    phkeyAdapterParams  [out] pointer to handle of
//
// Returns:   S_OK on success, otherwise an error code
//
// Author:    kumarp 17-December-97
//
// Notes:
//
HRESULT HrGetAdapterParamsKeyFromInstance(IN  HKEY  hkeyAdapterInstance,
                                          OUT HKEY* phkeyAdapterParams)
{
    DefineFunctionName("HrGetAdapterParamsKeyFromInstance");

    Assert(hkeyAdapterInstance);
    AssertValidWritePtr(phkeyAdapterParams);

    HRESULT hr=S_OK;
    tstring strServiceName;

    hr = HrRegQueryString(hkeyAdapterInstance, c_szRegValServiceName,
                          &strServiceName);
    if (S_OK == hr)
    {
        hr = HrRegOpenServiceSubKey(strServiceName.c_str(), c_szParameters,
                                    KEY_READ, phkeyAdapterParams);
    }

    TraceError(__FUNCNAME__, hr);

    return hr;
}

// ----------------------------------------------------------------------
//
// Function:  HrGenerateHardwareConflictList
//
// Purpose:   Detect upgrade conflicts for h/w components
//
// Arguments: None
//
// Returns:   S_OK on success, otherwise an error code
//
// Author:    kumarp 17-December-97
//
// Notes:
//
HRESULT HrGenerateHardwareConflictList()
{
    DefineFunctionName("HrGenerateHardwareConflictList");

    HKEY hkeyAdapters;
    HKEY hkeyAdapter;
    DWORD dwHidden;
    tstring strAdapterDescription;
    tstring strPreNT5InfId;
    tstring strServiceName;
    tstring strNT5InfId;
    tstring strAdapterType;
    BOOL    fIsOemAdapter;
    BOOL  fRealNetCard = FALSE;

    HRESULT hr=S_OK;

    hr = HrRegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szRegKeyAdapterHome,
                        KEY_READ, &hkeyAdapters);
    if (S_OK == hr)
    {
        WCHAR szBuf[MAX_PATH];
        FILETIME time;
        DWORD dwSize = celems(szBuf);
        DWORD dwRegIndex = 0;

        while(S_OK == (hr = HrRegEnumKeyEx(hkeyAdapters, dwRegIndex++, szBuf,
                                           &dwSize, NULL, NULL, &time)))
        {
            dwSize = celems(szBuf);
            Assert(*szBuf);

            hr = HrRegOpenKeyEx(hkeyAdapters, szBuf, KEY_READ, &hkeyAdapter);
            if (hr == S_OK)
            {
                hr = HrRegQueryDword(hkeyAdapter, c_szHidden, &dwHidden);

                // for REAL netcards, "Hidden" is absent or if present the value is 0
                if (S_OK == hr)
                {
                    fRealNetCard = (dwHidden == 0);
                }
                else if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr)
                {
                    fRealNetCard = TRUE;
                    hr = S_OK;
                }

                if ((S_OK == hr) && fRealNetCard)
                {

                    hr = HrGetPreNT5InfIdAndDesc(hkeyAdapter, &strPreNT5InfId,
                                                 &strAdapterDescription, &
                                                 strServiceName);
                    if (S_OK == hr)
                    {
                        HKEY hkeyAdapterParams;
                        hr = HrGetAdapterParamsKeyFromInstance(hkeyAdapter,
                                                               &hkeyAdapterParams);
                        if (S_OK == hr)
                        {
                            hr = HrMapPreNT5NetCardInfIdToNT5InfId(hkeyAdapterParams,
                                                                   strPreNT5InfId.c_str(),
                                                                   &strNT5InfId,
                                                                   &strAdapterType,
                                                                   &fIsOemAdapter,
                                                                   NULL);
                            if (S_FALSE == hr)
                            {
                                AddToConflictsList(strPreNT5InfId.c_str(),
                                                   strServiceName.c_str(),
                                                   strAdapterDescription.c_str(),
                                                   CT_Hardware);
                            }
                        }
                        RegCloseKey(hkeyAdapterParams);
                    }
                }
                RegCloseKey(hkeyAdapter);
            }
        }
        if ((HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS) == hr) ||
            (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr))
        {
            hr = S_OK;
        }

        RegCloseKey(hkeyAdapters);
    }

    TraceError(__FUNCNAME__, hr);

    return hr;
}

// ----------------------------------------------------------------------
//
// Function:  ShouldIgnoreComponentForInstall
//
// Purpose:   Determine if a components should be ignored when
//            we are checking to see for obsolesence
//
// Arguments:
//    pszComponentName [in]  name of component
//
// Returns:   TRUE on success, FALSE otherwise
//
// Author:    deonb 22-September-2000
//
BOOL
ShouldIgnoreComponentForInstall (
    IN PCWSTR pszComponentName)
{
    BOOL fRet=FALSE;

    if (
        // We ignore NETBEUI since it's checked by DOSNET.INF already (NTBUG9: 181798)
         (lstrcmpiW(pszComponentName, sz_NBF) == 0) ||

         // We ignore DLC since it's checked by HrGenerateNT5ConflictList (NTBUG9: 187135)
         (lstrcmpiW(pszComponentName, sz_DLC) == 0)
         )
    {
        fRet = TRUE;
    }
    else
    {
        fRet = FALSE;
    }

    return fRet;
}

// ----------------------------------------------------------------------
//
// Function:  HrGenerateSoftwareConflictListForProvider
//
// Purpose:   Detect upgrade conflicts for s/w components of a provider
//
// Arguments:
//    pszSoftwareProvider [in]  name of software provider (e.g. Microsoft)
//
// Returns:   S_OK on success, otherwise an error code
//
// Author:    kumarp 17-December-97
//
// Notes:
//
HRESULT HrGenerateSoftwareConflictListForProvider(IN PCWSTR pszSoftwareProvider)
{
    DefineFunctionName("HrGenerateSoftwareConflictList");

    HRESULT hr=S_OK;
    HKEY hkeyProvider;
    HKEY hkeyProductCurrentVersion;

    tstring strProvider;
    strProvider =  c_szRegKeySoftware;
    AppendToPath(&strProvider, pszSoftwareProvider);

    hr = HrRegOpenKeyEx(HKEY_LOCAL_MACHINE, strProvider.c_str(),
                        KEY_READ, &hkeyProvider);
    if (S_OK == hr)
    {
        tstring strPreNT5InfId;
        tstring strNT5InfId;
        tstring strProductCurrentVersion;
        tstring strDescription;
        tstring strServiceName;
        tstring strSoftwareType;
        WCHAR szBuf[MAX_PATH];
        FILETIME time;
        DWORD dwSize = celems(szBuf);
        DWORD dwRegIndex = 0;
        BOOL  fIsOemComponent;

        while(S_OK == (hr = HrRegEnumKeyEx(hkeyProvider, dwRegIndex++, szBuf,
                                           &dwSize, NULL, NULL, &time)))
        {
            dwSize = celems(szBuf);
            Assert(*szBuf);


            if (!ShouldIgnoreComponentForInstall(szBuf))
            {
                strProductCurrentVersion = szBuf;
                AppendToPath(&strProductCurrentVersion, c_szRegKeyCurrentVersion);

                // Look for Component\CurrentVersion
                hr = HrRegOpenKeyEx(hkeyProvider, strProductCurrentVersion.c_str(),
                                    KEY_READ, &hkeyProductCurrentVersion);
                if (hr == S_OK)
                {
                    // Under Component\CurrentVersion, look for "SoftwareType" value
                    hr = HrRegQueryString(hkeyProductCurrentVersion,
                                          c_szRegValSoftwareType,
                                          &strSoftwareType);
                    if (!lstrcmpiW(strSoftwareType.c_str(), c_szSoftwareTypeDriver))
                    {
                        // ignore components of type "driver"
                        hr = S_OK;
                    }
                    else
                    {
                        hr = HrGetPreNT5InfIdAndDesc(hkeyProductCurrentVersion,
                                                     &strPreNT5InfId, &strDescription,
                                                     &strServiceName);

                        if (S_OK == hr)
                        {
                            hr = HrMapPreNT5NetComponentInfIDToNT5InfID(
                                    strPreNT5InfId.c_str(), &strNT5InfId,
                                    &fIsOemComponent, NULL, NULL);

                            if (S_FALSE == hr)
                            {
                                AddToConflictsList(strPreNT5InfId.c_str(),
                                                   strServiceName.c_str(),
                                                   strDescription.c_str(),
                                                   CT_Software);
                            }
                        }
                        RegCloseKey(hkeyProductCurrentVersion);
                    }
                }
            }
        }
        if (HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS) == hr)
        {
            hr = S_OK;
        }

        RegCloseKey(hkeyProvider);
    }

    TraceError(__FUNCNAME__, hr);

    return hr;
}

// ----------------------------------------------------------------------
//
// Function:  HrGenerateSoftwareConflictList
//
// Purpose:   Detect upgrade conflicts for s/w components of all providers
//
// Arguments: None
//
// Returns:   S_OK on success, otherwise an error code
//
// Author:    kumarp 17-December-97
//
// Notes:
//
HRESULT HrGenerateSoftwareConflictList()
{
    DefineFunctionName("HrGenerateSoftwareConflictList");

    HRESULT hr=S_OK;
    HKEY hkeySoftware;

    hr = HrRegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szRegKeySoftware,
                        KEY_READ, &hkeySoftware);
    if (S_OK == hr)
    {
        WCHAR szBuf[MAX_PATH];
        FILETIME time;
        DWORD dwSize = celems(szBuf);
        DWORD dwRegIndex = 0;

        while(S_OK == (hr = HrRegEnumKeyEx(hkeySoftware, dwRegIndex++, szBuf,
                                           &dwSize, NULL, NULL, &time)))
        {
            dwSize = celems(szBuf);
            Assert(*szBuf);

            hr = HrGenerateSoftwareConflictListForProvider(szBuf);
        }
        if (HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS) == hr)
        {
            hr = S_OK;
        }

        RegCloseKey(hkeySoftware);
    }

    TraceError(__FUNCNAME__, hr);

    return hr;
}

// ----------------------------------------------------------------------
//
// Function:  HrGenerateNT5ConflictList
//
// Purpose:   Detect upgrade conflicts from Windows 2000
//
// Arguments: None
//
// Returns:   S_OK on success, otherwise an error code
//
// Author:    deonb 20-September 2000
//
// Notes:
//
HRESULT HrGenerateNT5ConflictList()
 {
    HRESULT hr = S_OK;
    tstring strDescription;
    BOOL    fInstalled;


    if ( ShouldRemoveDLC(&strDescription, &fInstalled) )
    {
        // Add to conflict list only if DLC is installed, otherwise user will see
        // a warning message even if it is uninstalled.
        //

        if ( fInstalled )
        {
            if (strDescription.empty())
            {   
                // Couldn't find a description from previous O/S. Oh well - just use "DLC".
                AddToConflictsList(sz_DLC, sz_DLC, sz_DLC, CT_Software);
            }
            else
            {
                AddToConflictsList(sz_DLC, sz_DLC, strDescription.c_str(), CT_Software);
            }
        }
    }
    
    return hr;
    
}

// ----------------------------------------------------------------------
//
// Function:  ShouldRemoveDLC
//
// Purpose:   Determine if DLC should be removed during the upgrade irrespective of whether
//            it is currently installed or not.
//
// Arguments:
//    strDLCDesc  [out] pointer to DLC Description string.
//    pfInstalled [out] pointer to a boolean indicating if DLC is currently installed.
//                      Valid for X86 only.
//
// Returns:   TRUE if DLC should be removed.
//
// Author:    asinha 3/27/2001
//
// Notes:
//
BOOL ShouldRemoveDLC (tstring *strDLCDesc,
                      BOOL *pfInstalled)
{
    HRESULT hr;
    BOOL fDlcRemove = FALSE;

    if ( pfInstalled )
    {
        *pfInstalled = FALSE;
    }

    // Check if DLC is installed (only for x86 - for IA64 we don't care (NTBUG9:186001) )
#ifdef _X86_

    CServiceManager sm;
    CService        srv;

    if ( pfInstalled )
    {

        hr = sm.HrOpenService(&srv, sz_DLC);

        if (SUCCEEDED(hr)) // DLC Service is installed
        {
            *pfInstalled = TRUE;

            LPQUERY_SERVICE_CONFIG pConfig;
            HRESULT hr = srv.HrQueryServiceConfig (&pConfig);

            if (S_OK == hr)
            {
                if ( strDLCDesc )
                {
                    *strDLCDesc = pConfig->lpDisplayName;
                }

                MemFree (pConfig);
            }

            srv.Close();
        }
        else
        {
            *pfInstalled = FALSE;
        }
    }

    fDlcRemove = TRUE;

    OSVERSIONINFO osvi;
    ZeroMemory(&osvi, sizeof(OSVERSIONINFO));
    
    osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);

    // If SNA Server is installed (on NT5) - this is ok

    if (GetVersionEx(&osvi)) // Can't use VerifyVersionInfo - we have to run on NT4.
    {
        if ( (osvi.dwPlatformId == VER_PLATFORM_WIN32_NT) && 
             (osvi.dwMajorVersion == 5) &&
             (osvi.dwMinorVersion == 0) )
        {
            // If SNA Server is installed - we still allow this

            hr = sm.HrOpenService(&srv, L"SnaServr");

            if (SUCCEEDED(hr)) // Service is installed
            {
                srv.Close();

                // Only if SNA version is 5.0 or more.

                HKEY hkeySnaServer;
                hr = HrRegOpenKeyEx(HKEY_LOCAL_MACHINE, sz_SNAServerKey, KEY_READ, &hkeySnaServer);
                if (S_OK == hr)
                {
                    tstring tstr;
                    hr = HrRegQueryString(hkeySnaServer, sz_SNAServerVersion, &tstr);
                    if (S_OK == hr)
                    {
                        int nSnaVersion = _wtoi(tstr.c_str());
                        if (nSnaVersion >= 5)
                        {
                            fDlcRemove = FALSE;
                        }
                    }
                    RegCloseKey(hkeySnaServer);
                }
            }
        }

        // Never complain about DLC if upgrading from Whistler+

        if ( (osvi.dwPlatformId == VER_PLATFORM_WIN32_NT) && 
             ( ( (osvi.dwMajorVersion == 5) && (osvi.dwMinorVersion >= 1) ) ||
                 (osvi.dwMajorVersion >= 6) ) )
        {
            fDlcRemove = FALSE; 
        }
    }
#endif
    
    return fDlcRemove;
    
}


// ----------------------------------------------------------------------
//
// Function:  HrGenerateConflictList
//
// Purpose:   Generate upgrade conflict list for s/w and h/w components
//
// Arguments: None
//
// Returns:   S_OK on success, otherwise an error code
//
// Author:    kumarp 17-December-97
//
// Notes:
//
HRESULT HrGenerateConflictList(OUT UINT* pcNumConflicts)
{
    DefineFunctionName("HrGenerateConflictList");

    HRESULT hr=S_OK;

    (void) HrGenerateHardwareConflictList();
    (void) HrGenerateSoftwareConflictList();
    (void) HrGenerateNT5ConflictList();

    if (g_pplNetComponents && g_pplNetComponents->size())
    {
        *pcNumConflicts = g_pplNetComponents->size();
    }
    else
    {
        *pcNumConflicts = 0;
    }

    TraceError(__FUNCNAME__, hr);

    return hr;
}

// ----------------------------------------------------------------------
//
// Function:  UninitConflictList
//
// Purpose:   Uninitialize and destroy global lists holding upgrade conflicts
//
// Arguments: None
//
// Returns:   None
//
// Author:    kumarp 17-December-97
//
// Notes:
//
void UninitConflictList()
{
    if (g_pplNetComponents)
    {
        CNetComponent* pnc;
        TPtrListIter pos;

        for (pos = g_pplNetComponents->begin();
             pos != g_pplNetComponents->end(); pos++)
        {
            pnc = (CNetComponent*) *pos;
            delete pnc;
        }
        g_pplNetComponents->erase(g_pplNetComponents->begin(),
                                  g_pplNetComponents->end());
        delete g_pplNetComponents;
        g_pplNetComponents = NULL;
    }
}

// ----------------------------------------------------------------------
//
// Function:  HrResolveConflictsFromList
//
// Purpose:   Use the specified netmap.inf file to find out if any
//            of the components currently detected as unsupported can
//            be mapped. If such components are found, then delete them
//            from pplComponents if fDeleteResolvedItemsFromList is TRUE
//
// Arguments:
//    fDeleteResolvedItemsFromList [in]  flag (see above)
//    pplComponents                [in]  pointer to list of unsupported components
//    hinfNetMap                   [in]  handle of netmap.inf file
//    pdwNumConflictsResolved      [out] number of components mapped using the
//                                       specified netmap.inf
//
// Returns:   S_OK on success, otherwise an error code
//
// Author:    kumarp 17-December-97
//
// Notes:
//
HRESULT HrResolveConflictsFromList(IN  BOOL fDeleteResolvedItemsFromList,
                                   IN  TPtrList* pplComponents,
                                   IN  HINF hinfNetMap,
                                   OUT DWORD* pdwNumConflictsResolved,
                                   OUT BOOL*  pfHasUpgradeHelpInfo)
{
    DefineFunctionName("HrResolveConflictsFromList");

    Assert(hinfNetMap);
    AssertValidWritePtr(pdwNumConflictsResolved);

    HRESULT hr=S_OK;

    *pdwNumConflictsResolved = 0;

    if (pplComponents && (pplComponents->size() > 0))
    {
        TPtrListIter pos;
        TPtrListIter tpos;
        tstring strPreNT5InfId;
        CNetComponent* pnc;
        HKEY hkeyAdapterParams;
        BOOL fIsOemComponent;
        tstring strNT5InfId;

        pos = pplComponents->begin();

        while(pos != pplComponents->end())
        {
            pnc = (CNetComponent*) *pos;
            strNT5InfId = c_szEmpty;

            if (pnc->m_eType == CT_Hardware)
            {
                hr = HrRegOpenServiceSubKey(pnc->m_strServiceName.c_str(), c_szParameters,
                                            KEY_READ, &hkeyAdapterParams);
                if (S_OK == hr)
                {
                    fIsOemComponent = FALSE;
                    hr = HrMapPreNT5NetCardInfIdInInf(hinfNetMap, hkeyAdapterParams,
                                                      pnc->m_strPreNT5InfId.c_str(),
                                                      &strNT5InfId,
                                                      NULL, &fIsOemComponent);
                    RegCloseKey(hkeyAdapterParams);
                }
            }
            else
            {
                hr = HrMapPreNT5NetComponentInfIDInInf(hinfNetMap,
                                                       pnc->m_strPreNT5InfId.c_str(),
                                                       &strNT5InfId,
                                                       NULL,
                                                       &fIsOemComponent);
                if ((S_FALSE == hr) && !strNT5InfId.empty())
                {
                    *pfHasUpgradeHelpInfo = TRUE;
                }
            }
            tpos = pos;
            pos++;
            // if we found a map, remove the entry
            if (S_OK == hr)
            {
                (*pdwNumConflictsResolved)++;
                if (fDeleteResolvedItemsFromList)
                {
                    delete pnc;
                    pplComponents->erase(tpos);
                }
            }
        }
    }
    else
    {
        hr = S_FALSE;
    }

    TraceErrorOptional(__FUNCNAME__, hr, (S_FALSE == hr));

    return hr;
}

// ----------------------------------------------------------------------
//
// Function:  HrUpdateConflictList
//
// Purpose:   Use the specified netmap.inf file to find out if any
//            of the components currently detected as unsupported can
//            be mapped. If such components are found, then delete them
//            from pplComponents if fDeleteResolvedItemsFromList is TRUE
//
// Arguments:
//    fDeleteResolvedItemsFromList [in]  flag (see above)
//    hinfNetMap                   [in]  handle of netmap.inf file
//    pdwNumConflictsResolved      [out] number of components mapped using the
//                                       specified netmap.inf
// Returns:   S_OK on success, otherwise an error code
//
// Author:    kumarp 17-December-97
//
// Notes:
//
HRESULT HrUpdateConflictList(IN BOOL    fDeleteResolvedItemsFromList,
                             IN HINF    hinfNetMap,
                             OUT DWORD* pdwNumConflictsResolved,
                             OUT BOOL*  pfHasUpgradeHelpInfo)
{
    DefineFunctionName("HrUpdateConflictList");


    HRESULT hr=S_OK;

    hr = HrResolveConflictsFromList(fDeleteResolvedItemsFromList,
                                    g_pplNetComponents, hinfNetMap,
                                    pdwNumConflictsResolved,
                                    pfHasUpgradeHelpInfo);

    TraceErrorOptional(__FUNCNAME__, hr, (S_FALSE == hr));

    return hr;
}


HRESULT HrGetConflictsList(OUT TPtrList** ppplNetComponents)
{
    HRESULT hr=S_FALSE;

    if (g_pplNetComponents)
    {
        hr = S_OK;
        *ppplNetComponents = g_pplNetComponents;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\upgrade\netupgrd\infmap.h ===
// ----------------------------------------------------------------------
//
//  Microsoft Windows NT
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:      I N F M A P . H
//
//  Contents:  Functions that work on netmap.inf file.
//
//  Notes:
//
//  Author:    kumarp 22-December-97
//
// ----------------------------------------------------------------------

#pragma once
#include "ncstring.h"

extern const WCHAR c_szIsaAdapters[];
extern const WCHAR c_szEisaAdapters[];
extern const WCHAR c_szPciAdapters[];
extern const WCHAR c_szMcaAdapters[];
extern const WCHAR c_szPcmciaAdapters[];
extern const WCHAR c_szAsyncAdapters[];

extern const WCHAR c_szOemAsyncAdapters[];

class CNetMapInfo;

enum ENetComponentType
{
    NCT_Unknown=0,
    NCT_Adapter,
    NCT_Protocol,
    NCT_Service,
    NCT_Client
};

HRESULT HrMapPreNT5NetCardInfIdInInf(IN  HINF     hinf,
                                     IN  HKEY     hkeyAdapterParams,
                                     IN  PCWSTR  pszPreNT5InfId,
                                     OUT tstring* pstrNT5InfId,
                                     OUT tstring* pstrAdapterType,
                                     OUT BOOL*    pfOemComponent);
HRESULT HrMapPreNT5NetComponentInfIDInInf(IN HINF hinf,
                                          IN PCWSTR pszOldInfID,
                                          OUT tstring* pstrNT5InfId,
                                          OUT ENetComponentType* pnct,
                                          OUT BOOL* pfOemComponent);

HRESULT HrMapPreNT5NetCardInfIdToNT5InfId(IN  HKEY     hkeyAdapterParams,
                                          IN  PCWSTR  pszPreNT5InfId,
                                          OUT tstring* pstrNT5InfId,
                                          OUT tstring* pstrAdapterType,
                                          OUT BOOL*    pfOemComponent,
                                          OUT CNetMapInfo** ppnmi);
HRESULT HrMapPreNT5NetComponentInfIDToNT5InfID(IN PCWSTR   pszPreNT5InfId,
                                               OUT tstring* pstrNT5InfId,
                                               OUT BOOL* pfOemComponent,
                                               OUT ENetComponentType* pnct,
                                               OUT CNetMapInfo** ppnmi);
HRESULT HrMapPreNT5NetComponentServiceNameToNT5InfId(IN  PCWSTR pszServiceName,
                                                     OUT tstring* pstrNT5InfId);
HRESULT HrGetOemUpgradeDllInfo(IN  PCWSTR pszNT5InfId,
                               OUT tstring* pstrUpgradeDllName,
                               OUT tstring* pstrInf);

HRESULT HrGetOemUpgradeInfoInInf(IN  HINF hinf,
                                 IN  PCWSTR pszNT5InfId,
                                 OUT tstring* pstrUpgradeDllName,
                                 OUT tstring* pstrInf);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\upgrade\netupgrd\netupgrd.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       N E T U P G R D . C P P
//
//  Contents:   DllMain and winnt32.exe plug-in exported functions
//
//  Notes:
//
//  Author:     kumarp    25-Nov-1996
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include <winnt32p.h>

#include "afilestr.h"
#include "conflict.h"
#include "kkcwinf.h"
#include "kkutils.h"
#include "nceh.h"
#include "ncreg.h"
#include "netreg.h"
#include "netupgrd.h"
#include "nuutils.h"
#include "oemupg.h"
#include "resource.h"
#include "dhcpupg.h"

extern const WCHAR c_szNetUpgradeDll[];
extern const WCHAR c_szAfUnknown[];


//Global
WINNT32_PLUGIN_INIT_INFORMATION_BLOCK g_PlugInInfo;
NetUpgradeInfo g_NetUpgradeInfo;
CWInfFile* g_pwifAnswerFile;
HINSTANCE g_hinst;
DWORD g_dwUpgradeError;

void CleanupNetupgrdTempFiles();
void GetNetworkingSections(IN  CWInfFile* pwif,
                           OUT TStringList* pslSections);

const WCHAR c_szExceptionInNetupgrd[] = L"netupgrd.dll threw an exception";

EXTERN_C
BOOL
WINAPI
DllMain (
    HINSTANCE   hInstance,
    DWORD       dwReason,
    LPVOID   /* lpReserved */)
{
    if (DLL_PROCESS_ATTACH == dwReason)
    {
        g_hinst = hInstance;
        DisableThreadLibraryCalls(hInstance);
        InitializeDebugging();
    }
    else if (DLL_PROCESS_DETACH == dwReason)
    {
        UnInitializeDebugging();
    }
    return TRUE;
}


//+---------------------------------------------------------------------------
//
// Function:  HrGetProductTypeUpgradingFrom
//
// Purpose:   Determine the product type of the current system
//
// Arguments:
//    ppt [out] pointer to
//
// Returns:   S_OK on success, otherwise an error code
//
HRESULT HrGetProductTypeUpgradingFrom(
    OUT PRODUCTTYPE* ppt)
{
    Assert (ppt);
    *ppt = NT_WORKSTATION;

    HRESULT hr;
    HKEY    hkeyProductOptions;

    hr = HrRegOpenKeyEx(
            HKEY_LOCAL_MACHINE,
            L"System\\CurrentControlSet\\Control\\ProductOptions",
            KEY_READ, &hkeyProductOptions);
    if (S_OK == hr)
    {
        WCHAR szProductType [64];
        ULONG cbProductType = sizeof(szProductType);

        hr = HrRegQuerySzBuffer(
                hkeyProductOptions,
                L"ProductType",
                szProductType,
                &cbProductType);

        if (S_OK == hr)
        {
            if (0 != lstrcmpiW(szProductType, L"WinNT"))
            {
                *ppt = NT_SERVER;
            }
        }

        RegCloseKey(hkeyProductOptions);
    }

    return hr;
}

//+---------------------------------------------------------------------------
// The following four functions are required to be exported so that
// winnt32.exe can correctly use this plug-in DLL during down level
// upgrade for description of each see winnt32p.h
//


//+---------------------------------------------------------------------------
//
// Function:  Winnt32PluginInit
//
// Purpose:   Initialize the DLL
//
// Arguments:
//    pInfo [in]  winnt32 plug-in initialization info
//
// Returns:   ERROR_SUCCESS on success, else win32 error code
//
// Author:    kumarp 19-December-97
//
// Notes:     see winnt32p.h for more information
//
DWORD
CALLBACK
Winnt32PluginInit(
    PWINNT32_PLUGIN_INIT_INFORMATION_BLOCK pInfo)
{
    DefineFunctionName("Winnt32PluginInit");
    TraceFunctionEntry(ttidNetUpgrade);

    Assert (pInfo);
    CopyMemory(&g_PlugInInfo, pInfo, sizeof(g_PlugInInfo));

    // We should only be doing this once.
    //
    Assert (0 == g_NetUpgradeInfo.To.dwBuildNumber);
    Assert (0 == g_NetUpgradeInfo.From.dwBuildNumber);

    g_NetUpgradeInfo.To.ProductType   = *g_PlugInInfo.ProductType;
    g_NetUpgradeInfo.To.dwBuildNumber = g_PlugInInfo.BuildNumber;

    g_dwUpgradeError = ERROR_OPERATION_ABORTED;

    OSVERSIONINFO osv;
    osv.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    if (GetVersionEx(&osv))
    {
        // This DLL doesn't upgrade anything but Windows NT.
        //
        if (osv.dwPlatformId == VER_PLATFORM_WIN32_NT)
        {
            PRODUCTTYPE pt;
            HRESULT hr = HrGetProductTypeUpgradingFrom(&pt);

            if (S_OK == hr)
            {
                g_NetUpgradeInfo.From.dwBuildNumber = osv.dwBuildNumber;
                g_NetUpgradeInfo.From.ProductType = pt;

                NC_TRY
                {
                    g_dwUpgradeError = NOERROR;
                    (void) HrInitNetUpgrade();
                }
                NC_CATCH_ALL
                {
                    TraceTag(ttidNetUpgrade, "%s: exception!!", __FUNCNAME__);
                    g_dwUpgradeError = ERROR_OPERATION_ABORTED;
                    AbortUpgradeFn(g_dwUpgradeError, c_szExceptionInNetupgrd);
                }
            }
        }
    }

    TraceTag(ttidNetUpgrade, "%s: returning status code: %ld",
             __FUNCNAME__, g_dwUpgradeError);

    return g_dwUpgradeError;
}

//+---------------------------------------------------------------------------
//
// Function:  Winnt32PluginGetPages
//
// Purpose:   Supply wizard pages to winnt32.exe
//
// Arguments:
//    PageCount1 [in]  number of pages in group 1
//    Pages1     [in]  array of pages in group 1
//    PageCount2 [in]  number of pages in group 2
//    Pages2     [in]  array of pages in group 2
//    PageCount3 [in]  number of pages in group 3
//    Pages3     [in]  array of pages in group 3
//
// Returns:   ERROR_SUCCESS on success, else win32 error code
//
// Author:    kumarp 19-December-97
//
// Notes:     see winnt32p.h for more information
//
DWORD
CALLBACK
Winnt32PluginGetPages(
    PUINT            PageCount1,
    LPPROPSHEETPAGE *Pages1,
    PUINT            PageCount2,
    LPPROPSHEETPAGE *Pages2,
    PUINT            PageCount3,
    LPPROPSHEETPAGE *Pages3)
{
    //We dont need any UI for upgrade and hence no pages
    *PageCount1 = 0;
    *PageCount2 = 0;
    *PageCount3 = 0;

    *Pages1 = NULL;
    *Pages2 = NULL;
    *Pages3 = NULL;

    return NOERROR;
}

//+---------------------------------------------------------------------------
//
// Function:  Winnt32WriteParams
//
// Purpose:   Write network parameters to the answerfile
//
// Arguments:
//    FileName [in]  name of answerfile
//
// Returns:   ERROR_SUCCESS on success, else win32 error code
//
// Author:    kumarp 19-December-97
//
// Notes:     see winnt32p.h for more information
//
DWORD
CALLBACK
Winnt32WriteParams(
    PCWSTR FileName)
{
    DefineFunctionName("Winnt32WriteParams");
    TraceFunctionEntry(ttidNetUpgrade);

    TraceTag(ttidNetUpgrade, "netupgrd.dll: Winnt32WriteParams(%S)", FileName);

    NC_TRY
    {
        if (*g_PlugInInfo.UpgradeFlag && (!(*g_PlugInInfo.CancelledFlag)))
        {
            // g_pwifAnswerFile needs to be global since functions in
            // oemnuex.cpp require it that way.
            //
            g_pwifAnswerFile = new CWInfFile();

			// initialize answer file class
			if ((g_pwifAnswerFile == NULL) ||
				(g_pwifAnswerFile->Init() == FALSE))
			{
				AssertSz(FALSE,"Winnt32WriteParams 1 - Failed to initialize CWInfFile");
				return(ERROR_OPERATION_ABORTED);
			}

            g_pwifAnswerFile->Open(FileName);

            // ------------------------------------------------------------
            //$ REVIEW  kumarp 25-November-98
            //
            // the code between the two dashed lines in temporary.
            //
            // Currently we do not support merging of the system generated answerfile
            // with the user supplied answerfile, because the code was never
            // designed to handle that. This causes problem (#175623) when a user
            // supplies an answerfile with "NtUpgrade = Yes" value. To get
            // around this problem, we just remove all user supplied
            // networking sections using the following code. As an additional
            // special case, we preserve the key NetComponentsToRemove if
            // present in the [Networking] section of the user supplied answerfile.
            //
            CWInfSection* pwisNetworking;
            TStringList slNetComponentsToRemove;

            // remember the value of NetComponentsToRemove
            if (pwisNetworking =
                g_pwifAnswerFile->FindSection(c_szAfSectionNetworking))
            {
                pwisNetworking->GetStringListValue(c_szAfNetComponentsToRemove,
                                                   slNetComponentsToRemove);
            }

            // get the list of networking sections in the user supplied file
            TStringList slUserSuppliedNetworkingSections;
            GetNetworkingSections(g_pwifAnswerFile,
                                  &slUserSuppliedNetworkingSections);
            TraceStringList(ttidNetUpgrade,
                            L"User supplied networking sections",
                            slUserSuppliedNetworkingSections);

            // remove the user supplied networking sections
            g_pwifAnswerFile->RemoveSections(slUserSuppliedNetworkingSections);

            // if NetComponentsToRemove was specified, re-insert it
            if (slNetComponentsToRemove.size())
            {
                pwisNetworking =
                    g_pwifAnswerFile->AddSection(c_szAfSectionNetworking);
                pwisNetworking->AddKey(c_szAfNetComponentsToRemove,
                                       slNetComponentsToRemove);
            }

            // 295708: cached ptrs may be trashed, so close and reopen the file
            //  Note:   this fix is considered temporary for beta3.  The right fix
            //          is to either fix up the trashed ptrs when removing the sections,
            //          or to check when accessing the ptrs later.  The crash should be
            //          easy to repro by removing the block below and using the answerfile
            //          attached to the bug.
            //
            g_pwifAnswerFile->Close();
            delete g_pwifAnswerFile;
            g_pwifAnswerFile = NULL;
            g_pwifAnswerFile = new CWInfFile();

			// initialize answer file class
			if ((g_pwifAnswerFile == NULL) ||
				(g_pwifAnswerFile->Init() == FALSE))
			{
				AssertSz(FALSE,"Winnt32WriteParams 2 - Failed to initialize CWInfFile");
				return(ERROR_OPERATION_ABORTED);
			}

            g_pwifAnswerFile->Open(FileName);
            // ------------------------------------------------------------

            WriteNetworkInfoToAnswerFile(g_pwifAnswerFile);

            BOOL fStatus = g_pwifAnswerFile->Close();

            delete g_pwifAnswerFile;
            g_pwifAnswerFile = NULL;

            if (!fStatus)
            {
                AbortUpgradeId(GetLastError(), IDS_E_WritingAnswerFile);
            }
            else if( DhcpUpgGetLastError() != NO_ERROR )
            {
                TraceTag(ttidNetUpgrade,  "DhcpUpgGetLastError: %d", DhcpUpgGetLastError() );
                AbortUpgradeId( DhcpUpgGetLastError(), IDS_E_DhcpServerUpgradeError);
            }
        }
        else
        {
            TraceTag(ttidNetUpgrade, "%s: network parameters not written to answerfile: g_pfUpgrade is %d, g_pfCancelled is %d",
                     __FUNCNAME__, *g_PlugInInfo.UpgradeFlag,
                     *g_PlugInInfo.CancelledFlag);
        }
    }
    NC_CATCH_ALL
    {
        TraceTag(ttidNetUpgrade, "%s: exception!!", __FUNCNAME__);
        g_dwUpgradeError = ERROR_OPERATION_ABORTED;
        AbortUpgradeFn(g_dwUpgradeError, c_szExceptionInNetupgrd);
    }

    TraceTag(ttidNetUpgrade, "%s: returning status code: %ld, CancelledFlag: %ld",
             __FUNCNAME__, g_dwUpgradeError, (DWORD) (*g_PlugInInfo.CancelledFlag));

    return g_dwUpgradeError;
}

//+---------------------------------------------------------------------------
//
// Function:  Winnt32Cleanup
//
// Purpose:   Cleanup
//
// Arguments: None
//
// Returns:   ERROR_SUCCESS on success, else win32 error code
//
// Author:    kumarp 19-December-97
//
// Notes:     see winnt32p.h for more information
//
DWORD
CALLBACK
Winnt32Cleanup(
    VOID)
{
    DefineFunctionName("Winnt32Cleanup");
    TraceFunctionEntry(ttidNetUpgrade);

    NC_TRY
    {
        // netmap-info and conflicts-list is initialized in
        // HrInitNetUpgrade and destroyed here
        //
        UnInitNetMapInfo();
        UninitConflictList();

        if (*g_PlugInInfo.CancelledFlag)
        {
            CleanupNetupgrdTempFiles();
            DhcpUpgCleanupDhcpTempFiles();
        }
    }
    NC_CATCH_ALL
    {
        TraceTag(ttidNetUpgrade, "%s: exception!!", __FUNCNAME__);
        g_dwUpgradeError = ERROR_OPERATION_ABORTED;
    }

    TraceTag(ttidNetUpgrade, "%s: returning status code: %ld",
             __FUNCNAME__, g_dwUpgradeError);

    return g_dwUpgradeError;
}

//+---------------------------------------------------------------------------
//
// Function:  GetSections
//
// Purpose:   Enumerate over the keys in the specified section and
//            return value of each key in a list.
//
// Arguments:
//    pwif        [in]  answerfile
//    pszSection   [in]  section to use
//    pslSections [out] list of values of keys in that section
//
// Returns:   None
//
// Author:    kumarp 25-November-98
//
// Notes:
//   For example:
//   if pszSection == NetServices and the answerfile has the following section
//
//   [NetServices]
//   MS_Server = params.MS_Server
//   MS_Foo = params.MS_Foo
//   bar = p.bar
//
//   then this function returns the following list:
//       NetServices,params.MS_Server,params.MS_Foo,p.bar
//
void
GetSections(
    IN CWInfFile* pwif,
    IN PCWSTR pszSection,
    OUT TStringList* pslSections)
{
    AssertValidReadPtr(pwif);
    AssertValidReadPtr(pszSection);
    AssertValidWritePtr(pslSections);

    PCWSTR pszParamsSection;
    CWInfKey* pwik;
    CWInfSection* pwis;

    if (pwis = pwif->FindSection(pszSection))
    {
        pslSections->push_back(new tstring(pszSection));
        pwik = pwis->FirstKey();
        do
        {
            if (pszParamsSection = pwik->GetStringValue(NULL))
            {
                pslSections->push_back(new tstring(pszParamsSection));
            }
        }
        while (pwik = pwis->NextKey());
    }
}

//+---------------------------------------------------------------------------
//
// Function:  GetNetworkingSections
//
// Purpose:   Locate all networking related sections in the specified file
//            and return their names in a list
//
// Arguments:
//    pwif        [in]  answerfile
//    pslSections [out] list of networking sections
//
// Returns:   None
//
// Author:    kumarp 25-November-98
//
// Notes:
//
void
GetNetworkingSections(
    IN CWInfFile* pwif,
    OUT TStringList* pslSections)
{
    if (pwif->FindSection(c_szAfSectionNetworking))
    {
        pslSections->push_back(new tstring(c_szAfSectionNetworking));
    }

    if (pwif->FindSection(c_szAfSectionNetBindings))
    {
        pslSections->push_back(new tstring(c_szAfSectionNetBindings));
    }

    GetSections(pwif, c_szAfSectionNetAdapters, pslSections);
    GetSections(pwif, c_szAfSectionNetServices, pslSections);
    GetSections(pwif, c_szAfSectionNetClients,  pslSections);

    TStringList slProtocolSections;
    TStringListIter pos;
    tstring strSection;
    CWInfSection* pwis;
    TStringList slAdapterSections;

    GetSections(pwif, c_szAfSectionNetProtocols, &slProtocolSections);
    for (pos = slProtocolSections.begin();
         pos != slProtocolSections.end(); )
    {
        strSection = **pos++;
        if (pwis = pwif->FindSection(strSection.c_str()))
        {
            pslSections->push_back(new tstring(strSection));
            pwis->GetStringListValue(c_szAfAdapterSections,
                                     slAdapterSections);
            pslSections->splice(pslSections->end(),
                                slAdapterSections,
                                slAdapterSections.begin(),
                                slAdapterSections.end());
        }
    }
}

//+---------------------------------------------------------------------------
//
// Function:  CleanupNetupgrdTempFiles
//
// Purpose:   Delete any temp files/dirs created
//
// Arguments: None
//
// Returns:   None
//
// Author:    kumarp 19-December-97
//
// Notes:
//
VOID
CleanupNetupgrdTempFiles(
    VOID)
{
    HRESULT hr=S_OK;

    tstring strNetupgrdTempDir;

    hr = HrGetNetUpgradeTempDir(&strNetupgrdTempDir);
    if (S_OK == hr)
    {
        hr = HrDeleteDirectory(strNetupgrdTempDir.c_str(), TRUE);
    }
}

//+---------------------------------------------------------------------------
//
// Function:  AbortUpgradeFn
//
// Purpose:   Helper function for aborting upgrade
//
// Arguments:
//    dwErrorCode [in]  win32 error code
//    pszMessage   [in]  message to be traced
//
// Returns:   None
//
// Author:    kumarp 19-December-97
//
// Notes:
//
VOID
AbortUpgradeFn(
    IN DWORD dwErrorCode,
    IN PCWSTR pszMessage)
{
    DefineFunctionName("AbortUpgradeFn");

    g_dwUpgradeError = dwErrorCode;
    if (g_PlugInInfo.CancelledFlag)
    {
        *g_PlugInInfo.CancelledFlag = TRUE;
    }
    else
    {
        TraceTag(ttidNetUpgrade, "%s: g_PlugInInfo.CancelledFlag is NULL!!",
                 __FUNCNAME__);
    }

    TraceTag(ttidError, "AbortUpgrade: %d: %S", dwErrorCode, pszMessage);
}

//+---------------------------------------------------------------------------
//
// Function:  AbortUpgradeSz
//
// Purpose:   Helper function for aborting upgrade
//
// Arguments:
//    dwErrorCode [in]  win32 error code
//    pszMessage   [in]  message to be displayed and traced
//
// Returns:   None
//
// Author:    kumarp 19-December-97
//
// Notes:
//
VOID
AbortUpgradeSz(
    IN DWORD dwErrorCode,
    IN PCWSTR pszMessage)
{
    AssertValidReadPtr(pszMessage);

    tstring strMessage;

    strMessage  = pszMessage;
    strMessage += L"\n\n";
    strMessage += SzLoadString(g_hinst, IDS_E_SetupCannotContinue);

    AbortUpgradeFn(dwErrorCode, pszMessage);
    MessageBox (NULL, strMessage.c_str(),
                SzLoadString(g_hinst, IDS_NetupgrdCaption),
                MB_OK | MB_TASKMODAL);
}

//+---------------------------------------------------------------------------
//
// Function:  AbortUpgradeId
//
// Purpose:   Helper function for aborting upgrade
//
// Arguments:
//    dwErrorCode  [in]  win32 error code
//    dwResourceId [in]  resource ID of message to be displayed
//
// Returns:   None
//
// Author:    kumarp 19-December-97
//
// Notes:
//
VOID
AbortUpgradeId (
    IN DWORD dwErrorCode,
    IN DWORD dwResourceId)
{
    Assert(g_hinst);

    PCWSTR pszMessage;

    pszMessage = SzLoadString(g_hinst, dwResourceId);
    AbortUpgradeSz(dwErrorCode, pszMessage);
}

//+---------------------------------------------------------------------------
//
// Function:  FIsUpgradeAborted
//
// Purpose:   Determine if the upgrade has been aborted
//
// Arguments: None
//
// Returns:   TRUE on success, FALSE otherwise
//
// Author:    kumarp 19-December-97
//
// Notes:
//
BOOL
FIsUpgradeAborted(
    VOID)
{
    return g_PlugInInfo.CancelledFlag && *g_PlugInInfo.CancelledFlag;
}

//+---------------------------------------------------------------------------
//
// Function:  FGetConfirmationForAbortingUpgrade
//
// Purpose:   Ask user confirmation for aborting upgrade
//
// Arguments:
//    pszMessage [in]  message prompt
//
// Returns:   TRUE on success, FALSE otherwise
//
// Author:    kumarp 19-December-97
//
// Notes:
//
BOOL
FGetConfirmationForAbortingUpgrade(
    IN PCWSTR pszMessage)
{
    tstring strMessage;

    if (pszMessage)
    {
        strMessage = pszMessage;
        strMessage += L"\n\n";
    }

    PCWSTR pszDoYouWantToAbortUpgrade =
        SzLoadString(g_hinst, IDS_DoYouWantToAbortUpgrade);

    strMessage += pszDoYouWantToAbortUpgrade;

    DWORD dwRet = MessageBox (NULL, strMessage.c_str(),
                              SzLoadString(g_hinst, IDS_NetupgrdCaption),
                              MB_YESNO | MB_TASKMODAL);

    return dwRet == IDYES;
}

//+---------------------------------------------------------------------------
//
// Function:  FGetConfirmationAndAbortUpgrade
//
// Purpose:   Abort upgrade if user confirms
//
// Arguments:
//    pszMessage [in]  message prompt
//
// Returns:   TRUE on success, FALSE otherwise
//
// Author:    kumarp 19-December-97
//
// Notes:
//
BOOL
FGetConfirmationAndAbortUpgrade(
    IN PCWSTR pszMessage)
{
    BOOL fUpgradeAborted=FALSE;

    if (FGetConfirmationForAbortingUpgrade(pszMessage))
    {
        AbortUpgradeFn(ERROR_SUCCESS, pszMessage);
        fUpgradeAborted = TRUE;
    }

    return fUpgradeAborted;
}

//+---------------------------------------------------------------------------
//
// Function:  FGetConfirmationAndAbortUpgradeId
//
// Purpose:   Abort upgrade if user confirms
//
// Arguments:
//    dwErrorMessageId [in]  message prompt
//
// Returns:   TRUE on success, FALSE otherwise
//
// Author:    kumarp 19-December-97
//
// Notes:
//
BOOL
FGetConfirmationAndAbortUpgradeId(
    IN DWORD dwErrorMessageId)
{
    return FGetConfirmationAndAbortUpgrade(SzLoadString(g_hinst,
                                                        dwErrorMessageId));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\upgrade\netupgrd\nucompat.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       N U C O M P A T . C P P
//
//  Contents:
//
//
//  Notes:
//
//  Author:     kumarp 04/12/97 17:17:27
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

#include "comp.h"
#include "conflict.h"
#include "infmap.h"
#include "kkstl.h"
#include "kkutils.h"
#include "ncsetup.h"
#include "oemupg.h"
#include "ncsvc.h"

// ----------------------------------------------------------------------
// String constants
const WCHAR sz_DLC[] = L"DLC";

#ifdef _X86_

#define NWC_PRINT_PROVIDER    101
#define MAX_BUF_SIZE          350

const WCHAR c_szNWCWorkstation[] = L"NWCWorkstation";
const WCHAR c_szNWCfgDll[] = L"System32\\nwcfg.dll";

const WCHAR c_szProviders[] = L"System\\CurrentControlSet\\Control\\Print\\Providers";
const WCHAR c_szNWCPrintProviderKey[] = L"System\\CurrentControlSet\\Control\\Print\\Providers\\Netware or Compatible Network";
const WCHAR c_szOrder[] = L"Order";
const WCHAR c_szTmpPrefix[] = L"$net";
const WCHAR c_szNWCSection[] = L"RenameNWCPrintProvider";
const WCHAR c_szUpdateProviderOrder[] = L"UpdateProvidersOrder";
const WCHAR c_szNWCDelReg[] = L"NWCProviderDelReg";
const WCHAR c_szNWCAddReg[] = L"NWCProviderAddReg";
const WCHAR c_szNWCPrintProviderName[] = L"Netware or Compatible Network";
const WCHAR c_szDefaultDisplayName[] = L"DisplayName";
const WCHAR c_szDefaultName[] = L"Name";
const WCHAR c_szDefaultameValue [] = L"nwprovau.dll";

static DWORD g_dwBytesWritten;
static WCHAR g_buf[MAX_BUF_SIZE+1];

#endif

const WCHAR c_szDefaultTextFile[]     = L"winntupg\\unsupmsg.txt";

void GetHelpFile(IN PCWSTR pszPreNT5InfId,
                 OUT tstring* pstrTextHelpFile,
                 OUT tstring* pstrHtmlHelpFile);

#ifdef _X86_

VOID FixNWClientPrinProviderName (PCOMPAIBILITYCALLBACK CompatibilityCallback, LPVOID Context);
HRESULT DumpProvidersOrder (HANDLE hFile, LPWSTR lpszPrintProviderName);
HRESULT DumpNWPrintProviderKey (HANDLE hFile, LPWSTR lpszPrintProviderName);
BOOL IsNT4Upgrade (VOID);
BOOL IsNetWareClientKeyLocalized (VOID);
HRESULT GetNWPrintProviderName (LPWSTR *lppPrintProvider);

#endif

// ----------------------------------------------------------------------
//
// Function:  NetUpgradeCompatibilityCheck
//
// Purpose:   This functions is called by winnt32.exe so that we
//            can scan the system to find any potential upgrade problems
//
//            For each such problem-net-component found, we call
//            CompatibilityCallback to report it to winnt32
//
// Arguments:
//    CompatibilityCallback [in]  pointer to COMPAIBILITYCALLBACK fn
//    Context               [in]  pointer to compatibility context
//
// Returns:
//
// Author:    kumarp 21-May-98
//
// Notes:
//
BOOL
WINAPI
NetUpgradeCompatibilityCheck(
    PCOMPAIBILITYCALLBACK CompatibilityCallback,
    LPVOID Context)
{
    DefineFunctionName("NetUpgradeCompatibilityCheck");

    TraceTag(ttidNetUpgrade, "entering ---> %s", __FUNCNAME__);

    HRESULT hr=S_OK;
    TPtrList* plNetComponents;
    TPtrListIter pos;
    COMPATIBILITY_ENTRY ce;
    CNetComponent* pnc;
    DWORD dwError;

    hr = HrGetConflictsList(&plNetComponents);
    if (S_OK == hr)
    {
        tstring strHtmlHelpFile;
        tstring strTextHelpFile;

        for (pos = plNetComponents->begin();
             pos != plNetComponents->end(); pos++)
        {
            pnc = (CNetComponent*) *pos;

            GetHelpFile(pnc->m_strPreNT5InfId.c_str(),
                        &strTextHelpFile, &strHtmlHelpFile);

            // prepare the entry
            //
            ZeroMemory(&ce, sizeof(ce));
            ce.Description    = (PWSTR) pnc->m_strDescription.c_str();
            ce.HtmlName       = (PWSTR) strHtmlHelpFile.c_str();
            ce.TextName       = (PWSTR) strTextHelpFile.c_str();
            ce.RegKeyName     = NULL;
            ce.RegValName     = NULL;
            ce.RegValDataSize = 0;
            ce.RegValData     = 0;
            ce.SaveValue      = (LPVOID) pnc;
            ce.Flags          = COMPFLAG_USE_HAVEDISK;

            TraceTag(ttidNetUpgrade,
                     "%s: calling CompatibilityCallback for '%S': %S, %S...",
                     __FUNCNAME__, ce.Description, ce.HtmlName, ce.TextName);

            dwError = CompatibilityCallback(&ce, Context);
            TraceTag(ttidNetUpgrade, "...CompatibilityCallback returned 0x%x",
                     dwError);
        }

    }
    else if (FAILED(hr))
    {
        TraceTag(ttidNetUpgrade, "%s: HrGetConflictsList returned err code: 0x%x",
                 __FUNCNAME__, hr);
    }

#ifdef _X86_

    // Raid Bug 327760: Change localized Netware Print Provider name to English.

    FixNWClientPrinProviderName( CompatibilityCallback, Context );
#endif

    return SUCCEEDED(hr);
}

// ----------------------------------------------------------------------
//
// Function:  NetUpgradeHandleCompatibilityHaveDisk
//
// Purpose:   This callback function is called by winnt32.exe
//            if user clicks HaveDisk button on the compatibility
//            report page.
//
// Arguments:
//    hwndParent [in]  handle of parent window
//    SaveValue  [in]  pointer to private data
//                     (we store CNetComponent* in this pointer)
//
// Returns:
//
// Author:    kumarp 21-May-98
//
// Notes:
//
DWORD
WINAPI
NetUpgradeHandleCompatibilityHaveDisk(HWND hwndParent,
                                      LPVOID SaveValue)
{
    DefineFunctionName("NetUpgradeHandleCompatibilityHaveDisk");

    HRESULT hr=S_OK;
    BOOL fStatus = FALSE;
    DWORD dwStatus=ERROR_SUCCESS;
    CNetComponent* pnc=NULL;
    PCWSTR pszComponentDescription;

    static const WCHAR c_szNull[] = L"<Null>";

    if (SaveValue)
    {
        pnc = (CNetComponent*) SaveValue;
        pszComponentDescription = pnc->m_strDescription.c_str();
    }
    else
    {
        pszComponentDescription = c_szNull;
    }

    TraceTag(ttidNetUpgrade, "%s: called for %S...",
             __FUNCNAME__, pszComponentDescription);

    if (pnc)
    {
        tstring strOemDir;

        hr = HrShowUiAndGetOemFileLocation(hwndParent,
                                           pszComponentDescription,
                                           &strOemDir);

        if (S_OK == hr)
        {
            hr = HrProcessAndCopyOemFiles(strOemDir.c_str(), TRUE);
        }
    }
    else
    {
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
    }

    TraceErrorOptional(__FUNCNAME__, hr, (S_FALSE == hr));

    if (S_FALSE == hr)
    {
        // this will ensure that winnt32 will not take this item
        // off the compatibility list
        //
        dwStatus = ERROR_FILE_NOT_FOUND;
    }
    else
    {
        dwStatus = DwWin32ErrorFromHr(hr);
    }

    return dwStatus;
}

// ----------------------------------------------------------------------
//
// Function:  GetHelpFile
//
// Purpose:   Get name of help file for an unsupported component
//
// Arguments:
//    hinfNetUpg       [in]  handle of netupg.inf
//    pszPreNT5InfId    [in]  pre-NT5 InfId
//    pstrTextHelpFile [out] name of the text file found
//    pstrHtmlHelpFile [out] name of the html file found
//
// Returns:   None
//
// Author:    kumarp 22-May-98
//
// Notes:
//
void GetHelpFile(IN PCWSTR pszPreNT5InfId,
                 OUT tstring* pstrTextHelpFile,
                 OUT tstring* pstrHtmlHelpFile)
{
    // Known txt/htm files
    if (lstrcmpiW(pszPreNT5InfId, sz_DLC) == 0)
    {
        *pstrTextHelpFile = L"compdata\\dlcproto.txt";
        *pstrHtmlHelpFile = L"compdata\\dlcproto.htm";
        return;
    }

    // Unknown or OEM files
    static const WCHAR c_szOemUpgradeHelpFiles[] = L"OemUpgradeHelpFiles";
    static const WCHAR c_szDefaultHtmlFile[]     = L"winntupg\\unsupmsg.htm";

    HRESULT hr=S_OK;
    INFCONTEXT ic;
    tstring strText;
    tstring strHtml;
    tstring strNT5InfId;
    BOOL fIsOemComponent=FALSE;
    CNetMapInfo* pnmi=NULL;

    *pstrTextHelpFile = c_szDefaultTextFile;
    *pstrHtmlHelpFile = c_szDefaultHtmlFile;

    hr = HrMapPreNT5NetComponentInfIDToNT5InfID(pszPreNT5InfId,
                                                &strNT5InfId,
                                                &fIsOemComponent,
                                                NULL, &pnmi);

    if ((S_FALSE == hr) && !strNT5InfId.empty())
    {
        hr = HrSetupFindFirstLine(pnmi->m_hinfNetMap, c_szOemUpgradeHelpFiles,
                                  strNT5InfId.c_str(), &ic);
        if (S_OK == hr)
        {
            hr = HrSetupGetStringField(ic, 1, &strText);
            if (S_OK == hr)
            {
                hr = HrSetupGetStringField(ic, 2, &strHtml);
                if (S_OK == hr)
                {
                    *pstrTextHelpFile = pnmi->m_strOemDir;
                    *pstrHtmlHelpFile = pnmi->m_strOemDir;
                    AppendToPath(pstrTextHelpFile, strText.c_str());
                    AppendToPath(pstrHtmlHelpFile, strHtml.c_str());
                }
            }
        }
    }
}

#ifdef _X86_

// ----------------------------------------------------------------------
//
// Function:  FixNWClientPrinProviderName
//
// Purpose:   Change the localized Print Provider name to English.
//
// Arguments:
//
// Returns:   None
//
// Author:    asinha 14-June-01
//
// Notes:
//

VOID FixNWClientPrinProviderName (PCOMPAIBILITYCALLBACK CompatibilityCallback,
                                  LPVOID Context)
{
    DefineFunctionName( "FixNWClientPrinProviderName" );

    TraceTag(ttidNetUpgrade, "entering ---> %s", __FUNCNAME__);

    LPWSTR  lpszPrintProviderName;
    WCHAR   lpTmpFile[MAX_PATH+1];
    WCHAR   lpTmpPath[MAX_PATH+1];
    HANDLE  hFile;
    DWORD   dwChars;
    COMPATIBILITY_ENTRY ce;
    BOOL    bRet;
    HRESULT hr=S_OK;

    //
    // Is it an upgrade from NT 4.0 and the Netware print provider name localized?
    //

    if ( IsNT4Upgrade() && IsNetWareClientKeyLocalized() )
    {
        TraceTag( ttidNetUpgrade, "%s: Netware Print Provider name is localized.",
                  __FUNCNAME__ );

        // Get the localized Netware print provider name from nwcfg.dll.

        hr = GetNWPrintProviderName( &lpszPrintProviderName ); 

        if ( hr == S_OK )
        {
            TraceTag( ttidNetUpgrade, "%s: Netware Print Provider name is: %S",
                      __FUNCNAME__, lpszPrintProviderName );

            // Create a .tmp filename where INF directives are written to rename
            // the print provider name into English. This INF file will be executed
            // by base setup in GUI mode.
            //
 
            GetTempPathW( MAX_PATH, lpTmpPath );

            if ( GetTempFileNameW( lpTmpPath, c_szTmpPrefix, 1, lpTmpFile) )
            {
                hFile = CreateFileW( lpTmpFile,
                                    GENERIC_WRITE | GENERIC_WRITE,
                                    0,
                                    NULL,
                                    CREATE_ALWAYS,
                                    FILE_ATTRIBUTE_NORMAL,
                                    NULL );
                if ( hFile != INVALID_HANDLE_VALUE )
                {

                    // Write the initial entries.

                    dwChars = wsprintfW( g_buf, L"[Version]\r\n"
                                        L"Signature=\"$WINDOWS NT$\"\r\n"
                                        L"Provider=Microsoft\r\n"
                                        L"LayoutFile=layout.inf\r\n\r\n"
                                        L"[%s]\r\n"
                                        L"AddReg=%s\r\n"
                                        L"DelReg=%s\r\n"
                                        L"AddReg=%s\r\n",
                                        c_szNWCSection,
                                        c_szUpdateProviderOrder,
                                        c_szNWCDelReg,
                                        c_szNWCAddReg );

                    Assert( dwChars <= MAX_BUF_SIZE );

                    WriteFile( hFile,
                               g_buf,
                               dwChars * sizeof(WCHAR),
                               &g_dwBytesWritten, 
                               NULL );

                    Assert( g_dwBytesWritten == (dwChars * sizeof(WCHAR)) );

                    // Write the HKLM\System\CCS\Control\Print\Providers\Order values.

                    hr = DumpProvidersOrder( hFile, lpszPrintProviderName );

                    if ( hr == S_OK )
                    {

                        // Write addreg/delreg directives to change the Print Provider name

                        hr = DumpNWPrintProviderKey( hFile, lpszPrintProviderName );

                        if ( hr == S_OK )
                        {
                            CloseHandle( hFile );
                            hFile = INVALID_HANDLE_VALUE;

                            // Call the compatibility callback so the %temp%\$ne1.tmp INF file
                            // is executed in GUI mode setup.

                            ZeroMemory( &ce, sizeof(ce) );

                            ce.Description = (PWSTR)c_szNWCPrintProviderName;
                            ce.TextName    = (PWSTR)c_szDefaultTextFile;
                            ce.InfName     = (PWSTR)lpTmpFile;
                            ce.InfSection  = (PWSTR)c_szNWCSection;
                            ce.Flags       = COMPFLAG_HIDE;

                            TraceTag(ttidNetUpgrade,
                                     "%s: calling CompatibilityCallback for '%S'...",
                                     __FUNCNAME__, ce.Description );

                            bRet = CompatibilityCallback( &ce, Context );
                            TraceTag( ttidNetUpgrade, "...CompatibilityCallback returned %#x",
                                     bRet );
                        }
                    }

                    if ( hFile != INVALID_HANDLE_VALUE )
                    {
                        CloseHandle( hFile );
                    }
                }
                else
                {
                    TraceTag( ttidNetUpgrade, "%s: Failed to open %S.",
                              __FUNCNAME__, lpTmpFile );

                    hr = HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED);
                }
            }
            else
            {
                hr = HRESULT_FROM_WIN32(GetLastError());

                TraceTag( ttidNetUpgrade, "%s: GetTempFileName failed, path=%S, prefix=%S: Error=%#x",
                          __FUNCNAME__, lpTmpPath, c_szTmpPrefix, hr );

            }

            MemFree( lpszPrintProviderName );
        }
        else
        {
            TraceTag( ttidNetUpgrade, "%s: GetNWPrintProviderName returned error : %#x",
                      __FUNCNAME__, hr );
        }
    }

    TraceTag(ttidNetUpgrade, "<---%s: hr = %#x",
             __FUNCNAME__, hr);
    return;
}

// Write addreg to update HKLM\System\CCS\Control\Print\Order value with the Netware Print Provider
// in English.

HRESULT DumpProvidersOrder (HANDLE hFile, LPWSTR lpszPrintProviderName)
{
    
    DefineFunctionName( "DumpProvidersOrder" );
    TraceTag(ttidNetUpgrade, "entering ---> %s", __FUNCNAME__);

    HKEY hkeyProviders;
    DWORD dwValueLen;
    LPWSTR lpValue;
    LPWSTR lpTemp;
    DWORD  dwChars;
    LONG   lResult;

    dwChars = wsprintfW( g_buf, L"\r\n[%s]\r\n", c_szUpdateProviderOrder );

    Assert( dwChars <= MAX_BUF_SIZE );

    WriteFile( hFile,
               g_buf,
               dwChars * sizeof(WCHAR),
               &g_dwBytesWritten,
               NULL );

    Assert( g_dwBytesWritten == (dwChars * sizeof(WCHAR)) );

    lResult = RegOpenKeyExW( HKEY_LOCAL_MACHINE,
                             c_szProviders,
                             0,
                             KEY_READ,
                             &hkeyProviders );

    if ( lResult == ERROR_SUCCESS )
    {

        // First query how many bytes are needed to read the value.
 
        lResult = RegQueryValueExW( hkeyProviders, // handle to key
                                    c_szOrder,      // value name
                                    NULL,          // reserved
                                    NULL,          // type buffer
                                    NULL,          // data buffer
                                    &dwValueLen ); // size of data buffer
        if ( lResult == ERROR_SUCCESS )
        {
            lpValue = (LPWSTR)MemAlloc( dwValueLen );

            if ( lpValue )
            {
                // Read the old value which is a multi_sz.
               
                lResult = RegQueryValueExW( hkeyProviders,  // handle to key
                                            c_szOrder,       // value name
                                            NULL,           // reserved
                                            NULL,           // type buffer
                                            (LPBYTE)lpValue,// data buffer
                                            &dwValueLen ); // size of data buffer
                if ( lResult == ERROR_SUCCESS )
                {
                    lpTemp = lpValue;

                    dwChars = wsprintfW( g_buf,
                                        L"HKLM,\"%s\",\"%s\",0x00010020",
                                        c_szProviders, c_szOrder );

                    Assert( dwChars <= MAX_BUF_SIZE );

                    WriteFile( hFile,
                               g_buf,
                               dwChars * sizeof(WCHAR),
                               &g_dwBytesWritten,
                               NULL );

                    Assert( g_dwBytesWritten == (dwChars * sizeof(WCHAR)) );

                    // Write each print provider name.

                    while( *lpTemp )
                    {
                        // If we find a localized one then, we write its English name.

                        if ( _wcsicmp( lpTemp, lpszPrintProviderName) != 0 )
                        {
                            dwChars = wsprintfW( g_buf, L",\"%s\"", lpTemp );

                            Assert( dwChars <= MAX_BUF_SIZE );
    
                            TraceTag( ttidNetUpgrade, "%s: Writing print provider name %S.",
                                      __FUNCNAME__, lpTemp );
                        }
                        else
                        {
                            dwChars = wsprintfW( g_buf, L",\"%s\"", c_szNWCPrintProviderName );

                            Assert( dwChars <= MAX_BUF_SIZE );

                            TraceTag( ttidNetUpgrade, "%s: Writing print provider name %S.",
                                      __FUNCNAME__, c_szNWCPrintProviderName );
                        }

                        WriteFile( hFile,
                                   g_buf,
                                   dwChars * sizeof(WCHAR),
                                   &g_dwBytesWritten,
                                   NULL );

                        Assert( g_dwBytesWritten == (dwChars * sizeof(WCHAR)) );

                        // Get next print provider name.

                        lpTemp += lstrlenW( lpTemp ) + 1;
                    }

                    dwChars = wsprintfW( g_buf, L"\r\n" );

                    Assert( dwChars <= MAX_BUF_SIZE );

                    WriteFile( hFile,
                               g_buf,
                               dwChars * sizeof(WCHAR),
                               &g_dwBytesWritten,
                               NULL );

                    Assert( g_dwBytesWritten == (dwChars * sizeof(WCHAR)) );

                }
                else
                {
                    TraceTag( ttidNetUpgrade, "%s: RegQueryValueExW failed to open '%S' value, Error: %#x",
                             c_szOrder, HRESULT_FROM_WIN32(lResult) );
                }

                MemFree( lpValue );
            }
            else
            {
                lResult = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
            }
        }
        else
        {
            TraceTag(ttidNetUpgrade, "RegQueryValueExW failed to open '%S' value, Error: %#x",
                     __FUNCNAME__, c_szOrder, HRESULT_FROM_WIN32(lResult) );
        }

        RegCloseKey( hkeyProviders );
    }
    else
    {
        TraceTag(ttidNetUpgrade, "%s: RegOpenKeyExW failed to open '%S' key, Error: %#x",
                 __FUNCNAME__, c_szProviders, HRESULT_FROM_WIN32(lResult) );
    }

    TraceTag(ttidNetUpgrade, "<---%s: hr = %#x",
             __FUNCNAME__, HRESULT_FROM_WIN32(lResult));

    return HRESULT_FROM_WIN32(lResult);
}

// Write delreg/addreg directives to rename the Netware PrintProvider name into English.

HRESULT DumpNWPrintProviderKey (HANDLE hFile, LPWSTR lpszPrintProviderName)
{
    DefineFunctionName( "DumpNWPrintProviderKey" );
    TraceTag(ttidNetUpgrade, "entering ---> %s", __FUNCNAME__);

    HKEY   hkeyNWPrinProvider;
    WCHAR  szNWPrintProvider[MAX_PATH+1];
    DWORD  dwMaxValueNameLen;
    DWORD  dwMaxValueLen;
    DWORD  dwNameLen;
    DWORD  dwValueLen;
    DWORD  dwCount;
    DWORD  i;
    DWORD  dwChars;
    LPWSTR lpValueName;
    LPWSTR lpValue;
    LONG   lResult;

    dwChars = wsprintfW( szNWPrintProvider, L"%s\\%s",
                         c_szProviders,
                         lpszPrintProviderName );

    Assert( dwChars <= MAX_BUF_SIZE );

    dwChars = wsprintfW( g_buf, L"\r\n[%s]\r\n"
                         L"HKLM,\"%s\"\r\n",
                         c_szNWCDelReg, szNWPrintProvider );

    Assert( dwChars <= MAX_BUF_SIZE );

    WriteFile( hFile,
               g_buf,
               dwChars * sizeof(WCHAR),
               &g_dwBytesWritten,
               NULL );

    Assert( g_dwBytesWritten == (dwChars * sizeof(WCHAR)) );

    dwChars = wsprintfW( g_buf, L"\r\n[%s]\r\n", c_szNWCAddReg );

    Assert( dwChars <= MAX_BUF_SIZE );

    WriteFile( hFile,
               g_buf,
               dwChars * sizeof(WCHAR),
               &g_dwBytesWritten,
               NULL );

    Assert( g_dwBytesWritten == (dwChars * sizeof(WCHAR)) );

    // Open the localize Netware print provider key.

    lResult = RegOpenKeyExW( HKEY_LOCAL_MACHINE,
                             szNWPrintProvider,
                             0,
                             KEY_READ,
                             &hkeyNWPrinProvider );

    if ( lResult == ERROR_SUCCESS )
    {
        // Find out the space needed for longest name and largest value and how many values.

        lResult = RegQueryInfoKeyW( hkeyNWPrinProvider,
                                    NULL,
                                    NULL,
                                    NULL,
                                    NULL,
                                    NULL,
                                    NULL,
                                    &dwCount,
                                    &dwMaxValueNameLen,
                                    &dwMaxValueLen,
                                    NULL,
                                    NULL );
        if ( lResult == ERROR_SUCCESS )
        {
            // Add some padding.

            dwMaxValueLen += 4;
            dwMaxValueNameLen += 4;

            lpValueName = (LPWSTR)MemAlloc( dwMaxValueNameLen * sizeof(WCHAR) );
            lpValue = (LPWSTR)MemAlloc( dwMaxValueLen );

            if ( lpValueName && lpValue )
            {

                // Enumerate each value and write it to the INF file.

                for (i=0; i < dwCount; ++i)
                {
                    dwNameLen = dwMaxValueNameLen;
                    dwValueLen = dwMaxValueLen;

                    lResult = RegEnumValueW(hkeyNWPrinProvider,
                                            i,
                                            lpValueName,
                                            &dwNameLen,
                                            NULL,
                                            NULL,
                                            (LPBYTE)lpValue,
                                            &dwValueLen );

                    Assert( lResult == ERROR_SUCCESS );

                    if ( lResult == ERROR_SUCCESS )
                    {
                        dwChars = wsprintfW( g_buf,
                                             L"HKLM,\"%s\",\"%s\",,\"%s\"\r\n",
                                             c_szNWCPrintProviderKey, lpValueName, lpValue );

                        Assert( dwChars <= MAX_BUF_SIZE );

                        WriteFile( hFile,
                                   g_buf,
                                   dwChars * sizeof(WCHAR),
                                   &g_dwBytesWritten,
                                   NULL );

                        Assert( g_dwBytesWritten == (dwChars * sizeof(WCHAR)) );

                        TraceTag( ttidNetUpgrade, "%s: Writing value name %S, value %S",
                                  __FUNCNAME__, lpValueName, lpValue );
                    }
                    else
                    {
                        TraceTag( ttidNetUpgrade, "%s: RegEnumValueW(%d) failed. Error: %#x",
                                 __FUNCNAME__, i, HRESULT_FROM_WIN32(lResult) );
                    }

                }

                lResult = ERROR_SUCCESS;
            }
            else
            {
                lResult = ERROR_NOT_ENOUGH_MEMORY;
            }

            if ( lpValueName )
            {
                MemFree( lpValueName );
            }

            if ( lpValue )
            {
                MemFree( lpValue );
            }
        }

        RegCloseKey( hkeyNWPrinProvider );
    }
    else
    {

        // For some reason, we couldn't open the localized Netware Print Provider name. So, we
        // write the default values.
        //

        TraceTag(ttidNetUpgrade,"%s: RegOpenKeyExW failed to open '%S' key, Error: %#x",
                 __FUNCNAME__, szNWPrintProvider, HRESULT_FROM_WIN32(lResult) );

        dwChars = wsprintfW( g_buf,
                             L"HKLM,\"%s\",\"%s\",,\"%s\"\r\n",
                             c_szNWCPrintProviderKey, c_szDefaultDisplayName, lpszPrintProviderName );

        Assert( dwChars <= MAX_BUF_SIZE );

        WriteFile( hFile,
                   g_buf,
                   dwChars * sizeof(WCHAR),
                   &g_dwBytesWritten,
                   NULL );

        Assert( g_dwBytesWritten == (dwChars * sizeof(WCHAR)) );

        dwChars = wsprintfW( g_buf,
                             L"HKLM,\"%s\",\"%s\",,\"%s\"\r\n",
                             c_szNWCPrintProviderKey, c_szDefaultName, c_szDefaultameValue );

        Assert( dwChars <= MAX_BUF_SIZE );

        WriteFile( hFile,
                   g_buf,
                   dwChars * sizeof(WCHAR),
                   &g_dwBytesWritten,
                   NULL );

        Assert( g_dwBytesWritten == (dwChars * sizeof(WCHAR)) );

        lResult = ERROR_SUCCESS;
    }

    TraceTag(ttidNetUpgrade, "<---%s: hr = %#x",
             __FUNCNAME__, HRESULT_FROM_WIN32(lResult));

    return HRESULT_FROM_WIN32(lResult);
}

BOOL IsNT4Upgrade (VOID)
{
    OSVERSIONINFO osvi;

    ZeroMemory( &osvi,
                sizeof(OSVERSIONINFO) );
    
    osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);

    if ( GetVersionEx(&osvi) )
    {
        return ( (osvi.dwPlatformId == VER_PLATFORM_WIN32_NT) && 
                 (osvi.dwMajorVersion == 4) &&
                 (osvi.dwMinorVersion == 0) );
    }

    return TRUE;
 }

// Determine if Netware print provider name is localized.

BOOL IsNetWareClientKeyLocalized (VOID)
{
    CServiceManager sm;
    CService        srv;
    HKEY            hKey;
    HRESULT         hr;
    LONG            lResult = ERROR_SUCCESS;

    // Is CSNW installed?

    if ( sm.HrOpenService(&srv,
                          c_szNWCWorkstation) == S_OK )
    {
        srv.Close();

        // Open the Netware print provider name key assuming it is in English.
       
        lResult = RegOpenKeyExW( HKEY_LOCAL_MACHINE,
                                 c_szNWCPrintProviderKey,
                                 0,
                                 KEY_READ,
                                 &hKey );
        if ( lResult == ERROR_SUCCESS )
        {
            RegCloseKey( hKey );
        }
    }

    // If we successfully opened the key then, it is not localized.

    return lResult != ERROR_SUCCESS;
}

// Get the localized Netware Print provider name from nwcfg.dll.

HRESULT GetNWPrintProviderName (LPWSTR *lppPrintProvider)
{
    LPWSTR  lpszNWCfgDll;
    int     iLen;
    HMODULE hModule;
    WCHAR   lpszNWCName[100];
    DWORD   dwLen;
    HRESULT hr;

    *lppPrintProvider = NULL;

    dwLen = GetWindowsDirectoryW( NULL, 0 );

    if ( dwLen == 0 )
    {
        return HRESULT_FROM_WIN32(GetLastError());
    }

    lpszNWCfgDll = (LPWSTR)MemAlloc( (dwLen + celems(c_szNWCfgDll) + 2)
                                    * sizeof(WCHAR) );

    if ( !lpszNWCfgDll )
    {
        return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
    }

    if ( GetWindowsDirectoryW(lpszNWCfgDll, dwLen) == 0 )
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }
    else
    {
        if ( lpszNWCfgDll[dwLen-1] == L'\\' )
        {
            lstrcatW( lpszNWCfgDll, c_szNWCfgDll );
        }
        else
        {
            lstrcatW( lpszNWCfgDll, L"\\" );
            lstrcatW( lpszNWCfgDll, c_szNWCfgDll );
        }

        hModule = LoadLibraryExW( lpszNWCfgDll, NULL, LOAD_LIBRARY_AS_DATAFILE );

        if ( hModule )
        {
            iLen = LoadStringW( hModule, NWC_PRINT_PROVIDER, lpszNWCName, 100 );

            if ( iLen > 0 )
            {
                *lppPrintProvider = (LPWSTR)MemAlloc( (iLen + 1) * sizeof(WCHAR) );

                lstrcpyW( *lppPrintProvider, lpszNWCName );

                hr = S_OK;
            }
            else
            {
                hr = HRESULT_FROM_WIN32( GetLastError() );
            }

            FreeLibrary( hModule );
        }
        else
        {
            hr = HRESULT_FROM_WIN32( GetLastError() );
        }
    }

    MemFree( lpszNWCfgDll );
    return hr;
}



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\upgrade\netupgrd\nustrs.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT5.0
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       N U S T R S . C P P
//
//  Contents:   Strings constants for netupgrd
//
//  Notes:
//
//  Author:     kumarp    16-October-97
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "nustrs.h"

const WCHAR c_szType[]                   = L"Type";
const WCHAR c_szLinkage[]                = L"Linkage";
const WCHAR c_szLinkageDisabled[]        = L"Linkage\\Disabled";
const WCHAR c_szRegKeyAdapterHome[]      = L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\NetworkCards";
const WCHAR c_szHidden[]                 = L"Hidden";
const WCHAR c_szRegKeyNetRules[]         = L"NetRules";
const WCHAR c_szRegValInfOption[]        = L"InfOption";
const WCHAR c_szRegValDescription[]      = L"Description";

const WCHAR c_szRegValSoftwareType[]     = L"SoftwareType";
const WCHAR c_szSoftwareTypeTransport[]  = L"transport";
const WCHAR c_szSoftwareTypeDriver[]     = L"driver";
const WCHAR c_szSoftwareTypeService[]    = L"service";
const WCHAR c_szSoftwareTypeSystem[]     = L"system";
const WCHAR c_szSoftwareTypeClient[]     = L"client";
const WCHAR c_szRegKeySoftware[]         = L"Software";
const WCHAR c_szRegKeyCurrentVersion[]   = L"CurrentVersion";
const WCHAR c_szRegKeyMicrosoft[]        = L"Microsoft";

const WCHAR c_szNetCard[]                = L"Net Card";

const WCHAR c_szRegValComputerName[]     = L"SYSTEM\\CurrentControlSet\\Control\\ComputerName\\ComputerName";
const WCHAR c_szComputerName[]           = L"ComputerName";
const WCHAR c_szRegKeySoftwareMicrosoft[]= L"Software\\Microsoft";
const WCHAR c_szRegValRoute[]            = L"Route";
const WCHAR c_szRegValBind[]             = L"Bind";
const WCHAR c_szSvcTcpip[]               = L"Tcpip";
const WCHAR c_szSvcNetBT[]               = L"NetBT";
const WCHAR c_szNoParamsRequired[]       = L"This component does not require any parameters";
const WCHAR c_szNotSupported[]           = L"NotSupported";
const WCHAR c_szDhcpServerLinkageDisabled[] = L"SYSTEM\\CurrentControlSet\\Services\\DhcpServer\\Linkage\\Disabled";
const WCHAR c_szRegWlbsLinkage[]         = L"SYSTEM\\CurrentControlSet\\Services\\WLBS\\Linkage";
const WCHAR c_szRegConvoyLinkage[]       = L"SYSTEM\\CurrentControlSet\\Services\\Convoy\\Linkage";
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\upgrade\netupgrd\nuutils.h ===
#pragma once

HRESULT HrGetNetupgrdDir(OUT tstring* pstrNetupgrdDir);

HRESULT HrCopyFiles(IN PCWSTR pszSrcDir, IN PCWSTR pszDstDir);
HRESULT HrDeleteDirectory(IN PCWSTR pszDir,
                          IN BOOL fContinueOnError);
HRESULT HrSetupGetLineText(PINFCONTEXT Context,
                           HINF hinf,
                           PCWSTR pszSection,
                           PCWSTR pszKey,
                           tstring* pstrReturnedText);
HRESULT HrRegOpenServiceSubKey(IN PCWSTR pszServiceName,
                               IN PCWSTR pszSubKeyName,
                               REGSAM samDesired,
                               OUT HKEY* phKey);
HRESULT HrGetPreNT5InfIdAndDesc(IN HKEY hkeyCurrentVersion,
                                OUT tstring* pstrInfId,
                                OUT tstring* pstrDescription,
                                OUT tstring* pstrServiceName);
void GetUnsupportedMessage(IN PCWSTR pszComponentType,
                           IN PCWSTR pszPreNT5InfId,
                           IN PCWSTR pszDescription,
                           OUT tstring* pstrMsg);
void GetUnsupportedMessageBool(IN BOOL    fIsHardwareComponent,
                               IN PCWSTR pszPreNT5InfId,
                               IN PCWSTR pszDescription,
                               OUT tstring* pstrMsg);
void ConvertMultiSzToDelimitedList(IN  PCWSTR  mszList,
                                   IN  WCHAR    chDelimeter,
                                   OUT tstring* pstrList);
#ifdef ENABLETRACE
void TraceStringList(IN TraceTagId ttid,
                     IN PCWSTR pszMsgPrefix,
                     IN TStringList& sl);
void TraceMultiSz(IN TraceTagId ttid,
                  IN PCWSTR pszMsgPrefix,
                  IN PCWSTR msz);
#else
#define TraceStringList(ttid,szMsgPrefix,sl) (void) 0
#define TraceMultiSz(ttid,szMsgPrefix,msz) (void) 0
#endif

HRESULT HrGetWindowsDir(OUT tstring* pstrWinDir);
HRESULT HrDirectoryExists(IN PCWSTR pszDir);
BOOL FIsPreNT5NetworkingInstalled();
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\upgrade\netupgrd\oemupg.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       O E M U P G . C P P
//
//  Contents:   Down level upgrade code for OEM cards
//
//  Notes:
//
//  Author:     kumarp    12 April 97
//
//----------------------------------------------------------------------------


#include "pch.h"
#pragma hdrstop

#include "conflict.h"
#include "infmap.h"
#include "kkcwinf.h"
#include "kkutils.h"
#include "nceh.h"
#include "ncsetup.h"
#include "netupgrd.h"
#include "nustrs.h"
#include "nuutils.h"
#include "oemupg.h"
#include "oemupgex.h"
#include "resource.h"


static const WCHAR c_szOemNMapFileName[] = L"netmap.inf";

TNetMapArray* g_pnmaNetMap=NULL;

#if 0
extern BOOL g_fForceNovellDirCopy;
#endif

//----------------------------------------------------------------------------
// prototypes
//
void AbortUpgradeOemComponent(IN PCWSTR pszPreNT5InfId,
                              IN PCWSTR pszDescription,
                              IN DWORD dwError,
                              IN DWORD dwErrorMessageId);

//----------------------------------------------------------------------------

// ----------------------------------------------------------------------
//
// Function:  CNetMapInfo::CNetMapInfo
//
// Purpose:   constructor for class CNetMapInfo
//
// Arguments: None
//
// Returns:
//
// Author:    kumarp 17-December-97
//
// Notes:
//
CNetMapInfo::CNetMapInfo()
{
    m_hinfNetMap = NULL;
    m_hOemDll = NULL;
    m_dwFlags = 0;
    m_nud.mszServicesNotToBeDeleted = NULL;
    m_pfnPreUpgradeInitialize = NULL;
    m_pfnDoPreUpgradeProcessing = NULL;
    m_fDllInitFailed = FALSE;
}

// ----------------------------------------------------------------------
//
// Function:  CNetMapInfo::~CNetMapInfo
//
// Purpose:   destructor for class CNetMapInfo
//
// Arguments: None
//
// Returns:   None
//
// Author:    kumarp 17-December-97
//
// Notes:
//
CNetMapInfo::~CNetMapInfo()
{
    if (m_hinfNetMap)
    {
        ::SetupCloseInfFile(m_hinfNetMap);
    }

    if (m_hOemDll)
    {
        ::FreeLibrary(m_hOemDll);
    }
}

// ----------------------------------------------------------------------
//
// Function:  CNetMapInfo::HrGetOemInfName
//
// Purpose:   Get name of installation INF of a component
//
// Arguments:
//    pszNT5InfId [in]  NT5 InfID of a component
//    pstrOemInf [out] pointer to name of INF for this component
//
// Returns:   S_OK on success, otherwise an error code
//
// Author:    kumarp 26-May-98
//
// Notes:
//
HRESULT CNetMapInfo::HrGetOemInfName(IN  PCWSTR pszNT5InfId,
                                     OUT tstring* pstrOemInf)
{
    DefineFunctionName("CNetMapInfo::HrGetOemInfName");

    AssertValidReadPtr(pszNT5InfId);
    AssertValidWritePtr(pstrOemInf);

    HRESULT hr=S_OK;
    tstring strOemDll;

    Assert(m_hinfNetMap);

    hr = HrGetOemUpgradeInfoInInf(m_hinfNetMap, pszNT5InfId,
                                  &strOemDll, pstrOemInf);

    TraceError(__FUNCNAME__, hr);

    return hr;
}

// ----------------------------------------------------------------------
//
// Function:  HrOpenNetUpgInfFile
//
// Purpose:   Open netupg.inf file.
//            - if env var NETUPGRD_INIT_FILE_DIR is set, open it from that dir
//            - otherwise open it from the dir where netuprd.dll is located
//
// Arguments:
//    phinf [out]  handle of netupg.inf file
//
// Returns:   S_OK on success, otherwise an error code
//
// Author:    kumarp 17-December-97
//
// Notes:
//
HRESULT HrOpenNetUpgInfFile(OUT HINF* phinf)
{
    DefineFunctionName("HrOpenNetUpgInfFile");

    AssertValidWritePtr(phinf);

    static const WCHAR c_szNetUpgInfFile[]   = L"netupg.inf";
    static const WCHAR c_szNetUpgrdInitDir[] = L"NETUPGRD_INIT_FILE_DIR";


    HRESULT hr=S_OK;
    tstring strNetUpgInfFile;

    // first try opening from N
    WCHAR szNetUpgrdInitDir[MAX_PATH+1];
    DWORD dwNumCharsReturned;
    dwNumCharsReturned =
        GetEnvironmentVariable(c_szNetUpgrdInitDir, szNetUpgrdInitDir, MAX_PATH);

    if (dwNumCharsReturned)
    {
        strNetUpgInfFile = szNetUpgrdInitDir;
    }
    else
    {
        hr = HrGetNetupgrdDir(&strNetUpgInfFile);
    }

    if (S_OK == hr)
    {
        AppendToPath(&strNetUpgInfFile, c_szNetUpgInfFile);
        hr = HrSetupOpenInfFile(strNetUpgInfFile.c_str(), NULL,
                                INF_STYLE_WIN4, NULL, phinf);
    }

    TraceError(__FUNCNAME__, hr);

    return hr;
}

// ----------------------------------------------------------------------
//
// Function:  HrGetOemDirs
//
// Purpose:   Get list of OEM dirs from netupg.inf file
//
// Arguments:
//    pslOemDirs [out] pointer to list of OEM dirs
//
// Returns:   S_OK on success, otherwise an error code
//
// Author:    kumarp 17-December-97
//
// Notes:
//
HRESULT HrGetOemDirs(OUT TStringList* pslOemDirs)
{
    DefineFunctionName("HrGetOemDirs");

    TraceFunctionEntry(ttidNetUpgrade);

    AssertValidReadPtr(pslOemDirs);

    HRESULT hr=S_OK;
    static const WCHAR c_szOemDirsSection[] = L"OemNetUpgradeDirs";

    HINF hInf;
    INFCONTEXT ic;
    tstring strNetUpgrdDir;
    tstring strDirFullPath;

    hr = HrGetNetupgrdDir(&strNetUpgrdDir);
    if (S_OK == hr)
    {
        hr = HrOpenNetUpgInfFile(&hInf);
    }

    if (S_OK == hr)
    {
        tstring strOemDir;

        hr = HrSetupFindFirstLine(hInf, c_szOemDirsSection, NULL, &ic);
        if (S_OK == hr)
        {
            do
            {
                hr = HrSetupGetLineText(&ic, hInf, NULL, NULL, &strOemDir);
                if (S_OK == hr)
                {
                    TraceTag(ttidNetUpgrade, "%s: locating '%S'...",
                             __FUNCNAME__, strOemDir.c_str());

                    hr = HrDirectoryExists(strOemDir.c_str());

                    if (S_OK == hr)
                    {
                        strDirFullPath = strOemDir;
                    }
                    else if (S_FALSE == hr)
                    {
                        // this may be a dir. relative to winntupg dir
                        //
                        strDirFullPath = strNetUpgrdDir;
                        AppendToPath(&strDirFullPath, strOemDir.c_str());

                        hr = HrDirectoryExists(strDirFullPath.c_str());
                    }

                    if (S_OK == hr)
                    {
                        pslOemDirs->push_back(new tstring(strDirFullPath));
                        TraceTag(ttidNetUpgrade, "%s: ...found OEM dir: %S",
                                 __FUNCNAME__, strDirFullPath.c_str());
                    }
                    else if (S_FALSE == hr)
                    {
                        TraceTag(ttidNetUpgrade,
                                 "%s: ...could not locate '%S'",
                                 __FUNCNAME__, strOemDir.c_str());
                    }

                    if (SUCCEEDED(hr))
                    {
                        hr = HrSetupFindNextLine(ic, &ic);
                    }
                }
            }
            while (S_OK == hr);

            if (S_FALSE == hr)
            {
                hr = S_OK;
            }
        }
        if (HRESULT_FROM_SETUPAPI(ERROR_LINE_NOT_FOUND) == hr)
        {
            hr = S_OK;
        }
        ::SetupCloseInfFile(hInf);
    }

    TraceError(__FUNCNAME__, hr);

    return hr;
}

// ----------------------------------------------------------------------
//
// Function:  HrOpenOemNMapFile
//
// Purpose:   Open netmap.inf file from the specified dir.
//
// Arguments:
//    pszOemDir [in]  name of dir.
//    phinf    [out] pointer to handle of netmap.inf file opened
//
// Returns:   S_OK on success, otherwise an error code
//
// Author:    kumarp 17-December-97
//
// Notes:
//
HRESULT HrOpenOemNMapFile(IN PCWSTR pszOemDir, OUT HINF* phinf)
{
    DefineFunctionName("HrOpenOemNMapFile");

    HRESULT hr=S_OK;
    *phinf = NULL;

    tstring strOemNMapFile;

    strOemNMapFile = pszOemDir;
    AppendToPath(&strOemNMapFile, c_szOemNMapFileName);

    hr = HrSetupOpenInfFile(strOemNMapFile.c_str(), NULL,
                            INF_STYLE_WIN4, NULL, phinf);

    TraceError(__FUNCNAME__, hr);

    return hr;
}

// ----------------------------------------------------------------------
//
// Function:  HrAddToNetMapInfo
//
// Purpose:   Add the specified netmap.inf file to the set of netmap.inf files
//
// Arguments:
//    pnma     [in]  array of CNetMapInfo objects
//    hinf     [in]  handle of netmap.inf file to add
//    pszOemDir [in]  location of the above file
//
// Returns:   S_OK on success, otherwise an error code
//
// Author:    kumarp 17-December-97
//
// Notes:
//
HRESULT HrAddToNetMapInfo(IN TNetMapArray* pnma,
                          IN HINF hinf,
                          IN PCWSTR pszOemDir)
{
    DefineFunctionName("HrAddToNetMapInfo");

    AssertValidReadPtr(pnma);
    Assert(hinf);
    AssertValidReadPtr(pszOemDir);

    HRESULT hr=E_OUTOFMEMORY;
    CNetMapInfo* pnmi;

    pnmi = new CNetMapInfo;
    if (pnmi)
    {
        hr = S_OK;

        pnmi->m_hinfNetMap = hinf;
        pnmi->m_strOemDir = pszOemDir;

        pnma->push_back(pnmi);
    }

    TraceError(__FUNCNAME__, hr);

    return hr;
}

// ----------------------------------------------------------------------
//
// Function:  HrOpenNetMapAndAddToNetMapInfo
//
// Purpose:   Open and add netmap.inf file in the specified dir.
//            to the set of netmap.inf files
//
// Arguments:
//    pnma     [in]  array of CNetMapInfo objects
//    pszOemDir [in]  location of netmap.inf file
//
// Returns:   S_OK on success, otherwise an error code
//
// Author:    kumarp 17-December-97
//
// Notes:
//
HRESULT HrOpenNetMapAndAddToNetMapInfo(IN TNetMapArray* pnma,
                                       IN PCWSTR pszOemDir)
{
    DefineFunctionName("HrOpenNetMapAndAddToNetMapInfo");

    AssertValidReadPtr(pnma);
    AssertValidReadPtr(pszOemDir);

    HRESULT hr = S_OK;
    HINF hinf;

    hr = HrOpenOemNMapFile(pszOemDir, &hinf);
    if (S_OK == hr)
    {
        hr = HrAddToNetMapInfo(pnma, hinf, pszOemDir);
    }

    TraceError(__FUNCNAME__, hr);

    return hr;
}

// ----------------------------------------------------------------------
//
// Function:  HrAddToGlobalNetMapInfo
//
// Purpose:   Add the specified netmap.inf file to the set of netmap.inf files
//
// Arguments:
//    hinf     [in]  handle of netmap.inf file to add
//    pszOemDir [in]  location of the above file
//
// Returns:   S_OK on success, otherwise an error code
//
// Author:    kumarp 17-December-97
//
// Notes:
//
HRESULT HrAddToGlobalNetMapInfo(IN HINF hinf,
                                IN PCWSTR pszOemDir)
{
    DefineFunctionName("HrAddToGlobalNetMapInfo");

    AssertValidReadPtr(g_pnmaNetMap);
    Assert(hinf);
    AssertValidReadPtr(pszOemDir);

    HRESULT hr=E_OUTOFMEMORY;

    hr = HrAddToNetMapInfo(g_pnmaNetMap, hinf, pszOemDir);

    TraceError(__FUNCNAME__, hr);

    return hr;
}

// ----------------------------------------------------------------------
//
// Function:  HrInitNetMapInfo
//
// Purpose:   Initialize array of CNetMapInfo objects
//
// Arguments: None
//
// Returns:   S_OK on success, otherwise an error code
//
// Author:    kumarp 17-December-97
//
// Notes:
//
HRESULT HrInitNetMapInfo()
{
    DefineFunctionName("HrInitNetMapInfo");

    HRESULT hr=E_FAIL;
    tstring strNetupgrdDir;

    g_pnmaNetMap = new TNetMapArray;
    if (!g_pnmaNetMap)
    {
        hr = E_OUTOFMEMORY;
    }
    else
    {
        hr = HrGetNetupgrdDir(&strNetupgrdDir);

        if (S_OK == hr)
        {
            TraceTag(ttidNetUpgrade, "%s: initializing netmap info from '%S'",
                     __FUNCNAME__, strNetupgrdDir.c_str());
            hr = HrOpenNetMapAndAddToNetMapInfo(g_pnmaNetMap,
                                                strNetupgrdDir.c_str());
        }
    }

    TraceError(__FUNCNAME__, hr);

    return hr;
}

// ----------------------------------------------------------------------
//
// Function:  UnInitNetMapInfo
//
// Purpose:   Uninitialize the array of CNetMapInfo objects
//
// Arguments: None
//
// Returns:   None
//
// Author:    kumarp 17-December-97
//
// Notes:
//
void UnInitNetMapInfo()
{
    DefineFunctionName("UnInitNetMapInfo");

    if (g_pnmaNetMap)
    {
        CNetMapInfo* pnmi;
        size_t cNumNetMapEntries = g_pnmaNetMap->size();

        for (size_t i = 0; i < cNumNetMapEntries; i++)
        {
            pnmi = (CNetMapInfo*) (*g_pnmaNetMap)[i];

            delete pnmi;
        }
        g_pnmaNetMap->erase(g_pnmaNetMap->begin(), g_pnmaNetMap->end());
        delete g_pnmaNetMap;
        g_pnmaNetMap = NULL;
    }
}

// ----------------------------------------------------------------------
//
// Function:  HrInitAndProcessOemDirs
//
// Purpose:   Initialize and process each OEM dir specified in netupg.inf file
//
// Arguments: None
//
// Returns:   S_OK on success, otherwise an error code
//
// Author:    kumarp 17-December-97
//
// Notes:
//
HRESULT HrInitAndProcessOemDirs()
{
    DefineFunctionName("HrInitAndProcessOemDirs");

    TraceFunctionEntry(ttidNetUpgrade);

    HRESULT hr=S_OK;
    TStringList slOemDirs;

    hr = HrGetOemDirs(&slOemDirs);
    if (S_OK == hr)
    {
        PCWSTR pszOemDir;
        HINF hinf;
        TStringListIter pos;

        for (pos=slOemDirs.begin(); pos != slOemDirs.end(); pos++)
        {
            pszOemDir = (*pos)->c_str();
            TraceTag(ttidNetUpgrade, "%s: initializing NetMapInfo for: %S",
                     __FUNCNAME__, pszOemDir);

            hr = HrProcessAndCopyOemFiles(pszOemDir, FALSE);
            if (FAILED(hr))
            {
                break;
            }
        }
    }

    if (S_FALSE == hr)
    {
        hr = S_OK;
    }

    TraceError(__FUNCNAME__, hr);

    return hr;
}

// ----------------------------------------------------------------------
//
// Function:  HrGetNetUpgradeTempDir
//
// Purpose:   Return name of temp. dir to use, creating one if necessary
//
// Arguments:
//    pstrTempDir [out] pointer to
//
// Returns:   S_OK on success, otherwise an error code
//
// Author:    kumarp 17-December-97
//
// Notes:
//
HRESULT HrGetNetUpgradeTempDir(OUT tstring* pstrTempDir)
{
    DefineFunctionName("HrGetNetUpgradeTempDir");

    HRESULT hr=E_FAIL;
    tstring strNetUpgradeTempDir;

    hr = HrGetWindowsDir(&strNetUpgradeTempDir);

    if (S_OK == hr)
    {
        static const WCHAR c_szNetupgrdSubDir[] = L"\\netsetup\\";

        strNetUpgradeTempDir += c_szNetupgrdSubDir;

        if (!CreateDirectory(strNetUpgradeTempDir.c_str(), NULL))
        {
            hr = HrFromLastWin32Error();
            if (HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS) == hr)
            {
                hr = S_OK;
            }
        }

        if (S_OK == hr)
        {
            *pstrTempDir = strNetUpgradeTempDir;
        }
    }

    TraceError(__FUNCNAME__, hr);

    return hr;
}

// ----------------------------------------------------------------------
//
// Function:  HrCreateOemTempDir
//
// Purpose:   Create a temp. dir with unique name
//
// Arguments:
//    pstrOemTempDir [out] name of dir created
//
// Returns:   S_OK on success, otherwise an error code
//
// Author:    kumarp 17-December-97
//
// Notes:
//
HRESULT HrCreateOemTempDir(OUT tstring* pstrOemTempDir)
{
    DefineFunctionName("HrCreateOemTempDir");

    HRESULT hr=S_OK;
    static DWORD dwOemDirCount=0;
    WCHAR szOemDirPath[MAX_PATH];

    hr = HrGetNetUpgradeTempDir(pstrOemTempDir);
    if (S_OK == hr)
    {
        DWORD dwRetryCount=0;
        const DWORD c_dwMaxRetryCount=1000;
        DWORD err=NO_ERROR;
        DWORD status;

        do
        {
            swprintf(szOemDirPath, L"%soem%05ld",
                      pstrOemTempDir->c_str(), dwOemDirCount++);

            TraceTag(ttidNetUpgrade, "%s: trying to create %S",
                     __FUNCNAME__, szOemDirPath);

            status = CreateDirectory(szOemDirPath, NULL);

            if (status)
            {
                *pstrOemTempDir = szOemDirPath;
            }
            else
            {
                err = GetLastError();
            }
        }
        while (!status && (ERROR_ALREADY_EXISTS == err) &&
               (dwRetryCount++ < c_dwMaxRetryCount));
        if (!status)
        {
            hr = HrFromLastWin32Error();
        }
    }

    TraceError(__FUNCNAME__, hr);

    return hr;
}

// ----------------------------------------------------------------------
//
// Function:  HrLoadAndVerifyOemDll
//
// Purpose:   Load and check for correct exported fns in the specified OEM DLL
//
// Arguments:
//    CNetMapInfo [in]
//    i           [in]  pointer to
//
// Returns:   S_OK on success,
//            S_FALSE if DLL init had failed last time when we tried
//            otherwise an error code
//
// Author:    kumarp 17-December-97
//
// Notes:
//
HRESULT HrLoadAndVerifyOemDll(IN OUT CNetMapInfo* pnmi)
{
    DefineFunctionName("HrLoadAndVerifyOemDll");

    HRESULT hr=S_OK;

    Assert(!pnmi->m_hOemDll);
    Assert(pnmi->m_strOemDllName.size() > 0);
    Assert(pnmi->m_strOemDir.size() > 0);

    if (pnmi->m_fDllInitFailed)
    {
        hr = S_FALSE;
    }
    else if (!pnmi->m_hOemDll)
    {
        TraceTag(ttidNetUpgrade, "%s: loading OEM DLL: %S%S",
                 __FUNCNAME__, pnmi->m_strOemDir.c_str(),
                 pnmi->m_strOemDllName.c_str());

        tstring strOemDllFullPath;
        strOemDllFullPath = pnmi->m_strOemDir;
        AppendToPath(&strOemDllFullPath, pnmi->m_strOemDllName.c_str());

        hr = HrLoadLibAndGetProcsV(strOemDllFullPath.c_str(),
                                   &pnmi->m_hOemDll,
                                   c_szPreUpgradeInitialize,
                                   (FARPROC*) &pnmi->m_pfnPreUpgradeInitialize,
                                   c_szDoPreUpgradeProcessing,
                                   (FARPROC*) &pnmi->m_pfnDoPreUpgradeProcessing,
                                   NULL);

        if (FAILED(hr))
        {
            pnmi->m_hOemDll = NULL;
            pnmi->m_pfnPreUpgradeInitialize   = NULL;
            pnmi->m_pfnDoPreUpgradeProcessing = NULL;
            pnmi->m_fDllInitFailed = TRUE;
        }
    }

    TraceError(__FUNCNAME__, hr);

    return hr;
}

// ----------------------------------------------------------------------
//
// Function:  HrLoadAndInitOemDll
//
// Purpose:   Load the specified OEM DLL and call its
//            PreUpgradeInitialize function
//
// Arguments:
//    pnmi            [in]  pointer to CNetMapInfo object
//    pNetUpgradeInfo [in]  pointer to NetUpgradeInfo
//
// Returns:   S_OK on success
//            S_FALSE if DLL init had failed last time when we tried
//            otherwise an error code
//
// Author:    kumarp 17-December-97
//
// Notes:
//
HRESULT HrLoadAndInitOemDll(IN CNetMapInfo* pnmi,
                            IN  NetUpgradeInfo* pNetUpgradeInfo)
{
    DefineFunctionName("HrLoadAndInitOemDll");

    HRESULT hr=S_OK;
    DWORD dwError=ERROR_SUCCESS;
    VENDORINFO vi;

    hr = HrLoadAndVerifyOemDll(pnmi);

    if (S_OK == hr)
    {
        if (pnmi->m_pfnPreUpgradeInitialize)
        {
            NC_TRY
            {
                TraceTag(ttidNetUpgrade, "%s: initializing OEM DLL: %S in %S",
                         __FUNCNAME__,
                         pnmi->m_strOemDllName.c_str(),
                         pnmi->m_strOemDir.c_str());

                dwError = pnmi->m_pfnPreUpgradeInitialize(pnmi->m_strOemDir.c_str(),
                                                         pNetUpgradeInfo,
                                                         &vi,
                                                         &pnmi->m_dwFlags,
                                                         &pnmi->m_nud);
#ifdef ENABLETRACE
                if (pnmi->m_nud.mszServicesNotToBeDeleted)
                {
                    TraceMultiSz(ttidNetUpgrade,
                                 L"OEM services that will not be deleted",
                                 pnmi->m_nud.mszServicesNotToBeDeleted);
                }
#endif
                // ensure that this function gets called only once
                //
                pnmi->m_pfnPreUpgradeInitialize = NULL;

                hr = HRESULT_FROM_WIN32(dwError);

                if (pnmi->m_dwFlags & NUA_REQUEST_ABORT_UPGRADE)
                {
                    TraceTag(ttidNetUpgrade,
                             "%s: OEM DLL '%S' requested that upgrade be aborted",
                             __FUNCNAME__, pnmi->m_strOemDllName.c_str());
                    RequestAbortUpgradeOboOemDll(pnmi->m_strOemDllName.c_str(),
                                                 &vi);
                    hr = S_FALSE;
                }
                else if (pnmi->m_dwFlags & NUA_ABORT_UPGRADE)
                {
                    TraceTag(ttidNetUpgrade,
                             "%s: OEM DLL '%S' aborted the upgrade",
                             __FUNCNAME__, pnmi->m_strOemDllName.c_str());
                    AbortUpgradeFn(ERROR_SUCCESS, pnmi->m_strOemDllName.c_str());
                    hr = S_FALSE;
                }
            }
            NC_CATCH_ALL
            {
                TraceTag(ttidError, "%s: OEM DLL '%S' caused an exception",
                         __FUNCNAME__, pnmi->m_strOemDllName.c_str());
                hr = HRESULT_FROM_WIN32(ERROR_DLL_INIT_FAILED);
            }
        }
    }

    TraceError(__FUNCNAME__, hr);

    return hr;
}

// ----------------------------------------------------------------------
//
// Function:  HrProcessOemComponent
//
// Purpose:   Load an OEM DLL and call DoPreUpgradeProcessing
//            function for the specified component
//
// Arguments:
//    pnmi             [in]  pointer to CNetMapInfo object
//    pNetUpgradeInfo  [in]  pointer to NetUpgradeInfo
//    hwndParent    [in]  handle of parent window
//    hkeyParams       [in]  handle of Parameters registry key
//    pszPreNT5InfId    [in]  pre-NT5 InfID of a component (e.g. IEEPRO)
//    pszPreNT5Instance [in]  pre-NT5 instance of a component (e.g. IEEPRO2)
//    pszNT5InfId       [in]  NT5 InfID of the component
//    pszDescription    [in]  description of the component
//    pszSectionName    [in]  name of section that the OEM DLL must use
//                           for storing its upgrade parameters
//    pdwFlags         [out] pointer to flags returned by OEM DLL
//
// Returns:   S_OK on success, otherwise an error code
//
// Author:    kumarp 17-December-97
//
// Notes:
//
HRESULT HrProcessOemComponent(CNetMapInfo* pnmi,
                              IN  NetUpgradeInfo* pNetUpgradeInfo,
                              IN  HWND      hwndParent,
                              IN  HKEY      hkeyParams,
                              IN  PCWSTR   pszPreNT5InfId,
                              IN  PCWSTR   pszPreNT5Instance,
                              IN  PCWSTR   pszNT5InfId,
                              IN  PCWSTR   pszDescription,
                              IN  PCWSTR   pszSectionName,
                              OUT DWORD*    pdwFlags)
{
    DefineFunctionName("HrProcessOemComponent");

    AssertValidReadPtr(pnmi);
    AssertValidReadPtr(pNetUpgradeInfo);
    Assert(hkeyParams);
    AssertValidReadPtr(pszPreNT5InfId);
    AssertValidReadPtr(pszPreNT5Instance);
    AssertValidReadPtr(pszNT5InfId);
    AssertValidReadPtr(pszDescription);
    AssertValidReadPtr(pszSectionName);
    AssertValidWritePtr(pdwFlags);

    TraceTag(ttidNetUpgrade,
             "%s: Processing OEM component: %S(%S), instance: %S",
             __FUNCNAME__, pszNT5InfId, pszPreNT5InfId, pszPreNT5Instance);

    HRESULT hr=S_OK;
    VENDORINFO vi;
    DWORD dwErrorMessageId=0;

    if (pnmi->m_strOemDllName.empty())
    {
        tstring strOemInf;

        hr = HrGetOemUpgradeInfoInInf(pnmi->m_hinfNetMap,
                                      pszNT5InfId,
                                      &pnmi->m_strOemDllName,
                                      &strOemInf);
        if (S_OK == hr)
        {
            hr = HrLoadAndInitOemDll(pnmi, pNetUpgradeInfo);
            if (FAILED(hr))
            {
                dwErrorMessageId = IDS_E_LoadAndInitOemDll;
            }
        }
        else
        {
            dwErrorMessageId = IDS_E_GetOemUpgradeDllInfoInInf;
        }

    }

    if (S_OK == hr)
    {
        Assert(pnmi->m_pfnDoPreUpgradeProcessing);

        NC_TRY
        {
            TraceTag(ttidNetUpgrade,
                     "%s: calling DoPreUpgradeProcessing in %S for %S",
                     __FUNCNAME__, pnmi->m_strOemDllName.c_str(), pszNT5InfId);

            Assert(pnmi->m_pfnDoPreUpgradeProcessing);

            DWORD dwError =
                pnmi->m_pfnDoPreUpgradeProcessing(hwndParent, hkeyParams,
                                                  pszPreNT5InfId, pszPreNT5Instance,
                                                  pszNT5InfId,
                                                  pszSectionName,
                                                  &vi,
                                                  pdwFlags, NULL);

            TraceTag(ttidNetUpgrade, "%s: DoPreUpgradeProcessing returned: 0x%x",
                     __FUNCNAME__, dwError);

            hr = HRESULT_FROM_WIN32(dwError);

            if (S_OK == hr)
            {
                if (*pdwFlags & NUA_REQUEST_ABORT_UPGRADE)
                {
                    RequestAbortUpgradeOboOemDll(pnmi->m_strOemDllName.c_str(),
                                                 &vi);
                    hr = S_FALSE;
                }
            }
            else
            {
                dwErrorMessageId = IDS_E_DoPreUpgradeProcessing;
            }
        }
        NC_CATCH_ALL
        {
            TraceTag(ttidError, "%s: OEM DLL '%S' caused an exception",
                     __FUNCNAME__, pnmi->m_strOemDllName.c_str());

            hr = HRESULT_FROM_WIN32(ERROR_OPERATION_ABORTED);
            dwErrorMessageId = IDS_E_OemDllCausedAnException;
        }
    }
    else if (S_FALSE == hr)
    {
        TraceTag(ttidNetUpgrade, "%s: DoPreUpgradeProcessing was not called"
                 " since DLL init had failed", __FUNCNAME__);
    }

    if (FAILED(hr))
    {
        AbortUpgradeOemComponent(pszPreNT5InfId, pszDescription,
                                 DwWin32ErrorFromHr(hr), dwErrorMessageId);
    }

    TraceError(__FUNCNAME__, hr);

    return hr;
}

// ----------------------------------------------------------------------
//
// Function:  HrShowUiAndGetOemFileLocation
//
// Purpose:   Display UI asking the user to specify location of OEM files
//
// Arguments:
//    hwndParent      [in]  handle of parent window
//    pszComponentName [in]  name of Component
//    pstrOemPath     [out] name of netmap.inf file the user selected
//
// Returns:   S_OK on success, otherwise an error code
//
// Author:    kumarp 17-December-97
//
// Notes:
//
HRESULT
HrShowUiAndGetOemFileLocation(
    IN HWND hwndParent,
    IN PCWSTR pszComponentName,
    OUT tstring* pstrOemPath)
{
    DefineFunctionName("HrShowUiAndGetOemFileLocation");

    AssertValidWritePtr(pstrOemPath);

    OPENFILENAME ofn;
    WCHAR szOemPath[MAX_PATH+1];
    PWSTR pszTitle;
    PCWSTR pszOemQueryFileLocationFormatString =
                SzLoadString(g_hinst, IDS_OemQueryFileLocation);

    PCWSTR pszOemFileTypeFilter1 =
                SzLoadString(g_hinst, IDS_OemNetMapFileFilter1);
    PCWSTR pszOemFileTypeFilter2 =
                SzLoadString(g_hinst, IDS_OemNetMapFileFilter2);

    PWSTR mszFileFilter = NULL;
    HRESULT hr = S_OK;
    BOOL    f;

    hr = HrAddSzToMultiSz(pszOemFileTypeFilter1, NULL,
                          STRING_FLAG_ENSURE_AT_END,
                          0, &mszFileFilter, &f);
    if (S_OK != hr)
    {
        goto cleanup;
    }

    hr = HrAddSzToMultiSz(pszOemFileTypeFilter2, mszFileFilter,
                          STRING_FLAG_ENSURE_AT_END,
                          0, &mszFileFilter, &f);
    if (S_OK != hr)
    {
        goto cleanup;
    }

    ZeroMemory (&ofn, sizeof(ofn));
    *szOemPath = 0;

    DwFormatStringWithLocalAlloc (
        pszOemQueryFileLocationFormatString,
        &pszTitle,
        pszComponentName);

    ofn.lStructSize = sizeof(OPENFILENAME);
    ofn.hwndOwner   = hwndParent;
    ofn.lpstrFilter = mszFileFilter;
    ofn.lpstrFile   = szOemPath;
    ofn.nMaxFile    = MAX_PATH;
    ofn.lpstrTitle  = pszTitle;
    ofn.Flags       = OFN_FILEMUSTEXIST | OFN_PATHMUSTEXIST |
                      OFN_HIDEREADONLY | OFN_NOCHANGEDIR |
                      OFN_NODEREFERENCELINKS;

    if (GetOpenFileName(&ofn))
    {
        // get rid of the trailing filename.
        //
        szOemPath[ofn.nFileOffset] = 0;
        *pstrOemPath = szOemPath;
        hr = S_OK;
    }
    else
    {
        DWORD err;
        err = CommDlgExtendedError();
        if (err)
        {
            hr = E_FAIL;
            TraceTag(ttidError, "%s: FileOpen dialog returned error: %ld (0x%lx)",
                     __FUNCNAME__, err, err);
        }
        else
        {
            hr = S_FALSE;
            TraceTag(ttidError, "%s: FileOpen dialog was canceled by user",
                     __FUNCNAME__);
        }
    }

    LocalFree (pszTitle);
cleanup:    
    MemFree(mszFileFilter);

    TraceErrorOptional(__FUNCNAME__, hr, (hr == S_FALSE));

    return hr;
}

// ----------------------------------------------------------------------
//
// Function:  HrProcessAndCopyOemFiles
//
// Purpose:   Copy OEM files from the specified dir to OEM temp. dir.
//
// Arguments:
//    pszOemDir     [in]  location of OEM files
//    fInteractive [in]  TRUE --> called when a user has interactively
//                       supplied a disk having OEM files, FALSE otherwise
//
// Returns:   S_OK on success,
//            S_FALSE if the OEM files are valid but not applicable for
//              currently displayed unsupported components,
//            otherwise an error code
//
// Author:    kumarp 17-December-97
//
// Notes:
//
HRESULT HrProcessAndCopyOemFiles(IN PCWSTR pszOemDir,
                                 IN BOOL fInteractive)
{
    DefineFunctionName("HrProcessAndCopyOemFiles");

    HRESULT hr=S_OK;
    HINF hinf=NULL;
    tstring strTempOemDir;
    DWORD dwErrorMessageId;

    TraceTag(ttidNetUpgrade, "%s: processing OEM files in: %S",
             __FUNCNAME__, pszOemDir);

    hr = HrOpenOemNMapFile(pszOemDir, &hinf);

    if (S_OK == hr)
    {
        DWORD dwNumConflictsResolved=0;
        BOOL  fHasUpgradeHelpInfo=FALSE;

        hr = HrUpdateConflictList(FALSE, hinf, &dwNumConflictsResolved,
                                  &fHasUpgradeHelpInfo);

#if 0
        BOOL fNovell = (g_fForceNovellDirCopy && wcsstr(pszOemDir, L"oem\\novell"));
        
        if (SUCCEEDED(hr) && ((dwNumConflictsResolved > 0) ||
                              fHasUpgradeHelpInfo ||
                              fNovell))
#endif
        if (SUCCEEDED(hr) && ((dwNumConflictsResolved > 0) ||
                              fHasUpgradeHelpInfo))
        {
#if 0
            if (fNovell)
            {
                // special case for novell (dir name is %windir%\netsetup\novell)

                hr = HrGetNetUpgradeTempDir(&strTempOemDir);
                if (S_OK == hr)
                {
                    strTempOemDir += L"novell";
                    if (0 == CreateDirectory(strTempOemDir.c_str(), NULL))
                    {
                        hr = HrFromLastWin32Error();
                        if (HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS) == hr)
                        {
                            // perhaps a previous failed attempt, maybe.  Since
                            // we can just copy on top of this, ignore the 'error'.
                            //
                            hr = S_OK;
                        }
                        
                        if (S_OK == hr)
                        {
                            TraceTag(ttidNetUpgrade, "Created oem\\Novell dir",
                                     __FUNCNAME__);
                        }
                    }
                }
            }
            else
#endif
            
            {
                // regular case (dir name is %windir%\netsetup\oemNNNNN)
                hr = HrCreateOemTempDir(&strTempOemDir);
            }

            if (S_OK == hr)
            {
                hr = HrCopyFiles(pszOemDir, strTempOemDir.c_str());
            }
            if (FAILED(hr))
            {
                dwErrorMessageId = IDS_E_CopyingOemFiles;
            }
        }
        else
        {
            if (fInteractive)
            {
                MessageBox(NULL,
                           SzLoadString(g_hinst, IDS_E_OemFilesNotValidForComponents),
                           SzLoadString(g_hinst, IDS_NetupgrdCaption),
                           MB_OK|MB_APPLMODAL);
            }

            hr = S_FALSE;
        }
        ::SetupCloseInfFile(hinf);

        if (S_OK == hr)
        {
            hr = HrOpenOemNMapFile(strTempOemDir.c_str(), &hinf);
            if (S_OK == hr)
            {
                hr = HrUpdateConflictList(TRUE, hinf, &dwNumConflictsResolved,
                                          &fHasUpgradeHelpInfo);
                if (SUCCEEDED(hr) && ((dwNumConflictsResolved > 0) ||
                                      fHasUpgradeHelpInfo))
                {
                    // hinf is stored in the global array, it will be
                    // closed in UninitNetMapInfo function
                    //
                    hr = HrAddToGlobalNetMapInfo(hinf, strTempOemDir.c_str());
                }
                else
                {
                    ::SetupCloseInfFile(hinf);
                }
            }
            if (FAILED(hr))
            {
                dwErrorMessageId = IDS_E_PresetNetMapInfError;
            }
        }
    }
    else
    {
        TraceTag(ttidNetUpgrade, "%s: could not open netmap.inf in %S",
                 __FUNCNAME__, pszOemDir);
        dwErrorMessageId = IDS_E_PresetNetMapInfError;
    }

    if (FAILED(hr))
    {
        FGetConfirmationAndAbortUpgradeId(dwErrorMessageId);
    }

    TraceErrorOptional(__FUNCNAME__, hr, (hr == S_FALSE));

    return hr;
}

// ----------------------------------------------------------------------
//
// Function:  RequestAbortUpgradeOboOemDll
//
// Purpose:   Display UI on behalf of an OEM DLL and ask user
//            if upgrade needs to be aborted
//
// Arguments:
//    pszDllName [in]  name of OEM DLL
//
// Returns:   None
//
// Author:    kumarp 17-December-97
//
// Notes:
//
void RequestAbortUpgradeOboOemDll(IN PCWSTR pszDllName, VENDORINFO* pvi)
{
    tstring strMessage;

    strMessage = SzLoadString(g_hinst, IDS_E_OemDllRequestsAbortingUpgrade);
    strMessage += pszDllName;
    strMessage += L"\n\n";

    strMessage += SzLoadString(g_hinst, IDS_InfoAboutOemDllSupplier);

    strMessage += SzLoadString(g_hinst, IDS_ViCompanyName);
    strMessage += pvi->szCompanyName;
    strMessage += L"\n";

    if (*pvi->szSupportNumber)
    {
        strMessage += SzLoadString(g_hinst, IDS_ViSupportNumber);
        strMessage += pvi->szSupportNumber;
        strMessage += L"\n";
    }

    if (*pvi->szSupportUrl)
    {
        strMessage += SzLoadString(g_hinst, IDS_ViSupportUrl);
        strMessage += pvi->szSupportUrl;
        strMessage += L"\n";
    }

    if (*pvi->szInstructionsToUser)
    {
        strMessage += SzLoadString(g_hinst, IDS_ViAdditionalInfo);
        strMessage += pvi->szInstructionsToUser;
        strMessage += L"\n";
    }

    FGetConfirmationAndAbortUpgrade(strMessage.c_str());
}

// ----------------------------------------------------------------------
//
// Function:  AbortUpgradeOemComponent
//
// Purpose:   Abort upgrade because of a fatal error when upgrading an
//            OEM component
//
// Arguments:
//    pszPreNT5InfId    [in]  pre-NT5 InfID of OEM component
//    pszDescription    [in]  description of OEM component
//    dwError          [in]  error code
//    dwErrorMessageId [in]  ID of error message resource string
//
// Returns:   None
//
// Author:    kumarp 17-December-97
//
// Notes:
//
void AbortUpgradeOemComponent(IN PCWSTR pszPreNT5InfId,
                              IN PCWSTR pszDescription,
                              IN DWORD dwError,
                              IN DWORD dwErrorMessageId)
{
    tstring strMessage;

    static const WCHAR c_szNewLine[] = L"\n";
    WCHAR szErrorCode[16];

    swprintf(szErrorCode, L"0x%08x", dwError);

    strMessage = SzLoadString(g_hinst, IDS_E_OemComponentUpgrade);
    strMessage = strMessage + c_szNewLine + pszDescription + L"(" +
        pszPreNT5InfId + L"\n\n" +
        SzLoadString(g_hinst, dwErrorMessageId) +
        c_szNewLine + SzLoadString(g_hinst, IDS_E_ErrorCode) + szErrorCode;

    FGetConfirmationAndAbortUpgrade(strMessage.c_str());
}

// ----------------------------------------------------------------------
//
// Function:  FCanDeleteOemService
//
// Purpose:   Determine if a service can be deleted.
//            OEM upgrade DLLs can prevent a service from being deleted,
//            by specifying a list in the mszServicesNotToBeDeleted
//            member of NetUpgradeData structure.
//
// Arguments:
//    pszServiceName [in]  name of the service to be spared.
//
// Returns:   TRUE if can delete, FALSE otherwise
//
// Author:    kumarp 04-March-98
//
// Notes:
//
BOOL FCanDeleteOemService(IN PCWSTR pszServiceName)
{
    BOOL fCanDeleteService = TRUE;

    if (g_pnmaNetMap)
    {
        CNetMapInfo* pnmi;
        size_t cNumNetMapEntries = g_pnmaNetMap->size();

        for (size_t i = 0; i < cNumNetMapEntries; i++)
        {
            pnmi = (CNetMapInfo*) (*g_pnmaNetMap)[i];

            if (FIsSzInMultiSzSafe(pszServiceName,
                                   pnmi->m_nud.mszServicesNotToBeDeleted))
            {
                fCanDeleteService = FALSE;
                break;
            }
        }
    }

    return fCanDeleteService;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\upgrade\netupgrd\oemupg.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       I S D N U P G . H
//
//  Contents:   Down level upgrade code for OEM cards
//
//  Notes:
//
//  Author:     kumarp    12 April 97
//
//----------------------------------------------------------------------------

#pragma once

#include "oemupgex.h"

class CWInfFile;
class CWInfSection;


class CNetMapInfo
{
public:
    HINF m_hinfNetMap;
    tstring m_strOemDir;
    tstring m_strOemDllName;
    HMODULE m_hOemDll;
    DWORD   m_dwFlags;
    NetUpgradeData m_nud;
    PreUpgradeInitializePrototype   m_pfnPreUpgradeInitialize;
    DoPreUpgradeProcessingPrototype m_pfnDoPreUpgradeProcessing;
    BOOL   m_fDllInitFailed;

    CNetMapInfo();
    ~CNetMapInfo();

    HRESULT HrGetOemInfName(IN  PCWSTR pszNT5InfId,
                            OUT tstring* pstrOemInf);
};
typedef vector<CNetMapInfo*> TNetMapArray;
extern TNetMapArray* g_pnmaNetMap;

HRESULT HrInitNetMapInfo();
void UnInitNetMapInfo();


HRESULT HrShowUiAndGetOemFileLocation(IN  HWND hParent,
                                      IN  PCWSTR  pszComponentName,
                                      OUT tstring* pstrOemPath);


HRESULT HrOpenNetUpgInfFile(HINF* phinf);
HRESULT HrGetNetUpgradeTempDir(OUT tstring* pstrTempDir);
HRESULT HrCreateOemTempDir(OUT tstring* pstrOemTempDir);
HRESULT HrOpenOemNMapFile(IN PCWSTR pszOemDir, OUT HINF* phinf);
HRESULT HrAddToGlobalNetMapInfo(IN HINF hinf,
                                IN PCWSTR pszOemDir);
HRESULT HrProcessAndCopyOemFiles(IN PCWSTR pszOemDir,
                                 IN BOOL fInteractive);
HRESULT HrInitAndProcessOemDirs();

HRESULT HrLoadAndInitOemDll(IN CNetMapInfo* pnmi,
                            IN  NetUpgradeInfo* pNetUpgradeInfo);
HRESULT HrProcessOemComponent(CNetMapInfo* pnmi,
                              IN  NetUpgradeInfo* pNetUpgradeInfo,
                              IN  HWND      hParentWindow,
                              IN  HKEY      hkeyParams,
                              IN  PCWSTR   pszPreNT5InfId,
                              IN  PCWSTR   pszPreNT5Instance,
                              IN  PCWSTR   pszNT5InfId,
                              IN  PCWSTR   pszDescription,
                              IN  PCWSTR   pszSectionName,
                              OUT DWORD*    pdwFlags);

void RequestAbortUpgradeOboOemDll(IN PCWSTR pszDllName, VENDORINFO* pvi);

BOOL FCanDeleteOemService(IN PCWSTR pszServiceName);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\upgrade\netupgrd\nuutils.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT5.0
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       N U U T I L S . C P P
//
//  Contents:   Functions needed by OEM DLLs for OEM network upgrade
//
//  Notes:
//
//  Author:     kumarp    16-October-97
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

#include "kkstl.h"
#include "nustrs.h"
#include "nuutils.h"
#include "netupgrd.h"
#include "kkutils.h"

#include "ncreg.h"

// ----------------------------------------------------------------------
extern const WCHAR c_szNetUpgradeDll[];
extern const WCHAR c_szRegValServiceName[];
static const WCHAR c_szComponent[] = L"Component";


// ----------------------------------------------------------------------
//
// Function:  HrGetWindowsDir
//
// Purpose:   Return full path to %WINDIR%
//
// Arguments:
//    pstrWinDir [out] full path to windir
//
// Returns:   S_OK on success, otherwise an error code
//
// Author:    kumarp 19-December-97
//
// Notes:
//
HRESULT HrGetWindowsDir(OUT tstring* pstrWinDir)
{
    DefineFunctionName("HrGetWindowsDir");

    HRESULT hr=S_OK;

    WCHAR szWindowsDir[MAX_PATH+1];
    DWORD cNumCharsReturned = GetWindowsDirectory(szWindowsDir, MAX_PATH);
    if (cNumCharsReturned)
    {
        *pstrWinDir = szWindowsDir;
    }
    else
    {
        hr = HrFromLastWin32Error();
    }

    TraceError(__FUNCNAME__, hr);

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrGetNetupgrdDir
//
//  Purpose:    Get the full path of directory containing netupgrd.dll
//
//  Arguments:
//    pstrNetupgrdDir [out]  the directory path is returned in this
//
//  Returns:    S_OK or an HRESULT_FROM_WIN32 error code.
//
//  Author:     kumarp    24-July-97
//
//  Notes:
//
HRESULT HrGetNetupgrdDir(OUT tstring* pstrNetupgrdDir)
{
    DefineFunctionName("HrGetNetupgrdDir");

    AssertValidWritePtr(pstrNetupgrdDir);

    HRESULT hr=S_OK;

    WCHAR szNetupgrd[MAX_PATH+1];
    HMODULE hModule = GetModuleHandle(c_szNetUpgradeDll);
    DWORD cPathLen = GetModuleFileName(hModule, szNetupgrd, MAX_PATH);
    if (!cPathLen)
    {
        hr = ERROR_FILE_NOT_FOUND;
        goto return_from_function;
    }

    // split path into components
    WCHAR szDrive[_MAX_DRIVE+1];
    WCHAR szDir[_MAX_DIR+1];
    _wsplitpath(szNetupgrd, szDrive, szDir, NULL, NULL);

    *pstrNetupgrdDir = szDrive;
    *pstrNetupgrdDir += szDir;

return_from_function:
    TraceError(__FUNCNAME__, hr);

    return hr;
}

// ======================================================================
// move to common code
// ======================================================================

// ----------------------------------------------------------------------
//
// Function:  HrSetupGetLineText
//
// Purpose:   Wrapper around SetupGetLineText
//
// Arguments:
//    Context          [in]  pointer to INFCONTEXT
//    hinf             [in]  handle of INF
//    pszSection        [in]  section name
//    pszKey            [in]  key name
//    pstrReturnedText [in]  pointer to returned text
//
// Returns:   S_OK on success, otherwise an error code
//
// Author:    kumarp 19-December-97
//
// Notes:
//
HRESULT HrSetupGetLineText(PINFCONTEXT Context,
                           HINF hinf,
                           PCWSTR pszSection,
                           PCWSTR pszKey,
                           tstring* pstrReturnedText)
{
    DefineFunctionName("HrSetupGetLineText");

    BOOL fStatus;
    HRESULT hr;
    WCHAR szLineText[MAX_INF_STRING_LENGTH+1];

    if (::SetupGetLineText(Context, hinf, pszSection, pszKey, szLineText,
                           MAX_INF_STRING_LENGTH, NULL))
    {
        hr = S_OK;
        *pstrReturnedText = szLineText;
    }
    else
    {
        hr = HrFromLastWin32Error ();
    }

    TraceError(__FUNCNAME__, hr);

    return hr;
}

// ----------------------------------------------------------------------
//
// Function:  HrCopyFiles
//
// Purpose:   Recursively copy all files in SrcDir to DstDir
//
// Arguments:
//    pszSrcDir [in]  source dir
//    pszDstDir [in]  dest. dir
//
// Returns:   S_OK on success, otherwise an error code
//
// Author:    kumarp 19-December-97
//
// Notes:
//
HRESULT HrCopyFiles(IN PCWSTR pszSrcDir, IN PCWSTR pszDstDir)
{
    DefineFunctionName("HrCopyFiles");

    HRESULT hr=S_OK;
    BOOL fStatus=FALSE;
    DWORD dwError=ERROR_SUCCESS;

    TraceTag(ttidNetUpgrade, "%s: Src: %S, Dst: %S",
             __FUNCNAME__, pszSrcDir, pszDstDir);

    HANDLE hFileContext;
    WIN32_FIND_DATA fd;
    tstring strSrcDirAllFiles;
    tstring strDstDir;
    tstring strSrcDir;
    tstring strFileSrcFullPath;
    tstring strFileDstFullPath;

    strSrcDir  = pszSrcDir;
    AppendToPath(&strSrcDir, c_szEmpty);

    strDstDir  = pszDstDir;
    AppendToPath(&strDstDir, c_szEmpty);

    strSrcDirAllFiles = pszSrcDir;
    AppendToPath(&strSrcDirAllFiles, L"*");

    hFileContext = FindFirstFile(strSrcDirAllFiles.c_str(), &fd);

    if (hFileContext != INVALID_HANDLE_VALUE)
    {
        do
        {
            strFileSrcFullPath = strSrcDir + fd.cFileName;
            strFileDstFullPath = strDstDir + fd.cFileName;

            if (fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
            {
                if (!lstrcmpiW(fd.cFileName, L".") ||
                    !lstrcmpiW(fd.cFileName, L".."))
                {
                    hr = S_OK;
                    TraceTag(ttidNetUpgrade, "%s: skipped %S",
                             __FUNCNAME__, strFileSrcFullPath.c_str());
                }
                else
                {
                    TraceTag(ttidNetUpgrade, "%s: creating dir: %S",
                             __FUNCNAME__, strFileDstFullPath.c_str());

                    fStatus = CreateDirectory(strFileDstFullPath.c_str(), NULL);

                    if (!fStatus)
                    {
                        dwError = GetLastError();
                    }

                    if (fStatus || (ERROR_ALREADY_EXISTS == dwError))
                    {
                        hr = HrCopyFiles(strFileSrcFullPath.c_str(),
                                         strFileDstFullPath.c_str());
                    }
                    else
                    {
                        hr = HrFromLastWin32Error();
                    }
                }
            }
            else if (!(fd.dwFileAttributes & FILE_ATTRIBUTE_OFFLINE))
            {
                TraceTag(ttidNetUpgrade, "%s: copying %S to %S",
                         __FUNCNAME__, strFileSrcFullPath.c_str(),
                         strFileDstFullPath.c_str());

                if (CopyFile(strFileSrcFullPath.c_str(),
                             strFileDstFullPath.c_str(), FALSE))
                {
                    hr = S_OK;
                }
                else
                {
                    hr = HrFromLastWin32Error();
                }
            }
            else
            {
                TraceTag(ttidNetUpgrade, "%s: skipped %S",
                         __FUNCNAME__, strFileSrcFullPath.c_str());
            }

            if ((S_OK == hr) && FindNextFile(hFileContext, &fd))
            {
                hr = S_OK;
            }
            else
            {
                hr = HrFromLastWin32Error();
            }
        }
        while (S_OK == hr);
        if (hr == HRESULT_FROM_WIN32(ERROR_NO_MORE_FILES))
        {
            hr = S_OK;
        }
        FindClose(hFileContext);
    }
    else
    {
        hr = HrFromLastWin32Error();
    }

    TraceError(__FUNCNAME__, hr);

    return hr;
}

// ----------------------------------------------------------------------
//
// Function:  HrGetNumNetCardsPreNT5
//
// Purpose:   Get number of netcards installed on a pre-NT5 system
//
// Arguments:
//    pcNetCards [out] pointer to num net cards value
//
// Returns:   S_OK on success, otherwise an error code
//
// Author:    kumarp 13-April-98
//
// Notes:     Dont use it on NT5!
//
HRESULT HrGetNumNetCardsPreNT5(OUT UINT* pcNetCards)
{
    DefineFunctionName("HrGetNumNetCardsPreNT5");

    HRESULT hr=S_OK;
    HKEY hkeyAdapters;

    *pcNetCards = 0;

    hr = HrRegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szRegKeyAdapterHome,
                        KEY_READ, &hkeyAdapters);
    if (S_OK == hr)
    {
        WCHAR szBuf[MAX_PATH];
        FILETIME time;
        DWORD dwSize = celems(szBuf);
        DWORD dwRegIndex = 0;

        while(S_OK == (hr = HrRegEnumKeyEx(hkeyAdapters, dwRegIndex++, szBuf,
                                           &dwSize, NULL, NULL, &time)))
        {
            Assert(*szBuf);

            dwSize = celems(szBuf);
            (*pcNetCards)++;
        }
        RegCloseKey(hkeyAdapters);
    }

    TraceErrorSkip2(__FUNCNAME__, hr,
                    HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND),
                    HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS));

    return hr;
}

// ----------------------------------------------------------------------
//
// Function:  HrDirExists
//
// Purpose:   Check if the given directory exists
//
// Arguments:
//    pszDir [in]  full path to a directory
//
// Returns:   S_OK if it exists, S_FALSE if not, otherwise an error code
//
// Author:    kumarp 09-April-98
//
// Notes:
//
HRESULT HrDirectoryExists(IN PCWSTR pszDir)
{
    DefineFunctionName("HrDirExists");

    HRESULT hr=S_FALSE;

    HANDLE hFile=0;
    BY_HANDLE_FILE_INFORMATION bhfi;

    hFile = CreateFile(pszDir, GENERIC_READ, FILE_SHARE_READ,
                       NULL, OPEN_EXISTING, FILE_FLAG_BACKUP_SEMANTICS,
                       NULL);

    if(INVALID_HANDLE_VALUE != hFile) {
        if(GetFileInformationByHandle(hFile, &bhfi)) {
            if (bhfi.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
            {
                hr = S_OK;
            }
        }
        else 
        {
            hr = HrFromLastWin32Error();
        }
        CloseHandle(hFile);
    }
    else 
    {
        hr = HrFromLastWin32Error();
    }

    if ((HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr) ||
        (HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND) == hr))
    {
        hr = S_FALSE;
    }

    TraceErrorSkip1(__FUNCNAME__, hr, S_FALSE);

    return hr;
}


// ======================================================================

// ----------------------------------------------------------------------
//
// Function:  HrGetPreNT5InfIdAndDesc
//
// Purpose:   Get pre-NT5 InfID and description of a net component
//
// Arguments:
//    hkeyCurrentVersion [in]  handle of HKLM\Software\<provider>\<component>\CurrentVersion
//    pstrInfId          [out] InfID returned
//    pstrDescription    [out] description returned
//    pstrServiceName    [out] service name returned
//
// Returns:   S_OK on success, otherwise an error code
//
// Author:    kumarp 19-December-97
//
// Notes:
//
HRESULT HrGetPreNT5InfIdAndDesc(IN HKEY hkeyCurrentVersion,
                                OUT tstring* pstrInfId,
                                OUT tstring* pstrDescription,
                                OUT tstring* pstrServiceName)
{
    DefineFunctionName("HrGetPreNT5InfIdAndDesc");

    Assert(hkeyCurrentVersion);
    AssertValidWritePtr(pstrInfId);

    HRESULT hr=S_OK;
    HKEY hkeyNetRules;

    hr = HrRegOpenKeyEx(hkeyCurrentVersion, c_szRegKeyNetRules,
                        KEY_READ, &hkeyNetRules);
    if (S_OK == hr)
    {
        hr = HrRegQueryString(hkeyNetRules, c_szRegValInfOption, pstrInfId);
        if ((S_OK == hr) && pstrDescription)
        {
            hr = HrRegQueryString(hkeyCurrentVersion, c_szRegValDescription,
                                  pstrDescription);
        }
        if ((S_OK == hr) && pstrServiceName)
        {
            hr = HrRegQueryString(hkeyCurrentVersion, c_szRegValServiceName,
                                  pstrServiceName);
        }
        RegCloseKey(hkeyNetRules);
    }

    if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr)
    {
        hr = S_FALSE;
    }

    TraceErrorOptional(__FUNCNAME__, hr, (hr == S_FALSE));

    return hr;
}

// ----------------------------------------------------------------------
//
// Function:  GetUnsupportedMessage
//
// Purpose:   Generate a message of the form:
//            Unsupported Net Card: DEC FDDIcontroller/PCI (DEFPA)
//
// Arguments:
//    pszComponentType [in]  type of component (net card/service/proto)
//    pszPreNT5InfId   [in]  pre-NT5 InfID
//    pszDescription   [in]  description
//    pstrMsg         [out] generated message
//
// Returns:   None
//
// Author:    kumarp 19-December-97
//
// Notes:
//
void GetUnsupportedMessage(IN PCWSTR pszComponentType,
                           IN PCWSTR pszPreNT5InfId,
                           IN PCWSTR pszDescription,
                           OUT tstring* pstrMsg)
{
    AssertValidReadPtr(pszPreNT5InfId);
    AssertValidReadPtr(pszDescription);
    AssertValidWritePtr(pstrMsg);

    if (!pszComponentType)
    {
        pszComponentType = c_szComponent;
    }

    const WCHAR c_szUnsupported[] = L"Possibly unsupported ";

    *pstrMsg = c_szUnsupported;
    *pstrMsg = *pstrMsg + pszComponentType + L" : " +
    pszDescription + L" (" + pszPreNT5InfId + L")";
}

// ----------------------------------------------------------------------
//
// Function:  GetUnsupportedMessageBool
//
// Purpose:   Generate a message of the form:
//            Unsupported Net Card: DEC FDDIcontroller/PCI (DEFPA)
//
// Arguments:
//    fIsHardwareComponent [in]  TRUE for a net card
//    pszPreNT5InfId        [in]  pre-NT5 InfID
//    pszDescription        [in]  description
//    pstrMsg              [out] generated message
//
// Returns:   None
//
// Author:    kumarp 19-December-97
//
// Notes:
//
void GetUnsupportedMessageBool(IN BOOL    fIsHardwareComponent,
                               IN PCWSTR pszPreNT5InfId,
                               IN PCWSTR pszDescription,
                               OUT tstring* pstrMsg)
{
    AssertValidReadPtr(pszPreNT5InfId);
    AssertValidReadPtr(pszDescription);
    AssertValidWritePtr(pstrMsg);

    GetUnsupportedMessage(fIsHardwareComponent ?
                          c_szNetCard : c_szComponent,
                          pszPreNT5InfId, pszDescription, pstrMsg);
}


// ----------------------------------------------------------------------
//
// Function:  ConvertMultiSzToDelimitedList
//
// Purpose:   Convert a multi-sz to a delimited list
//
// Arguments:
//    mszList     [in]  multi-sz
//    chDelimeter [in]  delimiter
//    pstrList    [out] delimited list
//
// Returns:   None
//
// Author:    kumarp 19-December-97
//
// Notes:
//
void ConvertMultiSzToDelimitedList(IN  PCWSTR  mszList,
                                   IN  WCHAR    chDelimeter,
                                   OUT tstring* pstrList)
{
    ULONG   ulLen;

    *pstrList = c_szEmpty;

    if (mszList)
    {
        while (*mszList)
        {
            ulLen = lstrlen(mszList);
            *pstrList += mszList;
            *pstrList += chDelimeter;
            mszList += (ulLen + 1);
        }
    }
}

//+---------------------------------------------------------------------------
//
// Function:  FIsPreNT5NetworkingInstalled
//
// Purpose:   Find out if atleast one networking component is installed
//
// Arguments: None
//
// Returns:   TRUE on success, FALSE otherwise
//
// Author:    kumarp 29-July-98
//
// Notes:     Valid only on pre NT5 versions
//

BOOL FIsPreNT5NetworkingInstalled()
{
    DefineFunctionName("FIsPreNT5NetworkingInstalled");
    HRESULT hr=S_OK;
    UINT cAdapters=0;

    if ((S_OK == HrGetNumNetCardsPreNT5(&cAdapters)) &&
        (cAdapters > 0))
    {
        return TRUE;
    }
    else
    {
        TraceTag(ttidNetUpgrade, "%s: no netcard found, trying to find other network components...", __FUNCNAME__);

        static const PCWSTR c_aszPreNt5NetworkingServices[] =
        {
            L"Alerter",
            L"Browser",
            L"DHCP",
            L"IpRip",
            L"LanmanServer",
            L"LanmanWorkstation",
            L"Messenger",
            L"NWCWorkstation",
            L"NetBIOS",
            L"NetBT",
            L"NtLmSsp",
            L"NwlnkIpx",
            L"NwlnkNb",
            L"NwlnkRip",
            L"NwlnkSpx",
            L"RasAuto",
            L"RasMan",
            L"Rdr",
            L"RelayAgent",
            L"RemoteAccess",
            L"Router",
            L"Rpclocator",
            L"Srv",
            L"Tcpip",
        };

        for (int i = 0; i < celems(c_aszPreNt5NetworkingServices); i++)
        {
            if (FIsServiceKeyPresent(c_aszPreNt5NetworkingServices[i]))
            {
                return TRUE;
            }
        }
    }

    TraceTag(ttidNetUpgrade, "%s: no netcards or net components found",
             __FUNCNAME__);

    return FALSE;
}

#ifdef ENABLETRACE

// ----------------------------------------------------------------------
//
// Function:  TraceStringList
//
// Purpose:   Trace items of a TStringList
//
// Arguments:
//    ttid        [in]  trace tag id to use
//    pszMsgPrefix [in]  prefix to use
//    sl          [in]  list
//
// Returns:   None
//
// Author:    kumarp 19-December-97
//
// Notes:
//
void TraceStringList(IN TraceTagId ttid,
                     IN PCWSTR pszMsgPrefix,
                     IN TStringList& sl)
{
    tstring strTemp;
    ConvertStringListToCommaList(sl, strTemp);
    TraceTag(ttid, "%S : %S", pszMsgPrefix, strTemp.c_str());
}

// ----------------------------------------------------------------------
//
// Function:  TraceMultiSz
//
// Purpose:   Trace elements of a multi-sz
//
// Arguments:
//    ttid        [in]  trace tag id to use
//    pszMsgPrefix [in]  prefix to use
//    msz         [in]  multi-sz
//
// Returns:   None
//
// Author:    kumarp 19-December-97
//
// Notes:
//
void TraceMultiSz(IN TraceTagId ttid,
                  IN PCWSTR pszMsgPrefix,
                  IN PCWSTR msz)
{
    tstring strTemp;
    ConvertMultiSzToDelimitedList(msz, ',', &strTemp);
    TraceTag(ttid, "%S : %S", pszMsgPrefix, strTemp.c_str());
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\upgrade\netupgrd\oemnuex.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT5.0
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       O E M N U E X . C P P
//
//  Contents:   Functions needed by OEM DLLs for OEM network upgrade
//
//  Notes:
//
//  Author:     kumarp    16-October-97
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

#include "kkcwinf.h"
#include "kkutils.h"
#include "oemupgex.h"

extern CWInfFile* g_pwifAnswerFile;


// ----------------------------------------------------------------------
//
// Function:  NetUpgradeAddSection
//
// Purpose:   Add section to answerfile
//
// Arguments:
//    szSectionName [in]  name of section to add
//
// Returns:   win32 error-code
//
// Author:    kumarp 19-December-97
//
// Notes:
//
EXTERN_C LONG __stdcall
NetUpgradeAddSection(IN PCWSTR szSectionName)
{
    DefineFunctionName("NetUpgradeAddSection");

    DWORD dwError=ERROR_OUTOFMEMORY;


    if (IsBadReadPtr(szSectionName, sizeof(*szSectionName)))
    {
        dwError = ERROR_INVALID_PARAMETER;
        TraceTag(ttidError, "%s: [<bad-read-ptr>]", __FUNCNAME__);
    }
    else if (g_pwifAnswerFile)
    {
        TraceTag(ttidNetUpgrade, "%s: [%S]", __FUNCNAME__, szSectionName);

        CWInfSection* pwis;

        pwis = g_pwifAnswerFile->AddSectionIfNotPresent(szSectionName);

        if (pwis)
        {
            dwError = ERROR_SUCCESS;
        }
        else
        {
            TraceTag(ttidError, "%s: failed", __FUNCNAME__);
        }
    }

    return dwError;
}

// ----------------------------------------------------------------------
//
// Function:  NetUpgradeAddLineToSection
//
// Purpose:   Add a line to the specified section in the answerfile
//
// Arguments:
//    szSectionName [in]  name of section
//    szLine        [in]  line text to add
//
// Returns:   win32 error code
//
// Author:    kumarp 19-December-97
//
// Notes:
//
EXTERN_C LONG __stdcall
NetUpgradeAddLineToSection(IN PCWSTR szSectionName,
                           IN PCWSTR szLine)
{
    DefineFunctionName("NetUpgradeAddLineToSection");

    DWORD dwError=ERROR_OUTOFMEMORY;

    if (IsBadReadPtr(szSectionName, sizeof(*szSectionName)) ||
        IsBadReadPtr(szSectionName, sizeof(*szLine)))
    {
        dwError = ERROR_INVALID_PARAMETER;
        TraceTag(ttidError, "%s: <bad-read-ptr>", __FUNCNAME__);
    }
    else if (g_pwifAnswerFile)
    {
        CWInfSection* pwis;

        pwis = g_pwifAnswerFile->FindSection(szSectionName);

        if (pwis)
        {
            TraceTag(ttidNetUpgrade, "%s: [%S] <-- %S", __FUNCNAME__,
                     szSectionName, szLine);
            pwis->AddRawLine(szLine);
            dwError = ERROR_SUCCESS;
        }
        else
        {
            TraceTag(ttidError, "%s: [%S] not found", __FUNCNAME__,
                     szSectionName);
            dwError = ERROR_SECTION_NOT_FOUND;
        }
    }

    return dwError;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\upgrade\netupgrd\nustrs.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT5.0
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       N U S T R S . H
//
//  Contents:   Strings constants for netupgrd
//
//  Notes:
//
//  Author:     kumarp    16-October-97
//
//----------------------------------------------------------------------------

#pragma once

extern const WCHAR c_szType[];
extern const WCHAR c_szLinkage[];
extern const WCHAR c_szLinkageDisabled[];
extern const WCHAR c_szRegKeyAdapterHome[];
extern const WCHAR c_szHidden[];
extern const WCHAR c_szRegKeyNetRules[];
extern const WCHAR c_szRegValInfOption[];
extern const WCHAR c_szRegValDescription[];
extern const WCHAR c_szRegValSoftwareType[];
extern const WCHAR c_szSoftwareTypeTransport[];
extern const WCHAR c_szSoftwareTypeDriver[];
extern const WCHAR c_szSoftwareTypeService[];
extern const WCHAR c_szSoftwareTypeSystem[];
extern const WCHAR c_szSoftwareTypeClient[];
extern const WCHAR c_szRegKeySoftware[];
extern const WCHAR c_szRegKeyCurrentVersion[];
extern const WCHAR c_szRegKeyMicrosoft[];

extern const WCHAR c_szNetCard[];


extern const WCHAR c_szRegValComputerName[];
extern const WCHAR c_szComputerName[];
extern const WCHAR c_szRegKeySoftwareMicrosoft[];
extern const WCHAR c_szRegValRoute[];
extern const WCHAR c_szRegValBind[];
extern const WCHAR c_szSvcTcpip[];
extern const WCHAR c_szSvcNetBT[];
extern const WCHAR c_szNoParamsRequired[];
extern const WCHAR c_szNotSupported[];
extern const WCHAR c_szDhcpServerLinkageDisabled[];
extern const WCHAR c_szRegWlbsLinkage[];
extern const WCHAR c_szRegConvoyLinkage[];
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\upgrade\netupgrd\resource.h ===
// Used by netupgrd.rc
//

#define IDD_UPGRADE_CONFLICTS                   2100
#define IDC_LB_CONFLICTS                        2108
#define IDC_HAVE_DISK                           2109
#define IDC_STATIC                              -1


#define IDS_DoYouWantToAbortUpgrade             2000
#define IDS_E_CopyingOemFiles                   2001
#define IDS_E_DoPreUpgradeProcessing            2002
#define IDS_E_ErrorCode                         2003
#define IDS_E_GenUpgradeConflictList            2004
#define IDS_E_GetOemUpgradeDllInfoInInf         2005
#define IDS_E_InitAndProcessOemDirs             2006
#define IDS_E_LoadAndInitOemDll                 2007
#define IDS_E_NetMapInfError                    2008
#define IDS_E_DhcpServerUpgradeError            2009
#define IDS_E_OemComponentUpgrade               2010
#define IDS_E_OemDllCausedAnException           2011
#define IDS_E_OemDllRequestsAbortingUpgrade     2012
#define IDS_E_OemFilesNotValidForComponents     2013
#define IDS_E_PresetNetMapInfError              2014
#define IDS_E_RefuseNovellClientUpgrade         2015
#define IDS_E_SetupCannotContinue               2016
#define IDS_E_WritingAnswerFile                 2017
#define IDS_InfoAboutOemDllSupplier             2018
#define IDS_NetupgrdCaption                     2019
#define IDS_OemNetMapFileFilter1                2020
#define IDS_OemQueryFileLocation                2021
#define IDS_ViAdditionalInfo                    2022
#define IDS_ViCompanyName                       2023
#define IDS_ViSupportNumber                     2024
#define IDS_ViSupportUrl                        2025
#define IDS_OemNetMapFileFilter2                2026
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\upgrade\netupgrd\wconflct.h ===
// ----------------------------------------------------------------------
//
//  Microsoft Windows NT
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:      W C O N F L C T . H
//
//  Contents:  Wizard page for upgrade conflicts
//
//  Notes:
//
//  Author:    kumarp 22-December-97
//
// ----------------------------------------------------------------------


#pragma once

PROPSHEETPAGE GetUpgradeConflictPage();
HPROPSHEETPAGE GetUpgradeConflictHPage();

void AddListBoxItem(IN HWND hwndListBox, IN PCWSTR pszItem);
void AddListBoxItems(IN HWND hwndListBox, IN TStringList* pslItems);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\upgrade\netupgrd\version.h ===
#include <ntverp.h>
#include <winver.h>

#define VER_FILETYPE                    VFT_DLL
#define VER_FILESUBTYPE                 VFT2_UNKNOWN
#define VER_FILEDESCRIPTION_STR         "Network Upgrade Wizard"
#define VER_INTERNALNAME_STR            "netupgrd.dll"

#include "common.ver"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ddk\makefile.inc ===
!IFDEF PASS0ONLY
BuildDDK:

!ELSE

#
# Process only on the second pass
#

BuildDDK:
	call $(RAZZLETOOLPATH)\copyddkfiles.cmd ddk_net.ini ddk $(PROJECT_ROOT)

!ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\client\dhcp\apiargs.c ===
/*++

Copyright (C) 1997 Microsoft Corporation

Module:
    apiargs.c

Abstract:
    argument marshalling, unmarshalling helper routines.

Environment:
    Win32 usermode (DHCP), Win98 VxD

--*/

#include "precomp.h"
#include <apiargs.h>

DWORD
DhcpApiArgAdd(
    IN OUT LPBYTE Buffer,
    IN ULONG MaxBufSize,
    IN BYTE ArgId,
    IN ULONG ArgSize,
    IN LPBYTE ArgVal OPTIONAL
)
/*++

Routine Description:

    This routine adds an arg provided via the ArgId, ArgSize and ArgVal
    parameters onto the buffer "Buffer" which is formatted as follows:
        sequence of  [BYTE Option ID, DWORD network order Size of foll
                       bytes, actual Bytes of information]
    Also, the first DWORD of the buffer is the number of bytes of the
    buffer (excluding itself).

    In case the buffer does not have enough space, the first ULONG will
    contain the actual size required, and ERROR_MORE_DATA will be
    returned. 

    For this reason, the Buffer MUST be atleast sizeof(ULONG) bytes long. 

Arguments:

    Buffer -- a byte stream buffer where the arg is appended.
    MaxBufSize -- maximum size of the buffer provided
    ArgId -- argument to add
    ArgSize -- # of bytes of argument
    ArgVal -- the actual binary information 

Return Value:

    ERROR_MORE_DATA -- not enough space in the buffer
    ERROR_SUCCESS -- everthing went fine

--*/
{
    ULONG CurBufSize, OldBufSize;

    DhcpAssert(Buffer);
    CurBufSize = ntohl(*(ULONG UNALIGNED *)Buffer);
    OldBufSize = CurBufSize;
    CurBufSize += sizeof(ArgId) + sizeof(ArgSize) + ArgSize ;

    *(ULONG UNALIGNED*)Buffer = htonl(CurBufSize);

    if( CurBufSize + sizeof(DWORD) > MaxBufSize ) return ERROR_MORE_DATA;

    OldBufSize += sizeof(DWORD);
    Buffer[OldBufSize++] = ArgId;
    (*(DWORD UNALIGNED*) (&Buffer[OldBufSize])) = htonl(ArgSize);
    OldBufSize += sizeof(ArgSize);

    if(ArgSize) memcpy(&Buffer[OldBufSize], ArgVal, ArgSize);

    return ERROR_SUCCESS;
}

DWORD
DhcpApiArgDecode(
    IN LPBYTE Buffer,
    IN ULONG BufSize,
    IN OUT PDHCP_API_ARGS ArgsArray OPTIONAL,
    IN OUT PULONG Size 
) 
/*++

Routine Description:

    This routine unmarshalls a buffer that has marshalled arguments (the
    arguments must have been created via the DhcpApiArgAdd routine) into
    the ArgsArray array of args..

    If the ArgsArray has insufficient elements (i.e. the Buffer has more
    args than there are in ArgsArray) then ERROR_MORE_DATA is returned and
    Size is set to the number of elements required in ArgsArray.

    The pointers in ArgsArray are patched to the respective places in the
    Buffer so while ArgsArray is in use, the Buffer should not be
    modified. 

    The input buffer should exclude the first ULONG of the buffer that
    would be output by DhcpApiArgAdd -- The first ULONG should be passed as
    BufSize and the rest of the buffer should be passed as the first
    parameter. 

Arguments:

    Buffer -- input buffer marshalled via DhcpApiArgAdd
    BufSize -- size of input buffer
    ArgsArray -- array to fill in with parsed arguments off buffer
    Size -- On input this is the number of elements in ArgsArray.  On
    output, it is the number of filled elements in ArgsArray.

Return Value:

    ERROR_MORE_DATA -- the number of elements in ArgsArray is
    insufficient.   Check Size to find out the actual # of elements
    required.

    ERROR_INVALID_PARAMETER -- Buffer was illegally formatted.

    ERROR_SUCCESS -- routine succeeded.

--*/
{
    ULONG ReqdSize, InSize, tmp, ArgSize, ArgVal, i;
    BYTE ArgId;

    DhcpAssert(Size && Buffer);
    InSize = *Size;
    ReqdSize = 0;
    i = 0;

    while( i < BufSize ) {
        ArgId = Buffer[i++];
        if( i + sizeof(ArgSize) > BufSize ) return ERROR_INVALID_PARAMETER;
        ArgSize = ntohl(*(DWORD UNALIGNED *)&Buffer[i]);
        i += sizeof(ArgSize);
        if( i + ArgSize > BufSize ) return ERROR_INVALID_PARAMETER;

        if( ReqdSize < InSize ) {
            ArgsArray[ReqdSize].ArgId = ArgId;
            ArgsArray[ReqdSize].ArgSize = ArgSize;
            ArgsArray[ReqdSize].ArgVal = &Buffer[i];
        }
        ReqdSize ++;
        i += ArgSize;
    }

    *Size = ReqdSize;
    if( ReqdSize > InSize ) return ERROR_MORE_DATA;

    return ERROR_SUCCESS;
}

//
// end of file.
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\client\dhcp\dhcpmsg.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    local.c

Abstract:

    Stubs for NT specific functions.

Author:

    Manny Weiser (mannyw)  18-Oct-1992
    Johnl                  28-Oct-1993
        Broke out from locals.c for Vxd support

Environment:

    User Mode - Win32

Revision History:

--*/

#include "precomp.h"
#include "dhcpglobal.h"

#define MAX_ADAPTERS  10

#ifdef VXD
#include <vxdprocs.h>
#include <..\vxd\local.h>
#else

#ifdef NEWNT                // Pickup the platform specific structures
#include <dhcploc.h>
#else
#include <local.h>
#endif
#endif


//*******************  Pageable Routine Declarations ****************
#if defined(CHICAGO) && defined(ALLOC_PRAGMA)
//
// This is a hack to stop compiler complaining about the routines already
// being in a segment!!!
//

#pragma code_seg()

#pragma CTEMakePageable(PAGEDHCP, SendDhcpMessage )
#pragma CTEMakePageable(PAGEDHCP, GetSpecifiedDhcpMessage )
//*******************************************************************
#endif CHICAGO && ALLOC_PRAGMA

DWORD
SendDhcpMessage(
    PDHCP_CONTEXT DhcpContext,
    DWORD MessageLength,
    PDWORD TransactionId
    )
/*++

Routine Description:

    This function sends a UDP message to the DHCP server specified
    in the DhcpContext.

Arguments:

    DhcpContext - A pointer to a DHCP context block.

    MessageLength - The length of the message to send.

    TransactionID - The transaction ID for this message.  If 0, the
        function generates a random ID, and returns it.

Return Value:

    The status of the operation.

--*/
{
    DWORD error;
    int i;
    struct sockaddr_in socketName;
    time_t TimeNow;
    BOOL   LockedInterface = FALSE;

    if ( *TransactionId == 0 ) {
        *TransactionId = (rand() << 16) + rand();
    }

    DhcpContext->MessageBuffer->TransactionID = *TransactionId;

    //
    // Initialize the outgoing address.
    //

    socketName.sin_family = PF_INET;
    socketName.sin_port = htons( (USHORT)DhcpGlobalServerPort );

    if( IS_ADDRESS_PLUMBED(DhcpContext) &&
               !IS_MEDIA_RECONNECTED(DhcpContext) &&    // media reconnect - braodcast
               !IS_POWER_RESUMED(DhcpContext) ) {       // power resumed - broadcast

        //
        // If we are past T2, use the broadcast address; otherwise,
        // direct this to the server.
        //

        TimeNow = time( NULL );

        if ( TimeNow > DhcpContext->T2Time
            || !DhcpContext->DhcpServerAddress ) {
            socketName.sin_addr.s_addr = (DHCP_IP_ADDRESS)(INADDR_BROADCAST);
        } else {
            socketName.sin_addr.s_addr = DhcpContext->DhcpServerAddress;
        }
    }
    else {
        socketName.sin_addr.s_addr = (DHCP_IP_ADDRESS)(INADDR_BROADCAST);
    }

    for ( i = 0; i < 8 ; i++ ) {
        socketName.sin_zero[i] = 0;
    }

    if( socketName.sin_addr.s_addr ==
            (DHCP_IP_ADDRESS)(INADDR_BROADCAST) ) {

        DWORD Error = ERROR_SUCCESS;
        DWORD InterfaceId;

        //
        // if we broadcast a message, inform IP stack - the adapter we
        // like to send this broadcast on, otherwise it will pick up the
        // first uninitialized adapter.
        //

#ifdef VXD
        InterfaceId = ((PLOCAL_CONTEXT_INFO)
            DhcpContext->LocalInformation)->IpContext;

        if( !IPSetInterface( InterfaceId ) ) {
            // DhcpAssert( FALSE );
            Error = ERROR_GEN_FAILURE;
        }
#else
        InterfaceId = ((PLOCAL_CONTEXT_INFO)
            DhcpContext->LocalInformation)->IpInterfaceContext;

        LOCK_INTERFACE();
        LockedInterface = TRUE;
        Error = IPSetInterface( InterfaceId );
        // DhcpAssert( Error == ERROR_SUCCESS );
#endif
        if( ERROR_SUCCESS != Error ) {
            DhcpPrint((DEBUG_ERRORS, "IPSetInterface failed with %lx error\n", Error));
            UNLOCK_INTERFACE();
            return Error;
        }
    }

    //
    // send minimum DHCP_MIN_SEND_RECV_PK_SIZE (300) bytes, otherwise
    // bootp relay agents don't like the packet.
    //

    MessageLength = (MessageLength > DHCP_MIN_SEND_RECV_PK_SIZE) ?
                        MessageLength : DHCP_MIN_SEND_RECV_PK_SIZE;
    error = sendto(
                ((PLOCAL_CONTEXT_INFO)
                    DhcpContext->LocalInformation)->Socket,
                (PCHAR)DhcpContext->MessageBuffer,
                MessageLength,
                0,
                (struct sockaddr *)&socketName,
                sizeof( struct sockaddr )
                );

#ifndef VXD
    if( LockedInterface ) UNLOCK_INTERFACE();
#endif  VXD

    if ( error == SOCKET_ERROR ) {
        error = WSAGetLastError();
        DhcpPrint(( DEBUG_ERRORS, "Send failed, error = %ld\n", error ));
    } else {
        IF_DEBUG( PROTOCOL ) {
            DhcpPrint(( DEBUG_PROTOCOL, "Sent message to %s: \n", inet_ntoa( socketName.sin_addr )));
        }

        DhcpDumpMessage(
            DEBUG_PROTOCOL_DUMP,
            DhcpContext->MessageBuffer,
            DHCP_MESSAGE_SIZE
            );
        error = NO_ERROR;
    }

    return( error );
}

typedef     struct  /* anonymous */ {             // structure to hold waiting recvfroms
    LIST_ENTRY                     RecvList;      // other elements in this list
    PDHCP_CONTEXT                  Ctxt;          // which context is this wait for?
    DWORD                          InBufLen;      // what was the buffer size to recv in?
    PDWORD                         BufLen;        // how many bytes did we recvd?
    DWORD                          Xid;           // what xid is this wait for?
    time_t                         ExpTime;       // wait until what time?
    WSAEVENT                       WaitEvent;     // event for waiting on..
    BOOL                           Recd;          // was a packet received..?
} RECV_CTXT, *PRECV_CTXT;                         // ctxt used to recv on..

VOID
InsertInPriorityList(                             // insert in priority list according to Secs
    IN OUT  PRECV_CTXT             Ctxt,          // Secs field changed to hold offset
    IN      PLIST_ENTRY            List,
    OUT     PBOOL                  First          // adding in first location?
)
{
    PRECV_CTXT                     ThisCtxt;
    PLIST_ENTRY                    InitList;      // "List" param at function entry

    EnterCriticalSection( &DhcpGlobalRecvFromCritSect );

    if( IsListEmpty(List) ) {                     // no element in list? add this and quit
        *First = TRUE;                            // adding at head
    } else {
        *First = FALSE;                           // adding at tail..
    }

    InsertTailList( List, &Ctxt->RecvList);       // insert element..
    LeaveCriticalSection( &DhcpGlobalRecvFromCritSect );
}

#define RATIO 1
DWORD
AsyncSelect(
    PDHCP_CONTEXT   DhcpContext,
    time_t          Timeout
    )
/*++

Routine Description:

Arguments:

Return Value:

    ERROR_CANCELLED     the request is cancelled
    ERROR_SEM_TIMEOUT   the request time out
    ERROR_SUCCESS       message is ready
    other               unknown failure

--*/
{
    PLOCAL_CONTEXT_INFO    pLocalInfo;
    DWORD error;

    pLocalInfo = (PLOCAL_CONTEXT_INFO)DhcpContext->LocalInformation;
    if (DhcpContext->CancelEvent != WSA_INVALID_EVENT)
    {
        // there is a valid cancel event for this socket - then wait on the socket
        // while listening for cancel requests
        WSAEVENT WaitEvts[2];

        DhcpPrint((DEBUG_TRACK, "Wait %dsecs for message through WSAWaitForMultipleEvents().\n", Timeout));

        // create the event associated with the socket
        WaitEvts[0] = WSACreateEvent();
        if (WaitEvts[0] == WSA_INVALID_EVENT ||
            WSAEventSelect(pLocalInfo->Socket, WaitEvts[0], FD_READ) != 0)
        {
            // the event creation failed -> something must have gone really bad
            error = WSAGetLastError();
            DhcpPrint((DEBUG_ERRORS, "Could not create/select socket event: 0x%ld\n", error));
        }
        else
        {
            WaitEvts[1] = DhcpContext->CancelEvent;


            error = WSAWaitForMultipleEvents(
                        2,
                        WaitEvts,
                        FALSE,
                        (DWORD)(Timeout*1000),
                        FALSE);

            if (error == WSA_WAIT_FAILED)
            {
                // some error occured in the WSA call - this shouldn't happen
                error = WSAGetLastError();
                DhcpPrint((DEBUG_ERRORS,"WSAWaitForMultipleEvents failed: %d\n", error));
            }
            else if (error == WSA_WAIT_TIMEOUT)
            {
                // the call timed out - could happen if no server is on the net
                error = ERROR_SEM_TIMEOUT;
                DhcpPrint((DEBUG_ERRORS, "WSAWaitForMultipleEvents timed out\n"));
            }
            else if (error == WSA_WAIT_EVENT_0+1)
            {
                // some PnP event must have been triggering the cancel request
                error = ERROR_CANCELLED;
                DhcpPrint((DEBUG_TRACK, "AsyncSelect has been canceled\n"));
            }
            else if (error == WSA_WAIT_EVENT_0)
            {
                // everything went up fine, some message must have been received
                WSANETWORKEVENTS netEvents;

                // assume the socket event has been signaled because of data
                // being available on the socket.
                error = WSAEnumNetworkEvents(
                            pLocalInfo->Socket,
                            NULL,
                            &netEvents);
                if (error == SOCKET_ERROR)
                {
                    // if something really bad went on, return with that error
                    error = WSAGetLastError();
                    DhcpPrint((DEBUG_ERRORS,"WSAEnumNetworkEvents failed: %d\n", error));
                }
                else 
                {   // return whatever error corresponds to this event.
                    // normally it should be NO_ERROR.
                    error = netEvents.iErrorCode[FD_READ_BIT];
                }
            } else {
                DhcpAssert(0);
            }
        }

        if (WaitEvts[0] != WSA_INVALID_EVENT)
            WSACloseEvent(WaitEvts[0]);
    }
    else
    {
        struct timeval timeout;
        fd_set readSocketSet;

        DhcpPrint((DEBUG_TRACK, "Wait %dsecs for message through select().\n", Timeout));

        FD_ZERO( &readSocketSet );
        FD_SET( pLocalInfo->Socket, &readSocketSet );

        timeout.tv_sec  = (DWORD)(Timeout / RATIO);
        timeout.tv_usec = (DWORD)(Timeout % RATIO);
        DhcpPrint((DEBUG_TRACE, "Select: waiting for: %ld seconds\n", Timeout));
        error = select( 0, &readSocketSet, NULL, NULL, &timeout );
        if (error == 0)
        {
            DhcpPrint((DEBUG_ERRORS, "Select timed out\n", 0));
            error = ERROR_SEM_TIMEOUT;
        }
        else if (error == SOCKET_ERROR)
        {
            error = WSAGetLastError();
            DhcpPrint((DEBUG_ERRORS, "Generic error in select %d\n", error));
        } else {
            // the only case that remains is that our only socket has data on it.
            DhcpAssert(error == 1);
            // this means success
            error = ERROR_SUCCESS;
        }
    }
    DhcpPrint((DEBUG_TRACK, "AsyncSelect exited: %d\n", error));
    return error;
}

DWORD
TryReceive(                                       // try to recv pkt on 0.0.0.0 socket
    IN      PDHCP_CONTEXT          DhcpContext,   // socket to recv on
    IN      LPBYTE                 Buffer,        // buffer to fill
    OUT     PDWORD                 BufLen,        // # of bytes filled in buffer
    OUT     PDWORD                 Xid,           // Xid of recd pkt
    IN      DWORD                  Secs           // # of secs to spend waiting?
)
{
    DWORD           Error;
    struct sockaddr SockName;
    int             SockNameSize;
    PLOCAL_CONTEXT_INFO    pLocalInfo;

    DhcpPrint((DEBUG_TRACE, "Select: waiting for: %ld seconds\n", Secs));

    pLocalInfo = (PLOCAL_CONTEXT_INFO)DhcpContext->LocalInformation;
    Error = AsyncSelect(
                DhcpContext,
                Secs);
    if( Error != NO_ERROR)
        return Error;

    SockNameSize = sizeof( SockName );
    Error = recvfrom(pLocalInfo->Socket,Buffer,*BufLen, 0, &SockName, &SockNameSize);
    if( SOCKET_ERROR == Error ) {
        Error = WSAGetLastError();
        DhcpPrint((DEBUG_ERRORS, "Recv failed %d\n",Error));
    } else if( Error < sizeof(DHCP_MESSAGE) ) {
        DhcpPrint((DEBUG_ERRORS, "Recv received small packet: %d\n", Error));
        DhcpPrint((DEBUG_ERRORS, "Packet ignored\n"));
        Error = ERROR_INVALID_DATA;
    } else {
        *BufLen = Error;
        Error = ERROR_SUCCESS;
        *Xid = ((PDHCP_MESSAGE)Buffer)->TransactionID;
        DhcpPrint((DEBUG_PROTOCOL, "Recd msg XID: 0x%lx [Mdhcp? %s]\n", *Xid,
                   IS_MDHCP_MESSAGE(((PDHCP_MESSAGE)Buffer))?"yes":"no" ));
    }

    return Error;
}

VOID
DispatchPkt(                                      // find out any takers for Xid
    IN OUT  PRECV_CTXT             Ctxt,          // ctxt that has buffer and buflen
    IN      DWORD                  Xid            // recd Xid
)
{
    EnterCriticalSection(&DhcpGlobalRecvFromCritSect);
    do {                                          // not a loop, just for ease of use
        LPBYTE                     Tmp;
        PLIST_ENTRY                Entry;
        PRECV_CTXT                 ThisCtxt;

        Entry = DhcpGlobalRecvFromList.Flink;
        while(Entry != &DhcpGlobalRecvFromList ) {
            ThisCtxt = CONTAINING_RECORD(Entry, RECV_CTXT, RecvList);
            Entry = Entry->Flink;

            if(Xid != ThisCtxt->Xid ) continue;   // mismatch.. nothing more todo

            // now check for same type of message and ctxt...
            if( (unsigned)IS_MDHCP_MESSAGE((Ctxt->Ctxt->MessageBuffer))
                !=
                IS_MDHCP_CTX( (ThisCtxt->Ctxt) )
            ) {
                //
                // The contexts dont match.. give up
                //
                continue;
            }

            //
            // check for same hardware address..
            //
            if (ThisCtxt->Ctxt->HardwareAddressType != HARDWARE_1394 ||
                Ctxt->Ctxt->MessageBuffer->HardwareAddressType != HARDWARE_1394) {
                if( ThisCtxt->Ctxt->HardwareAddressLength != Ctxt->Ctxt->MessageBuffer->HardwareAddressLength ) {
                    continue;
                }

                if( 0 != memcmp(ThisCtxt->Ctxt->HardwareAddress,
                                Ctxt->Ctxt->MessageBuffer->HardwareAddress,
                                ThisCtxt->Ctxt->HardwareAddressLength
                ) ) {
                    continue;
                }
            }

            // matched.. switch buffers to give this guy this due..

            DhcpDumpMessage(
                DEBUG_PROTOCOL_DUMP,
                (PDHCP_MESSAGE)(Ctxt->Ctxt->MessageBuffer),
                DHCP_RECV_MESSAGE_SIZE
                );

            *(ThisCtxt->BufLen) = *(Ctxt->BufLen);
            RtlCopyMemory(
                ThisCtxt->Ctxt->MessageBuffer, Ctxt->Ctxt->MessageBuffer,
                (*ThisCtxt->BufLen)
                );

            RemoveEntryList(&ThisCtxt->RecvList);
            InitializeListHead(&ThisCtxt->RecvList);
            DhcpAssert(FALSE == ThisCtxt->Recd);
            ThisCtxt->Recd = TRUE;
            if( !WSASetEvent(ThisCtxt->WaitEvent) ) {
                DhcpAssert(FALSE);
            }

            break;
        }
    } while (FALSE);
    LeaveCriticalSection(&DhcpGlobalRecvFromCritSect);
}

DWORD
ProcessRecvFromSocket(                            // wait using select and process incoming pkts
    IN OUT  PRECV_CTXT             Ctxt           // ctxt to use
)
{
    time_t                         TimeNow;
    LPBYTE                         Buffer;
    DWORD                          Xid;
    DWORD                          Error = ERROR_SEM_TIMEOUT;
    PLIST_ENTRY                    Entry;

    TimeNow = time(NULL);
    // if the context is already expired, then rely on the
    // default Error (ERROR_SEM_TIMEOUT)
    while(TimeNow <= Ctxt->ExpTime )
    {
        Buffer = (LPBYTE)((Ctxt->Ctxt)->MessageBuffer);
        *(Ctxt->BufLen) = Ctxt->InBufLen;

        Error = TryReceive(
                    Ctxt->Ctxt,
                    Buffer,
                    Ctxt->BufLen,
                    &Xid,
                    (DWORD)(Ctxt->ExpTime - TimeNow));

        // update the timestamp - most probably we will need it
        TimeNow = time(NULL);

        // ignore spurious connection reset errors (???)
        if (Error == WSAECONNRESET)
            continue;

        // if something went wrong or we got the message
        // we were waiting for, just break the loop
        if (Error != ERROR_SUCCESS || Xid == Ctxt->Xid)
            break;

        // we successfully got a message but it was not for us.
        // dispatch it in the queue and continue
        DispatchPkt(Ctxt, Xid);
    }

    if( TimeNow > Ctxt->ExpTime )
    {               // we timed out.
        Error = ERROR_SEM_TIMEOUT;
    }

    // now done.. so we must remove this ctxt from the list and signal first guy
    EnterCriticalSection(&DhcpGlobalRecvFromCritSect);
    RemoveEntryList(&Ctxt->RecvList);
    WSACloseEvent(Ctxt->WaitEvent);
    if( !IsListEmpty(&DhcpGlobalRecvFromList))
    {  // ok got an elt.. signal this.
        Entry = DhcpGlobalRecvFromList.Flink;
        Ctxt = CONTAINING_RECORD(Entry, RECV_CTXT, RecvList);
        if( !WSASetEvent(Ctxt->WaitEvent) )
        {
            DhcpAssert(FALSE);
        }
    }
    LeaveCriticalSection(&DhcpGlobalRecvFromCritSect);

    return Error;
}

//================================================================================
//  get dhcp message with requested transaction id, but also make sure only one
//  socket is used at any given time (one socket bound to 0.0.0.0), and also
//  re-distribute message for some other thread if that is also required..
//================================================================================
DWORD
GetSpecifiedDhcpMessageEx(
    IN OUT  PDHCP_CONTEXT          DhcpContext,   // which context to recv for
    OUT     PDWORD                 BufferLength,  // how big a buffer was read?
    IN      DWORD                  Xid,           // which xid to look for?
    IN      DWORD                  TimeToWait     // how many seconds to sleep?
)
/*++

Routine Description:

Arguments:

Return Value:

    ERROR_CANCELLED     the request is cancelled
    ERROR_SEM_TIMEOUT   the request time out
    ERROR_SUCCESS       message is ready
    other               unknown failure

--*/
{
    RECV_CTXT                      Ctxt;          // element in list for this call to getspe..
    BOOL                           First;         // is this the first element in list?
    DWORD                          Result;

    Ctxt.Ctxt = DhcpContext;                      // fill in the context
    Ctxt.InBufLen = *BufferLength;
    Ctxt.BufLen = BufferLength;
    Ctxt.Xid = Xid;
    Ctxt.ExpTime = time(NULL) + TimeToWait;
    Ctxt.WaitEvent = WSACreateEvent();
    Ctxt.Recd = FALSE;
    if( Ctxt.WaitEvent == WSA_INVALID_EVENT)
    {
        DhcpAssert(NULL != Ctxt.WaitEvent);
        return WSAGetLastError();
    }

    First = FALSE;
    InsertInPriorityList(&Ctxt, &DhcpGlobalRecvFromList, &First);

    if( First )
    {                                 // this *is* the first call to GetSpec..
        Result = ProcessRecvFromSocket(&Ctxt);
    }
    else
    {                                      // we wait for other calls to go thru..
        WSAEVENT    WaitEvts[2];
        DWORD       WaitCount;
        PLOCAL_CONTEXT_INFO pLocalInfo = (PLOCAL_CONTEXT_INFO)DhcpContext->LocalInformation;

        WaitCount = 0;
        WaitEvts[WaitCount++] = Ctxt.WaitEvent;
        if (DhcpContext->CancelEvent != WSA_INVALID_EVENT)
            WaitEvts[WaitCount++] = DhcpContext->CancelEvent;

        Result = WSAWaitForMultipleEvents(
                    WaitCount,
                    WaitEvts,
                    FALSE,
                    TimeToWait*1000,
                    FALSE);

        EnterCriticalSection(&DhcpGlobalRecvFromCritSect);
        if (Result == WSA_WAIT_EVENT_0)
        {
            // some other thread signaled up.
            LeaveCriticalSection(&DhcpGlobalRecvFromCritSect);

            if (Ctxt.Recd)
            {
                // If a message has been received for us (Recd is set) we were 
                // already removed from the queue - just return SUCCESS.
                Result = ERROR_SUCCESS;
                WSACloseEvent(Ctxt.WaitEvent);
            }
            else
            {
                // If there was no message for us it means it is our turn to 
                // listen on the wire.
                Result = ProcessRecvFromSocket(&Ctxt);
            }
        }
        else
        {
            // either something bad happened while waiting, we timed out or
            // a cancellation request has been signaled. In any case we
            // get out of the queue.
            RemoveEntryList(&Ctxt.RecvList);
            LeaveCriticalSection(&DhcpGlobalRecvFromCritSect);

            switch(Result)
            {
            case WSA_WAIT_EVENT_0+1: // cancel has been signaled
                DhcpPrint((DEBUG_TRACK, "GetSpecifiedDhcpMessageEx has been canceled\n"));
                Result = ERROR_CANCELLED;
                break;
            case WSA_WAIT_TIMEOUT:  // timed out waiting in the queue
                Result = ERROR_SEM_TIMEOUT;
                break;
            default:                // something else bad happened
                Result = WSAGetLastError();
            }

            WSACloseEvent(Ctxt.WaitEvent);
        }
    }

    return Result;
}

DWORD
GetSpecifiedDhcpMessage(
    PDHCP_CONTEXT DhcpContext,
    PDWORD BufferLength,
    DWORD TransactionId,
    DWORD TimeToWait
    )
/*++

Routine Description:

    This function waits TimeToWait seconds to receives the specified
    DHCP response.

Arguments:

    DhcpContext - A pointer to a DHCP context block.

    BufferLength - Returns the size of the input buffer.

    TransactionID - A filter.  Wait for a message with this TID.

    TimeToWait - Time, in milli seconds, to wait for the message.

Return Value:

    ERROR_CANCELLED     the request is cancelled
    ERROR_SEM_TIMEOUT   the request time out
    ERROR_SUCCESS       message is ready
    other               unknown failure

--*/
{
    struct sockaddr socketName;
    int socketNameSize = sizeof( socketName );
    time_t startTime, now;
    DWORD error;
    DWORD actualTimeToWait;
    PLOCAL_CONTEXT_INFO pLocalInfo;

    if( IS_APICTXT_DISABLED(DhcpContext) && IS_DHCP_ENABLED(DhcpContext) && (
        !IS_ADDRESS_PLUMBED(DhcpContext) || DhcpIsInitState(DhcpContext)) ) {
        //
        // For RAS server Lease API this call won't happen as we don't have to do this nonsense
        //
        error = GetSpecifiedDhcpMessageEx(
            DhcpContext,
            BufferLength,
            TransactionId,
            TimeToWait
        );
        if( ERROR_SUCCESS == error ) {
            // received a message frm the dhcp server..
            SERVER_REACHED(DhcpContext);
        }
        return error;
    }

    startTime = time( NULL );
    actualTimeToWait = TimeToWait;

    //
    // Setup the file descriptor set for select.
    //

    pLocalInfo = (PLOCAL_CONTEXT_INFO)DhcpContext->LocalInformation;

    while ( 1 ) {

        error = AsyncSelect(DhcpContext, actualTimeToWait);

        if ( error != ERROR_SUCCESS )
        {
            // Timeout, cancel or some other error...
            DhcpPrint(( DEBUG_ERRORS, "Recv failed %d\n", error ));
            break;
        }

        error = recvfrom(
            pLocalInfo->Socket,
            (PCHAR)DhcpContext->MessageBuffer,
            *BufferLength,
            0,
            &socketName,
            &socketNameSize
            );

        if ( error == SOCKET_ERROR ) {
            error = WSAGetLastError();
            DhcpPrint(( DEBUG_ERRORS, "Recv failed, error = %ld\n", error ));

            if( WSAECONNRESET != error ) break;

            //
            // ignore connreset -- this could be caused by someone sending random ICMP port unreachable.
            //

        } else if( error < sizeof(DHCP_MESSAGE) ) {
            DhcpPrint(( DEBUG_ERRORS, "Recv received a very small packet: 0x%lx\n", error));
        } else if (DhcpContext->MessageBuffer->TransactionID == TransactionId ) {
            DhcpPrint(( DEBUG_PROTOCOL,
                            "Received Message, XID = %lx, MDhcp = %d.\n",
                            TransactionId,
                            IS_MDHCP_MESSAGE( DhcpContext->MessageBuffer) ));

            if (((unsigned)IS_MDHCP_MESSAGE( DhcpContext->MessageBuffer) == IS_MDHCP_CTX( DhcpContext))) {
                DhcpDumpMessage(
                    DEBUG_PROTOCOL_DUMP,
                    DhcpContext->MessageBuffer,
                    DHCP_RECV_MESSAGE_SIZE
                    );

                *BufferLength = error;
                error = NO_ERROR;

                if (DhcpContext->MessageBuffer->HardwareAddressType != HARDWARE_1394 ||
                    DhcpContext->HardwareAddressType != HARDWARE_1394) {
                    if( DhcpContext->MessageBuffer->HardwareAddressLength == DhcpContext->HardwareAddressLength
                        && 0 == memcmp(DhcpContext->MessageBuffer->HardwareAddress,
                                       DhcpContext->HardwareAddress,
                                       DhcpContext->HardwareAddressLength
                        )) {

                        //
                        // Transction IDs match, same type (MDHCP/DHCP), Hardware addresses match!
                        //

                        break;
                    }
                } else {
                    break;
                }
            }
        } else {
            DhcpPrint(( DEBUG_PROTOCOL,
                "Received a buffer with unknown XID = %lx\n",
                    DhcpContext->MessageBuffer->TransactionID ));
        }

        //
        // We received a message, but not the one we're interested in.
        // Reset the timeout to reflect elapsed time, and wait for
        // another message.
        //
        now = time( NULL );
        actualTimeToWait = (DWORD)(TimeToWait - RATIO * (now - startTime));
        if ( (LONG)actualTimeToWait < 0 ) {
            error = ERROR_SEM_TIMEOUT;
            break;
        }
    }

    if ( NO_ERROR == error ) {
        //
        // a message was received from a DHCP server.  disable IP autoconfiguration.
        //

        SERVER_REACHED(DhcpContext);
    }

    return( error );
}

//================================================================================
// end of file
//================================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\client\dhcp\mediasns.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    mediasns.c

Abstract:

    This file contains media sense code.

Author:

    Munil Shah (munils) 20-Feb-1997.

Environment:

    User Mode - Win32

Revision History:

--*/

#include "precomp.h"

DWORD
ProcessMediaConnectEvent(
    IN PDHCP_CONTEXT dhcpContext,
    IN IP_STATUS mediaStatus
)
/*++

Routine Description:
    Handle media sense disconnects and connects for the adapter.
    N.B.  The RENEW LIST lock must have been taken.

Arguments:
    dhcpContext - dhcp client context
    mediaStatus - IP_MEDIA_CONNECT or IP_MEDIA_DISCONNECT

Return Value:
    Error codes

--*/
{
    DWORD Error;
    CHAR StateStringBuffer[200];
    time_t timeNow, timeToSleep;
    DHCP_GATEWAY_STATUS GatewayStatus;

    if( IP_MEDIA_CONNECT != mediaStatus &&
        IP_BIND_ADAPTER != mediaStatus ) {
        DhcpAssert(FALSE);
        return ERROR_INVALID_PARAMETER;
    }

    timeNow = time( NULL );

    Error = ERROR_SUCCESS;
    DhcpPrint( (DEBUG_MISC,"ProcessMediaSenseEventCommon:<connect> "
                "context %lx, flags %s\n",
                dhcpContext,
                ConvertStateToString(dhcpContext, StateStringBuffer)));
    
    if( IS_DHCP_DISABLED(dhcpContext) ) {
        //
        // Nothing to do for static IP addresses..
        //
        return ERROR_SUCCESS;
    }
    
    //
    // for DHCP enabled addresses we have to do some funky stuff.
    // but only if the address was a dhcp address... If not, we just 
    // reschedule a refresh right away.
    //
    
    GatewayStatus = RefreshNotNeeded(dhcpContext);
    if (DHCP_GATEWAY_REACHABLE == GatewayStatus) {
        return ERROR_SUCCESS;
    }
    
    MEDIA_RECONNECTED( dhcpContext );
    
    //
    // Leave the ctxt marked as seen before -- thsi will avoid
    // going back to autonet.
    //
    // Actually, design changed again.  So, mark context as not
    // see before and certainly do "autonet".
    //
    CTXT_WAS_NOT_LOOKED( dhcpContext );

    if ( DhcpIsInitState( dhcpContext) ) {
        dhcpContext->RenewalFunction = ReObtainInitialParameters;
    } else {
        DhcpPrint((DEBUG_MEDIA, "Optimized Renewal for ctxt: %p\n", dhcpContext));
        dhcpContext->RenewalFunction = ReRenewParameters;
    }

    ScheduleWakeUp( dhcpContext, GatewayStatus == DHCP_GATEWAY_REQUEST_CANCELLED ? 6 : 0 );
    
    return Error;
}

//
// end of file
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\client\dhcp\dhcpinit.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    init.c

Abstract:

    This is the main routine for the DHCP client.

Author:

    Manny Weiser (mannyw)  18-Oct-1992

Environment:

    User Mode - Win32

Revision History:

--*/


#include "precomp.h"
#include "dhcpglobal.h"

#if !defined(VXD)
#include <dhcploc.h>
#endif

//*******************  Pageable Routine Declarations ****************
#if defined(CHICAGO) && defined(ALLOC_PRAGMA)
//
// This is a hack to stop compiler complaining about the routines already
// being in a segment!!!
//

#pragma code_seg()

#pragma CTEMakePageable(PAGEDHCP, DhcpInitialize )
#pragma CTEMakePageable(PAGEDHCP, CalculateTimeToSleep )
#pragma CTEMakePageable(PAGEDHCP, InitializeDhcpSocket )
//*******************************************************************
#endif CHICAGO && ALLOC_PRAGMA

//
// Internal function prototypes
//


DWORD
DhcpInitialize(
    LPDWORD SleepTime
    )
/*++

Routine Description:

    This function initializes DHCP.  It walks the work list looking for
    address to be acquired, or to renew.  It then links the DHCP context
    block for each card on the renewal list.

Arguments:

    None.

Return Value:

    minTimeToSleep - The time before the until DHCP must wake up to renew,
        or reattempt acquisition of an address.

    -1 - DHCP could not initialize, or no cards are configured for DHCP.

--*/
{
    DWORD Error;
    PDHCP_CONTEXT dhcpContext;

    PLIST_ENTRY listEntry;

    DWORD minTimeToSleep = (DWORD)-1;
    DWORD timeToSleep;

    //
    // Perform Global (common) variables initialization.
    //

    DhcpGlobalProtocolFailed = FALSE;

    //
    // Perform local initialization
    //

    Error = SystemInitialize();
    if ( Error != ERROR_SUCCESS ) {
        minTimeToSleep = (DWORD)-1;
        goto Cleanup;
    }

    minTimeToSleep = 1;

    Error = ERROR_SUCCESS;

Cleanup:

    if( SleepTime != NULL ) {
        *SleepTime = minTimeToSleep;
    }

    return( Error );
}



DWORD
CalculateTimeToSleep(
    PDHCP_CONTEXT DhcpContext
    )
/*++

Routine Description:

    Calculate the amount of time to wait before sending a renewal,
    or new address request.

    Algorithm:

        //
        // ?? check retry times.
        //

        If Current-Ip-Address == 0
            TimeToSleep = ADDRESS_ALLOCATION_RETRY
            UseBroadcast = TRUE
        else if the lease is permanent
            TimeToSleep = INFINIT_LEASE
            UseBroadcast = TRUE
        else if the time now is < T1 time
            TimeToSleep = T1 - Now
            UseBroadcast = FALSE
        else  if the time now is < T2 time
            TimeToSleep = Min( 1/8 lease time, MIN_RETRY_TIME );
            UseBroadcast = FALSE
        else if the time now is < LeaseExpire
            TimeToSleep = Min( 1/8 lease time, MIN_RETRY_TIME );
            UseBroadcast = TRUE


Arguments:

    RenewalContext - A pointer to a renewal context.

Return Value:

    TimeToSleep - Returns the time to wait before sending the next
        DHCP request.

    This routine sets DhcpContext->DhcpServer to -1 if a broadcast
    should be used.

--*/
{
    time_t TimeNow;

    //
    // if there is no lease.
    //

    if ( DhcpContext->IpAddress == 0 ) {

        // DhcpContext->DhcpServerAddress = (DHCP_IP_ADDRESS)-1;
        return( ADDRESS_ALLOCATION_RETRY );
    }

    //
    // if the lease is permanent.
    //

    if ( DhcpContext->Lease == INFINIT_LEASE ) {

        return( (DWORD) INFINIT_TIME );
    }

    TimeNow = time( NULL );

    //
    // if the time is < T1
    //

    if( TimeNow < DhcpContext->T1Time ) {
        return ( (DWORD)(DhcpContext->T1Time - TimeNow) );
    }

    //
    // if the time is between T1 and T2.
    //

    if( TimeNow < DhcpContext->T2Time ) {
        time_t  TimeDiff;

        //
        // wait half of the ramaining time but minimum of
        // MIN_TIME_SLEEP secs.
        //

        TimeDiff = ( MAX( ((DhcpContext->T2Time - TimeNow) / 2),
                        MIN_SLEEP_TIME ) );

        if( TimeNow + TimeDiff < DhcpContext->T2Time ) {
            return (DWORD)(TimeDiff);
        } else {
            // time is actually going past T2? then re-schedule for T2

            return (DWORD)(DhcpContext->T2Time - TimeNow);
        }
    }

    //
    // if the time is between T2 and LeaseExpire.
    //

    if( TimeNow < DhcpContext->LeaseExpires ) {
        time_t TimeDiff;

        DhcpContext->DhcpServerAddress = (DHCP_IP_ADDRESS)-1;

        //
        // wait half of the ramaining time but minimum of
        // MIN_SLEEP_TIME secs.
        //

        TimeDiff = MAX( ((DhcpContext->LeaseExpires - TimeNow) / 2),
                        MIN_SLEEP_TIME ) ;

        if( TimeDiff + TimeNow < DhcpContext->LeaseExpires ) {
            return (DWORD)(TimeDiff);
        } else {
            //
            // time has gone past the expiry time? re-start
            // immediately

            return 0;
        }
    }

    //
    // Lease has Expired. re-start immediately.
    //

    // DhcpContext->IpAddress = 0;
    return( 0 );
}


DWORD
InitializeDhcpSocket(
    SOCKET *Socket,
    DHCP_IP_ADDRESS IpAddress,
    BOOL  IsApiCall  // is it related to an API generated context?
    )
/*++

Routine Description:

    This function initializes and binds a socket to the specified IP address.

Arguments:

    Socket - Returns a pointer to the initialized socket.

    IpAddress - The IP address to bind the socket to.  It is legitimate
        to bind a socket to 0.0.0.0 if the card has no current IP address.

Return Value:

    The status of the operation.

--*/
{
    DWORD error;
    DWORD closeError;
    DWORD value, buflen = 0;
    struct sockaddr_in socketName;
    DWORD i;
    SOCKET sock;

    //
    // Sockets initialization
    //

    sock = socket( PF_INET, SOCK_DGRAM, IPPROTO_UDP );

    if ( sock == INVALID_SOCKET ) {
        error = WSAGetLastError();
        DhcpPrint(( DEBUG_ERRORS, "socket failed, error = %ld\n", error ));
        return( error );
    }

    //
    // Make the socket share-able
    //

    value = 1;

    error = setsockopt( sock, SOL_SOCKET, SO_REUSEADDR, (char FAR *)&value, sizeof(value) );
    if ( error != 0 ) {
        error = WSAGetLastError();
        DhcpPrint((DEBUG_ERRORS, "setsockopt failed, err = %ld\n", error ));

        closeError = closesocket( sock );
        if ( closeError != 0 ) {
            DhcpPrint((DEBUG_ERRORS, "closesocket failed, err = %d\n", closeError ));
        }
        return( error );
    }

#ifndef VXD
    value = 1;
    WSAIoctl(
        sock, SIO_LIMIT_BROADCASTS, &value, sizeof(value),
        NULL, 0, &buflen, NULL, NULL
        );
    value = 1;
#endif VXD
    
    error = setsockopt( sock, SOL_SOCKET, SO_BROADCAST, (char FAR *)&value, sizeof(value) );
    if ( error != 0 ) {
        error = WSAGetLastError();
        DhcpPrint((DEBUG_ERRORS, "setsockopt failed, err = %ld\n", error ));

        closeError = closesocket( sock );
        if ( closeError != 0 ) {
            DhcpPrint((DEBUG_ERRORS, "closesocket failed, err = %d\n", closeError ));
        }
        return( error );
    }

    //
    // If the IpAddress is zero, set the special socket option to make
    // stack work with zero address.
    //

#ifdef VXD
    if( IpAddress == 0 ) {
#else

    //
    // On NT system, set this special option only if the routine is
    // called from service.
    //

    if( (IpAddress == 0 ) && !IsApiCall ) {

#endif
        value = 1234;
        error = setsockopt( sock, SOL_SOCKET, 0x8000, (char FAR *)&value, sizeof(value) );
        if ( error != 0 ) {
            error = WSAGetLastError();
            DhcpPrint((DEBUG_ERRORS, "setsockopt failed, err = %ld\n", error ));

            closeError = closesocket( sock );
            if ( closeError != 0 ) {
                DhcpPrint((DEBUG_ERRORS, "closesocket failed, err = %d\n", closeError ));
            }
            return( error );
        }
    }

    socketName.sin_family = PF_INET;
    socketName.sin_port = htons( (USHORT)DhcpGlobalClientPort );
    socketName.sin_addr.s_addr = IpAddress;

    for ( i = 0; i < 8 ; i++ ) {
        socketName.sin_zero[i] = 0;
    }

    //
    // Bind this socket to the DHCP server port
    //

    error = bind(
               sock,
               (struct sockaddr FAR *)&socketName,
               sizeof( socketName )
               );

    if ( error != 0 ) {
        error = WSAGetLastError();
        DhcpPrint((DEBUG_ERRORS, "bind failed (address 0x%lx), err = %ld\n", IpAddress, error ));
        closeError = closesocket( sock );
        if ( closeError != 0 ) {
            DhcpPrint((DEBUG_ERRORS, "closesocket failed, err = %d\n", closeError ));
        }
        return( error );
    }

    *Socket = sock;
    return( NO_ERROR );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\client\dhcp\dyndns.c ===
/*++

Copyright 1997 Microsoft Corporation

Module Name:
    dyndns.c

Abstract:
    Implements some core dynamic DNS routines.

Environment:
    Win32 NT.

--*/
#include "precomp.h"
#include <dhcploc.h>
#include <dhcppro.h>
#include <dnsapi.h>

#define MAX_DOM_NAME_LEN                     260

#define OPTION_DYNDNS_FLAGS_REGULAR          0
#define OPTION_DYNDNS_FLAGS_CLIENT_NOFQDN    1
#define OPTION_DYNDNS_FLAGS_SERVER_DOES_FQDN 3
typedef enum {
    DNS_REGISTER_BOTH = 0,                  // Register both AdapterSpecificDomainName and PrimaryDomainName
    DNS_REGISTER_PRIMARY_ONLY
} DNS_REG_TYPE;

#define WAIT_FOR_DNS_TIME                    4000

//
// Local functions...
//
DWORD
GetPerAdapterRegConfig(
    IN      HKEY    hAdapterKey,
    IN      LPCWSTR adapterName,
    OUT     BOOL    *fenabled,
    OUT     LPWSTR  domainName,
    IN OUT  DWORD   *size
    );

//
// DynDNS Client implementation.
//

BYTE
DhcpDynDnsGetDynDNSOptionFlags(
    IN BOOL fGlobalDynDnsEnabled
    )
/*++

Routine Description:
    This routine returns the FLAGS value to use for the DynDns
    DHCP option.

    The choice is made using the simple algorithm that if
    Dynamic DNS is disabled globally, then this option would be
        OPTION_DYNDNS_FLAGS_CLIENT_NOFQDN
    else it would just be OPTION_DYNDNS_FLAGS_REGULAR.

Arguments:
    fGlobalDynDnsEnabled -- Is Dynamic DNS enabled as a whole?

Return Values:
    OPTION_DYNDNS_FLAGS_CLIENT_NOFQDN or
    OPTION_DYNDNS_FLAGS_REGULAR

--*/
{
    BYTE fRetVal;

    if( fGlobalDynDnsEnabled ) {
        fRetVal = (BYTE)(OPTION_DYNDNS_FLAGS_REGULAR);
    } else {
        fRetVal = (BYTE)(OPTION_DYNDNS_FLAGS_CLIENT_NOFQDN);
    }

    return fRetVal;
}

ULONG
DhcpDynDnsGetDynDNSOptionDomainOem(
    IN OUT BYTE *DomainNameBuf,
    IN OUT ULONG *DomainNameBufSize,
    IN HKEY hAdapterKey,
    IN LPCWSTR AdapterName,
    IN LPCSTR DhcpOfferedDomainName,
    IN ULONG DhcpOfferedDomainNameSize
    )
/*++

Routine Description:

    See DHCPDynDns.htm for design on choosing the adapter name.

    1.  If per-Adapter registration is disabled, the domain name
        would always be primary domain name if it exists.

    2.  If per-Adapter registration is enabled:
        2.1 If a static domain name is configured, then static
            domain name is preferred.
        2.2 Else DhcpOfferedDomainName is used if present
        2.3 Else primary domain name is used if it exists

Arguments:

    DomainNameBuf -- buffer to fill in (won't be NUL terminated)
    DomainNameBufSize -- on i/p input buf size, on o/p filled bufsize
    hAdapterKey -- key to tcpip adapter device
        (tcpip\parameters\interfaces\adaptername)
    AdapterName -- name of adapter for which this is being sought.
    DhcpOfferedDomainName -- Domain name as provided in DHCP
        Offer or last ACK.
    DhcpOfferedDomainNameSize -- size of above in bytes.
   
Return Values:
    ERROR_SUCCESS if a domain name was found.
    ERROR_CAN_NOT_COMPLETE if no domain name was found.
    ERROR_INSUFFICIENT_BUFFER if DomainNameBuf is of insufficient
        size. (required buf size is not returned).
    ERROR_INVALID_DATA if cannot convert from OEM to UNICODE etc
    
--*/
{
    WCHAR StaticAdapterName[MAX_DOM_NAME_LEN] = {0};
    BOOL fPerAdapterRegEnabled, fChoseStatic, fChoseDhcp;  
    ULONG Error;
    DWORD   Size;

    fChoseStatic = fChoseDhcp = FALSE;

    Size = sizeof(StaticAdapterName);

    Error = GetPerAdapterRegConfig(hAdapterKey,
                                   AdapterName, 
                                   &fPerAdapterRegEnabled,
                                   StaticAdapterName, 
                                   (LPDWORD)&Size);

    if (fPerAdapterRegEnabled) {
        if( ERROR_SUCCESS == Error) {
            fChoseStatic = TRUE;
        } else if( DhcpOfferedDomainName != NULL &&
                   *DhcpOfferedDomainName != '\0' ) {
            fChoseDhcp = TRUE;
        }
    }

    ASSERT( !( fChoseDhcp && fChoseStatic) );

    Error = NO_ERROR;

    if( fChoseDhcp ) {
        //
        // If using dhcp, check size and copy over.
        //
        if( DhcpOfferedDomainNameSize > (*DomainNameBufSize) ) {
            Error = ERROR_INSUFFICIENT_BUFFER;
        } else {
            (*DomainNameBufSize) = DhcpOfferedDomainNameSize;
            RtlCopyMemory(
                DomainNameBuf, DhcpOfferedDomainName,
                DhcpOfferedDomainNameSize
                );
        }
    } else if( !fChoseStatic ) {
        ULONG Size;
        //
        // If using primary domain name obtain domain name via
        // GetComputerNameEx.
        //

        Size = sizeof(StaticAdapterName)/sizeof(WCHAR);
        Error = GetComputerNameExW(
            ComputerNameDnsDomain,
            (PVOID)StaticAdapterName,
            &Size
            );
        if( FALSE == Error ) {
            //
            // could not get global primary domain name>?
            //
            DhcpPrint((
                DEBUG_DNS, "GetComputerName(Domain):%lx\n",
                GetLastError()
                ));
                       
            Error = ERROR_CAN_NOT_COMPLETE;
        } else {

            //
            // Now fake the static case to cause conversion
            //
            fChoseStatic = TRUE;
        }
    }

    if( fChoseStatic ) {
        UNICODE_STRING Uni;
        OEM_STRING Oem;
        
        //
        // if using static, need to convert WCHAR to OEM.
        //
        RtlInitUnicodeString(&Uni, StaticAdapterName);
        Oem.Buffer = DomainNameBuf;
        Oem.MaximumLength = (USHORT) *DomainNameBufSize;

        Error = RtlUnicodeStringToOemString(&Oem, &Uni, FALSE);
        if( !NT_SUCCESS(Error) ) {
            //
            // Could not convert string? 
            //
            Error = ERROR_INVALID_DATA;
        } else {
            *DomainNameBufSize = strlen(DomainNameBuf);
        }
    }
    
    return Error;
}

ULONG
DhcpDynDnsGetDynDNSOption(
    IN OUT BYTE *OptBuf,
    IN OUT ULONG *OptBufSize,
    IN HKEY hAdapterKey,
    IN LPCWSTR AdapterName,
    IN BOOL fEnabled,
    IN LPCSTR DhcpDomainOption,
    IN ULONG DhcpDomainOptionSize
    )
/*++

Routine Description:
    This routine fills the DynDNS option as per
    draft-ietf-dhc-dhcp-dns-08.txt based on the parameters.

    The format is:
    BYTE Flags, BYTE RCODE1 BYTE RCODE2 FQDN
    
    N.B.  The FQDN option is not NUL terminated.

Arguments:

    OptBuf -- the buffer to fill with option 81.
    OptBufSize -- size of buffer to fill
    hAdapterKey -- adapter info key
    AdapterName -- name of adapter.
    fEnabled -- is global dyndns enabled?
    DhcpDomainOption -- domain name option offered by dhcp server
    DhcpDomainOptionSize -- domain name option size excluding any
       terminating NUL

Return Values:
    NO_ERROR if the option has been successfully formatted.
    Win32 error if option could not be formatted.

--*/
{
    BYTE *FQDN;
    ULONG Error, FQDNSize, Size;
    WCHAR DnsNameBuf[MAX_DOM_NAME_LEN];
    UNICODE_STRING Uni;
    OEM_STRING Oem;
    
    //
    // Prerequisite is a buffer size of atleast 4 bytes.
    //
    
    FQDNSize = (*OptBufSize);
    if( FQDNSize < sizeof(BYTE)*4 ) {
        return ERROR_INSUFFICIENT_BUFFER;
    }
    FQDNSize -= 3;

    //
    // Fill in FLAGS field. RCODE1 and RCODE2 MUST be zero.
    //
    OptBuf[0] = DhcpDynDnsGetDynDNSOptionFlags(
        fEnabled
        );
    OptBuf[1] = OptBuf[2] = 0;

    FQDN = &OptBuf[3];
    (*OptBufSize) = 3;

    //
    //  Check if DNS registration is enabled
    //      - if enabled globally, check this adapter
    //      - if not check global setting
    //

    if ( ! (BOOL) DnsQueryConfigDword(
                    DnsConfigRegistrationEnabled,
                    fEnabled
                        ? (LPWSTR)AdapterName
                        : NULL ) ) {
        //
        // Act like down level client
        //
        return ERROR_CAN_NOT_COMPLETE;
    }
    
    //
    // Fill in Host Name now from GetComputerNameEx.
    //
    Size = sizeof(DnsNameBuf)/sizeof(DnsNameBuf[0]);
    Error = GetComputerNameExW(
        ComputerNameDnsHostname,
        (PVOID)DnsNameBuf,
        &Size
        );
    if( NO_ERROR == Error ) {
        //
        // If no host name, no option can be set!
        //
        return Error;
    }

    //
    // Convert Unicode hostname to OEM.
    //
    RtlInitUnicodeString(&Uni, DnsNameBuf);
    Oem.Buffer = FQDN;
    Oem.MaximumLength = (USHORT)FQDNSize;

    Error = RtlUnicodeStringToOemString(&Oem, &Uni, FALSE);
    if( !NT_SUCCESS(Error) ) {
        //
        // Couldn't convert host name to OEM?
        //
        return ERROR_INVALID_DATA;
    }

    //
    // Now try to get the domain name, if any.
    //
    (*OptBufSize) += strlen(FQDN);
    Size = FQDNSize - strlen(FQDN) - 1;
    FQDN += strlen(FQDN);
    Error = DhcpDynDnsGetDynDNSOptionDomainOem(
        FQDN+1, /* allow for space for the '.' */
        &Size,
        hAdapterKey,
        AdapterName,
        DhcpDomainOption,
        DhcpDomainOptionSize
        );
    if( NO_ERROR != Error ) {
        //
        // Could not get the domain name? return error? no ignore
        // the domain name and just return host name.
        //
        DhcpPrint((
            DEBUG_DNS,
            "DhcpDynDnsGetDynDNSOptionDomainOem:0x%lx\n", Error
            ));
                   
        return NO_ERROR;
    }

    //
    // Now add the '.' and update size accordingly.
    //
    (*FQDN) = '.';

    (*OptBufSize) += 1 + Size;
    return NO_ERROR;
}


    
PREGISTER_HOST_ENTRY
DhcpCreateHostEntries(
    IN PIP_ADDRESS Addresses,
    IN DWORD nAddr
)
{
    PREGISTER_HOST_ENTRY RetVal;
    DWORD i;

    if( 0 == nAddr ) return NULL;

    RetVal = DhcpAllocateMemory(sizeof(*RetVal)*nAddr);
    if( NULL == RetVal ) {
        return NULL;
    }

    for( i = 0; i < nAddr ; i ++ ) {
        RetVal[i].dwOptions = REGISTER_HOST_A | REGISTER_HOST_PTR;
        RetVal[i].Addr.ipAddr = Addresses[i];
    }

    return RetVal;
}

REGISTER_HOST_STATUS DhcpGlobalHostStatus;
ULONG
DhcpDynDnsDeregisterAdapter(
    IN HKEY hAdapterKey,
    IN LPCWSTR AdapterName,
    IN BOOL fRAS,
    IN BOOL fDynDnsEnabled
    )
/*++

Routine Description:
    This routine performs DynDNS name deletions.

Arguments:
    hAdapterKey -- adapter key for which name deletions should
       happen.
    AdapterName -- name of adapter.
    fRAS -- Is this RAS or DHCP adapter?
    fDynDnsEnabled -- is Dynamic DNS enabled globally?

Return Values:
    DNS API error codes.

--*/
{
    ULONG Error;
    BOOLEAN PassStatus;
    
    DhcpPrint((
        DEBUG_DNS, "Deregistering Adapter: %ws\n", AdapterName
        ));
    DhcpPrint((
        DEBUG_DNS, "fRAS: %ld, fDynDnsEnabled: %ld\n", fRAS,
        fDynDnsEnabled
        ));

    PassStatus = FALSE;
    if( fDynDnsEnabled ) {
        if (NULL != DhcpGlobalHostStatus.hDoneEvent) {
            ResetEvent(DhcpGlobalHostStatus.hDoneEvent);
            PassStatus = TRUE;
        }
    }
        
    Error = DnsAsyncRegisterHostAddrs_W(
        fDynDnsEnabled ? ((LPWSTR)AdapterName) : NULL,
        NULL, NULL, 0, NULL, 0, NULL,
        PassStatus ? (&DhcpGlobalHostStatus): NULL,
        0, DYNDNS_DEL_ENTRY
        );

    if( ERROR_SUCCESS != Error ) {
        DhcpPrint((
            DEBUG_DNS, "DnsAsyncRegisterHostAddrs_W:0x%lx\n",
            Error
            ));
    } else if ( PassStatus && DhcpGlobalHostStatus.hDoneEvent
                && !fRAS) {
        switch(WaitForSingleObject(DhcpGlobalHostStatus.hDoneEvent, WAIT_FOR_DNS_TIME)) {
        case WAIT_ABANDONED:
        case WAIT_FAILED:
            Error = GetLastError();
            DhcpPrint((
                DEBUG_DNS, "Wait failed: 0x%lx\n", Error
                ));
            break;
        case WAIT_TIMEOUT:
            DhcpPrint((
                DEBUG_DNS, "DNS de-reg timed out..\n"
                ));
            Error = NO_ERROR;
            break;
        default:
            Error = NO_ERROR;
            break;
        }
    }

    /*
     * In case that dhcp client initialization fails
     */
    if (!PassStatus && fDynDnsEnabled && !fRAS) {
        Sleep(1000);
    }
    
    return Error;
}

LPWSTR _inline
x_wcschr(
    IN LPWSTR Str,
    IN LPWSTR Separation
)
{
    while( *Str ) {
        if( wcschr(Separation, *Str) ) return Str;
        Str ++;
    }
    return NULL;
}

PIP_ADDRESS
DhcpCreateListFromStringAndFree(
    IN LPWSTR Str,
    IN LPWSTR Separation,
    OUT LPDWORD nAddresses
    )
{
    DWORD                i;
    DWORD                count;
    DWORD                RetCount;
    PIP_ADDRESS          RetVal;
    LPWSTR               tmp;

    *nAddresses = 0;                              // initialize to 0, so if things go wrong...
    if( NULL == Str ) return NULL;                // nothing to do

    tmp = Str;
    if( NULL != Separation ) {                    // If '\0' is not the separation there is only one string in Str
        count = wcslen(tmp) ? 1 : 0;              // count the first string in line, as the wcschr may fail firsttime
        while( x_wcschr(tmp, Separation ) ) {     // keep looking for the reqd separation character
            tmp = x_wcschr(tmp, Separation);
            *tmp ++ = '\0';                       // now mark it as NULL so that the string LOOKS like REG_MULTI_SZ
            count ++;                             // and keep track so that we dont have to do this again
        }
    }

    if( NULL == Separation ) {                    // if '\0' is the separator, it is already a REG_MULTI_SZ
        count = 0;
        while( wcslen(tmp) ) {                    // still we need to get count of # of strings in here
            tmp += wcslen(tmp) +1;
            count ++;                             // so just track of this so that we dont have to do this again
        }
    }

    if( 0 == count ) {                            // no element found
        DhcpFreeMemory(Str);                      // keep promise of freeing string, and then return
        return NULL;
    }

    RetVal = DhcpAllocateMemory(sizeof(IP_ADDRESS)*count);
    if( NULL == RetVal ) {                        // could not allocate memory. assume we had no i/p
        DhcpFreeMemory(Str);
        return NULL;
    }

    tmp = Str; RetCount = 0;                      // now convert each address using inet_addr
    for( i = 0 ; i < count ; (tmp += wcslen(tmp)+1), i ++ ) {
        CHAR    Buffer[1000];                     // allocate on stack
        LPSTR   ipAddrString;

        ipAddrString = DhcpUnicodeToOem( tmp , Buffer);
        if( NULL == ipAddrString ) {              // convertion from unicode to ascii failed!
            DhcpPrint((DEBUG_ERRORS, "Could not convert %ws into ascii: DNS\n", tmp));
            continue;                             // if cant convert, just ignore this address
        }

        if( inet_addr(ipAddrString) )             // do not add empty strings, or 0.0.0.0
            RetVal[RetCount++] = inet_addr( ipAddrString);
    }

    if( 0 == RetCount ) {                         // ok, we ended up skipping the whole list
        DhcpFreeMemory(RetVal);
        RetVal = NULL;
    }

    DhcpFreeMemory(Str);                          // there, promises kept
    *nAddresses = RetCount;
    return RetVal;
}

ULONG
DhcpDynDnsRegisterAdapter(
    IN LPCWSTR AdapterName,
    IN PREGISTER_HOST_ENTRY pHostEntries,
    IN ULONG nHostEntries,
    IN ULONG Flags,
    IN LPCWSTR AdapterDomainName,
    IN ULONG *DNSServers,
    IN ULONG nDNSServers
    )
/*++

Routine Description:
    Wrapper around DnsAsyncRegisterHostAddrs_W.

Arguments:
    Self descriptive.
    N.B.  DNSServers MUST be DWORD aligned.

Return Values:
    DnsAsyncRegisterHostAddrs_W

--*/
{
    ULONG Error, Size;
    WCHAR HostNameBuf[MAX_DOM_NAME_LEN];

    RtlZeroMemory(HostNameBuf, sizeof(HostNameBuf));
    Size = sizeof(HostNameBuf)/sizeof(HostNameBuf[0]);
    Error = GetComputerNameExW(
        ComputerNameDnsHostname,
        (PVOID)HostNameBuf,
        &Size
        );
    if( NO_ERROR == Error ) return GetLastError();

    DhcpPrint((DEBUG_DNS, "AdapterName: %ws\n", AdapterName));
    DhcpPrint((DEBUG_DNS, "HostName   : %ws\n", HostNameBuf));
    DhcpPrint((DEBUG_DNS, "DomainName : %ws\n", (AdapterDomainName)? AdapterDomainName: L"[PrimaryOnly]"));
    DhcpPrint((DEBUG_DNS, "nHostEntr..: %d\n", nHostEntries));
    DhcpPrint((DEBUG_DNS, "nDNSServers: %d\n", nDNSServers));
    DhcpPrint((DEBUG_DNS, "Flags      : [%s%s]\n",
               (Flags & DYNDNS_REG_PTR) ? "REG_PTR " : "",
               (Flags & DYNDNS_REG_RAS) ? "REG_RAS " : ""
               ));
    Error = DnsAsyncRegisterHostAddrs_W(
        (LPWSTR)AdapterName,
        HostNameBuf,
        pHostEntries,
        nHostEntries,
        DNSServers,
        nDNSServers,
        (LPWSTR)AdapterDomainName,
        NULL,
        DHCP_DNS_TTL,
        Flags
        );

    DhcpPrint((DEBUG_DNS, "Error      : %d\n", Error));

    return Error;
}

ULONG
DhcpDynDnsRegisterAdapterCheckingForStatic(
    IN HKEY hAdapterKey,
    IN LPCWSTR AdapterName,
    IN PREGISTER_HOST_ENTRY pHostEntries,
    IN ULONG nHostEntries,
    IN ULONG Flags,
    IN PBYTE DhcpDom,
    IN ULONG DhcpDomSize,
    IN PBYTE DhcpDNSServers,
    IN ULONG DhcpDNSServersSize,
    IN DNS_REG_TYPE DnsRegType
    )
/*++

Routine Description:
    This routine registers the host entries for the given adapter
    name via DNSAPI routines.

    The Domain name presented here is used for domain name if no
    static domain is available. (See DHCPDynDns.htm for exact
    description on how this is chosen).

    If there are static DNS servers present, then the DNS servers
    are used, otherwise the parameter "DhcpDNSServers" is used
    instead.

Arguments:
    hAdapterKey -- key to adapter.
    AdapterName -- name of adapter
    pHostEntries -- list of ip addresses to register.
    nHostEntries -- size of above array.
    Flags -- registration flags.
    DhcpDom -- domain to register.
    DhcpDomSize -- size of above in bytes.
    DhcpDNSServers -- list of dns servers
    DhcpDNSServersSize -- size of above in bytes.

Return Values:
    DNSAPI errors..

--*/
{
    ULONG Error, Type, Size, nDnsServers;
    WCHAR DomainName[MAX_DOM_NAME_LEN+1];
    LPWSTR NameServerList;
    ULONG *DnsServers;
    //
    // First get Oem domain name.
    //

    Size = (sizeof(DomainName))-1;
    RtlZeroMemory(DomainName, sizeof(DomainName));
    Error = RegQueryValueExW(
        hAdapterKey,
        DHCP_DOMAINNAME_VALUE,
        0,
        &Type,
        (PVOID)DomainName,
        &Size
        );
    if( NO_ERROR == Error && REG_SZ == Type && sizeof(WCHAR) < Size){
        //
        // Obtained static domain name.
        //
    } else if( DhcpDomSize > 0 && (*DhcpDom) != '\0' ) {
        //
        // Convert Oem domain name to Unicode..
        //
        RtlZeroMemory(DomainName, sizeof(DomainName));
        Size = sizeof(DomainName)/sizeof(DomainName[0]);
        if( NULL == DhcpOemToUnicodeN(
            DhcpDom, DomainName, (USHORT)Size)) {
            DomainName[0] = L'\0';
        }
    } else {
        //
        // No domain name.
        //
        DomainName[0] = L'\0';
    }
        
    //
    // Next check for static DNS server list.
    //
    NameServerList = NULL;
    Error = GetRegistryString(
        hAdapterKey,
        DHCP_NAME_SERVER_VALUE,
        &NameServerList,
        NULL
        );
    if( NO_ERROR != Error ) NameServerList = NULL;

    nDnsServers = 0;
    DnsServers = DhcpCreateListFromStringAndFree(
        NameServerList, L" ,", &nDnsServers
        );

    //
    // if no DNS servers use DhcpDNSServersSize.
    //
    if( 0 == nDnsServers
        && 0 != (DhcpDNSServersSize/sizeof(DWORD))  ) {
        nDnsServers = DhcpDNSServersSize/ sizeof(DWORD);
        DnsServers = DhcpAllocateMemory(
            sizeof(ULONG)*nDnsServers
            );
        if( NULL == DnsServers ) nDnsServers = 0;
        else {
            RtlCopyMemory(
                DnsServers, DhcpDNSServers,
                DhcpDNSServersSize
                );
        }
    }

    //
    // Now just call DhcpDynDnsRegisterAdapter..
    //

    Error = DhcpDynDnsRegisterAdapter(
        AdapterName,
        pHostEntries,
        nHostEntries,
        Flags,
        (DnsRegType == DNS_REGISTER_BOTH)? DomainName: NULL,
        DnsServers,
        nDnsServers
        );

    if( nDnsServers ) {
        DhcpFreeMemory( DnsServers );
    }

    return Error;
}

    
ULONG
DhcpDynDnsRegisterStaticAdapter(
    IN HKEY hAdapterKey,
    IN LPCWSTR AdapterName,
    IN BOOL fRAS,
    IN BOOL fDynDnsEnabled
    )
/*++

Routine Description:
    This routine performs DynDNS name registrations for static
    adapter only.

Arguments:
    hAdapterKey -- adapter key for which name deletions should
       happen.
    AdapterName -- name of adapter.
    fRAS -- Is this RAS or DHCP adapter?
    fDynDnsEnabled -- is Dynamic DNS enabled globally?

Return Values:
    DNS API error codes.

--*/
{
    ULONG Error, Size, nIpAddresses;
    LPWSTR IpAddrString;
    ULONG *IpAddresses;
    PREGISTER_HOST_ENTRY pHostEntries;

    NotifyDnsCache();
    if( FALSE == fDynDnsEnabled ) return NO_ERROR;

    if ( ! (BOOL) DnsQueryConfigDword(
                    DnsConfigRegistrationEnabled,
                    (LPWSTR)AdapterName )) {
        //
        // If DNS registration not enabled, de-register this
        //
        return DhcpDynDnsDeregisterAdapter(
            hAdapterKey, AdapterName, fRAS, fDynDnsEnabled
            );
    }
    
    //
    // Get IP address string.
    //
    IpAddrString = NULL;
    Error = GetRegistryString(
        hAdapterKey,
        fRAS ? DHCP_IP_ADDRESS_STRING : DHCP_IPADDRESS_VALUE,
        &IpAddrString,
        NULL
        );
    if( NO_ERROR != Error ) {
        DhcpPrint((
            DEBUG_DNS, "Could not get IP address for %ws: 0x%lx\n",
            AdapterName, Error
            ));
        return Error;
    }

    IpAddresses = DhcpCreateListFromStringAndFree(
        IpAddrString, fRAS ? L" " : NULL, &nIpAddresses
        );

    if( 0 == nIpAddresses ) return ERROR_INVALID_DATA;

    //
    // Convert IP address to host entries.
    //
    pHostEntries = DhcpCreateHostEntries(
        IpAddresses, nIpAddresses
        );
    if( NULL != IpAddresses ) DhcpFreeMemory(IpAddresses);

    if( NULL == pHostEntries ) return ERROR_INVALID_DATA;

    Error = DhcpDynDnsRegisterAdapterCheckingForStatic(
        hAdapterKey,
        AdapterName,
        pHostEntries,
        nIpAddresses,
        DYNDNS_REG_PTR | (fRAS ? DYNDNS_REG_RAS : 0 ),
        NULL, 0, NULL, 0, DNS_REGISTER_BOTH
        );

    if( NULL != pHostEntries ) DhcpFreeMemory( pHostEntries );
    return Error;
}

ULONG
DhcpDynDnsRegisterDhcpOrRasAdapter(
    IN HKEY hAdapterKey,
    IN LPCWSTR AdapterName,
    IN BOOL fDynDnsEnabled,
    IN BOOL fRAS,
    IN ULONG IpAddress,
    IN LPBYTE DomOpt OPTIONAL,
    IN ULONG DomOptSize,
    IN LPBYTE DnsListOpt OPTIONAL,
    IN ULONG DnsListOptSize,
    IN LPBYTE DnsFQDNOpt,
    IN ULONG DnsFQDNOptSize
    )
/*++

Routine Description:
    This routine performs DynDNS name registrations for dhcp
    enabled adapter.

Arguments:
    hAdapterKey -- adapter key for which name deletions should
       happen.
    AdapterName -- name of adapter.
    fDynDnsEnabled -- is Dynamic DNS enabled globally?
    fRAS -- is this for RAS or for DHCP?
    IpAddress -- IP address to register.
    DomOpt -- domain name option
    DomOptSize -- size of domain name option.
    DnsListOpt -- DNS servers list option.
    DnsListOptSize -- size of above in bytes.
    DnsFQDNOpt -- dns fqdn option
    DnsFQDNOptSize -- size of above in bytes.

Return Values:
    DNS API error codes.

--*/
{
    REGISTER_HOST_ENTRY HostEntry;
    ULONG Flags;
    DNS_REG_TYPE    dnsRegType;
    BOOL            fAdapterSpecificEnabled;

    if(!fRAS)
        NotifyDnsCache();
    if( FALSE == fDynDnsEnabled ) return NO_ERROR;

    if ( ! (BOOL) DnsQueryConfigDword(
                    DnsConfigRegistrationEnabled,
                    (LPWSTR)AdapterName ) ) {
        //
        // If dyndns is not enabled for this adapter, delete entry
        //
        return DhcpDynDnsDeregisterAdapter(
            hAdapterKey, AdapterName, fRAS, fDynDnsEnabled
            );
    }
            
    //
    // For RAS, get the IP address also from registry.
    //
    if( fRAS ) {
        LPWSTR IpAddrString = NULL;
        CHAR Buf[100];
        ULONG Error;
        
        Error = GetRegistryString(
            hAdapterKey,
            DHCP_IP_ADDRESS_STRING,
            &IpAddrString,
            NULL
            );
        if( NO_ERROR != Error ) {
            DhcpPrint((
                DEBUG_DNS, "Could not get IP address for %ws: 0x%lx\n",
                AdapterName, Error
                ));
            return Error;
        }

        if( NULL == DhcpUnicodeToOem(IpAddrString, Buf) ) {
            DhcpPrint((
                DEBUG_DNS, "Could not convert [%ws] to Oem.\n",
                IpAddrString
                ));
            DhcpFreeMemory(IpAddrString);
            return ERROR_INVALID_DATA;
        }
        DhcpFreeMemory(IpAddrString);
        IpAddress = inet_addr(Buf);
    }
    
    HostEntry.dwOptions = REGISTER_HOST_A;
    if( 0 == DnsFQDNOptSize ) {
        HostEntry.dwOptions |= REGISTER_HOST_PTR;
    }
    HostEntry.Addr.ipAddr = IpAddress;

    Flags = (0 == DnsFQDNOptSize) ? DYNDNS_REG_PTR : 0;
    if( fRAS ) Flags = DYNDNS_REG_PTR | DYNDNS_REG_RAS;

    //
    // if adapter specific domain registration is also
    // enabled, then use reg_ptr also as flags
    //
    GetPerAdapterRegConfig(hAdapterKey,
                           AdapterName,
                           &fAdapterSpecificEnabled,
                           NULL,
                           NULL);

    if (fAdapterSpecificEnabled) {
        Flags |= DYNDNS_REG_PTR;
    }

    dnsRegType = DNS_REGISTER_BOTH;
    if( DnsFQDNOptSize > 0 && OPTION_DYNDNS_FLAGS_SERVER_DOES_FQDN == DnsFQDNOpt[0] ) {
        //
        // DHCP server does both A and PTR.  Just do not do any
        // registrations in this case.
        //
        if (fAdapterSpecificEnabled) {
            DhcpPrint((DEBUG_DNS, "DHCP sent FQDN option flags value: 03. "
                                "Do DynDns only for host.primary_domain, "
                                "no DynDns host.AdapterSpecifixDomain ...\n"));
            dnsRegType = DNS_REGISTER_PRIMARY_ONLY;
        } else {
            DhcpPrint((DEBUG_DNS, "DHCP sent FQDN option flags value: 03. No DynDns...\n"));
            return NO_ERROR;
        }
    }
    
    return DhcpDynDnsRegisterAdapterCheckingForStatic(
        hAdapterKey,
        AdapterName,
        &HostEntry,
        1,
        Flags,
        DomOpt, DomOptSize,
        DnsListOpt, DnsListOptSize, dnsRegType
        );
}

DWORD
NotifyDnsCache(
    VOID
)
{
    //
    //  ping DNS resolver cache telling it we've changed
    //  the IP configuration
    //

    DnsNotifyResolver(
        0,      // no flag
        NULL        // reserved
    );
    return ERROR_SUCCESS;
}

DWORD
GetPerAdapterRegConfig(
    IN      HKEY    hAdapterKey,
    IN      LPCWSTR adapterName,
    OUT     BOOL    *fenabled,
    OUT     LPWSTR  domainName,
    IN OUT  DWORD   *size
    )
{
    DWORD   dwEnabled = 0;
    HKEY    hKeyPolicy = NULL;
    LONG    Error = ERROR_SUCCESS;
    BOOL    fQueryName;

    //
    // Currently DNS does not check the policy setting if a specific adapter
    // is asked for.  We will work around this by checking the DNS policy 
    // registry location ourselves.  This is a hack as the check should be 
    // done by DNS.  We are unable to get any traction with the DNS folks
    // so I'm going to do it this way for now.
    //

    fQueryName = (domainName != NULL && size != NULL);

    do {
        DWORD   ReadSize;

        // Check the policy
        //

        ReadSize = sizeof(dwEnabled);

        Error = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                             DNS_POLICY_KEY,
                             0,
                             KEY_READ,
                             &hKeyPolicy);

        if (Error == ERROR_SUCCESS) {

            Error = RegQueryValueEx(hKeyPolicy,
                                    REGISTER_ADAPTER_NAME,
                                    NULL,
                                    NULL,
                                    (LPBYTE)&dwEnabled,
                                    &ReadSize);

            if (Error == ERROR_SUCCESS) {
                break;
            }
        }

        //
        // We did not find all that we needed in the policy section
        // so try the per adapter setting from tcp/ip
        //
        dwEnabled = DnsQueryConfigDword(
            DnsConfigAdapterHostNameRegistrationEnabled,
            (LPWSTR)adapterName);

    } while (FALSE);

    if (dwEnabled == 1 && fQueryName) {

        // First try to read the name from the policy section.  If it is not
        // there then try to read it from the per adapter section.

        Error = RegQueryValueExW(hKeyPolicy,
                                 ADAPTER_DOMAIN_NAME,
                                 NULL,
                                 NULL,
                                 (PVOID)domainName,
                                 size);

        if (Error != ERROR_SUCCESS) {

            Error = RegQueryValueExW(hAdapterKey,
                                     DHCP_DOMAINNAME_VALUE,
                                     NULL,
                                     NULL,
                                     (PVOID)domainName,
                                     size);
        }
    }

    if (hKeyPolicy != NULL) {
        RegCloseKey(hKeyPolicy);
    }

    //
    // Check for a NULL domain name
    //
    if (fQueryName 
        && Error == ERROR_SUCCESS
        &&  *domainName == L'\0') {
        Error = ERROR_CANTREAD;
    }

    *fenabled = (BOOL)dwEnabled;

    return (Error);
}

//================================================================================
// end of file
//================================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\client\dhcp\apistub.c ===
/*++

Copyright (C) Microsoft Corporation 1997

Module Name:
    apistub.c

Abstract:
    Routines that help marshal/unmarshal API arguments etc.

--*/

#include "precomp.h"
#include "dhcpglobal.h"
#include <apiargs.h>
#include <lmcons.h>
#include <dhcploc.h>
#include <dhcppro.h>
#include <apistub.h>
#include <stack.h>
#include <apiimpl.h>
#include <dnsapi.h>

typedef
DWORD (*PDHCP_ARGUMENTED_FUNC)(
    IN OUT PDHCP_CONTEXT AdapterName,
    IN PDHCP_API_ARGS Args,
    IN DWORD nArgs,
    IN OUT LPBYTE OutBuf,
    IN OUT LPDWORD OutBufSize
);


DWORD
DhcpApiProcessArgumentedCalls(
    IN LPBYTE AdapterName,
    IN DWORD Size,
    IN BYTE OpCode,
    IN PDHCP_API_ARGS Args,
    IN DWORD nArgs,
    IN OUT LPBYTE Buf,
    IN OUT LPDWORD BufSize
)
/*++

Routine Description:

    This routine processes calls that take arguments other than just
    the adapter name.

    N.B. This dispatches the correct routine, but makes sure both the
    context semaphore is taken for the appropriate context, as well as
    the global renewl list critical section.
    
Arguments:

    AdapterName -- name of the adapter (actually widestring)
    Size -- number of bytes of above
    OpCode -- operation to perform
    Args -- buffer of arguments for this operation
    nArgs -- size of above array
    Buf -- output buffer to hold output information
    BufSize -- on input the size of buffer available.
        On output, size of buffer required or used up.

Return Values:
    ERROR_INVALID_PARAMETER if some argument is not present or is in
    correct.
    ERROR_FILE_NOT_FOUND if the adapter in question is not found.
    Other errors returned by routines that were dispatched.

--*/
{
    LPWSTR AdapterNameW;
    WCHAR StaticName[PATHLEN];
    PDHCP_CONTEXT DhcpContext;
    PDHCP_ARGUMENTED_FUNC DispatchFunc;
    HANDLE Handle;
    DWORD Error, StartBufSize;
    BOOL BoolError;

    StartBufSize = *BufSize;
    *BufSize = 0;

    switch(OpCode) {
        
    case RequestParamsOpCode:
        DispatchFunc = RequestParams;
        break;
        
    case PersistentRequestParamsOpCode:
        DispatchFunc = PersistentRequestParams;
        break;
        
    case RegisterParamsOpCode:
        break;
        
    case DeRegisterParamsOpCode:
        break;
        
    default:
        return ERROR_INVALID_PARAMETER;
    }

    if( 0 == Size ) {
        if( RequestParamsOpCode == OpCode
            || PersistentRequestParamsOpCode == OpCode ) {

            //
            // Both these routines take require additional params.
            //

            return ERROR_INVALID_PARAMETER;
        }
        
        AdapterNameW = NULL;
        
    } else {
        
        if( Size % sizeof(WCHAR) ) {
            //
            // Size must be multiple of WCHAR ..
            //
            return ERROR_INVALID_PARAMETER;
        }

        if (Size > sizeof(WCHAR) * PATHLEN) {
            return ERROR_INVALID_PARAMETER;
        }

        memcpy(StaticName, AdapterName, Size);
        Size /= sizeof(WCHAR);
        
        if( L'\0' != StaticName[Size-1] ) {
            //
            // Adapter Name must be NULL terminated.
            //
            return ERROR_INVALID_PARAMETER;
        }
        
        AdapterNameW = StaticName;
    }

    if( RegisterParamsOpCode == OpCode ||
        DeRegisterParamsOpCode == OpCode ) {

        //
        // These two do not have anything to do with existing
        // dhcpcontexts..
        //
            
        return (
            ((RegisterParamsOpCode == OpCode)? RegisterParams:DeRegisterParams) ( 
                AdapterNameW, Args, nArgs
                ));
    }

    //
    // Find the context corresponding to this adapter.  If found bump
    // up refcount while global list is locked.
    //
    
    LOCK_RENEW_LIST();
    DhcpContext = FindDhcpContextOnNicList(
        StaticName, INVALID_INTERFACE_CONTEXT
        );
    if( DhcpContext ) {
        Handle = DhcpContext->RenewHandle;
        InterlockedIncrement(&DhcpContext->RefCount);
    }
    UNLOCK_RENEW_LIST();

    if( NULL == DhcpContext ) {
        //
        // If no context is known, then can't process API
        //
        return ERROR_FILE_NOT_FOUND;
    }

    //
    // Acquire context semaphore first
    //
                                  
    DhcpAssert(NULL != Handle);
    Error = WaitForSingleObject(Handle, INFINITE);
    if( WAIT_OBJECT_0 == Error ) {
        if( DhcpContext->RefCount > 1 ) {
            //
            // If RefCount == 1 then, this is the only reference
            // to the context. As good as context not being present.
            // So, not to do anything on it.
            //

            *BufSize = StartBufSize;
            LOCK_RENEW_LIST();

            //
            // Dispatch the routine
            //
            
            Error = DispatchFunc(
                DhcpContext, Args, nArgs, Buf, BufSize
                );
            
            UNLOCK_RENEW_LIST();

        } else {

            //
            // Last reference.  Might as well fail now.
            //
            
            DhcpAssert(IsListEmpty(&DhcpContext->NicListEntry));
            Error = ERROR_FILE_NOT_FOUND;
        }

        //
        // Release semaphore.
        //
                                            
        BoolError = ReleaseSemaphore(Handle, 1, NULL);
        DhcpAssert(FALSE != BoolError);
    } else {

        //
        // Wait shouldn't fail!
        //
        
        Error = GetLastError();
        DhcpAssert(FALSE);
        DhcpPrint((
            DEBUG_ERRORS, "ProcessArgumentedCalls:Wait:0x%lx\n",
            Error));
    }

    if( 0 == InterlockedDecrement( &DhcpContext->RefCount ) ) {
        //
        // The last reference vanished?
        //
        DhcpDestroyContext(DhcpContext);
    }

    return Error;
}

typedef
DWORD (*PDHCP_ADAPTER_ONLY_API)(
    IN OUT PDHCP_CONTEXT DhcpContext
    );

DWORD
DhcpApiProcessAdapterOnlyApi(
    IN LPBYTE AdapterName,
    IN DWORD Size,
    IN PDHCP_ADAPTER_ONLY_API AdapterOnlyApi,
    IN ULONG Code
)
/*++

Routine Description:

    This routine processes APIs that take as parameter only the
    adapter context and no other params.

    N.B.  The API is called with both semaphore and renew_list locks
    taken.

Arguments:

    AdapterName -- name of adapter (acutally LPWSTR)
    Size -- size of above in bytes
    AdapterOnlyApi -- the API to call
    Code -- operation code

Return Values:

    ERROR_INVALID_PARAMETER if adapter name is invalid size
    ERROR_FILE_NOT_FOUND if no context was found for the adapter.
    Other API errors

--*/
{
    WCHAR StaticName[PATHLEN];
    PDHCP_CONTEXT DhcpContext = NULL;
    DWORD Error;
    BOOL BoolError;
    BOOL bCancelOngoingRequest;

    bCancelOngoingRequest = FALSE;
    if (AcquireParameters == AdapterOnlyApi ||
        AcquireParametersByBroadcast == AdapterOnlyApi ||
        ReleaseParameters == AdapterOnlyApi ||
        StaticRefreshParams == AdapterOnlyApi) {
        bCancelOngoingRequest = TRUE;
    }

    if( Size % sizeof(WCHAR) ) {

        return ERROR_INVALID_PARAMETER;
    }
    
    memcpy(StaticName, AdapterName, Size);
    Size /= sizeof(WCHAR);

    if( Size == 0 ||
        L'\0' != StaticName[Size-1] ) {
        
        return ERROR_INVALID_PARAMETER;
    }

    LOCK_RENEW_LIST();
    DhcpContext = FindDhcpContextOnNicList(
        StaticName, INVALID_INTERFACE_CONTEXT
        );
    if( DhcpContext ) {

        //
        // Bump up refcount to keep context alive
        //

        InterlockedIncrement(&DhcpContext->RefCount);
    }
    UNLOCK_RENEW_LIST();

    if( NULL == DhcpContext ) {

        //
        // If no context, err out
        //
        
        return ERROR_FILE_NOT_FOUND;
    }

    //
    // Acquire the semaphore and dispatch
    //
   
    Error = LockDhcpContext(DhcpContext, bCancelOngoingRequest);
    if( WAIT_OBJECT_0 == Error ) {
        if( DhcpContext->RefCount > 1 ) {

            //
            // If RefCount == 1 then, this is the only reference
            // to the context. As good as context not being present.
            // So, not to do anything on it.
            //
            
            LOCK_RENEW_LIST();
            if( StaticRefreshParams != AdapterOnlyApi ) {
                Error = AdapterOnlyApi(DhcpContext);
            } else {
                Error = StaticRefreshParamsEx(DhcpContext, Code );
                
                if(     (NULL != DhcpContext)
                    &&  NdisWanAdapter(DhcpContext))
                    (void) NotifyDnsCache();
            }
            UNLOCK_RENEW_LIST();

        } else {
            
            DhcpAssert(IsListEmpty(&DhcpContext->NicListEntry));
            Error = ERROR_FILE_NOT_FOUND;

        }
        BoolError = UnlockDhcpContext(DhcpContext);
        DhcpAssert(FALSE != BoolError);

    } else {

        //
        // Wait is not supposed to fail.
        //
        
        Error = GetLastError();
        DhcpAssert(FALSE);
        DhcpPrint((DEBUG_ERRORS, "ApiProcessAdapterOnlyApi:"
                   "Wait:0x%lx\n",Error));
    }

    if( 0 == InterlockedDecrement( &DhcpContext->RefCount ) ) {

        //
        // The last reference vanished?
        //
        
        DhcpDestroyContext(DhcpContext);
    }
    
    return Error;
}

DWORD
DhcpApiProcessBuffer(
    IN LPBYTE InBuffer,
    IN DWORD InBufSize,
    IN OUT LPBYTE OutBuffer,
    IN OUT LPDWORD OutBufSize
)
/*++

Routine Description:

    This routine picks the input buffer, parses the arguments and
    dispatches to the correct routine, and collects the output from
    the dispatched routine.

Arguments:

    InBuffer -- input buffer
    InBufSize -- size of buffer in bytes
    OutBuffer -- output buffer
    OutBufSize -- size of output buffer

Return Values:

    Win32 errors

--*/
{
    PDHCP_API_ARGS ApiArgs;
    DWORD nApiArgs, i, j, Code, Error, OutBufSizeAtInput;

    DhcpAssert(OutBufSize);

    OutBufSizeAtInput = (*OutBufSize);
    *OutBufSize = 0;
    nApiArgs = 0;

    Error = DhcpApiArgDecode(
        InBuffer,InBufSize, NULL, &nApiArgs
        );
    if( ERROR_SUCCESS == Error ) {

        //
        // The format is not correct
        //
        
        return ERROR_INVALID_PARAMETER;
    }
    
    if( ERROR_MORE_DATA != Error ) return Error;

    DhcpAssert(nApiArgs);

    //
    // Allocate buffer space required
    //
    
    ApiArgs = DhcpAllocateMemory(nApiArgs*sizeof(DHCP_API_ARGS));
    if( NULL == ApiArgs ) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // Decode the parameters passed.
    //

    Error = DhcpApiArgDecode(InBuffer,InBufSize, ApiArgs, &nApiArgs);
    DhcpAssert(ERROR_SUCCESS == Error);
    DhcpAssert(nApiArgs);

    //
    // Check for opcode and adaptername
    //
    
    for(i = 0; i < nApiArgs ; i ++ )
        if( ApiArgs[i].ArgId >= FirstApiOpCode && ApiArgs[i].ArgId < InvalidApiOpCode )
            break;

    if( i >= nApiArgs ) {
        DhcpFreeMemory(ApiArgs);
        return ERROR_INVALID_PARAMETER;
    }

    switch(ApiArgs[i].ArgId) {
        
    case AcquireParametersOpCode:
        Error = DhcpApiProcessAdapterOnlyApi(
            ApiArgs[i].ArgVal, ApiArgs[i].ArgSize, AcquireParameters, 0
            );
        break;

    case AcquireParametersByBroadcastOpCode:
        Error = DhcpApiProcessAdapterOnlyApi(
            ApiArgs[i].ArgVal, ApiArgs[i].ArgSize, AcquireParametersByBroadcast, 0
            );
        break;

    case FallbackParamsOpCode:
        Error = DhcpApiProcessAdapterOnlyApi(
            ApiArgs[i].ArgVal, ApiArgs[i].ArgSize, FallbackRefreshParams, 0
            );
        break;

    case ReleaseParametersOpCode:
        Error = DhcpApiProcessAdapterOnlyApi(
            ApiArgs[i].ArgVal, ApiArgs[i].ArgSize, ReleaseParameters, 0
            );
        break;
        
    case EnableDhcpOpCode:
        Error = DhcpApiProcessAdapterOnlyApi(
            ApiArgs[i].ArgVal, ApiArgs[i].ArgSize, EnableDhcp, 0
            );
        break;
        
    case DisableDhcpOpCode:
        Error = DhcpApiProcessAdapterOnlyApi(
            ApiArgs[i].ArgVal, ApiArgs[i].ArgSize, DisableDhcp, 0
            );
        break;
        
    case StaticRefreshParamsOpCode:
        if( i +1 >= nApiArgs ||
            ApiArgs[i+1].ArgId != FlagsParam ||
            sizeof(DWORD) != ApiArgs[i+1].ArgSize ) {

            //
            // Expect flags argument right after adapter name arg..
            //
            DhcpAssert( FALSE );
            Code = 0;
        } else {

            //
            // Convert flags ptr to value.
            //
            Code = *(DWORD UNALIGNED *)ApiArgs[i+1].ArgVal ;
        }

        if( 0 == ApiArgs[i].ArgSize ||
            ( sizeof(WCHAR) == ApiArgs[i].ArgSize &&
              L'\0' == *(WCHAR UNALIGNED *)ApiArgs[i].ArgVal ) ) {
            Error = StaticRefreshParamsEx(NULL, Code );
        } else {
            Error = DhcpApiProcessAdapterOnlyApi(
                ApiArgs[i].ArgVal, ApiArgs[i].ArgSize, StaticRefreshParams,
                Code
                );
        }
        break;
        
    case RemoveDNSRegistrationsOpCode:
        Error = DnsRemoveRegistrations();
        break;

    default:
        (*OutBufSize) = OutBufSizeAtInput;
        Error = DhcpApiProcessArgumentedCalls(
            ApiArgs[i].ArgVal,
            ApiArgs[i].ArgSize,
            ApiArgs[i].ArgId,
            ApiArgs, nApiArgs,
            OutBuffer, OutBufSize
        );
    }

    DhcpFreeMemory(ApiArgs);
    return Error;
}

//
// end of file
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\client\dhcp\apiimpl.c ===
/*++

Copyright (C) 1995 Microsoft Corporation

Module:

    apiimpl.c

Abstract:

    routines for API -- renew, release, inform, etc

Environment:

    Win32 user mode, Win98 VxD

--*/

#include "precomp.h"
#include "dhcpglobal.h"

#ifdef VXD
#include <vxdprocs.h>
#include <debug.h>
#include <string.h>
#include <vwin32.h>
#include <local.h>
#include <vxdlib.h>
#else
#include <dhcploc.h>
#include <dhcppro.h>
#include <dnsapi.h>
#endif

#include <lmcons.h>
#include <apiappl.h>
#include <apiimpl.h>
#include <apistub.h>
#include <stack.h>
#include <optchg.h>
#include "nlanotif.h"

//
//  The following code (for VxD) assumes that it is the only process
//  executing at any givent time, and so no locks are taken any where.
//  On NT critical sections are taken appropriately.
//

#ifdef VXD
#undef LOCK_RENEW_LIST
#undef UNLOCK_RENEW_LIST
#define LOCK_RENEW_LIST()
#define UNLOCK_RENEW_LIST()
#endif

//
// Pageable routine declarations.
//

#if defined(CHICAGO) && defined(ALLOC_PRAGMA)
DWORD
VDhcpClientApi(
    LPBYTE lpRequest,
    ULONG dwRequestBufLen
);

//
// This is a hack to stop compiler complaining about the routines already
// being in a segment!!!
//

#pragma code_seg()

#pragma CTEMakePageable(PAGEDHCP, AcquireParameters)
#pragma CTEMakePageable(PAGEDHCP, AcquireParametersByBroadcast)
#pragma CTEMakePageable(PAGEDHCP, FallbackRefreshParams)
#pragma CTEMakePageable(PAGEDHCP, ReleaseParameters)
#pragma CTEMakePageable(PAGEDHCP, EnableDhcp)
#pragma CTEMakePageable(PAGEDHCP, DisableDhcp)
#pragma CTEMakePageable(PAGEDHCP, DhcpDoInform)
#pragma CTEMakePageable(PAGEDHCP, VDhcpClientApi)

#endif CHICAGO && ALLOC_PRAGMA

//
//  Main CODE starts HERE
//


#ifndef VXD
DWORD
DhcpApiInit(
    VOID
    )
/*++

Routine Description:

    This routine initializes the DHCP Client API structures, creates
    required pipes and events etc.

Return Value:

    Win32 errors

--*/
{
    ULONG Error, Length;
    BOOL BoolError;
    SECURITY_ATTRIBUTES SecurityAttributes;
    PSECURITY_DESCRIPTOR  SecurityDescriptor = NULL;
    SID_IDENTIFIER_AUTHORITY Authority = SECURITY_NT_AUTHORITY;
    PACL Acl = NULL;
    PSID AdminSid = NULL,
         PowerUserSid = NULL,
         LocalServiceSid = NULL,
         NetworkConfigOpsSid = NULL;
    
    //
    // Create event w/ no security, manual reset (overlapped io).. no name
    //
    DhcpGlobalClientApiPipeEvent = CreateEvent( NULL, TRUE, FALSE, NULL );
    if( NULL == DhcpGlobalClientApiPipeEvent ) {
        Error = GetLastError();
        goto Cleanup;
    }

    BoolError = AllocateAndInitializeSid(
        &Authority,
        2,
        SECURITY_BUILTIN_DOMAIN_RID,
        DOMAIN_ALIAS_RID_ADMINS,
        0, 0, 0, 0, 0, 0,
        &AdminSid
    );

    BoolError = BoolError && AllocateAndInitializeSid(
        &Authority,
        2,
        SECURITY_BUILTIN_DOMAIN_RID,
        DOMAIN_ALIAS_RID_POWER_USERS,
        0, 0, 0, 0, 0, 0,
        &PowerUserSid
        );
    
    BoolError = BoolError && AllocateAndInitializeSid(
        &Authority,
        1,
        SECURITY_LOCAL_SERVICE_RID,
        0,
        0, 0, 0, 0, 0, 0,
        &LocalServiceSid
        );

    BoolError = BoolError && AllocateAndInitializeSid(
        &Authority,
        2,
        SECURITY_BUILTIN_DOMAIN_RID,
        DOMAIN_ALIAS_RID_NETWORK_CONFIGURATION_OPS,
        0, 0, 0, 0, 0, 0,
        &NetworkConfigOpsSid
        );
    
    if( BoolError == FALSE )
    {
        Error = GetLastError();
        goto Cleanup;
    }

    Length = ( (ULONG)sizeof(ACL)
               + 4*((ULONG)sizeof(ACCESS_ALLOWED_ACE) - (ULONG)sizeof(ULONG)) +
               + GetLengthSid( AdminSid )
               + GetLengthSid( PowerUserSid )
               + GetLengthSid( LocalServiceSid )
               + GetLengthSid( NetworkConfigOpsSid ) );
    
    Acl = DhcpAllocateMemory( Length );
    if( NULL == Acl )
    {
        Error = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }
    
    BoolError = InitializeAcl( Acl, Length, ACL_REVISION2);
    
    BoolError = BoolError && AddAccessAllowedAce (
        Acl,
        ACL_REVISION2,
        GENERIC_READ | GENERIC_WRITE,
        AdminSid );
    
    BoolError = BoolError && AddAccessAllowedAce (
        Acl,
        ACL_REVISION2,
        GENERIC_READ | GENERIC_WRITE,
        PowerUserSid );
    
    BoolError = BoolError && AddAccessAllowedAce (
        Acl,
        ACL_REVISION2,
        GENERIC_READ | GENERIC_WRITE,
        LocalServiceSid );

    BoolError = BoolError && AddAccessAllowedAce (
        Acl,
        ACL_REVISION2,
        GENERIC_READ | GENERIC_WRITE,
        NetworkConfigOpsSid );

    if( FALSE == BoolError )
    {
        Error = GetLastError();
        goto Cleanup;
    }

    SecurityDescriptor = DhcpAllocateMemory(SECURITY_DESCRIPTOR_MIN_LENGTH );
    if( NULL == SecurityDescriptor )
    {
        Error = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }
    
    BoolError = InitializeSecurityDescriptor(
        SecurityDescriptor,
        SECURITY_DESCRIPTOR_REVISION );
    
    BoolError = BoolError && SetSecurityDescriptorDacl (
        SecurityDescriptor,
        TRUE,
        Acl,
        FALSE
        );
    
    if( BoolError == FALSE ) {
        Error = GetLastError();
        goto Cleanup;
    }
    
    SecurityAttributes.nLength = sizeof( SecurityAttributes );
    SecurityAttributes.lpSecurityDescriptor = SecurityDescriptor;
    SecurityAttributes.bInheritHandle = FALSE;

    DhcpGlobalClientApiPipe = CreateNamedPipe(
        DHCP_PIPE_NAME,
        PIPE_ACCESS_DUPLEX | FILE_FLAG_OVERLAPPED,
        PIPE_TYPE_MESSAGE | PIPE_READMODE_MESSAGE | PIPE_WAIT,
        PIPE_UNLIMITED_INSTANCES,
        1024,
        0,
        10,     // Client timeout
        &SecurityAttributes );

    if( DhcpGlobalClientApiPipe == INVALID_HANDLE_VALUE ) {
        Error = GetLastError();
        DhcpGlobalClientApiPipe = NULL;
        goto Cleanup;
    }

    DhcpGlobalClientApiOverLapBuffer.hEvent = DhcpGlobalClientApiPipeEvent;
    if( FALSE == ConnectNamedPipe(
        DhcpGlobalClientApiPipe,
        &DhcpGlobalClientApiOverLapBuffer )) {

        Error = GetLastError();

        if( (Error != ERROR_IO_PENDING) &&
            (Error != ERROR_PIPE_CONNECTED) ) {
            goto Cleanup;
        }

        Error = ERROR_SUCCESS; // Wonder what I should have here?
    }

 Cleanup:

    if (AdminSid != NULL)
    {
        FreeSid(AdminSid);
    }

    if (PowerUserSid != NULL)
    {
        FreeSid(PowerUserSid);
    }

    if (LocalServiceSid != NULL)
    {
        FreeSid(LocalServiceSid);
    }

    if (NetworkConfigOpsSid != NULL)
    {
        FreeSid(NetworkConfigOpsSid);
    }

    if( SecurityDescriptor != NULL ) {
        DhcpFreeMemory( SecurityDescriptor );
    }

    if( Acl != NULL ) {
        DhcpFreeMemory( Acl );
    }

    if( Error != ERROR_SUCCESS ) {
        DhcpPrint(( DEBUG_ERRORS, "DhcpApiInit failed, %ld.\n", Error ));
    }

    return( Error );
}

VOID
DhcpApiCleanup(
    VOID
    )
/*++

Routine Description:

    Cleanup the effects of DhcpApiInit

--*/
{
    if( DhcpGlobalClientApiPipe != NULL ) {
        CloseHandle( DhcpGlobalClientApiPipe );
        DhcpGlobalClientApiPipe = NULL;
    }

    if( DhcpGlobalClientApiPipeEvent != NULL ) {
        CloseHandle( DhcpGlobalClientApiPipeEvent );
        DhcpGlobalClientApiPipeEvent = NULL;
    }

    return;
}

#else

//
// VxD Specific code.
//

DWORD
VDhcpClientApi(
    LPBYTE lpRequest,
    ULONG dwRequestBufLen
)
/*++

Routine Description:

    This routine is the entrypoint for a DeviceIoControl in a VxD.. (a
    short stub in asm calls into this routine).  The request comes in
    lpRequest and its size is the dwRequestBufLen.  It is expected that the
    same buffer is used as output buffer with atmost same space.

    This dispatches the right API call.

Arguments:

    lpRequest -- device ioctl request,output buffer
    dwRequestBufLen -- size of above buffer.

Return Values:

    basic errors with buffers.. Status is reported as part of the output
    buffer.

--*/
 {
    PDHCP_RESPONSE pDhcpResponse = NULL;
    PDHCP_REQUEST  pDhcpRequest = NULL;
    DHCP_RESPONSE  DhcpResponse;
    static BYTE    RetOptList[DHCP_RECV_MESSAGE_SIZE];

    DWORD   Ring0Event;
    DWORD   RetOptListSize;
    DWORD   RetVal;

    if( dwRequestBufLen < sizeof(DHCP_REQUEST)
        || dwRequestBufLen < sizeof(DHCP_RESPONSE)
        || !lpRequest ) {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Cast pointers.
    //

    pDhcpRequest = (PDHCP_REQUEST) lpRequest;
    pDhcpResponse = (PDHCP_RESPONSE) lpRequest;

    switch(pDhcpRequest->WhatToDo) {
    case AcquireParametersOpCode:
        DhcpResponse.Status = AcquireParameters(pDhcpRequest->AdapterName); break;
    case AcquireParametersByBroadcastOpCode:
        DhcpResponse.Status = AcquireParametersByBroadcast(pDhcpRequest->AdapterName); break;
    case FallbackParamsOpCode:
        DhcpResponse.Status = FallbackRefreshParams(pDhcpRequest->AdapterName); break;
    case ReleaseParametersOpCode:
        DhcpResponse.Status = ReleaseParameters(pDhcpRequest->AdapterName); break;
    case EnableDhcpOpCode:
        DhcpResponse.Status = EnableDhcp(pDhcpRequest->AdapterName); break;
    case DisableDhcpOpCode:
        DhcpResponse.Status = DisableDhcp(pDhcpRequest->AdapterName); break;
    case RequestOptionsOpCode:
        DhcpResponse.Status = RequestOptions(
            pDhcpRequest->AdapterName,
            pDhcpRequest->RequestedOptions,
            DhcpResponse.CopiedOptions,
            RetOptList,
            dwRequestBufLen - sizeof(DhcpResponse),
            &DhcpResponse.dwOptionListSize
            );
        // Should also copy the options data for request options..
        if(DhcpResponse.Status == ERROR_SUCCESS)
            memcpy(((LPBYTE)pDhcpResponse)+sizeof(DHCP_RESPONSE), RetOptList,
                   DhcpResponse.dwOptionListSize);
        break;
    case RegisterOptionsOpCode:
        DhcpResponse.Status = RegisterOptions(
            pDhcpRequest->AdapterName,
            pDhcpRequest->RequestedOptions,
            NULL, // Event name has no meaning for VXD's
            &pDhcpRequest->dwHandle
        );
        break;
    case DeRegisterOptionsOpCode:
        DhcpResponse.Status = DeRegisterOptions(pDhcpRequest->dwHandle); break;
    default:
        DhcpResponse.Status = ERROR_INVALID_PARAMETER;
        return ERROR_INVALID_PARAMETER;
    }

    memcpy(pDhcpResponse, &DhcpResponse, sizeof(DHCP_RESPONSE));

    // Now we are done.. return the status.
    return DhcpResponse.Status;
}

// end of VxD code
#endif VXD

DWORD
DhcpDoInform(
    IN PDHCP_CONTEXT DhcpContext,
    IN BOOL fBroadcast
)
/*++

Routine Description:

    This routine does the inform part by sending inform messages and
    collecting responses etc. on  given context.
    In case of no-response, no error is returned as a timeout is not
    considered an error.

Arguments:

    DhcpContext -- context to dhcp struct
    fBroadcast -- should the inform be broadcast or unicast?

Return Values:

    Win32 errors

--*/
{
    ULONG Error, LocalError;
    time_t OldT2Time;
    BOOL WasPlumbedBefore;

    //
    // MDHCP uses INADDR_ANY -- so an address need not be there.
    //
    DhcpAssert(!IS_MDHCP_CTX( DhcpContext));

    if( 0 == DhcpContext->IpAddress) {
        DhcpPrint((DEBUG_ERRORS, "Cannot do DhcpInform on an adapter "
                   "without ip address!\n"));
        return ERROR_SUCCESS;
    }

    //
    // Open socket before calling SendInformAndGetReplies -- else it don't
    // work, for some strange reason.
    //

    if((Error = OpenDhcpSocket(DhcpContext)) != ERROR_SUCCESS ) {
        DhcpPrint((DEBUG_ERRORS, "Could not open socket (%ld)\n", Error));
        return Error;
    }

    //
    // If a BROADCAST is requested, use the following kludge.   Set the
    // flags so that the context doesn't look plumbed -- this causes a
    // broadcast. Remember to restore the flags later.
    //

    OldT2Time = DhcpContext->T2Time;
    WasPlumbedBefore = IS_ADDRESS_PLUMBED(DhcpContext);
    if(fBroadcast) {
        DhcpContext->T2Time = 0;
        ADDRESS_UNPLUMBED(DhcpContext);
    } else {
        DhcpContext->T2Time = (-1);
    }

    //
    // Send atmost 2 inform packets, and wait for atmost 4 responses..
    //

    Error = SendInformAndGetReplies( DhcpContext, 2, 4 );
    DhcpContext->LastInformSent = time(NULL);

    //
    // restore old values for T2time as well as plumb state.
    //

    DhcpContext->T2Time = OldT2Time;
    if( WasPlumbedBefore ) ADDRESS_PLUMBED(DhcpContext);

    LocalError = CloseDhcpSocket(DhcpContext);
    DhcpAssert(ERROR_SUCCESS == LocalError);

    //
    //  For DHCP packets alone, save the information onto the registry.
    //

    if (!IS_MDHCP_CTX(DhcpContext)) {
        LOCK_OPTIONS_LIST();
        (void) DhcpRegSaveOptions(
            &DhcpContext->RecdOptionsList,
            ((PLOCAL_CONTEXT_INFO)DhcpContext->LocalInformation)->AdapterName,
            DhcpContext->ClassId,
            DhcpContext->ClassIdLength
            );
        UNLOCK_OPTIONS_LIST();

        if(Error == ERROR_SEM_TIMEOUT) {
            Error = ERROR_SUCCESS;
            DhcpPrint((DEBUG_PROTOCOL, "No response to Dhcp inform\n"));
        }
    }

    if( ERROR_SUCCESS != Error ) {
        DhcpPrint((DEBUG_ERRORS, "DhcpDoInform:return [0x%lx]\n", Error));
    }

    return Error;
}

DWORD
AcquireParameters(
    IN PDHCP_CONTEXT DhcpContext
)
/*++

Routine Description:

    This routine acquires a new lease or renews existing lease for dhcp
    enabled adapters.  If the adapter is not dhcp enabled, then it returns
    ERROR_FILE_NOT_FOUND (????).

    It is assumed that the context semaphore is already taken on NT.

Arguments:

    DhcpContext -- context

Return Value:

    Status of operation.

--*/
{
    if( IS_DHCP_DISABLED(DhcpContext)) return ERROR_FILE_NOT_FOUND;

    //
    // --ft:06/22 #124864
    // There is a weird corner case here: It could happen that the context is not in 
    // the DhcpGlobalRenewList but its semaphore is not yet taken. This happens if
    // the DhcpRenewThread that is spawned from within ProcessDhcpRequestForever->
    // ->DhcpCreateThreadAndRenew has not been yet scheduled for execution.
    // so the previous code:
    // DhcpAssert( !IsListEmpty(&DhcpContext->RenewalListEntry) );
    // was based on a wrong assumption causing the assert to be hit.
    //
    // we can safely return success if the context doesn't look to be enlisted in
    // DhcpGloablRenewList. This means the DhcpRenewThread is about to be started
    // and it will be it taking care of refreshing the lease.
    if ( IsListEmpty(&DhcpContext->RenewalListEntry) )
        return ERROR_SUCCESS;

    RemoveEntryList(&DhcpContext->RenewalListEntry);
    InitializeListHead(&DhcpContext->RenewalListEntry);
    return DhcpContext->RenewalFunction(DhcpContext, NULL);
}

DWORD
AcquireParametersByBroadcast(
    IN PDHCP_CONTEXT DhcpContext
)
/*++

Routine Description:

    This routine acquires a new lease or renews existing lease for dhcp
    enabled adapters.  If the adapter is not dhcp enabled, then it returns
    ERROR_FILE_NOT_FOUND (????).

    It is assumed that the context semaphore is already taken on NT.

Arguments:

    DhcpContext -- context

Return Value:

    Status of operation.

--*/
{
    DWORD           Error;

    if( IS_DHCP_DISABLED(DhcpContext)) return ERROR_FILE_NOT_FOUND;

    //
    // --ft:06/22 #124864
    // There is a weird corner case here: It could happen that the context is not in 
    // the DhcpGlobalRenewList but its semaphore is not yet taken. This happens if
    // the DhcpRenewThread that is spawned from within ProcessDhcpRequestForever->
    // ->DhcpCreateThreadAndRenew has not been yet scheduled for execution.
    // so the previous code:
    // DhcpAssert( !IsListEmpty(&DhcpContext->RenewalListEntry) );
    // was based on a wrong assumption causing the assert to be hit.
    //
    // we can safely return success if the context doesn't look to be enlisted in
    // DhcpGloablRenewList. This means the DhcpRenewThread is about to be started
    // and it will be it taking care of refreshing the lease.
    if ( IsListEmpty(&DhcpContext->RenewalListEntry) )
        return ERROR_SUCCESS;

    RemoveEntryList(&DhcpContext->RenewalListEntry);
    InitializeListHead(&DhcpContext->RenewalListEntry);

    if (DhcpContext->RenewalFunction != ReRenewParameters) {
        Error = DhcpContext->RenewalFunction(DhcpContext, NULL);
    } else {
        time_t OldT1Time;
        time_t OldT2Time;

        OldT1Time = DhcpContext->T1Time;
        OldT2Time = DhcpContext->T2Time;

        time(&DhcpContext->T2Time);
        DhcpContext->T2Time--;
        DhcpContext->T1Time = DhcpContext->T2Time - 1;

        Error = ReRenewParameters(DhcpContext, NULL);
        if (Error != ERROR_SUCCESS) {
            DhcpContext->T1Time = OldT1Time;
            DhcpContext->T2Time = OldT2Time;
        }
    }

    return Error;
}

/*++

Routine Description:

    This routine refreshes the fallback configuration parameters. If the
    adapter is dhcp enabled and already defaulted to autonet, then the
    fallback configuration is applied instantly.

    It is assumed that the context semaphore is already taken on NT.

Arguments:

    DhcpContext -- context

Return Value:

    Status of operation.

--*/
DWORD
FallbackRefreshParams(
    IN OUT PDHCP_CONTEXT DhcpContext
)
{
    DWORD Error = ERROR_SUCCESS;
    BOOL  fWasFallback;
    LONG  timeToSleep;

    LOCK_OPTIONS_LIST();

    // see if we had a fallback configuration already applied
    fWasFallback = IS_FALLBACK_ENABLED(DhcpContext);

    // destroy the previously fallback list of options
    // it is assumed FbOptionsList ends up as a valid empty list head
    // as after InitializeHeadList();
    DhcpDestroyOptionsList(&DhcpContext->FbOptionsList, &DhcpGlobalClassesList);
    // read the fallback configuration (if any). This adjustes also the
    // Fallback flag from the context to true or false depending whether there
    // has been a fallback configuration or not.
    Error = DhcpRegFillFallbackConfig(
        DhcpContext
    );
    UNLOCK_OPTIONS_LIST();

    // the adapter is re-plumbed only if
    // - it was already plumbed with autonet/fallback 
    // - and it has a non zero address (might never have this case here!)
    // Otherwise don't touch any of the tcpip settings
    if (IS_ADDRESS_AUTO(DhcpContext) &&
        DhcpContext->IpAddress != 0)
    {
        if (IS_FALLBACK_ENABLED(DhcpContext))
        {
            // If there is a Fallback configuration, plumb it in instantly
            // regardless we had before pure autonet or another fallback config
            //
            // NOTE: The DhcpContext is exclusively accessed here, so it can't be
            // a discover process on course. This means that the fallback config
            // will not be applied somehow in the middle of the 'discover' process.
            //
            Error = SetAutoConfigurationForNIC(
                        DhcpContext,
                        DhcpContext->IpAddress,
                        DhcpContext->SubnetMask);

            // make sure to not schedule the fallback config for automatic discover
            // attempts as in the case of pure autonet
            timeToSleep = INFINIT_LEASE;
        }
        else
        {
            // since the new configuration is pure autonet, make sure to activate
            // the automatic discover attempts.
            timeToSleep = max((LONG)(AutonetRetriesSeconds + RAND_RETRY_DELAY), 0);

            if (fWasFallback)
            {
                // If currently we have no fallback config, apply a pure autonet config
                // but only if we didn't have one already. In that case there is no
                // reason to change it.
                Error = DhcpPerformIPAutoconfiguration(DhcpContext);

                // alternate option: switching from fallback to autonet triggers a
                // discover as soon as possible
                timeToSleep = 1;

            }
        }

        ScheduleWakeUp(DhcpContext, timeToSleep);
    }

    return Error;
}



DWORD
ReleaseParameters(
    IN PDHCP_CONTEXT DhcpContext
)
/*++

Routine Description:

    This routine releases a lease assuming one exists, on a dhcp enabled
    context.  If the context is not dhcp enabled, it returns
    ERROR_FILE_NOT_FOUND (????).

    It is assumed that the context semaphore is already taken.

Arguments:

    DhcpContext -- context

Return Value:

    Stats of operation.

--*/
{
    ULONG Error;

    if( IS_DHCP_DISABLED(DhcpContext)) return ERROR_FILE_NOT_FOUND;
    Error = ReleaseIpAddress(DhcpContext);

    //
    // Make sure this item doesn't get picked up now.
    //
    ScheduleWakeUp(DhcpContext, INFINIT_LEASE);

    return Error;
}

#ifndef VXD
DWORD
EnableDhcp(
    IN PDHCP_CONTEXT DhcpContext
)
/*++

Routine Description:

    This routine converts a non-dhcp enabled adapter to dhcp and starts off
    a thread that will get an address on this.   If the adapter is already
    dhcp enabled, then nothing is done..

    It is assumed that the context semaphore is already taken.

Arguments:

    DhcpContext -- context

Return Value:

    Status of the operation.

--*/
{
    ULONG Error;

    if( IS_DHCP_ENABLED(DhcpContext) ) {
        return ERROR_SUCCESS;
    }

    DhcpContext->RenewalFunction = ReObtainInitialParameters;
    ADDRESS_PLUMBED( DhcpContext );
    Error = SetDhcpConfigurationForNIC(
        DhcpContext,
        NULL,
        0,
        (DWORD)-1,
        TRUE
    );

    DHCP_ENABLED(DhcpContext);
    CTXT_WAS_NOT_LOOKED(DhcpContext);
    ScheduleWakeUp(DhcpContext, 0);
    return Error;
}

ULONG
DisableDhcp(
    IN PDHCP_CONTEXT DhcpContext
)
/*++

Routine Description:

    This routine converts its internal context from dhcp-enabled to
    static.  It is presumed that the adapter has been converted from dhcp
    to static externally and this is just used as a notification
    mechanism.   This routine also deletes all the DHCP specific registry
    values.

    It is assumed that the context semaphore is already taken.

Arguments:

    DhcpContext -- context

Return Value:

    Status of the operation.

--*/
{
    ULONG  Error, Error2;

    if( IS_DHCP_DISABLED(DhcpContext) ) {
        return ERROR_SUCCESS;
    }

    Error = SetDhcpConfigurationForNIC(
        DhcpContext,
        NULL,
        0,
        (DWORD)-1,
        FALSE
    );

    Error2 = DhcpRegDeleteIpAddressAndOtherValues(DhcpContext->AdapterInfoKey);
    DhcpAssert(ERROR_SUCCESS == Error2);


    RemoveEntryList(&DhcpContext->RenewalListEntry);
    InitializeListHead(&DhcpContext->RenewalListEntry);
    DHCP_DISABLED(DhcpContext);

    return Error;
}

#endif VXD

BOOL
DhcpMissSomeOptions(
    IN PDHCP_CONTEXT DhcpContext,
    IN LPBYTE ClassId OPTIONAL,
    IN DWORD ClassIdLength,
    IN LPBYTE ParamRequestList OPTIONAL,
    IN DWORD nParamsRequested,
    IN LPBYTE VParamRequestList OPTIONAL,
    IN DWORD nVParamsRequested
)
/*++

Routine Description:

    This routine verifies to see if any options requested are missing in
    the internal options list (of available options).
    (An expired option found is ignored -- only unexpired options are
    considered "available").

Arguments:

    DhcpContext -- context
    ClassId -- ClassId this option belongs to
    ClassIdLength -- # of bytes of ClassId stream
    ParamRequestList -- the sequence of non-vendor options that are of
        interest
    nParamsRequested -- size of above buffer..
    VParamRequestList -- the sequence of vendor options that are of
        interest
    nVParamsRequested -- number of vendor options requested.

Return Value:

    TRUE -- Atleast one of the requested option is not available.
    FALSE -- No requested option is unvailable.

--*/
{
    ULONG i;
    PDHCP_OPTION ThisOpt;
    time_t TimeNow;

    if( 0 == nParamsRequested && 0 == nVParamsRequested )
        return TRUE;

    TimeNow = time(NULL);
    for( i = 0; i < nParamsRequested; i ++ ) {
        ThisOpt = DhcpFindOption(
            &DhcpContext->RecdOptionsList,
            ParamRequestList[i],
            FALSE /* Not vendor specific */,
            ClassId,
            ClassIdLength,
            0                               //dont care about serverid
        );
        if( NULL == ThisOpt ) return TRUE;
        if( 0 == ThisOpt->DataLen ) return TRUE;
        if( TimeNow > ThisOpt->ExpiryTime ) return TRUE;
    }

    for( i = 0; i < nVParamsRequested; i ++ ) {
        ThisOpt = DhcpFindOption(
            &DhcpContext->RecdOptionsList,
            VParamRequestList[i],
            TRUE /* YES, it is vendor specific */,
            ClassId,
            ClassIdLength,
            0                               //dont care about serverid
        );
        if( NULL == ThisOpt ) return TRUE;
        if( 0 == ThisOpt->DataLen ) return TRUE;
        if( TimeNow > ThisOpt->ExpiryTime ) return TRUE;
    }

    return FALSE;
}

DWORD
DhcpSendInformIfRequired(
    IN BYTE OpCode,
    IN PDHCP_CONTEXT DhcpContext,
    IN LPBYTE ClassId OPTIONAL,
    IN DWORD ClassIdLength,
    IN LPBYTE ParamRequestList OPTIONAL,
    IN DWORD nParamsRequested,
    IN LPBYTE VParamRequestList OPTIONAL,
    IN DWORD nVParamsRequested,
    IN OUT PLIST_ENTRY SendOptions
)
/*++

Routine Description:

    This routine attempts to check to see if any Inform packets have to be
    sent to satisfy the request of parameters (as specified in ClassId,
    ParamRequestList and VParamRequestList) and in case it decides to send
    any informs, then it uses the SendOptions field to send additional
    options in the inform message.

    Informs are sent only if the context has the UseInformFlag set to
    TRUE.  If this is set to FALSE and the adapter is DHCP enabled, a
    REQUEST packet is the alternative way to retrive options..

    Also, this routine makes sure that an inform is not sent within the
    InformSeparationInterval for the context since the last inform being
    sent.   This prevents unnecessary traffic.

    Also, no informs may be sent on a card with no ip address, and no
    inform is sent if all the requested options are already available.

    Also, if OpCode is PersistentRequestParamsOpCode, then no check is made
    to see if the options are available in the list or not.. and the inform
    is not sent either.. (but the send options are safely stored in the
    context's list of options to send).

Arguments:

    OpCode -- PersistentRequestParamsOpCode or just RequestParamsOpCode
    DhcpContext -- context
    ClassId -- ClassId of options being requested
    ClassIdLength -- # of bytes of above
    ParamRequestList -- sequence of non-vendor options requested
    nParamsRequested -- size of above in bytes..
    VParamRequestList -- sequence of vendor options requested
    nVParamsRequested -- size of above in bytes
    SendOptions -- list of optiosn to send in case an inform is sent

Return Value:

    Win32 error code

--*/
{
    ULONG Error, i, nSendOptionsAdded, OldClassIdLength;
    BOOL ParametersMissing;
    time_t TimeNow;
    LPBYTE OldClassId;
    PDHCP_OPTION ThisOpt;
    PLIST_ENTRY ThisEntry;

    ParametersMissing = TRUE;
    TimeNow = time(NULL);

    //
    // If inform not allowed, and dhcp enabled, we may use dhcp-request.
    // Also, check time to disallow frequent sends..
    // For PersistentRequestParamsOpCode, we need to remember optiosn
    // to send (assuming class Id's match)
    //

    if( PersistentRequestParamsOpCode == OpCode ) {
        if( ClassIdLength == DhcpContext->ClassIdLength
            && 0 == memcmp( ClassId, DhcpContext->ClassId, ClassIdLength )
            ) {
            ParametersMissing = TRUE;
        } else {
            ParametersMissing = FALSE;
        }
    } else {
        time_t tmp_time;

        tmp_time = (time_t) DhcpContext->LastInformSent;
        tmp_time += (time_t) DhcpContext->InformSeparationInterval;

        if( DhcpContext->UseInformFlag ) {
            if( TimeNow < tmp_time  ) return ERROR_SUCCESS ;
        } else {
            if( !IS_DHCP_ENABLED(DhcpContext)) return ERROR_SUCCESS;
            if( TimeNow < tmp_time ) return ERROR_SUCCESS;
        }

        if( DhcpIsInitState(DhcpContext) ) return ERROR_SUCCESS;

        ParametersMissing = DhcpMissSomeOptions(
            DhcpContext,
            ClassId,
            ClassIdLength,
            ParamRequestList,
            nParamsRequested,
            VParamRequestList,
            nVParamsRequested
        );
    }

    if( !ParametersMissing ) {
        DhcpPrint((
            DEBUG_OPTIONS,
            "DhcpSendInformIfRequired:got all parameters, so not sending inform\n"
            ));
        return ERROR_SUCCESS;
    } else {
        DhcpPrint((
            DEBUG_OPTIONS,
            "DhcpSendInformIfRequired:missing parameters, will try to get some\n"
            ));
    }

    OldClassIdLength = DhcpContext->ClassIdLength;
    OldClassId = DhcpContext->ClassId;

    //
    // use the new class id and length after storing old one
    //
    
    DhcpContext->ClassId = ClassId;
    DhcpContext->ClassIdLength = ClassIdLength;

    //
    // add the requested send options to the context
    //
    
    nSendOptionsAdded = 0;
    while(!IsListEmpty(SendOptions) ) {
        ThisEntry = RemoveHeadList(SendOptions);
        ThisOpt = CONTAINING_RECORD(ThisEntry, DHCP_OPTION, OptionList);

        InsertHeadList(&DhcpContext->SendOptionsList, &ThisOpt->OptionList);
        nSendOptionsAdded++;
    }

    //
    // Done, so far as PersistentRequestParamsOpCode is concerned.
    //

    if( PersistentRequestParamsOpCode == OpCode ) {
        if( OldClassIdLength && OldClassId ) {
            DhcpFreeMemory( OldClassId );
        }
        return ERROR_SUCCESS;
    }

    if( DhcpContext->UseInformFlag ) {

        //
        // Send broadcast inform by default.
        //
        Error = DhcpDoInform(DhcpContext, TRUE);
        
    } else {

        LOCK_RENEW_LIST();
        DhcpAssert(!IsListEmpty(&DhcpContext->RenewalListEntry));
        RemoveEntryList(&DhcpContext->RenewalListEntry);
        InitializeListHead(&DhcpContext->RenewalListEntry);
        UNLOCK_RENEW_LIST();
        Error = ReRenewParameters(DhcpContext, NULL);
        
    }

    DhcpContext->ClassId = ClassId;
    DhcpContext->ClassIdLength = ClassIdLength;

    //
    // recreate SendOptions list
    //

    while(nSendOptionsAdded) {
        DhcpAssert(!IsListEmpty(&DhcpContext->SendOptionsList));
        ThisEntry = RemoveHeadList(&DhcpContext->SendOptionsList);
        ThisOpt = CONTAINING_RECORD(ThisEntry, DHCP_OPTION, OptionList);

        InsertHeadList(SendOptions, &ThisOpt->OptionList);
        nSendOptionsAdded--;
    }

    if( ERROR_SUCCESS != Error ) {
        DhcpPrint((DEBUG_ERRORS, "DhcpSendInformIfRequired:"
                   "DoInform/ReRenew: return 0x%lx\n", Error));
    }

    return Error;
}

DWORD
RequestParamsDetailed(
    IN BYTE OpCode,
    IN PDHCP_CONTEXT DhcpContext,
    IN LPBYTE ClassId OPTIONAL,
    IN DWORD ClassIdLength,
    IN LPBYTE ParamRequestList,
    IN DWORD nParamsRequested,
    IN LPBYTE VParamRequestList,
    IN DWORD nVParamsRequested,
    IN PLIST_ENTRY SendOptions,
    IN OUT LPBYTE Buffer,
    IN OUT LPDWORD BufferSize
)
/*++

Routine Description:

    This routine checks if the requested paramaters are available and if
    not available, INFORM is used to retrieve the option.  If inform is
    being sent, then the options listed are used to send to the dhcp server
    in the packet.

Arguments:

    OpCode -- PersistentRequestParamsOpCode or just RequestParamsOpCode
    DhcpContext -- context
    ClassId -- ClassId of options being requested
    ClassIdLength -- # of bytes of above
    ParamRequestList -- sequence of non-vendor options requested
    nParamsRequested -- size of above in bytes..
    VParamRequestList -- sequence of vendor options requested
    nVParamsRequested -- size of above in bytes
    SendOptions -- list of optiosn to send in case an inform is sent
    Buffer -- output buffer to be filled with options retrieved
    BufferSize -- on input this will have the size in bytes of available
        space.  On output, this will either contain the required size or
        the available size.

Return Values:

    Win32 errors
    
--*/
{
    PDHCP_OPTION ThisOpt;
    DWORD OutBufSizeAtStart, Error, i, Size;
    BYTE OptionId;
    BOOL IsVendor;
    time_t TimeNow;
    LPBYTE pCrtOption;

    OutBufSizeAtStart = (*BufferSize);
    *BufferSize = 0;

    //
    // if any of the reqd params are missing, send an inform
    //
    
    Error = DhcpSendInformIfRequired(
        OpCode,
        DhcpContext,
        ClassId,
        ClassIdLength,
        ParamRequestList,
        nParamsRequested,
        VParamRequestList,
        nVParamsRequested,
        SendOptions
    );
    if( ERROR_SUCCESS != Error ) return Error;

    if( 0 == nParamsRequested + nVParamsRequested ) return ERROR_SUCCESS;
    if( PersistentRequestParamsOpCode == OpCode ) return ERROR_SUCCESS;

    Size = 0;
    TimeNow = time(NULL);

    //
    // Now fill all avaialable params, non-vendor first and vendor next.
    //
    
    for(IsVendor = FALSE; IsVendor <= TRUE; IsVendor ++ ) {
        LPBYTE xParamRequestList;
        DWORD xnParamsRequested;

        xnParamsRequested = (
            IsVendor?nVParamsRequested:nParamsRequested
            );
        xParamRequestList = (
            IsVendor?VParamRequestList:ParamRequestList
            );

        for( i = 0; i < xnParamsRequested; i ++ ) {
            OptionId = xParamRequestList[i];
            ThisOpt = DhcpFindOption(
                &DhcpContext->RecdOptionsList,
                OptionId,
                IsVendor,
                ClassId,
                ClassIdLength,
                0
            );
            if( NULL == ThisOpt
                || 0 == ThisOpt->DataLen ) {
                continue;
            }
            
            if( ThisOpt->ExpiryTime < TimeNow ) {
                DhcpPrint((
                    DEBUG_OPTIONS, "%sOption [0x%lx] has expired\n",
                    IsVendor?"Vendor ":"", OptionId
                    ));
                continue;
            }

            DhcpPrint((
                DEBUG_OPTIONS,
                "%sOption [0x%lx] has been found - %ld bytes\n",
                IsVendor?"Vendor ":"", OptionId, ThisOpt->DataLen
                ));
            
            Size += ThisOpt->DataLen + sizeof(DWORD) + 2*sizeof(BYTE);
        }
    }

    *BufferSize = Size;
    if( OutBufSizeAtStart < Size ) {
        DhcpPrint((
            DEBUG_OPTIONS,
            "Buffer size [0x%lx] is not as big as [0x%lx]\n",
            OutBufSizeAtStart, Size
            ));

        return ERROR_MORE_DATA;
    }

    //
    // initial # of bytes filled in is zero
    //
    
    ((DWORD UNALIGNED*)Buffer)[0] = 0;
    pCrtOption = Buffer + sizeof(DWORD);

    for(IsVendor = FALSE; IsVendor <= TRUE; IsVendor ++ ) {
        LPBYTE xParamRequestList;
        DWORD xnParamsRequested;
        //BYTE TmpBuf[OPTION_END+1];

        xnParamsRequested = (
            IsVendor?nVParamsRequested:nParamsRequested
            );
        xParamRequestList = (
            IsVendor?VParamRequestList:ParamRequestList
            );
        for( i = 0; i < xnParamsRequested; i ++ ) {
            OptionId = xParamRequestList[i];
            ThisOpt = DhcpFindOption(
                &DhcpContext->RecdOptionsList,
                OptionId,
                IsVendor,
                ClassId,
                ClassIdLength,
                0
            );
            if( NULL == ThisOpt
                || 0 == ThisOpt->DataLen ) {
                continue;
            }
            
            if( ThisOpt->ExpiryTime < TimeNow ) {
                DhcpPrint((
                    DEBUG_OPTIONS,
                    "%sOption [0x%lx] has expired\n",
                    IsVendor?"Vendor ":"", OptionId
                    ));
                continue;
            }

            //
            // originally the formatting was done by calling DhcpApiArgAdd. Now, the formatting is done
            // explicitly in this function since the Data field is composed by both option Id and Option Data.
            // Doing so allows an in-place formatting instead of having to build up a new buffer for
            // preformating the argument's value.
            // Also, there is no need for the additional size checking from DhcpApiArgAdd since this was done
            // just before in this same function.
            //
            *(DWORD UNALIGNED*)Buffer += sizeof(BYTE) + sizeof(DWORD) + ThisOpt->DataLen + 1;
            *pCrtOption++ = (BYTE)(IsVendor?VendorOptionParam:NormalOptionParam);
            *(DWORD UNALIGNED*) pCrtOption = htonl((DWORD)(ThisOpt->DataLen+1));
            pCrtOption += sizeof(DWORD);
            *pCrtOption++ = (BYTE) OptionId;
            memcpy (pCrtOption, ThisOpt->Data, ThisOpt->DataLen);
            pCrtOption += ThisOpt->DataLen;
            
            DhcpPrint((
                DEBUG_OPTIONS,
                "%sOption [0x%lx] has been added\n",
                IsVendor?"Vendor ":"", OptionId
                ));
        }
    }

    DhcpAssert(Size == *BufferSize);
    return ERROR_SUCCESS;
}

DWORD
RequestParamsInternal(
    IN BYTE OpCode,
    IN PDHCP_CONTEXT DhcpContext,
    IN PDHCP_API_ARGS Args,
    IN DWORD nArgs,
    IN OUT LPBYTE Buffer,
    IN OUT LPDWORD BufferSize
)
/*++

Routine Description:

    This routine either makes a persisten request for parameters or
    attempts to retrive the requested params.  The reqeusted params value
    is obtained by parsing the Args array.

    The available set of params are filled onto the output buffer provided.

Arguments:

    OpCode -- operation
    DhcpContext -- adapter to apply operation on
    Args -- argument array
    nArgs -- number of elements in above array
    Buffer -- output buffer to use to fill requested options with
    BufferSize -- on input this is the size of the above array in bytes.
        On output this is either the number of bytes filled or the number
        of bytes required.


Return Values:

    Win32 errors

--*/
{
    LIST_ENTRY SendOptionList;
    PDHCP_OPTION SendOptionArray;
    LPBYTE ClassId, ParamRequestList, VParamRequestList;
    LPBYTE AdditionalMem;
    DWORD nParamsRequested, nVParamsRequested, ClassIdLength;
    DWORD nSendOptions, OutBufSizeAtStart, i, Error;
    DWORD CheckError, AdditionalSize;

    //
    // Initialize variables
    //
    
    ClassIdLength = 0;
    nSendOptions = 0;
    nParamsRequested = 0;
    nVParamsRequested =0;
    ParamRequestList = NULL;
    VParamRequestList = NULL;
    ClassId = NULL;

    OutBufSizeAtStart = (*BufferSize);
    (*BufferSize) = 0;

    //
    // count options and do some stuff..
    //
    
    for( i = 0; i < nArgs; i ++ ) {
        if( NormalOptionParam == Args[i].ArgId && Args[i].ArgSize &&
            OPTION_PARAMETER_REQUEST_LIST == Args[i].ArgVal[0] ) {
            DhcpAssert( Args[i].ArgSize > 1 );
            DhcpAssert(NULL == ParamRequestList );
            ParamRequestList = &Args[i].ArgVal[1];
            nParamsRequested = Args[i].ArgSize -1;
        }
        if( VendorOptionParam == Args[i].ArgId && Args[i].ArgSize &&
            OPTION_PAD == Args[i].ArgVal[0] ) {
            DhcpAssert( Args[i].ArgSize > 1 );
            DhcpAssert(NULL == VParamRequestList );
            VParamRequestList = &Args[i].ArgVal[1];
            nVParamsRequested = Args[i].ArgSize -1;
            //
            // ignore this special information
            //
            continue;
        }

        if( VendorOptionParam == Args[i].ArgId
            || NormalOptionParam == Args[i].ArgId ) {
            DhcpAssert( Args[i].ArgSize > 1 );
            nSendOptions ++;
            continue;
        }

        //
        // Check class id option.  Only one class id option allowed.
        //
        
        if( ClassIdParam == Args[i].ArgId ) {
            DhcpAssert( NULL == ClassId );
            if( 0 == Args[i].ArgSize ) {
                DhcpAssert(FALSE);
            }

            ClassId = Args[i].ArgVal;
            ClassIdLength = Args[i].ArgSize;
            continue;
        }
    }
    if( 0 == ClassIdLength ) ClassId = NULL;
    if( 0 == nParamsRequested ) ParamRequestList = NULL;
    if( 0 == nVParamsRequested ) VParamRequestList = NULL;

    DhcpAssert(nSendOptions || nVParamsRequested );
    if( 0 == nSendOptions && 0 == nVParamsRequested ) {
        return ERROR_SUCCESS;
    }

    //
    // get a correct ptr for doing class id correctly
    //
    
    if( ClassId ) {
        LOCK_OPTIONS_LIST();
        ClassId = DhcpAddClass(
            &DhcpGlobalClassesList, ClassId, ClassIdLength
            );
        UNLOCK_OPTIONS_LIST();
        if( NULL == ClassId ) return ERROR_NOT_ENOUGH_MEMORY;
    }

    if( PersistentRequestParamsOpCode == OpCode && ClassId
        && ClassId != DhcpContext->ClassId ) {

        LOCK_OPTIONS_LIST();
        (void)DhcpDelClass(&DhcpGlobalClassesList, ClassId, ClassIdLength);
        UNLOCK_OPTIONS_LIST();
        
        return ERROR_INVALID_PARAMETER;
    }

    if( PersistentRequestParamsOpCode != OpCode ) {
        //
        // since this is NOT persistent, there is no need to copy
        //

        AdditionalSize = 0;
        
    } else {
        //
        // For persistent, make copies.
        //

        AdditionalSize = 0;
        for(i = 0; i < nArgs; i ++ ) {
            if( NormalOptionParam == Args[i].ArgId ) {
            } else if( VendorOptionParam == Args[i].ArgId ) {
                if( Args[i].ArgSize && OPTION_PAD == Args[i].ArgVal[0] )
                    continue;
            } else continue;

            AdditionalSize  += Args[i].ArgSize - 1;
        }
    }

    //
    // Allocate arrays
    //
    
    SendOptionArray = DhcpAllocateMemory(
        AdditionalSize + sizeof(DHCP_OPTION)*nSendOptions
        );
    if( NULL == SendOptionArray ) return ERROR_NOT_ENOUGH_MEMORY;

    if( 0 == AdditionalSize ) {
        AdditionalMem = NULL;
    } else {
        AdditionalMem = (
            ((LPBYTE)SendOptionArray)
            + sizeof(DHCP_OPTION)*nSendOptions
            );
    }

    //
    // collect all the options to send into the array
    //
    
    InitializeListHead(&SendOptionList);
    nSendOptions = 0;
    for( i = 0; i < nArgs ; i ++ ) {
        if( NormalOptionParam == Args[i].ArgId )
            SendOptionArray[nSendOptions].IsVendor = FALSE;
        else if( VendorOptionParam == Args[i].ArgId ) {
            if( Args[i].ArgSize && OPTION_PAD == Args[i].ArgVal[0] )
                continue;
            SendOptionArray[nSendOptions].IsVendor = TRUE;
        } else continue;

        if( 0 == Args[i].ArgSize ) continue;

        SendOptionArray[nSendOptions].OptionId = Args[i].ArgVal[0];
        SendOptionArray[nSendOptions].ClassName = ClassId;
        SendOptionArray[nSendOptions].ClassLen = ClassIdLength;
        SendOptionArray[nSendOptions].ExpiryTime = 0;
        SendOptionArray[nSendOptions].Data = (Args[i].ArgSize == 1)?NULL:&Args[i].ArgVal[1];
        SendOptionArray[nSendOptions].DataLen = Args[i].ArgSize -1;
        InsertTailList(&SendOptionList, &SendOptionArray[nSendOptions].OptionList);

        DhcpPrint((
            DEBUG_OPTIONS, "Added %soption [0x%lx] with [0x%lx] bytes\n",
            SendOptionArray[nSendOptions].IsVendor?"vendor ":"",
            SendOptionArray[nSendOptions].OptionId,
            SendOptionArray[nSendOptions].DataLen
        ));
        if( AdditionalMem  && SendOptionArray[nSendOptions].DataLen ) {
            memcpy(AdditionalMem, SendOptionArray[nSendOptions].Data, SendOptionArray[nSendOptions].DataLen );
            SendOptionArray[nSendOptions].Data = AdditionalMem;
            AdditionalMem += SendOptionArray[nSendOptions].DataLen;
        }
        nSendOptions++;
    }

    *BufferSize = OutBufSizeAtStart;
    Error = RequestParamsDetailed(
        OpCode,
        DhcpContext,
        ClassId,
        ClassIdLength,
        ParamRequestList,
        nParamsRequested,
        VParamRequestList,
        nVParamsRequested,
        &SendOptionList,
        Buffer,
        BufferSize
    );

    if( RequestParamsOpCode == OpCode) {
        DhcpFreeMemory(SendOptionArray);
        if( ClassId ) {
            LOCK_OPTIONS_LIST();
            CheckError = DhcpDelClass(
                &DhcpGlobalClassesList, ClassId, ClassIdLength
                );
            UNLOCK_OPTIONS_LIST();
            DhcpAssert(ERROR_SUCCESS == CheckError);
        }
    }

    return Error;
}

DWORD
RequestParams(
    IN PDHCP_CONTEXT DhcpContext,
    IN PDHCP_API_ARGS Args,
    IN DWORD nArgs,
    IN OUT LPBYTE Buffer,
    IN OUT LPDWORD BufferSize
)
/*++

Routine Description:

    Request Parameters stub. See RequestParamsInternal.
    

--*/
{
    return RequestParamsInternal(
        RequestParamsOpCode, DhcpContext,
        Args,nArgs, Buffer,BufferSize
        );
}

DWORD
PersistentRequestParams(
    IN PDHCP_CONTEXT DhcpContext,
    IN PDHCP_API_ARGS Args,
    IN DWORD nArgs,
    IN OUT LPBYTE Buffer,
    IN OUT LPDWORD BufferSize
)
/*++

Routine Description:

    Request Parameters stub. See RequestParamsInternal.
    

--*/
{
    return RequestParamsInternal(
        PersistentRequestParamsOpCode, DhcpContext,
        Args,nArgs,Buffer,BufferSize
        );
}

DWORD
PlumbStaticIP(
    PDHCP_CONTEXT dhcpContext
    )
{
    DWORD               Error;
    int                 i, Count, plumbed_cnt;
    PIP_SUBNET          IpSubnetArray;
    PLOCAL_CONTEXT_INFO LocalInfo;
    CHAR                ipstr[32], subnetstr[32];

    DhcpAssert (IS_DHCP_DISABLED(dhcpContext));

    DhcpPrint((DEBUG_MISC, "Plumb static IP/subnet mask into TCP\n"));

    LocalInfo = dhcpContext->LocalInformation;

    //
    // Don't do anything for WAN and Unidirectional adapter.
    //
    if (NdisWanAdapter(dhcpContext) || IS_UNIDIRECTIONAL(dhcpContext)) {
        return ERROR_SUCCESS;
    }

    //
    // TCP guys use REG_MULTI_SZ. We need to parse the string and add all the IP/Subnet Mask
    // to TCP. The first IP/subnet mask is primary address which should be added through IPSetIPAddress.
    // The remaining should be added through IPAddIPAddress.
    //
    Error = RegGetIpAndSubnet(
                dhcpContext,
                &IpSubnetArray,
                &Count);
    if( Error != ERROR_SUCCESS ) {
        DhcpPrint(( DEBUG_ERRORS, "Faied to read static IpAddress:0x%ld\n", Error));
        DhcpAssert(IpSubnetArray == NULL);
        return(Error);
    }
    DhcpAssert(IpSubnetArray);
    DhcpAssert(Count);

    /*
     * No need to reset the stack.
     */
    //IPResetInterface(LocalInfo->IpInterfaceContext);
    //IPDelNonPrimaryAddresses(LocalInfo->AdapterName);
    //IPDelIPAddress(LocalInfo->IpInterfaceContext);

    for (plumbed_cnt = i = 0; i < Count; i++) {
        DhcpPrint((DEBUG_MISC, "%d. Plumbing IP=%s Mask=%s\n",
                i, strcpy(ipstr, inet_ntoa(*(struct in_addr *)&IpSubnetArray[i].IpAddress)),
                strcpy(subnetstr, inet_ntoa(*(struct in_addr *)&IpSubnetArray[i].SubnetMask))));
        if (i == 0) {
            /* Primary IP address */
            Error = IPSetIPAddress(                       // set new ip address, mask with ip
                LocalInfo->IpInterfaceContext,            // identify context
                IpSubnetArray[i].IpAddress,
                IpSubnetArray[i].SubnetMask
            );
            if (Error == ERROR_DUP_NAME) {
                dhcpContext->ConflictAddress = IpSubnetArray[i].IpAddress;
                break;
            }
        } else {
            Error = IPAddIPAddress(            // add new ip address, mask with ip
                LocalInfo->AdapterName,
                IpSubnetArray[i].IpAddress,
                IpSubnetArray[i].SubnetMask
            );
        }
        if (Error != ERROR_SUCCESS) {
            DhcpPrint(( DEBUG_ERRORS, "Add IP=%s SubnetMask=%s Faied: %ld\n",
                            strcpy(ipstr, inet_ntoa(*(struct in_addr *)&IpSubnetArray[i].IpAddress)),
                            strcpy(subnetstr, inet_ntoa(*(struct in_addr *)&IpSubnetArray[i].SubnetMask)),
                            Error));
        } else {
            plumbed_cnt ++;
        }
    }
    DhcpFreeMemory(IpSubnetArray);
    if (plumbed_cnt) {
        return ERROR_SUCCESS;
    } else {
        if (Error != ERROR_DUP_NAME) {
            Error = ERROR_UNEXP_NET_ERR;
        }
        return Error;
    }
}

#ifdef NEWNT
DWORD
StaticRefreshParamsEx(
    IN OUT PDHCP_CONTEXT DhcpContext, OPTIONAL
    IN DWORD Flags
)
/*++

Routine Description:

    Refresh DNS, gateways etc parameters from the registry..

Arguments:

   DhcpContext -- context to refresh for. OPTIONAL.
       NULL indicates refresh all contexts.
   Flags -- 0 ==> register with dns, non-zero implies don't
       register with dns.

Return Values:

   Win32 errors.

--*/
{
    DWORD Error;
    DHCP_FULL_OPTIONS DummyOptions;

    if( NULL == DhcpContext ) {

        //
        // DNS host name change? start main thread and don't worry..
        //
        DhcpGlobalDoRefresh ++;
        return ERROR_SUCCESS;
    }

    LOCK_OPTIONS_LIST();
    if( NULL != DhcpContext->ClassId ) {

        //
        // if we got a class id already.. then just delete it..
        //
        (void)DhcpDelClass(
            &DhcpGlobalClassesList, DhcpContext->ClassId,
            DhcpContext->ClassIdLength
            );
        DhcpContext->ClassId = NULL; DhcpContext->ClassIdLength = 0;
    }
    DhcpRegReadClassId(DhcpContext);
    UNLOCK_OPTIONS_LIST();

    if( IS_DHCP_ENABLED(DhcpContext) ) {

        //
        // RegisterWithDns takes care of details.
        //

        DhcpPrint((DEBUG_DNS, "Reregistering DNS for %ws\n",
                   DhcpAdapterName(DhcpContext)));
        RtlZeroMemory(&DummyOptions, sizeof(DummyOptions));

        DhcpRegisterWithDns(DhcpContext, FALSE);

        //
        // Refresh gateways information.
        //

        DhcpSetGateways(DhcpContext, &DummyOptions, FALSE);
        DhcpSetStaticRoutes(DhcpContext, &DummyOptions);

        //
        // Attempt to renew lease as well
        //
        
        ScheduleWakeUp( DhcpContext, 0 );

    }
    else
    {
    
        Error = DhcpRegFillParams(DhcpContext, FALSE);
        DhcpAssert(ERROR_SUCCESS == Error);

        if (PlumbStaticIP(DhcpContext) == ERROR_DUP_NAME) {
            DhcpLogEvent(DhcpContext, EVENT_ADDRESS_CONFLICT, 1);
        }
        if( 0 == (Flags & 0x01) ) {

            //
            // Do not do DNS updates if Flags's last bit is set..
            //
            memset(&DummyOptions, 0, sizeof(DummyOptions));

            Error = DhcpSetAllStackParameters(
                DhcpContext, &DummyOptions
                );
            if( ERROR_SUCCESS != Error ) {
                DhcpPrint((
                    DEBUG_ERRORS, "StaticRefreshParams:"
                    "DhcpSetAllStackParameters:0x%lx\n", Error
                    ));
            }
        }

        if(!NdisWanAdapter(DhcpContext))
            (void)NotifyDnsCache();

        //
        // Dont care if things go wrong in this routine.
        // If we return error here, then changing static to dhcp etc
        // all give trouble.
        //
    }
    
    // either way notify NLA something changed for this context
    NLANotifyDHCPChange();

    return NO_ERROR;
}

DWORD
StaticRefreshParams(
    IN OUT PDHCP_CONTEXT DhcpContext
)
{
    return StaticRefreshParamsEx(
        DhcpContext, 0);
}

#endif

DWORD
DhcpDecodeRegistrationParams(
    IN PDHCP_API_ARGS ArgArray,
    IN DWORD nArgs,
    IN OUT LPDWORD ProcId,
    IN OUT LPDWORD Descriptor,
    IN OUT LPHANDLE Handle
)
/*++

Routine Description:

    This routine walks throug the arguments array looking for the processor
    ID, the descriptor and the handle fields that are required as parameters
    for the registration routine.

Arguments:

    ArgArray -- array of args to parse
    nArgs -- size of above array
    ProcId -- process id
    Descriptor -- unique descriptor
    Handle -- handle to event

Return Values:

    Win32 errors.

--*/
{
    BOOL FoundProcId, FoundDescriptor, FoundHandle;
    DWORD i;

    FoundProcId = FoundDescriptor = FoundHandle = FALSE;
    
    for( i = 0; i < nArgs; i ++ ) {
        switch(ArgArray[i].ArgId) {

        case ProcIdParam:
            if( FoundProcId ) return ERROR_INVALID_PARAMETER;
            DhcpAssert(sizeof(DWORD) == ArgArray[i].ArgSize);
            (*ProcId) = ((DWORD UNALIGNED*)(ArgArray[i].ArgVal))[0];
            FoundProcId = TRUE;
            continue;

        case DescriptorParam:
            if( FoundDescriptor ) return ERROR_INVALID_PARAMETER;
            DhcpAssert(sizeof(DWORD) == ArgArray[i].ArgSize);
            (*Descriptor) = ((DWORD UNALIGNED*)(ArgArray[i].ArgVal))[0];
            FoundDescriptor = TRUE;
            continue;

        case EventHandleParam:
            if( FoundHandle ) return ERROR_INVALID_PARAMETER;
            DhcpAssert(sizeof(HANDLE) == ArgArray[i].ArgSize);
            (*Handle) = ((HANDLE UNALIGNED*)(ArgArray[i].ArgVal))[0];
            FoundHandle = TRUE;
            continue;
        }
        
    }

    //
    // it is valid to not find a descriptor -- use 0
    // valid in the case of de-registration.
    // But ProcId and handle are required.
    //
    
    if( !FoundProcId ) return ERROR_INVALID_PARAMETER;
    if( !FoundHandle ) return ERROR_INVALID_PARAMETER;
    if( !FoundDescriptor ) {
        (*Descriptor) = 0;
    }

    return ERROR_SUCCESS;
}


DWORD
RegisterParams(
    IN LPWSTR AdapterName,
    IN PDHCP_API_ARGS ArgArray,
    IN DWORD nArgs
)
/*++

Routine Description:

    This routine registers the required set of options, so that the
    specified event is signaled whenever the options are modfieid.

Arguments:

    AdapterName -- adapter to register for
    ArgArray -- array of args 
    nArgs -- size of above array.

Return Values:

    Win32 errors

--*/
{
    HANDLE ApiHandle;
    //
    // valid only in the API context, not here.
    //

    DWORD ProcId, Descriptor, Error;
    DWORD i, nOpts, nVendorOpts,ClassIdLength; 
    LPBYTE OptList, VendorOptList, ClassId;

    //
    // First decode the requried params.
    //
    
    Error = DhcpDecodeRegistrationParams(
        ArgArray, nArgs, &ProcId, &Descriptor, &ApiHandle
        );
    if( ERROR_SUCCESS != Error ) return Error;

    if( 0 == ApiHandle || 0 == Descriptor ) {
        
        return ERROR_INVALID_PARAMETER;
    }

    OptList = VendorOptList = NULL;
    nOpts = nVendorOpts = ClassIdLength = 0;

    //
    // Parse for options list to register for.
    //
    
    for( i = 0; i < nArgs ; i ++ ) {
        if( NormalOptionParam == ArgArray[i].ArgId ) {
            if( 0 != nOpts ) return ERROR_INVALID_PARAMETER;
            nOpts = ArgArray[i].ArgSize;
            OptList = ArgArray[i].ArgVal;
            if( 0 == nOpts ) return ERROR_INVALID_PARAMETER;
        }

        if( VendorOptionParam == ArgArray[i].ArgId ) {
            if( 0 != nVendorOpts) return ERROR_INVALID_PARAMETER;
            nVendorOpts = ArgArray[i].ArgSize;
            VendorOptList = ArgArray[i].ArgVal;
            if( 0 == nVendorOpts ) return ERROR_INVALID_PARAMETER;
        }
        
        if( ClassIdParam == ArgArray[i].ArgId ) {
            if( ClassIdLength ) return ERROR_INVALID_PARAMETER;
            ClassIdLength = ArgArray[i].ArgSize;
            ClassId = ArgArray[i].ArgVal;
            if( 0 == ClassIdLength ) return ERROR_INVALID_PARAMETER;
        }
    }

    if( 0 == nOpts + nVendorOpts ) {

        return ERROR_INVALID_PARAMETER;
    }

    //
    // Add the request.
    //
    
    if( nOpts ) {
        Error = DhcpAddParamChangeRequest(
            AdapterName,
            ClassId,
            ClassIdLength,
            OptList,
            nOpts,
            FALSE /* not vendor specific */,
            ProcId,
            Descriptor,
            ApiHandle
        );

        DhcpAssert(ERROR_SUCCESS == Error);
        if( ERROR_SUCCESS != Error ) {

            return Error;
        }
    }

    if( nVendorOpts ) {
        Error = DhcpAddParamChangeRequest(
            AdapterName,
            ClassId,
            ClassIdLength,
            VendorOptList,
            nVendorOpts,
            TRUE /* is vendor specific */,
            ProcId,
            Descriptor,
            ApiHandle
        );
        DhcpAssert(ERROR_SUCCESS == Error);
        if( ERROR_SUCCESS != Error ) {
            if( nOpts ) {

                //
                // if there was some part of it that we registered before,
                // deregister that
                //
    
                (void)DhcpDelParamChangeRequest(
                    ProcId, ApiHandle
                    );
            }

            return Error;
        }
    }

    return ERROR_SUCCESS;
}

DWORD
DeRegisterParams(
    IN LPWSTR AdapterName,
    IN PDHCP_API_ARGS ArgArray,
    IN DWORD nArgs
)
/*++

Routine Description:

    This is the converse of the RegisterParams routine.
    It removes the registration so that no more notifications will be done
    for this request.

Arguments:

    AdapterName -- name of adapter.
    ArgArray -- array of args
    nArgs -- size of above array

Return Values:

    Win32 errors.

--*/
{
    DWORD Error, ProcId, Descriptor;
    HANDLE ApiHandle;

    //
    // Parse for required list of params.
    //
    
    Error = DhcpDecodeRegistrationParams(
        ArgArray, nArgs, &ProcId, &Descriptor, &ApiHandle
        );
    if( ERROR_SUCCESS != Error ) return Error;

    //
    // remove notification registration
    //
    
    return DhcpDelParamChangeRequest(
        ProcId, ApiHandle
        );
}

//
//  End of file
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\client\dhcp\autonet.c ===
/*++

Copyright (C) 1997 Microsoft Corporation

Module Name:
    autonet.c

Abstract:
    autonet hashing algorithm.

--*/

#include "precomp.h"

#define DHCP_IPAUTOCONFIGURATION_ATTEMPTS   10

DHCP_IP_ADDRESS
GrandHashing(
    IN LPBYTE HwAddress,
    IN DWORD HwLen,
    IN OUT LPDWORD Seed,
    IN DHCP_IP_ADDRESS Mask,
    IN DHCP_IP_ADDRESS Subnet
)
/*++

Routine Description:
    This routine produces a random IP address in the subnet given
    by the "Mask" and "Subnet" parameters.

    To do this, it uses the Seed and HwAddress to create
    randomness. Also, the routine updates the seed value so that
    future calls with same set of parameters can produce newer IP
    addresses.

Arguments:
    HwAddress -- hardware address to use to hash
    HwLen -- length of above in bytes.
    Seed -- pointer to a DWORD holding a seed value that will be
        updated on call.
    Mask -- subnet mask.
    Subnet -- subnet address.

Return Values:
    IP address belonging to "Subnet" that is quite randomly
    chosen. 

--*/
{
    DWORD Hash, Shift;
    DWORD i;

    //
    // generate 32 bit random number
    //
    
    for( i = 0; i < HwLen ; i ++ ) {
        (*Seed) += HwAddress[i];
    }

    *Seed = (*Seed)*1103515245 + 12345 ;
    Hash = (*Seed) >> 16 ;
    Hash <<= 16;
    *Seed = (*Seed)*1103515245 + 12345 ;
    Hash += (*Seed) >> 16;

    //
    // Now Hash contains the 32 bit Random # we need.
    // "Shift" holds the number of bytes the hwaddress would be
    // cyclically shifted to induce more randomness.
    
    Shift = Hash % sizeof(DWORD) ; 

    while( HwLen -- ) {
        Hash += (*HwAddress++) << (8 * Shift);
        Shift = (Shift + 1 )% sizeof(DWORD);
    }

    //
    // Now Hash holds a weird random number.
    //
    
    return (Hash & ~Mask) | Subnet ;
}

DWORD
DhcpPerformIPAutoconfiguration(
    IN OUT DHCP_CONTEXT *pCtxt
)
/*++

Routine Description:
    This routine attempts to plumb an autoconfigured IP address
    by first randomly selecting an IP address. (If there is
    already an autoconfigured IP address, the same address is
    chosen for continuity.)

    The address is verified by TCPIP for conflicts, and in case
    of conflicts, another attempt is made (to a total of 10
    attempts).

Parameters:
    pCtxt -- the context to plumb with autonet address.

Return Values:
    win32 errors.
    ERROR_DHCP_ADDRESS_CONFLICT -- if no address was set..
    
--*/
{
    DWORD Try, Result, Seed, HwLen;
    DHCP_IP_ADDRESS AttemptedAddress, Mask, Subnet;
    LPBYTE HwAddress;

    DhcpAssert( IS_AUTONET_ENABLED(pCtxt) );

    //
    // Store values in locals for easy typing.
    //
    
    Mask = pCtxt->IPAutoconfigurationContext.Mask ;
    Subnet = pCtxt->IPAutoconfigurationContext.Subnet ;
    HwAddress = pCtxt->HardwareAddress ;
    HwLen = pCtxt->HardwareAddressLength ;
    Seed = pCtxt->IPAutoconfigurationContext.Seed;

    //
    // If already have autonet address, chose the same as first try.
    //
    
    if( 0 != pCtxt->IPAutoconfigurationContext.Address ) {
        AttemptedAddress = pCtxt->IPAutoconfigurationContext.Address ;
    } else {
        AttemptedAddress = GrandHashing( HwAddress, HwLen, &Seed, Mask, Subnet );
    }

    Try = 0;

    while( Try <  DHCP_IPAUTOCONFIGURATION_ATTEMPTS ) {
        DhcpPrint((
            DEBUG_TRACE, "Trying autoconf address: %s\n",
            inet_ntoa(*(struct in_addr *)&AttemptedAddress)
            ));

        if( DHCP_RESERVED_AUTOCFG_FLAG &&
            (AttemptedAddress&inet_addr(DHCP_RESERVED_AUTOCFG_MASK)) ==
            inet_addr(DHCP_RESERVED_AUTOCFG_SUBNET) ) {

            //
            // address is in reserved range, dont use it..
            //
            DhcpPrint((
                DEBUG_TRACE, "Address fell in reserved range\n" 
                ));
            pCtxt->IPAutoconfigurationContext.Seed = Seed;
            AttemptedAddress = GrandHashing(
                HwAddress, HwLen, &Seed, Mask, Subnet
                );
            continue;
        } 

        //
        // Attempt to set the address.
        //
        Try ++;
        
        Result = SetAutoConfigurationForNIC(
            pCtxt,
            pCtxt->IPAutoconfigurationContext.Address = AttemptedAddress,
            pCtxt->IPAutoconfigurationContext.Mask
        );

        //
        // If this failed, we have to advance seed, so that
        // on next attempt we try different address.
        //
        if( ERROR_SUCCESS != Result ) {
            pCtxt->IPAutoconfigurationContext.Seed = Seed;
            //pCtxt->IPAutoconfigurationContext.Address = 0;
            DhcpPrint((
                DEBUG_ERRORS, "SetAutoConfigurationForNIC(%s): %ld\n",
                inet_ntoa(*(struct in_addr *)&AttemptedAddress),
                Result
                ));
        }

        //
        // Handle address conflicts..
        //
        
        if( ERROR_DHCP_ADDRESS_CONFLICT == Result ) {
            Result = HandleIPAutoconfigurationAddressConflict(
                pCtxt
                );

            if( ERROR_SUCCESS != Result ) break;
        } else break;

        // if anything went wrong on plumbing in the fallback
        // config (conflict included), there is no need to try
        // further. So, simulate an exhaust of all loops and break out.
        if (IS_FALLBACK_ENABLED(pCtxt))
        {
            Try = DHCP_IPAUTOCONFIGURATION_ATTEMPTS;
            break;
        }
        //
        // Make more attempts.
        // 
        AttemptedAddress = GrandHashing( HwAddress, HwLen, &Seed, Mask, Subnet );
    }

    if( DHCP_IPAUTOCONFIGURATION_ATTEMPTS == Try ) {
        //
        //  Tried everything and could not still match
        //
        Result = SetAutoConfigurationForNIC(
            pCtxt, 0, 0
            );
        if (ERROR_SUCCESS != Result) {
            DhcpPrint((DEBUG_ERRORS, "Result = %d\n", Result));
        }
        Result = ERROR_DHCP_ADDRESS_CONFLICT;
        DhcpPrint((DEBUG_ERRORS, "Gave up autoconfiguration\n"));
    }

    return Result;
}

//================================================================================
//  End of file
//================================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\client\dhcp\optchg.c ===
#include "precomp.h"
#include "dhcpglobal.h"

#ifdef H_ONLY
//================================================================================
// Copyright (c) 1997 Microsoft Corporation
// Author: RameshV
// Description: handles the noticiations and other mechanisms for parameter
//      changes (options )
//================================================================================

#ifndef OPTCHG_H_INCLUDED
#define OPTCHG_H_INCLUDED

//================================================================================
// exported APIS
//================================================================================
DWORD                                             // win32 status
DhcpAddParamChangeRequest(                        // add a new param change notification request
    IN      LPWSTR                 AdapterName,   // for this adapter, can be NULL
    IN      LPBYTE                 ClassId,       // what class id does this belong to?
    IN      DWORD                  ClassIdLength, // how big is this class id?
    IN      LPBYTE                 OptList,       // this is the list of options of interest
    IN      DWORD                  OptListSize,   // this is the # of bytes of above
    IN      BOOL                   IsVendor,      // is this vendor specific?
    IN      DWORD                  ProcId,        // which is the calling process?
    IN      DWORD                  Descriptor,    // what is the unique descriptor in this process?
    IN      HANDLE                 Handle         // what is the handle in the calling process space?
);

DWORD                                             // win32 status
DhcpDelParamChangeRequest(                        // delete a particular request
    IN      DWORD                  ProcId,        // the process id of the caller
    IN      HANDLE                 Handle         // the handle as used by the calling process
);

DWORD                                             // win32 status
DhcpMarkParamChangeRequests(                      // find all params that are affected and mark then as pending
    IN      LPWSTR                 AdapterName,   // adapter of relevance
    IN      DWORD                  OptionId,      // the option id itself
    IN      BOOL                   IsVendor,      // is this vendor specific
    IN      LPBYTE                 ClassId        // which class --> this must be something that has been ADD-CLASSED
);

typedef DWORD (*DHCP_NOTIFY_FUNC)(                // this is the type of the fucntion that actually notifies clients of option change
    IN      DWORD                  ProcId,        // <ProcId + Descriptor> make a unique key used for finding the event
    IN      DWORD                  Descriptor     // --- on Win98, only Descriptor is really needed.
);                                                // if return value is NOT error success, we delete this request

DWORD                                             // win32 status
DhcpNotifyMarkedParamChangeRequests(              // notify pending param change requests
    IN      DHCP_NOTIFY_FUNC       NotifyHandler  // call this function for each unique id that is present
);

DWORD                                             // win32 status
DhcpAddParamRequestChangeRequestList(             // add to the request list the list of params registered for notifications
    IN      LPWSTR                 AdapterName,   // which adatper is this request list being requested for?
    IN      LPBYTE                 Buffer,        // buffer to add options to
    IN OUT  LPDWORD                Size,          // in: existing filled up size, out: total size filled up
    IN      LPBYTE                 ClassName,     // ClassId
    IN      DWORD                  ClassLen       // size of ClassId in bytes
);

DWORD                                             // win32 status
DhcpNotifyClientOnParamChange(                    // notify clients
    IN      DWORD                  ProcId,        // which process called this
    IN      DWORD                  Descriptor     // unique descriptor for that process
);

DWORD                                             // win32 status
DhcpInitializeParamChangeRequests(                // initialize everything in this file
    VOID
);

VOID
DhcpCleanupParamChangeRequests(                   // unwind this module
    VOID
);

#endif OPTCHG_H_INCLUDED
#else  H_ONLY

#include <dhcpcli.h>
#include <optchg.h>

typedef struct _DHCP_PARAM_CHANGE_REQUESTS {      // each param change request looks like this
    LIST_ENTRY                     RequestList;
    LPWSTR                         AdapterName;   // which is the concerned adapter?
    LPBYTE                         ClassId;       // which class id does this belong to, huh?
    DWORD                          ClassIdLength; // unused, but denotes the # of bytes of above
    LPBYTE                         OptList;       // the list of options that need to be affected
    DWORD                          OptListSize;   // size of above list
    BOOL                           IsVendor;      // is this vendor specific?
    DWORD                          Descriptor;    // <procid+descriptor> is a unique key
    DWORD                          ProcId;        // the process which asked for this registration
    HANDLE                         Handle;        // the handle used by the api's caller
    BOOL                           NotifyPending; // is there a notification pending?
} DHCP_PARAM_CHANGE_REQUESTS, *PDHCP_PARAM_CHANGE_REQUESTS, *LPDHCP_PARAM_CHANGE_REQUESTS;

STATIC
LIST_ENTRY                         ParamChangeRequestList; // this is the static list used for keeping the requests

DWORD                                             // win32 status
DhcpAddParamChangeRequest(                        // add a new param change notification request
    IN      LPWSTR                 AdapterName,   // for this adapter, can be NULL
    IN      LPBYTE                 ClassId,       // what class id does this belong to?
    IN      DWORD                  ClassIdLength, // how big is this class id?
    IN      LPBYTE                 OptList,       // this is the list of options of interest
    IN      DWORD                  OptListSize,   // this is the # of bytes of above
    IN      BOOL                   IsVendor,      // is this vendor specific?
    IN      DWORD                  ProcId,        // which is the calling process?
    IN      DWORD                  Descriptor,    // what is the unique descriptor in this process?
    IN      HANDLE                 Handle         // what is the handle in the calling process space?
) {
    LPBYTE                         NewClass;
    PDHCP_PARAM_CHANGE_REQUESTS    PChange;
    DWORD                          PChangeSize;
    DWORD                          OptListOffset;
    DWORD                          AdapterNameOffset;

    PChangeSize = ROUND_UP_COUNT(sizeof(*PChange), ALIGN_WORST);
    OptListOffset = PChangeSize;
    PChangeSize += OptListSize;
    PChangeSize = ROUND_UP_COUNT(PChangeSize, ALIGN_WORST);
    AdapterNameOffset = PChangeSize;
    if( AdapterName ) {
        PChangeSize += sizeof(WCHAR) * (wcslen(AdapterName)+1);
    }
    PChange = DhcpAllocateMemory(PChangeSize);
    if( NULL == PChange ) return ERROR_NOT_ENOUGH_MEMORY;

    if( ClassIdLength ) {
        LOCK_OPTIONS_LIST();
        NewClass = DhcpAddClass(&DhcpGlobalClassesList,ClassId,ClassIdLength);
        UNLOCK_OPTIONS_LIST();
        if( NULL == NewClass ) {
            DhcpFreeMemory(PChange);
            return ERROR_NOT_ENOUGH_MEMORY;
        }
        PChange->ClassId = NewClass;
        PChange->ClassIdLength = ClassIdLength;
    } else NewClass = NULL;

    if( AdapterName ) {
        PChange->AdapterName = (LPWSTR) (((LPBYTE)PChange)+AdapterNameOffset);
        wcscpy(PChange->AdapterName, AdapterName);
    } else PChange->AdapterName = NULL;

    if( OptListSize ) {
        PChange->OptList = ((LPBYTE)PChange) + OptListOffset;
        memcpy(PChange->OptList, OptList, OptListSize);
        PChange->OptListSize = OptListSize;
    } else {
        PChange->OptListSize = 0;
        PChange->OptList = NULL;
    }

    PChange->IsVendor = IsVendor;
    PChange->ProcId = ProcId;
    PChange->Descriptor = Descriptor;
    PChange->Handle = Handle;
    PChange->NotifyPending = FALSE;

    LOCK_OPTIONS_LIST();
    InsertHeadList(&ParamChangeRequestList, &PChange->RequestList);
    UNLOCK_OPTIONS_LIST();

    return ERROR_SUCCESS;
}

DWORD                                             // win32 status
DhcpDelParamChangeRequest(                        // delete a particular request
    IN      DWORD                  ProcId,        // the process id of the caller
    IN      HANDLE                 Handle         // the handle as used by the calling process
) {
    PLIST_ENTRY                    ThisEntry;
    PDHCP_PARAM_CHANGE_REQUESTS    ThisRequest;
    DWORD                          Error;

    Error = ERROR_FILE_NOT_FOUND;
    LOCK_OPTIONS_LIST();
    ThisEntry = ParamChangeRequestList.Flink;

    while(ThisEntry != &ParamChangeRequestList) {
        ThisRequest = CONTAINING_RECORD(ThisEntry, DHCP_PARAM_CHANGE_REQUESTS, RequestList);
        ThisEntry   = ThisEntry->Flink;

        if( ProcId && ThisRequest->ProcId != ProcId )
            continue;

        if( 0 == Handle || ThisRequest->Handle == Handle ) {
            RemoveEntryList(&ThisRequest->RequestList);
            if( ThisRequest->ClassIdLength ) {
                Error = DhcpDelClass(&DhcpGlobalClassesList, ThisRequest->ClassId, ThisRequest->ClassIdLength);
                DhcpAssert(ERROR_SUCCESS == Error);
            }
            DhcpFreeMemory(ThisRequest);
            Error = ERROR_SUCCESS;
        }
    }
    UNLOCK_OPTIONS_LIST();
    return Error;
}

DWORD                                             // win32 status
DhcpMarkParamChangeRequests(                      // find all params that are affected and mark then as pending
    IN      LPWSTR                 AdapterName,   // adapter of relevance
    IN      DWORD                  OptionId,      // the option id itself
    IN      BOOL                   IsVendor,      // is this vendor specific
    IN      LPBYTE                 ClassId        // which class --> this must be something that has been ADD-CLASSED
) {
    PLIST_ENTRY                    ThisEntry;
    PDHCP_PARAM_CHANGE_REQUESTS    ThisRequest;
    DWORD                          i;

    if ( !AdapterName ) return ERROR_INVALID_PARAMETER;

    // at this point the call should be related with a Service (not an API) context change.

    LOCK_OPTIONS_LIST();
    ThisEntry = ParamChangeRequestList.Flink;

    while(ThisEntry != &ParamChangeRequestList) {
        ThisRequest = CONTAINING_RECORD(ThisEntry, DHCP_PARAM_CHANGE_REQUESTS, RequestList);
        ThisEntry   = ThisEntry->Flink;

        if( ThisRequest->NotifyPending ) continue;// if already notified, dont bother about checking it
        if( ThisRequest->IsVendor != IsVendor ) continue;
        if( ClassId && ThisRequest->ClassId && ClassId != ThisRequest->ClassId )
            continue;
        if( ThisRequest->AdapterName && AdapterName && 0 != wcscmp(AdapterName,ThisRequest->AdapterName))
            continue;

        if( 0 == ThisRequest->OptListSize ) {
            ThisRequest->NotifyPending = TRUE;
            continue;
        }

        for(i = 0; i < ThisRequest->OptListSize; i ++ ) {
            if( OptionId == ThisRequest->OptList[i] ) {
                ThisRequest->NotifyPending = TRUE;
                break;
            }
        }

        ThisRequest->NotifyPending = TRUE;
    }

    UNLOCK_OPTIONS_LIST();
    return ERROR_SUCCESS;
}

DWORD                                             // win32 status
DhcpNotifyMarkedParamChangeRequests(              // notify pending param change requests
    IN      DHCP_NOTIFY_FUNC       NotifyHandler  // call this function for each unique id that is present
) {
    PLIST_ENTRY                    ThisEntry;
    PDHCP_PARAM_CHANGE_REQUESTS    ThisRequest;
    DWORD                          Error;

    LOCK_OPTIONS_LIST();
    ThisEntry = ParamChangeRequestList.Flink;

    while(ThisEntry != &ParamChangeRequestList) {
        ThisRequest = CONTAINING_RECORD(ThisEntry, DHCP_PARAM_CHANGE_REQUESTS, RequestList);
        ThisEntry   = ThisEntry->Flink;

        if( ThisRequest->NotifyPending ) {
            ThisRequest->NotifyPending = FALSE;
            Error = NotifyHandler(ThisRequest->ProcId, ThisRequest->Descriptor);
            if( ERROR_SUCCESS == Error) continue;
            DhcpPrint((DEBUG_ERRORS, "NotifyHandler(0x%lx,0x%lx):0x%lx\n",
                       ThisRequest->ProcId, ThisRequest->Descriptor, Error));
            RemoveEntryList(&ThisRequest->RequestList);
            if( ThisRequest->ClassIdLength ) {
                Error = DhcpDelClass(&DhcpGlobalClassesList,ThisRequest->ClassId,ThisRequest->ClassIdLength);
                DhcpAssert(ERROR_SUCCESS == Error);
            }
            DhcpFreeMemory(ThisRequest);
        }
    }
    UNLOCK_OPTIONS_LIST();
    return ERROR_SUCCESS;
}


DWORD                                             // win32 status
DhcpAddParamRequestChangeRequestList(             // add to the request list the list of params registered for notifications
    IN      LPWSTR                 AdapterName,   // which adatper is this request list being requested for?
    IN      LPBYTE                 Buffer,        // buffer to add options to
    IN OUT  LPDWORD                Size,          // in: existing filled up size, out: total size filled up
    IN      LPBYTE                 ClassName,     // ClassId
    IN      DWORD                  ClassLen       // size of ClassId in bytes
) {
    PLIST_ENTRY                    ThisEntry;
    PDHCP_PARAM_CHANGE_REQUESTS    ThisRequest;
    DWORD                          Error;
    DWORD                          i,j;

    LOCK_OPTIONS_LIST();
    ThisEntry = ParamChangeRequestList.Flink;

    while(ThisEntry != &ParamChangeRequestList) {
        ThisRequest = CONTAINING_RECORD(ThisEntry, DHCP_PARAM_CHANGE_REQUESTS, RequestList);
        ThisEntry   = ThisEntry->Flink;

        if( ThisRequest->IsVendor) continue;
        if( ClassName && ThisRequest->ClassId && ClassName != ThisRequest->ClassId )
            continue;
        if( ThisRequest->AdapterName && AdapterName && 0 != wcscmp(AdapterName,ThisRequest->AdapterName))
            continue;

        for( i = 0; i < ThisRequest->OptListSize; i ++ ) {
            for( j = 0; j < (*Size); j ++ )
                if( ThisRequest->OptList[i] == Buffer[j] )
                    break;
            if( j < (*Size) ) continue;
            Buffer[(*Size)++] = ThisRequest->OptList[i];
        }
    }
    UNLOCK_OPTIONS_LIST();
    return ERROR_SUCCESS;
}

DWORD                                             // win32 status
DhcpNotifyClientOnParamChange(                    // notify clients
    IN      DWORD                  ProcId,        // which process called this
    IN      DWORD                  Descriptor     // unique descriptor for that process
) {
#ifdef NEWNT
    BYTE                           Name[sizeof("DhcpPid-1-2-3-4-5-6-7-8UniqueId-1-2-3-4-5-6-7-8")];
    HANDLE                         Event;
    DWORD                          Error;

    // ***** Change this requires change in apiappl.c function  DhcpCreateApiEventAndDescriptor

    sprintf(Name, "DhcpPid%16xUniqueId%16x", ProcId, Descriptor);
    Event = OpenEventA(                           // create event before pulsing it
        EVENT_ALL_ACCESS,                         // require all access
        FALSE,                                    // dont inherit this event
        Name                                      // name of event
    );

    if( NULL == Event ) return GetLastError();
    Error = SetEvent(Event);
    CloseHandle(Event);

    if( 0 == Error ) return GetLastError();
#else
#ifdef VXD
    if( 0 == Descriptor ) return ERROR_INVALID_PARAMETER;
    if( 0 == DhcpPulseWin32Event(Descriptor) )    // misnomer -- this is SetWin32Event not PULSE
        return ERROR_NO_SYSTEM_RESOURCES;
#endif VXD
#endif NEWNT

    return ERROR_SUCCESS;
}

static DWORD Initialized = 0;

DWORD                                             // win32 status
DhcpInitializeParamChangeRequests(                // initialize everything in this file
    VOID
) {
    DhcpAssert(0 == Initialized);
    InitializeListHead(&ParamChangeRequestList);
    Initialized++;

    return ERROR_SUCCESS;
}

VOID
DhcpCleanupParamChangeRequests(                   // unwind this module
    VOID
) {
    PLIST_ENTRY                    ThisEntry;
    PDHCP_PARAM_CHANGE_REQUESTS    ThisRequest;
    DWORD                          Error;

    if( 0 == Initialized ) return;
    Initialized--;

    while(!IsListEmpty(&ParamChangeRequestList)) {// delete each element of this list
        ThisEntry = RemoveHeadList(&ParamChangeRequestList);
        ThisRequest = CONTAINING_RECORD(ThisEntry, DHCP_PARAM_CHANGE_REQUESTS, RequestList);

        if( ThisRequest->ClassIdLength ) {
            Error = DhcpDelClass(&DhcpGlobalClassesList, ThisRequest->ClassId, ThisRequest->ClassIdLength);
            DhcpAssert(ERROR_SUCCESS == Error);
        }

#ifdef VXD                                        // for memphis alone, we need to free up this Event handle
        DhcpCloseVxDHandle(ThisRequest->Descriptor);
#endif

        DhcpFreeMemory(ThisRequest);
    }
    DhcpAssert(0 == Initialized);
}

//================================================================================
// end of file
//================================================================================
#endif H_ONLY
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\client\dhcp\precomp.h ===
#include <dhcpcli.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\client\inc\apiargs.h ===
/*++

Copyright (C) 1997 Microsoft Corporation

Module:

    apiarg.h

Author:

    Ramesh V K (RameshV)

Abstract:

    argument marshalling, unmarshalling helper routines.

Environment:

    Win32 usermode, Win98 VxD

--*/

#ifndef _APIARGS_
#define _APIARGS_

//
// Each argument for API is maintained like this.
//

typedef struct _DHCP_API_ARGS {
    BYTE ArgId;
    DWORD ArgSize;
    LPBYTE ArgVal;
} DHCP_API_ARGS, *PDHCP_API_ARGS, *LPDHCP_API_ARGS;

DWORD
DhcpApiArgAdd(
    IN OUT LPBYTE Buffer,
    IN ULONG MaxBufSize,
    IN BYTE ArgId,
    IN ULONG ArgSize,
    IN LPBYTE ArgVal OPTIONAL
    );

DWORD
DhcpApiArgDecode(
    IN LPBYTE Buffer,
    IN ULONG BufSize,
    IN OUT PDHCP_API_ARGS ArgsArray OPTIONAL,
    IN OUT PULONG Size 
    );

#endif _APIARGS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\client\dhcp\stack.c ===
//================================================================================
// Copyright (C) Micorosoft Confidential 1997
// Author: RameshV
// Description: definitions for almost all stack manipulations are here.
//================================================================================
#include "precomp.h"
#include "dhcpglobal.h"
#include <dhcploc.h>
#include <dhcppro.h>
#include <optchg.h>
#include <dnsapi.h>
#include <iphlpstk.h>

//================================================================================
// private API's
//================================================================================
#ifdef  NT
#define IPSTRING(x) (inet_ntoa(*(struct in_addr*)&(x)))
#else
#define IPSTRING(x) "ip-address"
#endif  NT

#define NT          // to include data structures for NT build.

#include <nbtioctl.h>
#include <ntddip.h>
#include <ntddtcp.h>

#include <tdiinfo.h>
#include <tdistat.h>
#include <ipexport.h>
#include <tcpinfo.h>
#include <ipinfo.h>
#include <llinfo.h>

#include <lmcons.h>
#include <lmsname.h>
#include <winsvc.h>
#include <ntddbrow.h>
#include <limits.h>
#include "nlanotif.h"


#define DEFAULT_DEST                    0
#define DEFAULT_DEST_MASK               0
#define DEFAULT_METRIC                  1

DWORD                                             // win32 status
DhcpSetStaticRoutes(                              // add/remove static routes
    IN     PDHCP_CONTEXT           DhcpContext,   // the context to set the route for
    IN     PDHCP_FULL_OPTIONS      DhcpOptions    // route info is given here
);

DWORD                                             // status
DhcpSetIpGateway(                                 // set the gateway
    IN     PDHCP_CONTEXT           DhcpContext,   // for this adapter/interface
    IN     DWORD                   GateWayAddress,// the gateway address in n/w order
    IN     DWORD                   Metric,        // metric
    IN     BOOL                    IsDelete       // is this a gateway delete?
);

DWORD                                             // win32 status
DhcpSetIpRoute(                                   // set the route
    IN     PDHCP_CONTEXT           DhcpContext,   // for this adapter/interface
    IN     DWORD                   Dest,          // route for which dest?
    IN     DWORD                   DestMask,      // network order destination mask
    IN     DWORD                   NextHop,       // this is the next hop address
    IN     BOOL                    IsDelete       // is this a route delete?
);

//================================================================================
// definitions
//================================================================================

#ifdef NT                                         // defined only on NT

ULONG
DhcpRegisterWithDns(
    IN PDHCP_CONTEXT DhcpContext,
    IN BOOL fDeregister
    )
/*++

Routine Description:
    This routine registers with DNS for Static/DHCP-enabled/RAS cases.

Arguments:
    DhcpContext -- context to delete for.
    fDeregister -- is this a de-registration?

Return Values:
    DNSAPI error codes.

--*/
{
    ULONG Error, DomOptSize, DnsFQDNOptSize, DNSListOptSize;
    LPBYTE DomOpt, DnsFQDNOpt, DNSListOpt;
    BOOL fRAS;
    PDHCP_OPTION Opt;
    
    fRAS = NdisWanAdapter(DhcpContext);

    if( fDeregister || DhcpIsInitState(DhcpContext) ) {
        //
        // Deregistration?
        //
        return DhcpDynDnsDeregisterAdapter(
            DhcpContext->AdapterInfoKey,
            DhcpAdapterName(DhcpContext),
            fRAS,
            UseMHAsyncDns
            );
    }

    //
    // Surely registration.  Static/DHCP Cases.
    //
    if( IS_DHCP_DISABLED(DhcpContext) && !fRAS ) {
        return DhcpDynDnsRegisterStaticAdapter(
            DhcpContext->AdapterInfoKey,
            DhcpAdapterName(DhcpContext),
            fRAS,
            UseMHAsyncDns
            );
    }

    //
    // For DHCP Case, we need to retrieve all the options.
    //
    DomOpt = DnsFQDNOpt = DNSListOpt = NULL;
    DomOptSize = DnsFQDNOptSize = DNSListOptSize = 0;
    
    Opt = DhcpFindOption(
        &DhcpContext->RecdOptionsList,
        OPTION_DOMAIN_NAME,
        FALSE,
        DhcpContext->ClassId,
        DhcpContext->ClassIdLength,
        0
        );
    if( NULL != Opt ) {
        DomOpt = Opt->Data;
        DomOptSize = Opt->DataLen;
    }

    Opt = DhcpFindOption(
        &DhcpContext->RecdOptionsList,
        OPTION_DYNDNS_BOTH,
        FALSE,
        DhcpContext->ClassId,
        DhcpContext->ClassIdLength,
        0
        );
    if( NULL != Opt ) {
        DnsFQDNOpt = Opt->Data;
        DnsFQDNOptSize = Opt->DataLen;
    }

    Opt = DhcpFindOption(
        &DhcpContext->RecdOptionsList,
        OPTION_DOMAIN_NAME_SERVERS,
        FALSE,
        DhcpContext->ClassId,
        DhcpContext->ClassIdLength,
        0
        );
    if( NULL != Opt ) {
        DNSListOptSize = Opt->DataLen;
        DNSListOpt = Opt->Data;
    }

    return DhcpDynDnsRegisterDhcpOrRasAdapter(
        DhcpContext->AdapterInfoKey,
        DhcpAdapterName(DhcpContext),
        UseMHAsyncDns,
        fRAS,
        DhcpContext->IpAddress,
        DomOpt, DomOptSize,
        DNSListOpt, DNSListOptSize,
        DnsFQDNOpt, DnsFQDNOptSize
        );
}

#endif NT                                         // end of NT only code

DWORD                                             // status
DhcpSetIpGateway(                                 // set the gateway
    IN      PDHCP_CONTEXT          DhcpContext,   // for this adapter/interface
    IN      DWORD                  GateWayAddress,// the gateway address in n/w order
    IN      DWORD                  Metric,        // metric
    IN      BOOL                   IsDelete       // is this a gateway delete?
) 
{
    BOOL                           IsLocal;
    DWORD                          IfIndex;

    IsLocal = (GateWayAddress == DhcpContext->IpAddress);
    IfIndex = DhcpIpGetIfIndex(DhcpContext);
    return DhcpSetRoute(
        DEFAULT_DEST, DEFAULT_DEST_MASK, IfIndex, 
        GateWayAddress, Metric, IsLocal, IsDelete 
        );
}

DWORD
DhcpGetStackGateways(
    IN  PDHCP_CONTEXT DhcpContext,
    OUT DWORD   *pdwCount,
    OUT DWORD   **ppdwGateways,
    OUT DWORD   **ppdwMetrics
    )
{
    DWORD               dwIfIndex = 0;
    DWORD               i, dwCount = 0;
    DWORD               dwError = ERROR_SUCCESS;
    DWORD               *pdwGateways = NULL, *pdwMetrics = NULL;
    PMIB_IPFORWARDTABLE RouteTable = NULL;

    dwIfIndex = DhcpIpGetIfIndex(DhcpContext);

    //
    // Query the stack
    //
    dwError = AllocateAndGetIpForwardTableFromStack(
            &RouteTable,
            FALSE,
            GetProcessHeap(),
            0
            );
    if( ERROR_SUCCESS != dwError ) {
        RouteTable = NULL;
        goto Cleanup;
    }

    //
    // Pick up the default gateways for the interface dwIfIndex
    //
    ASSERT(RouteTable);

    //
    // Count the qualified entries
    //
    DhcpPrint((DEBUG_STACK, "The stack returns:\n"));
    for (dwCount = 0, i = 0; i < RouteTable->dwNumEntries; i++) {
        DhcpPrint((DEBUG_STACK, "\t%02d. IfIndex=0x%x Dest=%s Metric=%d Type=%d\n",
                    i,
                    RouteTable->table[i].dwForwardIfIndex,
                    inet_ntoa(*(struct in_addr *)&RouteTable->table[i].dwForwardDest),
                    RouteTable->table[i].dwForwardMetric1,
                    RouteTable->table[i].dwForwardType));

        if( RouteTable->table[i].dwForwardIfIndex == dwIfIndex &&
            DEFAULT_DEST == RouteTable->table[i].dwForwardDest &&
            MIB_IPROUTE_TYPE_INVALID != RouteTable->table[i].dwForwardType ) {
            dwCount ++;
        }
    }
    if (0 == dwCount) {
        *pdwCount = 0;
        *ppdwGateways = NULL;
        *ppdwMetrics  = NULL;
        dwError   = ERROR_SUCCESS;
        DhcpPrint((DEBUG_TRACE, "GetIpForwardTable returns %d default gateways for interface %d, %ws\n",
                    dwCount, dwIfIndex, DhcpAdapterName(DhcpContext)));
        goto Cleanup;
    }

    //
    // Allocate memory for the qualified entries
    //
    pdwGateways = (DWORD*)DhcpAllocateMemory(dwCount * sizeof(DWORD));
    pdwMetrics  = (DWORD*)DhcpAllocateMemory(dwCount * sizeof(DWORD));
    if (NULL == pdwGateways || NULL == pdwMetrics) {
        if (pdwGateways) {
            DhcpFreeMemory(pdwGateways);
        }
        if (pdwMetrics) {
            DhcpFreeMemory(pdwMetrics);
        }
        dwError = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    //
    // Copy back the result
    //
    DhcpPrint((DEBUG_STACK, "Default gateway for %ws:\n", DhcpAdapterName(DhcpContext)));
    *pdwCount = dwCount;
    *ppdwGateways = pdwGateways;
    *ppdwMetrics  = pdwMetrics;
    for (dwCount = 0, i = 0; i < RouteTable->dwNumEntries; i++) {
        if( RouteTable->table[i].dwForwardIfIndex == dwIfIndex &&
            DEFAULT_DEST == RouteTable->table[i].dwForwardDest &&
            MIB_IPROUTE_TYPE_INVALID != RouteTable->table[i].dwForwardType ) {

            //
            // For safe
            //
            if (dwCount >= *pdwCount) {
                ASSERT(0);
                break;
            }

            pdwGateways[dwCount] = RouteTable->table[i].dwForwardNextHop;
            pdwMetrics[dwCount]  = RouteTable->table[i].dwForwardMetric1;
            DhcpPrint((DEBUG_STACK, "\t%02d. IfIndex=0x%x Dest=%s Metric=%d Type=%d\n",
                    dwCount,
                    RouteTable->table[i].dwForwardIfIndex,
                    inet_ntoa(*(struct in_addr *)&RouteTable->table[i].dwForwardDest),
                    RouteTable->table[i].dwForwardMetric1,
                    RouteTable->table[i].dwForwardType));

            dwCount ++;
        }
    }
    dwError = ERROR_SUCCESS;
    DhcpPrint((DEBUG_TRACE, "GetIpForwardTable returns %d default gateways for interface 0x%x, %ws\n",
                    dwCount, dwIfIndex, DhcpAdapterName(DhcpContext)));

Cleanup:
    if (RouteTable) {
        HeapFree(GetProcessHeap(), 0, RouteTable);
    }
    return dwError;
}

DWORD                                             // win32 status
DhcpSetIpRoute(                                   // set the route
    IN      PDHCP_CONTEXT          DhcpContext,   // for this adapter/interface
    IN      DWORD                  Dest,          // route for which dest?
    IN      DWORD                  DestMask,      // network order destination mask
    IN      DWORD                  NextHop,       // this is the next hop address
    IN      BOOL                   IsDelete       // is this a route delete?
) 
{
    BOOL                           IsLocal;
    DWORD                          IfIndex;

    IsLocal = (NextHop == DhcpContext->IpAddress);
    IfIndex = DhcpIpGetIfIndex(DhcpContext);
    return DhcpSetRoute(
        Dest, DestMask, IfIndex, 
        NextHop, DEFAULT_METRIC, IsLocal, IsDelete
        );
}

BOOL
UsingStaticGateways(                              // is stack configured to use static g/w
    IN     PDHCP_CONTEXT           DhcpContext,   // for this adapter
    OUT    PDWORD                 *pDwordArray,   // if so, this is the list of g/w's
    OUT    PDWORD                  pCount,        // the size of the above array
    OUT    PDWORD                 *pMetricArray,
    OUT    PDWORD                  pMetricCount
) 
{
    DWORD                          ValueType;
    DWORD                          ValueSize;
    DWORD                          Value;
    DWORD                          Error;
    LPWSTR                         GatewayString;
    DWORD                          GatewayStringSize;
    LPWSTR                         GatewayMetricString;
    DWORD                          GatewayMetricStringSize;
    
#ifdef VXD
    return FALSE;                                 // nope, no overrides for memphis
#else

    *pDwordArray = NULL; *pCount = 0;
    *pMetricArray = NULL; *pMetricCount = 0;
    
    ValueSize = sizeof(DWORD);
    Error = RegQueryValueEx(                      // look for DHCP_DONT_ADD_GATEWAY_FLAG
        DhcpContext->AdapterInfoKey,
        DHCP_DONT_ADD_DEFAULT_GATEWAY_FLAG,
        0 /* Reserved */,
        &ValueType,
        (LPBYTE)&Value,
        &ValueSize
    );

    if( ERROR_SUCCESS == Error && Value > 0 ) return FALSE;

    GatewayString = NULL;
    Error = GetRegistryString(
        DhcpContext->AdapterInfoKey,
        DHCP_DEFAULT_GATEWAY_PARAMETER,
        &GatewayString,
        &GatewayStringSize
    );

    if( ERROR_SUCCESS != Error ) return FALSE;    // this should exist
    if( 0 == GatewayStringSize || 0 == wcslen(GatewayString)) {
        if( GatewayString ) LocalFree( GatewayString );
        return FALSE;
    }

    (*pDwordArray) = DhcpCreateListFromStringAndFree(
        GatewayString,
        NULL,                                    // multi-sz strings have nul char as separation
        pCount
    );

    //
    // Attempt to retrieve the optional gateway metric list.
    // If no values are found, default metrics will be used.
    //

    GatewayMetricString = NULL;
    Error = GetRegistryString(
        DhcpContext->AdapterInfoKey,
        DHCP_DEFAULT_GATEWAY_METRIC_PARAMETER,
        &GatewayMetricString,
        &GatewayMetricStringSize
    );
    if ( ERROR_SUCCESS == Error && GatewayMetricString ) {
        DWORD MetricCount;
        PDWORD MetricArray;
        LPWSTR MetricString;

        //
        // Count the entries in the gateway metric list
        // and allocate a buffer large enough to hold all the entries.
        //

        for( MetricString = GatewayMetricString, MetricCount = 0;
            *MetricString;
             MetricString += wcslen(MetricString) + 1, ++MetricCount) { }

        MetricArray = NULL;
        if( MetricCount ) {
            MetricArray = DhcpAllocateMemory(sizeof(DWORD)*MetricCount);
        }
        
        if (MetricArray) {

            //
            // Initialize all entries to zero and parse each entry
            // into the array of metrics. When in invalid entry is encountered,
            // the process stops and we make do with whatever has been read.
            //

            RtlZeroMemory(MetricArray, sizeof(DWORD)*MetricCount);
            for( MetricString = GatewayMetricString, MetricCount = 0;
                *MetricString;
                 MetricString += wcslen(MetricString) + 1) {
                LPWSTR EndChar;
                MetricArray[MetricCount] = wcstoul(MetricString, &EndChar, 0);
                if (MetricArray[MetricCount] == MAXULONG) {
                    break;
                } else {
                    ++MetricCount;
                }
            }
            if (MetricCount) {
                *pMetricArray = MetricArray;
                *pMetricCount = MetricCount;
            }
        }
        DhcpFreeMemory(GatewayMetricString);
    }
                
    return (*pCount > 0);
#endif VXD
}

DWORD                                             // win32 status
DhcpSetGateways(                                  // set/unset gateways
    IN     PDHCP_CONTEXT           DhcpContext,   // the context to set gateway for
    IN     PDHCP_FULL_OPTIONS      DhcpOptions,   // gateway info is given here
    IN     BOOLEAN                 fForceUpdate
) 
{
    DWORD                          Error;
    DWORD                          LastError;     // last error condition is reported
    DWORD                          OldCount = 0;
    DWORD                          NewCount;
    DWORD                         *OldArray = NULL;      // old array of gateways
    DWORD                         *OldMetric = NULL;     // old array of gateways
    DWORD                         *NewArray;      // new array of gateways
    DWORD                         *MetricArray = NULL;
    DWORD                          MetricCount;
    DWORD                          i, j;
    DWORD                          BaseMetric;
    BOOL                           fStatic = TRUE, fDhcpMetric = FALSE;
    DHCP_FULL_OPTIONS              DummyOptions;
    DWORD                          Type, Result, Size;
    
    LastError = ERROR_SUCCESS;

    if( !UsingStaticGateways(DhcpContext, &NewArray, &NewCount, &MetricArray, &MetricCount ) ) {
        fStatic = FALSE;

        if( NULL != DhcpOptions && 0 == DhcpOptions->nGateways ) {
            DummyOptions = (*DhcpOptions);
            DhcpOptions = &DummyOptions;
            RetreiveGatewaysList(
                DhcpContext,
                &DhcpOptions->nGateways,
                &DhcpOptions->GatewayAddresses
                );
        }
        
        if( NULL == DhcpOptions || 0 == DhcpOptions->nGateways ) {
            DhcpPrint((DEBUG_STACK, "DhcpSetGateways: deleting all gateways\n"));
            NewArray = NULL;
            NewCount = 0;
        } else {                                  // create the required arrays
            NewCount = DhcpOptions->nGateways;    // new array's size
            NewArray = DhcpAllocateMemory(NewCount * sizeof(DWORD));
            if( NULL == NewArray ) {              // could not allocate, still remove g/w
                NewCount = 0;
                DhcpPrint((DEBUG_ERRORS, "DhcpSetGateways:DhcpAllocateMemory: NULL\n"));
                LastError = ERROR_NOT_ENOUGH_MEMORY;
            }
            memcpy(NewArray,DhcpOptions->GatewayAddresses, NewCount*sizeof(DWORD));
        }
    }

    //
    // Use the array in our own list (to minimize the effect)
    //
    OldCount = DhcpContext->nGateways;
    OldArray = DhcpContext->GatewayAddresses;

    for(j = 0; j < OldCount ; j ++ ) {            // for each old g/w entry
        for( i = 0; i < NewCount; i ++ ) {        // check if it is not present in new list
            if( OldArray[j] == NewArray[i] )      // gotcha
                break;
        }
        if( i < NewCount ) continue;              // this is there in new list, nothing to do
        Error = DhcpSetIpGateway(DhcpContext, OldArray[j], 0, TRUE);
        if( ERROR_SUCCESS != Error ) {            // coult not delete gateway?
            LastError = Error;
            DhcpPrint((DEBUG_ERRORS, "DhcpDelIpGateway(%s):%ld\n",IPSTRING(OldArray[j]),Error));
        }
    }

    if(OldArray) {
        DhcpFreeMemory(OldArray);        // free up the old memory
    }

    OldCount  = 0;
    OldArray  = NULL;
    OldMetric = NULL;
    //
    // Use the array queried from the stack
    //
    if (!fForceUpdate) {
        Error = DhcpGetStackGateways(DhcpContext, &OldCount, &OldArray, &OldMetric);
        if (ERROR_SUCCESS != Error) {
            OldCount  = 0;
            OldArray  = NULL;
            OldMetric = NULL;
        }
    }

    // now read the basic metric from the registry, if it is there,
    Error = RegQueryValueEx(
        DhcpContext->AdapterInfoKey,
        DHCP_INTERFACE_METRIC_PARAMETER,
        0 /* Reserved */,
        &Type,
        (LPBYTE)&Result,
        &Size
        );
    if (Error == ERROR_SUCCESS &&
        Size == sizeof(DWORD) &&
        Type == REG_DWORD)
    {
        BaseMetric = Result;
    }
    else
    {
        BaseMetric = (Error == ERROR_FILE_NOT_FOUND)? 0 : DEFAULT_METRIC;
    }
    // if it is not or anything else went wrong with the registry,
    // we're still stuck with 0 which is good.

    // now, just in case we don't have any static routes, we're
    // looking for the base matric as it was sent by DHCP.
    if( !fStatic ) {
        fDhcpMetric = DhcpFindDwordOption(
                        DhcpContext,
                        OPTION_MSFT_VENDOR_METRIC_BASE,
                        TRUE,
                        &BaseMetric);
        // if there is no such option, we're still stuck with
        // whatever is already, which is good
    }

    for(i = 0 ; i < NewCount ; i ++ )
    {
        if (!fForceUpdate) {
            for (j = 0; j < OldCount; j++) {
                //
                // Check if the gateway is already there. If it is, don't
                // touch it. RRAS could bump up the metric for VPN connections.
                // RRAS will be broken if we change the metric
                //
                if (OldArray[j] == NewArray[i]) {
                    break;
                }
            }
            if (j < OldCount) {
                DhcpPrint((DEBUG_STACK, "Skip gateway %s, metric %d\n", 
                    inet_ntoa(*(struct in_addr *)&OldArray[j]), OldMetric[j]));
                continue;
            }
        }

        // for each element we'd like to add
        if (fStatic)
        {
            // if the gateway in the "new" list is static...
            if (i >= MetricCount)
            {
                // ..but we don't have a clear metric for it..
                // ..and it is not already present in the default gw list...
                // 
                // then configure this gw with the BaseMetric we could get from the
                // the registry (if any) or the default value of 0 if there was no such registry.
                Error = DhcpSetIpGateway(
                            DhcpContext,
                            NewArray[i],
                            BaseMetric,
                            FALSE);
            }
            else
            {
                // ..or we have a clear metric for this gateway..
                //
                // this could very well be a new metric, so plumb it down.
                Error = DhcpSetIpGateway(
                            DhcpContext,
                            NewArray[i],
                            MetricArray[i],
                            FALSE);
            }
        }
        else
        {
            // we need to infere the metric from BaseMetric calculated above
            // since the DHCP option doesn't include the metric.
            // if the BaseMetric is 0 it means the interface is in auto-metric mode (metric
            // is set based on interfaces speed). Pass this value down to the stack such that
            // the stack knows it needs to select the right metric.
            // if BaseMetric is not 0 it means it either came from the server (as vendor option 3)
            // or the interface is not in auto-metric mode (hence "InterfaceMetric" in the registry
            // gave the base metric) or something really bad happened while reading the registry
            // so the metric base is defaulted to DEFAULT.

            // we set the gateway with whatever metric we can give it (either based
            // on the dhcp option or on what we found in the registry).
            Error = DhcpSetIpGateway(
                    DhcpContext,
                    NewArray[i],
                    BaseMetric != 0 ? (BaseMetric+i) : 0,
                    FALSE);
        }

        if( ERROR_SUCCESS != Error ) {            // could not add gateway?
            LastError = Error;
            DhcpPrint((DEBUG_ERRORS, "DhcpAddIpGateway(%s): %ld\n",IPSTRING(NewArray[i]),Error));
        }
    }

    DhcpContext->GatewayAddresses = NewArray;     // now, save this information
    DhcpContext->nGateways = NewCount;

    if(OldArray) DhcpFreeMemory(OldArray);        // free up the old memory
    if(OldMetric) DhcpFreeMemory(OldMetric);      // free up the old memory
    if(MetricArray) DhcpFreeMemory(MetricArray);  // free up old memory
    return LastError;
}

/*++
Routine Description:
    Takes as input a pointer to a classless route description
    (mask ordinal, route dest encoding, route gw)
    Fills in the output buffers (if provided) with the route's parameters
--*/
DWORD
GetCLRoute(
    IN      LPBYTE                 RouteData,
    OUT     LPBYTE                 RouteDest,
    OUT     LPBYTE                 RouteMask,
    OUT     LPBYTE                 RouteGateway
    )
{
    BYTE maskOrd;
    BYTE maskTrail;
    INT  maskCount;
    INT  i;

    // prepare the mask: 
    // - check the mask ordinal doesn't exceed 32 
    maskOrd = RouteData[0];
    if (maskOrd > 32)
        return ERROR_BAD_FORMAT;
    // - get in maskCount the number of bytes encoding the subnet address
    maskCount = maskOrd ? (((maskOrd-1) >> 3) + 1) : 0;
    // - get in maskTrail the last byte from the route's subnet mask
    for (i = maskOrd%8, maskTrail=0; i>0; i--)
    {
        maskTrail >>= 1;
        maskTrail |= 0x80;
    }
    // if the last byte from the mask is incomplet, check to see
    // if the last byte from the subnet address is confom to the subnet mask
    if (maskTrail != 0 && ((RouteData[maskCount] & ~maskTrail) != 0))
        return ERROR_BAD_FORMAT;

    //-----------
    // copy the route destination if requested
    if (RouteDest != NULL)
    {
        RtlZeroMemory(RouteDest, sizeof(DHCP_IP_ADDRESS));

        // for default route (maskOrd == 0), leave the dest as 0.0.0.0
        if (maskCount > 0)
        {
            memcpy(RouteDest, RouteData+1, maskCount);
        }
    }

    //-----------
    // if route mask is requested, build it from the maskOrd & maskTrail
    if (RouteMask != NULL)
    {
        RtlZeroMemory(RouteMask, sizeof(DHCP_IP_ADDRESS));

        // for default route (maskOrd == 0), leave the mask as 0.0.0.0
        if (maskCount > 0)
        {
            RtlFillMemory(RouteMask, maskCount-(maskTrail != 0), 0xFF);
            if (maskTrail != 0)
                RouteMask[maskCount-1] = maskTrail;
        }
    }

    //-----------
    // if route gateway is requested, copy it over from the option's data
    if (RouteGateway != NULL)
    {
        memcpy(RouteGateway,
               RouteData+CLASSLESS_ROUTE_LEN(maskOrd)-sizeof(DHCP_IP_ADDRESS),
               sizeof(DHCP_IP_ADDRESS));
    }

    return ERROR_SUCCESS;
}

/*++
Routine Description:
    This routine checks the validity of a OPTION_CLASSLESS_ROUTES data.
    Given this option has variable length entries, the routine checks
    whether the option's length matches the sum of all the static classless
    routes from within.
    The routine returns the number of classless routes from the option's data
--*/
DWORD
CheckCLRoutes(
    IN      DWORD                  RoutesDataLen,
    IN      LPBYTE                 RoutesData,
    OUT     LPDWORD                pNRoutes
)
{
    DWORD NRoutes = 0;

    while (RoutesDataLen > 0)
    {
        // calculate the number of bytes for this route
        DWORD nRouteLen = CLASSLESS_ROUTE_LEN(RoutesData[0]);

        // if this exceeds the remaining option's length 
        // then it is something wrong with it - return with the error
        if (nRouteLen > RoutesDataLen)
            return ERROR_BAD_FORMAT;

        // otherwise count it and skip it.
        NRoutes++;
        RoutesData += nRouteLen;
        RoutesDataLen -= nRouteLen;
    }

    *pNRoutes = NRoutes;

    return ERROR_SUCCESS;
}

VOID
UpdateDhcpStaticRouteOptions(
    IN PDHCP_CONTEXT DhcpContext,
    IN PDHCP_FULL_OPTIONS DhcpOptions
    )
/*++

Routine Description:
    This routine fills the gateway and static routes information
    into the DhcpOptions structure assuming it was empty earlier.

--*/
{
    PDHCP_OPTION Opt;
    time_t CurrentTime;

    if (DhcpOptions == NULL)
        return;

    time(&CurrentTime);

    //
    // If no static routes configured, configure it.
    //
    if(DhcpOptions->nClassedRoutes == 0)
    {
        Opt = DhcpFindOption(
                &DhcpContext->RecdOptionsList,
                (BYTE)OPTION_STATIC_ROUTES,
                FALSE,
                DhcpContext->ClassId,
                DhcpContext->ClassIdLength,
                0);

        if (Opt != NULL &&
            Opt->ExpiryTime >= CurrentTime &&
            Opt->DataLen &&
            Opt->DataLen % (2*sizeof(DWORD)) == 0)
        {
            DhcpOptions->nClassedRoutes = (Opt->DataLen / (2*sizeof(DWORD)));
            DhcpOptions->ClassedRouteAddresses = (PVOID)Opt->Data;
        }
    }

    //
    // If no classless routes configured, configure them.
    //
    if (DhcpOptions->nClasslessRoutes == 0)
    {
        Opt = DhcpFindOption(
            &DhcpContext->RecdOptionsList,
            (BYTE)OPTION_CLASSLESS_ROUTES,
            FALSE,
            DhcpContext->ClassId,
            DhcpContext->ClassIdLength,
            0);

        if (Opt != NULL &&
            Opt->ExpiryTime >= CurrentTime &&
            Opt->DataLen &&
            CheckCLRoutes(Opt->DataLen, Opt->Data, &DhcpOptions->nClasslessRoutes) == ERROR_SUCCESS)
        {
            DhcpOptions->ClasslessRouteAddresses = (PVOID)Opt->Data;
        }
    }
}

DWORD                                             // win32 status
DhcpSetStaticRoutes(                              // add/remove static routes
    IN     PDHCP_CONTEXT           DhcpContext,   // the context to set the route for
    IN     PDHCP_FULL_OPTIONS      DhcpOptions    // route info is given here
)
{
    DWORD                          Error;
    DWORD                          LastError;     // last error condition is reported
    DWORD                          OldCount;
    DWORD                          NewCount;
    DWORD                         *OldArray;      // old array of routes
    DWORD                         *NewArray;      // new array of routes
    DWORD                          i, j;

    LastError = ERROR_SUCCESS;

    UpdateDhcpStaticRouteOptions(DhcpContext, DhcpOptions);

    NewCount = DhcpOptions != NULL ? DhcpOptions->nClassedRoutes + DhcpOptions->nClasslessRoutes : 0;

    if( NewCount == 0 )
    {
        DhcpPrint((DEBUG_STACK, "DhcpSetStaticRoutes: deleting all routes\n"));
        NewArray = NULL;
    }
    else
    {
        LPBYTE classlessRoute;

        // create the required arrays
        NewArray = DhcpAllocateMemory(NewCount * 3 * sizeof(DWORD));
        if( NULL == NewArray )
        {                                         // could not allocate, still remove g/w
            NewCount = 0;
            DhcpPrint((DEBUG_ERRORS, "DhcpSetSetStatic:DhcpAllocateMemory: NULL\n"));
            LastError = ERROR_NOT_ENOUGH_MEMORY;
        }

        j = 0;
        for (classlessRoute = DhcpOptions->ClasslessRouteAddresses, i = 0;
             i < DhcpOptions->nClasslessRoutes;
             classlessRoute += CLASSLESS_ROUTE_LEN(classlessRoute[0]), i++)
        {
            // create classless route layout
            if ( GetCLRoute (
                    classlessRoute,
                    (LPBYTE)&NewArray[3*j],     // route's dest
                    (LPBYTE)&NewArray[3*j+1],   // route's subnet mask
                    (LPBYTE)&NewArray[3*j+2])   // route's gateway
                    == ERROR_SUCCESS)
            {
                // only count this route if it is valid
                // (the destination doesn't contain bits set beyound what the mask shows)
                DhcpPrint((DEBUG_STACK,"Classless route: ip 0x%08x mask 0x%08x gw 0x%08x.\n",
                                NewArray[3*j], NewArray[3*j+1], NewArray[3*j+2]));
                j++;
            }
        }

        for (i = 0; i < DhcpOptions->nClassedRoutes; i++, j++)
        {
            // create classed route layout
            NewArray[3*j]   = DhcpOptions->ClassedRouteAddresses[2*i];   // route's dest
            NewArray[3*j+1] = (DWORD)(-1);                               // route's subnet mask
            NewArray[3*j+2] = DhcpOptions->ClassedRouteAddresses[2*i+1]; // route's gateway
        }

        NewCount = j;

        if (NewCount == 0)
        {
            DhcpPrint((DEBUG_OPTIONS, "Invalid classless routes - no new route picked up\n"));

            DhcpFreeMemory(NewArray);
            NewArray = NULL;
        }
    }

    OldCount = DhcpContext->nStaticRoutes;
    OldArray = DhcpContext->StaticRouteAddresses;

    for(j = 0; j < OldCount ; j ++ ) {            // for each old route entry
        for( i = 0; i < NewCount; i ++ ) {        // check if it is not present in new list
            if( OldArray[3*j] == NewArray[3*i] &&
                OldArray[3*j+1] == NewArray[3*i+1] &&
                OldArray[3*j+2] == NewArray[3*i+2])
                break;                            // got it. this route is present even now
        }
        if( i < NewCount ) continue;              // this is there in new list, nothing to do
        Error = DhcpSetIpRoute(                   // the route needs to be deleted, so do it
            DhcpContext,                          // delete on this interface
            OldArray[3*j],                        // for this destination
            OldArray[3*j+1],                      // subnet mask for the route
            OldArray[3*j+2],                      // to this router
            TRUE                                  // and yes, this IS a deletion
        );

        if( ERROR_SUCCESS != Error ) {            // coult not delete route?
            LastError = Error;
            DhcpPrint((DEBUG_ERRORS, "DhcpDelIpRoute(%s):%ld\n",IPSTRING(OldArray[2*j]),Error));
        }
    }

    for(i = 0 ; i < NewCount ; i ++ ) {           // for each element we'd like to add
        for(j = 0; j < OldCount; j ++ ) {         // check if already exists
            if( OldArray[3*j] == NewArray[3*i] &&
                OldArray[3*j+1] == NewArray[3*i+1] &&
                OldArray[3*j+2] == NewArray[3*i+2])
                break;                            // yup, this route exists..
        }
        if( j < OldCount) continue;               // already exists, skip it
        Error = DhcpSetIpRoute(                   // new route, add it
            DhcpContext,                          // the interface to add route for
            NewArray[3*i],                        // destination for the specific route
            NewArray[3*i+1],                      // subnet mask for the route
            NewArray[3*i+2],                      // router for this destination
            FALSE                                 // this is not a deletion; addition
        );
        if( ERROR_SUCCESS != Error ) {            // could not add route?
            LastError = Error;
            DhcpPrint((DEBUG_ERRORS, "DhcpAddIpRoute(%s): %ld\n",IPSTRING(NewArray[2*i]),Error));
        }
    }

    DhcpContext->StaticRouteAddresses= NewArray;  // now, save this information
    DhcpContext->nStaticRoutes = NewCount;

    if(OldArray) DhcpFreeMemory(OldArray);        // free up the old memory
    return LastError;
}

DWORD
DhcpSetRouterDiscoverOption(
    IN OUT PDHCP_CONTEXT DhcpContext
    )
{
    BYTE Value;
    BOOL fPresent;

    fPresent = DhcpFindByteOption(
        DhcpContext, OPTION_PERFORM_ROUTER_DISCOVERY, FALSE, &Value
        );

    return TcpIpNotifyRouterDiscoveryOption(
        DhcpAdapterName(DhcpContext), fPresent, (DWORD)Value
        );    
}


//================================================================================
// exported function definitions
//================================================================================

DWORD                                             // win32 status
DhcpClearAllStackParameters(                      // undo the effects
    IN      PDHCP_CONTEXT          DhcpContext    // the adapter to undo
)
{
    DWORD err = DhcpSetAllStackParameters(DhcpContext,NULL);

    // notify NLA about the change
    NLANotifyDHCPChange();

    return err;
}

DWORD                                             // win32 status
DhcpSetAllStackParameters(                        // set all stack details
    IN      PDHCP_CONTEXT          DhcpContext,   // the context to set stuff
    IN      PDHCP_FULL_OPTIONS     DhcpOptions    // pick up the configuration from off here
)
{
    DWORD                          Error;
    DWORD                          LastError;
    DHCP_FULL_OPTIONS              DummyOptions;
    BOOL                           fReset;


    // see if this context actually got reset (i.e. due to a lease release or expiration)
    fReset = DhcpIsInitState(DhcpContext) &&
             (DhcpContext->IpAddress == 0 || IS_FALLBACK_DISABLED(DhcpContext));
    
    LastError = ERROR_SUCCESS;                    // this is the last error condition that happened

    if (!fReset)
    {
        // this is either a DHCP lease or an autonet fallback configuration
        // in both cases we need to setup correctly Gateways & StaticRoutes.
        Error = DhcpSetGateways(DhcpContext,DhcpOptions, FALSE);
        if( ERROR_SUCCESS != Error )
        {   
            // unable to add gateways successfully?
            LastError = Error;
            DhcpPrint((DEBUG_ERRORS, "DhcpSetGateways: %ld\n", Error));
        }

        Error = DhcpSetStaticRoutes(DhcpContext, DhcpOptions);
        if( ERROR_SUCCESS != Error )
        {   
            // unable to add the reqd static routes?
            LastError = Error;
            DhcpPrint((DEBUG_ERRORS, "DhcpSetStaticRoutes: %ld\n", Error));
        }
    }

#ifdef NT                                         // begin NT only code
    if( TRUE || UseMHAsyncDns ) {                 // dont do DNS if disabled in registry..
                                                  // Actually, we will call DNS anyway -- they do
                                                  // the right thing according to GlennC (08/19/98)

        Error = DhcpRegisterWithDns(DhcpContext, FALSE);
        if( ERROR_SUCCESS != Error ) {            // unable to do dns (de)registrations?
            DhcpPrint((DEBUG_ERRORS, "DhcpDnsRegister: %ld\n", Error));
           // LastError = Error;                  // ignore DNS errors. these are dont care anyways.
        }
    }
#endif NT                                         // end NT only code

    // if the address is actually being reset (due to lease release or expiration) we have
    // to reset the Gateways & StaticRoutes. Normally this done by the stack, but in the case
    // there is some other IP address bound to the same adapter, the stack won't clear up either
    // gateway or routes. Since we still want this to happen we're doing it explicitely here.
    if (fReset)
    {
        Error = DhcpSetGateways(DhcpContext, DhcpOptions, FALSE);
        if ( ERROR_SUCCESS != Error )
        {
            DhcpPrint((DEBUG_ERRORS, "DhcpSetGateways: %ld while resetting.\n", Error));
        }

        Error = DhcpSetStaticRoutes(DhcpContext, DhcpOptions);
        if ( ERROR_SUCCESS != Error )
        {
            DhcpPrint((DEBUG_ERRORS, "DhcpSetStaticRoutes: %ld while resetting.\n", Error));
        }

        // if it is pure autonet - with no fallback configuration...
        if( DhcpContext->nGateways )
        {
            // if we dont free these, we will never set this later on...
            DhcpContext->nGateways = 0;
            DhcpFreeMemory(DhcpContext->GatewayAddresses );
            DhcpContext->GatewayAddresses = NULL;
        }
        if( DhcpContext->nStaticRoutes )
        {
            // got to free these or, we will never set these up next time?
            DhcpContext->nStaticRoutes =0;
            DhcpFreeMemory(DhcpContext->StaticRouteAddresses);
            DhcpContext->StaticRouteAddresses = NULL;
        }
        //
        // Need to blow away the options information!
        //
        Error = DhcpClearAllOptions(DhcpContext);
        if( ERROR_SUCCESS != Error )
        {
            LastError = Error;
            DhcpPrint((DEBUG_ERRORS, "DhcpClearAllOptions: %ld\n", Error));
        }
    }

    Error = DhcpSetRouterDiscoverOption(DhcpContext);
    if( ERROR_SUCCESS != Error ) {
        //LastError = Error;
        DhcpPrint((DEBUG_ERRORS, "DhcpSetRouterDiscoverOption: %ld\n", Error));
    }
        
    
    Error = DhcpNotifyMarkedParamChangeRequests(
        DhcpNotifyClientOnParamChange
        );
    DhcpAssert(ERROR_SUCCESS == Error);

    return LastError;
}

DWORD
GetIpPrimaryAddresses(
    IN  PMIB_IPADDRTABLE    *IpAddrTable
    )
/*++

Routine Description:

    This routine gets the ipaddress table from the stack. The
    primary addresses are marked in the table.

Arguments:

    IpAddrTable - Pointer to the ipaddress table pointer. The memory
                    is allocated in this routine and the caller is
                    responsible for freeing the memory.
Return Value:

    The status of the operation.

--*/
{
    DWORD                           Error;
    DWORD                           Size;
    PMIB_IPADDRTABLE                LocalTable;

    Error = ERROR_SUCCESS;
    Size = 0;

    //
    // find the size of the table..
    //
    Error = GetIpAddrTable(NULL, &Size, FALSE);
    if (ERROR_INSUFFICIENT_BUFFER != Error && ERROR_SUCCESS != Error) {
        DhcpPrint(( DEBUG_ERRORS, "GetIpAddrTable failed to obtain the size, %lx\n",Error));
        return Error;
    }

    DhcpAssert( Size );

    //
    // allocate the table.
    //
    LocalTable = DhcpAllocateMemory( Size );
    if (!LocalTable) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    Error = GetIpAddrTable( LocalTable, &Size, FALSE );
    if (ERROR_SUCCESS == Error) {
        DhcpAssert(LocalTable->dwNumEntries);
        *IpAddrTable = LocalTable;
    } else {
        DhcpPrint(( DEBUG_ERRORS, "GetIpAddrTable failed, %lx\n",Error));
        DhcpFreeMemory( LocalTable );
    }

    return Error;
}

//================================================================================
// end of file
//================================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\client\dhcp\optreg.c ===
//--------------------------------------------------------------------------------
// Copyright (C) Micorosoft Confidential 1997
// Author: RameshV
// Description: Option related registry handling -- common between NT and VxD
//--------------------------------------------------------------------------------

#include "precomp.h"
#include "dhcpglobal.h"
#include <dhcploc.h>
#include <dhcppro.h>
#include <dhcpcapi.h>

#include <align.h>
#include <lmcons.h>
#include <optchg.h>

#ifndef  OPTREG_H
#define  OPTREG_H
//--------------------------------------------------------------------------------
// Exported functions: Caller must take locks and any lists accessed
//--------------------------------------------------------------------------------

DWORD                                             // status
DhcpRegReadOptionDefList(                         // fill DhcpGlobalOptionDefList
    VOID
);

DWORD                                             // status
DhcpRegFillSendOptions(                           // fill in the list of options for SENDING
    IN OUT  PLIST_ENTRY            SendOptList,   // list to add too
    IN      LPWSTR                 AdapterName,   // adapter name to fill for
    IN      LPBYTE                 ClassId,       // class id to assume for filling
    IN      DWORD                  ClassIdLen     // the length of the classId in bytes
);

DWORD                                             // status
DhcpRegSaveOptions(                               // save these options onto the registry
    IN      PLIST_ENTRY            SaveOptList,   // list of options to save
    IN      LPWSTR                 AdapterName,   // adapter name
    IN      LPBYTE                 ClassName,     // the current class
    IN      DWORD                  ClassLen       // length of the above in bytes
);

BOOLEAN                                           // status
DhcpRegIsOptionChanged(
    IN      PLIST_ENTRY            SaveOptList,   // list of options to save
    IN      LPWSTR                 AdapterName,   // adapter name
    IN      LPBYTE                 ClassName,     // the current class
    IN      DWORD                  ClassLen       // length of the above in bytes
);

DWORD                                             // status
DhcpRegReadOptionCache(                           // read the list of options from cache
    IN OUT  PLIST_ENTRY            OptionsList,   // add the options to this list
    IN      HKEY                   KeyHandle,     // registry key where options are stored
    IN      LPWSTR                 ValueName      // name of the value holding the options blob
);

POPTION                                           // option from which more appends can occur
DhcpAppendSendOptions(                            // append all configured options
    IN OUT  PDHCP_CONTEXT          DhcpContext,   // this is the context to append for
    IN      PLIST_ENTRY            SendOptionsList,
    IN      LPBYTE                 ClassName,     // current class
    IN      DWORD                  ClassLen,      // len of above in bytes
    IN      LPBYTE                 BufStart,      // start of buffer
    IN      LPBYTE                 BufEnd,        // how far can we go in this buffer
    IN OUT  LPBYTE                 SentOptions,   // BoolArray[OPTION_END+1] to avoid repeating options
    IN OUT  LPBYTE                 VSentOptions,  // to avoid repeating vendor specific options
    IN OUT  LPBYTE                 VendorOpt,     // Buffer[OPTION_END+1] Holding Vendor specific options
    OUT     LPDWORD                VendorOptLen   // the # of bytes filled into that
);

DWORD                                             // status
DhcpAddIncomingOption(                            // this option just arrived, add it to list
    IN      LPWSTR                 AdapterName,   // which adapter to add option for
    IN OUT  PLIST_ENTRY            RecdOptionsList,
    IN      DWORD                  OptionId,      // option id of the option
    IN      BOOL                   IsVendor,      // is it vendor specific?
    IN      LPBYTE                 ClassName,     // what is the class name?
    IN      DWORD                  ClassLen,      // what is the class name's lenght in bytes?
    IN      DWORD                  ServerId,      // server ip from which this option came
    IN      LPBYTE                 Data,          // this is the real data value coming in
    IN      DWORD                  DataLen,       // the length of above in # of bytes
    IN      time_t                 ExpiryTime     // when does this option expire?
    IN      BOOL                   IsApiCall      // is this coming from an API call?
);

DWORD                                             // status
MadcapAddIncomingOption(                          // this option just arrived, add it to list
    IN OUT  PLIST_ENTRY            RecdOptionsList,
    IN      DWORD                  OptionId,      // option id of the option
    IN      DWORD                  ServerId,      // server ip from which this option came
    IN      LPBYTE                 Data,          // this is the real data value coming in
    IN      DWORD                  DataLen,       // the length of above in # of bytes
    IN      DWORD                  ExpiryTime     // when does this option expire?
);

DWORD                                             // status
DhcpCopyFallbackOptions(                          // copies the Fallback options list to RecdOptionsList
    IN OUT  PDHCP_CONTEXT          DhcpContext,   // NIC context
    OUT     LPDHCP_IP_ADDRESS      Address,       // Fallback address as taken from option 50
    OUT     LPDHCP_IP_ADDRESS      SubnetMask     // SubnetMask as taken from option 1
);

DWORD                                             // status
DhcpDestroyOptionsList(                           // destroy a list of options, freeing up memory
    IN OUT  PLIST_ENTRY            OptionsList,   // this is the list of options to destroy
    IN      PLIST_ENTRY            ClassesList    // this is where to remove classes off
);

DWORD                                             // win32 status
DhcpClearAllOptions(                              // remove all turds from off registry
    IN OUT  PDHCP_CONTEXT          DhcpContext    // the context to clear for
);

DWORD                                             // status
DhcpRegSaveOptionAtLocation(                      // save this option at this particular location
    IN      PDHCP_OPTION           OptionInfo,    // optin to save
    IN      LPWSTR                 RegLocation,   // location to save at
    IN      DWORD                  RegValueType,  // type of the value to save at
    IN      BOOL                   SpecialCase    // dirty downward compatabiltiy?
);

DWORD                                             // status
DhcpRegSaveOptionAtLocationEx(                    // save the option in the required place in registry
    IN      PDHCP_OPTION           OptionInfo,    // save THIS option
    IN      LPWSTR                 AdapterName,   // for this adpater,
    IN      LPWSTR                 RegLocMZ,      // multiple locations in the registry
    IN      DWORD                  SaveValueType  // What is the type of the value?
);

DWORD
DhcpRegDeleteIpAddressAndOtherValues(             // delete IPAddress, SubnetMask values from off key
    IN      HKEY                   Key            // handle to adapter regkey..
);


DWORD                                             // status
DhcpRegClearOptDefs(                              // clear all standard options
    IN      LPWSTR                 AdapterName    // clear for this adapter
);


#endif OPTREG_H

// internal private function that takes the lock on OPTIONS_LIST

//--------------------------------------------------------------------------------
// function definitions
//--------------------------------------------------------------------------------


DWORD                                             // status
DhcpRegReadOptionDef(                             // read the definition for a single key
    IN      LPWSTR                 KeyLocation    // where to look for thekey
) {
    HKEY                           Key;
    LPWSTR                         RegSendLoc;
    LPWSTR                         RegSaveLoc;
    LPBYTE                         ClassId;
    LPBYTE                         NewClass;
    DWORD                          ClassIdLen;
    DWORD                          ValueType;
    DWORD                          ValueSize;
    DWORD                          DwordValue;
    DWORD                          OptionId;
    DWORD                          IsVendor;
    DWORD                          Tmp;
    DWORD                          RegSaveType;
    DWORD                          Error;

    DhcpPrint((DEBUG_OPTIONS, "DhcpRegReadOptionDef %ws entered\n", KeyLocation));

    Error = RegOpenKeyEx(
        HKEY_LOCAL_MACHINE,
        KeyLocation,
        0 /* Reserved */,
        DHCP_CLIENT_KEY_ACCESS,
        &Key
    );

    if( ERROR_SUCCESS != Error ) return Error;

    ClassId = NULL;
    ClassIdLen = 0;
    RegSendLoc = NULL;
    RegSaveLoc = NULL;

    Error = DhcpGetRegistryValueWithKey(
        Key,
        DHCP_OPTION_OPTIONID_VALUE,
        DHCP_OPTION_OPTIONID_TYPE,
        (LPVOID)&OptionId
    );
    if( ERROR_SUCCESS != Error ) {                // try to get optid from KeyLocation..
        LPWSTR                     Tmp;

        if( Tmp = wcsrchr(KeyLocation, REGISTRY_CONNECT) ) {
            OptionId = _wtol(Tmp+1);
            if( 0 == OptionId || (~0) == OptionId ) {
                return Error;                     // barf... our guess was wrong..
            }
        } else return Error;                      // barf... our guess was wrong
    }

    Error = DhcpGetRegistryValueWithKey(
        Key,
        DHCP_OPTION_ISVENDOR_VALUE,
        DHCP_OPTION_ISVENDOR_TYPE,
        (LPVOID)&IsVendor
    );
    if( ERROR_SUCCESS != Error ) {
        IsVendor = FALSE;
    }

    Error = DhcpGetRegistryValueWithKey(
        Key,
        DHCP_OPTION_SAVE_TYPE_VALUE,
        DHCP_OPTION_SAVE_TYPE_TYPE,
        (LPVOID)&RegSaveType
    );
    if( ERROR_SUCCESS != Error ) {
        goto Cleanup;
    }

    ValueSize = 0;
    Error = RegQueryValueEx(
        Key,
        DHCP_OPTION_CLASSID_VALUE,
        0 /* Reserved */,
        &ValueType,
        NULL,
        &ValueSize
    );

    if( ERROR_SUCCESS == Error && 0 != ValueSize ) {
        ClassId = DhcpAllocateMemory(ValueSize);
        Error = RegQueryValueEx(
            Key,
            DHCP_OPTION_CLASSID_VALUE,
            0 /* Reserved */,
            &ValueType,
            ClassId,
            &ValueSize
        );
        if( ERROR_SUCCESS != Error ) goto Cleanup;
        ClassIdLen = ValueSize;
    }

    Error = GetRegistryString(
        Key,
        DHCP_OPTION_SAVE_LOCATION_VALUE,
        &RegSaveLoc,
        &Tmp
    );
    if( ERROR_SUCCESS != Error || 0 == Tmp ) {
        RegSaveLoc = NULL;
        Tmp = 0;
    } else if( 0 == wcslen(RegSaveLoc) ) {               // as good as not having this element
        DhcpFreeMemory(RegSaveLoc);
        RegSaveLoc = NULL;
        Tmp = 0;
    }

    if( Tmp ) {                                   // if this string is REG_SZ convert to REG_MULTI
        if( (1+wcslen(RegSaveLoc))*sizeof(WCHAR) == Tmp ) {
            LPWSTR TmpStr = DhcpAllocateMemory(Tmp+sizeof(WCHAR));
            DhcpPrint((DEBUG_MISC, "Converting <%ws> to MULTI_SZ\n", RegSaveLoc));
            if( NULL == TmpStr) {
                Error = ERROR_NOT_ENOUGH_MEMORY;
                goto Cleanup;
            }
            memcpy((LPBYTE)TmpStr, (LPBYTE)RegSaveLoc, Tmp);
            *((LPWSTR)(Tmp + (LPBYTE)TmpStr)) = L'\0';
            DhcpFreeMemory(RegSaveLoc);
            RegSaveLoc = TmpStr;
        }
    }

    Error = GetRegistryString(
        Key,
        DHCP_OPTION_SEND_LOCATION_VALUE,
        &RegSendLoc,
        &Tmp
    );
    if( ERROR_SUCCESS != Error || 0 == Tmp) {
        RegSendLoc = NULL;
        Tmp = 0;
    } else if( 0 == wcslen(RegSendLoc) ) {        // this is as good as string not existing
        DhcpFreeMemory(RegSendLoc);
        RegSendLoc = NULL;
        Tmp = 0;
    }

    if( Tmp ) {                                   // if this string is REG_SZ convert to REG_MULTI
        if( (1+wcslen(RegSendLoc))*sizeof(WCHAR) == Tmp ) {
            LPWSTR TmpStr = DhcpAllocateMemory(Tmp+sizeof(WCHAR));
            DhcpPrint((DEBUG_MISC, "Converting <%ws> to MULTI_SZ\n", RegSendLoc));
            if( NULL == TmpStr) {
                Error = ERROR_NOT_ENOUGH_MEMORY;
                goto Cleanup;
            }
            memcpy((LPBYTE)TmpStr, (LPBYTE)RegSendLoc, Tmp);
            *((LPWSTR)(Tmp + (LPBYTE)TmpStr)) = L'\0';
            DhcpFreeMemory(RegSendLoc);
            RegSendLoc = TmpStr;
        }
    }

    if(ClassIdLen) {
        NewClass = DhcpAddClass(
            &DhcpGlobalClassesList,
            ClassId,
            ClassIdLen
        );
        if( NULL == NewClass ) {
            Error = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }
    } else {
        NewClass = NULL;
    }


    Error = DhcpAddOptionDef(
        &DhcpGlobalOptionDefList,
        OptionId,
        IsVendor?TRUE:FALSE,
        NewClass,
        ClassIdLen,
        RegSendLoc,
        RegSaveLoc,
        RegSaveType
    );

    if( ERROR_SUCCESS != Error && ClassIdLen) {
        DhcpDelClass(&DhcpGlobalClassesList, NewClass, ClassIdLen);
    }

  Cleanup:

    if( ClassId ) DhcpFreeMemory(ClassId);
    if( RegSendLoc ) DhcpFreeMemory(RegSendLoc);
    if( RegSaveLoc ) DhcpFreeMemory(RegSaveLoc);
    if( Key ) RegCloseKey(Key);

    DhcpPrint((DEBUG_OPTIONS, "DhcpRegReadOptionDef(%ws):%ld\n", KeyLocation, Error));
    return Error;
}


DWORD                                             // status
DhcpRegReadOptionDefList(                         // fill DhcpGlobalOptionDefList
    VOID
) {
    HKEY                           Key;
    LPWSTR                         CurrentKey;
    LPWSTR                         KeyBuffer;
    LPWSTR                         KeysListAlloced, KeysList;
    LPWSTR                         Tmp;
    DWORD                          ValueSize;
    DWORD                          ValueType;
    DWORD                          MaxKeySize, KeySize;
    DWORD                          Error;

#if 1
    Error = DhcpAddOptionDef(
        &DhcpGlobalOptionDefList,
        0x6,
        FALSE,
        NULL,
        0,
        NULL,
        L"SYSTEM\\CurrentControlSet\\Services\\Tcpip\\Parameters\\DhcpNameServer\0"
        L"SYSTEM\\CurrentControlSet\\Services\\Tcpip\\Parameters\\Interfaces\\?\\DhcpNameServer\0\0",
        0x3
    );
    Error = DhcpAddOptionDef(
        &DhcpGlobalOptionDefList,
        0xf,
        FALSE,
        NULL,
        0,
        NULL,
        L"SYSTEM\\CurrentControlSet\\Services\\Tcpip\\Parameters\\DhcpDomain\0"
        L"SYSTEM\\CurrentControlSet\\Services\\Tcpip\\Parameters\\Interfaces\\?\\DhcpDomain\0\0",
        0x1
    );
    Error = DhcpAddOptionDef(
        &DhcpGlobalOptionDefList,
        0x2c,
        FALSE,
        NULL,
        0,
        NULL,
        L"SYSTEM\\CurrentControlSet\\Services\\NetBT\\Parameters\\Interfaces\\Tcpip_?\\DhcpNameServerList\0\0",
        0x3
    );

    Error = DhcpAddOptionDef(
        &DhcpGlobalOptionDefList,
        OPTION_PARAMETER_REQUEST_LIST,
        FALSE,
        NULL,
        0,
        DEFAULT_REGISTER_OPT_LOC L"\0\0",
        NULL,
        0
    );

#endif

    Error = RegOpenKeyEx(
        HKEY_LOCAL_MACHINE,
        DHCP_CLIENT_OPTION_KEY,
        0 /* Reserved */,
        DHCP_CLIENT_KEY_ACCESS,
        &Key
    );

    if( ERROR_SUCCESS != Error ) return Error;

    KeysList = NULL;
    Error = GetRegistryString(
        Key,
        DHCP_OPTION_LIST_VALUE,
        &KeysList,
        &ValueSize
    );

    RegCloseKey(Key);                             // dont need this key anymore
    if( ERROR_SUCCESS != Error || 0 == ValueSize ) {
        DhcpPrint((DEBUG_TRACE, "GetRegistryString(%ws):%ld\n", DHCP_OPTION_LIST_VALUE, Error));
        KeysList = DEFAULT_DHCP_KEYS_LIST_VALUE;
        KeysListAlloced = NULL;                   // nothing allocated
    } else {
        KeysListAlloced = KeysList;
    }

    Tmp = KeysList; MaxKeySize = 0;
    while( KeySize = wcslen(Tmp) ) {
        if( KeySize > MaxKeySize) MaxKeySize = KeySize;
        Tmp += KeySize + 1;
    }

    MaxKeySize *= sizeof(WCHAR);
    MaxKeySize += sizeof(DHCP_CLIENT_OPTION_KEY) + sizeof(REGISTRY_CONNECT_STRING);

    KeyBuffer = DhcpAllocateMemory(MaxKeySize);   // allocate buffer to hold key names
    if( NULL == KeyBuffer ) {
        if(KeysListAlloced) DhcpFreeMemory(KeysListAlloced);
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    memcpy((LPBYTE)KeyBuffer, (LPBYTE)DHCP_CLIENT_OPTION_KEY, sizeof(DHCP_CLIENT_OPTION_KEY));
    CurrentKey = (LPWSTR)(sizeof(DHCP_CLIENT_OPTION_KEY) + (LPBYTE)KeyBuffer);
    CurrentKey[-1] = REGISTRY_CONNECT;            // this would be L'\0', so correct it
    Tmp = KeysList;
    while( KeySize = wcslen(Tmp) ) {              // now add each key's information onto option defs
        wcscpy(CurrentKey, Tmp);
        Tmp += KeySize + 1;
        (void)DhcpRegReadOptionDef(KeyBuffer);    // add this key to the option def list
    }

    if(KeysListAlloced) DhcpFreeMemory(KeysListAlloced);
    DhcpFreeMemory(KeyBuffer);

    return ERROR_SUCCESS;
}

DWORD                                             // status
DhcpRegFillSendOptions(                           // fill in the list of options for SENDING
    IN OUT  PLIST_ENTRY            SendOptList,   // list to add too
    IN      LPWSTR                 AdapterName,   // adapter name to fill for
    IN      LPBYTE                 ClassId,       // class id to assume for filling
    IN      DWORD                  ClassIdLen     // the length of the classId in bytes
) {
    PLIST_ENTRY                    ThisEntry;
    PDHCP_OPTION_DEF               ThisOptDef;
    LPBYTE                         Tmp;
    LPBYTE                         Value;
    DWORD                          ValueSize;
    DWORD                          ValueType;
    DWORD                          Error;


    ThisEntry = DhcpGlobalOptionDefList.Blink;

    while( ThisEntry != &DhcpGlobalOptionDefList){// try each element of the global def list
        ThisOptDef = CONTAINING_RECORD(ThisEntry, DHCP_OPTION_DEF, OptionDefList);
        ThisEntry = ThisEntry->Blink;

        if( NULL == ThisOptDef->RegSendLoc )      // no send option defined
            continue;

        if( ThisOptDef->ClassLen ) {              // this is a class based option
            if( ThisOptDef->ClassLen != ClassIdLen ) continue;
            if( ThisOptDef->ClassName != ClassId ) continue;

            Tmp = DhcpAddClass(
                &DhcpGlobalClassesList,
                ThisOptDef->ClassName,
                ThisOptDef->ClassLen
            );

            if( Tmp != ThisOptDef->ClassName ) {
                DhcpAssert( Tmp );
                DhcpAssert( Tmp == ThisOptDef->ClassName);
                continue;
            }
        } else {
            Tmp = NULL;
        }

        // Either ClassIdLen of ThisOptDef is zero, or there is a genuine match
        Error = DhcpRegReadFromAnyLocation(
            ThisOptDef->RegSendLoc,
            AdapterName,
            &Value,
            &ValueType,
            &ValueSize
        );

        if( ERROR_SUCCESS != Error || 0 == ValueSize ) {
            DhcpPrint((DEBUG_MISC, "Not sending option: <%ws>\n", ThisOptDef->RegSendLoc));
            if( Tmp ) (void)DhcpDelClass(&DhcpGlobalClassesList, Tmp, ThisOptDef->ClassLen);
            continue;                             // nothing to send
        }

        Error = DhcpAddOption(                    // add this option
            SendOptList,                          // to this list
            ThisOptDef->OptionId,                 // option id to add
            ThisOptDef->IsVendor,                 // vendor spec info
            ThisOptDef->ClassName,                // name of the class (byte stream)
            ThisOptDef->ClassLen,                 // # of bytes in above parameter
            0,                                    // don't care about serverid
            Value,                                // this is the data to send
            ValueSize,                            // # of bytes of above parameter
            0                                     // no meaning for expiry time
        );

        if( ERROR_SUCCESS != Error ) {            // something went wrong. continue, but print error
            DhcpPrint((DEBUG_ERRORS, "DhcpAddOption(%ld, %s): %ld\n",
                       ThisOptDef->OptionId, ThisOptDef->IsVendor?"Vendor":"NotVendor", Error));
            if( Tmp ) (void)DhcpDelClass(&DhcpGlobalClassesList, Tmp, ThisOptDef->ClassLen);
        }

        if( Value ) DhcpFreeMemory(Value);
    }

    return ERROR_SUCCESS;
}

static
struct /* anonymous */ {
    DWORD                          Option;
    DWORD                          RegValueType;
} OptionRegValueTypeTable[] = {
    OPTION_SUBNET_MASK,            REG_MULTI_SZ,
    OPTION_ROUTER_ADDRESS,         REG_MULTI_SZ,
    OPTION_NETBIOS_NODE_TYPE,      REG_DWORD,
    //    OPTION_NETBIOS_SCOPE_OPTION,   REG_SZ,
    //    OPTION_DOMAIN_NAME,            REG_SZ,
    OPTION_DOMAIN_NAME_SERVERS,    REG_SZ,
    OPTION_NETBIOS_NAME_SERVER,    REG_MULTI_SZ,
    0,                             0,
};

DWORD                                             // status
DhcpRegSaveOptionAtLocation(                      // save this option at this particular location
    IN      PDHCP_OPTION           OptionInfo,    // optin to save
    IN      LPWSTR                 RegLocation,   // location to save at
    IN      DWORD                  RegValueType,  // type of the value to save at
    IN      BOOL                   SpecialCase    // dirty downward compatabiltiy?
) {
    LPWSTR                         ValueName;
    DWORD                          Error;
    HKEY                           Key;
    WCHAR                          wBuffer[500];  // options cannot be longer than 256!
    BYTE                           bBuffer[500];
    LPVOID                         Data;
    DWORD                          DataLen, DwordData;

    if( OptionInfo->IsVendor ) SpecialCase = FALSE;

    ValueName = wcsrchr(RegLocation, REGISTRY_CONNECT);
    if( NULL != ValueName ) *ValueName++ = L'\0';

    Error = RegOpenKeyEx(
        HKEY_LOCAL_MACHINE,
        RegLocation,
        0 /* Reserved */,
        DHCP_CLIENT_KEY_ACCESS,
        &Key
    );

    if( ERROR_SUCCESS != Error )
        return Error;

    if( 0 == OptionInfo->DataLen ) {
        Error = RegDeleteValue(Key, ValueName);
        RegCloseKey(Key);
        return Error;
    }

    if( SpecialCase ) {
        LPSTR                      StringAddress;
        WCHAR                      LpwstrValueStack[500];
        LPWSTR                     LpwstrValueHeap;
        LPWSTR                     LpwstrValue;
        LPWSTR                     Tmp;
        LPWSTR                     PrimaryServer, SecondaryServer;
        DWORD                      LpwstrValueSize;
        DWORD                      DwordIpAddress;
        DWORD                      i, count;

        LpwstrValueHeap = NULL;
        LpwstrValue = NULL;
        LpwstrValueSize = 0;

        if(OptionInfo->DataLen ) {
            switch(OptionInfo->OptionId) {
            case OPTION_SUBNET_MASK:
            case OPTION_ROUTER_ADDRESS:
            case OPTION_NETBIOS_NAME_SERVER:      // this is also a REG_SZ LPWSTR format (space separated again)
            case OPTION_DOMAIN_NAME_SERVERS:      // these two are REG_SZ of ip addresses (space separated)
                LpwstrValueSize = sizeof(L"XXX.XXX.XXX.XXX.")*(OptionInfo->DataLen)/sizeof(DWORD);
                if( LpwstrValueSize > sizeof(LpwstrValueStack) ) {
                    LpwstrValue = LpwstrValueHeap = DhcpAllocateMemory(LpwstrValueSize);
                    if( NULL == LpwstrValue ) {
                        return ERROR_NOT_ENOUGH_MEMORY;
                    }
                } else {                          // just use the stack for reqd memory
                    LpwstrValue = LpwstrValueStack;
                }

                Tmp = LpwstrValue;                // convert OptionInfo->Data into REG_MULTI_SZ
                for( i = 0; i < OptionInfo->DataLen/sizeof(DWORD); i ++ ) {
                    DwordIpAddress = ((DWORD UNALIGNED *)OptionInfo->Data)[i];
                    StringAddress = inet_ntoa(*(struct in_addr *)&DwordIpAddress);
                    Tmp = DhcpOemToUnicode(StringAddress, Tmp);
                    DhcpPrint((DEBUG_DNS, "DNS: Converted address %ws to unicode\n", Tmp));
                    Tmp += wcslen(Tmp) +1;
                }
                wcscpy(Tmp, L"");
                Tmp += wcslen(Tmp);
                LpwstrValueSize = (DWORD)(Tmp-LpwstrValue+1)*sizeof(WCHAR);
                break;                            // completed conversion
            case OPTION_NETBIOS_NODE_TYPE:        // this is a dword, but we make it look like a lpwstr
                if( 1 == OptionInfo->DataLen ) {  // must be exactly one byte
                    count = *(OptionInfo->Data);  // overload the value count..
                } else count = 1;                 // default is BNODE
                LpwstrValue = (LPWSTR)&count;     // does not matter.. we use the right type later on
                LpwstrValueSize = sizeof(count);  // this is needed to keep track of right size
                break;
            }

            i = 1;
            if( OPTION_NETBIOS_NAME_SERVER == OptionInfo->OptionId ) {

                if( 0 == LpwstrValueSize ) {
                    LpwstrValue = L"";
                    LpwstrValueSize = sizeof(L"");
                }
            }

            if( OPTION_DOMAIN_NAME_SERVERS == OptionInfo->OptionId ) {
                LpwstrValueSize -= sizeof(WCHAR);     // remove the last NULL string
                count = OptionInfo->DataLen/sizeof(DWORD);
                Tmp = LpwstrValue;
                for(; i < count ; i ++ ) {            // for each of them, convert the ending to a space
                    Tmp += wcslen(Tmp);               // skip to the end of the string
                    *Tmp++ = L' ';                    // replace the L'\0' with a L' ' instead
                }
                DhcpPrint((DEBUG_DNS, "DNS Server list = %ws\n", LpwstrValue));

            }
        }

        for( i = 0; OptionRegValueTypeTable[i].Option; i ++ ) {
            if( OptionInfo->OptionId == OptionRegValueTypeTable[i].Option ) {

                Error = RegSetValueEx(
                    Key,
                    ValueName,
                    0 /* Reserved */,
                    OptionRegValueTypeTable[i].RegValueType,
                    (LPBYTE)LpwstrValue,
                    LpwstrValueSize
                );
                if( ERROR_SUCCESS != Error) {     // something went wrong? just print error and quit
                    DhcpPrint((DEBUG_ERRORS, "RegSetValueEx(%ws):%ld\n", ValueName, Error));
                }
              Cleanup:
                RegCloseKey(Key);
                if( LpwstrValueHeap ) DhcpFreeMemory(LpwstrValueHeap);
                return Error;
            }
        }
    }

    if( REG_SZ == RegValueType || REG_MULTI_SZ == RegValueType ) {
        if( OptionInfo->DataLen ) {
            DataLen = OptionInfo->DataLen;
            Data = AsciiNulTerminate(OptionInfo->Data, &DataLen, bBuffer, sizeof(bBuffer));
            Data = DhcpOemToUnicode(Data, wBuffer);
            DataLen = wcslen(Data)+2;             // two nul termination characters
            ((LPWSTR)Data)[DataLen] = L'\0';
            DataLen *= sizeof(WCHAR);
            if( REG_SZ == RegValueType ) DataLen -= sizeof(WCHAR);
        }

    } else if( REG_DWORD == RegValueType ) {
        if( sizeof(DWORD) != OptionInfo->DataLen ) {
            DhcpPrint((DEBUG_ERRORS, "Regvalue DWORD has got wrong size.. option ignored\n"));
            Data = NULL;
            DataLen = 0;
        } else {
            DwordData = ntohl(*(DWORD UNALIGNED*)(OptionInfo->Data));
            Data = &DwordData;
            DataLen = sizeof(DWORD);
        }
    } else {
        Data = OptionInfo->Data;
        DataLen = OptionInfo->DataLen;
    }

    Error = RegSetValueEx(
        Key,
        ValueName,
        0 /* Reserved */,
        RegValueType,
        Data,
        DataLen
    );
    RegCloseKey(Key);

    if( ERROR_SUCCESS != Error ) {
        DhcpPrint((DEBUG_ERRORS, "RegSetValueEx(%ws):%ld\n", ValueName, Error));
    }
    return Error;
}

DWORD                                             // status
DhcpRegSaveOptionAtLocationEx(                    // save the option in the required place in registry
    IN      PDHCP_OPTION           OptionInfo,    // save THIS option
    IN      LPWSTR                 AdapterName,   // for this adpater,
    IN      LPWSTR                 RegLocMZ,      // multiple locations in the registry
    IN      DWORD                  SaveValueType  // What is the type of the value?
) {
    DWORD                          StrSize;
    DWORD                          Error;
    DWORD                          LastError;
    LPWSTR                         RegExpandedLocation;
    BOOL                           SpecialCase = TRUE;

    // for each location: expand the location and (for each option attrib save the option in the location)
    for( LastError = ERROR_SUCCESS ; StrSize = wcslen(RegLocMZ); RegLocMZ += StrSize + 1) {

        Error = DhcpRegExpandString(              // expand each location into full string
            RegLocMZ,
            AdapterName,
            &RegExpandedLocation,
            NULL
        );
        if( ERROR_SUCCESS != Error ) {
            DhcpPrint((DEBUG_ERRORS, "DhcpRegExpandString(%ws):%ld\n", RegLocMZ, Error));
            LastError = Error;
        } else {
            if( OPTION_NETBIOS_NODE_TYPE == OptionInfo->OptionId
                && 0 == OptionInfo->DataLen ) {
                //
                // If no node type value, do not delete it.
                //
                Error = NO_ERROR;
            } else {
                Error = DhcpRegSaveOptionAtLocation(
                    OptionInfo, RegExpandedLocation, SaveValueType, SpecialCase
                    );
            }
            
            if( ERROR_SUCCESS != Error) {
                DhcpPrint((DEBUG_ERRORS, "DhcpRegSaveOptionAtLocation(%ld,%ws):%ld\n",
                           OptionInfo->OptionId, RegExpandedLocation, Error));
                LastError = Error;
            }
        }

        // SpecialCase = FALSE;
        if(RegExpandedLocation) DhcpFreeMemory(RegExpandedLocation);
    }

    return LastError;
}


DWORD                                             // status
DhcpRegSaveOption(                                // save the option in the required place in registry
    IN      PDHCP_OPTION           OptionInfo,    // this is the option to save
    IN      LPWSTR                 AdapterName    // this is the adapter for which the option is being saved
) {
    PDHCP_OPTION_DEF               OptDef;        // the definition for this option
    DWORD                          Error;         // did anything go wrong?

    OptDef = DhcpFindOptionDef(                   // find the defn for this option WITH class
        &DhcpGlobalOptionDefList,
        OptionInfo->OptionId,
        OptionInfo->IsVendor,
        OptionInfo->ClassName,
        OptionInfo->ClassLen
    );

    if( NULL != OptDef && NULL != OptDef->RegSaveLoc ) {
        Error = DhcpRegSaveOptionAtLocationEx(OptionInfo, AdapterName, OptDef->RegSaveLoc, OptDef->RegValueType);
        if( ERROR_SUCCESS != Error ) {
            DhcpPrint((DEBUG_MISC, "DhcpRegSaveOptionAtLocationEx <%ld,%s>: %ld\n",
                       OptionInfo->OptionId, OptionInfo->IsVendor?"Vendor":"NotVendor", Error));
        }
    } else Error = ERROR_SUCCESS;

    if( !OptionInfo->ClassLen ) return Error;     // if no class existed already, nothing more to do.

    Error = ERROR_SUCCESS;
    OptDef = DhcpFindOptionDef(                   // now try the generic option storage location, maybe
        &DhcpGlobalOptionDefList,
        OptionInfo->OptionId,
        OptionInfo->IsVendor,
        NULL,
        0
    );


    if( NULL != OptDef && NULL != OptDef->RegSaveLoc ) {
        Error = DhcpRegSaveOptionAtLocationEx(OptionInfo, AdapterName, OptDef->RegSaveLoc, OptDef->RegValueType);
        if( ERROR_SUCCESS != Error ) {
            DhcpPrint((DEBUG_MISC, "DhcpRegSaveOptionAtLocationEx <%ld,%s>: %ld\n",
                       OptionInfo->OptionId, OptionInfo->IsVendor?"Vendor":"NotVendor", Error));
        }
    }

    if( ERROR_SUCCESS != Error ) {
        DhcpPrint((DEBUG_OPTIONS, "DhcpRegSaveOption(%lx, %s):%ld\n", OptionInfo->OptionId, AdapterName, Error));
    }
    return Error;
}

DWORD
DhcpRegSaveOptions(
    IN PLIST_ENTRY SaveOptList,
    IN LPWSTR AdapterName,
    IN LPBYTE ClassName,
    IN DWORD ClassLen
)
/*++

Routine Description:
    This routine saves the options in SaveOptList onto the registry.   On
    NT this saving onto places defined in the global option definitino
    list.

    In any case, all the optiosn are blobb'ed together as defined below and
    then saved into one registry value under the key given by adaptername.

    OPTION binary structure:
        Each option is formatted as follows (rounded up by alignment)
        DWORD network order option ID, DWORD class id length, DWORD Option
        Length, DWORD IsVendor, DWORD ExpiryTime, class id information, option info

Arguments:
    SaveOptList -- options to save
    AdapterName -- name of adapter
    ClassName -- class the current option belongs to
    ClassLen -- length of above in bytes.

Return Value:
    Status

--*/
{
    PLIST_ENTRY ThisEntry;
    PDHCP_OPTION_DEF ThisOptDef;
    PDHCP_OPTION ThisOpt;
    LPBYTE Tmp, Value;
    DWORD ValueSize, ValueType, Count, BlobSize, BlobSizeTmp, Error;

#ifdef NEWNT
    //
    // First clear the setof defined options
    //
    (void)DhcpRegClearOptDefs(AdapterName);

#endif

    Error = ERROR_SUCCESS;

    Count = BlobSize = 0;
    ThisEntry = SaveOptList->Flink;
    while(ThisEntry != SaveOptList ) {
        ThisOpt = CONTAINING_RECORD(ThisEntry, DHCP_OPTION, OptionList);
        ThisEntry = ThisEntry->Flink;

        Count ++;

#ifdef NEWNT
        if( ThisOpt->ClassLen == ClassLen
            && ThisOpt->ClassName == ClassName ) {
            Error = DhcpRegSaveOption(
                ThisOpt,
                AdapterName
            );

            if( ERROR_SUCCESS != Error ) {
                DhcpPrint((DEBUG_MISC, "Could not save option <%ld, %s>:"
                           " %ld\n", ThisOpt->OptionId,
                           ThisOpt->IsVendor?"Vendor":"NotVendor", Error));
            }
        }
#endif

        BlobSizeTmp = sizeof(DWORD) + sizeof(DWORD) + sizeof(DWORD) +
            sizeof(DWORD) + sizeof(DWORD) +
            ThisOpt->ClassLen + ThisOpt->DataLen;
        BlobSize += ROUND_UP_COUNT(BlobSizeTmp, ALIGN_DWORD);
    }

    if( ERROR_SUCCESS != Error ) {
        DhcpPrint((DEBUG_MISC, "RegSaveOptionCache(%ld):%ld\n", Count, Error));
    }

    if( 0 == Count ) {
        //
        // Need to delete the registry value
        //
        Tmp = NULL;
        return RegDeleteValue(
            DhcpGlobalParametersKey, AdapterName
            );

    } else {
        //
        // Need to allocate and fill in the option values
        //
        Tmp = DhcpAllocateMemory( BlobSize );
        if( NULL == Tmp ) return ERROR_NOT_ENOUGH_MEMORY;
    }

    Value = Tmp;
    ThisEntry = SaveOptList->Flink;
    while( ThisEntry != SaveOptList ) {
        ThisOpt = CONTAINING_RECORD(
            ThisEntry, DHCP_OPTION, OptionList
            );
        ThisEntry = ThisEntry->Flink;

        *((ULONG *)Tmp) ++ = (ULONG)ThisOpt->OptionId;
        *((ULONG *)Tmp) ++ = (ULONG)ThisOpt->ClassLen;
        *((ULONG *)Tmp) ++ = (ULONG)ThisOpt->DataLen;
        *((ULONG *)Tmp) ++ = (ULONG)ThisOpt->IsVendor;
        *((ULONG *)Tmp) ++ = (ULONG)ThisOpt->ExpiryTime;
        if( 0 != ThisOpt->ClassLen ) {
            memcpy(Tmp, ThisOpt->ClassName, ThisOpt->ClassLen);
            Tmp += ThisOpt->ClassLen;
        }
        if( 0 != ThisOpt->DataLen ) {
            memcpy(Tmp, ThisOpt->Data, ThisOpt->DataLen);
            Tmp += ThisOpt->DataLen;
        }
        Tmp = ROUND_UP_POINTER(Tmp, ALIGN_DWORD);
    }

    Error = RegSetValueEx(
        DhcpGlobalParametersKey,
        AdapterName,
        0 /* Reserved */,
        REG_BINARY,
        Value,
        BlobSize
        );

    DhcpFreeMemory(Value);
    return Error;
}

DWORD
DhcpRegReadOptionCache(
    IN OUT  PLIST_ENTRY            OptionsList,
    IN      HKEY                   KeyHandle,
    IN      LPWSTR                 ValueName,
    IN      BOOLEAN                fAddClassName
)
/*++

Routine Description:
    Read the list of options saved in the cache for the given adapter name,
    and fill the OptionsList correspondingly.

    Note that the options are saved in the binary format defined in the
    RegSaveOptions function above.

Arguments:
    OptionsList -- add the options to this list
    KeyHandle -- registry key where options are stored
    ValueName -- name of the value holding the options blob

Return Value:
    Status

--*/
{
    DWORD Error, TmpSize, Size, ValueType;
    LPBYTE Tmp, Tmp2;

    Size = 0;
    Error = RegQueryValueEx(
        KeyHandle,
        ValueName,
        0 /* Reserved */,
        &ValueType,
        NULL,
        &Size
        );
    if( ERROR_SUCCESS != Error || 0 == Size ) return Error;

    Tmp = DhcpAllocateMemory(Size);
    if( NULL == Tmp ) return ERROR_NOT_ENOUGH_MEMORY;

    Error = RegQueryValueEx(
        KeyHandle,
        ValueName,
        0 /* Reserved */,
        &ValueType,
        Tmp,
        &Size
        );

    if( ERROR_SUCCESS != Error || 0 == Size ) {
        DhcpFreeMemory(Tmp);
        return Error;
    }

    Error = ERROR_SUCCESS;
    Tmp2 = Tmp;
    while( Size ) {
        ULONG OptId, ClassLen, DataLen;
        ULONG IsVendor, ExpiryTime;
        LPBYTE ClassName, Data;

        if( Size < 5 * sizeof(DWORD) ) break;
        OptId = *((ULONG *)Tmp) ++;
        ClassLen = *((ULONG *)Tmp) ++;
        DataLen = *((ULONG *)Tmp) ++;
        IsVendor = *((ULONG *)Tmp) ++;
        ExpiryTime = *((ULONG *)Tmp) ++;

        TmpSize = sizeof(ULONG)*5 + ClassLen + DataLen;
        TmpSize = ROUND_UP_COUNT(TmpSize, ALIGN_DWORD);
        if( TmpSize > Size ) break;

        if( 0 == ClassLen ) ClassName = NULL;
        else ClassName = Tmp;
        Tmp += ClassLen;

        if( 0 == DataLen ) Data = NULL;
        else Data = Tmp;
        Tmp += DataLen;

        Tmp = ROUND_UP_POINTER( Tmp, ALIGN_DWORD);
        Size -= TmpSize ;
        if( 0 == DataLen ) continue;

        if(fAddClassName && ClassName ) {
            ClassName = DhcpAddClass(
                &DhcpGlobalClassesList,
                ClassName,
                ClassLen
                );

            if( NULL == ClassName ) break;
        }
        Error = DhcpAddOption(
            OptionsList,
            (BYTE)OptId,
            IsVendor,
            ClassName,
            ClassLen,
            0,
            Data,
            DataLen,
            ExpiryTime
            );

        if( ERROR_SUCCESS != Error ) {
            if( fAddClassName && ClassName ) DhcpDelClass(
                &DhcpGlobalClassesList,
                ClassName,
                ClassLen
                );
            break;
        }
    }

    DhcpFreeMemory(Tmp2);
    return Error;
}

BOOLEAN
DhcpOptIsSubset(
    IN  PLIST_ENTRY OptList1,
    IN  PLIST_ENTRY OptList2
    )
/*++
Routine Description:
    This routine check if OptList1 is a subset of OptList2

Arguments:
    OptList1
    OptList2

Return Value:
    TRUE  if OptList1 is subset of OptList2
--*/
{
    PLIST_ENTRY ThisEntry1, ThisEntry2;
    PDHCP_OPTION ThisOpt1, ThisOpt2;

    ThisEntry1 = OptList1->Flink;
    while(ThisEntry1 != OptList1) {
        ThisOpt1 = CONTAINING_RECORD(ThisEntry1, DHCP_OPTION, OptionList);

        ThisEntry1 = ThisEntry1->Flink;
        if (ThisOpt1->OptionId == OPTION_MESSAGE_TYPE) {
            continue;       // Ignore this meaningless option
        }

        ThisEntry2 = OptList2->Flink;
        while(ThisEntry2 != OptList2) {
            ThisOpt2 = CONTAINING_RECORD(ThisEntry2, DHCP_OPTION, OptionList);

            if (ThisOpt2->OptionId == ThisOpt1->OptionId) {
                break;
            }
            ThisEntry2 = ThisEntry2->Flink;
        }
        if (ThisEntry2 == OptList2) {
            /* Option Id not found */
            return FALSE;
        }
        
        if (ThisOpt1->DataLen != ThisOpt2->DataLen ||
                memcmp(ThisOpt1->Data, ThisOpt2->Data, ThisOpt1->DataLen) != 0) {
            return FALSE;
        }
    }
    return TRUE;
}

BOOLEAN
DhcpRegIsOptionChanged(
    IN PLIST_ENTRY OptList,
    IN LPWSTR AdapterName,
    IN LPBYTE ClassName,
    IN DWORD ClassLen
)
/*++

Routine Description:
    This routine compare the options with those cached in registry.

Arguments:
    OptList -- options to compare
    AdapterName -- name of adapter
    ClassName -- class the current option belongs to
    ClassLen -- length of above in bytes.

Return Value:
    TRUE  if something is changed

--*/
{
    DWORD   Error;
    LIST_ENTRY  RegOptList;
    BOOLEAN fChanged;

    InitializeListHead(&RegOptList);
    Error = DhcpRegReadOptionCache(
            &RegOptList,
            DhcpGlobalParametersKey,
            AdapterName,
            FALSE                       // Don't modify DhcpGlobalClassesList
            );
    if (Error != ERROR_SUCCESS) {
        return TRUE;
    }

    fChanged = !DhcpOptIsSubset(OptList, &RegOptList) || !DhcpOptIsSubset(&RegOptList, OptList);
    DhcpDestroyOptionsList(&RegOptList, NULL);
    return fChanged;
}

LPBYTE                                            // ptr to buf loc where more appends can occur
DhcpAppendParamRequestList(                       // append the param request list option
    IN      PDHCP_CONTEXT          DhcpContext,   // the context to append for
    IN      PLIST_ENTRY            SendOptionsList,// look thru this list
    IN      LPBYTE                 ClassName,     // which class does this belong to?
    IN      DWORD                  ClassLen,      // size of above in bytes
    IN      LPBYTE                 BufStart,      // where to start adding this option
    IN      LPBYTE                 BufEnd         // limit for this option
) {
    BYTE                           Buffer[OPTION_END+1];
    LPBYTE                         Tmp;
    DWORD                          FirstSize;
    DWORD                          Size;
    PLIST_ENTRY                    ThisEntry;
    PDHCP_OPTION                   ThisOpt;
    DWORD                          i, j;

    Size = FirstSize = 0;
    if( IS_DHCP_ENABLED( DhcpContext ) ) {
        //
        // do not append these for static adapters.
        //

        Buffer[Size++] = OPTION_SUBNET_MASK;          // standard requested options
        Buffer[Size++] = OPTION_DOMAIN_NAME;
        Buffer[Size++] = OPTION_ROUTER_ADDRESS;
        Buffer[Size++] = OPTION_DOMAIN_NAME_SERVERS;
        Buffer[Size++] = OPTION_NETBIOS_NAME_SERVER;
        Buffer[Size++] = OPTION_NETBIOS_NODE_TYPE;
        Buffer[Size++] = OPTION_NETBIOS_SCOPE_OPTION;
        Buffer[Size++] = OPTION_PERFORM_ROUTER_DISCOVERY;
        Buffer[Size++] = OPTION_STATIC_ROUTES;
        Buffer[Size++] = OPTION_CLASSLESS_ROUTES;
        Buffer[Size++] = OPTION_VENDOR_SPEC_INFO;
    }
    
    ThisEntry = SendOptionsList->Flink;
    while( ThisEntry != SendOptionsList ) {
        ThisOpt = CONTAINING_RECORD(ThisEntry, DHCP_OPTION, OptionList);
        ThisEntry = ThisEntry->Flink;

        if( ThisOpt->IsVendor) continue;

        if( ThisOpt->ClassLen ) {
            if( ThisOpt->ClassLen != ClassLen ) continue;
            if( ThisOpt->ClassName != ClassName )
                continue;                         // this option is not used for this client
        }

        if( OPTION_PARAMETER_REQUEST_LIST != ThisOpt->OptionId ) {
            //
            // only if the option is param_request_list do we request..
            //
            continue;
        }

        for( i = 0; i < ThisOpt->DataLen ; i ++ ) {
            for( j = 0; j < Size; j ++ )
                if( ThisOpt->Data[i] == Buffer[j] ) break;
            if( j < Size ) continue;              // option already plugged in
            Buffer[Size++] = ThisOpt->Data[i]; // add this option
        }

        if( 0 == FirstSize ) FirstSize = Size;
    }

    if( 0 == FirstSize ) FirstSize = Size;

    DhcpAddParamRequestChangeRequestList(         // add to this the registered ParamChangeRequestList
        ((PLOCAL_CONTEXT_INFO)DhcpContext->LocalInformation)->AdapterName,
        Buffer,
        &Size,
        ClassName,
        ClassLen
    );
    if( 0 == FirstSize ) FirstSize = Size;

    Tmp = BufStart;
    BufStart = (LPBYTE)DhcpAppendOption(          // now add the param request list
        (POPTION)BufStart,
        (BYTE)OPTION_PARAMETER_REQUEST_LIST,
        Buffer,
        (BYTE)Size,
        BufEnd
    );

    if( Tmp == BufStart ) {                       // did not really add the option
        BufStart = (LPBYTE)DhcpAppendOption(      // now try adding the first request we saw instead of everything
            (POPTION)BufStart,
            (BYTE)OPTION_PARAMETER_REQUEST_LIST,
            Buffer,
            (BYTE)FirstSize,
            BufEnd
        );
    }

    return BufStart;
}

POPTION                                           // option from which more appends can occur
DhcpAppendSendOptions(                            // append all configured options
    IN OUT  PDHCP_CONTEXT          DhcpContext,   // this is the context to append for
    IN      PLIST_ENTRY            SendOptionsList,
    IN      LPBYTE                 ClassName,     // current class
    IN      DWORD                  ClassLen,      // len of above in bytes
    IN      LPBYTE                 BufStart,      // start of buffer
    IN      LPBYTE                 BufEnd,        // how far can we go in this buffer
    IN OUT  LPBYTE                 SentOptions,   // BoolArray[OPTION_END+1] to avoid repeating options
    IN OUT  LPBYTE                 VSentOptions,  // to avoid repeating vendor specific options
    IN OUT  LPBYTE                 VendorOpt,     // Buffer[OPTION_END+1] Holding Vendor specific options
    OUT     LPDWORD                VendorOptLen   // the # of bytes filled into that
) {
    PLIST_ENTRY                    ThisEntry;
    PDHCP_OPTION                  ThisOpt;

    DhcpAssert(FALSE == SentOptions[OPTION_PARAMETER_REQUEST_LIST]);
    BufStart = DhcpAppendParamRequestList(
        DhcpContext,
        SendOptionsList,
        ClassName,
        ClassLen,
        BufStart,
        BufEnd
    );
    SentOptions[OPTION_PARAMETER_REQUEST_LIST] = TRUE;

    ThisEntry = SendOptionsList->Flink;
    while( ThisEntry != SendOptionsList ) {
        ThisOpt = CONTAINING_RECORD(ThisEntry, DHCP_OPTION, OptionList);
        ThisEntry = ThisEntry->Flink;

        if( ThisOpt->IsVendor ? VSentOptions[(BYTE)ThisOpt->OptionId] : SentOptions[(BYTE)ThisOpt->OptionId] )
            continue;

        // if( ThisOpt->IsVendor) continue;       // No vendor specific information this round through
        if( ThisOpt->ClassLen ) {
            if( ThisOpt->ClassLen != ClassLen ) continue;
            if( ThisOpt->ClassName != ClassName )
                continue;                         // this option is not used for this client
        }

        if( !ThisOpt->IsVendor ) {                // easy to add non-vendor spec options
            SentOptions[(BYTE)ThisOpt->OptionId] = TRUE;
            BufStart = (LPBYTE)DhcpAppendOption(
                (POPTION)BufStart,
                (BYTE)ThisOpt->OptionId,
                ThisOpt->Data,
                (BYTE)ThisOpt->DataLen,
                BufEnd
            );
        } else {                                  // ENCAPSULATE vendor specific options
            if( SentOptions[OPTION_VENDOR_SPEC_INFO] )
                continue;                         // Vendor spec info already added

            VSentOptions[(BYTE)ThisOpt->OptionId] = TRUE;

            if( ThisOpt->DataLen + 2 + *VendorOptLen > OPTION_END )
                continue;                         // this option overflows the buffer

            VendorOpt[(*VendorOptLen)++] = (BYTE)ThisOpt->OptionId;
            VendorOpt[(*VendorOptLen)++] = (BYTE)ThisOpt->DataLen;
            memcpy(&VendorOpt[*VendorOptLen], ThisOpt->Data, ThisOpt->DataLen);
            (*VendorOptLen) += ThisOpt->DataLen;
        }
    }
    return (POPTION)BufStart;
}

DWORD                                             // status
DhcpAddIncomingVendorOption(                      // unencapsulate a vendor specific option
    IN      LPWSTR                 AdapterName,
    IN OUT  PLIST_ENTRY            RecdOptionsList,
    IN      LPBYTE                 ClassName,     // input class
    IN      DWORD                  ClassLen,      // # of bytes of above
    IN      DWORD                  ServerId,      // server ip from which this option came
    IN      LPBYTE                 Data,          // actual option value is this
    IN      DWORD                  DataLen,       // # of bytes of option is this
    IN      time_t                 ExpiryTime,
    IN      BOOL                   IsApiCall      // is this call comming through the API?
) {
    DWORD                          i;
    DWORD                          Error;

    i = 0;
    while( i < DataLen && OPTION_END != Data[i] ){// dont go over the boundary
        if( OPTION_PAD == Data[i++]) continue;    // skip option_id part .. and start over if it is a PAD
        if( i >= DataLen ) return ERROR_INVALID_PARAMETER;
        i += Data[i]; i ++;                       // skip the full length of data
        if( i > DataLen ) return ERROR_INVALID_PARAMETER;
    }

    // we are here --> the option DOES look like it is encapsulated. let us unencapsulate it anyways
    i = 0;
    while( i < DataLen && OPTION_END != Data[i] ) {
        if( OPTION_PAD == Data[i] ) { i ++; continue; }
        Error = DhcpAddIncomingOption(            // now we can use our old friend to add this option
            AdapterName,
            RecdOptionsList,
            (DWORD)Data[i],
            TRUE,
            ClassName,
            ClassLen,
            ServerId,
            &Data[i+2],
            (DWORD)Data[i+1],
            ExpiryTime,
            IsApiCall
        );
        if( ERROR_SUCCESS != Error ) return Error;
        i += Data[i+1]; i += 2;
    }

    return ERROR_SUCCESS;
}


DWORD                                             // status
MadcapAddIncomingOption(                          // this option just arrived, add it to list
    IN OUT  PLIST_ENTRY            RecdOptionsList,
    IN      DWORD                  OptionId,      // option id of the option
    IN      DWORD                  ServerId,      // server ip from which this option came
    IN      LPBYTE                 Data,          // this is the real data value coming in
    IN      DWORD                  DataLen,       // the length of above in # of bytes
    IN      DWORD                  ExpiryTime     // when does this option expire?
)
{
    DWORD                          Error;
    PDHCP_OPTION                   OldOption;

    DhcpPrint((DEBUG_OPTIONS, "MadcapAddIncomingOption: OptionId %ld ServerId %ld\n",OptionId,ServerId));

    OldOption = DhcpFindOption(                   // is this already there?
        RecdOptionsList,
        OptionId,
        FALSE, // is vendor?
        NULL, // class name
        0,    // class len
        ServerId
    );

    if( NULL != OldOption ) {                     // If the option existed, delete it
        DhcpPrint((DEBUG_OPTIONS, "MadcapAddIncomingOption: OptionId %ld already exist\n",OptionId));
        return ERROR_SUCCESS;
    }

    Error = DhcpAddOption(                        // now add it freshly
        RecdOptionsList,
        OptionId,
        FALSE, // is vendor?
        NULL, // class name
        0, // class len
        ServerId,
        Data,
        DataLen,
        ExpiryTime
    );

    if( ERROR_SUCCESS != Error ) {
        DhcpPrint((DEBUG_ERRORS, "MadcapAddOption(%ld):%ld\n", OptionId, Error));
    }

    return Error;

}

DWORD                                             // status
DhcpAddIncomingOption(                            // this option just arrived, add it to list
    IN      LPWSTR                 AdapterName,
    IN OUT  PLIST_ENTRY            RecdOptionsList,
    IN      DWORD                  OptionId,      // option id of the option
    IN      BOOL                   IsVendor,      // is it vendor specific?
    IN      LPBYTE                 ClassName,     // what is the class name?
    IN      DWORD                  ClassLen,      // what is the class name's lenght in bytes?
    IN      DWORD                  ServerId,      // server ip from which this option came
    IN      LPBYTE                 Data,          // this is the real data value coming in
    IN      DWORD                  DataLen,       // the length of above in # of bytes
    IN      time_t                 ExpiryTime,    // when does this option expire?
    IN      BOOL                   IsApiCall      // is this coming from an API call?
) {
    LPBYTE                         NewClassName;
    DWORD                          Error;
    PDHCP_OPTION                   OldOption;

    DhcpPrint((DEBUG_OPTIONS, "DhcpAddIncomingOption: OptionId %ld ServerId %ld\n",OptionId,ServerId));
    if( !IsVendor && OPTION_VENDOR_SPEC_INFO == OptionId ) {
        Error = DhcpAddIncomingVendorOption(      // if encapsulated vendor spec option, unencapsulate it
            AdapterName,
            RecdOptionsList,
            ClassName,
            ClassLen,
            ServerId,
            Data,
            DataLen,
            ExpiryTime,
            IsApiCall
        );
        if( ERROR_INVALID_PARAMETER == Error ) {  // ignore this error
            Error = ERROR_SUCCESS;
        }
        if( ERROR_SUCCESS != Error ) return Error;
    }

    if( ClassLen ) {
        NewClassName = DhcpAddClass(&DhcpGlobalClassesList, ClassName, ClassLen);
        if( NULL == NewClassName ) {
            DhcpPrint((DEBUG_ERRORS, "DhcpAddIncomingOption|DhcpAddClass: not enough memory\n"));
            return ERROR_NOT_ENOUGH_MEMORY;
        }
    } else {
        NewClassName = NULL;
        ClassLen = 0;
    }

    OldOption = DhcpFindOption(                   // is this already there?
        RecdOptionsList,
        OptionId,
        IsVendor,
        NewClassName,
        ClassLen,
        ServerId
    );

    if( NULL != OldOption ) {                     // If the option existed, delete it
        DhcpPrint((DEBUG_OPTIONS, "DhcpAddIncomingOption: OptionId %ld already exist\n",OptionId));
        if(OldOption->ClassLen)
            DhcpDelClass(&DhcpGlobalClassesList,OldOption->ClassName, OldOption->ClassLen);
        DhcpDelOption(OldOption);
    }

    Error = DhcpAddOption(                        // now add it freshly
        RecdOptionsList,
        OptionId,
        IsVendor,
        NewClassName,
        ClassLen,
        ServerId,
        Data,
        DataLen,
        ExpiryTime
    );

    if( ERROR_SUCCESS != Error ) {
        DhcpPrint((DEBUG_ERRORS, "DhcpAddOption(%ld,%s):%ld\n", OptionId, IsVendor?"Vendor":"NotVendor", Error));
        if(NewClassName)
            (void)DhcpDelClass(&DhcpGlobalClassesList, NewClassName, ClassLen);
    } else {

        if (!IsApiCall)
        {
            DWORD LocalError = DhcpMarkParamChangeRequests(
                AdapterName,
                OptionId,
                IsVendor,
                NewClassName
            );
            DhcpAssert(ERROR_SUCCESS == Error );
        }

    }

    return Error;
}

DWORD                                             // status
DhcpCopyFallbackOptions(                          // copies the Fallback options list to RecdOptionsList
    IN OUT  PDHCP_CONTEXT          DhcpContext,   // NIC context
    OUT     LPDHCP_IP_ADDRESS      Address,       // Fallback address as taken from option 50
    OUT     LPDHCP_IP_ADDRESS      SubnetMask     // SubnetMask as taken from option 1
)
{
    DWORD           Error = ERROR_SUCCESS;
    PLIST_ENTRY     ThisEntry;
    PDHCP_OPTION    ThisOpt;

    // since we're altering the structure of options list,
    // protect them in critical list
    LOCK_OPTIONS_LIST();

    // clear all the options - this has to be done here, before
    // the fallback options take place in the RecdOptionsList.
    // (RecdOptionsList gets cleared here as well)
    Error = DhcpClearAllOptions(DhcpContext);

    if (Error == ERROR_SUCCESS)
    {
        // free up memory from the previous RecdOptionsList
        // This call will let RecdOptionsList initialized as an empty list
        DhcpDestroyOptionsList(&DhcpContext->RecdOptionsList, &DhcpGlobalClassesList);

        for ( ThisEntry = DhcpContext->FbOptionsList.Flink;
              ThisEntry != &DhcpContext->FbOptionsList;
              ThisEntry = ThisEntry->Flink)
        {
            ThisOpt = CONTAINING_RECORD(ThisEntry, DHCP_OPTION, OptionList);

            if (ThisOpt->OptionId == OPTION_SUBNET_MASK)
            {
                // DHCP_IP_ADDRESS is actually DWORD
                // copy the fallback SubnetMask to the output parameters SubnetMask
                memcpy(SubnetMask, ThisOpt->Data, sizeof(DHCP_IP_ADDRESS));
            }
            else if (ThisOpt->OptionId == OPTION_REQUESTED_ADDRESS)
            {
                // DHCP_IP_ADDRESS is actually DWORD
                // copy the fallback IpAddress to the output parameter Address
                memcpy(Address, ThisOpt->Data, sizeof(DHCP_IP_ADDRESS));
            }
            else
            {
                PDHCP_OPTION NewOption;

                // all options but 50 {Requested IpAddress} and 1 {Subnet Mask}
                // are copied from the Fallback list to the RecdOptionsList
                // this is where they are going to be picked from and plumbed
                // as for regular leases.
                NewOption = DhcpDuplicateOption(ThisOpt);
                if (NewOption == NULL)
                {
                    Error = ERROR_NOT_ENOUGH_MEMORY;
                    break;
                }

                // insert the copied options in the RecdOptionsList
                InsertHeadList( &DhcpContext->RecdOptionsList, &NewOption->OptionList );
            }
        }
    }

    UNLOCK_OPTIONS_LIST();

    return Error;
}


DWORD                                             // status
DhcpDestroyOptionsList(                           // destroy a list of options, freeing up memory
    IN OUT  PLIST_ENTRY            OptionsList,   // this is the list of options to destroy
    IN      PLIST_ENTRY            ClassesList    // this is where to remove classes off
) {
    PLIST_ENTRY                    ThisEntry;
    PDHCP_OPTION                   ThisOption;
    DWORD                          Error;
    DWORD                          LastError;

    LastError = ERROR_SUCCESS;
    while(!IsListEmpty(OptionsList) ) {           // for each element of this list
        ThisEntry  = RemoveHeadList(OptionsList);
        ThisOption = CONTAINING_RECORD(ThisEntry, DHCP_OPTION, OptionList);

        if( NULL != ClassesList && NULL != ThisOption->ClassName ) {     // if there is a class, deref it
            Error = DhcpDelClass(
                ClassesList,
                ThisOption->ClassName,
                ThisOption->ClassLen
            );
            if( ERROR_SUCCESS != Error ) {
                DhcpAssert( ERROR_SUCCESS == Error);
                LastError = Error;
            }
        }

        DhcpFreeMemory(ThisOption);               // now really free this
    }
    return LastError;
}

DWORD                                             // win32 status
DhcpClearAllOptions(                              // clear all the options information
    IN OUT  PDHCP_CONTEXT          DhcpContext    // the context to clear for
) {
    PLIST_ENTRY                    ThisEntry;
    PDHCP_OPTION                   ThisOption;
    DWORD                          LocalError;

    (void) DhcpRegClearOptDefs(DhcpAdapterName(DhcpContext));

    ThisEntry = DhcpContext->RecdOptionsList.Flink;
    while(ThisEntry != &DhcpContext->RecdOptionsList) {
        ThisOption = CONTAINING_RECORD(ThisEntry, DHCP_OPTION, OptionList);
        ThisEntry  = ThisEntry->Flink;

        ThisOption->Data = NULL;
        ThisOption->DataLen = 0;

        if (IS_APICTXT_DISABLED(DhcpContext))
        {
            LocalError = DhcpMarkParamChangeRequests(
                ((PLOCAL_CONTEXT_INFO)DhcpContext->LocalInformation)->AdapterName,
                ThisOption->OptionId,
                ThisOption->IsVendor,
                ThisOption->ClassName
            );
            DhcpAssert(ERROR_SUCCESS == LocalError);
        }
    }
    return ERROR_SUCCESS;
}

DWORD                                             // status
DhcpRegClearOptDefs(                              // clear all standard options
    IN      LPWSTR                 AdapterName    // clear for this adapter
)
{
    ULONG                          LastError, Error;
    PLIST_ENTRY                    List;
    PDHCP_OPTION_DEF               OptDef;
    DHCP_OPTION                    Dummy;

    Dummy.OptionId = 0;
    Dummy.ClassName = NULL;
    Dummy.ClassLen = 0;
    Dummy.IsVendor = FALSE;
    Dummy.Data = NULL;
    Dummy.DataLen = 0;

    LastError = ERROR_SUCCESS;
    LOCK_OPTIONS_LIST();                          // need to take lock for globallist

    for(                                          // traverse global OptionDefList
        List = DhcpGlobalOptionDefList.Flink
        ; List != &DhcpGlobalOptionDefList ;
        List = List->Flink
    ) {
        OptDef = CONTAINING_RECORD(List, DHCP_OPTION_DEF, OptionDefList);

        if( NULL == OptDef->RegSaveLoc ) continue;// no where to save .. so cool

        Dummy.OptionId = OptDef->OptionId;
        Error = DhcpRegSaveOptionAtLocationEx(    // save empty option at location..
            &Dummy,
            AdapterName,
            OptDef->RegSaveLoc,
            OptDef->RegValueType
        );
        if( ERROR_SUCCESS != Error ) LastError = Error;
    }

    UNLOCK_OPTIONS_LIST();

    return LastError;
}


DWORD
DhcpRegDeleteIpAddressAndOtherValues(             // delete IPAddress, SubnetMask values from off key
    IN      HKEY                   Key            // handle to adapter regkey..
)
{
    ULONG                          Error1, Error2;

    Error1 = RegDeleteValue(Key, DHCP_IP_ADDRESS_STRING);
    //DhcpAssert(ERROR_SUCCESS == Error1);

    Error2 = RegDeleteValue(Key, DHCP_SUBNET_MASK_STRING);
    //DhcpAssert(ERROR_SUCCESS == Error2);

    if( ERROR_SUCCESS != Error1 ) return Error1;
    return Error2;
}



//================================================================================
//   end of file
//================================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\client\dhcp\options.c ===
//================================================================================
//  Copyright (C) Microsoft Corporation 1997.
//  Author: RameshV
//  Date: 09-Sep-97 06:20
//  Description: Manages the class-id and options information
//================================================================================

#include "precomp.h"
#include <dhcploc.h>
#include <dhcppro.h>
#include <dhcpcapi.h>

#include <align.h>
#include <lmcons.h>

//--------------------------------------------------------------------------------
//  types, defines and structures
//--------------------------------------------------------------------------------

#ifndef PRIVATE
#define PRIVATE STATIC
#define PUBLIC
#endif  PRIVATE

#ifndef OPTIONS_H
#define OPTIONS_H

#define MAX_DATA_LEN               255            // atmost 255 bytes for an option

typedef struct _DHCP_CLASSES {                    // common pool of class names
    LIST_ENTRY                     ClassList;     // global list of classes
    LPBYTE                         ClassName;     // name of the class
    DWORD                          ClassLen;      // # of bytes in class name
    DWORD                          RefCount;      // # of references to this
} DHCP_CLASSES, *LPDHCP_CLASSES, *PDHCP_CLASSES;

typedef struct _DHCP_OPTION {                    // list of options
    LIST_ENTRY                     OptionList;    // the fwd/back ptrs
    DWORD                          OptionId;      // the option value
    BOOL                           IsVendor;      // is this vendor specific
    LPBYTE                         ClassName;     // the class of this option
    DWORD                          ClassLen;      // the length of above option
    time_t                         ExpiryTime;    // when this option expires
    LPBYTE                         Data;          // the data value for this option
    DWORD                          DataLen;       // the # of bytes of above
    DWORD                          ServerId;      // the server from which the option came
    OPTION_VERSION                 OptionVer;     // specifies the format of the options
} DHCP_OPTION, *LPDHCP_OPTION, *PDHCP_OPTION;

typedef struct _DHCP_OPTION_DEF {
    LIST_ENTRY                     OptionDefList; // list of option definitions
    DWORD                          OptionId;      // the option id
    BOOL                           IsVendor;      // is this vendor specific?
    LPBYTE                         ClassName;     // the class this belongs to
    DWORD                          ClassLen;      // the size of above in bytes

    LPWSTR                         RegSendLoc;    // where is the info about sending this out
    LPWSTR                         RegSaveLoc;    // where is this option going to be stored?
    DWORD                          RegValueType;  // as what value should this be stored?
} DHCP_OPTION_DEF, *LPDHCP_OPTION_DEF, *PDHCP_OPTION_DEF;


//================================================================================
//  exported functions classes
//================================================================================

//--------------------------------------------------------------------------------
// In all of the following functions, ClassesList is unprotected within the fn.
// Caller has to take a lock on it.
//--------------------------------------------------------------------------------
LPBYTE                                            // data bytes, or NULL (no mem)
DhcpAddClass(                                     // add a new class
    IN OUT  PLIST_ENTRY            ClassesList,   // list to add to
    IN      LPBYTE                 Data,          // input class name
    IN      DWORD                  Len            // # of bytes of above
);  // Add the new class into the list or bump up ref count if already there

DWORD                                             // status
DhcpDelClass(                                     // de-refernce a class
    IN OUT  PLIST_ENTRY            ClassesList,   // the list to delete off
    IN      LPBYTE                 Data,          // the data ptr
    IN      DWORD                  Len            // the # of bytes of above
);

VOID                                              // always succeeds
DhcpFreeAllClasses(                               // free each elt of the list
    IN OUT  PLIST_ENTRY            ClassesList    // input list of classes
);  // free every class in the list

//--------------------------------------------------------------------------------
// In all the following functions, OptionsList is unprotected within the fn.
// Caller has to take a lock on it.
//--------------------------------------------------------------------------------

PDHCP_OPTION                                     // the reqd structure or NULL
DhcpFindOption(                                   // find a specific option
    IN OUT  PLIST_ENTRY            OptionsList,   // the list of options to search
    IN      DWORD                  OptionId,      // the option id to search for
    IN      BOOL                   IsVendor,      // is it vendor specific?
    IN      LPBYTE                 ClassName,     // is there a class associated?
    IN      DWORD                  ClassLen,      // # of bytes of above parameter
    IN      DWORD                  ServerId       // server which gave this option
);  // search for the required option in the list, return NULL if not found

DWORD                                             // status or ERROR_FILE_NOT_FOUND
DhcpDelOption(                                    // remove a particular option
    IN OUT  PLIST_ENTRY            OptionsList,   // list to remove from
    IN      DWORD                  OptionId,      // id of the option
    IN      BOOL                   IsVendor,      // is it vendor spec?
    IN      LPBYTE                 ClassName,     // which class does it belong to?
    IN      DWORD                  ClassLen       // lenght of above
);  // delete an existing option in the list, and free up space used

DWORD                                             // status
DhcpAddOption(                                    // add a new option
    IN OUT  PLIST_ENTRY            OptionsList,   // list to add to
    IN      DWORD                  OptionId,      // option id to add
    IN      BOOL                   IsVendor,      // is it vendor specific?
    IN      LPBYTE                 ClassName,     // what is the class?
    IN      DWORD                  ClassLen,      // size of above in bytes
    IN      DWORD                  ServerId,      // server which gave this option
    IN      LPBYTE                 Data,          // data for this option
    IN      DWORD                  DataLen,       // # of bytes of above
    IN      time_t                 ExpiryTime     // when the option expires
);  // replace or add new option to the list.  fail if not enough memory

VOID                                              // always succeeds
DhcpFreeAllOptions(                               // frees all the options
    IN OUT  PLIST_ENTRY            OptionsList    // input list of options
);  // free every option in the list

time_t                                            // 0 || time for next expiry (absolute)
DhcpGetExpiredOptions(                            // delete all expired options
    IN OUT  PLIST_ENTRY            OptionsList,   // list to search frm
    OUT     PLIST_ENTRY            ExpiredOptions // o/p list of expired options
);  // move expired options between lists and return timer. 0 => switch off timer.

//--------------------------------------------------------------------------------
//  In all the following functions, OptionsDefList is unprotected.  Caller has
//  to take a lock on it.
//--------------------------------------------------------------------------------

DWORD                                             // status
DhcpAddOptionDef(                                 // add a new option definition
    IN OUT  PLIST_ENTRY            OptionDefList, // input list of options to add to
    IN      DWORD                  OptionId,      // option to add
    IN      BOOL                   IsVendor,      // is it vendor specific
    IN      LPBYTE                 ClassName,     // name of class it belongs to
    IN      DWORD                  ClassLen,      // the size of above in bytes
    IN      LPWSTR                 RegSendLoc,    // where to get info about sending this out
    IN      LPWSTR                 RegSaveLoc,    // where to get info about saving this
    IN      DWORD                  ValueType      // what is the type when saving it?
);

PDHCP_OPTION_DEF                                  // NULL, or requested option def
DhcpFindOptionDef(                                // search for a particular option
    IN      PLIST_ENTRY            OptionDefList, // list to search in
    IN      DWORD                  OptionId,      // the option id to search for
    IN      BOOL                   IsVendor,      // is it vendor specific
    IN      LPBYTE                 ClassName,     // the class, if one exists
    IN      DWORD                  ClassLen       // # of bytes of class name
);

DWORD                                             // status
DhcpDelOptionDef(                                 // delete a particular option def
    IN      PLIST_ENTRY            OptionDefList, // list to delete from
    IN      DWORD                  OptionId,      // the option id to delete
    IN      BOOL                   IsVendor,      // is it vendor specific
    IN      LPBYTE                 ClassName,     // the class, if one exists
    IN      DWORD                  ClassLen       // # of bytes of class name
);

VOID
DhcpFreeAllOptionDefs(                            // free each element of a list
    IN OUT  PLIST_ENTRY            OptionDefList, // the list to free
    IN OUT  PLIST_ENTRY            ClassesList    // the list of classes to deref..
);

#endif  OPTIONS_H

//================================================================================
// function definitions
//================================================================================

// data locks on ClassesList must be taken before calling this function
PDHCP_CLASSES PRIVATE                             // the required classes struct
DhcpFindClass(                                    // find a specified class
    IN OUT  PLIST_ENTRY            ClassesList,   // list of classes to srch in
    IN      LPBYTE                 Data,          // non-NULL data bytes
    IN      DWORD                  Len            // # of bytes of above, > 0
) {
    PLIST_ENTRY                    ThisEntry;
    PDHCP_CLASSES                  ThisClass;

    ThisEntry = ClassesList->Flink;               // first element in list
    while( ThisEntry != ClassesList ) {           // search the full list
        ThisClass = CONTAINING_RECORD( ThisEntry, DHCP_CLASSES, ClassList );
        ThisEntry = ThisEntry->Flink;

        if( ThisClass->ClassLen == Len ) {        // lengths must match
            if( ThisClass->ClassName == Data )    // data ptrs can match OR data can match
                return ThisClass;
            if( 0 == memcmp(ThisClass->ClassName, Data, Len) )
                return ThisClass;
        }
    }
    return NULL;
}

// locks on ClassesList should be taken when using this function
LPBYTE                                            // data bytes, or NULL
DhcpAddClass(                                     // add a new class
    IN OUT  PLIST_ENTRY            ClassesList,   // list to add to
    IN      LPBYTE                 Data,          // input class name
    IN      DWORD                  Len            // # of bytes of above
) {
    PDHCP_CLASSES                  Class;
    DWORD                          MemSize;       // amt of memory reqd

    if( NULL == ClassesList ) {                   // invalid parameter
        DhcpAssert( NULL != ClassesList );
        return NULL;
    }

    if( 0 == Len || NULL == Data ) {              // invalid parameters
        DhcpAssert(0 != Len && NULL != Data );
        return NULL;
    }

    Class = DhcpFindClass(ClassesList,Data,Len);  // already there in list?
    if(NULL != Class) {                           // yes, found
        Class->RefCount++;                        // increase ref-count
        return Class->ClassName;
    }

    MemSize = sizeof(*Class)+Len;                 // amt of memory reqd
    Class = DhcpAllocateMemory(MemSize);
    if( NULL == Class ) {                         // not enough memory
        DhcpAssert( NULL != Class);
        return NULL;
    }

    Class->ClassLen = Len;
    Class->RefCount = 1;
    Class->ClassName = ((LPBYTE)Class) + sizeof(*Class);
    memcpy(Class->ClassName, Data, Len);

    InsertHeadList(ClassesList, &Class->ClassList);

    return Class->ClassName;
}

// locks on ClassesList must be taken before calling this function
DWORD                                             // status
DhcpDelClass(                                     // de-refernce a class
    IN OUT  PLIST_ENTRY            ClassesList,   // the list to delete off
    IN      LPBYTE                 Data,          // the data ptr
    IN      DWORD                  Len            // the # of bytes of above
) {
    PDHCP_CLASSES                  Class;

    if( NULL == ClassesList ) {
        DhcpAssert( NULL != ClassesList );
        return ERROR_INVALID_PARAMETER;
    }

    if( 0 == Len || NULL == Data ) {              // invalid parameter
        DhcpAssert( 0 != Len && NULL != Data );
        return ERROR_INVALID_PARAMETER;
    }

    Class = DhcpFindClass(ClassesList,Data,Len);
    if( NULL == Class ) {                         // did not find this class?
        DhcpAssert( NULL != Class );
        return ERROR_FILE_NOT_FOUND;
    }

    Class->RefCount --;
    if( 0 == Class->RefCount ) {                  // all references removed
        RemoveEntryList( &Class->ClassList );     // remove this from the list
        DhcpFreeMemory(Class);                    // free it
    }

    return ERROR_SUCCESS;
}

// locks on ClassesList must be taken before calling this function
VOID                                              // always succeed
DhcpFreeAllClasses(                               // free each elt of the list
    IN OUT  PLIST_ENTRY            ClassesList    // input list of classes
) {
    PDHCP_CLASSES                  ThisClass;
    PLIST_ENTRY                    ThisEntry;

    if( NULL == ClassesList ) {
        DhcpAssert( NULL != ClassesList && "DhcpFreeAllClasses" );
        return ;
    }

    while( !IsListEmpty(ClassesList) ) {
        ThisEntry = RemoveHeadList(ClassesList);
        ThisClass = CONTAINING_RECORD(ThisEntry, DHCP_CLASSES, ClassList);

        if( ThisClass->RefCount ) {
            DhcpPrint((DEBUG_ERRORS, "Freeing with refcount = %ld\n", ThisClass->RefCount));
        }

        DhcpFreeMemory(ThisClass);
    }

    InitializeListHead(ClassesList);
}

//--------------------------------------------------------------------------------
// exported functions, options
//--------------------------------------------------------------------------------

// data locks need to be taken on OptionsList before calling this function
PDHCP_OPTION                                     // the reqd structure or NULL
DhcpFindOption(                                   // find a specific option
    IN OUT  PLIST_ENTRY            OptionsList,   // the list of options to search
    IN      DWORD                  OptionId,      // the option id to search for
    IN      BOOL                   IsVendor,      // is it vendor specific?
    IN      LPBYTE                 ClassName,     // is there a class associated?
    IN      DWORD                  ClassLen,      // # of bytes of above parameter
    IN      DWORD                  ServerId       // match serverid also if not 0
) {
    PLIST_ENTRY                    ThisEntry;
    PDHCP_OPTION                  ThisOption;

    if( NULL == OptionsList ) {
        DhcpAssert( NULL != OptionsList );
        return NULL;
    }

    ThisEntry = OptionsList->Flink;
    while( ThisEntry != OptionsList ) {           // search the set of options
        ThisOption = CONTAINING_RECORD( ThisEntry, DHCP_OPTION, OptionList );
        ThisEntry  = ThisEntry->Flink;

        if( ThisOption->OptionId != OptionId ) continue;
        if( ThisOption->IsVendor != IsVendor ) continue;
        if( ThisOption->ClassLen != ClassLen ) continue;
        if( ClassLen && ThisOption->ClassName != ClassName )
            continue;                             // mismatched so far
        if ( ServerId && ThisOption->ServerId != ServerId  )
            continue;

        return ThisOption;                        // found the option
    }

    return NULL;                                  // did not find any match
}

// locks on OptionsList need to be taken before calling this function
DWORD                                             // status
DhcpDelOption(                                    // remove a particular option
    IN      PDHCP_OPTION           ThisOption     // option to delete
) {
    if( NULL == ThisOption)                       // nope, did not find this option
        return ERROR_FILE_NOT_FOUND;

    RemoveEntryList( &ThisOption->OptionList);    // found it.  remove and free
    DhcpFreeMemory(ThisOption);

    return ERROR_SUCCESS;
}

// locks on OptionsList need to be taken before calling this function
DWORD                                             // status
DhcpAddOption(                                    // add a new option
    IN OUT  PLIST_ENTRY            OptionsList,   // list to add to
    IN      DWORD                  OptionId,      // option id to add
    IN      BOOL                   IsVendor,      // is it vendor specific?
    IN      LPBYTE                 ClassName,     // what is the class?
    IN      DWORD                  ClassLen,      // size of above in bytes
    IN      DWORD                  ServerId,      // server which gave this option
    IN      LPBYTE                 Data,          // data for this option
    IN      DWORD                  DataLen,       // # of bytes of above
    IN      time_t                 ExpiryTime     // when the option expires
) {
    PDHCP_OPTION                  ThisOption;
    DWORD                          MemSize;

    if( NULL == OptionsList ) {
        DhcpAssert( NULL != OptionsList && "DhcpAddOption" );
        return ERROR_INVALID_PARAMETER;
    }

    if( 0 != ClassLen && NULL == ClassName ) {
        DhcpAssert( 0 == ClassLen || NULL != ClassName && "DhcpAddOption" );
        return ERROR_INVALID_PARAMETER;
    }

    if( 0 != DataLen && NULL == Data ) {
        DhcpAssert( 0 == DataLen || NULL != Data && "DhcpAddOption" );
        return ERROR_INVALID_PARAMETER;
    }

    MemSize = sizeof(DHCP_OPTION) + DataLen ;
    ThisOption = DhcpAllocateMemory(MemSize);
    if( NULL == ThisOption )                      // could not allocate memory
        return ERROR_NOT_ENOUGH_MEMORY;

    ThisOption->OptionId   = OptionId;
    ThisOption->IsVendor   = IsVendor;
    ThisOption->ClassName  = ClassName;
    ThisOption->ClassLen   = ClassLen;
    ThisOption->ServerId   = ServerId;
    ThisOption->ExpiryTime = ExpiryTime;
    ThisOption->DataLen    = DataLen;
    ThisOption->Data       = ((LPBYTE)ThisOption) + sizeof(DHCP_OPTION);
    memcpy(ThisOption->Data, Data, DataLen);

    InsertHeadList( OptionsList, &ThisOption->OptionList );

    return ERROR_SUCCESS;
}

PDHCP_OPTION                                      // pointer to the duplicated option
DhcpDuplicateOption(                              // creates a copy of the source option
     IN PDHCP_OPTION SrcOption                    // source option
)
{
    PDHCP_OPTION DstOption;

    // allocate space enough for the option structure plus its data
    DstOption = DhcpAllocateMemory(sizeof(DHCP_OPTION) + SrcOption->DataLen);

    if (DstOption != NULL)
    {
        // copy the whole content of the option structure and the data
        memcpy(DstOption, SrcOption, sizeof(DHCP_OPTION) + SrcOption->DataLen);
        // make sure to correct the Data pointer from inside the destination
        // DHCP_OPTION structure
        DstOption->Data = ((LPBYTE)DstOption) + sizeof(DHCP_OPTION);
        // safety: Initialize the DstOption->OptionList
        InitializeListHead(&DstOption->OptionList);
    }
    
    return DstOption;
}

// locks on OptionsList need to be taken before calling this function
VOID                                              // always succeeds
DhcpFreeAllOptions(                               // frees all the options
    IN OUT  PLIST_ENTRY            OptionsList    // input list of options
) {
    PLIST_ENTRY                    ThisEntry;
    PDHCP_OPTION                  ThisOption;

    if( NULL == OptionsList ) {
        DhcpAssert( NULL != OptionsList && "DhcpFreeAllOptions" );
        return;
    }

    while(!IsListEmpty(OptionsList)) {
        ThisEntry  = RemoveHeadList(OptionsList);
        ThisOption = CONTAINING_RECORD(ThisEntry, DHCP_OPTION, OptionList);

        DhcpFreeMemory(ThisOption);
    }

    InitializeListHead(OptionsList);
}

// locks on OptionsList need to be taken before calling this function
time_t                                            // 0 || time for next expiry (absolute)
DhcpGetExpiredOptions(                            // delete all expired options
    IN OUT  PLIST_ENTRY            OptionsList,   // list to search frm
    OUT     PLIST_ENTRY            ExpiredOptions // o/p list of expired options
) {
    time_t                         TimeNow;
    time_t                         RetVal;
    PLIST_ENTRY                    ThisEntry;
    PDHCP_OPTION                  ThisOption;

    if( NULL == OptionsList ) {
        DhcpAssert( NULL != OptionsList && "DhcpGetExpiredOptions" );
        return 0;
    }

    TimeNow  = time(NULL);
    RetVal = 0;

    ThisEntry = OptionsList->Flink;
    while( ThisEntry != OptionsList ) {
        ThisOption = CONTAINING_RECORD(ThisEntry, DHCP_OPTION, OptionList);
        ThisEntry  = ThisEntry->Flink;

        if( ThisOption->ExpiryTime < TimeNow ) {  // option has expired
            RemoveEntryList(&ThisOption->OptionList);
            InsertTailList(ExpiredOptions, &ThisOption->OptionList);
            continue;
        }

        if( 0 == RetVal || RetVal > ThisOption->ExpiryTime ) {
            RetVal = ThisOption->ExpiryTime;      // reset return value
        }
    }

    return RetVal;
}

// locks need to be taken for OptionDefList before calling this function
DWORD                                             // status
DhcpAddOptionDef(                                 // add a new option definition
    IN OUT  PLIST_ENTRY            OptionDefList, // input list of options to add to
    IN      DWORD                  OptionId,      // option to add
    IN      BOOL                   IsVendor,      // is it vendor specific
    IN      LPBYTE                 ClassName,     // name of class it belongs to
    IN      DWORD                  ClassLen,      // the size of above in bytes
    IN      LPWSTR                 RegSendLoc,    // MSZ string: where to get info about sending this out
    IN      LPWSTR                 RegSaveLoc,    // MSZ string: where to get info about saving this
    IN      DWORD                  ValueType      // what is the type when saving it?
) {
    LPBYTE                         Memory;
    DWORD                          MemSize;
    DWORD                          RegSendLocSize;
    DWORD                          RegSaveLocSize;
    DWORD                          TmpSize;
    LPWSTR                         Tmp;
    PDHCP_OPTION_DEF               OptDef;

    if( NULL == OptionDefList ) {
        DhcpAssert( NULL != OptionDefList && "DhcpAddOptionDef" );
        return ERROR_INVALID_PARAMETER;
    }

    if( ClassLen && NULL == ClassName ) {
        DhcpAssert( (0 == ClassLen || NULL != ClassName) && "DhcpAddOptionDef" );
        return ERROR_INVALID_PARAMETER;
    }

    MemSize = sizeof(DHCP_OPTION_DEF);
    MemSize = ROUND_UP_COUNT(MemSize, ALIGN_WORST);
    RegSendLocSize = 0;
    if( RegSendLoc ) {
        Tmp = RegSendLoc;
        while(TmpSize = wcslen(Tmp)) {
            Tmp += TmpSize +1;
            RegSendLocSize += sizeof(WCHAR)*(TmpSize+1);
        }
        RegSendLocSize += sizeof(WCHAR);          // terminating NULL character
    }
    MemSize += RegSendLocSize;
    RegSaveLocSize = 0;
    if( RegSaveLoc ) {
        Tmp = RegSaveLoc;
        while(TmpSize = wcslen(Tmp)) {
            Tmp += TmpSize + 1;
            RegSaveLocSize += sizeof(WCHAR)*(TmpSize+1);
        }
        RegSaveLocSize += sizeof(WCHAR);          // termination character L'\0'
    }
    MemSize += RegSaveLocSize;

    Memory = DhcpAllocateMemory(MemSize);
    if( NULL == Memory ) return ERROR_NOT_ENOUGH_MEMORY;

    OptDef = (PDHCP_OPTION_DEF)Memory;
    OptDef ->OptionId  = OptionId;
    OptDef ->IsVendor  = IsVendor;
    OptDef ->ClassName = ClassName;
    OptDef ->ClassLen  = ClassLen;
    OptDef ->RegValueType = ValueType;

    MemSize = sizeof(DHCP_OPTION_DEF);
    MemSize = ROUND_UP_COUNT(MemSize, ALIGN_WORST);
    Memory += MemSize;

    if( NULL == RegSendLoc ) OptDef->RegSendLoc = NULL;
    else {
        OptDef->RegSendLoc = (LPWSTR) Memory;
        Memory += RegSendLocSize;
        memcpy(OptDef->RegSendLoc, RegSendLoc, RegSendLocSize);
    }

    if( NULL == RegSaveLoc ) OptDef->RegSaveLoc = NULL;
    else {
        OptDef->RegSaveLoc = (LPWSTR) Memory;
        memcpy(OptDef->RegSaveLoc, RegSaveLoc, RegSaveLocSize);
    }

    InsertTailList(OptionDefList, &OptDef->OptionDefList);

    return ERROR_SUCCESS;
}

// locks need to be taken for OptionDefList before calling this function
PDHCP_OPTION_DEF                                  // NULL, or requested option def
DhcpFindOptionDef(                                // search for a particular option
    IN      PLIST_ENTRY            OptionDefList, // list to search in
    IN      DWORD                  OptionId,      // the option id to search for
    IN      BOOL                   IsVendor,      // is it vendor specific
    IN      LPBYTE                 ClassName,     // the class, if one exists
    IN      DWORD                  ClassLen       // # of bytes of class name
) {
    PLIST_ENTRY                    ThisEntry;
    PDHCP_OPTION_DEF               ThisDef;

    if( NULL == OptionDefList ) {
        DhcpAssert( NULL != OptionDefList && "DhcpFindOptionDef" );
        return NULL;
    }

    if( ClassLen && NULL == ClassName ) {
        DhcpAssert( (0 == ClassLen || NULL != ClassName) && "DhcpFindOptionDef" );
        return NULL;
    }

    ThisEntry = OptionDefList->Flink;             // first element in list
    while ( ThisEntry != OptionDefList ) {        // search the input list
        ThisDef = CONTAINING_RECORD(ThisEntry, DHCP_OPTION_DEF, OptionDefList);
        ThisEntry = ThisEntry->Flink;

        if( ThisDef->OptionId != OptionId ) continue;
        if( ThisDef->IsVendor != IsVendor ) continue;
        if( ThisDef->ClassLen != ClassLen ) continue;
        if( 0 == ClassLen ) return ThisDef;
        if( ThisDef->ClassName != ClassName ) continue;
        return ThisDef;
    }

    return NULL;
}

// locks need to be taken for OptionDefList before calling this function
DWORD                                             // status
DhcpDelOptionDef(                                 // delete a particular option def
    IN      PLIST_ENTRY            OptionDefList, // list to delete from
    IN      DWORD                  OptionId,      // the option id to delete
    IN      BOOL                   IsVendor,      // is it vendor specific
    IN      LPBYTE                 ClassName,     // the class, if one exists
    IN      DWORD                  ClassLen       // # of bytes of class name
) {
    PDHCP_OPTION_DEF               ThisDef;

    if( NULL == OptionDefList ) {
        DhcpAssert( NULL != OptionDefList && "DhcpDelOptionDef" );
        return ERROR_INVALID_PARAMETER;
    }

    if( ClassLen && NULL == ClassName ) {
        DhcpAssert( (0 == ClassLen || NULL != ClassName) && "DhcpDelOptionDef" );
        return ERROR_INVALID_PARAMETER;
    }

    ThisDef = DhcpFindOptionDef(OptionDefList,OptionId,IsVendor,ClassName,ClassLen);
    if( NULL == ThisDef ) return ERROR_FILE_NOT_FOUND;

    RemoveEntryList(&ThisDef->OptionDefList);     // remove it from the list
    DhcpFreeMemory(ThisDef);                      // free the memory

    return ERROR_SUCCESS;
}

// locks need tobe taken for OptionDefList before calling this function
VOID
DhcpFreeAllOptionDefs(                            // free each element of a list
    IN OUT  PLIST_ENTRY            OptionDefList, // the list to free
    IN OUT  PLIST_ENTRY            ClassesList    // the list of classes to deref
) {
    PLIST_ENTRY                    ThisEntry;
    PDHCP_OPTION_DEF               ThisDef;

    if( NULL == OptionDefList || NULL == ClassesList ) {
        DhcpAssert( NULL != OptionDefList && "DhcpFreeAllOptionDef" );
        return ;
    }

    while( !IsListEmpty(OptionDefList ) ) {
        ThisEntry = RemoveHeadList(OptionDefList);
        ThisDef = CONTAINING_RECORD(ThisEntry, DHCP_OPTION_DEF, OptionDefList);

        if( ThisDef->ClassLen ) DhcpDelClass(ClassesList, ThisDef->ClassName, ThisDef->ClassLen);

        DhcpFreeMemory(ThisDef);
    }

    InitializeListHead(OptionDefList);
}

BOOL                                              // TRUE==>found..
DhcpOptionsFindDomain(                            // find the domain name option values
    IN OUT  PDHCP_CONTEXT          DhcpContext,   // for this adapter
    OUT     LPBYTE                *Data,          // fill this ptr up
    OUT     LPDWORD                DataLen
)
{
    PDHCP_OPTION                   Opt;

    *Data = NULL; *DataLen = 0;                   // init ret vals
    Opt = DhcpFindOption                          // search for OPTION_DOMAIN_NAME
    (
        &DhcpContext->RecdOptionsList,
        OPTION_DOMAIN_NAME,
        FALSE,
        DhcpContext->ClassId,
        DhcpContext->ClassIdLength,
        0                               //dont care about serverid
    );
    if( NULL == Opt ) return FALSE;               // return "not found"
    if( Opt->ExpiryTime <= time(NULL)) {          // option has expired!
        return FALSE;
    }
    if( 0 == Opt->DataLen ) return FALSE;         // no value is present actually..
    *Data = Opt->Data; *DataLen = Opt->DataLen;   // copy ret val

    return TRUE;                                  // yup, we did find domain name..
}

BOOL
DhcpFindDwordOption(
    IN PDHCP_CONTEXT DhcpContext,
    IN ULONG OptId,
    IN BOOL fVendor,
    OUT PDWORD Result
)
{
    PDHCP_OPTION Opt;

    Opt = DhcpFindOption(
        &DhcpContext->RecdOptionsList,
        (BYTE)OptId,
        fVendor,
        DhcpContext->ClassId,
        DhcpContext->ClassIdLength,
        0
        );

    if( NULL == Opt ) return FALSE;
    if( Opt->ExpiryTime < time(NULL) ) {
        return FALSE ;
    }

    if( Opt->DataLen != sizeof(*Result) ) {
        return FALSE;
    }

    *Result = ntohl(*(DWORD UNALIGNED *)Opt->Data);
    return TRUE;
}

BOOL
DhcpFindByteOption(
    IN PDHCP_CONTEXT DhcpContext,
    IN ULONG OptId,
    IN BOOL fVendor,
    OUT PBYTE Result
)
{
    PDHCP_OPTION Opt;

    Opt = DhcpFindOption(
        &DhcpContext->RecdOptionsList,
        (BYTE)OptId,
        fVendor,
        DhcpContext->ClassId,
        DhcpContext->ClassIdLength,
        0
        );

    if( NULL == Opt ) return FALSE;
    if( Opt->ExpiryTime < time(NULL) ) {
        return FALSE ;
    }

    if( Opt->DataLen != sizeof(*Result) ) {
        return FALSE;
    }

    *Result = (*Opt->Data);
    return TRUE;
}

BOOL
RetreiveGatewaysList(
    IN PDHCP_CONTEXT DhcpContext,
    IN OUT ULONG *nGateways,
    IN OUT DHCP_IP_ADDRESS UNALIGNED **Gateways
)
/*++

Routine Description:
    This routine retrives a pointer to the list of gateways for
    the interface in question.

    The lock should be taken on the context as the pointer points
    to some value in the option list.

    The gateways are in network order.

Arguments:
    DhcpContext -- the context to retrive value for.
    nGateways -- the # of gateways present
    Gateways -- a pointer to buffer where the data is stored.

Return Value:
    TRUE indicates the operation was successful and there was
    _some_ gateway present.
    FALSE no gateways.

--*/
{
    PDHCP_OPTION Opt;

    Opt = DhcpFindOption(
        &DhcpContext->RecdOptionsList,
        (BYTE)OPTION_ROUTER_ADDRESS,
        FALSE,
        DhcpContext->ClassId,
        DhcpContext->ClassIdLength,
        0
        );

    if( NULL == Opt ) return FALSE;
    if( Opt->ExpiryTime < time(NULL) ) {
        return FALSE ;
    }

    if( 0 == Opt->DataLen
        || ( Opt->DataLen % sizeof(DHCP_IP_ADDRESS) ) ) {
        return FALSE;
    }

    (*nGateways) = Opt->DataLen / sizeof(DHCP_IP_ADDRESS) ;
    (*Gateways) = (DHCP_IP_ADDRESS UNALIGNED *)Opt->Data;

    return TRUE;
}

//================================================================================
// end of file
//================================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\client\inc\apiappl.h ===
//================================================================================
//  Copyright (C) 1997 Microsoft Corporation
//  Author: RameshV
//  Description: these are the exported dhcp client api function definitions
//================================================================================

#ifndef APIAPPL_H_INCLUDED
#define APIAPPL_H_INCLUDED

#ifndef DHCPAPI_PARAMS_DEFINED
#define DHCPAPI_PARAMS_DEFINED
typedef struct _DHCPAPI_PARAMS {                  // use this structure to request params
    ULONG                          Flags;         // for future use
    ULONG                          OptionId;      // what option is this?
    BOOL                           IsVendor;      // is this vendor specific?
    LPBYTE                         Data;          // the actual data
    DWORD                          nBytesData;    // how many bytes of data are there in Data?
} DHCPAPI_PARAMS, *PDHCPAPI_PARAMS, *LPDHCPAPI_PARAMS;
#endif DHCPAPI_PARAMS_DEFINED

DWORD                                             // win32 status
DhcpAcquireParameters(                            // acquire/renew a lease
    IN      LPWSTR                 AdapterName    // adapter to acquire lease on
);

DWORD                                             // win32 status
DhcpFallbackRefreshParams(                        // something has changed in the fallback settings
    IN      LPWSTR                 AdapterName
);

DWORD                                             // win32 status
DhcpReleaseParameters(                            // release an existing lease
    IN      LPWSTR                 AdapterName    // adpater to release lease for
);

DWORD                                             // win32 status
DhcpEnableDynamicConfic(                          // convert from static to dhcp
    IN      LPWSTR                 AdapterName    // convert for this adapter
);

DWORD                                             // win32 status
DhcpDisableDynamicConfig(                         // convert from dhcp to static
    IN      LPWSTR                 AdapterName    // convert this adapter
);

DWORD                                             // win32 status
DhcpStaticRefreshParams(                          // some registry parameters may have changed, refresh them
    IN      LPWSTR                 AdapterName
);

DWORD                                             // win32 status
DhcpStaticRefreshParamsInternal(                 // some registry parameters may have changed, refresh them
    IN      LPWSTR                 AdapterName,
    IN      BOOL                   fDoDns
);

DWORD
APIENTRY // Request client for options.. and get the options.
DhcpRequestOptions(
    LPWSTR             AdapterName,
    BYTE              *pbRequestedOptions,
    DWORD              dwNumberOfOptions,
    BYTE             **ppOptionList,        // out param
    DWORD             *pdwOptionListSize,   // out param
    BYTE             **ppbReturnedOptions,  // out param
    DWORD             *pdwNumberOfAvailableOptions // out param
);

DWORD
APIENTRY // Register with the client to get Event for notification.
DhcpRegisterOptions(
    LPWSTR             AdapterName ,  // Null implies ALL adapters.
    LPBYTE             OptionList  ,  // The list of options to check.
    DWORD              OptionListSz,  // The size of the above list
    HANDLE             *pdwHandle     // the handle of an event to wait for.
);  // returns an event.


DWORD
APIENTRY // Deregister with the client..
DhcpDeRegisterOptions(
    HANDLE             Event          // This MUST be the one returned by above fn.
);

DWORD                                             // win32 status
APIENTRY
DhcpRequestParameters(                            // request parameters of client
    IN      LPWSTR                 AdapterName,   // adapter name to request for
    IN      LPBYTE                 ClassId,       // byte stream of class id to use
    IN      DWORD                  ClassIdLen,    // # of bytes of class id to use
    IN      PDHCPAPI_PARAMS        SendParams,    // parameters to send to server
    IN      DWORD                  nSendParams,   // size of above array
    IN      DWORD                  Flags,         // must be zero, reserved
    IN OUT  PDHCPAPI_PARAMS        RecdParams,    // fill this array with received params
    IN OUT  LPDWORD                pnRecdParamsBytes // i/p: size of above in BYTES, o/p required bytes or filled up # of elements
);  // returns ERROR_MORE_DATA if o/p buffer is of insufficient size, and fills in reqd size in # of bytes

DWORD                                             // win32 status
APIENTRY
DhcpRegisterParameterChangeNofitication(          // notify if a parameter has changed
    IN      LPWSTR                 AdapterName,   // adapter of interest
    IN      LPBYTE                 ClassId,       // byte stream of class id to use
    IN      DWORD                  ClassIdLen,    // # of bytes of class id
    IN      PDHCPAPI_PARAMS        Params,        // params of interest
    IN      DWORD                  nParams,       // # of elts in above array
    IN      DWORD                  Flags,         // must be zero, reserved
    IN OUT  PHANDLE                hEvent         // handle to event that will be SetEvent'ed in case of param change
);

DWORD
APIENTRY
DhcpDeRegisterParameterChangeNofitication(        // undo the registration
    IN      HANDLE                 Event          // handle to event returned by DhcpRegisterParameterChangeNotification, NULL ==> everything
);

DWORD                                             // win32 status
APIENTRY
DhcpPersistentRequestParams(                      // parameters to request persistently
    IN      LPWSTR                 AdapterName,   // adapter name to request for
    IN      LPBYTE                 ClassId,       // byte stream of class id to use
    IN      DWORD                  ClassIdLen,    // # of bytes of class id
    IN      PDHCPAPI_PARAMS        SendParams,    // persistent parameters
    IN      DWORD                  nSendParams,   // size of above array
    IN      DWORD                  Flags,         // must be zero, reserved
    IN      LPWSTR                 AppName        // the name of the app that is to be used for this instance
);

DWORD                                             // win32 status
APIENTRY
DhcpDelPersistentRequestParams(                   // undo the effect of a persistent request -- currently undo from registry
    IN      LPWSTR                 AdapterName,   // the name of the adpater to delete for
    IN      LPWSTR                 AppName        // the name used by the app
);

#endif APIAPPL_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\client\dhcp\protocol.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    protocol.c

Abstract:

    This module contains the server to client protocol for DHCP.

Author:

    Manny Weiser (mannyw)  21-Oct-1992

Environment:

    User Mode - Win32

Revision History:

    Madan Appiah (madana)  21-Oct-1993

--*/

#include "precomp.h"
#include "dhcpglobal.h"

#ifndef VXD
// ping routines.. ICMP
#include <ipexport.h>
#include <icmpif.h>
#include <icmpapi.h>
#endif

#include <stack.h>
DWORD                                             // Time in seconds
DhcpCalculateWaitTime(                            // how much time to wait
    IN      DWORD                  RoundNum,      // which round is this
    OUT     DWORD                 *WaitMilliSecs  // if needed the # in milli seconds
);


POPTION
FormatDhcpDiscover(
    PDHCP_CONTEXT DhcpContext
);

DWORD
SendDhcpDiscover(
    PDHCP_CONTEXT DhcpContext,
    PDWORD TransactionId
);

POPTION
FormatDhcpRequest(
    PDHCP_CONTEXT DhcpContext,
    BOOL UseCiAddr
);

DWORD
SendDhcpRequest(
    PDHCP_CONTEXT DhcpContext,
    PDWORD TransactionId,
    DWORD RequestedIpAddress,
    DWORD SelectedServer,
    BOOL UseCiAddr
);

DWORD
FormatDhcpRelease(
    PDHCP_CONTEXT DhcpContext
);

DWORD
SendDhcpRelease(
    PDHCP_CONTEXT DhcpContext
);

POPTION
FormatDhcpInform(
    PDHCP_CONTEXT DhcpContext
);

DWORD
SendDhcpInform(
    PDHCP_CONTEXT DhcpContext,
    PDWORD TransactionId
);

DWORD                                             // status
SendInformAndGetReplies(                          // send an inform packet and collect replies
    IN      PDHCP_CONTEXT          DhcpContext,   // the context to send out of
    IN      DWORD                  nInformsToSend,// how many informs to send?
    IN      DWORD                  MaxAcksToWait  // how many acks to wait for
);

DWORD
HandleDhcpAddressConflict(
    DHCP_CONTEXT *pContext,
    DWORD         dwXID
);

DWORD
HandleIPAutoconfigurationAddressConflict(
    DHCP_CONTEXT *pContext
);

DWORD
HandleIPConflict(
    DHCP_CONTEXT *pContext,
    DWORD         dwXID,
    BOOL          fDHCP
);


BOOL
JustBootedOnLapTop(
    PDHCP_CONTEXT pContext
);

BOOL
JustBootedOnNonLapTop(
    PDHCP_CONTEXT pContext
);

VOID
DhcpExtractFullOrLiteOptions(                     // Extract some important options alone or ALL
    IN      PDHCP_CONTEXT          DhcpContext,
    IN      LPBYTE                 OptStart,      // start of the options stuff
    IN      DWORD                  MessageSize,   // # of bytes of options
    IN      BOOL                   LiteOnly,      // next struc is EXPECTED_OPTIONS and not FULL_OPTIONS
    OUT     LPVOID                 DhcpOptions,   // this is where the options would be stored
    IN OUT  PLIST_ENTRY            RecdOptions,   // if !LiteOnly this gets filled with all incoming options
    IN OUT  time_t                 *LeaseExpiry,   // if !LiteOnly input expiry time, else output expiry time
    IN      LPBYTE                 ClassName,     // if !LiteOnly this is used to add to the option above
    IN      DWORD                  ClassLen,      // if !LiteOnly this gives the # of bytes of classname
    IN      DWORD                  ServerId       // if !LiteOnly this specifies the server which gave this
);

BOOL
CheckSwitchedNetwork(
    IN PDHCP_CONTEXT DhcpContext,
    IN ULONG nGateways,
    IN DHCP_IP_ADDRESS UNALIGNED *Gateways
);

DHCP_GATEWAY_STATUS
AnyGatewaysReachable(
    IN ULONG nGateways,
    IN DHCP_IP_ADDRESS UNALIGNED *GatewaysList,
    IN WSAEVENT CancelEvent
);

VOID
GetDomainNameOption(
    IN PDHCP_CONTEXT DhcpContext,
    OUT PBYTE *DomainNameOpt,
    OUT ULONG *DomainNameOptSize
    );

#define RAS_INFORM_START_SECONDS_SINCE_BOOT 6     // RAS informs start off with SecondsSinceBoot as 6

#define DHCP_ICMP_WAIT_TIME     1000
#define DHCP_ICMP_RCV_BUF_SIZE  0x2000
#define DHCP_ICMP_SEND_MESSAGE  "DHCPC"

//*******************  Pageable Routine Declarations ****************//
#if defined(CHICAGO) && defined(ALLOC_PRAGMA)
//
// This is a hack to stop compiler complaining about the routines already
// being in a segment!!!
//

#pragma code_seg()

#pragma CTEMakePageable(PAGEDHCP, DhcpCalculateWaitTime )
#pragma CTEMakePageable(PAGEDHCP, DhcpExtractFullOrLiteOptions )
#pragma CTEMakePageable(PAGEDHCP, FormatDhcpDiscover )
#pragma CTEMakePageable(PAGEDHCP, SendDhcpDiscover )
#pragma CTEMakePageable(PAGEDHCP, FormatDhcpRequest )
#pragma CTEMakePageable(PAGEDHCP, SendDhcpRequest )
#pragma CTEMakePageable(PAGEDHCP, FormatDhcpRelease )
#pragma CTEMakePageable(PAGEDHCP, SendDhcpRelease )
#pragma CTEMakePageable(PAGEDHCP, ObtainInitialParameters )
#pragma CTEMakePageable(PAGEDHCP, RenewLease )
#pragma CTEMakePageable(PAGEDHCP, ReleaseIpAddress )
#pragma CTEMakePageable(PAGEDHCP, ReObtainInitialParameters )
#pragma CTEMakePageable(PAGEDHCP, ReRenewParameters )
#pragma CTEMakePageable(PAGEDHCP, HandleIPAutoconfigurationAddressConflict )
#pragma CTEMakePageable(PAGEDHCP, HandleDhcpAddressConflict )
#pragma CTEMakePageable(PAGEDHCP, HandleIPConflict )
#pragma CTEMakePageable(PAGEDHCP, DhcpIsInitState )
#pragma CTEMakePageable(PAGEDHCP, JustBootedOnLapTop)
#pragma CTEMakePageable(PAGEDHCP, JustBootedOnNonLapTop)
#pragma CTEMakePageable(PAGEDHCP, FormatDhcpInform)
#pragma CTEMakePageable(PAGEDHCP, SendDhcpInform)
#pragma CTEMakePageable(PAGEDHCP, SendInformAndGetReplies)
//*******************************************************************//
#endif CHICAGO && ALLOC_PRAGMA

//================================================================================
// Return TRUE iff this machine is a laptop and easynet is enabled and this is
// the first time this function is getting called on this context.
//================================================================================
BOOL
JustBootedOnLapTop(
    PDHCP_CONTEXT DhcpContext
) {
    if( IS_AUTONET_DISABLED(DhcpContext) )        // if not autonet enabled then
        return FALSE;                             // return false

    if( WAS_CTXT_LOOKED(DhcpContext) )            // if context was already looked at
        return FALSE;                             // this cant be just booted

    CTXT_WAS_LOOKED(DhcpContext);                 // now mark it as looked at

    if(DhcpGlobalMachineType != MACHINE_LAPTOP)   // finally check if machine is a laptop
        return FALSE;

    return TRUE;
}

//================================================================================
//  JustBootedOnNonLapTop returns TRUE iff this machine has EASYNET enabled,
//  this machine is NOT a laptop, and this is the FIRST time the function is
//  getting called on this context.
//================================================================================
BOOL
JustBootedOnNonLapTop(
    PDHCP_CONTEXT DhcpContext
) {
    if( IS_AUTONET_DISABLED(DhcpContext) )        // if autonet disabled, doesnt matter
        return FALSE;

    if( WAS_CTXT_LOOKED(DhcpContext) )            // if already seen this, cant be first boot
        return FALSE;

    CTXT_WAS_LOOKED(DhcpContext);                 // mark it off as already seen

    if(DhcpGlobalMachineType == MACHINE_LAPTOP)   // finally check real machine type
        return FALSE;

    return TRUE;
}


//================================================================================
//  JustBooted returns TRUE iff this machine has just booted (as far as this
//  adapter is concerned).  In other words, calling this function the first
//  time (for this DhcpContext) is guaranteed to return TRUE, and all other times
//  is guaranteed to return FALSE. Note that THIS FUNCTION WILL WORK TO THE
//  EXCLUSION OF THE JustBootedOn functions; but that is ok, as this is needed
//  only for NT and the other two are needed only for Memphis.
//================================================================================
BOOL
JustBooted(PDHCP_CONTEXT DhcpContext) {
    if( WAS_CTXT_LOOKED(DhcpContext) )
       return FALSE;
    CTXT_WAS_LOOKED(DhcpContext);
    return TRUE;
}

DWORD                                             // Time in seconds
DhcpCalculateWaitTime(                            // how much time to wait
    IN      DWORD                  RoundNum,      // which round is this
    OUT     DWORD                 *WaitMilliSecs  // if needed the # in milli seconds
) {
    DWORD                          MilliSecs;
    DWORD                          WaitTimes[4] = { 4000, 8000, 16000, 32000 };

    if( WaitMilliSecs ) *WaitMilliSecs = 0;
    if( RoundNum >= sizeof(WaitTimes)/sizeof(WaitTimes[0]) )
        return 0;

    MilliSecs = WaitTimes[RoundNum] - 1000 + ((rand()*((DWORD) 2000))/RAND_MAX);
    if( WaitMilliSecs ) *WaitMilliSecs = MilliSecs;

    return (MilliSecs + 501)/1000;
}


VOID        _inline
ConcatOption(
    IN OUT  LPBYTE                *Buf,           // input buffer to re-alloc
    IN OUT  ULONG                 *BufSize,       // input buffer size
    IN      LPBYTE                 Data,          // data to append
    IN      ULONG                  DataSize       // how many bytes to add?
)
{
    LPBYTE                         NewBuf;
    ULONG                          NewSize;

    NewSize = (*BufSize) + DataSize;
    NewBuf = DhcpAllocateMemory(NewSize);
    if( NULL == NewBuf ) {                        // could not alloc memory?
        return;                                   // can't do much
    }

    memcpy(NewBuf, *Buf, *BufSize);               // copy existing part
    memcpy(NewBuf + *BufSize, Data, DataSize);    // copy new stuff

    if( NULL != *Buf ) DhcpFreeMemory(*Buf);      // if we alloc'ed mem, free it now
    *Buf = NewBuf;
    *BufSize = NewSize;                           // fill in new values..
}

VOID
DhcpExtractFullOrLiteOptions(                     // Extract some important options alone or ALL
    IN      PDHCP_CONTEXT          DhcpContext,   // input context
    IN      LPBYTE                 OptStart,      // start of the options stuff
    IN      DWORD                  MessageSize,   // # of bytes of options
    IN      BOOL                   LiteOnly,      // next struc is EXPECTED_OPTIONS and not FULL_OPTIONS
    OUT     LPVOID                 DhcpOptions,   // this is where the options would be stored
    IN OUT  PLIST_ENTRY            RecdOptions,   // if !LiteOnly this gets filled with all incoming options
    IN OUT  time_t                 *LeaseExpiry,   // if !LiteOnly input expiry time, else output expiry time
    IN      LPBYTE                 ClassName,     // if !LiteOnly this is used to add to the option above
    IN      DWORD                  ClassLen,      // if !LiteOnly this gives the # of bytes of classname
    IN      DWORD                  ServerId       // if !LiteOnly this specifies the server which gave this
) {
    BYTE    UNALIGNED*             ThisOpt;
    BYTE    UNALIGNED*             NextOpt;
    BYTE    UNALIGNED*             EndOpt;
    BYTE    UNALIGNED*             MagicCookie;
    DWORD                          Error;
    DWORD                          Size, ThisSize, UClassSize = 0;
    LPBYTE                         UClass= NULL;  // concatenation of all OPTION_USER_CLASS options
    PDHCP_EXPECTED_OPTIONS         ExpOptions;
    PDHCP_FULL_OPTIONS             FullOptions;
    BYTE                           ReqdCookie[] = {
        (BYTE)DHCP_MAGIC_COOKIE_BYTE1,
        (BYTE)DHCP_MAGIC_COOKIE_BYTE2,
        (BYTE)DHCP_MAGIC_COOKIE_BYTE3,
        (BYTE)DHCP_MAGIC_COOKIE_BYTE4
    };


    EndOpt = OptStart + MessageSize;              // all options should be < EndOpt;
    ExpOptions = (PDHCP_EXPECTED_OPTIONS)DhcpOptions;
    FullOptions = (PDHCP_FULL_OPTIONS)DhcpOptions;
    RtlZeroMemory((LPBYTE)DhcpOptions, LiteOnly?sizeof(*ExpOptions):sizeof(*FullOptions));
    // if(!LiteOnly) InitializeListHead(RecdOptions); -- clear off this list for getting ALL options
    // dont clear off options... just accumulate over..

    MagicCookie = OptStart;
    if( 0 == MessageSize ) goto DropPkt;          // nothing to do in this case
    if( 0 != memcmp(MagicCookie, ReqdCookie, sizeof(ReqdCookie)) )
        goto DropPkt;                             // oops, cant handle this packet

    NextOpt = &MagicCookie[sizeof(ReqdCookie)];
    while( NextOpt < EndOpt && OPTION_END != *NextOpt ) {
        if( OPTION_PAD == *NextOpt ) {            // handle pads right away
            NextOpt++;
            continue;
        }

        ThisOpt = NextOpt;                        // take a good look at this option
        if( NextOpt + 2 >  EndOpt ) {             // goes over boundary?
            break;
        }

        NextOpt += 2 + (unsigned)ThisOpt[1];      // Option[1] holds the size of this option
        Size = ThisOpt[1];

        if( NextOpt > EndOpt ) {                  // illegal option that goes over boundary!
            break;                                // ignore the error, but dont take this option
        }

        if(!LiteOnly) do {                        // look for any OPTION_MSFT_CONTINUED ..
            if( NextOpt >= EndOpt ) break;        // no more options
            if( OPTION_MSFT_CONTINUED != NextOpt[0] ) break;
            if( NextOpt + 1 + NextOpt[1] > EndOpt ) {
                NextOpt = NULL;                   // do this so that we know to quit at the end..
                break;
            }

            NextOpt++;                            // skip opt code
            ThisSize = NextOpt[0];                // # of bytes to shift back..
            memcpy(ThisOpt+2+Size, NextOpt+1,ThisSize);
            NextOpt += ThisSize+1;
            Size += ThisSize;
        } while(1);                               // keep stringing up any "continued" options..

        if( NULL == NextOpt ) {                   // err parsing OPTION_MSFT_CONTINUED ..
            break;
        }

        if( LiteOnly ) {                          // handle the small subnet of options
            switch( ThisOpt[0] ) {                // ThisOpt[0] is OptionId, ThisOpt[1] is size
            case OPTION_MESSAGE_TYPE:
                if( ThisOpt[1] != 1 ) goto DropPkt;
                ExpOptions->MessageType = &ThisOpt[2];
                continue;
            case OPTION_SUBNET_MASK:
                if( ThisOpt[1] != sizeof(DWORD) ) goto DropPkt;
                ExpOptions->SubnetMask = (DHCP_IP_ADDRESS UNALIGNED *)&ThisOpt[2];
                continue;
            case OPTION_LEASE_TIME:
                if( ThisOpt[1] != sizeof(DWORD) ) goto DropPkt;
                ExpOptions->LeaseTime = (DHCP_IP_ADDRESS UNALIGNED *)&ThisOpt[2];
                continue;
            case OPTION_SERVER_IDENTIFIER:
                if( ThisOpt[1] != sizeof(DWORD) ) goto DropPkt;
                ExpOptions->ServerIdentifier = (DHCP_IP_ADDRESS UNALIGNED *)&ThisOpt[2];
                continue;
            case OPTION_DOMAIN_NAME:
                if( ThisOpt[1] == 0 ) goto DropPkt;
                ExpOptions->DomainName = (BYTE UNALIGNED *)&ThisOpt[2];
                ExpOptions->DomainNameSize = ThisOpt[1];
                break;
            case OPTION_MSFT_AUTOCONF:
                if( ThisOpt[1] != sizeof(BYTE) ) goto DropPkt;
                ExpOptions->AutoconfOption = (BYTE UNALIGNED *)&ThisOpt[2];
                break;
            case OPTION_IETF_AUTOCONF:
                if( ThisOpt[1] != sizeof(BYTE) ) goto DropPkt;
                ExpOptions->AutoconfOption = (BYTE UNALIGNED *)&ThisOpt[2];
                break;
            default:
                continue;
            }
        } else {                                  // Handle the full set of options
            switch( ThisOpt[0] ) {
            case OPTION_MESSAGE_TYPE:
                if( Size != 1 ) goto DropPkt;
                FullOptions->MessageType = &ThisOpt[2];
                break;
            case OPTION_SUBNET_MASK:
                if( Size != sizeof(DWORD) ) goto DropPkt;
                FullOptions->SubnetMask = (DHCP_IP_ADDRESS UNALIGNED *)&ThisOpt[2];
                break;
            case OPTION_LEASE_TIME:
                if( Size != sizeof(DWORD) ) goto DropPkt;
                FullOptions->LeaseTime = (DHCP_IP_ADDRESS UNALIGNED *)&ThisOpt[2];
                break;
            case OPTION_SERVER_IDENTIFIER:
                if( Size != sizeof(DWORD) ) goto DropPkt;
                FullOptions->ServerIdentifier = (DHCP_IP_ADDRESS UNALIGNED *)&ThisOpt[2];
                break;
            case OPTION_RENEWAL_TIME:             // T1Time
                if( Size != sizeof(DWORD) ) goto DropPkt;
                FullOptions->T1Time = (DHCP_IP_ADDRESS UNALIGNED *)&ThisOpt[2];
                break;
            case OPTION_REBIND_TIME:              // T2Time
                if( Size != sizeof(DWORD) ) goto DropPkt;
                FullOptions->T2Time = (DHCP_IP_ADDRESS UNALIGNED *)&ThisOpt[2];
                break;
            case OPTION_ROUTER_ADDRESS:
                if( Size < sizeof(DWORD) || (Size % sizeof(DWORD) ) )
                    goto DropPkt;                 // There can be many router addresses
                FullOptions->GatewayAddresses = (DHCP_IP_ADDRESS UNALIGNED *)&ThisOpt[2];
                FullOptions->nGateways = Size / sizeof(DWORD);
                break;
            case OPTION_STATIC_ROUTES:
                if( Size < 2*sizeof(DWORD) || (Size % (2*sizeof(DWORD))) )
                    goto DropPkt;                 // the static routes come in pairs
                FullOptions->ClassedRouteAddresses = (DHCP_IP_ADDRESS UNALIGNED *)&ThisOpt[2];
                FullOptions->nClassedRoutes = Size/(2*sizeof(DWORD));
                break;
            case OPTION_CLASSLESS_ROUTES:
                if (CheckCLRoutes(Size, &ThisOpt[2], &FullOptions->nClasslessRoutes) != ERROR_SUCCESS)
                    goto DropPkt;
                FullOptions->ClasslessRouteAddresses = (BYTE UNALIGNED *)&ThisOpt[2];
                break;
            case OPTION_DYNDNS_BOTH:
                if( Size < 3 ) goto DropPkt;
                FullOptions->DnsFlags = (BYTE UNALIGNED *)&ThisOpt[2];
                FullOptions->DnsRcode1 = (BYTE UNALIGNED *)&ThisOpt[3];
                FullOptions->DnsRcode2 = (BYTE UNALIGNED *)&ThisOpt[4];
                break;
            case OPTION_DOMAIN_NAME:
                if( Size == 0 ) goto DropPkt;
                FullOptions->DomainName = (BYTE UNALIGNED *)&ThisOpt[2];
                FullOptions->DomainNameSize = Size;
                break;
            case OPTION_DOMAIN_NAME_SERVERS:
                if( Size < sizeof(DWORD) || (Size % sizeof(DWORD) ))
                    goto DropPkt;
                FullOptions->DnsServerList = (DHCP_IP_ADDRESS UNALIGNED *)&ThisOpt[2];
                FullOptions->nDnsServers = Size / sizeof(DWORD);
                break;
            case OPTION_MESSAGE:
                if( Size == 0 ) break;      // ignore zero sized packets
                FullOptions->ServerMessage = &ThisOpt[2];
                FullOptions->ServerMessageLength = ThisOpt[1];
                break;
            case OPTION_USER_CLASS:
                if( Size <= 6) goto DropPkt;
                ConcatOption(&UClass, &UClassSize, &ThisOpt[2], Size);
                continue;                         // don't add this option yet...

            default:
                // unknowm message, nothing to do.. especially dont log this
                break;
            }

            LOCK_OPTIONS_LIST();

            Error = DhcpAddIncomingOption(        // Now add this option to the list
                DhcpAdapterName(DhcpContext),
                RecdOptions,
                ThisOpt[0],
                FALSE,
                ClassName,
                ClassLen,
                ServerId,
                &ThisOpt[2],
                Size,
                *LeaseExpiry,
                IS_APICTXT_ENABLED(DhcpContext)
            );
            UNLOCK_OPTIONS_LIST();
        } // if LiteOnly then else
    } // while NextOpt < EndOpt

    if( LiteOnly && LeaseExpiry ) {               // If asked to calculate lease expiration time..
        LONG     LeaseTime;                       // 32bit signed value!!
        time_t   TimeNow, ExpirationTime;

        if( ExpOptions->LeaseTime )
        {
            LeaseTime = ntohl(*(ExpOptions->LeaseTime));
        }
        else LeaseTime = DHCP_MINIMUM_LEASE;

        ExpirationTime = (TimeNow = time(NULL)) + (time_t)LeaseTime;

        if( ExpirationTime < TimeNow ) {
            ExpirationTime = INFINIT_TIME;
        }

        *LeaseExpiry = ExpirationTime ;
    }

    if( !LiteOnly && NULL != UClass ) {           // we have a user class list to pass on..
        DhcpAssert(UClassSize != 0 );             // we better have something here..
        LOCK_OPTIONS_LIST();                      // Now add the user class option
        Error = DhcpAddIncomingOption(
            DhcpAdapterName(DhcpContext),
            RecdOptions,
            OPTION_USER_CLASS,
            FALSE,
            ClassName,
            ClassLen,
            ServerId,
            UClass,
            UClassSize,
            *LeaseExpiry,
            IS_APICTXT_ENABLED(DhcpContext)
        );
        UNLOCK_OPTIONS_LIST();
        DhcpFreeMemory(UClass); UClass = NULL;
    }

    return;

  DropPkt:
    RtlZeroMemory(DhcpOptions, LiteOnly?sizeof(*ExpOptions):sizeof(*FullOptions));
    if( LiteOnly && LeaseExpiry ) *LeaseExpiry = (DWORD) time(NULL) + DHCP_MINIMUM_LEASE;
    if(!LiteOnly) DhcpFreeAllOptions(RecdOptions);// ok undo the options that we just added
    if(!LiteOnly && NULL != UClass ) DhcpFreeMemory(UClass);
}

POPTION                                           // buffer after filling option
DhcpAppendClassIdOption(                          // fill class id if exists
    IN OUT  PDHCP_CONTEXT          DhcpContext,   // the context to fillfor
    OUT     LPBYTE                 BufStart,      // start of message buffer
    IN      LPBYTE                 BufEnd         // end of message buffer
) {
    DWORD                          Size;

    Size = (DWORD)(BufEnd - BufStart);

    if( DhcpContext->ClassId ) {
        DhcpAssert(DhcpContext->ClassIdLength);
        BufStart = (LPBYTE)DhcpAppendOption(
            (POPTION)BufStart,
            OPTION_USER_CLASS,
            DhcpContext->ClassId,
            (BYTE)DhcpContext->ClassIdLength,
            BufEnd
        );
    }

    return (POPTION) BufStart;
}

POPTION                                           // Option ptr to add additional options
FormatDhcpDiscover(                               // Format the packet to send out discovers
    IN OUT  PDHCP_CONTEXT          DhcpContext    // format on this context
)
{
    LPOPTION                       option;
    LPBYTE                         OptionEnd;
    DWORD                          Size, Error;

    BYTE                           value;
    PDHCP_MESSAGE                  dhcpMessage;

    dhcpMessage = DhcpContext->MessageBuffer;
    RtlZeroMemory( dhcpMessage, DHCP_SEND_MESSAGE_SIZE );

    //
    // For RAS client (api context), use broadcast bit, otherwise the router will try
    // to send as unicast to made-up RAS client hardware address, which
    // will not work.
    // no broadcast flag for mdhcp context

    // Or if we are using AUTONET address, we do the same as our stack
    // will actually have IP address as the autonet address and hence will
    // drop all but BROADCASTS..

    if( !IS_MDHCP_CTX(DhcpContext) && (
        //(DhcpContext->IpAddress == 0 && DhcpContext->HardwareAddressType == HARDWARE_1394) ||
        (DhcpContext->HardwareAddressType == HARDWARE_1394) ||
        IS_APICTXT_ENABLED(DhcpContext) || 
        (DhcpContext->IpAddress && IS_ADDRESS_AUTO(DhcpContext)) )) {
        dhcpMessage->Reserved = htons(DHCP_BROADCAST);
    }


    //
    // Transaction ID is filled in during send
    //

    dhcpMessage->Operation = BOOT_REQUEST;
    dhcpMessage->HardwareAddressType = DhcpContext->HardwareAddressType;
    dhcpMessage->SecondsSinceBoot = (WORD) DhcpContext->SecondsSinceBoot;
    if (DhcpContext->HardwareAddressType != HARDWARE_1394) {
        memcpy(dhcpMessage->HardwareAddress, DhcpContext->HardwareAddress, DhcpContext->HardwareAddressLength);
        dhcpMessage->HardwareAddressLength = (BYTE)DhcpContext->HardwareAddressLength;
    }
    option = &dhcpMessage->Option;
    OptionEnd = (LPBYTE)dhcpMessage + DHCP_SEND_MESSAGE_SIZE;
    if ( IS_MDHCP_CTX(DhcpContext ) ) MDHCP_MESSAGE( dhcpMessage );

    //
    // always add magic cookie first
    //

    option = (LPOPTION) DhcpAppendMagicCookie( (LPBYTE) option, OptionEnd );

    value = DHCP_DISCOVER_MESSAGE;
    option = DhcpAppendOption(
        option,
        OPTION_MESSAGE_TYPE,
        &value,
        1,
        OptionEnd
    );

    //
    // append class id if one exists
    //

    option = DhcpAppendClassIdOption(
            DhcpContext,
            (LPBYTE)option,
            OptionEnd
    );

    if( CFLAG_AUTOCONF_OPTION && !IS_MDHCP_CTX(DhcpContext)
        && IS_AUTONET_ENABLED( DhcpContext ) ) {
        //
        // We support the autoconf option
        //
        BYTE AutoConfOpt[1] = { AUTOCONF_ENABLED };

        option = DhcpAppendOption(
            option,
            OPTION_IETF_AUTOCONF,
            AutoConfOpt,
            sizeof(AutoConfOpt),
            OptionEnd
            );
    }
    return( option );
}

POPTION                                           // ptr to add additional options
FormatDhcpDecline(                                // format the packet for a decline
    IN      PDHCP_CONTEXT          DhcpContext,   // this is the context to format for
    IN      DWORD                  dwDeclinedIPAddress
) {
    LPOPTION                       option;
    LPBYTE                         OptionEnd;
    BYTE                           value;
    PDHCP_MESSAGE                  dhcpMessage;

    dhcpMessage = DhcpContext->MessageBuffer;
    RtlZeroMemory( dhcpMessage, DHCP_SEND_MESSAGE_SIZE );

    //
    // Transaction ID is filled in during send
    //

    dhcpMessage->Operation             = BOOT_REQUEST;
    dhcpMessage->HardwareAddressType   = DhcpContext->HardwareAddressType;
    dhcpMessage->ClientIpAddress       = dwDeclinedIPAddress;
    dhcpMessage->SecondsSinceBoot      = (WORD) DhcpContext->SecondsSinceBoot;
    if (DhcpContext->HardwareAddressType != HARDWARE_1394) {
        memcpy(dhcpMessage->HardwareAddress,DhcpContext->HardwareAddress,DhcpContext->HardwareAddressLength);
        dhcpMessage->HardwareAddressLength = (BYTE)DhcpContext->HardwareAddressLength;
    }

    option = &dhcpMessage->Option;
    OptionEnd = (LPBYTE)dhcpMessage + DHCP_SEND_MESSAGE_SIZE;

    if ( IS_MDHCP_CTX(DhcpContext ) ) MDHCP_MESSAGE( dhcpMessage );

    //
    // always add magic cookie first
    //

    option = (LPOPTION) DhcpAppendMagicCookie( (LPBYTE) option, OptionEnd );

    value = DHCP_DECLINE_MESSAGE;
    option = DhcpAppendOption(
        option,
        OPTION_MESSAGE_TYPE,
        &value,
        1,
        OptionEnd
    );

    return( option );
}

POPTION                                           // ptr to add additional options
FormatDhcpInform(                                 // format the packet for an INFORM
    IN      PDHCP_CONTEXT          DhcpContext    // format for this context
) {
    LPOPTION option;
    LPBYTE OptionEnd;

    BYTE value;
    PDHCP_MESSAGE dhcpMessage;


    dhcpMessage = DhcpContext->MessageBuffer;
    RtlZeroMemory( dhcpMessage, DHCP_SEND_MESSAGE_SIZE );

#if NEWNT

    //
    // For RAS client, use broadcast bit, otherwise the router will try
    // to send as unicast to made-up RAS client hardware address, which
    // will not work.
    //
    // no broadcast flag for mdhcp context

    // Or if we are using AUTONET address, we do the same as our stack
    // will actually have IP address as the autonet address and hence will
    // drop all but BROADCASTS..
    if( !IS_MDHCP_CTX(DhcpContext)  ) {

        //
        // just make sure all informs are broadcast....?
        //

        // dhcpMessage->Reserved = htons(DHCP_BROADCAST);

        // INFORMS are supposed to be ACKed back in UNICAST.. So this should
        // not matter.  So we don't bother to ste the BROADCAST bit here..
    }

#endif // 0

    //
    // Transaction ID is filled in during send
    //

    dhcpMessage->Operation             = BOOT_REQUEST;
    dhcpMessage->HardwareAddressType   = DhcpContext->HardwareAddressType;
    dhcpMessage->SecondsSinceBoot      = (WORD) DhcpContext->SecondsSinceBoot;
    if (DhcpContext->HardwareAddressType != HARDWARE_1394) {
        memcpy(dhcpMessage->HardwareAddress,DhcpContext->HardwareAddress,DhcpContext->HardwareAddressLength);
        dhcpMessage->HardwareAddressLength = (BYTE)DhcpContext->HardwareAddressLength;
    }
    dhcpMessage->ClientIpAddress       = DhcpContext->IpAddress;
    if ( IS_MDHCP_CTX(DhcpContext ) ) MDHCP_MESSAGE( dhcpMessage );

    option = &dhcpMessage->Option;
    OptionEnd = (LPBYTE)dhcpMessage + DHCP_SEND_MESSAGE_SIZE;

    //
    // always add magic cookie first
    //

    option = (LPOPTION) DhcpAppendMagicCookie( (LPBYTE) option, OptionEnd );

    value = DHCP_INFORM_MESSAGE;
    option = DhcpAppendOption(
        option,
        OPTION_MESSAGE_TYPE,
        &value,
        1,
        OptionEnd
    );

    option = DhcpAppendClassIdOption(
        DhcpContext,
        (LPBYTE)option,
        OptionEnd
    );

    return( option );
}


DWORD                                             // status
SendDhcpDiscover(                                 // send a discover packet
    IN      PDHCP_CONTEXT          DhcpContext,   // on this context
    IN OUT  DWORD                 *pdwXid         // use this Xid (if zero, fill something and return it)
) {
    DWORD                          size;
    DWORD                          Error;
    POPTION                        option;
    LPBYTE                         OptionEnd;
    BYTE                           SentOpt[OPTION_END+1];
    BYTE                           SentVOpt[OPTION_END+1];
    BYTE                           VendorOpt[OPTION_END+1];
    DWORD                          VendorOptSize;

    RtlZeroMemory(SentOpt, sizeof(SentOpt));      // initialize boolean arrays
    RtlZeroMemory(SentVOpt, sizeof(SentVOpt));    // so that no option is presumed sent
    VendorOptSize = 0;                            // encapsulated vendor option is empty
    option = FormatDhcpDiscover( DhcpContext );   // core format

    OptionEnd = (LPBYTE)(DhcpContext->MessageBuffer) + DHCP_SEND_MESSAGE_SIZE;

    if( DhcpContext->ClientIdentifier.fSpecified) // client id specified in registy
        option = DhcpAppendClientIDOption(        // ==> use this client id as option
            option,
            DhcpContext->ClientIdentifier.bType,
            DhcpContext->ClientIdentifier.pbID,
            (BYTE)DhcpContext->ClientIdentifier.cbID,
            OptionEnd
        );
    else                                          // client id was not specified
        option = DhcpAppendClientIDOption(        // ==> use hw addr as client id
            option,
            DhcpContext->HardwareAddressType,
            DhcpContext->HardwareAddress,
            (BYTE)DhcpContext->HardwareAddressLength,
            OptionEnd
        );

    if( DhcpContext->DesiredIpAddress != 0 ) {    // we had this addr before, ask for it again
        option = DhcpAppendOption(                // maybe we will get it
            option,
            OPTION_REQUESTED_ADDRESS,
            (LPBYTE)&DhcpContext->DesiredIpAddress,
            sizeof(DHCP_IP_ADDRESS),
            OptionEnd
        );
    }

    if( IS_MDHCP_CTX(DhcpContext) && DhcpContext->Lease != 0 ) {    // did mdhcp client ask specific lease
        option = DhcpAppendOption(                // maybe we will get it
            option,
            OPTION_LEASE_TIME,
            (LPBYTE)&DhcpContext->Lease,
            sizeof(DhcpContext->Lease),
            OptionEnd
        );
    }

    if ( DhcpGlobalHostName != NULL ) {           // add host name and comment options
        option = DhcpAppendOption(
            option,
            OPTION_HOST_NAME,
            (LPBYTE)DhcpGlobalHostName,
            (BYTE)(strlen(DhcpGlobalHostName) * sizeof(CHAR)),
            OptionEnd
        );
    }

    if( NULL != DhcpGlobalClientClassInfo ) {     // if we have any info on client class..
        option = DhcpAppendOption(
            option,
            OPTION_CLIENT_CLASS_INFO,
            (LPBYTE)DhcpGlobalClientClassInfo,
            strlen(DhcpGlobalClientClassInfo),
            OptionEnd
        );
    }

    SentOpt[OPTION_MESSAGE_TYPE] = TRUE;          // these must have been added by now
    if(DhcpContext->ClassIdLength) SentOpt[OPTION_USER_CLASS] = TRUE;
    SentOpt[OPTION_CLIENT_CLASS_INFO] = TRUE;
    SentOpt[OPTION_CLIENT_ID] = TRUE;
    SentOpt[OPTION_REQUESTED_ADDRESS] = TRUE;
    SentOpt[OPTION_HOST_NAME] = TRUE;

    option = DhcpAppendSendOptions(               // append all other options we need to send
        DhcpContext,                              // for this context
        &DhcpContext->SendOptionsList,            // this is the list of options to send out
        DhcpContext->ClassId,                     // which class.
        DhcpContext->ClassIdLength,               // how many bytes are there in the class id
        (LPBYTE)option,                           // start of the buffer to add the options
        (LPBYTE)OptionEnd,                        // end of the buffer up to which we can add options
        SentOpt,                                  // this is the boolean array that marks what opt were sent
        SentVOpt,                                 // this is for vendor spec options
        VendorOpt,                                // this would contain some vendor specific options
        &VendorOptSize                            // the # of bytes of vendor options added to VendorOpt param
    );

    if( !SentOpt[OPTION_VENDOR_SPEC_INFO] && VendorOptSize && VendorOptSize <= OPTION_END)
        option = DhcpAppendOption(                // add vendor specific options if we havent already sent it
            option,
            OPTION_VENDOR_SPEC_INFO,
            VendorOpt,
            (BYTE)VendorOptSize,
            OptionEnd
        );

    option = DhcpAppendOption( option, OPTION_END, NULL, 0, OptionEnd );
    size = (DWORD)((PBYTE)option - (PBYTE)DhcpContext->MessageBuffer);

    return  SendDhcpMessage(                      // finally send the message and return
        DhcpContext,
        size,
        pdwXid
    );
}

DWORD                                             // status
SendDhcpInform(                                   // send an inform packet after filling required options
    IN      PDHCP_CONTEXT          DhcpContext,   // sned out for this context
    IN OUT  DWORD                 *pdwXid         // use this Xid (if zero fill something and return it)
) {
    DWORD                          size;
    DWORD                          Error;
    POPTION                        option;
    LPBYTE                         OptionEnd;
    BYTE                           SentOpt[OPTION_END+1];
    BYTE                           SentVOpt[OPTION_END+1];
    BYTE                           VendorOpt[OPTION_END+1];
    DWORD                          VendorOptSize;

    RtlZeroMemory(SentOpt, sizeof(SentOpt));      // initialize boolean arrays
    RtlZeroMemory(SentVOpt, sizeof(SentVOpt));    // so that no option is presumed sent
    VendorOptSize = 0;                            // encapsulated vendor option is empty
    option = FormatDhcpInform( DhcpContext );     // core format

    OptionEnd = (LPBYTE)(DhcpContext->MessageBuffer) + DHCP_SEND_MESSAGE_SIZE;

    if( DhcpContext->ClientIdentifier.fSpecified) // client id specified in registy
        option = DhcpAppendClientIDOption(        // ==> use this client id as option
            option,
            DhcpContext->ClientIdentifier.bType,
            DhcpContext->ClientIdentifier.pbID,
            (BYTE)DhcpContext->ClientIdentifier.cbID,
            OptionEnd
        );
    else                                          // client id was not specified
        option = DhcpAppendClientIDOption(        // ==> use hw addr as client id
            option,
            DhcpContext->HardwareAddressType,
            DhcpContext->HardwareAddress,
            (BYTE)DhcpContext->HardwareAddressLength,
            OptionEnd
        );

    if ( DhcpGlobalHostName != NULL ) {           // add hostname and comment options
        option = DhcpAppendOption(
            option,
            OPTION_HOST_NAME,
            (LPBYTE)DhcpGlobalHostName,
            (BYTE)(strlen(DhcpGlobalHostName) * sizeof(CHAR)),
            OptionEnd
        );
    }

    if( NULL != DhcpGlobalClientClassInfo ) {     // if we have any info on client class..
        option = DhcpAppendOption(
            option,
            OPTION_CLIENT_CLASS_INFO,
            (LPBYTE)DhcpGlobalClientClassInfo,
            strlen(DhcpGlobalClientClassInfo),
            OptionEnd
        );
    }

    SentOpt[OPTION_MESSAGE_TYPE] = TRUE;          // these must have been added by now
    if(DhcpContext->ClassIdLength) SentOpt[OPTION_USER_CLASS] = TRUE;
    SentOpt[OPTION_CLIENT_CLASS_INFO] = TRUE;
    SentOpt[OPTION_CLIENT_ID] = TRUE;
    SentOpt[OPTION_REQUESTED_ADDRESS] = TRUE;
    SentOpt[OPTION_HOST_NAME] = TRUE;

    option = DhcpAppendSendOptions(               // append all other options we need to send
        DhcpContext,                              // for this context
        &DhcpContext->SendOptionsList,            // this is the list of options to send out
        DhcpContext->ClassId,                     // which class.
        DhcpContext->ClassIdLength,               // how many bytes are there in the class id
        (LPBYTE)option,                           // start of the buffer to add the options
        (LPBYTE)OptionEnd,                        // end of the buffer up to which we can add options
        SentOpt,                                  // this is the boolean array that marks what opt were sent
        SentVOpt,                                 // this is for vendor spec options
        VendorOpt,                                // this would contain some vendor specific options
        &VendorOptSize                            // the # of bytes of vendor options added to VendorOpt param
    );

    if( !SentOpt[OPTION_VENDOR_SPEC_INFO] && VendorOptSize && VendorOptSize <= OPTION_END )
        option = DhcpAppendOption(                // add vendor specific options if we havent already sent it
            option,
            OPTION_VENDOR_SPEC_INFO,
            VendorOpt,
            (BYTE)VendorOptSize,
            OptionEnd
        );

    option = DhcpAppendOption( option, OPTION_END, NULL, 0, OptionEnd );
    size = (DWORD)((PBYTE)option - (PBYTE)DhcpContext->MessageBuffer);

    return  SendDhcpMessage(                      // finally send the message and return
        DhcpContext,
        size,
        pdwXid
    );
}

DWORD                                             // status
SendInformAndGetReplies(                          // send an inform packet and collect replies
    IN      PDHCP_CONTEXT          DhcpContext,   // the context to send out of
    IN      DWORD                  nInformsToSend,// how many informs to send?
    IN      DWORD                  MaxAcksToWait  // how many acks to wait for
) {
    time_t                         StartTime;
    time_t                         TimeNow;
    DWORD                          TimeToWait;
    DWORD                          Error;
    DWORD                          Xid;
    DWORD                          MessageSize;
    DWORD                          RoundNum;
    DWORD                          MessageCount;
    time_t                         LeaseExpirationTime;
    DHCP_EXPECTED_OPTIONS          ExpectedOptions;
    DHCP_FULL_OPTIONS              FullOptions;

    DhcpPrint((DEBUG_PROTOCOL, "SendInformAndGetReplies entered\n"));

    if((Error = OpenDhcpSocket(DhcpContext)) != ERROR_SUCCESS) {
        DhcpPrint((DEBUG_ERRORS, "Could not open socket for this interface! (%ld)\n", Error));
        return Error;
    }

    Xid                           = 0;            // Will be generated by first SendDhcpPacket
    MessageCount                  = 0;            // total # of messages we have got

    DhcpContext->SecondsSinceBoot = 0;            // start at zero..

    if( NdisWanAdapter((DhcpContext) ) ) {
        DhcpContext->SecondsSinceBoot = RAS_INFORM_START_SECONDS_SINCE_BOOT;
    }

    for( RoundNum = 0; RoundNum < nInformsToSend;  RoundNum ++ ) {
        Error = SendDhcpInform(DhcpContext, &Xid);
        if( ERROR_SUCCESS != Error ) {
            DhcpPrint((DEBUG_ERRORS, "SendDhcpInform: %ld\n", Error));
            goto Cleanup;
        } else {
            DhcpPrint((DEBUG_PROTOCOL, "Sent DhcpInform\n"));
        }

        TimeToWait = DhcpCalculateWaitTime(RoundNum, NULL);
        DhcpContext->SecondsSinceBoot += TimeToWait; // do this so that next time thru it can go thru relays..
        StartTime  = time(NULL);
        while ( TRUE ) {                          // wiat for the specified wait time
            MessageSize =  DHCP_RECV_MESSAGE_SIZE;

            DhcpPrint((DEBUG_TRACE, "Waiting for ACK[Xid=%x]: %ld seconds\n",Xid, TimeToWait));
            Error = GetSpecifiedDhcpMessage(      // try to receive an ACK
                DhcpContext,
                &MessageSize,
                Xid,
                (DWORD)TimeToWait
            );
            if ( Error == ERROR_SEM_TIMEOUT ) break;
            if( Error != ERROR_SUCCESS ) {
                DhcpPrint((DEBUG_ERRORS, "GetSpecifiedDhcpMessage: %ld\n", Error));
                goto Cleanup;
            }

            DhcpExtractFullOrLiteOptions(         // Need to see if this is an ACK
                DhcpContext,
                (LPBYTE)&DhcpContext->MessageBuffer->Option,
                MessageSize - DHCP_MESSAGE_FIXED_PART_SIZE,
                TRUE,                             // do lite extract only
                &ExpectedOptions,                 // check for only expected options
                NULL,                             // unused
                &LeaseExpirationTime,
                NULL,                             // unused
                0,                                // unused
                0                                 // unused
            );

            //
            // Hack!!!
            //
            // If the DHCP server doesn't explicitly give us the lease time,
            // use the lease expiration time stored in the DHCP context. This
            // should be OK in the case of DHCP-inform.
            //
            if (NULL == ExpectedOptions.LeaseTime) {
                if (IS_DHCP_ENABLED(DhcpContext) && DhcpContext->IpAddress) {
                    //
                    // Ok, we have a valid lease expiration time.
                    //
                    LeaseExpirationTime = DhcpContext->LeaseExpires;
                }
            }

            if( NULL == ExpectedOptions.MessageType ) {
                DhcpPrint((DEBUG_PROTOCOL, "Received no message type!\n"));
            } else if( DHCP_ACK_MESSAGE != *ExpectedOptions.MessageType ) {
                DhcpPrint((DEBUG_PROTOCOL, "Received unexpected message type: %ld\n", *ExpectedOptions.MessageType));
            } else if( NULL == ExpectedOptions.ServerIdentifier ) {
                DhcpPrint((DEBUG_PROTOCOL, "Received no server identifier, dropping inform ACK\n"));
            } else {
                MessageCount ++;
                DhcpPrint((DEBUG_TRACE, "Received %ld ACKS so far\n", MessageCount));
                DhcpExtractFullOrLiteOptions(     // do FULL options..
                    DhcpContext,
                    (LPBYTE)&DhcpContext->MessageBuffer->Option,
                    MessageSize - DHCP_MESSAGE_FIXED_PART_SIZE,
                    FALSE,
                    &FullOptions,
                    &(DhcpContext->RecdOptionsList),
                    &LeaseExpirationTime,
                    DhcpContext->ClassId,
                    DhcpContext->ClassIdLength,
                    IS_MDHCP_CTX(DhcpContext) ? *ExpectedOptions.ServerIdentifier : 0

                );
                if( MessageCount >= MaxAcksToWait ) goto Cleanup;
            } // if( it is an ACK and ServerId present )

            TimeNow     = time(NULL);             // Reset the time values to reflect new time
            if( TimeToWait < (DWORD) (TimeNow - StartTime) ) {
                break;                            // no more time left to wait..
            }
            TimeToWait -= (DWORD)(TimeNow - StartTime);  // recalculate time now
            StartTime   = TimeNow;                // reset start time also
        } // end of while ( TimeToWait > 0)
    } // for (RoundNum = 0; RoundNum < nInformsToSend ; RoundNum ++ )

  Cleanup:
    CloseDhcpSocket(DhcpContext);
    if( MessageCount ) Error = ERROR_SUCCESS;
    DhcpPrint((DEBUG_PROTOCOL, "SendInformAndGetReplies: got %d ACKS (returning %ld)\n", MessageCount,Error));
    return Error;
}

DWORD                                             // status
HandleIPConflict(                                 // do some basic work when there is an ip address conflict
    IN      DHCP_CONTEXT          *pContext,      // the context that has the trouble
    IN      DWORD                  dwXID,         // xid as used in discover/request
    IN      BOOL                   fDHCP          // is this dhcp or autonet conflict?
) {
    DWORD                          dwResult;
    DHCP_IP_ADDRESS                IpAddress, ServerAddress;

    IpAddress = pContext->IpAddress;              // this addr is use in the n/w --> save it before resetting
    pContext->ConflictAddress = IpAddress;
    ServerAddress = pContext->DhcpServerAddress;

    if ( fDHCP ) {                                // if obtained the address via dhcp, clear it via SetDhcp
        SetDhcpConfigurationForNIC(
            pContext,
            NULL,
            0,
            (DHCP_IP_ADDRESS)(-1),
            TRUE
        );
    } else {                                      // if obtained it via autonet, clear via autonet
        SetAutoConfigurationForNIC(
            pContext,
            0,
            0
        );
    }

    // ARP brings down the interface when a conflict is detected --> so we need to
    // bring the interface back up again.
    // If the address was obtained via a dhcp server, we need to send a DHCP-DECLINE too

    dwResult = BringUpInterface( pContext->LocalInformation );

    if ( ERROR_SUCCESS != dwResult ) {            // Simple operation -- there is no way to fail
        //DhcpAssert( FALSE );                      // unless invalid params for the ioctl
    } else if ( fDHCP ) {                         // send DECLINE to dhcp server
        dwResult = OpenDhcpSocket( pContext );    // socket was closed before initializing interface, reopen it
                                                  // will be closed by caller
        if ( ERROR_SUCCESS == dwResult ) {        // everything went fine -- could open a socket
            dwResult = SendDhcpDecline(           // now really send the decline out
                pContext,
                dwXID,
                ServerAddress,
                IpAddress
            );
        }
        pContext->DesiredIpAddress = 0;           // dont try to get this ip address again, start fresh

#ifndef VXD
        if ( !DhcpGlobalProtocolFailed ) {        // NT alone, log this event
            DhcpLogEvent( pContext, EVENT_ADDRESS_CONFLICT, 0 );
        }
#endif
    }
    return dwResult;
}

DWORD                                             // status
HandleIPAutoconfigurationAddressConflict(         // handle same address on n/w for autonet
    IN      DHCP_CONTEXT          *pContext       // context of adapter that had this problem
) {
    return HandleIPConflict( pContext, 0, FALSE );
}

DWORD                                             // status
HandleDhcpAddressConflict(                        // same addr present on n/w as given by DHCP srv
    IN      DHCP_CONTEXT          *pContext,      // context of adapter that had trouble
    IN      DWORD                  dwXID          // XID that was used for the DISCIVER/RENEW
) {
    return HandleIPConflict( pContext, dwXID, TRUE );
}


DWORD                                             // status
SendDhcpDecline(                                  // send a decline packet to the server
    IN      PDHCP_CONTEXT          DhcpContext,   // adapter that needs this to be sent on
    IN      DWORD                  dwXid,         // transaction id used for DISCOVER/RENEW
    IN      DWORD                  dwServerAddr,  // which server to unicast decline
    IN      DWORD                  dwDeclinedAddr // which address was offered that we dont want
) {
    DWORD                          size;
    DWORD                          Error;
    POPTION                        option;
    LPBYTE                         OptionEnd;

    option = FormatDhcpDecline( DhcpContext, dwDeclinedAddr );
    OptionEnd = (LPBYTE)(DhcpContext->MessageBuffer) + DHCP_SEND_MESSAGE_SIZE;

    if(DhcpContext->ClientIdentifier.fSpecified)  // use ClientId if it was specified in registry
        option = DhcpAppendClientIDOption(        // and send it out as an option
            option,
            DhcpContext->ClientIdentifier.bType,
            DhcpContext->ClientIdentifier.pbID,
            (BYTE)DhcpContext->ClientIdentifier.cbID,
            OptionEnd
        );
    else  option = DhcpAppendClientIDOption(      // otherwise, send the h/w address out instead
        option,                                   // as if it was the client id
        DhcpContext->HardwareAddressType,
        DhcpContext->HardwareAddress,
        (BYTE)DhcpContext->HardwareAddressLength,
        OptionEnd
    );

    option = DhcpAppendOption(                    // The requested addr is the one we dont want
        option,
        OPTION_REQUESTED_ADDRESS,
        (LPBYTE)&dwDeclinedAddr,
        sizeof(dwDeclinedAddr),
        OptionEnd
    );

    option = DhcpAppendOption(                    // identify the server so it is not dropped
        option,
        OPTION_SERVER_IDENTIFIER,
        (LPBYTE)&dwServerAddr,
        sizeof( dwServerAddr ),
        OptionEnd
    );


    option = DhcpAppendOption( option, OPTION_END, NULL, 0, OptionEnd );
    size = (DWORD)((PBYTE)option - (PBYTE)DhcpContext->MessageBuffer);

    return SendDhcpMessage( DhcpContext, size, &dwXid );
}


POPTION                                           // ptr where additional options can be added
FormatDhcpRequest(                                // format a packet for sending out requests
    IN      PDHCP_CONTEXT          DhcpContext,   // context of the adapter to format for
    IN      BOOL                   UseCiAddr      // should ciaddr field be set to desired address?
) {
    LPOPTION                       option;
    LPBYTE                         OptionEnd;
    BYTE                           value;
    PDHCP_MESSAGE                  dhcpMessage;


    dhcpMessage                        = DhcpContext->MessageBuffer;
    RtlZeroMemory( dhcpMessage, DHCP_SEND_MESSAGE_SIZE );
    dhcpMessage->Operation             = BOOT_REQUEST;
    dhcpMessage->HardwareAddressType   = DhcpContext->HardwareAddressType;
    dhcpMessage->SecondsSinceBoot      = (WORD)DhcpContext->SecondsSinceBoot;

    if( UseCiAddr ) {                             // Renewal?  can we receive unicast on this address?
        dhcpMessage->ClientIpAddress   = DhcpContext->DesiredIpAddress;
    } else {                                      // Nope? then leave CIADDR as zero
#if NEWNT
        // For RAS client, use broadcast bit, otherwise the router will try
        // to send as unicast to made-up RAS client hardware address, which
        // will not work.
        // no broadcast flag for mdhcp context

        // Or if we are using AUTONET address, we do the same as our stack
        // will actually have IP address as the autonet address and hence will
        // drop all but BROADCASTS..

        if( !IS_MDHCP_CTX(DhcpContext) && (
            //(DhcpContext->IpAddress == 0 && DhcpContext->HardwareAddressType == HARDWARE_1394) ||
            (DhcpContext->HardwareAddressType == HARDWARE_1394) ||
            IS_APICTXT_ENABLED(DhcpContext) ||
            (DhcpContext->IpAddress && IS_ADDRESS_AUTO(DhcpContext)) )) {
            dhcpMessage->Reserved = htons(DHCP_BROADCAST);
        }

#endif // NEWNT
    }

    if ( IS_MDHCP_CTX(DhcpContext ) ) {
         MDHCP_MESSAGE( dhcpMessage );
    }

    if (DhcpContext->HardwareAddressType != HARDWARE_1394) {
        memcpy(dhcpMessage->HardwareAddress,DhcpContext->HardwareAddress,DhcpContext->HardwareAddressLength);
        dhcpMessage->HardwareAddressLength = (BYTE)DhcpContext->HardwareAddressLength;
    }

    option     = &dhcpMessage->Option;
    OptionEnd  = (LPBYTE)dhcpMessage + DHCP_SEND_MESSAGE_SIZE;

    option     = (LPOPTION) DhcpAppendMagicCookie( (LPBYTE) option, OptionEnd );

    value      =  DHCP_REQUEST_MESSAGE;
    option     = DhcpAppendOption( option, OPTION_MESSAGE_TYPE, &value, 1, OptionEnd );
    option     = DhcpAppendClassIdOption(         // Append class id as soon as we can
        DhcpContext,
        (LPBYTE)option,
        OptionEnd
    );

    return option;
}


DWORD                                             // status
SendDhcpRequest(                                  // send a dhcp request packet
    IN      PDHCP_CONTEXT          DhcpContext,   // the context to send the packet on
    IN      PDWORD                 pdwXid,        // what is hte Xid to use?
    IN      DWORD                  RequestedAddr, // what address do we want?
    IN      DWORD                  SelectedServer,// is there a prefernce for a server?
    IN      BOOL                   UseCiAddr      // should CIADDR be set with desired address?
) {
    POPTION                        option;
    LPBYTE                         OptionEnd;
    DWORD                          Error;

    BYTE                           SentOpt[OPTION_END+1];
    BYTE                           SentVOpt[OPTION_END+1];
    BYTE                           VendorOpt[OPTION_END+1];
    DWORD                          VendorOptSize;

    RtlZeroMemory(SentOpt, sizeof(SentOpt));      // initialize boolean arrays
    RtlZeroMemory(SentVOpt, sizeof(SentVOpt));    // so that no option is presumed sent
    VendorOptSize = 0;                            // encapsulated vendor option is empty
    option = FormatDhcpRequest( DhcpContext, UseCiAddr );
    OptionEnd = (LPBYTE)(DhcpContext->MessageBuffer) + DHCP_SEND_MESSAGE_SIZE;

    if(DhcpContext->ClientIdentifier.fSpecified)  // if client id was specified in the registry
        option = DhcpAppendClientIDOption(        // send it out as an option
            option,
            DhcpContext->ClientIdentifier.bType,
            DhcpContext->ClientIdentifier.pbID,
            (BYTE)DhcpContext->ClientIdentifier.cbID,
            OptionEnd
        );
    else option = DhcpAppendClientIDOption(       // otherwise, send the hw address instead
        option,
        DhcpContext->HardwareAddressType,
        DhcpContext->HardwareAddress,
        (BYTE)DhcpContext->HardwareAddressLength,
        OptionEnd
    );

    DhcpAssert( RequestedAddr != 0 );             // cannot really request zero address

    if( 0 != RequestedAddr && !UseCiAddr) {       // if using CIADDR, dont send this option
         option = DhcpAppendOption(
             option,
             OPTION_REQUESTED_ADDRESS,
             (LPBYTE)&RequestedAddr,
             sizeof(RequestedAddr),
             OptionEnd
         );
    }

    if( IS_MDHCP_CTX(DhcpContext) && DhcpContext->Lease != 0 ) {    // did mdhcp client ask specific lease
        option = DhcpAppendOption(                // maybe we will get it
            option,
            OPTION_LEASE_TIME,
            (LPBYTE)&DhcpContext->Lease,
            sizeof(DhcpContext->Lease),
            OptionEnd
        );
    }

    if(SelectedServer != (DHCP_IP_ADDRESS)(-1)) { // Are we verifying the lease? (for ex INIT-REBOOT)
        option = DhcpAppendOption(                // if not, we have a server to talk to
            option,                               // append this option to talk to that server alone
            OPTION_SERVER_IDENTIFIER,
            (LPBYTE)&SelectedServer,
            sizeof( SelectedServer ),
            OptionEnd
        );
    }

    if ( DhcpGlobalHostName != NULL ) {           // add the host name if we have one
        option = DhcpAppendOption(
            option,
            OPTION_HOST_NAME,
            (LPBYTE)DhcpGlobalHostName,
            (BYTE)(strlen(DhcpGlobalHostName) * sizeof(CHAR)),
            OptionEnd
        );
    }

    //
    // Only for real dhcp clients do we send option 81.
    //
    if( IS_APICTXT_DISABLED(DhcpContext) ) {
        BYTE  Buffer[256];
        ULONG BufSize = sizeof(Buffer) -1, DomOptSize;
        BYTE  *DomOpt;

        GetDomainNameOption(DhcpContext, &DomOpt, &DomOptSize);

        RtlZeroMemory(Buffer, sizeof(Buffer));
        Error = DhcpDynDnsGetDynDNSOption(
            Buffer,
            &BufSize,
            DhcpContext->AdapterInfoKey,
            DhcpAdapterName(DhcpContext),
            UseMHAsyncDns,
            DomOpt,
            DomOptSize
            );
        if( NO_ERROR != Error ) {
            DhcpPrint((
                DEBUG_DNS, "Option 81 not getting added: 0x%lx\n", Error
                ));
        } else {
            DhcpPrint((
                DEBUG_DNS, "Option 81 [%ld bytes]: Flags: %ld, FQDN= [%s]\n",
                BufSize,(ULONG)Buffer[0], &Buffer[3]
                ));

            option = DhcpAppendOption(
                option,
                OPTION_DYNDNS_BOTH,
                Buffer,
                (BYTE)BufSize,
                OptionEnd
                );
        }
    }

    if( NULL != DhcpGlobalClientClassInfo ) {     // if we have any info on client class..
        option = DhcpAppendOption(
            option,
            OPTION_CLIENT_CLASS_INFO,
            (LPBYTE)DhcpGlobalClientClassInfo,
            strlen(DhcpGlobalClientClassInfo),
            OptionEnd
        );
    }

    SentOpt[OPTION_MESSAGE_TYPE] = TRUE;          // these must have been added by now
    if(DhcpContext->ClassIdLength) SentOpt[OPTION_USER_CLASS] = TRUE;
    SentOpt[OPTION_USER_CLASS] = TRUE;
    SentOpt[OPTION_CLIENT_ID] = TRUE;
    SentOpt[OPTION_REQUESTED_ADDRESS] = TRUE;
    SentOpt[OPTION_HOST_NAME] = TRUE;
    SentOpt[OPTION_SERVER_IDENTIFIER] = TRUE;
    SentOpt[OPTION_HOST_NAME] = TRUE;
    SentOpt[OPTION_DYNDNS_BOTH] = TRUE;

    option = DhcpAppendSendOptions(               // append all other options we need to send
        DhcpContext,                              // for this context
        &DhcpContext->SendOptionsList,            // this is the list of options to send out
        DhcpContext->ClassId,                     // which class.
        DhcpContext->ClassIdLength,               // how many bytes are there in the class id
        (LPBYTE)option,                           // start of the buffer to add the options
        (LPBYTE)OptionEnd,                        // end of the buffer up to which we can add options
        SentOpt,                                  // this is the boolean array that marks what opt were sent
        SentVOpt,                                 // this is for vendor spec options
        VendorOpt,                                // this would contain some vendor specific options
        &VendorOptSize                            // the # of bytes of vendor options added to VendorOpt param
    );

    if( !SentOpt[OPTION_VENDOR_SPEC_INFO] && VendorOptSize && VendorOptSize <= OPTION_END )
        option = DhcpAppendOption(                // add vendor specific options if we havent already sent it
            option,
            OPTION_VENDOR_SPEC_INFO,
            VendorOpt,
            (BYTE)VendorOptSize,
            OptionEnd
        );

    option = DhcpAppendOption( option, OPTION_END, NULL, 0, OptionEnd );

    return SendDhcpMessage(
        DhcpContext,
        (DWORD)((LPBYTE)option - (LPBYTE)DhcpContext->MessageBuffer),
        pdwXid
    );
}


DWORD                                             // status
FormatDhcpRelease(                                // format the release packet
    IN      PDHCP_CONTEXT          DhcpContext    // context of adapter to send on
) {
    LPOPTION                       option;
    LPBYTE                         OptionEnd;
    BYTE                           bValue;
    PDHCP_MESSAGE                  dhcpMessage;

    dhcpMessage = DhcpContext->MessageBuffer;
    RtlZeroMemory( dhcpMessage, DHCP_SEND_MESSAGE_SIZE );

    dhcpMessage->Operation = BOOT_REQUEST;
    dhcpMessage->HardwareAddressType = DhcpContext->HardwareAddressType;
    dhcpMessage->SecondsSinceBoot = (WORD)DhcpContext->SecondsSinceBoot;
    dhcpMessage->ClientIpAddress = DhcpContext->IpAddress;

    if ( IS_MDHCP_CTX(DhcpContext ) ) {
         MDHCP_MESSAGE( dhcpMessage );
    } else {
        dhcpMessage->Reserved = htons(DHCP_BROADCAST);
    }

    if (DhcpContext->HardwareAddressType != HARDWARE_1394) {
        memcpy(dhcpMessage->HardwareAddress,DhcpContext->HardwareAddress,DhcpContext->HardwareAddressLength);
        dhcpMessage->HardwareAddressLength = (BYTE)DhcpContext->HardwareAddressLength;
    }
    option = &dhcpMessage->Option;
    OptionEnd = (LPBYTE)dhcpMessage + DHCP_SEND_MESSAGE_SIZE;

    option = (LPOPTION) DhcpAppendMagicCookie( (LPBYTE) option, OptionEnd );

    bValue =  DHCP_RELEASE_MESSAGE;
    option = DhcpAppendOption(
        option,
        OPTION_MESSAGE_TYPE,
        &bValue,
        1,
        OptionEnd
    );

    option = DhcpAppendOption(
        option,
        OPTION_SERVER_IDENTIFIER,
        &DhcpContext->DhcpServerAddress,
        sizeof(DhcpContext->DhcpServerAddress),
        OptionEnd
    );

    if(DhcpContext->ClientIdentifier.fSpecified)  // if the client id option is specified
        option = DhcpAppendClientIDOption(        // use that and send it to the server
            option,
            DhcpContext->ClientIdentifier.bType,
            DhcpContext->ClientIdentifier.pbID,
            (BYTE)DhcpContext->ClientIdentifier.cbID,
            OptionEnd
        );
    else
        option = DhcpAppendClientIDOption(        // otherwise send the h/w addr instead
            option,
            DhcpContext->HardwareAddressType,
            DhcpContext->HardwareAddress,
            (BYTE)DhcpContext->HardwareAddressLength,
            OptionEnd
        );

    option = DhcpAppendOption( option, OPTION_END, NULL, 0, OptionEnd );

    return (DWORD)( (LPBYTE)option - (LPBYTE)dhcpMessage );
}

DWORD                                             // status
SendDhcpRelease(                                  // send the release packet
    IN      PDHCP_CONTEXT          DhcpContext    // adapter context to send release on
) {
    DWORD                          Xid = 0;       // 0 ==> SendDhcpMessage would choose random value

    return SendDhcpMessage( DhcpContext, FormatDhcpRelease(DhcpContext), &Xid );
}

BOOL INLINE                                       // should this offer be accepted?
AcceptThisOffer(                                  // decide to choose the offer
    IN      PDHCP_EXPECTED_OPTIONS DhcpOptions,   // Options received from the server.
    IN      PDHCP_CONTEXT          DhcpContext,   // The context of the adapter..
    IN      PDHCP_IP_ADDRESS       SelectedServer,// The server selected, to select.
    IN      PDHCP_IP_ADDRESS       SelectedAddr,  // The address selected, to select.
    IN      DWORD                  RoundNum       // The # of discovers sent so far.
) {
    DHCP_IP_ADDRESS                LocalSelectedServer;
    DHCP_IP_ADDRESS                LocalSelectedAddr;
    DHCP_IP_ADDRESS                LocalSelectedSubnetMask;

    if( DhcpOptions->ServerIdentifier != NULL ) {
        LocalSelectedServer = *DhcpOptions->ServerIdentifier;
    } else {
        DhcpPrint((DEBUG_PROTOCOL, "Invalid Server ID\n"));
        LocalSelectedServer = (DWORD) -1;
    }

    if ( DhcpOptions->SubnetMask != NULL ) {
        LocalSelectedSubnetMask = *DhcpOptions->SubnetMask;
    } else {
        LocalSelectedSubnetMask = 0;
    }

    LocalSelectedAddr =  DhcpContext->MessageBuffer->YourIpAddress;

    if( 0 == LocalSelectedAddr || 0xFFFFFFFF == LocalSelectedAddr ) {
        return FALSE;
    }

    // note down the (first) server IP addr even if we dont accept this.
    if( *SelectedServer == (DWORD)-1) {           // note down the first server IP addr even
        *SelectedServer = LocalSelectedServer;    // if we dont really accept this
        *SelectedAddr   = LocalSelectedAddr;
    }

    DhcpPrint((DEBUG_PROTOCOL, "Successfully received a DhcpOffer (%s) ",
                   inet_ntoa(*(struct in_addr *)&LocalSelectedAddr) ));

    DhcpPrint((DEBUG_PROTOCOL, "from %s.\n",
                   inet_ntoa(*(struct in_addr*)&LocalSelectedServer) ));

    // Accept the offer if
    //   (a)  We were prepared to accept any offer.
    //   (b)  We got the address we asked for.
    //   (c)  the retries > DHCP_ACCEPT_RETRIES
    //   (d)  different subnet address.

    if( !DhcpContext->DesiredIpAddress || RoundNum >= DHCP_ACCEPT_RETRIES ||
        DhcpContext->DesiredIpAddress == LocalSelectedAddr ||
        (DhcpContext->DesiredIpAddress&LocalSelectedSubnetMask) !=
        (LocalSelectedAddr & LocalSelectedSubnetMask) ) {

        *SelectedServer = LocalSelectedServer;
        *SelectedAddr   = LocalSelectedAddr;

        return TRUE;                              // accept this offer.
    }
    return FALSE;                                 // reject this offer.
}

DWORD                                             // status;if addr in use: ERROR_DHCP_ADDRESS_CONFLICT
ObtainInitialParameters(                          // get a new lease from the dhcp server
    IN      PDHCP_CONTEXT          DhcpContext,   // context of adapter to get the lease for
    OUT     PDHCP_OPTIONS          DhcpOptions,   // return some of the options sent out by the dhcpserver
    OUT     PBOOL                  fAutoConfigure // should we autoconfigure?
)
/*++

Routine Description:

    Obtain lease from DHCP server through DISCOVER-OFFER-REQUEST-ACK/NAK.

Arguments:

Return Value:

    ERROR_CANCELLED     when the renewal is cancelled

--*/
{
    DHCP_EXPECTED_OPTIONS          ExpOptions;
    DWORD                          Error;
    time_t                         StartTime;
    time_t                         InitialStartTime;
    time_t                         TimeNow;
    DWORD                          TimeToWait;
    DWORD                          Xid;
    DWORD                          RoundNum, NewRoundNum;
    DWORD                          MessageSize;
    DWORD                          SelectedServer;
    DWORD                          SendFailureCount = 3;
    DWORD                          SelectedAddress;
    time_t                         LeaseExpiryTime;
    BOOL                           GotOffer;
    BOOL                           GotAck;

    Xid                            = 0;           // generate xid on first send.  keep it same throughout
    DhcpContext->SecondsSinceBoot  = 0;
    SelectedServer                 = (DWORD)-1;
    SelectedAddress                = (DWORD)-1;
    GotOffer = GotAck              = FALSE;
    InitialStartTime               = time(NULL);
    *fAutoConfigure                = IS_AUTONET_ENABLED(DhcpContext);

    for (RoundNum = 0; RoundNum < DHCP_MAX_RETRIES; RoundNum = NewRoundNum ) {

        Error = SendDhcpDiscover(                 // send a discover packet
            DhcpContext,
            &Xid
        );

        NewRoundNum = RoundNum +1;
        if ( Error != ERROR_SUCCESS ) {           // can't really fail here
            DhcpPrint((DEBUG_ERRORS, "Send Dhcp Discover failed, %ld.\n", Error));
            if( SendFailureCount ) {
                SendFailureCount --;
                NewRoundNum --;
            }
        }

        DhcpPrint((DEBUG_PROTOCOL, "Sent DhcpDiscover Message.\n"));

        TimeToWait = DhcpCalculateWaitTime(RoundNum, NULL);
        StartTime  = time(NULL);

        while ( TRUE ) {                         // wait for specified time
            MessageSize = DHCP_RECV_MESSAGE_SIZE;

            DhcpPrint((DEBUG_TRACE, "Waiting for Offer: %ld seconds\n", TimeToWait));

            Error = GetSpecifiedDhcpMessage(      // try to receive an offer
                DhcpContext,
                &MessageSize,
                Xid,
                (DWORD)TimeToWait
            );

            if ( Error == ERROR_SEM_TIMEOUT ) {   // get out and try another discover
                DhcpPrint(( DEBUG_PROTOCOL, "Dhcp offer receive Timeout.\n" ));
                break;
            }

            if ( ERROR_SUCCESS != Error ) {       // unexpected error
                DhcpPrint(( DEBUG_PROTOCOL, "Dhcp Offer receive failed, %ld.\n", Error ));
                return Error ;
            }

            DhcpExtractFullOrLiteOptions(         // now extract basic information
                DhcpContext,
                (LPBYTE)&DhcpContext->MessageBuffer->Option,
                MessageSize - DHCP_MESSAGE_FIXED_PART_SIZE,
                TRUE,                             // dont extract everything, only the basic options
                &ExpOptions,
                NULL,
                NULL,
                NULL,
                0,
                0
            );

            if( NULL == ExpOptions.MessageType ||
                DHCP_OFFER_MESSAGE != *ExpOptions.MessageType ) {
                DhcpPrint(( DEBUG_PROTOCOL, "Received Unknown Message.\n"));
            } else {
                GotOffer = AcceptThisOffer(       // check up and see if we find this offer kosher
                    &ExpOptions,
                    DhcpContext,
                    &SelectedServer,
                    &SelectedAddress,
                    RoundNum
                );
                if( GotOffer ) break;             // ok accepting the offer
                if( 0 == DhcpContext->MessageBuffer->YourIpAddress ) {
                    //
                    // Check for autoconfigure option being present..
                    //
                    if( CFLAG_AUTOCONF_OPTION && ExpOptions.AutoconfOption ) {
                        if( AUTOCONF_DISABLED == *(ExpOptions.AutoconfOption ) ) {
                            (*fAutoConfigure) = FALSE;
                        }
                    }
                }
            }

            TimeNow     = time( NULL );           // calc the remaining wait time for this round
            if( TimeToWait < (DWORD)(TimeNow - StartTime) ) {
                break;                            // no more time left to wait
            }
            TimeToWait -= (DWORD)(TimeNow - StartTime);
            StartTime   = TimeNow;

        } // while (TimeToWait > 0 )

        if(GotOffer) {                            // if we got an offer, everything should be fine
            DhcpAssert(ERROR_SUCCESS == Error);
            break;
        }

        DhcpContext->SecondsSinceBoot = (DWORD)(TimeNow - InitialStartTime);
    } // for n tries... send discover.

    if(!GotOffer || SelectedAddress == (DWORD)-1) // did not get any valid offers
        return ERROR_SEM_TIMEOUT ;

    (*fAutoConfigure) = FALSE;
    DhcpPrint((DEBUG_PROTOCOL,"Accepted Offer(%s)",inet_ntoa(*(struct in_addr*)&SelectedAddress)));
    DhcpPrint((DEBUG_PROTOCOL," from %s.\n",inet_ntoa(*(struct in_addr*)&SelectedServer)));

    //
    // Fix correct domain name.
    //

    RtlZeroMemory(
        DhcpContext->DomainName, sizeof(DhcpContext->DomainName)
        );
    if( ExpOptions.DomainNameSize ) {
        RtlCopyMemory(
            DhcpContext->DomainName, ExpOptions.DomainName,
            ExpOptions.DomainNameSize
            );
    }

    for ( RoundNum = 0; RoundNum < DHCP_MAX_RETRIES; RoundNum = NewRoundNum ) {
        Error = SendDhcpRequest(                  // try to receive the ack for the offer we got
            DhcpContext,
            &Xid,                                 // use same transaction id as before
            SelectedAddress,
            SelectedServer,
            FALSE                                 // do not use ciaddr.
        );
        NewRoundNum = RoundNum+1;
        if ( Error != ERROR_SUCCESS ) {           // dont expect send to fail
            DhcpPrint(( DEBUG_ERRORS, "Send request failed, %ld.\n", Error));
            if( SendFailureCount ) {
                SendFailureCount --;
                NewRoundNum --;
            }
        }

        TimeToWait = DhcpCalculateWaitTime(RoundNum, NULL);
        StartTime  = time(NULL);

        while ( TRUE ) {                          // either get an ack or run the full round
            MessageSize = DHCP_RECV_MESSAGE_SIZE;

            Error = GetSpecifiedDhcpMessage(      // try to receive an ACK
                DhcpContext,
                &MessageSize,
                Xid,
                TimeToWait
            );

            if ( Error == ERROR_SEM_TIMEOUT ) {   // did not receive an ack, try another round
                DhcpPrint(( DEBUG_PROTOCOL, "Dhcp ACK receive Timeout.\n" ));
                break;
            }

            if ( ERROR_SUCCESS != Error ) {       // unexpected error
                DhcpPrint(( DEBUG_PROTOCOL, "Dhcp ACK receive failed, %ld.\n", Error ));
                goto EndFunc;
            }

            DhcpExtractFullOrLiteOptions(         // now extract basic information
                DhcpContext,
                (LPBYTE)&DhcpContext->MessageBuffer->Option,
                MessageSize - DHCP_MESSAGE_FIXED_PART_SIZE,
                TRUE,                             // dont extract everything, only the basic options
                &ExpOptions,
                NULL,
                &LeaseExpiryTime,
                NULL,
                0,
                0
            );

            if(! ExpOptions.MessageType ) {       // sanity check before accepting this
                DhcpPrint(( DEBUG_PROTOCOL, "Received Unknown Message.\n" ));
            } else if (DHCP_NACK_MESSAGE == *ExpOptions.MessageType) {
                DhcpPrint((DEBUG_PROTOCOL, "Received NACK\n"));
                if( ExpOptions.ServerIdentifier ) {
                    DhcpContext->DhcpServerAddress = *(ExpOptions.ServerIdentifier);
                } else {
                    DhcpContext->DhcpServerAddress = 0;
                }
                DhcpContext->NackedIpAddress = SelectedAddress;

                Error = ERROR_ACCESS_DENIED;
                goto EndFunc;
            } else if (DHCP_ACK_MESSAGE  != *ExpOptions.MessageType) {
                DhcpPrint((DEBUG_PROTOCOL, "Received Unknown ACK.\n"));
            } else {                              // verify if the ack is kosher
                DHCP_IP_ADDRESS AckServer;

                if ( ExpOptions.ServerIdentifier != NULL ) {
                    AckServer = *ExpOptions.ServerIdentifier;
                } else {
                    AckServer = SelectedServer;
                }

                if( SelectedAddress == DhcpContext->MessageBuffer->YourIpAddress ) {
                    if( AckServer == SelectedServer ) {
                        GotAck = TRUE;            // everything is kosher, quit this loop
                        break;
                    }
                }

                DhcpPrint(( DEBUG_PROTOCOL, "Received an ACK -unknown server or ip-address.\n" ));
            }

            TimeNow     = time(NULL);
            if( (DWORD)(TimeNow - StartTime) > TimeToWait ) {
                break;                            // finished required time to wait..
            }
            TimeToWait -= (DWORD)(TimeNow - StartTime);
            StartTime   = TimeNow;
        } // while time to wait

        if(TRUE == GotAck) {                      // if we got an ack, everything must be good
            DhcpAssert(ERROR_SUCCESS == Error);   // cannot have any errors
            break;
        }
    } // for RoundNum < MAX_RETRIES

    if(!GotAck) {
        Error = ERROR_SEM_TIMEOUT ;
        goto EndFunc;
    }

    DhcpContext->DhcpServerAddress = SelectedServer;
    DhcpContext->IpAddress         = SelectedAddress;
    if( ExpOptions.SubnetMask ) {
        DhcpContext->SubnetMask    = *ExpOptions.SubnetMask;
    } else {
        DhcpContext->SubnetMask    = DhcpDefaultSubnetMask(DhcpContext->IpAddress);
    }

    if ( ExpOptions.LeaseTime != NULL) {
        DhcpContext->Lease = ntohl( *ExpOptions.LeaseTime );
    } else {
        DhcpContext->Lease = DHCP_MINIMUM_LEASE;
    }

    // if previously the context was autonet with a fallback configuration
    // we need to clean up all the options that were set through the
    // fallback configuration
    if (IS_ADDRESS_AUTO(DhcpContext) && IS_FALLBACK_ENABLED(DhcpContext))
        DhcpClearAllOptions(DhcpContext);

    DhcpExtractFullOrLiteOptions(
        DhcpContext,
        (LPBYTE)&DhcpContext->MessageBuffer->Option,
        MessageSize - DHCP_MESSAGE_FIXED_PART_SIZE,
        FALSE,                                    // extract every option
        DhcpOptions,
        &(DhcpContext->RecdOptionsList),
        &LeaseExpiryTime,
        DhcpContext->ClassId,
        DhcpContext->ClassIdLength,
        0                                           // dont care about serverid
    );

    Error = SetDhcpConfigurationForNIC(
        DhcpContext,
        DhcpOptions,
        DhcpContext->IpAddress,
        DhcpContext->DhcpServerAddress,
        TRUE
    );

    if ( ERROR_DHCP_ADDRESS_CONFLICT == Error ) {
        HandleDhcpAddressConflict( DhcpContext, Xid);
        Error = ERROR_DHCP_ADDRESS_CONFLICT;
        goto EndFunc;
    }

    DhcpPrint((DEBUG_PROTOCOL, "Accepted ACK (%s) ",
               inet_ntoa(*(struct in_addr *)&SelectedAddress) ));
    DhcpPrint((DEBUG_PROTOCOL, "from %s.\n",
               inet_ntoa(*(struct in_addr *)&SelectedServer)));
    DhcpPrint((DEBUG_PROTOCOL, "Lease is %ld secs.\n", DhcpContext->Lease));

    Error = ERROR_SUCCESS;
EndFunc:

    //
    // Cleanup DomainName so that on return this is always set to
    // empty string no matter what.
    //
    RtlZeroMemory(
        DhcpContext->DomainName, sizeof(DhcpContext->DomainName)
        );
    return Error;
}

BOOL _inline
InvalidSID(
    IN      LPBYTE                 SidOption
)
{
    DWORD                          Sid;

    if( NULL == SidOption ) return FALSE;
    Sid = *(DWORD UNALIGNED *)SidOption;
    if( 0 == Sid || (-1) == Sid ) return TRUE;
    return FALSE;
}

DWORD                                             // status
RenewLease(                                       // renew lease for existing address
    IN      PDHCP_CONTEXT          DhcpContext,   // context of adapter to renew for
    IN      PDHCP_OPTIONS          DhcpOptions    // some of the options returned
)
/*++

Routine Description:

    Renew lease through REQUEST-ACK/NAK

Arguments:

Return Value:

    ERROR_CANCELLED     the request is cancelled
    ERROR_SEM_TIMEOUT   the request time out
    ERROR_SUCCESS       message is ready
    other               unknown failure

--*/
{
    DHCP_EXPECTED_OPTIONS          ExpOptions;
    DWORD                          Error;
    DWORD                          Xid;
    DWORD                          RoundNum, NewRoundNum;
    DWORD                          TimeToWait;
    DWORD                          MessageSize;
    time_t                         LeaseExpiryTime;
    time_t                         InitialStartTime;
    DWORD                          SendFailureCount = 3;
    time_t                         StartTime;
    time_t                         TimeNow;

    DhcpPrint((DEBUG_TRACK,"Entered RenewLease.\n"));

    Xid = 0;                                     // new Xid will be generated first time
    DhcpContext->SecondsSinceBoot = 0;
    InitialStartTime = time(NULL);

    for ( RoundNum = 0; RoundNum < DHCP_MAX_RENEW_RETRIES; RoundNum = NewRoundNum) {
        Error = SendDhcpRequest(                 // send a request
            DhcpContext,
            &Xid,
            DhcpContext->DesiredIpAddress,
            (DHCP_IP_ADDRESS)(-1),               // don't include server ID option.
            IS_ADDRESS_PLUMBED(DhcpContext)
        );
        NewRoundNum = RoundNum+1 ;
        if ( Error != ERROR_SUCCESS ) {          // dont expect send to fail
            DhcpPrint(( DEBUG_ERRORS,"Send request failed, %ld.\n", Error));
            if( SendFailureCount ) {
                SendFailureCount --;
                NewRoundNum --;
            }
        }

        TimeToWait = DhcpCalculateWaitTime(RoundNum, NULL);
        StartTime  = time(NULL);


        if( StartTime >= DhcpContext->LeaseExpires )
        {
            return ERROR_SEM_TIMEOUT;
        }
        else
        {
            DWORD Diff = (DWORD)(DhcpContext->LeaseExpires - StartTime);
            if( Diff < TimeToWait )
            {
                TimeToWait = Diff;
            }
        }

        while ( TRUE ) {                         // try to recv message for this full period
            MessageSize = DHCP_RECV_MESSAGE_SIZE;
            Error = GetSpecifiedDhcpMessage(     // expect to recv an ACK
                DhcpContext,
                &MessageSize,
                Xid,
                TimeToWait
            );

            if ( Error == ERROR_SEM_TIMEOUT ) {  // No response, so resend DHCP REQUEST.
                DhcpPrint(( DEBUG_PROTOCOL, "Dhcp ACK receive Timeout.\n" ));
                break;
            }

            if ( ERROR_SUCCESS != Error ) {      // unexpected error
                DhcpPrint(( DEBUG_PROTOCOL, "Dhcp ACK receive failed, %ld.\n", Error ));
                return Error ;
            }

            DhcpExtractFullOrLiteOptions(         // now extract basic information
                DhcpContext,
                (LPBYTE)&DhcpContext->MessageBuffer->Option,
                MessageSize - DHCP_MESSAGE_FIXED_PART_SIZE,
                TRUE,                             // dont extract everything, only the basic options
                &ExpOptions,
                NULL,
                &LeaseExpiryTime,
                NULL,
                0,
                0
            );

            if( !ExpOptions.MessageType ) {      // do some basic sanity checking
                DhcpPrint(( DEBUG_PROTOCOL, "Received Unknown Message.\n"));
            } else if( DHCP_NACK_MESSAGE == *ExpOptions.MessageType ) {
                if( ExpOptions.ServerIdentifier ) {
                    DhcpContext->DhcpServerAddress = *(ExpOptions.ServerIdentifier);
                } else {
                    DhcpContext->DhcpServerAddress = 0;
                }
                DhcpContext->NackedIpAddress = DhcpContext->IpAddress;

                return ERROR_ACCESS_DENIED;
            } else if( DHCP_ACK_MESSAGE != *ExpOptions.MessageType ) {
                DhcpPrint(( DEBUG_PROTOCOL, "Received unknown message.\n"));
            } else if( DhcpContext->IpAddress != DhcpContext->MessageBuffer->YourIpAddress) {
                DhcpPrint((DEBUG_ERRORS, "Misbehaving server: offered %s :",
                           inet_ntoa(*(struct in_addr*)&DhcpContext->MessageBuffer->YourIpAddress)));
                DhcpPrint((DEBUG_ERRORS, " Requested %s \n",
                           inet_ntoa(*(struct in_addr*)&DhcpContext->IpAddress)));
                //DhcpAssert(FALSE);
            } else if( InvalidSID((LPBYTE)ExpOptions.ServerIdentifier) ) {
                DhcpPrint(( DEBUG_PROTOCOL, "Received ACK with INVALID ServerId\n"));
            } else {                              // our request was ACK'ed.
                DHCP_IP_ADDRESS AckServer = (DHCP_IP_ADDRESS)-1;

                if ( ExpOptions.ServerIdentifier != NULL ) {
                    AckServer = *ExpOptions.ServerIdentifier;
                } else {
                    AckServer = DhcpContext->DhcpServerAddress;
                }

                if( AckServer != (DHCP_IP_ADDRESS)(-1) && 0 != AckServer ) {
                    DhcpContext->DhcpServerAddress = AckServer;
                }

                if ( ExpOptions.LeaseTime != NULL) {
                    DhcpContext->Lease = ntohl( *ExpOptions.LeaseTime );
                } else {
                    DhcpContext->Lease = DHCP_MINIMUM_LEASE;
                }

                DhcpExtractFullOrLiteOptions(     // extract all the options now
                    DhcpContext,
                    (LPBYTE)&DhcpContext->MessageBuffer->Option,
                    MessageSize - DHCP_MESSAGE_FIXED_PART_SIZE,
                    FALSE,                        // extract everything, not only the basic options
                    DhcpOptions,
                    &(DhcpContext->RecdOptionsList),
                    &LeaseExpiryTime,
                    DhcpContext->ClassId,
                    DhcpContext->ClassIdLength,
                    0                               // dont care about serverid
                );

                Error = SetDhcpConfigurationForNIC(
                    DhcpContext,
                    DhcpOptions,
                    DhcpContext->IpAddress,
                    DhcpContext->DhcpServerAddress,
                    IS_ADDRESS_UNPLUMBED(DhcpContext)
                );

                if ( ERROR_DHCP_ADDRESS_CONFLICT == Error ) {
                    HandleDhcpAddressConflict( DhcpContext, Xid );
                    return ERROR_DHCP_ADDRESS_CONFLICT;
                }

                return ERROR_SUCCESS;
            }

            TimeNow     = time( NULL );
            if( TimeNow > DhcpContext->LeaseExpires ) {
                //
                // If we have already passed lease expiration time,
                // give up right away.
                //
                return ERROR_SEM_TIMEOUT;
            }

            if( TimeToWait < (DWORD)(TimeNow - StartTime) ) {
                break;                            // finished waiting reqd amt of time
            }

            TimeToWait -= (DWORD)(TimeNow - StartTime);
            StartTime   = TimeNow;

        } // while time to wait

        DhcpContext->SecondsSinceBoot = (DWORD)(InitialStartTime - TimeNow);
    } // for RoundNum < MAX_RETRIES

    DhcpPrint((DEBUG_TRACK,"Leaving RenewLease.\n"));

    return ERROR_SEM_TIMEOUT;
}

DWORD                                             // status
ReleaseIpAddress(                                 // release the ip address lease
    IN      PDHCP_CONTEXT          DhcpContext    // adapter context to send release for
) {
    DWORD                          Error;

    if( IS_ADDRESS_AUTO(DhcpContext)) {           // if currently using autoconfigured address
        return ERROR_SUCCESS;                     // nothing needs to be done here
    }

    OpenDhcpSocket( DhcpContext );                // open if closed

    Error = SendDhcpRelease( DhcpContext );       // send the actual release packet

    if ( Error != ERROR_SUCCESS ) {               // cant really fail?
        DhcpPrint(( DEBUG_ERRORS, "Send request failed, %ld.\n", Error ));
//        return Error;
        DhcpLogEvent(DhcpContext, EVENT_NET_ERROR, Error);
        Error = ERROR_SUCCESS;
    } else {
        DhcpPrint(( DEBUG_PROTOCOL, "ReleaseIpAddress: Sent Dhcp Release.\n"));
    }

    Error = SetDhcpConfigurationForNIC(           // remember current addr to request next time
        DhcpContext,
        NULL,
        0,
        (DHCP_IP_ADDRESS)(-1),
        TRUE
    );

    DhcpContext->RenewalFunction = ReObtainInitialParameters;
    CloseDhcpSocket( DhcpContext );

    if( ERROR_SUCCESS != Error ) {                // cant really fail
        DhcpPrint((DEBUG_ERRORS, "SetDhcpConfigurationForNIC failed %ld\n", Error));
    }

    return Error;
}

DHCP_GATEWAY_STATUS
CouldPingGateWay(
    IN PDHCP_CONTEXT DhcpContext
)
/*++

Routine Description:
    This routine checks to see if any old known
    routers are present.

    See RefreshNotNeeded for details.  Just a small
    wrapper around that routine.

Return Value:
    TRUE -- some router present.
    FALSE -- none present.

--*/
{
#ifdef VXD
    return FALSE;                                 // ON VXD's -- return g/w not present always
#else  VXD

    if( DhcpContext->DontPingGatewayFlag ) {      // if disabled via registry, return g/w absent
        return DHCP_GATEWAY_REACHABLE;
    }

    if( IS_MEDIA_RECONNECTED(DhcpContext) ) {
        //
        // On reconnect, always act as if the gateway isn't present.
        // Infact, this check would have been done even before in
        // mediasns.c
        //
        return DHCP_GATEWAY_UNREACHABLE;
    }

    return RefreshNotNeeded(DhcpContext);

#endif VXD // end of non-vxd code.
}

BOOL                                              // TRUE ==> context is init state
DhcpIsInitState(                                  // is context in init state?
    IN      PDHCP_CONTEXT          DhcpContext    // adpater context
) {

    if( 0 == DhcpContext->IpAddress )             // if we dont have any ip address, then init state
        return TRUE;
    if ( IS_AUTONET_DISABLED(DhcpContext))        // if autonet disabled, no other state is possible
        return FALSE;

    if( IS_DHCP_DISABLED(DhcpContext)) {          // static adapter
        return FALSE;
    }

    return IS_ADDRESS_AUTO(DhcpContext);          // if we are using autonet address, then in init state
}


DWORD                                             // status
ReObtainInitialParameters(                        // obtain a lease from the server; add context to RenewalList
    IN      PDHCP_CONTEXT          DhcpContext,   // adapter context to get lease for
    OUT     LPDWORD                Sleep          // if nonNULL, return the amt of time intended to sleep
) {
    DWORD                          Error, Error2;
    LONG                           timeToSleep;
    DHCP_OPTIONS                   dhcpOptions;
    BOOL                           fAutoConfigure = TRUE;
    DWORD                          PopupTime = 0;

#ifdef CHICAGO
    // Did we just boot up on a non-laptop machine?
    BOOL fJustBootedOnNonLapTop = JustBootedOnNonLapTop(DhcpContext);
#else
    // In NT, all machines are treated like LAPTOPS as far as EASYNET is concerned.
    BOOL fJustBootedOnNonLapTop = FALSE;
    // Just to make sure we have the right information.. this fn is needed.
    // Otherwise the JustBooted function will say TRUE when being called elsewhere.
    // Look at the JustBooted fn at the top of this file and you'll know why.
    BOOL fJustBooted = JustBooted(DhcpContext);
#endif

    DhcpPrint((DEBUG_TRACK, "Entered ReObtainInitialParameters\n"));

#ifdef VXD
    CleanupDhcpOptions( DhcpContext );
#endif

    OpenDhcpSocket( DhcpContext );

    if( IS_AUTONET_ENABLED(DhcpContext) ) SERVER_UNREACHED(DhcpContext);
    else SERVER_REACHED(DhcpContext);

    MEDIA_RECONNECTED( DhcpContext );
    Error = ObtainInitialParameters(              // try to obtain a lease from the server
        DhcpContext,                              // if this fails, but server was reachable
        &dhcpOptions,                             // then, IS_SERVER_REACHABLE would be true
        &fAutoConfigure
    );
    MEDIA_CONNECTED( DhcpContext );

    DhcpContext->RenewalFunction = ReObtainInitialParameters;
    timeToSleep = 0;                              // default renewal fn is reobtain, time = 0

    if( Error == ERROR_SUCCESS) {                // everything went fine
        timeToSleep = CalculateTimeToSleep( DhcpContext );
        DhcpContext->RenewalFunction = ReRenewParameters;

        if( DhcpGlobalProtocolFailed ) {          // dont throw unecessary popups
            DhcpGlobalProtocolFailed = FALSE;
            DisplayUserMessage(
                DhcpContext,
                MESSAGE_SUCCESSFUL_LEASE,
                DhcpContext->IpAddress
            );
        }

        DhcpPrint((DEBUG_LEASE, "Lease acquisition succeeded.\n"));
        DhcpContext->RenewalFunction = ReRenewParameters;
        goto Cleanup;
    }

    if( ERROR_DHCP_ADDRESS_CONFLICT == Error ) {  // the address was in use -- retry
        DhcpLogEvent(DhcpContext, EVENT_ADDRESS_CONFLICT, 0);
        timeToSleep = ADDRESS_CONFLICT_RETRY;
        goto Cleanup;
    }

    if( !CFLAG_AUTOCONF_OPTION ) {
        //
        // If we are not looking at the autoconf option that hte server is returning,
        // then we decide whether we want to autoconfigure or not based on whether we
        // got any packet from the dhcp server or not....
        // Otherwise, we decide this based on the fAutoConfigure flag alone, which
        // would be modified by the dhcp client when it receives an acceptable offer
        // (it would be turned off) or when some dhcp server on the network requires
        // autoconfiguration to be turned off.
        //
        fAutoConfigure = !IS_SERVER_REACHABLE(DhcpContext);
    }

    if ( FALSE == fAutoConfigure ) {
        //  removed || fJustBootedOnNonLapTop from the condition, as this would
        //  endup starting off with 0.0.0.0 address even when autonet was enabled?

        //
        // If asked NOT to autoconfigure, then do not autoconfigure..
        //

        if ( Error == ERROR_ACCESS_DENIED ) {         // lease renewal was NAK'ed
            DhcpPrint((DEBUG_LEASE, "Lease renew is Nak'ed, %ld.\n", Error ));
            DhcpPrint((DEBUG_LEASE, "Fresh renewal is requested.\n" ));

            DhcpLogEvent( DhcpContext, EVENT_NACK_LEASE, Error );
            DhcpContext->DesiredIpAddress = 0;
        } else {
            DhcpLogEvent( DhcpContext, EVENT_FAILED_TO_OBTAIN_LEASE, Error );
        }

        if ( !DhcpGlobalProtocolFailed ) {        // dont log too often
            DhcpGlobalProtocolFailed = TRUE;
            PopupTime = DisplayUserMessage(DhcpContext,MESSAGE_FAILED_TO_OBTAIN_LEASE,(DWORD)-1 );
        } else {
            PopupTime = 0;
        }

        if(PopupTime < ADDRESS_ALLOCATION_RETRY) {
            timeToSleep = ADDRESS_ALLOCATION_RETRY - PopupTime;
            timeToSleep += RAND_RETRY_DELAY;
            if( timeToSleep < 0 ) {
                //
                // wrap around
                //

                timeToSleep = 0;
            }
        }

        if( Error != ERROR_CANCELLED &&
            0 != DhcpContext->IpAddress ) {
            //
            // If we have not zeroed the Ip address yet.. do it now..
            //
            SetDhcpConfigurationForNIC(
                DhcpContext,
                NULL,
                0,
                (DHCP_IP_ADDRESS)(-1),
                TRUE
                );

        }

        if( ERROR_ACCESS_DENIED == Error ) {
            //
            // Sleep 1 second for a NACK
            //
            timeToSleep = 1;
            DhcpContext->DesiredIpAddress = 0;
        }

        goto Cleanup;
    }

    if( 0 == DhcpContext->IpAddress ||
        DhcpContext->IPAutoconfigurationContext.Address != DhcpContext->IpAddress ) {
        BOOL   WasAutoModeBefore;

        WasAutoModeBefore = IS_ADDRESS_AUTO(DhcpContext);
        DhcpPrint((DEBUG_PROTOCOL, "Autoconfiguring....\n"));


        if(!DhcpGlobalProtocolFailed && !WasAutoModeBefore) {
            DhcpGlobalProtocolFailed = TRUE;
            DisplayUserMessage(
                DhcpContext,
                MESSAGE_FAILED_TO_OBTAIN_LEASE,
                0
            );
        }

        if (Error != ERROR_CANCELLED)
        {
            // attempt autoconfiguration
            Error2 = DhcpPerformIPAutoconfiguration(DhcpContext);
            if( ERROR_SUCCESS == Error2 )
            {
                DhcpLogEvent( DhcpContext, EVENT_IPAUTOCONFIGURATION_SUCCEEDED, 0);

                // in case the autoconfig succeeded with a pure autonet address,
                // the first discover will be scheduled 2 secs after that.
                if (IS_FALLBACK_DISABLED(DhcpContext))
                {
                    timeToSleep = 2;
                    goto Cleanup;
                }
            }
            else
            {
                Error = Error2;
                DhcpLogEvent( DhcpContext, EVENT_IPAUTOCONFIGURATION_FAILED, Error2 );
            }

            // no matter whether the autoconfig succeeded or failed, if the adapter is set
            // for fallback config we won't initiate a re-discover any further
            if (IS_FALLBACK_ENABLED(DhcpContext))
            {
                timeToSleep = INFINIT_LEASE;
                goto Cleanup;
            }
        }

    } else {
        DhcpPrint((DEBUG_PROTOCOL, "Not autoconfiguring..\n"));
    }


    timeToSleep = AutonetRetriesSeconds + RAND_RETRY_DELAY;
    if( timeToSleep < 0 ) {
        //
        // wrap around
        //
        timeToSleep = 0;
    }


  Cleanup:

    // if the media was just reconnected before this renewal attemp,
    // make a note that media is now in connected state. This is required
    // bcoz we special case the first renewal cycle after media reconnect.
    // First renewal cycle after media reconnect is treated as INIT-REBOOT
    // later on, we fall back to normal RENEW state.
    // see DhcpSendMessage routine also.
    if (Error != ERROR_CANCELLED && IS_MEDIA_RECONNECTED( DhcpContext ) ) {
        MEDIA_CONNECTED( DhcpContext );
    }

    // The same logic applies when power is resumed on the system.
    if ( IS_POWER_RESUMED( DhcpContext ) ) {
        POWER_NOT_RESUMED( DhcpContext );
    }

    // reschedule and wakeup the required guys.
    ScheduleWakeUp( DhcpContext, Error == ERROR_CANCELLED ? 6 : timeToSleep );
    DhcpPrint((DEBUG_LEASE, "Sleeping for %ld seconds.\n", timeToSleep ));

    //
    // we just tried to reach the server.. so lets mark this as the time..
    //
    DhcpContext->LastInformSent = time(NULL);

    //
    // Restore the "context looked" bit.
    //
    if (fJustBooted && Error == ERROR_CANCELLED) {
        CTXT_WAS_NOT_LOOKED( DhcpContext );
    }


    CloseDhcpSocket( DhcpContext );
    if(Sleep)  *Sleep = timeToSleep;

    if( ERROR_SUCCESS != Error) {
        DhcpPrint((DEBUG_LEASE, "Lease acquisition failed, %ld.\n", Error ));
    }

    return Error ;
}

DWORD                                             // win32 status
InitRebootPlumbStack(                             // plumb for init-reboot
    IN OUT  PDHCP_CONTEXT          DhcpContext
) {
    DHCP_FULL_OPTIONS              DummyOptions;
    PDHCP_OPTION                   ThisOption;
    DWORD                          i;
    DWORD                          Error;
    struct  /* anonymous */ {
        DWORD                      OptionId;
        LPBYTE                    *DataPtrs;
        DWORD                     *DataLen;
    } OptionArray[] = {
        OPTION_SUBNET_MASK,  (LPBYTE*)&DummyOptions.SubnetMask, NULL,
        OPTION_LEASE_TIME, (LPBYTE*)&DummyOptions.LeaseTime, NULL,
        OPTION_RENEWAL_TIME, (LPBYTE*)&DummyOptions.T1Time, NULL,
        OPTION_REBIND_TIME, (LPBYTE*)&DummyOptions.T2Time, NULL,
        OPTION_ROUTER_ADDRESS, (LPBYTE *)&DummyOptions.GatewayAddresses, &DummyOptions.nGateways,
        OPTION_STATIC_ROUTES, (LPBYTE *)&DummyOptions.ClassedRouteAddresses, &DummyOptions.nClassedRoutes,
        OPTION_CLASSLESS_ROUTES, (LPBYTE *)&DummyOptions.ClasslessRouteAddresses, &DummyOptions.nClasslessRoutes,
        OPTION_DOMAIN_NAME_SERVERS, (LPBYTE *)&DummyOptions.DnsServerList, &DummyOptions.nDnsServers,
        OPTION_DYNDNS_BOTH, (LPBYTE *)&DummyOptions.DnsFlags, NULL,
        OPTION_DOMAIN_NAME, (LPBYTE *)&DummyOptions.DomainName, &DummyOptions.DomainNameSize,
    };

    memset(&DummyOptions, 0, sizeof(DummyOptions));
    for( i = 0; i < sizeof(OptionArray)/sizeof(OptionArray[0]) ; i ++ ) {
        ThisOption = DhcpFindOption(
            &DhcpContext->RecdOptionsList,
            (BYTE)OptionArray[i].OptionId,
            FALSE,
            DhcpContext->ClassId,
            DhcpContext->ClassIdLength,
            0                               //dont care about serverid
        );
        if (ThisOption) {
            *(OptionArray[i].DataPtrs) = DhcpAllocateMemory(ThisOption->DataLen);
            if (*(OptionArray[i].DataPtrs) == NULL) {
                Error = ERROR_OUTOFMEMORY;
                goto Cleanup;
            }
            memcpy (*(OptionArray[i].DataPtrs), ThisOption->Data, ThisOption->DataLen);
            if(OptionArray[i].DataLen)
                *(OptionArray[i].DataLen) = ThisOption->DataLen;
        } else {
            *(OptionArray[i].DataPtrs) = NULL;
            if(OptionArray[i].DataLen)
                *(OptionArray[i].DataLen) = 0;
        }
    }
    DummyOptions.nGateways /= sizeof(DWORD);
    DummyOptions.nClassedRoutes /= 2*sizeof(DWORD);
    DummyOptions.nDnsServers /= sizeof(DWORD);

    // this call is expected to succeed since the option is picked up from RecdOptionsList
    // in order to get there the option was already checked.
    CheckCLRoutes(
            DummyOptions.nClasslessRoutes,
            DummyOptions.ClasslessRouteAddresses,
            &DummyOptions.nClasslessRoutes);

    Error = SetDhcpConfigurationForNIC(
        DhcpContext,
        &DummyOptions,
        DhcpContext->IpAddress,
        DhcpContext->DhcpServerAddress,
        TRUE
    );

Cleanup:
    for( i = 0; i < sizeof(OptionArray)/sizeof(OptionArray[0]) ; i ++ ) {
        if (*(OptionArray[i].DataPtrs) != NULL) {
            DhcpFreeMemory(*(OptionArray[i].DataPtrs));
        }
    }

    return Error;
}

DWORD                                             // status
ReRenewParameters(                                // renew an existing lease
    IN      PDHCP_CONTEXT          DhcpContext,   // adapter context
    OUT     LPDWORD                Sleep          // if nonNULL fill in the amt of time to sleep
) {
    DWORD                          Error, Error2;
    LONG                           timeToSleep;
    DWORD                          PopupTime = 0;
    time_t                         TimeNow;
    DHCP_OPTIONS                   dhcpOptions;
    BOOL                           ObtainedNewAddress = FALSE;
#ifdef CHICAGO
    BOOL fJustBootedOnLapTop = JustBootedOnLapTop(DhcpContext);
#else
    // For NT, all machines are LAPTOPS as far as EASYNET is concerned.
    // But since we do not want to do EASYNET unless the lease expired,
    // we set this to FALSE here.
    BOOL fJustBootedOnLapTop = FALSE;
    // Did we just boot as far as this Adapter is concerned?
    BOOL fJustBooted = JustBooted(DhcpContext);
    BOOL fCancelled  = FALSE;
#endif


    OpenDhcpSocket( DhcpContext );

    if( IS_AUTONET_ENABLED(DhcpContext) ) SERVER_UNREACHED(DhcpContext);
    else SERVER_REACHED(DhcpContext);

    if( time(NULL) > DhcpContext->LeaseExpires ) {
        //
        // if lease is already expired, don't wait till RenewLease
        // returns, instead give up right away
        //
        Error = ERROR_SEM_TIMEOUT;
    } else {
        Error = RenewLease( DhcpContext, &dhcpOptions );
    }

    fCancelled = (Error == ERROR_CANCELLED);

    DhcpContext->RenewalFunction = ReObtainInitialParameters;
    timeToSleep = 6 ;                             // default renewal is reobtain;

    if( Error == ERROR_SUCCESS)  {                // everything went fine
        timeToSleep = CalculateTimeToSleep( DhcpContext );
        DhcpContext->RenewalFunction = ReRenewParameters;
        DhcpPrint((DEBUG_LEASE, "Lease renew succeeded.\n", 0 ));
        goto Cleanup;
    }

    if ( Error == ERROR_ACCESS_DENIED ) {         // lease renewal was NAK'ed
        DhcpPrint((DEBUG_LEASE, "Lease renew is Nak'ed, %ld.\n", Error ));
        DhcpPrint((DEBUG_LEASE, "Fresh renewal is requested.\n" ));

        DhcpLogEvent( DhcpContext, EVENT_NACK_LEASE, Error );
        SetDhcpConfigurationForNIC(               // reset ip address to zero and try immediately
            DhcpContext,
            NULL,
            0,
            (DHCP_IP_ADDRESS)(-1),
            TRUE
        );
        DhcpContext->DesiredIpAddress = 0;

        timeToSleep = 1;
        goto Cleanup;
    }

    if ( Error == ERROR_DHCP_ADDRESS_CONFLICT ) { // addr already in use, reschedule
        DhcpLogEvent(DhcpContext, EVENT_ADDRESS_CONFLICT, 0);
        timeToSleep  = ADDRESS_CONFLICT_RETRY;
        goto Cleanup;
    }

    DhcpLogEvent( DhcpContext, EVENT_FAILED_TO_RENEW, Error );
    DhcpPrint((DEBUG_LEASE, "Lease renew failed, %ld.\n", Error ));
    TimeNow = time( NULL );

    // If the lease has expired or this is the just booted on laptop
    // try autoconfiguration...

    // lease expired => TimeNow is great *or equal* to the lease expiration time
    // the loose comparision is to be used here since in case of equal timestamps
    // renew has already been attempted.
    if( TimeNow >= DhcpContext->LeaseExpires || fJustBootedOnLapTop) {

        DhcpPrint((DEBUG_LEASE, "Lease Expired.\n", Error ));
        DhcpPrint((DEBUG_LEASE, "New Lease requested.\n", Error ));

        DhcpLogEvent( DhcpContext, EVENT_LEASE_TERMINATED, 0 );

        // If the lease has expired.  Reset the IP address to 0, alert the user.
        //
        // Unplumb the stack first and then display the user
        // message. Since, on Vxd the display call does not return
        // until the user dismiss the dialog box, so the stack is
        // plumbed with expired address when the message is
        // displayed, which is incorrect.

        SetDhcpConfigurationForNIC(
            DhcpContext,
            NULL,
            0,
            (DHCP_IP_ADDRESS)(-1),
            TRUE
        );

        if(!DhcpGlobalProtocolFailed ) {
            DhcpGlobalProtocolFailed = TRUE;
            DisplayUserMessage(
                DhcpContext,
                MESSAGE_FAILED_TO_OBTAIN_LEASE,
                0
            );
        }

        timeToSleep = 1;
        goto Cleanup;
    }

    if( !fCancelled && IS_ADDRESS_UNPLUMBED(DhcpContext) ) {     // could not renew a currently valid lease
        Error2 = InitRebootPlumbStack(DhcpContext);
        if ( ERROR_SUCCESS != Error2 ) {           // hit address conflict.
            DhcpLogEvent(DhcpContext, EVENT_ADDRESS_CONFLICT, 0);
            HandleDhcpAddressConflict( DhcpContext, 0 );
            timeToSleep = ADDRESS_CONFLICT_RETRY;
            Error = Error2;
            goto Cleanup;
        }
    }

#ifdef  NEWNT
    // If easynet is enabled; we just booted; and if the flag IPAUTO... is
    // also enabled (meaning, no DHCP messages were received), then we
    // try autoconfiguration.
    if(fJustBooted && IS_SERVER_UNREACHABLE(DhcpContext))
    {
        if (!fCancelled)
        {
            Error2 = CouldPingGateWay(DhcpContext);
            fCancelled = fCancelled || (Error2 == DHCP_GATEWAY_REQUEST_CANCELLED);
        }

        if (!fCancelled && Error2 == DHCP_GATEWAY_UNREACHABLE)
        {
            if (!DhcpGlobalProtocolFailed)
            {
                DhcpGlobalProtocolFailed = TRUE;
                DisplayUserMessage(
                    DhcpContext,
                    MESSAGE_FAILED_TO_OBTAIN_LEASE,
                    0
                );
            }

            Error2 = DhcpPerformIPAutoconfiguration( DhcpContext);
            if( ERROR_SUCCESS != Error2) {
                DhcpLogEvent( DhcpContext, EVENT_IPAUTOCONFIGURATION_FAILED, Error2 );
                Error = Error2;
            } else {
                DhcpLogEvent(DhcpContext, EVENT_IPAUTOCONFIGURATION_SUCCEEDED, 0 );
            }

            // if fallback configuration has been plumbed don't attempt to reach
            // a DHCP server from now on.
            if (IS_FALLBACK_ENABLED(DhcpContext))
                timeToSleep = INFINIT_LEASE;
            else
                timeToSleep = 2;

            goto Cleanup;
        }
    }
#endif  NEWNT

    if (!fCancelled)
    {
        timeToSleep = CalculateTimeToSleep( DhcpContext );
    }
    DhcpContext->RenewalFunction = ReRenewParameters;

  Cleanup:

    // if the media was just reconnected before this renewal attemp,
    // make a note that media is now in connected state. This is required
    // bcoz we special case the first renewal cycle after media reconnect.
    // First renewal cycle after media reconnect is treated as INIT-REBOOT
    // later on, we fall back to normal RENEW state.
    // see DhcpSendMessage routine also.
    if (!fCancelled && IS_MEDIA_RECONNECTED( DhcpContext ) ) {
        MEDIA_CONNECTED( DhcpContext );
    }

    ScheduleWakeUp( DhcpContext, timeToSleep );
    DhcpPrint((DEBUG_LEASE, "Sleeping for %ld seconds.\n", timeToSleep ));

    //
    // we just tried to reach for the dhcp server.. lets mark this time..
    //
    DhcpContext->LastInformSent = time(NULL);

    //
    // Restore the "context looked" bit.
    //
    if (fCancelled && fJustBooted) {
        CTXT_WAS_NOT_LOOKED( DhcpContext );
    }

    if( Sleep ) *Sleep = timeToSleep;
    CloseDhcpSocket( DhcpContext );

    return( Error );
}

BOOL
CheckSwitchedNetwork(
    IN PDHCP_CONTEXT DhcpContext,
    IN ULONG nGateways,
    IN DHCP_IP_ADDRESS UNALIGNED *Gateways
)
/*++

Routine Description:
    This routine checks to see if any of the gateways present in
    the list Gateways has an address the same as that of hte address
    of DhcpContext.

    The IP Addresses in the Gateways structure is presumed to be
    in network order. (Same as for DhcpContext->IpAddress).

Arguments:
    DhcpContext -- context to check for switched network info
    nGateways -- # of gateways given as input in Gateways
    Gateways -- pointer to IP address list in n/w order

Return Value:
    TRUE -- the interface is on a switched network.
    FALSE -- none of the gateways match the ip address of the context.

--*/
{
    if( DhcpIsInitState(DhcpContext) ) return FALSE;
    while(nGateways --) {
        if( *Gateways++ == DhcpContext->IpAddress ) {
            DhcpPrint((DEBUG_PROTOCOL, "Interface is in a switched network\n"));
            return TRUE;
        }
    }
    return FALSE;
}

DHCP_GATEWAY_STATUS
AnyGatewaysReachable(
    IN ULONG nGateways,
    IN DHCP_IP_ADDRESS UNALIGNED *GatewaysList,
    IN WSAEVENT CancelEvent
)
/*++

Routine Description:
    This routine checks to see if any of the IP addresses presented
    in the GatewaysList parameter are reachable via ICMP ping with
    TTL = 1.

Arguments:
    nGateways -- # of gateways present in GatewaysList
    GatewaysList -- the actual list of ip addresses in n/w order

Return Values:
    DHCP_GATEWAY_UNREACHABLE  --  no gateway responded favourably
    DHCP_GATEWAY_REACHABLE  --  atleast one gateway responded favourably to the ping.
    DHCP_GATEWAY_REQUEST_CANCELLED  --  the request was cancelled

--*/
{
    HANDLE Icmp;
    BYTE ReplyBuffer[DHCP_ICMP_RCV_BUF_SIZE];
    PICMP_ECHO_REPLY EchoReplies;
    IP_OPTION_INFORMATION Options = {
        1 /* Ttl */, 0 /* TOS */, 0 /* Flags */, 0, NULL
    };
    ULONG nRetries = 3, nReplies = 0, i, j;
    ULONG Error, IpAddr;
    DHCP_GATEWAY_STATUS Status = DHCP_GATEWAY_UNREACHABLE;

    Status = DHCP_GATEWAY_UNREACHABLE;
    Icmp = IcmpCreateFile();
    if( INVALID_HANDLE_VALUE == Icmp ) {
        //
        // Could not open ICMP handle? problem!
        //
        Error = GetLastError();
        DhcpPrint((DEBUG_ERRORS, "IcmpCreateFile: %ld\n", Error));
        DhcpAssert(FALSE);
        return Status;
    }

    while( nGateways -- ) {
        IpAddr = *GatewaysList++;
        for( i = 0; i < nRetries ; i ++ ) {
            nReplies = IcmpSendEcho(
                Icmp,
                (IPAddr) IpAddr,
                (LPVOID) DHCP_ICMP_SEND_MESSAGE,
                (WORD)strlen(DHCP_ICMP_SEND_MESSAGE),
                &Options,
                ReplyBuffer,
                DHCP_ICMP_RCV_BUF_SIZE,
                DHCP_ICMP_WAIT_TIME
                );

            if (CancelEvent != WSA_INVALID_EVENT) {
                DWORD   error;
                error = WSAWaitForMultipleEvents(
                        1,
                        &CancelEvent,
                        FALSE,
                        0,
                        FALSE
                        );
                if (error == WSA_WAIT_EVENT_0) {
                    DhcpPrint((DEBUG_PING, "IcmpSendEcho: cancelled\n"));
                    Status = DHCP_GATEWAY_REQUEST_CANCELLED;
                    goto cleanup;
                }
            }

            DhcpPrint((DEBUG_PING, "IcmpSendEcho(%s): %ld (Error: %ld)\n",
                       inet_ntoa(*(struct in_addr *)&IpAddr),
                       nReplies, GetLastError()
                ));
            if( nReplies ) {
                EchoReplies = (PICMP_ECHO_REPLY) ReplyBuffer;
                for( j = 0; j < nReplies ; j ++ ) {
                    if( EchoReplies[j].Address == IpAddr
                        && IP_SUCCESS == EchoReplies[j].Status
                        ) {
                        //
                        // Cool.  Hit the gateway.
                        //
                        DhcpPrint((DEBUG_PROTOCOL, "Received response"));
                        Status = DHCP_GATEWAY_REACHABLE;
                        break;
                    } else {
                        DhcpPrint((DEBUG_PROTOCOL, "ICMP Status: %ld\n",
                                   EchoReplies[j].Status ));
                    }
                }
                //
                // Hit the gateway?
                //
                if( DHCP_GATEWAY_REACHABLE == Status ) break;
            }
        }
        if( DHCP_GATEWAY_REACHABLE == Status ) break;
    }

cleanup:
    CloseHandle( Icmp );
    return Status;
}

DHCP_GATEWAY_STATUS
RefreshNotNeeded(
    IN PDHCP_CONTEXT DhcpContext
)
/*++

Routine Description:
    This routine tells if the adapter needs to be refreshed for address
    or not on media sense renewal.

    The algorithm is to return FALSE in all of hte following cases:
    1.  The adapter has no IP address
    2.  The adapter has an autonet address
    3.  The adapter lease has expired(!!!)
          The last case shouldn't happen, coz the system should have woken up.
    4.  No default gateways were configured previously.
    5.  One of the gateways is the local interface itself.
    6.  None of the previous default routers respond to a ping with TTL=1

Return Value:
    TRUE -- Do not need to refresh this interface.
    FALSE -- need to refresh this interface.

--*/
{
    ULONG nGateways;
    DHCP_IP_ADDRESS UNALIGNED *Gateways;

    if( DhcpIsInitState(DhcpContext) ) return FALSE;

    if( time(NULL) > DhcpContext->LeaseExpires ) {
        DhcpAssert(FALSE);
        return DHCP_GATEWAY_UNREACHABLE;
    }

    Gateways = NULL;
    nGateways = 0;

    if( !RetreiveGatewaysList(DhcpContext, &nGateways, &Gateways) ) {
        //
        // No gateways could be retrieved.  Definitely refresh.
        //
        return DHCP_GATEWAY_UNREACHABLE;
    }

    if( CheckSwitchedNetwork(DhcpContext, nGateways, Gateways) ) {
        //
        // Ok we are in a swiched network.  Definite refresh.
        //
        return DHCP_GATEWAY_UNREACHABLE;
    }

    return AnyGatewaysReachable(nGateways, Gateways, DhcpContext->CancelEvent);
}

VOID
GetDomainNameOption(
    IN PDHCP_CONTEXT DhcpContext,
    OUT PBYTE *DomainNameOpt,
    OUT ULONG *DomainNameOptSize
    )
/*++

Routine Description:
    This routine fetches the domain name option either from the
    cache (DhcpContext->DomainName) or by looking at the options
    for the context (as was obtained via the previous dhcp
    protocol attempt).

    The DhcpContext->DomainName variable is expected to be
    written by the ObtainInitialParameters routine to be filled
    with the temporary option chosen.

Arguments:
    DhcpContext -- context to use for picking options out of.
    DomainNameOpt -- on return NULL or valid ptr to dom name opt.
    DomainNameOptSize -- on return 0 or size of above excludign
       NUL termination.

--*/
{
    PDHCP_OPTION Opt;

    //
    // If option already exists in the context, return that.
    //
    if( DhcpContext->DomainName[0] != '\0' ) {
        (*DomainNameOpt) = DhcpContext->DomainName;
        (*DomainNameOptSize) = strlen(DhcpContext->DomainName);
        return;
    }

    //
    // Otherwise, retrieve it from any previous domain name option.
    //
    if( DhcpIsInitState(DhcpContext) ) {
        (*DomainNameOpt) = NULL;
        (*DomainNameOptSize) = 0;
        return;
    }

    //
    // Check if domain name option is present.
    //
    Opt = DhcpFindOption(
        &DhcpContext->RecdOptionsList,
        OPTION_DOMAIN_NAME,
        FALSE,
        DhcpContext->ClassId,
        DhcpContext->ClassIdLength,
        0
        );
    if( NULL == Opt ) {
        (*DomainNameOpt) = NULL;
        (*DomainNameOptSize) = 0;
    } else {
        (*DomainNameOpt) = Opt->Data;
        (*DomainNameOptSize) = Opt->DataLen;
    }
}


//================================================================================
// End of file
//================================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\client\inc\apiimpl.h ===
/*++

Copyright (C) 1995 Microsoft Corporation 

Module:

    apiimpl.h

Abstract:

    routines for API -- renew, release, inform, etc

Environment:

    Win32 user mode, Win98 VxD

--*/
#ifndef DHCP_APIIMPL_H
#define DHCP_APIIMPL_H

#include <dhcpcli.h>
#include <apiargs.h>

#define DHCP_PIPE_NAME                            L"\\\\.\\Pipe\\DhcpClient"

DWORD                                             // win32 status
DhcpApiInit(                                      // Initialize API datastructures
    VOID
);

VOID
DhcpApiCleanup(                                   // Cleanup API data structures
    VOID
);

DWORD                                             // win32 status
AcquireParameters(                                // renew or obtain a lease
    IN OUT  PDHCP_CONTEXT          DhcpContext
);

DWORD                                             // win32 status
AcquireParametersByBroadcast(                     // renew or obtain a lease
    IN OUT  PDHCP_CONTEXT          DhcpContext
);

DWORD                                             // win32 status
FallbackRefreshParams(                            // refresh all the fallback parameters for this adapter
    IN OUT  PDHCP_CONTEXT          DhcpContext
);

DWORD                                             // win32 status
ReleaseParameters(                                // release existing lease
    IN OUT  PDHCP_CONTEXT          DhcpContext
);

DWORD                                             // win32 status
EnableDhcp(                                       // convert a static adapter to use dhcp
    IN OUT  PDHCP_CONTEXT          DhcpContext
);

DWORD                                             // win32 status
DisableDhcp(                                      // convert a dhcp-enabled adapter to static
    IN OUT  PDHCP_CONTEXT          DhcpContext
);

DWORD                                             // win32 status
StaticRefreshParamsEx(                            // refresh all the static parameters for this adapter
    IN OUT  PDHCP_CONTEXT          DhcpContext,
    IN ULONG Flags
);

DWORD                                             // win32 status
StaticRefreshParams(                              // refresh all the static parameters for this adapter
    IN OUT  PDHCP_CONTEXT          DhcpContext
);

DWORD                                             // win32 status
RequestParams(                                    // request some params
    IN      PDHCP_CONTEXT          AdapterName,   // for which adapter?
    IN      PDHCP_API_ARGS         ArgArray,      // other arguments
    IN      DWORD                  nArgs,         // size of above array
    IN OUT  LPBYTE                 Buffer,        // buffer to fill with options
    IN OUT  LPDWORD                BufferSize     // size of above buffer in bytes
) ;

DWORD                                             // win32 status
PersistentRequestParams(                          // keep this request persistent -- request some params
    IN      PDHCP_CONTEXT          AdapterName,   // for which adapter?
    IN      PDHCP_API_ARGS         ArgArray,      // other arguments
    IN      DWORD                  nArgs,         // size of above array
    IN OUT  LPBYTE                 Buffer,        // buffer to fill with options
    IN OUT  LPDWORD                BufferSize     // size of above buffer in bytes
) ;

DWORD                                             // win32 status
RegisterParams(                                   // register some params for notification
    IN      LPWSTR                 AdapterName,   // adapter name to use
    IN      PDHCP_API_ARGS         ArgArray,      // other parameters
    IN      DWORD                  nArgs          // size of above array
);

DWORD                                             // win32 status
DeRegisterParams(                                 // undo the effects of the above
    IN      LPWSTR                 AdapterName,   // which adapter name, NULL ==> all
    IN      PDHCP_API_ARGS         ArgArray,      // other parameters
    IN      DWORD                  nArgs          // size of above array
);

DWORD                                             // error status
ExecuteApiRequest(                                // execute an api request
    IN      LPBYTE                 InBuffer,      // buffer to process
    OUT     LPBYTE                 OutBuffer,     // place to copy the output data
    IN OUT  LPDWORD                OutBufSize     // ip: how big can the outbuf be, o/p: how big it really is
);

DWORD                                             // win32 status
DhcpDoInform(                                     // send an inform packet if necessary
    IN      PDHCP_CONTEXT          DhcpContext,   // input context to do inform on
    IN      BOOL                   fBroadcast     // Do we broadcast this inform, or unicast to server?
);

#endif DHCP_APIIMPL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\client\inc\apistub.h ===
//================================================================================
// Copyright (C) Microsoft Corporation 1997
// Author: RameshV
// Description: this file has functions that marshal and unmarshal the arguments
//  and calls the right functions to get the api executed.
//================================================================================

#ifndef APISTUB_H_INCLUDED
#define APISTUB_H_INCLUDED

typedef enum _API_OPCODES {
    FirstApiOpCode = 0,
    AcquireParametersOpCode = FirstApiOpCode,
    FallbackParamsOpCode,
    ReleaseParametersOpCode,
    EnableDhcpOpCode,
    DisableDhcpOpCode,
    StaticRefreshParamsOpCode,
    RequestParamsOpCode,
    PersistentRequestParamsOpCode,
    RegisterParamsOpCode,
    DeRegisterParamsOpCode,
    RemoveDNSRegistrationsOpCode,
    AcquireParametersByBroadcastOpCode,
    InvalidApiOpCode
} API_OPCODES, *LPAPI_OPCODES;

typedef enum _API_PARAMS {
    ClassIdParam = InvalidApiOpCode,
    VendorOptionParam,
    NormalOptionParam,
    ProcIdParam,
    DescriptorParam,
    EventHandleParam,
    FlagsParam,
    InvalidApiParam
} API_PARAMS, *PAPI_PARAMS, *LPAPI_PARAMS;

//================================================================================
// the api buffer comes to DhcpApiProcessBuffer which then dispatches it to
// the right function after unmarshalling as much of the arguments as possible.
//================================================================================

DWORD                                             // win32 status
DhcpApiProcessBuffer(                             // process a single buffer
    IN      LPBYTE                 InBuffer,      // the input buffer
    IN      DWORD                  InBufSize,     // input buffer size
    IN OUT  LPBYTE                 OutBuffer,     // the processed data gets written to this buffer
    IN OUT  LPDWORD                OutBufSize     // the size of the output buffer
);

#endif APISTUB_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\client\inc\dhcpcli.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    dhcpcli.h

Abstract:

    This file is the central include file for the DHCP client service.

Author:

    Manny Weiser  (mannyw)  20-Oct-1992

Environment:

    User Mode - Win32

Revision History:

    Madan Appiah (madana)  21-Oct-1993

--*/

#ifndef _DHCPCLI_H_
#define _DHCPCLI_H_

//
//  NT public header files
//
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windef.h>
#include <winbase.h>
#include <winsock2.h>
#include <ws2tcpip.h>
#include <mstcpip.h>

//
//  DHCP public header files
//

#include <dhcp.h>
#include <dhcplib.h>
#if !defined(VXD)
#include <dhcpcapi.h>
#endif

//
// C Runtime Lib.
//

#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <string.h>

//
//  Local header files
//

#include <dhcpdef.h>
#include <debug.h>
#include <gmacros.h>

#ifdef VXD
#include <vxdmsg.h>
#else
#include <dhcpmsg.h>
#endif

#include <ipexport.h>
#ifndef VXD
#include <ntddip.h>
#endif

#include <proto.h>


#ifdef VXD
#include <vxdprocs.h>
#endif


//
// debug heap
//
#include <heapx.h>

#ifndef VXD
#ifdef DBG
#ifdef __DHCP_USE_DEBUG_HEAP__

#pragma message ( "*** DHCP Client will use debug heap ***" )

#define DhcpAllocateMemory(x) calloc(1,x)
#define DhcpFreeMemory(x)     free(x)

#endif
#endif
#endif

#ifdef CHICAGO
#define _WINNT_
#include <vmm.h>
#endif  // CHICAGO
//
// Macros for pageable code.
//
#define CTEMakePageable( _Page, _Routine )  \
    alloc_text(_Page,_Routine)

#ifdef CHICAGO
#define ALLOC_PRAGMA
#undef  INIT
#define INIT _ITEXT
#undef  PAGE
#define PAGE _PTEXT
#define PAGEDHCP _PTEXT
#endif // CHICAGO

#if     defined(CHICAGO) && defined(DEBUG)
//
// This is asserts when the pageable code is called at inappropriate time.
// Since in reality all our pageable code is dynamically locked, there is no
// need for this.
//
//#define CTEPagedCode() _Debug_Flags_Service(DFS_TEST_REENTER+DFS_TEST_BLOCK)
#define CTEPagedCode()
#else
#define CTEPagedCode()
#endif

#include <options.h>
#include <optreg.h>
#include <stack.h>

#endif //_DHCPCLI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\client\inc\dhcpglobal.h ===
#pragma once

//
// init.c will #include this file with GLOBAL_DATA_ALLOCATE defined.
// That will cause each of these variables to be allocated.
//

#ifdef  GLOBAL_DATA_ALLOCATE
#define GLOBAL
#else
#define GLOBAL extern
#endif

//
// DHCP Global data.
//

extern BOOL DhcpGlobalServiceRunning;   // initialized global.

GLOBAL LONG DhcpGlobalNdisWanAdaptersCount; // global count of Wan adaptersx
GLOBAL LPSTR DhcpGlobalHostName;
GLOBAL LPWSTR DhcpGlobalHostNameW;
GLOBAL LPSTR DhcpGlobalHostComment;

//
// NIC List.
//

GLOBAL LIST_ENTRY DhcpGlobalNICList;
GLOBAL LIST_ENTRY DhcpGlobalRenewList;

//
// Synchronization variables.
//

GLOBAL CRITICAL_SECTION DhcpGlobalRenewListCritSect;
GLOBAL CRITICAL_SECTION DhcpGlobalSetInterfaceCritSect;
GLOBAL CRITICAL_SECTION DhcpGlobalOptionsListCritSect;
GLOBAL HANDLE DhcpGlobalRecomputeTimerEvent;

// waitable timer
GLOBAL HANDLE DhcpGlobalWaitableTimerHandle;

//
// to display success message.
//

GLOBAL BOOL DhcpGlobalProtocolFailed;

//
// This varible tells if we are going to provide the DynDns api support to external clients
// and if we are going to use the corresponding DnsApi.  The define below gives the default
// value.
//

GLOBAL DWORD UseMHAsyncDns;
#define DEFAULT_USEMHASYNCDNS             1

//
// This flag tells if we need to use inform or request packets
//
GLOBAL DWORD DhcpGlobalUseInformFlag;

#ifdef BOOTPERF
//
// This flag controls if pinging is disabled on the whole or not.
//
GLOBAL DWORD DhcpGlobalQuickBootEnabledFlag;
#endif

//
// This flag tells if pinging the g/w is disabled. (in this case the g/w is always NOT present)
//
GLOBAL DWORD DhcpGlobalDontPingGatewayFlag;

//
// The # of seconds before retrying according to AUTONET... default is EASYNET_ALLOCATION_RETRY
//

GLOBAL DWORD AutonetRetriesSeconds;
#define RAND_RETRY_DELAY_INTERVAL  30             // randomize +/- 30 SECONDS
#define RAND_RETRY_DELAY           ((DWORD)(RAND_RETRY_DELAY_INTERVAL - ((rand()*2*RAND_RETRY_DELAY_INTERVAL)/RAND_MAX)))

//
// Not used on NT.  Just here for memphis.
//

GLOBAL DWORD DhcpGlobalMachineType;

//
// Do we need to do a global refresh?
//

GLOBAL ULONG DhcpGlobalDoRefresh;

//
// (global check) autonet is enabled ?
//
GLOBAL ULONG DhcpGlobalAutonetEnabled;

//
// options related lists
//

GLOBAL LIST_ENTRY DhcpGlobalClassesList;
GLOBAL LIST_ENTRY DhcpGlobalOptionDefList;


//
// dhcpmsg.c.. list for doing parallel recv on..
//

GLOBAL LIST_ENTRY DhcpGlobalRecvFromList;
GLOBAL CRITICAL_SECTION DhcpGlobalRecvFromCritSect;

//
// need to for entering exiting external APIs..
//

GLOBAL CRITICAL_SECTION DhcpGlobalApiCritSect;

//
// the client vendor name ( "MSFT 5.0" or something like that )
//

GLOBAL LPSTR   DhcpGlobalClientClassInfo;

//
// The following global keys are used to avoid re-opening each time
//
GLOBAL DHCPKEY DhcpGlobalParametersKey;
GLOBAL DHCPKEY DhcpGlobalTcpipParametersKey;
GLOBAL DHCPKEY DhcpGlobalClientOptionKey;
GLOBAL DHCPKEY DhcpGlobalServicesKey;

//
// debug variables.
//

#if DBG
GLOBAL DWORD DhcpGlobalDebugFlag;
GLOBAL HANDLE DhcpGlobalDebugFile;
GLOBAL CRITICAL_SECTION DhcpGlobalDebugFileCritSect;
#endif

GLOBAL DWORD DhcpGlobalClientPort, DhcpGlobalServerPort;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\client\inc\debug.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    debug.h

Abstract:

    This file contains debugging macros for the DHCP server.

Author:

    Manny Weiser  (mannyw)  10-Oct-1992

Environment:

    User Mode - Win32

Revision History:

    Madan Appiah (madana)  21-Oct-1993

--*/

#if DBG

//
// Critical debug output flags.
//

#define DEBUG_ERRORS                0x00000001
#define DEBUG_PROTOCOL              0x00000002
#define DEBUG_LEASE                 0x00000004
#define DEBUG_MISC                  0x00000008
#define DEBUG_INIT                  0x00000010
#define DEBUG_TIMESTAMP             0x00000020
#define DEBUG_ASSERT                0x00001000
#define DEBUG_TRACK                 0x00002000
//
// more verbose debug output flags.
//

#define DEBUG_PROTOCOL_DUMP         0x00010000
#define DEBUG_STACK                 0x00020000
#define DEBUG_TCP_INFO              0x00040000
#define DEBUG_DNS                   0x00080000

#define DEBUG_MEDIA                 0x00100000
#define DEBUG_PING                  0x00200000

#define DEBUG_BACKDOOR              0x01000000
#define DEBUG_ALLOC                 0x02000000
#define DEBUG_PERF                  0x04000000
#define DEBUG_TRACE                 0x08000000

#define DEBUG_API                   0x10000000
#define DEBUG_OPTIONS               0x20000000
#define DEBUG_BREAK_POINT           0x40000000
#define DEBUG_TRACE_CALLS           0x80000000

#endif DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\client\inc\mdhcpcli.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    mdhcp.h

Abstract:

    This file contains the header for data blocks of
    client side APIs for the MCAST.

Author:

    Munil Shah (munils)  02-Sept-97

Environment:

    User Mode - Win32

Revision History:


--*/
#ifndef _MDHCPCLI_H_
#define _MDHCPCLI_H_

#include <madcapcl.h>


/***********************************************************************
 *      Structure Definitions
 ***********************************************************************/

// Mdhcp scopelist
typedef struct _MCAST_SCOPE_LIST {
    DWORD   ScopeLen;
    DWORD   ScopeCount;
    MCAST_SCOPE_ENTRY    pScopeBuf[1];
} MCAST_SCOPE_LIST, *PMCAST_SCOPE_LIST;

typedef struct _MCAST_SCOPE_LIST_OPT_V4 {
    DWORD   ScopeId;
    DWORD   LastAddr;
    BYTE    TTL;
    BYTE    NameCount;
} MCAST_SCOPE_LIST_OPT_V4, *PMCAST_SCOPE_LIST_OPT_V4;


typedef struct _MCAST_SCOPE_LIST_OPT_V6 {
    BYTE    ScopeId[16];
    BYTE    LastAddr[16];
    BYTE    TTL;
    BYTE    NameCount;
} MCAST_SCOPE_LIST_OPT_V6, *PMCAST_SCOPE_LIST_OPT_V6;

typedef struct _MCAST_SCOPE_LIST_OPT_LANG {
    BYTE    Flags;
    BYTE    Len;
    BYTE    Tag[1];
} MCAST_SCOPE_LIST_OPT_LANG, *PMCAST_SCOPE_LIST_OPT_LANG;



/***********************************************************************
 *      Macro Definitions
 ***********************************************************************/

// Locking of scope list.
#define LOCK_MSCOPE_LIST()   EnterCriticalSection(&MadcapGlobalScopeListCritSect)
#define UNLOCK_MSCOPE_LIST() LeaveCriticalSection(&MadcapGlobalScopeListCritSect)

/***********************************************************************
 *      Global Data
 ***********************************************************************/
#ifdef MADCAP_DATA_ALLOCATE
#define MADCAP_EXTERN
#else
#define MADCAP_EXTERN extern
#endif

#define MADCAP_QUERY_SCOPE_LIST_RETRIES 2
#define MADCAP_MAX_RETRIES    4
#define MADCAP_QUERY_SCOPE_LIST_TIME 1

MADCAP_EXTERN CRITICAL_SECTION MadcapGlobalScopeListCritSect;       // protects scopelist.
MADCAP_EXTERN PMCAST_SCOPE_LIST   gMadcapScopeList;
MADCAP_EXTERN BOOL gMScopeQueryInProgress;
MADCAP_EXTERN HANDLE gMScopeQueryEvent;
MADCAP_EXTERN DWORD  gMadcapClientApplVersion;

/***********************************************************************
 *      Function Protos.
 ***********************************************************************/

DWORD
CopyMScopeList(
    IN OUT PMCAST_SCOPE_ENTRY       pScopeList,
    IN OUT PDWORD             pScopeLen,
    OUT    PDWORD             pScopeCount
    );

BOOL
ShouldRequeryMScopeList();

DWORD
CreateMadcapContext(
    IN OUT  PDHCP_CONTEXT  *ppContext,
    IN LPMCAST_CLIENT_UID    pRequestID,
    IN DHCP_IP_ADDRESS      IpAddress
    );

DWORD
MadcapDoInform(
    IN PDHCP_CONTEXT  pContext
    );

DWORD
StoreMScopeList(
    IN PDHCP_CONTEXT    pContext,
    IN BOOL             NewList
    );

DWORD
ObtainMScopeList(
    );

DWORD
GenMadcapClientUID(
    OUT    PBYTE    pRequestID,
    IN     PDWORD   pRequestIDLen
);

DWORD
ObtainMadcapAddress(
    IN      PDHCP_CONTEXT DhcpContext,
    IN     PIPNG_ADDRESS         pScopeID,
    IN     PMCAST_LEASE_REQUEST  pRenewRequest,
    IN OUT PMCAST_LEASE_RESPONSE pAddrResponse
    );

DWORD
RenewMadcapAddress(
    IN      PDHCP_CONTEXT DhcpContext,
    IN     PIPNG_ADDRESS         pScopeID,
    IN     PMCAST_LEASE_REQUEST  pRenewRequest,
    IN OUT PMCAST_LEASE_RESPONSE pAddrResponse,
    IN DHCP_IP_ADDRESS SelectedServer
    );

DWORD
ReleaseMadcapAddress(
    PDHCP_CONTEXT DhcpContext
    );


DWORD
MadcapInitGlobalData(VOID);


#endif _MDHCPCLI_H_






=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\client\inc\macro.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    macro.h

Abstract:

    This module contains the macro definitions for the DHCP client.

Author:

    Manny Weiser (mannyw)  21-Oct-1992

Environment:

    User Mode - Win32

Revision History:

--*/

//
// General purpose macros
//

#define MIN(a,b)                    ((a) < (b) ? (a) : (b))

#if DBG
#define STATIC
#else
#define STATIC static
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\client\inc\dhcpdef.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    dhcpdef.h

Abstract:

    This module contains data type definitions for the DHCP client.

Author:

    Madan Appiah (madana) 31-Oct-1993

Environment:

    User Mode - Win32

Revision History:

--*/

#ifndef _DHCPDEF_
#define _DHCPDEF_

//
// the registry key is of different type between NT and Memphis.
//
#ifdef VXD
typedef VMMHKEY   DHCPKEY;
#else  //  NT
typedef HKEY      DHCPKEY;
#endif


//
// The amount of time to wait for a retry if we have no IP address
//

#define ADDRESS_ALLOCATION_RETRY        300 //  5 minutes
#define EASYNET_ALLOCATION_RETRY        300 //  5 minutes

//
// The amount of time to wait for a retry if we have an IP address,
// but the renewal on startup failed.
//

#if !DBG
#define RENEWAL_RETRY                   600 // 10 minutes
#else
#define RENEWAL_RETRY                   60  // 1 minute
#endif

//
// The number of times to send a request before giving up waiting
// for a response.
//

#define DHCP_MAX_RETRIES                4
#define DHCP_ACCEPT_RETRIES             2
#define DHCP_MAX_RENEW_RETRIES          3


//
// amount of time required between consequtive send_informs..
//

#define DHCP_DEFAULT_INFORM_SEPARATION_INTERVAL   60 // one minute

//
// amount of time to wait after an address conflict is detected
//

#define ADDRESS_CONFLICT_RETRY          10 // 10 seconds

//
//
// Expoenential backoff delay.
//

#define DHCP_EXPO_DELAY                  4

//
// The maximum total amount of time to spend trying to obtain an
// initial address.
//
// This delay is computed as below:
//
// DHCP_MAX_RETRIES - n
// DHCP_EXPO_DELAY - m
// WAIT_FOR_RESPONSE_TIME - w
// MAX_STARTUP_DELAY - t
//
// Binary Exponential backup Algorithm.
//
// t > m * (n*(n+1)/2) + n + w*n
//     -------------------   ---
//        random wait      + response wait
//

#define MAX_STARTUP_DELAY \
    DHCP_EXPO_DELAY * \
        (( DHCP_MAX_RETRIES * (DHCP_MAX_RETRIES + 1)) / 2) + \
            DHCP_MAX_RETRIES + DHCP_MAX_RETRIES * WAIT_FOR_RESPONSE_TIME

#define MAX_RENEW_DELAY \
    DHCP_EXPO_DELAY * \
        (( DHCP_MAX_RENEW_RETRIES * (DHCP_MAX_RENEW_RETRIES + 1)) / 2) + \
            DHCP_MAX_RENEW_RETRIES + DHCP_MAX_RENEW_RETRIES * \
                WAIT_FOR_RESPONSE_TIME

//
// The maximum amount of time to wait between renewal retries, if the
// lease period is between T1 and T2.
//

#define MAX_RETRY_TIME                  3600    // 1 hour

//
// Minimum time to sleep between retries.
//

#if DBG
#define MIN_SLEEP_TIME                  1       // 1 sec.
#else
#define MIN_SLEEP_TIME                  5       // 5 sec.
#endif

//
// Minimum lease time.
//

#define DHCP_MINIMUM_LEASE              60*60   // 1 hour.

#define DHCP_DNS_TTL                    0       // let the DNS api decide..


//
// IP Autoconfiguration defaults
//

#define DHCP_IPAUTOCONFIGURATION_DEFAULT_SUBNET  "169.254.0.0"
#define DHCP_IPAUTOCONFIGURATION_DEFAULT_MASK    "255.255.0.0"

// define the reserved range of autonet addresses..

#define DHCP_RESERVED_AUTOCFG_SUBNET             "169.254.255.0"
#define DHCP_RESERVED_AUTOCFG_MASK               "255.255.255.0"

// will dhcp pick any reserved autonet addr? NO!
#define DHCP_RESERVED_AUTOCFG_FLAG                (1)

// self default route (0,0,<self>) will have a metric of (3)
#define DHCP_SELF_DEFAULT_METRIC                  (3)

//
// General purpose macros
//

#define MIN(a,b)                        ((a) < (b) ? (a) : (b))
#define MAX(a,b)                        ((a) > (b) ? (a) : (b))

#if DBG
#define STATIC
#else
#define STATIC static
#endif

#define LOCK_RENEW_LIST()       EnterCriticalSection(&DhcpGlobalRenewListCritSect)
#define UNLOCK_RENEW_LIST()     LeaveCriticalSection(&DhcpGlobalRenewListCritSect)

#define LOCK_INTERFACE()        EnterCriticalSection(&DhcpGlobalSetInterfaceCritSect)
#define UNLOCK_INTERFACE()      LeaveCriticalSection(&DhcpGlobalSetInterfaceCritSect)

#define LOCK_OPTIONS_LIST()     EnterCriticalSection(&DhcpGlobalOptionsListCritSect)
#define UNLOCK_OPTIONS_LIST()   LeaveCriticalSection(&DhcpGlobalOptionsListCritSect)

#define ZERO_TIME                       0x0         // in secs.

//
// length of the time string returned by ctime.
// actually it is 26.
//

#define TIME_STRING_LEN                 32

//
// String size when a long converted to printable string.
// 2^32 = 4294967295 (10 digits) + termination char.
//

#define LONG_STRING_SIZE                12

//
// A renewal function.
//

typedef
DWORD
(*PRENEWAL_FUNCTION) (
    IN PVOID Context,
    LPDWORD Sleep
    );

//
// DHCP Client-Identifier (option 61)
//
typedef struct _DHCP_CLIENT_IDENTIFIER
{
    BYTE  *pbID;
    DWORD  cbID;
    BYTE   bType;
    BOOL   fSpecified;
} DHCP_CLIENT_IDENTIFIER;


//
// state information for IP autoconfiguration
//

typedef struct _DHCP_IPAUTOCONFIGURATION_CONTEXT
{
    DHCP_IP_ADDRESS   Address;
    DHCP_IP_ADDRESS   Subnet;
    DHCP_IP_ADDRESS   Mask;
    DWORD             Seed;
} DHCP_IPAUTOCONFIGURATION_CONTEXT;

//
// A DHCP context block.  One block is maintained per NIC (network
// interface Card).
//

typedef struct _DHCP_CONTEXT {

        // list of adapters.
    LIST_ENTRY NicListEntry;

        // to place in renewal list.
    LIST_ENTRY RenewalListEntry;

        // Ref count
    LONG RefCount;

        // failed to renew because of lack of resources?
    BOOL bFailedRenewal;
    
        // hardware type.
    BYTE HardwareAddressType;
        // HW address, just follows this context structure.
    LPBYTE HardwareAddress;
        // Length of HW address.
    DWORD HardwareAddressLength;

        // Selected IpAddress, NetworkOrder.
    DHCP_IP_ADDRESS IpAddress;
        // Selected subnet mask. NetworkOrder.
    DHCP_IP_ADDRESS SubnetMask;
        // Selected DHCP server address. Network Order.
    DHCP_IP_ADDRESS DhcpServerAddress;
        // Desired IpAddress the client request in next discover.
    DHCP_IP_ADDRESS DesiredIpAddress;
        // The ip address that was used just before losing this..
    DHCP_IP_ADDRESS NackedIpAddress;
        // The ip address that just resulted in address conflict
    DHCP_IP_ADDRESS ConflictAddress;
        // current domain name for this adapter.    
    BYTE DomainName[260];
    
        // IP Autoconfiguration state
    DHCP_IPAUTOCONFIGURATION_CONTEXT IPAutoconfigurationContext;

    DHCP_CLIENT_IDENTIFIER ClientIdentifier;

        // Lease time in seconds.
    DWORD Lease;
        // Time the lease was obtained.
    time_t LeaseObtained;
        // Time the client should start renew its address.
    time_t T1Time;
        // Time the client should start broadcast to renew address.
    time_t T2Time;
        // Time the lease expires. The clinet should stop using the
        // IpAddress.
        // LeaseObtained  < T1Time < T2Time < LeaseExpires
    time_t LeaseExpires;
        // when was the last time an inform was sent?
    time_t LastInformSent;
        // how many seconds between consecutive informs?
    DWORD  InformSeparationInterval;
        // # of gateways and the currently plumbed gateways are stored here
    DWORD  nGateways;
    DHCP_IP_ADDRESS *GatewayAddresses;

        // # of static routes and the actual static routes are stored here
    DWORD  nStaticRoutes;
    DHCP_IP_ADDRESS *StaticRouteAddresses;

        // Time for next renewal state.
    time_t RunTime;

        // seconds passed since boot.
    DWORD SecondsSinceBoot;

        // should we ping the g/w or always assume g/w is NOT present?
    BOOL  DontPingGatewayFlag;

        // can we use DHCP_INFORM packets or should we use DHCP_REQUEST instead?
    BOOL  UseInformFlag;

        // Release on shutdown?
    ULONG ReleaseOnShutdown;

        // turn timers on off?
    BOOL fTimersEnabled;
    
#ifdef BOOTPERF
        // allow saving of quickboot information?
    ULONG fQuickBootEnabled;
#endif BOOTPERF
    
        // what to function at next renewal state.
    PRENEWAL_FUNCTION RenewalFunction;

    	// A semaphore for synchronization to this structure
    HANDLE RenewHandle;

        // the list of options to send and the list of options received
    LIST_ENTRY  SendOptionsList;
    LIST_ENTRY  RecdOptionsList;
        // the list of options defining the fallback configuration
    LIST_ENTRY  FbOptionsList;

        // the opened key to the adapter info storage location
    DHCPKEY AdapterInfoKey;

        // the class this adapter belongs to
    LPBYTE ClassId;
    DWORD  ClassIdLength;

        // Message buffer to send and receive DHCP message.
    union {
        PDHCP_MESSAGE MessageBuffer;
        PMADCAP_MESSAGE MadcapMessageBuffer;
    };

        // state information for this interface. see below for manifests
    struct /* anonymous */ {
        unsigned Plumbed       : 1 ;    // is this interface plumbed
        unsigned ServerReached : 1 ;    // Did we reach the server ever
        unsigned AutonetEnabled: 1 ;    // Autonet enabled?
        unsigned HasBeenLooked : 1 ;    // Has this context been looked at?
        unsigned DhcpEnabled   : 1 ;    // Is this context dhcp enabled?
        unsigned AutoMode      : 1 ;    // Currently in autonet mode?
        unsigned MediaState    : 2 ;    // One of connected, disconnected, reconnected, unbound
        unsigned MDhcp         : 1 ;    // Is this context created for Mdhcp?
        unsigned PowerResumed  : 1 ;    // Was power just resumed on this interface?
        unsigned Fallback      : 1 ;    // Is fallback configuration available?
        unsigned ApiContext    : 1 ;    // Is this context created by an API call?
        unsigned UniDirectional: 1 ;    // Is this context created for a unidirectional adapter?
    }   State;

    //
    // The following 2 fields are for the cancellation mechanism.
    //
    DWORD    NumberOfWaitingThreads;
    WSAEVENT CancelEvent;

	    // machine specific information
    PVOID LocalInformation;
} DHCP_CONTEXT, *PDHCP_CONTEXT;

#define ADDRESS_PLUMBED(Ctxt)        ((Ctxt)->State.Plumbed = 1)
#define ADDRESS_UNPLUMBED(Ctxt)      ((Ctxt)->State.Plumbed = 0)
#define IS_ADDRESS_PLUMBED(Ctxt)     ((Ctxt)->State.Plumbed)
#define IS_ADDRESS_UNPLUMBED(Ctxt)   (!(Ctxt)->State.Plumbed)

#define SERVER_REACHED(Ctxt)         ((Ctxt)->State.ServerReached = 1)
#define SERVER_UNREACHED(Ctxt)       ((Ctxt)->State.ServerReached = 0)
#define IS_SERVER_REACHABLE(Ctxt)    ((Ctxt)->State.ServerReached)
#define IS_SERVER_UNREACHABLE(Ctxt)  (!(Ctxt)->State.ServerReached)

#define AUTONET_ENABLED(Ctxt)        ((Ctxt)->State.AutonetEnabled = 1)
#define AUTONET_DISABLED(Ctxt)       ((Ctxt)->State.AutonetEnabled = 0)
#define IS_AUTONET_ENABLED(Ctxt)     ((Ctxt)->State.AutonetEnabled)
#define IS_AUTONET_DISABLED(Ctxt)    (!(Ctxt)->State.AutonetEnabled)

#define CTXT_WAS_LOOKED(Ctxt)        ((Ctxt)->State.HasBeenLooked = 1)
#define CTXT_WAS_NOT_LOOKED(Ctxt)    ((Ctxt)->State.HasBeenLooked = 0)
#define WAS_CTXT_LOOKED(Ctxt)        ((Ctxt)->State.HasBeenLooked)
#define WAS_CTXT_NOT_LOOKED(Ctxt)    (!(Ctxt)->State.HasBeenLooked)

#define DHCP_ENABLED(Ctxt)           ((Ctxt)->State.DhcpEnabled = 1)
#define DHCP_DISABLED(Ctxt)          ((Ctxt)->State.DhcpEnabled = 0)
#define IS_DHCP_ENABLED(Ctxt)        ((Ctxt)->State.DhcpEnabled )
#define IS_DHCP_DISABLED(Ctxt)       (!(Ctxt)->State.DhcpEnabled )

#define FALLBACK_ENABLED(Ctxt)       ((Ctxt)->State.Fallback = 1)
#define FALLBACK_DISABLED(Ctxt)      ((Ctxt)->State.Fallback = 0)
#define IS_FALLBACK_ENABLED(Ctxt)    ((Ctxt)->State.Fallback)
#define IS_FALLBACK_DISABLED(Ctxt)   (!(Ctxt)->State.Fallback)

#define APICTXT_ENABLED(Ctxt)        ((Ctxt)->State.ApiContext = 1)
#define APICTXT_DISABLED(Ctxt)       ((Ctxt)->State.ApiContext = 0)
#define IS_APICTXT_ENABLED(Ctxt)     ((Ctxt)->State.ApiContext)
#define IS_APICTXT_DISABLED(Ctxt)    (!(Ctxt)->State.ApiContext)

#define IS_UNIDIRECTIONAL(Ctxt)      ((Ctxt)->State.UniDirectional)

//
// DNS resolver uses these without defines. So, don't change them.
//
#define ADDRESS_TYPE_AUTO            1
#define ADDRESS_TYPE_DHCP            0

#define ACQUIRED_DHCP_ADDRESS(Ctxt)  ((Ctxt)->State.AutoMode = 0 )
#define ACQUIRED_AUTO_ADDRESS(Ctxt)  ((Ctxt)->State.AutoMode = 1 )
#define IS_ADDRESS_DHCP(Ctxt)        (!(Ctxt)->State.AutoMode)
#define IS_ADDRESS_AUTO(Ctxt)        ((Ctxt)->State.AutoMode)

#define MEDIA_CONNECTED(Ctxt)        ((Ctxt)->State.MediaState = 0)
#define MEDIA_RECONNECTED(Ctxt)      ((Ctxt)->State.MediaState = 1)
#define MEDIA_DISCONNECTED(Ctxt)     ((Ctxt)->State.MediaState = 2)
#define MEDIA_UNBOUND(Ctxt)          ((Ctxt)->State.MediaState = 3)
#define IS_MEDIA_CONNECTED(Ctxt)     ((Ctxt)->State.MediaState == 0)
#define IS_MEDIA_RECONNECTED(Ctxt)   ((Ctxt)->State.MediaState == 1)
#define IS_MEDIA_DISCONNECTED(Ctxt)  ((Ctxt)->State.MediaState == 2)
#define IS_MEDIA_UNBOUND(Ctxt)       ((Ctxt)->State.MediaState == 3)

#define _INIT_STATE1(Ctxt)           do{(Ctxt)->State.Plumbed = 0; (Ctxt)->State.AutonetEnabled=0;}while(0)
#define _INIT_STATE2(Ctxt)           do{(Ctxt)->State.HasBeenLooked = 0; (Ctxt)->State.DhcpEnabled=1;}while(0)
#define _INIT_STATE3(Ctxt)           do{(Ctxt)->State.AutoMode = 0; (Ctxt)->State.MediaState = 0;}while(0)
#define INIT_STATE(Ctxt)             do{_INIT_STATE1(Ctxt);_INIT_STATE2(Ctxt);_INIT_STATE3(Ctxt);}while(0)

#define MDHCP_CTX(Ctxt)           ((Ctxt)->State.MDhcp = 1)
#define NONMDHCP_CTX(Ctxt)          ((Ctxt)->State.MDhcp = 0)
#define IS_MDHCP_CTX(Ctxt)        ((Ctxt)->State.MDhcp )
#define SET_MDHCP_STATE( Ctxt ) { \
    ADDRESS_PLUMBED( Ctxt ), MDHCP_CTX( Ctxt ); \
}

#define POWER_RESUMED(Ctxt)           ((Ctxt)->State.PowerResumed = 1)
#define POWER_NOT_RESUMED(Ctxt)       ((Ctxt)->State.PowerResumed = 0)
#define IS_POWER_RESUMED(Ctxt)        ((Ctxt)->State.PowerResumed )


LPSTR _inline                        //  the string'ed version of state (same as Buffer)
ConvertStateToString(                //  convert from bits to string
    IN PDHCP_CONTEXT   Ctxt,         //  The context to print state for
    IN LPBYTE          Buffer        //  The input buffer to write state into
) {
    strcpy(Buffer, IS_DHCP_ENABLED(Ctxt)?"DhcpEnabled ":"DhcpDisabled ");
    strcat(Buffer, IS_AUTONET_ENABLED(Ctxt)?"AutonetEnabled ":"AutonetDisabled ");
    strcat(Buffer, IS_ADDRESS_DHCP(Ctxt)?"DhcpMode ":"AutoMode ");
    strcat(Buffer, IS_ADDRESS_PLUMBED(Ctxt)?"Plumbed ":"UnPlumbed ");
    strcat(Buffer, IS_SERVER_REACHABLE(Ctxt)?"(server-present) ":"(server-absent) ");
    strcat(Buffer, WAS_CTXT_LOOKED(Ctxt)? "(seen) ":"(not-seen) ");

    if(IS_MEDIA_CONNECTED(Ctxt) ) strcat(Buffer, "MediaConnected\n");
    else if(IS_MEDIA_RECONNECTED(Ctxt)) strcat(Buffer, "MediaReConnected\n");
    else if(IS_MEDIA_DISCONNECTED(Ctxt)) strcat(Buffer, "MediaDisConnected\n");
    else strcat(Buffer, "MediaUnknownState\n");

    strcat(Buffer, IS_MDHCP_CTX(Ctxt)? "(MDhcp) ":"");
    strcat(Buffer, IS_POWER_RESUMED(Ctxt)? "Pwr Resumed ":"");

    return Buffer;
}

//
// Release on shutdown values..
//
#define RELEASE_ON_SHUTDOWN_OBEY_DHCP_SERVER 2
#define RELEASE_ON_SHUTDOWN_ALWAYS           1
#define RELEASE_ON_SHUTDOWN_NEVER            0

//
// The types of machines.. laptop would have aggressive EASYNET behaviour.
//

#define MACHINE_NONE   0
#define MACHINE_LAPTOP 1

//
//  Here is the set of expected options by the client -- If they are absent, not much can be done
//

typedef struct _DHCP_EXPECTED_OPTIONS {
    BYTE            UNALIGNED*     MessageType;
    DHCP_IP_ADDRESS UNALIGNED*     SubnetMask;
    DHCP_IP_ADDRESS UNALIGNED*     LeaseTime;
    DHCP_IP_ADDRESS UNALIGNED*     ServerIdentifier;
    BYTE            UNALIGNED*     AutoconfOption;
    BYTE            UNALIGNED*     DomainName;
    DWORD                          DomainNameSize;
} DHCP_EXPECTED_OPTIONS, *PDHCP_EXPECTED_OPTIONS, *LPDHCP_EXPECTED_OPTIONS;

//
//  Here is the set of options understood by the client
//
typedef struct _DHCP_FULL_OPTIONS {
    BYTE            UNALIGNED*     MessageType;   // What kind of message is this?

    // Basic IP Parameters

    DHCP_IP_ADDRESS UNALIGNED*     SubnetMask;
    DHCP_IP_ADDRESS UNALIGNED*     LeaseTime;
    DHCP_IP_ADDRESS UNALIGNED*     T1Time;
    DHCP_IP_ADDRESS UNALIGNED*     T2Time;
    DHCP_IP_ADDRESS UNALIGNED*     GatewayAddresses;
    DWORD                          nGateways;
    DHCP_IP_ADDRESS UNALIGNED*     ClassedRouteAddresses;
    DWORD                          nClassedRoutes;

    BYTE            UNALIGNED*     ClasslessRouteAddresses;
    DWORD                          nClasslessRoutes;

    DHCP_IP_ADDRESS UNALIGNED*     ServerIdentifier;

    // DNS parameters

    BYTE            UNALIGNED*     DnsFlags;
    BYTE            UNALIGNED*     DnsRcode1;
    BYTE            UNALIGNED*     DnsRcode2;
    BYTE            UNALIGNED*     DomainName;
    DWORD                          DomainNameSize;
    DHCP_IP_ADDRESS UNALIGNED*     DnsServerList;
    DWORD                          nDnsServers;

    // Server message is something that the server may inform us of

    BYTE            UNALIGNED*     ServerMessage;
    DWORD                          ServerMessageLength;

} DHCP_FULL_OPTIONS, *PDHCP_FULL_OPTIONS, *LPDHCP_FULL_OPTIONS;

typedef DHCP_FULL_OPTIONS DHCP_OPTIONS, *PDHCP_OPTIONS;

typedef struct _MADCAP_OPTIONS {
    DWORD               UNALIGNED*     LeaseTime;
    DWORD               UNALIGNED*     Time;
    DWORD               UNALIGNED*     RetryTime;
    DHCP_IP_ADDRESS     UNALIGNED*     ServerIdentifier;
    BYTE                         *     ClientGuid;
    WORD                               ClientGuidLength;
    BYTE                         *     MScopeList;
    WORD                               MScopeListLength;
    DWORD               UNALIGNED*     MCastLeaseStartTime;
    BYTE                         *     AddrRangeList;
    WORD                               AddrRangeListSize;
    DWORD               UNALIGNED*     McastScope;
    DWORD               UNALIGNED*     Error;
} MADCAP_OPTIONS, *PMADCAP_OPTIONS, *LPMADCAP_OPTIONS;

//
// structure for a list of messages
//

typedef struct _MSG_LIST {
    LIST_ENTRY     MessageListEntry;
    DWORD          ServerIdentifier;
    DWORD          MessageSize;
    DWORD          LeaseExpirationTime;
    DHCP_MESSAGE   Message;
} MSGLIST, *PMSGLIST, *LPMSGLIST;

//
// structure for IP/Subnet pair
//
typedef struct {
    DHCP_IP_ADDRESS IpAddress;
    DHCP_IP_ADDRESS SubnetMask;
} IP_SUBNET, *PIP_SUBNET;

#endif // _DHCPDEF_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\client\inc\optchg.h ===
//================================================================================
// Copyright (c) 1997 Microsoft Corporation
// Author: RameshV
// Description: handles the noticiations and other mechanisms for parameter
//      changes (options )
//================================================================================

#ifndef OPTCHG_H_INCLUDED
#define OPTCHG_H_INCLUDED

//================================================================================
// exported APIS
//================================================================================
DWORD                                             // win32 status
DhcpAddParamChangeRequest(                        // add a new param change notification request
    IN      LPWSTR                 AdapterName,   // for this adapter, can be NULL
    IN      LPBYTE                 ClassId,       // what class id does this belong to?
    IN      DWORD                  ClassIdLength, // how big is this class id?
    IN      LPBYTE                 OptList,       // this is the list of options of interest
    IN      DWORD                  OptListSize,   // this is the # of bytes of above
    IN      BOOL                   IsVendor,      // is this vendor specific?
    IN      DWORD                  ProcId,        // which is the calling process?
    IN      DWORD                  Descriptor,    // what is the unique descriptor in this process?
    IN      HANDLE                 Handle         // what is the handle in the calling process space?
);

DWORD                                             // win32 status
DhcpDelParamChangeRequest(                        // delete a particular request
    IN      DWORD                  ProcId,        // the process id of the caller
    IN      HANDLE                 Handle         // the handle as used by the calling process
);

DWORD                                             // win32 status
DhcpMarkParamChangeRequests(                      // find all params that are affected and mark then as pending
    IN      LPWSTR                 AdapterName,   // adapter of relevance
    IN      DWORD                  OptionId,      // the option id itself
    IN      BOOL                   IsVendor,      // is this vendor specific
    IN      LPBYTE                 ClassId        // which class --> this must be something that has been ADD-CLASSED
);

typedef DWORD (*DHCP_NOTIFY_FUNC)(                // this is the type of the fucntion that actually notifies clients of option change
    IN      DWORD                  ProcId,        // <ProcId + Descriptor> make a unique key used for finding the event
    IN      DWORD                  Descriptor     // --- on Win98, only Descriptor is really needed.
);                                                // if return value is NOT error success, we delete this request

DWORD                                             // win32 status
DhcpNotifyMarkedParamChangeRequests(              // notify pending param change requests
    IN      DHCP_NOTIFY_FUNC       NotifyHandler  // call this function for each unique id that is present
);


DWORD                                             // win32 status
DhcpNotifyClientOnParamChange(                    // notify clients
    IN      DWORD                  ProcId,        // which process called this
    IN      DWORD                  Descriptor     // unique descriptor for that process
);

DWORD                                             // win32 status
DhcpInitializeParamChangeRequests(                // initialize everything in this file
    VOID
);

VOID
DhcpCleanupParamChangeRequests(                   // unwind this module
    VOID
);

DWORD                                             // win32 status
DhcpAddParamRequestChangeRequestList(             // add to the request list the list of params registered for notifications
    IN      LPWSTR                 AdapterName,   // which adatper is this request list being requested for?
    IN      LPBYTE                 Buffer,        // buffer to add options to
    IN OUT  LPDWORD                Size,          // in: existing filled up size, out: total size filled up
    IN      LPBYTE                 ClassName,     // ClassId
    IN      DWORD                  ClassLen       // size of ClassId in bytes
);

#endif OPTCHG_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\client\inc\proto.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    proto.h

Abstract:

    This module contains the function prototypes for the DHCP client.

Author:

    Manny Weiser (mannyw)  21-Oct-1992

Environment:

    User Mode - Win32

Revision History:

    Madan Appiah (madana)  21-Oct-1993

--*/

#ifndef _PROTO_
#define _PROTO_

//
//  OS independant functions
//

DWORD
DhcpInitialize(
    LPDWORD SleepTime
    );

DWORD
ObtainInitialParameters(
    PDHCP_CONTEXT DhcpContext,
    PDHCP_OPTIONS DhcpOptions,
    BOOL *fAutoConfigure
    );

DWORD
RenewLease(
    PDHCP_CONTEXT DhcpContext,
    PDHCP_OPTIONS DhcpOptions
    );

DWORD
CalculateTimeToSleep(
    PDHCP_CONTEXT DhcpContext
    );

DWORD
ReObtainInitialParameters(
    PDHCP_CONTEXT DhcpContext,
    LPDWORD Sleep
    );

BOOL
DhcpIsInitState(
    DHCP_CONTEXT    *pContext
    );


DWORD
ReRenewParameters(
    PDHCP_CONTEXT DhcpContext,
    LPDWORD Sleep
    );

DWORD
ReleaseIpAddress(
    PDHCP_CONTEXT DhcpContext
    );

DWORD                                             // status
SendInformAndGetReplies(                          // send an inform packet and collect replies
    IN      PDHCP_CONTEXT          DhcpContext,   // the context to send out of
    IN      DWORD                  nInformsToSend,// how many informs to send?
    IN      DWORD                  MaxAcksToWait  // how many acks to wait for
);

DWORD
InitializeDhcpSocket(
    SOCKET *Socket,
    DHCP_IP_ADDRESS IpAddress,
    BOOL  IsApiCall                     // is it related to an API generated context?
    );

DWORD
HandleIPAutoconfigurationAddressConflict(
    DHCP_CONTEXT *pContext
    );

DHCP_IP_ADDRESS                         //  Ip address o/p after hashing
GrandHashing(
    IN      LPBYTE       HwAddress,     //  Hardware addres of the card
    IN      DWORD        HwLen,         //  Hardware length
    IN OUT  LPDWORD      Seed,          //  In: orig value, Out: final value
    IN      DHCP_IP_ADDRESS  Mask,      //  Subnet mask to generate ip addr in
    IN      DHCP_IP_ADDRESS  Subnet     //  Subnet address to generate ip addr in
);

DWORD
DhcpPerformIPAutoconfiguration(
    DHCP_CONTEXT    *pContext
    );

ULONG
DhcpDynDnsGetDynDNSOption(
    IN OUT BYTE *OptBuf,
    IN OUT ULONG *OptBufSize,
    IN HKEY hAdapterKey,
    IN LPCWSTR AdapterName,
    IN BOOL fEnabled,
    IN LPCSTR DhcpDomainOption,
    IN ULONG DhcpDomainOptionSize
    );

ULONG
DhcpDynDnsDeregisterAdapter(
    IN HKEY hAdapterKey,
    IN LPCWSTR AdapterName,
    IN BOOL fRAS,
    IN BOOL fDynDnsEnabled
    );


ULONG
DhcpDynDnsRegisterDhcpOrRasAdapter(
    IN HKEY hAdapterKey,
    IN LPCWSTR AdapterName,
    IN BOOL fDynDnsEnabled,
    IN BOOL fRAS,
    IN ULONG IpAddress,
    IN LPBYTE DomOpt OPTIONAL,
    IN ULONG DomOptSize,
    IN LPBYTE DnsListOpt OPTIONAL,
    IN ULONG DnsListOptSize,
    IN LPBYTE DnsFQDNOpt,
    IN ULONG DnsFQDNOptSize
    );


ULONG *
DhcpCreateListFromStringAndFree(
    IN LPWSTR Str,
    IN LPWSTR Separation,
    OUT LPDWORD nAddresses
    );


ULONG
DhcpDynDnsRegisterStaticAdapter(
    IN HKEY hAdapterKey,
    IN LPCWSTR AdapterName,
    IN BOOL fRAS,
    IN BOOL fDynDnsEnabled
    );


DWORD
NotifyDnsCache(
    VOID
    );


DWORD
CalculateExpDelay(
    DWORD dwDelay,
    DWORD dwFuzz
    );



//
//  OS specific functions
//

DWORD
SystemInitialize(
    VOID
    );

VOID
ScheduleWakeUp(
    PDHCP_CONTEXT DhcpContext,
    DWORD TimeToSleep
    );

DWORD
SetDhcpConfigurationForNIC(
    PDHCP_CONTEXT DhcpContext,
    PDHCP_OPTIONS DhcpOptions,
    DHCP_IP_ADDRESS IpAddress,
    DHCP_IP_ADDRESS ServerIpAddress,
    BOOL ObtainedNewAddress
    );


DWORD
SetAutoConfigurationForNIC(
    PDHCP_CONTEXT DhcpContext,
    DHCP_IP_ADDRESS Address,
    DHCP_IP_ADDRESS Mask
    );

DWORD
SendDhcpMessage(
    PDHCP_CONTEXT DhcpContext,
    DWORD MessageLength,
    LPDWORD TransactionId
    );

DWORD
SendDhcpDecline(
    PDHCP_CONTEXT DhcpContext,
    DWORD         dwTransactionId,
    DWORD         dwServerIPAddress,
    DWORD         dwDeclinedIPAddress
    );


DWORD
GetSpecifiedDhcpMessage(
    PDHCP_CONTEXT DhcpContext,
    PDWORD BufferLength,
    DWORD TransactionId,
    DWORD TimeToWait
    );

DWORD
OpenDhcpSocket(
    PDHCP_CONTEXT DhcpContext
    );

DWORD
CloseDhcpSocket(
    PDHCP_CONTEXT DhcpContext
    );

DWORD
InitializeInterface(
    PDHCP_CONTEXT DhcpContext
    );

DWORD
UninitializeInterface(
    PDHCP_CONTEXT DhcpContext
    );

VOID
DhcpLogEvent(
    PDHCP_CONTEXT DhcpContext,
    DWORD EventNumber,
    DWORD ErrorCode
    );

BOOL
NdisWanAdapter(
    PDHCP_CONTEXT DhcpContext
);

POPTION
AppendOptionParamsRequestList(
#if   defined(__DHCP_CLIENT_OPTIONS_API_ENABLED__)
    PDHCP_CONTEXT DhcpContext,
#endif
    POPTION       Option,
    LPBYTE        OptionEnd
    );

DWORD
InitEnvSpecificDhcpOptions(
    PDHCP_CONTEXT DhcpContext
    );

DWORD
ExtractEnvSpecificDhcpOption(
    PDHCP_CONTEXT DhcpContext,
    DHCP_OPTION_ID OptionId,
    LPBYTE OptionData,
    DWORD OptionDataLength
    );

DWORD
SetEnvSpecificDhcpOptions(
    PDHCP_CONTEXT DhcpContext
    );

DWORD
DisplayUserMessage(
    PDHCP_CONTEXT DhcpContext,
    DWORD MessageId,
    DHCP_IP_ADDRESS IpAddress
    );

DWORD
UpdateStatus(
    VOID
    );

#ifdef VXD
VOID                                  // declspec(import) hoses vxd so work
DhcpSleep( DWORD dwMilliseconds ) ;   // around it
#else
#define DhcpSleep   Sleep
#endif

DWORD
IPSetInterface(
    DWORD IpInterfaceContext
    );

DWORD
IPResetInterface(
    DWORD IpInterfaceContext
    );

DWORD SetIPAddressAndArp(
    PVOID pvLocalInformation,
    DWORD dwAddress,
    DWORD dwSubnetMask
    );

DWORD BringUpInterface(
    PVOID pvLocalInformation
    );


DWORD
OpenDriver(
    HANDLE *Handle,
    LPWSTR DriverName
    );


DWORD
DhcpRegReadMachineType(void);

#ifdef NEWNT
DWORD
DhcpRegPingingEnabled(PDHCP_CONTEXT);

LPSTR
DhcpGetDomainName(
    LPWSTR AdapterName,
    LPSTR Buf, DWORD Size);

#endif

#ifdef VXD
VOID
CleanupDhcpOptions(
    PDHCP_CONTEXT DhcpContext
    );
#endif

DWORD
DhcpRegOkToUseInform(
    LPWSTR   AdapterName
);

DWORD
DhcpRegAutonetRetries(
    IN  PDHCP_CONTEXT DhcpContext
);

// Media sense related common functions
DWORD
ProcessMediaConnectEvent(
    PDHCP_CONTEXT dhcpContext,
    IP_STATUS mediaStatus
    );

DWORD                                             // win32 status
DhcpDestroyContext(                               // destroy this context and free relevant stuff
    IN      PDHCP_CONTEXT          DhcpContext    // the context to destroy and free
);

//
// dhcp/vxd common function with different implementations
//

LPWSTR                                            // Adapter name string
DhcpAdapterName(                                  // get the adapter name string stored in the context
    IN      PDHCP_CONTEXT          DhcpContext
);

//
// registry
//

DWORD                                             // win32
DhcpRegRecurseDelete(                             // delete the key, recursing downwards
    IN      HKEY                   Key,           // root at this key and
    IN      LPWSTR                 KeyName        // delete the key given by this keyname (and all its children)
);

BOOL                                              // obtained a static address?
DhcpRegDomainName(                                // get the static domain name if any
    IN      PDHCP_CONTEXT          DhcpContext,   // adapter to get static domain for..
    IN OUT  LPBYTE                 DomainNameBuf, // buffer to fill with static domain name
    IN      ULONG                  BufSize        // size of above buffer in bytes..
);

// protocol.c

DWORD                                             // status
SendDhcpDiscover(                                 // send a discover packet
    IN      PDHCP_CONTEXT          DhcpContext,   // on this context
    IN OUT  DWORD                 *pdwXid         // use this Xid (if zero, fill something and return it)
);

DWORD                                             // Time in seconds
DhcpCalculateWaitTime(                            // how much time to wait
    IN      DWORD                  RoundNum,      // which round is this
    OUT     DWORD                 *WaitMilliSecs  // if needed the # in milli seconds
);

VOID
DhcpExtractFullOrLiteOptions(                     // Extract some important options alone or ALL
    IN      PDHCP_CONTEXT          DhcpContext,   // input context
    IN      LPBYTE                 OptStart,      // start of the options stuff
    IN      DWORD                  MessageSize,   // # of bytes of options
    IN      BOOL                   LiteOnly,      // next struc is EXPECTED_OPTIONS and not FULL_OPTIONS
    OUT     LPVOID                 DhcpOptions,   // this is where the options would be stored
    IN OUT  PLIST_ENTRY            RecdOptions,   // if !LiteOnly this gets filled with all incoming options
    IN OUT  time_t                 *LeaseExpiry,   // if !LiteOnly input expiry time, else output expiry time
    IN      LPBYTE                 ClassName,     // if !LiteOnly this is used to add to the option above
    IN      DWORD                  ClassLen,      // if !LiteOnly this gives the # of bytes of classname
    IN      DWORD                  ServerId       // if !LiteOnly this specifies the server which gave this
);

DWORD                                             // status
SendDhcpRequest(                                  // send a dhcp request packet
    IN      PDHCP_CONTEXT          DhcpContext,   // the context to send the packet on
    IN      PDWORD                 pdwXid,        // what is hte Xid to use?
    IN      DWORD                  RequestedAddr, // what address do we want?
    IN      DWORD                  SelectedServer,// is there a prefernce for a server?
    IN      BOOL                   UseCiAddr      // should CIADDR be set with desired address?
);

DWORD
SendDhcpRelease(
    PDHCP_CONTEXT DhcpContext
);

typedef enum {
    DHCP_GATEWAY_UNREACHABLE = 0,
    DHCP_GATEWAY_REACHABLE,
    DHCP_GATEWAY_REQUEST_CANCELLED
} DHCP_GATEWAY_STATUS;

DHCP_GATEWAY_STATUS
RefreshNotNeeded(
    IN PDHCP_CONTEXT DhcpContext
);

//
// ioctl.c
//

DWORD
IPDelNonPrimaryAddresses(
    LPWSTR AdapterName
    );

DWORD
GetIpInterfaceContext(
    LPWSTR AdapterName,
    DWORD IpIndex,
    LPDWORD IpInterfaceContext
    );

//
// dhcp.c
//
DWORD
LockDhcpContext(
    PDHCP_CONTEXT   DhcpContext,
    BOOL            bCancelOngoingRequest
    );

BOOL
UnlockDhcpContext(
    PDHCP_CONTEXT   DhcpContext
    );
#endif // _PROTO_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\client\inc\vxddebug.h ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1994                **/
/**********************************************************************/

/*
    debug.h

    This file contains a number of debug-dependent definitions.


    FILE HISTORY:
        KeithMo     20-Sep-1993 Created.

*/


#ifndef _DEBUG_H_
#define _DEBUG_H_


#ifdef DEBUG

#include <stdarg.h>

//
//  Debug output control flags.
//

extern  DWORD   VxdDebugFlags;


#define VXD_DEBUG_INIT                 0x00000001L
#define VXD_DEBUG_SOCKET               0x00000002L
#define VXD_DEBUG_MISC                 0x00000004L
#define VXD_DEBUG_BIND                 0x00000008L
#define VXD_DEBUG_ACCEPT               0x00000010L
#define VXD_DEBUG_CONNECT              0x00000020L
#define VXD_DEBUG_LISTEN               0x00000040L
#define VXD_DEBUG_RECV                 0x00000080L
#define VXD_DEBUG_SEND                 0x00000100L
#define VXD_DEBUG_SOCKOPT              0x00000200L
#define VXD_DEBUG_CONFIG               0x00000400L
#define VXD_DEBUG_CONNECT_EVENT        0x00000800L
#define VXD_DEBUG_DISCONNECT_EVENT     0x00001000L
#define VXD_DEBUG_ERROR_EVENT          0x00002000L
#define VXD_DEBUG_RECV_EVENT           0x00004000L
#define VXD_DEBUG_RECV_DATAGRAM_EVENT  0x00008000L
#define VXD_DEBUG_RECV_EXPEDITED_EVENT 0x00010000L
// #define VXD_DEBUG_                     0x00020000L
// #define VXD_DEBUG_                     0x00040000L
// #define VXD_DEBUG_                     0x00080000L
// #define VXD_DEBUG_                     0x00100000L
// #define VXD_DEBUG_                     0x00200000L
// #define VXD_DEBUG_                     0x00400000L
// #define VXD_DEBUG_                     0x00800000L
// #define VXD_DEBUG_                     0x01000000L
// #define VXD_DEBUG_                     0x02000000L
// #define VXD_DEBUG_                     0x04000000L
// #define VXD_DEBUG_                     0x08000000L
// #define VXD_DEBUG_                     0x10000000L
// #define VXD_DEBUG_                     0x20000000L
// #define VXD_DEBUG_                     0x40000000L
#define VXD_DEBUG_OUTPUT_TO_DEBUGGER   0x80000000L

#if 0
#define IF_DEBUG(flag) if ( (VxdDebugFlags & VXD_DEBUG_ ## flag) != 0 )
#endif



#define VXD_PRINT(args) VxdPrintf args


//
//  Assert & require.
//

void VxdAssert( void          * pAssertion,
                void          * pFileName,
                unsigned long   nLineNumber );

#define VXD_ASSERT(exp) if (!(exp)) VxdAssert( #exp, __FILE__, __LINE__ )
#define VXD_REQUIRE VXD_ASSERT


//
//  Miscellaneous goodies.
//

void VxdDebugOutput( char * pszMessage );

#define DEBUG_BREAK     _asm int 3
#define DEBUG_OUTPUT(x) VxdDebugOutput(x)


#else   // !DEBUG


//
//  No debug output.
//

#undef IF_DEBUG
#define IF_DEBUG(flag) if (0)


//
//  Null debug output function.
//

#define VXD_PRINT(args)


//
//  Null assert & require.
//

#define VXD_ASSERT(exp)
#define VXD_REQUIRE(exp) ((void)(exp))


//
//  No goodies.
//

#define DEBUG_BREAK
#define DEBUG_OUTPUT(x)


#endif  // DEBUG


#endif  // _DEBUG_H_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\client\inc\optreg.h ===
//--------------------------------------------------------------------------------
// Copyright (C) Micorosoft Confidential 1997
// Author: RameshV
// Description: Option related registry handling -- common between NT and VxD
//--------------------------------------------------------------------------------
#ifndef  OPTREG_H
#define  OPTREG_H
//--------------------------------------------------------------------------------
// Exported functions: Caller must take locks and any lists accessed
//--------------------------------------------------------------------------------

DWORD                                             // status
DhcpRegReadOptionDefList(                         // fill DhcpGlobalOptionDefList
    VOID
);

DWORD                                             // status
DhcpRegFillSendOptions(                           // fill in the list of options for SENDING
    IN OUT  PLIST_ENTRY            SendOptList,   // list to add too
    IN      LPWSTR                 AdapterName,   // adapter name to fill for
    IN      LPBYTE                 ClassId,       // class id to assume for filling
    IN      DWORD                  ClassIdLen     // the length of the classId in bytes
);

DWORD                                             // status
DhcpRegSaveOptions(                               // save these options onto the registry
    IN      PLIST_ENTRY            SaveOptList,   // list of options to save
    IN      LPWSTR                 AdapterName,   // adapter name
    IN      LPBYTE                 ClassName,     // the current class
    IN      DWORD                  ClassLen       // length of the above in bytes
);

BOOLEAN                                           // status
DhcpRegIsOptionChanged(
    IN      PLIST_ENTRY            SaveOptList,   // list of options to save
    IN      LPWSTR                 AdapterName,   // adapter name
    IN      LPBYTE                 ClassName,     // the current class
    IN      DWORD                  ClassLen       // length of the above in bytes
);

DWORD                                             // status
DhcpRegReadOptionCache(                           // read the list of options from cache
    IN OUT  PLIST_ENTRY            OptionsList,   // add the options to this list
    IN      HKEY                   KeyHandle,     // registry key where options are stored
    IN      LPWSTR                 ValueName,     // name of the value holding the options blob
    IN      BOOLEAN                fAddClassList
);

POPTION                                           // option from which more appends can occur
DhcpAppendSendOptions(                            // append all configured options
    IN OUT  PDHCP_CONTEXT          DhcpContext,   // this is the context to append for
    IN      PLIST_ENTRY            SendOptionsList,
    IN      LPBYTE                 ClassName,     // current class
    IN      DWORD                  ClassLen,      // len of above in bytes
    IN      LPBYTE                 BufStart,      // start of buffer
    IN      LPBYTE                 BufEnd,        // how far can we go in this buffer
    IN OUT  LPBYTE                 SentOptions,   // BoolArray[OPTION_END+1] to avoid repeating options
    IN OUT  LPBYTE                 VSentOptions,  // to avoid repeating vendor specific options
    IN OUT  LPBYTE                 VendorOpt,     // Buffer[OPTION_END+1] Holding Vendor specific options
    OUT     LPDWORD                VendorOptLen   // the # of bytes filled into that
);

DWORD                                             // status
DhcpAddIncomingOption(                            // this option just arrived, add it to list
    IN      LPWSTR                 AdapterName,
    IN OUT  PLIST_ENTRY            RecdOptionsList,
    IN      DWORD                  OptionId,      // option id of the option
    IN      BOOL                   IsVendor,      // is it vendor specific?
    IN      LPBYTE                 ClassName,     // what is the class name?
    IN      DWORD                  ClassLen,      // what is the class name's lenght in bytes?
    IN      DWORD                  ServerId,      // server ip from which this option came
    IN      LPBYTE                 Data,          // this is the real data value coming in
    IN      DWORD                  DataLen,       // the length of above in # of bytes
    IN      time_t                 ExpiryTime,    // when does this option expire?
    IN      BOOL                   IsApiCall      // is this coming from an API call?
);

DWORD                                             // status
DhcpCopyFallbackOptions(                          // copies the Fallback options list to RecdOptionsList
    IN OUT  PDHCP_CONTEXT          DhcpContext,   // NIC context
    OUT     LPDHCP_IP_ADDRESS      Address,       // Fallback address as taken from option 50
    OUT     LPDHCP_IP_ADDRESS      SubnetMask     // SubnetMask as taken from option 1
);

DWORD                                             // status
MadcapAddIncomingOption(                          // this option just arrived, add it to list
    IN OUT  PLIST_ENTRY            RecdOptionsList,
    IN      DWORD                  OptionId,      // option id of the option
    IN      DWORD                  ServerId,      // server ip from which this option came
    IN      LPBYTE                 Data,          // this is the real data value coming in
    IN      DWORD                  DataLen,       // the length of above in # of bytes
    IN      DWORD                  ExpiryTime     // when does this option expire?
);

DWORD                                             // status
DhcpDestroyOptionsList(                           // destroy a list of options, freeing up memory
    IN OUT  PLIST_ENTRY            OptionsList,   // this is the list of options to destroy
    IN      PLIST_ENTRY            ClassesList    // this is where to remove classes off
);

DWORD                                             // win32 status
DhcpClearAllOptions(                              // remove all turds from off registry
    IN OUT  PDHCP_CONTEXT          DhcpContext    // the context to clear for
);

DWORD                                             // status
DhcpRegSaveOptionAtLocation(                      // save this option at this particular location
    IN      PDHCP_OPTION           OptionInfo,    // optin to save
    IN      LPWSTR                 RegLocation,   // location to save at
    IN      DWORD                  RegValueType,  // type of the value to save at
    IN      BOOL                   SpecialCase    // dirty downward compatabiltiy?
);

DWORD                                             // status
DhcpRegSaveOptionAtLocationEx(                    // save the option in the required place in registry
    IN      PDHCP_OPTION           OptionInfo,    // save THIS option
    IN      LPWSTR                 AdapterName,   // for this adpater,
    IN      LPWSTR                 RegLocMZ,      // multiple locations in the registry
    IN      DWORD                  SaveValueType  // What is the type of the value?
);


DWORD
DhcpRegDeleteIpAddressAndOtherValues(             // delete IPAddress, SubnetMask values from off key
    IN      HKEY                   Key            // handle to adapter regkey..
);

DWORD                                             // status
DhcpRegClearOptDefs(                              // clear all standard options
    IN      LPWSTR                 AdapterName    // clear for this adapter
);

#endif OPTREG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\client\inc\options.h ===
//================================================================================
//  Copyright (C) Microsoft Corporation 1997.
//  Author: RameshV
//  Date: 09-Sep-97 06:20
//  Description: Manages the class-id and options information
//================================================================================

#ifndef OPTIONS_H
#define OPTIONS_H

#define MAX_DATA_LEN               255            // atmost 255 bytes for an option

typedef struct _DHCP_CLASSES {                    // common pool of class names
    LIST_ENTRY                     ClassList;     // global list of classes
    LPBYTE                         ClassName;     // name of the class
    DWORD                          ClassLen;      // # of bytes in class name
    DWORD                          RefCount;      // # of references to this
} DHCP_CLASSES, *LPDHCP_CLASSES, *PDHCP_CLASSES;

typedef struct _DHCP_OPTION  {                    // list of options
    LIST_ENTRY                     OptionList;    // the fwd/back ptrs
    DWORD                          OptionId;      // the option value
    BOOL                           IsVendor;      // is this vendor specific
    LPBYTE                         ClassName;     // the class of this option
    DWORD                          ClassLen;      // the length of above option
    time_t                         ExpiryTime;    // when this option expires
    LPBYTE                         Data;          // the data value for this option
    DWORD                          DataLen;       // the # of bytes of above
    DWORD                          ServerId;      // the server from which the option came
    OPTION_VERSION                 OptionVer;     // specifies the format of the options
} DHCP_OPTION , *LPDHCP_OPTION , *PDHCP_OPTION ;

typedef struct _DHCP_OPTION_DEF {
    LIST_ENTRY                     OptionDefList; // list of option definitions
    DWORD                          OptionId;      // the option id
    BOOL                           IsVendor;      // is this vendor specific?
    LPBYTE                         ClassName;     // the class this belongs to
    DWORD                          ClassLen;      // the size of above in bytes

    LPWSTR                         RegSendLoc;    // where is the info about sending this out
    LPWSTR                         RegSaveLoc;    // where is this option going to be stored?
    DWORD                          RegValueType;  // as what value should this be stored?
} DHCP_OPTION_DEF, *LPDHCP_OPTION_DEF, *PDHCP_OPTION_DEF;


//================================================================================
//  exported functions classes
//================================================================================

//--------------------------------------------------------------------------------
// In all of the following functions, ClassesList is unprotected within the fn.
// Caller has to take a lock on it.
//--------------------------------------------------------------------------------
LPBYTE                                            // data bytes, or NULL (no mem)
DhcpAddClass(                                     // add a new class
    IN OUT  PLIST_ENTRY            ClassesList,   // list to add to
    IN      LPBYTE                 Data,          // input class name
    IN      DWORD                  Len            // # of bytes of above
);  // Add the new class into the list or bump up ref count if already there

DWORD                                             // status (FILE_NOT_FOUND => no such class)
DhcpDelClass(                                     // de-refernce a class
    IN OUT  PLIST_ENTRY            ClassesList,   // the list to delete off
    IN      LPBYTE                 Data,          // the data ptr
    IN      DWORD                  Len            // the # of bytes of above
);  // decrease refcount in the list and if becomes zero, free the struct

VOID                                              // always succeeds
DhcpFreeAllClasses(                               // free each elt of the list
    IN OUT  PLIST_ENTRY            ClassesList    // input list of classes
);  // free every class in the list

//--------------------------------------------------------------------------------
// In all the following functions, OptionsList is unprotected within the fn.
// Caller has to take a lock on it.
//--------------------------------------------------------------------------------

PDHCP_OPTION                                      // the reqd structure or NULL
DhcpFindOption(                                   // find a specific option
    IN OUT  PLIST_ENTRY            OptionsList,   // the list of options to search
    IN      DWORD                  OptionId,      // the option id to search for
    IN      BOOL                   IsVendor,      // is it vendor specific?
    IN      LPBYTE                 ClassName,     // is there a class associated?
    IN      DWORD                  ClassLen,      // # of bytes of above parameter
    IN      DWORD                  ServerId       // match serverid also if not 0
);  // search for the required option in the list, return NULL if not found

DWORD                                             // status or ERROR_FILE_NOT_FOUND
DhcpDelOption(                                    // remove a particular option
    IN      PDHCP_OPTION           Option2Delete  // delete this option
);  // delete an existing option in the list, and free up space used

DWORD                                             // status
DhcpAddOption(                                    // add a new option
    IN OUT  PLIST_ENTRY            OptionsList,   // list to add to
    IN      DWORD                  OptionId,      // option id to add
    IN      BOOL                   IsVendor,      // is it vendor specific?
    IN      LPBYTE                 ClassName,     // what is the class?
    IN      DWORD                  ClassLen,      // size of above in bytes
    IN      DWORD                  ServerId,      // server which gave this option
    IN      LPBYTE                 Data,          // data for this option
    IN      DWORD                  DataLen,       // # of bytes of above
    IN      time_t                 ExpiryTime     // when the option expires
);  // replace or add new option to the list.  fail if not enough memory

PDHCP_OPTION                                      // pointer to the duplicated option
DhcpDuplicateOption(                              // creates a copy of the source option
     IN PDHCP_OPTION SrcOption                    // source option
);

VOID                                              // always succeeds
DhcpFreeAllOptions(                               // frees all the options
    IN OUT  PLIST_ENTRY            OptionsList    // input list of options
);  // free every option in the list

time_t                                            // 0 || time for next expiry (absolute)
DhcpGetExpiredOptions(                            // delete all expired options
    IN OUT  PLIST_ENTRY            OptionsList,   // list to search frm
    OUT     PLIST_ENTRY            ExpiredOptions // o/p list of expired options
);  // move expired options between lists and return timer. 0 => switch off timer.

//--------------------------------------------------------------------------------
//  In all the following functions, OptionsDefList is unprotected.  Caller has
//  to take a lock on it.
//--------------------------------------------------------------------------------

DWORD                                             // status
DhcpAddOptionDef(                                 // add a new option definition
    IN OUT  PLIST_ENTRY            OptionDefList, // input list of options to add to
    IN      DWORD                  OptionId,      // option to add
    IN      BOOL                   IsVendor,      // is it vendor specific
    IN      LPBYTE                 ClassName,     // name of class it belongs to
    IN      DWORD                  ClassLen,      // the size of above in bytes
    IN      LPWSTR                 RegSendLoc,    // where to get info about sending this out
    IN      LPWSTR                 RegSaveLoc,    // where to get info about saving this
    IN      DWORD                  ValueType      // what is the type when saving it?
);

PDHCP_OPTION_DEF                                  // NULL, or requested option def
DhcpFindOptionDef(                                // search for a particular option
    IN      PLIST_ENTRY            OptionDefList, // list to search in
    IN      DWORD                  OptionId,      // the option id to search for
    IN      BOOL                   IsVendor,      // is it vendor specific
    IN      LPBYTE                 ClassName,     // the class, if one exists
    IN      DWORD                  ClassLen       // # of bytes of class name
);

DWORD                                             // status
DhcpDelOptionDef(                                 // delete a particular option def
    IN      PLIST_ENTRY            OptionDefList, // list to delete from
    IN      DWORD                  OptionId,      // the option id to delete
    IN      BOOL                   IsVendor,      // is it vendor specific
    IN      LPBYTE                 ClassName,     // the class, if one exists
    IN      DWORD                  ClassLen       // # of bytes of class name
);

VOID
DhcpFreeAllOptionDefs(                            // free each element of a list
    IN OUT  PLIST_ENTRY            OptionDefList, // the list to free
    IN OUT  PLIST_ENTRY            ClassesList    // classes to de-ref off
);

BOOL                                              // TRUE==>found..
DhcpOptionsFindDomain(                            // find the domain name option values
    IN OUT  PDHCP_CONTEXT          DhcpContext,   // for this adapter
    OUT     LPBYTE                *Data,          // fill this ptr up
    OUT     LPDWORD                DataLen
);

BOOL
DhcpFindDwordOption(
    IN PDHCP_CONTEXT DhcpContext,
    IN ULONG OptId,
    IN BOOL fVendor,
    OUT PDWORD Result
);

BOOL
DhcpFindByteOption(
    IN PDHCP_CONTEXT DhcpContext,
    IN ULONG OptId,
    IN BOOL fVendor,
    OUT PBYTE Result
);

BOOL
RetreiveGatewaysList(
    IN PDHCP_CONTEXT DhcpContext,
    IN OUT ULONG *nGateways,
    IN OUT DHCP_IP_ADDRESS UNALIGNED **Gateways
);

#endif  OPTIONS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\client\inc\vxdmsg.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1994  Microsoft Corporation

Module Name:

    dhcpmsg.h

Abstract:

    Definitions for DHCP messages.

Author:

    Manny Weiser 8-Dec-1992

Revision History:

Notes:

    This file is generated by the MC tool from the dhcpmsg.mc file.

--*/

#ifndef _DHCPMESSAGE_
#define _DHCPMESSAGE_

//
//  1000 - 1099   Reserved for DHCP client events.
//
//
//  Values are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-+-----------------------+-------------------------------+
//  |Sev|C|R|     Facility          |               Code            |
//  +---+-+-+-----------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      R - is a reserved bit
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//
//
// Define the facility codes
//


//
// Define the severity codes
//


//
// MessageId: EVENT_FAILED_TO_INITIALIZE
//
// MessageText:
//
//  Failed to initialize the card with network address %1.
//
#define EVENT_FAILED_TO_INITIALIZE       1000L

//
// MessageId: EVENT_LEASE_TERMINATED
//
// MessageText:
//
//  DHCP is unable to renew a lease for the card with network address %1.
//  The lease for IP address %2 has been terminated.
//
#define EVENT_LEASE_TERMINATED           1001L

//
// MessageId: EVENT_UNKNOWN_DHCP_OPTION
//
// MessageText:
//
//  DHCP received an unknown option %1 of length %2. The raw option data is
//  given below.
//
#define EVENT_UNKNOWN_DHCP_OPTION        1002L

//
// MessageId: EVENT_FAILED_TO_OBTAIN_LEASE
//
// MessageText:
//
//  DHCP failed to obtain a lease for the card with network address %1.
//  The following error occurred : %n%2
//
#define EVENT_FAILED_TO_OBTAIN_LEASE     1003L

//
// MessageId: EVENT_NACK_LEASE
//
// MessageText:
//
//  DHCP IP address lease %1 for the card with network address %2 has been
//  denied.
//
#define EVENT_NACK_LEASE                 1004L

//
// MessageId: EVENT_FAILED_TO_RENEW
//
// MessageText:
//
//  DHCP failed to renew a lease for the card with network address %1. The
//  following error occurred : %n%2
//
#define EVENT_FAILED_TO_RENEW            1005L

//
// MessageId: EVENT_DHCP_SHUTDOWN
//
// MessageText:
//
//  DHCP service is shutting down. The following error occurred : %n%1
//
#define EVENT_DHCP_SHUTDOWN              1006L

//
// MessageId: EVENT_FAILED_TO_OBTAIN_LEASE_MULTI_HOME
//
// MessageText:
//
//  DHCP failed to obtain a lease for the card with network address %1.
//  On multi-homed machine all subsequent adapters will also fail to obtain
//  lease. The following error occurred : %n%2
//
#define EVENT_FAILED_TO_OBTAIN_LEASE_MULTI_HOME 1007L

//
// MessageId: EVENT_ADDRESS_CONFLICT
//
// MessageText:
//
//  The IP address %1 for the card with network address %2 is already in use
//  on the network.  The DHCP client will attempt to obtain a new address.
//
#define EVENT_ADDRESS_CONFLICT           1008L

//
// MessageId: EVENT_IPAUTOCONFIGURATION_FAILED
//
// MessageText:
//
//  Windows NT was unable to automatically configure the IP parameters for the network interface identified by the physical address %1.  The following error occurred during configuration: %2.
//
#define EVENT_IPAUTOCONFIGURATION_FAILED 1009L

//
// MessageId: EVENT_IPAUTOCONFIGURATION_SUCCEEDED
//
// MessageText:
//
//  Windows NT was unable to reach a DHCP server, has automatically configured the IP parameters identified by
//  the physical address %1.  The IP address being used is %2.
//
#define EVENT_IPAUTOCONFIGURATION_SUCCEEDED 1010L

//
// 1100 - 1199   Reserved for User messages
//
//
// MessageId: MESSAGE_FAILED_TO_INITIALIZE
//
// MessageText:
//
//  The DHCP client could not obtain an IP address.
//  
//  If you want to see DHCP messages in the future, choose YES. If you do not want to see DHCP messages choose NO.
//
#define MESSAGE_FAILED_TO_INITIALIZE     1100L

//
// MessageId: MESSAGE_LEASE_TERMINATED
//
// MessageText:
//
//  The DHCP client lost the lease of the IP Address %1. The network is brought down.
//  
//  If you want to see DHCP messages in the future, choose YES. Otherwise choose NO.
//
#define MESSAGE_LEASE_TERMINATED         1101L

//
// MessageId: MESSAGE_FAILED_TO_OBTAIN_LEASE
//
// MessageText:
//
//  The DHCP client could not obtain an IP address.
//  
//  If you want to see DHCP messages in the future, choose YES. Otherwise choose NO.
//
#define MESSAGE_FAILED_TO_OBTAIN_LEASE   1102L

//
// MessageId: MESSAGE_FAILED_TO_RENEW_LEASE
//
// MessageText:
//
//  The DHCP client could not renew the lease of the IP Address %1. Your lease is valid until %2. DHCP will try to renew the lease before it expires.
//  
//  If you want to see DHCP messages in the future, choose YES. Otherwise choose NO.
//
#define MESSAGE_FAILED_TO_RENEW_LEASE    1103L

//
// MessageId: MESSAGE_SUCCESSFUL_LEASE
//
// MessageText:
//
//  The DHCP client successfully leased the IP address %1. Your lease is valid until %2.
//  
//  If you want to see DHCP messages in the future, choose YES. Otherwise choose NO.
//
#define MESSAGE_SUCCESSFUL_LEASE         1104L

//
// MessageId: MESSAGE_SUCCESSFUL_RENEW
//
// MessageText:
//
//  The DHCP client successfully renewed the IP address %1. Your lease is valid until %2.
//  
//  If you want to see DHCP messages in the future, choose YES. Otherwise choose NO.
//
#define MESSAGE_SUCCESSFUL_RENEW         1105L

//
// MessageId: MESSAGE_POPUP_TITLE
//
// MessageText:
//
//  DHCP Client%0
//
#define MESSAGE_POPUP_TITLE              1106L

//
// MessageId: MESSAGE_ADDRESS_CONFLICT
//
// MessageText:
//
//  The DHCP client obtained an IP address that is already in use on the network.  The local
//  interface will be disabled until the DHCP client can obtain a valid address.
//  
//  If you want to see DHCP messages in the future, choose YES. Otherwise choose NO.
//
#define MESSAGE_ADDRESS_CONFLICT         1107L

//
// MessageId: MESSAGE_IPAUTOCONFIGURATION_FAILED
//
// MessageText:
//
//  Windows NT was unable to automatically configure the IP parameters for one or more network interfaces.
//  
//  If you want to see DHCP messages in the future, choose YES. Otherwise choose NO.
//
#define MESSAGE_IPAUTOCONFIGURATION_FAILED 1108L

//
// MessageId: MESSAGE_IPAUTOCONFIGURATION_SUCCEEDED
//
// MessageText:
//
//  Windows NT was unable to reach a DHCP server, and has automatically configured the IP address %1.
//  DHCP would automatically try to reach a DHCP server in the background.
//  
//  If you want to see DHCP messages in the future, choose YES. Otherwise choose NO.
//
#define MESSAGE_IPAUTOCONFIGURATION_SUCCEEDED 1109L

#endif // _DHCPMESSAGE_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\client\inc\stack.h ===
//================================================================================
// Copyright (C) 1997 Microsoft Corporation
// Author: RameshV
// All dealings with the stack and other non-Dhcp components go through the API
// given here
//================================================================================

#ifndef STACK_H_INCLUDED
#define STACK_H_INCLUDED
#include <iphlpapi.h>

//================================================================================
// Exported API's
//================================================================================

DWORD                                             // win32 status
DhcpClearAllStackParameters(                      // undo the effects
    IN      PDHCP_CONTEXT          DhcpContext    // the adapter to undo
);

DWORD                                             // win32 status
DhcpSetAllStackParameters(                        // set all stack details
    IN      PDHCP_CONTEXT          DhcpContext,   // the context to set stuff
    IN      PDHCP_FULL_OPTIONS     DhcpOptions    // pick up the configuration from off here
);

DWORD
GetIpPrimaryAddresses(
    IN  PMIB_IPADDRTABLE    *IpAddrTable
    );

DWORD
DhcpSetGateways(
    IN      PDHCP_CONTEXT          DhcpContext,
    IN      PDHCP_FULL_OPTIONS     DhcpOptions,
    IN      BOOLEAN                fForceUpdate
    );

// The classless route layout is:
// - 1 byte encoding the route subnet mask
// - depending on the mask, 0 to 4 bytes encoding the route destination address
// - 4 bytes for the gateway address for the route
// The route destination is encoded based on the value of mask:
// mask = 0 => destination = 0.0.0.0 (no bytes to encode it)
// mask = 1..8 => destination = b1.0.0.0 (1 byte to encode it)
// mask = 9..16 => destination = b1.b2.0.0 (2 bytes for encoding)
// mask = 17..24 => destination = b1.b2.b3.0 (3 bytes for encoding)
// mask = 25..32 => destination = b1.b2.b3.b4 (4 bytes for encoding)
#define CLASSLESS_ROUTE_LEN(x)  (1+((x)?((((x)-1)>>3)+1):0)+4)

DWORD
GetCLRoute(
    IN      LPBYTE                 RouteData,
    OUT     LPBYTE                 RouteDest,
    OUT     LPBYTE                 RouteMask,
    OUT     LPBYTE                 RouteGateway
    );

DWORD
CheckCLRoutes(
    IN      DWORD                  RoutesDataLen,
    IN      LPBYTE                 RoutesData,
    OUT     LPDWORD                pNRoutes
    );


DWORD
DhcpSetStaticRoutes(
    IN     PDHCP_CONTEXT           DhcpContext,
    IN     PDHCP_FULL_OPTIONS      DhcpOptions
);

DWORD
DhcpRegisterWithDns(
    IN     PDHCP_CONTEXT           DhcpContext,
    IN     BOOL                    fDeRegister
    );

#endif STACK_H_INCLUDED

#ifndef SYSSTACK_H_INCLUDED
#define SYSSTACK_H_INCLUDED
//================================================================================
// imported api's
//================================================================================
DWORD                                             // return interface index or -1
DhcpIpGetIfIndex(                                 // get the IF index for this adapter
    IN      PDHCP_CONTEXT          DhcpContext    // context of adapter to get IfIndex for
);

DWORD                                             // win32 status
DhcpSetRoute(                                     // set a route with the stack
    IN      DWORD                  Dest,          // network order destination
    IN      DWORD                  DestMask,      // network order destination mask
    IN      DWORD                  IfIndex,       // interface index to route
    IN      DWORD                  NextHop,       // next hop n/w order address
    IN      DWORD                  Metric,        // metric
    IN      BOOL                   IsLocal,       // is this a local address? (IRE_DIRECT)
    IN      BOOL                   IsDelete       // is this route being deleted?
);

ULONG
TcpIpNotifyRouterDiscoveryOption(
    IN LPCWSTR AdapterName,
    IN BOOL fOptionPresent,
    IN DWORD OptionValue
    );

#endif SYSSTACK_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\client\inc\vxdmsg.inc ===
ifndef _DHCPMESSAGE_
_DHCPMESSAGE_	EQU	1
EVENT_FAILED_TO_INITIALIZE	EQU	1000
EVENT_LEASE_TERMINATED	EQU	1001
EVENT_UNKNOWN_DHCP_OPTION	EQU	1002
EVENT_FAILED_TO_OBTAIN_LEASE	EQU	1003
EVENT_NACK_LEASE	EQU	1004
EVENT_FAILED_TO_RENEW	EQU	1005
EVENT_DHCP_SHUTDOWN	EQU	1006
EVENT_FAILED_TO_OBTAIN_LEASE_MULTI_HOME	EQU	1007
EVENT_ADDRESS_CONFLICT	EQU	1008
EVENT_IPAUTOCONFIGURATION_FAILED	EQU	1009
MESSAGE_FAILED_TO_INITIALIZE	EQU	1100
MESSAGE_LEASE_TERMINATED	EQU	1101
MESSAGE_FAILED_TO_OBTAIN_LEASE	EQU	1102
MESSAGE_FAILED_TO_RENEW_LEASE	EQU	1103
MESSAGE_SUCCESSFUL_LEASE	EQU	1104
MESSAGE_SUCCESSFUL_RENEW	EQU	1105
MESSAGE_POPUP_TITLE	EQU	1106
MESSAGE_ADDRESS_CONFLICT	EQU	1107
MESSAGE_IPAUTOCONFIGURATION_FAILED	EQU	1108
MESSAGE_IPAUTOCONFIGURATION_SUCCEEDED EQU 1109
ERROR_CONFLICT	EQU	1200
endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\client\inc\vxdprocs.h ===
/**********************************************************************/
/**           Microsoft Windows/NT               **/
/**                Copyright(c) Microsoft Corp., 1994                **/
/**********************************************************************/

/*
    vxdprocs.h

    This file contains VxD specific types/manifests for the DHCP driver


    FILE HISTORY:
        Johnl   29-Mar-1993     Created

*/

#ifndef _VXDPROCS_H_
#define _VXDPROCS_H_

#ifdef DEBUG
#define DBG 1
#endif

#define _NETTYPES_      // Keep tcp\h\nettypes.h from being included

#include <dhcpcli.h>
#include <oscfg.h>
#include <cxport.h>
#include <tdi.h>

//--------------------------------------------------------------------
//
//  Define some ndis stuff here because tdivxd.h needs it however we can't
//  include ndis3\inc\ndis.h because it conflicts with ntconfig.h and we
//  can't take out ntconfig.h because it has definitions needed by other
//  header files...grrrr....
//

#ifdef CHICAGO
#ifndef NDIS_STDCALL
#define NDIS_STDCALL    1
#endif
#endif

#ifdef NDIS_STDCALL
#define NDIS_API __stdcall
#else
#define NDIS_API
#endif

//
// Ndis Buffer
//

#define BUFFER_POOL_SIGN  (UINT)0X4C50424E  /* NBPL */
#define BUFFER_SIGN       (UINT)0x4655424e  /* NBUF */

typedef INT NDIS_SPIN_LOCK, * PNDIS_SPIN_LOCK;

struct _NDIS_BUFFER;
typedef struct _NDIS_BUFFER_POOL {
    UINT Signature;                     //character signature for debug "NBPL"
    NDIS_SPIN_LOCK SpinLock;            //to serialize access to the buffer pool
    struct _NDIS_BUFFER *FreeList;      //linked list of free slots in pool
    UINT BufferLength;                  //amount needed for each buffer descriptor
    UCHAR Buffer[1];                    //actual pool memory
    } NDIS_BUFFER_POOL, * PNDIS_BUFFER_POOL;

#ifdef NDIS_STDCALL
typedef struct _NDIS_BUFFER {
    struct _NDIS_BUFFER *Next;          //pointer to next buffer descriptor in chain
    PVOID VirtualAddress;               //linear address of this buffer
    PNDIS_BUFFER_POOL Pool;             //pointer to pool so we can free to correct pool
    UINT Length;                        //length of this buffer
    UINT Signature;                     //character signature for debug "NBUF"
} NDIS_BUFFER, * PNDIS_BUFFER;

#else

typedef struct _NDIS_BUFFER {
    UINT Signature;                     //character signature for debug "NBUF"
    struct _NDIS_BUFFER *Next;          //pointer to next buffer descriptor in chain
    PVOID VirtualAddress;               //linear address of this buffer
    PNDIS_BUFFER_POOL Pool;             //pointer to pool so we can free to correct pool
    UINT Length;                        //length of this buffer
} NDIS_BUFFER, * PNDIS_BUFFER;
#endif

#define NDIS_STATUS_SUCCESS         1   // Used by CTEinitBlockStruc macro

#include <tdivxd.h>
#include <tdistat.h>

//--------------------------------------------------------------------

//
//  Initializes an NDIS buffer (doesn't allocate memory)
//
//      pndisBuff - Pointer to NDIS buffer to initialize
//      pvData    - Pointer to buffer data
//      cbLen     - Length of user data (in bytes)
//      pndisBuffnext - Next NDIS buffer in chain (or NULL if last)
//
#define InitNDISBuff( pndisBuff, pvData, cbLen, pndisBuffNext )       \
{                                                                     \
    (pndisBuff)->Signature      = BUFFER_SIGN ;                       \
    (pndisBuff)->Next           = (pndisBuffNext) ;                   \
    (pndisBuff)->Length         = (cbLen) ;                           \
    (pndisBuff)->VirtualAddress = (pvData) ;                          \
    (pndisBuff)->Pool           = NULL ;                              \
}

//--------------------------------------------------------------------
//
//  Initializes a TA_ADDRESS_IP structure
//
//     ptanb - Pointer to the TA_ADDRESS_IP
//     pName - Pointer to the IP information
//
#define InitIPAddress( ptaip, port, addr )                            \
{                                                                     \
    (ptaip)->TAAddressCount           = 1 ;                           \
    (ptaip)->Address[0].AddressLength = sizeof( TDI_ADDRESS_IP );     \
    (ptaip)->Address[0].AddressType   = TDI_ADDRESS_TYPE_IP ;         \
    (ptaip)->Address[0].Address[0].sin_port = (port) ;                \
    (ptaip)->Address[0].Address[0].in_addr  =  (addr) ;               \
    memset((ptaip)->Address[0].Address[0].sin_zero, 8, 0) ;           \
}

//
//  Initializes a TDI_CONNECTION_INFORMATION structure for IP
//
//      pConnInfo - Pointer to TDI_CONNECTION_INFORMATION structure
//      ptaip - pointer to TA_IP_ADDRESS to initialize
//      port  - IP Port to use
//      addr  - IP Addr to use
//
#define InitIPTDIConnectInfo( pConnInfo, ptaip, port, addr )          \
{                                                                     \
    InitIPAddress( ((PTA_IP_ADDRESS)ptaip), (port), (addr) ) ;        \
    (pConnInfo)->RemoteAddressLength = sizeof( TA_IP_ADDRESS ) ;      \
    (pConnInfo)->RemoteAddress       = (ptaip) ;                      \
}

//--------------------------------------------------------------------
//
//  TDI Dispatch table (exported from vtdi.386)
//
extern TDIDispatchTable * TdiDispatch ;

//
//  Wrappers for interfacing to the TDI Dispatch table
//
#define TdiVxdOpenAddress           TdiDispatch->TdiOpenAddressEntry
#define TdiVxdCloseAddress          TdiDispatch->TdiCloseAddressEntry
#define TdiVxdOpenConnection        TdiDispatch->TdiOpenConnectionEntry
#define TdiVxdCloseConnection       TdiDispatch->TdiCloseConnectionEntry
#define TdiVxdAssociateAddress      TdiDispatch->TdiAssociateAddressEntry
#define TdiVxdDisAssociateAddress   TdiDispatch->TdiDisAssociateAddressEntry
#define TdiVxdConnect               TdiDispatch->TdiConnectEntry
#define TdiVxdDisconnect            TdiDispatch->TdiDisconnectEntry
#define TdiVxdListen                TdiDispatch->TdiListenEntry
#define TdiVxdAccept                TdiDispatch->TdiAcceptEntry
#define TdiVxdReceive               TdiDispatch->TdiReceiveEntry
#define TdiVxdSend                  TdiDispatch->TdiSendEntry
#define TdiVxdSendDatagram          TdiDispatch->TdiSendDatagramEntry
#define TdiVxdReceiveDatagram       TdiDispatch->TdiReceiveDatagramEntry
#define TdiVxdSetEventHandler       TdiDispatch->TdiSetEventEntry
#define TdiVxdQueryInformationEx    TdiDispatch->TdiQueryInformationExEntry
#define TdiVxdSetInformationEx      TdiDispatch->TdiSetInformationExEntry

//--------------------------------------------------------------------
//
//  Debug helper macros
//
#undef  ASSERT
#undef  ASSERTMSG
#ifdef DEBUG
    #include <vxddebug.h>

    extern DWORD DebugFlags ;
    extern char  DBOut[4096] ;
    extern int   iCurPos ;
    void   NbtDebugOut( char * ) ;

    #define DBGFLAG_ALL            (0x00000001)     // Everything else
    #define DBGFLAG_KDPRINTS       (0x00000004)     // KdPrint output
    #define DBGFLAG_AUX_OUTPUT     (0x00000080)

    #define DbgPrint( s )                   \
       if ( DebugFlags & DBGFLAG_ALL )      \
       {                                    \
          VxdSprintf( DBOut+iCurPos, s ) ;  \
          NbtDebugOut( DBOut+iCurPos ) ;    \
       }

    #define DbgPrintNum( n )                      \
       if ( DebugFlags & DBGFLAG_ALL )            \
       {                                          \
          VxdSprintf( DBOut+iCurPos, "%x", n ) ;  \
          NbtDebugOut( DBOut+iCurPos ) ;          \
       }

    #undef KdPrint
    #define KdPrint( s )                          \
       if ( DebugFlags & DBGFLAG_KDPRINTS )       \
       {                                          \
           VxdPrintf s ;                          \
       }

    //
    //  Conditional print routines
    //
    #define CDbgPrint( flag, s )            \
       if ( DebugFlags & (flag) )           \
       {                                    \
          VxdSprintf( DBOut+iCurPos, s ) ;  \
          NbtDebugOut( DBOut+iCurPos ) ;    \
       }

    #define CDbgPrintNum( flag, n )               \
       if ( DebugFlags & (flag) )                 \
       {                                          \
          VxdSprintf( DBOut+iCurPos, "%x", n ) ;  \
          NbtDebugOut( DBOut+iCurPos ) ;          \
       }

    #define DbgBreak()             _asm int 3
    #define ASSERT( exp )          CTEAssert( exp )
    #define ASSERTMSG( msg, exp )  CTEAssert( exp )

    #undef  DhcpAssert
    #define DhcpAssert( exp )      ASSERT( exp )
    #define DhcpGlobalDebugFlag    DebugFlags

    //
    //  REQUIRE is an ASSERT that keeps the expression under non-debug
    //  builds
    //
    #define REQUIRE( exp )         ASSERT( exp )

    //
    //  Consistency checks of the interrupt vector table to help watch
    //  for NULL pointer writes
    //
    extern BYTE abVecTbl[256] ;
    #define INIT_NULL_PTR_CHECK()  memcpy( abVecTbl, 0, sizeof( abVecTbl ))
    #define CHECK_MEM()            if ( sizeof(abVecTbl) != VxdRtlCompareMemory( 0, abVecTbl, sizeof(abVecTbl)) ) \
                                   {                                                         \
                                       DbgPrint("Vector table corrupt at " ) ;               \
                                       DbgPrintNum( VxdRtlCompareMemory( 0, abVecTbl, sizeof(abVecTbl) ) ) ;\
                                       DbgPrint("\n\r") ;                                    \
                                       _asm int 3                                            \
                                   }                                                         \
                                   CTECheckMem(__FILE__) ;
#else
    #define DbgPrint( s )
    #define DbgPrintNum( n )
    #define DbgBreak()
    #define ASSERT( exp )           { ; }
    #define ASSERTMSG( msg, exp )   { ; }
    #define REQUIRE( exp )          { exp ; }
    #define INIT_NULL_PTR_CHECK()
    #define CHECK_MEM()
    #define CDbgPrint( flag, s )
    #define CDbgPrintNum( flag, n )
#endif


//---------------------------------------------------------------------
//
// FROM init.c
//

BOOL DhcpInit( void ) ;

VOID
ProcessDhcpRequestForever(
    CTEEvent * pCTEEvent,
    PVOID      pContext
    ) ;

PVOID
CTEAllocInitMem(
    IN USHORT cbBuff ) ;

NTSTATUS
VxdReadIniString(
    IN      LPTSTR   pchKeyName,
    IN OUT  LPTSTR * ppStringBuff
    ) ;

//---------------------------------------------------------------------
//
// FROM utils.c
//
NTSTATUS
ConvertDottedDecimalToUlong(
    IN  PUCHAR               pInString,
    OUT PULONG               IpAddress
    ) ;

TDI_STATUS CopyBuff( PVOID  Dest,
                     int    DestSize,
                     PVOID  Src,
                     int    SrcSize,
                     int   *pSize ) ;

VOID DhcpSleep( DWORD Milliseconds ) ;

//---------------------------------------------------------------------
//
// FROM fileio.c
//

BOOL  InitFileSupport( void ) ;
DWORD WriteParamsToFile( PDHCP_CONTEXT pDhcpContext, HANDLE hFile ) ;
DWORD RewriteConfigFile( PVOID pEvent, PVOID pContext ) ;

//---------------------------------------------------------------------
//
// FROM msg.c
//

BOOL InitMsgSupport( VOID ) ;
PUCHAR DhcpGetMessage( DWORD MsgId ) ;

//---------------------------------------------------------------------
//
// FROM dhcpinfo.c
//

void NotifyClients( PDHCP_CONTEXT DhcpContext,
                    ULONG OldAddress,
                    ULONG IpAddress,
                    ULONG IpMask ) ;

#endif //_VXDPROCS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\client\nt\apinmp.c ===
//================================================================================
// Copyright (C) 1997 Microsoft Corporation
// Author: RamesV
// description: implements the API stuff for a named pipe.
//================================================================================

#include "precomp.h"
#include <apistub.h>
#include <apiimpl.h>

typedef
BOOL (*PFILE_OP_FN) (HANDLE, LPVOID, DWORD, LPDWORD, LPOVERLAPPED);

#define DEFAULT_SERVER_TIMEOUT     (2*60*1000)    // two minutes.

DWORD INLINE                                      // win32 status
BlockFileOp(                                      // synchronous read/write file
    IN      HANDLE                 Handle,        // handle to read/write on
    IN OUT  LPBYTE                 Buffer,        // buffer to read/write into
    IN      DWORD                  BufSize,       // o/p buffer size
    OUT     LPDWORD                nBytes,        // the # of bytes read/written
    IN      LPOVERLAPPED           Overlap,
    IN      PFILE_OP_FN            FileOp         // file operation, ReadFile or WriteFile
) {
    BOOL                           Success;
    DWORD                          Error;
    BOOL                           fCancelled = FALSE;

    Success = FileOp(Handle, Buffer, BufSize, nBytes, Overlap);
    if( Success ) return ERROR_SUCCESS;
    Error = GetLastError();
    if( ERROR_MORE_DATA == Error ) {
        (*nBytes) = BufSize;
        return ERROR_SUCCESS;
    }
    if( ERROR_IO_PENDING != Error ) return Error;
/*
    if( (PFILE_OP_FN)WriteFile == FileOp ) {
        Success = FlushFileBuffers(Handle);
        if( !Success ) return GetLastError();
    }
*/
    Error = WaitForSingleObject(Overlap->hEvent, DEFAULT_SERVER_TIMEOUT );
    if( WAIT_TIMEOUT == Error ) {
        //
        // Waited too long?
        //
        DhcpPrint((DEBUG_ERRORS, "Waited too long on pipe. Cancelling IO\n"));
        fCancelled = CancelIo(Handle);
        if( 0 == Error ) DhcpAssert( 0 == GetLastError());
        //
        // Hopefully, even if we cancel, get Overlapped result would return..
        //
    }
    
    Success = GetOverlappedResult(Handle, Overlap, nBytes, TRUE);
    if( Success ) return ERROR_SUCCESS;
    Error = GetLastError();
    if( ERROR_MORE_DATA == Error ) {
        (*nBytes) = BufSize;
        return ERROR_SUCCESS;
    }
    if( fCancelled ) DhcpAssert( ERROR_OPERATION_ABORTED == Error);
    return Error;
}

DWORD INLINE                                      // win32 status
BlockReadFile(                                    // synchronous read/write file
    IN      HANDLE                 Handle,        // handle to read on
    IN OUT  LPBYTE                 OutBuffer,     // buffer to read into
    IN      DWORD                  OutBufSize,    // o/p buffer size
    OUT     LPDWORD                nBytesRead,    // the # of bytes read
    IN      LPOVERLAPPED           Overlap
) {
    return BlockFileOp(Handle,OutBuffer, OutBufSize, nBytesRead, Overlap, ReadFile);
}

DWORD INLINE                                      // win32 status
BlockWriteFile(                                   // synchronous read/write file
    IN      HANDLE                 Handle,        // handle to write on
    IN OUT  LPBYTE                 InBuffer,      // buffer to writeinto
    IN      DWORD                  InBufSize,     // i/p buffer size
    OUT     LPDWORD                nBytesWritten, // the # of bytes written
    IN      LPOVERLAPPED           Overlap
) {
    return BlockFileOp(Handle, InBuffer, InBufSize, nBytesWritten, Overlap, WriteFile);
}

DWORD
ProcessApiRequest(                                // win32 status
    IN      HANDLE                 PipeHandle,    // input pipe to read from
    IN      LPOVERLAPPED           Overlap        // overlap buffer to use for this
) {
    DWORD                          Tmp[2];
    DWORD                          OutBufSize;
    DWORD                          InBufSize;
    DWORD                          Error;
    DWORD                          BytesRead;
    DWORD                          BytesWritten;
    LPBYTE                         InBuf;
    LPBYTE                         OutBuf;
    LPBYTE                         RealOutBuf;
    BOOL                           Success;

    ResetEvent(Overlap->hEvent);
    Error = BlockReadFile(PipeHandle, (LPBYTE)Tmp, sizeof(Tmp), &BytesRead, Overlap);
    if( ERROR_SUCCESS != Error ) return Error;
    if( sizeof(Tmp) != BytesRead ) return ERROR_INVALID_PARAMETER;

    InBufSize = ntohl(Tmp[1]);
    OutBufSize = ntohl(Tmp[0]);

    if( 0 == InBufSize ) return ERROR_INVALID_PARAMETER;
    InBuf = DhcpAllocateMemory(InBufSize);
    if( NULL == InBuf ) return ERROR_NOT_ENOUGH_MEMORY;

    RealOutBuf = DhcpAllocateMemory(2*sizeof(DWORD) + OutBufSize);
    if( NULL == RealOutBuf ) {
        DhcpFreeMemory(InBuf);
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    OutBuf = RealOutBuf+sizeof(DWORD);

    Error = BlockReadFile(PipeHandle, InBuf, InBufSize, &BytesRead, Overlap);
    if( ERROR_SUCCESS != Error ) goto Cleanup;
    if( InBufSize != BytesRead ) {
        Error = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    Error = DhcpApiProcessBuffer(InBuf,InBufSize, OutBuf, &OutBufSize);
    ((DWORD UNALIGNED*)RealOutBuf)[0] = htonl(Error);
    ((DWORD UNALIGNED*)RealOutBuf)[1] = htonl(OutBufSize);
    if( ERROR_SUCCESS == Error ) OutBufSize += sizeof(DWORD)*2;
    else OutBufSize = sizeof(DWORD)*2;

    Error = BlockWriteFile(PipeHandle, RealOutBuf, OutBufSize, &BytesWritten, Overlap);
    if( ERROR_SUCCESS != Error ) goto Cleanup;
    DhcpAssert(OutBufSize == BytesWritten);

  Cleanup:
    DhcpAssert(InBuf);
    DhcpFreeMemory(InBuf);
    if( NULL != RealOutBuf) DhcpFreeMemory(RealOutBuf);

    return Error;
}


DWORD                                            // error status
ExecuteApiRequest(                               // execute an api request
    IN      LPBYTE                 InBuffer,     // buffer to process
    OUT     LPBYTE                 OutBuffer,    // place to copy the output data
    IN OUT  LPDWORD                OutBufSize    // ip: how big can the outbuf be, o/p: how big it really is
) {
    LPBYTE                         xOutBuf;
    LPBYTE                         Tmp;
    DWORD                          xOutBufSize;
    DWORD                          BytesRead;
    BOOL                           Status;

    xOutBufSize = (*OutBufSize) + 2 * sizeof(DWORD); // the first two dwords are STATUS and reqd SIZE respectively
    xOutBuf = DhcpAllocateMemory(xOutBufSize);
    if( NULL == xOutBuf ) return ERROR_NOT_ENOUGH_MEMORY;

    Status = CallNamedPipe(
        DHCP_PIPE_NAME,
        InBuffer,
        ntohl(((DWORD UNALIGNED *)InBuffer)[1]) + 2*sizeof(DWORD),
        xOutBuf,
        xOutBufSize,
        &BytesRead,
        NMPWAIT_WAIT_FOREVER
    );
    if( FALSE == Status ) {
        Status = GetLastError();
        DhcpAssert(ERROR_MORE_DATA != Status);
        DhcpFreeMemory(xOutBuf);
        return Status;
    }

    DhcpAssert( BytesRead >= 2*sizeof(DWORD));    // expect to read STATUS and SIZE at the minimum..

    Status = *(DWORD UNALIGNED *)xOutBuf; Tmp = xOutBuf + sizeof(DWORD);
    xOutBufSize = *(DWORD UNALIGNED *)Tmp; Tmp += sizeof(DWORD);

    Status = ntohl(Status);
    xOutBufSize = ntohl(xOutBufSize);

    if( ERROR_SUCCESS == Status && 0 != xOutBufSize ) {
        memcpy(OutBuffer, Tmp, xOutBufSize);
    }

    (*OutBufSize) = xOutBufSize;

    DhcpFreeMemory(xOutBuf);
    return Status;
}

//================================================================================
// end of file
//================================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\client\nt\change.c ===
/*++

Copyright (C) 1998 Microsoft Corporation

Module Name:
    change.c

Abstract:
    handles some change notifications for dhcp.

--*/

#include "precomp.h"
#include <dhcpcapi.h>
#include <apiappl.h>
#include <dhcploc.h>
#include <dhcppro.h>

DWORD
ConvertNetworkString(
    IN OUT LPBYTE Buf,
    IN ULONG Size
    )
/*++

Routine Description:
    This routine converts a wide character string where each
    character is in network-order, to host-order so that the
    string can be used (for ex, for displaying).

Arguments:
    Buf -- wide character string buffer, replace in-place.
    Size -- size of above buffer in BYTES.

Return Value:
    ERROR_INTERNAL_ERROR or ERROR_SUCCESS

--*/
{
    if( 0 == Size ) return ERROR_INTERNAL_ERROR;
    if( Size % sizeof(WCHAR)) return ERROR_INTERNAL_ERROR;

    while( Size ) {
        *(LPWSTR) Buf = ntohs(*(LPWSTR)Buf);
        Buf += sizeof(WCHAR);
        Size -= sizeof(WCHAR);
    }

    return ERROR_SUCCESS;
}

DWORD
ConvertFromBufferToClassInfo(
    IN LPBYTE Data,
    IN ULONG nData,
    IN OUT LPDHCP_CLASS_INFO ClassesArray,
    IN OUT LPDWORD Size
    )
/*++

Routine Description:
    This routine converts a buffer which has wire-data to the
    DHCP_CLASS_INFO array structure.  The wire-data format is as
    follows: it is a set of triples, where each triple contains the
    actual user-class-id used on wire (binary), its name (LPWSTR), and
    its description (LPWSTR).  Each of these three items have their
    length specified first using two bytes -- the hi-byte followed by
    the lo-byte.

    N.B.  If the first of the triple (user-class-id) has length X,
    then the actual number of bytes of data on-wire would be X rounded
    off to 4 to preserve alignment.  This is taken care of in this
    routine.

    N.B #2. The pointers within the ClassesArray all point to the
    buffer (Data) provided.

Arguments:
    Data -- the wire-data buffer
    nData -- number of bytes of above
    ClassesArray -- input buffer that will be formatted with info.
    Size -- on input, this must be size of above buffer in bytes.
        on output, if the routine failed with ERROR_MORE_DATA, then
        this will contain the required number of bytes.  If the
        routine succeeded, then this will contain the number of
        elements in above array that got filled.

Return Values:
    ERROR_SUCCESS -- success
    ERROR_MORE_DATA -- data buffer provided in ClassesArray must be at
        least as many bytes as "Size."
    Win32 errors

--*/
{
    ULONG ReqdSize, ThisSize, nBytes, nClasses;
    LPBYTE Buf;

    Buf = Data; nBytes = 0;
    ReqdSize = 0; nClasses = 0;
    do {
        //
        // Require length (hi-byte, lo-byte)
        //
        if( nBytes + 2 > nData ) return ERROR_INTERNAL_ERROR; 

        //
        // user-classid binary blob of specified size.
        // N.B.  length must be rounded off to nearest
        // multiple of 4.
        //
        ThisSize = ((Buf[0])<<8)+Buf[1];
        if( 0 == ThisSize ) return ERROR_INTERNAL_ERROR;
        ThisSize = (ThisSize + 3) & ~3;

        //
        // Go over class id.
        //
        Buf += 2 + ThisSize;
        nBytes += 2 + ThisSize;
        ReqdSize += ThisSize;

        if( nBytes + 2 > nData ) return ERROR_INTERNAL_ERROR;

        //
        // user class name.. size must be multiple of sizeof(WCHAR)
        //
        ThisSize = ((Buf[0])<<8)+Buf[1];
        Buf += 2 + ThisSize;
        nBytes += 2 + ThisSize;

        if( (ThisSize % 2 ) ) return ERROR_INTERNAL_ERROR;
        ReqdSize += ThisSize + sizeof(L'\0');

        if( nBytes + 2 > nData ) return ERROR_INTERNAL_ERROR;

        //
        // user class description.. 
        //
        ThisSize = ((Buf[0])<<8)+Buf[1];
        Buf += 2 + ThisSize;
        nBytes += 2 + ThisSize;

        if( (ThisSize % 2 ) ) return ERROR_INTERNAL_ERROR;
        ReqdSize += ThisSize + sizeof(L'\0');

        nClasses ++;
    } while( nBytes < nData );

    //
    // Check if we have the required size.
    //
    ReqdSize += sizeof(DHCP_CLASS_INFO)*nClasses;

    if( (*Size) < ReqdSize ) {
        *Size = ReqdSize;
        return ERROR_MORE_DATA;
    } else {
        *Size = nClasses;
    }

    //
    // Assemble the array.
    //

    Buf = nClasses*sizeof(DHCP_CLASS_INFO) + ((LPBYTE)ClassesArray);
    nClasses = 0;
    do {

        ClassesArray[nClasses].Version = DHCP_CLASS_INFO_VERSION_0;

        //
        // user class id binary info
        //
        ThisSize = ((Data[0])<<8)+Data[1];
        Data += 2;
        ClassesArray[nClasses].ClassData = Buf;
        ClassesArray[nClasses].ClassDataLen = ThisSize;
        memcpy(Buf, Data, ThisSize);
        ThisSize = (ThisSize + 3)&~3;
        Buf += ThisSize;  Data += ThisSize;

        //
        // class name
        //
        ThisSize = ((Data[0])<<8)+Data[1];
        Data += 2;
        ClassesArray[nClasses].ClassName = (LPWSTR)Buf;
        memcpy(Buf, Data, ThisSize);
        if( ERROR_SUCCESS != ConvertNetworkString(Buf, ThisSize) ){ 
            return ERROR_INTERNAL_ERROR;
        }

        Buf += ThisSize; Data += ThisSize;
        *(LPWSTR)Buf = L'\0'; Buf += sizeof(WCHAR);

        //
        // Class description
        //
        ThisSize = ((Data[0])<<8)+Data[1];
        Data += 2;
        if( 0 == ThisSize ) {
            ClassesArray[nClasses].ClassDescr = NULL;
        } else {
            ClassesArray[nClasses].ClassDescr = (LPWSTR)Buf;
            memcpy(Buf, Data, ThisSize);
            if( ERROR_SUCCESS != ConvertNetworkString(Buf, ThisSize) ) {
                return ERROR_INTERNAL_ERROR;
            }
        }
        Buf += ThisSize; Data += ThisSize;
        *(LPWSTR)Buf = L'\0'; Buf += sizeof(WCHAR);

        nClasses ++;
    } while( nClasses < *Size );

    return ERROR_SUCCESS;
}

//DOC DhcpEnumClasses enumerates the list of classes available on the system for configuration.
//DOC This is predominantly going to be used by the NetUI. (in which case the ClassData part of the
//DOC DHCP_CLASS_INFO structure is essentially useless).
//DOC Note that Flags is used for future use.
//DOC The AdapterName can currently be only GUIDs but may soon be EXTENDED to be IpAddress strings or
//DOC h-w addresses or any other user friendly means of denoting the Adapter.  Note that if the Adapter
//DOC Name is NULL (not the empty string L""), then it refers to either ALL adapters.
//DOC The Size parameter is an input/output parameter. The input value is the # of bytes of allocated
//DOC space in the ClassesArray buffer.  On return, the meaning of this value depends on the return value.
//DOC If the function returns ERROR_SUCCESS, then, this parameter would return the # of elements in the
//DOC array ClassesArray.  If the function returns ERROR_MORE_DATA, then, this parameter refers to the
//DOC # of bytes space that is actually REQUIRED to hold the information.
//DOC In all other cases, the values in Size and ClassesArray dont mean anything.
//DOC
//DOC Return Values:
//DOC ERROR_DEVICE_DOES_NOT_EXIST  The AdapterName is illegal in the given context
//DOC ERROR_INVALID_PARAMETER
//DOC ERROR_MORE_DATA              ClassesArray is not a large enough buff..
//DOC ERROR_FILE_NOT_FOUND         The DHCP Client is not running and could not be started up.
//DOC ERROR_NOT_ENOUGH_MEMORY      This is NOT the same as ERROR_MORE_DATA
//DOC Win32 errors
//DOC
//DOC Remarks:
//DOC To notify DHCP that some class has changed, please use the DhcpHandlePnPEvent API.
DWORD
DhcpEnumClasses(                                  // enumerate the list of classes available
    IN      DWORD                  Flags,         // currently must be zero
    IN      LPWSTR                 AdapterName,   // currently must be AdapterGUID (cannot be NULL yet)
    IN OUT  DWORD                 *Size,          // input # of bytes available in BUFFER, output # of elements in array
    IN OUT  DHCP_CLASS_INFO       *ClassesArray   // pre-allocated buffer
)
{
    DHCPAPI_PARAMS                 SendParams;    // we need to get something from teh dhcp server..
    PDHCPAPI_PARAMS                RecdParams;
    DWORD                          Result;
    DWORD                          nBytesToAllocate;
    DWORD                          nRecdParams;
    BYTE                           Opt;

    if( 0 != Flags || NULL == AdapterName || NULL == Size ) {
        return ERROR_INVALID_PARAMETER;           // sanity check
    }

    if( NULL == ClassesArray && 0 != *Size ) {
        return ERROR_INVALID_DATA;                // if *Size is non-Zero, then the ClassesArray buffer should exist
    }

    Opt = OPTION_USER_CLASS;                      // intiialize request packet for this option..
    SendParams.OptionId = (BYTE)OPTION_PARAMETER_REQUEST_LIST;
    SendParams.IsVendor = FALSE;
    SendParams.Data = &Opt;
    SendParams.nBytesData = sizeof(Opt);

    nBytesToAllocate = 0;
    Result = DhcpRequestParameters                // try to get this either directly from client or via INFORM
    (
        /* LPWSTR                 AdapterName      */ AdapterName,
        /* LPBYTE                 ClassId          */ NULL,
        /* DWORD                  ClassIdLen       */ 0,
        /* PDHCPAPI_PARAMS        SendParams       */ &SendParams,
        /* DWORD                  nSendParams      */ 1,
        /* DWORD                  Flags            */ 0,
        /* PDHCPAPI_PARAMS        RecdParams       */ NULL,
        /* LPDWORD                pnRecdParamsBytes*/ &nBytesToAllocate
    );
    if( ERROR_MORE_DATA != Result ) {             // either an error or dont have anything to return?
        return Result;
    }

    DhcpAssert(nBytesToAllocate);                 // if it were 0, Result would have been ERROR_SUCCESS
    RecdParams = DhcpAllocateMemory(nBytesToAllocate);
    if( NULL == RecdParams ) {                    // um? dont have memory? cant really happen?
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    nRecdParams = nBytesToAllocate;
    Result = DhcpRequestParameters                // try to get this either directly from client or via INFORM
    (
        /* LPWSTR                 AdapterName      */ AdapterName,
        /* LPBYTE                 ClassId          */ NULL,
        /* DWORD                  ClassIdLen       */ 0,
        /* PDHCPAPI_PARAMS        SendParams       */ &SendParams,
        /* DWORD                  nSendParams      */ 1,
        /* DWORD                  Flags            */ 0,
        /* PDHCPAPI_PARAMS        RecdParams       */ RecdParams,
        /* LPDWORD                pnRecdParamsBytes*/ &nRecdParams
    );

    if( ERROR_SUCCESS == Result && 1 != nRecdParams ) {
        DhcpAssert(FALSE);
        Result = ERROR_INTERNAL_ERROR;            // dont expect this to happen..
    }

    if( ERROR_SUCCESS != Result ) {               // aw, comeone, cant happen now...
        // it is possible for instance to have a PnP event in the middle that would cause
        // the adapter to go away. In this case ERROR_FILE_NOT_FOUND (2) is returned.
        // no point for the assert - otherwise returning the error up to the caller is
        // just fine.
        //DhcpAssert(FALSE);
        DhcpPrint((DEBUG_ERRORS, "DhcpRequestParams: 0x%lx (%ld)\n", Result, Result));
        DhcpFreeMemory(RecdParams);
        return Result;
    }

    DhcpAssert(NULL != RecdParams);
    Result = ConvertFromBufferToClassInfo(        // convert from straight bytes to classinfo struct
        RecdParams->Data,
        RecdParams->nBytesData,
        ClassesArray,
        Size
    );

    DhcpFreeMemory(RecdParams);
    return Result;
}

ULONG       _inline                               // status
GetRegistryClassIdName(                           // get registr string class id name written by ui
    IN      LPWSTR                 AdapterName,   // for this adapter
    OUT     LPWSTR                *ClassIdName
)
{
    ULONG                          Error;
    LPBYTE                         Value;
    ULONG                          ValueType, ValueSize;

    *ClassIdName = NULL;
    ValueSize = 0; Value = NULL;
    Error = DhcpRegReadFromLocation(
        DEFAULT_USER_CLASS_UI_LOC_FULL,
        AdapterName,
        &Value,
        &ValueType,
        &ValueSize
    );
    if( ERROR_SUCCESS != Error ) return Error;    // failed?
    if( REG_SZ != ValueType ) {
        if( Value ) DhcpFreeMemory(Value);
        DhcpPrint((DEBUG_ERRORS, "DhcpClassId Type is incorrect: %ld\n", ValueType));
        DhcpAssert(FALSE);
        return ERROR_INVALID_DATA;                // uh ? should not have happened!
    }

    *ClassIdName = (LPWSTR)Value;
    return ERROR_SUCCESS;
}

ULONG       _inline                               // status
ConvertClassIdNameToBin(                          // get corresponding value, return itself in ASCII o/w
    IN      LPWSTR                 AdapterName,   // for this adapter
    IN      LPWSTR                 ClassIdName,   // ClassIdName for which we are searching
    IN      BOOL                   SkipClassEnum, // to skip dhcp class enumeration during initialization
    OUT     LPBYTE                *ClassIdBin,    // fill this ptr up
    OUT     ULONG                 *ClassIdBinSize // fill this with size of memory allocated
)
{
    ULONG                          Error, Size, i;
    PDHCP_CLASS_INFO               pDhcpClassInfo;// array
    LPBYTE                         BinData;
    ULONG                          BinDataLen;

    pDhcpClassInfo = NULL;
    BinData = NULL; BinDataLen = 0;
    *ClassIdBin = NULL; *ClassIdBinSize = 0;

    // do not perform class enumeration before Dhcp is initialized.
    if (!SkipClassEnum) {
        do {                                          // not a loop, just to avoid GOTOs
            Size = 0;                                 // buffer yet be allocated..
            Error = DhcpEnumClasses(
                /* Flags        */ 0,
                /* AdapterName  */ AdapterName,
                /* Size         */ &Size,
                /* ClassesArray */ NULL
            );
            if( ERROR_MORE_DATA != Error ) {          // failed?
                break;
            }

            DhcpAssert(0 != Size);
            pDhcpClassInfo = DhcpAllocateMemory(Size);
            if( NULL == pDhcpClassInfo ) return ERROR_NOT_ENOUGH_MEMORY;

            Error = DhcpEnumClasses(
                /* Flags        */ 0,
                /* AdapterName  */ AdapterName,
                /* Size         */ &Size,
                /* ClassesArray */ pDhcpClassInfo
            );
            if( ERROR_SUCCESS != Error ) {            // This call should not fail!
                DhcpPrint((DEBUG_ERRORS, "DhcpEnumClasses failed %ld\n", Error));
                DhcpAssert(FALSE);
                DhcpFreeMemory(pDhcpClassInfo);
                return Error;
            }

            DhcpAssert(0 != Size);
            for( i = 0; i != Size ; i ++ ) {
                if( 0 == wcscmp(pDhcpClassInfo[i].ClassName, ClassIdName) )
                    break;
            }
            if( i != Size ) {                         // found a match
                BinData = pDhcpClassInfo[i].ClassData;
                BinDataLen = pDhcpClassInfo[i].ClassDataLen;
            } else {
                DhcpFreeMemory(pDhcpClassInfo);
            }
        } while(0);                                   // not a loop just to avoid GOTOs
    }

    // BinData and BinDataLen holds the info we know..

    if( NULL == BinData ) {                       // couldn't find the class..
        DhcpPrint((DEBUG_ERRORS, "Could not find the class <%ws>\n", ClassIdName));

        BinDataLen = wcslen(ClassIdName);
        BinData = DhcpAllocateMemory(BinDataLen);
        if( NULL == BinData ) {                   // could not allocate this mem?
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        Error = wcstombs(BinData, ClassIdName, BinDataLen);
        if( -1 == Error ) {                       // failed conversion?
            Error = GetLastError();
            DhcpPrint((DEBUG_ERRORS, "Failed ot convert %ws\n", ClassIdName));
            DhcpAssert(FALSE);
            DhcpFreeMemory(BinData);
            return Error;
        }

        *ClassIdBin = BinData; *ClassIdBinSize = BinDataLen;
        return ERROR_SUCCESS;
    }

    // successfully got the bindata etc..
    DhcpAssert(pDhcpClassInfo);                   // this is where the string is..

    *ClassIdBin = DhcpAllocateMemory(BinDataLen); // try allocating memory
    if( NULL == *ClassIdBin ) {                   // failed
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    memcpy(*ClassIdBin, BinData, BinDataLen);
    *ClassIdBinSize = BinDataLen;

    if (pDhcpClassInfo != NULL)
        DhcpFreeMemory(pDhcpClassInfo);           // free allocated ptr

    return ERROR_SUCCESS;
}

LPWSTR      _inline                               // String (allocated)
GetRegClassIdBinLocation(                         // find where to store bin
    IN      LPWSTR                 AdapterName    // for this adapter
)
{
    ULONG                          Error;
    LPWSTR                         Value, RetVal;
    ULONG                          ValueSize, ValueType;

    ValueSize = 0; Value = NULL;
    Error = DhcpRegReadFromLocation(
        DHCP_CLIENT_PARAMETER_KEY REGISTRY_CONNECT_STRING DHCP_CLASS_LOCATION_VALUE,
        AdapterName,
        &(LPBYTE)Value,
        &ValueType,
        &ValueSize
    );
    if( ERROR_SUCCESS != Error ) {                // couldn't find it? choose default!
        ValueSize = 0;                            // didn't allocate nothing..
    } else if( ValueType != DHCP_CLASS_LOCATION_TYPE ) {
        DhcpPrint((DEBUG_ERRORS, "DhcpLocationType is %ld\n", ValueType));
        DhcpAssert(FALSE);
        ValueSize = 0;
    }
    if( 0 == ValueSize ) {                        // choose default..
        Value = DEFAULT_USER_CLASS_LOC_FULL;
    }

    Error = DhcpRegExpandString(                  // replace '?' with AdapterName
        Value,
        AdapterName,
        &RetVal,
        NULL
    );

    if( 0 != ValueSize ) DhcpFreeMemory(Value);   // free only if we didn't allocate
    if( ERROR_SUCCESS != Error ) return NULL;     // can't return error codes?

    return RetVal;
}


ULONG       _inline                               // status
SetRegistryClassIdBin(                            // write the binary classid value
    IN      LPWSTR                 AdapterName,   // for this adapter
    IN      LPBYTE                 ClassIdBin,    // Binary value to write
    IN      ULONG                  ClassIdBinSize // size of entry..
)
{
    ULONG                          Error;
    LPWSTR                         RegLocation;   // registry location..
    LPWSTR                         RegValue;
    HKEY                           RegKey;

    RegLocation = GetRegClassIdBinLocation(AdapterName);
    if( NULL == RegLocation ) return ERROR_NOT_ENOUGH_MEMORY;

    RegValue = wcsrchr(RegLocation, REGISTRY_CONNECT);
    if( NULL == RegValue ) {                      // invalid string?
        return ERROR_INVALID_DATA;
    }

    *RegValue ++ = L'\0';                         // separate key and value..

    Error = RegOpenKeyEx(                         // open the key..
        HKEY_LOCAL_MACHINE,
        RegLocation,
        0 /* Reserved */,
        DHCP_CLIENT_KEY_ACCESS,
        &RegKey
    );
    if( ERROR_SUCCESS != Error ) {
        DhcpPrint((DEBUG_ERRORS, "Could not open key: %ws : %ld\n", RegLocation, Error));
        DhcpFreeMemory(RegLocation);
        return Error;
    }

    Error = RegSetValueEx(
        RegKey,
        RegValue,
        0 /* Reserved */,
        REG_BINARY,
        ClassIdBin,
        ClassIdBinSize
    );
    RegCloseKey(RegKey);
    if( ERROR_SUCCESS != Error ) {
        DhcpPrint((DEBUG_ERRORS, "Could not save value:"
                   "%ws / %ws: %ld\n", RegLocation, RegValue, Error));
    }
    DhcpFreeMemory(RegLocation);
    return Error;
}

ULONG                                             // status
FixupDhcpClassId(                                 // fix ClassIdBin value in registry based on ClassId
    IN      LPWSTR                 AdapterName,
    IN      BOOL                   SkipClassEnum
)
{
    LPWSTR                         ClassIdName;   // as written by UI
    LPBYTE                         ClassIdBin;    // as needs to be written in registry
    ULONG                          ClassIdBinSize;// the # of bytes of above..
    ULONG                          Error;         // status

    ClassIdName = NULL;
    Error = GetRegistryClassIdName(AdapterName, &ClassIdName);
    if( ERROR_SUCCESS != Error || NULL == ClassIdName
        || L'\0' == *ClassIdName ) {
        DhcpPrint((DEBUG_ERRORS, "Could not read ClassId: %ld\n", Error));
        ClassIdName = NULL;
    }

    ClassIdBinSize = 0; ClassIdBin = NULL;

    if( ClassIdName ) {
        Error = ConvertClassIdNameToBin(
            AdapterName, ClassIdName, SkipClassEnum, &ClassIdBin, &ClassIdBinSize
            );

        DhcpFreeMemory(ClassIdName);// Dont need this memory anymore
    } else {
        Error = ERROR_SUCCESS;
    }

    if( ERROR_SUCCESS != Error || NULL == ClassIdBin ) {
        DhcpPrint((DEBUG_ERRORS, "Could not convert classid.. making it NULL\n"));
        ClassIdBin = NULL;
        ClassIdBinSize = 0;
    }

    Error = SetRegistryClassIdBin(AdapterName, ClassIdBin, ClassIdBinSize);
    if( ClassIdBin ) DhcpFreeMemory(ClassIdBin);

    return Error;
}

//DOC DhcpHandlePnpEvent can be called as an API by any process (excepting that executing within the
//DOC DHCP process itself) when any of the registry based configuration has changed and DHCP client has to
//DOC re-read the registry.  The Flags parameter is for future expansion.
//DOC The AdapterName can currently be only GUIDs but may soon be EXTENDED to be IpAddress strings or
//DOC h-w addresses or any other user friendly means of denoting the Adapter.  Note that if the Adapter
//DOC Name is NULL (not the empty string L""), then it refers to either GLOBAL parameters or ALL adapters
//DOC depending on which BOOL has been set. (this may not get done for BETA2).
//DOC The Changes structure gives the information on what changed.
//DOC Currently, only a few of the defined BOOLs would be supported (for BETA2 NT5).
//DOC
//DOC Return Values:
//DOC ERROR_DEVICE_DOES_NOT_EXIST  The AdapterName is illegal in the given context
//DOC ERROR_INVALID_PARAMETER
//DOC ERROR_CALL_NOT_SUPPORTED     The particular parameter that has changed is not completely pnp yet.
//DOC Win32 errors
DWORD
WINAPI
DhcpHandlePnPEvent(
    IN      DWORD                  Flags,         // MUST BE ZERO
    IN      DWORD                  Caller,        // currently must be DHCP_CALLER_TCPUI
    IN      LPWSTR                 AdapterName,   // currently must be the adapter GUID or NULL if global
    IN      LPDHCP_PNP_CHANGE      Changes,       // specify what changed
    IN      LPVOID                 Reserved       // reserved for future use..
)
{
    ULONG Error;

    if( 0 != Flags || DHCP_CALLER_TCPUI != Caller ||
        NULL != Reserved || NULL == Changes ) {
        return ERROR_INVALID_PARAMETER;           // sanity check
    }

    if( Changes->Version > DHCP_PNP_CHANGE_VERSION_0 ) {
        return ERROR_NOT_SUPPORTED;               // this version is not supported
    }

    if( Changes->ClassIdChanged ) {               // the classid got changed..
        // The UI writes any changes to the "DhcpClassId" registry value... but
        // this is just the name of the class and not the actual ClassId binary value
        // So we read this compare and write the correct value..
        (void) FixupDhcpClassId(AdapterName, FALSE);     // figure the binary classid value
    }

    Error = DhcpStaticRefreshParams(AdapterName); // refresh all static params..

    if( ERROR_SUCCESS != Error ) return Error;
    if( Changes->ClassIdChanged ) {
        //
        // If ClassID changes, we have to refresh lease..
        // 
        (void) DhcpAcquireParameters(AdapterName);
    }

    return ERROR_SUCCESS;
}

//================================================================================
// end of file
//================================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\client\nt\dhcp.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    dhcp.c

Abstract:

    This file contains specific to NT dhcp service.

Author:

    Madan Appiah (madana) 7-Dec-1993.

Environment:

    User Mode - Win32

Revision History:

--*/

#include "precomp.h"
#include <optchg.h>

#define  GLOBAL_DATA_ALLOCATE
#include "dhcpglobal.h"
#include <dhcploc.h>

#include <dhcppro.h>
#include <lmsname.h>
#include <align.h>
#include <ipexport.h>
#include <dnsapi.h>
#include <iphlpapi.h>
#include <apiimpl.h>
#include <ntlsa.h>
#include <ntddndis.h>
#include "nlanotif.h"

extern
DWORD
MadcapInitGlobalData(VOID);

extern
VOID
MadcapCleanupGlobalData(VOID);

BOOL DhcpGlobalServiceRunning = FALSE;

HANDLE  DhcpGlobalMediaSenseHandle = NULL;
HANDLE  DhcpLsaDnsDomChangeNotifyHandle = NULL;

BOOL Initialized = FALSE;


//
// local protos
//

DWORD
DhcpInitMediaSense(
    VOID
    );

VOID
MediaSenseDetectionLoop(
    VOID
    );

DWORD
ProcessAdapterBindingEvent(
    LPWSTR  adapterName,
    DWORD   ipInterfaceContext,
    IP_STATUS   mediaStatus
    );

DWORD
ProcessMediaSenseEvent(
    LPWSTR adapterName,
    DWORD   ipInterfaceContext,
    IP_STATUS   mediaStatus
    );


DWORD
DhcpInitGlobalData(
    VOID
);

VOID
DhcpCleanupGlobalData(
    VOID
);

CHAR  DhcpGlobalHostNameBuf[MAX_COMPUTERNAME_LENGTH+300];
WCHAR DhcpGlobalHostNameBufW[MAX_COMPUTERNAME_LENGTH+300];

BOOLEAN
DhcpClientDllInit (
    IN PVOID DllHandle,
    IN ULONG Reason,
    IN PCONTEXT Context OPTIONAL
    )

/*++

Routine Description:

    This is the DLL initialization routine for dhcpcsvc.dll.

Arguments:

    Standard.

Return Value:

    TRUE iff initialization succeeded.

--*/
{
    DWORD Error = ERROR_SUCCESS;
    BOOL  BoolError;
    DWORD Length;

    UNREFERENCED_PARAMETER(DllHandle);  // avoid compiler warnings
    UNREFERENCED_PARAMETER(Context);    // avoid compiler warnings

    //
    // Handle attaching netlogon.dll to a new process.
    //

    if (Reason == DLL_PROCESS_ATTACH) {

        if ( !DisableThreadLibraryCalls( DllHandle ) ) {
            return( FALSE );
        }

        DhcpGlobalWinSockInitialized = FALSE;

        Error = DhcpInitGlobalData();
        if( ERROR_SUCCESS != Error ) return FALSE;

        Error = DhcpInitializeParamChangeRequests();
        if( ERROR_SUCCESS != Error ) return FALSE;

    } else if (Reason == DLL_PROCESS_DETACH) {
        //
        // Handle detaching dhcpcsvc.dll from a process.
        //

        DhcpCleanupGlobalData();
    }

    return( TRUE );
}


DWORD
UpdateStatus(
    VOID
    )
/*++

Routine Description:

    This function updates the dhcp service status with the Service
    Controller.

Arguments:

    None.

Return Value:

    Return code from SetServiceStatus.

--*/
{
    DWORD Error = ERROR_SUCCESS;


    if ( ((SERVICE_STATUS_HANDLE)0) != DhcpGlobalServiceStatusHandle ) {

        DhcpGlobalServiceStatus.dwCheckPoint++;
        if (!SetServiceStatus(
            DhcpGlobalServiceStatusHandle,
            &DhcpGlobalServiceStatus)) {
            Error = GetLastError();
            DhcpPrint((DEBUG_ERRORS, "SetServiceStatus failed, %ld.\n", Error ));
        }
    }

    return(Error);
}

DWORD
ServiceControlHandler(
    IN DWORD Opcode,
    DWORD    EventType,
    PVOID    EventData,
    PVOID    pContext
    )
/*++

Routine Description:

    This is the service control handler of the dhcp service.

Arguments:

    Opcode - Supplies a value which specifies the action for the
        service to perform.

Return Value:

    None.

--*/
{
    DWORD  dwStatus = NO_ERROR;

    switch (Opcode) {

    case SERVICE_CONTROL_SHUTDOWN:
        DhcpGlobalIsShuttingDown = TRUE;
    case SERVICE_CONTROL_STOP:

        if (DhcpGlobalServiceStatus.dwCurrentState != SERVICE_STOP_PENDING) {

            DhcpPrint(( DEBUG_MISC, "Service is stop pending.\n"));

            DhcpGlobalServiceStatus.dwCurrentState = SERVICE_STOP_PENDING;
            DhcpGlobalServiceStatus.dwCheckPoint = 0;

            //
            // Send the status response.
            //

            UpdateStatus();

            if (! SetEvent(DhcpGlobalTerminateEvent)) {

                //
                // Problem with setting event to terminate dhcp
                // service.
                //

                DhcpPrint(( DEBUG_ERRORS,
                    "Error setting Terminate Event %lu\n",
                        GetLastError() ));

                DhcpAssert(FALSE);
            }
            return dwStatus;
        }
        break;

    case SERVICE_CONTROL_PAUSE:

        DhcpGlobalServiceStatus.dwCurrentState = SERVICE_PAUSED;
        DhcpPrint(( DEBUG_MISC, "Service is paused.\n"));
        break;

    case SERVICE_CONTROL_CONTINUE:

        DhcpGlobalServiceStatus.dwCurrentState = SERVICE_RUNNING;
        DhcpPrint(( DEBUG_MISC, "Service is Continued.\n"));
        break;

    case SERVICE_CONTROL_INTERROGATE:
        DhcpPrint(( DEBUG_MISC, "Service is interrogated.\n"));
        break;

    default:
        dwStatus = ERROR_CALL_NOT_IMPLEMENTED;
        DhcpPrint(( DEBUG_MISC, "Service received unknown control.\n"));
        break;
    }

    //
    // Send the status response.
    //

    UpdateStatus();

    return dwStatus;
}


VOID
ScheduleWakeUp(
    PDHCP_CONTEXT DhcpContext,
    DWORD TimeToSleep
    )
/*++

Routine Description:

    This functions schedules a DHCP routine to run.

Arguments:

    Context - A pointer to a DHCP context block.

    TimeToSleep - The time to sleep before running the renewal function,
        in seconds.

Return Value:

    The status of the operation.

--*/
{
    time_t TimeNow;
    BOOL BoolError;

    if ( TimeToSleep == INFINIT_LEASE ) {
        DhcpContext->RunTime = INFINIT_TIME;
    } else {
        TimeNow = time( NULL);
        DhcpContext->RunTime = TimeNow + TimeToSleep;

        if( DhcpContext->RunTime  < TimeNow ) {   // time wrapped around
            DhcpContext->RunTime = INFINIT_TIME;
        }
    }

    //
    // Append this work item to the DhcpGlobalRenewList and kick the list event.
    // Also, release the semaphore on this context, so that someone else can enter.
    //


    LOCK_RENEW_LIST();

    // RenewalListEntry could be non-empty as there could be another thread scheduled on this.
    // This could easily happen if:
    //    ProcessDhcpRequestForEver spawns a thread, but API Threads grabs semaphore and
    //    completes renewal process.. so it goes back into the RenewalList.  Now Renewal thread
    //    completes, comes here and our list entry is not empty.  So do this only when
    //    our list entry is not empty.
    if( IsListEmpty(&DhcpContext->RenewalListEntry ) ) {
        InsertTailList( &DhcpGlobalRenewList, &DhcpContext->RenewalListEntry );
    }
    UNLOCK_RENEW_LIST();

    BoolError = SetEvent( DhcpGlobalRecomputeTimerEvent );
    DhcpAssert( BoolError == TRUE );
}

SOCKET DhcpGlobalSocketForZeroAddress = INVALID_SOCKET;
ULONG  DhcpGlobalNOpensForZeroAddress = 0;
CRITICAL_SECTION  DhcpGlobalZeroAddressCritSect;

DWORD
OpenDhcpSocket(
    PDHCP_CONTEXT DhcpContext
    )
{

    DWORD Error;
    PLOCAL_CONTEXT_INFO localInfo;
    DhcpAssert(!IS_MDHCP_CTX( DhcpContext ) ) ;
    localInfo = DhcpContext->LocalInformation;

    if ( localInfo->Socket != INVALID_SOCKET ) {
        return ( ERROR_SUCCESS );
    }

    if( IS_DHCP_DISABLED(DhcpContext) ) {
        //
        // For static IP addresses, always bind to IP address of context.
        //
        Error = InitializeDhcpSocket(
            &localInfo->Socket,
            DhcpContext->IpAddress,
            IS_APICTXT_ENABLED(DhcpContext)
            );
        goto Cleanup;
    }

    if( !IS_ADDRESS_PLUMBED(DhcpContext) || DhcpIsInitState(DhcpContext) ) {
        // need to bind to zero address.. try to use the global one..

        EnterCriticalSection(&DhcpGlobalZeroAddressCritSect);

        if( ++DhcpGlobalNOpensForZeroAddress == 1 ) {
            // open DhcpGlobalSocketForZeroAddress bound to zero address..
            
            Error = InitializeDhcpSocket(&DhcpGlobalSocketForZeroAddress,0, IS_APICTXT_ENABLED(DhcpContext));
            if( ERROR_SUCCESS != Error ) {
                --DhcpGlobalNOpensForZeroAddress;
            }
        
        } else {
            Error = ERROR_SUCCESS;
        }

        LeaveCriticalSection(&DhcpGlobalZeroAddressCritSect);

        if( ERROR_SUCCESS == Error )
        {
            DhcpAssert(INVALID_SOCKET != DhcpGlobalSocketForZeroAddress);
            if( INVALID_SOCKET == DhcpGlobalSocketForZeroAddress ) 
            {
                Error = ERROR_GEN_FAILURE;
                goto Cleanup;
            }
            localInfo->Socket = DhcpGlobalSocketForZeroAddress;
        }

        goto Cleanup;
   }

    //
    // create a socket for the dhcp protocol.  it's important to bind the
    // socket to the correct ip address.  There are currently three cases:
    //
    // 1.  If the interface has been autoconfigured, it already has an address,
    //     say, IP1.  If the client receives a unicast offer from a dhcp server
    //     the offer will be addressed to IP2, which is the client's new dhcp
    //     address.  If we bind the dhcp socket to IP1, the client won't be able
    //     to receive unicast responses.  So, we bind the socket to 0.0.0.0.
    //     This will allow the socket to receive a unicast datagram addressed to
    //     any address.
    //
    // 2.  If the interface in not plumbed (i.e. doesn't have an address) bind
    //     the socket to 0.0.0.0
    //
    // 3.  If the interface has been plumbed has in *not* autoconfigured, then
    //     bind to the current address.

    Error =  InitializeDhcpSocket(
                 &localInfo->Socket,
                 ( IS_ADDRESS_PLUMBED(DhcpContext) &&
                   !DhcpContext->IPAutoconfigurationContext.Address
                 ) ?
                    DhcpContext->IpAddress : (DHCP_IP_ADDRESS)(0),
                    IS_APICTXT_ENABLED(DhcpContext)
                 );
Cleanup:
    if( Error != ERROR_SUCCESS )
    {
        localInfo->Socket = INVALID_SOCKET;
        DhcpPrint((DEBUG_ERRORS, "Socket open failed: 0x%lx\n", Error));
    }

    return(Error);
}


DWORD
CloseDhcpSocket(
    PDHCP_CONTEXT DhcpContext
    )
{

    DWORD Error = ERROR_SUCCESS;
    PLOCAL_CONTEXT_INFO localInfo;
    DWORD Error1;

    localInfo = DhcpContext->LocalInformation;

    if( localInfo->Socket != INVALID_SOCKET ) {

        if( DhcpGlobalSocketForZeroAddress == localInfo->Socket ) {

            EnterCriticalSection(&DhcpGlobalZeroAddressCritSect);

            if( 0 == --DhcpGlobalNOpensForZeroAddress ) {
                // last open socket..
                Error = closesocket( localInfo->Socket );
                DhcpGlobalSocketForZeroAddress = INVALID_SOCKET;
            }

            LeaveCriticalSection(&DhcpGlobalZeroAddressCritSect);

        } else {
            Error = closesocket( localInfo->Socket );
        }

        if( Error != ERROR_SUCCESS ) {
            DhcpPrint(( DEBUG_ERRORS, " Socket close failed, %ld\n", Error ));
        }

        localInfo->Socket = INVALID_SOCKET;

        //
        // Reset the IP stack to send DHCP broadcast to first
        // uninitialized stack.
        //

        if (!IS_MDHCP_CTX(DhcpContext)) {
            Error1 = IPResetInterface(localInfo->IpInterfaceContext);
            // DhcpAssert( Error1 == ERROR_SUCCESS );
        }
    }

    return( Error );
}

BEGIN_EXPORT
DWORD                                             // status
UninitializeInterface(                            // close the scoket and unplumb the address
    IN OUT  PDHCP_CONTEXT          DhcpContext    // interface to unplumb
) END_EXPORT {
    DWORD                          Error;
    DWORD                          ReturnError;
    PLOCAL_CONTEXT_INFO            LocalInfo;

    if( IS_ADDRESS_UNPLUMBED(DhcpContext) ) {     // if address is not plumbed
        DhcpPrint((DEBUG_ASSERT,"UninitializeInterface:Already unplumbed\n"));
        return ERROR_SUCCESS;
    }

    LocalInfo = DhcpContext->LocalInformation;
    ReturnError = CloseDhcpSocket( DhcpContext );
    /*
     * If the adapter is unbound, there is no point to reset the IP.
     * The stack may re-use the IpInterfaceContext for other adapter.
     * We cannot depend on the order of the event, ie, the new adapter which
     * re-uses a context will be indicated to us later than the adapter which
     * is going away.
     */
    if (!IS_MEDIA_UNBOUND(DhcpContext)) {
        Error = IPResetIPAddress(                     // remove the address we got before
            LocalInfo->IpInterfaceContext,
            DhcpContext->SubnetMask
        );
    }

    if( Error != ERROR_SUCCESS ) ReturnError = Error;

    ADDRESS_UNPLUMBED(DhcpContext);
    if( ReturnError != ERROR_SUCCESS ) {
        DhcpPrint(( DEBUG_ERRORS,"UninitializeInterface:0x%ld\n", ReturnError));
    }

    return ReturnError;
}

BEGIN_EXPORT
DWORD                                             // status
InitializeInterface(                              // plumb address and open socket
    IN OUT  PDHCP_CONTEXT          DhcpContext    // context to initialize
) END_EXPORT {
    PLOCAL_CONTEXT_INFO            LocalInfo;
    DWORD                          Error;
    DWORD                          ReturnError;

    if( IS_ADDRESS_PLUMBED(DhcpContext) ) {       // if already plumbed, nothing to do
        DhcpPrint((DEBUG_ASSERT, "InitializeInterface:Already plumbed\n"));
        return ERROR_SUCCESS;
    }

    LocalInfo = DhcpContext->LocalInformation;
    ADDRESS_PLUMBED(DhcpContext);

    Error = IPSetIPAddress(                       // set new ip address, mask with ip
        LocalInfo->IpInterfaceContext,            // identify context
        DhcpContext->IpAddress,
        DhcpContext->SubnetMask
    );

    if( ERROR_SUCCESS != Error ) {                // if anything fails, got to be address conflict
        DhcpPrint((DEBUG_TRACK, "IPSetIPAddress %ld,%ld,%ld : 0x%lx\n",
            LocalInfo->IpInterfaceContext,
            DhcpContext->IpAddress, DhcpContext->SubnetMask,
            Error
        ));
        Error = ERROR_DHCP_ADDRESS_CONFLICT;
    } else {                                      // everything went fine, open the socket for future
        Error = OpenDhcpSocket( DhcpContext );
    }

    if( ERROR_SUCCESS != Error ) {
        DhcpPrint((DEBUG_ERRORS, "InitializeInterface:0x%lx\n", Error));
    }

    return Error;
}

HKEY
DhcpRegGetAltKey(
    IN LPCWSTR AdapterName
    )
/*++

Routine Description:
    Try to open the old format registry key for the adapter.

Arguments:
    AdapterName -- adapter device name (no \Device\.. prefix)

Return Value:
    NULL if key could not be opened..
    valid HKEY otherwise.

--*/
{
    HKEY AdapterKey, ReturnKey;
    ULONG Error;

    if( NULL == AdapterName ) return NULL;
    Error = RegOpenKeyEx(
        DhcpGlobalServicesKey,
        AdapterName,
        0 /* Reserved */,
        KEY_ALL_ACCESS,
        &AdapterKey
        );
    if( ERROR_SUCCESS != Error ) return NULL;

    Error = RegOpenKeyEx(
        AdapterKey,
        DHCP_ADAPTER_PARAMETERS_KEY_OLD,
        0 /* Reserved */,
        KEY_ALL_ACCESS,
        &ReturnKey
        );

    RegCloseKey(AdapterKey);
    if( ERROR_SUCCESS != Error ) return NULL;
    return ReturnKey;
}


#ifdef BOOTPERF
VOID
DhcpSaveQuickBootValuesToRegistry(
    IN PDHCP_CONTEXT DhcpContext,
    IN BOOL fDelete
    )
/*++

Routine Description:
    If quick boot is enabled for this interface as well as fDelete is
    not FALSE, then this routine will save the IP address, mask and
    lease time options to the registry.  Otherwise, it would delete
    these optiosn from the registry.

    This routine also checks to see if current time has gone past the
    T1 time and if so, it would clear the registry values..

Arguments:
    DhcpContext -- the context to do this for
    fDelete -- shoudl the values be deleted?

--*/
{
    ULONG Error;
    ULONG Now = (ULONG)time(NULL);
    ULONGLONG NtSysTime;

    //
    // Check if quick boot is enabled on the context,
    // if the context is dhcp enabled or not,
    // Check if we are past t1 time or lease expiration..
    //

    if( TRUE == fDelete ||
        FALSE == DhcpContext->fQuickBootEnabled ||
        IS_DHCP_DISABLED(DhcpContext) ||
        0 == DhcpContext->IpAddress ||
        ( IS_ADDRESS_DHCP(DhcpContext) &&
          ( Now >= (ULONG)DhcpContext->T2Time ||
            Now >= (ULONG)DhcpContext->LeaseExpires
              ) ) ) {
        fDelete = TRUE;
    }

    //
    // Now we know if we are going to delete the values
    // or create them.  If creating the values, we need to
    // save the lease time in NT system time format.
    //

    if( TRUE == fDelete ) {
        DhcpRegDeleteQuickBootValues(
            DhcpContext->AdapterInfoKey
            );
    } else {
        ULONG Diff;
        ULONGLONG Diff64;

        GetSystemTimeAsFileTime((FILETIME *)&NtSysTime);

        if( IS_ADDRESS_DHCP(DhcpContext) ) {
            Diff = ((ULONG)DhcpContext->T2Time) - Now;

            //DhcpAssert(Diff == DhcpContext->T2 );

            //
            // Now add the diff to the system time.
            // (Diff is in seconds. 10000*1000 times this is
            // in 100-nanoseconds like the file time)
            //
            Diff64 = ((ULONGLONG)Diff);
            Diff64 *= (ULONGLONG)10000;
            Diff64 *= (ULONGLONG)1000;
            NtSysTime += Diff64;
        } else {
            //
            // For autonet addresses, time is infinte
            //
            LARGE_INTEGER Li = {0,0};
            Li.HighPart = 0x7FFFFFF;
            Li.LowPart = 0xFFFFFFFF;
            NtSysTime = *(ULONGLONG*)&Li;
        }

        //
        // Now save the IP address, Mask and Lease time.
        // We will leave default gateways alone.
        //

        DhcpRegSaveQuickBootValues(
            DhcpContext->AdapterInfoKey,
            DhcpContext->IpAddress,
            DhcpContext->SubnetMask,
            NtSysTime
            );
    }
}
#endif BOOTPERF
BEGIN_EXPORT
DWORD                                             // win32 status
DhcpSetAllRegistryParameters(                     // update the registry completely
    IN      PDHCP_CONTEXT          DhcpContext,   // input context to save stuff
    IN      DHCP_IP_ADDRESS        ServerAddress  // which server is this about?
) END_EXPORT {
    DWORD                          i;
    DWORD                          Error;
    DWORD                          LastError;
    HKEY                           AltKey;
    PLOCAL_CONTEXT_INFO            LocalInfo;
    struct  /* anonymous */ {
        LPWSTR                     ValueName;     // where to store this in the registry?
        DWORD                      Value;         // what is the value to store
        DWORD                      RegValueType;  // dword or string?
    } DwordArray[] = {
        DHCP_IP_ADDRESS_STRING, DhcpContext->IpAddress, DHCP_IP_ADDRESS_STRING_TYPE,
        DHCP_SUBNET_MASK_STRING, DhcpContext->SubnetMask, DHCP_SUBNET_MASK_STRING_TYPE,
        DHCP_SERVER, ServerAddress, DHCP_SERVER_TYPE,
        DHCP_LEASE, DhcpContext->Lease, DHCP_LEASE_TYPE,
        DHCP_LEASE_OBTAINED_TIME, (DWORD) DhcpContext->LeaseObtained, DHCP_LEASE_OBTAINED_TIME_TYPE,
        DHCP_LEASE_T1_TIME, (DWORD) DhcpContext->T1Time, DHCP_LEASE_T1_TIME_TYPE,
        DHCP_LEASE_T2_TIME, (DWORD) DhcpContext->T2Time, DHCP_LEASE_T2_TIME_TYPE,
        DHCP_LEASE_TERMINATED_TIME, (DWORD) DhcpContext->LeaseExpires, DHCP_LEASE_TERMINATED_TIME_TYPE,
        //
        // Sentinel -- all values from below this won't get
        // save to fake AdapterKey (for Server Apps portability).
        //

        NULL, 0, REG_NONE,

        DHCP_IPAUTOCONFIGURATION_ADDRESS, DhcpContext->IPAutoconfigurationContext.Address, DHCP_IPAUTOCONFIGURATION_ADDRESS_TYPE,
        DHCP_IPAUTOCONFIGURATION_MASK, DhcpContext->IPAutoconfigurationContext.Mask, DHCP_IPAUTOCONFIGURATION_MASK_TYPE,
        DHCP_IPAUTOCONFIGURATION_SEED, DhcpContext->IPAutoconfigurationContext.Seed, DHCP_IPAUTOCONFIGURATION_SEED_TYPE,
        DHCP_ADDRESS_TYPE_VALUE, IS_ADDRESS_AUTO(DhcpContext)?ADDRESS_TYPE_AUTO:ADDRESS_TYPE_DHCP, DHCP_ADDRESS_TYPE_TYPE,
    };

    LocalInfo = ((PLOCAL_CONTEXT_INFO) DhcpContext->LocalInformation);
    LOCK_OPTIONS_LIST();
    Error = DhcpRegSaveOptions(                   // save the options info - ignore error
        &DhcpContext->RecdOptionsList,
        LocalInfo->AdapterName,
        DhcpContext->ClassId,
        DhcpContext->ClassIdLength
    );
    UNLOCK_OPTIONS_LIST();

    LastError = ERROR_SUCCESS;
    AltKey = DhcpRegGetAltKey(LocalInfo->AdapterName);
    for( i = 0; i < sizeof(DwordArray)/sizeof(DwordArray[0]); i ++ ) {
        if( REG_DWORD == DwordArray[i].RegValueType ) {
            Error = RegSetValueEx(
                DhcpContext->AdapterInfoKey,
                DwordArray[i].ValueName,
                0 /* Reserved */,
                REG_DWORD,
                (LPBYTE)&DwordArray[i].Value,
                sizeof(DWORD)
            );
            if( NULL != AltKey ) {
                (void)RegSetValueEx(
                    AltKey, DwordArray[i].ValueName,
                    0, REG_DWORD, (LPBYTE)&DwordArray[i].Value,
                    sizeof(DWORD)
                    );
            }
        } else if( REG_NONE == DwordArray[i].RegValueType ) {
            if( NULL != AltKey ) {
                RegCloseKey(AltKey);
                AltKey = NULL;
            }
        } else {
            Error = RegSetIpAddress(
                DhcpContext->AdapterInfoKey,
                DwordArray[i].ValueName,
                DwordArray[i].RegValueType,
                DwordArray[i].Value
            );
            if( NULL != AltKey ) {
                (void)RegSetIpAddress(
                    AltKey, DwordArray[i].ValueName,
                    DwordArray[i].RegValueType, DwordArray[i].Value
                    );
            }
        }

        if( ERROR_SUCCESS != Error ) {
            DhcpPrint((DEBUG_ERRORS,"SetAllRegistryParams:RegSetValueEx(%ws):0x%lx\n", DwordArray[i].ValueName,Error));
            LastError = Error;
        }
    }

    if( NULL != AltKey ) {
        RegCloseKey(AltKey);
        AltKey = NULL;
    }

#ifdef BOOTPERF
    DhcpSaveQuickBootValuesToRegistry(DhcpContext, FALSE);
#endif BOOTPERF

    return LastError;
}

DWORD                                             // win32 status
CheckForAddressConflict(                          // send ARP and see if the address conflicts..
    IN      DHCP_IP_ADDRESS        Address,       // address to send gratuitous ARP for..
    IN      ULONG                  nRetries       // how many attempts to do?
)
{
    DWORD       HwAddressBufDummy[20];            // HwAddress cant be larger than50*sizeof(DWORD)
    ULONG       HwAddressBufSize;
    DWORD       Error;

    if( 0 == Address ) return NO_ERROR;           // nothing to do if we are resetting address

    while( nRetries -- ) {                        // keep trying as many times are required..
        HwAddressBufSize = sizeof(HwAddressBufDummy);

        // even though src and dest addr are same below, tcpip discards the src address we give
        // here (it just uses it to find the interface to send on) and uses the addr of interface..
        Error = SendARP(                          // send an ARP Request
            Address,                              // destination address to ARP for
            Address,                              // dont use zero -- tcpip asserts, use same addres..
            HwAddressBufDummy,
            &HwAddressBufSize
        );
        if( ERROR_SUCCESS == Error && 0 != HwAddressBufSize ) {
            DhcpPrint((DEBUG_ERRORS, "Address conflict detected for RAS\n"));
            return ERROR_DHCP_ADDRESS_CONFLICT;   // some other client has got this address!!!!
        } else {
            DhcpPrint((DEBUG_ERRORS, "RAS stuff: SendARP returned 0x%lx\n", Error));
        }
    }

    return ERROR_SUCCESS;
}

BEGIN_EXPORT
DWORD                                             // status
SetDhcpConfigurationForNIC(                       // plumb registry, stack and notify clients
    IN OUT  PDHCP_CONTEXT          DhcpContext,   // input context to do work for
    IN      PDHCP_FULL_OPTIONS     DhcpOptions,   // options to plumb registry with
    IN      DHCP_IP_ADDRESS        Address,       // address to plumb stack with
    IN      DHCP_IP_ADDRESS        ServerAddress, // need to plumb registry
    IN      BOOL                   fNewAddress    // TRUE==>plumb stack, FALSE=> dont plumb stack
) END_EXPORT {
    DWORD                          Error;
    DWORD                          BoolError;
    DWORD                          LeaseTime;
    DWORD_PTR                          LeaseObtainedTime;
    DWORD_PTR                          LeaseExpiresTime;
    DWORD_PTR                          T1Time;
    DWORD_PTR                          T2Time;
    DWORD                          SubnetMask;
    LIST_ENTRY                     ExpiredOptions;
    PLOCAL_CONTEXT_INFO            LocalInfo;
    ULONG                          OldIp, OldMask;
    DWORD                          NotifyDnsCache(void);
    BOOLEAN                        fSomethingChanged = FALSE;
    LocalInfo = (PLOCAL_CONTEXT_INFO)DhcpContext->LocalInformation;

#ifdef BOOTPERF
    OldIp = LocalInfo->OldIpAddress;
    OldMask = LocalInfo->OldIpMask;

    LocalInfo->OldIpAddress = LocalInfo->OldIpMask = 0;

    if( Address && fNewAddress && OldIp && Address != OldIp
        && IS_ADDRESS_UNPLUMBED(DhcpContext) ) {
        //
        // If the first time the address is being set, and for some reason
        // the address being set is NOT the address we are trying to set,
        // then the machine already has an IP.  Bad Bad thing.
        // So, we just reset the old IP to avoid spurious address conflict
        // errors..
        //
        Error = IPResetIPAddress(
            LocalInfo->IpInterfaceContext, DhcpContext->SubnetMask
            );
    }
#endif BOOTPERF

    InitializeListHead(&ExpiredOptions);
    DhcpGetExpiredOptions(&DhcpContext->RecdOptionsList, &ExpiredOptions);
    LOCK_OPTIONS_LIST();
    Error = DhcpDestroyOptionsList(&ExpiredOptions, &DhcpGlobalClassesList);
    UNLOCK_OPTIONS_LIST();
    DhcpAssert(ERROR_SUCCESS == Error);

    if( Address && (DWORD)-1 == ServerAddress )   // mark address type as auto or dhcp..
        ACQUIRED_AUTO_ADDRESS(DhcpContext);
    else ACQUIRED_DHCP_ADDRESS(DhcpContext);

    SubnetMask = ntohl(DhcpDefaultSubnetMask(Address));
    if( IS_ADDRESS_AUTO(DhcpContext) ) {
        LeaseTime = 0;
    } else {
        LeaseTime = htonl(DHCP_MINIMUM_LEASE);
    }

    T1Time = 0;
    T2Time = 0;
    if( DhcpOptions && DhcpOptions->SubnetMask ) SubnetMask = *(DhcpOptions->SubnetMask);
    if( DhcpOptions && DhcpOptions->LeaseTime) LeaseTime = *(DhcpOptions->LeaseTime);
    if( DhcpOptions && DhcpOptions->T1Time) T1Time = *(DhcpOptions->T1Time);
    if( DhcpOptions && DhcpOptions->T2Time) T2Time = *(DhcpOptions->T2Time);

    LeaseTime = ntohl(LeaseTime);
    LeaseObtainedTime = time(NULL);
    if( 0 == T1Time ) T1Time = LeaseTime/2;
    else {
        T1Time = ntohl((DWORD) T1Time);
        DhcpAssert(T1Time < LeaseTime);
    }

    T1Time += LeaseObtainedTime;
    if( T1Time < LeaseObtainedTime ) T1Time = INFINIT_TIME;

    if( 0 == T2Time ) T2Time = LeaseTime * 7/8;
    else {
        T2Time = ntohl((DWORD)T2Time);
        DhcpAssert(T2Time < DhcpContext->Lease );
        DhcpAssert(T2Time > T1Time - LeaseObtainedTime);
    }
    T2Time += LeaseObtainedTime;
    if( T2Time < LeaseObtainedTime ) T2Time = INFINIT_TIME;

    LeaseExpiresTime = LeaseObtainedTime + LeaseTime;
    if( LeaseExpiresTime < LeaseObtainedTime ) LeaseExpiresTime = INFINIT_TIME;

    if( IS_ADDRESS_AUTO(DhcpContext) ) {
        LeaseExpiresTime = INFINIT_TIME;
        // DhcpContext->IPAutoconfigurationContext.Address = 0;
    }

    if( IS_ADDRESS_DHCP(DhcpContext) ) {
        DhcpContext->DesiredIpAddress = Address? Address : DhcpContext->IpAddress;
        DhcpContext->SubnetMask = SubnetMask;
        DhcpContext->IPAutoconfigurationContext.Address = 0;
    }
    DhcpContext->IpAddress = Address;
    DhcpContext->Lease = LeaseTime;
    DhcpContext->LeaseObtained = LeaseObtainedTime;
    DhcpContext->T1Time = T1Time;
    DhcpContext->T2Time = T2Time;
    DhcpContext->LeaseExpires = LeaseExpiresTime;

    if( IS_APICTXT_ENABLED(DhcpContext) ) {       // dont do anything when called thru lease api's for RAS
        if( IS_ADDRESS_DHCP(DhcpContext) ) {      // dont do any conflict detection for dhcp addresses..
            return ERROR_SUCCESS;
        }

        Error = CheckForAddressConflict(Address,2);
        if( ERROR_SUCCESS != Error ) {            // address did conflict with something
            DhcpPrint((DEBUG_ERRORS, "RAS AddressConflict: 0x%lx\n", Error));
            return Error;
        }
        return ERROR_SUCCESS;
    }

    if( DhcpIsInitState(DhcpContext) && 
        (Address == 0 || IS_FALLBACK_DISABLED(DhcpContext)) )
    {    // lost address, lose options
        Error = DhcpClearAllOptions(DhcpContext);
    }

    /*
     * Check if something is changed before the registry is overwritten
     */
    if (!fNewAddress) {
        fSomethingChanged = DhcpRegIsOptionChanged(    // Check if something is really changed
            &DhcpContext->RecdOptionsList,
            LocalInfo->AdapterName,
            DhcpContext->ClassId,
            DhcpContext->ClassIdLength
        );
    } else {
        fSomethingChanged = TRUE;
    }

    Error = DhcpSetAllRegistryParameters(         // save all the registry parameters
        DhcpContext,
        ServerAddress
    );

    if( fNewAddress && 0 == DhcpContext->IpAddress ) {
        Error = DhcpSetAllStackParameters(        // reset all stack parameters, and also DNS
            DhcpContext,
            DhcpOptions
        );
    }

    if( !fNewAddress ) {                          // address did not change, but ask NetBT to read from registry
        NetBTNotifyRegChanges(LocalInfo->AdapterName);
    } else {                                      // address change -- reset the stack
        Error = UninitializeInterface(DhcpContext);
        if(ERROR_SUCCESS != Error ) return Error;

        if( Address ) {
            Error = InitializeInterface(DhcpContext);
            if( ERROR_SUCCESS != Error) return Error;
        }
        BoolError = PulseEvent(DhcpGlobalNewIpAddressNotifyEvent);
        if (FALSE == BoolError) {
            DhcpPrint((DEBUG_ERRORS, "PulseEvent failed: 0x%lx\n", GetLastError()));
            DhcpAssert(FALSE);
        }
    }

    if( !fNewAddress || 0 != DhcpContext->IpAddress ) {
        Error = DhcpSetAllStackParameters(        // reset all stack parameters, and also DNS
            DhcpContext,
            DhcpOptions
        );
    }

    NotifyDnsCache();

    if (fSomethingChanged) {
        NLANotifyDHCPChange();
    }

    return Error;
}

BEGIN_EXPORT
DWORD                                             // win32 status
SetAutoConfigurationForNIC(                       // autoconfigured address-set dummy options before calling SetDhcp..
    IN OUT  PDHCP_CONTEXT          DhcpContext,   // the context to set info for
    IN      DHCP_IP_ADDRESS        Address,       // autoconfigured address
    IN      DHCP_IP_ADDRESS        Mask           // input mask
) END_EXPORT 
{
    DWORD Error = ERROR_SUCCESS;
    PDHCP_OPTIONS pOptions = NULL;

    if (Address != 0 && IS_FALLBACK_ENABLED(DhcpContext))
    {
        // we rely that DhcpAllocateMemory is using
        // calloc() hence zeroes all the structure
        pOptions = DhcpAllocateMemory(sizeof (DHCP_OPTIONS));
        if (pOptions == NULL)
            return ERROR_NOT_ENOUGH_MEMORY;

        // replace DhcpContext->RecdOptionsList w/ FbOptionsList
        // and filter out the fallback IpAddress & SubnetMask
        Error = DhcpCopyFallbackOptions(DhcpContext, &Address, &Mask);

        // pOptions->SubnetMask has to point to the fallback mask address
        // it is safe to get pOptions->SubnetMask to point to a local variable
        // since pOptions will not live more than Mask.
        pOptions->SubnetMask = &Mask;
    }

    // if no error has been hit so far go further and try to 
    // plumb in the autonet/fallback configuration.
    if (Error == ERROR_SUCCESS)
    {
        DhcpContext->SubnetMask = Mask;
        Error = SetDhcpConfigurationForNIC(
            DhcpContext,
            pOptions,
            Address,
            (DWORD)-1,
            TRUE
        );
    }

    if (pOptions != NULL)
        DhcpFreeMemory(pOptions);

    return Error;
}

DWORD
SystemInitialize(
    VOID
    )
/*++

Routine Description:

    This function performs implementation specific initialization
    of DHCP.

Arguments:

    None.

Return Value:

    The status of the operation.

--*/
{
    DWORD Error;

    HKEY OptionInfoKey = NULL;
    DHCP_KEY_QUERY_INFO QueryInfo;
    DWORD OptionInfoSize;
    DWORD Index;

#if 0
    PLIST_ENTRY listEntry;
    PDHCP_CONTEXT dhcpContext;
#endif

    DWORD Version;

    //
    // Init Global variables.
    //

    DhcpGlobalOptionCount = 0;
    DhcpGlobalOptionInfo = NULL;
    DhcpGlobalOptionList = NULL;

    //
    // Seed the random number generator for Transaction IDs.
    //

    srand( (unsigned int) time( NULL ) );

    //
    // make host comment, windows' version.
    //

    DhcpGlobalHostComment = DhcpAllocateMemory( HOST_COMMENT_LENGTH );

    if( DhcpGlobalHostComment == NULL ) {
        Error = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    Version = GetVersion();
    sprintf( DhcpGlobalHostComment, "%s %d.%d, BUILD %d",
                ((Version & 0x80000000) ? WINDOWS_32S : WINDOWS_NT),
                    Version & 0xFF,
                        (Version >> 8) & 0xFF,
                            ((Version >> 16) & 0x7FFF) );

    //
    // Obtain a handle to the message file.
    //

    DhcpGlobalMessageFileHandle = LoadLibrary( DHCP_SERVICE_DLL );

    //
    // Register for global machine domain name changes.
    //

    DhcpLsaDnsDomChangeNotifyHandle = CreateEvent(NULL, FALSE, FALSE, NULL);
    if( NULL == DhcpLsaDnsDomChangeNotifyHandle ) {
        Error = GetLastError();
        goto Cleanup;
    }

    Error = LsaRegisterPolicyChangeNotification(
        PolicyNotifyDnsDomainInformation,
        DhcpLsaDnsDomChangeNotifyHandle
        );
    Error = LsaNtStatusToWinError(Error);

    if( ERROR_SUCCESS != Error ) {
        DhcpPrint((DEBUG_INIT, "LsaRegisterPolicyChangeNotification failed %lx\n", Error));
        goto Cleanup;
    }

    Error = ERROR_SUCCESS;

    // Start DNS Thread now..

    if( UseMHAsyncDns ) {
        Error = DnsAsyncRegisterInit(NULL);

        // If we could not start Async Dns.. do not try to quit it.

        if( ERROR_SUCCESS != Error ) UseMHAsyncDns = 0;

        //
        // ignore any Dns register init errors..
        //

        Error = ERROR_SUCCESS;
    }


Cleanup:

    return( Error );
}



DWORD
DhcpInitData(
    VOID
    )
/*++

Routine Description:

    This function initializes DHCP Global data.

Arguments:

    None.

Return Value:

    Windows Error.

--*/
{
    DWORD Error;

    DhcpGlobalMessageFileHandle = NULL;
    DhcpGlobalRecomputeTimerEvent = NULL;
    DhcpGlobalTerminateEvent = NULL;
    DhcpGlobalClientApiPipe = NULL;
    DhcpGlobalClientApiPipeEvent = NULL;
    UseMHAsyncDns = DEFAULT_USEMHASYNCDNS;

    DhcpGlobalHostComment = NULL;
    DhcpGlobalNewIpAddressNotifyEvent = NULL;

    InitializeListHead( &DhcpGlobalNICList );
    InitializeListHead( &DhcpGlobalRenewList );


    DhcpGlobalMsgPopupThreadHandle = NULL;
    DhcpGlobalDisplayPopup = TRUE;

    DhcpGlobalParametersKey = NULL;
    DhcpGlobalTcpipParametersKey = NULL;
    DhcpGlobalServicesKey = NULL;

    UseMHAsyncDns = DEFAULT_USEMHASYNCDNS;
    AutonetRetriesSeconds = EASYNET_ALLOCATION_RETRY;
    DhcpGlobalUseInformFlag = TRUE;
    DhcpGlobalDontPingGatewayFlag = FALSE;
    DhcpGlobalIsShuttingDown = FALSE;

#ifdef BOOTPERF
    DhcpGlobalQuickBootEnabledFlag = TRUE;
#endif BOOTPERF

    //
    // init service status data.
    //

    DhcpGlobalServiceStatus.dwServiceType = SERVICE_WIN32_OWN_PROCESS;
    DhcpGlobalServiceStatus.dwCurrentState = SERVICE_START_PENDING;
    DhcpGlobalServiceStatus.dwControlsAccepted = (
        SERVICE_ACCEPT_STOP |
        SERVICE_ACCEPT_SHUTDOWN
        );

    DhcpGlobalServiceStatus.dwCheckPoint = 1;
    DhcpGlobalServiceStatus.dwWaitHint = 25000;
    // should be larger than the wait before the last retry.

    DhcpGlobalServiceStatus.dwWin32ExitCode = ERROR_SUCCESS;
    DhcpGlobalServiceStatus.dwServiceSpecificExitCode = 0;

    //
    // Initialize dhcp to receive service requests by registering the
    // control Handler.
    //


    DhcpGlobalServiceStatusHandle = RegisterServiceCtrlHandlerEx(
                                      SERVICE_DHCP,
                                      ServiceControlHandler,
                                      NULL );
    if ( DhcpGlobalServiceStatusHandle == 0 ) {
        Error = GetLastError();
        DhcpPrint(( DEBUG_INIT,
            "RegisterServiceCtrlHandlerW failed, %ld.\n", Error ));
        //return(Error);
    }

    //
    // Tell Service Controller that we are start pending.
    //

    UpdateStatus();

    Error = DhcpInitRegistry();
    if( ERROR_SUCCESS != Error ) goto Cleanup;

    // create the waitable timer.
    DhcpGlobalWaitableTimerHandle = CreateWaitableTimer(
                                        NULL,
                                        FALSE,
                                        NULL );

    if( DhcpGlobalWaitableTimerHandle == NULL ) {
        Error = GetLastError();
        goto Cleanup;
    }

    DhcpGlobalRecomputeTimerEvent =
        CreateEvent(
            NULL,       // no security.
            FALSE,      // automatic reset.
            TRUE,       // initial state is signaled.
            NULL );     // no name.


    if( DhcpGlobalRecomputeTimerEvent == NULL ) {
        Error = GetLastError();
        goto Cleanup;
    }

    DhcpGlobalTerminateEvent =
        CreateEvent(
            NULL,       // no security.
            TRUE,       // manual reset
            FALSE,      // initial state is signaled.
            NULL );     // no name.


    if( DhcpGlobalTerminateEvent == NULL ) {
        Error = GetLastError();
        goto Cleanup;
    }

    //
    // create a named event that notifies the ip address changes to
    // external apps.
    //

    DhcpGlobalNewIpAddressNotifyEvent = DhcpOpenGlobalEvent();

    if( DhcpGlobalNewIpAddressNotifyEvent == NULL ) {
        Error = GetLastError();
        goto Cleanup;
    }


    Error = DhcpApiInit();

    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }

    Error = ERROR_SUCCESS;



Cleanup:

    if( Error != ERROR_SUCCESS ) {
        DhcpPrint(( DEBUG_ERRORS, "DhcpInitData failed, %ld.\n", Error ));
    }

    return( Error );
}

BOOL
DhcpDoReleaseOnShutDown(
    IN PDHCP_CONTEXT DhcpContext
)
/*++

Routine Description:
    This routine checks to see if the context has release on
    shutdown enabled.

    Release on shutdown is enabled if either deliberately enabled
    via the registry.  It is disabled if deliberately disabled
    via the registry.  If neither, then the vendor option is searched
    for to see if the particular option is present.  If present,
    then the value in that is used.  If not present, then this is
    not considered enabled.

Return Value:
    TRUE -- Release on shutdown enabled.
    FALSE -- Release on shutdown disabled.

--*/
{
    BOOL fFound;
    DWORD Result;

    if( DhcpContext->ReleaseOnShutdown != RELEASE_ON_SHUTDOWN_OBEY_DHCP_SERVER ) {
        //
        // The user deliberately specified the behaviour.  Do as instructed.
        //
        return DhcpContext->ReleaseOnShutdown != RELEASE_ON_SHUTDOWN_NEVER;
    }

    //
    // Need to do as requested by the server.  In this case, need to
    // look for vendor option
    //

    fFound = DhcpFindDwordOption(
        DhcpContext,
        OPTION_MSFT_VENDOR_FEATURELIST,
        TRUE,
        &Result
        );
    if( fFound ) {
        //
        // Found the option? then do what the server specified.
        //
        return (
            (Result & BIT_RELEASE_ON_SHUTDOWN) == BIT_RELEASE_ON_SHUTDOWN
            );
    }

    //
    // Didn't find the option.  By default, we have this turned off.
    //
    return FALSE;
}

VOID
DhcpCleanup(
    DWORD Error
    )
/*++

Routine Description:

    This function cleans up DHCP Global data before stopping the
    service.

Arguments:

    None.

Return Value:

    Windows Error.

--*/
{
    DWORD    WaitStatus;

    DhcpPrint(( DEBUG_MISC,
        "Dhcp Client service is shutting down, %ld.\n", Error ));

    if( Error != ERROR_SUCCESS ) {

        DhcpLogEvent( NULL, EVENT_DHCP_SHUTDOWN, Error );
    }

    //
    // Service is shuting down, may be due to some service problem or
    // the administrator is stopping the service. Inform the service.
    //

    DhcpGlobalServiceStatus.dwCurrentState = SERVICE_STOP_PENDING;
    DhcpGlobalServiceStatus.dwCheckPoint = 0;
    UpdateStatus();

    if( FALSE == DhcpGlobalWinSockInitialized ||
        FALSE == Initialized ) {
        goto Done;
    }

    DhcpGlobalServiceRunning = FALSE;

    if( FALSE == DhcpGlobalIsShuttingDown ) {
        if( NULL != DhcpGlobalMediaSenseHandle ) {
            // MediaSenseDetectionLoop can do discovers, etc.  That has to die before
            // any other data is killed
            WaitStatus = WaitForSingleObject( DhcpGlobalMediaSenseHandle, 3000 );
            if( WAIT_OBJECT_0 != WaitStatus ) {
                // Should have completed by now.  Since it did not, kill it!
                if( TerminateThread( DhcpGlobalMediaSenseHandle, (DWORD)-1) ) {
                    DhcpPrint((DEBUG_ERRORS, "MediaSenseDetectionLoop killed!\n"));
                } else {
                    DhcpPrint((DEBUG_ERRORS, "Could not kill MediaSense Loop: %ld\n", GetLastError()));
                }
            }
            CloseHandle(DhcpGlobalMediaSenseHandle);
            DhcpGlobalMediaSenseHandle = NULL;
        }

        if ( NULL != DhcpGlobalWaitableTimerHandle ) {
            DhcpCancelWaitableTimer( DhcpGlobalWaitableTimerHandle );
            CloseHandle( DhcpGlobalWaitableTimerHandle );
            DhcpGlobalWaitableTimerHandle = NULL;
        }
    }

    if( FALSE == DhcpGlobalIsShuttingDown ) {
        if( NULL != DhcpLsaDnsDomChangeNotifyHandle ) {
            LsaUnregisterPolicyChangeNotification(
                PolicyNotifyDnsDomainInformation,
                DhcpLsaDnsDomChangeNotifyHandle
                );
            CloseHandle(DhcpLsaDnsDomChangeNotifyHandle);
            DhcpLsaDnsDomChangeNotifyHandle = NULL;
        }
    }

    LOCK_RENEW_LIST();
    while( !IsListEmpty(&DhcpGlobalNICList) ) {
        PLIST_ENTRY NextEntry;
        PDHCP_CONTEXT DhcpContext;
        DWORD DefaultSubnetMask;
        PLOCAL_CONTEXT_INFO LocalInfo;
        DWORD   LocalError;


        NextEntry = RemoveHeadList(&DhcpGlobalNICList);

        DhcpContext = CONTAINING_RECORD( NextEntry, DHCP_CONTEXT, NicListEntry );
        InitializeListHead(&DhcpContext->NicListEntry);
        RemoveEntryList( &DhcpContext->RenewalListEntry );
        InitializeListHead( &DhcpContext->RenewalListEntry );
        LocalInfo = DhcpContext->LocalInformation;

        DefaultSubnetMask = DhcpDefaultSubnetMask(0);

        //
        // Close the semaphore handle after first acquiring it
        //

        if( FALSE == DhcpGlobalIsShuttingDown ) {

            UNLOCK_RENEW_LIST();
            DhcpAssert( NULL != DhcpContext->RenewHandle);
            LocalError = WaitForSingleObject(DhcpContext->RenewHandle, INFINITE);
            DhcpAssert( WAIT_OBJECT_0 == LocalError);

            //
            // There may be other threads waiting on this, but nevermind..
            // DhcpAssert(1 == DhcpContext->RefCount);
            //
            CloseHandle(DhcpContext->RenewHandle);
            DhcpContext->RenewHandle = NULL;
            if (DhcpContext->CancelEvent != WSA_INVALID_EVENT) {
                WSACloseEvent(DhcpContext->CancelEvent);
                DhcpContext->CancelEvent = WSA_INVALID_EVENT;
            }
            LOCK_RENEW_LIST();
        }

        //
        // reset the stack since dhcp is going away and we dont want IP to keep
        // using an expired address if we are not brought back up
        //
        if ( IS_DHCP_ENABLED(DhcpContext) ) {

            if( TRUE == DhcpGlobalIsShuttingDown
                && !DhcpIsInitState(DhcpContext)
                && DhcpDoReleaseOnShutDown(DhcpContext) ) {
                //
                // Shutting down.  Check if Release On Shutdown is enabled
                // For the adapter in question.  If so, then do it.
                //
                LocalError = ReleaseIpAddress(DhcpContext);
                if( ERROR_SUCCESS != LocalError ) {
                    DhcpPrint((DEBUG_ERRORS, "ReleaseAddress failed: %ld\n"));
                }
            }

        }

        if( FALSE == DhcpGlobalIsShuttingDown ) {
            if( 0 == InterlockedDecrement(&DhcpContext->RefCount) ) {
                //
                // Ok, we lost the context.. Just free it now..
                //
                DhcpDestroyContext(DhcpContext);
            }
        }
    }
    UNLOCK_RENEW_LIST();

    if( FALSE == DhcpGlobalIsShuttingDown ) {
        DhcpCleanupParamChangeRequests();
    }

    if( DhcpGlobalMsgPopupThreadHandle != NULL ) {
        DWORD WaitStatus;

        WaitStatus = WaitForSingleObject(
                       DhcpGlobalMsgPopupThreadHandle,
                       0 );

        if ( WaitStatus == 0 ) {

            //
            // This shouldn't be a case, because we close this handle at
            // the end of popup thread.
            //

            DhcpAssert( WaitStatus == 0 );

            CloseHandle( DhcpGlobalMsgPopupThreadHandle );
            DhcpGlobalMsgPopupThreadHandle = NULL;

        } else {

            DhcpPrint((DEBUG_ERRORS,
                "Cannot WaitFor message popup thread: %ld\n",
                    WaitStatus ));

            if( TerminateThread(
                    DhcpGlobalMsgPopupThreadHandle,
                    (DWORD)(-1)) == TRUE) {

                DhcpPrint(( DEBUG_ERRORS, "Terminated popup Thread.\n" ));
            }
            else {
                DhcpPrint(( DEBUG_ERRORS,
                    "Can't terminate popup Thread %ld.\n",
                        GetLastError() ));
            }
        }
    }

    if( FALSE == DhcpGlobalIsShuttingDown ) {
        DhcpApiCleanup();

        if( DhcpGlobalOptionInfo != NULL) {
            DhcpFreeMemory( DhcpGlobalOptionInfo );
            DhcpGlobalOptionInfo = NULL;
        }

        if( DhcpGlobalOptionList != NULL) {
            DhcpFreeMemory( DhcpGlobalOptionList );
            DhcpGlobalOptionList = NULL;
        }

        if( DhcpGlobalMessageFileHandle != NULL ) {
            FreeLibrary( DhcpGlobalMessageFileHandle );
            DhcpGlobalMessageFileHandle = NULL;
        }

        if( DhcpGlobalTerminateEvent != NULL ) {
            CloseHandle( DhcpGlobalTerminateEvent );
            DhcpGlobalTerminateEvent = NULL;
        }

        if( DhcpGlobalNewIpAddressNotifyEvent != NULL ) {
            CloseHandle( DhcpGlobalNewIpAddressNotifyEvent );
            DhcpGlobalNewIpAddressNotifyEvent = NULL;
        }

        if( DhcpGlobalRecomputeTimerEvent != NULL ) {
            CloseHandle( DhcpGlobalRecomputeTimerEvent );
            DhcpGlobalRecomputeTimerEvent = NULL;
        }
    }

    if( UseMHAsyncDns && FALSE == DhcpGlobalIsShuttingDown ) {
        DWORD Error = DnsAsyncRegisterTerm();
        if(ERROR_SUCCESS != Error) {
            DhcpPrint((DEBUG_ERRORS, "DnsTerm: %ld\n", Error));
        }
    }

Done:

#if DBG
    if (NULL != DhcpGlobalDebugFile) {
        CloseHandle(DhcpGlobalDebugFile);
        DhcpGlobalDebugFile = NULL;
    }
#endif

    //
    // stop winsock.
    //
    if( DhcpGlobalWinSockInitialized == TRUE ) {
        WSACleanup();
        DhcpGlobalWinSockInitialized = FALSE;
    }

    DhcpGlobalServiceStatus.dwCurrentState = SERVICE_STOPPED;
    DhcpGlobalServiceStatus.dwWin32ExitCode = Error;
    DhcpGlobalServiceStatus.dwServiceSpecificExitCode = 0;

    DhcpGlobalServiceStatus.dwCheckPoint = 0;
    DhcpGlobalServiceStatus.dwWaitHint = 0;
    UpdateStatus();

    return;
}

typedef struct _DHCP_THREAD_CTXT {                // params to the thread
    HANDLE                         Handle;        // semaphore handle
    PDHCP_CONTEXT                  DhcpContext;
} DHCP_THREAD_CTXT, *PDHCP_THREAD_CTXT;

DWORD                                             // status
DhcpRenewThread(                                  // renew the context
    IN OUT  PDHCP_THREAD_CTXT      ThreadCtxt     // the context to run...
)
{
    DWORD                          Error;         // return value

    srand((ULONG)(                                 // set the per-thread rand seed
        time(NULL) + (ULONG_PTR)ThreadCtxt
        ));

    DhcpAssert( NULL != ThreadCtxt && NULL != ThreadCtxt->Handle );
    DhcpPrint((DEBUG_TRACE, ".. Getting RenewHandle %d ..\n",ThreadCtxt->Handle));
    Error = WaitForSingleObject(ThreadCtxt->Handle, INFINITE);
    if( WAIT_OBJECT_0 != Error ) {                // could happen if this context just disappeared
        Error = GetLastError();
        DhcpPrint((DEBUG_ERRORS, "WaitForSingleObject: %ld\n", Error));
        DhcpAssert(FALSE);                        // not that likely is it?

        if( 0 == InterlockedDecrement(&ThreadCtxt->DhcpContext->RefCount) ) {
            DhcpDestroyContext(ThreadCtxt->DhcpContext);
        }
    } else {
        Error = ERROR_SUCCESS;

        DhcpPrint((DEBUG_TRACE, "[-- Acquired RenewHandle %d --\n",ThreadCtxt->Handle));

        if( 1 == ThreadCtxt->DhcpContext->RefCount ) {
            //
            // Last reference to this context.  No need to do any refresh.
            //
            DhcpAssert(IsListEmpty(&ThreadCtxt->DhcpContext->NicListEntry));
        } else if( IS_DHCP_ENABLED(ThreadCtxt->DhcpContext)) {
            //
            // Perform this only on DHCP enabled interfaces.
            // It is possible that the interface got converted to static
            // when the thread was waiting for it.
            //
            Error =  ThreadCtxt->DhcpContext->RenewalFunction(ThreadCtxt->DhcpContext,NULL);
        }
        DhcpPrint((DEBUG_TRACE, "-- Releasing RenewHandle %d --]\n",ThreadCtxt->Handle));

        //
        // Do this while we still hold the semaphore to synchronize the access to the registry
        //
        if( 0 == InterlockedDecrement(&ThreadCtxt->DhcpContext->RefCount) ) {
            DhcpDestroyContext(ThreadCtxt->DhcpContext);
        } else {
            BOOL    BoolError;

            BoolError = ReleaseSemaphore(ThreadCtxt->Handle, 1, NULL);
            DhcpPrint((DEBUG_TRACE, ".. Released RenewHandle %d ..\n", ThreadCtxt->Handle));
            DhcpAssert( FALSE != BoolError );
        }
    }

    DhcpFreeMemory(ThreadCtxt);
    return Error;
}

DWORD                                             // Status
DhcpCreateThreadAndRenew(                         // renew in a separate thread
    IN OUT  PDHCP_CONTEXT          DhcpContext    // the context to renew
)
{
    DWORD                          Error;         // return value
    HANDLE                         RenewThread;
    DWORD                          Unused;
    BOOL                           BoolError;
    PDHCP_THREAD_CTXT              ThreadCtxt;

    ThreadCtxt = DhcpAllocateMemory(sizeof(DHCP_THREAD_CTXT));
    if( NULL == ThreadCtxt ) {
        DhcpPrint((DEBUG_ERRORS, "DhcpCreateThreadAndRenew:Alloc:NULL\n"));
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    ThreadCtxt->Handle = DhcpContext->RenewHandle;
    ThreadCtxt->DhcpContext = DhcpContext;
    InterlockedIncrement(&DhcpContext->RefCount);
    DhcpPrint((DEBUG_TRACE, "Creating thread in DhcpCreateThreadAndRenew\n"));

    RenewThread = CreateThread(                   // thread that does the real renew
        NULL,                                     // no securtiy
        0,                                        // default process stack size
        (LPTHREAD_START_ROUTINE) DhcpRenewThread, // the function to start off with
        (LPVOID) ThreadCtxt,                      // the only parameter to the function
        0,                                        // start the other thread right away
        &Unused                                   // Dont care about thread id
    );

    if( NULL == RenewThread) {                    // create thread failed for some reason
        Error = GetLastError();
        DhcpPrint((DEBUG_ERRORS, "CreateThread(DhcpCreateThreadAndRenew): %ld\n", Error));
        if( ERROR_NOT_ENOUGH_MEMORY != Error && ERROR_NO_SYSTEM_RESOURCES != Error ) {
            // DhcpAssert(FALSE);                 // this assert is bothering lots of ppl
        }
        DhcpFreeMemory(ThreadCtxt);
        if( 0 == InterlockedDecrement(&DhcpContext->RefCount) ) {
            DhcpDestroyContext(DhcpContext);
        }
        return Error;
    }

    BoolError = CloseHandle(RenewThread);         // Dont need the handle, close it
    return ERROR_SUCCESS;
}

VOID
HandleFailedRenewals(
    VOID
    )
/*++

Routine Description:
    This routine handles all contexts that have failed to
    create a separate thread to renew... by doing the renewal
    inline.  Note that if several contexts have this problem,
    then this may take a long time.

    The algorithm used is to walk the list of all contexts,
    looking for one which has failed renewal.  If none found,
    the routine returns.  If anything found, then an inline renewal
    is attempted.

--*/
{
    ULONG Error, BoolError;
    PDHCP_CONTEXT DhcpContext;
    PLIST_ENTRY List;

    while( TRUE ) {
        BOOL bFound = FALSE;

        //
        // Find a desirable context.
        //
        LOCK_RENEW_LIST();

        for( List = DhcpGlobalNICList.Flink;
             List != &DhcpGlobalNICList;
             List = List->Flink
            ) {

            DhcpContext = CONTAINING_RECORD(
                List, DHCP_CONTEXT, NicListEntry
                );

            //
            // if not failed renewal give up.
            //
            if( FALSE == DhcpContext->bFailedRenewal ) {
                continue;
            }

            DhcpContext->bFailedRenewal = FALSE;

            //
            // if not DHCP enabled give up.
            //
            if( IS_DHCP_DISABLED(DhcpContext)) {
                continue;
            }

            //
            // If list entry is not empty, ignore
            //
            if( !IsListEmpty(&DhcpContext->RenewalListEntry) ) {
                continue;
            }

            //
            // Got a context, break!
            //
            bFound = TRUE;
            InterlockedIncrement(&DhcpContext->RefCount);
            break;
        }

        UNLOCK_RENEW_LIST();

        //
        // If no contexts, quit
        //
        if( FALSE == bFound ) return;

        //
        // Acquire context and perform renewal
        //
        Error = WaitForSingleObject(DhcpContext->RenewHandle, INFINITE);
        if( WAIT_OBJECT_0 != Error ) {
            Error = GetLastError();
            DhcpPrint((DEBUG_ERRORS, "WaitForSingleObject: 0x%lx\n", Error));
            DhcpAssert(FALSE);
        } else {
            Error = ERROR_SUCCESS;

            if( 1 == DhcpContext->RefCount ) {
                //
                // Last reference to this context?
                //
                DhcpAssert(IsListEmpty(&DhcpContext->NicListEntry));
            } else if ( IS_DHCP_ENABLED(DhcpContext) ) {
                //
                // Work only for DHCP enabled contexts.
                //
                Error = DhcpContext->RenewalFunction(DhcpContext, NULL);
            }
            BoolError = ReleaseSemaphore(DhcpContext->RenewHandle, 1, NULL);
            DhcpAssert(FALSE != BoolError );
        }

        if( 0 == InterlockedDecrement(&DhcpContext->RefCount) ) {
            //
            // Last reference went away..
            //
            DhcpDestroyContext(DhcpContext);
        }

    }

    //
    // dead code.
    //
    DhcpAssert(FALSE);
}

DWORD                                             // win32 status; returns only on STOP of dhcp
ProcessDhcpRequestForever(                        // process renewal requests and api requests
    IN      DWORD                  TimeToSleep    // initial time to sleep
) {
#define TERMINATE_EVENT     0
#define TIMER_EVENT         1
#define PIPE_EVENT          2
#define GLOBAL_DOM_CHANGE   3

#define EVENT_COUNT         4

    HANDLE                         WaitHandle[EVENT_COUNT];
    DWORD                          LocalTimeToSleep = TimeToSleep;
    DWORD                          ElapseTime;
    LIST_ENTRY                     CurrentRenewals;
    DWORD                          ResumeTime;
    DWORD                          Length, BoolError;
    BOOL                           bFailedRenewal;

    //  Wait and Process the following work items:
    //
    //      1. Wait for Timer recompute event for Client renewal.
    //      2. DHCP Client APIs.

    WaitHandle[TIMER_EVENT] = DhcpGlobalRecomputeTimerEvent;
    WaitHandle[PIPE_EVENT] = DhcpGlobalClientApiPipeEvent;
    WaitHandle[TERMINATE_EVENT] = DhcpGlobalTerminateEvent;
    WaitHandle[GLOBAL_DOM_CHANGE] = DhcpLsaDnsDomChangeNotifyHandle;

    DhcpGlobalDoRefresh = 0;
    ResumeTime = 0;
    bFailedRenewal = FALSE;
    for(;;) {

        DWORD Waiter;
        DWORD SleepTimeMsec;

        if( INFINITE == LocalTimeToSleep ) {
            SleepTimeMsec = INFINITE;
        } else {
            SleepTimeMsec = LocalTimeToSleep * 1000;
            if( SleepTimeMsec < LocalTimeToSleep ) {
                SleepTimeMsec = INFINITE ;
            }
        }

        // There is a flaw in the way resume is done below in that if the machine
        // suspends while we are actually doing dhcp on any of the adapter, we will not get
        // around in doing DhcpStartWaitableTime. One simpler way to fix this is to restart
        // the waitable timer, immediately after we get out of WaitForMultipleObjects but that is
        // ugly and also that we will be able to wakeup the system but will not be able to detect
        // that it did happen. The best way to fix this is to run the waitable timer on a separate
        // thread and just signal this loop here whenever necessary. This should be fixed after
        // new client code is checked in so that merge can be
        // avoided.
        //  --  The above problem should be fixed because a new
        //  thread is now created for each renewal
        // Resumed = FALSE;
        if (INFINITE != ResumeTime) {
            DhcpStartWaitableTimer(
                DhcpGlobalWaitableTimerHandle,
                ResumeTime );
        } else {
            DhcpCancelWaitableTimer( DhcpGlobalWaitableTimerHandle );
        }


        //
        // Need to wait to see what happened.
        //

        DhcpPrint((DEBUG_MISC, "ProcessDhcpRequestForever sleeping 0x%lx msec\n",
                   SleepTimeMsec));
        
        Waiter = WaitForMultipleObjects(
            EVENT_COUNT,                          // num. of handles.
            WaitHandle,                           // handle array.
            FALSE,                                // wait for any.
            SleepTimeMsec                         // timeout in msecs.
            );

        //
        // Initialize sleep value to zero so that if we need to recompute
        // time to sleep after we process the event, it will be done automatically
        //

        LocalTimeToSleep = 0 ;

        switch( Waiter ) {
        case GLOBAL_DOM_CHANGE:
            //
            // If domain name has changed, all we got to do is set
            // the global refresh flag and fall-through.
            // That will fall to the wait_timeout case and then
            // refresh all NICs.
            //

            DhcpGlobalDoRefresh = TRUE;

        case TIMER_EVENT:
            //
            //  FALL THROUGH and recompute
            //
        case WAIT_TIMEOUT: {                      // we timed out or were woken up -- recompute timers
            PDHCP_CONTEXT DhcpContext;
            time_t TimeNow;
            PLIST_ENTRY ListEntry;
            DhcpPrint((DEBUG_TRACE,"ProcessDhcpRequestForever - processing WAIT_TIMEOUT\n"));

            if( bFailedRenewal ) {
                HandleFailedRenewals();
                bFailedRenewal = FALSE;
            }

            LocalTimeToSleep = ResumeTime = INFINIT_LEASE;
            TimeNow = time( NULL );

            LOCK_RENEW_LIST();                    // with pnp, it is ok to have no adapters; sleep till we get one

            // recalculate timers and do any required renewals.. ScheduleWakeup would re-schedule these renewals
            for( ListEntry = DhcpGlobalNICList.Flink;
                 ListEntry != &DhcpGlobalNICList;
                ) {
                DhcpContext = CONTAINING_RECORD(ListEntry,DHCP_CONTEXT,NicListEntry );
                ListEntry   = ListEntry->Flink;

                //
                // For static adapters, we may need to refresh params ONLY if we're asked to..
                // Otherwise we can ignore them..
                //

                if( IS_DHCP_DISABLED(DhcpContext) ) {
                    if( 0 == DhcpGlobalDoRefresh ) continue;

                    StaticRefreshParams(DhcpContext);
                    continue;
                }

                //
                // If it is time to run this renewal function, remove the
                // renewal context from the list. If the power just resumed on this
                // system, we need to re-run all the contexts in INIT-REBOOT mode,
                // coz during suspend the machine may have been moved to a different
                // network.
                //

                if ( 0 != DhcpGlobalDoRefresh || DhcpContext->RunTime <= TimeNow ) {

                    RemoveEntryList( &DhcpContext->RenewalListEntry );
                    if( IsListEmpty( &DhcpContext->RenewalListEntry ) ) {
                        //
                        // This context is already being processed, so ignore it
                        //
                    } else {
                        InitializeListHead( &DhcpContext->RenewalListEntry);

                        if( NO_ERROR != DhcpCreateThreadAndRenew(DhcpContext)) {
                            DhcpContext->bFailedRenewal = TRUE;
                            bFailedRenewal = TRUE;
                            SetEvent(DhcpGlobalRecomputeTimerEvent);
                        }
                    }
                } else if( INFINIT_TIME != DhcpContext->RunTime ) {
                    // if RunTime is INFINIT_TIME then we never want to schedule it...

                    ElapseTime = (DWORD)(DhcpContext->RunTime - TimeNow);

                    if ( LocalTimeToSleep > ElapseTime ) {
                        LocalTimeToSleep = ElapseTime;
                        //
                        // if this adapter is in the autonet mode, dont let
                        // the 5 minute retry timer wake the machine up.
                        //
                        // Also, if context not enabled for WOL, don't do this
                        //
                        
                        if ( DhcpContext->fTimersEnabled
                             && IS_ADDRESS_DHCP( DhcpContext ) ) {
                            
                            // shorten the resumetime by half minute so that we can process power up event
                            // before normal timer fires. this we can guarantee we start with INIT-REBOOT
                            // sequence after power up.
                            if (LocalTimeToSleep > 10 ) {
                                ResumeTime = LocalTimeToSleep - 10;
                            } else {
                                ResumeTime = 0;
                            }
                        }
                    }
                }
            }

            DhcpGlobalDoRefresh = 0;

            UNLOCK_RENEW_LIST();
            break;
        }
        case PIPE_EVENT: {
            BOOL BoolError;

            DhcpPrint( (DEBUG_TRACE,"ProcessDhcpRequestForever - processing PIPE_EVENT\n"));

            ProcessApiRequest(DhcpGlobalClientApiPipe,&DhcpGlobalClientApiOverLapBuffer );

            // Disconnect from the current client, setup listen for next client;
            BoolError = DisconnectNamedPipe( DhcpGlobalClientApiPipe );
            DhcpAssert( BoolError );

            // ensure the event handle in the overlapped structure is reset
            // before we initiate putting the pipe into listening state
            ResetEvent(DhcpGlobalClientApiPipeEvent);
            BoolError = ConnectNamedPipe(
                DhcpGlobalClientApiPipe,
                &DhcpGlobalClientApiOverLapBuffer );

            if( ! DhcpGlobalDoRefresh ) {

                //
                // Completed processing!
                //

                break;
            }

            //
            // Need to do refresh DNS host name etc..
            //

            Length = sizeof(DhcpGlobalHostNameBufW)/sizeof(WCHAR);
            DhcpGlobalHostNameW = DhcpGlobalHostNameBufW;

            BoolError = GetComputerNameExW(
                ComputerNameDnsHostname,
                DhcpGlobalHostNameW,
                &Length
            );


            if( FALSE == BoolError ) {
                KdPrint(("DHCP:GetComputerNameExW failed %ld\n", GetLastError()));
                DhcpAssert(FALSE);
                break;
            }

            DhcpUnicodeToOem( DhcpGlobalHostNameW, DhcpGlobalHostNameBuf);
            DhcpGlobalHostName = DhcpGlobalHostNameBuf;

            //
            //  We need to re-visit each context to refresh. So, hack that with
            //  setting LocalTimeToSleep to zero

            break;
        }
        case TERMINATE_EVENT:
            return( ERROR_SUCCESS );

        case WAIT_FAILED:
            DhcpPrint((DEBUG_ERRORS,"WaitForMultipleObjects failed, %ld.\n", GetLastError() ));
            break;

        default:
            DhcpPrint((DEBUG_ERRORS,"WaitForMultipleObjects received invalid handle, %ld.\n",Waiter));
            break;
        }
    }
}

DWORD
ResetStaticInterface(
    IN PDHCP_CONTEXT DhcpContext
)
{
    ULONG Error;
    DWORD IpInterfaceContext;

    //
    // Try to delete all the non-primary interfaces for the adapter..
    //
    Error = IPDelNonPrimaryAddresses(DhcpAdapterName(DhcpContext));
    if( ERROR_SUCCESS != Error ) {
        DhcpAssert(FALSE);
        return Error;
    }

    //
    // Now we have to set the primary address to zero..
    //
    Error = GetIpInterfaceContext(
        DhcpAdapterName(DhcpContext),
        0,
        &IpInterfaceContext
        );
    if( ERROR_SUCCESS != Error ) {
        DhcpAssert(FALSE);
        return Error;
    }

    //
    // Got hte interface context.. just set address to zero for that..
    //
    Error = IPResetIPAddress(
        IpInterfaceContext,
        DhcpDefaultSubnetMask(0)
        );
    return Error;
}

DWORD
DhcpDestroyContextEx(
    IN PDHCP_CONTEXT DhcpContext,
    IN ULONG fKeepInformation
)
{
    ULONG Error;
    BOOL  bNotifyNLA = TRUE;
    DWORD NotifyDnsCache(VOID);

    if (NdisWanAdapter(DhcpContext))
        InterlockedDecrement(&DhcpGlobalNdisWanAdaptersCount);

    DhcpAssert( IS_MDHCP_CTX( DhcpContext ) || IsListEmpty(&DhcpContext->NicListEntry) );
    if(!IsListEmpty(&DhcpContext->RenewalListEntry) ) {
        LOCK_RENEW_LIST();
        RemoveEntryList( &DhcpContext->RenewalListEntry );
        InitializeListHead( &DhcpContext->RenewalListEntry );
        UNLOCK_RENEW_LIST();
    }

#ifdef BOOTPERF
    //
    // No matter what, if the context is going away, we
    // clear out the quickboot values.
    //
    if( NULL != DhcpContext->AdapterInfoKey ) {
        DhcpRegDeleteQuickBootValues(
            DhcpContext->AdapterInfoKey
            );
    }
#endif BOOTPERF

    if (!IS_MDHCP_CTX( DhcpContext ) ) {
        if( IS_DHCP_DISABLED(DhcpContext) ) {
            Error = ERROR_SUCCESS;
            //Error = ResetStaticInterface(DhcpContext);
        } else {
            if( FALSE == fKeepInformation ) {

                Error = SetDhcpConfigurationForNIC(
                    DhcpContext,
                    NULL,
                    0,
                    (DWORD)-1,
                    TRUE
                    );

                // if we get here, NLA is notified through SetDhcpConfigurationForNIC
                // hence avoid sending a second notification later
                if (Error == ERROR_SUCCESS)
                    bNotifyNLA = FALSE;

                Error = DhcpRegDeleteIpAddressAndOtherValues(
                    DhcpContext->AdapterInfoKey
                    );
            } else {
                LOCK_OPTIONS_LIST();
                (void) DhcpRegClearOptDefs(DhcpAdapterName(DhcpContext));
                UNLOCK_OPTIONS_LIST();
                Error = UninitializeInterface(DhcpContext);
            }

        //DhcpAssert(ERROR_SUCCESS == Error);
        }
	
        DhcpRegisterWithDns(DhcpContext, TRUE);
        NotifyDnsCache();
    }


    LOCK_OPTIONS_LIST();
    DhcpDestroyOptionsList(&DhcpContext->SendOptionsList, &DhcpGlobalClassesList);
    DhcpDestroyOptionsList(&DhcpContext->RecdOptionsList, &DhcpGlobalClassesList);
    // all fallback options are not supposed to have classes, so &DhcpGlobalClassesList below
    // is actually not used.
    DhcpDestroyOptionsList(&DhcpContext->FbOptionsList, &DhcpGlobalClassesList);

    if( DhcpContext->ClassIdLength ) {            // remove any class id we might have
        DhcpDelClass(&DhcpGlobalClassesList, DhcpContext->ClassId, DhcpContext->ClassIdLength);
    }
    UNLOCK_OPTIONS_LIST();
    CloseHandle(DhcpContext->AdapterInfoKey);     // close the open handles to the registry
    CloseHandle(DhcpContext->RenewHandle);        // and synchronization events
    if (DhcpContext->CancelEvent != WSA_INVALID_EVENT) {
        WSACloseEvent(DhcpContext->CancelEvent);
        DhcpContext->CancelEvent = WSA_INVALID_EVENT;
    }

    CloseDhcpSocket( DhcpContext );               // close the socket if it's open.

    DhcpFreeMemory(DhcpContext);                  // done!

    if (bNotifyNLA)
        NLANotifyDHCPChange();                    // notify NLA the adapter went away

    return ERROR_SUCCESS;                         // always return success
}

DWORD
DhcpDestroyContext(
    IN PDHCP_CONTEXT DhcpContext
)
{
    return DhcpDestroyContextEx(
        DhcpContext,
        FALSE
        );

}

DWORD
DhcpCommonInit(                                   // initialize common stuff for service as well as APIs
    VOID
)
{
    ULONG                          Length;
    BOOL                           BoolError;
    DWORD                          Error;
#if DBG
    LPWSTR  DebugFileName = NULL;
#endif

#if DBG
    //
    // This is very funcky.
    // Initialized won't be reset to FALSE after it gets a TRUE value
    // As a result, DhcpCommonInit will be called only once.
    //
    // DhcpGlobalDebugFlag is updated in DhcpInitRegistry each time
    // the service is stoped and started.
    //
    DebugFileName = NULL;
    Error = DhcpGetRegistryValue(
        DHCP_CLIENT_PARAMETER_KEY,
        DHCP_DEBUG_FILE_VALUE,
        DHCP_DEBUG_FILE_VALUE_TYPE,
        &DebugFileName
        );
    if (DebugFileName) {
        if (DhcpGlobalDebugFile) {
            CloseHandle(DhcpGlobalDebugFile);
        }
        DhcpGlobalDebugFile = CreateFileW(
                DebugFileName,
                GENERIC_WRITE,
                FILE_SHARE_READ,
                NULL,
                OPEN_ALWAYS,
                FILE_FLAG_SEQUENTIAL_SCAN,
                NULL
                );
        DhcpFreeMemory(DebugFileName);
        DebugFileName = NULL;
    }
#endif

    if( Initialized ) return ERROR_SUCCESS;
    EnterCriticalSection(&DhcpGlobalApiCritSect);
    if( Initialized ) {
        Error = ERROR_SUCCESS ;
        goto Cleanup;
    }

    Length = sizeof(DhcpGlobalHostNameBufW)/sizeof(WCHAR);
    DhcpGlobalHostNameW = DhcpGlobalHostNameBufW;

    BoolError = GetComputerNameExW(
        ComputerNameDnsHostname,
        DhcpGlobalHostNameW,
        &Length
    );

    if( FALSE == BoolError ) {
        Error = GetLastError();
#if DBG
        KdPrint(("DHCP:GetComputerNameExW failed %ld\n", Error));
#endif
        goto Cleanup;
    }

    DhcpUnicodeToOem(DhcpGlobalHostNameBufW, DhcpGlobalHostNameBuf);
    DhcpGlobalHostName = DhcpGlobalHostNameBuf;

#if DBG
    Error = DhcpGetRegistryValue(
        DHCP_CLIENT_PARAMETER_KEY,
        DHCP_DEBUG_FLAG_VALUE,
        DHCP_DEBUG_FLAG_VALUE_TYPE,
        (PVOID *)&DhcpGlobalDebugFlag
    );

    if( Error != ERROR_SUCCESS ) {
        DhcpGlobalDebugFlag = 0;
    }

    if( DhcpGlobalDebugFlag & DEBUG_BREAK_POINT ) {
        DbgBreakPoint();
    }

#endif

    Error = ERROR_SUCCESS;
    Initialized = TRUE;
 
  Cleanup:

    LeaveCriticalSection(&DhcpGlobalApiCritSect);

    return Error;
}

VOID
ServiceMain (                                // (SVC_main) this thread quits when dhcp is unloaded
    IN      DWORD                  argc,          // unused
    IN      LPTSTR                 argv[]         // unused
    )
{
    DWORD                          Error;
    DWORD                          timeToSleep = 1;

    UNREFERENCED_PARAMETER(argc);
    UNREFERENCED_PARAMETER(argv);

    Error = WSAStartup( 0x0101, &DhcpGlobalWsaData );
    if( ERROR_SUCCESS != Error ) {                // initialize winsock first
        goto Cleanup;
    }
    DhcpGlobalWinSockInitialized = TRUE;


    Error = DhcpCommonInit();
    if( ERROR_SUCCESS != Error ) goto Cleanup;

    Error = DhcpInitData();
    if( ERROR_SUCCESS != Error ) goto Cleanup;    // should not happen, we abort if this happens

    UpdateStatus();                               // send heart beat to the service controller.

    Error = DhcpInitialize( &timeToSleep );       // with pnp, this does not get any addresses
    if( Error != ERROR_SUCCESS ) goto Cleanup;    // this should succeed without any problems

    Error   =   DhcpInitMediaSense();             // this would handle the notifications for arrival/departure of
    if( Error != ERROR_SUCCESS ) goto Cleanup;

    DhcpGlobalServiceStatus.dwCurrentState = SERVICE_RUNNING;
    UpdateStatus();                               // placate the service controller -- we are running.

    DhcpPrint(( DEBUG_MISC, "Service is running.\n"));
    DhcpGlobalServiceRunning = TRUE;

    Error = ProcessDhcpRequestForever(            // this gets the address for any adapters that may come up
        timeToSleep
    );

Cleanup:

    DhcpCleanup( Error );
    return;
}

DWORD
DhcpInitMediaSense(
    VOID
    )
/*++

Routine Description:

    This function initializes the media sense detection code.
    It creates a thread which basically just waits for media
    sense notifications from tcpip.
Arguments:

    None.

Return Value:

    Success or Failure.

--*/
{
    DWORD Error = ERROR_SUCCESS;
    DWORD threadId;

    DhcpGlobalIPEventSeqNo = 0;
    DhcpGlobalMediaSenseHandle = CreateThread(
        NULL,
        0,
        (LPTHREAD_START_ROUTINE)MediaSenseDetectionLoop,
        NULL,
        0,
        &threadId
    );

    if ( DhcpGlobalMediaSenseHandle == NULL ) {
        Error =  GetLastError();
        DhcpPrint((DEBUG_INIT, "DhcpInitMediaSense: Can't create MediaThread, %ld.\n", Error));
        return(Error);
    }

    DhcpPrint((DEBUG_INIT, "DhcpInitMediaSense succeded\n", Error));
    return(Error);
}

VOID
DoInterfaceMetricChange(
    IN LPWSTR AdapterName,
    IN ULONG IpInterfaceContext
    )
/*++

Routine Description:
    This routine handles interface metric changes for the context
    specified by the AdapterName or IpInterfaceContext values.

Arguments:
    AdapterName -- name of adapter for which interface metric is
        changing.

    IpInterfaceContext -- nte_context value for interface

--*/
{
    PDHCP_CONTEXT DhcpContext;
    DHCP_FULL_OPTIONS DhcpOptions;
    ULONG Error;

    LOCK_RENEW_LIST();
    do {
        DhcpContext = FindDhcpContextOnNicList(
            AdapterName, IpInterfaceContext
            );
        if( NULL == DhcpContext ) {
            //
            // If there is no context, we can't do much.
            //
            break;
        }

        InterlockedIncrement( &DhcpContext->RefCount );

        break;
    } while ( 0 );
    UNLOCK_RENEW_LIST();

    if( NULL == DhcpContext ) {
        //
        // We never found the context. Just have to return.
        //
        return;
    }

    //
    // Since we found the context, we have to acquire it.
    //
    Error = WaitForSingleObject( DhcpContext->RenewHandle, INFINITE);
    if( WAIT_OBJECT_0 == Error ) {
        //
        // Now set the interface gateways again.
        //

        RtlZeroMemory(&DhcpOptions, sizeof(DhcpOptions));
        DhcpOptions.nGateways = DhcpContext->nGateways;
        DhcpOptions.GatewayAddresses = DhcpContext->GatewayAddresses;

        DhcpSetGateways(DhcpContext, &DhcpOptions, TRUE);
    } else {
        //
        // Shouldn't really happen.
        //
        Error = GetLastError();
        DhcpAssert( ERROR_SUCCESS == Error );
    }

    (void) ReleaseSemaphore( DhcpContext->RenewHandle, 1, NULL);

    if( 0 == InterlockedDecrement( &DhcpContext->RefCount ) ) {
        //
        // Last reference to the context.. Destroy it.
        //
        DhcpDestroyContext( DhcpContext );
    }
}

VOID
DoWOLCapabilityChange(
    IN LPWSTR AdapterName,
    IN ULONG IpInterfaceContext
    )
/*++

Routine Description:
    This routine handles interface metric changes for the context
    specified by the AdapterName or IpInterfaceContext values.

Arguments:
    AdapterName -- name of adapter for which interface metric is
        changing.

    IpInterfaceContext -- nte_context value for interface

--*/
{
    PDHCP_CONTEXT DhcpContext;
    ULONG Error;

    LOCK_RENEW_LIST();
    do {
        DhcpContext = FindDhcpContextOnNicList(
            AdapterName, IpInterfaceContext
            );
        if( NULL == DhcpContext ) {
            //
            // If there is no context, we can't do much.
            //
            break;
        }

        InterlockedIncrement( &DhcpContext->RefCount );

        break;
    } while ( 0 );
    UNLOCK_RENEW_LIST();

    if( NULL == DhcpContext ) {
        //
        // We never found the context. Just have to return.
        //
        return;
    }

    //
    // Since we found the context, we have to acquire it.
    //
    Error = WaitForSingleObject( DhcpContext->RenewHandle, INFINITE);
    if( WAIT_OBJECT_0 == Error ) {
        //
        // Now set the interface gateways again.
        //
        
        ULONG Caps;
        BOOL fTimersEnabled;

        Error = IPGetWOLCapability(
            DhcpIpGetIfIndex(DhcpContext), &Caps
            );
        if( ERROR_SUCCESS != Error ) {
            DhcpPrint((DEBUG_ERRORS, "Failed IPGetWOLCapability: 0x%lx\n", Error));
        } else {
            fTimersEnabled = ((Caps& NDIS_DEVICE_WAKE_UP_ENABLE)!= 0);
            if( fTimersEnabled != DhcpContext->fTimersEnabled ) {
                DhcpContext->fTimersEnabled = fTimersEnabled;

                DhcpPrint((DEBUG_MISC, "WOL Capability: %ld\n", fTimersEnabled));
                if( IS_DHCP_ENABLED(DhcpContext)
                    && !DhcpIsInitState(DhcpContext) ) {

                    //
                    // Cause processdhcpprocessdiscoverforeever to wakeup
                    // to take care of this timer issue..
                    //
                    SetEvent(DhcpGlobalRecomputeTimerEvent);
                }
            }
        }
            
    } else {
        //
        // Shouldn't really happen.
        //
        Error = GetLastError();
        DhcpAssert( ERROR_SUCCESS == Error );
    }

    (void) ReleaseSemaphore( DhcpContext->RenewHandle, 1, NULL);

    if( 0 == InterlockedDecrement( &DhcpContext->RefCount ) ) {
        //
        // Last reference to the context.. Destroy it.
        //
        DhcpDestroyContext( DhcpContext );
    }

}

VOID
MediaSenseDetectionLoop(
    VOID
    )
/*++

Routine Description:

    This function is the starting point for the main MediaSenseDetection thread.
    It loops to process queued messages, and sends replies.

Arguments:

    none.

Return Value:

    None.

--*/
{
#define TERMINATION_EVENT           0
#define MEDIA_SENSE_EVENT           1
#undef  EVENT_COUNT
#define EVENT_COUNT                 2

    IP_STATUS           MediaStatus;
    HANDLE              WaitHandle[EVENT_COUNT];
    HANDLE              tcpHandle   =   NULL;
    PIP_GET_IP_EVENT_RESPONSE  responseBuffer;
    DWORD               responseBufferSize;
    IO_STATUS_BLOCK     ioStatusBlock;
    NTSTATUS            status;
    DWORD               Error,result;
    PDHCP_CONTEXT       dhcpContext;
    BOOL                serviceStopped = FALSE;



    responseBuffer = NULL;      // Bug 292526: in case that OpenDriver and CreateEvent fails.

    WaitHandle[TERMINATION_EVENT] = DhcpGlobalTerminateEvent;
    WaitHandle[MEDIA_SENSE_EVENT] = CreateEvent(
        NULL,   // no security
        FALSE,  // no manual reset
        FALSE,  // initial state not signalled
        NULL    // no name
    );

    if ( !WaitHandle[MEDIA_SENSE_EVENT] ) {
        DhcpPrint( (DEBUG_ERRORS,"MediaSenseDetectionLoop: OpenDriver failed %lx\n",GetLastError()));
        goto Exit;
    }

    Error = OpenDriver(&tcpHandle, DD_IP_DEVICE_NAME);
    if (Error != ERROR_SUCCESS) {
        DhcpPrint( (DEBUG_ERRORS,"MediaSenseDetectionLoop: OpenDriver failed %lx\n",Error));
        goto Exit;
    }

    //
    // Allocate large enough buffer to hold adapter name
    //
    responseBufferSize = sizeof(IP_GET_IP_EVENT_RESPONSE)+ ADAPTER_STRING_SIZE;
    responseBuffer = DhcpAllocateMemory(responseBufferSize);
    if( responseBuffer == NULL ) {
        Error = ERROR_NOT_ENOUGH_MEMORY;
        goto Exit;
    }

    do {

        ZeroMemory( responseBuffer, responseBufferSize );

        DhcpPrint((DEBUG_MEDIA, "-->IPGetIPEventRequest(..%d..)\n", DhcpGlobalIPEventSeqNo));

        status = IPGetIPEventRequest(
                    tcpHandle,
                    WaitHandle[MEDIA_SENSE_EVENT],
                    DhcpGlobalIPEventSeqNo,
                    responseBuffer,
                    responseBufferSize,
                    &ioStatusBlock);

        if ( (STATUS_PENDING != status) && (STATUS_SUCCESS != status) )
        {
            DhcpPrint( (DEBUG_ERRORS,"Media Sense request ioctl failed with error %lx\n",status));

            Error = RtlNtStatusToDosError(status);
            break;

        } else {

            DhcpPrint( (DEBUG_TRACE,"Media Sense request ioctl sent\n"));
            //
            // Note: even in case of a immediate success from IPGetIPEventRequest,
            // we do waitformultipleobjects. This is to make sure that we catch terminate
            // event in case where we are getting bombarded with media sense events.
            //
            result = WaitForMultipleObjects(
                        EVENT_COUNT,            // num. of handles.
                        WaitHandle,             // handle array.
                        FALSE,                  // wait for any.
                        ( status == STATUS_SUCCESS ? 0 : INFINITE ));  // timeout in msecs

            switch( result ) {
            case TERMINATION_EVENT:

                DhcpPrint( (DEBUG_TRACE,"MediaSenseDetectionLoop: rcvd terminate event\n"));
                if ( status == STATUS_PENDING ) {
                    Error =    IPCancelIPEventRequest(
                                    tcpHandle,
                                    &ioStatusBlock);

                }

                //
                // the service is asked to stop, break the loop.
                //
                serviceStopped  =   TRUE;
                break;

            default:
                DhcpAssert( result == WAIT_FAILED );

                DhcpPrint( (DEBUG_TRACE,"WaitForMultipleObjects returned %lx\n",result));
                //
                // when IPGetIPEventRequest gives immediate return code,
                // we may here. So we should never fall here if it returned
                // STATUS_PENDING
                //
                if ( status == STATUS_PENDING ) {

                    Error = GetLastError();
                    DhcpPrint( (DEBUG_ERRORS,"WaitForMultipleObjects failed with error %lx\n",Error));
                    break;
                }
                //
                // THERE IS NO BREAK HERE.
                //
            case MEDIA_SENSE_EVENT:

                if ( status != STATUS_SUCCESS && status != STATUS_PENDING ) {
                    DhcpPrint( (DEBUG_ERRORS,"Media Sense ioctl failed with error %lx\n",status));
                    break;
                }

                DhcpPrint((DEBUG_MEDIA,"Wait-> SequenceNo=%d; MediaStatus=%d\n",
                    responseBuffer->SequenceNo,
                    responseBuffer->MediaStatus));
                DhcpPrint((DEBUG_MEDIA,"DhcpGlobalIPEventSeqNo=%d\n", DhcpGlobalIPEventSeqNo));

                //
                // remap the adaptername buffer from kernel space to user space
                //
                responseBuffer->AdapterName.Buffer = (PWSTR)(
                    (char *)responseBuffer + sizeof(IP_GET_IP_EVENT_RESPONSE)
                    );

                //
                // nul-terminate the string for adapter name: HACKHACK!
                //
                {
                    DWORD Size = strlen("{16310E8D-F93B-42C7-B952-00F695E40ECF}");
                    responseBuffer->AdapterName.Buffer[Size] = L'\0';
                }

                if ( responseBuffer->MediaStatus == IP_INTERFACE_METRIC_CHANGE ) {
                    //
                    // Handle interface metric change requests..
                    //
                    DoInterfaceMetricChange(
                        responseBuffer->AdapterName.Buffer,
                        responseBuffer->ContextStart
                        );
                    if( responseBuffer->SequenceNo > DhcpGlobalIPEventSeqNo ) {
                        DhcpGlobalIPEventSeqNo = responseBuffer->SequenceNo;
                    } else {
                        DhcpAssert(FALSE);
                    }
                    break;
                }

                if( responseBuffer->MediaStatus == IP_INTERFACE_WOL_CAPABILITY_CHANGE ) {
                    //
                    // Handle WOL capabilities change.
                    //
                    DoWOLCapabilityChange(
                        responseBuffer->AdapterName.Buffer,
                        responseBuffer->ContextStart
                        );
                    if( responseBuffer->SequenceNo > DhcpGlobalIPEventSeqNo ) {
                        DhcpGlobalIPEventSeqNo = responseBuffer->SequenceNo;
                    } else {
                        DhcpAssert(FALSE);
                    }
                    break;
                }

                if ( responseBuffer->MediaStatus != IP_MEDIA_CONNECT &&
                     responseBuffer->MediaStatus != IP_BIND_ADAPTER &&
                     responseBuffer->MediaStatus != IP_UNBIND_ADAPTER &&
                     responseBuffer->MediaStatus != IP_MEDIA_DISCONNECT &&
                     responseBuffer->MediaStatus != IP_INTERFACE_METRIC_CHANGE
                    ) {
                    DhcpPrint( (DEBUG_ERRORS, "Media Sense ioctl received unknown event %lx"
                                "for %ws, context %x\n",
                                responseBuffer->MediaStatus,
                                responseBuffer->AdapterName.Buffer,
                                responseBuffer->ContextStart));
                    break;
                }

                Error = ProcessAdapterBindingEvent(
                    responseBuffer->AdapterName.Buffer,
                    responseBuffer->ContextStart,
                    responseBuffer->MediaStatus);

                DhcpGlobalIPEventSeqNo = responseBuffer->SequenceNo;

                break;

            } // end of switch

        }

    } while (!serviceStopped);

Exit:
    if ( WaitHandle[MEDIA_SENSE_EVENT] ) CloseHandle( WaitHandle[MEDIA_SENSE_EVENT] );
    if ( responseBuffer) DhcpFreeMemory(responseBuffer);
    if ( tcpHandle ) NtClose(tcpHandle);

    return;
}

DWORD
ProcessAdapterBindingEvent(
    IN LPWSTR adapterName,
    IN DWORD ipInterfaceContext,
    IN IP_STATUS bindingStatus
    )
/*++

Routine Description:
    This routine handles both the media sense for a card as well as
    bind-unbind notifications.

    It heavily assumes the fact that this is routine is called
    synchronously by a single thread (thereby, connect and disconnect
    cannot happen in parallel).

    bindingStatus can be any of the four values IP_BIND_ADAPTER,
    IP_UNBIND_ADAPTER, IP_MEDIA_CONNECT or IP_MEDIA_DISCONNECT ---
    Of these, the first and third are treated exactly the same and
    so is the second and fourth.

    On BIND/CONNECT, this routine creates a DHCP Context structure
    initializing the RefCount to ONE on it.  But if the context
    already existed, then just a refresh is done on the context.
    (Assuming the router isn't present at that time etc).

    On UNBIND/DISCONNECT, the refcount is temporarily bumped up
    until the context semaphore can be obtained -- after that, the
    context refcount is bumped down twice and if that hits zero,
    the context is released. If the context refcount didn't fall to
    zero, then some other thread is waiting to acquire the context
    and that thread would acquire and do its work and when done,
    it would bump down the refcount and at that time the refount
    would fall to zero.

Arguments:
    adapterName -- name of adapter all this si being done on
    ipInterfaceContext -- interface context # (nte_context)_
    bindingStatus -- bind/unbind/connect/disconnect indication.

Return Values:
    Various useless Win32 errors.

--*/
{
    DWORD Error = ERROR_SUCCESS;
    PDHCP_CONTEXT dhcpContext;

    DhcpPrint((DEBUG_MEDIA, "ProcessAdapterBindingEvent(%d) for %ws.\n",
        bindingStatus,
        adapterName));

    if ( bindingStatus == IP_BIND_ADAPTER  ||
         bindingStatus == IP_MEDIA_CONNECT ) {
        //
        // New adapter or adapter re-connecting.
        //
        LOCK_RENEW_LIST();
        dhcpContext = FindDhcpContextOnNicList(
            adapterName, ipInterfaceContext
            );
        if( NULL == dhcpContext ) {
            //
            // Create new context now!
            //
            DhcpPrint(( DEBUG_MEDIA, "New Adapter (Event %ld)\n", bindingStatus ));

            Error = DhcpAddNICtoListEx(
                adapterName,
                ipInterfaceContext,
                &dhcpContext
                );

            if (Error != ERROR_SUCCESS ) {
                //
                // Failed to create a context? PnP hazard. Just ignore error
                // and print debug info.
                //
                UNLOCK_RENEW_LIST();
                //DhcpAssert(FALSE);
                DhcpLogEvent(NULL, EVENT_COULD_NOT_INITIALISE_INTERFACE, Error);
                return Error;
            }

            //
            // Now handle new adapter. Static case first followed by DHCP case.
            //

            if ( IS_DHCP_DISABLED(dhcpContext) ) {
                StaticRefreshParams(dhcpContext);
                UNLOCK_RENEW_LIST();
                return Error;
            }

            //
            // No prior-DHCP address case (INIT state) or INIT-REBOOT state?
            //

            if( DhcpIsInitState(dhcpContext) ) {
                dhcpContext->RenewalFunction = ReObtainInitialParameters;
            } else {
                dhcpContext->RenewalFunction = ReRenewParameters;
            }

            //
            // Do this on a separate thread..
            //
            ScheduleWakeUp(dhcpContext, 0);
            UNLOCK_RENEW_LIST();

            return ERROR_SUCCESS;
        }

        //
        // Ok we already have a context.
        //

        DhcpPrint((DEBUG_MEDIA, "bind/connect for an existing adapter (context %p).\n",dhcpContext));

        if( IS_DHCP_DISABLED(dhcpContext) ) {
            //
            // For static addresses, nothing to do.
            //
            UNLOCK_RENEW_LIST();

            return ERROR_SUCCESS;
        }

        //
        // For DHCP enabled, we need to call ProcessMediaConnectEvent
        //
        InterlockedIncrement( &dhcpContext->RefCount );
        UNLOCK_RENEW_LIST();

        Error = LockDhcpContext(dhcpContext, TRUE);
        if( WAIT_OBJECT_0 == Error ) {
            LOCK_RENEW_LIST();

            //
            // do not remove from renewal list at all..
            // schedulewakeup is what is called in processmediaconnectevent
            // and that can take care of renewallist being present..
            //
            // RemoveEntryList( &dhcpContext->RenewalListEntry);
            // InitializeListHead( &dhcpContext->RenewalListEntry );
            //

            Error = ProcessMediaConnectEvent(
                dhcpContext,
                bindingStatus
                );

            UNLOCK_RENEW_LIST();

            DhcpPrint((DEBUG_MEDIA, "-- media: releasing RenewHandle %d --]\n", dhcpContext->RenewHandle));
            UnlockDhcpContext(dhcpContext);
        } else {
            //
            // Shouldn't really happen..
            //
            Error = GetLastError();
            DhcpAssert( ERROR_SUCCESS == Error );
        }

        if( 0 == InterlockedDecrement (&dhcpContext->RefCount ) ) {
            //
            // Can't really be as only this current thread can
            // remove refcount on unbind/unconnect..
            //
            DhcpAssert(FALSE);
            DhcpDestroyContext(dhcpContext);
        }

        return Error;
    }

    //
    // Unbind or disconnect.
    //

    DhcpAssert( bindingStatus == IP_UNBIND_ADAPTER ||
            bindingStatus == IP_MEDIA_DISCONNECT );

    DhcpPrint((DEBUG_MEDIA, "ProcessAdapterBindingEvent: rcvd"
               " unbind event for %ws, ipcontext %lx\n",
               adapterName, ipInterfaceContext));

    LOCK_RENEW_LIST();
    dhcpContext = FindDhcpContextOnNicList(
        adapterName, ipInterfaceContext
        );
    if( NULL == dhcpContext) {
        //
        // Can happen... We take this opportunity to clear registry.
        //
        UNLOCK_RENEW_LIST();

        LOCK_OPTIONS_LIST();
        (void) DhcpRegClearOptDefs( adapterName );
        UNLOCK_OPTIONS_LIST();

        return ERROR_FILE_NOT_FOUND;
    }

    InterlockedIncrement( &dhcpContext->RefCount );
    UNLOCK_RENEW_LIST();

    Error = LockDhcpContext(dhcpContext, TRUE);
    if( WAIT_OBJECT_0 == Error ) {
        LOCK_RENEW_LIST();
        RemoveEntryList( &dhcpContext->RenewalListEntry );
        InitializeListHead( &dhcpContext->RenewalListEntry );
        RemoveEntryList( &dhcpContext->NicListEntry);
        InitializeListHead( &dhcpContext->NicListEntry );
        UNLOCK_RENEW_LIST();
        InterlockedDecrement( &dhcpContext->RefCount );
        DhcpAssert( dhcpContext->RefCount );

        Error = ERROR_SUCCESS;
    } else {
        //
        // Wait can't fail really. Nevermind.
        //
        Error = GetLastError();
        DhcpAssert(ERROR_SUCCESS == Error);
    }

    //
    // Now decrease ref-count and if it goes to zero destroy
    // context.
    //

    if (bindingStatus == IP_UNBIND_ADAPTER) {
        /*
         * Set the state properly so that UninitializeInterface won't reset the stack
         * When adapter is unbound, the IpInterfaceContext may be re-used.
         */

        MEDIA_UNBOUND(dhcpContext);
    }
    if( 0 == InterlockedDecrement(&dhcpContext->RefCount ) ) {
        //
        // Last person to hold onto context? Destroy context.
        //
        DhcpAssert(ERROR_SUCCESS == Error);
        DhcpDestroyContextEx(
            dhcpContext,
            (bindingStatus == IP_MEDIA_DISCONNECT)
            );
    } else {
        //
        // Some other thread attempting to hold onto context.
        //
        ULONG BoolError = UnlockDhcpContext(dhcpContext);
        DhcpAssert( FALSE != BoolError );
    }

    return Error;
}

LPWSTR
DhcpAdapterName(
    IN PDHCP_CONTEXT DhcpContext
)
{

    return ((PLOCAL_CONTEXT_INFO)DhcpContext->LocalInformation)->AdapterName;
}

static
DWORD   DhcpGlobalInit = 0;                       // did we do any global initialization at all?

extern CRITICAL_SECTION MadcapGlobalScopeListCritSect;

DWORD   DhcpGlobalNumberInitedCriticalSections = 0;
PCRITICAL_SECTION   DhcpGlobalCriticalSections[] = {
    (&DhcpGlobalOptionsListCritSect),
    (&DhcpGlobalSetInterfaceCritSect),
    (&DhcpGlobalRecvFromCritSect),
    (&DhcpGlobalZeroAddressCritSect),
    (&DhcpGlobalApiCritSect),
    (&DhcpGlobalRenewListCritSect),
    (&MadcapGlobalScopeListCritSect),
    (&gNLA_LPC_CS),
#if DBG
    (&DhcpGlobalDebugFileCritSect),
#endif
    (&DhcpGlobalPopupCritSect)
};
#define NUM_CRITICAL_SECTION    (sizeof(DhcpGlobalCriticalSections)/sizeof(DhcpGlobalCriticalSections[0]))

extern REGISTER_HOST_STATUS DhcpGlobalHostStatus;

DWORD                                             // win32 status
DhcpInitGlobalData(                               // initialize the dhcp module spec data (included for RAS etc)
    VOID
)
{
    DWORD   i;

    InitializeListHead(&DhcpGlobalClassesList);
    InitializeListHead(&DhcpGlobalOptionDefList);
    InitializeListHead(&DhcpGlobalRecvFromList);
    try {
        for (DhcpGlobalNumberInitedCriticalSections = 0;
                DhcpGlobalNumberInitedCriticalSections < NUM_CRITICAL_SECTION;
                DhcpGlobalNumberInitedCriticalSections++) {
            InitializeCriticalSection(DhcpGlobalCriticalSections[DhcpGlobalNumberInitedCriticalSections]);
        }
    } except (EXCEPTION_EXECUTE_HANDLER) {
        for (i = 0; i < DhcpGlobalNumberInitedCriticalSections; i++) {
            DeleteCriticalSection(DhcpGlobalCriticalSections[i]);
        }
        DhcpGlobalNumberInitedCriticalSections = 0;
        return ERROR_OUTOFMEMORY;
    }

    DhcpGlobalHostStatus.hDoneEvent = CreateEvent(NULL,TRUE,FALSE,NULL);

    AutonetRetriesSeconds = EASYNET_ALLOCATION_RETRY;
    DhcpGlobalClientClassInfo = DHCP_DEFAULT_CLIENT_CLASS_INFO;
    DhcpGlobalDoRefresh = 0;
    DhcpGlobalInit ++;
    DhcpGlobalServerPort = DHCP_SERVR_PORT;
    DhcpGlobalClientPort = DHCP_CLIENT_PORT;

    return ERROR_SUCCESS;
}

VOID
DhcpCleanupGlobalData(                            // cleanup data intialized via DhcpInitGlobalData
    VOID
)
{
    DWORD   i;

    if( 0 == DhcpGlobalInit ) return;

    for (i = 0; i < DhcpGlobalNumberInitedCriticalSections; i++) {
        DeleteCriticalSection(DhcpGlobalCriticalSections[i]);
    }
    DhcpGlobalNumberInitedCriticalSections = 0;

    if (ghNLA_LPC_Port != NULL)
    {
        CloseHandle(ghNLA_LPC_Port);
        ghNLA_LPC_Port = NULL;
    }
    if (NULL != DhcpGlobalHostStatus.hDoneEvent) {
        CloseHandle(DhcpGlobalHostStatus.hDoneEvent);
        DhcpGlobalHostStatus.hDoneEvent = NULL;
    }

    DhcpFreeAllOptionDefs(&DhcpGlobalOptionDefList, &DhcpGlobalClassesList);
    DhcpFreeAllClasses(&DhcpGlobalClassesList);
    DhcpGlobalClientClassInfo = NULL;
    DhcpGlobalDoRefresh = 0;
    DhcpGlobalInit --;
}

DWORD
LockDhcpContext(
    PDHCP_CONTEXT   DhcpContext,
    BOOL            bCancelOngoingRequest
    )
{
    DWORD   Error;

    if (bCancelOngoingRequest) {
        InterlockedIncrement(&DhcpContext->NumberOfWaitingThreads);
        if (DhcpContext->CancelEvent != WSA_INVALID_EVENT) {
            WSASetEvent(DhcpContext->CancelEvent);
        }
    }

    Error = WaitForSingleObject(DhcpContext->RenewHandle,INFINITE);

    //
    // If CancelEvent is valid, reset it just in case no one waited on it.
    // It is safe to do it here since we already locked the context
    //
    if (bCancelOngoingRequest && (0 == InterlockedDecrement(&DhcpContext->NumberOfWaitingThreads))) {
        if (DhcpContext->CancelEvent != WSA_INVALID_EVENT) {
            //
            // There is a small chance that we reset the event
            // before another thread set the event. In order to
            // fully solve this problem, we need to protect the
            // SetEvent/ResetEvent with a critical section. It
            // doesn't worth the effort.
            //
            // The only harm of this problem is that that thread
            // has to wait for up to 1 minutes to lock the context.
            // This should be ok.
            //
            WSAResetEvent(DhcpContext->CancelEvent);
        }
    }
    return Error;
}

BOOL
UnlockDhcpContext(
    PDHCP_CONTEXT   DhcpContext
    )
{
    return ReleaseSemaphore(DhcpContext->RenewHandle,1,NULL);
}

//================================================================================
//  End of file
//================================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\client\nt\dhcpc.c ===
#include "precomp.h"

void _cdecl main(void) 
{
    void ServiceMain(unsigned long, void *);
    ServiceMain(0, 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\client\nt\dhcpcli.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    dhcpcli.c

Abstract:

    This is the API tester for the DHCP client.

    To build, 'nmake UMTEST=dhcpcli'

Author:

    Manny Weiser (mannyw)  1-Dec-1992

Environment:

    User Mode - Win32

Revision History:

    Madan Appiah (madana)  21-Oct-1993

--*/


#include "precomp.h"
#include "dhcploc.h"
#include "dhcppro.h"
#include "dhcpcapi.h"
#include "lmcons.h"
#include "conio.h"

DWORD                                             // win32 status
DhcpAcquireParametersByBroadcast(                 // acquire/renew a lease
    IN      LPWSTR                 AdapterName    // adapter to acquire lease on
);


#define IP_ADDRESS_STRING                  L"IPAddress"
#define IP_ADDRESS_STRING_TYPE             REG_MULTI_SZ

#define SUBNET_MASK_STRING                 L"SubnetMask"
#define SUBNET_MASK_STRING_TYPE            REG_MULTI_SZ

#define USAGE_MESSAGE0  \
    "Usage:  dhcpcli { " \
    "renew,release,set,enabledhcp,disabledhcp,timestamp," \
    "leasetest,fbrefresh, reinit } parameters\n"
#define USAGE_MESSAGE1  "Usage:  dhcpcli renew adapter\n"
#define USAGE_MESSAGE2  "Usage:  dhcpcli release adapter\n"
#define USAGE_MESSAGE3  "Usage:  dhcpcli set ip-address subnet-mask adapter index \n"
#define USAGE_MESSAGE4  "Usage:  dhcpcli enabledhcp adapter\n"
#define USAGE_MESSAGE5  "Usage:  dhcpcli disabledhcp adapter ip-address subnet-mask \n"
#define USAGE_MESSAGE6  "Usage:  dhcpcli timestamp Value\n"
#define USAGE_MESSAGE7  "Usage:  dhcpcli leasetest adapter-ip-addres hardware-address\n"
#define USAGE_MESSAGE8  "Usage:  dhcpcli fbrefresh adapter\n"
#define USAGE_MESSAGE9  "Usage:  dhcpcli reinit adapter\n"

DWORD
GetRegistryString(
    HKEY Key,
    LPWSTR ValueStringName,
    LPWSTR *String,
    LPDWORD StringSize
    )
/*++

Routine Description:

    This function retrieves the specified string value from the
    registry. It allocates local memory for the returned string.

Arguments:

    Key : registry handle to the key where the value is.

    ValueStringName : name of the value string.

    String : pointer to a location where the string pointer is returned.

    StringSize : size of the string data returned. Optional

Return Value:

    The status of the operation.

--*/
{
    DWORD Error;
    DWORD LocalValueType;
    DWORD ValueSize;
    LPWSTR LocalString;

    DhcpAssert( *String == NULL );

    //
    // Query DataType and BufferSize.
    //

    Error = RegQueryValueEx(
                Key,
                ValueStringName,
                0,
                &LocalValueType,
                NULL,
                &ValueSize );

    if( Error != ERROR_SUCCESS ) {
        return(Error);
    }

    DhcpAssert( (LocalValueType == REG_SZ) ||
                    (LocalValueType == REG_MULTI_SZ) );

    if( ValueSize == 0 ) {
        *String = NULL;
        *StringSize = 0;
        return( ERROR_SUCCESS );
    }

    //
    // now allocate memory for string data.
    //

    LocalString = DhcpAllocateMemory( ValueSize );

    if(LocalString == NULL) {
        return( ERROR_NOT_ENOUGH_MEMORY );
    }

    //
    // Now query the string data.
    //

    Error = RegQueryValueEx(
                Key,
                ValueStringName,
                0,
                &LocalValueType,
                (LPBYTE)(LocalString),
                &ValueSize );

    if( Error != ERROR_SUCCESS ) {
        DhcpFreeMemory(LocalString);
        return(Error);
    }

    *String = LocalString;

    if( StringSize != NULL ) {
        *StringSize = ValueSize;
    }

    return( ERROR_SUCCESS );
}


DWORD
RegSetIpAddress(
    HKEY KeyHandle,
    LPWSTR ValueName,
    DWORD ValueType,
    DHCP_IP_ADDRESS IpAddress
    )
/*++

Routine Description:

    This function sets IpAddress Value in the registry.

Arguments:

    KeyHandle - handle to the key.

    ValueName - name of the value field.

    ValueType - Type of the value field.

    IpAddress - Ipaddress to be set.

Return Value:

    Registry Error.

--*/
{
    DWORD Error;

    LPSTR AnsiAddressString;
    WCHAR UnicodeAddressBuf[DOT_IP_ADDR_SIZE];
    LPWSTR UnicodeAddressString;

    LPWSTR MultiIpAddressString = NULL;
    LPWSTR NewMultiIpAddressString = NULL;
    DWORD MultiIpAddressStringSize;
    DWORD NewMultiIpAddressStringSize;
    DWORD FirstOldIpAddressSize;

    AnsiAddressString = inet_ntoa( *(struct in_addr *)&IpAddress );

    UnicodeAddressString = DhcpOemToUnicode(
                            AnsiAddressString,
                            UnicodeAddressBuf );

    DhcpAssert( UnicodeAddressString != NULL );

    if( ValueType == REG_SZ ) {
        Error = RegSetValueEx(
                    KeyHandle,
                    ValueName,
                    0,
                    ValueType,
                    (LPBYTE)UnicodeAddressString,
                    (wcslen(UnicodeAddressString) + 1) * sizeof(WCHAR) );

        goto Cleanup;
    }

    DhcpAssert( ValueType == REG_MULTI_SZ );

    //
    // replace the first IpAddress.
    //

    //
    // query current multi-IpAddress string.
    //

    Error = GetRegistryString(
                KeyHandle,
                ValueName,
                &MultiIpAddressString,
                &MultiIpAddressStringSize );

    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }

    //
    // allocate new address string.
    //

    DhcpAssert(MultiIpAddressString != NULL);

    FirstOldIpAddressSize =
            (wcslen(MultiIpAddressString) + 1) * sizeof(WCHAR);

    NewMultiIpAddressStringSize =
        MultiIpAddressStringSize - FirstOldIpAddressSize +
            (wcslen(UnicodeAddressString) + 1) * sizeof(WCHAR);

    NewMultiIpAddressString = DhcpAllocateMemory( NewMultiIpAddressStringSize );

    if( NewMultiIpAddressString == NULL ) {
        Error = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    //
    // make new address string first.
    //

    wcscpy( NewMultiIpAddressString, UnicodeAddressString );

    //
    // copy rest of the old addresses
    //

    RtlCopyMemory(
        (LPBYTE)NewMultiIpAddressString +
            (wcslen(UnicodeAddressString) + 1) * sizeof(WCHAR),
        (LPBYTE)MultiIpAddressString + FirstOldIpAddressSize,
        MultiIpAddressStringSize - FirstOldIpAddressSize );

    Error = RegSetValueEx(
                KeyHandle,
                ValueName,
                0,
                ValueType,
                (LPBYTE)NewMultiIpAddressString,
                NewMultiIpAddressStringSize );

Cleanup:

    if( MultiIpAddressString != NULL) {
        DhcpFreeMemory( MultiIpAddressString );
    }

    if( NewMultiIpAddressString != NULL) {
        DhcpFreeMemory( NewMultiIpAddressString );
    }

    return( Error );
}

EnableDhcp(
    char **argv
    )
{
    DWORD Error;
    LPWSTR RegKey = NULL;
    HKEY KeyHandle = NULL;
    WCHAR AdapterNameBuffer[PATHLEN];
    LPWSTR AdapterName;

    DWORD EnableDhcp;

    AdapterName = DhcpOemToUnicode( argv[0], AdapterNameBuffer );

    if( AdapterName == NULL ) {
        Error = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    //
    // make NIC IP parameter key.
    //

    RegKey = DhcpAllocateMemory(
                (wcslen(DHCP_SERVICES_KEY) +
                    wcslen(REGISTRY_CONNECT_STRING) +
                    wcslen(AdapterName) +
                    wcslen(DHCP_ADAPTER_PARAMETERS_KEY) + 1) *
                            sizeof(WCHAR) ); // termination char.

    if( RegKey == NULL ) {
        Error = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

#if     defined(_PNP_POWER_)
    wcscpy( RegKey, DHCP_SERVICES_KEY );
    wcscat( RegKey, DHCP_ADAPTER_PARAMETERS_KEY );
    wcscat( RegKey, REGISTRY_CONNECT_STRING );
    wcscat( RegKey, AdapterName );
#else
    wcscpy( RegKey, DHCP_SERVICES_KEY );
    wcscat( RegKey, REGISTRY_CONNECT_STRING );
    wcscat( RegKey, AdapterName );
    wcscat( RegKey, DHCP_ADAPTER_PARAMETERS_KEY );
#endif _PNP_POWER_


    //
    // open this key.
    //

    Error = RegOpenKeyEx(
                HKEY_LOCAL_MACHINE,
                RegKey,
                0, // Reserved field
                DHCP_CLIENT_KEY_ACCESS,
                &KeyHandle
                );

    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }

    //
    // Set DHCP switch.
    //

    EnableDhcp = TRUE;
    Error = RegSetValueEx(
                KeyHandle,
                DHCP_ENABLE_STRING,
                0,
                DHCP_ENABLE_STRING_TYPE,
                (LPBYTE)&EnableDhcp,
                sizeof(EnableDhcp) );

    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }

    //
    // set Ipaddress and SubnetMask to zero.
    //

    Error = RegSetIpAddress(
                KeyHandle,
                IP_ADDRESS_STRING,
                IP_ADDRESS_STRING_TYPE,
                0 );

    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }

    Error = RegSetIpAddress(
                KeyHandle,
                DHCP_IP_ADDRESS_STRING,
                DHCP_IP_ADDRESS_STRING_TYPE,
                0 );

    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }

    Error = RegSetIpAddress(
                KeyHandle,
                SUBNET_MASK_STRING,
                SUBNET_MASK_STRING_TYPE,
                0xff );

    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }

    Error = RegSetIpAddress(
                KeyHandle,
                DHCP_SUBNET_MASK_STRING,
                DHCP_SUBNET_MASK_STRING_TYPE,
                0xff );

    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }

    //
    // Call config API to indicate to DHCP service.
    //

    Error = DhcpNotifyConfigChange(
                L"",
                AdapterName,
                TRUE,
                0,  // AdapterIndex
                0,  // IpAddress
                0,  // SubnetMask
                DhcpEnable );

Cleanup:

    if( RegKey != NULL ) {
        DhcpFreeMemory( RegKey );
    }

    if( KeyHandle != NULL ) {
        RegCloseKey( KeyHandle );
    }

    return(Error);
}

DisableDhcp(
    char **argv
    )
{
    DWORD Error;
    LPWSTR RegKey = NULL;
    HKEY KeyHandle = NULL;

    DWORD IpAddress;
    DWORD SubnetMask;
    WCHAR AdapterNameBuffer[PATHLEN];
    LPWSTR AdapterName;

    DWORD EnableDhcp;

    AdapterName = DhcpOemToUnicode( argv[0], AdapterNameBuffer );

    if( AdapterName == NULL ) {
        Error = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    IpAddress = inet_addr( argv[1] );
    SubnetMask = inet_addr( argv[2] );

    //
    // make NIC IP parameter key.
    //

    RegKey = DhcpAllocateMemory(
                (wcslen(DHCP_SERVICES_KEY) +
                    wcslen(REGISTRY_CONNECT_STRING) +
                    wcslen(AdapterName) +
                    wcslen(DHCP_ADAPTER_PARAMETERS_KEY) + 1) *
                            sizeof(WCHAR) ); // termination char.

    if( RegKey == NULL ) {
        Error = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

#if     defined(_PNP_POWER_)
    wcscpy( RegKey, DHCP_SERVICES_KEY );
    wcscat( RegKey, DHCP_ADAPTER_PARAMETERS_KEY );
    wcscat( RegKey, REGISTRY_CONNECT_STRING );
    wcscat( RegKey, AdapterName );
#else
    wcscpy( RegKey, DHCP_SERVICES_KEY );
    wcscat( RegKey, REGISTRY_CONNECT_STRING );
    wcscat( RegKey, AdapterName );
    wcscat( RegKey, DHCP_ADAPTER_PARAMETERS_KEY );
#endif _PNP_POWER_


    //
    // open this key.
    //

    Error = RegOpenKeyEx(
                HKEY_LOCAL_MACHINE,
                RegKey,
                0, // Reserved field
                DHCP_CLIENT_KEY_ACCESS,
                &KeyHandle
                );

    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }

    //
    // Set DHCP switch.
    //

    EnableDhcp = FALSE;
    Error = RegSetValueEx(
                KeyHandle,
                DHCP_ENABLE_STRING,
                0,
                DHCP_ENABLE_STRING_TYPE,
                (LPBYTE)&EnableDhcp,
                sizeof(EnableDhcp) );

    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }

    //
    // set Ipaddress and SubnetMask to zero.
    //

    Error = RegSetIpAddress(
                KeyHandle,
                IP_ADDRESS_STRING,
                IP_ADDRESS_STRING_TYPE,
                IpAddress );

    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }

    Error = RegSetIpAddress(
                KeyHandle,
                DHCP_IP_ADDRESS_STRING,
                DHCP_IP_ADDRESS_STRING_TYPE,
                0 );

    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }

    Error = RegSetIpAddress(
                KeyHandle,
                SUBNET_MASK_STRING,
                SUBNET_MASK_STRING_TYPE,
                SubnetMask );

    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }

    Error = RegSetIpAddress(
                KeyHandle,
                DHCP_SUBNET_MASK_STRING,
                DHCP_SUBNET_MASK_STRING_TYPE,
                0xff );

    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }

    //
    // Call config API to indicate to DHCP service.
    //

    Error = DhcpNotifyConfigChange(
                L"",
                AdapterName,
                TRUE,
                0,  // AdapterIndex
                IpAddress,
                SubnetMask,
                DhcpDisable );

Cleanup:

    if( RegKey != NULL ) {
        DhcpFreeMemory( RegKey );
    }

    if( KeyHandle != NULL ) {
        RegCloseKey( KeyHandle );
    }

    return(Error);
}

SetIpAddress(
    char **argv
    )
{
    DWORD Error;
    DWORD IpAddress;
    DWORD SubnetMask;
    WCHAR AdapterNameBuffer[PATHLEN];
    LPWSTR AdapterName;
    DWORD AdapterIndex;

    IpAddress = inet_addr( argv[0] );
    SubnetMask = inet_addr( argv[1] );

    AdapterName = DhcpOemToUnicode( argv[2], AdapterNameBuffer );

    if( AdapterName == NULL ) {
        return( ERROR_NOT_ENOUGH_MEMORY );
    }

    AdapterIndex = atoi( argv[3] );

    Error = DhcpNotifyConfigChange(
                L"",
                AdapterName,
                TRUE,
                AdapterIndex,
                IpAddress,
                SubnetMask,
                IgnoreFlag );

    return( Error );
}

VOID
PrintClientLeaseInfo(
    LPDHCP_LEASE_INFO LeaseInfo
    )
{
    DWORD i;
    DWORD DataLength;
    LPBYTE Data;

    if( LeaseInfo == NULL ) {
        printf( "LeaseInfo is NULL .\n" );
    }

    printf("ClientInfo :\n");

    printf("\tClient Hardware Address = ");

    DataLength = LeaseInfo->ClientUID.ClientUIDLength;
    Data = LeaseInfo->ClientUID.ClientUID;
    for( i = 0; i < DataLength; i++ ) {
        printf("%.2lx", (DWORD)Data[i]);
    }
    printf( "\n" );

    printf("\tIP Address = %s.\n",
        DhcpIpAddressToDottedString(LeaseInfo->IpAddress));
    printf("\tSubnetMask = %s.\n",
        DhcpIpAddressToDottedString(LeaseInfo->SubnetMask));
    printf("\tDhcpServerAddress = %s.\n",
        DhcpIpAddressToDottedString(LeaseInfo->DhcpServerAddress));
    printf("\tLease = %ld secs.\n", LeaseInfo->Lease );
    printf("\tLease Obtained at %s", ctime(&LeaseInfo->LeaseObtained) );
    printf("\tT1 time is %s", ctime(&LeaseInfo->T1Time) );
    printf("\tT2 time is %s", ctime(&LeaseInfo->T2Time) );
    printf("\tLease Expires at %s", ctime(&LeaseInfo->LeaseExpires) );

    return;
}

DWORD
DhcpTestLease(
    LPSTR AdapterIpAddressString,
    LPSTR HardwareAddressString
    )
{
#define MAX_ADDRESS_LENGTH  64  // 64 bytes

    DWORD Error;
    DWORD AdapterIpAddress;
    DHCP_CLIENT_UID ClientUID;
    BYTE  Address[MAX_ADDRESS_LENGTH];
    DWORD i;
    LPDHCP_LEASE_INFO LeaseInfo = NULL;
    LPDHCP_OPTION_INFO OptionInfo;
    DHCP_OPTION_LIST OptionList;
    CHAR ch;

    AdapterIpAddress = ntohl( inet_addr( AdapterIpAddressString ) );
    ClientUID.ClientUIDLength = strlen(HardwareAddressString);
    if( ClientUID.ClientUIDLength % 2 != 0 ) {

        //
        // address must be even length.
        //

        printf("DhcpTestLease: Hardware address must be even length.\n");
        return( ERROR_INVALID_PARAMETER );
    }

    ClientUID.ClientUIDLength /= 2;

    if( ClientUID.ClientUIDLength > MAX_ADDRESS_LENGTH ) {

        printf("DhcpTestLease: hardware address is too long.\n");
        return( ERROR_INVALID_PARAMETER );
    }

    i = DhcpStringToHwAddress( (LPSTR)Address, HardwareAddressString );
    DhcpAssert( i == ClientUID.ClientUIDLength );

    ClientUID.ClientUID = Address;

    OptionList.NumOptions = 0;
    OptionList.OptionIDArray = NULL;

    Error = DhcpLeaseIpAddress(
                AdapterIpAddress,              // any subnet.
                &ClientUID,
                0,              // desired address.
                &OptionList,    // option list - not supported
                &LeaseInfo,     // lease info returned.
                &OptionInfo);   // option data returned.

    if( Error != ERROR_SUCCESS ) {
        printf("DhcpLeaseIpAddress failed, %ld.\n", Error);
        goto Cleanup;
    }

    PrintClientLeaseInfo( LeaseInfo );

    printf("Renew the lease ? (Y/N) ");

    do {
        ch = (CHAR)getchar();
    } while ( (ch != 'Y') && (ch != 'y') && (ch != 'N') && (ch != 'n') );

    printf("%c\n", ch);

    if( (ch == 'N') || (ch == 'n') ) {

        printf( "NOTE: YOU HAVE CONSUMED AN IP ADDRESS FROM "
                    "THE DHCP SERVER. \n");

        Error = ERROR_SUCCESS;
        goto Cleanup;
    }

    Error = DhcpRenewIpAddressLease(
                AdapterIpAddress,
                LeaseInfo,
                &OptionList,    // option list - not supported
                &OptionInfo);   // option data returned.

    if( Error != ERROR_SUCCESS ) {
        printf("DhcpRenewIpAddressLease failed, %ld.\n", Error);
        goto Cleanup;
    }

    PrintClientLeaseInfo( LeaseInfo );

    printf("Release the lease ? (Y/N) ");

    do {
        ch = (CHAR)getchar();
    } while ( (ch != 'Y') && (ch != 'y') && (ch != 'N') && (ch != 'n') );

    printf("%c\n", ch);

    if( (ch == 'N') || (ch == 'n') ) {

        printf( "NOTE: YOU HAVE CONSUMED AN IP ADDRESS FROM "
                    "THE DHCP SERVER. \n");

        Error = ERROR_SUCCESS;
        goto Cleanup;
    }

    Error = DhcpReleaseIpAddressLease(
                AdapterIpAddress,
                LeaseInfo );

    if( Error != ERROR_SUCCESS ) {
        printf("DhcpReleaseIpAddressLease failed, %ld.\n", Error);
        goto Cleanup;
    }

    Error = ERROR_SUCCESS;

Cleanup:

    if( LeaseInfo != NULL ) {
        DhcpFreeMemory( LeaseInfo );
    }

    return( Error );
}


DWORD __cdecl
main(
    int argc,
    char **argv
    )
{
    DWORD error;
    WCHAR AdapterNameBuffer[PATHLEN];
    LPWSTR AdapterName;

    //
    // seed random generator.
    //

    srand( GetCurrentTime() );

    if ( argc < 2) {
        printf( USAGE_MESSAGE0 );
        return( 1 );
    }

    if ( _stricmp( argv[1], "renew" ) == 0 ) {

        if ( argc < 3) {
            printf( USAGE_MESSAGE1 );
            return( 1 );
        }

        AdapterName = DhcpOemToUnicode( argv[2], AdapterNameBuffer );

        if( AdapterName == NULL ) {
            error = ERROR_NOT_ENOUGH_MEMORY;
        }
        else {
            error = DhcpAcquireParameters( AdapterName );
        }

    } else if ( _stricmp( argv[1], "fbrefresh" ) == 0 ) {

        if ( argc < 3) {
            printf( USAGE_MESSAGE8 );
            return( 1 );
        }

        AdapterName = DhcpOemToUnicode( argv[2], AdapterNameBuffer );

        if( AdapterName == NULL ) {
            error = ERROR_NOT_ENOUGH_MEMORY;
        }
        else {
            error = DhcpFallbackRefreshParams( AdapterName );
        }

    } else if ( _stricmp( argv[1], "release" ) == 0 ) {

        if ( argc < 3) {
            printf( USAGE_MESSAGE2 );
            return( 1 );
        }

        AdapterName = DhcpOemToUnicode( argv[2], AdapterNameBuffer );

        if( AdapterName == NULL ) {
            error = ERROR_NOT_ENOUGH_MEMORY;
        }
        else {
            error = DhcpReleaseParameters( AdapterName );
        }

    } else if ( _stricmp( argv[1], "set" ) == 0 ) {

        if ( argc < 6) {
            printf( USAGE_MESSAGE3 );
            return( 1 );
        }

        error = SetIpAddress( &argv[2] );


    } else if ( _stricmp( argv[1], "enabledhcp" ) == 0 ) {

        if ( argc < 3) {
            printf( USAGE_MESSAGE4 );
            return( 1 );
        }

        error = EnableDhcp( &argv[2] );


    } else if ( _stricmp( argv[1], "disabledhcp" ) == 0 ) {

        if ( argc < 5) {
            printf( USAGE_MESSAGE5 );
            return( 1 );
        }

        error = DisableDhcp( &argv[2] );


    } else if ( _stricmp( argv[1], "timestamp" ) == 0 ) {

        time_t Time;
        char *endptr;

        if ( argc < 3) {
            printf( USAGE_MESSAGE6 );
            return( 1 );
        }

        Time = strtol( argv[2], &endptr, 0 );

        if( (endptr != NULL) && (*endptr != '\0') ) {
            printf( "Invalid Input, %s\n", endptr );
            return( 1 );
        }

        printf("TimeStamp = %s\n", ctime(&Time) );
        error = ERROR_SUCCESS;


    } else if ( _stricmp( argv[1], "leasetest" ) == 0 ) {

        if ( argc < 3) {
            printf( USAGE_MESSAGE7 );
            return( 1 );
        }

        error = DhcpTestLease( argv[2], argv[3] );

    } else if ( _stricmp( argv[1], "reinit" ) == 0 ) {

        if ( argc < 3) {
            printf( USAGE_MESSAGE9 );
            return( 1 );
        }

        AdapterName = DhcpOemToUnicode( argv[2], AdapterNameBuffer );

        if( AdapterName == NULL ) {
            error = ERROR_NOT_ENOUGH_MEMORY;
        }
        else {
            error = DhcpAcquireParametersByBroadcast( AdapterName );
        }

    } else {
        printf("Unknown function %s\n", argv[1] );
        error = ERROR_INVALID_FUNCTION;
    }

    if( error != ERROR_SUCCESS ) {
        printf("Result = %d\n", error );
    }
    else {
        printf("Command completed successfully.\n");
    }

    return(0);
}

#if DBG

VOID
DhcpPrintRoutine(
    IN DWORD DebugFlag,
    IN LPSTR Format,
    ...
    )

{

#define MAX_PRINTF_LEN 1024        // Arbitrary.

    va_list arglist;
    char OutputBuffer[MAX_PRINTF_LEN];
    ULONG length = 0;

    //
    // Put a the information requested by the caller onto the line
    //

    va_start(arglist, Format);
    length += (ULONG) vsprintf(&OutputBuffer[length], Format, arglist);
    va_end(arglist);

    DhcpAssert(length <= MAX_PRINTF_LEN);

    //
    // Output to the debug terminal,
    //

    printf( "%s", OutputBuffer);
}

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\client\nt\dhcppro.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    lproto.h

Abstract:

    This file contains function proto types for the NT specific
    functions.

Author:

    Madan Appiah (madana)  Dec-7-1993

Environment:

    User Mode - Win32

Revision History:


--*/

//
// dhcpreg.c
//

DWORD
DhcpRegQueryInfoKey(
    HKEY KeyHandle,
    LPDHCP_KEY_QUERY_INFO QueryInfo
    );

DWORD
GetRegistryString(
    HKEY Key,
    LPWSTR ValueStringName,
    LPWSTR *String,
    LPDWORD StringSize
    );

DWORD
DhcpRegReadParamString(
    LPWSTR     AdapterName,
    LPWSTR     RegKeyLocation,
    LPWSTR     ValueName,
    LPWSTR    *ReturnValue
);

DWORD
RegGetIpAndSubnet(
    IN  DHCP_CONTEXT *DhcpContext,
    OUT PIP_SUBNET  *TcpConf,
    OUT int         *Count
    );

DWORD
RegSetIpAddress(
    HKEY KeyHandle,
    LPWSTR ValueName,
    DWORD ValueType,
    DHCP_IP_ADDRESS IpAddress
    );

#if DBG
DWORD
RegSetTimeField(
    HKEY KeyHandle,
    LPWSTR ValueName,
    DWORD ValueType,
    time_t Time
    );
#endif

DWORD
DhcpGetRegistryValue(
    LPWSTR RegKey,
    LPWSTR ValueName,
    DWORD ValueType,
    PVOID *Data
    );

DWORD
DhcpSetDNSAddress(
    HKEY KeyHandle,
    LPWSTR ValueName,
    DWORD ValueType,
    DHCP_IP_ADDRESS UNALIGNED *Data,
    DWORD DataLength
    );

DWORD
SetDhcpOption(
    LPWSTR AdapterName,
    DHCP_OPTION_ID OptionId,
    LPBOOL DefaultGatewaysSet,
    BOOL LastKnownDefaultGateway
    );

DWORD
DhcpMakeNICList(
    VOID
    );

DWORD
DhcpAddNICtoList(
    LPWSTR AdapterName,
    LPWSTR DeviceName,
    PDHCP_CONTEXT *DhcpContext
    );

#if     defined(_PNP_POWER_)
DWORD
DhcpAddNICtoListEx(
    LPWSTR AdapterName,
    DWORD  ipInterfaceContext,
    PDHCP_CONTEXT *DhcpContext
    );

#endif _PNP_POWER_
BOOL
SetOverRideDefaultGateway(
    LPWSTR AdapterName
    );

BOOL
DhcpGetAddressOption(
    DHCP_IP_ADDRESS **ppDNSServerList,
    DWORD            *pNumberOfServers
    );


BOOL
DhcpRegReadUseMHAsyncDnsFlag(
    VOID
);

DWORD                                             // Win32 status
DhcpInitRegistry(                                 // Initialize registry based globals
    VOID
);

VOID
DhcpCleanupRegistry(                              // undo the effects of InitReg call
    VOID
);


DHCP_IP_ADDRESS                                   // the static ip address of the adapter
DhcpRegReadIpAddress(                             // get the first ip address
    LPWSTR    AdapterName,                        // the adaptor of interest
    LPWSTR    ValueName                           // the ip address value to read
);

DWORD                                             // status
DhcpRegReadIpAddresses(                           // read a set of ip addresses
    IN      DHCPKEY                RegKeyHandle,  // open key handle
    IN      LPWSTR                 ValueName,     // name of value to read frm
    IN      WCHAR                  Separation,    // a MULTI_SZ has L'\0', SZ has L' ' or L',' etc.
    OUT     PDHCP_IP_ADDRESS      *AddressArray,  // an array of addresses
    OUT     LPDWORD                AddressCount   // the output size of above array
);

VOID
DhcpRegInitializeClasses(                         // initialize the classes list
    IN OUT  PDHCP_CONTEXT          DhcpContext    // NULL or adpater context
);

DWORD                                             // status
DhcpGetRegistryValueWithKey(                      // see defn of GetRegistryValue
    IN      HKEY                   KeyHandle,     // keyhandle NOT location
    IN      LPWSTR                 ValueName,     // value to read from registry
    IN      DWORD                  ValueType,     // type of value
    OUT     LPVOID                 Data           // this will be filled in
);

DWORD                                             // status
DhcpRegExpandString(                              // replace '?' with AdapterName
    IN      LPWSTR                 InString,      // input string to expand
    IN      LPWSTR                 AdapterName,   // the adapter name
    OUT     LPWSTR                *OutString,     // the output ptr to store string
    IN OUT  LPWSTR                 Buffer         // the buffer to use if non NULL
);

DWORD                                             // status
DhcpRegReadFromLocation(                          // read from one location
    IN      LPWSTR                 OneLocation,   // value to read from
    IN      LPWSTR                 AdapterName,   // replace '?' with adapternames
    OUT     LPBYTE                *Value,         // output value
    OUT     DWORD                 *ValueType,     // data type of value
    OUT     DWORD                 *ValueSize      // the size in bytes
);

DWORD                                             // status
DhcpRegReadFromAnyLocation(                       // read from one of many locations
    IN      LPWSTR                 MzRegLocation, // multiple locations thru REG_MULTI_MZ
    IN      LPWSTR                 AdapterName,   // may have to replace '?' with AdapterName
    OUT     LPBYTE                *Value,         // data for the value read
    OUT     DWORD                 *ValueType,     // type of the data
    OUT     DWORD                 *ValueSize      // the size of data
);

DWORD                                             // win32 status
DhcpRegFillParams(                                // get the registry config for this adapter
    IN OUT  PDHCP_CONTEXT          DhcpContext,   // adapter context to fill in
    IN      BOOL                   ReadAllInfo    // read EVERYTHING or only some critical info?
);

DWORD                                             // win32 status
DhcpRegFillFallbackConfig(                        // get the fallback config for this adapter
    IN OUT PDHCP_CONTEXT           DhcpContext    // adapter context to fill in
);

VOID
DhcpRegReadClassId(                               // Read the class id stuff
    IN      PDHCP_CONTEXT          DhcpContext    // Input context to read for
);

#ifdef BOOTPERF
VOID
DhcpRegDeleteQuickBootValues(
    IN HKEY Key
    );


VOID
DhcpRegSaveQuickBootValues(
    IN HKEY Key,
    IN ULONG IpAddress,
    IN ULONG Mask,
    IN ULONGLONG LeaseExpirationTime
    );
#endif BOOTPERF

//
// ioctl.c
//

DWORD
IPSetIPAddress(
    DWORD IpInterfaceContext,
    DHCP_IP_ADDRESS IpAddress,
    DHCP_IP_ADDRESS SubnetMask
    );

DWORD
IPAddIPAddress(
    LPWSTR AdapterName,
    DHCP_IP_ADDRESS Address,
    DHCP_IP_ADDRESS SubnetMask
    );

DWORD
IPDelIPAddress(
    DWORD IpInterfaceContext
    );

DWORD
IPResetIPAddress(
    DWORD           dwInterfaceContext,
    DHCP_IP_ADDRESS SubnetMask
    );


DWORD
SetIPAddressAndArp(
    PVOID         pvLocalInformation,
    DWORD         dwAddress,
    DWORD         dwSubnetMask
    );


DWORD
NetBTSetIPAddress(
    LPWSTR DeviceName,
    DHCP_IP_ADDRESS IpAddress,
    DHCP_IP_ADDRESS SubnetMask
    );

DWORD
NetBTResetIPAddress(
    LPWSTR DeviceName,
    DHCP_IP_ADDRESS SubnetMask
    );

DWORD
NetBTNotifyRegChanges(
    LPWSTR DeviceName
    );

DWORD
SetDefaultGateway(
    DWORD Command,
    DHCP_IP_ADDRESS GatewayAddress,
    DWORD Metric
    );

HANDLE
APIENTRY
DhcpOpenGlobalEvent(
    void
    );

#if     defined(_PNP_POWER_) && !defined(VXD)
DWORD
IPGetIPEventRequest(
    HANDLE  handle,
    HANDLE  event,
    UINT    seqNo,
    PIP_GET_IP_EVENT_RESPONSE  responseBuffer,
    DWORD                responseBufferSize,
    PIO_STATUS_BLOCK     ioStatusBlock
    );

DWORD
IPCancelIPEventRequest(
    HANDLE  handle,
    PIO_STATUS_BLOCK     ioStatusBlock
    );

#endif _PNP_POWER_ && !VXD

//
// api.c
//

DWORD
DhcpApiInit(
    VOID
    );



VOID
DhcpApiCleanup(
    VOID
    );

DWORD
ProcessApiRequest(
    HANDLE PipeHandle,
    LPOVERLAPPED Overlap
    );

//
// util.c
//

PDHCP_CONTEXT
FindDhcpContextOnNicList(
    LPCWSTR AdapterName,
    DWORD InterfaceContext
    );

//
// dhcp.c
//

DWORD
DhcpCommonInit(
    VOID
    );


DWORD
SetIpConfigurationForNIC(
    HKEY            KeyHandle,
    PDHCP_CONTEXT   DhcpContext,
    PDHCP_OPTIONS   DhcpOptions,
    DHCP_IP_ADDRESS ServerIpAddress,
    DWORD           dwLeaseTime,
    DWORD           dwT1Time,
    DWORD           dwT2Time,
    BOOL            ObtainedNewAddress
    );

#ifdef BOOTPERF
DWORD
DhcpQueryHWInfoEx(
    DWORD   IpInterfaceContext,
    DWORD  *pIpInterfaceInstance,
    DWORD  *pOldIpAddress OPTIONAL,
    DWORD  *pOldMask OPTIONAL,
    BOOL   *pfInterfaceDown OPTIONAL,
    LPBYTE  HardwareAddressType,
    LPBYTE *HardwareAddress,
    LPDWORD HardwareAddressLength
    );
#endif BOOTPERF

DWORD
IPGetWOLCapability(
    IN ULONG IfIndex,
    OUT PULONG pRetVal
    );


DWORD
QueryIfIndex(
    IN ULONG IpInterfaceContext,
    IN ULONG IpInterfaceInstance
    );

BOOL
IsUnidirectionalAdapter(
    IN DWORD IpInterfaceContext
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\client\nt\apiappl.c ===
#include "precomp.h"

#ifdef H_ONLY
//================================================================================
//  Copyright (C) 1997 Microsoft Corporation
//  Author: RameshV
//  Description: these are the exported dhcp client api function definitions
//================================================================================

#ifndef APIAPPL_H_INCLUDED
#define APIAPPL_H_INCLUDED

#ifndef DHCPAPI_PARAMS_DEFINED
#define DHCPAPI_PARAMS_DEFINED
typedef struct _DHCPAPI_PARAMS {                  // use this structure to request params
    ULONG                          Flags;         // for future use
    ULONG                          OptionId;      // what option is this?
    BOOL                           IsVendor;      // is this vendor specific?
    LPBYTE                         Data;          // the actual data
    DWORD                          nBytesData;    // how many bytes of data are there in Data?
} DHCPAPI_PARAMS, *PDHCPAPI_PARAMS, *LPDHCPAPI_PARAMS;
#endif DHCPAPI_PARAMS_DEFINED

DWORD                                             // win32 status
DhcpAcquireParameters(                            // acquire/renew a lease
    IN      LPWSTR                 AdapterName    // adapter to acquire lease on
);

DWORD                                             // win32 status
DhcpAcquireParametersByBroadcast(                 // acquire/renew a lease
    IN      LPWSTR                 AdapterName    // adapter to acquire lease on
);

DWORD                                             // win32 status
DhcpFallbackRefreshParams(                        // refresh fallback params
    IN      LPWSTR                 AdapterName    // adapter to be refreshed
);

DWORD                                             // win32 status
DhcpReleaseParameters(                            // release an existing lease
    IN      LPWSTR                 AdapterName    // adpater to release lease for
);

DWORD                                             // win32 status
DhcpEnableDynamicConfic(                          // convert from static to dhcp
    IN      LPWSTR                 AdapterName    // convert for this adapter
);

DWORD                                             // win32 status
DhcpDisableDynamicConfig(                         // convert from dhcp to static
    IN      LPWSTR                 AdapterName    // convert this adapter
);

DWORD                                             // win32 status
DhcpReRegisterDynDns(                             // reregister static address with dns
    IN      LPWSTR                 AdapterName
);

DWORD                                             // win32 status
APIENTRY
DhcpRequestParams(                                // request parameters of client
    IN      LPWSTR                 AdapterName,   // adapter name to request for
    IN      LPBYTE                 ClassId,       // byte stream of class id to use
    IN      DWORD                  ClassIdLen,    // # of bytes of class id to use
    IN      PDHCPAPI_PARAMS        SendParams,    // parameters to send to server
    IN      DWORD                  nSendParams,   // size of above array
    IN      DWORD                  Flags,         // must be zero, reserved
    IN OUT  PDHCPAPI_PARAMS        RecdParams,    // fill this array with received params
    IN OUT  LPDWORD                pnRecdParamsBytes // i/p: size of above in BYTES, o/p required bytes or filled up # of elements
);  // returns ERROR_MORE_DATA if o/p buffer is of insufficient size, and fills in reqd size in # of bytes

DWORD                                             // win32 status
DhcpRegisterParameterChangeNotification(          // notify if a parameter has changed
    IN      LPWSTR                 AdapterName,   // adapter of interest
    IN      LPBYTE                 ClassId,       // byte stream of class id to use
    IN      DWORD                  ClassIdLen,    // # of bytes of class id
    IN      PDHCPAPI_PARAMS        Params,        // params of interest
    IN      DWORD                  nParams,       // # of elts in above array
    IN      DWORD                  Flags,         // must be zero, reserved
    IN OUT  PHANDLE                hEvent         // handle to event that will be SetEvent'ed in case of param change
);

DhcpDeRegisterParameterChangeNotification(        // undo the registration
    IN      HANDLE                 Event          // handle to event returned by DhcpRegisterParameterChangeNotification, NULL ==> everything
);

DWORD                                             // win32 status
DhcpPersistentRequestParams(                      // parameters to request persistently
    IN      LPWSTR                 AdapterName,   // adapter name to request for
    IN      LPBYTE                 ClassId,       // byte stream of class id to use
    IN      DWORD                  ClassIdLen,    // # of bytes of class id
    IN      PDHCPAPI_PARAMS        SendParams,    // persistent parameters
    IN      DWORD                  nSendParams,   // size of above array
    IN      DWORD                  Flags,         // must be zero, reserved
    IN      LPWSTR                 AppName,       // the name of the app that is to be used for this instance
    IN OUT  LPDWORD                UniqueId       // OPTIONAL, return value is id that can be used in DhcpDelPersistentRequestParams
);


DWORD                                             // win32 status
DhcpDelPersistentRequestParams(                   // undo the effect of a persistent request -- currently undo from registry
    IN      LPWSTR                 AdapterName,   // the name of the adpater to delete for
    IN      LPWSTR                 AppName,       // the name used by the app
    IN      DWORD                  UniqueId       // something for this instance
);

#endif APIAPPL_H_INCLUDED
#else  H_ONLY

#include <apiargs.h>
#include <apistub.h>
#include <apiimpl.h>
#include <apiappl.h>
#include <dhcploc.h>
#include <dhcppro.h>
#include <dhcpcsdk.h>

DWORD INLINE                                      // win32 status
DhcpApiFillBuffer(                                // fill the buffer with some params
    IN OUT  LPBYTE                 Buffer,        // the buffer to fill
    IN      DWORD                  MaxBufferSize, // the max size of buffer allwoed
    IN      LPWSTR                 AdapterName,   // fill in adapter name
    IN      BYTE                   OpCode         // what opcode to use?
) {
    DWORD                          Size;

    if( NULL == AdapterName ) Size = 0;
    else Size = (wcslen(AdapterName)+1)*sizeof(WCHAR);

    return DhcpApiArgAdd(                         // fill in the buffer with the reqd options
        Buffer,
        MaxBufferSize,
        OpCode,
        Size,
        (LPBYTE)AdapterName
    );
}

DWORD INLINE                                      // win32 status
DhcpAdapterOnlyApi(                               // execute apis that take only adapter name params
    IN      LPWSTR                 AdapterName,   // the adapter name
    IN      BYTE                   OpCode
) 
{
    LPBYTE                         Buffer;
    LPBYTE                         Buffer2;
    DWORD                          BufSize;
    DWORD                          Size;
    DWORD                          Error;

    BufSize = 0;
    Error = DhcpApiFillBuffer((LPBYTE)&BufSize, sizeof(BufSize), AdapterName, OpCode);
    DhcpAssert( ERROR_SUCCESS != Error );
    if( ERROR_MORE_DATA != Error ) return Error;
    DhcpAssert(BufSize);
    BufSize = ntohl(BufSize) + 2*sizeof(DWORD);

    Buffer = DhcpAllocateMemory(BufSize);
    if( NULL == Buffer ) return ERROR_NOT_ENOUGH_MEMORY;

    *(DWORD UNALIGNED *)Buffer = htonl(0);
    Buffer2 = Buffer + sizeof(DWORD);
    *(DWORD UNALIGNED *)Buffer2 = 0;
    BufSize -= sizeof(DWORD);
    Error = DhcpApiFillBuffer(Buffer2, BufSize, AdapterName, OpCode);
    Size = 0;
    if( ERROR_SUCCESS == Error ) Error = ExecuteApiRequest(Buffer, NULL, &Size);
    DhcpFreeMemory(Buffer);

    return Error;
}

DWORD                                             // win32 status
DhcpAcquireParameters(                            // acquire/renew a lease
    IN      LPWSTR                 AdapterName    // adapter to acquire lease on
) {
    return DhcpAdapterOnlyApi(AdapterName, AcquireParametersOpCode);
}

DWORD                                             // win32 status
DhcpAcquireParametersByBroadcast(                 // acquire/renew a lease
    IN      LPWSTR                 AdapterName    // adapter to acquire lease on
) {
    return DhcpAdapterOnlyApi(AdapterName, AcquireParametersByBroadcastOpCode);
}

DWORD                                             // win32 status
DhcpFallbackRefreshParams(                        // refresh fallback params
    IN LPWSTR AdapterName                         // adapter to be refreshed
)
{
    return DhcpAdapterOnlyApi(AdapterName, FallbackParamsOpCode);
}

DWORD                                             // win32 status
DhcpReleaseParameters(                            // release an existing lease
    IN      LPWSTR                 AdapterName    // adpater to release lease for
) {
    return DhcpAdapterOnlyApi(AdapterName, ReleaseParametersOpCode);
}

DWORD                                             // win32 status
DhcpEnableDynamicConfig(                          // convert from static to dhcp
    IN      LPWSTR                 AdapterName    // convert for this adapter
) {
    return DhcpAdapterOnlyApi(AdapterName, EnableDhcpOpCode);
}

DWORD                                             // win32 status
DhcpDisableDynamicConfig(                         // convert from dhcp to static
    IN      LPWSTR                 AdapterName    // convert this adapter
) {
    return DhcpAdapterOnlyApi(AdapterName, DisableDhcpOpCode);
}

DWORD                                             // win32 status
DhcpStaticRefreshParamsInternal(                  // refresh some static parameters that have changed
    IN      LPWSTR                 AdapterName,
    IN      BOOL                   fDoDns
) 
{
    LPBYTE Buffer, Buffer2;
    DWORD BufSize, Size, Error, Code;

    BufSize = 0;
    Error = DhcpApiFillBuffer(
        (LPBYTE)&BufSize, sizeof(BufSize), AdapterName, StaticRefreshParamsOpCode
        );
    if( ERROR_MORE_DATA != Error ) return Error;
    DhcpAssert( BufSize );
    BufSize = ntohl(BufSize) + 2 * sizeof(DWORD);
    BufSize += 3*sizeof(DWORD);

    Buffer = DhcpAllocateMemory( BufSize );
    if( NULL == Buffer ) return ERROR_NOT_ENOUGH_MEMORY;
    
    *(DWORD*)Buffer = 0;
    Buffer2 = Buffer + sizeof(DWORD);
    *(DWORD*)Buffer2 = 0;

    BufSize -= sizeof(DWORD);
    Error = DhcpApiFillBuffer(
        Buffer2, BufSize, AdapterName, StaticRefreshParamsOpCode
        );
    DhcpAssert( ERROR_SUCCESS == Error );
    Code = (fDoDns ? 0x00 : 0x01);
    Error = DhcpApiArgAdd(
        Buffer2, BufSize, (BYTE)FlagsParam, sizeof(DWORD), (LPBYTE)&Code
        );
    DhcpAssert( ERROR_SUCCESS == Error );

    Size = 0;
    Error =  ExecuteApiRequest(Buffer, NULL, &Size); 
    DhcpFreeMemory( Buffer );
    return Error;
}

DWORD
DhcpStaticRefreshParams(
    IN LPWSTR AdapterName
)
{
    return DhcpStaticRefreshParamsInternal(AdapterName, TRUE );
}

#if 0
// pl dont use this api, use DhcpRequestParams instead.
DWORD                                             // win32 status
DhcpRequestOptions(                               // request for specific options
    IN      LPWSTR                 AdapterName,   // which adapter's info is needed
    IN      LPBYTE                 RequestedOpt,  // list of requested options
    IN      DWORD                  nRequestedOpts,// size of above BYTE array
    OUT     LPBYTE                *OptData,       // the data for each available option
    IN OUT  LPDWORD                OptDataSize,   // # of bytes of above byte array
    OUT     LPBYTE                *AvailOpts,     // the list of available options
    IN OUT  LPDWORD                nAvailOpts     // # of available options
) {
    PDHCP_API_ARGS                 DhcpApiArgs;
    CHAR                           TmpBuf[OPTION_END+1];
    LPBYTE                         OutBuf;
    LPBYTE                         InBuf;
    LPBYTE                         Buffer;
    LPBYTE                         Endp;
    LPBYTE                         RetOptList;
    LPBYTE                         RetDataList;
    DWORD                          Size;
    DWORD                          OutBufSize;
    DWORD                          InBufSize;
    DWORD                          i;
    DWORD                          nArgsReturned;
    DWORD                          Error;
    BOOL                           Tmp;

    // check parameter consistency
    if( NULL == AdapterName || NULL == RequestedOpt || 0 == nRequestedOpts )
        return ERROR_INVALID_PARAMETER;

    if( NULL == AvailOpts || 0 == nAvailOpts || NULL == OptData || 0 == OptDataSize )
        return ERROR_INVALID_PARAMETER;

    if( nRequestedOpts >= OPTION_END ) return ERROR_NO_SYSTEM_RESOURCES;

    // initialize out params
    (*nAvailOpts) = (*OptDataSize) = 0;
    (*AvailOpts) = (*OptData) = NULL;

    // calculate input buffer size for ONE option to be sent and allocate it
    InBufSize = 0;
    InBufSize += sizeof(DWORD)*2;                 // INBUF_SIZE, OUTBUF_SIZE
    InBufSize += sizeof(BYTE)+sizeof(DWORD)+(1+wcslen(AdapterName))*sizeof(WCHAR);
    InBufSize += sizeof(BYTE)+sizeof(DWORD)+nRequestedOpts+sizeof(BYTE);

    InBuf = DhcpAllocateMemory(InBufSize);
    if( NULL == InBuf ) return ERROR_NOT_ENOUGH_MEMORY;

    // intialize ptrs
    OutBufSize = 0; OutBuf = NULL;
    DhcpApiArgs = NULL;
    RetOptList = RetDataList = NULL;

    // now fill the input buffer
    ((DWORD UNALIGNED*)InBuf)[0] = htonl(OutBufSize);
    ((DWORD UNALIGNED*)InBuf)[1] = 0;
    Buffer = InBuf + sizeof(DWORD); InBufSize -= sizeof(DWORD);

    Error = DhcpApiFillBuffer(Buffer, InBufSize, AdapterName, RequestParamsOpCode);
    DhcpAssert(ERROR_SUCCESS == Error);

    TmpBuf[0] = (BYTE)OPTION_PARAMETER_REQUEST_LIST;
    memcpy(&TmpBuf[1], RequestedOpt, nRequestedOpts);

    Error = DhcpApiArgAdd(Buffer, InBufSize, NormalOptionParam, nRequestedOpts+1, TmpBuf);
    DhcpAssert(ERROR_SUCCESS == Error);

    Error = ExecuteApiRequest(InBuf, NULL, &OutBufSize);
    if( ERROR_SUCCESS == Error ) {
        DhcpAssert(0 == OutBufSize);
        goto Cleanup;
    }
    if( ERROR_MORE_DATA != Error ) goto Cleanup;  // ERROR_MORE_DATA ==> need to allocate buffer

    DhcpPrint((DEBUG_OPTIONS, "RequestOptions: retrying with buffer size [%ld]\n", OutBufSize));
    DhcpAssert(OutBufSize);
    OutBuf = DhcpAllocateMemory(OutBufSize);
    if( NULL == OutBuf) {
        Error = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    ((DWORD UNALIGNED*)InBuf)[0] = htonl(OutBufSize);
    Error = ExecuteApiRequest(InBuf, OutBuf, &OutBufSize);
    DhcpAssert(ERROR_MORE_DATA != Error);         // can happen, just hope it does not...
    if( ERROR_SUCCESS != Error ) goto Cleanup;    // unexpected error

    nArgsReturned = 0;
    DhcpApiArgs = NULL;
    Error = DhcpApiArgDecode(OutBuf, OutBufSize, DhcpApiArgs, &nArgsReturned );
    if( ERROR_MORE_DATA != Error ) goto Cleanup;
    DhcpAssert(nArgsReturned);
    if( 0 == nArgsReturned ) goto Cleanup;        // no options sent? funny.. still, quit its

    DhcpApiArgs = DhcpAllocateMemory(sizeof(DHCP_API_ARGS)*nArgsReturned);
    if( NULL == DhcpApiArgs ) {
        Error = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    nArgsReturned = 0;
    Error = DhcpApiArgDecode(OutBuf, OutBufSize, DhcpApiArgs, &nArgsReturned);
    if( ERROR_SUCCESS != Error ) {
        DhcpAssert(FALSE);
        goto Cleanup;
    }
    DhcpAssert(nArgsReturned);

    RetOptList = DhcpAllocateMemory(nArgsReturned);
    if( NULL == RetOptList ) {
        Error = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    Size = 0;
    for( i = 0; i < nArgsReturned; i ++ ) {
        DhcpAssert(DhcpApiArgs[i].ArgId == NormalOptionParam);
        if( DhcpApiArgs[i].ArgId != NormalOptionParam ) continue;
        DhcpAssert(DhcpApiArgs[i].ArgSize <= OPTION_END +1 );
        if( DhcpApiArgs[i].ArgSize <= 1 ) continue;

        Size += DhcpApiArgs[i].ArgSize;
    }
    RetDataList = DhcpAllocateMemory(Size);
    if( NULL == RetDataList ) {
        Error = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    Size = 0;
    for(i = 0; i < nArgsReturned; i ++ ) {
        if( DhcpApiArgs[i].ArgId != NormalOptionParam ) continue;
        if( DhcpApiArgs[i].ArgSize <= 1 ) continue;
        RetOptList[i] = DhcpApiArgs[i].ArgVal[0];
        RetDataList[Size++] = (BYTE)(DhcpApiArgs[i].ArgSize - 1);
        memcpy(&RetDataList[Size], DhcpApiArgs[i].ArgVal, DhcpApiArgs[i].ArgSize - 1);
        Size += DhcpApiArgs[i].ArgSize - 1;
    }

    (*AvailOpts) = RetOptList;
    (*nAvailOpts) = nArgsReturned;
    (*OptData) = RetDataList;
    (*OptDataSize) = Size;

    DhcpFreeMemory(InBuf);
    DhcpFreeMemory(OutBuf);
    DhcpFreeMemory(DhcpApiArgs);

    return ERROR_SUCCESS;

  Cleanup:
    if( InBuf ) DhcpFreeMemory(InBuf);
    if( OutBuf ) DhcpFreeMemory(OutBuf);
    if( DhcpApiArgs ) DhcpFreeMemory(DhcpApiArgs);
    if( RetDataList ) DhcpFreeMemory(RetDataList);
    if( RetOptList) DhcpFreeMemory(RetOptList);
    return Error;
}
#endif
// pl dont use this api, use DhcpRequestParams instead.
DWORD                                             // win32 status
DhcpRequestOptions(                               // request for specific options
    IN      LPWSTR                 AdapterName,   // which adapter's info is needed
    IN      LPBYTE                 RequestedOpt,  // list of requested options
    IN      DWORD                  nRequestedOpts,// size of above BYTE array
    OUT     LPBYTE                *OptData,       // the data for each available option
    IN OUT  LPDWORD                OptDataSize,   // # of bytes of above byte array
    OUT     LPBYTE                *AvailOpts,     // the list of available options
    IN OUT  LPDWORD                nAvailOpts     // # of available options
) {
    DHCPAPI_PARAMS                 SendParams;
    PDHCPAPI_PARAMS                RecdParams;
    LPBYTE                         RetDataList;
    LPBYTE                         RetOptList;
    DWORD                          nRecdParams;
    DWORD                          Error;
    DWORD                          i;
    DWORD                          OutBufSize;

    // check parameter consistency
    if( NULL == AdapterName || NULL == RequestedOpt || 0 == nRequestedOpts )
        return ERROR_INVALID_PARAMETER;

    if( NULL == AvailOpts || 0 == nAvailOpts || NULL == OptData || 0 == OptDataSize )
        return ERROR_INVALID_PARAMETER;

    if( nRequestedOpts >= OPTION_END ) return ERROR_NO_SYSTEM_RESOURCES;

    // initialize out params
    (*nAvailOpts) = (*OptDataSize) = 0;
    (*AvailOpts) = (*OptData) = NULL;

    // try to process this request
    SendParams.OptionId = (BYTE)OPTION_PARAMETER_REQUEST_LIST;
    SendParams.IsVendor = FALSE;
    SendParams.Data = RequestedOpt;
    SendParams.nBytesData = nRequestedOpts;

    nRecdParams = 0;
    Error = DhcpRequestParameters(
        AdapterName,
        NULL,
        0,
        &SendParams,
        1,
        0,
        NULL,
        &nRecdParams
    );
    if( ERROR_MORE_DATA != Error ) return Error;

    while ( TRUE ) {
        DhcpAssert(nRecdParams);
        DhcpPrint((DEBUG_OPTIONS, "RequestOptions: require: 0x%lx bytes\n", nRecdParams));
        
        RecdParams = DhcpAllocateMemory(nRecdParams);
        if( NULL == RecdParams ) return ERROR_NOT_ENOUGH_MEMORY;
        
        Error = DhcpRequestParameters(
            AdapterName,
            NULL,
            0,
            &SendParams,
            1,
            0,
            RecdParams,
            &nRecdParams
            );

        // DhcpAssert(ERROR_MORE_DATA != Error);
        if( ERROR_SUCCESS != Error ) {
            DhcpPrint((DEBUG_ERRORS, "RequestOptions:RequestParams:0x%lx\n", Error));
            DhcpFreeMemory(RecdParams);
            if( ERROR_MORE_DATA == Error ) continue;
            return Error;
        }
        break;
    }

    if( 0 == nRecdParams ) return ERROR_SUCCESS;

    DhcpPrint((DEBUG_OPTIONS, "Received 0x%lx options\n", nRecdParams));

    RetOptList = NULL;
    RetDataList = NULL;
    OutBufSize = 0;
    for( i = 0; i < nRecdParams; i ++ ) {
        DhcpPrint((DEBUG_TRACE, "Received option 0x%lx, 0x%lx bytes\n",
                   RecdParams[i].OptionId, RecdParams[i].nBytesData));
        OutBufSize += RecdParams[i].nBytesData + sizeof(BYTE);
    }

    RetOptList = DhcpAllocateMemory(nRecdParams);
    RetDataList = DhcpAllocateMemory(OutBufSize);
    if( NULL == RetOptList || NULL == RetDataList ) {
        if( RetOptList ) DhcpFreeMemory(RetOptList);
        if( RetDataList ) DhcpFreeMemory(RetDataList);
        if( RecdParams ) DhcpFreeMemory(RecdParams);
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    OutBufSize = 0;
    for( i = 0; i < nRecdParams ; i ++ ) {
        RetOptList[i] = (BYTE)RecdParams[i].OptionId;
        RetDataList[OutBufSize++] = (BYTE)RecdParams[i].nBytesData;
        memcpy(&RetDataList[OutBufSize], RecdParams[i].Data, RecdParams[i].nBytesData);
        OutBufSize += RecdParams[i].nBytesData;
    }

    (*AvailOpts) = RetOptList;
    (*nAvailOpts) = nRecdParams;
    (*OptData) = RetDataList;
    (*OptDataSize) = OutBufSize;

    if( RecdParams ) DhcpFreeMemory(RecdParams);

    return ERROR_SUCCESS;
}

DWORD                                             // win32 status
DhcpRequestParamsInternalEx(                      // request parameters of client
    IN      BYTE                   OpCode,        // opcode to use
    IN      LPWSTR                 AdapterName,   // adapter name to request for
    IN      LPBYTE                 ClassId,       // byte stream of class id to use
    IN      DWORD                  ClassIdLen,    // # of bytes of class id to use
    IN      PDHCPAPI_PARAMS        SendParams,    // parameters to send to server
    IN      DWORD                  nSendParams,   // size of above array
    IN      DWORD                  Flags,         // must be zero, reserved
    IN OUT  PDHCPAPI_PARAMS        RecdParams,    // fill this array with received params
    IN OUT  DWORD                 *pnRecdParams,  // input: size of above array output: filled size
    IN      LPBYTE                 Bufp,          // buffer for data ptrs
    IN OUT  LPDWORD                pSize          // i/p: size of above array, o/p filled size
)
{
    PDHCP_API_ARGS                 DhcpApiArgs = NULL;
    LPBYTE                         OutBuf;
    LPBYTE                         InBuf = NULL;
    LPBYTE                         Buffer;
    LPBYTE                         Endp;
    DWORD                          OutBufSize;
    DWORD                          InBufSize;
    DWORD                          i,j;
    DWORD                          nArgsReturned;
    DWORD                          Error;
    DWORD                          nRecdParams = (*pnRecdParams);
    DWORD                          nParamsRequested;
    DWORD                          nVParamsRequested;
    ULONG                          Tmp, VTmp;
    CHAR                           TmpBuf[256], VTmpBuf[256];

    // check parameter consistency

    if( ClassIdLen && NULL == ClassId) return ERROR_INVALID_PARAMETER;
    if( 0 == ClassIdLen && NULL != ClassId ) return ERROR_INVALID_PARAMETER;
    if( nSendParams && NULL == SendParams) return ERROR_INVALID_PARAMETER;
    if( 0 == nSendParams && NULL != SendParams) return ERROR_INVALID_PARAMETER;
    if( NULL == RecdParams || 0 == nRecdParams ) return ERROR_INVALID_PARAMETER;
    if( NULL == AdapterName ) return ERROR_INVALID_PARAMETER;
    Tmp = VTmp = 0;
    for( i = 0; i < nRecdParams ; i ++ ) {
        if( FALSE == RecdParams[i].IsVendor ) {
            TmpBuf[ ++Tmp] = (BYTE)RecdParams[i].OptionId;
        } else {
            VTmpBuf[ ++VTmp] = (BYTE)RecdParams[i].OptionId;
        }
    }
    if( 0 == (VTmp + Tmp) ) return ERROR_INVALID_PARAMETER;

    // allocate buffers

    OutBufSize = (*pSize);
    (*pSize) = 0;

    if( 0 ==  OutBufSize ) OutBuf = NULL;
    else {
        OutBuf = Bufp;
    }

    // calculate input buffer size required

    InBufSize = 0;
    InBufSize += (DWORD)(sizeof(DWORD)*2);                 // INBUF_SIZE, OUTBUF_SIZE
    InBufSize += (DWORD)(sizeof(BYTE)+sizeof(DWORD)+(1+wcslen(AdapterName))*sizeof(WCHAR));
    if( ClassIdLen )
        InBufSize += sizeof(BYTE)+sizeof(DWORD)+ClassIdLen;
    for( i = 0; i < nSendParams; i ++ ) {
        InBufSize += sizeof(BYTE)+sizeof(DWORD)+sizeof(BYTE)+SendParams[i].nBytesData;
    }

    //
    // Now for options request list (vendor and otherwise)
    //

    if( Tmp ) {
        InBufSize += sizeof(BYTE)+sizeof(DWORD)+sizeof(BYTE)+Tmp;
    }
    if( VTmp ) {
        InBufSize += sizeof(BYTE)+sizeof(DWORD)+sizeof(BYTE)+VTmp;
    }

    InBuf = DhcpAllocateMemory(InBufSize);
    if( NULL == InBuf ) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    // fill up output buffer size right at start of input buffer

    ((DWORD UNALIGNED*)InBuf)[0] = htonl(OutBufSize);
    ((DWORD UNALIGNED*)InBuf)[1] = 0;

    Buffer = InBuf + sizeof(DWORD);
    InBufSize -= sizeof(DWORD);

    // fill in input buffer

    Error = DhcpApiFillBuffer(Buffer, InBufSize, AdapterName, OpCode);
    DhcpAssert(ERROR_SUCCESS == Error);

    if( ClassIdLen ) {
        Error = DhcpApiArgAdd(Buffer, InBufSize, ClassIdParam, ClassIdLen, ClassId);
        DhcpAssert(ERROR_SUCCESS == Error);
    }

    for( i = 0; i < nSendParams; i ++ ) {
        BYTE                       Buf[OPTION_END+1];
        BYTE                       OpCode;

        Buf[0] = (BYTE)SendParams[i].OptionId;
        memcpy(&Buf[1], SendParams[i].Data, SendParams[i].nBytesData);
        OpCode = SendParams[i].IsVendor? VendorOptionParam: NormalOptionParam;
        Error = DhcpApiArgAdd(Buffer, InBufSize, OpCode, SendParams[i].nBytesData+1, Buf);
        DhcpAssert(ERROR_SUCCESS == Error);
    }

    //
    // Now fillup the request lists (vendor & otherwise)
    //

    if( Tmp ) {
        TmpBuf[0] = (BYTE)OPTION_PARAMETER_REQUEST_LIST;
        Error = DhcpApiArgAdd(Buffer, InBufSize, NormalOptionParam, Tmp+1, TmpBuf);
        DhcpAssert(ERROR_SUCCESS == Error);
    }
    if( VTmp ) {
        VTmpBuf[0] = (BYTE)OPTION_PAD;
        Error = DhcpApiArgAdd(Buffer, InBufSize, VendorOptionParam, VTmp+1, VTmpBuf);
    }

    // now, execute and obtain the output filled in OutBuf

    Error = ExecuteApiRequest(InBuf, OutBuf, &OutBufSize);
    (*pSize) = OutBufSize;
    if( ERROR_MORE_DATA == Error ) {
        // recalculate the real OutBufSize required
        DhcpAssert(OutBufSize != 0);
        goto Cleanup;
    }

    if( ERROR_SUCCESS != Error ) goto Cleanup;
    if( 0 == OutBufSize ) goto Cleanup;

    // parse output and fill in the structures..
    nArgsReturned = 0;
    DhcpApiArgs = NULL;
    Error = DhcpApiArgDecode(OutBuf, OutBufSize, DhcpApiArgs, &nArgsReturned);
    DhcpAssert( 0 == nArgsReturned || ERROR_MORE_DATA == Error);
    if( ERROR_MORE_DATA != Error ) goto Cleanup;
    DhcpAssert(0 != nArgsReturned);
    DhcpApiArgs = DhcpAllocateMemory( sizeof(DHCP_API_ARGS) * nArgsReturned);
    if( NULL == DhcpApiArgs ) {
        Error = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    Error = DhcpApiArgDecode(OutBuf, OutBufSize, DhcpApiArgs, &nArgsReturned);
    DhcpAssert(ERROR_SUCCESS == Error);
    DhcpAssert(nArgsReturned);

    for(i = j = 0; i < nArgsReturned; i ++ ) {
        DhcpAssert( VendorOptionParam == DhcpApiArgs[i].ArgId || NormalOptionParam == DhcpApiArgs[i].ArgId);
        DhcpAssert( DhcpApiArgs[i].ArgSize > 1);  // one byte for option id, and atleast one byte actual option
        if( VendorOptionParam != DhcpApiArgs[i].ArgId && NormalOptionParam != DhcpApiArgs[i].ArgId )
            continue;
        RecdParams[j].OptionId = DhcpApiArgs[i].ArgVal[0];
        RecdParams[j].IsVendor = ( VendorOptionParam == DhcpApiArgs[i].ArgId );
        RecdParams[j].nBytesData = DhcpApiArgs[i].ArgSize-1;
        RecdParams[j].Data = &DhcpApiArgs[i].ArgVal[1];
        j ++;
    }
    (*pnRecdParams) = j;

    Error = ERROR_SUCCESS;

  Cleanup:
    if( NULL != InBuf ) DhcpFreeMemory(InBuf);
    if( NULL != DhcpApiArgs ) DhcpFreeMemory(DhcpApiArgs);
    return Error;
}

DWORD                                             // win32 status
DhcpRequestParamsInternal(                        // request parameters of client
    IN      BYTE                   OpCode,        // opcode to use
    IN      LPWSTR                 AdapterName,   // adapter name to request for
    IN      LPBYTE                 ClassId,       // byte stream of class id to use
    IN      DWORD                  ClassIdLen,    // # of bytes of class id to use
    IN      PDHCPAPI_PARAMS        SendParams,    // parameters to send to server
    IN      DWORD                  nSendParams,   // size of above array
    IN      DWORD                  Flags,         // must be zero, reserved
    IN OUT  PDHCPAPI_PARAMS        RecdParams,    // fill this array with received params
    IN OUT  LPDWORD                pnRecdParams   // i/p: size of above in BYTES, o/p required or filled up size
) {
    PDHCP_API_ARGS                 DhcpApiArgs = NULL;
    LPBYTE                         OutBuf;
    LPBYTE                         InBuf = NULL;
    LPBYTE                         Buffer;
    LPBYTE                         Endp;
    DWORD                          OutBufSize;
    DWORD                          InBufSize;
    DWORD                          i,j;
    DWORD                          nArgsReturned;
    DWORD                          Error;
    DWORD                          nParamsRequested;
    DWORD                          nVParamsRequested;
    ULONG                          Tmp, VTmp;
    ULONG                          OriginalOutBufSize;
        
    // check parameter consistency

    if( ClassIdLen && NULL == ClassId) return ERROR_INVALID_PARAMETER;
    if( 0 == ClassIdLen && NULL != ClassId ) return ERROR_INVALID_PARAMETER;
    if( nSendParams && NULL == SendParams) return ERROR_INVALID_PARAMETER;
    if( 0 == nSendParams && NULL != SendParams) return ERROR_INVALID_PARAMETER;
    if( NULL == pnRecdParams ) return ERROR_INVALID_PARAMETER;
    if( *pnRecdParams && NULL == RecdParams ) return ERROR_INVALID_PARAMETER;
    if( NULL == AdapterName ) return ERROR_INVALID_PARAMETER;
    Tmp = VTmp = 0;
    for( i = 0; i < nSendParams ; i ++ ) {
        if( SendParams[i].nBytesData > OPTION_END ) return ERROR_INVALID_PARAMETER;
        if( SendParams[i].nBytesData && NULL == SendParams[i].Data )
            return ERROR_INVALID_PARAMETER;
        if( OPTION_PARAMETER_REQUEST_LIST == SendParams[i].OptionId ) {
            if( SendParams[i].IsVendor ) continue;
            nParamsRequested = SendParams[i].nBytesData;
            Tmp ++;
        }
        if( OPTION_PAD == SendParams[i].OptionId ) {
            if( !SendParams[i].IsVendor ) continue;
            nVParamsRequested = SendParams[i].nBytesData;
            VTmp ++;
        }
    }
    if( 0 == (VTmp + Tmp) || 1 < VTmp || 1 < Tmp ) return ERROR_INVALID_PARAMETER;
    if( 0 == Tmp) nParamsRequested = 0;
    if( VTmp ) nParamsRequested += nVParamsRequested;

    // allocate buffers

    OriginalOutBufSize = OutBufSize = (*pnRecdParams);
    (*pnRecdParams) = 0;

    if( 0 ==  OutBufSize ) OutBuf = NULL;
    else {
        OutBuf = DhcpAllocateMemory(OutBufSize);
        if( NULL == OutBuf ) return ERROR_NOT_ENOUGH_MEMORY;
    }

    // calculate input buffer size required

    InBufSize = 0;
    InBufSize += (DWORD)(sizeof(DWORD)*2);                 // INBUF_SIZE, OUTBUF_SIZE
    InBufSize += (DWORD)(sizeof(BYTE)+sizeof(DWORD)+(1+wcslen(AdapterName))*sizeof(WCHAR));
    if( ClassIdLen )
        InBufSize += sizeof(BYTE)+sizeof(DWORD)+ClassIdLen;
    for( i = 0; i < nSendParams; i ++ ) {
        InBufSize += sizeof(BYTE)+sizeof(DWORD)+sizeof(BYTE)+SendParams[i].nBytesData;
    }
    InBuf = DhcpAllocateMemory(InBufSize);
    if( NULL == InBuf ) {
        DhcpFreeMemory(OutBuf);
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    // fill up output buffer size right at start of input buffer

    ((DWORD UNALIGNED*)InBuf)[0] = htonl(OutBufSize);
    ((DWORD UNALIGNED*)InBuf)[1] = 0;

    Buffer = InBuf + sizeof(DWORD);
    InBufSize -= sizeof(DWORD);

    // fill in input buffer

    Error = DhcpApiFillBuffer(Buffer, InBufSize, AdapterName, OpCode);
    DhcpAssert(ERROR_SUCCESS == Error);

    if( ClassIdLen ) {
        Error = DhcpApiArgAdd(Buffer, InBufSize, ClassIdParam, ClassIdLen, ClassId);
        DhcpAssert(ERROR_SUCCESS == Error);
    }

    for( i = 0; i < nSendParams; i ++ ) {
        BYTE Buf[OPTION_END+1];
        BYTE OpCode;

        Buf[0] = (BYTE)SendParams[i].OptionId;
        memcpy(&Buf[1], SendParams[i].Data, SendParams[i].nBytesData);
        OpCode = SendParams[i].IsVendor? VendorOptionParam: NormalOptionParam;
        Error = DhcpApiArgAdd(Buffer, InBufSize, OpCode, SendParams[i].nBytesData+1, Buf);
        DhcpAssert(ERROR_SUCCESS == Error);
    }

    // now, execute and obtain the output filled in OutBuf

    Error = ExecuteApiRequest(InBuf, OutBuf, &OutBufSize);
    if( ERROR_MORE_DATA == Error ) {
        // recalculate the real OutBufSize required
        DhcpAssert(OutBufSize != 0);
        OutBufSize += nParamsRequested*(sizeof(DHCPAPI_PARAMS) - (2*sizeof(BYTE)+sizeof(DWORD)));
        (*pnRecdParams) = OutBufSize;
        goto Cleanup;
    }

    if( ERROR_SUCCESS != Error ) goto Cleanup;
    if( 0 == OutBufSize ) goto Cleanup;

    // parse output and fill in the structures..
    nArgsReturned = 0;
    DhcpApiArgs = NULL;
    Error = DhcpApiArgDecode(OutBuf, OutBufSize, DhcpApiArgs, &nArgsReturned);
    DhcpAssert( 0 == nArgsReturned || ERROR_MORE_DATA == Error);
    if( ERROR_MORE_DATA != Error ) goto Cleanup;
    DhcpAssert(0 != nArgsReturned);
    DhcpApiArgs = DhcpAllocateMemory( sizeof(DHCP_API_ARGS) * nArgsReturned);
    if( NULL == DhcpApiArgs ) {
        Error = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    Error = DhcpApiArgDecode(OutBuf, OutBufSize, DhcpApiArgs, &nArgsReturned);
    DhcpAssert(ERROR_SUCCESS == Error);
    DhcpAssert(nArgsReturned);

    if( OriginalOutBufSize < OutBufSize + nParamsRequested*(sizeof(DHCPAPI_PARAMS) - (2*sizeof(BYTE)+sizeof(DWORD)) ) ) {
        //
        // Input size is not sufficient
        //
        (*pnRecdParams ) = OutBufSize + nParamsRequested*(
            sizeof(DHCPAPI_PARAMS) - (2*sizeof(BYTE)+sizeof(DWORD) )
            );
        Error = ERROR_MORE_DATA;
        // DbgPrint("Bug 330419 repro'ed");
        goto Cleanup;
    }
    
    Endp = OutBufSize + (LPBYTE)RecdParams + nParamsRequested*(sizeof(DHCPAPI_PARAMS) - (2*sizeof(BYTE)+sizeof(DWORD)));
    
    for(i = j = 0; i < nArgsReturned; i ++ ) {
        DhcpAssert( VendorOptionParam == DhcpApiArgs[i].ArgId || NormalOptionParam == DhcpApiArgs[i].ArgId);
        DhcpAssert( DhcpApiArgs[i].ArgSize > 1);  // one byte for option id, and atleast one byte actual option
        if( VendorOptionParam != DhcpApiArgs[i].ArgId && NormalOptionParam != DhcpApiArgs[i].ArgId )
            continue;
        RecdParams[j].OptionId = DhcpApiArgs[i].ArgVal[0];
        RecdParams[j].IsVendor = ( VendorOptionParam == DhcpApiArgs[i].ArgId );
        RecdParams[j].nBytesData = DhcpApiArgs[i].ArgSize-1;
        Endp -= RecdParams[j].nBytesData;
        memcpy(Endp, &DhcpApiArgs[i].ArgVal[1], RecdParams[j].nBytesData);
        RecdParams[j].Data = Endp;
        j ++;
    }

    DhcpAssert(((LPBYTE)&RecdParams[j]) <= Endp);

    *pnRecdParams = j;
    Error = ERROR_SUCCESS;

  Cleanup:
    DhcpFreeMemory(InBuf);
    if(OutBuf) DhcpFreeMemory(OutBuf);
    if(DhcpApiArgs) DhcpFreeMemory(DhcpApiArgs);
    return Error;
}

DWORD                                             // win32 status
APIENTRY
DhcpRequestParameters(                                // request parameters of client
    IN      LPWSTR                 AdapterName,   // adapter name to request for
    IN      LPBYTE                 ClassId,       // byte stream of class id to use
    IN      DWORD                  ClassIdLen,    // # of bytes of class id to use
    IN      PDHCPAPI_PARAMS        SendParams,    // parameters to send to server
    IN      DWORD                  nSendParams,   // size of above array
    IN      DWORD                  Flags,         // must be zero, reserved
    IN OUT  PDHCPAPI_PARAMS        RecdParams,    // fill this array with received params
    IN OUT  LPDWORD                pnRecdParams   // i/p: size of above in BYTES, o/p required or filled up size
) {
    return DhcpRequestParamsInternal(
        RequestParamsOpCode,
        AdapterName,
        ClassId,
        ClassIdLen,
        SendParams,
        nSendParams,
        Flags,
        RecdParams,
        pnRecdParams
    );
}

DWORD                                             // win32 status
DhcpRegisterParameterChangeNotificationInternal(  // notify if a parameter has changed -- common between NT and VxD
    IN      LPWSTR                 AdapterName,   // adapter of interest
    IN      LPBYTE                 ClassId,       // byte stream of class id to use
    IN      DWORD                  ClassIdLen,    // # of bytes of class id
    IN      PDHCPAPI_PARAMS        Params,        // params of interest
    IN      DWORD                  nParams,       // # of elts in above array
    IN      DWORD                  Flags,         // must be zero, reserved
    IN      DWORD                  Descriptor,    // thsi describes the event uniquely for this process
    IN      HANDLE                 hEvent         // handle to event that will be SetEvent'ed in case of param change
) {
    LPBYTE                         InBuf;
    LPBYTE                         OptList;
    LPBYTE                         VendorOptList;
    LPBYTE                         Buffer;
    DWORD                          Error;
    DWORD                          InBufSize;
    DWORD                          nVendorOpts;
    DWORD                          nOpts;
    DWORD                          ProcId;
    DWORD                          OutBufSize;
    DWORD                          i;

    VendorOptList = OptList = NULL;
    nVendorOpts = nOpts = 0;

    InBufSize = 2*sizeof(DWORD);                  // expected outbuf size + inbuf size
    InBufSize += sizeof(BYTE) + 2*sizeof(DWORD);  // Proc Id
    InBufSize += sizeof(BYTE) + 2*sizeof(DWORD);  // Event Handle
    InBufSize += sizeof(BYTE) + 2*sizeof(DWORD);  // Descriptor

    InBufSize += (DWORD)(sizeof(Descriptor)+sizeof(hEvent)+sizeof(DWORD));
    InBufSize += (DWORD)(sizeof(BYTE)+sizeof(DWORD)+(1+wcslen(AdapterName))*sizeof(WCHAR));
    if( ClassIdLen )
        InBufSize += sizeof(BYTE)+sizeof(DWORD)+ClassIdLen;

    for( i = 0; i < nParams; i ++ ) {
        if( OPTION_PARAMETER_REQUEST_LIST == Params[i].OptionId ) {
            if( Params[i].IsVendor ) continue;
            if( nOpts ) return ERROR_INVALID_PARAMETER;
            nOpts = Params[i].nBytesData;
            if( 0 == nOpts ) return ERROR_INVALID_PARAMETER;
            OptList = Params[i].Data;
            continue;
        }

        if( OPTION_PAD == Params[i].OptionId ) {
            if( ! Params[i].IsVendor ) continue;
            if( nVendorOpts ) return ERROR_INVALID_PARAMETER;
            nVendorOpts = Params[i].nBytesData;
            if( 0 == nVendorOpts ) return ERROR_INVALID_PARAMETER;
            VendorOptList = Params[i].Data;
            continue;
        }
    }
    if( 0 == nOpts + nVendorOpts ) return ERROR_INVALID_PARAMETER;

    if( nOpts ) InBufSize += sizeof(BYTE) + sizeof(DWORD) + nOpts;
    if( nVendorOpts ) InBufSize += sizeof(BYTE) + sizeof(DWORD) + nVendorOpts;

    InBuf = DhcpAllocateMemory(InBufSize);
    if( NULL == InBuf ) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    Buffer = InBuf + sizeof(DWORD);
    ((DWORD UNALIGNED*)InBuf)[0] = 0;             // dont expect anything in return other than status
    ((DWORD UNALIGNED*)Buffer)[0] = 0;            // increase the input buffer size each time we add something
    InBufSize -= sizeof(DWORD);                   // ignore the first DWORD

    Error = DhcpApiFillBuffer(Buffer, InBufSize, AdapterName, RegisterParamsOpCode);
    DhcpAssert(ERROR_SUCCESS == Error );

    if( ClassIdLen ) {
        Error = DhcpApiArgAdd(Buffer, InBufSize, ClassIdParam, ClassIdLen, ClassId);
        DhcpAssert(ERROR_SUCCESS == Error);
    }

    if( nOpts ) {
        Error = DhcpApiArgAdd(Buffer, InBufSize, NormalOptionParam, nOpts, OptList);
        DhcpAssert(ERROR_SUCCESS == Error);
    }

    if( nVendorOpts ) {
        Error = DhcpApiArgAdd(Buffer, InBufSize, VendorOptionParam, nVendorOpts, VendorOptList);
        DhcpAssert(ERROR_SUCCESS == Error);
    }

    ProcId = GetCurrentProcessId();
    Error = DhcpApiArgAdd(Buffer, InBufSize, ProcIdParam, sizeof(ProcId), (LPBYTE) &ProcId);
    DhcpAssert(ERROR_SUCCESS == Error);

    Error = DhcpApiArgAdd(Buffer, InBufSize, DescriptorParam, sizeof(Descriptor), (LPBYTE) &Descriptor);
    DhcpAssert(ERROR_SUCCESS == Error);

    Error = DhcpApiArgAdd(Buffer, InBufSize, EventHandleParam, sizeof(hEvent), (LPBYTE) &hEvent);
    DhcpAssert(ERROR_SUCCESS == Error);

    OutBufSize = 0;
    Error = ExecuteApiRequest(InBuf, NULL, &OutBufSize);
    DhcpFreeMemory(InBuf);
    DhcpAssert(ERROR_MORE_DATA != Error );

    return Error;
}

DWORD                                             // Ring 0 handle -- used only on win9x platform
VxDGetDescriptor(                                 // convert Event to Ring0 handle for use in vdhcp.vxd
    IN      HANDLE                 Event,
    IN OUT  LPDWORD                pDescriptor
) {
    HANDLE                         Kernel32;
    DWORD                          (*HandleToRing0Handle)(HANDLE);
    DWORD                          RetVal;

    Kernel32 = LoadLibraryA("kernel32.dll");
    if( NULL == Kernel32 ) return GetLastError();

    HandleToRing0Handle = (DWORD (*)(HANDLE))GetProcAddress(Kernel32, "OpenVxDHandle");
    if( NULL == HandleToRing0Handle ) {
        CloseHandle(Kernel32);
        return GetLastError();
    }

    (*pDescriptor) = HandleToRing0Handle(Event);
    CloseHandle(Kernel32);

    if( 0 == (*pDescriptor) ) return ERROR_INVALID_PARAMETER;

    return ERROR_SUCCESS;
}

DWORD                                             // win32 status
DhcpCreateApiEventAndDescriptor(                  // create both the api event handle and the unique descriptor for it
    IN OUT  LPHANDLE               hEvent,        // fill this with a valid event handle if succeeded
    IN OUT  LPDWORD                pDescriptor    // this descriptor is unique for this process.
) {
    static  DWORD                  Descriptor = 1;// use this for the descriptor
    OSVERSIONINFO                  OsVersion;     // need to know if NT or Win95+
    BOOL                           BoolError;
    CHAR                           NameBuf[sizeof("DhcpPid-1-2-3-4-5-6-7-8UniqueId-1-2-3-4-5-6-7-8")];
    DWORD                          Error;

    // *** changing NameBuf's format requires change in apiimpl.c NotifyClients...*

    OsVersion.dwOSVersionInfoSize = sizeof(OsVersion);
    BoolError = GetVersionEx(&OsVersion);
    if( FALSE == BoolError ) return GetLastError();

    if( VER_PLATFORM_WIN32_WINDOWS == OsVersion.dwPlatformId ) {
        (*hEvent) = CreateEvent(
            NULL,                                 // no security
            FALSE,                                // auto reset
            FALSE,                                // intially signaled? NO
            NULL                                  // no name
        );
    } else {
        (*pDescriptor) = InterlockedIncrement(pDescriptor);
        sprintf(NameBuf, "DhcpPid%16xUniqueId%16x", GetCurrentProcessId(), *pDescriptor);

        (*hEvent) = CreateEventA(                 // now create the required event
            NULL,                                 // no security
            FALSE,                                // automatic reset
            FALSE,                                // intially signalled? NO!
            NameBuf                               // the name to use to create
        );
    }

    if( NULL == (*hEvent) ) return GetLastError();

    if( VER_PLATFORM_WIN32_WINDOWS != OsVersion.dwPlatformId )
        return ERROR_SUCCESS;                     // done for NT.

    // for Memphis, need to get OpenVxdHandle procedure to get Descriptor value
    Error = VxDGetDescriptor(*hEvent, pDescriptor);
    if( ERROR_SUCCESS != Error ) {
        CloseHandle(*hEvent);
    }

    return Error;
}

DWORD                                             // win32 status
DhcpRegisterParameterChangeNotification(          // notify if a parameter has changed
    IN      LPWSTR                 AdapterName,   // adapter of interest
    IN      LPBYTE                 ClassId,       // byte stream of class id to use
    IN      DWORD                  ClassIdLen,    // # of bytes of class id
    IN      PDHCPAPI_PARAMS        Params,        // params of interest
    IN      DWORD                  nParams,       // # of elts in above array
    IN      DWORD                  Flags,         // must be zero, reserved
    IN OUT  PHANDLE                hEvent         // handle to event that will be SetEvent'ed in case of param change
) {
    DWORD                          Descriptor;    // on NT this is an id unique across this process, on VxD ring0 handle
    DWORD                          Error;         //
    DWORD                          i;

    if( 0 == ClassIdLen && NULL != ClassId ) return ERROR_INVALID_PARAMETER;
    if( 0 != ClassIdLen && NULL == ClassId ) return ERROR_INVALID_PARAMETER;
    if( 0 == nParams && NULL != Params ) return ERROR_INVALID_PARAMETER;
    if( 0 != nParams && NULL == Params ) return ERROR_INVALID_PARAMETER;
    if( Flags ) return ERROR_INVALID_PARAMETER;
    if( NULL == hEvent ) return ERROR_INVALID_PARAMETER;
    for( i = 0; i < nParams ; i ++ ) {
        if( Params[i].nBytesData > OPTION_END ) return ERROR_INVALID_PARAMETER;
        if( Params[i].nBytesData && NULL == Params[i].Data )
            return ERROR_INVALID_PARAMETER;
    }

    Error = DhcpCreateApiEventAndDescriptor(hEvent, &Descriptor);
    if( ERROR_SUCCESS != Error ) return Error;

    Error = DhcpRegisterParameterChangeNotificationInternal(
        AdapterName,
        ClassId,
        ClassIdLen,
        Params,
        nParams,
        Flags,
        Descriptor,
        (*hEvent)
    );

    if( ERROR_SUCCESS != Error ) {
        CloseHandle(*hEvent);
        *hEvent = NULL;
        return Error;
    }

    return ERROR_SUCCESS;
}

DhcpDeRegisterParameterChangeNotification(        // undo the registration
    IN      HANDLE                 Event          // handle to event returned by DhcpRegisterParameterChangeNotification, NULL ==> everything
) {
    DWORD                          Error;
    DWORD                          Descriptor;
    DWORD                          ProcId;
    DWORD                          InBufSize;
    DWORD                          OutBufSize;
    LPBYTE                         InBuf;
    LPBYTE                         Buffer;

    InBufSize = 2*sizeof(DWORD);                  // input/output sizes
    InBufSize += sizeof(BYTE) + sizeof(DWORD);    // opcode
    InBufSize += sizeof(BYTE) + sizeof(DWORD)*2;  // proc id
    InBufSize += sizeof(BYTE) + sizeof(DWORD)*2;  // handle

    InBuf = DhcpAllocateMemory(InBufSize);
    if( NULL == InBuf ) return ERROR_NOT_ENOUGH_MEMORY;

    Buffer = InBuf + sizeof(DWORD);
    ((DWORD UNALIGNED*)InBuf)[0] = 0;             // nothing expected in return
    ((DWORD UNALIGNED*)Buffer)[0] = 0;            // initialize size to zero -- will be increased each time something is added

    Error = DhcpApiFillBuffer(Buffer, InBufSize, NULL, DeRegisterParamsOpCode);
    DhcpAssert(ERROR_SUCCESS == Error);

    ProcId = GetCurrentProcessId();

    Error = DhcpApiArgAdd(Buffer, InBufSize, ProcIdParam, sizeof(ProcId), (LPBYTE)&ProcId);
    DhcpAssert(ERROR_SUCCESS == Error);

    Error = DhcpApiArgAdd(Buffer, InBufSize, EventHandleParam, sizeof(Event), (LPBYTE) &Event);
    DhcpAssert(ERROR_SUCCESS == Error);

    OutBufSize = 0;
    Error = ExecuteApiRequest(InBuf, NULL, &OutBufSize);
    DhcpFreeMemory(InBuf);
    DhcpAssert(ERROR_MORE_DATA != Error);

    if( ERROR_SUCCESS == Error ) {
        CloseHandle(Event);
    }

    return Error;
}

DWORD                                             // win32 status
DhcpRegistryFillParamsList(                       // read the registry value and add this list of values to it
    IN      LPWSTR                 AppName,       // prefix for key
    IN      DWORD                  nSendParams    // # of values to add
) {
    HKEY                           DhcpOptionKey;
    LPWSTR                         OldValueName;
    LPWSTR                         NewValueName;
    LPWSTR                         ValueName;
    LPWSTR                         Tmp, Tmp2;
    BOOL                           fOldValueExists = FALSE;
    DWORD                          ValueNameSize;
    DWORD                          OldValueNameSize;
    DWORD                          NewValueNameSize;
    DWORD                          Error;
    DWORD                          i;

    Error = RegOpenKeyEx(                         // open the dhcp option key first
        HKEY_LOCAL_MACHINE,
        DHCP_CLIENT_OPTION_KEY,
        0 /* Reserved */,
        DHCP_CLIENT_KEY_ACCESS,
        &DhcpOptionKey
    );
    if( ERROR_SUCCESS != Error ) return Error;

    OldValueName = NULL;
    Error = GetRegistryString(
        DhcpOptionKey,
        DHCP_OPTION_LIST_VALUE,
        &OldValueName,
        &OldValueNameSize
    );

    if( ERROR_SUCCESS != Error ) {
        OldValueName = DEFAULT_DHCP_KEYS_LIST_VALUE;
        OldValueNameSize = sizeof(DEFAULT_DHCP_KEYS_LIST_VALUE);
    } else {
        fOldValueExists = TRUE;
    }

    NewValueNameSize = OldValueNameSize;

    ValueNameSize = 0;
    ValueNameSize += wcslen(AppName)*sizeof(WCHAR);
    ValueNameSize += sizeof(L"\\12345");

    ValueName = DhcpAllocateMemory(ValueNameSize);
    if( NULL == ValueName ) {
        RegCloseKey(DhcpOptionKey);
        if( fOldValueExists ) DhcpFreeMemory(OldValueName);
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    NewValueNameSize = nSendParams*ValueNameSize + OldValueNameSize;
    NewValueName = DhcpAllocateMemory(NewValueNameSize);
    if( NULL == NewValueName ) {
        RegCloseKey(DhcpOptionKey);
        if( fOldValueExists ) DhcpFreeMemory(OldValueName);
        DhcpFreeMemory(ValueName);
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    wcscpy(ValueName, AppName);
    wcscat(ValueName, L"\\");

    Tmp = NewValueName;
    for( i = 0; i < nSendParams ; i ++ ) {        // for each value, add its to the list
        wcscpy(Tmp, ValueName);
        Tmp += wcslen(Tmp);
        swprintf(Tmp, L"%5x", i);
        Tmp += wcslen(Tmp);
        Tmp ++;                                   // move the ptr off the last L'\0'
    }
    DhcpFreeMemory(ValueName);

    Tmp2 = OldValueName;
    while(wcslen(Tmp2)) {
        wcscpy(Tmp, Tmp2);
        Tmp += wcslen(Tmp2);
        Tmp2 += wcslen(Tmp2);
        Tmp ++;
        Tmp2 ++;
    }

    *Tmp++ = L'\0';

    if(fOldValueExists ) DhcpFreeMemory(OldValueName);

    Error = RegSetValueEx(                        // write this string back
        DhcpOptionKey,
        DHCP_OPTION_LIST_VALUE,
        0 /* Reserved */,
        REG_MULTI_SZ,
        (LPBYTE) NewValueName,
        (ULONG)(((LPBYTE)Tmp) - ((LPBYTE)NewValueName))
    );
    DhcpFreeMemory(NewValueName);
    RegCloseKey(DhcpOptionKey);

    if( ERROR_SUCCESS != Error ) {
        DhcpPrint((DEBUG_ERRORS, "RegSetValueEx(OPTION_LIST):0x%lx\n", Error));
    }

    return Error;
}

DWORD                                             // win32 status
DhcpRegistryFillParams(                           // make a subkey and fill in the details
    IN      LPWSTR                 AdapterName,   // NULL ==> global change
    IN      LPBYTE                 ClassId,       // this is the class of the option
    IN      DWORD                  ClassIdLen,    // # of bytes of above
    IN      DWORD                  i,             // key index is 3hex-digit convertion onf this
    IN      HKEY                   Key,           // use this key for creating subkeys
    IN      PDHCPAPI_PARAMS        SendParam,     // ptr to structure to use for this one key write operation
    IN      LPWSTR                 AppName        // name of app
) {
    HKEY                           SubKey;
    WCHAR                          KeyName[7];    // key is just 5 bytes
    LPWSTR                         SendLocation;
    LPWSTR                         ValueName;
    LPBYTE                         SendData;
    DWORD                          SendDataSize;
    DWORD                          Size;
    DWORD                          Disposition;
    DWORD                          Error;
    DWORD                          OptionId;
    DWORD                          IsVendor;
    DWORD                          DummyKeyType;

    swprintf(KeyName, L"%5x", i);

    OptionId = SendParam->OptionId;
    IsVendor = SendParam->IsVendor;
    SendData = SendParam->Data;
    SendDataSize = SendParam->nBytesData;

    Size = wcslen(AppName)*sizeof(WCHAR)+sizeof(KeyName) + sizeof(L"\\");
    if( AdapterName ) {
        Size += (DWORD)(sizeof(DHCP_SERVICES_KEY) + sizeof(DHCP_ADAPTER_PARAMETERS_KEY) + wcslen(AdapterName)*sizeof(WCHAR));
    } else {
        Size += sizeof(DHCP_TCPIP_PARAMETERS_KEY);
    }
    SendLocation = DhcpAllocateMemory(Size);
    if( NULL == SendLocation ) return ERROR_NOT_ENOUGH_MEMORY;

    if( AdapterName ) {
        wcscpy(SendLocation, DHCP_SERVICES_KEY DHCP_ADAPTER_PARAMETERS_KEY);
        wcscat(SendLocation, L"\\?\\");
    } else {
        wcscpy(SendLocation, DHCP_TCPIP_PARAMETERS_KEY);
    }
    wcscat(SendLocation, AppName);
    wcscat(SendLocation, KeyName);

    Error = RegCreateKeyEx(                       // create the option key
        Key,
        KeyName,
        0 /* Reserved */,
        DHCP_CLASS,
        REG_OPTION_NON_VOLATILE,
        KEY_ALL_ACCESS,
        NULL,
        &SubKey,
        &Disposition
    );
    if( ERROR_SUCCESS != Error ) {
        DhcpFreeMemory(SendLocation);
        return Error;
    }

    DhcpAssert(REG_CREATED_NEW_KEY == Disposition);

    Error = RegSetValueEx(                        // now create each of the values -- OPTION ID
        SubKey,
        DHCP_OPTION_OPTIONID_VALUE,
        0 /* Reserved */,
        DHCP_OPTION_OPTIONID_TYPE,
        (LPBYTE)&OptionId,
        sizeof(OptionId)
    );
    DhcpAssert(ERROR_SUCCESS == Error);

    Error = RegSetValueEx(                        // IS VENDOR
        SubKey,
        DHCP_OPTION_ISVENDOR_VALUE,
        0 /* Reserved */,
        DHCP_OPTION_ISVENDOR_TYPE,
        (LPBYTE) (&IsVendor),
        sizeof(IsVendor)
    );
    DhcpAssert(ERROR_SUCCESS == Error);

    if( ClassIdLen ) {
        Error = RegSetValueEx(                    // CLASS ID
            SubKey,
            DHCP_OPTION_CLASSID_VALUE,
            0 /* Reserved */,
            REG_BINARY,
            ClassId,
            ClassIdLen
        );
        DhcpAssert(ERROR_SUCCESS == Error);
    }

    Error = RegSetValueEx(
        SubKey,
        DHCP_OPTION_SEND_LOCATION_VALUE,
        0 /* Reserved */,
        REG_SZ,
        (LPBYTE)SendLocation,
        (wcslen(SendLocation)+1)*sizeof(WCHAR)
    );
    DhcpAssert(ERROR_SUCCESS == Error);

    DummyKeyType = REG_DWORD;                    // KeyType
    Error = RegSetValueEx(
        SubKey,
        DHCP_OPTION_SAVE_TYPE_VALUE,
        0 /* Reserved */,
        DHCP_OPTION_SAVE_TYPE_TYPE,
        (LPBYTE)&DummyKeyType,
        sizeof(DummyKeyType));
    DhcpAssert(ERROR_SUCCESS == Error);

    RegCloseKey(SubKey);

    if( AdapterName ) {
        wcscpy(SendLocation, DHCP_SERVICES_KEY DHCP_ADAPTER_PARAMETERS_KEY);
        wcscat(SendLocation, L"\\");
        wcscat(SendLocation, AdapterName);
    } else {
        wcscpy(SendLocation, DHCP_TCPIP_PARAMETERS_KEY);
    }

    ValueName = wcslen(SendLocation) + 1 + SendLocation;
    wcscpy(ValueName, AppName);
    wcscat(ValueName, KeyName);

    Error = RegOpenKeyEx(
        HKEY_LOCAL_MACHINE,
        SendLocation,
        0 /* Reserved */,
        KEY_ALL_ACCESS,
        &SubKey
    );
    if( ERROR_SUCCESS != Error ) {
        DhcpFreeMemory(SendLocation);
        return Error;
    }

    Error = RegSetValueEx(
        SubKey,
        ValueName,
        0 /* Reserved */,
        REG_BINARY,
        SendData,
        SendDataSize
    );
    DhcpAssert(ERROR_SUCCESS == Error);
    RegCloseKey(SubKey);
    DhcpFreeMemory(SendLocation);

    return ERROR_SUCCESS;
}

DWORD                                             // win32 status
DhcpRegistryCreateUniqueKey(                      // create a unique key with prefix AppName
    IN      LPWSTR                 AppName,       // some App descriptor
    IN OUT  HKEY*                  Key            // return the opened key here
) {
    DWORD                          FullKeyNameSize, Disposition;
    DWORD                          Error;
    LPWSTR                         FullKeyName;

    FullKeyNameSize = sizeof(DHCP_CLIENT_OPTION_KEY);
    FullKeyNameSize += wcslen(AppName)*sizeof(WCHAR) + sizeof(WCHAR);
    FullKeyName = DhcpAllocateMemory(FullKeyNameSize);
    if( NULL == FullKeyName ) return ERROR_NOT_ENOUGH_MEMORY;

    wcscpy(FullKeyName, DHCP_CLIENT_OPTION_KEY);
    wcscat(FullKeyName, L"\\");
    wcscat(FullKeyName, AppName);

    Error = RegCreateKeyEx(
        HKEY_LOCAL_MACHINE,
        FullKeyName,
        0 /* Reserved */,
        DHCP_CLASS,
        REG_OPTION_NON_VOLATILE,
        KEY_ALL_ACCESS,
        NULL,
        Key,
        &Disposition
    );

    DhcpFreeMemory(FullKeyName);
    if( ERROR_SUCCESS != Error ) return Error;

    if( REG_OPENED_EXISTING_KEY == Disposition ) {
        RegCloseKey(*Key);
        return ERROR_ALREADY_EXISTS;
    }

    return ERROR_SUCCESS;
}

DWORD                                             // win32 status
DhcpRegistryPersistentRequestParams(              // edit registry to consider this additional persistent request
    IN      LPWSTR                 AdapterName,   // which adapter is this request for?
    IN      LPBYTE                 ClassId,       // class
    IN      DWORD                  ClassIdLen,    // # of bytes in class id
    IN      PDHCPAPI_PARAMS        SendParams,    // the actual parameters to fill up
    IN      DWORD                  nSendParams,   // the size of the above array
    IN      PDHCPAPI_PARAMS        RecdParams,    // would like to receive these
    IN      DWORD                  nRecdParams,   // count..
    IN      LPWSTR                 AppName        // some thing unique about the app that wants to do registrations
) {
    HKEY                           Key;
    DWORD                          i;
    DWORD                          Error;
    DWORD                          LastError;
    DHCPAPI_PARAMS                 NonVendorParams;
    ULONG                          nVendorOpt, nNonVendorOpt;
    CHAR                           Buf[256];

    if( NULL == AppName ) return ERROR_INVALID_PARAMETER;
    if( 0 == nSendParams && NULL != SendParams ) return ERROR_INVALID_PARAMETER;
    if( 0 != nSendParams && NULL == SendParams ) return ERROR_INVALID_PARAMETER;
    if( 0 != nRecdParams && NULL == RecdParams ) return ERROR_INVALID_PARAMETER;
    if( 0 == nRecdParams && NULL != RecdParams ) return ERROR_INVALID_PARAMETER;
    if( ClassIdLen && NULL == ClassId || 0 == ClassIdLen && NULL != ClassId)
        return ERROR_INVALID_PARAMETER;

    for( i = 0; i < nSendParams; i ++ ) {
        if( SendParams[i].nBytesData == 0 ) return ERROR_INVALID_PARAMETER;
    }

    nVendorOpt = nNonVendorOpt = 0;

    // --ft: 07/25/00 fixes the way the non-vendor options
    // are collected from RecdParams.
    for (i = 0; i < nRecdParams; i++)
    {
        if (RecdParams[i].IsVendor)
        {
            nVendorOpt = 1;
        }
        else
        {
            Buf[nNonVendorOpt++] = (BYTE)RecdParams[i].OptionId;
        }
    }

    // if nVendorOpt is 1 this means we have at least one vendor option in
    // the requested parameters list. Make sure then OPTION_VENDOR_SPEC_INFO
    // is mentioned in the array to be sent as OPTION_PARAMETER_REQUEST_LIST
    if( nVendorOpt ) {
        for( i = 0; i < nNonVendorOpt ; i ++ )
            if( Buf[i] == OPTION_VENDOR_SPEC_INFO )
                break;

        if( i == nNonVendorOpt ) Buf[nNonVendorOpt ++] = (BYTE)OPTION_VENDOR_SPEC_INFO;
    }

    NonVendorParams.Flags = 0;
    NonVendorParams.OptionId = OPTION_PARAMETER_REQUEST_LIST;
    NonVendorParams.IsVendor = FALSE;
    NonVendorParams.Data = Buf;
    NonVendorParams.nBytesData = nNonVendorOpt;

    Error = DhcpRegistryCreateUniqueKey(          // first try creating the key
        AppName,
        &Key
    );
    if( ERROR_SUCCESS != Error ) return Error;


    Error = DhcpRegistryFillParamsList(
        AppName,
        nSendParams + (nNonVendorOpt?1:0)
    );
    if( ERROR_SUCCESS != Error ) {
        DhcpAssert(FALSE);
        DhcpPrint((DEBUG_ERRORS, "DhcpRegistryFillParamsList:0x%lx\n", Error));
        RegCloseKey(Key);
        return Error;
    }

    LastError = ERROR_SUCCESS;
    for( i = 0; i < nSendParams; i ++ ) {         // now enter the particular option in the registry
        Error = DhcpRegistryFillParams(
            AdapterName,
            ClassId,
            ClassIdLen,
            i,
            Key,
            &SendParams[i],
            AppName
        );
        if( ERROR_SUCCESS != Error ) {
            DhcpAssert(FALSE);
            DhcpPrint((DEBUG_ERRORS, "DhcpRegistryFillParams:0x%lx\n", Error));
            LastError = Error;
        }
    }
    if( nNonVendorOpt ) {
        Error = DhcpRegistryFillParams(
            AdapterName,
            ClassId,
            ClassIdLen,
            i ++,
            Key,
            &NonVendorParams,
            AppName
        );
        if( ERROR_SUCCESS != Error ) {
            DhcpAssert(FALSE);
            DhcpPrint((DEBUG_ERRORS, "DhcpRegistryFillParams:0x%lx\n", Error));
            LastError = Error;
        }
    }

    RegCloseKey(Key);
    return LastError;
}

// Please note that AppName must be unique for each request (and if it is not, things are
// likely to behave weirdly..  This is the same name that should be used for the deletion..
DWORD                                             // win32 status
DhcpPersistentRequestParams(                      // parameters to request persistently
    IN      LPWSTR                 AdapterName,   // adapter name to request for
    IN      LPBYTE                 ClassId,       // byte stream of class id to use
    IN      DWORD                  ClassIdLen,    // # of bytes of class id
    IN      PDHCPAPI_PARAMS        SendParams,    // persistent parameters
    IN      DWORD                  nSendParams,   // size of above array
    IN      DWORD                  Flags,         // must be zero, reserved
    IN      LPWSTR                 AppName        // name of app doing the persistent request
) {
    DWORD                          Error;
    DWORD                          nRecdParams;

    nRecdParams = 0;
    Error = DhcpRequestParamsInternal(
        PersistentRequestParamsOpCode,
        AdapterName,
        ClassId,
        ClassIdLen,
        SendParams,
        nSendParams,
        Flags,
        NULL,
        &nRecdParams
    );
    DhcpAssert(ERROR_MORE_DATA != Error );
    if( ERROR_INVALID_PARAMETER == Error ) Error = ERROR_SUCCESS; // see below comment
    if( ERROR_SUCCESS != Error ) {                // if AdapterName is NULL or if ClassId is not the one currently in use
        return Error;                             // only then do we get ERROR_INVALID_PARAMETER -- so filter those out
    }

    return DhcpRegistryPersistentRequestParams(   // now munge the registry
        AdapterName,
        ClassId,
        ClassIdLen,
        SendParams,
        nSendParams,
        NULL,
        0,
        AppName
    );
}

DWORD                                             // win32 status
DhcpDelPersistentRequestParams(                   // undo the effect of a persistent request -- currently undo from registry
    IN      LPWSTR                 AdapterName,   // the name of the adpater to delete for
    IN      LPWSTR                 AppName        // the name used by the app
) {
    HKEY                           Key;
    DWORD                          Error;
    DWORD                          LocationSize;
    DWORD                          FullKeyNameSize, Disposition;
    LPWSTR                         FullKeyName;
    LPWSTR                         LocationValue;
    LPWSTR                         Tmp, Tmp2;

    FullKeyNameSize = sizeof(DHCP_CLIENT_OPTION_KEY);
    FullKeyNameSize += wcslen(AppName)*sizeof(WCHAR) + sizeof(WCHAR);
    FullKeyName = DhcpAllocateMemory(FullKeyNameSize);
    if( NULL == FullKeyName ) return ERROR_NOT_ENOUGH_MEMORY;

    wcscpy(FullKeyName, DHCP_CLIENT_OPTION_KEY);
    wcscat(FullKeyName, L"\\");
    wcscat(FullKeyName, AppName);

    Error = DhcpRegRecurseDelete(HKEY_LOCAL_MACHINE, FullKeyName);
    DhcpAssert(ERROR_SUCCESS == Error);
    DhcpFreeMemory(FullKeyName);

    Error = RegOpenKeyEx(
        HKEY_LOCAL_MACHINE,
        DHCP_CLIENT_OPTION_KEY,
        0 /* Reserved */,
        DHCP_CLIENT_KEY_ACCESS,
        &Key
    );
    if( ERROR_SUCCESS != Error ) {
        DhcpAssert(FALSE);
        return Error;
    } else {
        DhcpRegRecurseDelete(Key, AppName);
    }

    LocationValue = NULL;
    Error = GetRegistryString(                    // read the value
        Key,
        DHCP_OPTION_LIST_VALUE,
        &LocationValue,
        &LocationSize
    );

    if( LocationValue == NULL ) Error = ERROR_FILE_NOT_FOUND;
    
    if( ERROR_SUCCESS != Error  ) {
        RegCloseKey(Key);
        return Error;
    }

    Tmp = Tmp2 = LocationValue;
    while(wcslen(Tmp) ) {
        if( 0 != wcsncmp(AppName, Tmp, wcslen(AppName))) {
            wcscpy(Tmp2, Tmp);
            Tmp2 += wcslen(Tmp) +1;
            Tmp += wcslen(Tmp) +1;
            continue;
        }
        if( Tmp[wcslen(AppName)] != L'\\' ) {
            wcscpy(Tmp2, Tmp);
            Tmp2 += wcslen(Tmp) +1;
            Tmp += wcslen(Tmp) +1;
            continue;
        }

        //
        // found required entry.. just skip over it..
        //

        Tmp += wcslen(Tmp) +1;
    }
    *Tmp2 ++ = L'\0';

    Error = RegSetValueEx(
        Key,
        DHCP_OPTION_LIST_VALUE,
        0 /* Reserved */,
        REG_MULTI_SZ,
        (LPBYTE)LocationValue,
        (ULONG)(((LPBYTE)Tmp2 - (LPBYTE)LocationValue))
    );
    RegCloseKey(Key);
    DhcpFreeMemory(LocationValue);

    return Error;
}

BOOL _inline
CharInMem(
    IN      BYTE                   Byte,
    IN      LPBYTE                 Mem,
    IN      ULONG                  MemSz
)
{
    while(MemSz) {
        if( Byte == *Mem ) return TRUE;
        Mem ++; MemSz --;
    }
    return FALSE;
}

DWORD
APIENTRY
DhcpRegisterOptions(
    IN      LPWSTR                 AdapterName,
    IN      LPBYTE                 OptionList,
    IN      DWORD                  OptionListSz,
    IN      HANDLE                *pdwHandle
) {
    DHCPAPI_PARAMS                 DhcpParams;
    DWORD                          Error;
    DHCP_OPTION                    DummyOption;
    LPBYTE                         Value;
    DWORD                          ValueSize, ValueType;
    BYTE                           Buf[256];
    ULONG                          nElementsInBuf;

    DhcpParams.OptionId = OPTION_PARAMETER_REQUEST_LIST;
    DhcpParams.IsVendor = FALSE;
    DhcpParams.Data = OptionList;
    DhcpParams.nBytesData = OptionListSz;

    Error = DhcpRegisterParameterChangeNotification(
        AdapterName,
        NULL,
        0,
        &DhcpParams,
        1,
        0,
        pdwHandle
    );

    if( ERROR_SUCCESS != Error ) return Error;

    memset(&DummyOption, 0, sizeof(DummyOption));

    Value = NULL; ValueSize = 0;
    Error = DhcpRegReadFromAnyLocation(
        DHCP_REGISTER_OPTIONS_LOC,
        AdapterName,
        &Value,
        &ValueType,
        &ValueSize
    );
    if( ERROR_SUCCESS == Error && REG_BINARY == ValueType && 0 != ValueSize ) {
        //
        // Got some pre-existing values... add the remaining to it..
        //
        memcpy(Buf, Value, ValueSize);
        while(OptionListSz) {
            if( !CharInMem(*OptionList, Value, ValueSize) )
                Buf[ValueSize++] = *OptionList;
            OptionList ++; OptionListSz --;
        }
        OptionList = Buf;
        OptionListSz = ValueSize;
    }

    if( NULL != Value ) DhcpFreeMemory(Value);

    DummyOption.Data = OptionList;
    DummyOption.DataLen = OptionListSz;

    Error = DhcpRegSaveOptionAtLocationEx(
        &DummyOption,
        AdapterName,
        DHCP_REGISTER_OPTIONS_LOC,
        REG_BINARY
    );

    return Error;
}

DWORD
APIENTRY
DhcpDeRegisterOptions (
    IN      HANDLE                 OpenHandle
) {
    DWORD                          Error;

    Error = DhcpDeRegisterParameterChangeNotification(OpenHandle);
    if( ERROR_SUCCESS != Error ) return Error;

    //
    // can't undo registry as we don't have enough information to do that.
    //

    return Error;
}

//================================================================================
//  C L I E N T   A P I   E N T R Y  P O I N T S
//================================================================================

DWORD
APIENTRY
DhcpCApiInitialize(
    OUT     LPDWORD                Version
)
/*++

    Routine Description:

       This routine intializes all the DHCP Client side APIs

    Arguemnts:

        Version    - a pointer to a DWORD that gets filled with DHCP APIs version #.

    Return Value:

        Returns STatus.
--*/
{
    if( NULL != Version ) *Version = 2;
    return ERROR_SUCCESS;
}

VOID
APIENTRY
DhcpCApiCleanup(
    VOID
)
/*++

    Routine Description:

        This routine cleansup afterall the DHCP Client side APIs have been called.

--*/
{
    return ;
}

DWORD                                             // win32 status
APIENTRY
DhcpRequestParams(                                // request parameters of client
    IN      DWORD                  Flags,         // must be DHCPCAPI_REQUEST_SYNCHRONOUS
    IN      LPVOID                 Reserved,      // this parameter is reserved
    IN      LPWSTR                 AdapterName,   // adapter name to request for
    IN      LPDHCPCAPI_CLASSID     ClassId,       // reserved must be NULL
    IN      DHCPCAPI_PARAMS_ARRAY  SendParams,    // parameters to send.
    IN OUT  DHCPCAPI_PARAMS_ARRAY  RecdParams,    // parameters that are to be requested..
    IN      LPBYTE                 Buffer,        // a buffer to hold data for RecdParams
    IN OUT  LPDWORD                pSize,         // i/p: size of above in BYTES, o/p required bytes..
    IN      LPWSTR                 RequestIdStr   // name of the application, unique per request
)   // returns ERROR_MORE_DATA if o/p buffer is of insufficient size, and fills in reqd size in # of bytes
/*++

    Routine Description:

        This routine can be used to do Request options from the DHCP Server and based on
        whether then whether the request is permanent or not, this request would be stored
        in the registry for persistence across boots.  The requests can have a particular class
        for which they'd be defined... (the class is sent on wire for the server to decide
        which options to send).  The request could be ASYNCHRONOUS in the sense that the call
        returns even before the server returns the data.. But this is not yet implemented.

    Arugments:

        Flags     -  currently DHCPCAPI_REQUEST_SYNCHRONOUS must be defined.
                     if a persisten request is desired, DHCPCAPI_REQUEST_PERSISTENT can
                     also be passed (bit-wise OR'ed)

        Reserved  -  MUST be NULL.  Reserved for future USE.

        AdapterName - The Name of the adapter for which this request is designed.  This
                     cannot be NULL currently though it is a nice thing to implement for
                     future.

        ClassId   -  The binary ClassId information to use to send on wire.

        SendParams - The Parameters to actual send on wire.

        RecdParams - The parameters to be received back from the DHCP server

        Buffer     - A buffer to hold some information.  This cannot be NULL and some
                     pointers within the RecdParams structure use this buffer, so it cannot
                     be deallocated so long as the RecdParams array is in USE.

        pSize      - This is (on input) the size in bytes of the Buffer variable.  When
                     the function returns ERROR_MORE_DATA, this variable would be the size
                     in bytes required.  If the function returns SUCCESSFULLY, this would
                     be the number of bytes space used up in reality.

        RequestIdStr - a string identifying the request being made.  This has to be unique
                     to each request (and a Guid is suggested).  This string is needed to
                     undo the effects of a RequestParam via UndoRequestParams..

    Return Value:

        This function returns ERROR_MORE_DATA if the buffer space provided by "Buffer" variable
        is not sufficient. (In this case, the pSize variable is filled in with the actual
        size required).  On success it returns ERROR_SUCCESS.  Otherwise, it returns Win32
        status.
--*/
{

    ULONG                          Error;
    ULONG                          i;

    //
    // Parameter validation
    //

    if( Flags != DHCPCAPI_REQUEST_SYNCHRONOUS &&
        Flags != DHCPCAPI_REQUEST_PERSISTENT &&
        Flags != (DHCPCAPI_REQUEST_SYNCHRONOUS | DHCPCAPI_REQUEST_PERSISTENT)) {
        return ERROR_INVALID_PARAMETER;
    }

    if( NULL != Reserved || NULL == AdapterName ||
        0 == RecdParams.nParams || NULL == pSize ) {
        return ERROR_INVALID_PARAMETER;
    }

    if( NULL == Buffer && *pSize ) {
        return ERROR_INVALID_PARAMETER;
    }

    if( NULL != ClassId ) {
        if( 0 != ClassId->Flags ) return ERROR_INVALID_PARAMETER;
        if( NULL == ClassId->Data || 0 == ClassId->nBytesData ) {
            return ERROR_INVALID_PARAMETER;
        }
    }

    if( NULL == RecdParams.Params || (0 != SendParams.nParams && NULL == SendParams.Params) ) {
        return ERROR_INVALID_PARAMETER;
    }

    for( i = 0; i < RecdParams.nParams ; i ++ ) {
        if( 0 != RecdParams.Params[i].nBytesData ||
            NULL != RecdParams.Params[i].Data ) {
            return ERROR_INVALID_PARAMETER;
        }
    }

    //
    // Now call the DhcpRequestParameters API and do datatype conversions for that..
    //

    Error = ERROR_SUCCESS;

    if( Flags & DHCPCAPI_REQUEST_SYNCHRONOUS ) {
        Error = DhcpRequestParamsInternalEx(
            RequestParamsOpCode,
            AdapterName,
            ClassId? ClassId->Data : NULL,
            ClassId? ClassId->nBytesData : 0,
            SendParams.Params,
            SendParams.nParams,
            0,
            RecdParams.Params,
            &RecdParams.nParams,
            Buffer,
            pSize
        );
    }

    if( ERROR_SUCCESS != Error ) return Error;

    if( Flags & DHCPCAPI_REQUEST_PERSISTENT ) {
        Error = DhcpRegistryPersistentRequestParams(
            AdapterName,
            ClassId? ClassId->Data : NULL,
            ClassId? ClassId->nBytesData : 0,
            SendParams.Params,
            SendParams.nParams,
            RecdParams.Params,
            RecdParams.nParams,
            RequestIdStr
        );
    }

    return Error;
}

DWORD                                             // win32 status
APIENTRY
DhcpUndoRequestParams(                            // undo the effect of a persistent request -- currently undo from registry
    IN      DWORD                  Flags,         // must be zero, reserved
    IN      LPVOID                 Reserved,      // this parameter is reserved
    IN      LPWSTR                 AdapterName,   // the original adapter this was registerdd for,..
    IN      LPWSTR                 RequestIdStr   // the requestId str passed to RequestParams..
)
/*++

    Routine Description:

       This function is used to undo the effects of a persistent request done
       via DhcpRequestParams with DHCPCAPI_REQUEST_PERSISTENT option.

    Arguments:

       Flags        -  MUST be zero. Reserved for future use.

       Reserved     -  MUST be NULL

       AdapterName  -  The original adapter name this request was made for

       RequestIdStr -  The original request Id string passed to RequestParams

    Return Value:

       returns Win32 status

--*/
{
    if( 0 != Flags || NULL != Reserved || NULL == RequestIdStr )
        return ERROR_INVALID_PARAMETER;

    return DhcpDelPersistentRequestParams(
        AdapterName,
        RequestIdStr
    );
}

DWORD                                             // win32 status
APIENTRY
DhcpRegisterParamChange(                          // notify if a parameter has changed
    IN      DWORD                  Flags,         // must be DHCPCAPI_REGISTER_HANDLE_EVENT
    IN      LPVOID                 Reserved,      // this parameter is reserved
    IN      LPWSTR                 AdapterName,   // adapter of interest
    IN      LPDHCPCAPI_CLASSID     ClassId,       // reserved must be NULL
    IN      DHCPCAPI_PARAMS_ARRAY  Params,        // parameters of interest
    IN OUT  LPVOID                 Handle         // handle to event that will be SetEvent'ed in case of param change
)
/*++

    Routine Description;

        This function registers with DHCP for any notifications on changes to the
        specified options.. (notifications are via an EVENT handle)

    Arguments:

        Flags      - this decides how the notification works -- via EVENTS or otherwise.
                     Currently, only event based mechanism is provided. So, this must be
                     DHCPCAPI_REGISTER_HANDLE_EVENT.  In this case, Handle must also
                     be the address of a handle variable. (This is not the event handle
                     itself, the event handle is returned in this address).

        Reserved   - MUST be NULL.

        AdapterName - MUST NOT BE NULL.  This is the name of the adapter for which the
                     notification is being registered..

        ClassId    - This specifies the classId if any for which the registration is.

        Params     - This is the set of parameter to listen on and notify of when any
                     change happens..

        Handle     - See "Flags" for what this variable is.

    Return values:

        returns Win32 status codes

--*/
{
    DWORD                          Error;
    CHAR                           Buf[256];      // cannot request more options than this!
    CHAR                           VBuf[256];
    DHCPAPI_PARAMS                 Param[2], *pReqParams;
    ULONG                          i;
    DWORD                          nOpt, nVOpt;

    if( Flags != DHCPCAPI_REGISTER_HANDLE_EVENT ) {
        return ERROR_INVALID_PARAMETER;
    }

    if( NULL != Reserved || NULL == AdapterName || 0 == Params.nParams || NULL == Handle ) {
        return ERROR_INVALID_PARAMETER;
    }

    nOpt = nVOpt = 0;
    for( i = 0; i < Params.nParams ; i ++ ) {
        if( Params.Params[i].IsVendor ) {
            VBuf[nVOpt++] = (BYTE)Params.Params[i].OptionId;
        } else {
            Buf[nOpt++] = (BYTE)Params.Params[i].OptionId;
        }
    }

    Param[0].OptionId = OPTION_PARAMETER_REQUEST_LIST;
    Param[0].IsVendor = FALSE;
    Param[0].Data = Buf;
    Param[0].nBytesData = nOpt;

    Param[1].OptionId = OPTION_PAD;
    Param[1].IsVendor = TRUE;
    Param[1].Data = VBuf;
    Param[1].nBytesData = nVOpt;

    if( 0 == nOpt ) pReqParams = &Param[1]; else pReqParams = &Param[0];

    return DhcpRegisterParameterChangeNotification(
        AdapterName,
        ClassId? ClassId->Data : NULL,
        ClassId? ClassId->nBytesData : 0,
        pReqParams,
        (nOpt != 0) + (nVOpt != 0),
        0,
        Handle
    );
}

DWORD
APIENTRY
DhcpDeRegisterParamChange(                        // undo the registration
    IN      DWORD                  Flags,         // MUST BE ZERO --> No flags yet.
    IN      LPVOID                 Reserved,      // MUST BE NULL --> Reserved
    IN      LPVOID                 Event          // handle to event returned by DhcpRegisterParamChange.
)
/*++

    Routine description:

        This routine undoes whateve was done by previous routine, and closes the
        handle also.  The handle cannot be used after this.

    Arguments:

        Flags   - MUST BE DHCPCAPI_REGISTER_HANDLE_EVENT currently.

        Reserved - MuST BE NULL

        Event   - this is the event handle returned in the "Handle" parameter to
                  DhcpRegisterParamChange function.

    Return Value:

        Win32 status

--*/
{
    return DhcpDeRegisterParameterChangeNotification(Event);
}


DWORD
APIENTRY
DhcpRemoveDNSRegistrations(
    VOID
    )
{
    return DhcpAdapterOnlyApi(NULL, RemoveDNSRegistrationsOpCode);
}


//================================================================================
// end of file
//================================================================================
#endif H_ONLY
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\client\nt\dhcploc.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    local.h

Abstract:

    This module contains various declarations for implementation
    specific "stuff".

Author:

    Manny Weiser (mannyw)  21-Oct-1992

Environment:

    User Mode - Win32

Revision History:

    Madan Appiah (madana)  21-Oct-1993

--*/

#ifndef _LOCAL_
#define _LOCAL_

//
// dhcp.c will #include this file with GLOBAL_DATA_ALLOCATE defined.
// That will cause each of these variables to be allocated.
//

#ifdef  GLOBAL_DATA_ALLOCATE
#define GLOBAL
#else
#define GLOBAL extern
#endif

#define DAY_LONG_SLEEP                          24*60*60    // in secs.
#define INVALID_INTERFACE_CONTEXT               0xFFFF

#define DHCP_NEW_IPADDRESS_EVENT_NAME   L"DHCPNEWIPADDRESS"

//
// Registry keys and values we're interested in.
//

#define DHCP_SERVICES_KEY                       L"System\\CurrentControlSet\\Services"

#define DHCP_ADAPTERS_KEY                       L"System\\CurrentControlSet\\Services\\TCPIP\\Linkage"
#define DHCP_ADAPTERS_VALUE                     L"Bind"
#define DHCP_ADAPTERS_VALUE_TYPE                REG_MULTI_SZ
#define DHCP_ADAPTERS_DEVICE_STRING             L"\\Device\\"
#define DHCP_TCPIP_DEVICE_STRING                L"\\Device\\TCPIP_"
#if     defined(_PNP_POWER_)
#define DHCP_NETBT_DEVICE_STRING                L"NetBT_TCPIP_"
#else
#define DHCP_NETBT_DEVICE_STRING                L"NetBT_"
#endif _PNP_POWER_

#define DHCP_CLIENT_ENABLE_DYNDNS_VALUE         L"EnableDynDNS"
#define DHCP_CLIENT_ENABLE_DYNDNS_VALUE_TYPE    REG_DWORD

#define DHCP_CLIENT_PARAMETER_KEY               L"System\\CurrentControlSet\\Services\\Dhcp\\Parameters"
#define DHCP_CLIENT_CONFIGURATIONS_KEY          L"System\\CurrentControlSet\\Services\\Dhcp\\Configurations"

#if DBG
#define DHCP_DEBUG_FLAG_VALUE                   L"DebugFlag"
#define DHCP_DEBUG_FLAG_VALUE_TYPE              REG_DWORD

#define DHCP_DEBUG_FILE_VALUE                   L"DebugFile"
#define DHCP_DEBUG_FILE_VALUE_TYPE              REG_SZ

#define DHCP_SERVER_PORT_VALUE                  L"ServerPort"
#define DHCP_CLIENT_PORT_VALUE                  L"ClientPort"

#endif

#define DHCP_CLIENT_OPTION_KEY                  L"System\\CurrentControlSet\\Services\\Dhcp\\Parameters\\Options"

#define DHCP_CLIENT_GLOBAL_CLASSES_KEY          L"System\\CurrentControlSet\\Services\\Tcpip\\Parameters\\Classes"
#define DHCP_CLIENT_CLASS_VALUE                 L"DhcpMachineClass"

#define DHCP_ADAPTER_PARAMETERS_KEY             L"\\TCPIP\\Parameters\\Interfaces"
#define DHCP_ADAPTER_PARAMETERS_KEY_OLD         L"Parameters\\TCPIP"

#define DHCP_DEFAULT_GATEWAY_PARAMETER          L"DefaultGateway"
#define DHCP_DEFAULT_GATEWAY_METRIC_PARAMETER   L"DefaultGatewayMetric"
#define DHCP_INTERFACE_METRIC_PARAMETER         L"InterfaceMetric"
#define DHCP_DONT_ADD_DEFAULT_GATEWAY_FLAG      L"DontAddDefaultGateway"
#define DHCP_DONT_PING_GATEWAY_FLAG             L"DontPingGateway"
#define DHCP_USE_MHASYNCDNS_FLAG                L"UseMHAsyncDns"
#define DHCP_USE_INFORM_FLAG                    L"UseInform"
#ifdef BOOTPERF
#define DHCP_QUICK_BOOT_FLAG                    L"EnableQuickBoot"
#endif BOOTPERF
#define DHCP_INFORM_SEPARATION_INTERVAL         L"DhcpInformInterval"

#define DHCP_TCPIP_PARAMETERS_KEY               DHCP_SERVICES_KEY L"\\TCPIP\\Parameters"
#define DHCP_TCPIP_ADAPTER_PARAMETERS_KEY       NULL
#define DHCP_NAME_SERVER_VALUE                  L"NameServer"
#define DHCP_IPADDRESS_VALUE                    L"IPAddress"
#define DHCP_HOSTNAME_VALUE                     L"Hostname"
#define DHCP_DOMAINNAME_VALUE                   L"Domain"
#define DHCP_STATIC_DOMAIN_VALUE_A              "Domain"

#define DHCP_STATIC_IP_ADDRESS_STRING           L"IPAddress"
#define DHCP_STATIC_IP_ADDRESS_STRING_TYPE      REG_MULTI_SZ

#define DHCP_STATIC_SUBNET_MASK_STRING          L"SubnetMask"
#define DHCP_STATIC_SUBNET_MASK_STRING_TYPE     REG_MULTI_SZ

#ifdef __DHCP_CLIENT_OPTIONS_API_ENABLED__

#define DHCP_CLIENT_OPTION_SIZE                 L"OptionSize"
#define DHCP_CLIENT_OPTION_SIZE_TYPE            REG_DWORD
#define DHCP_CLIENT_OPTION_VALUE                L"OptionValue"
#define DHCP_CLIENT_OPTION_VALUE_TYPE           REG_BINARY

#endif

#define REGISTRY_CONNECT                        L'\\'
#define REGISTRY_CONNECT_STRING                 L"\\"

#define DHCP_CLIENT_OPTION_REG_LOCATION         L"RegLocation"
#define DHCP_CLIENT_OPTION_REG_LOCATION_TYPE    REG_SZ

#define DHCP_CLIENT_OPTION_REG_KEY_TYPE         L"KeyType"
#define DHCP_CLIENT_OPTION_REG_KEY_TYPE_TYPE    REG_DWORD

#define DHCP_CLASS_LOCATION_VALUE               L"DhcpClientClassLocation"
#define DHCP_CLASS_LOCATION_TYPE                REG_MULTI_SZ

#define DEFAULT_USER_CLASS_LOCATION             L"Tcpip\\Parameters\\Interfaces\\?\\DhcpClassIdBin"
#define DEFAULT_USER_CLASS_LOC_FULL             DHCP_SERVICES_KEY REGISTRY_CONNECT_STRING DEFAULT_USER_CLASS_LOCATION

#define DEFAULT_USER_CLASS_UI_LOCATION          L"Tcpip\\Parameters\\Interfaces\\?\\DhcpClassId"
#define DEFAULT_USER_CLASS_UI_LOC_FULL          DHCP_SERVICES_KEY REGISTRY_CONNECT_STRING DEFAULT_USER_CLASS_UI_LOCATION

// ******** Don;t chagne regloc for below.. it also affects DHCP_REGISTER_OPTION_LOC below
#define DEFAULT_REGISTER_OPT_LOC            L"Tcpip\\Parameters\\Interfaces\\?\\DhcpRequestOptions"

#define DHCP_OPTION_LIST_VALUE                  L"DhcpOptionLocationList"
#define DHCP_OPTION_LIST_TYPE                   REG_MULTI_SZ

#define NETBIOSLESS_OPT                         L"DhcpNetbiosOptions\0"
#define DEFAULT_DHCP_KEYS_LIST_VALUE            (L"1\0" L"15\0" L"3\0" L"44\0" L"46\0" L"47\0" L"6\0" NETBIOSLESS_OPT)

#define DHCP_OPTION_OPTIONID_VALUE              L"OptionId"
#define DHCP_OPTION_OPTIONID_TYPE               REG_DWORD

#define DHCP_OPTION_ISVENDOR_VALUE              L"VendorType"
#define DHCP_OPTION_ISVENDOR_TYPE               REG_DWORD

#define DHCP_OPTION_SAVE_TYPE_VALUE             L"KeyType"
#define DHCP_OPTION_SAVE_TYPE_TYPE              REG_DWORD

#define DHCP_OPTION_CLASSID_VALUE               L"ClassId"
#define DHCP_OPTION_CLASSID_TYPE                REG_BINARY

#define DHCP_OPTION_SAVE_LOCATION_VALUE         L"RegLocation"
#define DHCP_OPTION_SAVE_LOCATION_TYPE          REG_MULTI_SZ

#define DHCP_OPTION_SEND_LOCATION_VALUE         L"RegSendLocation"
#define DHCP_OPTION_SEND_LOCATION_TYPE          REG_MULTI_SZ

#define DHCP_ENABLE_STRING                      L"EnableDhcp"
#define DHCP_ENABLE_STRING_TYPE                 REG_DWORD

#define DHCP_IP_ADDRESS_STRING                  L"DhcpIPAddress"
#define DHCP_IP_ADDRESS_STRING_TYPE             REG_SZ

#define DHCP_SUBNET_MASK_STRING                 L"DhcpSubnetMask"
#define DHCP_SUBNET_MASK_STRING_TYPE            REG_SZ

#define DHCP_SERVER                             L"DhcpServer"
#define DHCP_SERVER_TYPE                        REG_SZ

#define DHCP_LEASE                              L"Lease"
#define DHCP_LEASE_TYPE                         REG_DWORD

#define DHCP_LEASE_OBTAINED_TIME                L"LeaseObtainedTime"
#define DHCP_LEASE_OBTAINED_TIME_TYPE           REG_DWORD

#define DHCP_LEASE_T1_TIME                      L"T1"
#define DHCP_LEASE_T1_TIME_TYPE                 REG_DWORD

#define DHCP_LEASE_T2_TIME                      L"T2"
#define DHCP_LEASE_T2_TIME_TYPE                 REG_DWORD

#define DHCP_LEASE_TERMINATED_TIME              L"LeaseTerminatesTime"
#define DHCP_LEASE_TERMINATED_TIME_TYPE         REG_DWORD

#define DHCP_IP_INTERFACE_CONTEXT               L"IpInterfaceContext"
#define DHCP_IP_INTERFACE_CONTEXT_TYPE          REG_DWORD

#define DHCP_IP_INTERFACE_CONTEXT_MAX           L"IpInterfaceContextMax"
#define DHCP_IP_INTERFACE_CONTEXT_MAX_TYPE      REG_DWORD

#if     defined(_PNP_POWER_)
#define DHCP_NTE_CONTEXT_LIST                   L"NTEContextList"
#define DHCP_NTE_CONTEXT_LIST_TYPE              REG_MULTI_SZ
#endif _PNP_POWER_

#define DHCP_CLIENT_IDENTIFIER_FORMAT           L"DhcpClientIdentifierType"
#define DHCP_CLIENT_IDENTIFIER_FORMAT_TYPE      REG_DWORD

#define DHCP_CLIENT_IDENTIFIER_VALUE            L"DhcpClientIdentifier"

#define DHCP_DYNDNS_UPDATE_REQUIRED             L"DNSUpdateRequired"
#define DHCP_DYNDNS_UPDATE_REQUIRED_TYPE        REG_DWORD

#define DHCP_IPAUTOCONFIGURATION_ENABLED        L"IPAutoconfigurationEnabled"
#define DHCP_IPAUTOCONFIGURATION_ENABLED_TYPE   REG_DWORD

#define DHCP_IPAUTOCONFIGURATION_ADDRESS        L"IPAutoconfigurationAddress"
#define DHCP_IPAUTOCONFIGURATION_ADDRESS_TYPE   REG_SZ

#define DHCP_IPAUTOCONFIGURATION_SUBNET         L"IPAutoconfigurationSubnet"
#define DHCP_IPAUTOCONFIGURATION_SUBNET_TYPE    REG_SZ

#define DHCP_IPAUTOCONFIGURATION_MASK           L"IPAutoconfigurationMask"
#define DHCP_IPAUTOCONFIGURATION_MASK_TYPE      REG_SZ

#define DHCP_IPAUTOCONFIGURATION_SEED           L"IPAutoconfigurationSeed"
#define DHCP_IPAUTOCONFIGURATION_SEED_TYPE      REG_DWORD

#define DHCP_IPAUTOCONFIGURATION_CFG            L"ActiveConfigurations"
#define DHCP_IPAUTOCONFIGURATION_CFG_TYPE       REG_MULTI_SZ

#define DHCP_IPAUTOCONFIGURATION_CFGOPT         L"Options"
#define DHCP_IPAUTOCONFIGURATION_CFGOPT_TYPE    REG_BINARY

#define DHCP_OPTION_EXPIRATION_DATE             L"ExpirationTime"
#define DHCP_OPTION_EXPIRATION_DATE_TYPE        REG_BINARY

#define DHCP_MACHINE_TYPE                       L"MachineType"
#define DHCP_MACHINE_TYPE_TYPE                  REG_DWORD

#define DHCP_AUTONET_RETRIES_VALUE              L"AutonetRetries"
#define DHCP_AUTONET_RETRIES_VALUE_TYPE         REG_DWORD

#define DHCP_ADDRESS_TYPE_VALUE                 L"AddressType"
#define DHCP_ADDRESS_TYPE_TYPE                  REG_DWORD

#if DBG

#define DHCP_LEASE_OBTAINED_CTIME               L"LeaseObtainedCTime"
#define DHCP_LEASE_OBTAINED_CTIME_TYPE          REG_SZ

#define DHCP_LEASE_T1_CTIME                     L"T1CTime"
#define DHCP_LEASE_T1_CTIME_TYPE                REG_SZ

#define DHCP_LEASE_T2_CTIME                     L"T2CTime"
#define DHCP_LEASE_T2_CTIME_TYPE                REG_SZ

#define DHCP_LEASE_TERMINATED_CTIME             L"LeaseTerminatesCTime"
#define DHCP_LEASE_TERMINATED_CTIME_TYPE        REG_SZ

#define DHCP_OPTION_EXPIRATION_CDATE            L"ExpirationCTime"
#define DHCP_OPTION_EXPIRATION_CDATE_TYPE       REG_SZ


#endif

// options api specials
#define DHCPAPI_VALID_VALUE                     L"Valid"
#define DHCPAPI_VALID_VALUE_TYPE                REG_DWORD

#define DHCPAPI_AVAIL_VALUE                     L"AvailableOptions"
#define DHCPAPI_AVAIL_VALUE_TYPE                REG_BINARY

#define DHCPAPI_REQUESTED_VALUE                 L"RequestedOptions"
#define DHCPAPI_REQUESTED_VALUE_TYPE            REG_BINARY

#define DHCPAPI_RAW_OPTIONS_VALUE               L"RawOptionsValue"
#define DHCPAPI_RAW_OPTIONS_VALUE_TYPE          REG_BINARY

#define DHCPAPI_RAW_LENGTH_VALUE                L"RawOptionsLength"
#define DHCPAPI_RAW_LENGTH_VALUE_TYPE           REG_DWORD

#define DHCPAPI_GATEWAY_VALUE                   L"LastGateWay"
#define DHCPAPI_GATEWAY_VALUE_TYPE              REG_DWORD

// this tag is used to locate dns updates requests on the renewal list
#define DHCP_DNS_UPDATE_CONTEXT_TAG             L"DNSUpdateRetry"

// This semaphore cannot have backward slashes in it.
#define DHCP_REQUEST_OPTIONS_API_SEMAPHORE      L"DhcpRequestOptionsAPI"

// the client vendor name (DhcpGlobalClientClassInfo) value is this..
#define DHCP_DEFAULT_CLIENT_CLASS_INFO          "MSFT 5.0"

// the location for storing options for DhcpRegisterOptions API.
// ****** Don't change the foll value -- it also changes DEFAULT_REGISTER_OPT_LOC above
//
#define DHCP_REGISTER_OPTIONS_LOC               DHCP_TCPIP_PARAMETERS_KEY L"\\Interfaces\\?\\DhcpRequestOptions"

//
// the value name of the flag that controls whether the popups are displayed or not on NT..
// (By default they are NOT displayed -- this value is under System\CCS\Services\Dhcp)
//
#define DHCP_DISPLAY_POPUPS_FLAG                L"PopupFlag"

#ifdef BOOTPERF
//
//  The values related to quick boot...  All of these start with "Temp"
//
//
#define DHCP_TEMP_IPADDRESS_VALUE               L"TempIpAddress"
#define DHCP_TEMP_MASK_VALUE                    L"TempMask"
#define DHCP_TEMP_LEASE_EXP_TIME_VALUE          L"TempLeaseExpirationTime"
#endif BOOTPERF

//
// size of the largest adapter name in unicode.
//
#define ADAPTER_STRING_SIZE 512

//
// windows version info.
//

#define HOST_COMMENT_LENGTH                     128
#define WINDOWS_32S                             "Win32s on Windows 3.1"
#define WINDOWS_NT                              "Windows NT"

#define DHCP_NAMESERVER_BACKUP                  L"Backup"
#define DHCP_NAMESERVER_BACKUP_LIST             L"BackupList"

//
// Adapter Key - replacement character.
//
#define OPTION_REPLACE_CHAR                     L'\?'

//
// registry access key.
//

#define DHCP_CLIENT_KEY_ACCESS  (KEY_QUERY_VALUE |           \
                                    KEY_SET_VALUE |          \
                                    KEY_CREATE_SUB_KEY |     \
                                    KEY_ENUMERATE_SUB_KEYS)

//
// Dhcp registry class.
//

#define DHCP_CLASS                      L"DhcpClientClass"
#define DHCP_CLASS_SIZE                 sizeof(DHCP_CLASS)


//
// Option ID key length.
//

#define DHCP_OPTION_KEY_LEN             32

//
// The name of the DHCP service DLL
//

#define DHCP_SERVICE_DLL                L"dhcpcsvc.dll"

#define DHCP_RELEASE_ON_SHUTDOWN_VALUE  L"ReleaseOnShutdown"

#define DEFAULT_RELEASE_ON_SHUTDOWN     RELEASE_ON_SHUTDOWN_OBEY_DHCP_SERVER

//
// command values for SetDefaultGateway function.

#define DEFAULT_GATEWAY_ADD             0
#define DEFAULT_GATEWAY_DELETE          1


//
// A block NT specific context information, appended the the DHCP work
// context block.
//

typedef struct _LOCAL_CONTEXT_INFO {
    DWORD  IpInterfaceContext;
    DWORD  IpInterfaceInstance;  // needed for BringUpInterface
    DWORD  IfIndex;
    LPWSTR AdapterName;
    LPWSTR NetBTDeviceName;
    LPWSTR RegistryKey;
    SOCKET Socket;
    BOOL DefaultGatewaysSet;
#ifdef BOOTPERF
    ULONG OldIpAddress;
    ULONG OldIpMask;
    BOOL fInterfaceDown;
#endif BOOTPERF
} LOCAL_CONTEXT_INFO, *PLOCAL_CONTEXT_INFO;

//
// Other service specific options info struct.
//

typedef struct _SERVICE_SPECIFIC_DHCP_OPTION {
    DHCP_OPTION_ID OptionId;
    LPWSTR RegKey;              // alloted memory.
    LPWSTR ValueName;           // embedded in the RegKey memory.
    DWORD ValueType;
    DWORD OptionLength;
#ifdef __DHCP_CLIENT_OPTIONS_API_ENABLED__
    time_t ExpirationDate; // this value is used to decide when to stop
                           // requested unneeded options.
#endif
    LPBYTE RawOptionValue;
} SERVICE_SPECIFIC_DHCP_OPTION, *LPSERVICE_SPECIFIC_DHCP_OPTION;


//
// Key query Info.
//

typedef struct _DHCP_KEY_QUERY_INFO {
    WCHAR Class[DHCP_CLASS_SIZE];
    DWORD ClassSize;
    DWORD NumSubKeys;
    DWORD MaxSubKeyLen;
    DWORD MaxClassLen;
    DWORD NumValues;
    DWORD MaxValueNameLen;
    DWORD MaxValueLen;
    DWORD SecurityDescriptorLen;
    FILETIME LastWriteTime;
} DHCP_KEY_QUERY_INFO, *LPDHCP_KEY_QUERY_INFO;

//
// Global variables.
//

//
// client specific option list.
//


GLOBAL HINSTANCE DhcpGlobalMessageFileHandle;

GLOBAL DWORD DhcpGlobalOptionCount;
GLOBAL LPSERVICE_SPECIFIC_DHCP_OPTION DhcpGlobalOptionInfo;
GLOBAL LPBYTE DhcpGlobalOptionList;

//
// Service variables
//

GLOBAL SERVICE_STATUS DhcpGlobalServiceStatus;
GLOBAL SERVICE_STATUS_HANDLE DhcpGlobalServiceStatusHandle;

//
// To signal to stop the service.
//

GLOBAL HANDLE DhcpGlobalTerminateEvent;

//
// Client APIs over name pipe variables.
//

GLOBAL HANDLE DhcpGlobalClientApiPipe;
GLOBAL HANDLE DhcpGlobalClientApiPipeEvent;
GLOBAL OVERLAPPED DhcpGlobalClientApiOverLapBuffer;

//
// Message Popup Thread handle.
//

GLOBAL HANDLE DhcpGlobalMsgPopupThreadHandle;
GLOBAL BOOL DhcpGlobalDisplayPopup;
GLOBAL CRITICAL_SECTION DhcpGlobalPopupCritSect;

#define LOCK_POPUP()   EnterCriticalSection(&DhcpGlobalPopupCritSect)
#define UNLOCK_POPUP() LeaveCriticalSection(&DhcpGlobalPopupCritSect)


//
// winsock variables.
//

GLOBAL WSADATA DhcpGlobalWsaData;
GLOBAL BOOL DhcpGlobalWinSockInitialized;

GLOBAL BOOL DhcpGlobalGatewaysSet;

//
// a named event that notifies the ip address changes to
// external apps.
//

GLOBAL HANDLE DhcpGlobalNewIpAddressNotifyEvent;
GLOBAL UINT   DhcpGlobalIPEventSeqNo;

GLOBAL ULONG  DhcpGlobalIsShuttingDown;

//
// Added for winse 25452
// This is to allow reading of the DNS client policy
// in the registry so that DHCP can figure out if
// per adapter name registration is enabled for 
// dynamic dns.
//
#define DNS_POLICY_KEY          L"Software\\Policies\\Microsoft\\Windows NT\\DnsClient"
#define REGISTER_ADAPTER_NAME   L"RegisterAdapterName"
#define ADAPTER_DOMAIN_NAME     L"AdapterDomainName"



#endif // _LOCAL_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\client\nt\leaseapi.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    leaseapi.c

Abstract:

    This file contains apis that obtains/releases ip address from a
    dhcpserver. These apis can be called by any apps that needs an ip
    address for lease.


Author:

    Madan Appiah (madana)  30-Nov-1993

Environment:

    User Mode - Win32

Revision History:

--*/

#include "precomp.h"
#include "dhcpglobal.h"
#include <dhcploc.h>
#include <dhcppro.h>
#include <align.h>

#include <dhcpcapi.h>
#include <iphlpapi.h>

#define  DEFAULT_RAS_CLASS         "RRAS.Microsoft"

//
// Helper routine
//

VOID
GetHardwareAddressForIpAddress(
    IN ULONG IpAddress,
    IN OUT LPBYTE Buf,
    IN OUT PULONG BufSize
)
/*++

Routine Description:

    This routine calls into iphlpapi to try to figure out the hardware
    address for an adapter with the given Ip address..
    In case of failure, it sets the BufSize to zero.

Arguments:

    IpAddress -- N/W order IpAddress of context for which h/w addr is needed.
    Buf -- buffer to fill hardware address 
    BufSize -- input size of buffer, and on output how much of buffer is
    used.

--*/
{
    MIB_IPADDRTABLE *AddrTable;
    MIB_IFTABLE *IfTable;
    ULONG Error, i, Index, OldBufSize;
    ULONG AllocateAndGetIpAddrTableFromStack( 
        MIB_IPADDRTABLE **, BOOL, HANDLE, ULONG 
        );
    ULONG AllocateAndGetIfTableFromStack( 
        MIB_IFTABLE **, BOOL, HANDLE, ULONG, BOOL
        );

    IpAddress = ntohl(IpAddress);
    OldBufSize = (*BufSize);
    (*BufSize) = 0;
    AddrTable = NULL;
    IfTable = NULL;

    do {
        Error = AllocateAndGetIpAddrTableFromStack(
            &AddrTable,
            FALSE,
            GetProcessHeap(),
            0
            );
        if( ERROR_SUCCESS != Error ) break;

        Error = AllocateAndGetIfTableFromStack(
            &IfTable,
            FALSE,
            GetProcessHeap(),
            0,
            FALSE
            );
        if( ERROR_SUCCESS != Error ) break;

        //
        // Got both tables.. Now walk the ip addr table to get the index.
        //

        for( i = 0; i < AddrTable->dwNumEntries ; i ++ ) {
            if( AddrTable->table[i].dwAddr == IpAddress ) break;
        }

        if( i >= AddrTable->dwNumEntries ) break;
        Index = AddrTable->table[i].dwIndex;

        //
        // Now walk the iftable to find the hwaddr entyr.
        //
        
        for( i = 0; i < IfTable->dwNumEntries ; i ++ ) {
            if( IfTable->table[i].dwIndex == Index ) {
                break;
            }
        }

        if( i >= IfTable->dwNumEntries ) break;

        //
        // Copy the hw address if there is space.
        //

        if( OldBufSize <= IfTable->table[i].dwPhysAddrLen ) break;
        *BufSize = IfTable->table[i].dwPhysAddrLen;

        RtlCopyMemory( Buf, IfTable->table[i].bPhysAddr, *BufSize );
        
        //
        // done
        //
    } while ( 0 );

    if( NULL != AddrTable ) HeapFree( GetProcessHeap(), 0, AddrTable );
    if( NULL != IfTable ) HeapFree( GetProcessHeap(), 0, IfTable );
    return ;
}

ULONG
GetSeed(
    VOID
    )
/*++

Routine Description:
    This routine returns a rand number seed that can be used on
    any thread... (If the routine is called on multiple threads,
    it tries to make sure that the same number isn't returned in
    different threads).

--*/
{
    static LONG Seed = 0;
    LONG OldSeed;

    OldSeed = InterlockedIncrement(&Seed) - 1;
    if( 0 == OldSeed ) {
        OldSeed = Seed = (LONG) time(NULL);
    }

    srand((OldSeed << 16) + (LONG)time(NULL));
    OldSeed = (rand() << 16) + (rand());
    Seed = (rand() << 16) + (rand());
    return OldSeed;
}
        
DWORD
DhcpLeaseIpAddressEx(
    IN DWORD AdapterIpAddress,
    IN LPDHCP_CLIENT_UID ClientUID,
    IN DWORD DesiredIpAddress OPTIONAL,
    IN OUT LPDHCP_OPTION_LIST OptionList,
    OUT LPDHCP_LEASE_INFO *LeaseInfo,
    IN OUT LPDHCP_OPTION_INFO *OptionInfo,
    IN LPBYTE ClassId OPTIONAL,
    IN ULONG ClassIdLen
    )
/*++

Routine Description:

    This api obtains an IP address lease from a dhcp server. The
    caller should specify the client uid and a desired ip address.
    The client uid must be globally unique. Set the desired ip address
    to zero if you can accept any ip address. Otherwise this api will
    try to obtain the ip address you have specified, but not guaranteed.

    The caller may optionally requtest additional option info from the
    dhcp server, The caller should specify the list in OptionList
    parameter and the api will return the available option data in
    OptionInfo structure.

    ?? Option retrival is not implemented in the first phase. This
    requires several modification in the dhcp client code.

    WSAStartup must haave been successfully called before this function
    can be called.

Arguments:

    AdapterIpAddress - IpAddress of the adapter. On a multi-homed
        machined this specifies the subnet from which an address is
        requested. This value can be set to zero if the machine is a
        non-multi-homed machine or you like to get ip address from any
        of the subnets. This must be network byte order..

    ClientUID - pointer to a client UID structure.

    DesiredIpAddress - the ip address you prefer.

    OptionList - list of option ids.

    LeaseInfo - pointer to a location where the lease info structure
        pointer is retured. The caller should free up this structure
        after use.

    OptionInfo - pointer to a location where the option info structure
        pointer is returned. The caller should free up this structure
        after use.

    ClassId - a byte sequence for user class

    ClassIdLen - number of bytes present in ClassId

Return Value:

    Windows Error.

--*/
{
    DWORD                          Error;
    PDHCP_CONTEXT                  DhcpContext = NULL;
    ULONG                          DhcpContextSize;
    PLOCAL_CONTEXT_INFO            LocalInfo = NULL;
    LPVOID                         Ptr;
    DHCP_OPTIONS                   DhcpOptions;
    LPDHCP_LEASE_INFO              LocalLeaseInfo = NULL;
    time_t                         LeaseObtained;
    DWORD                          T1, T2, Lease;
    BYTE                           DefaultParamRequests[] = { 0x2E, 0x2C, 0x0F, 0x01, 0x03, 0x06, 0x2F };
    DWORD                          nDefaultParamRequests = sizeof(DefaultParamRequests);
    ULONG                          HwAddrSize;
    BYTE                           HwAddrBuf[200];
    BOOL                           fAutoConfigure = TRUE;
    DHCP_OPTION                    ParamRequestList = {
        { NULL, NULL /* List entry */},
        OPTION_PARAMETER_REQUEST_LIST,
        FALSE /* not a vendor specific option */,
        NULL,
        0 /* no class id */,
        0 /* expiration time useless */,
        DefaultParamRequests,
        nDefaultParamRequests
    };

    if( NULL == ClassId && 0 != ClassIdLen || 0 == ClassIdLen && NULL != ClassId ) {
        return ERROR_INVALID_PARAMETER;
    }

    Error = DhcpCommonInit();
    if( ERROR_SUCCESS != Error ) return Error;

    HwAddrSize = 0;
    if( INADDR_ANY != AdapterIpAddress 
        && INADDR_LOOPBACK  != AdapterIpAddress ) {
        HwAddrSize = sizeof(HwAddrBuf);
        GetHardwareAddressForIpAddress( AdapterIpAddress, HwAddrBuf, &HwAddrSize );;
    }

    if( 0 == HwAddrSize ) {
        HwAddrSize = ClientUID->ClientUIDLength;
        if( HwAddrSize > sizeof(HwAddrBuf) ) return ERROR_INVALID_DATA;
        RtlCopyMemory(HwAddrBuf, ClientUID->ClientUID, HwAddrSize );
    }

    DhcpContextSize =                             // allocate memory for dhcpcontext, in one blob
        ROUND_UP_COUNT(sizeof(DHCP_CONTEXT), ALIGN_WORST) +
        ROUND_UP_COUNT(ClientUID->ClientUIDLength, ALIGN_WORST) + 
        ROUND_UP_COUNT(HwAddrSize, ALIGN_WORST ) +
        ROUND_UP_COUNT(sizeof(LOCAL_CONTEXT_INFO), ALIGN_WORST) +
        ROUND_UP_COUNT(DHCP_RECV_MESSAGE_SIZE, ALIGN_WORST);

    Ptr = DhcpAllocateMemory( DhcpContextSize );
    if ( Ptr == NULL ) return( ERROR_NOT_ENOUGH_MEMORY );

    memset(Ptr, 0, DhcpContextSize);

    DhcpContext = Ptr;                            // align up the pointers
    Ptr = ROUND_UP_POINTER( (LPBYTE)Ptr + sizeof(DHCP_CONTEXT), ALIGN_WORST);
    DhcpContext->ClientIdentifier.pbID = Ptr;
    Ptr = ROUND_UP_POINTER( (LPBYTE)Ptr + ClientUID->ClientUIDLength, ALIGN_WORST);
    DhcpContext->HardwareAddress = Ptr;
    Ptr = ROUND_UP_POINTER( (LPBYTE)Ptr + HwAddrSize, ALIGN_WORST);
    DhcpContext->LocalInformation = Ptr;
    LocalInfo = Ptr;
    Ptr = ROUND_UP_POINTER( (LPBYTE)Ptr + sizeof(LOCAL_CONTEXT_INFO), ALIGN_WORST);
    DhcpContext->MessageBuffer = Ptr;

    //
    // initialize fields.
    //

    DhcpContext->HardwareAddressType = HARDWARE_TYPE_10MB_EITHERNET;
    DhcpContext->HardwareAddressLength = HwAddrSize;
    DhcpContext->RefCount = 1 ;
    RtlCopyMemory(DhcpContext->HardwareAddress,HwAddrBuf, HwAddrSize);

    DhcpContext->ClientIdentifier.cbID = ClientUID->ClientUIDLength;
    DhcpContext->ClientIdentifier.bType = HARDWARE_TYPE_10MB_EITHERNET;
    DhcpContext->ClientIdentifier.fSpecified = TRUE;
    RtlCopyMemory(
        DhcpContext->ClientIdentifier.pbID, 
        ClientUID->ClientUID, 
        ClientUID->ClientUIDLength
        );

    DhcpContext->IpAddress = 0;
    DhcpContext->SubnetMask = DhcpDefaultSubnetMask(0);
    DhcpContext->DhcpServerAddress = 0xFFFFFFFF;
    DhcpContext->DesiredIpAddress = DesiredIpAddress;

    DhcpContext->Lease = 0;
    DhcpContext->LeaseObtained = 0;
    DhcpContext->T1Time = 0;
    DhcpContext->T2Time = 0;
    DhcpContext->LeaseExpires = 0;

    INIT_STATE(DhcpContext);
    AUTONET_ENABLED(DhcpContext);
    APICTXT_ENABLED(DhcpContext);                 // mark the context as being created by the API

    DhcpContext->IPAutoconfigurationContext.Address = 0;
    DhcpContext->IPAutoconfigurationContext.Subnet  = inet_addr(DHCP_IPAUTOCONFIGURATION_DEFAULT_SUBNET);
    DhcpContext->IPAutoconfigurationContext.Mask    = inet_addr(DHCP_IPAUTOCONFIGURATION_DEFAULT_MASK);
    DhcpContext->IPAutoconfigurationContext.Seed    = GetSeed();

    InitializeListHead(&DhcpContext->RecdOptionsList);
    InitializeListHead(&DhcpContext->SendOptionsList);
    InsertHeadList(&DhcpContext->SendOptionsList, &ParamRequestList.OptionList);

    DhcpContext->ClassId = ClassId;
    DhcpContext->ClassIdLength = ClassIdLen;

    //
    // copy local info.
    //

    //
    // unused portion of the local info.
    //

    LocalInfo->IpInterfaceContext = 0xFFFFFFFF;
    LocalInfo->AdapterName= NULL;
    //LocalInfo->DeviceName= NULL;
    LocalInfo->NetBTDeviceName= NULL;
    LocalInfo->RegistryKey= NULL;
    LocalInfo->DefaultGatewaysSet = FALSE;

    // used portion of the local info.
    LocalInfo->Socket = INVALID_SOCKET;

    // if AdapterIpAddress is loopback addr then, the client just wants us to
    // fabricate autonet address. The client can do this if there is no interface
    // available on this machine to autonet on.
    if (INADDR_LOOPBACK == AdapterIpAddress) {
        DhcpContext->IpAddress = GrandHashing(
            DhcpContext->HardwareAddress,
            DhcpContext->HardwareAddressLength,
            &DhcpContext->IPAutoconfigurationContext.Seed,
            DhcpContext->IPAutoconfigurationContext.Mask,
            DhcpContext->IPAutoconfigurationContext.Subnet
            );
        DhcpContext->SubnetMask = DhcpContext->IPAutoconfigurationContext.Mask;
        ACQUIRED_AUTO_ADDRESS(DhcpContext);
    } else {
        //
        // open socket now. receive any.
        //

        Error = InitializeDhcpSocket(&LocalInfo->Socket,ntohl( AdapterIpAddress ), IS_APICTXT_ENABLED(DhcpContext) );

        if( Error != ERROR_SUCCESS ) {
            goto Cleanup;
        }

        //
        // now discover an ip address.
        //

        Error = ObtainInitialParameters( DhcpContext, &DhcpOptions, &fAutoConfigure );
        if( ERROR_SEM_TIMEOUT == Error ) {
            DhcpPrint((DEBUG_PROTOCOL, "RAS: No server found, trying to autoconfigure\n"));
            if( fAutoConfigure ) {
                Error = DhcpPerformIPAutoconfiguration(DhcpContext);
            }
            if( ERROR_SUCCESS != Error ) {
                DhcpPrint((DEBUG_ERRORS, "Autoconfiguration for RAS failed: 0x%lx\n", Error));
            }
        }

        //
        // no matter what happens here, freeup the list of options as that is not really needed..
        //

        LOCK_OPTIONS_LIST();
        (void) DhcpDestroyOptionsList(&DhcpContext->RecdOptionsList, &DhcpGlobalClassesList);
        UNLOCK_OPTIONS_LIST();

        if( Error != ERROR_SUCCESS ) {
            goto Cleanup;
        }
    }

    //
    // allocate memory for the return client info structure.
    //

    LocalLeaseInfo = DhcpAllocateMemory( sizeof(DHCP_LEASE_INFO) );

    if( LocalLeaseInfo == NULL ) {
        Error = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }


    LocalLeaseInfo->ClientUID = *ClientUID;
    LocalLeaseInfo->IpAddress = ntohl( DhcpContext->IpAddress );

    if( IS_ADDRESS_AUTO(DhcpContext) ) {
        LocalLeaseInfo->SubnetMask = ntohl(DhcpContext->SubnetMask);
        LocalLeaseInfo->DhcpServerAddress = ntohl(DhcpContext->DhcpServerAddress);
        LocalLeaseInfo->Lease = DhcpContext->Lease;
        LocalLeaseInfo->LeaseObtained = DhcpContext->LeaseObtained;
        LocalLeaseInfo->T1Time = DhcpContext->T1Time;
        LocalLeaseInfo->T2Time = DhcpContext->T2Time;
        LocalLeaseInfo->LeaseExpires = DhcpContext->LeaseExpires;
        Error = ERROR_SUCCESS;
        *LeaseInfo = LocalLeaseInfo;
        goto Cleanup;
    }

    if ( DhcpOptions.SubnetMask != NULL ) {

        LocalLeaseInfo->SubnetMask= ntohl( *DhcpOptions.SubnetMask );
    }
    else {

        LocalLeaseInfo->SubnetMask =
            ntohl(DhcpDefaultSubnetMask( DhcpContext->IpAddress ));
    }


    LocalLeaseInfo->DhcpServerAddress =
        ntohl( DhcpContext->DhcpServerAddress );

    if ( DhcpOptions.LeaseTime != NULL) {

        LocalLeaseInfo->Lease = ntohl( *DhcpOptions.LeaseTime );
    } else {

        LocalLeaseInfo->Lease = DHCP_MINIMUM_LEASE;
    }

    Lease = LocalLeaseInfo->Lease;
    LeaseObtained = time( NULL );
    LocalLeaseInfo->LeaseObtained = LeaseObtained;

    T1 = 0;
    if ( DhcpOptions.T1Time != NULL ) {
        T1 = ntohl( *DhcpOptions.T1Time );
    }

    T2 = 0;
    if ( DhcpOptions.T2Time != NULL ) {
        T2 = ntohl( *DhcpOptions.T2Time );
    }

    //
    // make sure T1 < T2 < Lease
    //

    if( (T2 == 0) || (T2 > Lease) ) {
        T2 = Lease * 7 / 8; // default 87.7 %.
    }

    if( (T1 == 0) || (T1 > T2) ) {
        T1 = (T2 > Lease / 2) ? (Lease / 2) : (T2 - 1);
        // default 50 %.;
    }

    LocalLeaseInfo->T1Time = LeaseObtained  + T1;
    if ( LocalLeaseInfo->T1Time < LeaseObtained ) {
        LocalLeaseInfo->T1Time = INFINIT_TIME;  // over flow.
    }

    LocalLeaseInfo->T2Time = LeaseObtained + T2;
    if ( LocalLeaseInfo->T2Time < LeaseObtained ) {
        LocalLeaseInfo->T2Time = INFINIT_TIME;
    }

    LocalLeaseInfo->LeaseExpires = LeaseObtained + Lease;
    if ( LocalLeaseInfo->LeaseExpires < LeaseObtained ) {
        LocalLeaseInfo->LeaseExpires = INFINIT_TIME;
    }

    *LeaseInfo = LocalLeaseInfo;
    Error = ERROR_SUCCESS;

Cleanup:
    if( OptionInfo ) *OptionInfo = NULL;          // not implemented.

    //
    // close socket.
    //

    if( (LocalInfo != NULL) && (LocalInfo->Socket != INVALID_SOCKET) ) {
        closesocket( LocalInfo->Socket );
    }

    if( DhcpContext != NULL ) {
        DhcpFreeMemory( DhcpContext );
    }

    if( Error != ERROR_SUCCESS ) {

        //
        // free locally allocated memory, if we aren't successful.
        //

        if( LocalLeaseInfo != NULL ) {
            DhcpFreeMemory( LocalLeaseInfo );
            *LeaseInfo = NULL;
        }

    }

    return( Error );
}

DWORD
DhcpRenewIpAddressLeaseEx(
    DWORD AdapterIpAddress,
    LPDHCP_LEASE_INFO ClientLeaseInfo,
    LPDHCP_OPTION_LIST OptionList,
    LPDHCP_OPTION_INFO *OptionInfo,
    LPBYTE ClassId OPTIONAL,
    ULONG ClassIdLen
    )
/*++

Routine Description:

    This api renews an ip address that the client already has. When a
    client gets an ip address, it can use the address until the lease
    expires. The client should stop using the ip address after that.
    Also the client should renew the address after T1 time if the client
    is planning to use the address longer than the current lease time.

    WSAStartup must have been successfully called before this function
    can be called.

Arguments:

    AdapterIpAddress - IpAddress of the adapter. On a multi-homed
        machined this specifies the subnet from which an address is
        renewed. This value can be set to zero if the machine is
        non-multi-homed machine.

    ClientLeaseInfo : pointer to the client lease info structure. On
        entry the structure should contain the information that was
        returned by the DhcpLeaseIpAddress or DhcpRenewIpAddressLease
        apis. On return this structure is updated to reflect the lease
        extension.

    OptionList - list of option ids.

    OptionInfo - pointer to a location where the option info structure
        pointer is returned. The caller should free up this structure
        after use.

    ClassId - a byte sequence for user class

    ClassIdLen - number of bytes present in ClassId

Return Value:

    Windows Error.

--*/
{
    DWORD                          Error;
    PDHCP_CONTEXT                  DhcpContext = NULL;
    ULONG                          DhcpContextSize;
    PLOCAL_CONTEXT_INFO            LocalInfo;
    LPVOID                         Ptr;
    DHCP_OPTIONS                   DhcpOptions;
    time_t                         LeaseObtained;
    DWORD                          T1, T2, Lease;
    BYTE                           DefaultParamRequests[] = { 0x2E, 0x2C, 0x0F, 0x01, 0x03, 0x06, 0x2F };
    DWORD                          nDefaultParamRequests = sizeof(DefaultParamRequests);
    LPDHCP_CLIENT_UID              ClientUID = &(ClientLeaseInfo->ClientUID);
    ULONG                          HwAddrSize;
    BYTE                           HwAddrBuf[200];
    DHCP_OPTION                    ParamRequestList = {
        { NULL, NULL /* List entry */},
        OPTION_PARAMETER_REQUEST_LIST,
        FALSE /* not a vendor specific option */,
        NULL,
        0 /* no class id */,
        0 /* expiration time useless */,
        DefaultParamRequests,
        nDefaultParamRequests
    };

    if( NULL == ClassId && 0 != ClassIdLen || 0 == ClassIdLen && NULL != ClassId) {
        return ERROR_INVALID_PARAMETER;
    }

    Error = DhcpCommonInit();
    if( ERROR_SUCCESS != Error ) return Error;

    //
    // prepare dhcp context structure.
    //

    HwAddrSize = 0;
    if( INADDR_ANY != AdapterIpAddress 
        && INADDR_LOOPBACK  != AdapterIpAddress ) {
        HwAddrSize = sizeof(HwAddrBuf);
        GetHardwareAddressForIpAddress( AdapterIpAddress, HwAddrBuf, &HwAddrSize );;
    }

    if( 0 == HwAddrSize ) {
        HwAddrSize = ClientUID->ClientUIDLength;
        if( HwAddrSize > sizeof(HwAddrBuf) ) return ERROR_INVALID_DATA;
        RtlCopyMemory(HwAddrBuf, ClientUID->ClientUID, HwAddrSize );
    }

    DhcpContextSize =                             // allocate memory for dhcpcontext, in one blob
        ROUND_UP_COUNT(sizeof(DHCP_CONTEXT), ALIGN_WORST) +
        ROUND_UP_COUNT(ClientUID->ClientUIDLength, ALIGN_WORST) + 
        ROUND_UP_COUNT(HwAddrSize, ALIGN_WORST ) +
        ROUND_UP_COUNT(sizeof(LOCAL_CONTEXT_INFO), ALIGN_WORST) +
        ROUND_UP_COUNT(DHCP_RECV_MESSAGE_SIZE, ALIGN_WORST);

    Ptr = DhcpAllocateMemory( DhcpContextSize );
    if ( Ptr == NULL ) {
        return( ERROR_NOT_ENOUGH_MEMORY );
    }

    //
    // make sure the pointers are aligned.
    //

    DhcpContext = Ptr;                            // align up the pointers
    Ptr = ROUND_UP_POINTER( (LPBYTE)Ptr + sizeof(DHCP_CONTEXT), ALIGN_WORST);
    DhcpContext->ClientIdentifier.pbID = Ptr;
    Ptr = ROUND_UP_POINTER( (LPBYTE)Ptr + ClientUID->ClientUIDLength, ALIGN_WORST);
    DhcpContext->HardwareAddress = Ptr;
    Ptr = ROUND_UP_POINTER( (LPBYTE)Ptr + HwAddrSize, ALIGN_WORST);
    DhcpContext->LocalInformation = Ptr;
    LocalInfo = Ptr;
    Ptr = ROUND_UP_POINTER( (LPBYTE)Ptr + sizeof(LOCAL_CONTEXT_INFO), ALIGN_WORST);
    DhcpContext->MessageBuffer = Ptr;

    //
    // initialize fields.
    //

    DhcpContext->HardwareAddressType = HARDWARE_TYPE_10MB_EITHERNET;
    DhcpContext->HardwareAddressLength = HwAddrSize;
    RtlCopyMemory(DhcpContext->HardwareAddress,HwAddrBuf, HwAddrSize);
    DhcpContext->RefCount = 1 ;

    DhcpContext->ClientIdentifier.cbID = ClientUID->ClientUIDLength;
    DhcpContext->ClientIdentifier.bType = HARDWARE_TYPE_10MB_EITHERNET;
    DhcpContext->ClientIdentifier.fSpecified = TRUE;
    RtlCopyMemory(
        DhcpContext->ClientIdentifier.pbID, 
        ClientUID->ClientUID, 
        ClientUID->ClientUIDLength
        );

    DhcpContext->IpAddress = htonl( ClientLeaseInfo->IpAddress );
    DhcpContext->SubnetMask = htonl( ClientLeaseInfo->SubnetMask );
    if( time(NULL) > ClientLeaseInfo->T2Time ) {
        DhcpContext->DhcpServerAddress = 0xFFFFFFFF;
    }
    else {
        DhcpContext->DhcpServerAddress =
            htonl( ClientLeaseInfo->DhcpServerAddress );
    }

    DhcpContext->DesiredIpAddress = DhcpContext->IpAddress;


    DhcpContext->Lease = ClientLeaseInfo->Lease;
    DhcpContext->LeaseObtained = ClientLeaseInfo->LeaseObtained;
    DhcpContext->T1Time = ClientLeaseInfo->T1Time;
    DhcpContext->T2Time = ClientLeaseInfo->T2Time;
    DhcpContext->LeaseExpires = ClientLeaseInfo->LeaseExpires;

    INIT_STATE(DhcpContext);
    AUTONET_ENABLED(DhcpContext);
    CTXT_WAS_LOOKED(DhcpContext);                 // this is to prevent PING from happeneing.
    APICTXT_ENABLED(DhcpContext);                 // mark the context as being created by the API

    DhcpContext->DontPingGatewayFlag = TRUE;      // double assurance against the former..
    DhcpContext->IPAutoconfigurationContext.Address = 0;
    DhcpContext->IPAutoconfigurationContext.Subnet  = inet_addr(DHCP_IPAUTOCONFIGURATION_DEFAULT_SUBNET);
    DhcpContext->IPAutoconfigurationContext.Mask    = inet_addr(DHCP_IPAUTOCONFIGURATION_DEFAULT_MASK);
    DhcpContext->IPAutoconfigurationContext.Seed    = GetSeed();

    InitializeListHead(&DhcpContext->RecdOptionsList);
    InitializeListHead(&DhcpContext->SendOptionsList);
    InsertHeadList(&DhcpContext->SendOptionsList, &ParamRequestList.OptionList);

    DhcpContext->ClassId = ClassId;
    DhcpContext->ClassIdLength = ClassIdLen;


    //
    // copy local info.
    //

    //
    // unused portion of the local info.
    //

    LocalInfo->IpInterfaceContext = 0xFFFFFFFF;
    LocalInfo->AdapterName= NULL;
    //LocalInfo->DeviceName= NULL;
    LocalInfo->NetBTDeviceName= NULL;
    LocalInfo->RegistryKey= NULL;

    //
    // used portion of the local info.
    //

    LocalInfo->Socket = INVALID_SOCKET;
    LocalInfo->DefaultGatewaysSet = FALSE;

    //
    // open socket now.
    //

    Error =  InitializeDhcpSocket(
                &LocalInfo->Socket,
                htonl( AdapterIpAddress ),
                IS_APICTXT_ENABLED(DhcpContext));

    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }

    //
    // now discover ip address.
    //

    Error = RenewLease( DhcpContext, &DhcpOptions );

    //
    // no matter what happens here, freeup the list of options as that is not really needed..
    //

    LOCK_OPTIONS_LIST();
    (void) DhcpDestroyOptionsList(&DhcpContext->RecdOptionsList, &DhcpGlobalClassesList);
    UNLOCK_OPTIONS_LIST();


    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }

    ClientLeaseInfo->DhcpServerAddress =
        ntohl( DhcpContext->DhcpServerAddress );

    if ( DhcpOptions.LeaseTime != NULL) {

        ClientLeaseInfo->Lease = ntohl( *DhcpOptions.LeaseTime );
    } else {

        ClientLeaseInfo->Lease = DHCP_MINIMUM_LEASE;
    }

    Lease = ClientLeaseInfo->Lease;
    LeaseObtained = time( NULL );
    ClientLeaseInfo->LeaseObtained = LeaseObtained;

    T1 = 0;
    if ( DhcpOptions.T1Time != NULL ) {
        T1 = ntohl( *DhcpOptions.T1Time );
    }

    T2 = 0;
    if ( DhcpOptions.T2Time != NULL ) {
        T2 = ntohl( *DhcpOptions.T2Time );
    }

    //
    // make sure T1 < T2 < Lease
    //

    if( (T2 == 0) || (T2 > Lease) ) {
        T2 = Lease * 7 / 8; // default 87.7 %.
    }

    if( (T1 == 0) || (T1 > T2) ) {
        T1 = (T2 > Lease / 2) ? (Lease / 2) : (T2 - 1); // default 50 %.
    }

    ClientLeaseInfo->T1Time = LeaseObtained  + T1;
    if ( ClientLeaseInfo->T1Time < LeaseObtained ) {
        ClientLeaseInfo->T1Time = INFINIT_TIME; // over flow.
    }

    ClientLeaseInfo->T2Time = LeaseObtained + T2;
    if ( ClientLeaseInfo->T2Time < LeaseObtained ) {
        ClientLeaseInfo->T2Time = INFINIT_TIME;
    }

    ClientLeaseInfo->LeaseExpires = LeaseObtained + Lease;
    if ( ClientLeaseInfo->LeaseExpires < LeaseObtained ) {
        ClientLeaseInfo->LeaseExpires = INFINIT_TIME;
    }

    Error = ERROR_SUCCESS;

Cleanup:

    if( OptionInfo ) *OptionInfo = NULL;          // not implemented.

    if( (LocalInfo != NULL) && (LocalInfo->Socket != INVALID_SOCKET) ) {
        closesocket( LocalInfo->Socket );
    }

    if( DhcpContext != NULL ) {
        DhcpFreeMemory( DhcpContext );
    }

    return( Error );
}

DWORD
DhcpReleaseIpAddressLeaseEx(
    DWORD AdapterIpAddress,
    LPDHCP_LEASE_INFO ClientLeaseInfo,
    LPBYTE ClassId OPTIONAL,
    ULONG ClassIdLen
    )
/*++

Routine Description:

    This function releases an ip address the client has.
    WSAStartup must have already been called before this function can be called.

Arguments:

    AdapterIpAddress - IpAddress of the adapter. On a multi-homed
        machined this specifies the subnet to which an address is
        released. This value can be set to zero if the machine is
        non-multi-homed machine.

    ClientLeaseInfo : pointer to the client lease info structure. On
        entry the structure should contain the information that was
        returned by the DhcpLeaseIpAddress or DhcpRenewIpAddressLease
        apis.

    ClassId - a byte sequence for user class

    ClassIdLen - number of bytes present in ClassId

Return Value:

    Windows Error.

--*/
{
    DWORD Error;
    PDHCP_CONTEXT DhcpContext = NULL;
    ULONG DhcpContextSize;
    PLOCAL_CONTEXT_INFO LocalInfo;
    LPDHCP_CLIENT_UID ClientUID = &(ClientLeaseInfo->ClientUID);
    ULONG HwAddrSize;
    BYTE HwAddrBuf[200];
    LPVOID Ptr;

    if( NULL == ClassId && 0 != ClassIdLen || 0 == ClassIdLen && NULL != ClassId ) {
        return ERROR_INVALID_PARAMETER;
    }

    Error = DhcpCommonInit();
    if( ERROR_SUCCESS != Error ) return Error;

    if( (DWORD) -1 == ClientLeaseInfo->DhcpServerAddress ) {
        // this means the address was autoconfigured, nothing to release..
        return ERROR_SUCCESS;
    }

    //
    // prepare dhcp context structure.
    //
    HwAddrSize = 0;
    if( INADDR_ANY != AdapterIpAddress 
        && INADDR_LOOPBACK  != AdapterIpAddress ) {
        HwAddrSize = sizeof(HwAddrBuf);
        GetHardwareAddressForIpAddress( AdapterIpAddress, HwAddrBuf, &HwAddrSize );;
    }

    if( 0 == HwAddrSize ) {
        HwAddrSize = ClientUID->ClientUIDLength;
        if( HwAddrSize > sizeof(HwAddrBuf) ) return ERROR_INVALID_DATA;
        RtlCopyMemory(HwAddrBuf, ClientUID->ClientUID, HwAddrSize );
    }

    DhcpContextSize =                             // allocate memory for dhcpcontext, in one blob
        ROUND_UP_COUNT(sizeof(DHCP_CONTEXT), ALIGN_WORST) +
        ROUND_UP_COUNT(ClientUID->ClientUIDLength, ALIGN_WORST) + 
        ROUND_UP_COUNT(HwAddrSize, ALIGN_WORST ) +
        ROUND_UP_COUNT(sizeof(LOCAL_CONTEXT_INFO), ALIGN_WORST) +
        ROUND_UP_COUNT(DHCP_RECV_MESSAGE_SIZE, ALIGN_WORST);

    Ptr = DhcpAllocateMemory( DhcpContextSize );
    if ( Ptr == NULL ) {
        return( ERROR_NOT_ENOUGH_MEMORY );
    }

    //
    // make sure the pointers are aligned.
    //

    DhcpContext = Ptr;                            // align up the pointers
    Ptr = ROUND_UP_POINTER( (LPBYTE)Ptr + sizeof(DHCP_CONTEXT), ALIGN_WORST);
    DhcpContext->ClientIdentifier.pbID = Ptr;
    Ptr = ROUND_UP_POINTER( (LPBYTE)Ptr + ClientUID->ClientUIDLength, ALIGN_WORST);
    DhcpContext->HardwareAddress = Ptr;
    Ptr = ROUND_UP_POINTER( (LPBYTE)Ptr + HwAddrSize, ALIGN_WORST);
    DhcpContext->LocalInformation = Ptr;
    LocalInfo = Ptr;
    Ptr = ROUND_UP_POINTER( (LPBYTE)Ptr + sizeof(LOCAL_CONTEXT_INFO), ALIGN_WORST);
    DhcpContext->MessageBuffer = Ptr;

    //
    // initialize fields.
    //

    DhcpContext->HardwareAddressType = HARDWARE_TYPE_10MB_EITHERNET;
    DhcpContext->HardwareAddressLength = HwAddrSize;
    RtlCopyMemory(DhcpContext->HardwareAddress,HwAddrBuf, HwAddrSize);
    DhcpContext->RefCount = 1 ;

    DhcpContext->ClientIdentifier.cbID = ClientUID->ClientUIDLength;
    DhcpContext->ClientIdentifier.bType = HARDWARE_TYPE_10MB_EITHERNET;
    DhcpContext->ClientIdentifier.fSpecified = TRUE;
    RtlCopyMemory(
        DhcpContext->ClientIdentifier.pbID, 
        ClientUID->ClientUID, 
        ClientUID->ClientUIDLength
        );

    DhcpContext->IpAddress = htonl( ClientLeaseInfo->IpAddress );
    DhcpContext->SubnetMask = htonl( ClientLeaseInfo->SubnetMask );
    DhcpContext->DhcpServerAddress = htonl( ClientLeaseInfo->DhcpServerAddress );

    DhcpContext->DesiredIpAddress = DhcpContext->IpAddress;

    DhcpContext->Lease = ClientLeaseInfo->Lease;
    DhcpContext->LeaseObtained = ClientLeaseInfo->LeaseObtained;
    DhcpContext->T1Time = ClientLeaseInfo->T1Time;
    DhcpContext->T2Time = ClientLeaseInfo->T2Time;
    DhcpContext->LeaseExpires = ClientLeaseInfo->LeaseExpires;

    INIT_STATE(DhcpContext);
    APICTXT_ENABLED(DhcpContext);                 // mark the context as being created by the API

    DhcpContext->IPAutoconfigurationContext.Address = 0;
    DhcpContext->IPAutoconfigurationContext.Subnet  = inet_addr(DHCP_IPAUTOCONFIGURATION_DEFAULT_SUBNET);
    DhcpContext->IPAutoconfigurationContext.Mask    = inet_addr(DHCP_IPAUTOCONFIGURATION_DEFAULT_MASK);
    DhcpContext->IPAutoconfigurationContext.Seed    = GetSeed();

    InitializeListHead(&DhcpContext->RecdOptionsList);
    InitializeListHead(&DhcpContext->SendOptionsList);

    DhcpContext->ClassId = ClassId;
    DhcpContext->ClassIdLength = ClassIdLen;

    //
    // copy local info.
    //

    //
    // unused portion of the local info.
    //

    LocalInfo->IpInterfaceContext = 0xFFFFFFFF;
    LocalInfo->AdapterName= NULL;
    //LocalInfo->DeviceName= NULL;
    LocalInfo->NetBTDeviceName= NULL;
    LocalInfo->RegistryKey= NULL;

    //
    // used portion of the local info.
    //

    LocalInfo->Socket = INVALID_SOCKET;
    LocalInfo->DefaultGatewaysSet = FALSE;

    //
    // open socket now.
    //

    Error =  InitializeDhcpSocket(
                &LocalInfo->Socket,
                htonl( AdapterIpAddress ),
                IS_APICTXT_ENABLED(DhcpContext));

    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }

    //
    // now release ip address.
    //

    Error = ReleaseIpAddress( DhcpContext );

    ClientLeaseInfo->IpAddress = 0;
    ClientLeaseInfo->SubnetMask = DhcpDefaultSubnetMask( 0 );
    ClientLeaseInfo->DhcpServerAddress = 0xFFFFFFFF;
    ClientLeaseInfo->Lease = 0;

    ClientLeaseInfo->LeaseObtained =
        ClientLeaseInfo->T1Time =
        ClientLeaseInfo->T2Time =
        ClientLeaseInfo->LeaseExpires = time( NULL );

    //
    // recd options list cannot have any elements now..!
    //
    DhcpAssert(IsListEmpty(&DhcpContext->RecdOptionsList));

  Cleanup:

    if( (LocalInfo != NULL) && (LocalInfo->Socket != INVALID_SOCKET) ) {
        closesocket( LocalInfo->Socket );
    }

    if( DhcpContext != NULL ) {
        DhcpFreeMemory( DhcpContext );
    }

    return( Error );
}

DWORD
DhcpLeaseIpAddress(
    DWORD AdapterIpAddress,
    LPDHCP_CLIENT_UID ClientUID,
    DWORD DesiredIpAddress,
    LPDHCP_OPTION_LIST OptionList,
    LPDHCP_LEASE_INFO *LeaseInfo,
    LPDHCP_OPTION_INFO *OptionInfo
    )
/*++

Routine Description:

    This api obtains an IP address lease from a dhcp server. The
    caller should specify the client uid and a desired ip address.
    The client uid must be globally unique. Set the desired ip address
    to zero if you can accept any ip address. Otherwise this api will
    try to obtain the ip address you have specified, but not guaranteed.

    The caller may optionally requtest additional option info from the
    dhcp server, The caller should specify the list in OptionList
    parameter and the api will return the available option data in
    OptionInfo structure.

    ?? Option retrival is not implemented in the first phase. This
    requires several modification in the dhcp client code.

    Please do not use this function -- this is deprecated. Use the
    Ex functions instead.

Arguments:

    AdapterIpAddress - IpAddress of the adapter. On a multi-homed
        machined this specifies the subnet from which an address is
        requested. This value can be set to zero if the machine is a
        non-multi-homed machine or you like to get ip address from any
        of the subnets. This must be network byte order..

    ClientUID - pointer to a client UID structure.

    DesiredIpAddress - the ip address you prefer.

    OptionList - list of option ids.

    LeaseInfo - pointer to a location where the lease info structure
        pointer is retured. The caller should free up this structure
        after use.

    OptionInfo - pointer to a location where the option info structure
        pointer is returned. The caller should free up this structure
        after use.

Return Value:

    Windows Error.

--*/
{

    return DhcpLeaseIpAddressEx(
        AdapterIpAddress,
        ClientUID,
        DesiredIpAddress,
        OptionList,
        LeaseInfo,
        OptionInfo,
        DEFAULT_RAS_CLASS,
        strlen(DEFAULT_RAS_CLASS)
    );
}

DWORD
DhcpRenewIpAddressLease(
    DWORD AdapterIpAddress,
    LPDHCP_LEASE_INFO ClientLeaseInfo,
    LPDHCP_OPTION_LIST OptionList,
    LPDHCP_OPTION_INFO *OptionInfo
    )
/*++

Routine Description:

    This api renews an ip address that the client already has. When a
    client gets an ip address, it can use the address until the lease
    expires. The client should stop using the ip address after that.
    Also the client should renew the address after T1 time if the client
    is planning to use the address longer than the current lease time.

Arguments:

    AdapterIpAddress - IpAddress of the adapter. On a multi-homed
        machined this specifies the subnet from which an address is
        renewed. This value can be set to zero if the machine is
        non-multi-homed machine.

    ClientLeaseInfo : pointer to the client lease info structure. On
        entry the structure should contain the information that was
        returned by the DhcpLeaseIpAddress or DhcpRenewIpAddressLease
        apis. On return this structure is updated to reflect the lease
        extension.

    OptionList - list of option ids.

    OptionInfo - pointer to a location where the option info structure
        pointer is returned. The caller should free up this structure
        after use.

Return Value:

    Windows Error.

--*/
{
    return DhcpRenewIpAddressLeaseEx(
        AdapterIpAddress,
        ClientLeaseInfo,
        OptionList,
        OptionInfo,
        DEFAULT_RAS_CLASS,
        strlen(DEFAULT_RAS_CLASS)
    );
}

DWORD
DhcpReleaseIpAddressLease(
    DWORD AdapterIpAddress,
    LPDHCP_LEASE_INFO ClientLeaseInfo
    )
/*++

Routine Description:

    This function releases an ip address the client has.

Arguments:

    AdapterIpAddress - IpAddress of the adapter. On a multi-homed
        machined this specifies the subnet to which an address is
        released. This value can be set to zero if the machine is
        non-multi-homed machine.

    ClientLeaseInfo : pointer to the client lease info structure. On
        entry the structure should contain the information that was
        returned by the DhcpLeaseIpAddress or DhcpRenewIpAddressLease
        apis.

Return Value:

    Windows Error.

--*/
{
    return DhcpReleaseIpAddressLeaseEx(
        AdapterIpAddress,
        ClientLeaseInfo,
        DEFAULT_RAS_CLASS,
        strlen(DEFAULT_RAS_CLASS)
    );
}

//================================================================================
// end of file
//================================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\client\nt\ioctl.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    ioctl.c

Abstract:

    This file contains functions to indicate to the other system
    services that the IP address and other TCP/IP parameters have
    changed.

Author:

    Madan Appiah (madana)  30-Nov-1993

Environment:

    User Mode - Win32

Revision History:

--*/


#include "precomp.h"
#include "dhcpglobal.h"
#include <dhcploc.h>
#include <dhcppro.h>
#include <dhcpcapi.h>
#include <apiappl.h>   // for DhcpReRegisterDynDns ?

#define NT          // to include data structures for NT build.

#include <nbtioctl.h>
#include <ntddip.h>
#include <ntddtcp.h>

#include <tdiinfo.h>
#include <tdistat.h>
#include <ipexport.h>
#include <tcpinfo.h>
#include <ipinfo.h>
#include <llinfo.h>

#include <lmcons.h>
#include <lmsname.h>
#include <winsvc.h>
#include <ntddbrow.h>
#include <limits.h>
#include <ndispnp.h>
#include <secobj.h>

#define DEFAULT_DEST                    0
#define DEFAULT_DEST_MASK               0
#define DEFAULT_METRIC                  1

//
// Following two functions (APIs) should be remove when MIKEMAS provides
// entry point DLL for these API.
//
// Also all TDI related include files that are checked-in in this dir.
// should be delfile'd when MIKEMAS checkin those files in private\inc.
//



NTSTATUS
TCPQueryInformationEx(
    IN HANDLE                 TCPHandle,
    IN TDIObjectID FAR       *ID,
    OUT void FAR             *Buffer,
    IN OUT DWORD FAR         *BufferSize,
    IN OUT BYTE FAR          *Context
    )
/*++

Routine Description:

    This routine provides the interface to the TDI QueryInformationEx
    facility of the TCP/IP stack on NT. Someday, this facility will be
    part of TDI.

Arguments:

    TCPHandle     - Open handle to the TCP driver
    ID            - The TDI Object ID to query
    Buffer        - Data buffer to contain the query results
    BufferSize    - Pointer to the size of the results buffer. Filled in
                    with the amount of results data on return.
    Context       - Context value for the query. Should be zeroed for a
                    new query. It will be filled with context
                    information for linked enumeration queries.

Return Value:

    An NTSTATUS value.

--*/

{
    TCP_REQUEST_QUERY_INFORMATION_EX   queryBuffer;
    DWORD                              queryBufferSize;
    NTSTATUS                           status;
    IO_STATUS_BLOCK                    ioStatusBlock;


    if (TCPHandle == NULL) {
        return(TDI_INVALID_PARAMETER);
    }

    queryBufferSize = sizeof(TCP_REQUEST_QUERY_INFORMATION_EX);
    RtlCopyMemory(
        &(queryBuffer.ID),
        ID,
        sizeof(TDIObjectID)
        );
    RtlCopyMemory(
        &(queryBuffer.Context),
        Context,
        CONTEXT_SIZE
    );

    status = NtDeviceIoControlFile(
                 TCPHandle,                       // Driver handle
                 NULL,                            // Event
                 NULL,                            // APC Routine
                 NULL,                            // APC context
                 &ioStatusBlock,                  // Status block
                 IOCTL_TCP_QUERY_INFORMATION_EX,  // Control code
                 &queryBuffer,                    // Input buffer
                 queryBufferSize,                 // Input buffer size
                 Buffer,                          // Output buffer
                 *BufferSize                      // Output buffer size
                 );

    if (status == STATUS_PENDING) {
        status = NtWaitForSingleObject(
                     TCPHandle,
                     TRUE,
                     NULL
                     );
    }

    if (status == STATUS_SUCCESS) {
        //
        // Copy the return context to the caller's context buffer
        //
        RtlCopyMemory(
            Context,
            &(queryBuffer.Context),
            CONTEXT_SIZE
            );

        *BufferSize = (ULONG)ioStatusBlock.Information;

        status = ioStatusBlock.Status;
    }
    else {
        if ( status != TDI_BUFFER_OVERFLOW) {
            DhcpPrint((DEBUG_ERRORS, "TCPQueryInformationEx returned failure %lx\n", status ));
        }
        *BufferSize = 0;
    }

    return(status);
}



NTSTATUS
TCPSetInformationEx(
    IN HANDLE             TCPHandle,
    IN TDIObjectID FAR   *ID,
    IN void FAR          *Buffer,
    IN DWORD FAR          BufferSize
    )
/*++

Routine Description:

    This routine provides the interface to the TDI SetInformationEx
    facility of the TCP/IP stack on NT. Someday, this facility will be
    part of TDI.

Arguments:

    TCPHandle     - Open handle to the TCP driver
    ID            - The TDI Object ID to set
    Buffer        - Data buffer containing the information to be set
    BufferSize    - The size of the set data buffer.

Return Value:

    An NTSTATUS value.

--*/

{
    PTCP_REQUEST_SET_INFORMATION_EX    setBuffer;
    NTSTATUS                           status;
    IO_STATUS_BLOCK                    ioStatusBlock;
    DWORD                              setBufferSize;


    if (TCPHandle == NULL) {
        return(TDI_INVALID_PARAMETER);
    }

    setBufferSize = FIELD_OFFSET(TCP_REQUEST_SET_INFORMATION_EX, Buffer) +
                    BufferSize;

    setBuffer = LocalAlloc(LMEM_FIXED, setBufferSize);

    if (setBuffer == NULL) {
        return(TDI_NO_RESOURCES);
    }

    setBuffer->BufferSize = BufferSize;

    RtlCopyMemory(
        &(setBuffer->ID),
        ID,
        sizeof(TDIObjectID)
        );

    RtlCopyMemory(
        &(setBuffer->Buffer[0]),
        Buffer,
        BufferSize
        );

    status = NtDeviceIoControlFile(
                 TCPHandle,                       // Driver handle
                 NULL,                            // Event
                 NULL,                            // APC Routine
                 NULL,                            // APC context
                 &ioStatusBlock,                  // Status block
                 IOCTL_TCP_SET_INFORMATION_EX,    // Control code
                 setBuffer,                       // Input buffer
                 setBufferSize,                   // Input buffer size
                 NULL,                            // Output buffer
                 0                                // Output buffer size
                 );

    if (status == STATUS_PENDING)
    {
        status = NtWaitForSingleObject(
                     TCPHandle,
                     TRUE,
                     NULL
                     );

        if ( STATUS_SUCCESS == status )
            status = ioStatusBlock.Status;

    } else if ( status == STATUS_SUCCESS ) {
        status = ioStatusBlock.Status;
    }

    LocalFree(setBuffer);
    return(status);
}



DWORD
OpenDriver(
    HANDLE *Handle,
    LPWSTR DriverName
    )
/*++

Routine Description:

    This function opens a specified IO drivers.

Arguments:

    Handle - pointer to location where the opened drivers handle is
        returned.

    DriverName - name of the driver to be opened.

Return Value:

    Windows Error Code.

--*/
{
    OBJECT_ATTRIBUTES   objectAttributes;
    IO_STATUS_BLOCK     ioStatusBlock;
    UNICODE_STRING      nameString;
    NTSTATUS            status;

    *Handle = NULL;

    //
    // Open a Handle to the IP driver.
    //

    RtlInitUnicodeString(&nameString, DriverName);

    InitializeObjectAttributes(
        &objectAttributes,
        &nameString,
        OBJ_CASE_INSENSITIVE,
        (HANDLE) NULL,
        (PSECURITY_DESCRIPTOR) NULL
        );

    status = NtCreateFile(
        Handle,
        SYNCHRONIZE | FILE_READ_DATA | FILE_WRITE_DATA,
        &objectAttributes,
        &ioStatusBlock,
        NULL,
        FILE_ATTRIBUTE_NORMAL,
        FILE_SHARE_READ | FILE_SHARE_WRITE,
        FILE_OPEN_IF,
        0,
        NULL,
        0
        );

    return( RtlNtStatusToDosError( status ) );
}



DWORD
IPSetIPAddress(
    DWORD IpInterfaceContext,
    DHCP_IP_ADDRESS Address,
    DHCP_IP_ADDRESS SubnetMask
    )
/*++

Routine Description:

    This rountine sets the IP Address and subnet mask of the IP stack.

Arguments:

    IpInterfaceContext - Context value of the Ip Table Entry.

    Address - New IP Address.

    SubnetMask - New subnet mask.

Return Value:

    Windows Error Code.

--*/
{
    HANDLE                    IPHandle;
    IP_SET_ADDRESS_REQUEST    requestBuffer;
    IO_STATUS_BLOCK           ioStatusBlock;
    NTSTATUS                  status;
    DWORD                     Error;


    DhcpPrint((DEBUG_TRACE, "IPSetIPAddress: settting %s address on interface context %lx\n",
            inet_ntoa(*(struct in_addr *)&Address), IpInterfaceContext ));

    Error = OpenDriver(&IPHandle, DD_IP_DEVICE_NAME);

    if (Error != ERROR_SUCCESS) {
        return( Error );
    }

    //
    // Initialize the input buffer.
    //

    requestBuffer.Context = (USHORT)IpInterfaceContext;
    requestBuffer.Address = Address;
    requestBuffer.SubnetMask = SubnetMask;

    status = NtDeviceIoControlFile(
                 IPHandle,                        // Driver handle
                 NULL,                            // Event
                 NULL,                            // APC Routine
                 NULL,                            // APC context
                 &ioStatusBlock,                  // Status block
                 IOCTL_IP_SET_ADDRESS,            // Control code
                 &requestBuffer,                  // Input buffer
                 sizeof(IP_SET_ADDRESS_REQUEST),  // Input buffer size
                 NULL,                            // Output buffer
                 0                                // Output buffer size
                 );


    if ( status == STATUS_UNSUCCESSFUL ) {        // whoa? syscall failed? should not really happen
        DhcpPrint( (DEBUG_ERRORS,
                   "IOCTL_IP_SET_ADDRESS returned immediate STATUS_UNSUCCESSFUL for %s\n",
                   inet_ntoa(*(struct in_addr *)&Address)));

    } else if ( STATUS_PENDING == status ) {      // ip is trying to do things..
       status = NtWaitForSingleObject( IPHandle, TRUE, NULL );
       status = ioStatusBlock.Status;
    } else if ( STATUS_SUCCESS == status ) {      // DeviceIoControl worked, but how does ip feel?
        status = ioStatusBlock.Status;
    }

    if ( STATUS_SUCCESS != status ) {
        DhcpPrint((DEBUG_ERRORS,
              "IOCTL_IP_SET_ADDRESS returned STATUS_UNSUCCESSFUL<0x%lx> for %s\n",
                   status, inet_ntoa(*(struct in_addr *)&Address)));
    }

    NtClose( IPHandle );

    if( 0 == Address && STATUS_DUPLICATE_NAME == status ) {
        // I think this is what happens when you try to set zero if it is already zero!!!
        DhcpPrint((DEBUG_ERRORS, "Trying to set zero address: ADDRESS_CONFLICT??? Ignored\n"));
        status = STATUS_SUCCESS;
    }

    if( IP_MEDIA_DISCONNECT == status ) {
        //
        // You get this if the media is disconnected... We just ignore this for now.
        //
        DhcpPrint((DEBUG_ERRORS, "Trying to set address while media disconnected..\n"));
        status = STATUS_SUCCESS;
    }

    return( RtlNtStatusToDosError( status ) );
}

DWORD
IPDelIPAddress(
    DWORD IpInterfaceContext
    )
/*++

Routine Description:

    This rountine deletes a static IP address for the supplied IpInterfaceContext

Arguments:

    IpInterfaceContext - Context value of the Ip Table Entry.

Return Value:

    Windows Error Code.

--*/
{
    HANDLE                    IPHandle;
    IP_DELETE_NTE_REQUEST       requestBuffer;
    IO_STATUS_BLOCK           ioStatusBlock;
    NTSTATUS                  status;
    DWORD                     Error;

    DhcpPrint((DEBUG_MISC, "IPDelIPAddress: deleting address with ipcontext %x \n", IpInterfaceContext));
    Error = OpenDriver(&IPHandle, DD_IP_DEVICE_NAME);

    if (Error != ERROR_SUCCESS) {
        return( Error );
    }


    requestBuffer.Context = (USHORT)IpInterfaceContext;

    status = NtDeviceIoControlFile(
                 IPHandle,                         // Driver handle
                 NULL,                             // Event
                 NULL,                             // APC Routine
                 NULL,                             // APC context
                 &ioStatusBlock,                   // Status block
                 IOCTL_IP_DELETE_NTE,                 // Control code
                 &requestBuffer,                    // Input buffer
                 sizeof(requestBuffer),                // Input buffer size
                 NULL,                   // Output buffer
                 0            // Output buffer size
                 );


    if ( status == STATUS_UNSUCCESSFUL )
    {
        DhcpPrint( (DEBUG_ERRORS,
                   "IOCTL_IP_DELETE_NTE returned immediate STATUS_UNSUCCESSFUL for context %lx\n",
                   IpInterfaceContext));
    }
    else if ( STATUS_PENDING == status )
    {
       status = NtWaitForSingleObject( IPHandle, TRUE, NULL );
       status = ioStatusBlock.Status;

       if ( STATUS_UNSUCCESSFUL == status ){
           DhcpPrint( (DEBUG_ERRORS,
                      "IOCTL_IP_DELETE_NTE returned STATUS_UNSUCCESSFUL for context %lx\n",
                      IpInterfaceContext));
       }

    } else if ( STATUS_SUCCESS == status ) {
        status = ioStatusBlock.Status;
    }


    NtClose( IPHandle );
    return( RtlNtStatusToDosError( status ) );
}

DWORD
IPDelNonPrimaryAddresses(
    LPWSTR AdapterName
    )
/*++

Routine Description:

    This rountine deletes all the static ip addresses but
    the primary one.

Arguments:

    AdapterName  - The adaptername that identifies the ip interface

Return Value:

    Windows Error Code.

--*/
{
    DWORD   Error;
    LPWSTR  RegKey = NULL;
    HKEY    KeyHandle = NULL;
    LPWSTR  nteContextList = NULL;
    PCHAR   oemNextContext = NULL;
    LPWSTR   nextContext;
    DWORD   i;

         //
    // Open device parameter.
    //

    RegKey = DhcpAllocateMemory(
                (wcslen(DHCP_SERVICES_KEY) +
                    wcslen(REGISTRY_CONNECT_STRING) +
                    wcslen(AdapterName) +
                    wcslen(DHCP_ADAPTER_PARAMETERS_KEY) + 1) *
                            sizeof(WCHAR) ); // termination char.

    if( RegKey == NULL ) {
        Error = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    wcscpy( RegKey, DHCP_SERVICES_KEY );
    wcscat( RegKey, DHCP_ADAPTER_PARAMETERS_KEY );
    wcscat( RegKey, REGISTRY_CONNECT_STRING );
    wcscat( RegKey, AdapterName );


    //
    // open this key.
    //

    Error = RegOpenKeyEx(
                HKEY_LOCAL_MACHINE,
                RegKey,
                0, // Reserved field
                DHCP_CLIENT_KEY_ACCESS,
                &KeyHandle
                );

    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }

    Error = GetRegistryString(
                    KeyHandle,
                    DHCP_NTE_CONTEXT_LIST,
                    &nteContextList,
                    NULL
                    );

    if ( ERROR_SUCCESS != Error )
    {
        DhcpPrint( (DEBUG_ERRORS,
                   "GetIpInterfaceContext: Could not read nteContextList %lx\n",
                   Error));

        goto Cleanup;
    }

    // if the adapter is disabled, nteContextList contains nothing
    // more than a L'\0'. No address to be deleted in this case.
    if (*nteContextList != L'\0')
    {
        nextContext = nteContextList;
        // delete all the addresses but the first one.
        for(    nextContext += (wcslen(nextContext) + 1), i = 1;
                *nextContext != L'\0';
                i++, nextContext += (wcslen(nextContext) + 1) ) {
            ULONG ival;
            oemNextContext = DhcpUnicodeToOem(nextContext, NULL);
            if ( NULL == oemNextContext ) {
                Error = ERROR_BAD_FORMAT;
            } else {
                ival = strtoul(oemNextContext, NULL, 0);
                if ( ival == ULONG_MAX || ival == 0) {
                    Error = ERROR_BAD_FORMAT;
                } else {
                    // delete this address
                    Error = IPDelIPAddress( ival );
                }
            }

        }
    }

Cleanup:

    if( RegKey != NULL ) {
        DhcpFreeMemory( RegKey );
    }

    if( KeyHandle != NULL ) {
        RegCloseKey( KeyHandle );
    }

    if ( nteContextList != NULL ) {
        DhcpFreeMemory( nteContextList );
    }

    if ( oemNextContext != NULL ) {
        DhcpFreeMemory( oemNextContext );
    }


    return( Error );

}


DWORD
IPGetWOLCapability(
    IN ULONG IfIndex,
    OUT PULONG pRetVal
    )
{
    HANDLE IPHandle;
    ULONG RetVal;
    IO_STATUS_BLOCK ioStatusBlock;
    NTSTATUS status;
    DWORD Error;


    DhcpPrint((
        DEBUG_MISC, "IPGetWOLCapability(0x%lx) called\n", IfIndex
        ));
    Error = OpenDriver(&IPHandle, DD_IP_DEVICE_NAME);

    if (Error != ERROR_SUCCESS) {
        return( Error );
    }

    status = NtDeviceIoControlFile(
                 IPHandle,                         // Driver handle
                 NULL,                             // Event
                 NULL,                             // APC Routine
                 NULL,                             // APC context
                 &ioStatusBlock,                   // Status block
                 IOCTL_IP_GET_WOL_CAPABILITY,      // Control code
                 &IfIndex,                         // Input buffer
                 sizeof(IfIndex),                  // Input buffer size
                 pRetVal,                          // Output buffer
                 sizeof(*pRetVal)                  // Output buffer size
                 );


    if ( status == STATUS_UNSUCCESSFUL )
    {
        DhcpPrint((
            DEBUG_ERRORS,
            "IOCTL_IP_GET_WOL_CAPABILITY(0x%lx): STATUS_UNSUCCESSFUL\n", IfIndex
            ));
    }
    else if ( STATUS_PENDING == status )
    {
       status = NtWaitForSingleObject( IPHandle, TRUE, NULL );
       status = ioStatusBlock.Status;

       if ( STATUS_UNSUCCESSFUL == status )
          DhcpPrint((
              DEBUG_ERRORS,
              "IOCTL_IP_GET_WOL_CAPABILITY(0x%lx): failed\n", IfIndex
              ));
    } else if( STATUS_SUCCESS == status ) {
        status = ioStatusBlock.Status;
    }

    NtClose( IPHandle );
    return( RtlNtStatusToDosError( status ) );
}

DWORD
IPAddIPAddress(
    LPWSTR AdapterName,
    DHCP_IP_ADDRESS Address,
    DHCP_IP_ADDRESS SubnetMask
    )
/*++

Routine Description:

    This rountine adds an static ipaddress to the IP interface for
    the given adaptername.

Arguments:

    AdapterName  - The adaptername that identifies the ip interface

    Address     -  IPaddress to be added

    SubnetMask  -  SubnetMask

Return Value:

    Windows Error Code.

--*/
{
    HANDLE                    IPHandle;
    PIP_ADD_NTE_REQUEST       requestBuffer;
    IP_ADD_NTE_RESPONSE       responseBuffer;
    IO_STATUS_BLOCK           ioStatusBlock;
    NTSTATUS                  status;
    DWORD                     Error;
    DWORD                     requestBufferSize;


    DhcpPrint((DEBUG_MISC, "IPAddIPAddress: adding an address on adapter %ws\n", AdapterName));
    Error = OpenDriver(&IPHandle, DD_IP_DEVICE_NAME);

    if (Error != ERROR_SUCCESS) {
        return( Error );
    }

    //
    // The adapter name that we pass to TCPIP should be of form
    // \device\TCPIP_<adaptername>
    //


    //
    // Initialize the input buffer.
    //
    requestBufferSize =  FIELD_OFFSET(IP_ADD_NTE_REQUEST, InterfaceNameBuffer) +
                        (wcslen(DHCP_TCPIP_DEVICE_STRING) // \Device
                         + wcslen(AdapterName)) * sizeof(WCHAR);

    requestBuffer = DhcpAllocateMemory( requestBufferSize + sizeof(WCHAR));
    if (requestBuffer == NULL) {
        NtClose(IPHandle);
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    wcscpy((PWCHAR)requestBuffer->InterfaceNameBuffer, DHCP_TCPIP_DEVICE_STRING);
    wcscat((PWCHAR)requestBuffer->InterfaceNameBuffer, AdapterName);
    RtlInitUnicodeString(&requestBuffer->InterfaceName, (PWCHAR)requestBuffer->InterfaceNameBuffer);
    RtlUpcaseUnicodeString( &requestBuffer->InterfaceName, &requestBuffer->InterfaceName, FALSE );

    requestBuffer->InterfaceContext = INVALID_INTERFACE_CONTEXT;
    requestBuffer->Address = Address;
    requestBuffer->SubnetMask = SubnetMask;

    status = NtDeviceIoControlFile(
                 IPHandle,                         // Driver handle
                 NULL,                             // Event
                 NULL,                             // APC Routine
                 NULL,                             // APC context
                 &ioStatusBlock,                   // Status block
                 IOCTL_IP_ADD_NTE,                 // Control code
                 requestBuffer,                    // Input buffer
                 requestBufferSize,                // Input buffer size
                 &responseBuffer,                   // Output buffer
                 sizeof(responseBuffer)            // Output buffer size
                 );


    if ( status == STATUS_UNSUCCESSFUL )
    {
        DhcpPrint( (DEBUG_ERRORS,
                   "IOCTL_IP_ADD_NTE returned immediate STATUS_UNSUCCESSFUL for %s\n",
                   inet_ntoa(*(struct in_addr *)&Address)));
    }
    else if ( STATUS_PENDING == status )
    {
        status = NtWaitForSingleObject( IPHandle, TRUE, NULL );
        status = ioStatusBlock.Status;
    } else if (STATUS_SUCCESS == status ) {
        status = ioStatusBlock.Status;
    }

    DhcpPrint( (DEBUG_ERRORS,
              "IOCTL_IP_ADD_NTE returned 0x%lx for %s\n",
              status, inet_ntoa(*(struct in_addr *)&Address)));
    NtClose( IPHandle );
    DhcpFreeMemory(requestBuffer);
    return( RtlNtStatusToDosError( status ) );
}


DWORD
IPSetInterface(
    DWORD IpInterfaceContext
    )
/*++

Routine Description:

    This rountine sets the IP interface for sending DHCP broadcasts.

Arguments:

    IpInterfaceContext - Context value of the Ip Table Entry.

Return Value:

    Windows Error Code.

--*/
{
    HANDLE                    IPHandle;
    IO_STATUS_BLOCK           ioStatusBlock;
    NTSTATUS                  status;
    DWORD                     Error;

    Error = OpenDriver(&IPHandle, DD_IP_DEVICE_NAME);

    if (Error != ERROR_SUCCESS) {
        return( Error );
    }

    status = NtDeviceIoControlFile(
                 IPHandle,                         // Driver handle
                 NULL,                             // Event
                 NULL,                             // APC Routine
                 NULL,                             // APC context
                 &ioStatusBlock,                   // Status block
                 IOCTL_IP_SET_DHCP_INTERFACE,      // Control code
                 &IpInterfaceContext,              // Input buffer
                 sizeof(IpInterfaceContext),       // Input buffer size
                 NULL,                             // Output buffer
                 0                                 // Output buffer size
                 );

    if (status == STATUS_PENDING)
    {
        status = NtWaitForSingleObject(
                     IPHandle,
                     TRUE,
                     NULL
                     );

        if ( STATUS_SUCCESS == status )
            status = ioStatusBlock.Status;

    } else if ( STATUS_SUCCESS == status ) {
        status = ioStatusBlock.Status;
    }

    NtClose(IPHandle);
    return( RtlNtStatusToDosError( status ) );
}



DWORD
IPResetInterface(
    DWORD    dwIpInterfaceContext
    )
/*++

Routine Description:

    This rountine resets the IP interface to restore normal IP
    interface behaviour.

Arguments:

    VOID

Return Value:

    Windows Error Code.

--*/
{
    DWORD  Error;

    LOCK_INTERFACE();
    Error = IPSetInterface(dwIpInterfaceContext);
    if( ERROR_SUCCESS == Error ) {
        Error = IPSetInterface( 0xFFFFFFFF );
    }
    UNLOCK_INTERFACE();

    return Error;
}



DWORD
IPResetIPAddress(
    DWORD           dwInterfaceContext,
    DHCP_IP_ADDRESS SubnetMask
    )
/*++

Routine Description:

    This rountine resets the IP Address of the IP to ZERO.

Arguments:

    IpInterfaceContext - Context value of the Ip Table Entry.

    SubnetMask - default subnet mask.

Return Value:

    Windows Error Code.

--*/
{
    DWORD dwResult = IPSetIPAddress( dwInterfaceContext, 0, SubnetMask);

    if ( ERROR_SUCCESS != dwResult )
        DhcpPrint( ( DEBUG_ERRORS,
                     "IPResetIPAddress failed: %x\n", dwResult ));

    return dwResult;
}



DWORD
NetBTSetIPAddress(
    LPWSTR DeviceName,
    DHCP_IP_ADDRESS IpAddress,
    DHCP_IP_ADDRESS SubnetMask
    )
/*++

Routine Description:

    This function informs the NetBT service that the IP address and
    SubnetMask parameters have changed.

Arguments:

    DeviceName : name of the device (viz. \device\Elink01) we are
        working on.

    IpAddress : New IP Address.

    SubnetMask : New SubnetMask.

Return Value:

    Windows Errors.

--*/
{
    DWORD Error;
    NTSTATUS Status;

    HANDLE NetBTDeviceHandle = NULL;
    IO_STATUS_BLOCK IoStatusBlock;
    tNEW_IP_ADDRESS RequestBlock;

    UNICODE_STRING BrowserDeviceName;
    UNICODE_STRING NetbtDeviceName;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE BrowserHandle = NULL;
    LMDR_REQUEST_PACKET RequestPacket;
#if     !defined(_PNP_POWER_)
    Error = OpenDriver( &NetBTDeviceHandle, DeviceName );

    if( Error != ERROR_SUCCESS ) {
        //
        // This can happen if NetBT is not bound to the adapter.
        // Make sure that really is the case by checking that
        // key for the adapter exists. If so, this means that
        // adapter is there but netbt isnt bound to it yet.
        //

        if ( Error == ERROR_FILE_NOT_FOUND ) {
            LPWSTR AdapterName = NULL;
            LPWSTR  RegKey = NULL;
            HKEY    KeyHandle = NULL;

            //
            // First form the adaptername (e.g Elnk31) from devicename(Device\NetBt_Elnk31
            //


            AdapterName = wcsstr( DeviceName, DHCP_NETBT_DEVICE_STRING );
            DhcpAssert( AdapterName );

            AdapterName += wcslen( DHCP_NETBT_DEVICE_STRING );


            //
            // Open device key
            //

            RegKey = DhcpAllocateMemory(
                        (wcslen(DHCP_SERVICES_KEY) +
                            wcslen(REGISTRY_CONNECT_STRING) +
                            wcslen(AdapterName) + 1) *
                                    sizeof(WCHAR) ); // termination char.

            if( RegKey == NULL ) {
                Error = ERROR_NOT_ENOUGH_MEMORY;
                goto Cleanup;
            }

            wcscpy( RegKey, DHCP_SERVICES_KEY );
            wcscat( RegKey, REGISTRY_CONNECT_STRING );
            wcscat( RegKey, AdapterName );

            //
            // open this key.
            //

            Error = RegOpenKeyEx(
                        HKEY_LOCAL_MACHINE,
                        RegKey,
                        0, // Reserved field
                        DHCP_CLIENT_KEY_ACCESS,
                        &KeyHandle
                        );

            DhcpFreeMemory( RegKey );

            if( Error != ERROR_SUCCESS ) {
                goto Cleanup;
            } else {
                //
                // The adapter key exists so return ERROR_SUCCESS
                //
                RegCloseKey( KeyHandle );
            }

        }
        goto Cleanup;
    }

    RequestBlock.IpAddress = IpAddress;
    RequestBlock.SubnetMask = SubnetMask;

    Status = NtDeviceIoControlFile(
                      NetBTDeviceHandle,       // Handle
                      NULL,                    // Event
                      NULL,                    // ApcRoutine
                      NULL,                    // ApcContext
                      &IoStatusBlock,          // IoStatusBlock
                      IOCTL_NETBT_NEW_IPADDRESS,
                                               // IoControlCode
                      &RequestBlock,           // InputBuffer
                      sizeof(RequestBlock),    // InputBufferSize
                      NULL,                    // OutputBuffer
                      0);                      // OutputBufferSize


    if (Status == STATUS_PENDING)
    {

        Status = NtWaitForSingleObject(
                    NetBTDeviceHandle,          // Handle
                    TRUE,                       // Alertable
                    NULL);                      // Timeout

        if ( STATUS_SUCCESS == Status )
            Status = IoStatusBlock.Status;
    } else if ( STATUS_SUCCESS == Status ) {
        Status = IoStatusBlock.Status;
    }

    if (!NT_SUCCESS(Status)) {
        Error = RtlNtStatusToDosError( Status );
        goto Cleanup;
    }
#endif // !_PNP_POWER_
    //
    // We also need to tell the browser that the IP address has changed.
    //

    RtlInitUnicodeString(&NetbtDeviceName, DeviceName);
    RequestPacket.Version = LMDR_REQUEST_PACKET_VERSION;
    RequestPacket.TransportName = NetbtDeviceName;

    RtlInitUnicodeString(&BrowserDeviceName, DD_BROWSER_DEVICE_NAME_U);

    InitializeObjectAttributes(
        &ObjectAttributes,
        &BrowserDeviceName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    Status = NtOpenFile(
                 &BrowserHandle,
                 SYNCHRONIZE | GENERIC_READ | GENERIC_WRITE,
                 &ObjectAttributes,
                 &IoStatusBlock,
                 FILE_SHARE_READ | FILE_SHARE_WRITE,
                 FILE_SYNCHRONOUS_IO_NONALERT
                 );

    if (NT_SUCCESS(Status)) {
        Status = IoStatusBlock.Status;
    }

    if (!NT_SUCCESS(Status)) {

        Error = RtlNtStatusToDosError( Status );

        // it is OK to have ERROR_FILE_NOT_FOUND || ERROR_PATH_NOT_FOUND

        if( Error == ERROR_FILE_NOT_FOUND || Error == ERROR_PATH_NOT_FOUND) {
            Error = ERROR_SUCCESS;
        }
        goto Cleanup;
    }

    Status = NtDeviceIoControlFile(
                 BrowserHandle,
                 NULL,
                 NULL,
                 NULL,
                 &IoStatusBlock,
                 IOCTL_LMDR_IP_ADDRESS_CHANGED,
                 &RequestPacket,
                 sizeof(RequestPacket),
                 NULL,
                 0
                 );

    if (!NT_SUCCESS(Status)) {
        Error = RtlNtStatusToDosError( Status );

        // it is OK to have ERROR_FILE_NOT_FOUND | ERROR_PATH_NOT_FOUND

        if( Error == ERROR_FILE_NOT_FOUND || ERROR_PATH_NOT_FOUND == Error ) {
            Error = ERROR_SUCCESS;
        }
        else {
            goto Cleanup;
        }
    }

    Error = ERROR_SUCCESS;

Cleanup:

    if( NetBTDeviceHandle != NULL ) {
        if( Error != ERROR_SUCCESS ) {
            DhcpPrint(( DEBUG_ERRORS,
                "NetBT IOCTL_NETBT_NEW_IPADDRESS failed on %ws, %ld.\n", DeviceName, Error ));
        }

        NtClose( NetBTDeviceHandle );
    }

    if( BrowserHandle != NULL ) {
        if( Error != ERROR_SUCCESS ) {
            DhcpPrint(( DEBUG_ERRORS,
                "Browser IOCTL_LMDR_IPADDRESS_CHANGED failed on %ws, %ld.\n", BrowserDeviceName, Error ));
        }

        NtClose( BrowserHandle );
    }

    return( Error );
}



DWORD
NetBTResetIPAddress(
    LPWSTR DeviceName,
    DHCP_IP_ADDRESS SubnetMask
    )
/*++

Routine Description:

    This rountine resets the IP Address of the NetBT to ZERO.

Arguments:

    DeviceName - adapter name.

    SubnetMask - default subnet mask.

Return Value:

    Windows Error Code.

--*/
{
    DWORD status;
    status = (DWORD) NetBTSetIPAddress(DeviceName, 0, SubnetMask);
    return status;
}


ULONG
TcpIpNotifyRouterDiscoveryOption(
    IN LPCWSTR AdapterName,
    IN BOOL fOptionPresent,
    IN DWORD OptionValue
    )
{
    ULONG Error;
    ULONG RetVal;
    WCHAR TcpipAdapter[300+sizeof(DHCP_ADAPTERS_DEVICE_STRING)];
    UNICODE_STRING UpperLayer, LowerLayer, BindString;
    IP_PNP_RECONFIG_REQUEST Request;

    Error = NO_ERROR;

    RtlZeroMemory(&Request, sizeof(Request));
    Request.version = IP_PNP_RECONFIG_VERSION;
    Request.Flags |= IP_PNP_FLAG_DHCP_PERFORM_ROUTER_DISCOVERY;
    if( fOptionPresent ) {
        Request.DhcpPerformRouterDiscovery = (BOOLEAN)OptionValue;
    }

    wcscpy(TcpipAdapter, DHCP_ADAPTERS_DEVICE_STRING);
    wcscat(TcpipAdapter, AdapterName);

    RtlInitUnicodeString(&BindString, NULL);      // no bind string
    RtlInitUnicodeString(&UpperLayer, TEXT("Tcpip"));
    RtlInitUnicodeString(&LowerLayer, TcpipAdapter);
    RetVal = NdisHandlePnPEvent(
        NDIS,                                     // uiLayer
        RECONFIGURE,                              // Operation
        &LowerLayer,
        &UpperLayer,
        &BindString,
        &Request,
        sizeof(Request)
    );
    if( 0 == RetVal) Error = GetLastError();

    if( ERROR_SUCCESS != Error) {
        DhcpPrint((DEBUG_ERRORS, "TcpipNotifyRegChanges:0x%ld\n", Error));
    }
    return Error;
}


DWORD                                             // win32 status
NetBTNotifyRegChanges(                            // Notify NetBT of some parameter changes
    IN      LPWSTR                 AdapterName    // the adapter that needs this change notification
)
{
    DWORD                          Error;
    DWORD                          RetVal;
    WCHAR                          NetBTBindAdapter[300+sizeof( DHCP_TCPIP_DEVICE_STRING )];
    UNICODE_STRING                 UpperLayer;
    UNICODE_STRING                 LowerLayer;
    UNICODE_STRING                 BindString;

    Error = ERROR_SUCCESS;
    wcscpy(NetBTBindAdapter, DHCP_TCPIP_DEVICE_STRING);
    wcscat(NetBTBindAdapter, AdapterName);        // \\Device\\Tcpip_{AdapterGuid} is what NetBT expects.

    RtlInitUnicodeString(&BindString, NULL);      // no bind string
    RtlInitUnicodeString(&UpperLayer, TEXT("NetBT"));
    RtlInitUnicodeString(&LowerLayer, NetBTBindAdapter);
    RetVal = NdisHandlePnPEvent(
        TDI,                                      // uiLayer
        RECONFIGURE,                              // Operation
        &LowerLayer,
        &UpperLayer,
        &BindString,
        NULL,
        0
    );
    if( 0 != RetVal) Error = GetLastError();

    if( ERROR_SUCCESS != Error) {
        DhcpPrint((DEBUG_ERRORS, "NetBTNotifyRegChanges:0x%ld\n", Error));
    }
    return Error;
}


NTSTATUS
FindHardwareAddr(
    HANDLE TCPHandle,
    TDIEntityID *EList,
    DWORD cEntities,
    IPAddrEntry *pIAE,
    LPBYTE HardwareAddressType,
    LPBYTE *HardwareAddress,
    LPDWORD HardwareAddressLength,
    DWORD  *pIpInterfaceInstance,
#ifdef BOOTPERF
    BOOL *pfInterfaceDown,
#endif BOOTPERF
    BOOL *pfFound
    )
/*++

Routine Description:

    This function browses the TDI entries list and finds out the
    hardware address for the specified address entry.

Arguments:

    TCPHandle - handle TCP driver.

    EList - list of TDI entries.

    cEntities - number of entries in the above list.

    pIAE - IP entry for which we need HW address.

    HardwareAddressType - hardware address type.

    HardwareAddress - pointer to location where the HW address buffer
        pointer is returned.

    HardwareAddressLength - length of the HW address returned.

    pIpInterfaceInstance - pointer to interface instance for the matching entry

    pfFound - pointer to BOOL location which is set to TRUE if we found
        the HW address otherwise set to FALSE.

Return Value:

    Windows Error Code.

--*/
{
    DWORD i;
    BYTE Context[CONTEXT_SIZE];
    TDIObjectID ID;
    NTSTATUS Status;
    DWORD Size;

    *pfFound = FALSE;

    ID.toi_entity.tei_entity   = IF_MIB;
    ID.toi_type                = INFO_TYPE_PROVIDER;

    for ( i = 0; i < cEntities; i++ ) {
        DhcpPrint((DEBUG_TCP_INFO, "FindHardwareAddress: entity %lx, type %lx, instance %lx\n",
                   i, EList[i].tei_entity, EList[i].tei_instance));

        if (EList[i].tei_entity == IF_ENTITY) {

            IFEntry IFE;
            DWORD IFType;

            //
            //  Check and make sure the interface supports MIB-2
            //

            ID.toi_entity.tei_entity   = EList[i].tei_entity;
            ID.toi_entity.tei_instance = EList[i].tei_instance;
            ID.toi_class               = INFO_CLASS_GENERIC;
            ID.toi_id                  = ENTITY_TYPE_ID;

            Size = sizeof( IFType );
            IFType = 0;
            RtlZeroMemory(Context, CONTEXT_SIZE);


            DhcpPrint((DEBUG_TCP_INFO, "FindHardwareAddress: querying IF_ENTITY %lx\n",i));

            Status = TCPQueryInformationEx(
                        TCPHandle,
                        &ID,
                        &IFType,
                        &Size,
                        Context);

            if (Status != TDI_SUCCESS) {
                goto Cleanup;;
            }


            if ( IFType != IF_MIB ) {
                DhcpPrint((DEBUG_TCP_INFO, "FindHardwareAddress: entity %lx does not support MIB\n",i));
                continue;
            }

            //
            //  We've found an interface, get its index and see if it
            //  matches the IP Address entry
            //

            ID.toi_class = INFO_CLASS_PROTOCOL;
            ID.toi_id    = IF_MIB_STATS_ID;

            Size = sizeof(IFEntry);

            RtlZeroMemory(Context, CONTEXT_SIZE);
            RtlZeroMemory(&IFE, Size);
            Status = TCPQueryInformationEx(
                        TCPHandle,
                        &ID,
                        &IFE,
                        &Size,
                        Context);

            if ( Status != TDI_SUCCESS &&
                 Status != TDI_BUFFER_OVERFLOW ) {
                goto Cleanup;
            }

            DhcpPrint(( DEBUG_TCP_INFO, "FindHardwareAddress: IFEntry %lx has if_index %lx.\n", &IFE, IFE.if_index ));

            if ( IFE.if_index == pIAE->iae_index )  {

                LPBYTE Address;
                DhcpPrint(( DEBUG_TCP_INFO, "FindHardwareAddress: IFEntry %lx has our if_index %lx\n",
                            &IFE, pIAE->iae_index ));

                //
                // Allocate Memory.
                //

                Address = DhcpAllocateMemory( IFE.if_physaddrlen );

                if( Address == NULL ) {
                    Status = STATUS_NO_MEMORY;
                    goto Cleanup;
                }

                RtlCopyMemory(
                    Address,
                    IFE.if_physaddr,
                    IFE.if_physaddrlen );

                switch( IFE.if_type ) {
                case IF_TYPE_ETHERNET_CSMACD:
                    *HardwareAddressType = HARDWARE_TYPE_10MB_EITHERNET;
                    break;

                case IF_TYPE_ISO88025_TOKENRING:
                case IF_TYPE_FDDI:
                    *HardwareAddressType = HARDWARE_TYPE_IEEE_802;
                    break;

                case IF_TYPE_OTHER:
                    *HardwareAddressType = HARDWARE_ARCNET;
                    break;

                case IF_TYPE_PPP:
                    *HardwareAddressType = HARDWARE_PPP;
                    break;

                case IF_TYPE_IEEE1394:
                    *HardwareAddressType = HARDWARE_1394;
                    break;

                default:
                    DhcpPrint(( DEBUG_ERRORS, "Invalid HW Type, %ld.\n", IFE.if_type ));
                    *HardwareAddressType = HARDWARE_ARCNET;
                    break;
                }

                *HardwareAddress        = Address;
                *HardwareAddressLength  = IFE.if_physaddrlen;
                *pIpInterfaceInstance   = ID.toi_entity.tei_instance;

                DhcpPrint( (DEBUG_MISC,
                            "tei_instance = %d\n", *pIpInterfaceInstance ));

                *pfFound = TRUE;
#ifdef BOOTPERF
                if( pfInterfaceDown ) {
                    *pfInterfaceDown = (IFE.if_adminstatus != IF_STATUS_UP);
                }
#endif BOOTPERF
                Status =  TDI_SUCCESS;
                goto Cleanup;
            }
        }
    }

    //
    // we couldn't find a corresponding entry. But it may be available
    // in another tanel.
    //

    Status =  STATUS_SUCCESS;

Cleanup:

    if (Status != TDI_SUCCESS) {
        DhcpPrint(( DEBUG_ERRORS, "FindHardwareAddr failed, %lx.\n", Status ));
    }

    return TDI_SUCCESS;
}

#ifdef BOOTPERF
DWORD
DhcpQueryHWInfoEx(
    DWORD   IpInterfaceContext,
    DWORD  *pIpInterfaceInstance,
    DWORD  *pOldIpAddress OPTIONAL,
    DWORD  *pOldMask OPTIONAL,
    BOOL   *pfInterfaceDown OPTIONAL,
    LPBYTE  HardwareAddressType,
    LPBYTE *HardwareAddress,
    LPDWORD HardwareAddressLength
    )
/*++

Routine Description:

    This function queries and browses through the TDI list to find out
    the specified IpTable entry and then determines the HW address that
    corresponds to this entry.

Arguments:

    IpInterfaceContext - Context value of the Ip Table Entry.

    pIpInterfaceInstance - pointer to the interface instance ID that corresponds
                           to matching IpTable entry

    pOldIpAddress - the old IP address that used to exist.

    pOldMask - the old IP mask for this entry.

    pfInterfaceDown -- location of BOOL that tells if the interface is DOWN or UP

    HardwareAddressType - hardware address type.

    HardwareAddress - pointer to location where the HW address buffer
        pointer is returned.

    HardwareAddressLength - length of the HW address returned.

Return Value:

    Windows Error Code.

--*/
{
    DWORD Error;
    NTSTATUS Status;
    DWORD i, j;

    BYTE Context[CONTEXT_SIZE];
    TDIEntityID *EList = NULL;
    TDIObjectID ID;
    DWORD Size;
    DWORD NumReturned;
    BOOL fFound;

    IPAddrEntry * pIAE = NULL;
    IPAddrEntry *pIAEMatch = NULL;
    HANDLE TCPHandle = NULL;

    DhcpPrint((DEBUG_TCP_INFO, "DhcpQueryHWInfo: querying for interface context %lx\n", IpInterfaceContext));

    Error = OpenDriver(&TCPHandle, DD_TCP_DEVICE_NAME);
    if (Error != ERROR_SUCCESS) {
        return( Error );
    }

    //
    //  The first thing to do is get the list of available entities, and make
    //  sure that there are some interface entities present.
    //

    ID.toi_entity.tei_entity   = GENERIC_ENTITY;
    ID.toi_entity.tei_instance = 0;
    ID.toi_class               = INFO_CLASS_GENERIC;
    ID.toi_type                = INFO_TYPE_PROVIDER;
    ID.toi_id                  = ENTITY_LIST_ID;

    Size = sizeof(TDIEntityID) * MAX_TDI_ENTITIES;
    EList = (TDIEntityID*)DhcpAllocateMemory(Size);
    if (EList == NULL) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }
    RtlZeroMemory(EList, Size);
    RtlZeroMemory(Context, CONTEXT_SIZE);

    Status = TCPQueryInformationEx(TCPHandle, &ID, EList, &Size, Context);

    if (Status != TDI_SUCCESS) {
        goto Cleanup;
    }

    NumReturned  = Size/sizeof(TDIEntityID);

    DhcpPrint((DEBUG_TCP_INFO, "DhcpQueryHWInfo: No of total entities %lx\n", NumReturned));

    for (i = 0; i < NumReturned; i++) {

        DhcpPrint((DEBUG_TCP_INFO, "DhcpQueryHWInfo: entity %lx, type %lx, instance %lx\n",
                   i, EList[i].tei_entity, EList[i].tei_instance));

        if ( EList[i].tei_entity == CL_NL_ENTITY ) {

            IPSNMPInfo    IPStats;
            DWORD         NLType;

            //
            //  Does this entity support IP?
            //

            ID.toi_entity.tei_entity   = EList[i].tei_entity;
            ID.toi_entity.tei_instance = EList[i].tei_instance;
            ID.toi_class               = INFO_CLASS_GENERIC;
            ID.toi_type                = INFO_TYPE_PROVIDER;
            ID.toi_id                  = ENTITY_TYPE_ID;

            Size = sizeof( NLType );
            NLType = 0;
            RtlZeroMemory(Context, CONTEXT_SIZE);

            DhcpPrint((DEBUG_TCP_INFO, "DhcpQueryHWInfo: querying CL_NL_ENTITY %lx\n",i));
            Status = TCPQueryInformationEx(TCPHandle, &ID, &NLType, &Size, Context);

            if (Status != TDI_SUCCESS) {
                goto Cleanup;
            }

            if ( NLType != CL_NL_IP ) {
                DhcpPrint((DEBUG_TCP_INFO, "DhcpQueryHWInfo: entity %lx does not support IP\n",i));
                continue;
            }

            //
            //  We've got an IP driver so get it's address table
            //

            ID.toi_class  = INFO_CLASS_PROTOCOL;
            ID.toi_id     = IP_MIB_STATS_ID;
            Size = sizeof(IPStats);
            RtlZeroMemory( &IPStats, Size);
            RtlZeroMemory(Context, CONTEXT_SIZE);

            Status = TCPQueryInformationEx(
                        TCPHandle,
                        &ID,
                        &IPStats,
                        &Size,
                        Context);

            if (Status != TDI_SUCCESS) {
                goto Cleanup;
            }

            DhcpPrint((DEBUG_TCP_INFO, "DhcpQueryHWInfo: entity %lx, numaddr %lx\n",i, IPStats.ipsi_numaddr));

            if ( IPStats.ipsi_numaddr == 0 ) {
                continue;
            }

            Size = sizeof(IPAddrEntry) * IPStats.ipsi_numaddr;

            while (1) {
                DWORD   OldSize;
                pIAE =  DhcpAllocateMemory(Size);

                if ( pIAE == NULL  ) {
                    Status = STATUS_NO_MEMORY;
                    goto Cleanup;
                }

                ID.toi_id = IP_MIB_ADDRTABLE_ENTRY_ID;
                RtlZeroMemory(Context, CONTEXT_SIZE);

                OldSize = Size;
                Status = TCPQueryInformationEx(TCPHandle, &ID, pIAE, &Size, Context);

                if (Status == TDI_BUFFER_OVERFLOW) {
                    Size = OldSize * 2;
                    DhcpFreeMemory(pIAE);
                    pIAE = NULL;
                    continue;
                }
                if (Status != TDI_SUCCESS) {
                    goto Cleanup;
                }

                if (Status == TDI_SUCCESS) {
                    IPStats.ipsi_numaddr = Size/sizeof(IPAddrEntry);
                    DhcpAssert((Size % sizeof(IPAddrEntry)) == 0);
                    break;
                }
            }

            //
            // We have the IP address table for this IP driver.
            // Find the hardware address corresponds to the given
            // IpInterfaceContext.
            //
            // Loop through the IP table entries and findout the
            // matching entry.
            //

            pIAEMatch = NULL;
            for( j = 0; j < IPStats.ipsi_numaddr ; j++) {
                DhcpPrint(( DEBUG_TCP_INFO, "QueryHWInfo: IPAddrEntry %lx has iae_index %lx iae_context %lx\n",
                    &pIAE[j], pIAE[j].iae_index, pIAE[j].iae_context ));

                if( pIAE[j].iae_context == IpInterfaceContext ) {

                    DhcpPrint(( DEBUG_TCP_INFO, "QueryHWInfo: IPAddrEntry %lx has our interface context %lx\n",
                                &pIAE[j], IpInterfaceContext ));
                    pIAEMatch = &pIAE[j];
                    break;
                }
            }

            if( pIAEMatch == NULL ) {

                //
                // freeup the loop memory.
                //

                DhcpFreeMemory( pIAE );
                pIAE = NULL;
                continue;
            }

            //
            // NOTE : There may be more than one IpTable in the TDI
            // list. We need additional information to select the
            // IpTable we want. For now, we assume only one table
            // is supported, so pick the first and only table from the
            // list.

            //
            // If the old ip address is requested, return it.
            //
            if( pOldIpAddress ) *pOldIpAddress = pIAE->iae_addr;
            if( pOldMask ) *pOldMask = pIAE->iae_mask;

            Status = FindHardwareAddr(
                        TCPHandle,
                        EList,
                        NumReturned,
                        pIAEMatch,
                        HardwareAddressType,
                        HardwareAddress,
                        HardwareAddressLength,
                        pIpInterfaceInstance,
                        pfInterfaceDown,
                        &fFound
                        );

            if (Status != TDI_SUCCESS) {
                goto Cleanup;
            }

            if ( fFound ) {
                Status = TDI_SUCCESS;
                goto Cleanup;
            }

            //
            // freeup the loop memory.
            //

            DhcpFreeMemory( pIAE );
            pIAE = NULL;

        }  // if IP

    } // entity traversal

    Status =  STATUS_UNSUCCESSFUL;

Cleanup:

    if( pIAE != NULL ) {
        DhcpFreeMemory( pIAE );
    }

    if( TCPHandle != NULL ) {
        NtClose( TCPHandle );
    }

    if (Status != TDI_SUCCESS) {
        DhcpPrint(( DEBUG_ERRORS, "QueryHWInfo failed, %lx.\n", Status ));
    }

    if (NULL != EList) {
        DhcpFreeMemory(EList);
    }

    return( RtlNtStatusToDosError( Status ) );
}

DWORD
DhcpQueryHWInfo(
    DWORD   IpInterfaceContext,
    DWORD  *pIpInterfaceInstance,
    LPBYTE  HardwareAddressType,
    LPBYTE *HardwareAddress,
    LPDWORD HardwareAddressLength
    )
/*++

Routine Description:
    See DhcpQueryHWInfo

--*/
{
    return DhcpQueryHWInfoEx(
        IpInterfaceContext,
        pIpInterfaceInstance,
        NULL, NULL, NULL,
        HardwareAddressType,
        HardwareAddress,
        HardwareAddressLength
        );
}

#else BOOTPERF

DWORD
DhcpQueryHWInfo(
    DWORD   IpInterfaceContext,
    DWORD  *pIpInterfaceInstance,
    LPBYTE  HardwareAddressType,
    LPBYTE *HardwareAddress,
    LPDWORD HardwareAddressLength
    )
/*++

Routine Description:

    This function queries and browses through the TDI list to find out
    the specified IpTable entry and then determines the HW address that
    corresponds to this entry.

Arguments:

    IpInterfaceContext - Context value of the Ip Table Entry.

    pIpInterfaceInstance - pointer to the interface instance ID that corresponds
                           to matching IpTable entry

    HardwareAddressType - hardware address type.

    HardwareAddress - pointer to location where the HW address buffer
        pointer is returned.

    HardwareAddressLength - length of the HW address returned.

Return Value:

    Windows Error Code.

--*/
{
    DWORD Error;
    NTSTATUS Status;
    DWORD i, j;

    BYTE Context[CONTEXT_SIZE];
    TDIEntityID *EList = NULL;
    TDIObjectID ID;
    DWORD Size;
    DWORD NumReturned;
    BOOL fFound;

    IPAddrEntry * pIAE = NULL;
    IPAddrEntry *pIAEMatch = NULL;
    HANDLE TCPHandle = NULL;

    DhcpPrint((DEBUG_TCP_INFO, "DhcpQueryHWInfo: querying for interface context %lx\n", IpInterfaceContext));

    Error = OpenDriver(&TCPHandle, DD_TCP_DEVICE_NAME);
    if (Error != ERROR_SUCCESS) {
        return( Error );
    }

    //
    //  The first thing to do is get the list of available entities, and make
    //  sure that there are some interface entities present.
    //

    ID.toi_entity.tei_entity   = GENERIC_ENTITY;
    ID.toi_entity.tei_instance = 0;
    ID.toi_class               = INFO_CLASS_GENERIC;
    ID.toi_type                = INFO_TYPE_PROVIDER;
    ID.toi_id                  = ENTITY_LIST_ID;

    Size = sizeof(TDIEntityID) * MAX_TDI_ENTITIES;
    EList = (TDIEntityID*)DhcpAllocateMemory(Size);
    if (EList == NULL) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }
    RtlZeroMemory(EList, Size);
    RtlZeroMemory(Context, CONTEXT_SIZE);

    Status = TCPQueryInformationEx(TCPHandle, &ID, EList, &Size, Context);

    if (Status != TDI_SUCCESS) {
        goto Cleanup;
    }

    NumReturned  = Size/sizeof(TDIEntityID);

    DhcpPrint((DEBUG_TCP_INFO, "DhcpQueryHWInfo: No of total entities %lx\n", NumReturned));

    for (i = 0; i < NumReturned; i++) {

        DhcpPrint((DEBUG_TCP_INFO, "DhcpQueryHWInfo: entity %lx, type %lx, instance %lx\n",
                   i, EList[i].tei_entity, EList[i].tei_instance));

        if ( EList[i].tei_entity == CL_NL_ENTITY ) {

            IPSNMPInfo    IPStats;
            DWORD         NLType;

            //
            //  Does this entity support IP?
            //

            ID.toi_entity.tei_entity   = EList[i].tei_entity;
            ID.toi_entity.tei_instance = EList[i].tei_instance;
            ID.toi_class               = INFO_CLASS_GENERIC;
            ID.toi_type                = INFO_TYPE_PROVIDER;
            ID.toi_id                  = ENTITY_TYPE_ID;

            Size = sizeof( NLType );
            NLType = 0;
            RtlZeroMemory(Context, CONTEXT_SIZE);

            DhcpPrint((DEBUG_TCP_INFO, "DhcpQueryHWInfo: querying CL_NL_ENTITY %lx\n",i));
            Status = TCPQueryInformationEx(TCPHandle, &ID, &NLType, &Size, Context);

            if (Status != TDI_SUCCESS) {
                goto Cleanup;
            }

            if ( NLType != CL_NL_IP ) {
                DhcpPrint((DEBUG_TCP_INFO, "DhcpQueryHWInfo: entity %lx does not support IP\n",i));
                continue;
            }

            //
            //  We've got an IP driver so get it's address table
            //

            ID.toi_class  = INFO_CLASS_PROTOCOL;
            ID.toi_id     = IP_MIB_STATS_ID;
            Size = sizeof(IPStats);
            RtlZeroMemory( &IPStats, Size);
            RtlZeroMemory(Context, CONTEXT_SIZE);

            Status = TCPQueryInformationEx(
                        TCPHandle,
                        &ID,
                        &IPStats,
                        &Size,
                        Context);

            if (Status != TDI_SUCCESS) {
                goto Cleanup;
            }

            DhcpPrint((DEBUG_TCP_INFO, "DhcpQueryHWInfo: entity %lx, numaddr %lx\n",i, IPStats.ipsi_numaddr));

            if ( IPStats.ipsi_numaddr == 0 ) {
                continue;
            }

            Size = sizeof(IPAddrEntry) * IPStats.ipsi_numaddr;

            while (1) {
                DWORD   OldSize;
                pIAE =  DhcpAllocateMemory(Size);

                if ( pIAE == NULL  ) {
                    Status = STATUS_NO_MEMORY;
                    goto Cleanup;
                }

                ID.toi_id = IP_MIB_ADDRTABLE_ENTRY_ID;
                RtlZeroMemory(Context, CONTEXT_SIZE);

                OldSize = Size;
                Status = TCPQueryInformationEx(TCPHandle, &ID, pIAE, &Size, Context);

                if (Status == TDI_BUFFER_OVERFLOW) {
                    Size = OldSize * 2;
                    DhcpFreeMemory(pIAE);
                    pIAE = NULL;
                    continue;
                }
                if (Status != TDI_SUCCESS) {
                    goto Cleanup;
                }

                if (Status == TDI_SUCCESS) {
                    IPStats.ipsi_numaddr = Size/sizeof(IPAddrEntry);
                    DhcpAssert((Size % sizeof(IPAddrEntry)) == 0);
                    break;
                }
            }

            //
            // We have the IP address table for this IP driver.
            // Find the hardware address corresponds to the given
            // IpInterfaceContext.
            //
            // Loop through the IP table entries and findout the
            // matching entry.
            //

            pIAEMatch = NULL;
            for( j = 0; j < IPStats.ipsi_numaddr ; j++) {
                DhcpPrint(( DEBUG_TCP_INFO, "QueryHWInfo: IPAddrEntry %lx has iae_index %lx iae_context %lx\n",
                    &pIAE[j], pIAE[j].iae_index, pIAE[j].iae_context ));

                if( pIAE[j].iae_context == IpInterfaceContext ) {

                    DhcpPrint(( DEBUG_TCP_INFO, "QueryHWInfo: IPAddrEntry %lx has our interface context %lx\n",
                                &pIAE[j], IpInterfaceContext ));

                    pIAEMatch = &pIAE[j];
                    break;
                }
            }

            if( pIAEMatch == NULL ) {

                //
                // freeup the loop memory.
                //

                DhcpFreeMemory( pIAE );
                pIAE = NULL;
                continue;
            }

            //
            // NOTE : There may be more than one IpTable in the TDI
            // list. We need additional information to select the
            // IpTable we want. For now, we assume only one table
            // is supported, so pick the first and only table from the
            // list.

            Status = FindHardwareAddr(
                        TCPHandle,
                        EList,
                        NumReturned,
                        pIAEMatch,
                        HardwareAddressType,
                        HardwareAddress,
                        HardwareAddressLength,
                        pIpInterfaceInstance,
                        &fFound );

            if (Status != TDI_SUCCESS) {
                goto Cleanup;
            }

            if ( fFound ) {
                Status = TDI_SUCCESS;
                goto Cleanup;
            }

            //
            // freeup the loop memory.
            //

            DhcpFreeMemory( pIAE );
            pIAE = NULL;

        }  // if IP

    } // entity traversal

    Status =  STATUS_UNSUCCESSFUL;

Cleanup:

    if( pIAE != NULL ) {
        DhcpFreeMemory( pIAE );
    }

    if( TCPHandle != NULL ) {
        NtClose( TCPHandle );
    }

    if (Status != TDI_SUCCESS) {
        DhcpPrint(( DEBUG_ERRORS, "QueryHWInfo failed, %lx.\n", Status ));
    }

    if (NULL != EList) {
        DhcpFreeMemory(EList);
    }

    return( RtlNtStatusToDosError( Status ) );
}

#endif BOOTPERF

#if   DBG
#define print(X)     DhcpPrint((DEBUG_TRACE, "%20s\t", inet_ntoa(*(struct in_addr *)&X)))
#define printx(X)    DhcpPrint((DEBUG_TRACE, "%05x\t", X))


DWORD
PrintDefaultGateways( VOID ) {
    DWORD Error;
    NTSTATUS Status;

    HANDLE TCPHandle = NULL;
    BYTE Context[CONTEXT_SIZE];
    TDIObjectID ID;
    DWORD Size;
    IPSNMPInfo IPStats;
    IPAddrEntry *AddrTable = NULL;
    DWORD NumReturned;
    DWORD Type;
    DWORD i;
    DWORD MatchIndex;
    IPRouteEntry RouteEntry;
    IPRouteEntry *RtTable;
    DHCP_IP_ADDRESS NetworkOrderGatewayAddress;

    Error = OpenDriver(&TCPHandle, DD_TCP_DEVICE_NAME);
    if (Error != ERROR_SUCCESS) {
        return( Error );
    }

    //
    // Get the NetAddr info, to find an interface index for the gateway.
    //

    ID.toi_entity.tei_entity   = CL_NL_ENTITY;
    ID.toi_entity.tei_instance = 0;
    ID.toi_class               = INFO_CLASS_PROTOCOL;
    ID.toi_type                = INFO_TYPE_PROVIDER;
    ID.toi_id                  = IP_MIB_STATS_ID;

    Size = sizeof(IPStats);
    RtlZeroMemory(&IPStats, Size);
    RtlZeroMemory(Context, CONTEXT_SIZE);

    Status = TCPQueryInformationEx(
                TCPHandle,
                &ID,
                &IPStats,
                &Size,
                Context);

    if (Status != TDI_SUCCESS) {
        goto Cleanup;
    }

    // hack: RouteTable in IP is about 32 in size... and IP seems tob
    // be writing the whole bunch always!
    if(IPStats.ipsi_numroutes <= 32)
        IPStats.ipsi_numroutes = 32;
    Size = IPStats.ipsi_numroutes * sizeof(IPRouteEntry);
    RtTable = DhcpAllocateMemory(Size);

    if (RtTable == NULL) {
        Status = STATUS_NO_MEMORY;
        goto Cleanup;
    }

    ID.toi_id = IP_MIB_RTTABLE_ENTRY_ID;
    RtlZeroMemory(Context, CONTEXT_SIZE);

    Status = TCPQueryInformationEx(
                TCPHandle,
                &ID,
                RtTable,
                &Size,
                Context);

    if (Status != TDI_SUCCESS) {
        goto Cleanup;
    }

    NumReturned = Size/sizeof(IPAddrEntry);
    DhcpPrint((DEBUG_TRACE, "IP returned %ld routes\n", NumReturned));
    //    The following is almost always true... IP returns the whole array.. valid or not!
    //    DhcpAssert( NumReturned == IPStats.ipsi_numroutes );
    if( NumReturned > IPStats.ipsi_numroutes)
        NumReturned = IPStats.ipsi_numroutes;

    //
    // We've got the address table. Loop through it. If we find an exact
    // match for the gateway, then we're adding or deleting a direct route
    // and we're done. Otherwise try to find a match on the subnet mask,
    // and remember the first one we find.
    //

    DhcpPrint((DEBUG_TRACE,"Dest   mask   nexthop   index  metric1  type  proto\n"));
    for (i = 0, MatchIndex = 0xffff; i < NumReturned; i++) {
        print(RtTable[i].ire_dest);
        print(RtTable[i].ire_mask);
        print(RtTable[i].ire_nexthop);

        printx(RtTable[i].ire_index);
        printx(RtTable[i].ire_metric1);
        printx(RtTable[i].ire_type);
        printx(RtTable[i].ire_proto);
        DhcpPrint((DEBUG_TRACE, "\n"));
    }
    DhcpPrint((DEBUG_TRACE, "--------------------------------------------------------\n"));
    Status = TDI_SUCCESS;

Cleanup:

    if( AddrTable != NULL ) {
        DhcpFreeMemory( AddrTable );
    }

    if( TCPHandle != NULL ) {
        NtClose( TCPHandle );
    }

    if( (Status != TDI_SUCCESS) &&
        (Status != STATUS_UNSUCCESSFUL) ) { // HACK.

        DhcpPrint(( DEBUG_ERRORS, "SetDefaultGateway failed, %lx.\n", Status ));
    }

    return( RtlNtStatusToDosError( Status ) );
}
#endif

DWORD
SetDefaultGateway(
    DWORD Command,
    DHCP_IP_ADDRESS GatewayAddress,
    DWORD Metric
    )
/*++

Routine Description:

    This function adds/deletes a default gateway entry from the router table.

Arguments:

    Command : Either DEFAULT_GATEWAY_ADD/DEFAULT_GATEWAY_DELETE.

    GatewayAddress : Address of the default gateway.

Return Value:

    Windows Error Code.

--*/
{
    DWORD Error;
    NTSTATUS Status;

    HANDLE TCPHandle = NULL;
    BYTE Context[CONTEXT_SIZE];
    TDIObjectID ID;
    DWORD Size;
    IPSNMPInfo IPStats;
    IPAddrEntry *AddrTable = NULL;
    DWORD NumReturned;
    DWORD Type;
    DWORD i;
    DWORD MatchIndex;
    IPRouteEntry RouteEntry;
    DHCP_IP_ADDRESS NetworkOrderGatewayAddress;

    NetworkOrderGatewayAddress = htonl( GatewayAddress );

    Error = OpenDriver(&TCPHandle, DD_TCP_DEVICE_NAME);
    if (Error != ERROR_SUCCESS) {
        return( Error );
    }

    //
    // Get the NetAddr info, to find an interface index for the gateway.
    //

    ID.toi_entity.tei_entity   = CL_NL_ENTITY;
    ID.toi_entity.tei_instance = 0;
    ID.toi_class               = INFO_CLASS_PROTOCOL;
    ID.toi_type                = INFO_TYPE_PROVIDER;
    ID.toi_id                  = IP_MIB_STATS_ID;

    Size = sizeof(IPStats);
    RtlZeroMemory(&IPStats, Size);
    RtlZeroMemory(Context, CONTEXT_SIZE);

    Status = TCPQueryInformationEx(
        TCPHandle,
        &ID,
        &IPStats,
        &Size,
        Context
        );

    if (Status != TDI_SUCCESS) {
        goto Cleanup;
    }

    Size = IPStats.ipsi_numaddr * sizeof(IPAddrEntry);
    AddrTable = DhcpAllocateMemory(Size);

    if (AddrTable == NULL) {
        Status = STATUS_NO_MEMORY;
        goto Cleanup;
    }

    ID.toi_id = IP_MIB_ADDRTABLE_ENTRY_ID;
    RtlZeroMemory(Context, CONTEXT_SIZE);

    Status = TCPQueryInformationEx(
        TCPHandle,
        &ID,
        AddrTable,
        &Size,
        Context
        );

    if (Status != TDI_SUCCESS) {
        goto Cleanup;
    }

    NumReturned = Size/sizeof(IPAddrEntry);
    DhcpAssert( NumReturned == IPStats.ipsi_numaddr );

    //
    // We've got the address table. Loop through it. If we find an exact
    // match for the gateway, then we're adding or deleting a direct route
    // and we're done. Otherwise try to find a match on the subnet mask,
    // and remember the first one we find.
    //

    Type = IRE_TYPE_INDIRECT;
    for (i = 0, MatchIndex = 0xffff; i < NumReturned; i++) {

        if( AddrTable[i].iae_addr == NetworkOrderGatewayAddress ) {

            //
            // Found an exact match.
            //

            MatchIndex = i;
            Type = IRE_TYPE_DIRECT;
            break;
        }

        //
        // The next hop is on the same subnet as this address. If
        // we haven't already found a match, remember this one.
        //

        if ( (MatchIndex == 0xffff) &&
             (AddrTable[i].iae_addr != 0) &&
             (AddrTable[i].iae_mask != 0) &&
             ((AddrTable[i].iae_addr & AddrTable[i].iae_mask) ==
                (NetworkOrderGatewayAddress  & AddrTable[i].iae_mask)) ) {

            MatchIndex = i;
        }
    }

    //
    // We've looked at all of the entries. See if we found a match.
    //

    if (MatchIndex == 0xffff) {
        //
        // Didn't find a match.
        //

        Status = STATUS_UNSUCCESSFUL;
        goto Cleanup;
    }

    //
    // We've found a match. Fill in the route entry, and call the
    // Set API.
    //

    RouteEntry.ire_dest = DEFAULT_DEST;
    RouteEntry.ire_index = AddrTable[MatchIndex].iae_index;
    RouteEntry.ire_metric1 = Metric;
    RouteEntry.ire_metric2 = (DWORD)(-1);
    RouteEntry.ire_metric3 = (DWORD)(-1);
    RouteEntry.ire_metric4 = (DWORD)(-1);
    RouteEntry.ire_nexthop = NetworkOrderGatewayAddress;
    RouteEntry.ire_type =
        (Command == DEFAULT_GATEWAY_DELETE ? IRE_TYPE_INVALID : Type);
    RouteEntry.ire_proto = IRE_PROTO_NETMGMT;
    RouteEntry.ire_age = 0;
    RouteEntry.ire_mask = DEFAULT_DEST_MASK;
    RouteEntry.ire_metric5 = (DWORD)(-1);
    RouteEntry.ire_context = 0;

    Size = sizeof(RouteEntry);

    ID.toi_id = IP_MIB_RTTABLE_ENTRY_ID;

    Status = TCPSetInformationEx(
                TCPHandle,
                &ID,
                &RouteEntry,
                Size );

    if ( Status != TDI_SUCCESS &&
         Status != TDI_BUFFER_OVERFLOW ) {
        goto Cleanup;
    }

    Status = TDI_SUCCESS;

Cleanup:

    if( AddrTable != NULL ) {
        DhcpFreeMemory( AddrTable );
    }

    if( TCPHandle != NULL ) {
        NtClose( TCPHandle );
    }

    if( (Status != TDI_SUCCESS) &&
        (Status != STATUS_UNSUCCESSFUL) ) { // HACK.

        DhcpPrint(( DEBUG_ERRORS, "SetDefaultGateway failed, %lx.\n", Status ));
    }

    return( RtlNtStatusToDosError( Status ) );
}

DWORD
GetIpInterfaceContext(
    LPWSTR AdapterName,
    DWORD IpIndex,
    LPDWORD IpInterfaceContext
    )
/*++

Routine Description:

    This function returns the IpInterfaceContext for the specified
    IpAddress and devicename.

Arguments:

    AdapterName - name of the device.

    IpIndex - index of the IpAddress for this device.

    IpInterfaceContext - pointer to a location where the
        interface context is returned.

Return Value:

    Windows Error Code.

--*/
{
    DWORD   Error;
    LPWSTR  RegKey = NULL;
    HKEY    KeyHandle = NULL;
    LPWSTR  nteContextList = NULL;
    PCHAR   oemNextContext = NULL;
    LPWSTR   nextContext;
    DWORD   i;


    *IpInterfaceContext = INVALID_INTERFACE_CONTEXT;

    //
    // Open device parameter.
    //

    RegKey = DhcpAllocateMemory(
                (wcslen(DHCP_SERVICES_KEY) +
                    wcslen(REGISTRY_CONNECT_STRING) +
                    wcslen(AdapterName) +
                    wcslen(DHCP_ADAPTER_PARAMETERS_KEY) + 1) *
                            sizeof(WCHAR) ); // termination char.

    if( RegKey == NULL ) {
        Error = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    wcscpy( RegKey, DHCP_SERVICES_KEY );
    wcscat( RegKey, DHCP_ADAPTER_PARAMETERS_KEY );
    wcscat( RegKey, REGISTRY_CONNECT_STRING );
    wcscat( RegKey, AdapterName );


    //
    // open this key.
    //

    Error = RegOpenKeyEx(
                HKEY_LOCAL_MACHINE,
                RegKey,
                0, // Reserved field
                DHCP_CLIENT_KEY_ACCESS,
                &KeyHandle
                );

    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }

    Error = GetRegistryString(
                    KeyHandle,
                    DHCP_NTE_CONTEXT_LIST,
                    &nteContextList,
                    NULL
                    );

    if( nteContextList == NULL ) {
        Error = ERROR_BAD_FORMAT;

        DhcpPrint((DEBUG_ERRORS, "NteContextList empty\n"));
        goto Cleanup;
    }

    if ( ERROR_SUCCESS != Error )
    {
        DhcpPrint( (DEBUG_ERRORS,
                   "GetIpInterfaceContext: Could not read nteContextList %lx\n",
                   Error));

        goto Cleanup;
    }

    for(    nextContext = nteContextList, i = 0;
            *nextContext != L'\0' && i < IpIndex;
            i++, nextContext += (wcslen(nextContext) + 1) );

    if ( *nextContext != L'\0' && i == IpIndex ) {
        ULONG ival;
        oemNextContext = DhcpUnicodeToOem(nextContext, NULL);
        if ( NULL == oemNextContext ) {
            Error = ERROR_BAD_FORMAT;
        } else {
            ival = strtoul(oemNextContext, NULL, 0);
            if ( ival == ULONG_MAX || ival == 0) {
                Error = ERROR_BAD_FORMAT;
            } else {
                *IpInterfaceContext = ival;
            }
        }

    }



Cleanup:

    if( RegKey != NULL ) {
        DhcpFreeMemory( RegKey );
    }

    if( KeyHandle != NULL ) {
        RegCloseKey( KeyHandle );
    }

    if ( nteContextList != NULL ) {
        DhcpFreeMemory( nteContextList );
    }

    if ( oemNextContext != NULL ) {
        DhcpFreeMemory( oemNextContext );
    }


    return( Error );
}

HANDLE
APIENTRY
DhcpOpenGlobalEvent(
    void
    )
/*++

Routine Description:

    This functions creates global event that signals the the ipaddress
    changes to other waiting processes. The security dacl is set to NULL
    that makes anyone to open and read/set this event.

Arguments:

    None.

Return Value:

    Handle value of the global event. If the handle is NULL,
    GetLastError() function will return Windows error code.

--*/
{
    DWORD Error = NO_ERROR, Status, Length;
    BOOL BoolError;
    HANDLE EventHandle = NULL;
    SECURITY_ATTRIBUTES SecurityAttributes;
    SID_IDENTIFIER_AUTHORITY Authority = SECURITY_WORLD_SID_AUTHORITY;
    PACL Acl = NULL;
    PSID WorldSid = NULL;
    PSECURITY_DESCRIPTOR SecurityDescriptor = NULL;

    //
    // If event can be opened, chose that, don't attempt create
    //

    EventHandle = OpenEvent(
        EVENT_MODIFY_STATE | SYNCHRONIZE, FALSE,
        DHCP_NEW_IPADDRESS_EVENT_NAME
        );
    if( NULL != EventHandle ) return EventHandle;

    //
    // Set DACL also.. first create basic SIDs
    //

    BoolError = AllocateAndInitializeSid(
        &Authority, 1, SECURITY_WORLD_RID,
        0, 0, 0, 0, 0, 0, 0,
        &WorldSid
        );
    if( BoolError == FALSE ) {
        return NULL;
    }

    Length = ( (ULONG)sizeof(ACL) + (ULONG)sizeof(ACCESS_ALLOWED_ACE)
               + GetLengthSid( WorldSid ) + 16 );

    Acl = DhcpAllocateMemory( Length );
    if( NULL == Acl ) {
        Error = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    BoolError = InitializeAcl( Acl, Length, ACL_REVISION2 );
    if( FALSE == BoolError ) {
        Error = GetLastError();
        goto Cleanup;
    }

    BoolError = AddAccessAllowedAce(
        Acl, ACL_REVISION2,
        EVENT_MODIFY_STATE | SYNCHRONIZE,
        WorldSid
        );

    if( FALSE == BoolError ) {
        Error = GetLastError();
        goto Cleanup;
    }

    SecurityDescriptor = DhcpAllocateMemory(
        SECURITY_DESCRIPTOR_MIN_LENGTH
        );
    if( NULL == SecurityDescriptor ) {
        Error = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    BoolError = InitializeSecurityDescriptor(
        SecurityDescriptor, SECURITY_DESCRIPTOR_REVISION
        );

    if( BoolError == FALSE ) {
        Error = GetLastError();
        goto Cleanup;
    }

    BoolError = SetSecurityDescriptorDacl(
        SecurityDescriptor, TRUE, Acl, FALSE
        );

    if( BoolError == FALSE ) {
        Error = GetLastError();
        goto Cleanup;
    }

    SecurityAttributes.nLength = sizeof( SecurityAttributes );
    SecurityAttributes.lpSecurityDescriptor = SecurityDescriptor;
    SecurityAttributes.bInheritHandle = FALSE;

    EventHandle = CreateEvent(
        &SecurityAttributes,
        // everyone all access security.
        TRUE,       // MANUAL reset.
        FALSE,      // initial state is signaled.
        DHCP_NEW_IPADDRESS_EVENT_NAME
        );

    if( NULL == EventHandle ) {
        Error = GetLastError();
    } else {
        Error = NO_ERROR;
    }

Cleanup:

    if( SecurityDescriptor ) {
        DhcpFreeMemory( SecurityDescriptor );
    }

    if( Acl ) {
        DhcpFreeMemory( Acl );
    }

    if( WorldSid ) {
        FreeSid( WorldSid );
    }

    if( NO_ERROR != Error ) {
        SetLastError( Error );
    }

    return( EventHandle );
}

BOOL
NdisWanAdapter(                                   // Is this an NdisWan adapter?
    IN PDHCP_CONTEXT DhcpContext
)
{
    return DhcpContext->HardwareAddressType == HARDWARE_PPP;
}

DWORD INLINE                                      // win32 status
DhcpEnableDynamicConfigEx(                        // convert from static to dhcp and start DHCP client if reqd
    IN      LPWSTR                 AdapterName
)
{
    DWORD   Error;

    // ask the dhcp client to takeup this adapter also
    Error = DhcpEnableDynamicConfig(AdapterName);

    // now there are a couple possibilities:
    // - the above call succeeded
    // - DHCP service is not started or just got terminated
    // - DHCP service failed to process the request with some error
    // in the first case just go on straight to exit and return success
    // in the second case we attempt to start the DHCP service if it is not already started
    // in the last case we just bail out with the specific error
    if( Error == ERROR_FILE_NOT_FOUND || Error == ERROR_BROKEN_PIPE )
    {
        SC_HANDLE       SCHandle;
        SC_HANDLE       ServiceHandle;
        SERVICE_STATUS  svcStatus;

        // attempt now to start the DHCP service.
        // first thing to do is to open SCM
        SCHandle = OpenSCManager(
                        NULL,
                        NULL,
                        SC_MANAGER_CONNECT | SC_MANAGER_ENUMERATE_SERVICE | SC_MANAGER_QUERY_LOCK_STATUS
                   );
        if( SCHandle == NULL )
            return GetLastError();  // shouldn't happen normally

        // attempt to open the DHCP service
        ServiceHandle = OpenService(
                            SCHandle,
                            SERVICE_DHCP,
                            SERVICE_QUERY_STATUS | SERVICE_START
                        );
        if (ServiceHandle != NULL)
        {
        
            // check the status of the service
            if (!QueryServiceStatus(ServiceHandle, &svcStatus) ||
                svcStatus.dwCurrentState != SERVICE_RUNNING)
            {
                // is it worthy to attempt to start the service if QueryServiceStatus failed?
                Error = StartService(ServiceHandle, 0, NULL) ? ERROR_SUCCESS : GetLastError();
            }

            CloseServiceHandle(ServiceHandle);
        }
        else
            Error = GetLastError();

        CloseServiceHandle(SCHandle);
    }

    return Error;
}

DWORD                                             // win32 status
DhcpNotifyConfigChangeNotifications(              // notify whoever needed of param changes
    VOID
)
{
    HANDLE                         NotifyEvent;
    DWORD                          Error;
    BOOL                           BoolError;

    NotifyEvent = DhcpOpenGlobalEvent();
    if( NULL == NotifyEvent ) {
        Error = GetLastError();
        DhcpPrint((DEBUG_ERRORS, "DhcpOpenGlobalEvent:0x%lx\n", Error));
        return Error;
    }
    BoolError = PulseEvent(NotifyEvent);
    if( BoolError ) Error = ERROR_SUCCESS;
    else Error = GetLastError();
    CloseHandle(NotifyEvent);

    if( ERROR_SUCCESS != Error ) {
        DhcpPrint((DEBUG_ERRORS, "PulseEvent(NotifyEvent): 0x%lx\n", Error));
    }
    return Error;
}

DWORD                                             // win32 status
APIENTRY
DhcpNotifyConfigChangeEx(                         // handle address changes, param changes etc.
    IN      LPWSTR                 ServerName,    // name of server where this will be executed
    IN      LPWSTR                 AdapterName,   // which adapter is going to be reconfigured?
    IN      BOOL                   IsNewIpAddress,// is address new/ or address is same?
    IN      DWORD                  IpIndex,       // index of addr for this adapter -- 0 ==> first interface...
    IN      DWORD                  IpAddress,     // the ip address that is being set
    IN      DWORD                  SubnetMask,    // corresponding subnet mask
    IN      SERVICE_ENABLE         DhcpServiceEnabled,
    IN      ULONG                  Flags
)
{
    DWORD                          Error;
    DWORD                          IpInterfaceContext;
    DWORD                          DefaultSubnetMask;

    DhcpPrint(( DEBUG_MISC, "DhcpNotifyConfigChange: Adapter %ws, IsNewIp %s, IpAddr %lx, IpIndex %x, ServiceFlag %d\n",
                    AdapterName, IsNewIpAddress ? "TRUE" : "FALSE", IpAddress, IpIndex, DhcpServiceEnabled ));

    // param checks
    if( NULL == AdapterName ) return ERROR_INVALID_PARAMETER;

    if( DhcpEnable == DhcpServiceEnabled ) {      // converting from static to dhcp enabled address
        if( FALSE != IsNewIpAddress ) return ERROR_INVALID_PARAMETER;
        if( 0 != IpIndex ) return ERROR_INVALID_PARAMETER;
        if( IpAddress  || SubnetMask ) return ERROR_INVALID_PARAMETER;
    } else if( DhcpDisable == DhcpServiceEnabled){// converting from dhcp to static address
        if( TRUE != IsNewIpAddress ) return ERROR_INVALID_PARAMETER;
        if( 0 != IpIndex ) return ERROR_INVALID_PARAMETER;
        if( 0 == IpAddress || 0 == SubnetMask ) return ERROR_INVALID_PARAMETER;
    } else {
        if( IgnoreFlag != DhcpServiceEnabled ) return ERROR_INVALID_PARAMETER;
        // if( TRUE != IsNewIpAddress ) return ERROR_INVALID_PARAMETER;
        if( 0xFFFF == IpIndex ) {
            if( 0 == SubnetMask || 0 == IpAddress ) return ERROR_INVALID_PARAMETER;
        }
    }

    if( IgnoreFlag == DhcpServiceEnabled && FALSE == IsNewIpAddress ) {
        ULONG LocalError;

        // just some parameters changed -- currently, this could only be DNS domain name or server list change
        // or may be static gateway list change or static route change
        Error = DhcpStaticRefreshParams(AdapterName);
        if( ERROR_SUCCESS != Error ) {
            DhcpPrint((DEBUG_ERRORS, "DhcpNotifyConfigChange:DhcpStaticRefreshParams:0x%lx\n", Error));
        }

        LocalError = NetBTNotifyRegChanges(AdapterName);
        if( ERROR_SUCCESS != LocalError ) {
            DhcpPrint((
                DEBUG_ERRORS, "NetbtNotify(%ws): 0x%lx\n",
                AdapterName, LocalError
                ));
        }

        return Error;
    }

    if( DhcpEnable == DhcpServiceEnabled ) {      // convert from static to dhcp

        Error = IPDelNonPrimaryAddresses(         // remove all but the first static address
            AdapterName
        );
        if( ERROR_SUCCESS != Error ) return Error;

        Error = DhcpEnableDynamicConfigEx(        // convert this to dhcp, maybe starting dhcp in the process
            AdapterName
        );

        return Error;                             // notifications already done by service when we dhcp enable it..
    } else if( DhcpDisable == DhcpServiceEnabled ) {

        Error = DhcpDisableDynamicConfig( AdapterName );
        if( Error != ERROR_SUCCESS ) return Error;
    }

    // NetBt device name stuff removed, see any version pre- Oct 10, 1997
    DhcpAssert(TRUE == IsNewIpAddress);           // ip address changed in some way
    DhcpAssert(DhcpEnable != DhcpServiceEnabled); // static->dhcp already handled before

    DefaultSubnetMask = DhcpDefaultSubnetMask(0);

    if( INVALID_INTERFACE_CONTEXT == IpIndex ) {  // adding a new ip address
        DhcpAssert( IpAddress && SubnetMask);     // cannot be zero, these

        Error = IPAddIPAddress(                   // add the reqd ip address
            AdapterName,
            IpAddress,
            SubnetMask
        );
        if( ERROR_SUCCESS != Error ) return Error;

    } else {                                      // either delete or modify -- first find ipinterfacecontext
        Error = GetIpInterfaceContext(            // get the interface context value for this
            AdapterName,
            IpIndex,
            &IpInterfaceContext
        );

        if( ERROR_SUCCESS != Error ) {
            DhcpPrint((DEBUG_ERRORS, "GetIpInterfaceContext: 0x%lx\n", Error));
            return Error;
        }

        if( IpInterfaceContext == INVALID_INTERFACE_CONTEXT) {
            DhcpPrint((DEBUG_ERRORS, "GetIpInterfaceContext: returned ifctxt=INVALID_INTERFACE_CONTEXT\n"));
            return ERROR_INVALID_DRIVE;
        }

        if ( IpAddress != 0 ) {                   // if address is non-zero, we are changing address

            if (Flags & NOTIFY_FLG_RESET_IPADDR)
            {
                Error = IPResetIPAddress(             // first reset the interface to zero address
                    IpInterfaceContext,
                    DefaultSubnetMask
                );
                if( ERROR_SUCCESS != Error ) return Error;
            }

            Error = IPSetIPAddress(               // then set the required address
                IpInterfaceContext,
                IpAddress,
                SubnetMask
            );
            if( ERROR_SUCCESS != Error ) return Error;
            Error = SetOverRideDefaultGateway( AdapterName );
        } else {                                  // we are deleting addresses
            // we need to treat the 0th index separately from others.
            // IPDelIPAddress actually destroys the NTE from IP. But
            // we never blow away 0th index NTE. Just reset the ipaddr on it.
            if ( IpIndex == 0 ) {
                Error = IPResetIPAddress(         // just set this address to zero, dont blow interface away
                    IpInterfaceContext,DefaultSubnetMask
                );
            } else {                              // in this case, blow this interface altogether
                Error = IPDelIPAddress( IpInterfaceContext );
            }
            if( ERROR_SUCCESS != Error ) return Error;
        }

    }

    Error = DhcpNotifyConfigChangeNotifications();// notify clients, pulse the global event
    if( ERROR_SUCCESS != Error ) return Error;

    // refresh the parameters for static addresses
    Error = DhcpStaticRefreshParamsInternal(
        AdapterName, (Flags & NOTIFY_FLG_DO_DNS) ? TRUE : FALSE
        );
    if( ERROR_SUCCESS != Error ) {                // ignore this error anyways
        DhcpPrint((DEBUG_ERRORS, "DhcpStaticRefreshParams(%ws):0x%lx\n", AdapterName,Error));
    }

    return ERROR_SUCCESS;
}

//================================================================================
//    This function (API) notifies the TCP/IP configuration changes to
//    appropriate services. These changes will be in effect as soon as
//    possible.
//
//    If the IP Address is modified, the services are reset to ZERO IP
//    address (to cleanup the current IP address) and then set to new
//    address.
//
//    IpIndex - if the specified device is configured with multiple IP
//        addresses, specify index of address that is modified (0 - first
//        IpAddress, 1 - second IpAddres, so on) Pass 0xFFFF if adding an
//        additional address. The order of IP address is determined by the
//        order in the registry MULTI_SZ value "IPAddress" for the static
//        addresses. For dhcp enabled ip address, only ipindex 0 is valid.
//
//        Everytime when an address is added, removed or modified, the
//        order in the registry may change. It is caller's responsibility
//        to check the current order, and hence the index, before calling
//        this api.
//
//    DhcpServiceEnabled -
//        IgnoreFlag - indicates Ignore this flag. IgnoreFlag
//        DhcpEnable - indicates DHCP is enabled for this adapter.
//        DhcpDisable - indicates DHCP is diabled for this adapter.
//
//Invarient:
//
//    (1) DHCP enabled IPAddr and Static addr can exists only mutually exclusively.
//    (2) An interface cannot have more than 1 dhcp enabled ip address. However it
//        can have many static addresses.
//
//Usage:
//
//    Case 1: Changing from dhcp enabled ipaddress to static address(es)
//        - Firstly, change the first dhcp enabled ipaddress to static address.
//            arguments {SN, AN, TRUE, 0, I1, S1, DhcpDisable}
//        - Seconfly, add the remaining static address(es)
//            arguments (SN, AN, TRUE, 0xFFFF, I2, S2, DhcpIgnore)
//            arguments (SN, AN, TRUE, 0xFFFF, I3, S3, IgnoreFlag) and so on.
//
//    Case 2: Changing from static address(es) to dhcp enabled ipaddress
//        - Change the first static address to dhcp enabled. The api will delete
//          the remaining static address(es).
//            arguments (SN, AN, FALSE, 0, 0, 0, DhcpEnable)
//
//    Case 3: Adding, removing or changing static addresses.
//        - Adding:
//            arguments (SN, AN, TRUE, 0xFFFF, I, S, DhcpIgnore)
//        - Removing, say address # 2 i.e ipindex = 1
//            arguments (SN, AN, TRUE, 1, 0, 0, DhcpIgnore)
//        - Changing, say address # 2 i.e ipindex = 1
//            arguments (SN, AN, TRUE, 1, I, S, DhcpIgnore)
//
//================================================================================
DWORD                                             // win32 status
APIENTRY
DhcpNotifyConfigChange(                           // handle address changes, param changes etc.
    IN      LPWSTR                 ServerName,    // name of server where this will be executed
    IN      LPWSTR                 AdapterName,   // which adapter is going to be reconfigured?
    IN      BOOL                   IsNewIpAddress,// is address new/ or address is same?
    IN      DWORD                  IpIndex,       // index of addr for this adapter -- 0 ==> first interface...
    IN      DWORD                  IpAddress,     // the ip address that is being set
    IN      DWORD                  SubnetMask,    // corresponding subnet mask
    IN      SERVICE_ENABLE         DhcpServiceEnabled
)
{
     return DhcpNotifyConfigChangeEx(
         ServerName, AdapterName, IsNewIpAddress,
         IpIndex, IpAddress, SubnetMask, DhcpServiceEnabled,
         NOTIFY_FLG_DO_DNS | NOTIFY_FLG_RESET_IPADDR
         );
}



DWORD BringUpInterface( PVOID pvLocalInformation )
{
   LOCAL_CONTEXT_INFO              *pContext;
   TCP_REQUEST_SET_INFORMATION_EX  *pTcpRequest;
   TDIObjectID                     *pObjectID;
   IFEntry                         *pIFEntry;
   int                              cbTcpRequest;
   HANDLE                           hDriver = NULL;
   DWORD                            dwResult;
   NTSTATUS                         NtStatus;
   IO_STATUS_BLOCK                  IoStatusBlock;

   DhcpPrint( ( DEBUG_MISC, "Entering BringUpInterface\n" ));

   dwResult = OpenDriver( &hDriver, DD_TCP_DEVICE_NAME );
   if ( ERROR_SUCCESS != dwResult )
   {
       DhcpPrint( ( DEBUG_ERRORS,
                   "BringUpInterface: Unable to open TCP driver.\n" ) );
       return dwResult;
   }

   pContext = (LOCAL_CONTEXT_INFO *) pvLocalInformation;

   //
   // compute the input buffer size and allocate
   //


   cbTcpRequest =  sizeof( TCP_REQUEST_SET_INFORMATION_EX )
                 + sizeof( IFEntry ) -1;

   //
   // initialize the request
   //

   pTcpRequest             = DhcpAllocateMemory( cbTcpRequest );
   if ( !pTcpRequest )
   {
       NtClose( hDriver );
       DhcpPrint( ( DEBUG_ERRORS,
                    "BringUpInterface: Insufficient memory\n" ));
       return ERROR_NOT_ENOUGH_MEMORY;
   }

   pTcpRequest->BufferSize = cbTcpRequest - sizeof(TCP_REQUEST_SET_INFORMATION_EX);

   pObjectID = &pTcpRequest->ID;
   pIFEntry  = (IFEntry *) &pTcpRequest->Buffer[0];

   pObjectID->toi_entity.tei_entity   = IF_ENTITY;
   pObjectID->toi_entity.tei_instance = pContext->IpInterfaceInstance;

   pObjectID->toi_class    = INFO_CLASS_PROTOCOL;
   pObjectID->toi_type     = INFO_TYPE_PROVIDER;
   pObjectID->toi_id       = IF_MIB_STATS_ID;

   pIFEntry->if_adminstatus = IF_STATUS_UP;

   NtStatus = NtDeviceIoControlFile(
       hDriver, NULL, NULL, NULL, &IoStatusBlock,
       IOCTL_TCP_SET_INFORMATION_EX,
       pTcpRequest, cbTcpRequest,
       NULL, 0
       );

   if ( STATUS_PENDING == NtStatus )
   {
      if ( STATUS_SUCCESS == NtWaitForSingleObject( hDriver, TRUE, NULL ) )
        NtStatus = IoStatusBlock.Status;

#ifdef DBG
      if ( STATUS_SUCCESS != NtStatus )
          DhcpPrint( ( DEBUG_ERRORS,
                       "BringUpInterface: failed to bring up adapter\n" ));
#endif


   } else if ( STATUS_SUCCESS == NtStatus ) {
       NtStatus = IoStatusBlock.Status;
   }

   //
   // Clean up
   //

   if ( hDriver )
      NtClose( hDriver );

   if ( pTcpRequest )
      DhcpFreeMemory( pTcpRequest );

   DhcpPrint( ( DEBUG_MISC,
                "Leaving BringUpInterface\n" ) );

   return RtlNtStatusToDosError( NtStatus );
}

#if     defined(_PNP_POWER_)


DWORD
IPGetIPEventRequest(
    HANDLE  handle,
    HANDLE  event,
    UINT    seqNo,
    PIP_GET_IP_EVENT_RESPONSE  responseBuffer,
    DWORD   responseBufferSize,
    PIO_STATUS_BLOCK     ioStatusBlock
    )
/*++

Routine Description:

    This rountine sends the ioctl to get media sense notification from
    IP.

Arguments:

    handle - handle to tcpip driver.

    event -     the event we need to do wait on.

    seqNo - seqNo of the last event received.

    responseBuffer   - pointer to the buffer where event info will be stored.

    ioStatusBlock   - status of the operation, if not pending.

Return Value:

    NT Error Code.

--*/
{
    NTSTATUS                  status;
    DWORD                     Error;
    IP_GET_IP_EVENT_REQUEST   requestBuffer;

    requestBuffer.SequenceNo    =   seqNo;


    RtlZeroMemory( responseBuffer, sizeof(IP_GET_IP_EVENT_RESPONSE));
    responseBuffer->ContextStart = 0xFFFF;

    status = NtDeviceIoControlFile(
                 handle,                     // Driver handle
                 event,                          // Event
                 NULL,                          // APC Routine
                 NULL,                          // APC context
                 ioStatusBlock,                 // Status block
                 IOCTL_IP_GET_IP_EVENT,      // Control code
                 &requestBuffer,                 // Input buffer
                 sizeof(IP_GET_IP_EVENT_REQUEST),   // Input buffer size
                 responseBuffer,                 // Output buffer
                 responseBufferSize              // Output buffer size
                 );


    if ( status == STATUS_SUCCESS ) {
        status = ioStatusBlock->Status;
    }
    return status;
}

DWORD
IPCancelIPEventRequest(
    HANDLE  handle,
    PIO_STATUS_BLOCK     ioStatusBlock
    )
/*++

Routine Description:

    This rountine cancels the ioctl that was sent to get media sense
    notification from IP.

Arguments:

    handle -  handle to the ip driver.

Return Value:

    NT Error Code.

--*/
{
    NTSTATUS                  status;
    DWORD                     Error;

    status = NtCancelIoFile(
                 handle,                     // Driver handle
                 ioStatusBlock);                 // Status block


    DhcpPrint( (DEBUG_TRACE,"IPCancelIPEventRequest: status %lx\n",status));
    DhcpAssert( status == STATUS_SUCCESS );

    return RtlNtStatusToDosError( status );
}
#endif _PNP_POWER_

#define IPSTRING(x) (inet_ntoa(*(struct in_addr*)&(x)))


DWORD                                             // return interface index or -1
DhcpIpGetIfIndex(                                 // get the IF index for this adapter
    IN      PDHCP_CONTEXT          DhcpContext    // context of adapter to get IfIndex for
) {

    return ((PLOCAL_CONTEXT_INFO)DhcpContext->LocalInformation)->IfIndex;
}

DWORD
QueryIfIndex(
    IN ULONG IpInterfaceContext,
    IN ULONG IpInterfaceInstance
    )
{

    DWORD                          Error;
    DWORD                          Index;
    DWORD                          Size;
    DWORD                          NumReturned;
    DWORD                          i;
    BYTE                           Context[CONTEXT_SIZE];
    HANDLE                         TcpHandle;
    NTSTATUS                       Status;
    TDIObjectID                    ID;
    IFEntry                        IFE;

    Error = OpenDriver(&TcpHandle, DD_TCP_DEVICE_NAME);
    if( ERROR_SUCCESS != Error ) {
        DhcpPrint((DEBUG_ERRORS, "DhcpIpGetIfIndex:OpenDriver(DD_TCP):0x%lx\n", Error));
        return (DWORD)-1;
    }

    ID.toi_entity.tei_entity   = IF_ENTITY;
    ID.toi_entity.tei_instance = IpInterfaceInstance;
    ID.toi_class               = INFO_CLASS_PROTOCOL;
    ID.toi_type                = INFO_TYPE_PROVIDER;
    ID.toi_id                  = IF_MIB_STATS_ID;

    Size = sizeof(IFE);
    RtlZeroMemory(&IFE, sizeof(IFE));
    RtlZeroMemory(Context, CONTEXT_SIZE);

    Index = -1;

    Status = TCPQueryInformationEx(
        TcpHandle,
        &ID,
        &IFE,
        &Size,
        Context
    );
    if( TDI_SUCCESS != Status && TDI_BUFFER_OVERFLOW != Status ) {
        goto Cleanup;
    }

    Index = IFE.if_index;
    DhcpPrint((DEBUG_STACK, "IfIndex(0x%lx,0x%lx):0x%lx\n",
               IpInterfaceContext, IpInterfaceInstance, Index
               ));
  Cleanup:

    if( TcpHandle ) NtClose(TcpHandle);

    if( TDI_SUCCESS != Status ) {
        DhcpPrint((DEBUG_ERRORS, "DhcpIpGetIfIndex:TCPQueryInformationEx:%ld\n", Status));
    }

    DhcpPrint((DEBUG_TCP_INFO, "DhcpIpGetIfIndex:0x%lx\n", Index));
    return Index;
}

DWORD                                             // win32 status
DhcpSetRoute(                                     // set a route with the stack
    IN      DWORD                  Dest,          // network order destination
    IN      DWORD                  DestMask,      // network order destination mask
    IN      DWORD                  IfIndex,       // interface index to route
    IN      DWORD                  NextHop,       // next hop n/w order address
    IN      DWORD                  Metric,        // metric
    IN      BOOL                   IsLocal,       // is this a local address? (IRE_DIRECT)
    IN      BOOL                   IsDelete       // is this route being deleted?
)
{
    DWORD                          Error;
    NTSTATUS                       Status;
    HANDLE                         TcpHandle;
    IPRouteEntry                   RTE;
    TDIObjectID                    ID;

    if( 0xFFFFFFFF == IfIndex ) {                 // invalid If Index
        return ERROR_INVALID_PARAMETER;
    }

    Error = OpenDriver(&TcpHandle, DD_TCP_DEVICE_NAME);
    if( ERROR_SUCCESS != Error ) {                // should not really fail
        DhcpPrint((DEBUG_ERRORS, "OpenDriver(TCP_DEVICE):%ld\n", Error));
        return Error;
    }

    memset(&RTE, 0, sizeof(RTE));
    memset(&ID, 0, sizeof(ID));

    RTE.ire_dest               = Dest;
    RTE.ire_index              = IfIndex;
    RTE.ire_metric1            = Metric;
    RTE.ire_metric2            = (DWORD)(-1);
    RTE.ire_metric3            = (DWORD)(-1);
    RTE.ire_metric4            = (DWORD)(-1);
    RTE.ire_metric5            = (DWORD)(-1);
    RTE.ire_nexthop            = NextHop;
    RTE.ire_type               = (IsDelete?IRE_TYPE_INVALID:(IsLocal?IRE_TYPE_DIRECT:IRE_TYPE_INDIRECT));
    RTE.ire_proto              = IRE_PROTO_NETMGMT;
    RTE.ire_age                = 0;
    RTE.ire_mask               = DestMask;
    RTE.ire_context            = 0;

    ID.toi_id                  = IP_MIB_RTTABLE_ENTRY_ID;
    ID.toi_entity.tei_entity   = CL_NL_ENTITY;
    ID.toi_entity.tei_instance = 0;
    ID.toi_class               = INFO_CLASS_PROTOCOL;
    ID.toi_type                = INFO_TYPE_PROVIDER;

    DhcpPrint((DEBUG_TCP_INFO, "DhcpSetRoute:n/w Dest: %s\n", IPSTRING(Dest)));
    DhcpPrint((DEBUG_TCP_INFO, "DhcpSetRoute:n/w IfIndex:0x%lx\n", IfIndex));
    DhcpPrint((DEBUG_TCP_INFO, "DhcpSetRoute:n/w NextHop:%s\n", IPSTRING(NextHop)));
    DhcpPrint((DEBUG_TCP_INFO, "DhcpSetRoute:n/w Type:0x%lx\n", RTE.ire_type));
    DhcpPrint((DEBUG_TCP_INFO, "DhcpSetRoute:n/w DestMask:%s\n", IPSTRING(DestMask)));

    Status = TCPSetInformationEx(
        TcpHandle,
        &ID,
        &RTE,
        sizeof(RTE)
    );

    if( TDI_BUFFER_OVERFLOW == Status ) Status = TDI_SUCCESS;
    NtClose(TcpHandle);

    if( TDI_SUCCESS != Status ) {
        DhcpPrint((DEBUG_ERRORS, "DhcpSetRoute: 0x%lx\n", Status));
    }

    return RtlNtStatusToDosError(Status);
}

DWORD
GetAdapterFlag(
    HANDLE          TCPHandle,
    DHCP_IP_ADDRESS ipaddr
    )
{
    BYTE            Buffer[256];
    DWORD           AdapterFlag;
    NTSTATUS        Status;
    DWORD           Size;
    TDIObjectID     ID;
    BYTE            Context[CONTEXT_SIZE];

    /*
     * Read in adapter flag, which could be
     *      1. Point to Point
     *      2. Point to MultiPoint
     *      3. Unidirectional
     *      4. Non of the above
     */
    DhcpAssert(CONTEXT_SIZE >= sizeof(ipaddr));

    RtlCopyMemory(Context, &ipaddr, CONTEXT_SIZE);
    ID.toi_entity.tei_entity   = CL_NL_ENTITY;
    ID.toi_entity.tei_instance = 0;
    ID.toi_class               = INFO_CLASS_PROTOCOL;
    ID.toi_type                = INFO_TYPE_PROVIDER;
    ID.toi_id                  = IP_INTFC_INFO_ID;
    Size = sizeof(Buffer);
    Status = TCPQueryInformationEx(TCPHandle, &ID, Buffer, &Size, Context);
    if (Status != TDI_SUCCESS) {
        AdapterFlag = 0;
        DhcpPrint(( DEBUG_TCP_INFO, "QueryInterfaceType: IpAddress=%s Status=%lx\n",
                    inet_ntoa(*(struct in_addr*)&ipaddr), Status));
    } else {
        AdapterFlag = ((IPInterfaceInfo*)Buffer)->iii_flags;
        DhcpPrint(( DEBUG_TCP_INFO, "QueryInterfaceType: IpAddress=%s AdapterFlag=%lx\n",
                    inet_ntoa(*(struct in_addr*)&ipaddr), AdapterFlag));
    }

    return AdapterFlag;
}

BOOL
IsUnidirectionalAdapter(
    DWORD   IpInterfaceContext
    )
/*++

Routine Description:

    This function queries and browses through the TDI list to find out
    the specified IpTable entry and then determines if it is a unidirectional
    adapter.
    It almost identical to  DhcpQueryHWInfo

Arguments:

    IpInterfaceContext - Context value of the Ip Table Entry.

Return Value:

    Windows Error Code.

--*/
{
    DWORD Error;
    NTSTATUS Status;
    DWORD i, j;

    BYTE Context[CONTEXT_SIZE];
    TDIEntityID *EList = NULL;
    TDIObjectID ID;
    DWORD Size;
    DWORD NumReturned;
    BOOL fFound;

    IPAddrEntry * pIAE = NULL;
    IPAddrEntry *pIAEMatch = NULL;
    HANDLE TCPHandle = NULL;
    DWORD   AdapterFlag = 0;
    BYTE    HardwareAddressType = 0;
    LPBYTE  HardwareAddress = NULL;
    DWORD   HardwareAddressLength = 0;
    DWORD   pIpInterfaceInstance = 0;

    DhcpPrint((DEBUG_TCP_INFO, "DhcpQueryHWInfo: querying for interface context %lx\n", IpInterfaceContext));

    Error = OpenDriver(&TCPHandle, DD_TCP_DEVICE_NAME);
    if (Error != ERROR_SUCCESS) {
        return( Error );
    }

    //
    //  The first thing to do is get the list of available entities, and make
    //  sure that there are some interface entities present.
    //

    ID.toi_entity.tei_entity   = GENERIC_ENTITY;
    ID.toi_entity.tei_instance = 0;
    ID.toi_class               = INFO_CLASS_GENERIC;
    ID.toi_type                = INFO_TYPE_PROVIDER;
    ID.toi_id                  = ENTITY_LIST_ID;

    Size = sizeof(TDIEntityID) * MAX_TDI_ENTITIES;
    EList = (TDIEntityID*)DhcpAllocateMemory(Size);
    if (EList == NULL) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }
    RtlZeroMemory(EList, Size);
    RtlZeroMemory(Context, CONTEXT_SIZE);

    Status = TCPQueryInformationEx(TCPHandle, &ID, EList, &Size, Context);

    if (Status != TDI_SUCCESS) {
        goto Cleanup;
    }

    NumReturned  = Size/sizeof(TDIEntityID);

    DhcpPrint((DEBUG_TCP_INFO, "DhcpQueryHWInfo: No of total entities %lx\n", NumReturned));

    for (i = 0; i < NumReturned; i++) {

        DhcpPrint((DEBUG_TCP_INFO, "DhcpQueryHWInfo: entity %lx, type %lx, instance %lx\n",
                   i, EList[i].tei_entity, EList[i].tei_instance));

        if ( EList[i].tei_entity == CL_NL_ENTITY ) {

            IPSNMPInfo    IPStats;
            DWORD         NLType;

            //
            //  Does this entity support IP?
            //

            ID.toi_entity.tei_entity   = EList[i].tei_entity;
            ID.toi_entity.tei_instance = EList[i].tei_instance;
            ID.toi_class               = INFO_CLASS_GENERIC;
            ID.toi_type                = INFO_TYPE_PROVIDER;
            ID.toi_id                  = ENTITY_TYPE_ID;

            Size = sizeof( NLType );
            NLType = 0;
            RtlZeroMemory(Context, CONTEXT_SIZE);

            DhcpPrint((DEBUG_TCP_INFO, "DhcpQueryHWInfo: querying CL_NL_ENTITY %lx\n",i));
            Status = TCPQueryInformationEx(TCPHandle, &ID, &NLType, &Size, Context);

            if (Status != TDI_SUCCESS) {
                goto Cleanup;
            }

            if ( NLType != CL_NL_IP ) {
                DhcpPrint((DEBUG_TCP_INFO, "DhcpQueryHWInfo: entity %lx does not support IP\n",i));
                continue;
            }

            //
            //  We've got an IP driver so get it's address table
            //

            ID.toi_class  = INFO_CLASS_PROTOCOL;
            ID.toi_id     = IP_MIB_STATS_ID;
            Size = sizeof(IPStats);
            RtlZeroMemory( &IPStats, Size);
            RtlZeroMemory(Context, CONTEXT_SIZE);

            Status = TCPQueryInformationEx(
                        TCPHandle,
                        &ID,
                        &IPStats,
                        &Size,
                        Context);

            if (Status != TDI_SUCCESS) {
                goto Cleanup;
            }

            DhcpPrint((DEBUG_TCP_INFO, "DhcpQueryHWInfo: entity %lx, numaddr %lx\n",i, IPStats.ipsi_numaddr));

            if ( IPStats.ipsi_numaddr == 0 ) {
                continue;
            }

            Size = sizeof(IPAddrEntry) * IPStats.ipsi_numaddr;

            while (1) {
                DWORD   OldSize;
                pIAE =  DhcpAllocateMemory(Size);

                if ( pIAE == NULL  ) {
                    Status = STATUS_NO_MEMORY;
                    goto Cleanup;
                }

                ID.toi_id = IP_MIB_ADDRTABLE_ENTRY_ID;
                RtlZeroMemory(Context, CONTEXT_SIZE);

                OldSize = Size;
                Status = TCPQueryInformationEx(TCPHandle, &ID, pIAE, &Size, Context);

                if (Status == TDI_BUFFER_OVERFLOW) {
                    Size = OldSize * 2;
                    DhcpFreeMemory(pIAE);
                    pIAE = NULL;
                    continue;
                }
                if (Status != TDI_SUCCESS) {
                    goto Cleanup;
                }

                if (Status == TDI_SUCCESS) {
                    IPStats.ipsi_numaddr = Size/sizeof(IPAddrEntry);
                    DhcpAssert((Size % sizeof(IPAddrEntry)) == 0);
                    break;
                }
            }

            //
            // We have the IP address table for this IP driver.
            // Find the hardware address corresponds to the given
            // IpInterfaceContext.
            //
            // Loop through the IP table entries and findout the
            // matching entry.
            //

            pIAEMatch = NULL;
            for( j = 0; j < IPStats.ipsi_numaddr ; j++) {
                DhcpPrint(( DEBUG_TCP_INFO, "QueryHWInfo: IPAddrEntry %lx has iae_index %lx iae_context %lx\n",
                    &pIAE[j], pIAE[j].iae_index, pIAE[j].iae_context ));

                if( pIAE[j].iae_context == IpInterfaceContext ) {

                    DhcpPrint(( DEBUG_TCP_INFO, "QueryHWInfo: IPAddrEntry %lx has our interface context %lx\n",
                                &pIAE[j], IpInterfaceContext ));

                    pIAEMatch = &pIAE[j];
                    break;
                }
            }

            if( pIAEMatch == NULL ) {

                //
                // freeup the loop memory.
                //

                DhcpFreeMemory( pIAE );
                pIAE = NULL;
                continue;
            }

            //
            // NOTE : There may be more than one IpTable in the TDI
            // list. We need additional information to select the
            // IpTable we want. For now, we assume only one table
            // is supported, so pick the first and only table from the
            // list.

            Status = FindHardwareAddr(
                        TCPHandle,
                        EList,
                        NumReturned,
                        pIAEMatch,
                        &HardwareAddressType,
                        &HardwareAddress,
                        &HardwareAddressLength,
                        &pIpInterfaceInstance,
                        &fFound );

            if (Status != TDI_SUCCESS) {
                goto Cleanup;
            }

            if ( fFound ) {
                Status = TDI_SUCCESS;
                AdapterFlag = GetAdapterFlag(TCPHandle, pIAEMatch->iae_addr);
                goto Cleanup;
            }

            //
            // freeup the loop memory.
            //

            DhcpFreeMemory( pIAE );
            pIAE = NULL;

        }  // if IP

    } // entity traversal

    Status =  STATUS_UNSUCCESSFUL;

Cleanup:

    if( pIAE != NULL ) {
        DhcpFreeMemory( pIAE );
    }

    if( TCPHandle != NULL ) {
        NtClose( TCPHandle );
    }

    if (Status != TDI_SUCCESS) {
        DhcpPrint(( DEBUG_ERRORS, "QueryHWInfo failed, %lx.\n", Status ));
    }
    if( HardwareAddress ) DhcpFreeMemory(HardwareAddress);

    if (NULL != EList) {
        DhcpFreeMemory(EList);
    }

    return (AdapterFlag & IP_INTFC_FLAG_UNIDIRECTIONAL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\client\nt\dhcpreg.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    dhcpreg.c

Abstract:

    Stubs functions that manipulate NT registry.

Author:

    Madan Appiah (madana) 7-Dec-1993.

Environment:

    User Mode - Win32

Revision History:

--*/

#include "precomp.h"
#include "dhcpglobal.h"
#include <dhcploc.h>
#include <dhcppro.h>
#include <dhcpcapi.h>
#include <dnsapi.h>

#include <align.h>
#include <lmcons.h>
#include <ntddndis.h>

#define DEFAULT_METRIC (1)

extern ULONG
FixupDhcpClassId(
    IN      LPWSTR                 AdapterName,
    IN      BOOL                   SkipClassEnum
    );

//
// Local function prototypes
//

DWORD
DhcpRegQueryInfoKey(
    HKEY KeyHandle,
    LPDHCP_KEY_QUERY_INFO QueryInfo
    )
/*++

Routine Description:

    This function retrieves information about given key.

Arguments:

    KeyHandle - handle to a registry key whose info will be retrieved.

    QueryInfo - pointer to a info structure where the key info will be
                returned.

Return Value:

    Registry Errors.

--*/
{
    DWORD Error;

    QueryInfo->ClassSize = DHCP_CLASS_SIZE;
    Error = RegQueryInfoKey(
                KeyHandle,
                QueryInfo->Class,
                &QueryInfo->ClassSize,
                NULL,
                &QueryInfo->NumSubKeys,
                &QueryInfo->MaxSubKeyLen,
                &QueryInfo->MaxClassLen,
                &QueryInfo->NumValues,
                &QueryInfo->MaxValueNameLen,
                &QueryInfo->MaxValueLen,
                &QueryInfo->SecurityDescriptorLen,
                &QueryInfo->LastWriteTime
                );

    DhcpAssert( Error != ERROR_MORE_DATA );

    if( Error == ERROR_MORE_DATA ){
        Error = ERROR_SUCCESS;
    }

    return( Error );
}



DWORD
GetRegistryString(
    HKEY Key,
    LPWSTR ValueStringName,
    LPWSTR *String,
    LPDWORD StringSize
    )
/*++

Routine Description:

    This function retrieves the specified string value from the
    registry. It allocates local memory for the returned string.

Arguments:

    Key : registry handle to the key where the value is.

    ValueStringName : name of the value string.

    String : pointer to a location where the string pointer is returned.

    StringSize : size of the string data returned. Optional

Return Value:

    The status of the operation.

--*/
{
    DWORD Error;
    DWORD LocalValueType;
    DWORD ValueSize;
    LPWSTR LocalString;

    DhcpAssert( *String == NULL );

    //
    // Query DataType and BufferSize.
    //

    Error = RegQueryValueEx(
                Key,
                ValueStringName,
                0,
                &LocalValueType,
                NULL,
                &ValueSize );

    if( Error != ERROR_SUCCESS ) {
        return(Error);
    }

    DhcpAssert( (LocalValueType == REG_SZ) ||
                    (LocalValueType == REG_MULTI_SZ) );

    if( ValueSize == 0 ) {

         if( StringSize != NULL ) {
             *StringSize = 0;
         }

        *String = NULL;
        return( ERROR_SUCCESS );
    }

    //
    // now allocate memory for string data.
    //

    LocalString = DhcpAllocateMemory( ValueSize );

    if(LocalString == NULL) {
        return( ERROR_NOT_ENOUGH_MEMORY );
    }

    //
    // Now query the string data.
    //

    Error = RegQueryValueEx(
                Key,
                ValueStringName,
                0,
                &LocalValueType,
                (LPBYTE)(LocalString),
                &ValueSize );

    if( Error != ERROR_SUCCESS ) {
        DhcpFreeMemory(LocalString);
        return(Error);
    }

    *String = LocalString;

    if( StringSize != NULL ) {
        *StringSize = ValueSize;
    }

    return( ERROR_SUCCESS );
}

DWORD
ParseIpString(
    WCHAR           *AddressString,
    DHCP_IP_ADDRESS *IpAddress
    )
/*++

Routine Description

    This function converts an Internet standard 4-octet dotted decimal
    IP address string into a numeric IP address. Unlike inet_addr(), this
    routine does not support address strings of less than 4 octets nor does
    it support octal and hexadecimal octets.

    Lifted from tcpip\driver\ipv4\ntip.c

Arguments

    AddressString    - IP address in dotted decimal notation
    IpAddress        - Pointer to a variable to hold the resulting address

Return Value:

    ERROR_SUCCESS if the address string was converted.

--*/
{
    WCHAR *cp, *startPointer, *endPointer;
    ULONG digit, multiplier;
    int i;

    *IpAddress = 0;
    startPointer = AddressString;
    endPointer = AddressString;
    i = 3;

    while (i >= 0) {
        //
        // Collect the characters up to a '.' or the end of the string.
        //
        while ((*endPointer != L'.') && (*endPointer != L'\0')) {
            endPointer++;
        }

        if (startPointer == endPointer) {
            return ERROR_INVALID_DATA;
        }
        //
        // Convert the number.
        //

        for (cp = (endPointer - 1), multiplier = 1, digit = 0;
             cp >= startPointer;
             cp--, multiplier *= 10
             ) {

            if ((*cp < L'0') || (*cp > L'9') || (multiplier > 100)) {
                return ERROR_INVALID_DATA;
            }
            digit += (multiplier * ((ULONG) (*cp - L'0')));
        }

        if (digit > 255) {
            return ERROR_INVALID_DATA;
        }
        digit <<= ((3-i) * 8);
        (*IpAddress) |= digit;

        //
        // We are finished if we have found and converted 4 octets and have
        // no other characters left in the string.
        //
        if ((i-- == 0) &&
            ((*endPointer == L'\0') || (*endPointer == L' '))
            ) {
            return ERROR_SUCCESS;
        }
        if (*endPointer == L'\0') {
            return ERROR_INVALID_DATA;
        }
        startPointer = ++endPointer;
    }

    return ERROR_INVALID_DATA;
}

DWORD
RegGetIpAndSubnet(
    IN  DHCP_CONTEXT *dhcpContext,
    OUT PIP_SUBNET  *TcpConf,
    OUT int         *Count
    )
/*++

Routine Description

    This function read a list of <IP,SubnetMask> pairs from TCPIP registry parameters.

    Lifted from tcpip\driver\ipv4\ntip.c

Arguments

    KeyHandle       keyhandle NOT location
    TcpConf         The pointer to the array of <IP,SubnetMask>
    Count           The # of records.


Return Value:

    ERROR_SUCCESS if succeed, otherfise fail.

--*/
{
    DWORD   Error;
    WCHAR   *IpList, *SubnetList, *IpListTmp, *SubnetListTmp;
    int     i, cnt;
    PIP_SUBNET   IpSubnetArray;

    *Count        = 0;
    *TcpConf      = NULL;
    IpList        = NULL;
    SubnetList    = NULL;
    IpSubnetArray = NULL;

    Error = DhcpGetRegistryValueWithKey(
                dhcpContext->AdapterInfoKey,
                DHCP_STATIC_IP_ADDRESS_STRING,
                DHCP_STATIC_IP_ADDRESS_STRING_TYPE,
                &IpList);
    if (Error != ERROR_SUCCESS) {
        DhcpAssert(IpList == NULL);
        goto cleanup;
    }
    Error = DhcpGetRegistryValueWithKey(
                dhcpContext->AdapterInfoKey,
                DHCP_STATIC_SUBNET_MASK_STRING,
                DHCP_STATIC_SUBNET_MASK_STRING_TYPE,
                &SubnetList);
    if (Error != ERROR_SUCCESS) {
        DhcpAssert(SubnetList == NULL);
        goto cleanup;
    }
    DhcpAssert(IpList && SubnetList);

    /*
     * Count the # of valid <IP,subnet_mask>
     */
    cnt = 0;
    IpListTmp = IpList;
    SubnetListTmp = SubnetList;
    while(*IpListTmp && *SubnetListTmp) {
        DHCP_IP_ADDRESS SubnetMask;
        DHCP_IP_ADDRESS IpAddress;
        Error = ParseIpString(IpListTmp, &IpAddress);
        if (Error == ERROR_SUCCESS && IpAddress != 0xffffffff && IpAddress) {
            Error = ParseIpString(SubnetListTmp, &SubnetMask);
            if (Error == ERROR_SUCCESS) {
                cnt++;
            }
        }
        SubnetListTmp += wcslen(SubnetListTmp) + 1;
        IpListTmp += wcslen(IpListTmp) + 1;
    }
    if (cnt == 0) {
        DhcpPrint(( DEBUG_ERRORS, "No valid IP/SubnetMask pair\n"));
        Error = ERROR_BAD_FORMAT;
        goto cleanup;
    }

    IpSubnetArray = (PIP_SUBNET)DhcpAllocateMemory(cnt * sizeof(IP_SUBNET));
    if (IpSubnetArray == NULL) {
        Error = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }

    /*
     * copy the Ip and subnet mask
     */
    *Count = cnt;
    *TcpConf = IpSubnetArray;
    cnt = 0;
    IpListTmp = IpList;
    SubnetListTmp = SubnetList;
    while(*IpListTmp && *SubnetListTmp) {
        DHCP_IP_ADDRESS SubnetMask;
        DHCP_IP_ADDRESS IpAddress;
        Error = ParseIpString(IpListTmp, &IpAddress);
        if (Error == ERROR_SUCCESS && IpAddress != 0xffffffff && IpAddress) {
            Error = ParseIpString(SubnetListTmp, &SubnetMask);
            if (Error == ERROR_SUCCESS) {
                DhcpAssert(cnt < *Count);
                IpSubnetArray[cnt].IpAddress = IpAddress;
                IpSubnetArray[cnt].SubnetMask = SubnetMask;
                cnt++;
            }
        }
        SubnetListTmp += wcslen(SubnetListTmp) + 1;
        IpListTmp += wcslen(IpListTmp) + 1;
    }
    Error = ERROR_SUCCESS;

cleanup:
    if (IpList)     DhcpFreeMemory(IpList);
    if (SubnetList) DhcpFreeMemory(SubnetList);
    return Error;
}

DWORD
RegSetIpAddress(
    HKEY KeyHandle,
    LPWSTR ValueName,
    DWORD ValueType,
    DHCP_IP_ADDRESS IpAddress
    )
/*++

Routine Description:

    This function sets IpAddress Value in the registry.

Arguments:

    KeyHandle - handle to the key.

    ValueName - name of the value field.

    ValueType - Type of the value field.

    IpAddress - Ipaddress to be set.

Return Value:

    Registry Error.

--*/
{
    DWORD Error;

    LPSTR AnsiAddressString;
    WCHAR UnicodeAddressBuf[DOT_IP_ADDR_SIZE];
    LPWSTR UnicodeAddressString;

    LPWSTR MultiIpAddressString = NULL;
    LPWSTR NewMultiIpAddressString = NULL;
    DWORD MultiIpAddressStringSize;
    DWORD NewMultiIpAddressStringSize;
    DWORD FirstOldIpAddressSize;

    AnsiAddressString = inet_ntoa( *(struct in_addr *)&IpAddress );

    UnicodeAddressString = DhcpOemToUnicode(
                            AnsiAddressString,
                            UnicodeAddressBuf );

    DhcpAssert( UnicodeAddressString != NULL );

    if( ValueType == REG_SZ ) {
        Error = RegSetValueEx(
                    KeyHandle,
                    ValueName,
                    0,
                    ValueType,
                    (LPBYTE)UnicodeAddressString,
                    (wcslen(UnicodeAddressString) + 1) * sizeof(WCHAR) );

        goto Cleanup;
    }

    DhcpAssert( ValueType == REG_MULTI_SZ );

    //
    // replace the first IpAddress.
    //

    //
    // query current multi-IpAddress string.
    //

    Error = GetRegistryString(
                KeyHandle,
                ValueName,
                &MultiIpAddressString,
                &MultiIpAddressStringSize );

    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }

    //
    // allocate new address string.
    //

    DhcpAssert(MultiIpAddressString != NULL);

    FirstOldIpAddressSize =
            (wcslen(MultiIpAddressString) + 1) * sizeof(WCHAR);

    NewMultiIpAddressStringSize =
        MultiIpAddressStringSize - FirstOldIpAddressSize +
            (wcslen(UnicodeAddressString) + 1) * sizeof(WCHAR);

    NewMultiIpAddressString = DhcpAllocateMemory( NewMultiIpAddressStringSize );

    if( NewMultiIpAddressString == NULL ) {
        Error = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    //
    // make new address string first.
    //

    wcscpy( NewMultiIpAddressString, UnicodeAddressString );

    //
    // copy rest of the old addresses
    //

    RtlCopyMemory(
        (LPBYTE)NewMultiIpAddressString +
            (wcslen(UnicodeAddressString) + 1) * sizeof(WCHAR),
        (LPBYTE)MultiIpAddressString + FirstOldIpAddressSize,
        MultiIpAddressStringSize - FirstOldIpAddressSize );

    Error = RegSetValueEx(
                KeyHandle,
                ValueName,
                0,
                ValueType,
                (LPBYTE)NewMultiIpAddressString,
                NewMultiIpAddressStringSize );

Cleanup:

    if( MultiIpAddressString != NULL) {
        DhcpFreeMemory( MultiIpAddressString );
    }

    if( NewMultiIpAddressString != NULL) {
        DhcpFreeMemory( NewMultiIpAddressString );
    }

    return( Error );
}

#if DBG


DWORD
RegSetTimeField(
    HKEY KeyHandle,
    LPWSTR ValueName,
    DWORD ValueType,
    time_t Time
    )
/*++

Routine Description:

    This function sets time Value in string form in the registry.

Arguments:

    KeyHandle - handle to the key.

    ValueName - name of the value field.

    ValueType - Type of the value field.

    Time - time value to be set.

Return Value:

    Registry Error.

--*/
{
    DWORD Error;
    WCHAR UnicodeTimeBuf[TIME_STRING_LEN];
    LPWSTR UnicodeTimeString;

    UnicodeTimeString =
        DhcpOemToUnicode( ctime( &Time ), UnicodeTimeBuf ) ;

    DhcpAssert( UnicodeTimeString != NULL );
    DhcpAssert( ValueType == REG_SZ );

    Error = RegSetValueEx(
                KeyHandle,
                ValueName,
                0,
                ValueType,
                (LPBYTE)UnicodeTimeString,
                (wcslen(UnicodeTimeString) + 1) * sizeof(WCHAR) );

    return( Error );
}

#endif



DWORD                                             // status
DhcpGetRegistryValueWithKey(                      // see defn of GetRegistryValue
    IN      HKEY                   KeyHandle,     // keyhandle NOT location
    IN      LPWSTR                 ValueName,     // value to read from registry
    IN      DWORD                  ValueType,     // type of value
    OUT     LPVOID                *Data           // this will be filled in
) {
    DWORD                          Error;
    DWORD                          LocalValueType;
    DWORD                          ValueSize;
    LPWSTR                         LocalString;

    //
    // Query DataType and BufferSize.
    //

    Error = RegQueryValueEx(
        KeyHandle,
        ValueName,
        0,
        &LocalValueType,
        NULL,
        &ValueSize
    );

    if( Error != ERROR_SUCCESS ) goto Cleanup;

    if( LocalValueType != ValueType ) {
        Error = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    switch( LocalValueType ) {
    case REG_DWORD:

        DhcpAssert( ValueSize == sizeof(DWORD) );

        Error = RegQueryValueEx(
            KeyHandle,
            ValueName,
            0,
            &LocalValueType,
            (LPBYTE)Data,
            &ValueSize
        );

        if( Error != ERROR_SUCCESS ) goto Cleanup;

        DhcpAssert( LocalValueType == REG_DWORD );
        DhcpAssert( ValueSize == sizeof(DWORD) );

        break;

    case REG_SZ :
    case REG_MULTI_SZ:
        DhcpAssert(*Data == NULL);

        if( ValueSize == 0 ) {
            Error =  ERROR_SUCCESS;
            break;
        }

        //
        // now allocate memory for string data.
        //

        LocalString = DhcpAllocateMemory( ValueSize );

        if(LocalString == NULL) {
            Error = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }

        //
        // Now query the string data.
        //

        Error = RegQueryValueEx(
            KeyHandle,
            ValueName,
            0,
            &LocalValueType,
            (LPBYTE)(LocalString),
            &ValueSize
        );

        if( Error != ERROR_SUCCESS ) {
            DhcpFreeMemory(LocalString);
            goto Cleanup;
        }

        DhcpAssert( (LocalValueType == REG_SZ) ||
                    (LocalValueType == REG_MULTI_SZ) );

        *Data = (LPBYTE)LocalString;
        Error = ERROR_SUCCESS;

        break;

    default:
        Error = ERROR_INVALID_PARAMETER;
        break;
    }

Cleanup:
    return( Error );
}


DWORD
DhcpGetRegistryValue(
    LPWSTR RegKey,
    LPWSTR ValueName,
    DWORD ValueType,
    PVOID *Data
    )
/*++

Routine Description:

    This function retrieves the option information from registry.

Arguments:

    RegKey - pointer to registry location. like
                system\currentcontrolset\services\..

    ValueName - name of the value to read.

    ValueType - type of reg value, REG_DWORD, REG_SZ ..

    Data - pointer to a location where the data will be returned.
            For string data and binary data, the function allocates
            memory, the caller is responsible to free it.

Return Value:

    Registry Errors.

--*/
{
    DWORD Error;
    HKEY KeyHandle = NULL;
    DWORD LocalValueType;
    DWORD ValueSize;
    LPWSTR LocalString;

    Error = RegOpenKeyEx(
                HKEY_LOCAL_MACHINE,
                RegKey,
                0 /* Reserved */,
                DHCP_CLIENT_KEY_ACCESS,
                &KeyHandle
                );

    if( Error != ERROR_SUCCESS ) return Error;

    Error = DhcpGetRegistryValueWithKey(
        KeyHandle,
        ValueName,
        ValueType,
        Data
    );

    RegCloseKey(KeyHandle);
    return Error;
}

DWORD                                             // win32
DhcpRegRecurseDeleteSub(                          // delete the key's subkeys, recursing downwards
    IN      HKEY                   Key,
    IN      LPWSTR                 KeyName
) {
    HKEY                           SubKey;
    DWORD                          Error;
    DWORD                          Index;
    WCHAR                          NameBuf[512];
    FILETIME                       Unused;

    Error = RegOpenKeyEx(                         // open this key to get its sub keys
        Key,
        KeyName,
        0 /* Reserved */,
        KEY_ALL_ACCESS,
        &SubKey
    );
    if( ERROR_SUCCESS != Error ) return Error;


    Error = ERROR_SUCCESS;
    Index = 0;
    while( ERROR_SUCCESS == Error ) {             // scan looking for sub keys
        DWORD                      Size;

        memset(NameBuf, 0, sizeof(NameBuf)); Size = sizeof(NameBuf);
        Error = RegEnumKeyEx(
            SubKey,
            Index,
            NameBuf,
            &Size,
            NULL /* Reserved */,
            NULL /* Class */,
            NULL /* Class size */,
            &Unused
        );
        if( ERROR_SUCCESS != Error ) break;

        Error = DhcpRegRecurseDelete(SubKey, NameBuf);
        if( ERROR_SUCCESS != Error ) break;

        memset(NameBuf, 0, sizeof(NameBuf)); Size = sizeof(NameBuf);
        Error = RegEnumKeyEx(
            SubKey,
            Index,
            NameBuf,
            &Size,
            NULL /* Reserved */,
            NULL /* Class */,
            NULL /* Class size */,
            &Unused
        );
        if( ERROR_SUCCESS != Error ) break;

        Error = RegDeleteKey(SubKey, NameBuf);
        if( ERROR_SUCCESS != Error ) break;

        Index ++;
    }

    RegCloseKey(SubKey);
    if( ERROR_NO_MORE_ITEMS != Error ) return Error;

    return ERROR_SUCCESS;
}


DWORD                                             // win32 status
DhcpRegRecurseDelete(                             // delete the specified key AND its sub keys
    IN      HKEY                   Key,           // root key
    IN      LPWSTR                 KeyName        // the key to delete along with subkeys
) {
    DWORD                          Error;
    DWORD                          Error2;

    Error = DhcpRegRecurseDeleteSub(Key,KeyName);
    Error2 = RegDeleteKey(Key,KeyName);

    if( ERROR_SUCCESS != Error ) {
        return Error;
    }

    return Error2;
}


BOOL
SetOverRideDefaultGateway(
    LPWSTR AdapterName
    )
/*++

Routine Description:

    This function reads the override default gateway parameter from
    registry and if this parameter is non-null, it sets the gateway
    value in the TCP/IP stack and return TRUE, otherwise it returns
    FALSE.

Arguments:

    AdapterName - name of the adapter we are working on.

Return Value:

    TRUE: If the override gateway parameter is specified in the registry
            and it is succssfully set in the TCP/IP router table.

    FALSE : Otherwise.

--*/
{
    DWORD Error;
    LPWSTR RegKey = NULL;
    DWORD RegKeyLength;
    HKEY KeyHandle = NULL;
    LPWSTR DefaultGatewayString = NULL;
    DWORD DefaultGatewayStringSize;
    BOOL EmptyDefaultGatewayString = FALSE;
    LPWSTR DefaultGatewayMetricString = NULL;
    DWORD DefaultGatewayMetricStringSize;
    LPWSTR String;
    LPWSTR Metric;
    DWORD   ValueSize,ValueType;
    DWORD   DontAddGatewayFlag;

    RegKeyLength = (DWORD)(sizeof(DHCP_SERVICES_KEY) +
                    sizeof(REGISTRY_CONNECT_STRING) +
                    wcslen(AdapterName) * sizeof(WCHAR) +
                    sizeof(DHCP_ADAPTER_PARAMETERS_KEY));

    RegKey = DhcpAllocateMemory( RegKeyLength );

    if( RegKey == NULL ) {

        Error = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    wcscpy( RegKey, DHCP_SERVICES_KEY );
    wcscat( RegKey, DHCP_ADAPTER_PARAMETERS_KEY );
    wcscat( RegKey, REGISTRY_CONNECT_STRING );
    wcscat( RegKey, AdapterName);

    Error = RegOpenKeyEx(
        HKEY_LOCAL_MACHINE,
        RegKey,
        0, // Reserved field
        DHCP_CLIENT_KEY_ACCESS,
        &KeyHandle
        );

    DhcpFreeMemory(RegKey);
    RegKey = NULL;

    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }

    DhcpAssert( KeyHandle != NULL );

    ValueSize = sizeof(DWORD);
    Error = RegQueryValueEx(
        KeyHandle,
        DHCP_DONT_ADD_DEFAULT_GATEWAY_FLAG,
        0,
        &ValueType,
        (LPBYTE)&DontAddGatewayFlag,
        &ValueSize );


    if ( Error == ERROR_SUCCESS && DontAddGatewayFlag > 0 ) {
        RegCloseKey(KeyHandle);
        return TRUE;
    }

    Error = GetRegistryString(
        KeyHandle,
        DHCP_DEFAULT_GATEWAY_PARAMETER,
        &DefaultGatewayString,
        &DefaultGatewayStringSize );

    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }

    if ( (DefaultGatewayStringSize == 0) ||
         (wcslen(DefaultGatewayString) == 0) ) {

        EmptyDefaultGatewayString = TRUE;
        goto Cleanup;
    }

    Error = GetRegistryString(
        KeyHandle,
        DHCP_DEFAULT_GATEWAY_METRIC_PARAMETER,
        &DefaultGatewayMetricString,
        &DefaultGatewayMetricStringSize
        );

    if( 0 == DefaultGatewayMetricStringSize ) {
        Metric = NULL;
    } else {
        Metric = DefaultGatewayMetricString;
    }

    for( String = DefaultGatewayString;
            wcslen(String) != 0;
                String += (wcslen(String) + 1) ) {

        CHAR OemIpAddressBuffer[DOT_IP_ADDR_SIZE];
        LPSTR OemIpAddressString;
        DHCP_IP_ADDRESS GatewayAddress;
        DWORD GatewayMetric = 1;

        OemIpAddressString = DhcpUnicodeToOem( String, OemIpAddressBuffer );
        GatewayAddress = DhcpDottedStringToIpAddress( OemIpAddressString );

        if( Metric && Metric[0] ) {
            LPWSTR MetricEnd;
            GatewayMetric = wcstoul(Metric, &MetricEnd, 0);
            if( GatewayMetric && GatewayMetric != MAXULONG ) {
                Metric += wcslen(Metric) + 1;
            } else {
                GatewayMetric = DEFAULT_METRIC;
                Metric = NULL;
            }
        }

        Error = SetDefaultGateway(
            DEFAULT_GATEWAY_ADD,
            GatewayAddress,
            GatewayMetric
            );

        if( Error != ERROR_SUCCESS ) {
            goto Cleanup;
        }
    }

Cleanup:

    if( RegKey != NULL ) {
        DhcpFreeMemory( RegKey );
    }

    if( KeyHandle != NULL ) {
        RegCloseKey( KeyHandle );
    }

    if( DefaultGatewayString != NULL ) {
        DhcpFreeMemory( DefaultGatewayString );
    }

    if( DefaultGatewayMetricString != NULL ) {
        DhcpFreeMemory( DefaultGatewayMetricString );
    }

    if( Error != ERROR_SUCCESS ) {

        DhcpPrint((DEBUG_ERRORS,
            "SetOverRideDefaultGateway failed, %ld.\n", Error ));

        return( FALSE );
    }

    if( EmptyDefaultGatewayString ) {

        return( FALSE );
    }

    return( TRUE );
}



DWORD
SetDhcpOption(
    LPWSTR AdapterName,
    DHCP_OPTION_ID OptionId,
    LPBOOL DefaultGatewaysSet,
    BOOL LastKnownDefaultGateway
) {
    DhcpAssert(FALSE);
    return 0;
}

DWORD
DhcpMakeNICEntry(
    PDHCP_CONTEXT *ReturnDhcpContext,
    BYTE HardwareAddressType,
    LPBYTE HardwareAddress,
    DWORD HardwareAddressLength,
    DHCP_CLIENT_IDENTIFIER *pClientID,
    LPWSTR AdapterName,
    LPWSTR RegKey
)
/*++

Routine Description:

    This function allocates memory and fills in the fields that are passed as
    parameter. (Only the variable length fields must be here).

Arguments:

    Parameter for new entry :
         HardwareAddressType,
         HardwareAddress,
         HardwareAddressLength,
         ClientId,
         AdapterName,
         RegKey

Return Value:

    Windows Error.

History:
    8/26/96     Frankbee        Added Client ID (option 61) support

--*/
{
    PDHCP_CONTEXT       DhcpContext = NULL;
    ULONG               DhcpContextSize;
    PLOCAL_CONTEXT_INFO LocalInfo;
    LPVOID              Ptr;
    BYTE                StateStringBuffer[200];
    DWORD               AdapterNameLen;
    DWORD               DeviceNameLen;
    DWORD               NetBTDeviceNameLen;
    DWORD               RegKeyLen;

    AdapterNameLen = ((wcslen(AdapterName) + 1) * sizeof(WCHAR));
    NetBTDeviceNameLen =
         ((wcslen(DHCP_ADAPTERS_DEVICE_STRING) +
           wcslen(DHCP_NETBT_DEVICE_STRING) +
           wcslen(AdapterName) + 1) * sizeof(WCHAR));

    RegKeyLen = ((wcslen(RegKey) + 1) * sizeof(WCHAR));
    DhcpContextSize =
        ROUND_UP_COUNT(sizeof(DHCP_CONTEXT), ALIGN_WORST) +
        ROUND_UP_COUNT(HardwareAddressLength, ALIGN_WORST) +
        ROUND_UP_COUNT(sizeof(LOCAL_CONTEXT_INFO), ALIGN_WORST) +
        ROUND_UP_COUNT(AdapterNameLen, ALIGN_WORST) +
        ROUND_UP_COUNT(NetBTDeviceNameLen, ALIGN_WORST) +
        ROUND_UP_COUNT(RegKeyLen, ALIGN_WORST) +
        ROUND_UP_COUNT(DHCP_RECV_MESSAGE_SIZE, ALIGN_WORST);

    if ( pClientID->fSpecified ) {
        DhcpAssert( pClientID->cbID );
        DhcpContextSize += ROUND_UP_COUNT( pClientID->cbID, ALIGN_WORST );
    }

    Ptr = DhcpAllocateMemory( DhcpContextSize );
    if ( Ptr == NULL ) return ERROR_NOT_ENOUGH_MEMORY;
    RtlZeroMemory(Ptr, DhcpContextSize);

    DhcpContext = Ptr;
    Ptr = ROUND_UP_POINTER( (LPBYTE)Ptr + sizeof(DHCP_CONTEXT), ALIGN_WORST);

    DhcpContext->HardwareAddress = Ptr;
    Ptr = ROUND_UP_POINTER( (LPBYTE)Ptr + HardwareAddressLength, ALIGN_WORST);

    if ( pClientID->fSpecified ) {
        DhcpContext->ClientIdentifier.pbID = Ptr;
        Ptr = ROUND_UP_POINTER( (LPBYTE)Ptr + pClientID->cbID, ALIGN_WORST );
    }

    DhcpContext->LocalInformation = Ptr;
    LocalInfo = Ptr;
    Ptr = ROUND_UP_POINTER( (LPBYTE)Ptr + sizeof(LOCAL_CONTEXT_INFO), ALIGN_WORST);

    LocalInfo->AdapterName= Ptr;
    Ptr = ROUND_UP_POINTER( (LPBYTE)Ptr + AdapterNameLen, ALIGN_WORST);

    LocalInfo->NetBTDeviceName= Ptr;
    Ptr = ROUND_UP_POINTER( (LPBYTE)Ptr + NetBTDeviceNameLen, ALIGN_WORST);

    LocalInfo->RegistryKey= Ptr;
    Ptr = ROUND_UP_POINTER( (LPBYTE)Ptr + RegKeyLen, ALIGN_WORST);

    DhcpContext->MessageBuffer = Ptr;

    //
    // Fill in the fields
    //

    DhcpContext->HardwareAddressType = HardwareAddressType;
    DhcpContext->HardwareAddressLength = HardwareAddressLength;
    RtlCopyMemory(DhcpContext->HardwareAddress, HardwareAddress,HardwareAddressLength);

    DhcpContext->ClientIdentifier.fSpecified = pClientID->fSpecified;

    if ( pClientID->fSpecified ) {
        DhcpContext->ClientIdentifier.bType = pClientID->bType;
        DhcpContext->ClientIdentifier.cbID  = pClientID->cbID;

        RtlCopyMemory(DhcpContext->ClientIdentifier.pbID,pClientID->pbID,pClientID->cbID);
    }

    RtlCopyMemory(LocalInfo->AdapterName, AdapterName, AdapterNameLen);

    wcscpy( LocalInfo->NetBTDeviceName, DHCP_ADAPTERS_DEVICE_STRING );
    wcscat( LocalInfo->NetBTDeviceName, DHCP_NETBT_DEVICE_STRING );
    wcscat( LocalInfo->NetBTDeviceName, AdapterName );

    RtlCopyMemory(LocalInfo->RegistryKey, RegKey, RegKeyLen);

    if( ReturnDhcpContext != NULL ) *ReturnDhcpContext = DhcpContext;

    return( ERROR_SUCCESS );
}



BOOL
ReadClientID(
    HKEY   hKey,
    BYTE  *pbClientIDType,
    DWORD *pcbClientID,
    BYTE  *ppbClientID[]
)
/*++

Function:
    ReadClientID

Routine Description:

    Reads and validates the optional Client-Identifier option

Arguments:

    hKey            - handle to a registry key whose info will be retrieved.

    pbClientIDType  - Recieves the client ID option type

    pcbClientID     - Receives the size of the client id option

    ppbClientID     - Receives a pointer to a buffer containing the
                      client ID option

Return Value:
    TRUE            - A valid client ID was read from the registry
    FALSE           - Client ID could not be read

Comments:
    If ReadClientID returns false, pbClientIDType, pcbClientID and ppbClientID
    will be set to NULL.

History
    7/14/96     Frankbee      Created

--*/
{
    DWORD dwResult,
          dwDataType,
          dwcb,
          dwClientIDType,
          dwClientID;

    BYTE *pbClientID;

    BOOL  fClientIDSpecified = FALSE;

    //
    // read the client id and client id type, if present
    //

    dwcb = sizeof(dwClientIDType);
    dwResult = RegQueryValueEx(
                hKey,
                DHCP_CLIENT_IDENTIFIER_FORMAT,
                0,
                &dwDataType,
                (LPBYTE)&dwClientIDType,
                &dwcb );
    if ( ERROR_SUCCESS != dwResult )
    {
        DhcpPrint( (DEBUG_MISC,
                   "Client-Indentifier type not present in registry.\n" ));
        //
        // specify ID type 0 to indicate that the client ID is not a hardware
        // address
        //

        dwClientIDType = 0;
    }
    else
    {

        //
        // the client id type is present, make sure it is the correct
        // data type and within range
        //

        if ( DHCP_CLIENT_IDENTIFIER_FORMAT_TYPE != dwDataType || dwClientIDType > 0xFF )
        {
            DhcpPrint( (DEBUG_MISC,
                       "Invalid Client-Indentifier type: %d\n", dwClientIDType ));

            goto done;
        }
    }

    //
    // Now try to read the client ID
    //

    // first try to read the size
    dwcb = 0;
    dwResult = RegQueryValueEx(
                 hKey,
                 DHCP_CLIENT_IDENTIFIER_VALUE,
                 0,
                 0,    // don't care about the type
                 NULL, // specify null buffer to obtain size
                 &dwcb );

    // make the the value is present
    if ( ERROR_SUCCESS != dwResult || !dwcb  )
    {
        DhcpPrint( (DEBUG_MISC,
                    "Client-Identifier is not present or invalid.\n" ));
        goto done;
    }


    // allocate the buffer and read the value
    pbClientID = (BYTE*) DhcpAllocateMemory ( dwcb );

    if ( !pbClientID )
    {
        DhcpPrint( (DEBUG_ERRORS,
                   "Unable to allocate memory for Client-Identifier "));


       goto done;
    }


    dwResult = RegQueryValueEx(
                  hKey,
                  DHCP_CLIENT_IDENTIFIER_VALUE,
                  0,
                  0,  // client id can be any type
                  pbClientID,
                  &dwcb );
    if ( ERROR_SUCCESS != dwResult )
    {
        DhcpPrint( (DEBUG_ERRORS,
                  "Unable to read Client-Identifier from registry: %d\n", dwResult ));

        DhcpFreeMemory( pbClientID );
        goto done;
    }

    //
    // we have a client id
    //

    fClientIDSpecified = TRUE;

done:

    if ( fClientIDSpecified )
    {
       *pbClientIDType = (BYTE) dwClientIDType;
       *pcbClientID    = dwcb;
       *ppbClientID    = pbClientID;
    }
    else
    {
       *pbClientIDType = 0;
       *pcbClientID    = 0;
       *ppbClientID    = NULL;
    }

   if ( fClientIDSpecified )
   {
      int i;

      //
      // A valid client-identifier was obtained from the registry.  dump out
      // the contents
      //

      DhcpPrint( (DEBUG_MISC,
                 "A Client Identifier was obtained from the registry:\n" ));

      DhcpPrint( (DEBUG_MISC,
                 "Client-Identifier Type == %#2x\n", (int) *pbClientIDType ));

      DhcpPrint( (DEBUG_MISC,
                 "Client-Indentifier length == %d\n", (int) *pcbClientID ));

      DhcpPrint( (DEBUG_MISC,
                 "Client-Identifier == " ));

      for ( i = 0; i < (int) *pcbClientID; i++ )
          DhcpPrint((DEBUG_MISC, "%#2x ", (int) ((*ppbClientID)[i]) ));

      DhcpPrint( (DEBUG_MISC, "\n" ));
   }

   return fClientIDSpecified;
}

BOOL
GuidToClientID(
    IN LPWSTR  GuidString,
    BYTE  *pbClientIDType,
    DWORD *pcbClientID,
    BYTE  *ppbClientID[]
    )
{
    GUID    guid;
    UNICODE_STRING  unGuid;
    BYTE    *pbClientID;

    RtlInitUnicodeString(&unGuid, GuidString);
    if (RtlGUIDFromString(&unGuid, &guid) != STATUS_SUCCESS) {
        return FALSE;
    }
    pbClientID = (BYTE*) DhcpAllocateMemory (sizeof(GUID));
    if (pbClientID == NULL) {
        return FALSE;
    }

    memcpy(pbClientID, &guid, sizeof(GUID));
    *pbClientIDType = 0;        // per RFC 2132, 0 should be used when the ID is not a hardware address
    *pcbClientID    = sizeof(GUID);
    *ppbClientID    = pbClientID;
    return TRUE;
}

DWORD                                             // status
DhcpRegExpandString(                              // replace '?' with AdapterName
    IN      LPWSTR                 InString,      // input string to expand
    IN      LPWSTR                 AdapterName,   // the adapter name
    OUT     LPWSTR                *OutString,     // the output ptr to store string
    IN OUT  LPWSTR                 Buffer         // the buffer to use if non NULL
) {
    LPWSTR                         Mem;           // the real mem to use
    LPWSTR                         Tmp, Tmp2, MemTmp;
    DWORD                          MemSize;       // the size of this memory
    DWORD                          AdapterNameLen;// the amt of bytes for adapter name

    *OutString = NULL;

    AdapterNameLen = wcslen(AdapterName) * sizeof(WCHAR);
    if( NULL != Buffer ) {                        // Buffer already provided
        Mem = Buffer;
        MemSize = 0;
    } else {                                      // need to allocate buffer
        MemSize = wcslen(InString)+1;             // calculate memory size needed
        MemSize *= sizeof(WCHAR);

        Tmp = InString;
        while( Tmp = wcschr(Tmp, OPTION_REPLACE_CHAR ) ) {
            Tmp ++;
            MemSize += AdapterNameLen - sizeof(OPTION_REPLACE_CHAR);
        }

        Mem = DhcpAllocateMemory(MemSize);        // allocate the buffer
        if( NULL == Mem ) return ERROR_NOT_ENOUGH_MEMORY;
    }

    Tmp = InString; MemTmp = Mem;
    while( Tmp2 = wcschr(Tmp, OPTION_REPLACE_CHAR) ) {
        memcpy(MemTmp, Tmp, (int)(Tmp2 - Tmp) * sizeof(WCHAR) );
        MemTmp += (Tmp2-Tmp);
        memcpy(MemTmp, AdapterName, AdapterNameLen);
        MemTmp += AdapterNameLen/sizeof(WCHAR);
        Tmp = Tmp2+1;
    }

    wcscpy(MemTmp, Tmp);
    *OutString = Mem;

    return ERROR_SUCCESS;;
}

DWORD                                             // status
DhcpRegReadFromLocation(                          // read from one location
    IN      LPWSTR                 OneLocation,   // value to read from
    IN      LPWSTR                 AdapterName,   // replace '?' with adapternames
    OUT     LPBYTE                *Value,         // output value
    OUT     DWORD                 *ValueType,     // data type of value
    OUT     DWORD                 *ValueSize      // the size in bytes
) {
    DWORD                          Error;
    LPWSTR                         NewRegLocation;
    HKEY                           KeyHandle;
    LPWSTR                         ValueName;

    Error = DhcpRegExpandString(                  // replace all occurences of '?'
        OneLocation,
        AdapterName,
        &NewRegLocation,
        NULL
    );
    if( ERROR_SUCCESS != Error ) return Error;

    ValueName = wcsrchr(NewRegLocation, REGISTRY_CONNECT);
    if( NULL != ValueName ) *ValueName++ = L'\0'; // split to reg loc and value name

    Error = RegOpenKeyEx(                         // open the required key
        HKEY_LOCAL_MACHINE,                       // running in some process -- expect full path
        NewRegLocation,                           // this is the new key
        0 /* Reserved */,
        DHCP_CLIENT_KEY_ACCESS,
        &KeyHandle
    );

    if( ERROR_SUCCESS != Error ) {
        DhcpPrint((DEBUG_ERRORS, "RegOpenKeyEx(%ws):%ld\n", NewRegLocation, Error));
        DhcpFreeMemory(NewRegLocation);
        return Error;
    }

    *ValueSize = 0;
    *Value = NULL;
    Error = RegQueryValueEx(                      // first find out how much space reqd
        KeyHandle,
        ValueName,
        0 /* Reserved */,
        ValueType,
        NULL,
        ValueSize
    );

    *Value = NULL;
    if( ERROR_SUCCESS != Error || 0 == *ValueSize ) {
        DhcpPrint((DEBUG_ERRORS, "RegQueryValueEx(%ws, %ws):%ld\n", NewRegLocation, ValueName, Error));
        DhcpFreeMemory(NewRegLocation);
        RegCloseKey(KeyHandle);
        return Error;
    }

    if( NULL == (*Value = DhcpAllocateMemory(*ValueSize))) {
        DhcpPrint((DEBUG_ERRORS, "RegReadFromLocation(%s):Allocate(%ld)failed\n", NewRegLocation, *ValueSize));
        DhcpFreeMemory(NewRegLocation);
        RegCloseKey(KeyHandle);
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    Error = RegQueryValueEx(
        KeyHandle,
        ValueName,
        0 /* Reserved */,
        ValueType,
        *Value,
        ValueSize
    );

    DhcpFreeMemory(NewRegLocation);
    RegCloseKey(KeyHandle);

    return Error;
}

DWORD                                             // status
DhcpRegReadFromAnyLocation(                       // read from one of many locations
    IN      LPWSTR                 MzRegLocation, // multiple locations thru REG_MULTI_MZ
    IN      LPWSTR                 AdapterName,   // may have to replace '?' with AdapterName
    OUT     LPBYTE                *Value,         // data for the value read
    OUT     DWORD                 *ValueType,     // type of the data
    OUT     DWORD                 *ValueSize      // the size of data
) {
    DWORD                          StringSize;
    DWORD                          Error;

    if( NULL == Value || NULL == ValueType || NULL == ValueSize ) {
        DhcpAssert( Value && ValueType && ValueSize && "DhcpRegReadFromAnyLocation" );
        return ERROR_INVALID_PARAMETER;
    }

    while( StringSize = wcslen(MzRegLocation) ) { // read in sequence and see if anything hits
        Error = DhcpRegReadFromLocation(
            MzRegLocation,
            AdapterName,
            Value,
            ValueType,
            ValueSize
        );

        if( ERROR_SUCCESS == Error) return ERROR_SUCCESS;

        MzRegLocation += StringSize + 1;
    }

    return ERROR_FILE_NOT_FOUND;
}

VOID
DhcpRegReadClassId(                               // Read the class id stuff
    IN      PDHCP_CONTEXT          DhcpContext    // Input context to read for
) {
    PLOCAL_CONTEXT_INFO            LocalInfo;
    LPWSTR                         AdapterName;
    LPWSTR                         RegLocation;
    LPWSTR                         ValueName;
    LPBYTE                         Value;
    DWORD                          ValueSize;
    DWORD                          ValueType;
    DWORD                          Error;

    DhcpContext->ClassId = NULL;
    DhcpContext->ClassIdLength = 0;
    RegLocation = NULL;
    LocalInfo = DhcpContext->LocalInformation;
    AdapterName = LocalInfo->AdapterName;

    Error = GetRegistryString(
        DhcpGlobalParametersKey,
        DHCP_CLASS_LOCATION_VALUE,
        &RegLocation,
        NULL
    );

    if( ERROR_SUCCESS != Error || NULL == RegLocation ) {
        RegLocation = NULL;
    }

    Error = DhcpRegReadFromAnyLocation(
        RegLocation?RegLocation:DEFAULT_USER_CLASS_LOC_FULL,
        AdapterName,
        &Value,
        &ValueType,
        &ValueSize
    );

    if( ERROR_SUCCESS != Error || NULL == Value ) {
        Error = FixupDhcpClassId(AdapterName, TRUE);
        if (ERROR_SUCCESS == Error) {
            Error = DhcpRegReadFromAnyLocation(
                RegLocation?RegLocation:DEFAULT_USER_CLASS_LOC_FULL,
                AdapterName,
                &Value,
                &ValueType,
                &ValueSize
            );
        }
    }

    if( NULL != RegLocation ) DhcpFreeMemory(RegLocation);

    if( ERROR_SUCCESS != Error || NULL == Value ) return;

    DhcpContext->ClassId = DhcpAddClass(&DhcpGlobalClassesList,Value, ValueSize);
    if( NULL != DhcpContext->ClassId ) DhcpContext->ClassIdLength = ValueSize;

    DhcpFreeMemory(Value);
}

DWORD INLINE                                      // win32 status
DhcpMakeContext(                                  // allocate and create a context
    IN      LPWSTR                 AdapterName,   // name of adapter
    IN      DWORD                  IpInterfaceContext,
    OUT     PDHCP_CONTEXT         *pDhcpContext   // fill this with the ptr to allocated block
)
{
    LPWSTR                         RegKey;
    HKEY                           KeyHandle;
    DHCP_CLIENT_IDENTIFIER         ClientID;
    BYTE                           HardwareAddressType;
    LPBYTE                         HardwareAddress;
    DWORD                          HardwareAddressLength;
    DWORD                          Error, OldIpAddress, OldIpMask;
    DWORD                          IpInterfaceInstance;
    BOOL                           fInterfaceDown;
    PLOCAL_CONTEXT_INFO            LocalInfo;
    DWORD                          IfIndex;
    
    ClientID.pbID                  = NULL;
    RegKey                         = NULL;
    KeyHandle                      = NULL;
    HardwareAddress                = NULL;

    RegKey = DhcpAllocateMemory(
        sizeof(WCHAR) * (
            wcslen(DHCP_SERVICES_KEY) + wcslen(REGISTRY_CONNECT_STRING) +
            wcslen(AdapterName) + wcslen(DHCP_ADAPTER_PARAMETERS_KEY) + 1
        )
    );

    if( RegKey == NULL ) return ERROR_NOT_ENOUGH_MEMORY;

    wcscpy( RegKey, DHCP_SERVICES_KEY );
    wcscat( RegKey, DHCP_ADAPTER_PARAMETERS_KEY );
    wcscat( RegKey, REGISTRY_CONNECT_STRING );
    wcscat( RegKey, AdapterName );


    DhcpPrint((DEBUG_INIT, "Opening Adapter Key - %ws.\n", RegKey));

    Error = RegOpenKeyEx(
        HKEY_LOCAL_MACHINE,
        RegKey,
        0, // Reserved field
        DHCP_CLIENT_KEY_ACCESS,
        &KeyHandle
    );
    if( ERROR_SUCCESS != Error ) {
        DhcpPrint((DEBUG_ERRORS, "RegOpenKeyEx(%ws):0x%lx\n", AdapterName, Error));
        DhcpFreeMemory(RegKey);
        return Error;
    }

    ClientID.fSpecified = ReadClientID(
        KeyHandle,
        &ClientID.bType,
        &ClientID.cbID,
        &ClientID.pbID
    );

#ifdef BOOTPERF
    Error = DhcpQueryHWInfoEx(                      // query the stack for hw info
        IpInterfaceContext,
        &IpInterfaceInstance,
        &OldIpAddress,
        &OldIpMask,
        &fInterfaceDown,
        &HardwareAddressType,
        &HardwareAddress,
        &HardwareAddressLength
    );
#else 
    Error = DhcpQueryHWInfo(                      // query the stack for hw info
        IpInterfaceContext,
        &IpInterfaceInstance,
        &HardwareAddressType,
        &HardwareAddress,
        &HardwareAddressLength
    );
#endif BOOTPERF
    
    if (HardwareAddressType == HARDWARE_1394 && !ClientID.fSpecified) {
        //
        // Generate a client identifier for 1394 interface
        //
        ClientID.fSpecified = GuidToClientID(
            AdapterName,
            &ClientID.bType,
            &ClientID.cbID,
            &ClientID.pbID
        );
        if (!ClientID.fSpecified) {
            Error = ERROR_BAD_DEVICE;
        }
    }
    
    if( ERROR_SUCCESS == Error ) {                // now do the real allocate part and get the context

        IfIndex = QueryIfIndex(IpInterfaceContext, IpInterfaceInstance);
        
        Error = DhcpMakeNICEntry(
            pDhcpContext,
            HardwareAddressType,
            HardwareAddress,
            HardwareAddressLength,
            &ClientID,
            AdapterName,
            RegKey
        );
        if( ERROR_SUCCESS == Error ) {            // if everything went fine, store the KeyHandle
            ULONG Caps;
            
            DhcpAssert((*pDhcpContext));
            (*pDhcpContext)->AdapterInfoKey = KeyHandle;
            (*pDhcpContext)->RefCount = 1;
            KeyHandle = NULL;                     // null it so that it does not get closed below
            LocalInfo = (PLOCAL_CONTEXT_INFO)((*pDhcpContext)->LocalInformation);
            LocalInfo->IpInterfaceContext = IpInterfaceContext;
            LocalInfo->IpInterfaceInstance = IpInterfaceInstance;
            LocalInfo->IfIndex = IfIndex;            
            // IpInterfaceInstance is filled in make context
            LocalInfo->Socket = INVALID_SOCKET;
            // LocalInfo->AdapterName, RegistryKey, NetBtDeviceName ALREADY set in MakeNICEntry
#ifdef BOOTPERF
            LocalInfo->OldIpAddress = OldIpAddress;
            LocalInfo->OldIpMask = OldIpMask;
            LocalInfo->fInterfaceDown = fInterfaceDown;
#endif BOOTPERF
            (*pDhcpContext)->fTimersEnabled = FALSE;
            Error = IPGetWOLCapability(DhcpIpGetIfIndex(*pDhcpContext),&Caps);
            if( NO_ERROR == Error ) {
                if( Caps & NDIS_DEVICE_WAKE_UP_ENABLE ) {
                    (*pDhcpContext)->fTimersEnabled = TRUE;
                }
            }
            Error = NO_ERROR;
        }
    } else {
        DhcpPrint((DEBUG_ERRORS, "QueryHwInfo(0x%lx)=0x%lx\n", IpInterfaceContext, Error));
    }

    if( KeyHandle ) RegCloseKey(KeyHandle);
    if( ClientID.pbID ) DhcpFreeMemory(ClientID.pbID);
    if( RegKey ) DhcpFreeMemory(RegKey);
    if( HardwareAddress ) DhcpFreeMemory(HardwareAddress);
    if (Error == NO_ERROR) {
        (*pDhcpContext)->State.UniDirectional = (IsUnidirectionalAdapter(IpInterfaceContext))? 1: 0;
    }

    return Error;
}

DWORD                                             // win32 status
DhcpRegFillParams(                                // re-read all the parameters for this adapter?
    IN OUT  PDHCP_CONTEXT          DhcpContext,   // read for this context
    IN      BOOL                   ReadAllInfo    // read all information or just config stuff?
)
{
    // currently ReadAllInfo parameter is ignored
    HKEY                           KeyHandle;

    DWORD                          Error;
    DWORD                          DwordValue;
    DWORD                          ValueType;
    DWORD                          ValueSize;
    DWORD                          AddressType;
    DWORD                          i;
    DWORD                          EnableDhcp;
    DWORD                          dwIPAutoconfigurationEnabled;
    DWORD                          DontPingGatewayFlag;
    DWORD                          UseInformFlag;
    DWORD                          InformSeparationInterval;
    DWORD                          DwordValuesCount;
    DWORD                          IpAddrValuesCount;
    DWORD                          ReleaseOnShutdown;
    DWORD                          fQuickBootEnabled;
    
    DHCP_IP_ADDRESS                Address;
    DHCP_IP_ADDRESS                IpAddress;
    DHCP_IP_ADDRESS                SubnetMask;
    DHCP_IP_ADDRESS                DhcpServerAddress;
    DHCP_IP_ADDRESS                DesiredIpAddress;

    DWORD                          Lease;
    LONG                         LeaseObtainedTime;
    LONG                         T1Time;
    LONG                         T2Time;
    LONG                         LeaseTerminatedTime;

    LPWSTR                         AdapterName;
    LPWSTR                         ValueName;
    LPWSTR                         IpAddressString;
    CHAR                           IpAddressStringBuffer[DOT_IP_ADDR_SIZE];

    DHCP_IPAUTOCONFIGURATION_CONTEXT   IPAutoconfigContext;

    struct /* anonymous */ {
        LPDWORD    Value;
        LPWSTR     ValueName;
    } DwordValuesList[] = {
        &EnableDhcp,               DHCP_ENABLE_STRING,
        &Lease,                    DHCP_LEASE,
        &LeaseObtainedTime,        DHCP_LEASE_OBTAINED_TIME,
        &T1Time,                   DHCP_LEASE_T1_TIME,
        &T2Time,                   DHCP_LEASE_T2_TIME,
        &LeaseTerminatedTime,      DHCP_LEASE_TERMINATED_TIME,
        &dwIPAutoconfigurationEnabled, DHCP_IPAUTOCONFIGURATION_ENABLED,
        &IPAutoconfigContext.Seed, DHCP_IPAUTOCONFIGURATION_SEED,
        &AddressType,              DHCP_ADDRESS_TYPE_VALUE,
        &DontPingGatewayFlag,      DHCP_DONT_PING_GATEWAY_FLAG,
        &UseInformFlag,            DHCP_USE_INFORM_FLAG,
#ifdef BOOTPERF
        &fQuickBootEnabled,        DHCP_QUICK_BOOT_FLAG,
#endif BOOTPERF
        &InformSeparationInterval, DHCP_INFORM_SEPARATION_INTERVAL,
        &ReleaseOnShutdown,        DHCP_RELEASE_ON_SHUTDOWN_VALUE
    };

    struct /* anonymous */ {
        LPDHCP_IP_ADDRESS   Address;
        LPWSTR              ValueName;
    } IpAddressValuesList[] = {
        // The first element *HAS* to be Ip address -- see the function for why
        &IpAddress,                DHCP_IP_ADDRESS_STRING,
        &SubnetMask,               DHCP_SUBNET_MASK_STRING,
        &DhcpServerAddress,        DHCP_SERVER,
        &IPAutoconfigContext.Address,  DHCP_IPAUTOCONFIGURATION_ADDRESS,
        &IPAutoconfigContext.Subnet,   DHCP_IPAUTOCONFIGURATION_SUBNET,
        &IPAutoconfigContext.Mask, DHCP_IPAUTOCONFIGURATION_MASK,
    };

    //
    // Initialize locals
    //

    KeyHandle                      = DhcpContext->AdapterInfoKey;
    EnableDhcp                     = FALSE;
    Lease                          = 0;
    LeaseObtainedTime              = 0;
    T1Time                         = 0;
    T2Time                         = 0;
    LeaseTerminatedTime            = 0;
    dwIPAutoconfigurationEnabled   = (DhcpGlobalAutonetEnabled?TRUE:FALSE);
    AddressType                    = ADDRESS_TYPE_DHCP;
    DontPingGatewayFlag            = DhcpGlobalDontPingGatewayFlag;
    UseInformFlag                  = DhcpGlobalUseInformFlag;
#ifdef BOOTPERF
    fQuickBootEnabled              = DhcpGlobalQuickBootEnabledFlag;
#endif BOOTPERF
    IpAddress                      = 0;
    SubnetMask                     = 0;
    DhcpServerAddress              = 0;
    IPAutoconfigContext.Address    = 0;
    IPAutoconfigContext.Subnet     = inet_addr(DHCP_IPAUTOCONFIGURATION_DEFAULT_SUBNET);
    IPAutoconfigContext.Mask       = inet_addr(DHCP_IPAUTOCONFIGURATION_DEFAULT_MASK);
    IPAutoconfigContext.Seed       = 0;
    InformSeparationInterval       = DHCP_DEFAULT_INFORM_SEPARATION_INTERVAL;
    ReleaseOnShutdown              = DEFAULT_RELEASE_ON_SHUTDOWN;

    AdapterName                    = ((PLOCAL_CONTEXT_INFO)(DhcpContext->LocalInformation))->AdapterName;

    DwordValuesCount               = sizeof(DwordValuesList)/sizeof(DwordValuesList[0]);
    IpAddrValuesCount              = sizeof(IpAddressValuesList)/sizeof(IpAddressValuesList[0]);

    for( i = 0; i < DwordValuesCount ; i ++ ) {
        ValueSize = sizeof(DWORD);
        ValueName = DwordValuesList[i].ValueName;
        Error = RegQueryValueEx(
            KeyHandle,
            ValueName,
            0 /* Reserved */,
            &ValueType,
            (LPBYTE)&DwordValue,
            &ValueSize
        );
        if( ERROR_SUCCESS != Error ) {
            DhcpPrint((DEBUG_ERRORS, "RegValue %ws is not found? Error: %ld. Defaults used\n", ValueName, Error));
            continue;
        }
        if( REG_DWORD != ValueType ) {
            DhcpPrint((DEBUG_ERRORS, "RegValue %ws is not a DWORD.  Defaults used\n", ValueName));
            continue;
        }

        DhcpAssert( sizeof(DWORD) == ValueSize);
        *DwordValuesList[i].Value = DwordValue;
        DhcpPrint((DEBUG_TRACE, "RegValue %ws is [%ld]\n", ValueName, DwordValue));
    }

    if (IS_UNIDIRECTIONAL(DhcpContext)) {
        DhcpPrint((DEBUG_MEDIA, "Detect Unidirectional Adapter: %ws\n", AdapterName));
        EnableDhcp = FALSE;
        dwIPAutoconfigurationEnabled = FALSE;
    }

    //For this to work correctly, the first element of array has to be the IPADDRESS
    // RAS folks still use the DhcpIpAddress value in the registry, so dont change for them
    if( !EnableDhcp  && !NdisWanAdapter(DhcpContext) )
        IpAddressValuesList[0].ValueName = DHCP_IPADDRESS_VALUE;

    for( i = 0; i < IpAddrValuesCount ; i ++ ) {
        ValueName = IpAddressValuesList[i].ValueName;
        IpAddressString = NULL;
        Error = GetRegistryString(
            KeyHandle,
            ValueName,
            &IpAddressString,
            NULL
        );

        if( ERROR_SUCCESS != Error ) {
            DhcpPrint((DEBUG_ERRORS, "RegValue %ws : %ld -- Default used\n", ValueName, Error));
            if( IpAddressString ) DhcpFreeMemory(IpAddressString);
            continue;
        }

        if( wcslen(IpAddressString) >=  DOT_IP_ADDR_SIZE ) {
            // either the format is wrong or this is a ' ' separated string?
            DhcpPrint((DEBUG_ERRORS, "String <%ws> is too long, will try to take first address\n", IpAddressString));

            if( wcschr(IpAddressString, L' ') )
                *wcschr(IpAddressString, L' ') = L'\0' ;
            if( wcschr(IpAddressString, L',') )
                *wcschr(IpAddressString, L',') = L'\0' ;
            if( wcslen(IpAddressString) >= DOT_IP_ADDR_SIZE ) {
                DhcpPrint((DEBUG_ERRORS, "Unable to split string <%ws> to DOT_IP_ADDR_SIZE -- ignoring string\n", IpAddressString));
                if( IpAddressString ) DhcpFreeMemory(IpAddressString);
                continue;
            }
        }

        Address = inet_addr(DhcpUnicodeToOem(IpAddressString, IpAddressStringBuffer));
        *IpAddressValuesList[i].Address = Address;
        if( IpAddressString ) DhcpFreeMemory(IpAddressString);
        DhcpPrint((DEBUG_TRACE, "RegValue %ws is ip-address %s\n", ValueName,
                   inet_ntoa(*(struct in_addr *)&Address)));
    }

    if( IpAddress == 0 ) DhcpServerAddress = 0;

    //
    //  Sanity check read parameters
    //

    if( 0 == IPAutoconfigContext.Mask ) {
        IPAutoconfigContext.Mask = inet_addr( DHCP_IPAUTOCONFIGURATION_DEFAULT_MASK);
        IPAutoconfigContext.Subnet = inet_addr( DHCP_IPAUTOCONFIGURATION_DEFAULT_SUBNET);
    }

    if( (IPAutoconfigContext.Subnet & IPAutoconfigContext.Mask) != IPAutoconfigContext.Subnet) {
        DhcpPrint((DEBUG_ERRORS, "Illegal (auto) Subnet address or mask\n"));
        IPAutoconfigContext.Mask = inet_addr( DHCP_IPAUTOCONFIGURATION_DEFAULT_MASK);
        IPAutoconfigContext.Subnet = inet_addr( DHCP_IPAUTOCONFIGURATION_DEFAULT_SUBNET);
    }

    if( 0 != IPAutoconfigContext.Address &&
        (IPAutoconfigContext.Address & IPAutoconfigContext.Mask) != IPAutoconfigContext.Subnet) {
        DhcpPrint((DEBUG_ERRORS, "Illegal (auto) IP address: %s\n",
                   inet_ntoa(*(struct in_addr *)&IPAutoconfigContext.Address)));
        // cant use the specified address.. really.
        IPAutoconfigContext.Address = 0;
    }

    DesiredIpAddress = IpAddress;

    if( EnableDhcp && (time( NULL ) > LeaseTerminatedTime) || 0 == IpAddress ) {
        