ache_dist.GetLineSize();
      if (endval >= 0)
      {
         m_pData->m_LimCacheInMemorySize = endval;
         bChange = TRUE;
      }
      else
      {
         bChange = m_pData->m_LimCacheInMemorySize != 0;
         m_pData->m_LimCacheInMemorySize = 0;
      }
      break;
   case SB_LINERIGHT:
      endval = m_pData->m_LimCacheInMemorySize + m_cache_dist.GetLineSize();
      if (endval <= m_pData->m_TotalCacheSize)
      {
         m_pData->m_LimCacheInMemorySize = endval;
         bChange = TRUE;
      }
      else
      {
         bChange = m_pData->m_LimCacheInMemorySize != m_pData->m_TotalCacheSize;
         m_pData->m_LimCacheInMemorySize = m_pData->m_TotalCacheSize;
      }
      break;
   case SB_PAGELEFT:
      endval = m_pData->m_LimCacheInMemorySize - m_cache_dist.GetPageSize();
      if (endval >= 0)
      {
         m_pData->m_LimCacheInMemorySize = endval;
         bChange = TRUE;
      }
      else
      {
         bChange = m_pData->m_LimCacheInMemorySize != 0;
         m_pData->m_LimCacheInMemorySize = 0;
      }
      break;
   case SB_PAGERIGHT:
      endval = m_pData->m_LimCacheInMemorySize + m_cache_dist.GetPageSize();
      if (endval <= m_pData->m_TotalCacheSize)
      {
         m_pData->m_LimCacheInMemorySize = endval;
         bChange = TRUE;
      }
      else
      {
         bChange = m_pData->m_LimCacheInMemorySize != m_pData->m_TotalCacheSize;
         m_pData->m_LimCacheInMemorySize = m_pData->m_TotalCacheSize;
      }
      break;
   case SB_LEFT:
      bChange = m_pData->m_LimCacheInMemorySize != 0;
      m_pData->m_LimCacheInMemorySize = 0;
      break;
   case SB_RIGHT:
      bChange = m_pData->m_LimCacheInMemorySize != m_pData->m_TotalCacheSize;
      m_pData->m_LimCacheInMemorySize = m_pData->m_TotalCacheSize;
      break;
   case SB_THUMBTRACK:
   case SB_ENDSCROLL:
      break;
   }
   if (bChange)
   {
      DoDataExchange(FALSE, IDC_INMEM_LIM_EDIT);
      SET_MODIFIED(TRUE);
   }
}

void
CCacheOptPage::AdjustTracker()
{
   if (::IsWindow(m_cache_dist.m_hWnd))
   {
      m_cache_dist.SetRange(0, m_pData->m_TotalCacheSize, TRUE);
      m_cache_dist.SetPos(m_pData->m_LimCacheInMemorySize);
      m_cache_dist.SetPageSize(m_pData->m_TotalCacheSize / 10);
      m_cache_dist.SetLineSize(m_pData->m_TotalCacheSize / 25);
      m_cache_dist.SetTicFreq(m_pData->m_TotalCacheSize / 25);
   }
}

void 
CCacheOptPage::OnChangePath(UINT nCode, UINT nID, HWND hWnd)
{
	m_FileChooser.OnEditChange();
    CString buf;
    DWORD rc;
    if (FC_SUCCESS != (rc = m_FileChooser.GetFileName(buf)))
	{
        ::EnableWindow(m_pData->m_pSheet->GetDlgItem(IDOK), FALSE);
        SET_MODIFIED(FALSE);
	}
    else
    {
        ::EnableWindow(m_pData->m_pSheet->GetDlgItem(IDOK), TRUE);
        OnChangeData(nCode, nID, hWnd);
    }
}

void 
CCacheOptPage::OnDataValidateError(UINT id, BOOL bSave,_XData& data)
{
	if (bSave)
	{
		CString str, fmt, caption;
		caption.LoadString(_Module.GetResourceInstance(), IDS_SHEET_TITLE);
 
		switch (data.nDataType)
		{
		case ddxDataText:
 			break;
		case ddxDataNull:
			break;
		case ddxDataInt:
			fmt.LoadString(_Module.GetResourceInstance(), IDS_ERR_INT_RANGE);
			str.Format(fmt, data.intData.nMin, data.intData.nMax);
			break;
		}
		if (!str.IsEmpty())
		{
			MessageBox(str, caption, MB_OK | MB_ICONEXCLAMATION);
			::SetFocus(GetDlgItem(id));
		}
	}
}

void 
CCacheOptPage::OnDataExchangeError(UINT nCtrlID, BOOL bSave)
{
	if (bSave)
	{
		CString str, fmt, caption;
		int min, max;
		caption.LoadString(_Module.GetResourceInstance(), IDS_SHEET_TITLE);
		switch (nCtrlID)
		{
		case IDC_CACHE_SIZE_EDIT:
		case IDC_INMEM_UNLIM_EDIT:
			min = CACHE_SIZE_MIN;
			max = CACHE_SIZE_MAX;
			fmt.LoadString(_Module.GetResourceInstance(), IDS_ERR_INT_RANGE);
			break;
		case IDC_INMEM_LIM_EDIT:
			min = CACHE_SIZE_MIN;
			max = m_pData->m_TotalCacheSize;
			fmt.LoadString(_Module.GetResourceInstance(), IDS_ERR_INT_RANGE);
			break;
		case IDC_ENGINES:
			min = SCRIPT_ENG_MIN;
			max = SCRIPT_ENG_MAX;
			fmt.LoadString(_Module.GetResourceInstance(), IDS_ERR_INT_RANGE);
			break;
		default:
			str.LoadString(_Module.GetResourceInstance(), IDS_ERR_INVALID_DATA);
			break;
		}
		if (!fmt.IsEmpty())
		{
			str.Format(fmt, min, max);
		}
		MessageBox(str, caption, MB_OK | MB_ICONEXCLAMATION);
		::SetFocus(GetDlgItem(nCtrlID));
	}
}

void
CCacheOptPage::OnHelp()
{
    WinHelp(m_pData->m_HelpPath, HELP_CONTEXT, CCacheOptPage::IDD + WINHELP_NUMBER_BASE);
}

////////////////////////////////////////////////////////////////////////////

LRESULT 
CCacheOptPage_iis5::OnInitDialog(HWND hDlg, LPARAM lParam)
{
   if (NULL == m_pData)
   {
      ASSERT(FALSE);
      ::EndDialog(hDlg, 0);
      return -1;
   }
   m_bInitDone = FALSE;
   DoDataExchange();

   UDACCEL toAcc[3] = {{1, 1}, {3, 5}, {6, 10}};

   m_eng_cache.SetRange32(SCRIPT_ENG_MIN, SCRIPT_ENG_MAX);
   m_eng_cache.SetPos32(m_pData->m_ScriptEngCacheMax);
   m_eng_cache.SetAccel(3, toAcc);
   
   m_inmem_lim.SetRange32(CACHE_SIZE_MIN, CACHE_SIZE_MAX);
   m_inmem_lim.SetPos32(m_pData->m_LimCacheInMemorySize);
   m_inmem_lim.SetAccel(3, toAcc);

   UINT id = IDC_UNLIMITED_CACHE;
   if (m_pData->m_NoCache) 
      id = IDC_NO_CACHE;
   else if (m_pData->m_LimCache) 
      id = IDC_LIMITED_CACHE;
   OnCacheSwitch(0, id, NULL);

   DoDataExchange();

   m_bInitDone = TRUE;

   return FALSE;
};

BOOL
CCacheOptPage_iis5::OnKillActive()
{
   HRESULT hr = S_OK;

   if (m_bInitDone)
   {
      if (!DoDataExchange(TRUE))
		  return FALSE;
	  hr = m_pData->Save();
   }
   return SUCCEEDED(hr);
}

void
CCacheOptPage_iis5::OnCacheSwitch(UINT, UINT nID, HWND)
{
   switch (nID)
   {
   case IDC_NO_CACHE:
      m_pData->m_NoCache = TRUE;
      m_pData->m_UnlimCache = FALSE;
      m_pData->m_LimCache = FALSE;
      break;
   case IDC_UNLIMITED_CACHE:
      m_pData->m_NoCache = FALSE;
      m_pData->m_UnlimCache = TRUE;
      m_pData->m_LimCache = FALSE;
      break;
   case IDC_LIMITED_CACHE:
      // When cache is unlimited or disabled, size is set to -1,
      // reset it to reasonable default here
      if (m_pData->m_LimCacheInMemorySize == -1)
      {
         m_pData->m_LimCacheInMemorySize = IIS5_CACHE_DEFAULT;
         DoDataExchange(FALSE, IDC_CACHE_SIZE_EDIT);
      }
      m_pData->m_NoCache = FALSE;
      m_pData->m_UnlimCache = FALSE;
      m_pData->m_LimCache = TRUE;
      break;
   }
   m_NoCacheBtn.SetCheck(m_pData->m_NoCache);
   m_UnlimCacheBtn.SetCheck(m_pData->m_UnlimCache);
   m_LimCacheBtn.SetCheck(m_pData->m_LimCache);

   m_inmem_lim.EnableWindow(m_pData->m_LimCache);
   ::EnableWindow(GetDlgItem(IDC_CACHE_SIZE_EDIT), m_pData->m_LimCache);

   SET_MODIFIED(TRUE);
}

void 
CCacheOptPage_iis5::OnDataValidateError(UINT id, BOOL bSave,_XData& data)
{
	if (bSave)
	{
		CString str, fmt, caption;
		caption.LoadString(_Module.GetResourceInstance(), IDS_SHEET_TITLE);
 
		switch (data.nDataType)
		{
		case ddxDataText:
 			break;
		case ddxDataNull:
			break;
		case ddxDataInt:
			fmt.LoadString(_Module.GetResourceInstance(), IDS_ERR_INT_RANGE);
			str.Format(fmt, data.intData.nMin, data.intData.nMax);
			break;
		}
		if (!str.IsEmpty())
		{
			MessageBox(str, caption, MB_OK | MB_ICONEXCLAMATION);
			::SetFocus(GetDlgItem(id));
		}
	}
}

void 
CCacheOptPage_iis5::OnDataExchangeError(UINT nCtrlID, BOOL bSave)
{
	if (bSave)
	{
		CString str, fmt, caption;
		int min, max;
		caption.LoadString(_Module.GetResourceInstance(), IDS_SHEET_TITLE);
		fmt.LoadString(_Module.GetResourceInstance(), IDS_ERR_INT_RANGE);
		switch (nCtrlID)
		{
		case IDC_CACHE_SIZE_EDIT:
			min = CACHE_SIZE_MIN;
			max = CACHE_SIZE_MAX;
			break;
		case IDC_ENGINES:
			min = SCRIPT_ENG_MIN;
			max = SCRIPT_ENG_MAX;
			break;
		default:
			break;
		}
		str.Format(fmt, min, max);
		MessageBox(str, caption, MB_OK | MB_ICONEXCLAMATION);
		::SetFocus(GetDlgItem(nCtrlID));
	}
}

void
CCacheOptPage_iis5::OnHelp()
{
    WinHelp(m_pData->m_HelpPath, HELP_CONTEXT, CCacheOptPage::IDD + WINHELP_NUMBER_BASE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\appconfig\processopt.h ===
//
//
//
#ifndef _PROCESS_OPT_H
#define _PROCESS_OPT_H

#include "resource.h"
#include "ExchControls.h"
#include "PropSheet.h"

#define TIMEOUT_MIN     0
#define TIMEOUT_MAX     2000000000

class CProcessOptPage : 
   public WTL::CPropertyPageImpl<CProcessOptPage>,
   public WTL::CWinDataExchange<CProcessOptPage>
{
   typedef WTL::CPropertyPageImpl<CProcessOptPage> baseClass;

public:
   CProcessOptPage(CAppData * pData)
   {
      m_pData = pData;
   }
   ~CProcessOptPage()
   {
   }

   enum {IDD = IDD_PROCESS_OPT};

BEGIN_MSG_MAP_EX(CProcessOptPage)
   MSG_WM_INITDIALOG(OnInitDialog)
   COMMAND_HANDLER_EX(IDC_LOG_FAILS, BN_CLICKED, OnChangeData)
   COMMAND_HANDLER_EX(IDC_DEBUG_EXCEPTION, BN_CLICKED, OnChangeData)
   COMMAND_HANDLER_EX(IDC_CGI_TIMEOUT, EN_CHANGE, OnChangeData);
   CHAIN_MSG_MAP(baseClass)
END_MSG_MAP()

BEGIN_DDX_MAP(CProcessOptPage)
   DDX_CHECK(IDC_LOG_FAILS, m_pData->m_LogFailures)
   DDX_CHECK(IDC_DEBUG_EXCEPTION, m_pData->m_DebugExcept)
   DDX_INT_RANGE(IDC_CGI_TIMEOUT, m_pData->m_CgiTimeout, TIMEOUT_MIN, TIMEOUT_MAX)
   DDX_CONTROL(IDC_TIMEOUT_SPIN, m_TimeoutSpin)
END_DDX_MAP()

   LRESULT OnInitDialog(HWND hDlg, LPARAM lParam);
   void OnChangeData(UINT nCode, UINT nID, HWND hWnd)
   {
	  if (nCode == EN_CHANGE)
	  {
		 TCHAR buf[MAX_PATH];
	     UINT len = GetDlgItemText(nID, buf, MAX_PATH);
		 BOOL bEnable = (len != 0);
         // Disable OK and Apply buttons
		 ::EnableWindow(::GetDlgItem(GetParent(), IDOK), bEnable);
		 if (!bEnable)
		 {
			 SET_MODIFIED(FALSE);
			 return;
		 }
	  }
      SET_MODIFIED(TRUE);
   }
   BOOL OnKillActive();
   void OnHelp();
   void OnDataValidateError(UINT nCtrlID, BOOL bSave, _XData& data);
   void OnDataExchangeError(UINT nCtrlID, BOOL bSave);

protected:
   CAppData * m_pData;
   CUpDownCtrlExch m_TimeoutSpin;
};

#endif //_PROCESS_OPT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\appconfig\mappingpage.cpp ===
/*++

   Copyright    (c)    2001    Microsoft Corporation

   Module  Name :
        MappingPage.cpp

   Abstract:
        App config mapping page implementation

   Author:
        Sergei Antonov (sergeia)

   Project:
        Internet Services Manager

   Revision History:

--*/
#include "stdafx.h"
#include "MappingPage.h"

enum 
{
   COL_EXTENSION = 0,
   COL_PATH,
   COL_EXCLUSIONS
};

#define EXT_WIDTH          58
#define PATH_WIDTH         204
#define EXCLUSIONS_WIDTH   72

LRESULT
CAppMappingPage::OnInitDialog(HWND hDlg, LPARAM lParam)
{
   CString str;
   CError err;

   DoDataExchange();

   DWORD dwStyle = m_list.GetExtendedListViewStyle();
   m_list.SetExtendedListViewStyle(
      dwStyle | LVS_EX_FULLROWSELECT | LVS_EX_GRIDLINES | LVS_EX_HEADERDRAGDROP | LVS_EX_LABELTIP);

   str.LoadString(_Module.GetResourceInstance(), IDS_EXTENSION);
   m_list.InsertColumn(COL_EXTENSION, str, LVCFMT_LEFT, EXT_WIDTH, 0);
   str.LoadString(_Module.GetResourceInstance(), IDS_EXECUTABLE_PATH);
   m_list.InsertColumn(COL_PATH, str, LVCFMT_LEFT, PATH_WIDTH, 1);
   str.LoadString(_Module.GetResourceInstance(), IDS_VERBS);
   m_list.InsertColumn(COL_EXCLUSIONS, str, LVCFMT_LEFT, EXCLUSIONS_WIDTH, 2);

   ASSERT(m_pData != NULL);
   CMappings::iterator it;
   int idx = 0;
   CString all_verbs;
   VERIFY(all_verbs.LoadString(_Module.GetResourceInstance(), IDS_ALL));
   for (it = m_pData->m_Mappings.begin(); it != m_pData->m_Mappings.end(); it++, idx++)
   {
      Mapping map = (*it).second;
      VERIFY(-1 != m_list.InsertItem(idx, map.ext));
      VERIFY(m_list.SetItemText(idx, COL_PATH, map.path));
      VERIFY(m_list.SetItemData(idx, map.flags));
      VERIFY(m_list.SetItemText(idx, COL_EXCLUSIONS, 
         map.verbs.IsEmpty() ? all_verbs : map.verbs));
   }

   CString remainder;
   CMetabasePath::GetRootPath(m_pData->m_MetaPath, str, &remainder);
   ::EnableWindow(GetDlgItem(IDC_CACHE_ISAPI), remainder.IsEmpty());

   int count = m_list.GetItemCount();
   if (count > 0)
   {
      m_list.SelectItem(0);
   }
   ::EnableWindow(GetDlgItem(IDC_EDIT), count > 0);
   ::EnableWindow(GetDlgItem(IDC_REMOVE), count > 0);

   return 0;
}

void 
CAppMappingPage::OnAdd(UINT nCode, UINT nID, HWND hWnd)
{
   CEditMap dlg;
   dlg.m_new = TRUE;
   dlg.m_flags = MD_SCRIPTMAPFLAG_SCRIPT | MD_SCRIPTMAPFLAG_CHECK_PATH_INFO;
   dlg.m_pData = m_pData;
   if (dlg.DoModal() == IDOK)
   {
      CString all_verbs;
      VERIFY(all_verbs.LoadString(_Module.GetResourceInstance(), IDS_ALL));
      
      Mapping map;
      map.ext = dlg.m_ext;
      map.path = dlg.m_exec;
      map.verbs = dlg.m_verbs;
      map.flags = dlg.m_flags;
      m_pData->m_Mappings.insert(CMappings::value_type(map.ext, map));

      int count = m_list.GetItemCount();
      VERIFY(-1 != m_list.InsertItem(count, map.ext));
      VERIFY(m_list.SetItemText(count, COL_PATH, dlg.m_exec));
      VERIFY(m_list.SetItemData(count, dlg.m_flags));
      VERIFY(m_list.SetItemText(count, COL_EXCLUSIONS, 
         dlg.m_verbs[0] == 0 ? all_verbs : dlg.m_verbs));
      m_list.SelectItem(count);
      SET_MODIFIED(TRUE);
      ::EnableWindow(GetDlgItem(IDC_REMOVE), TRUE);
      ::EnableWindow(GetDlgItem(IDC_EDIT), TRUE);
   }
}

void 
CAppMappingPage::OnEdit(UINT nCode, UINT nID, HWND hWnd)
{
   int idx = m_list.GetSelectedIndex();
   if (idx != -1)
   {
       CEditMap dlg;
       dlg.m_new = FALSE;
       dlg.m_pData = m_pData;
   
       TCHAR buf[MAX_PATH];
       VERIFY(0 != m_list.GetItemText(idx, 0, buf, MAX_PATH));
       CMappings::iterator it = m_pData->m_Mappings.find(buf);
       ASSERT(it != m_pData->m_Mappings.end());
       StrCpyN(dlg.m_ext, buf, MAX_PATH);
       StrCpyN(dlg.m_exec, (*it).second.path, MAX_PATH);
       StrCpyN(dlg.m_verbs, (*it).second.verbs, MAX_PATH);
       dlg.m_flags = (*it).second.flags;

       if (dlg.DoModal() == IDOK)
       {
          CString all_verbs;
          VERIFY(all_verbs.LoadString(_Module.GetResourceInstance(), IDS_ALL));
          (*it).second.path = dlg.m_exec;
          (*it).second.verbs = dlg.m_verbs;
          (*it).second.flags = dlg.m_flags;
          VERIFY(m_list.SetItemText(idx, COL_PATH, dlg.m_exec));
          VERIFY(m_list.SetItemData(idx, dlg.m_flags));
          VERIFY(m_list.SetItemText(idx, COL_EXCLUSIONS, 
             dlg.m_verbs[0] == 0 ? all_verbs : dlg.m_verbs));
          SET_MODIFIED(TRUE);
       }
   }
}

void 
CAppMappingPage::OnRemove(UINT nCode, UINT nID, HWND hWnd)
{
   int idx = m_list.GetSelectedIndex();
   if (idx != LB_ERR)
   {
	   CString msg, caption;
	   msg.LoadString(_Module.GetResourceInstance(), IDS_CONFIRM_REMOVE_MAP);
	   caption.LoadString(_Module.GetResourceInstance(), IDS_SHEET_TITLE);
	   if (MessageBox(msg, caption, MB_ICONQUESTION|MB_YESNO) == IDYES)
	   {
	      int i = m_list.GetSelectedIndex();
	      int count;
	      TCHAR buf[MAX_PATH];
	      VERIFY(0 != m_list.GetItemText(i, 0, buf, MAX_PATH));
	      m_pData->m_Mappings.erase(buf);
	      m_list.DeleteItem(i);
	      SET_MODIFIED(TRUE);
	      if ((count = m_list.GetItemCount()) > 0)
	      {
	         if (i >= count)
	            i = count - 1;
	         m_list.SelectItem(i);
	      }
	      else
	      {
	         ::EnableWindow(GetDlgItem(IDC_REMOVE), FALSE);
	         ::EnableWindow(GetDlgItem(IDC_EDIT), FALSE);
	         ::SetFocus(GetDlgItem(IDC_ADD));
	      }
	   }
	}
}

void 
CAppMappingPage::OnCacheISAPI(UINT nCode, UINT nID, HWND hWnd)
{
   SET_MODIFIED(TRUE);
}

BOOL
CAppMappingPage::OnKillActive()
{
   DoDataExchange(TRUE);
   return SUCCEEDED(m_pData->Save());
}

LRESULT
CAppMappingPage::OnDblClickList(LPNMHDR pHdr)
{
    OnEdit(BN_CLICKED, pHdr->idFrom, pHdr->hwndFrom);
    return TRUE;
}

void
CAppMappingPage::OnHelp()
{
    WinHelp(m_pData->m_HelpPath, HELP_CONTEXT, CAppMappingPage::IDD + WINHELP_NUMBER_BASE);
}

//---------------- CEditMap dialog --------------------------

#define CHECK_VERBS()\
   m_bVerbsValid = \
      (m_verbs_index > 0 && lstrlen(m_verbs) != 0) || (m_verbs_index == 0)
_inline BOOL CheckExt(LPCTSTR ext)
{
    return (ext[0] != 0) && (ext[0] == _T('.'));
}
#define CHECK_EXT()\
    m_bExtValid = CheckExt(m_ext)
_inline BOOL ExecValid(LPCTSTR exec)
{
    return lstrlen(exec) != 0 && !PathIsUNC(exec);
}
#define CHECK_EXEC(buf)\
   m_bExecValid = ExecValid(buf)
#define ENABLE_OK()\
   ::EnableWindow(GetDlgItem(IDOK), m_bExtValid && m_bExecValid && m_bVerbsValid)
#define TYPE_BIT_SET(t,b)\
	((t)&(b)) != 0

LRESULT
CEditMap::OnInitDialog(HWND hDlg, LPARAM lParam)
{
   if (!m_new && m_ext[0] != 0)
   {
      if (m_ext[0] == _T('*') && m_ext[1] == 0)
      {
          m_prev_ext[0] = _T('.');
          m_prev_ext[1] = _T('*');
          m_prev_ext[2] = 0;
          StrCpy(m_ext, m_prev_ext);
      }
      else
      {
         StrCpyN(m_prev_ext, m_ext, sizeof(m_ext) - 1);
      }
   }
   DWORD style = FC_COMMANDLINE;
   if (m_pData->IsLocal())
   {
       style |= FC_PATH_CHECK|FC_DEFAULT_READ|FC_AUTOCOMPLETION;
   }
   ::EnableWindow(GetDlgItem(IDC_BROWSE), m_pData->IsLocal());

   m_FileChooser.Init(this, style, IDC_EXECUTABLE, IDC_BROWSE);
   m_FileChooser.AddExtension(_Module.GetResourceInstance(),
      IDS_EXECUTABLE_FILES, IDS_EXECUTABLE_EXT);
   m_FileChooser.AddExtension(_Module.GetResourceInstance(),
      IDS_DLL_FILES, IDS_DLL_EXT);
   m_FileChooser.AddExtension(_Module.GetResourceInstance(),
      IDS_ALL_FILES, IDS_ALL_EXT);
   m_FileChooser.SetPath(m_exec);

   m_verbs_index = lstrlen(m_verbs) == 0 ? 0 : 1;
   ::EnableWindow(GetDlgItem(IDC_VERBS), m_verbs_index > 0);

   m_script_engine = ((m_flags & MD_SCRIPTMAPFLAG_SCRIPT) != 0);
   m_file_exists = ((m_flags & MD_SCRIPTMAPFLAG_CHECK_PATH_INFO) != 0);
   ::EnableWindow(GetDlgItem(IDC_EXTENSION), m_new);

   CHECK_EXT();
   CHECK_EXEC(m_exec);
   CHECK_VERBS();
   ENABLE_OK();

   DoDataExchange();

   return FALSE;
}

void
CEditMap::OnVerbs(UINT nCode, UINT nID, HWND hWnd)
{
   DoDataExchange(TRUE);
   ::EnableWindow(GetDlgItem(IDC_VERBS), m_verbs_index > 0);
   CHECK_VERBS();
   ENABLE_OK();
}

void
CEditMap::OnVerbsChanged(UINT nCode, UINT nID, HWND hWnd)
{
   DoDataExchange(TRUE, IDC_VERBS);
   CHECK_VERBS();
   ENABLE_OK();
}

void
CEditMap::OnHelp(UINT nCode, UINT nID, HWND hWnd)
{
	WinHelp(m_pData->m_HelpPath, HELP_CONTEXT, CEditMap::IDD + WINHELP_NUMBER_BASE);
}

#define BAIL_WITH_MESSAGE(msg, focus)\
   idmsg = msg;\
   idfocus = focus;\
   break

void
CEditMap::OnOK(UINT nCode, UINT nID, HWND hWnd)
{
   UINT idmsg = 0, idfocus = 0;
   DoDataExchange(TRUE);

   // When All is selected, verbs string is empty
   do
   {
      if (m_verbs_index == 0)
      {
         m_verbs[0] = 0;
      }
      else if (m_verbs[0] == 0)
      {
         BAIL_WITH_MESSAGE(IDS_ERR_NOVERBS, IDC_VERBS);
      }

      CString ext = m_ext;
      if (ext.ReverseFind(_T('.')) > 0)
      {
         BAIL_WITH_MESSAGE(IDS_ERR_BADEXT, IDC_EXTENSION);
      }
      // Ext should be unique, if new or changed
      if (  (m_new || StrCmpI(m_prev_ext, ext) != 0)
         && m_pData->m_Mappings.find(ext) != m_pData->m_Mappings.end()
         )
      {
         BAIL_WITH_MESSAGE(IDS_ERR_USEDEXT, IDC_EXTENSION);
      }
      if (ext.GetAt(0) == _T('*'))
         ext.erase(1);
      else if (ext.Compare(_T(".*")) == 0)
         ext = _T("*");
      else if (ext.GetAt(0) != _T('.'))
         ext = _T('.') + ext;

      StrCpyN(m_ext, ext, sizeof(m_ext)-1);

      CString buf;
      if (FC_SUCCESS != m_FileChooser.GetFileName(buf))
      {
         BAIL_WITH_MESSAGE(IDS_ERR_BADEXECFORMAT, IDC_EXECUTABLE);
      }

      int pos;
      CString path;
      if (buf[0] == _T('\"'))
      {
         if ((pos = buf.find_last_of(_T('\"'))) != CString::npos)
         {
            path = buf.substr(1, pos);
         }
         else
         {
            BAIL_WITH_MESSAGE(IDS_ERR_BADEXECFORMAT, IDC_EXECUTABLE);
         }
      }
      else if (CString::npos != (pos = buf.find(_T(' '))))
      {
         // in case there are parameters after the file name, just take it to the first space
         path = buf.substr(0, --pos);
      }
      if (PathIsUNC(path))
      {
         BAIL_WITH_MESSAGE(IDS_ERR_NOUNC, IDC_EXECUTABLE);
      }
      // perform extra local-machine tests
      if (m_pData->IsLocal())
      {
         // if local, the drive can't be redirected
         // test the drive and only accept valid, non-remote drives
         if (PathIsNetworkPath(path))
         {
            BAIL_WITH_MESSAGE(IDS_ERR_NOREMOTE, IDC_EXECUTABLE);
         }
         // check that the file exists
         if (PathIsDirectory(path))
         {
            BAIL_WITH_MESSAGE(IDS_ERR_FILENOTEXISTS, IDC_EXECUTABLE);
         }
      }
      m_flags = 0;
      if (m_script_engine)
         m_flags |= MD_SCRIPTMAPFLAG_SCRIPT;
      if (m_file_exists)
         m_flags |= MD_SCRIPTMAPFLAG_CHECK_PATH_INFO;
      StrCpy(m_exec, buf);
   }
   while (FALSE);

   if (idmsg != 0)
   {
      CString msg;
      CString cap;
      msg.LoadString(_Module.GetResourceInstance(), idmsg);
      cap.LoadString(_Module.GetResourceInstance(), IDS_SHEET_TITLE);
      MessageBox(msg, cap);
      ::SetFocus(GetDlgItem(idfocus));
      SendDlgItemMessage(idfocus, EM_SETSEL, 0, -1);
      return;
   }
   EndDialog(nID);
}

void
CEditMap::OnCancel(UINT nCode, UINT nID, HWND hWnd)
{
   EndDialog(nID);
}

void
CEditMap::OnExtChanged(UINT nCode, UINT nID, HWND hWnd)
{
   DoDataExchange(TRUE, IDC_EXTENSION);
   CHECK_EXT();
   if (m_bExtValid)
   {
	   int l = lstrlen(m_ext);
	   int i = 0;
	   while (i < l)
	   {
		   TCHAR c = m_ext[i];
		   UINT type = PathGetCharType(c);
		   if (		TYPE_BIT_SET(type, GCT_INVALID)
//			   ||	TYPE_BIT_SET(type, GCT_WILD)
			   ||	TYPE_BIT_SET(type, GCT_SEPARATOR)
			   ||	(TYPE_BIT_SET(type, GCT_LFNCHAR) && !TYPE_BIT_SET(type, GCT_SHORTCHAR))
			   ||	c == _T('/') || c == _T('<') || c == _T('|') || c == _T('>') || c == _T('?')
			   )
		   {
			   m_bExtValid = FALSE;
			   break;
		   }
		   i++;
	   }
	   if (!m_bExtValid)
	   {
			SendDlgItemMessage(IDC_EXTENSION, EM_SETSEL, i, l);
	   }
   }
   ENABLE_OK();
}

void
CEditMap::OnExecChanged(UINT nCode, UINT nID, HWND hWnd)
{
	m_FileChooser.OnEditChange();
	CString str;
	if (FC_SUCCESS == m_FileChooser.GetFileName(str))
	{
		TCHAR buff[MAX_PATH];
		StrCpyN(buff, str, MAX_PATH - 1);
		PathRemoveArgs(buff);
		CHECK_EXEC(buff);
		ENABLE_OK();
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\appconfig\mappingpage.h ===
//
//
//
#ifndef _MAPPING_PAGE_H
#define _MAPPING_PAGE_H

#include "resource.h"
#include "ExchControls.h"
#include "PropSheet.h"

class CAppMappingPage : 
   public WTL::CPropertyPageImpl<CAppMappingPage>,
   public WTL::CWinDataExchange<CAppMappingPage>
{
   typedef WTL::CPropertyPageImpl<CAppMappingPage> baseClass;

public:
   CAppMappingPage(CAppData * pData)
   {
      m_pData = pData;
   }
   ~CAppMappingPage()
   {
   }

   enum {IDD = IDD_APPMAP};

BEGIN_MSG_MAP_EX(CAppMappingPage)
   MSG_WM_INITDIALOG(OnInitDialog)
   COMMAND_HANDLER_EX(IDC_ADD, BN_CLICKED, OnAdd)
   COMMAND_HANDLER_EX(IDC_EDIT, BN_CLICKED, OnEdit)
   COMMAND_HANDLER_EX(IDC_REMOVE, BN_CLICKED, OnRemove)
   COMMAND_HANDLER_EX(IDC_CACHE_ISAPI, BN_CLICKED, OnCacheISAPI)
   NOTIFY_HANDLER_EX(IDC_LIST, NM_DBLCLK, OnDblClickList)
   CHAIN_MSG_MAP(baseClass)
END_MSG_MAP()

BEGIN_DDX_MAP(CAppMappingPage)
   DDX_CHECK(IDC_CACHE_ISAPI, m_pData->m_CacheISAPI)
   DDX_CONTROL(IDC_LIST, m_list)
END_DDX_MAP()

   LRESULT OnInitDialog(HWND hDlg, LPARAM lParam);
   void OnAdd(UINT nCode, UINT nID, HWND hWnd);
   void OnEdit(UINT nCode, UINT nID, HWND hWnd);
   void OnRemove(UINT nCode, UINT nID, HWND hWnd);
   void OnCacheISAPI(UINT nCode, UINT nID, HWND hWnd);
   LRESULT OnDblClickList(LPNMHDR pHdr);
   BOOL OnKillActive();
   void OnHelp();

protected:
   CAppData * m_pData;
   CListViewExch m_list;
};

class CEditMap : 
   public CDialogImpl<CEditMap>,
   public WTL::CWinDataExchange<CEditMap>
{
public:
   CEditMap() :
      m_script_engine(FALSE),
      m_file_exists(FALSE),
      m_verbs_index(0),
      m_new(FALSE),
      m_bExecValid(FALSE),
      m_bExtValid(FALSE),
      m_bVerbsValid(FALSE)
   {
      m_exec[0] = 0;
      m_ext[0] = 0;
      m_verbs[0] = 0;
   }
   ~CEditMap()
   {
   }

   enum {IDD = IDD_EDITMAP};

protected:

BEGIN_MSG_MAP_EX(CEditMap)
   MSG_WM_INITDIALOG(OnInitDialog)
   COMMAND_HANDLER_EX(IDC_HELPBTN, BN_CLICKED, OnHelp)
   COMMAND_HANDLER_EX(IDOK, BN_CLICKED, OnOK)
   COMMAND_HANDLER_EX(IDCANCEL, BN_CLICKED, OnCancel)
   COMMAND_HANDLER_EX(IDC_ALL_VERBS, BN_CLICKED, OnVerbs)
   COMMAND_HANDLER_EX(IDC_LIMIT_VERBS, BN_CLICKED, OnVerbs)
   COMMAND_HANDLER_EX(IDC_EXTENSION, EN_CHANGE, OnExtChanged)
   COMMAND_HANDLER_EX(IDC_EXECUTABLE, EN_CHANGE, OnExecChanged)
   COMMAND_HANDLER_EX(IDC_VERBS, EN_CHANGE, OnVerbsChanged)
END_MSG_MAP()

BEGIN_DDX_MAP(CEditMap)
//   DDX_TEXT_LEN(IDC_EXECUTABLE, m_exec, MAX_PATH)
   DDX_TEXT_LEN(IDC_EXTENSION, m_ext, MAX_PATH)
   DDX_TEXT_LEN(IDC_VERBS, m_verbs, MAX_PATH)
   DDX_RADIO(IDC_ALL_VERBS, m_verbs_index)
   DDX_CHECK(IDC_SCRIPT_ENGINE, m_script_engine)
   DDX_CHECK(IDC_FILE_EXISTS, m_file_exists)
END_DDX_MAP()

   LRESULT OnInitDialog(HWND hDlg, LPARAM lParam);
   void OnBrowse(UINT nCode, UINT nID, HWND hWnd);
   void OnHelp(UINT nCode, UINT nID, HWND hWnd);
   void OnOK(UINT nCode, UINT nID, HWND hWnd);
   void OnCancel(UINT nCode, UINT nID, HWND hWnd);
   void OnVerbs(UINT nCode, UINT nID, HWND hWnd);
   void OnExtChanged(UINT nCode, UINT nID, HWND hWnd);
   void OnExecChanged(UINT nCode, UINT nID, HWND hWnd);
   void OnVerbsChanged(UINT nCode, UINT nID, HWND hWnd);

public:
	// There is a bug in DDX_Text routine -- they pass sizeof(var) there which is site in bytes, not in chars,
	// as should be for GetWindowText(). These ugly buffers are for protection
   TCHAR m_exec[MAX_PATH];
   TCHAR buffer1[MAX_PATH];
   TCHAR m_ext[MAX_PATH];
   TCHAR buffer2[MAX_PATH];
   TCHAR m_prev_ext[MAX_PATH];
   TCHAR buffer3[MAX_PATH];
   TCHAR m_verbs[MAX_PATH];
   TCHAR buffer4[MAX_PATH];
   int m_verbs_index;
   BOOL m_script_engine, m_file_exists;
   BOOL m_new, m_bExtValid, m_bExecValid, m_bVerbsValid;
   DWORD m_flags;
   CFileChooser m_FileChooser;
   CAppData * m_pData;
};

#endif //_MAPPING_PAGE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\appconfig\iisappconfig.h ===
// IISAppConfig.h : Declaration of the CIISAppConfig

#ifndef __IISAPPCONFIG_H_
#define __IISAPPCONFIG_H_

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CIISAppConfig
class ATL_NO_VTABLE CIISAppConfig : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CIISAppConfig, &CLSID_IISAppConfig>,
	public IDispatchImpl<IIISAppConfig, &IID_IIISAppConfig, &LIBID_APPCONFIGLib>
{
public:
	CIISAppConfig()
	{
	}

DECLARE_REGISTRY_RESOURCEID(IDR_IISAPPCONFIG)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CIISAppConfig)
	COM_INTERFACE_ENTRY(IIISAppConfig)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// IIISAppConfig
public:
	STDMETHOD(put_UserPassword)(/*[in]*/ BSTR newVal);
	STDMETHOD(put_UserName)(/*[in]*/ BSTR newVal);
	STDMETHOD(put_ComputerName)(/*[in]*/ BSTR newVal);
	STDMETHOD(put_MetaPath)(/*[in]*/ BSTR newVal);
	STDMETHOD(put_HelpPath)(/*[in]*/ BSTR newVal);
	STDMETHOD(put_ServiceVersion)(/*[in]*/ DWORD newVal);
	STDMETHOD(put_ServiceCompatMode)(/*[in]*/ BOOL newVal);
	STDMETHOD(Run)();

   CComBSTR m_ComputerName;
   CComBSTR m_UserName;
   CComBSTR m_UserPassword;
   CComBSTR m_MetaPath;
   CComBSTR m_HelpPath;
   BOOL m_ShowProcessPage;
   DWORD m_Version;
   BOOL m_CompatMode;
};

#endif //__IISAPPCONFIG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\appconfig\propsheet.cpp ===
//
//
//
#include "stdafx.h"
#include "resource.h"
#include "PropSheet.h"
#include <common.h>
#include <algorithm>
#include <functional>

BOOL
PathIsValid(LPCTSTR path)
{
    LPCTSTR p = path;
    BOOL rc = TRUE;
    if (p == NULL || *p == 0)
        return FALSE;
    while (*p != 0)
    {
        switch (*p)
        {
        case TEXT('|'):
        case TEXT('>'):
        case TEXT('<'):
        case TEXT('/'):
        case TEXT('?'):
        case TEXT('*'):
        case TEXT(';'):
        case TEXT(','):
        case TEXT('"'):
            rc = FALSE;
            break;
        default:
            if (*p < TEXT(' '))
            {
                rc = FALSE;
            }
            break;
        }
        if (!rc)
        {
            break;
        }
        p++;
    }
    return rc;
}

HRESULT
CMappings::Load(CMetaKey * pKey)
{
   CStringListEx listData;
   BOOL fOverride = TRUE;
   DWORD dwAttr = 0;
   HRESULT hr = pKey->QueryValue(MD_SCRIPT_MAPS, listData, &fOverride, NULL, &dwAttr);
   if (SUCCEEDED(hr))
   {
      m_fInherited = (dwAttr & METADATA_ISINHERITED) != 0;
      m_initData.assign(listData.size(), CString(_T("")));
      std::copy(listData.begin(), listData.end(), m_initData.begin());
      CStringListEx::iterator i;
      CString buf;
      for (i = listData.begin(); i != listData.end(); i++)
      {
         buf = *i;
         Mapping map;
         int len = buf.GetLength();
         int pos = buf.find(_T(','));
         ASSERT(pos != CString::npos);
         map.ext = buf.Left(pos);

         int pos1 = buf.find(_T(','), ++pos);
         ASSERT(pos1 != CString::npos);
         map.path = buf.Mid(pos, pos1 - pos);

         pos = pos1;
         pos1 = buf.find(_T(','), ++pos);
         if (pos1 == CString::npos)
         {
            map.flags = StrToInt(buf.Right(len - pos));
         }
         else
         {
            map.flags = StrToInt(buf.Mid(pos, pos1 - pos));
            map.verbs = buf.Right(len - pos1 - 1);
         }
         insert(begin(), value_type(map.ext, map));
      }
   }
   else
   {
      hr = S_OK;
   }
   return hr;
}

inline bool eq_nocase(CString& str1, CString& str2)
{
    return str1.CompareNoCase(str2) == 0;
}

struct less_nocase : public std::less<CString>
{
    bool operator()(const CString& str1, const CString& str2) const
    {
        return StrCmpI(str1.c_str(), str2.c_str()) < 0;
    }
};

//inline bool less_nocase(const CString& str1, const CString& str2)
//{
//    return str1.CompareNoCase(str2) == -1;
//}

HRESULT
CMappings::Save(CMetaKey * pKey)
{
   CStringListEx listData;
   CMappings::iterator i;
   Mapping map;
   TCHAR buf[MAX_PATH * 2];
   TCHAR num[12];
   for (i = begin(); i != end(); i++)
   {
      map = (*i).second;
      StrCpy(buf, map.ext);
      StrCat(buf, _T(","));
      StrCat(buf, map.path);
      StrCat(buf, _T(","));
      wsprintf(num, _T("%u"), map.flags);
      StrCat(buf, num);
      if (!map.verbs.IsEmpty())
      {
         StrCat(buf, _T(","));
         StrCat(buf, map.verbs);
      }
      listData.PushBack(buf);
      buf[0] = 0;
   }
   HRESULT hr = S_OK;
   if (listData.empty())
   {
       // User must be want to inherit scriptmaps from the parent
       if (!m_fInherited)
       {
           hr = pKey->DeleteValue(MD_SCRIPT_MAPS);
       }
   }
   else
   {
      if (listData.size() != m_initData.size())
      {
          VERIFY(SUCCEEDED(hr = pKey->SetValue(MD_SCRIPT_MAPS, listData)));
		  // If it was inherited, we should reset the flag now, or it will be confusing if
		  // another save will be performed before load.
		  m_fInherited = FALSE;
      }
      else
      {
          std::vector<CString> newData;
          newData.assign(listData.size(), CString(_T("")));
          std::copy(listData.begin(), listData.end(), newData.begin());
          std::sort(m_initData.begin(), m_initData.end(), less_nocase());
          std::sort(newData.begin(), newData.end(), less_nocase());
          if (!std::equal(newData.begin(), newData.end(), m_initData.begin(), eq_nocase))
          {
              VERIFY(SUCCEEDED(hr = pKey->SetValue(MD_SCRIPT_MAPS, listData)));
          }
      }
   }
   return hr;
}

HRESULT
CAppData::Load()
{
   ASSERT(!m_MetaPath.IsEmpty());
   CComAuthInfo auth(m_ServerName, m_UserName, m_UserPassword); 
   CMetaKey mk(&auth, m_MetaPath, METADATA_PERMISSION_READ);
   HRESULT hr = mk.QueryResult();
   if (FAILED(hr))
      return hr;
   do
   {
      m_fIsLocal = auth.IsLocal();
      CString buf;
      if (FAILED(hr = mk.QueryValue(MD_APP_ISOLATED, m_AppIsolated)))
         break;
      if (FAILED(hr = mk.QueryValue(MD_ASP_ALLOWSESSIONSTATE, m_EnableSession)))
         break;
      if (FAILED(hr = mk.QueryValue(MD_ASP_BUFFERINGON, m_EnableBuffering)))
         break;
      if (FAILED(hr = mk.QueryValue(MD_ASP_ENABLEPARENTPATHS, m_EnableParents)))
         break;
      if (FAILED(hr = mk.QueryValue(MD_ASP_SESSIONTIMEOUT, m_SessionTimeout)))
         break;
      if (FAILED(hr = mk.QueryValue(MD_ASP_SCRIPTTIMEOUT, m_ScriptTimeout)))
         break;
      if (FAILED(hr = mk.QueryValue(MD_ASP_SCRIPTLANGUAGE, buf)))
         break;
      StrCpy(m_Languages, buf);
      //
      if (FAILED(hr = mk.QueryValue(MD_ASP_ENABLESERVERDEBUG, m_ServerDebug)))
         break;
      if (FAILED(hr = mk.QueryValue(MD_ASP_ENABLECLIENTDEBUG, m_ClientDebug)))
         break;
      if (FAILED(hr = mk.QueryValue(MD_ASP_SCRIPTERRORSSENTTOBROWSER, m_SendAspError)))
         break;
      if (FAILED(hr = mk.QueryValue(MD_ASP_SCRIPTERRORMESSAGE, buf)))
         break;
      StrCpy(m_DefaultError, buf);
      //
      if (FAILED(hr = m_Mappings.Load(&mk)))
         break;
      if (FAILED(hr = mk.QueryValue(MD_CACHE_EXTENSIONS, m_CacheISAPI)))
         break;
      //
      if (FAILED(hr = mk.QueryValue(MD_ASP_LOGERRORREQUESTS, m_LogFailures)))
         break;
      if (FAILED(hr = mk.QueryValue(MD_ASP_EXCEPTIONCATCHENABLE, m_DebugExcept)))
         break;
      if (FAILED(hr = mk.QueryValue(MD_SCRIPT_TIMEOUT, m_CgiTimeout)))
         break;
      if (FAILED(hr = mk.QueryValue(MD_ASP_SCRIPTENGINECACHEMAX, m_ScriptEngCacheMax)))
	     break;
      //
	  if (MajorVersion() == 5 && MinorVersion() == 0)
	  {
		 if (FAILED(hr = mk.QueryValue(MD_ASP_SCRIPTFILECACHESIZE, m_LimCacheInMemorySize)))
		 {
			break;
		 }
	     m_NoCache = m_UnlimCache = m_LimCache = FALSE;
		 if (m_LimCacheInMemorySize == 0)
		 {
			 m_NoCache = TRUE;
		 }
		 else if (m_LimCacheInMemorySize == 0xFFFFFFFF)
		 {
			 m_UnlimCache = TRUE;
		 }
		 else
		 {
			 m_LimCache = TRUE;
		 }
	  }
	  else
	  {
		  if (FAILED(hr = mk.QueryValue(MD_ASP_DISKTEMPLATECACHEDIRECTORY, buf)))
		  {
			 VERIFY(0 != ExpandEnvironmentStrings(
				_T("%windir%\\system32\\inetsrv\\ASP Compiled Templates"),
				m_DiskCacheDir, MAX_PATH));
			 hr = S_OK;
		  }
		  else
			 StrCpy(m_DiskCacheDir, buf);
		  m_NoCache = m_UnlimCache = m_LimCache = FALSE;
		  if (FAILED(hr = mk.QueryValue(MD_ASP_SCRIPTFILECACHESIZE, m_AspScriptFileCacheSize)))
          {
			 m_TotalCacheSize = -1;
			 hr = S_OK;
              break;
          }
          if (m_AspScriptFileCacheSize == 0)
          {
              m_NoCache = TRUE;
			 if (FAILED(hr = mk.QueryValue(MD_ASP_SCRIPTFILECACHESIZE, m_UnlimCacheInMemorySize)))
			 {
				break;
			 }
			 m_LimCacheInMemorySize = 250;
          }
          else if (m_AspScriptFileCacheSize == -1)
          {
              m_UnlimCache = TRUE;
              m_UnlimCacheInMemorySize = CACHE_UNLIM_MAX;
			 m_LimCacheInMemorySize = 0;
          }
          else
          {
              m_LimCache = TRUE;
		      if (FAILED(hr = mk.QueryValue(MD_ASP_MAXDISKTEMPLATECACHEFILES, m_AspMaxDiskTemplateCacheFiles)))
		      {
				break;
			     m_AspMaxDiskTemplateCacheFiles = -1;
			     hr = S_OK;
		      }
              if (m_AspMaxDiskTemplateCacheFiles == 0)
              {
                  m_LimCacheInMemorySize = m_TotalCacheSize = m_AspScriptFileCacheSize;
              }
              else if (m_AspMaxDiskTemplateCacheFiles == -1)
              {
                  m_TotalCacheSize = CACHE_UNLIM_MAX;
                  m_LimCacheInMemorySize = m_AspScriptFileCacheSize;
              }
              else
              {
                  m_LimCacheInMemorySize = m_AspScriptFileCacheSize;
                  m_TotalCacheSize = m_LimCacheInMemorySize + m_AspMaxDiskTemplateCacheFiles;
              }
          }
	  }
      //
      m_MetaPath = mk.QueryMetaPath();
   } while (FALSE);
   return hr;
}

HRESULT
CAppData::Save()
{
   if (!m_Dirty)
   {
      return S_OK;
   }
   ASSERT(!m_MetaPath.IsEmpty());
   CComAuthInfo auth(m_ServerName, m_UserName, m_UserPassword); 
   CMetaKey mk(&auth, m_MetaPath, METADATA_PERMISSION_WRITE);
   HRESULT hr = mk.QueryResult();
   if (FAILED(hr))
      return hr;
   do
   {
      CString buf;
      if (FAILED(hr = mk.SetValue(MD_ASP_ALLOWSESSIONSTATE, m_EnableSession)))
         break;
      if (FAILED(hr = mk.SetValue(MD_ASP_BUFFERINGON, m_EnableBuffering)))
         break;
      if (FAILED(hr = mk.SetValue(MD_ASP_ENABLEPARENTPATHS, m_EnableParents)))
         break;
      if (FAILED(hr = mk.SetValue(MD_ASP_SESSIONTIMEOUT, m_SessionTimeout)))
         break;
      if (FAILED(hr = mk.SetValue(MD_ASP_SCRIPTTIMEOUT, m_ScriptTimeout)))
         break;
      buf = m_Languages;
      if (FAILED(hr = mk.SetValue(MD_ASP_SCRIPTLANGUAGE, buf)))
         break;
      //
      if (FAILED(hr = mk.SetValue(MD_ASP_ENABLESERVERDEBUG, m_ServerDebug)))
         break;
      if (FAILED(hr = mk.SetValue(MD_ASP_ENABLECLIENTDEBUG, m_ClientDebug)))
         break;
      if (FAILED(hr = mk.SetValue(MD_ASP_SCRIPTERRORSSENTTOBROWSER, m_SendAspError)))
         break;
      buf = m_DefaultError;
      if (FAILED(hr = mk.SetValue(MD_ASP_SCRIPTERRORMESSAGE, buf)))
         break;
      //
      if (FAILED(hr = m_Mappings.Save(&mk)))
         break;
      if (FAILED(hr = mk.SetValue(MD_CACHE_EXTENSIONS, m_CacheISAPI)))
         break;
      //
      if (FAILED(hr = mk.SetValue(MD_ASP_LOGERRORREQUESTS, m_LogFailures)))
         break;
      if (FAILED(hr = mk.SetValue(MD_ASP_EXCEPTIONCATCHENABLE, m_DebugExcept)))
         break;
      if (FAILED(hr = mk.SetValue(MD_SCRIPT_TIMEOUT, m_CgiTimeout)))
         break;
      //
      if (FAILED(hr = mk.SetValue(MD_ASP_SCRIPTENGINECACHEMAX, m_ScriptEngCacheMax)))
         break;
	  if (MajorVersion() == 5 && MinorVersion() == 0)
	  {
		  if (m_NoCache)
		  {
			 m_LimCacheInMemorySize = 0;
		  }
		  else if (m_UnlimCache)
		  {
			 m_LimCacheInMemorySize = -1;
		  }
		  if (FAILED(hr = mk.SetValue(MD_ASP_SCRIPTFILECACHESIZE, m_LimCacheInMemorySize)))
			 break;
	  }
	  else
	  {
		  buf = m_DiskCacheDir;
		  if (FAILED(hr = mk.SetValue(MD_ASP_DISKTEMPLATECACHEDIRECTORY, buf)))
			 break;
		  int inmem = 0;
		  if (m_NoCache)
		  {
			 m_AspScriptFileCacheSize = 0;
			 m_AspMaxDiskTemplateCacheFiles = 0;
		  }
		  else if (m_UnlimCache)
		  {
		     m_AspScriptFileCacheSize = -1;
			 inmem = m_UnlimCacheInMemorySize;
		  }
		  else
		  {
             if (m_TotalCacheSize >= CACHE_UNLIM_MAX)
             {
                 // disk cache unlimited
                 m_AspMaxDiskTemplateCacheFiles = -1;
                 m_AspScriptFileCacheSize = m_LimCacheInMemorySize;
             }
             else
             {
                m_AspMaxDiskTemplateCacheFiles = m_TotalCacheSize - m_LimCacheInMemorySize;
                m_AspScriptFileCacheSize = m_LimCacheInMemorySize;
             }
		  }
		  if (FAILED(hr = mk.SetValue(MD_ASP_MAXDISKTEMPLATECACHEFILES, m_AspMaxDiskTemplateCacheFiles)))
			 break;
		  if (FAILED(hr = mk.SetValue(MD_ASP_SCRIPTFILECACHESIZE, m_AspScriptFileCacheSize)))
			 break;
	  }
   } while (FALSE);
   m_Dirty = SUCCEEDED(hr);
   return hr;
}

BOOL
CAppData::IsMasterInstance()
{
   return CMetabasePath::IsMasterInstance(m_MetaPath);
}

WORD
CAppData::MajorVersion()
{
	return LOWORD(m_dwVersion);
}

WORD
CAppData::MinorVersion()
{
	return HIWORD(m_dwVersion);
}

CAppPropSheet::CAppPropSheet()
{
   static TCHAR title[256];

   ::LoadString(_Module.GetResourceInstance(), IDS_SHEET_TITLE, title, 256);
   m_psh.pszCaption = title;

}

LRESULT
CAppPropSheet::OnInitDialog(HWND hDlg, LPARAM)
{
   return 0;
}

void
CAppPropSheet::OnKeyDown(UINT nChar, UINT nRepCount, UINT nFlags)
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\appconfig\processopt.cpp ===
//
//
//
#include "stdafx.h"
#include "ProcessOpt.h"


LRESULT
CProcessOptPage::OnInitDialog(HWND hDlg, LPARAM lParam)
{
   DoDataExchange();

   UDACCEL toAcc[3] = {{1, 1}, {3, 5}, {6, 10}};

   m_TimeoutSpin.SetRange32(TIMEOUT_MIN, TIMEOUT_MAX);
   m_TimeoutSpin.SetPos32(m_pData->m_CgiTimeout);
   m_TimeoutSpin.SetAccel(3, toAcc);

   DoDataExchange(TRUE);

   return FALSE;
}

BOOL
CProcessOptPage::OnKillActive()
{
   if (!DoDataExchange(TRUE))
      return FALSE;
   return SUCCEEDED(m_pData->Save());
}

void 
CProcessOptPage::OnDataValidateError(UINT id, BOOL bSave,_XData& data)
{
	if (bSave)
	{
		CString str, fmt, caption;
		caption.LoadString(_Module.GetResourceInstance(), IDS_SHEET_TITLE);
 
		switch (data.nDataType)
		{
		case ddxDataText:
 			break;
		case ddxDataNull:
			break;
		case ddxDataInt:
			fmt.LoadString(_Module.GetResourceInstance(), IDS_ERR_INT_RANGE);
			str.Format(fmt, data.intData.nMin, data.intData.nMax);
			break;
		}
		if (!str.IsEmpty())
		{
			MessageBox(str, caption, MB_OK | MB_ICONEXCLAMATION);
			::SetFocus(GetDlgItem(id));
		}
	}
}

void 
CProcessOptPage::OnDataExchangeError(UINT nCtrlID, BOOL bSave)
{
	if (bSave)
	{
		CString str, fmt, caption;
		int min, max;
		caption.LoadString(_Module.GetResourceInstance(), IDS_SHEET_TITLE);
		switch (nCtrlID)
		{
		case IDC_CGI_TIMEOUT:
			min = TIMEOUT_MIN;
			max = TIMEOUT_MAX;
			fmt.LoadString(_Module.GetResourceInstance(), IDS_ERR_INT_RANGE);
			break;
		default:
			str.LoadString(_Module.GetResourceInstance(), IDS_ERR_INVALID_DATA);
			break;
		}
		if (!fmt.IsEmpty())
		{
			str.Format(fmt, min, max);
		}
		MessageBox(str, caption, MB_OK | MB_ICONEXCLAMATION);
		::SetFocus(GetDlgItem(nCtrlID));
	}
}

void
CProcessOptPage::OnHelp()
{
    WinHelp(m_pData->m_HelpPath, HELP_CONTEXT, CProcessOptPage::IDD + WINHELP_NUMBER_BASE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\appconfig\propsheet.h ===
//
//
//
#ifndef _PROP_SHEET_H
#define _PROP_SHEET_H

#include <vector>

//#ifndef MD_APP_PERIODIC_RESTART_TIME
//#define MD_APP_PERIODIC_RESTART_TIME         2111
//#endif
//#ifndef MD_APP_PERIODIC_RESTART_REQUESTS
//#define MD_APP_PERIODIC_RESTART_REQUESTS     2112
//#endif
//#ifndef MD_APP_PERIODIC_RESTART_SCHEDULE
//#define MD_APP_PERIODIC_RESTART_SCHEDULE     2113
//#endif
#ifndef MD_ASP_DISKTEMPLATECACHEDIRECTORY
#define MD_ASP_DISKTEMPLATECACHEDIRECTORY    7036
#endif
#ifndef MD_ASP_MAXDISKTEMPLATECACHEFILES
#define MD_ASP_MAXDISKTEMPLATECACHEFILES     7040
#endif

#define CACHE_UNLIM_MAX     999999

typedef struct _Mapping
{
   CString ext;
   CString path;
   CString verbs;
   DWORD flags;
} Mapping;

class CMetaKey;

class CMappings : public std::map<CString, Mapping>
{
public:
   CMappings()
   {
   }
   ~CMappings()
   {
   }

   HRESULT Load(CMetaKey * pKey);
   HRESULT Save(CMetaKey * pKey);

   BOOL m_fInherited;
   std::vector<CString> m_initData;
};

#define SET_MODIFIED(x)\
   m_pData->m_Dirty = (x);\
   SetModified(m_pData->m_Dirty)

#define APPLY_DATA()\
   if (SUCCEEDED(m_pData->Save()))\
      CancelToClose()

class CAppPropSheet;

class CAppData
{
public:
   CAppData()
       : m_fIsLocal(TRUE),
       m_Dirty(FALSE)
   {
   }
   ~CAppData()
   {
   }

   BOOL IsMasterInstance();
   BOOL IsLocal() {return m_fIsLocal;}
   WORD MajorVersion();
   WORD MinorVersion();

   HRESULT Load();
   HRESULT Save();

   CString m_ServerName;
   CString m_UserName;
   CString m_UserPassword;
   CString m_MetaPath;
   CString m_HelpPath;
   BOOL m_fIsLocal;

   BOOL  m_Dirty;
   int   m_AppIsolated;                //MD_APP_ISOLATED
   BOOL  m_EnableSession;              //MD_ASP_ALLOWSESSIONSTATE
   BOOL  m_EnableBuffering;            //MD_ASP_BUFFERINGON
   BOOL  m_EnableParents;              //MD_ASP_ENABLEPARENTPATHS
   int   m_SessionTimeout;             //MD_ASP_SESSIONTIMEOUT
   int   m_ScriptTimeout;              //MD_ASP_SCRIPTTIMEOUT
   TCHAR m_Languages[MAX_PATH];        //MD_ASP_SCRIPTLANGUAGE
   BOOL  m_ServerDebug;                //MD_ASP_ENABLESERVERDEBUG
   BOOL  m_ClientDebug;                //MD_ASP_ENABLECLIENTDEBUG
   BOOL  m_SendAspError;               //MD_ASP_SCRIPTERRORSSENTTOBROWSER
   TCHAR m_DefaultError[MAX_PATH];     //MD_ASP_SCRIPTERRORMESSAGE
   BOOL  m_CacheISAPI;                 //MD_CACHE_EXTENSIONS
   BOOL  m_LogFailures;                //MD_ASP_LOGERRORREQUESTS
   BOOL  m_DebugExcept;                //MD_ASP_EXCEPTIONCATCHENABLE
   int   m_CgiTimeout;                 //MD_SCRIPT_TIMEOUT 
   BOOL  m_NoCache;                    // 
   BOOL  m_UnlimCache;                 //
   BOOL  m_LimCache;                   //
   int   m_AspScriptFileCacheSize;
   int   m_AspMaxDiskTemplateCacheFiles;
   int   m_UnlimCacheInMemorySize;     //MD_ASP_SCRIPTFILECACHESIZE
   int   m_LimCacheInMemorySize;       //MD_ASP_SCRIPTFILECACHESIZE
   int   m_TotalCacheSize;             //MD_ASP_MAXDISKTEMPLATECACHESIZE
   TCHAR m_DiskCacheDir[MAX_PATH];     //MD_ASP_DISKTEMPLATECACHEDIRECTORY
   int   m_ScriptEngCacheMax;          //MD_ASP_SCRIPTENGINECACHEMAX
   CMappings m_Mappings;               //
   DWORD m_dwVersion;
   BOOL m_fCompatMode;
   CAppPropSheet * m_pSheet;
};

class CAppPropSheet : public WTL::CPropertySheet
{
public:
   CAppPropSheet();

   ~CAppPropSheet()
   {
   }

BEGIN_MSG_MAP_EX(CAppPropSheet)
   MSG_WM_INITDIALOG(OnInitDialog)
	MSG_WM_KEYDOWN(OnKeyDown)
END_MSG_MAP()

   LRESULT OnInitDialog(HWND hDlg, LPARAM lParam);
   void OnKeyDown(UINT nChar, UINT nRepCnt, UINT hFlags);
};

BOOL PathIsValid(LPCTSTR path);

#endif //_PROP_SHEET_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\certmap\amapctl.h ===
// AMapCtl.h : Declaration of the CAccountMapperCtrl OLE control class.

/////////////////////////////////////////////////////////////////////////////
// CAccountMapperCtrl : See AMapCtl.cpp for implementation.

class CAccountMapperCtrl : public COleControl
{
    DECLARE_DYNCREATE(CAccountMapperCtrl)

// Constructor
public:
    CAccountMapperCtrl();

// Overrides

    // Drawing function
    virtual void OnDraw(
                CDC* pdc, const CRect& rcBounds, const CRect& rcInvalid);

    // Persistence
    virtual void DoPropExchange(CPropExchange* pPX);

    // Reset control state
    virtual void OnResetState();

// Implementation
protected:
    // run the mapping dialog - the whole purpose of this control!
    void    RunMappingDialog();

    ~CAccountMapperCtrl();

    DECLARE_OLECREATE_EX(CAccountMapperCtrl)    // Class factory and guid
    DECLARE_OLETYPELIB(CAccountMapperCtrl)      // GetTypeInfo
    DECLARE_PROPPAGEIDS(CAccountMapperCtrl)     // Property page IDs
    DECLARE_OLECTLTYPE(CAccountMapperCtrl)      // Type name and misc status

    // Subclassed control support
    BOOL PreCreateWindow(CREATESTRUCT& cs);
    BOOL IsSubclassedControl();
    LRESULT OnOcmCommand(WPARAM wParam, LPARAM lParam);

// Message maps
    //{{AFX_MSG(CAccountMapperCtrl)
        // NOTE - ClassWizard will add and remove member functions here.
        //    DO NOT EDIT what you see in these blocks of generated code !
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

// Dispatch maps
    //{{AFX_DISPATCH(CAccountMapperCtrl)
    afx_msg void ShowMappingDialog();
    //}}AFX_DISPATCH
    DECLARE_DISPATCH_MAP()

// Event maps
    //{{AFX_EVENT(CAccountMapperCtrl)
    void FireClick()
        {FireEvent(DISPID_CLICK,EVENT_PARAM(VTS_NONE));}
    //}}AFX_EVENT
    DECLARE_EVENT_MAP()

// Dispatch and event IDs
public:
    enum {
    //{{AFX_DISP_ID(CAccountMapperCtrl)
    dispidShowMappingDialog = 1L,
    //}}AFX_DISP_ID
    };

private:
    BOOL fInitialized;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\appconfig\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by AppConfig.rc
//
#define IDS_PROJNAME                    100
#define IDR_IISAPPCONFIG                101
#define IDS_SHEET_TITLE                 101
#define IDS_EXTENSION                   102
#define IDS_EXECUTABLE_PATH             103
#define IDS_VERBS                       104
#define IDS_ALL                         105
#define IDS_CONFIRM_REMOVE_MAP          106
#define IDS_EXECUTABLE_FILES            107
#define IDS_EXECUTABLE_EXT              108
#define IDS_DLL_FILES                   109
#define IDS_DLL_EXT                     110
#define IDS_ALL_FILES                   111
#define IDS_ALL_EXT                     112
#define IDS_ERR_NOVERBS                 113
#define IDS_ERR_NOEXT                   114
#define IDS_ERR_USEDEXT                 115
#define IDS_ERR_BADEXECFORMAT           116
#define IDS_ERR_NOUNC                   117
#define IDS_ERR_NOREMOTE                118
#define IDS_ERR_FILENOTEXISTS           119
#define IDS_SELECT_CACHE_PATH           120
#define IDS_ERR_BADEXT                  121
#define IDS_DIRECTORY_DOESNT_EXIST      122
#define IDS_READ_ONLY_DIRECTORY         123
#define IDS_ERR_INT_RANGE               124
#define IDS_ERR_INVALID_DATA            125
#define IDC_INMEM_UNLIM_EDIT            201
#define IDD_TIME_PICKER                 201
#define IDC_INMEM_UNLIM_SPIN            202
#define IDC_CACHE_SIZE_SPIN             203
#define IDC_ENG_CACHED_SPIN             204
#define IDC_TIMEOUT_SPIN                207
#define IDC_TIMESPAN_SPIN               208
#define IDC_REQUESTS_SPIN               209
#define IDC_ASPTIMEOUT_SPIN             211
#define IDC_TIME_PICKER                 212
#define IDC_BROWSE                      10210
#define IDD_ASPMAIN                     10214
#define IDD_ASPDEBUG                    10215
#define IDD_APP_APPMAP                  10216
#define IDD_APPMAP                      10216
#define IDD_EDITMAP                     10218
#define IDD_APP_PROC                    10220
#define IDD_CACHE_OPT                   10220
#define IDD_APP_RECYCLE                 10221
#define IDD_PROCESS_OPT                 10221
#define IDD_CACHE_OPT_IIS5              10222
#define IDC_RECYCLE_TIMER               10235
#define IDC_CHK_EXCEPTION_CATCH         10235
#define IDC_SCRIPT_ENGINE               10235
#define IDC_FILE_EXISTS                 10236
#define IDC_DEBUG_EXCEPTION             10236
#define IDC_ENABLE_BUFFERING            10236
#define IDC_ENABLE_PARENTS              10237
#define IDC_CHK_WRITE_FAIL_TO_LOG       10238
#define IDC_LOG_FAILS                   10238
#define IDC_TIMESPAN                    10240
#define IDC_EXECUTABLE                  10240
#define IDC_SESSION_TIMEOUT             10240
#define IDC_REQUEST_LIMIT               10241
#define IDC_EDT_NUM_ENGINES             10241
#define IDC_EXTENSION                   10241
#define IDC_ENGINES                     10241
#define IDC_VERBS                       10243
#define IDC_CACHE_PATH                  10243
#define IDC_SCRIPT_TIMEOUT              10243
#define IDC_RDO_CACHE_ALL               10244
#define IDC_ALL_VERBS                   10244
#define IDC_RDO_CACHE_SIZE              10245
#define IDC_RADIO_LIMIT_VERBS           10245
#define IDC_LIMIT_VERBS                 10245
#define IDC_EDT_CACHE_SIZE              10246
#define IDC_RDO_CACHE_NONE              10247
#define IDC_LIST                        10247
#define IDC_ADD_TIME                    10248
#define IDC_ADD                         10248
#define IDC_NO_CACHE                    10248
#define IDC_REMOVE                      10249
#define IDC_UNLIMITED_CACHE             10249
#define IDC_DELETE_TIME                 10249
#define IDC_EDIT                        10250
#define IDC_LIMITED_CACHE               10250
#define IDC_CHANGE_TIME                 10250
#define IDC_HELPBTN                     10251
#define IDC_CACHE_SIZE_EDIT             10251
#define IDC_SERVER_DEBUG                10251
#define IDC_CLIENT_DEBUG                10252
#define IDC_SEND_DETAILED_ERROR         10253
#define IDC_SEND_DEF_ERROR              10254
#define IDC_DEFAULT_ERROR               10255
#define IDC_CGI_SECONDS                 10258
#define IDC_CGI_TIMEOUT                 10258
#define IDC_ENABLE_SESSION              10263
#define IDC_SESSION_TITLE               10264
#define IDC_SESSION_UNITS               10265
#define IDC_LANG_TITLE                  10267
#define IDC_CACHE_ISAPI                 10268
#define IDC_LANGUAGES                   10270
#define IDC_RECYCLE_TIMESPAN            10271
#define IDC_RECYCLE_REQUESTS            10272
#define IDC_TIMES_LIST                  10273
#define IDC_CACHE_DIST                  10275
#define IDC_INMEM_LIM_EDIT              10276
#define IDC_INMEM_LIM_SPIN              10277

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        202
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         213
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\appconfig\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\appconfig\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__A74A456C_9DC6_4AD7_8D03_A6611CFFD005__INCLUDED_)
#define AFX_STDAFX_H__A74A456C_9DC6_4AD7_8D03_A6611CFFD005__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <shlwapi.h>
#include <shellapi.h>

#define _WTL_NO_CSTRING

#include <atlwin.h>
#include <atlapp.h>
#include <atldlgs.h>
#include <atlmisc.h>
#include <atlctrls.h>
#include <atlctrlx.h>
#include <atlddx.h>
#include <atlcrack.h>

#include <map>
#include <list>
#include <stack>
#include <set>

#include "common.h"

#define WINHELP_NUMBER_BASE 0x20000

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__A74A456C_9DC6_4AD7_8D03_A6611CFFD005__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\certmap\addcert.cpp ===
// AddCert.cpp : implementation file
//

#include "stdafx.h"
#include "certmap.h"

// persistence and mapping includes
#include "WrapMaps.h"
#include "wrapmb.h"

#include "ListRow.h"
#include "ChkLstCt.h"

// mapping page includes
#include "brwsdlg.h"
#include "EdtOne11.h"
#include "Ed11Maps.h"
#include "Map11Pge.h"

extern "C"
{
    #include <wincrypt.h>
    #include <sslsp.h>
}

#include <iismap.hxx>
#include <iiscmr.hxx>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


#define COL_NUM_NAME        0
#define COL_NUM_NTACCOUNT   1

#define CERT_HEADER         "-----BEGIN CERTIFICATE-----"



// the code that reads the certificate file is pretty much lifted from the
// keyring application. Which pretty much lifted it from the setkey application

// defines taken from the old KeyGen utility
#define MESSAGE_HEADER  "-----BEGIN NEW CERTIFICATE REQUEST-----\r\n"
#define MESSAGE_TRAILER "-----END NEW CERTIFICATE REQUEST-----\r\n"
#define MIME_TYPE       "Content-Type: application/x-pkcs10\r\n"
#define MIME_ENCODING   "Content-Transfer-Encoding: base64\r\n\r\n"

void uudecode_cert(char *bufcoded, DWORD *pcbDecoded );


//---------------------------------------------------------------------------
// originally from keyring - modified to fit
BOOL CMap11Page::FAddCertificateFile( CString szFile )
    {
    CFile       cfile;
    PVOID       pData = NULL;
    BOOL        fSuccess =FALSE;;

    // open the file
    if ( !cfile.Open( szFile, CFile::modeRead | CFile::shareDenyNone ) )
        return FALSE;

    // how big is the file - add one so we can zero terminate the buffer
    DWORD   cbCertificate = cfile.GetLength() + 1;

    // make sure the file has some size
    if ( !cbCertificate )
        {
        AfxMessageBox( IDS_ERR_INVALID_CERTIFICATE );
        return FALSE;
        }

    // put the rest of the operation in a try/catch
    try
        {
        PCCERT_CONTEXT pCertContext=NULL; //used to determine whether cert file is binary DER encoded
        // allocate space for the data
        pData = GlobalAlloc( GPTR, cbCertificate );
        if ( !pData ) AfxThrowMemoryException();

        // copy in the data from the file to the pointer - will throw and exception
        DWORD cbRead = cfile.Read( pData, cbCertificate );

        // zero terminate for decoding
        ((BYTE*)pData)[cbRead] = 0;

        // close the file
        cfile.Close();

        //certificate file may be either be binary DER file or BASE64 encoded file

        // try binary DER encoded first
        pCertContext= CertCreateCertificateContext(X509_ASN_ENCODING, (const BYTE *)pData, cbRead);
        if(pCertContext != NULL)
        {
                // we created certificate context only to verify that file is binary DER encoded
                // free it now
                CertFreeCertificateContext(pCertContext);
                pCertContext=NULL;
        }
        else    // now try BASE64 encoded
        {       
                // we don't care about header ----BEGIN CERTIFICATE----- or trailer-----END CERTIFICATE-----, 
				// uudecode will take care of that
                uudecode_cert( (PCHAR)pData, &cbRead );
        }
        // we now have a pointer to a certificate. Lets keep it clean looking
        // call another subroutine to finish the job.
        fSuccess = FAddCertificate( (PUCHAR)pData, cbRead );

    }catch( CException e )
        {
        // return failure
        fSuccess = FALSE;

    // if the pointer was allocated, deallocate it
    if ( pData )
        {
        GlobalFree( pData );
        pData = NULL;
        }
    }

    // return success
    return fSuccess;
    }

    #define CERT_HEADER_LEN 17
    CHAR CertTag[ 13 ] = { 0x04, 0x0b, 'c', 'e', 'r', 't', 'i', 'f', 'i', 'c', 'a', 't', 'e' };

//---------------------------------------------------------------------------
// we are passed in a complete certificate. We need to parse out the subject
// and the issuer fields so we can add the mapping. Then add the mapping.
BOOL CMap11Page::FAddCertificate( PUCHAR pCertificate, DWORD cbCertificate )
    {
    BOOL    fSuccess = FALSE;

    // thankfully, the certificate is already in the correct format.
    // this means that, for now at least, we don't have to do anything
    // special to it to store it. However, we should crack it once just
    // to see that we can to prove that it is a valid cert.

    ASSERT( pCertificate );
    if ( !pCertificate ) return FALSE;

    // crack the certificate to prove that we can
    PX509Certificate    p509 = NULL;
    fSuccess = SslCrackCertificate( pCertificate, cbCertificate, CF_CERT_FROM_FILE, &p509 );
    if ( fSuccess )
        {
        SslFreeCertificate( p509 );
        }
    else
        {
        // we were not able to crack the certificate. Alert the user and fail
        AfxMessageBox( IDS_ERR_INVALID_CERTIFICATE );
        return FALSE;
        }

    // by this point we know we have a valid certificate, make the new mapping and fill it in
    // make the new mapping object
    C11Mapping* pMapping = PNewMapping();
    ASSERT( pMapping );
    if( !pMapping )
        {
        AfxThrowMemoryException();  // seems fairly appropriate
        return FALSE;
        }


    // one more thing before we add the certificate. Skip the header if it is there
    PUCHAR pCert = pCertificate;
    DWORD cbCert = cbCertificate;
    if ( memcmp( pCert + 4, CertTag, sizeof( CertTag ) ) == 0 )
    {
        pCert += CERT_HEADER_LEN;
        cbCert -= CERT_HEADER_LEN;
    }


    // install the certificate into the mapping
    fSuccess &= pMapping->SetCertificate( pCert, cbCert );

    // by default, the mapping is enabled
    fSuccess &= pMapping->SetMapEnabled( TRUE );

    // install a default name
    CString sz;
    
    sz.LoadString( IDS_DEFAULT_11MAP );

    fSuccess &= pMapping->SetMapName( sz );

    // install a blank mapping
    fSuccess &= pMapping->SetNTAccount( "" );

    if ( !fSuccess )
        AfxThrowMemoryException();  // seems fairly appropriate


    // now edit the newly created mapping object. If the user cancels,
    // then do not add it to the mapper object nor the list
    if ( !EditOneMapping( pMapping) )
        {
        DeleteMapping( pMapping );
        return FALSE;
        }

    // add the mapping item to the list control
    fSuccess = FAddMappingToList( pMapping );

    // one more test for success
    if ( !fSuccess )
        {
        DeleteMapping( pMapping );
        ASSERT( FALSE );
        }

    // mark the mapping to be saved
    if ( fSuccess )
        MarkToSave( pMapping );

    // return the answer
    return fSuccess;
    }


//      ==============================================================
//      The function  'uudecode_cert'  IS THE SAME function that is
//      found in file:  Addcert.cpp if we make the following code
//      have a FALSE for bAddWrapperAroundCert -- surely we can unify
//      these 2 functions.  Having 2 functions named 'uudecode_cert'
//      was causing me LINKING errors.  + we have 2 instances of
//      the external tables: uudecode_cert and pr2six
//
//      Since I am linking both Addcert.cpp and CKey.cpp I choose to
//      leave the defintions intact for CKey.cpp   [ and have extended
//      uudecode_cert by adding conditional code as shown below] Further
//      work needs to be done after identification as to why I need both
//      Addcert.cpp and CKey.cpp to pass bAddWrapperAroundCert as a
//      parameter so that both files can be supported.
//      ==============================================================
//  BOOL  bAddWrapperAroundCert = TRUE;
//  if (bAddWrapperAroundCert) {
//     //
//     //  Now we need to add a new wrapper sequence around the certificate
//     //  indicating this is a certificate
//     //
// 
//     memmove( beginbuf + sizeof(abCertHeader),
//              beginbuf,
//              nbytesdecoded );
// 
//     memcpy( beginbuf,
//             abCertHeader,
//             sizeof(abCertHeader) );
// 
//     //
//     //  The beginning record size is the total number of bytes decoded plus
//     //  the number of bytes in the certificate header
//     //
// 
//     beginbuf[CERT_SIZE_HIBYTE] = (BYTE) (((USHORT)nbytesdecoded+CERT_RECORD) >> 8);
//     beginbuf[CERT_SIZE_LOBYTE] = (BYTE) ((USHORT)nbytesdecoded+CERT_RECORD);
// 
//     nbytesdecoded += sizeof(abCertHeader);
//   }

// #ifdef WE_ARE_USING_THE_VERSION_IN__CKey_cpp__NOT_THIS_ONE__ITS_JUST_LIKE_THIS_ONE_WITH_1SMALL_CHANGE

//============================ BASED ON SETKEY
const int pr2six[256]={
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,62,64,64,64,63,
    52,53,54,55,56,57,58,59,60,61,64,64,64,64,64,64,64,0,1,2,3,4,5,6,7,8,9,
    10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,64,64,64,64,64,64,26,27,
    28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64
};

//
//  We have to squirt a record into the decoded stream
//

#define CERT_RECORD            13
#define CERT_SIZE_HIBYTE        2       //  Index into record of record size
#define CERT_SIZE_LOBYTE        3

unsigned char abCertHeader[] = {0x30, 0x82,           // Record
                                0x00, 0x00,           // Size of cert + buff
                                0x04, 0x0b, 0x63, 0x65,// Cert record data
                                0x72, 0x74, 0x69, 0x66,
                                0x69, 0x63, 0x61, 0x74,
                                0x65 };

void uudecode_cert(char *bufcoded, DWORD *pcbDecoded )
{
    int nbytesdecoded;
    char *bufin = bufcoded;
    unsigned char *bufout = (unsigned char *)bufcoded;
    unsigned char *pbuf;
    int nprbytes;
    char * beginbuf = bufcoded;

    ASSERT(bufcoded);
    ASSERT(pcbDecoded);

    /* Strip leading whitespace. */

    while(*bufcoded==' ' ||
          *bufcoded == '\t' ||
          *bufcoded == '\r' ||
          *bufcoded == '\n' )
    {
          bufcoded++;
    }

    //
    //  If there is a beginning '---- ....' then skip the first line
    //

    if ( bufcoded[0] == '-' && bufcoded[1] == '-' )
    {
        bufin = strchr( bufcoded, '\n' );

        if ( bufin )
        {
            bufin++;
            bufcoded = bufin;
        }
        else
        {
            bufin = bufcoded;
        }
    }
    else
    {
        bufin = bufcoded;
    }

    //
    //  Strip all cr/lf from the block
    //

    pbuf = (unsigned char *)bufin;
    while ( *pbuf )
    {
        if ( (*pbuf == ' ') || (*pbuf == '\r') || (*pbuf == '\n') )
        {
            memmove( (void*)pbuf, pbuf+1, strlen( (char*)pbuf + 1) + 1 );
        }
        else
        {
            pbuf++;
        }
    }

    /* Figure out how many characters are in the input buffer.
     * If this would decode into more bytes than would fit into
     * the output buffer, adjust the number of input bytes downwards.
     */

    while(pr2six[*(bufin++)] <= 63);
    nprbytes = DIFF(bufin - bufcoded) - 1;
    nbytesdecoded = ((nprbytes+3)/4) * 3;

    bufin  = bufcoded;

    while (nprbytes > 0) {
        *(bufout++) =
            (unsigned char) (pr2six[*bufin] << 2 | pr2six[bufin[1]] >> 4);
        *(bufout++) =
            (unsigned char) (pr2six[bufin[1]] << 4 | pr2six[bufin[2]] >> 2);
        *(bufout++) =
            (unsigned char) (pr2six[bufin[2]] << 6 | pr2six[bufin[3]]);
        bufin += 4;
        nprbytes -= 4;
    }

    if(nprbytes & 03) {
        if(pr2six[bufin[-2]] > 63)
            nbytesdecoded -= 2;
        else
            nbytesdecoded -= 1;
    }

    /*
    //
    //  Now we need to add a new wrapper sequence around the certificate
    //  indicating this is a certificate
    //

    memmove( beginbuf + sizeof(abCertHeader),
             beginbuf,
             nbytesdecoded );

    memcpy( beginbuf,
            abCertHeader,
            sizeof(abCertHeader) );

    //
    //  The beginning record size is the total number of bytes decoded plus
    //  the number of bytes in the certificate header
    //

    beginbuf[CERT_SIZE_HIBYTE] = (BYTE) (((USHORT)nbytesdecoded+CERT_RECORD) >> 8);
    beginbuf[CERT_SIZE_LOBYTE] = (BYTE) ((USHORT)nbytesdecoded+CERT_RECORD);

    nbytesdecoded += sizeof(abCertHeader);
*/

    if ( pcbDecoded )
        *pcbDecoded = nbytesdecoded;
}
// ============ END BASED ON SETKEY

//#endif /* WE_ARE_USING_THE_VERSION_IN__CKey_cpp__NOT_THIS_ONE__ITS_JUST_LIKE_THIS_ONE_WITH_1SMALL_CHANGE */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\certmap\amapppg.h ===
// AMapPpg.h : Declaration of the CAccountMapperPropPage property page class.

////////////////////////////////////////////////////////////////////////////
// CAccountMapperPropPage : See AMapPpg.cpp.cpp for implementation.

class CAccountMapperPropPage : public COlePropertyPage
{
    DECLARE_DYNCREATE(CAccountMapperPropPage)
    DECLARE_OLECREATE_EX(CAccountMapperPropPage)

// Constructor
public:
    CAccountMapperPropPage();

// Dialog Data
    //{{AFX_DATA(CAccountMapperPropPage)
    enum { IDD = IDD_PROPPAGE_MAPR1 };
    CString m_Caption;
    //}}AFX_DATA

// Implementation
protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support

// Message maps
protected:
    //{{AFX_MSG(CAccountMapperPropPage)
        // NOTE - ClassWizard will add and remove member functions here.
        //    DO NOT EDIT what you see in these blocks of generated code !
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\certmap\authppg.h ===
// CertAuthPpg.h : Declaration of the CCertAuthPropPage property page class.

////////////////////////////////////////////////////////////////////////////
// CCertAuthPropPage : See CertAuthPpg.cpp.cpp for implementation.

class CCertAuthPropPage : public COlePropertyPage
{
    DECLARE_DYNCREATE(CCertAuthPropPage)
    DECLARE_OLECREATE_EX(CCertAuthPropPage)

// Constructor
public:
    CCertAuthPropPage();

// Dialog Data
    //{{AFX_DATA(CCertAuthPropPage)
    enum { IDD = IDD_PROPPAGE_CERTAUTH };
    CString m_sz_caption;
    //}}AFX_DATA

// Implementation
protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support

// Message maps
protected:
    //{{AFX_MSG(CCertAuthPropPage)
        // NOTE - ClassWizard will add and remove member functions here.
        //    DO NOT EDIT what you see in these blocks of generated code !
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\certmap\authctl.cpp ===
#include "stdafx.h"
#include "certmap.h"
#include "AuthCtl.h"
#include "AuthPpg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


IMPLEMENT_DYNCREATE(CCertAuthCtrl, COleControl)


/////////////////////////////////////////////////////////////////////////////
// Message map

BEGIN_MESSAGE_MAP(CCertAuthCtrl, COleControl)
    //{{AFX_MSG_MAP(CCertAuthCtrl)
    // NOTE - ClassWizard will add and remove message map entries
    //    DO NOT EDIT what you see in these blocks of generated code !
    //}}AFX_MSG_MAP
    ON_OLEVERB(AFX_IDS_VERB_PROPERTIES, OnProperties)
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// Dispatch map

BEGIN_DISPATCH_MAP(CCertAuthCtrl, COleControl)
    //{{AFX_DISPATCH_MAP(CCertAuthCtrl)
    DISP_FUNCTION(CCertAuthCtrl, "SetMachineName", SetMachineName, VT_EMPTY, VTS_BSTR)
    DISP_FUNCTION(CCertAuthCtrl, "SetServerInstance", SetServerInstance, VT_EMPTY, VTS_BSTR)
    DISP_STOCKPROP_FONT()
    DISP_STOCKPROP_BORDERSTYLE()
    DISP_STOCKPROP_ENABLED()
    DISP_STOCKPROP_CAPTION()
    DISP_FUNCTION_ID(CCertAuthCtrl, "DoClick", DISPID_DOCLICK, DoClick, VT_EMPTY, VTS_I4)
    //}}AFX_DISPATCH_MAP
    DISP_FUNCTION_ID(CCertAuthCtrl, "AboutBox", DISPID_ABOUTBOX, AboutBox, VT_EMPTY, VTS_NONE)
END_DISPATCH_MAP()


/////////////////////////////////////////////////////////////////////////////
// Event map

BEGIN_EVENT_MAP(CCertAuthCtrl, COleControl)
    //{{AFX_EVENT_MAP(CCertAuthCtrl)
    EVENT_STOCK_CLICK()
    //}}AFX_EVENT_MAP
END_EVENT_MAP()


/////////////////////////////////////////////////////////////////////////////
// Property pages

// TODO: Add more property pages as needed.  Remember to increase the count!
BEGIN_PROPPAGEIDS(CCertAuthCtrl, 2)
    PROPPAGEID(CCertAuthPropPage::guid)
    PROPPAGEID(CLSID_CFontPropPage)
END_PROPPAGEIDS(CCertAuthCtrl)


/////////////////////////////////////////////////////////////////////////////
// Initialize class factory and guid

IMPLEMENT_OLECREATE_EX(CCertAuthCtrl, "CERTMAP.CertmapCtrl.2",
    0x996ff6f, 0xb6a1, 0x11d0, 0x92, 0x92, 0, 0xc0, 0x4f, 0xb6, 0x67, 0x8b)


/////////////////////////////////////////////////////////////////////////////
// Type library ID and version

IMPLEMENT_OLETYPELIB(CCertAuthCtrl, _tlid, _wVerMajor, _wVerMinor)


/////////////////////////////////////////////////////////////////////////////
// Interface IDs

const IID BASED_CODE IID_DCertAuth =
        { 0x996ff6d, 0xb6a1, 0x11d0, { 0x92, 0x92, 0, 0xc0, 0x4f, 0xb6, 0x67, 0x8b } };
const IID BASED_CODE IID_DCertAuthEvents =
        { 0x996ff6e, 0xb6a1, 0x11d0, { 0x92, 0x92, 0, 0xc0, 0x4f, 0xb6, 0x67, 0x8b } };


/////////////////////////////////////////////////////////////////////////////
// Control type information

static const DWORD BASED_CODE _dwCertAuthOleMisc =
    OLEMISC_ACTIVATEWHENVISIBLE |
    OLEMISC_SETCLIENTSITEFIRST |
    OLEMISC_INSIDEOUT |
    OLEMISC_CANTLINKINSIDE |
    OLEMISC_RECOMPOSEONRESIZE;

IMPLEMENT_OLECTLTYPE(CCertAuthCtrl, IDS_CERTAUTH, _dwCertAuthOleMisc)


/////////////////////////////////////////////////////////////////////////////
// CCertAuthCtrl::CCertAuthCtrlFactory::UpdateRegistry -
// Adds or removes system registry entries for CCertAuthCtrl

BOOL CCertAuthCtrl::CCertAuthCtrlFactory::UpdateRegistry(BOOL bRegister)
    {
    if (bRegister)
        return AfxOleRegisterControlClass(
            AfxGetInstanceHandle(),
            m_clsid,
            m_lpszProgID,
            IDS_CERTAUTH,
            IDB_CERTAUTH,
            afxRegApartmentThreading,
            _dwCertAuthOleMisc,
            _tlid,
            _wVerMajor,
            _wVerMinor);
    else
        return AfxOleUnregisterClass(m_clsid, m_lpszProgID);
    }


/////////////////////////////////////////////////////////////////////////////
// CCertAuthCtrl::CCertAuthCtrl - Constructor

CCertAuthCtrl::CCertAuthCtrl():
    m_fUpdateFont( FALSE ),
    m_hAccel( NULL ),
    m_cAccel( 0 )
    {
    InitializeIIDs(&IID_DCertAuth, &IID_DCertAuthEvents);
    }


/////////////////////////////////////////////////////////////////////////////
// CCertAuthCtrl::~CCertAuthCtrl - Destructor

CCertAuthCtrl::~CCertAuthCtrl()
    {
     if ( m_hAccel )
        DestroyAcceleratorTable( m_hAccel );

        m_hAccel = NULL;

    }


/////////////////////////////////////////////////////////////////////////////
// CCertAuthCtrl::OnDraw - Drawing function

void CCertAuthCtrl::OnDraw(
            CDC* pdc, const CRect& rcBounds, const CRect& rcInvalid)
    {
    CFont* pOldFont;
    pOldFont = SelectStockFont( pdc );
    DoSuperclassPaint(pdc, rcBounds);
    pOldFont = pdc->SelectObject(pOldFont);
    if ( m_fUpdateFont )
        {
        m_fUpdateFont = FALSE;
        CWnd::SetFont( pOldFont );
        }
    }


/////////////////////////////////////////////////////////////////////////////
// CCertAuthCtrl::DoPropExchange - Persistence support

void CCertAuthCtrl::DoPropExchange(CPropExchange* pPX)
    {
    ExchangeVersion(pPX, MAKELONG(_wVerMinor, _wVerMajor));
    COleControl::DoPropExchange(pPX);
    }


/////////////////////////////////////////////////////////////////////////////
// CCertAuthCtrl::OnResetState - Reset control to default state

void CCertAuthCtrl::OnResetState()
    {
    COleControl::OnResetState();  // Resets defaults found in DoPropExchange
    }


/////////////////////////////////////////////////////////////////////////////
// CCertAuthCtrl::AboutBox - Display an "About" box to the user

void CCertAuthCtrl::AboutBox()
    {
    }


/////////////////////////////////////////////////////////////////////////////
// CCertAuthCtrl message handlers

//---------------------------------------------------------------------------
BOOL CCertAuthCtrl::PreCreateWindow(CREATESTRUCT& cs) 
    {
    if ( cs.style & WS_CLIPSIBLINGS )
        cs.style ^= WS_CLIPSIBLINGS;
    cs.lpszClass = _T("BUTTON");
    return COleControl::PreCreateWindow(cs);
    }



/////////////////////////////////////////////////////////////////////////////
// CAppsCtrl::IsSubclassedControl - This is a subclassed control

BOOL CCertAuthCtrl::IsSubclassedControl()
    {
    return TRUE;
    }



/////////////////////////////////////////////////////////////////////////////
// OnOcmCommand - Handle command messages

LRESULT CCertAuthCtrl::OnOcmCommand(WPARAM wParam, LPARAM lParam)
{
#ifdef _WIN32
    WORD wNotifyCode = HIWORD(wParam);
#else
    WORD wNotifyCode = HIWORD(lParam);
#endif
    return 0;
}


extern void test__non2Rons_WizClasses();

void CCertAuthCtrl::OnClick(USHORT iButton) 
{

    COleControl::OnClick(iButton);
}

//---------------------------------------------------------------------------
void CCertAuthCtrl::SetServerInstance(LPCTSTR szServerInstance) 
    {
    m_szServerInstance = szServerInstance;
    }

//---------------------------------------------------------------------------
void CCertAuthCtrl::SetMachineName(LPCTSTR szMachine) 
    {
    m_szMachineName = szMachine;
    }


//---------------------------------------------------------------------------
void CCertAuthCtrl::OnFontChanged() 
    {
    m_fUpdateFont = TRUE;
    COleControl::OnFontChanged();
    }
//---------------------------------------------------------------------------
void CCertAuthCtrl::OnAmbientPropertyChange(DISPID dispid) 
    {
    BOOL    flag;
    UINT    style;

    switch ( dispid )
        {
        case DISPID_AMBIENT_DISPLAYASDEFAULT:
            if ( GetAmbientProperty( DISPID_AMBIENT_DISPLAYASDEFAULT, VT_BOOL, &flag ) )
                {
                style = GetWindowLong(
                        GetSafeHwnd(), // handle of window 
                        GWL_STYLE  // offset of value to retrieve 
                        );
                if ( flag )
                    style |= BS_DEFPUSHBUTTON;
                else
                    style ^= BS_DEFPUSHBUTTON;
                SetWindowLong(
                        GetSafeHwnd(), // handle of window 
                        GWL_STYLE,  // offset of value to retrieve 
                        style
                        );
                Invalidate(TRUE);
                }
            break;
        };

    COleControl::OnAmbientPropertyChange(dispid);
    }

void CCertAuthCtrl::OnGetControlInfo(LPCONTROLINFO pControlInfo) 
    {
    if ( !pControlInfo || pControlInfo->cb < sizeof(CONTROLINFO) )
        return;

    pControlInfo->hAccel = m_hAccel;
    pControlInfo->cAccel = m_cAccel;

    pControlInfo->dwFlags = CTRLINFO_EATS_RETURN;
    }

void CCertAuthCtrl::OnKeyUpEvent(USHORT nChar, USHORT nShiftState) 
    {
    if ( nChar == _T(' ') )
        {
        OnClick((USHORT)GetDlgCtrlID());
        }
    COleControl::OnKeyUpEvent(nChar, nShiftState);
    }

//---------------------------------------------------------------------------
void CCertAuthCtrl::OnMnemonic(LPMSG pMsg) 
    {
    OnClick((USHORT)GetDlgCtrlID());
    COleControl::OnMnemonic(pMsg);
    }

//---------------------------------------------------------------------------
void CCertAuthCtrl::OnTextChanged() 
    {
    DWORD   i;
    ACCEL   accel;
    BOOL    f;
    BOOL    flag;
    int     iAccel;

    // get the new text
    CString sz = InternalGetText();
    sz.MakeLower();

    if ( m_hAccel )
        {
        DestroyAcceleratorTable( m_hAccel );
        m_hAccel = NULL;
        m_cAccel = 0;
        }

    iAccel = sz.Find(_T('&'));
    if ( iAccel >= 0 )
        {
        accel.fVirt = FALT;
        accel.key = sz.GetAt(iAccel + 1);
        accel.cmd = (WORD)GetDlgCtrlID();

        m_hAccel = CreateAcceleratorTable( &accel, 1 );
        if ( m_hAccel )
            m_cAccel = 1;
        }

    COleControl::OnTextChanged();
    }

void CCertAuthCtrl::DoClick(IN  long dwButtonNumber) 
{
    OnClick( (short) dwButtonNumber );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\certmap\authppg.cpp ===
// CertAuthPpg.cpp : Implementation of the CCertAuthPropPage property page class.

#include "stdafx.h"
#include "certmap.h"
#include "AuthPpg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


IMPLEMENT_DYNCREATE(CCertAuthPropPage, COlePropertyPage)


/////////////////////////////////////////////////////////////////////////////
// Message map

BEGIN_MESSAGE_MAP(CCertAuthPropPage, COlePropertyPage)
    //{{AFX_MSG_MAP(CCertAuthPropPage)
    // NOTE - ClassWizard will add and remove message map entries
    //    DO NOT EDIT what you see in these blocks of generated code !
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// Initialize class factory and guid

IMPLEMENT_OLECREATE_EX(CCertAuthPropPage, "CERTMAP.CertmapCtrl.2",
    0x996ff70, 0xb6a1, 0x11d0, 0x92, 0x92, 0, 0xc0, 0x4f, 0xb6, 0x67, 0x8b)


/////////////////////////////////////////////////////////////////////////////
// CCertAuthPropPage::CCertAuthPropPageFactory::UpdateRegistry -
// Adds or removes system registry entries for CCertAuthPropPage

BOOL CCertAuthPropPage::CCertAuthPropPageFactory::UpdateRegistry(BOOL bRegister)
{
    if (bRegister)
        return AfxOleRegisterPropertyPageClass(AfxGetInstanceHandle(),
            m_clsid, IDS_CERTAUTH_PPG);
    else
        return AfxOleUnregisterClass(m_clsid, NULL);
}


/////////////////////////////////////////////////////////////////////////////
// CCertAuthPropPage::CCertAuthPropPage - Constructor

CCertAuthPropPage::CCertAuthPropPage() :
    COlePropertyPage(IDD, IDS_CERTAUTH_PPG_CAPTION)
{
    //{{AFX_DATA_INIT(CCertAuthPropPage)
    m_sz_caption = _T("");
    //}}AFX_DATA_INIT
}


/////////////////////////////////////////////////////////////////////////////
// CCertAuthPropPage::DoDataExchange - Moves data between page and properties

void CCertAuthPropPage::DoDataExchange(CDataExchange* pDX)
{
    //{{AFX_DATA_MAP(CCertAuthPropPage)
    DDP_Text(pDX, IDC_CAPTIONEDIT, m_sz_caption, _T("Caption") );
    DDX_Text(pDX, IDC_CAPTIONEDIT, m_sz_caption);
    //}}AFX_DATA_MAP
    DDP_PostProcessing(pDX);
}


/////////////////////////////////////////////////////////////////////////////
// CCertAuthPropPage message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\certmap\authctl.h ===
// AuthCtl.h : Declaration of the CCertAuthCtrl OLE control class.

#ifndef  _AuthCtl_h_12375_
#define  _AuthCtl_h_12375_

//#include "NKChseCA.h"

//#include <wincrypt.h>
// #include "Certifct.h"
// #include "dlgs.h"
// #include "SelAcct.h"
// #include "FindDlg.h"
// #include "wintrust.h"
//#include <cryptui.h>

/////////////////////////////////////////////////////////////////////////////
// CCertAuthCtrl : See AuthCtl.cpp for implementation.

class CCertAuthCtrl : public COleControl
{
    DECLARE_DYNCREATE(CCertAuthCtrl)

// Constructor
public:
    CCertAuthCtrl();

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CCertAuthCtrl)
    public:
    virtual void OnDraw(CDC* pdc, const CRect& rcBounds, const CRect& rcInvalid);
    virtual void DoPropExchange(CPropExchange* pPX);
    virtual void OnResetState();
    virtual void OnClick(USHORT iButton);
    virtual void OnFontChanged();

#ifdef FUTURE_USE
    // tompop: some experimental code for testing
    virtual HRESULT LaunchCommonCTLDialog (CCTL* pCTL);
#endif /* FUTURE_USE */

    protected:
    virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
    //}}AFX_VIRTUAL

// Implementation
protected:
    ~CCertAuthCtrl();

    DECLARE_OLECREATE_EX(CCertAuthCtrl)    // Class factory and guid
    DECLARE_OLETYPELIB(CCertAuthCtrl)      // GetTypeInfo
    DECLARE_PROPPAGEIDS(CCertAuthCtrl)     // Property page IDs
    DECLARE_OLECTLTYPE(CCertAuthCtrl)       // Type name and misc status

// Message maps
    //{{AFX_MSG(CCertAuthCtrl)
        // NOTE - ClassWizard will add and remove member functions here.
        //    DO NOT EDIT what you see in these blocks of generated code !
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

// Dispatch maps
    //{{AFX_DISPATCH(CCertAuthCtrl)
    afx_msg void SetMachineName(LPCTSTR szMachineName);
    afx_msg void SetServerInstance(LPCTSTR szServerInstance);
    afx_msg void DoClick(long dwButtonNumber);
    //}}AFX_DISPATCH
    DECLARE_DISPATCH_MAP()

    afx_msg void AboutBox();

// Event maps
    //{{AFX_EVENT(CCertAuthCtrl)
    //}}AFX_EVENT
    DECLARE_EVENT_MAP()
    
    // Subclassed control support
    BOOL IsSubclassedControl();
    LRESULT OnOcmCommand(WPARAM wParam, LPARAM lParam);


//    void NKAddPageToWizard(IN ADMIN_INFO& info, IN CNKPages* nkpg2Add, IN OUT CPropertySheet* psWizard);

// Dispatch and event IDs
public:
    enum {
    //{{AFX_DISP_ID(CCertAuthCtrl)
    dispidSetMachineName = 1L,
    dispidSetServerInstance = 2L,
    //}}AFX_DISP_ID
    };
    
    ////////////////////////////////////////////////////////////////////////
    // run the dialogs used in this active X control.
    //  Big picture:  OnClick(USHORT iButton) will do all the setup for
    //  activeX controls and then call RunDialogs4OnClick that has the
    // tasks of setting up the MetaBase ptr and call the _RunDialogs4OnClick
    // routine that does all the work...
    //
    // The above 'RunDialogs4OnClick()' calls us inside of a try/catch
    // block to protect the metabase
    ////////////////////////////////////////////////////////////////////////
//    BOOL RunDialogs4OnClick(USHORT iButton);
    
    ////////////////////////////////////////////////////////////////////////
    //  _RunDialogs4OnClick -- main handler for our dialogs
    //
    //  Parms:  info:    holds the information database for out ActiveX cntrol
    //                   By this time its member m_mbWrap holds the MetaBase Wrapper
    //                   that is properly initialized
    //                   and points to the SERVER node that we are operating in.
    //          iButton: tells what "logical button" fired our control:
    //                   0=Get-Cert     1=Edit
    ////////////////////////////////////////////////////////////////////////
//    BOOL  _RunDialogs4OnClick(ADMIN_INFO& info, USHORT iButton);

    /////////////////////////////////////////////////////////////////////
    // Automation defined methods
    /////////////////////////////////////////////////////////////////////
    void OnAmbientPropertyChange(DISPID dispid) ;
    void OnTextChanged();
    void OnMnemonic(LPMSG pMsg); 
    void OnGetControlInfo(LPCONTROLINFO pControlInfo); 
    void OnKeyUpEvent(USHORT nChar, USHORT nShiftState); 
    
    CString     m_szServerInstance;
    CString     m_szMachineName;
    BOOL        m_fUpdateFont;
    CString     m_szOurApplicationTitle; // set in OnClick()
 
        // the accelerator table
    HACCEL  m_hAccel;
    WORD    m_cAccel;

};


#endif /* _AuthCtl_h_12375_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\certmap\cauthdlg.h ===
// CAuthDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CClientAuthoritiesDialog dialog

class CClientAuthoritiesDialog : public CDialog
{
// Construction
public:
    CClientAuthoritiesDialog(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
    //{{AFX_DATA(CClientAuthoritiesDialog)
    enum { IDD = IDD_CLIENT_AUTHORITIES };
        // NOTE: the ClassWizard will add data members here
    //}}AFX_DATA


// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CClientAuthoritiesDialog)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:

    // Generated message map functions
    //{{AFX_MSG(CClientAuthoritiesDialog)
    afx_msg void OnViewCertificate();
    afx_msg void OnDelete();
    afx_msg void OnAdd();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\certmap\brwsdlg.cpp ===
/*++

Module Name:

    brwsdlg.cpp

Abstract:

    Intermediate dialog class that provides basic NT user account browsing.
    It assumes that the dialog resource contains BOTH a IDC_BROWSE button
    and a IDC_ACCOUNT_NAME edit field. It maintains both of these items.

Author:

   Boyd Multerer boydm

--*/

#include "stdafx.h"
#include "certmap.h"
#include "brwsdlg.h"
#include "cnfrmpsd.h"


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CEditOne11MapDlg dialog

//---------------------------------------------------------------------------
CNTBrowsingDialog::CNTBrowsingDialog( UINT nIDTemplate, CWnd* pParentWnd )
    : CDialog( nIDTemplate, pParentWnd )
    {
    //{{AFX_DATA_INIT(CNTBrowsingDialog)
    m_sz_accountname = _T("");
    m_sz_password = _T("");
    //}}AFX_DATA_INIT
    }

//---------------------------------------------------------------------------
void CNTBrowsingDialog::DoDataExchange(CDataExchange* pDX)
    {
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CNTBrowsingDialog)
    DDX_Control(pDX, IDC_PASSWORD, m_cedit_password);
    DDX_Control(pDX, IDC_NTACCOUNT, m_cedit_accountname);
    DDX_Text(pDX, IDC_NTACCOUNT, m_sz_accountname);
    DDX_Text(pDX, IDC_PASSWORD, m_sz_password);
    //}}AFX_DATA_MAP
//  DDX_Control(pDX, IDC_PASSWORD, m_cedit_password);
    }

//---------------------------------------------------------------------------
BEGIN_MESSAGE_MAP(CNTBrowsingDialog, CDialog)
    //{{AFX_MSG_MAP(CNTBrowsingDialog)
    ON_BN_CLICKED(IDC_BROWSE, OnBrowse)
    ON_EN_CHANGE(IDC_PASSWORD, OnChangePassword)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CNTBrowsingDialog message handlers


//---------------------------------------------------------------------------
BOOL CNTBrowsingDialog::OnInitDialog()
  {
    m_bPassTyped = FALSE;
    m_szOrigPass = m_sz_password;
    if ( !m_sz_password.IsEmpty() ) 
    {
        m_sz_password.LoadString( IDS_SHOWN_PASSWORD );
    }
    return CDialog::OnInitDialog();
  }

//---------------------------------------------------------------------------
// run the user browser
void CNTBrowsingDialog::OnBrowse() 
{
   TCHAR * pUser = m_sz_accountname.GetBuffer(MAX_PATH);
   GetIUsrAccount(NULL, this, pUser, MAX_PATH);
   m_sz_accountname.ReleaseBuffer(-1);
   UpdateData(FALSE);
}

//---------------------------------------------------------------------------
// make sure that the selected NT acount is, in fact, a valid account
// 
void CNTBrowsingDialog::OnOK() 
    {
    // update the data
    UpdateData( TRUE );

    // see if the account name is empty
    if ( m_sz_accountname.IsEmpty() )
        {
        AfxMessageBox( IDS_WANTACCOUNT );
        m_cedit_accountname.SetFocus();
        m_cedit_accountname.SetSel(0, -1);
        return;
        }

    // validate the password
    if ( m_bPassTyped )
        {
        CConfirmPassDlg dlgPass;
        dlgPass.m_szOrigPass = m_sz_password;
        if ( dlgPass.DoModal() != IDOK )
            {
            m_cedit_password.SetFocus();
            m_cedit_password.SetSel(0, -1);
            return;
            }
        }
    else
        {
        // restore the original password instead of the
        // standard ****** string
        m_sz_password = m_szOrigPass;
        UpdateData( FALSE );
        }


    // although it would seem to be a nice thing to do to verify the password and
    // account - it is VERY difficult, if not impossible, to do on a remote machine

    // it is valid
    CDialog::OnOK();
    }

//---------------------------------------------------------------------------
void CNTBrowsingDialog::OnChangePassword() 
    {
    // TODO: If this is a RICHEDIT control, the control will not
    // send this notification unless you override the CNTBrowsingDialog::OnInitDialog()
    // function to send the EM_SETEVENTMASK message to the control
    // with the ENM_CHANGE flag ORed into the lParam mask.
    m_bPassTyped = TRUE;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\certmap\certctl.h ===
// CertCtl.h : Declaration of the CCertmapCtrl OLE control class.

/////////////////////////////////////////////////////////////////////////////
// CCertmapCtrl : See CertCtl.cpp for implementation.

class CCertmapCtrl : public COleControl
{
    DECLARE_DYNCREATE(CCertmapCtrl)

// Constructor
public:
    CCertmapCtrl();

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CCertmapCtrl)
    public:
    virtual void OnDraw(CDC* pdc, const CRect& rcBounds, const CRect& rcInvalid);
    virtual void DoPropExchange(CPropExchange* pPX);
    virtual void OnResetState();
    virtual void OnClick(USHORT iButton);
    virtual void OnFontChanged();
    virtual void OnAmbientPropertyChange(DISPID dispid);
    virtual void OnGetControlInfo(LPCONTROLINFO pControlInfo);
    virtual void OnKeyUpEvent(USHORT nChar, USHORT nShiftState);
    virtual void OnMnemonic(LPMSG pMsg);
    virtual void OnTextChanged();
    protected:
    virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
    //}}AFX_VIRTUAL

// Implementation
protected:
    ~CCertmapCtrl();

    // the whole point of the control
    void RunMappingDialog();


    DECLARE_OLECREATE_EX(CCertmapCtrl)    // Class factory and guid
    DECLARE_OLETYPELIB(CCertmapCtrl)      // GetTypeInfo
    DECLARE_PROPPAGEIDS(CCertmapCtrl)     // Property page IDs
    DECLARE_OLECTLTYPE(CCertmapCtrl)        // Type name and misc status

// Message maps
    //{{AFX_MSG(CCertmapCtrl)
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

// Dispatch maps
    //{{AFX_DISPATCH(CCertmapCtrl)
    afx_msg void SetServerInstance(LPCTSTR szServerInstance);
    afx_msg void SetMachineName(LPCTSTR szMachineName);
    //}}AFX_DISPATCH
    DECLARE_DISPATCH_MAP()

// Event maps
    //{{AFX_EVENT(CCertmapCtrl)
    //}}AFX_EVENT
    DECLARE_EVENT_MAP()

    // Subclassed control support
    BOOL IsSubclassedControl();
    LRESULT OnOcmCommand(WPARAM wParam, LPARAM lParam);

// Dispatch and event IDs
public:
    enum {
    //{{AFX_DISP_ID(CCertmapCtrl)
    dispidSetServerInstance = 1L,
    dispidSetMachineName = 2L,
    //}}AFX_DISP_ID
    };

    CString     m_szServerInstance;
    CString     m_szMachineName;
    BOOL        m_fUpdateFont;

        // the accelerator table
    HACCEL  m_hAccel;
    WORD    m_cAccel;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\certmap\brwsdlg.h ===
//--------------------------------------------------------
class CNTBrowsingDialog : public CDialog
    {
    public:

    // construct / deconstruct
    CNTBrowsingDialog( UINT nIDTemplate, CWnd* pParentWnd = NULL );

    // overrides
    virtual void OnOK();
    virtual BOOL OnInitDialog();

// Dialog Data
    //{{AFX_DATA(CEditOne11MapDlg)
    CEdit   m_cedit_password;
    CEdit   m_cedit_accountname;
    CString m_sz_accountname;
    CString m_sz_password;
    //}}AFX_DATA

//  CEdit   m_cedit_password;

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CNTBrowsingDialog)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:

    // Generated message map functions
    //{{AFX_MSG(CNTBrowsingDialog)
    afx_msg void OnBrowse();
    afx_msg void OnChangePassword();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

    CString m_szOrigPass;
    BOOL    m_bPassTyped;
    };
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\certmap\certmap.cpp ===
// certmap.cpp : Implementation of CCertmapApp and DLL registration.
                           
#include "stdafx.h"
#include "certmap.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


CCertmapApp /*NEAR*/ theApp;    // tompop: does this have to be near?  We are now getting errors when we finish refering to this var's addr

const GUID CDECL BASED_CODE _tlid =
        { 0xbbd8f298, 0x6f61, 0x11d0, { 0xa2, 0x6e, 0x8, 0, 0x2b, 0x2c, 0x6f, 0x32 } };
const WORD _wVerMajor = 1;
const WORD _wVerMinor = 0;

//--------------------------------------------------------------------------
void CCertmapApp::WinHelp(DWORD dwData, UINT nCmd )
    {
    COleControlModule::WinHelp(dwData,nCmd);
    }

////////////////////////////////////////////////////////////////////////////
// CCertmapApp::InitInstance - DLL initialization

BOOL CCertmapApp::InitInstance()
    {
    BOOL bInit = COleControlModule::InitInstance();

    // init ole stuff
    HRESULT hRes = CoInitialize(NULL);

    // finally, we need to redirect the winhelp file location to something more desirable
    CString sz;
    CString szHelpLocation;
    sz.LoadString( IDS_HELPLOC_PWSHELP );
    
    // expand the path
    ExpandEnvironmentStrings(
        sz,                                     // pointer to string with environment variables 
        szHelpLocation.GetBuffer(MAX_PATH + 1), // pointer to string with expanded environment variables  
        MAX_PATH                                // maximum characters in expanded string 
       );
    szHelpLocation.ReleaseBuffer();

    // free the existing path, and copy in the new one
    if ( m_pszHelpFilePath )
        free((void*)m_pszHelpFilePath);
    m_pszHelpFilePath = _tcsdup(szHelpLocation);

    return bInit;
    }


////////////////////////////////////////////////////////////////////////////
// CCertmapApp::ExitInstance - DLL termination
// tjp:  note that in 'CCertmapApp::InitInstance()' we add our help file to the
//       help path.  do we need to remove it on clean up here?
int CCertmapApp::ExitInstance()
    {
    CoUninitialize();
    return COleControlModule::ExitInstance();
    }


/////////////////////////////////////////////////////////////////////////////
// MigrateGUIDS - does all the GUID migration work. We pass back the
// return value of True iff we find GUIDs in the registry and migrate
// them to the metabase.
//
// We are called by top level fnct: InstallCertServerGUIDs that creates
// our 'info' structure and handles all the metabase init work.
/////////////////////////////////////////////////////////////////////////////
//  This code is written in response to bug # 167410.
//
//  This fix will handle all the GUID migration work, moving GUIDS that
//  CertServer placed in the registry into the metabase for Beta2. 
//  A more general install/deinstall mechanism for products that
//  work with IIS will be come post-Beta2.
//
//  DETAILS:
//  --------
//  
//   We look for evidence of CertServer by examing the Registry because
//   CertServer will write some entries under:
//   HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\KeyRing\Parameters\Certificate 
//         Authorities\Microsoft Certificate Server
//  
//    CertServer currently outputs:
//         CertGetConfig   "{C6CC49B0-CE17-11D0-8833-00A0C903B83C}"
//         CertRequest "{98AFF3F0-5524-11D0-8812-00A0C903B83C}"
//  
//    If we see the manditory 'CertRequest' entry, we will load as many strings
//    as we find, while defaulting the ones that are missing. See below
//    for the equivalent mdutil commands for what defaults are used
//  
//        => if we dont find  'CertRequest' we give up [meaning remove
//          any present MB GUID string entries]
//  
//   When we find that CertServer is installed, we dont fully believe that
//   certserver is still there.  To prove that its there we will do a
//   CoCreateInstance on CertConfig. If that works we install metabase
//   entries that are the equivalent of the following mdutil commands:
//  
//   ## ICERTGETCONFIG default setting:
//   mdutil SET "w3svc/CertServers/Microsoft Certificate Server" -dtype:STRING -
//    -utype:UT_SERVER -prop 5571 -value "{C6CC49B0-CE17-11D0-8833-00A0C903B83C}"
//   
//   ## ICERTREQUEST default setting:
//   mdutil SET "w3svc/CertServers/Microsoft Certificate Server" -dtype:STRING 
//    -utype:UT_SERVER -prop 5572 -value "{98AFF3F0-5524-11D0-8812-00A0C903B83C}"
//   
//   ## ICERTCONFIG default setting:
//   mdutil SET "w3svc/CertServers/Microsoft Certificate Server" -dtype:STRING 
//    -utype:UT_SERVER -prop 5574 -value "{372fce38-4324-11d0-8810-00a0c903b83c}"
//  
//   If the CoCreateInstance fails, we give up and remove MB GUID entries.
//  
//  ---------------------------------------------------------------
//   NOTE that we will either install or DE-install the metabase
//        GUID strings based on its decision that CertServer is present.
//        If we find GUID strings in the metabase but can not do a 
//        CoCreateInstance on CertConfig:
//          we remove them so that the rest of CertWizard will see CertServer
//          Guids iff we can use CertServer.
//  ---------------------------------------------------------------
//  NOTE also that if we make a decision to install GUID strings
//       into the metabase, we honor/preserve any present GUID strings that
//       are present in the metabase.
//  ---------------------------------------------------------------
//
/////////////////////////////////////////////////////////////////////////////


/*ddddddddddddddd
BOOL  MigrateGUIDS( ADMIN_INFO& info )
{
    BOOL   bRet = FALSE;                          // value to return, set to F
                                                  //  for defensive reasons.
    BOOL   bFoundCertSrvRegistryEntries = FALSE;  // assume false for now

    TCHAR* szRegPath = _T("SOFTWARE\\Microsoft\\KeyRing\\Parameters\\Certificate Authorities\\Microsoft Certificate Server");

    //-----------------------------------------------------------------------
    // In each of the following 3 sets of parameters, we have (1) a string
    // like "CertRequest" that CertServer uses in the registry, (2) a default
    // value to use like  "{98AFF3F0-5524-11D0-8812-00A0C903B83C}"  that we
    // use if we can not find anything in the registry, and (3) a CString
    // to hold the GUID.   The value in the CString will be stored in the MB.
    //-----------------------------------------------------------------------

    // CertRequest - variables
    TCHAR* szCertRequest = _T("CertRequest");
    TCHAR* szCertRequestGUIDdefault = _T( "{98AFF3F0-5524-11D0-8812-00A0C903B83C}" );
    CString szCertRequestGUID;

    // CertConfig - variables
    TCHAR* szCertConfig = _T("CertConfig");
    TCHAR* szCertConfigGUIDdefault = _T( "{372fce38-4324-11d0-8810-00a0c903b83c}" );
    CString szCertConfigGUID;

    // CertGetConfig - variables
    TCHAR* szCertGetConfig = _T("CertGetConfig");
    TCHAR* szCertGetConfigGUIDdefault = _T( "{C6CC49B0-CE17-11D0-8833-00A0C903B83C}");
    CString szCertGetConfigGUID;


    CString  szCertServerMetabaseRoot( SZ_ROOT_CERT_SERV_MB_PATH );
                // SZ_ROOT_CERT_SERV_MB_PATH = "/LM/W3SVC/CertServers"

    szCertServerMetabaseRoot += _T("/Microsoft Certificate Server");

#ifdef  DEBUGGING
    CEditDialog  dlg(szCertServerMetabaseRoot,
                _T("use this to test adding new CertServer entries."
                   " In order for us to install a new key you have to change the path"
                   " below to something [strange] and not already in the metabase."));
    dlg.DoModal();
#endif    
    
    // the following string will be restored into info.szMetaBasePath before
    // we exit this fnct.  We switch out the [info.szMetaBasePath] so that
    // we can use our native Set/Get metabase string fncts.
    // We switch it to: "/LM/W3SVC/CertServers/Microsoft Certificate Server" 
    //
    CString  szSaved_info_szMetaBasePath( info.szMetaBasePath  );
    
    info.szMetaBasePath =   szCertServerMetabaseRoot;


    // if we dont find HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\KeyRing\Parameters\
    // Certificate Authorities\Microsoft Certificate Server"
    // with key: CertRequest  quit!   CertServer should have installed this.
    // We are forgiving about the other 2 Registry GUID strings
    //-------------------------------------------------------------------------
    if (   Reg::GetNameValueIn( szRegPath,      szCertRequest,
                                szCertRequestGUID,  HKEY_LOCAL_MACHINE )) {
           bFoundCertSrvRegistryEntries = TRUE;
    }
    if (!  Reg::GetNameValueIn( szRegPath,      szCertConfig,
                                szCertConfigGUID,  HKEY_LOCAL_MACHINE )) {
           szCertConfigGUID = szCertConfigGUIDdefault; // assign default
    }
    if (!  Reg::GetNameValueIn( szRegPath,      szCertGetConfig,
                                szCertGetConfigGUID,  HKEY_LOCAL_MACHINE )) {
           szCertGetConfigGUID = szCertGetConfigGUIDdefault; // assign default
    }

    //------------------------------------------------------------------------
    // First lets try to create the directory path: the user might have
    // deleted it or this might be a virgin machine.
    //------------------------------------------------------------------------
    {
        CWrapMetaBase& MB = info.meta.m_mbWrap; // this is the MetaBase Wrapper
                                                // its already been openned by
                                                // openMetaDataForWrite

        if ( FALSE == openMetaDataForWrite(info,  FALSE) ) {

           if (ERROR_PATH_NOT_FOUND == HRESULT_CODE( MB.getHRESULT() )) {
            // lets create the path in the metabase, using AddObject.
            // recursively creates a "pathway in the metabase". E.g. assume that you
            // want to make sure that "/LM/W3SVC/CertServers/Microsoft Certificate Server"
            // is in the metabase.  you can open /LM/W3SVC and do a AddKey() on
            // "CertServers/Microsoft Certificate Server" to create that stub.

            // above we set:  info.szMetaBasePath =   szCertServerMetabaseRoot
            // here we will temporarily pretend that our root is at level
            // /LM/W3SVC  which we assume is at the top of szCertServerMetabaseRoot
            // and then call AddKey

            TCHAR  szPath[400];
            TCHAR* szRootPrefix = _T("/LM/W3SVC");
            UINT   nRootPrefixLen = STRLEN(szRootPrefix);
            
            STRCPY(szPath, szCertServerMetabaseRoot);

            if (STRNICMP(szRootPrefix, szPath, nRootPrefixLen) != 0) 
               goto returnFALSE;    // we could not figure out a common Root

            info.szMetaBasePath = szRootPrefix;
            if ( FALSE == openMetaDataForWrite(info) )
               goto returnFALSE;    // we could not open the metabase

            // the metabase path is already position to the proper directory
            // in the MB object.  MB will prepend that path to the subDirectory
            // that we want to create, the following will jump past the trailing
            // '/' separating the root and the rest of the sub-directory
            // e.g. "/CertServers/Microsoft Certificate Server"
            //
            // We dont do any other error checking besides notifying and
            // returning FALSE.
            
            if (FALSE == MB.AddObject( &szPath[nRootPrefixLen] )) {
                NotifyUsers_CouldNotAccessMetaBase( MB.getHRESULT() );
                goto returnFALSE;    // we could not create required path
            }

            // since we are continuing, we reset back our proper path.
            info.szMetaBasePath =   szCertServerMetabaseRoot;
               
           } else {
           
               goto returnFALSE;    // we could not open the metabase
           }
        }



    }

    //------------------------------------------------------------------------
    // Below we dont deal with the XENROLL GUID setting that is for future usage
    // PLUS its not CertServer Related, its Xenroll related.  We dont touch it.
    //------------------------------------------------------------------------
    {

        // lets see if we can do a CoCreateInstance on CertRequest.  If we can not
        // we believe that certServer is not installed and set/clear MB entries
        // The following values are set or cleared:
        //
        //  # define MD_SSL_CERT_WIZGUID_ICERTGETCONFIG ( IIS_MD_SSL_BASE+71 )
        //  # define MD_SSL_CERT_WIZGUID_ICERTREQUEST   ( IIS_MD_SSL_BASE+72 )
        //  # define MD_SSL_CERT_WIZGUID_XENROLL        ( IIS_MD_SSL_BASE+73 ) FUTURE USAGE
        //  # define MD_SSL_CERT_WIZGUID_ICERTCONFIG    ( IIS_MD_SSL_BASE+74 )
        //------------------------------------------------------------------------

        IPtr<ICertConfig, &IID_ICertConfig>  iptr;
        CString  szRemoteDCOMTargetMachine;
       
        // REMEMBER  bRet  returns whether we were able to delete everything
        //                 or set everything that we were wanting to set
        // in both cases assume now that we have success and update bRet when
        // we find errors, we continue as long as possible.  E.g. we add or delete
        // as many entries as possible and return our status value to the caller.

        bRet = TRUE;

           
        if ( (FALSE == bFoundCertSrvRegistryEntries)  ||

             (FALSE == GetICertConfigIPtrFromGuid( iptr, szCertConfigGUID,
                        &szRemoteDCOMTargetMachine)) )
        {
            // remove MB entries!

#ifdef  DEBUGGING
            DODBG  MsgBox( _T("adding CertServer MB entries"));
#endif

            if ( FALSE == openMetaDataForWrite(info) ) {
               goto returnFALSE;    // we could not open the metabase
            }

            //  We just need to blow away the cert info in the metabase
            //  which we do using the meta data wrapper
            // deleting values
            CWrapMetaBase& MB = info.meta.m_mbWrap; // this is the MetaBase Wrapper
                                                    // its already been openned by
                                                    // openMetaDataForWrite
            // try deletes once
            

            // In C++ &&= does not exist. However [bRet &= FALSE;] is OK, but we dont
            // have a uniform single value of TRUE in C/C++ so its not safe to use &=
            // to chain a set of TRUE-value
            //   so we can not do:
            //   bRet &&= MB.DeleteData(  _T(""),
            //                  MD_SSL_CERT_WIZGUID_ICERTGETCONFIG, STRING_METADATA);
            // so we will use a [if (! xxx) bRet=FALSE;]  construct below

            if (! MB.DeleteData(  _T(""),
                      MD_SSL_CERT_WIZGUID_ICERTGETCONFIG, STRING_METADATA))  bRet=FALSE;
            if (! MB.DeleteData(  _T(""),
                      MD_SSL_CERT_WIZGUID_ICERTREQUEST, STRING_METADATA))    bRet=FALSE;
            if (! MB.DeleteData(  _T(""),
                      MD_SSL_CERT_WIZGUID_ICERTCONFIG, STRING_METADATA))     bRet=FALSE;

            MB.Close();

        } else {
            
            CString   szPresentValue;        // used to read the present value
                                             // any metabase value so that we
                                             // can preserve it.

#ifdef  DEBUGGING
            DODBG MsgBox( _T("adding CertServer MB entries"));
#endif

            // add MB entries!   If an entry already exists, leave it alone.

            if (!  GetMetaBaseString ( info, 
                          IN  MD_SSL_CERT_WIZGUID_ICERTREQUEST,
                          IN       szPresentValue ) )
            {
              if (!SetMetaBaseString ( info,
                          IN  MD_SSL_CERT_WIZGUID_ICERTREQUEST,
                          IN       szCertRequestGUID ) )     bRet=FALSE;
            }

            if (!  GetMetaBaseString ( info, 
                          IN  MD_SSL_CERT_WIZGUID_ICERTCONFIG,
                          IN       szPresentValue ) )
            {
              if (!SetMetaBaseString ( info,
                          IN  MD_SSL_CERT_WIZGUID_ICERTCONFIG,
                          IN       szCertConfigGUID ) )      bRet=FALSE;
            }

            if (!  GetMetaBaseString ( info,  
                          IN  MD_SSL_CERT_WIZGUID_ICERTGETCONFIG,
                          IN       szPresentValue ) )
            {
              if (!SetMetaBaseString ( info,
                          IN  MD_SSL_CERT_WIZGUID_ICERTGETCONFIG,
                          IN       szCertGetConfigGUID ) )   bRet=FALSE;
            }

        }

    }
    
  commonReturn:         // this is the common return so that we an set
                        // back the metabase path.  We saved it so that
                        // we can switch to where the GUIDs live: 

    // the following will restore the original [info.szMetaBasePath] value
    // before we switched it to: "/LM/W3SVC/CertServers/..." 
    //
    info.szMetaBasePath =   szSaved_info_szMetaBasePath;

    return(bRet);


  returnFALSE:          // this will cause a FALSE return and do all things
                        // required in our "common return"

    bRet = FALSE;
    goto  commonReturn;   
}
*/

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    AFX_MANAGE_STATE(_afxModuleAddrThis);

    if (!AfxOleRegisterTypeLib(AfxGetInstanceHandle(), _tlid))
        return ResultFromScode(SELFREG_E_TYPELIB);

    if (!COleObjectFactoryEx::UpdateRegistryAll(TRUE))
        return ResultFromScode(SELFREG_E_CLASS);

    return NOERROR;
}


/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    AFX_MANAGE_STATE(_afxModuleAddrThis);

    if (!AfxOleUnregisterTypeLib(_tlid, _wVerMajor, _wVerMinor))
        return ResultFromScode(SELFREG_E_TYPELIB);

    if (!COleObjectFactoryEx::UpdateRegistryAll(FALSE))
        return ResultFromScode(SELFREG_E_CLASS);

    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\certmap\certmap.h ===
// certmap.h : main header file for CERTMAP.DLL

#if !defined( __AFXCTL_H__ )
    #error include 'afxctl.h' before including this file
#endif

#ifndef  _certmap_h_1234_
#define  _certmap_h_1234_


#include <iadmw.h>           // MetaBase Wrapper
#include <iis64.h>           // 64-bit helper stuff
#include "Wrapmb.h"          // CWrapMetaBase -- see below we also use CAFX_MetaWrapper
#include <iiscnfg.h>        // IIS config parameters like the MetaBase

// Boyd put a lot of efforts to make it hard to use iisui. Therefore I should
// put this declaration here instead of including the file
BOOL __declspec(dllimport)
GetIUsrAccount(
    IN  LPCTSTR lpstrServer,
    IN  CWnd * pParent,
	LPTSTR buf,
	int size
    );


/*
#include "Easy.h"           // do this before the "using namespace" decl

#include "Debug.h"           // Are we building a debugging build?
#include  "admin.h"         // defines the ADMIN_INFO an some handley #defines for the CN= strings


#include "Easy.h"           // do this before the "using namespace" decl
#include "Cookie.h"         // CCertmapCookie
#include "CTL.h"
#include "Certifct.h"

#include "WrpMBwrp.h"        // CAFX_MetaWrapper  derives from CWrapMetaBase
                             //  and provides a handy GetString method to set
                             //  strings directly.  Otherwise its CWrapMetaBase.

                            // property definitions and keywords
#include  "Meta.h"  // for general MetaBase constant definitions and error values


#include <wincrypt.h>
#include <cryptui.h>

//SkipThis// // We can not simply say:
//SkipThis// //    using namespace Easy;        // use the Easier to use
//SkipThis// // since the "less able" C++ compiler can not differentiate
//SkipThis// // between '::CString' and our Easier to use Easy::CString.  I wanted
//SkipThis// // Easy::CString to be used always and just say look in Easy first...
//SkipThis// //  This is easy to do w/ java by declaring a package and preInserting
//SkipThis// //  it in the class path ahead of the std libraries...
//SkipThis// 
//SkipThis// "#define  CString   Easy::CString"


        

//  Define  'USE_NEW_REG_METHOD'  if you  want us to use our new Reg::
//  methods to read and write strings to the registry...  The old code
//  that straight lines the calls to do this have sections like:
//   #ifdef  USE_NEW_REG_METHOD
//
//     //     Get entry in      ==path===      ==w/ name==    ==place here==
//     return Reg::GetNameValueIn(SZ_PARAMETERS, szValueName, sz,
//                               HKEY_CURRENT_USER);
//
//   #else   ////////////////////////////// use the old method ///////////////
//
//  so that you can choose whether to use the new method of the old one...
#define  USE_NEW_REG_METHOD



#include "Util.h"           // various utilites to help debug
*/

#include "resource.h"       // main symbols
#include "helpmap.h"       // main symbols


//#include "certcli.h"        // has ICertRequest COM interface definitions

/////////////////////////////////////////////////////////////////////////////
// CCertmapApp : See certmap.cpp for implementation.

class CCertmapApp : public COleControlModule
{
public:
    BOOL InitInstance();
    int ExitInstance();
    virtual void WinHelp(DWORD dwData, UINT nCmd = HELP_CONTEXT);
};



extern const GUID CDECL _tlid;
extern const WORD _wVerMajor;
extern const WORD _wVerMinor;
/*

#define _EXE_                //  We are building the EXE!
                             //  this is used in  "KeyObjs.h"  to
                             //  decide if we are importing or exporting
                             //  "KeyObjs.h" Classes.  We are the EXE,
                             //  aka the guy implementing the CService/etc objs.
#include "KeyObjs.h"
*/
#define         SZ_NAMESPACE_EXTENTION  "/<nsepm>"

/*
 extern void DisplaySystemError (HWND hParent, DWORD dwErr);  // see CTL.cpp
 extern BOOL MyGetOIDInfo (CString & string, LPCSTR pszObjId);
 extern HRESULT FormatDate (FILETIME utcDateTime, CString & pszDateTime);

 // the following fnct is used to move GUID strings out of the registry
 // and into the metabase.  Its called in the OnClick event for our OCX cntrl
 extern BOOL  MigrateGUIDS( ADMIN_INFO& info );

 #define   IDS_CERTIFICATE_MANAGER    IDS_CERTMAP
*/


#endif   /* _certmap_h_1234_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\certmap\cauthppg.h ===
// CAuthPpg.h : Declaration of the CCertAuthPropPage property page class.

////////////////////////////////////////////////////////////////////////////
// CCertAuthPropPage : See CAuthPpg.cpp.cpp for implementation.

class CCertAuthPropPage : public COlePropertyPage
{
    DECLARE_DYNCREATE(CCertAuthPropPage)
    DECLARE_OLECREATE_EX(CCertAuthPropPage)

// Constructor
public:
    CCertAuthPropPage();

// Dialog Data
    //{{AFX_DATA(CCertAuthPropPage)
    enum { IDD = IDD_PROPPAGE_MAPR2 };
        // NOTE - ClassWizard will add data members here.
        //    DO NOT EDIT what you see in these blocks of generated code !
    //}}AFX_DATA

// Implementation
protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support

// Message maps
protected:
    //{{AFX_MSG(CCertAuthPropPage)
        // NOTE - ClassWizard will add and remove member functions here.
        //    DO NOT EDIT what you see in these blocks of generated code !
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\certmap\cauthctl.h ===
// CAuthCtl.h : Declaration of the CCertAuthorityCtrl OLE control class.

/////////////////////////////////////////////////////////////////////////////
// CCertAuthorityCtrl : See CAuthCtl.cpp for implementation.

class CCertAuthorityCtrl : public COleControl
{
    DECLARE_DYNCREATE(CCertAuthorityCtrl)

// Constructor
public:
    CCertAuthorityCtrl();

// Overrides

    // Drawing function
    virtual void OnDraw(
                CDC* pdc, const CRect& rcBounds, const CRect& rcInvalid);

    // Persistence
    virtual void DoPropExchange(CPropExchange* pPX);

    // Reset control state
    virtual void OnResetState();

// Implementation
protected:
    ~CCertAuthorityCtrl();

    DECLARE_OLECREATE_EX(CCertAuthorityCtrl)    // Class factory and guid
    DECLARE_OLETYPELIB(CCertAuthorityCtrl)      // GetTypeInfo
    DECLARE_PROPPAGEIDS(CCertAuthorityCtrl)     // Property page IDs
    DECLARE_OLECTLTYPE(CCertAuthorityCtrl)      // Type name and misc status

    // Subclassed control support
    BOOL PreCreateWindow(CREATESTRUCT& cs);
    BOOL IsSubclassedControl();
    LRESULT OnOcmCommand(WPARAM wParam, LPARAM lParam);

// Message maps
    //{{AFX_MSG(CCertAuthorityCtrl)
        // NOTE - ClassWizard will add and remove member functions here.
        //    DO NOT EDIT what you see in these blocks of generated code !
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

// Dispatch maps
    //{{AFX_DISPATCH(CCertAuthorityCtrl)
        // NOTE - ClassWizard will add and remove member functions here.
        //    DO NOT EDIT what you see in these blocks of generated code !
    //}}AFX_DISPATCH
    DECLARE_DISPATCH_MAP()

// Event maps
    //{{AFX_EVENT(CCertAuthorityCtrl)
        // NOTE - ClassWizard will add and remove member functions here.
        //    DO NOT EDIT what you see in these blocks of generated code !
    //}}AFX_EVENT
    DECLARE_EVENT_MAP()

// Dispatch and event IDs
public:
    enum {
    //{{AFX_DISP_ID(CCertAuthorityCtrl)
        // NOTE: ClassWizard will add and remove enumeration elements here.
        //    DO NOT EDIT what you see in these blocks of generated code !
    //}}AFX_DISP_ID
    };

private:
    BOOL fInitialized;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\certmap\certctl.cpp ===
// CertCtl.cpp : Implementation of the CCertmapCtrl OLE control class.

#include "stdafx.h"
#include "certmap.h"
#include "CertCtl.h"
#include "CertPpg.h"

extern "C"
{
    #include <wincrypt.h>
    #include <sslsp.h>
}

// persistence and mapping includes
#include "Iismap.hxx"
#include "Iiscmr.hxx"
#include "WrapMaps.h"

#include "ListRow.h"
#include "ChkLstCt.h"

#include "wrapmb.h"

#include "Map11Pge.h"
#include "MapWPge.h"

//#include <iiscnfg.h>


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


IMPLEMENT_DYNCREATE(CCertmapCtrl, COleControl)


/////////////////////////////////////////////////////////////////////////////
// Message map

BEGIN_MESSAGE_MAP(CCertmapCtrl, COleControl)
    //{{AFX_MSG_MAP(CCertmapCtrl)
    //}}AFX_MSG_MAP
    ON_OLEVERB(AFX_IDS_VERB_PROPERTIES, OnProperties)
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// Dispatch map

BEGIN_DISPATCH_MAP(CCertmapCtrl, COleControl)
    //{{AFX_DISPATCH_MAP(CCertmapCtrl)
    DISP_FUNCTION(CCertmapCtrl, "SetServerInstance", SetServerInstance, VT_EMPTY, VTS_BSTR)
    DISP_FUNCTION(CCertmapCtrl, "SetMachineName", SetMachineName, VT_EMPTY, VTS_BSTR)
    DISP_STOCKFUNC_DOCLICK()
    DISP_STOCKPROP_FONT()
    DISP_STOCKPROP_ENABLED()
    DISP_STOCKPROP_BORDERSTYLE()
    DISP_STOCKPROP_CAPTION()
    //}}AFX_DISPATCH_MAP
END_DISPATCH_MAP()


/////////////////////////////////////////////////////////////////////////////
// Event map

BEGIN_EVENT_MAP(CCertmapCtrl, COleControl)
    //{{AFX_EVENT_MAP(CCertmapCtrl)
    EVENT_STOCK_CLICK()
    EVENT_STOCK_KEYUP()
    //}}AFX_EVENT_MAP
END_EVENT_MAP()


/////////////////////////////////////////////////////////////////////////////
// Property pages

// TODO: Add more property pages as needed.  Remember to increase the count!
BEGIN_PROPPAGEIDS(CCertmapCtrl, 2)
    PROPPAGEID(CCertmapPropPage::guid)
    PROPPAGEID(CLSID_CFontPropPage)
END_PROPPAGEIDS(CCertmapCtrl)


/////////////////////////////////////////////////////////////////////////////
// Initialize class factory and guid

IMPLEMENT_OLECREATE_EX(CCertmapCtrl, "CERTMAP.CertmapCtrl.1",
    0xbbd8f29b, 0x6f61, 0x11d0, 0xa2, 0x6e, 0x8, 0, 0x2b, 0x2c, 0x6f, 0x32)


/////////////////////////////////////////////////////////////////////////////
// Type library ID and version

IMPLEMENT_OLETYPELIB(CCertmapCtrl, _tlid, _wVerMajor, _wVerMinor)


/////////////////////////////////////////////////////////////////////////////
// Interface IDs

const IID BASED_CODE IID_DCertmap =
    { 0xbbd8f299, 0x6f61, 0x11d0, { 0xa2, 0x6e, 0x8, 0, 0x2b, 0x2c, 0x6f, 0x32 } };
const IID BASED_CODE IID_DCertmapEvents =
    { 0xbbd8f29a, 0x6f61, 0x11d0, { 0xa2, 0x6e, 0x8, 0, 0x2b, 0x2c, 0x6f, 0x32 } };


/////////////////////////////////////////////////////////////////////////////
// Control type information

static const DWORD BASED_CODE _dwCertmapOleMisc =
    OLEMISC_ACTIVATEWHENVISIBLE |
    OLEMISC_SETCLIENTSITEFIRST  |
    OLEMISC_INSIDEOUT           |
    OLEMISC_CANTLINKINSIDE      |
    OLEMISC_ACTSLIKEBUTTON      |
    OLEMISC_RECOMPOSEONRESIZE;

IMPLEMENT_OLECTLTYPE(CCertmapCtrl, IDS_CERTMAP, _dwCertmapOleMisc)


/////////////////////////////////////////////////////////////////////////////
// CCertmapCtrl::CCertmapCtrlFactory::UpdateRegistry -
// Adds or removes system registry entries for CCertmapCtrl

BOOL CCertmapCtrl::CCertmapCtrlFactory::UpdateRegistry(BOOL bRegister)
    {
    // TODO: Verify that your control follows apartment-model threading rules.
    // Refer to MFC TechNote 64 for more information.
    // If your control does not conform to the apartment-model rules, then
    // you must modify the code below, changing the 6th parameter from
    // afxRegApartmentThreading to 0.

    if (bRegister)
        return AfxOleRegisterControlClass(
            AfxGetInstanceHandle(),
            m_clsid,
            m_lpszProgID,
            IDS_CERTMAP,
            IDB_CERTMAP,
            afxRegApartmentThreading,
            _dwCertmapOleMisc,
            _tlid,
            _wVerMajor,
            _wVerMinor);
    else
        return AfxOleUnregisterClass(m_clsid, m_lpszProgID);
    }


/////////////////////////////////////////////////////////////////////////////
// CCertmapCtrl::CCertmapCtrl - Constructor

CCertmapCtrl::CCertmapCtrl():
    m_fUpdateFont( FALSE ),
    m_hAccel( NULL ),
    m_cAccel( 0 )
    {
    InitializeIIDs(&IID_DCertmap, &IID_DCertmapEvents);
    }


/////////////////////////////////////////////////////////////////////////////
// CCertmapCtrl::~CCertmapCtrl - Destructor

CCertmapCtrl::~CCertmapCtrl()
    {
    if ( m_hAccel )
        DestroyAcceleratorTable( m_hAccel );
    m_hAccel = NULL;
    }


/////////////////////////////////////////////////////////////////////////////
// CCertmapCtrl::OnDraw - Drawing function

void CCertmapCtrl::OnDraw( CDC* pdc, const CRect& rcBounds, const CRect& rcInvalid )
    {
    DoSuperclassPaint(pdc, rcBounds);
/*
    CFont* pOldFont;

    // select the stock font, recording the old one
    pOldFont = SelectStockFont( pdc );

    // do the superclass draw
    DoSuperclassPaint(pdc, rcBounds);

    // restore the old font - sneakily getting the correct font object
    pOldFont = pdc->SelectObject(pOldFont);
    
    // we want the button window to continue drawing in the correct font even
    // when we are not using OnDraw. i.e. when it is being pushed down. This
    // means we need to set the CWnd::SetFont() method.
    if ( m_fUpdateFont )
        {
        m_fUpdateFont = FALSE;
        CWnd::SetFont( pOldFont );
        }

    DoSuperclassPaint(pdc, rcBounds);
*/
    }

/////////////////////////////////////////////////////////////////////////////
// CCertmapCtrl::DoPropExchange - Persistence support

void CCertmapCtrl::DoPropExchange( CPropExchange* pPX )
    {
    ExchangeVersion(pPX, MAKELONG(_wVerMinor, _wVerMajor));
    COleControl::DoPropExchange(pPX);
    }


/////////////////////////////////////////////////////////////////////////////
// CCertmapCtrl::OnResetState - Reset control to default state

void CCertmapCtrl::OnResetState()
    {
    COleControl::OnResetState();  // Resets defaults found in DoPropExchange
    }


/////////////////////////////////////////////////////////////////////////////
// CCertmapCtrl message handlers

//---------------------------------------------------------------------------
BOOL CCertmapCtrl::PreCreateWindow(CREATESTRUCT& cs)
    {
    if ( cs.style & WS_CLIPSIBLINGS )
        cs.style ^= WS_CLIPSIBLINGS;
    cs.lpszClass = _T("BUTTON");
    return COleControl::PreCreateWindow(cs);
    }

/////////////////////////////////////////////////////////////////////////////
// CAppsCtrl::IsSubclassedControl - This is a subclassed control

BOOL CCertmapCtrl::IsSubclassedControl()
    {
    return TRUE;
    }


/////////////////////////////////////////////////////////////////////////////
// CAppsCtrl::OnOcmCommand - Handle command messages

LRESULT CCertmapCtrl::OnOcmCommand(WPARAM wParam, LPARAM lParam)
    {
#ifdef _WIN32
    WORD wNotifyCode = HIWORD(wParam);
#else
    WORD wNotifyCode = HIWORD(lParam);
#endif

    return 0;
    }

//---------------------------------------------------------------------------
void CCertmapCtrl::OnClick(USHORT iButton)
    {
    // in case there are any errors, prepare the error string
    CString sz;

    sz.LoadString( IDS_ERR_CERTMAP_TITLE );
    
    // free the existing name, and copy in the new one
    //  tjp:  you should compare if the old name matches the current name
    //        and only then free and malloc the new name -- chances are that
    //        the names are the same +++ all the free/malloc can fragment mem.
    free((void*)AfxGetApp()->m_pszAppName);
    AfxGetApp()->m_pszAppName = _tcsdup(sz);

    // this is the whole purpose of the control
    RunMappingDialog();

    // we are not in the business of telling the host to do
    // something here, so just don't fire anything off.
    COleControl::OnClick(iButton);
    }

//---------------------------------------------------------------------------
void CCertmapCtrl::RunMappingDialog()
    {
    //
    // UNICODE/ANSI conversion - RonaldM
    //
    // prepare the machine name pointer
    USES_CONVERSION;

    OLECHAR * poch = NULL;

    if ( !m_szMachineName.IsEmpty() )
    {
        // allocate the name buffer, no need to free

        poch = T2OLE((LPTSTR)(LPCTSTR)m_szMachineName);

        if ( !poch )
        {
            MessageBeep(0);

            return;
        }
    }
        
    // initialize the metabase wrappings - pass in the name of the target machine
    // if one has been specified

    //
    // Changed to generic metabase wrapper class - RonaldM
    //
    //IMSAdminBase * pMB = FInitMetabaseWrapper( poch );
    //if ( !pMB )

    IMSAdminBase * pMB = NULL;
    if (!FInitMetabaseWrapperEx( poch, &pMB ))
    {
        MessageBeep(0);

        return;
    }

    // the 1:1 mapping and rule-based mapping are panes in a single dialog window.
    // first we must build the propertysheet dialog and add the panes

    // pointers to the pages (construction may throw, so we need to be careful)
    CMap11Page       page11mapping;
    CMapWildcardsPge pageWildMapping;

    // declare the property sheet
    CPropertySheet   propsheet( IDS_MAP_SHEET_TITLE );

    // Things could throw here, so better protect it.
    try
        {
        // if there is nothing in the MB_Path, default to the first instance
        if ( m_szServerInstance.IsEmpty() )
            m_szServerInstance = _T("/LM/W3SVC/1");

        // I am assuming that the last character is NOT a '/' Thus, if that is what is
        // there, we need to remove it. Otherwise, the path gets messed up later
        if ( m_szServerInstance.Right(1) == _T('/') )
            m_szServerInstance = m_szServerInstance.Left( m_szServerInstance.GetLength()-1 );

        // tell the pages about the metabase path property
        page11mapping.m_szMBPath   = m_szServerInstance + SZ_NAMESPACE_EXTENTION;
        pageWildMapping.m_szMBPath = m_szServerInstance + SZ_NAMESPACE_EXTENTION;

        // do any other initializing of the pages
        page11mapping.FInit(pMB);
        pageWildMapping.FInit(pMB);
        }
    catch ( CException e )
        {
        }

    // add the pages to the sheet
    propsheet.AddPage( &page11mapping );
    propsheet.AddPage( &pageWildMapping );

    // turn on help
    propsheet.m_psh.dwFlags |= PSH_HASHELP;
    page11mapping.m_psp.dwFlags |= PSP_HASHELP;
    pageWildMapping.m_psp.dwFlags |= PSP_HASHELP;

    // Things could (potentially maybe) throw here, so better protect it.
    try
        {
        // run the propdsheet dialog
        // let the host container know that we are putting up a modal dialog
        PreModalDialog();
        // run the dialog
        //  tjp:   should we not test the outcome of the dialog?
        //         could the user ESCAPE out of it w/o doing anything?
        propsheet.DoModal();
        // let the host container know we are done with the modality
        PostModalDialog();
        }
    catch ( CException e )
        {
        }

    // close the metabase wrappings
    //
    // Changed to generic wrapper -- RonaldM
    FCloseMetabaseWrapperEx(&pMB);
    }

//---------------------------------------------------------------------------
void CCertmapCtrl::SetServerInstance(LPCTSTR szServerInstance)
    {
    m_szServerInstance = szServerInstance;
    }

//---------------------------------------------------------------------------
void CCertmapCtrl::SetMachineName(LPCTSTR szMachine)
    {
    m_szMachineName = szMachine;
    }

//---------------------------------------------------------------------------
void CCertmapCtrl::OnFontChanged()
    {
    m_fUpdateFont = TRUE;
    COleControl::OnFontChanged();
    }


//---------------------------------------------------------------------------
void CCertmapCtrl::OnAmbientPropertyChange(DISPID dispid)
    {
    BOOL    flag;
    UINT    style;

    // do the right thing depending on the dispid
    switch ( dispid )
    {
    case DISPID_AMBIENT_DISPLAYASDEFAULT:
        if ( GetAmbientProperty( DISPID_AMBIENT_DISPLAYASDEFAULT, VT_BOOL, &flag ) )
            {
            style = GetWindowLong(
                    GetSafeHwnd(), // handle of window
                    GWL_STYLE  // offset of value to retrieve
                    );
            if ( flag )
                style |= BS_DEFPUSHBUTTON;
            else
                style ^= BS_DEFPUSHBUTTON;
            SetWindowLong(
                    GetSafeHwnd(), // handle of window
                    GWL_STYLE,  // offset of value to retrieve
                    style
                    );
            Invalidate(TRUE);
            }
        break;
    };

    COleControl::OnAmbientPropertyChange(dispid);
    }

//---------------------------------------------------------------------------
// an important method where we tell the container how to deal with us.
// pControlInfo is passed in by the container, although we are responsible
// for maintining the hAccel structure
void CCertmapCtrl::OnGetControlInfo(LPCONTROLINFO pControlInfo)
    {
    // do a rudimentary check to see if we understand pControlInfo
    if ( !pControlInfo || pControlInfo->cb < sizeof(CONTROLINFO) )
        return;

    // set the accelerator handle into place
    pControlInfo->hAccel = m_hAccel;
    pControlInfo->cAccel = m_cAccel;

    // when we have focus, we do want the enter key
    pControlInfo->dwFlags = CTRLINFO_EATS_RETURN;
    }

//---------------------------------------------------------------------------
// the ole control container object specifically filters out the space
// key so we do not get it as a OnMnemonic call. Thus we need to look
// for it ourselves
void CCertmapCtrl::OnKeyUpEvent(USHORT nChar, USHORT nShiftState)
    {
    if ( nChar == _T(' ') )
        {
        OnClick((USHORT)GetDlgCtrlID());
        }
    COleControl::OnKeyUpEvent(nChar, nShiftState);
    }

//---------------------------------------------------------------------------
void CCertmapCtrl::OnMnemonic(LPMSG pMsg)
    {
    OnClick((USHORT)GetDlgCtrlID());
    COleControl::OnMnemonic(pMsg);
    }

//---------------------------------------------------------------------------
void CCertmapCtrl::OnTextChanged()
    {
    DWORD   i;
    ACCEL   accel;
    BOOL    f;
    BOOL    flag;
    int     iAccel;

    // get the new text
    CString sz = InternalGetText();
    sz.MakeLower();

    // if the handle has already been allocated, free it
    if ( m_hAccel )
        {
        DestroyAcceleratorTable( m_hAccel );
        m_hAccel = NULL;
        m_cAccel = 0;
        }

    // if there is a & character, then declare the accelerator
    iAccel = sz.Find(_T('&'));
    if ( iAccel >= 0 )
        {
        // fill in the accererator record
        accel.fVirt = FALT;
        accel.key = sz.GetAt(iAccel + 1);
        accel.cmd = (USHORT)GetDlgCtrlID();

        m_hAccel = CreateAcceleratorTable( &accel, 1 );
        if ( m_hAccel )
            m_cAccel = 1;
        }

    // finish with the default handling.
    COleControl::OnTextChanged();
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\certmap\certppg.cpp ===
// CertPpg.cpp : Implementation of the CCertmapPropPage property page class.

#include "stdafx.h"
#include "certmap.h"
#include "CertPpg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


IMPLEMENT_DYNCREATE(CCertmapPropPage, COlePropertyPage)


/////////////////////////////////////////////////////////////////////////////
// Message map

BEGIN_MESSAGE_MAP(CCertmapPropPage, COlePropertyPage)
    //{{AFX_MSG_MAP(CCertmapPropPage)
    // NOTE - ClassWizard will add and remove message map entries
    //    DO NOT EDIT what you see in these blocks of generated code !
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// Initialize class factory and guid

IMPLEMENT_OLECREATE_EX(CCertmapPropPage, "CERTMAP.CertmapPropPage.1",
    0xbbd8f29c, 0x6f61, 0x11d0, 0xa2, 0x6e, 0x8, 0, 0x2b, 0x2c, 0x6f, 0x32)


/////////////////////////////////////////////////////////////////////////////
// CCertmapPropPage::CCertmapPropPageFactory::UpdateRegistry -
// Adds or removes system registry entries for CCertmapPropPage

BOOL CCertmapPropPage::CCertmapPropPageFactory::UpdateRegistry(BOOL bRegister)
{
    if (bRegister)
        return AfxOleRegisterPropertyPageClass(
            AfxGetInstanceHandle(),
            m_clsid, 
            IDS_CERTMAP_PPG,
            afxRegApartmentThreading
            );
    else
        return AfxOleUnregisterClass(m_clsid, NULL);
}


/////////////////////////////////////////////////////////////////////////////
// CCertmapPropPage::CCertmapPropPage - Constructor

CCertmapPropPage::CCertmapPropPage() :
    COlePropertyPage(IDD, IDS_CERTMAP_PPG_CAPTION)
{
    //{{AFX_DATA_INIT(CCertmapPropPage)
    m_Caption = _T("");
    m_szPath = _T("");
    //}}AFX_DATA_INIT
}


/////////////////////////////////////////////////////////////////////////////
// CCertmapPropPage::DoDataExchange - Moves data between page and properties

void CCertmapPropPage::DoDataExchange(CDataExchange* pDX)
{
    //{{AFX_DATA_MAP(CCertmapPropPage)
    DDP_Text(pDX, IDC_CAPTIONEDIT, m_Caption, _T("Caption") );
    DDX_Text(pDX, IDC_CAPTIONEDIT, m_Caption);
    DDP_Text(pDX, IDC_MB_PATH, m_szPath, _T("MBPath") );
    DDX_Text(pDX, IDC_MB_PATH, m_szPath);
    //}}AFX_DATA_MAP
    DDP_PostProcessing(pDX);
}




/////////////////////////////////////////////////////////////////////////////
// CCertmapPropPage message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\certmap\chklstct.cpp ===
// ChkLstCt.cpp : implementation file
//

#include "stdafx.h"
#include "certmap.h"
#include "ListRow.h"
#include "ChkLstCt.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CCheckListCtrl

//-----------------------------------------------------------------------------------
CCheckListCtrl::CCheckListCtrl()
    {
    // set the correct start drawing column
    m_StartDrawingCol = 1;
    }

//-----------------------------------------------------------------------------------
CCheckListCtrl::~CCheckListCtrl()
    {
    }


//-----------------------------------------------------------------------------------
BEGIN_MESSAGE_MAP(CCheckListCtrl, CListSelRowCtrl)
    //{{AFX_MSG_MAP(CCheckListCtrl)
        // NOTE - the ClassWizard will add and remove mapping macros here.
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CCheckListCtrl message handlers

//-----------------------------------------------------------------------------------
void CCheckListCtrl::DrawItem(LPDRAWITEMSTRUCT lpDrawItemStruct)
    {
    CRect       rcItem = lpDrawItemStruct->rcItem;
    CRect       rcSection;
    UINT        itemID = lpDrawItemStruct->itemID;
    BOOL        f;
    CString     sz;
    LV_COLUMN   colData;

    // setup the CDC object
    CDC         cdc;
    cdc.Attach( lpDrawItemStruct->hDC );

    // clear the columnd buffer
    ZeroMemory( &colData, sizeof(colData) );
    colData.mask = LVCF_WIDTH;


    // get the checkmark bitmap
//  f = m_bitmapCheck.LoadBitmap( IDB_CHECK );


    // First, we draw the "enabled" column Get the data
    // for it first. If there is none, then we can skip it.
    sz = GetItemText( itemID, 0 );
    f = GetColumn( 0, &colData );

    if ( !sz.IsEmpty() )
        {
        // figure out the sectional rect
        rcSection = rcItem;
        rcSection.left += 4;
        rcSection.top += 3;

        rcSection.right = rcSection.left + 9;
        rcSection.bottom = rcSection.top + 9;

        // draw the circle
        cdc.Ellipse( &rcSection );
        rcSection.DeflateRect(1, 1);
        cdc.Ellipse( &rcSection );
        }
    
    cdc.Detach();

    // draw the rest of it
    CListSelRowCtrl::DrawItem( lpDrawItemStruct );
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\certmap\cnfrmpsd.cpp ===
// CnfrmPsD.cpp : implementation file
//
// NOTE that file Passdlg.h/cpp is very similar to this
//      file!
//
//       CnfrmPsD class has an OnOK that will complain
//       to the user if the passwds dont match
//       This is above whats in PassDlg class
//
//       And class PassDlg has an OnInitDialog that Cnfrmpsd
//       does not have. This simply puts focus on the edit
//       field for the passwd
//
#include "stdafx.h"
#include "certmap.h"
#include "CnfrmPsD.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CConfirmPassDlg dialog

CConfirmPassDlg::CConfirmPassDlg(CWnd* pParent /*=NULL*/)
    : CDialog(CConfirmPassDlg::IDD, pParent)
    {
    //{{AFX_DATA_INIT(CConfirmPassDlg)
    m_sz_password_new = _T("");
    //}}AFX_DATA_INIT
    }

void CConfirmPassDlg::DoDataExchange(CDataExchange* pDX)
    {
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CConfirmPassDlg)
    DDX_Text(pDX, IDC_CONFIRM_PASSWORD, m_sz_password_new);
    //}}AFX_DATA_MAP
    }

BEGIN_MESSAGE_MAP(CConfirmPassDlg, CDialog)
    //{{AFX_MSG_MAP(CConfirmPassDlg)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CConfirmPassDlg message handlers

void CConfirmPassDlg::OnOK() 
    {
    UpdateData( TRUE );

    // confirm it
    if ( m_sz_password_new != m_szOrigPass )
        {
        AfxMessageBox( IDS_PASS_CONFIRM_FAIL );
        return;
        }

    CDialog::OnOK();
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\certmap\cnfrmpsd.h ===
// CnfrmPsD.h : header file
//
// NOTE that file Passdlg.h is very similar to this
//      file!
//
//       CnfrmPsD class has an OnOK that will complain
//       to the user if the passwds dont match
//       This is above whats in PassDlg class
//
//       And class PassDlg has an OnInitDialog that Cnfrmpsd
//       does not have. This simply puts focus on the edit
//       field for the passwd
//
//
// DConfirmPassDlg.h : header file
//
#ifndef   _CnfrmPsdConfirmPassDlg_h_file_1287_
#define   _CnfrmPsdConfirmPassDlg_h_file_1287_



/////////////////////////////////////////////////////////////////////////////
// CConfirmPassDlg dialog

class CConfirmPassDlg : public CDialog
{
// Construction
public:
    CConfirmPassDlg(CWnd* pParent = NULL);   // standard constructor

    // the original password that we are confirming
    CString m_szOrigPass;

// Dialog Data
    //{{AFX_DATA(CConfirmPassDlg)
    enum { IDD = IDD_CONFIRM_PASSWORD };
    CString m_sz_password_new;
    //}}AFX_DATA


// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CConfirmPassDlg)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:

    // Generated message map functions
    //{{AFX_MSG(CConfirmPassDlg)
    virtual void OnOK();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\certmap\crackcrt.cpp ===
// implements the exported CKeyCrackedData

#include "stdafx.h"
#include "CrackCrt.h"

extern "C"
{
    #include <wincrypt.h>
    #include <sslsp.h>
}

//-------------------------------------------------
CCrackedCert:: CCrackedCert()
        : m_pData(NULL)
    {}

//-------------------------------------------------
CCrackedCert::~CCrackedCert()
    {
    PX509Certificate    p509 = (PX509Certificate)m_pData;

    // if the cracked data is there, free it
    if ( p509 ) 
        SslFreeCertificate( (PX509Certificate)m_pData );
    }

//-------------------------------------------------
// adds a key to the service. They CKey object is added to the
// array object below. If this Service is connected to a machine,
// then the key is also added to the tree view below the service.
//-------------------------------------------------
BOOL CCrackedCert::CrackCert( PUCHAR pCert, DWORD cbCert )
    {
    PX509Certificate    p509 = NULL;
    BOOL                f;

    // if there already is a cracked cert, get rid of it
    if ( m_pData )
        {
        SslFreeCertificate( (PX509Certificate)m_pData );
        m_pData = NULL;
        }

    // crack the certificate
    f = SslCrackCertificate( pCert, cbCert, CF_CERT_FROM_FILE, &p509 );

    m_pData = (PVOID)p509;
    return f;
    }

//-------------------------------------------------
// The rest of the methods access the data in the cracked certificate
//-------------------------------------------------
DWORD CCrackedCert::GetVersion()
    {
    ASSERT(m_pData);
    PX509Certificate pCert = (PX509Certificate)m_pData;
    return pCert->Version;
    }

//-------------------------------------------------
// returns a pointer to a DWORD[4]
DWORD* CCrackedCert::PGetSerialNumber()
    {
    ASSERT(m_pData);
    PX509Certificate pCert = (PX509Certificate)m_pData;
    return (DWORD*)&pCert->SerialNumber;
    }

//-------------------------------------------------
int CCrackedCert::GetSignatureAlgorithm()
    {
    ASSERT(m_pData);
    PX509Certificate pCert = (PX509Certificate)m_pData;
    return pCert->SignatureAlgorithm;
    }

//-------------------------------------------------
FILETIME CCrackedCert::GetValidFrom()
    {
    PX509Certificate pCert = (PX509Certificate)m_pData;
    ASSERT(m_pData);
    return pCert->ValidFrom;
    }

//-------------------------------------------------
FILETIME CCrackedCert::GetValidUntil()
    {
    PX509Certificate pCert = (PX509Certificate)m_pData;
    ASSERT(m_pData);
    return pCert->ValidUntil;
    }

//-------------------------------------------------
PVOID CCrackedCert::PSafePublicKey()
    {
    PX509Certificate pCert = (PX509Certificate)m_pData;
    ASSERT(m_pData);
    return pCert->pPublicKey;
    }

//-------------------------------------------------
DWORD CCrackedCert::GetBitLength()
    {
    PX509Certificate pCert = (PX509Certificate)m_pData;
    LPPUBLIC_KEY pPubKey = (LPPUBLIC_KEY)(pCert->pPublicKey);
    ASSERT(m_pData);
    return pPubKey->bitlen;
    }

//-------------------------------------------------
void CCrackedCert::GetIssuer( CString &sz )
    {
    PX509Certificate pCert = (PX509Certificate)m_pData;
    ASSERT(m_pData);
    sz = pCert->pszIssuer;
    }

//-------------------------------------------------
void CCrackedCert::GetSubject( CString &sz )
    {
    PX509Certificate pCert = (PX509Certificate)m_pData;
    ASSERT(m_pData);
    sz = pCert->pszSubject;
    }

//-------------------------------------------------
// gets a part of the subject's distinguishing information
void CCrackedCert::GetSubjectDN( CString &szDN, LPCTSTR szKey )
    {
    // clear the szDN
    szDN.Empty();

    // start with the dn (aka subject) string
    CString     szSubject;
    GetSubject( szSubject );

    // find the position of the key in the subject
    int cPos = szSubject.Find( szKey );

    // if we got it, get it
    if ( cPos >= 0 )
        {
        szDN = szKey;
        // get the string
        szDN = szSubject.Mid( cPos + szDN.GetLength() );
        // get the comma
        cPos = szDN.Find( _T(',') );
        // truncate at the comma
        if ( cPos >=0 )
            szDN = szDN.Left( cPos );
        }
    }

//-------------------------------------------------
// gets a part of the issuer's distinguishing information
void CCrackedCert::GetIssuerDN( CString &szDN, LPCTSTR szKey )
    {
    // clear the szDN
    szDN.Empty();

    // start with the dn (aka subject) string
    CString     szIssuer;
    GetIssuer( szIssuer );

    // find the position of the key in the subject
    int cPos = szIssuer.Find( szKey );

    // if we got it, get it
    if ( cPos >= 0 )
        {
        szDN = szKey;
        // get the string
        szDN = szIssuer.Mid( cPos + szDN.GetLength() );
        // get the comma
        cPos = szDN.Find( _T(',') );
        // truncate at the comma
        if ( cPos >=0 )
            szDN = szDN.Left( cPos );
        }
    }

//-------------------------------------------------
void CCrackedCert::GetSubjectCountry( CString &sz )
    {
    GetSubjectDN( sz, SZ_KEY_COUNTRY );
    }

//-------------------------------------------------
void CCrackedCert::GetSubjectState( CString &sz )
    {
    GetSubjectDN( sz, SZ_KEY_STATE );
    }

//-------------------------------------------------
void CCrackedCert::GetSubjectLocality( CString &sz )
    {
    GetSubjectDN( sz, SZ_KEY_LOCALITY );
    }

//-------------------------------------------------
void CCrackedCert::GetSubjectCommonName( CString &sz )
    {
    GetSubjectDN( sz, SZ_KEY_COMNAME );
    }

//-------------------------------------------------
void CCrackedCert::GetSubjectOrganization( CString &sz )
    {
    GetSubjectDN( sz, SZ_KEY_ORGANIZATION );
    }

//-------------------------------------------------
void CCrackedCert::GetSubjectUnit( CString &sz )
    {
    GetSubjectDN( sz, SZ_KEY_ORGUNIT );
    }


//-------------------------------------------------
void CCrackedCert::GetIssuerCountry( CString &sz )
    {
    GetIssuerDN( sz, SZ_KEY_COUNTRY );
    }

//-------------------------------------------------
void CCrackedCert::GetIssuerOrganization( CString &sz )
    {
    GetIssuerDN( sz, SZ_KEY_ORGANIZATION );
    }

//-------------------------------------------------
void CCrackedCert::GetIssuerUnit( CString &sz )
    {
    GetIssuerDN( sz, SZ_KEY_ORGUNIT );
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\certmap\crackcrt.h ===
class CCrackedCert
    {
    public:
    // constructor
    CCrackedCert();
    ~CCrackedCert();

    // give it a cert to crack. If this object was previously used to
    // crack a key, cleanup is automatically done and the new key is
    // cracked. - NOTE: The target key MUST have either a certificate
    // or a certificate request. Those are what get cracked. A return
    // value of 0 indicates success
    BOOL CrackCert( PUCHAR pCert, DWORD cbCert );

    // The rest of the methods access the data in the cracked certificate
    DWORD       GetVersion();
    DWORD*      PGetSerialNumber(); // returns a pointer to a DWORD[4]
    int         GetSignatureAlgorithm();
    FILETIME    GetValidFrom();
    FILETIME    GetValidUntil();
    PVOID       PSafePublicKey();
    DWORD       GetBitLength();

    void        GetIssuer( CString &sz );
    void        GetIssuerCountry( CString &sz );
    void        GetIssuerOrganization( CString &sz );
    void        GetIssuerUnit( CString &sz );

    void        GetSubject( CString &sz );
    void        GetSubjectCountry( CString &sz );
    void        GetSubjectState( CString &sz );
    void        GetSubjectLocality( CString &sz );
    void        GetSubjectCommonName( CString &sz );
    void        GetSubjectOrganization( CString &sz );
    void        GetSubjectUnit( CString &sz );

    protected:

    // string constants for distinguishing names. Not to be localized
    #define     SZ_KEY_COUNTRY          _T("C=")
    #define     SZ_KEY_STATE            _T("S=")
    #define     SZ_KEY_LOCALITY         _T("L=")
    #define     SZ_KEY_ORGANIZATION     _T("O=")
    #define     SZ_KEY_ORGUNIT          _T("OU=")
    #define     SZ_KEY_COMNAME          _T("CN=")

    private:
    void        GetSubjectDN( CString &szDN, LPCTSTR szKey );
    void        GetIssuerDN( CString &szDN, LPCTSTR szKey );


    // declare the x509 pointer as void so that the
    // files instantiating this don't have to include wincrypt
    PVOID       m_pData;
    };
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\certmap\chklstct.h ===
// ChkLstCt.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CCheckListCtrl window

class CCheckListCtrl : public CListSelRowCtrl
{
// Construction
public:
    CCheckListCtrl();

    virtual void DrawItem(LPDRAWITEMSTRUCT lpDrawItemStruct);

// Attributes
public:

// Operations
public:

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CCheckListCtrl)
    //}}AFX_VIRTUAL

// Implementation
public:
    virtual ~CCheckListCtrl();

    // Generated message map functions
protected:
    //{{AFX_MSG(CCheckListCtrl)
        // NOTE - the ClassWizard will add and remove member functions here.
    //}}AFX_MSG

    DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\certmap\edtone11.h ===
// EdtOne11.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CEditOne11MapDlg dialog

class CEditOne11MapDlg : public CNTBrowsingDialog
{
// Construction
public:
    CEditOne11MapDlg(CWnd* pParent = NULL);   // standard constructor
    virtual void OnOK();


// Dialog Data
    //{{AFX_DATA(CEditOne11MapDlg)
    enum { IDD = IDD_MAP_ONE_TO_ACCNT };
    CString m_sz_mapname;
    BOOL    m_bool_enable;
    //}}AFX_DATA


// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CEditOne11MapDlg)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:

    // Generated message map functions
    //{{AFX_MSG(CEditOne11MapDlg)
    afx_msg void OnBtnHelp();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\certmap\ed11maps.cpp ===
// Ed11Maps.cpp : implementation file
//

#include "stdafx.h"
#include "certmap.h"
#include "brwsdlg.h"
#include "Ed11Maps.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CEdit11Mappings dialog
CEdit11Mappings::CEdit11Mappings(CWnd* pParent /*=NULL*/)
    : CNTBrowsingDialog(CEdit11Mappings::IDD, pParent)
    {
    //{{AFX_DATA_INIT(CEdit11Mappings)
    m_int_enable = FALSE;
    //}}AFX_DATA_INIT
    }


void CEdit11Mappings::DoDataExchange(CDataExchange* pDX)
    {
    CNTBrowsingDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CEdit11Mappings)
    DDX_Check(pDX, IDC_ENABLE, m_int_enable);
    //}}AFX_DATA_MAP
    }


BEGIN_MESSAGE_MAP(CEdit11Mappings, CNTBrowsingDialog)
    //{{AFX_MSG_MAP(CEdit11Mappings)
    ON_BN_CLICKED(IDC_BTN_HELP, OnBtnHelp)
    //}}AFX_MSG_MAP
    ON_COMMAND(ID_HELP_FINDER,  OnBtnHelp)
    ON_COMMAND(ID_HELP,         OnBtnHelp)
    ON_COMMAND(ID_CONTEXT_HELP, OnBtnHelp)
    ON_COMMAND(ID_DEFAULT_HELP, OnBtnHelp)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CEdit11Mappings message handlers


//---------------------------------------------------------------------------
void CEdit11Mappings::OnOK()
    {
    UpdateData( TRUE ); 
    // call the superclass ok
    CNTBrowsingDialog::OnOK();
    }

//---------------------------------------------------------------------------
void CEdit11Mappings::OnBtnHelp() 
    {
    WinHelp( HIDD_CERTMAP_BASIC_MAP_MANY );
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\certmap\edtrulel.cpp ===
// EdtRulEl.cpp : implementation file
//

#include "stdafx.h"
#include "certmap.h"
#include "EdtRulEl.h"

extern "C"
{
    #include <wincrypt.h>
    #include <sslsp.h>
}

#include "Iismap.hxx"
#include "Iiscmr.hxx"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CEditRuleElement dialog


//---------------------------------------------------------------------------
CEditRuleElement::CEditRuleElement(CWnd* pParent /*=NULL*/)
    : CDialog(CEditRuleElement::IDD, pParent)
    {
    //{{AFX_DATA_INIT(CEditRuleElement)
    m_sz_criteria = _T("");
    m_int_field = -1;
    m_sz_subfield = _T("");
    m_bool_match_case = FALSE;
    //}}AFX_DATA_INIT
    }


//---------------------------------------------------------------------------
void CEditRuleElement::DoDataExchange(CDataExchange* pDX)
    {
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CEditRuleElement)
    DDX_Control(pDX, IDC_SUBFIELD, m_ccombobox_subfield);
    DDX_Control(pDX, IDC_FIELDS, m_ccombobox_field);
    DDX_Text(pDX, IDC_CRITERIA, m_sz_criteria);
    DDX_CBIndex(pDX, IDC_FIELDS, m_int_field);
    DDX_CBString(pDX, IDC_SUBFIELD, m_sz_subfield);
    DDX_Check(pDX, IDC_CHK_CAPITALIZATION, m_bool_match_case);
    //}}AFX_DATA_MAP
    }


//---------------------------------------------------------------------------
BEGIN_MESSAGE_MAP(CEditRuleElement, CDialog)
    //{{AFX_MSG_MAP(CEditRuleElement)
    ON_CBN_SELCHANGE(IDC_FIELDS, OnSelchangeFields)
    ON_EN_CHANGE(IDC_SUBFIELD, OnChangeSubfield)
    ON_BN_CLICKED(IDC_BTN_HELP, OnBtnHelp)
    //}}AFX_MSG_MAP
    ON_COMMAND(ID_HELP_FINDER,  OnBtnHelp)
    ON_COMMAND(ID_HELP,         OnBtnHelp)
    ON_COMMAND(ID_CONTEXT_HELP, OnBtnHelp)
    ON_COMMAND(ID_DEFAULT_HELP, OnBtnHelp)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CEditRuleElement message handlers

//---------------------------------------------------------------------------
BOOL CEditRuleElement::OnInitDialog()
    {
    CString     sz;

    // call the parental oninitdialog
    BOOL f = CDialog::OnInitDialog();

    // initialize the elements in the drop-list
    // loop the list of CERT_FIELD_IDs, adding each to the drop-list
    for ( UINT id = CERT_FIELD_ISSUER; id < CERT_FIELD_LAST; id++ )
        {
        // bug 154957 requests that we no longer support mapping on the
        // serial number. This makes sense anyway as mapping to the serial
        // numbers is better off done as 1::1 mapping. If the bug doesn't
        // make this conclusion clear enough upon reading, it is the
        // interpretation that MikeHow has handed down.
        if ( id == CERT_FIELD_SERIAL_NUMBER )
            continue;

        // get the string associated with the id
        sz = MapIdToField( (CERT_FIELD_ID)id );
        m_ccombobox_field.AddString( sz );
        }

    // initialize the list of known subfields

    id = 0;

    //
    // UNICODE conversion -- RonaldM
    //
    LPCSTR  psz;
    while ( psz = EnumerateKnownSubFields(id) )
        {
        CString str(psz);
        // append it to the drop-list
        m_ccombobox_subfield.AddString( str );

        // increment id
        id++;
        }

    UpdateData( FALSE );

    // store the initial value of the sub-field
    m_szTempSubStorage = m_sz_subfield;

    // make sure to check the subfields
    OnSelchangeFields();
    
    // return the answer
    return f;
    }

//---------------------------------------------------------------------------
// make sure that, if there is a sub-field, that it is valid
// 
void CEditRuleElement::OnOK() 
    {
    UpdateData( TRUE );

    //
    // UNICODE/ANSI conversion - RonaldM
    //
    USES_CONVERSION;

    // test the sub-field flag for the newly selected field type
    DWORD   flags = GetIdFlags( (CERT_FIELD_ID)m_int_field );
    BOOL    fSubs = flags & CERT_FIELD_FLAG_CONTAINS_SUBFIELDS;

    // if there are sub-fields, test their validity
    if ( fSubs )
        {
        CString szTest(MapSubFieldToAsn1( T2A((LPTSTR)(LPCTSTR)m_sz_subfield) ));
        // if there is NO match, tell the user
        if ( szTest.IsEmpty() )
            {
            AfxMessageBox( IDS_INVALID_SUBFIELD );
            return;
            }
        }

    // it is valid
    CDialog::OnOK();
    }

//---------------------------------------------------------------------------
void CEditRuleElement::OnSelchangeFields() 
    {
    UpdateData( TRUE );

    // test the sub-field flag for the newly selected field type
    DWORD   flags = GetIdFlags( (CERT_FIELD_ID)m_int_field );
    BOOL    fSubs = flags & CERT_FIELD_FLAG_CONTAINS_SUBFIELDS;

    // set the correct enable state
    BOOL    fWasEnabled = m_ccombobox_subfield.EnableWindow( fSubs );

    // restore the value if necessary
    if ( fSubs )
        {
        m_sz_subfield = m_szTempSubStorage;
        UpdateData( FALSE );
        }
    else
        {
        m_szTempSubStorage = m_sz_subfield;
        m_sz_subfield.Empty();
        UpdateData( FALSE );
        }
    }

//---------------------------------------------------------------------------
void CEditRuleElement::OnChangeSubfield() 
    {
    m_szTempSubStorage = m_sz_subfield;
    }

//---------------------------------------------------------------------------
void CEditRuleElement::OnBtnHelp() 
    {
    WinHelp( HIDD_CERTMAP_RUL_ELEMENT );
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\certmap\certppg.h ===
// CertPpg.h : Declaration of the CCertmapPropPage property page class.

////////////////////////////////////////////////////////////////////////////
// CCertmapPropPage : See CertPpg.cpp.cpp for implementation.

class CCertmapPropPage : public COlePropertyPage
{
    DECLARE_DYNCREATE(CCertmapPropPage)
    DECLARE_OLECREATE_EX(CCertmapPropPage)

// Constructor
public:
    CCertmapPropPage();

// Dialog Data
    //{{AFX_DATA(CCertmapPropPage)
    enum { IDD = IDD_PROPPAGE_CERTMAP };
    CString m_Caption;
    CString m_szPath;
    //}}AFX_DATA

// Implementation
protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support

// Message maps
protected:
    //{{AFX_MSG(CCertmapPropPage)
        // NOTE - ClassWizard will add and remove member functions here.
        //    DO NOT EDIT what you see in these blocks of generated code !
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\certmap\edtone11.cpp ===
// EdtOne11.cpp : implementation file
//

#include "stdafx.h"
#include "certmap.h"

#include "brwsdlg.h"
#include "EdtOne11.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


/////////////////////////////////////////////////////////////////////////////
// CEditOne11MapDlg dialog

CEditOne11MapDlg::CEditOne11MapDlg(CWnd* pParent /*=NULL*/)
        : CNTBrowsingDialog(CEditOne11MapDlg::IDD, pParent)
        {
        //{{AFX_DATA_INIT(CEditOne11MapDlg)
        m_sz_mapname = _T("");
        m_bool_enable = FALSE;
        //}}AFX_DATA_INIT
        }

void CEditOne11MapDlg::DoDataExchange(CDataExchange* pDX)
        {
        //{{AFX_DATA_MAP(CEditOne11MapDlg)
        DDX_Text(pDX, IDC_MAPNAME, m_sz_mapname);
        DDV_MaxChars(pDX, m_sz_mapname, 60);
        DDX_Check(pDX, IDC_ENABLE, m_bool_enable);
    //}}AFX_DATA_MAP
        CNTBrowsingDialog::DoDataExchange(pDX);
        }

BEGIN_MESSAGE_MAP(CEditOne11MapDlg, CNTBrowsingDialog)
        //{{AFX_MSG_MAP(CEditOne11MapDlg)
    ON_BN_CLICKED(IDC_BTN_HELP, OnBtnHelp)
    //}}AFX_MSG_MAP
    ON_COMMAND(ID_HELP_FINDER,  OnBtnHelp)
    ON_COMMAND(ID_HELP,         OnBtnHelp)
    ON_COMMAND(ID_CONTEXT_HELP, OnBtnHelp)
    ON_COMMAND(ID_DEFAULT_HELP, OnBtnHelp)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CEditOne11MapDlg message handlers

//---------------------------------------------------------------------------
// make sure that the selected NT acount is, in fact, a valid account
//
void CEditOne11MapDlg::OnOK()
        {
        // update the data
        UpdateData( TRUE );

        // it is valid
        CNTBrowsingDialog::OnOK();
        }

//---------------------------------------------------------------------------
void CEditOne11MapDlg::OnBtnHelp() 
    {
    WinHelp( HIDD_CERTMAP_BASIC_MAP_ONE );
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\certmap\ed11maps.h ===
// Ed11Maps.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CEdit11Mappings dialog

class CEdit11Mappings : public CNTBrowsingDialog
{
// Construction
public:
    CEdit11Mappings(CWnd* pParent = NULL);   // standard constructor

    // overrides
    virtual void OnOK();

// Dialog Data
    //{{AFX_DATA(CEdit11Mappings)
    enum { IDD = IDD_MAP_TO_ACCNT };
    int     m_int_enable;
    //}}AFX_DATA


// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CEdit11Mappings)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:

    // Generated message map functions
    //{{AFX_MSG(CEdit11Mappings)
    afx_msg void OnBtnHelp();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\certmap\crtmapd.h ===
// CrtMapD.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// C1To1CertMappingDlg dialog

class C1To1CertMappingDlg : public CPropertyPage
{
// Construction
public:
    C1To1CertMappingDlg(CWnd* pParent = NULL);  // standard constructor
    ~C1To1CertMappingDlg();                     // standard desstructor

    BOOL    FInitMapper();

    virtual BOOL OnApply();
    virtual BOOL OnInitDialog();

// Dialog Data
    //{{AFX_DATA(C1To1CertMappingDlg)
    enum { IDD = IDD_11CERT_MAPPING };
    CComboBox   m_ccombo_authorities;
    CButton m_cbutton_chooseaccnt;
    CButton m_cbutton_delete;
    CListCtrl   m_clistctrl_list;
    int     m_int_authorities;
    //}}AFX_DATA


// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(C1To1CertMappingDlg)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:

    // Generated message map functions
    //{{AFX_MSG(C1To1CertMappingDlg)
    afx_msg void OnChooseAccount();
    afx_msg void OnAdd();
    afx_msg void OnDelete();
    afx_msg void OnItemchangedList(NMHDR* pNMHDR, LRESULT* pResult);
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

    // internal utilities
    BOOL FInitMappingList();
    BOOL FInitAuthorityComboBox();

    // iMap is the mapping's index into the main mapper object. It gets saved as the private
    // data in the list item. Returns success or failure
    BOOL FAddMappingToList( CCert11Mapping* pMap, DWORD iMap );

    BOOL FEditOneMapping( CCert11Mapping* pMap );
    void EditManyMappings();
    void UpdateMappingInDispList( DWORD iList, CCert11Mapping* pMap );

    // reads a named certificate file from the disk. This is the same sort of cert file
    // that is passed around by the keyring application. In fact, this routine is defined
    // in its own source file and is largly lifted from the keyring app. AddCert.cpp
    BOOL FAddCertificateFile( CString szFile );
    BOOL FAddCertificate( PUCHAR pCertificate, DWORD cbCertificate );

    // convert a binary data thing to a distinguished name
    BOOL FBuildNameString( PUCHAR pBData, DWORD cbBData, CString &szDN );
    BOOL BuildRdnList( PNAME_INFO pNameInfo, CString &szDN );
    LPSTR MapAsnName( LPSTR pAsnName );



    // state utilities
    void EnableDependantButtons();

    // its mapper
    CIisCert11Mapper    m_mapper;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\certmap\editruld.h ===
// EditRulD.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CEditWildcardRuleDlg dialog

class CEditWildcardRuleDlg : public CDialog
{
// Construction
public:
    CEditWildcardRuleDlg(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
    //{{AFX_DATA(CEditWildcardRuleDlg)
    enum { IDD = IDD_WILDCARDS_2 };
        // NOTE: the ClassWizard will add data members here
    //}}AFX_DATA


// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CEditWildcardRuleDlg)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:

    // Generated message map functions
    //{{AFX_MSG(CEditWildcardRuleDlg)
    afx_msg void OnSelectIssuer();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\certmap\edtrulel.h ===
// EdtRulEl.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CEditRuleElement dialog

class CEditRuleElement : public CDialog
{
// Construction
public:
    CEditRuleElement(CWnd* pParent = NULL);   // standard constructor
    virtual BOOL OnInitDialog();

    // overrides
    virtual void OnOK();

// Dialog Data
    //{{AFX_DATA(CEditRuleElement)
    enum { IDD = IDD_EDIT_RULE_ELEMENT };
    CComboBox   m_ccombobox_subfield;
    CComboBox   m_ccombobox_field;
    CString m_sz_criteria;
    int     m_int_field;
    CString m_sz_subfield;
    BOOL    m_bool_match_case;
    //}}AFX_DATA


// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CEditRuleElement)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:

    // Generated message map functions
    //{{AFX_MSG(CEditRuleElement)
    afx_msg void OnSelchangeFields();
    afx_msg void OnChangeSubfield();
    afx_msg void OnBtnHelp();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

    
    // temporary storage in the event of a disabled subfield
    CString m_szTempSubStorage;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\certmap\edwldrul.cpp ===
// EdWldRul.cpp : implementation file
//

#include "stdafx.h"
#include <iadmw.h>

#include "ListRow.h"
#include "ChkLstCt.h"
extern "C"
    {
    #include <wincrypt.h>
    #include <sslsp.h>
    }
#include "Iismap.hxx"
#include "Iiscmr.hxx"

#include "brwsdlg.h"
#include "certmap.h"
#include "EdWldRul.h"
#include "EdtRulEl.h"
#include "IssueDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


#define ACCESS_DENY         0
#define ACCESS_ACCEPT       1

#define MATCH_ISSUER_ALL    0
#define MATCH_ISSUER_SOME   1


#define COL_CERT_FIELD          0
#define COL_SUB_FIELD           1
#define COL_MATCH_CRITERIA      2


// notes on the list:
// the list is the only source of current data for the rule elements. The actual
// rule object is not updated with changes in the list until the user hits IDOK.
// that way we can cancel without changing the object. All mapping between the
// text in the list and the binary formats used by the server are done at the
// beginning and end of the dialog


/////////////////////////////////////////////////////////////////////////////
// CEditWildcardRule dialog

//---------------------------------------------------------------------------
CEditWildcardRule::CEditWildcardRule(IMSAdminBase* pMB, CWnd* pParent /*=NULL*/)
    : CNTBrowsingDialog(CEditWildcardRule::IDD, pParent),
    m_pMB(pMB)
    {
    //{{AFX_DATA_INIT(CEditWildcardRule)
    m_sz_description = _T("");
    m_bool_enable = FALSE;
    m_int_MatchAllIssuers = -1;
    m_int_DenyAccess = -1;
    //}}AFX_DATA_INIT
    }

//---------------------------------------------------------------------------
void CEditWildcardRule::DoDataExchange(CDataExchange* pDX)
    {
    CNTBrowsingDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CEditWildcardRule)
    DDX_Control(pDX, IDC_EDIT, m_cbutton_edit);
    DDX_Control(pDX, IDC_DELETE, m_cbutton_delete);
    DDX_Control(pDX, IDC_NEW, m_cbutton_new);
    DDX_Control(pDX, IDC_LIST, m_clistctrl_list);
    DDX_Text(pDX, IDC_DESCRIPTION, m_sz_description);
    DDX_Check(pDX, IDC_ENABLE_RULE, m_bool_enable);
    DDX_Radio(pDX, IDC_ALL_ISSUERS, m_int_MatchAllIssuers);
    DDX_Radio(pDX, IDC_REFUSE_LOGON, m_int_DenyAccess);
    //}}AFX_DATA_MAP
    }

//---------------------------------------------------------------------------
BEGIN_MESSAGE_MAP(CEditWildcardRule, CNTBrowsingDialog)
    //{{AFX_MSG_MAP(CEditWildcardRule)
    ON_NOTIFY(NM_DBLCLK, IDC_LIST, OnDblclkList)
    ON_NOTIFY(LVN_ITEMCHANGED, IDC_LIST, OnItemchangedList)
    ON_BN_CLICKED(IDC_EDIT, OnEdit)
    ON_BN_CLICKED(IDC_NEW, OnNew)
    ON_BN_CLICKED(IDC_DELETE, OnDelete)
    ON_BN_CLICKED(IDC_SELECT_ISSUER, OnSelectIssuer)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()



//---------------------------------------------------------------------------
BOOL CEditWildcardRule::FInitRulesList()
    {
    CString sz;
    int     i;

    // setup the main field
    sz.LoadString( IDS_CERT_FIELD );

    i = m_clistctrl_list.InsertColumn( COL_CERT_FIELD, sz, LVCFMT_LEFT, 100 );

    // setup the sub field
    sz.LoadString( IDS_SUB_FIELD );

    i = m_clistctrl_list.InsertColumn( COL_SUB_FIELD, sz, LVCFMT_LEFT, 70 );

    // setup the match criteria column
    sz.LoadString( IDS_MATCH_CRITERIA );

    i = m_clistctrl_list.InsertColumn( COL_MATCH_CRITERIA, sz, LVCFMT_LEFT, 255 );

    return TRUE;
    }

//---------------------------------------------------------------------------
BOOL CEditWildcardRule::FillRulesList()
    {
    CERT_FIELD_ID   idCertField;
    LPBYTE          pContent;
    DWORD           cbContent;
    LPSTR           psz;

    CString         sz;
    int             i;

    // get the number of subfield rules
    DWORD cbRules = m_pRule->GetRuleElemCount();

    // loop the elements, adding each to the list
    for ( DWORD j = 0; j < cbRules; j++ )
        {
        // get the raw data for the rule element
        if ( !m_pRule->GetRuleElem( j, &idCertField, (PCHAR*)&pContent, &cbContent, &psz ) )
            continue;       // the call failed - try the next

        // start converting the data into readable form and adding it to the list
        sz = MapIdToField( idCertField );
        // create the new entry in the list box.
        i = m_clistctrl_list.InsertItem( j, sz );

        // add the subfield data
        sz = MapAsn1ToSubField( psz );
        m_clistctrl_list.SetItemText( i, COL_SUB_FIELD, sz );

        // add the content data - reuse the psz pointer
        if ( BinaryToMatchRequest( pContent, cbContent, &psz ) )
            m_clistctrl_list.SetItemText( i, COL_MATCH_CRITERIA, psz );

        // finally, attach the id cert field as user data to the item
        m_clistctrl_list.SetItemData( i, idCertField );
        }

        return TRUE;
    }

// editing and updating

//---------------------------------------------------------------------------
void CEditWildcardRule::EnableDependantButtons()
    {
    // the whole purpose of this routine is to gray or activate
    // the edit and delete buttons depending on whether or not anything
    // is selected. So start by getting the selection count
    UINT    cItemsSel = m_clistctrl_list.GetSelectedCount();

    if ( cItemsSel > 0 )
        {
        // there are items selected
        m_cbutton_edit.EnableWindow( TRUE );
        m_cbutton_delete.EnableWindow( TRUE );
        }
    else
        {
        // nope. Nothing selected
        m_cbutton_edit.EnableWindow( FALSE );
        m_cbutton_delete.EnableWindow( FALSE );
        }

    // always enable the new button
    m_cbutton_new.EnableWindow( TRUE );
}

//---------------------------------------------------------------------------
BOOL CEditWildcardRule::EditRule( DWORD iList )
    {
    // declare the editing dialog
    CEditRuleElement    editDlg;

    // fill in its data
    editDlg.m_int_field = m_clistctrl_list.GetItemData( iList );
    editDlg.m_sz_subfield = m_clistctrl_list.GetItemText( iList, COL_SUB_FIELD );
    editDlg.m_sz_criteria = m_clistctrl_list.GetItemText( iList, COL_MATCH_CRITERIA );

    // run the dialog
    if ( editDlg.DoModal() == IDOK )
        {
        // must convert the field into a string too
        CERT_FIELD_ID id = (CERT_FIELD_ID)editDlg.m_int_field;
        CString sz = MapIdToField( id );
        m_clistctrl_list.SetItemText( iList, COL_CERT_FIELD, sz );

        m_clistctrl_list.SetItemData( iList, id );
        m_clistctrl_list.SetItemText( iList, COL_SUB_FIELD, editDlg.m_sz_subfield );
        m_clistctrl_list.SetItemText( iList, COL_MATCH_CRITERIA, editDlg.m_sz_criteria );
        }
    return TRUE;
    }

/////////////////////////////////////////////////////////////////////////////
// CEditWildcardRule message handlers

//---------------------------------------------------------------------------
BOOL CEditWildcardRule::OnInitDialog()
    {
    // call the parental oninitdialog
    BOOL f = CNTBrowsingDialog::OnInitDialog();

    // set the easy default strings 
    m_sz_accountname = m_pRule->GetRuleAccount();   // managed by CNTBrowsingDialog from here on
    m_sz_description = m_pRule->GetRuleName();
    m_bool_enable = m_pRule->GetRuleEnabled();

    // set up the deny access radio buttons
    if ( m_pRule->GetRuleDenyAccess() )
        m_int_DenyAccess = ACCESS_DENY;
    else
        m_int_DenyAccess = ACCESS_ACCEPT;

    // set up the match issuer buttons
    if ( m_pRule->GetMatchAllIssuer() )
        m_int_MatchAllIssuers = MATCH_ISSUER_ALL;
    else
        m_int_MatchAllIssuers = MATCH_ISSUER_SOME;

    // initialize the list
    FInitRulesList();
    FillRulesList();
    EnableDependantButtons();

    // initialize the password
    m_sz_password = m_pRule->GetRulePassword();

    // exchange the data
    UpdateData( FALSE );

    // return the answer
    return f;
    }

//---------------------------------------------------------------------------
// this is the part where we fill in most of the items
void CEditWildcardRule::OnOK() 
    {
    CERT_FIELD_ID   id;
    CString         szSub, sz;
    LPBYTE          pbBin;
    DWORD           cbBin;
    UINT            cItems;
    UINT            iItem;


    // update the data
    UpdateData( TRUE );

    //======== store the rule elements
    // start by resetting the entire rule - that way we don't have to
    // mess with individual elements in the list, allowing us to cancel. 
    // But that is ok, because we can just spin through
    // the ones in the list very quickly and re-add them

    // remove the existing elements from the list.
    cItems = m_pRule->GetRuleElemCount();
    for ( iItem = 0; iItem < cItems; iItem++ )
        m_pRule->DeleteRuleElem( 0 );

    // add all the items in the list
    cItems = m_clistctrl_list.GetItemCount();
    for ( iItem = 0; iItem < cItems; iItem++ )
        {
        // prepare the field id
        id = (CERT_FIELD_ID)m_clistctrl_list.GetItemData( iItem );

        // prepare the subfield
        sz = m_clistctrl_list.GetItemText(iItem, COL_SUB_FIELD);
        szSub = MapSubFieldToAsn1( (PCHAR)(LPCSTR)sz );

        // prepare the data
        sz = m_clistctrl_list.GetItemText(iItem, COL_MATCH_CRITERIA);
        if ( !MatchRequestToBinary((PCHAR)(LPCSTR)sz, &pbBin, &cbBin) )
            continue;

        // add the element to the rule
        m_pRule->AddRuleElem( 0xffffffff, id, (PCHAR)(LPCSTR)szSub, pbBin, cbBin );

        // free the binary match data
        FreeMatchConversion( pbBin );
        }

    // set the easy data
    m_pRule->SetRuleName( (PCHAR)(LPCSTR)m_sz_description );
    m_pRule->SetRuleEnabled( m_bool_enable );

    // store the deny access radio buttons
    m_pRule->SetRuleDenyAccess( m_int_DenyAccess == ACCESS_DENY );

    // store the match issuer buttons
    m_pRule->SetMatchAllIssuer( m_int_MatchAllIssuers == MATCH_ISSUER_ALL );

    
    // we have to set the account name into place here
    m_pRule->SetRuleAccount( (PCHAR)(LPCSTR)m_sz_accountname );


    // store the password
    m_pRule->SetRulePassword( (PCHAR)(LPCSTR)m_sz_password );

    // it is valid
    CNTBrowsingDialog::OnOK();
    }

//---------------------------------------------------------------------------
void CEditWildcardRule::OnDblclkList(NMHDR* pNMHDR, LRESULT* pResult) 
    {
    *pResult = 0;
    // if something in the list was double clicked, edit it
    if ( m_clistctrl_list.GetSelectedCount() > 0 )
        OnEdit();
    }

//---------------------------------------------------------------------------
void CEditWildcardRule::OnItemchangedList(NMHDR* pNMHDR, LRESULT* pResult) 
    {
    NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;
    *pResult = 0;

    // enable the correct items
    EnableDependantButtons();
    }

//---------------------------------------------------------------------------
void CEditWildcardRule::OnEdit() 
    {
    ASSERT( m_clistctrl_list.GetSelectedCount() == 1 );
    DWORD           iList;

    // get index of the selected list item
    iList = m_clistctrl_list.GetNextItem( -1, LVNI_SELECTED );
    ASSERT( iList >= 0 );

    // edit the item
    EditRule( iList );
    }

//---------------------------------------------------------------------------
// actually very similar to editing an existing element
void CEditWildcardRule::OnNew() 
    {
    // declare the editing dialog
    CEditRuleElement    editDlg;

    // fill in its data
    editDlg.m_int_field = CERT_FIELD_SUBJECT;
//  editDlg.m_sz_subfield = MapAsn1ToSubField( "O" );
    editDlg.m_sz_subfield = "O";
    
    editDlg.m_sz_criteria.LoadString( IDS_WILDSTRING );

    // run the dialog
    if ( editDlg.DoModal() == IDOK )
        {
        // get the index for adding to the end of the list
        int iEnd = m_clistctrl_list.GetItemCount();

        // Start with the cert field
        CERT_FIELD_ID id = (CERT_FIELD_ID)editDlg.m_int_field;
        CString sz = MapIdToField( id );
        int i = m_clistctrl_list.InsertItem( iEnd, sz );

        m_clistctrl_list.SetItemData( i, id );
        m_clistctrl_list.SetItemText( i, COL_SUB_FIELD, editDlg.m_sz_subfield );
        m_clistctrl_list.SetItemText( i, COL_MATCH_CRITERIA, editDlg.m_sz_criteria );
        }
    }

//---------------------------------------------------------------------------
void CEditWildcardRule::OnDelete() 
    {
    ASSERT( m_clistctrl_list.GetSelectedCount() == 1 );
    DWORD           iList;

    // get index of the selected list item
    iList = m_clistctrl_list.GetNextItem( -1, LVNI_SELECTED );
    ASSERT( iList >= 0 );

    // delete the item from the display list
    m_clistctrl_list.DeleteItem ( iList );
    }

//---------------------------------------------------------------------------
// simple - just run the issuer dialog
void CEditWildcardRule::OnSelectIssuer() 
    {
    CSelectIssuersDlg   dlg(m_pMB);

    // prep the dialog
    dlg.m_pRule = m_pRule;
    dlg.m_szMBPath = m_szMBPath;

    dlg.m_sz_caption.LoadString( IDS_MATCH_ON_ISSUERS );

    // run it
    if ( dlg.DoModal() == IDOK )
        {
        UpdateData( TRUE );
        m_int_MatchAllIssuers = MATCH_ISSUER_SOME;
        UpdateData( FALSE );
        }
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\certmap\helpmap.h ===
// header file that equates to the helpmap file.
// these mappings are hand-made so as not to collide
// with other mappings made in other projects that
// all use the main help file

#define HIDD_CERTMAP_MAIN_BASIC                 0x50100
#define HIDD_CERTMAP_BASIC_MAP_ONE              0x50101
#define HIDD_CERTMAP_BASIC_MAP_MANY             0x50102

#define HIDD_CERTMAP_MAIN_ADVANCED              0x50110
#define HIDD_CERTMAP_ADV_RUL_GENERAL            0x50111
#define HIDD_CERTMAP_ADV_RUL_RULES              0x50112
#define HIDD_CERTMAP_ADV_RUL_MAPPING            0x50113
#define HIDD_CERTMAP_RUL_ELEMENT                0x50114
#define HIDD_CERTMAP_SELECT_ISSUERS             0x50115
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\certmap\hotlink.cpp ===
// HotLink.cpp : implementation file
//

#include "stdafx.h"
#include "resource.h"
#include "HotLink.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define COLOR_BLUE          RGB(0, 0, 0xFF)

/////////////////////////////////////////////////////////////////////////////
// CHotLink

CHotLink::CHotLink():
    m_CapturedMouse( FALSE ),
    m_fBrowse( FALSE ),
    m_fExplore( FALSE ),
    m_fOpen( FALSE ),
    m_fInitializedFont( FALSE )
{
}

CHotLink::~CHotLink()
{
}

BEGIN_MESSAGE_MAP(CHotLink, CButton)
    //{{AFX_MSG_MAP(CHotLink)
    ON_WM_LBUTTONDOWN()
    ON_WM_LBUTTONUP()
    ON_WM_MOUSEMOVE()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

//------------------------------------------------------------------------
// set the title string
void CHotLink::SetTitle( CString sz )
    {
    // set the title
    SetWindowText( sz );
    // force the window to redraw
    Invalidate( TRUE );
    }

/////////////////////////////////////////////////////////////////////////////
// CHotLink message handlers

//------------------------------------------------------------------------
void CHotLink::DrawItem( LPDRAWITEMSTRUCT lpDrawItemStruct )
    {
    // prep the device context
    CDC* pdc = CDC::FromHandle(lpDrawItemStruct->hDC);

    // get the drawing rect
    CRect rect = lpDrawItemStruct->rcItem;

    if ( ! m_fInitializedFont )
        {
        // get the window font
        CFont* pfont = GetFont();
        LOGFONT logfont;
        pfont->GetLogFont( &logfont );

        // modify the font  - add underlining
        logfont.lfUnderline = TRUE;

        // set the font back
        pfont->CreateFontIndirect( &logfont );
        SetFont( pfont, TRUE );

        m_fInitializedFont = TRUE;
        }

    // draw the text in blue
    pdc->SetTextColor( COLOR_BLUE );

    // draw the text
    CString sz;
    GetWindowText( sz );
    pdc->DrawText( sz, &rect, DT_LEFT|DT_SINGLELINE|DT_VCENTER );

    // get the extents fo the text for later reference
    m_cpTextExtents = pdc->GetOutputTextExtent( sz );
    }

//------------------------------------------------------------------------
// calculate the rectangle that surrounds the text
void CHotLink::GetTextRect( CRect &rect )
    {
    // get the main rect
    GetClientRect( rect );

    // reduce it by the width of the text
    rect.right = rect.left + m_cpTextExtents.cx;
    }

//------------------------------------------------------------------------
void CHotLink::OnLButtonDown(UINT nFlags, CPoint point)
    {
    // don't do the hotlink thing if there is no text
    CString sz;
    GetWindowText( sz );
    if ( sz.IsEmpty() )
        return;

    CRect   rect;
    GetTextRect( rect );
    if ( !m_CapturedMouse && rect.PtInRect(point) )
        {
        SetCapture( );
        m_CapturedMouse = TRUE;
        }
    }

//------------------------------------------------------------------------
void CHotLink::OnLButtonUp(UINT nFlags, CPoint point)
    {
    // only bother if we have the capture
    if ( m_CapturedMouse )
        {
        ReleaseCapture();
        if ( m_fBrowse )
            Browse();
        if ( m_fExplore )
            Explore();
        if ( m_fOpen )
            Open();
        }
    }

//------------------------------------------------------------------------
void CHotLink::Browse()
    {
    // get the window text
    CString sz;
    GetWindowText( sz );

    // and do it to it!
    ShellExecute(
        NULL,     // handle to parent window
        NULL,     // pointer to string that specifies operation to perform
        sz,       // pointer to filename or folder name string
        NULL,     // pointer to string that specifies executable-file parameters
        NULL,     // pointer to string that specifies default directory
        SW_SHOW   // whether file is shown when opened
       );
    }

//------------------------------------------------------------------------
void CHotLink::Explore()
    {
    // get the window text
    CString sz;
    GetWindowText( sz );

    // and do it to it!
    ShellExecute(
        NULL,          // handle to parent window
        _T("explore"), // pointer to string that specifies operation to perform
        sz,            // pointer to filename or folder name string
        NULL,          // pointer to string that specifies executable-file parameters
        NULL,          // pointer to string that specifies default directory
        SW_SHOW        // whether file is shown when opened
       );
    }

//------------------------------------------------------------------------
void CHotLink::Open()
    {
    // get the window text
    CString sz;
    GetWindowText(sz);

    // and do it to it!
    ShellExecute(
        NULL,          // handle to parent window
        _T("open"),    // pointer to string that specifies operation to perform
        sz,            // pointer to filename or folder name string
        NULL,          // pointer to string that specifies executable-file parameters
        NULL,          // pointer to string that specifies default directory
        SW_SHOW        // whether file is shown when opened
        );
    }

//------------------------------------------------------------------------
void CHotLink::OnMouseMove(UINT nFlags, CPoint point)
    {
    CRect   rect;
    GetTextRect( rect );
    // if the mouse is over the hot area, show the right cursor
    if ( rect.PtInRect(point) )
        ::SetCursor(AfxGetApp()->LoadCursor( IDC_BROWSE ));

//  CButton::OnMouseMove(nFlags, point);
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\certmap\hotlink.h ===
// HotLink.h : header file
//
#ifndef   _HotLink_h_file_123987_
#define   _HotLink_h_file_123987_



/////////////////////////////////////////////////////////////////////////////
// CHotLink window

class CHotLink : public CButton
{
// Construction
public:
    CHotLink();

// Attributes
public:
    BOOL    m_fBrowse;
    BOOL    m_fExplore;
    BOOL    m_fOpen;

// Operations
public:
    void Browse();
    void Explore();
    void Open();

    virtual void DrawItem( LPDRAWITEMSTRUCT lpDrawItemStruct );

    // set the title string
    void SetTitle( CString sz );

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CHotLink)
    //}}AFX_VIRTUAL

// Implementation
public:
    virtual ~CHotLink();

    // Generated message map functions
protected:
    //{{AFX_MSG(CHotLink)
    afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
    afx_msg void OnLButtonUp(UINT nFlags, CPoint point);
    afx_msg void OnMouseMove(UINT nFlags, CPoint point);
    //}}AFX_MSG

    DECLARE_MESSAGE_MAP()

    // height and width of the displayed text
    void GetTextRect( CRect &rect );
    CSize   m_cpTextExtents;

    // tracking the mouse flag
    BOOL    m_CapturedMouse;

    // init the font
    BOOL    m_fInitializedFont;
};

/////////////////////////////////////////////////////////////////////////////
#endif   /*_HotLink_h_file_123987_*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\certmap\edwldrul.h ===
// EdWldRul.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CEditWildcardRule dialog

class CEditWildcardRule : public CNTBrowsingDialog
{
// Construction
public:
    CEditWildcardRule(IMSAdminBase* pMB, CWnd* pParent = NULL);   // standard constructor
    virtual void OnOK();
    virtual BOOL OnInitDialog();

    // the only public member
    CCertMapRule*   m_pRule;

    // base path to the metabase
    CString m_szMBPath;


// Dialog Data
    //{{AFX_DATA(CEditWildcardRule)
    enum { IDD = IDD_WILDCARDS_2 };
    CListSelRowCtrl m_clistctrl_list;
    CButton m_cbutton_edit;
    CButton m_cbutton_delete;
    CButton m_cbutton_new;
    CString m_sz_description;
    BOOL    m_bool_enable;
    int     m_int_MatchAllIssuers;
    int     m_int_DenyAccess;
    //}}AFX_DATA


// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CEditWildcardRule)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL



// Implementation
protected:

    // Generated message map functions
    //{{AFX_MSG(CEditWildcardRule)
    afx_msg void OnDblclkList(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnItemchangedList(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnEdit();
    afx_msg void OnNew();
    afx_msg void OnDelete();
    afx_msg void OnSelectIssuer();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

    // more initialization methods
    BOOL FInitRulesList();
    BOOL FillRulesList();

    // editing and updating
    void EnableDependantButtons();
    BOOL EditRule( DWORD iList );

    IMSAdminBase*   m_pMB;
    };
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\certmap\keyring.h ===
#include "certmap.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\certmap\mapwpge.h ===
// MapWPge.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CMapWildcardsPge dialog

class CMapWildcardsPge : public CPropertyPage
{
    DECLARE_DYNCREATE(CMapWildcardsPge)

// Construction
public:
    CMapWildcardsPge();
    ~CMapWildcardsPge();

    BOOL    FInit(IMSAdminBase* pMB);

    virtual BOOL OnApply();
    virtual BOOL OnInitDialog();

    // base path for to the metabase
    CString m_szMBPath;


// Dialog Data
    //{{AFX_DATA(CMapWildcardsPge)
    enum { IDD = IDD_WILDCARDS_1 };
    CCheckListCtrl  m_clistctrl_list;
    CButton m_cbutton_up;
    CButton m_cbutton_down;
    CButton m_cbutton_add;
    CButton m_cbutton_delete;
    CButton m_cbutton_editrule;
    BOOL    m_bool_enable;
    //}}AFX_DATA


// Overrides
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CMapWildcardsPge)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:
    // Generated message map functions
    //{{AFX_MSG(CMapWildcardsPge)
    afx_msg void OnMoveDown();
    afx_msg void OnMoveUp();
    afx_msg void OnAdd();
    afx_msg void OnDelete();
    afx_msg void OnEdit();
    afx_msg void OnItemchangedList(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnDblclkList(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnEnable();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

    void DoHelp();


    // more initialization methods
    BOOL FInitRulesList();
    BOOL FillRulesList();

    // editing and updating
    void EnableDependantButtons();

    int AddRuleToList( CCertMapRule* pRule, DWORD iRule, int iInsert = 0xffffffff );
    void UpdateRuleInDispList( DWORD iList, CCertMapRule* pRule );

    BOOL EditOneRule( CCertMapRule* pRule, BOOL fAsWizard = FALSE );
    BOOL EditMultipleRules();

    void OnMove( int delta );


    // its storage/persistance object
//  CMBWrap             m_mbWrap;

    // its mapper
    CIisRuleMapper      m_mapper;

    CString             m_szMetaPath;
    IMSAdminBase*       m_pMB;

    // flag indicating if changes have been made
    BOOL                m_fDirty;
    };
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\certmap\listrow.cpp ===
// ListRow.cpp : implementation file
//

#include "stdafx.h"
#include "certmap.h"
#include "ListRow.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


#define SZ_RES_COLOR_PREFS      "Control Panel\\Colors"
#define SZ_RES_COLOR_HILITE     "Hilight"
#define SZ_RES_COLOR_HILITETEXT "HilightText"


/////////////////////////////////////////////////////////////////////////////
// CListSelRowCtrl
//-----------------------------------------------------------------------------------
CListSelRowCtrl::CListSelRowCtrl():
        m_StartDrawingCol( 0 )
    {
    }

//-----------------------------------------------------------------------------------
CListSelRowCtrl::~CListSelRowCtrl()
    {
    }


//-----------------------------------------------------------------------------------
BEGIN_MESSAGE_MAP(CListSelRowCtrl, CListCtrl)
    //{{AFX_MSG_MAP(CListSelRowCtrl)
    ON_WM_LBUTTONDOWN()
    ON_WM_LBUTTONDBLCLK()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

//-----------------------------------------------------------------------------------
void CListSelRowCtrl::GetHiliteColors()
    {
    // get the hilite color
    m_colorHilite = GetSysColor( COLOR_HIGHLIGHT );

    // get the hilited text color
    m_colorHiliteText = GetSysColor( COLOR_HIGHLIGHTTEXT );
    }



/////////////////////////////////////////////////////////////////////////////
// CListSelRowCtrl message handlers

//-----------------------------------------------------------------------------------
void CListSelRowCtrl::DrawItem(LPDRAWITEMSTRUCT lpDrawItemStruct)
    {
    CRect       rcItem = lpDrawItemStruct->rcItem;
    CRect       rcSection;
    UINT        itemID = lpDrawItemStruct->itemID;
    UINT        cpLeft = rcItem.left;
    CString     sz;
    LV_COLUMN   colData;
    COLORREF    colorTextOld;
    COLORREF    colorBackOld;

    // setup the CDC object
    CDC         cdc;
    cdc.Attach( lpDrawItemStruct->hDC );

#ifdef _DEBUG
    if ( m_StartDrawingCol == 0 )
        sz.Empty();
#endif

    // clear the columnd buffer
    ZeroMemory( &colData, sizeof(colData) );
    colData.mask = LVCF_WIDTH;

    // if this is the selected item, prepare the background and the text color
    BOOL fSelected = lpDrawItemStruct->itemState & ODS_SELECTED;
    if ( fSelected )
        {
        GetHiliteColors();
        colorTextOld = cdc.SetTextColor( m_colorHiliteText );
        colorBackOld = cdc.SetBkColor( m_colorHilite );
        }

    // starting with the m_StartDrawingCol column, draw the columns
    // do it in a loop, just skipping until we hit m_StartDrawingCol
    DWORD iCol = 0;
    while ( GetColumn(iCol, &colData) )
        {
        // see if we are ready yet
        if ( iCol < m_StartDrawingCol )
            {
            // set the new left.
            cpLeft += colData.cx;
            // increment the column counter
            iCol++;
            continue;
            }

        // prepare the background but once
        if ( iCol == m_StartDrawingCol )
            {
            // prepare the background
            rcSection = rcItem;
            rcSection.left = cpLeft;
            rcSection.right--;
            CBrush  brush;
            if ( lpDrawItemStruct->itemState & ODS_SELECTED )
                brush.CreateSolidBrush( m_colorHilite );
            else
                brush.CreateSolidBrush( GetSysColor( COLOR_WINDOW ) );
            cdc.FillRect( &rcSection, &brush );
            }


        // display the name
        sz = GetItemText( itemID, iCol );
        if ( !sz.IsEmpty() )
            {
            // figure out the sectional rect
            rcSection = rcItem;
            rcSection.left = cpLeft + 2;
            rcSection.right = cpLeft + colData.cx - 1;
            
            // fit the string into the required space
            FitString( sz, rcSection.right - rcSection.left, &cdc );

            //draw the string
            cdc.DrawText( sz, &rcSection, DT_SINGLELINE|DT_LEFT|DT_BOTTOM|DT_NOPREFIX );
            }

        // set the new left.
        cpLeft += colData.cx;
        // increment the column counter
        iCol++;
        }

    // if this is the selected item, restore the colors
    if ( fSelected )
        {
        cdc.SetTextColor( colorTextOld );
        cdc.SetBkColor( colorBackOld );
        }

    // cleanup the CDC object
    cdc.Detach();
    }


//------------------------------------------------------------------------
void CListSelRowCtrl::FitString( CString &sz, int cpWidth, CDC* pcdc )
    {
    CSize       size;
    UINT        cch;
    CString     szEllipsis;

    // start by testing the existing width
    size = pcdc->GetTextExtent( sz );
    if ( size.cx <= cpWidth ) return;

    // initialize szTrunc and szEllipsis
    cch = sz.GetLength();

    szEllipsis.LoadString(IDS_ELLIPSIS);

    // while we are too big, truncate one letter and add an ellipsis
    while( (size.cx > cpWidth) && (cch > 1) )
        {
        // chop off the last letter of the string - not counting the ...
        cch--;
        sz = sz.Left( cch );

        // add the elipsis (spelling?)
        sz += szEllipsis;

        // get the length
        size = pcdc->GetTextExtent( sz );
        }
    }







//------------------------------------------------------------------------
void CListSelRowCtrl::HiliteSelectedCells()
    {
    int iList = -1;
    while( (iList = GetNextItem( iList, LVNI_SELECTED )) >= 0 )
        HiliteSelectedCell( iList );
    }

//------------------------------------------------------------------------
void CListSelRowCtrl::HiliteSelectedCell( int iCell, BOOL fHilite )
    {
    // if there is no selected cell, do nothing
    if ( iCell < 0 )
        return;

    // get the rect to draw
    CRect   rect;
    if ( !FGetCellRect(iCell, -1, &rect) )
        {
        ASSERT(FALSE);
        return;
        }

    // get the client rect
    CRect   rectClient;
    GetClientRect( rectClient );

    // make sure it fits ok (problems can occur here when scrolled)
    // don't want it to draw in the column titles
    if ( rect.top < (rect.bottom - rect.top) )
        return;

    // now prepare to draw
    CDC *pdc = GetDC();

    // clip to the client area
    pdc->IntersectClipRect( rectClient );

    // set up the brush
    CBrush  cbrush;
    if ( fHilite )
        cbrush.CreateSolidBrush( RGB(192,192,192) );
    else
        cbrush.CreateSolidBrush( RGB(0xFF,0xFF,0xFF) );

    // draw the hilite rect
    pdc->FrameRect( rect, &cbrush );

    // cleanup
    ReleaseDC( pdc );
    }

//------------------------------------------------------------------------
BOOL    CListSelRowCtrl::FGetCellRect( LONG iRow, LONG iCol, CRect *pcrect )
    {
    // first, get the rect that the list thinks is appropriate
    if ( !GetItemRect(iRow, pcrect, LVIR_BOUNDS) )
        return FALSE;

    // if iCol < 0, then return the total size of the row
    if ( iCol < 0 )
        return TRUE;

    // trim the horizontal dimension to the correct column positioning
    LONG    cpLeft;
    LONG    cpRight = 0;
    for ( WORD i = 0; i <= iCol; i++ )
        {
        // set the left side
        cpLeft = cpRight;

        // get the right
        LONG cpWidth = GetColumnWidth(i);
        if ( cpWidth < 0 ) return FALSE;
        cpRight += cpWidth;
        }

    // well, now trim it seeing as we have the right values
    pcrect->left = cpLeft;
    pcrect->right = cpRight;
    
    // success!
    return TRUE;
    }

#define MAKE_LPARAM(x,y) ( ((unsigned long)(y)<<16) | ((unsigned long)(x)) )

//------------------------------------------------------------------------
void CListSelRowCtrl::OnLButtonDblClk(UINT nFlags, CPoint point) 
    {
    // force the point to be in the right place
    point.x = 6;
    LPARAM lp = MAKE_LPARAM(point.x, point.y);
//  DefWindowProc(WM_LBUTTONDBLCLK, nFlags, lp );
    CListCtrl::OnLButtonDblClk( nFlags, point);
    }

//------------------------------------------------------------------------
void CListSelRowCtrl::OnLButtonDown(UINT nFlags, CPoint point) 
    {
    point.x = 6;
    LPARAM lp = MAKE_LPARAM(point.x, point.y);
//  DefWindowProc(WM_LBUTTONDOWN, nFlags, lp );
    CListCtrl::OnLButtonDown( nFlags, point);
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\certmap\map11pge.cpp ===
// Map11Pge.cpp : implementation file
//

#include "stdafx.h"
#include <iadmw.h>
#include "certmap.h"

// persistence and mapping includes
#include "WrapMaps.h"
//#include "wrpprsis.h"
//#include "admutil.h"

#include "ListRow.h"
#include "ChkLstCt.h"

#include "wrapmb.h"

// mapping page includes
#include "brwsdlg.h"
#include "EdtOne11.h"
#include "Ed11Maps.h"
#include "Map11Pge.h"

#include "CrackCrt.h"

#include <iiscnfgp.h>
//#include "WrpMBWrp.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


#define COL_NUM_ENABLED         0
#define COL_NUM_NAME            1
#define COL_NUM_NTACCOUNT       2


#define MB_EXTEND_KEY           _T("Cert11")
#define MB_EXTEND_KEY_MAPS      _T("Cert11/Mappings")

/////////////////////////////////////////////////////////////////////////////
// CMap11Page property page

IMPLEMENT_DYNCREATE(CMap11Page, CPropertyPage)

CMap11Page::CMap11Page() : CPropertyPage(CMap11Page::IDD),
                m_MapsInMetabase( 0 )
    {
    //{{AFX_DATA_INIT(CMap11Page)
    m_csz_i_c = _T("");
    m_csz_i_o = _T("");
    m_csz_i_ou = _T("");
    m_csz_s_c = _T("");
    m_csz_s_cn = _T("");
    m_csz_s_l = _T("");
    m_csz_s_o = _T("");
    m_csz_s_ou = _T("");
    m_csz_s_s = _T("");
    //}}AFX_DATA_INIT
    }

CMap11Page::~CMap11Page()
    {
    ResetMappingList();
    }

void CMap11Page::DoDataExchange(CDataExchange* pDX)
    {
    CPropertyPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CMap11Page)
    DDX_Control(pDX, IDC_ADD, m_cbutton_add);
    DDX_Control(pDX, IDC_ISSUER, m_cbutton_grp_issuer);
    DDX_Control(pDX, IDC_ISSUED_TO, m_cbutton_grp_issuedto);
    DDX_Control(pDX, IDC_LIST, m_clistctrl_list);
    DDX_Control(pDX, IDC_EDIT_11MAP, m_cbutton_editmap);
    DDX_Control(pDX, IDC_DELETE, m_cbutton_delete);
    DDX_Text(pDX, IDC_I_C, m_csz_i_c);
    DDX_Text(pDX, IDC_I_O, m_csz_i_o);
    DDX_Text(pDX, IDC_I_OU, m_csz_i_ou);
    DDX_Text(pDX, IDC_S_C, m_csz_s_c);
    DDX_Text(pDX, IDC_S_CN, m_csz_s_cn);
    DDX_Text(pDX, IDC_S_L, m_csz_s_l);
    DDX_Text(pDX, IDC_S_O, m_csz_s_o);
    DDX_Text(pDX, IDC_S_OU, m_csz_s_ou);
    DDX_Text(pDX, IDC_S_S, m_csz_s_s);
    //}}AFX_DATA_MAP
    }


BEGIN_MESSAGE_MAP(CMap11Page, CPropertyPage)
    //{{AFX_MSG_MAP(CMap11Page)
    ON_BN_CLICKED(IDC_ADD, OnAdd)
    ON_BN_CLICKED(IDC_DELETE, OnDelete)
    ON_BN_CLICKED(IDC_EDIT_11MAP, OnEdit11map)
    ON_NOTIFY(LVN_ITEMCHANGED, IDC_LIST, OnItemchangedList)
    ON_NOTIFY(NM_DBLCLK, IDC_LIST, OnDblclkList)
    //}}AFX_MSG_MAP
    ON_COMMAND(ID_HELP_FINDER,  DoHelp)
    ON_COMMAND(ID_HELP,         DoHelp)
    ON_COMMAND(ID_CONTEXT_HELP, DoHelp)
    ON_COMMAND(ID_DEFAULT_HELP, DoHelp)
END_MESSAGE_MAP()

//---------------------------------------------------------------------------
void CMap11Page::DoHelp()
    {
    WinHelp( HIDD_CERTMAP_MAIN_BASIC );
    }

/////////////////////////////////////////////////////////////////////////////
// initialization routines

//---------------------------------------------------------------------------
// FInitMapper is called by the routine instantiating this page. After the object
// is first created is when it is called. It allows us to fail gracefully.
BOOL    CMap11Page::FInit(IMSAdminBase* pMB)
        {
        m_pMB = pMB;

        // this has become a simple place
        return TRUE;
        }

//---------------------------------------------------------------------------
BOOL CMap11Page::OnInitDialog()
    {
    //call the parental oninitdialog
    BOOL f = CPropertyPage::OnInitDialog();

    // if the initinalization (sp?) succeeded, init the list and other items
    if ( f )
        {
        // init the contents of the list
        FInitMappingList();

        // Fill the mapping list with the stored items
        FillMappingList();

        // set the initial button states
        EnableDependantButtons();
        }

    // set any changes in the info into place
    UpdateData(FALSE);

    // return the answer
    return f;
    }

//---------------------------------------------------------------------------
BOOL    CMap11Page::FInitMappingList()
    {
    CString sz;
    int             i;

    // setup the friendly name column
    sz.Empty();
    i = m_clistctrl_list.InsertColumn( COL_NUM_ENABLED, sz, LVCFMT_LEFT, 20 );

    // setup the friendly name column
    sz.LoadString( IDS_LIST11_NAME );

    i = m_clistctrl_list.InsertColumn( COL_NUM_NAME, sz, LVCFMT_LEFT, 105 );

    // setup the account column
    sz.LoadString( IDS_LIST11_ACCOUNT );

    i = m_clistctrl_list.InsertColumn( COL_NUM_NTACCOUNT, sz, LVCFMT_LEFT, 195 );

    return TRUE;
    }

//---------------------------------------------------------------------------
BOOL    CMap11Page::FillMappingList()
    {
    // reset the mapping list - get rid of anything in there now
    ResetMappingList();

    // read in the mappings - it adds them to the list
    FReadMappings();

    return TRUE;
    }

//---------------------------------------------------------------------------
//BOOL CMap11Page::FAddMappingToList( C11Mapping* pMap, DWORD iList )
BOOL CMap11Page::FAddMappingToList( C11Mapping* pMap )
    {
    CString sz;
    int     i;
    DWORD   iList;

    // if requested, make sure the mapping is added to the end of the list
    iList = m_clistctrl_list.GetItemCount();

    // get the appropriate "enabled" string
    BOOL fEnabled;
    pMap->GetMapEnabled( &fEnabled );
    if ( fEnabled )
         sz.LoadString( IDS_ENABLED );
    else
        sz.Empty();

    // add the friendly name of the mapping
    // create the new entry in the list box. Do not sort on this entry - yet
    i = m_clistctrl_list.InsertItem( iList, sz );

    // add the friendly name of the mapping
    pMap->GetMapName( sz );
    // create the new entry in the list box. Do not sort on this entry - yet
    m_clistctrl_list.SetItemText( i, COL_NUM_NAME, sz );

    // add the account name of the mapping
    pMap->GetNTAccount( sz );
    m_clistctrl_list.SetItemText( i, COL_NUM_NTACCOUNT, sz );

    // attach the pointer to the mapping as the private data in the list.
    m_clistctrl_list.SetItemData( i, (UINT_PTR)pMap );

    // return whether or not the insertion succeeded
    return TRUE;
    }

//---------------------------------------------------------------------------
void CMap11Page::EnableDependantButtons()
    {
    // the whole purpose of this routine is to gray or activate
    // the edit and delete buttons depending on whether or not anything
    // is selected. So start by getting the selection count
    if ( m_clistctrl_list.GetSelectedCount() > 0 )
        {
        // there are items selected
        m_cbutton_editmap.EnableWindow( TRUE );
        m_cbutton_delete.EnableWindow( TRUE );
        EnableCrackDisplay( TRUE );
        }
    else
        {
        // nope. Nothing selected
        m_cbutton_editmap.EnableWindow( FALSE );
        m_cbutton_delete.EnableWindow( FALSE );
        }

    // always enable the add button
    m_cbutton_add.EnableWindow( TRUE );
    }

//---------------------------------------------------------------------------
BOOL CMap11Page::EditOneMapping( C11Mapping* pUpdateMap )
    {
    CEditOne11MapDlg        mapdlg;

    // prepare the mapping dialog
    pUpdateMap->GetMapName( mapdlg.m_sz_mapname );
    pUpdateMap->GetMapEnabled( &mapdlg.m_bool_enable );
    pUpdateMap->GetNTAccount( mapdlg.m_sz_accountname );
    pUpdateMap->GetNTPassword( mapdlg.m_sz_password );

    // run the mapping dialog
    if ( mapdlg.DoModal() == IDOK )
        {
        // update its friendly name
        pUpdateMap->SetMapName( mapdlg.m_sz_mapname );

        // set the NT account field of the mapping object
        pUpdateMap->SetNTAccount( mapdlg.m_sz_accountname );

        // set the NT account password field of the mapping object
        pUpdateMap->SetNTPassword( mapdlg.m_sz_password );

        // set whether or not the mapping is enabled
        pUpdateMap->SetMapEnabled( mapdlg.m_bool_enable );

        // NOTE: the caller is resposible for calling UpdateMappingInDispList
        // as the mapping in question may not yet be in the display list

        // this mapping has changed. Mark it to be saved
        MarkToSave( pUpdateMap );

        // return true because the user said "OK"
        return TRUE;
        }

    // return FALSE because the user did not say "OK"
    return FALSE;
    }

//---------------------------------------------------------------------------
BOOL CMap11Page::EditMultipleMappings()
        {
        CEdit11Mappings mapdlg;
        C11Mapping*             pUpdate11Map;
        BOOL                    fSetInitialState = FALSE;
        BOOL                    fEnable;


        // scan the list of seleted items for the proper initial enable button state
                // loop through the selected items, setting each one's mapping
                int     iList = -1;
                while( (iList = m_clistctrl_list.GetNextItem( iList, LVNI_SELECTED )) >= 0 )
                        {
                        // get the mapping item for updating purposes
                        pUpdate11Map = GetMappingInDisplay( iList );
                        ASSERT( pUpdate11Map );
                        if ( !pUpdate11Map )
                                {
                                AfxMessageBox( IDS_ERR_ACCESS_MAPPING );
                                break;
                                }

                        // get the enable state of the mapping
                        pUpdate11Map->GetMapEnabled( &fEnable );

                        // if this is the first time, just set the initial state
                        if ( !fSetInitialState )
                                {
                                mapdlg.m_int_enable = fEnable;
                                fSetInitialState = TRUE;
                                }
                        else
                                {
                                // if it is different, then go indeterminate and break
                                if ( fEnable != mapdlg.m_int_enable )
                                        {
                                        mapdlg.m_int_enable = 2;
                                        break;
                                        }
                                }
                        }

        // run the mapping dialog
        if ( mapdlg.DoModal() == IDOK )
                {
                // loop through the selected items, setting each one's mapping
                int     iList = -1;
                while( (iList = m_clistctrl_list.GetNextItem( iList, LVNI_SELECTED )) >= 0 )
                        {
                        // get the mapping item for updating purposes
                        pUpdate11Map = GetMappingInDisplay( iList );
                        if ( !pUpdate11Map )
                                {
                                AfxMessageBox( IDS_ERR_ACCESS_MAPPING );
                                break;
                                }

                        // set the enable flag if requested
                        switch ( mapdlg.m_int_enable )
                                {
                                case 0:         // disable
                                        pUpdate11Map->SetMapEnabled( FALSE );
                                        break;
                                case 1:         // enable
                                        pUpdate11Map->SetMapEnabled( TRUE );
                                        break;
                                }

                        // set the NT account field of the mapping object
                        pUpdate11Map->SetNTAccount( mapdlg.m_sz_accountname );

                        // set the NT account password field of the mapping object
                        pUpdate11Map->SetNTPassword( mapdlg.m_sz_password );

                        // update it in the list control too
                        UpdateMappingInDispList( iList, pUpdate11Map );

                        // this mapping has changed. Mark it to be saved
                        MarkToSave( pUpdate11Map );
                        }

                // activate the apply button
                SetModified();

                // return true because the user said "OK"
                return TRUE;
                }

        // return FALSE because the user did not say "OK"
        return FALSE;
        }


//---------------------------------------------------------------------------
void CMap11Page::UpdateMappingInDispList( DWORD iList, C11Mapping* pMap )
    {
    CString sz;

    // verify the index and the pointer!
    ASSERT( pMap == GetMappingInDisplay(iList) );

    // get the appropriate "enabled" string
    BOOL fEnabled;
    pMap->GetMapEnabled( &fEnabled );
    if ( fEnabled )
        sz.LoadString( IDS_ENABLED );
    else
        sz.Empty();

    // update the "Enabled" indicator
    m_clistctrl_list.SetItemText( iList, COL_NUM_ENABLED, sz );

    // update the mapping name
    pMap->GetMapName( sz );
    m_clistctrl_list.SetItemText( iList, COL_NUM_NAME, sz );

    // update the account name
    pMap->GetNTAccount( sz );
    m_clistctrl_list.SetItemText( iList, COL_NUM_NTACCOUNT, sz );
    }

//---------------------------------------------------------------------------
void CMap11Page::ResetMappingList()
    {
    // first, delete all the mapping objects in the list
    DWORD cbList = m_clistctrl_list.GetItemCount();
    for ( DWORD iList = 0; iList < cbList; iList++ )
        DeleteMapping( GetMappingInDisplay(iList) );

    // reset the mapping list - get rid of anything in there now
    m_clistctrl_list.DeleteAllItems();
    }

//---------------------------------------------------------------------------
void CMap11Page::MarkToSave( C11Mapping* pSaveMap, BOOL fSave )
        {
        // first, we see if it is already in the list. If it is, we have nothing to do
        // unless fSave is set to false, then we remove it from the list
        DWORD cbItemsInList = (DWORD)m_rgbSave.GetSize();
        for ( DWORD i = 0; i < cbItemsInList; i++ )
            {
            if ( pSaveMap == (C11Mapping*)m_rgbSave[i] )
                {
                // go away if fSave, otherwise, double check it isn't
                // anywhere else in the list
                if ( fSave )
                    {
                    return;
                    }
                else
                    {
                    // remove the item from the list
                    m_rgbSave.RemoveAt(i);
                    // don't skip now as the list slid down
                    cbItemsInList--;
                    i--;
                    }
                }
            }

        // since it is not there, we should add it, if fSave is true
        if ( fSave )
            m_rgbSave.Add( (CObject*)pSaveMap );
        }

/////////////////////////////////////////////////////////////////////////////
// CMap11Page message handlers


//---------------------------------------------------------------------------
void CMap11Page::OnOK()
    {
    // this has gotten much simpler
    FWriteMappings();
    CPropertyPage::OnOK();
    }

//---------------------------------------------------------------------------
BOOL CMap11Page::OnApply()
    {
    // this has gotten much simpler
    BOOL f = FWriteMappings();
    // rebuild the display
    FillMappingList();
    return f;
    }

//#define MB_EXTEND_KEY         "nsepm/Cert11/"
//#define MB_EXTEND_KEY_MAPS    "nsepm/Cert11/Mappings/"

//---------------------------------------------------------------------------
// when the user pushes the add button, ask them to load a certificate, then
// add it to the list as a mapping
    void CMap11Page::OnAdd()
    {

    // put this in a try/catch to make errors easier to deal with
    try {
        CString     szFilter;
        szFilter.LoadString( IDS_KEY_OR_CERT_FILE_FILTER );

        // prepare the file dialog variables
        CFileDialog cfdlg(TRUE, NULL, NULL,
                    OFN_FILEMUSTEXIST | OFN_PATHMUSTEXIST | OFN_HIDEREADONLY,
                    (LPCTSTR)szFilter);
		// Disable hook to get Windows 2000 style dialog
		cfdlg.m_ofn.Flags &= ~(OFN_ENABLEHOOK);
        // run the dialog
        if ( cfdlg.DoModal() == IDOK )
            {
            // add the certificate to the mapping list
            if ( FAddCertificateFile( cfdlg.GetPathName() ) )
                {
                // activate the apply button
                SetModified();
                }
            }
        }
    catch ( CException e )
        {
        }
    }

//---------------------------------------------------------------------------
void CMap11Page::OnDelete()
    {
    C11Mapping* pKillMap;

    // ask the user to confirm this decision
    if ( AfxMessageBox(IDS_CONFIRM_DELETE, MB_OKCANCEL) != IDOK )
        return;

    // loop through the selected items. Remove each from the list,
    // then mark it to be deleted.
    int     iList = -1;
    while( (iList = m_clistctrl_list.GetNextItem( -1, LVNI_SELECTED )) >= 0 )
        {
        // get the mapping
        pKillMap = GetMappingInDisplay( iList );

        // remove it from the list
        m_clistctrl_list.DeleteItem( iList );

        // if it has not yet been applied to the metabase, continue
        if ( pKillMap->iMD == NEW_OBJECT )
            {
            // since this mapping never existed, we can just remove it from the add/edit lists
            MarkToSave( pKillMap, FALSE );

            // go to the next selected object
            continue;
            }

        // mark the item to be deleted from the metabase
        m_rgbDelete.Add( (CObject*)pKillMap );
        }

    // activate the apply button
    SetModified();
    }

//---------------------------------------------------------------------------
void CMap11Page::OnEdit11map()
    {
    int             iList;
    C11Mapping*     pUpdateMap;

    // what happens here depends on if just one mapping is selected, or many
    switch( m_clistctrl_list.GetSelectedCount() )
        {
        case 0:         // do nothing - should not get here because button grays out
            ASSERT( FALSE );
            break;

        case 1:         // get the mapping for update and run single edit dialog
            // get index of the selected list item
            iList = m_clistctrl_list.GetNextItem( -1, LVNI_SELECTED );
            ASSERT( iList >= 0 );


            // get the mapping item for updating purposes
            pUpdateMap = GetMappingInDisplay( iList );
            if ( !pUpdateMap )
                {
                AfxMessageBox( IDS_ERR_ACCESS_MAPPING );
                break;
                }

            // edit the mapping, update it if successful, delete if not
            if ( EditOneMapping(pUpdateMap) )
                {
                UpdateMappingInDispList( iList, pUpdateMap );
                // activate the apply button
                SetModified();
                }
            break;

        default:        // run the multi edit dialog
            EditMultipleMappings();
            break;
        }
    }

//---------------------------------------------------------------------------
void CMap11Page::OnDblclkList(NMHDR* pNMHDR, LRESULT* pResult)
    {
    *pResult = 0;

    // if something in the list was double clicked, edit it
    if ( m_clistctrl_list.GetSelectedCount() > 0 )
        OnEdit11map();
    }

//---------------------------------------------------------------------------
void CMap11Page::OnItemchangedList(NMHDR* pNMHDR, LRESULT* pResult)
    {
    C11Mapping*     pSelMap;
    NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;
    *pResult = 0;

    // enable the correct items
    EnableDependantButtons();

    // fill in the cracked information for the selected mapping - if there is only one
    if ( m_clistctrl_list.GetSelectedCount() == 1 )
        {
        // get index of the selected list item
        int i = m_clistctrl_list.GetNextItem( -1, LVNI_SELECTED );
        ASSERT( i >= 0 );

        // get the mapper index for the item
        pSelMap = GetMappingInDisplay( i );
        if ( pSelMap )
            {
            DisplayCrackedMap( pSelMap );
            }
        }
    else
        {
        // either multiple, or no mappings selected
        EnableCrackDisplay( FALSE );
        }
    }


//================================================================================
// special display
//---------------------------------------------------------------------------
BOOL CMap11Page::DisplayCrackedMap( C11Mapping* pMap )
    {
    PUCHAR                          pCert;
    DWORD                           cbCert;
    CString                         sz;

    // obtain a reference to the certificate
    if ( !pMap->GetCertificate( &pCert, &cbCert ) )
            return FALSE;

    // crack the certificate
    CCrackedCert    cracker;
    if ( !cracker.CrackCert( pCert, cbCert ) )
            return FALSE;

    // fill in all the fields
    cracker.GetIssuerCountry( sz );
    m_csz_i_c = sz;

    cracker.GetIssuerOrganization( sz );
    m_csz_i_o = sz;

    cracker.GetIssuerUnit( sz );
    m_csz_i_ou = sz;

    cracker.GetSubjectCountry( sz );
    m_csz_s_c = sz;

    cracker.GetSubjectCommonName( sz );
    m_csz_s_cn = sz;

    cracker.GetSubjectLocality( sz );
    m_csz_s_l = sz;

    cracker.GetSubjectOrganization( sz );
    m_csz_s_o = sz;

    cracker.GetSubjectUnit( sz );
    m_csz_s_ou = sz;

    cracker.GetSubjectState( sz );
    m_csz_s_s = sz;

    UpdateData( FALSE );

    // return success
    return TRUE;
    }

//---------------------------------------------------------------------------
void CMap11Page::ClearCrackDisplay()
    {
    m_csz_i_c.Empty();
    m_csz_i_o.Empty();
    m_csz_i_ou.Empty();
    m_csz_s_c.Empty();
    m_csz_s_cn.Empty();
    m_csz_s_l.Empty();
    m_csz_s_o.Empty();
    m_csz_s_ou.Empty();
    m_csz_s_s.Empty();
    UpdateData( FALSE );
    }

//---------------------------------------------------------------------------
void CMap11Page::EnableCrackDisplay( BOOL fEnable )
    {
    if ( !fEnable )
            ClearCrackDisplay();
    m_cbutton_grp_issuer.EnableWindow( fEnable );
    m_cbutton_grp_issuedto.EnableWindow( fEnable );
    }

//---------------------------------------------------------------------------
BOOL CMap11Page::FReadMappings()
    {
    BOOL                    f;
    C11Mapping*             pMap;
    DWORD                   cbData;
    PVOID                   pData;
    DWORD                   fEnabled;
    CString                 sz;
    BOOL                    fRet = TRUE;

    // before messing with the metabase, prepare the strings we will need
    CString                 szBasePath = m_szMBPath + _T('/');
    CString                 szRelativePath = MB_EXTEND_KEY_MAPS;
    CString                 szObjectPath = m_szMBPath + _T('/') + szRelativePath;
    CString                 szMapPath;

    // prepare the metabase wrappers
    CWrapMetaBase   mbWrap;
    f = mbWrap.FInit(m_pMB);

    // open the base object
    f = mbWrap.Open( szObjectPath, METADATA_PERMISSION_READ );
    ASSERT( f );
    if ( !f )
        {
        return FALSE;
        }

    // for now, at least, we are reading in all the mappings. reset the m_nNamer counter
    // so that we end up with a somewhat accurate reading of the last number-name in the list.
    m_MapsInMetabase = 0;

    // Loop the items in the metabase, adding each to the napper.
    DWORD index = 0;
    CString     szEnum;
    while ( mbWrap.EnumObjects(_T(""), szEnum.GetBuffer(MAX_PATH*sizeof(WCHAR)),
                        MAX_PATH*sizeof(WCHAR), index) )
        {
        szEnum.ReleaseBuffer();

        // keep track of the number of mappings we encounter
        m_MapsInMetabase++;

        // build the final mapping object path
        szMapPath.Format( _T("/%s"), szEnum );

        // make a new mapping object
        pMap = PNewMapping();

        if (pMap == NULL) {
            SetLastError(E_OUTOFMEMORY);
            fRet = FALSE;
            break;
        }

        // install the object name into the mapping
        pMap->iMD = m_MapsInMetabase;

        // get the certificate
        pData = mbWrap.GetData( szMapPath, MD_MAPCERT, IIS_MD_UT_SERVER, BINARY_METADATA, &cbData );
        if ( pData )
            {
            // set the data into place
            pMap->SetCertificate( (PUCHAR)pData, cbData );
            // free the buffer
            mbWrap.FreeWrapData( pData );
            }

        // get the NT Account - a string
        cbData = METADATA_MAX_NAME_LEN;
        if ( Get11String( &mbWrap, szMapPath, MD_MAPNTACCT, sz) )
            {
            pMap->SetNTAccount( sz );
            }

        // get the NT Password
        cbData = METADATA_MAX_NAME_LEN;
        if ( Get11String( &mbWrap, szMapPath, MD_MAPNTPWD, sz) )
            {
            pMap->SetNTPassword( sz );
            }

        // get the Enabled flag
        if ( mbWrap.GetDword( szMapPath, MD_MAPENABLED, IIS_MD_UT_SERVER, &fEnabled) )
            pMap->SetMapEnabled( (fEnabled > 0) );

        // get the mapping name
        cbData = METADATA_MAX_NAME_LEN;
        if ( Get11String( &mbWrap, szMapPath, MD_MAPNAME, sz) )
            {
            pMap->SetMapName( sz );
            }

        // add the mapping to the list
        FAddMappingToList( pMap );

        // increment the index
        index++;
        }
    szEnum.ReleaseBuffer();

    // close the mapping object
    mbWrap.Close();

    // return success
    return fRet;
    }

//---------------------------------------------------------------------------
// IMPORTANT: There is a bug in the mapping namespace extension where, even
// though we are using the unicode metabase interface, all the strings are
// expected to be ansi. This means that we cannont use the wrapmb getstring
// and setstring calls with regards to the nsmp extetention. That is why
// there are these two string wrapper classes that

// also, all the strings used here are IIS_MD_UT_SERVER, so we can elimiate that parameter.
BOOL CMap11Page::Get11String(CWrapMetaBase* pmb, LPCTSTR pszPath, DWORD dwPropID, CString& sz)
    {
    DWORD   dwcb;
    BOOL    fAnswer = FALSE;

    // get the string using the self-allocating get data process
    // that that it is cast as ANSI so the sz gets it right.
    // NOTE: This must be gotten as an ANSI string!
    PCHAR  pchar = (PCHAR)pmb->GetData( pszPath, dwPropID, IIS_MD_UT_SERVER, STRING_METADATA, &dwcb );
    if ( pchar )
        {
        // set the answer
        sz = pchar;

        fAnswer = TRUE;
        // clean up
        pmb->FreeWrapData( pchar );
        }

    // return the answer
    return fAnswer;
    }

//---------------------------------------------------------------------------
/* INTRINSA suppress=null_pointers, uninitialized */
BOOL CMap11Page::Set11String(CWrapMetaBase* pmb, LPCTSTR pszPath, DWORD dwPropID, CString& sz, DWORD dwFlags )
    {
    USES_CONVERSION;
    // Easy. Just set it as data
    // Make sure it is set back as an ANSI string though
    LPSTR pA = T2A((LPTSTR)(LPCTSTR)sz);
    return pmb->SetData( pszPath, dwPropID, IIS_MD_UT_SERVER, STRING_METADATA,
                            (PVOID)pA, strlen(pA)+1, dwFlags );
    }

//---------------------------------------------------------------------------
// we only need to write out the mappings that have been either changed or added.

// Thoughts on further optimizations: The bare minimum info about where to find
// a mapping in the metabase could be stored in the metabase. Then, the mappings
// would only be loaded when they were added to be edited or displayed in the
// cracked list. The private data for each item in the list would have to have
// some sort of reference to a position in the metabase.

BOOL CMap11Page::FWriteMappings()
    {
    BOOL                            f;
    DWORD                           i,j;
    DWORD                           cMappings;
    C11Mapping*                     pMap;
    C11Mapping*                     pMapTemp;

    CString                         sz;
    DWORD                           dwEnabled;
    PUCHAR                          pCert;
    DWORD                           cbCert;
    DWORD                           iList;

    // before messing with the metabase, prepare the strings we will need
    CString         szTempPath;
    CString         szBasePath = m_szMBPath + _T("/Cert11");
    CString         szRelativePath = _T("/Mappings");
    CString         szObjectPath = szRelativePath + _T('/');

    // prepare the base metabase wrapper
    CWrapMetaBase   mbBase;
    f = mbBase.FInit(m_pMB);
    if ( !f )
        {
        AfxMessageBox( IDS_ERR_ACCESS_MAPPING );
        return FALSE;
        }

        // first, we have to open the Cert11 object. If it doesn't exist
        // then we have to add it tothe metabase
        if ( !mbBase.Open( szBasePath, METADATA_PERMISSION_READ|METADATA_PERMISSION_WRITE ) )
            {
            // Cert11 does not exist - open the namespace base and add it
            szTempPath = m_szMBPath + _T('/');
            if ( !mbBase.Open( szTempPath, METADATA_PERMISSION_READ|METADATA_PERMISSION_WRITE ) )
                {
                AfxMessageBox( IDS_ERR_ACCESS_MAPPING );
                return FALSE;   // serious problems if we can't open the base
                }

            // add the Cert11 object
            szTempPath = _T("Cert11");
            f = mbBase.AddObject( szTempPath );
            mbBase.Close();
            if ( !f )
                {
                AfxMessageBox( IDS_ERR_CANTADD );
                return FALSE;
                }

            // try again to open the Cert11. Fail if it doesn't work
            if ( !mbBase.Open( szBasePath, METADATA_PERMISSION_READ|METADATA_PERMISSION_WRITE ) )
                {
                AfxMessageBox( IDS_ERR_ACCESS_MAPPING );
                return FALSE;
                }
            }

    //==========
    // start by deleting all the mappings in the to-be-deleted list
    cMappings = (DWORD)m_rgbDelete.GetSize();

    // only bother if there are items waiting to be deleted
    if ( cMappings > 0 )
        {
        // get the count of mappings in the display list
        DWORD   cList = m_clistctrl_list.GetItemCount();

        // sort the mappings, in decending order
        for ( i = 0; i < cMappings-1; i++ )
            {
            pMap = (C11Mapping*)m_rgbDelete[i];
            for ( j = i; j < cMappings; j++ )
                {
                pMapTemp = (C11Mapping*)m_rgbDelete[j];
                if ( pMap->iMD < pMapTemp->iMD )
                    {
                    m_rgbDelete.SetAt( i, (CObject*)pMapTemp );
                    m_rgbDelete.SetAt( j, (CObject*)pMap );
                    pMap = pMapTemp;
                    }
                }
            }

        // loop the mappings, deleting each from the metabase
        for ( i = 0; i < cMappings; i++ )
            {
            // get the mapping object
            pMap = (C11Mapping*)m_rgbDelete[i];
            if ( !pMap || (pMap->iMD == NEW_OBJECT) )
                continue;

            // build the relative path to the object in question.
            szObjectPath.Format( _T("%s/%d"), szRelativePath, pMap->iMD );

            // delete that mapping's object from the metabase
            f = mbBase.DeleteObject( szObjectPath );

            // decrement the number of maps in the metabase
            m_MapsInMetabase--;

            // loop the items in the list, decrementing the index of those
            // that are above it. Yes - this is non-optimal, but its what
            // has to be done for now
            for ( iList = 0; iList < cList; iList++ )
                {
                pMapTemp = GetMappingInDisplay(iList);
                if ( (pMapTemp->iMD > pMap->iMD) && (pMapTemp->iMD != NEW_OBJECT) )
                    pMapTemp->iMD--;
                }

            // since we will no longer be needing this mapping, delete it
            DeleteMapping( pMap );
            }

        // reset the to-be-deleted list
        m_rgbDelete.RemoveAll();
        }

    //==========
    // get the number mappings in the to-be-saved list
    cMappings = (DWORD)m_rgbSave.GetSize();

    // loop the mappings, adding each to the metabase
    for ( i = 0; i < cMappings; i++ )
        {
        // get the mapping object
        pMap = (C11Mapping*)m_rgbSave[i];
        ASSERT( pMap );

        // if the object is already in the metabase, just open it.
        if ( pMap->iMD != NEW_OBJECT )
            {
            // build the relative path to the object
            szObjectPath.Format( _T("%s/%d"), szRelativePath, pMap->iMD );
            }
        else
            {
            // set up the name of the new mapping as one higher
            // than the number of mappings in the metabase
            pMap->iMD = m_MapsInMetabase + 1;

            // build the relative path to the object
            szObjectPath.Format( _T("%s/%d"), szRelativePath, pMap->iMD );

            // add the mapping object to the base
            f = mbBase.AddObject( szObjectPath );
            if ( f )
                {
                // increment the number of maps in the metabase
                m_MapsInMetabase++;
                }
            }

        // write the object's parameters
        if ( f )
            {
            // save the certificate
            if ( pMap->GetCertificate(&pCert, &cbCert) )
                {
                // set the data into place in the object
                f = mbBase.SetData( szObjectPath, MD_MAPCERT, IIS_MD_UT_SERVER, BINARY_METADATA,
                pCert, cbCert, METADATA_SECURE | METADATA_INHERIT );
                }

            // save the NTAccount
            if ( pMap->GetNTAccount(sz) )
                {
                // set the data into place in the object
                f = Set11String(&mbBase, szObjectPath, MD_MAPNTACCT, sz, METADATA_SECURE);
                }

            // save the password - secure
            if ( pMap->GetNTPassword(sz) )
                {
                // set the data into place in the object
                f = Set11String(&mbBase, szObjectPath, MD_MAPNTPWD, sz, METADATA_SECURE);
                }

            // save the map's name
            if ( pMap->GetMapName(sz) )
                {
                // set the data into place in the object
                f = Set11String(&mbBase, szObjectPath, MD_MAPNAME, sz);
                }

            // save the Enabled flag
            // server reads the flag as the value of the dword
            if ( pMap->GetMapEnabled(&f) )
                {
                dwEnabled = (DWORD)f;
                f = mbBase.SetDword( szObjectPath, MD_MAPENABLED, IIS_MD_UT_SERVER, dwEnabled );
                }
            }
        }

    // close the base object
    mbBase.Close();

    // save the metabase
    mbBase.Save();

    // reset the to-be-saved list
    m_rgbSave.RemoveAll();

    // return success
    return TRUE;
    }

//---------------------------------------------------------------------------
C11Mapping*     CMap11Page::PNewMapping()
    {
    // the way it should be
    return new C11Mapping();
    }

//---------------------------------------------------------------------------
void CMap11Page::DeleteMapping( C11Mapping* pMap )
    {
    // the way it should be
    delete pMap;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\certmap\map11pge.h ===
// Map11Pge.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CMap11Page dialog

class CMap11Page : public CPropertyPage
{
    DECLARE_DYNCREATE(CMap11Page)

// Construction
public:
    CMap11Page();
    ~CMap11Page();

    BOOL    FInit(IMSAdminBase* pMB);

    virtual BOOL OnApply();
    virtual BOOL OnInitDialog();

    // base path for to the metabase
    CString m_szMBPath;

// Dialog Data
    //{{AFX_DATA(CMap11Page)
    enum { IDD = IDD_11CERT_MAPPING };
    CCheckListCtrl  m_clistctrl_list;
    CButton m_cbutton_add;
    CButton m_cbutton_grp_issuer;
    CButton m_cbutton_grp_issuedto;
    CButton m_cbutton_editmap;
    CButton m_cbutton_delete;
    CString m_csz_i_c;
    CString m_csz_i_o;
    CString m_csz_i_ou;
    CString m_csz_s_c;
    CString m_csz_s_cn;
    CString m_csz_s_l;
    CString m_csz_s_o;
    CString m_csz_s_ou;
    CString m_csz_s_s;
    //}}AFX_DATA


// Overrides
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CMap11Page)
    public:
    virtual void OnOK();
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:
    // Generated message map functions
    //{{AFX_MSG(CMap11Page)
    afx_msg void OnAdd();
    afx_msg void OnDelete();
    afx_msg void OnEdit11map();
    afx_msg void OnItemchangedList(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnDblclkList(NMHDR* pNMHDR, LRESULT* pResult);
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

    afx_msg void DoHelp();

    // more initialization methods
    BOOL FInitMappingList();
    BOOL FillMappingList();

    // more initialization methods
    BOOL FReadMappings();
    BOOL FWriteMappings();

    // control the maps in the list
//  BOOL FAddMappingToList( C11Mapping* pMap, DWORD iMap );
//  BOOL FAddMappingToList( C11Mapping* pMap, DWORD iList = 0xFFFFFFFF );
    // always adds to the end of the list
    BOOL FAddMappingToList( C11Mapping* pMap );

    // editing and updating
    BOOL EditOneMapping( C11Mapping* pUpdateMap );
    BOOL EditMultipleMappings();
    void EnableDependantButtons();
    void UpdateMappingInDispList( DWORD iList, C11Mapping* pUpdateMap );

    // adding a new certificate
    BOOL FAddCertificateFile( CString szFile );
    BOOL FAddCertificate( PUCHAR pCertificate, DWORD cbCertificate );

    // special display
    BOOL DisplayCrackedMap( C11Mapping* pUpdateMap );
    void ClearCrackDisplay();
    void EnableCrackDisplay( BOOL fEnable = TRUE );

    void ResetMappingList();
    C11Mapping* GetMappingInDisplay( DWORD iList ) {return (C11Mapping*)m_clistctrl_list.GetItemData(iList);}
    void MarkToSave( C11Mapping* pSaveMap, BOOL fSave = TRUE );

    C11Mapping* PNewMapping();
    void DeleteMapping( C11Mapping* pMap );

    BOOL Get11String(CWrapMetaBase* pmb, LPCTSTR pszPath, DWORD dwPropID, CString& sz);
    BOOL Set11String(CWrapMetaBase* pmb, LPCTSTR pszPath, DWORD dwPropID, CString& sz, DWORD dwFlags = METADATA_INHERIT);

    // list of names of objects to be deleted
    CObArray    m_rgbDelete;

    // list of objects to be saved
    CObArray    m_rgbSave;

    // number of objects in the etabase
    DWORD   m_MapsInMetabase;

    IMSAdminBase*   m_pMB;
    };
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\certmap\listrow.h ===
// ListRow.h : header file
//


#ifndef _LISTROW_
#define _LISTROW_

/////////////////////////////////////////////////////////////////////////////
// CListSelRowCtrl window

class CListSelRowCtrl : public CListCtrl
{
// Construction
public:
    CListSelRowCtrl();

    virtual void DrawItem(LPDRAWITEMSTRUCT lpDrawItemStruct);

// Attributes
public:

// Operations
public:

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CListSelRowCtrl)
    //}}AFX_VIRTUAL

// Implementation
public:
    virtual ~CListSelRowCtrl();

    // Generated message map functions
protected:
    //{{AFX_MSG(CListSelRowCtrl)
    afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
    afx_msg void OnLButtonDblClk(UINT nFlags, CPoint point);
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

    void GetHiliteColors();

    void HiliteSelectedCells();
    void HiliteSelectedCell( int iCell, BOOL fHilite = TRUE );
    BOOL FGetCellRect( LONG iRow, LONG iCol, CRect *pcrect );

    void FitString( CString &sz, int cpWidth, CDC* pcdc );

    CBitmap     m_bitmapCheck;
    COLORREF    m_colorHiliteText;
    COLORREF    m_colorHilite;

    DWORD       m_StartDrawingCol;

};

/////////////////////////////////////////////////////////////////////////////
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\certmap\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by certmap.rc
//
#define IDS_CERTMAP                     1
#define IDB_CERTMAP                     1
#define IDS_CERTMAP_PPG                 2
#define IDS_KEY_OR_CERT_FILE_FILTER     3
#define IDS_TITLE_CTL_WIZARD            4
#define IDS_OLD_KEYRING_BACKUP_FILE_IMPORT_FILTER 5
#define IDD_MIME_TYPES                  11
#define IDS_DDX_MINIMUM                 28
#define IDS_CERTMAP_PPG_CAPTION         100
#define IDD_PROPPAGE_CERTMAP            100
#define IDS_MAP_SHEET_TITLE             101
#define IDS_INIT_META_ERROR             102
#define IDS_LIST11_NAME                 103
#define IDS_LIST11_ACCOUNT              104
#define IDS_CONFIRM_DELETE              105
#define IDS_ERR_ACCESS_MAPPING          106
#define IDS_NTBROWSE_TITLE              107
#define IDD_PROPPAGE_LARGE_SAMPLE       107
#define IDS_INVALID_ACCOUNT             108
#define IDS_CERTIFICATE_FILTER          109
#define IDS_ERR_INVALID_CERTIFICATE     110
#define IDS_DEFAULT_11MAP               111
#define IDS_ENABLED                     112
#define IDS_ELLIPSIS                    113
#define IDS_WILD_DESCRIPTION            114
#define IDS_WILD_ACCOUNT                115
#define IDS_DEFAULT_RULE                116
#define IDS_CERT_FIELD                  117
#define IDS_MATCH_CRITERIA              118
#define IDS_SUB_FIELD                   119
#define IDS_WILDSTRING                  120
#define IDS_INVALID_SUBFIELD            121
#define IDS_ISSUE_AUTH                  122
#define IDS_ERR_NO_ISSUERS              123
#define IDS_ERR_CANTADD                 124
#define IDS_MATCH_ON_ISSUERS            125
#define IDS_CERTAUTH                    126
#define IDS_CERTAUTH_PPG                127
#define IDS_CERTAUTH_PPG_CAPTION        128
#define IDD_CLEARTEXTWARNING            128
#define IDS_TRUSTED_AUTHORITIES         129
#define IDS_WILDWIZ_TITLE               130
#define IDS_PASS_CONFIRM_FAIL           131
#define IDS_HELPLOC_PWSHELP             132
#define IDD_WZ_CERTGET_1_WELCOME        132
#define IDS_ERR_CERTMAP_TITLE           133
#define IDD_MIME_PROPERTY               133
#define IDS_SHOWN_PASSWORD              134
#define IDS_WANTACCOUNT                 135
#define IDS_DENYACCESS                  136
#define IDD_KEY_VIEWEDIT                137
#define IDR_KEYPROP                     138
#define IDD_CONFIRM_PASSWORD            139
#define IDD_KEY_DATA_VIEW               140
#define IDD_CHOOSE_IPADDRESS            141
#define IDD_NEW_KEY_INFO                142
#define IDI_ICONINFORMATION             143
#define IDD_DIALOG1                     145
#define IDD_CREATING_NEW_KEY            145
#define IDD_ADNIM_INFO                  146
#define IDD_DEFAULT_CONFIRM             147
#define IDR_AVI_CREATING_KEY            149
#define IDD_IMPORT_KEY_PAIR             151
#define IDD_NK_CHOOSE_CA                153
#define IDD_NK_FILE_INFO                154
#define IDD_NK_DN1                      155
#define IDD_NK_KEY_INFO                 157
#define IDD_NK_USER_INFO                158
#define IDD_NK_DN2                      159
#define IDD_CERT_MISMATCH               161
#define IDD_CTL_CREATE_GET_INFO_FROM_USER 188
#define IDD_WZ_CTL_CREATE_GETINFO2      188
#define IDD_WZ_IMPORT_USE_PREEXISTING   198
#define IDC_CAPTIONEDIT                 201
#define IDC_LIST                        202
#define IDD_11CERT_MAPPING              202
#define IDB_CHECK                       202
#define IDC_DELETE                      203
#define IDD_WILDCARDS_1                 203
#define IDD_WILDCARDS_2                 204
#define IDC_ADD                         205
#define IDD_EDIT_RULE_ELEMENT           205
#define IDC_S_O                         206
#define IDC_BTN_HELP                    206
#define IDD_PROPPAGE_CERTAUTH           206
#define IDC_S_OU                        207
#define IDB_CERTAUTH                    207
#define IDC_COMBO1                      208
#define IDC_S_CN                        208
#define IDD_MAP_TO_ACCNT                208
#define IDC_LIST1                       209
#define IDC_COMBO2                      209
#define IDC_S_C                         209
#define IDD_MAP_ONE_TO_ACCNT            209
#define IDC_COMBO3                      210
#define IDC_S_S                         210
#define IDD_WILDCARDS_stored            210
#define IDD_WILDWIZ_1                   210
#define IDC_COMBO4                      211
#define IDC_EDIT_11MAP                  211
#define IDD_SELECT_ISSUERS              211
#define IDC_BUTTON3                     212
#define IDC_S_L                         212
#define IDD_WILDCARDS_Storage           212
#define IDC_I_O                         213
#define IDD_WILDWIZ_2                   213
#define IDC_I_OU                        214
#define IDD_WILDWIZ_3                   214
#define IDC_CHECK1                      215
#define IDC_I_C                         215
#define IDC_CHK_CAPITALIZATION          215
#define IDD_WZ_CERTGET_2_WHAT_TASK      215
#define IDC_CHECK_REMOTE_ONLINE_AUTHORITY 215
#define IDC_ISSUED_TO                   216
#define IDD_WZ_CERTGET_3A_CERT_REQ_INFO 216
#define IDD_WZ_CERTGET_A3_REQ_SHOW_CERTINFO 216
#define IDC_EDIT                        217
#define IDC_ISSUER                      217
#define IDD_WZ_CERTGET_A4_REQ_HOW2CREATE 217
#define IDC_MOVE_UP                     218
#define IDC_MAPNAME                     218
#define IDD_WZ_CERTGET_A5_REQ_WHERE_REQ_GOES 218
#define IDC_MOVE_DOWN                   219
#define IDD_PROPPAGE__FAKE__USED_BY_WixPropPage 219
#define IDC_EDIT1                       220
#define IDC_DESCRIPTION                 220
#define IDC_SUBFIELD                    220
#define IDC_MB_PATH                     220
#define IDC_RADIO1                      221
#define IDC_ALL_ISSUERS                 221
#define IDB_BITMAP_MMC_CTL_4color       221
#define IDC_RADIO2                      222
#define IDC_ENABLE                      222
#define IDC_SOME_ISSUERS                222
#define IDD_MMC_CTL_FYI                 222
#define IDB_BITMAP_TJP2                 222
#define IDC_SELECT_ISSUER               223
#define IDC_EDIT2                       224
#define IDC_PASSWORD2                   224
#define IDD_EDITDIALOG                  224
#define IDC_RADIO5                      225
#define IDC_EDIT3                       225
#define IDC_EDIT4                       226
#define IDB_FYI_MMC_EMPT                226
#define IDD_DIALOG2                     226
#define IDC_RADIO6                      226
#define IDC_EDIT5                       227
#define IDB_FYI_MMC_ADD1                227
#define IDC_CHECK2                      228
#define IDC_ENABLE_RULE                 228
#define IDB_FYI_MMC_ADD2                228
#define IDC_CHECK3                      229
#define IDB_FYI_MMC_ADD3                229
#define IDC_EDIT6                       230
#define IDC_RADIO3                      230
#define IDC_REFUSE_LOGON                230
#define IDB_FYI_MMC_ADD4                230
#define IDC_BROWSE                      231
#define IDB_FYI_MMC_ADD5                231
#define IDC_RADIO4                      232
#define IDC_ACCEPT_LOGON                232
#define IDB_FYI_MMC_ADD6                232
#define IDC_DO_NOT_MATCH                233
#define IDB_FYI_MMC_MCH1                233
#define IDC_NEW                         234
#define IDB_FYI_MMC_MCH2                234
#define IDB_BITMAP_CTL_LEFT             236
#define IDC_FIELDS                      237
#define IDB_BITMAP1                     237
#define IDC_CRITERIA                    238
#define IDC_PASSWORD                    239
#define IDD_PROGRESS_BAR                239
#define IDC_TOGGLE                      240
#define IDD_WZ_INCORRECT_OOB_SAVED      240
#define IDC_CAPTION                     241
#define IDC_STATIC_ACCOUNT              242
#define IDC_STATIC_PASSWORD             243
#define IDC_STATIC_DESC                 244
#define IDC_NK_CA_OFFLINE_COMBO         245
#define IDC_STATIC_DESC_WHERE2MAIL_CERT 246
#define IDC_NTACCOUNT                   248
#define IDC_NK_CA_REMOTE_HOSTNAME       248
#define IDC_LABEL_ERROR_PARAGRAPH1      250
#define IDC_LABEL_ERROR_PARAGRAPH2      251
#define IDC_LABEL_ERROR_PARAGRAPH3      252
#define IDC_LABEL_ERROR_NUMBER          253
#define IDC_PROGRESS1                   254
#define IDB_UP                          505
#define IDB_UPFOC                       506
#define IDB_UPDIS                       507
#define IDB_UPINV                       508
#define IDB_DOWN                        509
#define IDB_DOWNFOC                     510
#define IDB_DOWNDIS                     511
#define IDB_DOWNINV                     512
#define IDC_CONNECT_ServerName          1000
#define IDC_NEW_KEY_NAME                1002
#define IDC_NEW_KEY_REQUEST_FILE        1003
#define IDC_NEW_KEY_BROWSE              1004
#define IDC_STATIC_BOLD                 1006
#define IDC_STATIC_BIGBOLD              1007
#define IDC_NEW_KEY_BITS                1015
#define IDC_NEW_KEY_ORGANIZATION        1017
#define IDC_NEWKEY_COUNTRY              1017
#define IDC_NEW_KEY_UNIT                1018
#define IDC_NEWKEY_ORG                  1018
#define IDC_NEW_KEY_NETADDRESS          1019
#define IDC_NEWKEY_STATE                1019
#define IDC_NEW_KEY_COUNTRY             1020
#define IDC_NEWKEY_ORGUNIT              1020
#define IDC_NEW_KEY_PASSWORD            1021
#define IDC_NEW_NKKI_PASSWORD           1021
#define IDC_INSTALL_PASSWORD            1022
#define IDC_NEWKEY_LOCALITY             1022
#define IDC_NEW_NKKI_PASSWORD2          1022
#define IDC_NEWKEY_COMMONNAME           1023
#define IDC_CONFIRM_PASSWORD            1032
#define IDC_VIEWKEY_STATEPROVINCE       1032
#define IDC_VIEWKEY_LOCALITY            1033
#define IDC_BTN_KEYVIEW_NONE            1034
#define IDC_BTN_KEYVIEW_DEFAULT         1035
#define IDC_BTN_KEYVIEW_IPADDR          1036
#define IDC_KEYDATAVIEW_IPADDRESS       1037
#define IDC_BTN_SELECT_IPADDRESS        1039
#define IDC_GROUP_DN                    1040
#define IDC_GROUP_CONNECTION            1041
#define IDC_STATIC_BITS                 1042
#define IDC_STATIC_ORG                  1043
#define IDC_STATIC_UNIT                 1044
#define IDC_STATIC_NETADDR              1045
#define IDC_STATIC_COUNTRY              1046
#define IDC_STATIC_NAME                 1047
#define IDC_CHOOSER_SERVER_DLG_HELP     1048
#define IDC_STATIC_STATEPROVICE         1048
#define IDC_CHOOSER_HELP_CHOOSE_IP      1048
#define IDC_LIST_IPADDRESSES            1049
#define IDC_STATIC_LOCALITY             1049
#define IDC_HELP_INSTALL_CERTIFICATE    1051
#define IDC_HELP_MORE_NEW_KEY_HELP      1051
#define IDC_BUTTON1                     1052
#define IDC_HELP_CONNECT_SERVER         1052
#define IDC_BROWSE_PRIVATE              1052
#define IDC_BK_CA_PROPERTIES            1052
#define IDC_HOTLINK_CCODES              1052
#define IDC_NEW_KEY_INFO_FILE_PART      1053
#define IDC_DISK_SPACE                  1056
#define IDC_PHYSICAL_MEM                1057
#define IDC_REPDEF_CURRENT              1059
#define IDC_REPDEF_NEW                  1060
#define IDC_STATIC_CREATED              1061
#define IDC_STATIC_EXPIRES              1062
#define IDC_VIEWKEY_CREATED             1063
#define IDC_STATIC_STARTS               1063
#define IDC_VIEWKEY_EXPIRES             1064
#define IDC_VIEWKEY_STARTS              1065
#define IDC_INFO_BASE                   1066
#define IDC_GRINDER_ANIMATION           1067
#define IDC_STATIC_VERIFIER             1068
#define IDC_HELP_CREATE_KEY             1069
#define IDC_BROWSE_CERT                 1070
#define IDC_NK_CA_FILE_RADIO            1070
#define IDC_CERT_FILE                   1071
#define IDC_NK_CA_ONLINE_RADIO          1071
#define IDC_PRIVATE_FILE                1072
#define IDC_NK_CA_ONLINE                1072
#define IDC_NKUI_USER_NAME              1073
#define IDC_BUTTON2                     1074
#define IDC_NK_CA_BROWSE                1074
#define IDC_EDIT_ALIAS                  1079
#define IDC_NK_INFO_FILENAME            1080
#define IDC_NK_CA_FILE                  1082
#define IDC_NKUI_EMAIL_ADDRESS          1083
#define IDC_NKUI_PHONE_NUMBER           1084
#define IDC_NKKI_NAME                   1085
#define IDC_NKKI_BITS                   1086
#define IDC_MESSAGE                     1087
#define IDC_LIST_REQUEST                1088
#define IDC_LIST_CERTIFICATE            1089
#define IDC_IPA_IPADDRESS               1107
#define IDC_EMAIL_ADDRESS               1108
#define IDC_PHONE_NUMBER                1109
#define IDD_FYI_MMC_EMPT                1222
#define IDD_FYI_MMC_ADD1                1223
#define IDD_FYI_MMC_ADD2                1224
#define IDD_FYI_MMC_ADD3                1225
#define IDD_FYI_MMC_ADD4                1226
#define IDD_FYI_MMC_ADD5                1227
#define IDD_FYI_MMC_ADD6                1228
#define IDD_FYI_MMC_MCH1                1229
#define IDD_FYI_MMC_MCH2                1230
#define IDS_ERR_CONNECT                 1446
#define IDS_MACHINE_LOCAL               1447
#define IDS_SERVER_NONE                 1448
#define IDS_CREATE_KEY_NEW_NAME         1449
#define IDS_CREATE_KEY_YOUR_COMPANY     1450
#define IDS_CREATE_KEY_YOUR_UNIT        1451
#define IDS_CREATE_KEY_YOUR_ADDRESS     1453
#define IDS_KEY_DELETE_WARNING          1454
#define IDS_SERVER_COMMIT               1455
#define IDS_ERR_GENERATEPAIR            1456
#define IDS_ERR_WRITEREQUEST            1457
#define IDS_ERR_WRITEKEYS               1458
#define IDS_KEY_STATUS_COMPLETE         1459
#define IDS_KEY_STATUS_INCOMPLETE       1460
#define IDS_KEY_UNKNOWN                 1461
#define IDS_CREATE_KEY_PASSREQUIRED     1462
#define IDS_INCORRECT_PASSWORD          1463
#define IDS_CERT_FILE_EXISTS            1464
#define IDS_REG_SERVER_STORAGE          1465
#define IDS_COMMIT_ERROR                1466
#define IDS_MACHINE_DEFAULT             1467
#define IDS_MACHINE_SELECTED            1468
#define IDS_NEW_KEY_INFO_1              1470
#define IDS_NEW_KEY_INFO_2              1471
#define IDS_ABOUT_MAIN                  1472
#define IDS_ABOUT_SECONDARY             1473
#define IDS_HTTP_COMM_ERROR             1474
#define IDS_NO_VIRT_ROOTS               1475
#define IDS_FOUND_KEYSET_KEYS           1476
#define IDS_UNTITLED                    1477
#define IDS_IMPORT_KEYSET_ERROR         1478
#define IDS_LOCALIZED_DEFAULT_COUNTRY_CODE 1479
#define IDS_GENERATE_KEY_ERROR          1480
#define IDS_INVALID_KEY                 1481
#define IDS_CREATE_KEY_YOUR_STATE       1482
#define IDS_CREATE_KEY_YOUR_LOCALITY    1483
#define IDS_CRED_PASS_ERROR             1484
#define IDS_CRED_PACK_ERROR             1485
#define IDS_KEY_STATUS_EXPIRED          1486
#define IDS_KEY_STATUS_EXPIRES_SOON     1487
#define IDS_EXPIRETIME_FORMAT           1488
#define IDS_RENEW_KEY_INFO_2            1489
#define IDS_NEW_KEY_INFO_BASE           1490
#define IDS_RENEW_KEY_INFO_BASE         1491
#define IDS_CREATING_ANIMATION          1492
#define IDS_CRACKING_ERROR              1493
#define IDS_IMPORT_KEYSET_PRIV_ERROR    1494
#define IDS_IMPORT_KEYSET_PUB_ERROR     1495
#define IDS_IMPORT_KEYSET_PASS_ERROR    1496
#define IDS_KEY_FILE_TYPE               1497
#define IDS_KEY_FILE_INVALID            1498
#define IDS_CERT_FILE_TYPE              1499
#define IDS_REG_USER_INFO               1499
#define IDS_KEYFILE_WARNING             1500
#define IDS_PRIVATE_FILE_TYPE           1501
#define IDD_USER_ACCOUNT                2029
#define IDD_NEW_DIR_ALIAS               2044
#define IDB_WELCOME_COMPLETION          2058
#define IDB_WELCOME_COMPLETION_LEFT     2059
#define ID_SERVER_COMMIT_NOW            2771
#define ID_KEY_CREATE_REQUEST           2772
#define ID_KEY_INSTALL_NEW              2773
#define ID_KEY_DELETE                   2774
#define ID_SERVER_CONNECT               2775
#define ID_KEY_ACTIVATE                 2776
#define IDD_WZwo_CERTSEL_3_CHOOSE_CERT  2776
#define ID_KEY_DEACTIVATE               2777
#define ID_KEY_INSTALL_CERTIFICATE      2778
#define ID_KEY_PROPERTIES               2780
#define ID_KEYPROP_PASTE                2781
#define ID_MAIN_HELP                    2784
#define ID_SERVER_DISCONNECT            2786
#define ID_KEY_SAVE_REQUEST             2787
#define ID_KEYPROP_WRITEKEYREQUEST      2788
#define ID_KEY_CREATE_RENEWAL           2789
#define ID_KEY_IMPORT                   2791
#define ID_KEY_EXPORT                   2792
#define ID_KEY_EXPORT_BACKUP            2793
#define ID_KEY_EXPORT_KEYSET            2794
#define ID_KEY_IMPORT_BACKUP            2795
#define ID_KEY_IMPORT_KEYSET            2796
#define ID_TEST_DATA                    2797
#define ID_SERVPROP_CUT                 2798
#define ID_PROPERTIES                   2799
#define IDS_NEW_CREATE_NEW              2801
#define IDS_ADDONS_LOCATION             2803
#define ID_HELPTOPICS                   2803
#define IDS_NO_SERVICE_MODS             2804
#define IDS_SERVER_INFO_STRING          2806
#define IDS_CA_LOCATION                 2807
#define IDS_LOAD_CA_ERR                 2808
#define IDS_DEFAULT_REQUEST_FILE        2809
#define IDS_GEN_KEYPAIR_ERR             2810
#define IDS_GRIND_GENERATING            2811
#define IDS_GRIND_SUBMITTING            2812
#define IDS_GRIND_SUCCESS               2813
#define IDS_GRIND_DELAYED               2814
#define IDS_GRIND_FILE                  2815
#define IDS_GRIND_ONLINE_FAILURE        2816
#define IDS_GRIND_RESUBMITTING          2818
#define IDS_ILLEGAL_DN_CHARS            2819
#define IDS_BADCHARMSG                  2820
#define IDS_GENERATE_KEY_TITLE          2821
#define IDS_RESTART_PROMPT              2822
#define IDS_IO_ERROR                    2823
#define IDS_BAD_FILE_NAME               2824
#define IDS_FILE_EXISTS                 2825
#define IDS_CHOOSE_COMPUTER             2826
#define IDS_TITLE_CREATE_WIZ            2827
#define IDS_TITLE_RENEW                 2828
#define IDS_INVALID_CA_REQUEST_OLD      2829
#define IDS_CA_NO_INTERFACE             2830
#define IDS_CA_INVALID                  2831
#define IDS_CA_FACTORY_ERR              2832
#define IDS_CA_DENIED                   2833
#define IDS_CA_ERROR                    2834
#define IDS_HELPLOC_KEYRINGHELP         2835
#define IDS_TOTALLY_ILLEGAL_CHARS       2837
#define IDS_CERTERR_INVALID_CERTIFICATE 2838
#define IDS_CERTERR_SCHANNEL_ERR        2840
#define IDS_CERTERROR_PACKAGELOAD_ERROR 2841
#define IDS_CERTERROR_BADPASSWORD       2842
#define IDS_CERTERR_LOMEM               2843
#define IDS_CERTERR_SCHNL_GENERIC       2844
#define EDS_CERTERR_SCHNL_BAD_INIT      2845
#define IDS_OPEN_PRIVATE_KEY            2846
#define IDS_OPEN_PUBLIC_KEY             2847
#define IDS_APP_EXTENSION               2848
#define IDS_APP_EXE_PATH                2849
#define IDS_ERR_GENERIC_ERRCODE         2850
#define IDC_STATIC_WZ_WELCOME           4000
#define IDC_STATIC_WZ_TITLE             4001
#define IDC_STATIC_WZ_SUBTITLE          4002
#define IDS_TRUE                        4003
#define IDS_FALSE                       4004
#define IDS_NOT_AVAILABLE               4005
#define IDS_NONE                        4006
#define IDS_CR_DISP_INCOMPLETE          4007
#define IDS_CR_DISP_ERROR               4008
#define IDS_CR_DISP_DENIED              4009
#define IDS_CR_DISP_ISSUED              4010
#define IDS_CR_DISP_ISSUED_OUT_OF_BAND  4011
#define IDC_ED_BOLD1                    4011
#define IDS_CR_DISP_UNDER_SUBMISSION    4012
#define IDC_ED_BOLD2                    4012
#define IDS_DUPLICATE_CERT              4013
#define IDC_ED_BOLD3                    4013
#define IDS_DESC_CERTMGROBJ             4014
#define IDC_ED_BOLD4                    4014
#define IDS_DESC_CERTIFICATE_STORE      4015
#define IDC_ED_BOLD5                    4015
#define IDS_DESC_CONTAINER              4016
#define IDS_DESC_USAGE                  4017
#define IDS_DESC_CTL                    4018
#define IDS_DESC_CERTIFICATE            4019
#define IDS_ERR_INVALID_FILENAME        4020
#define IDS_ERR_INVALID_FILENAME_0_LEN  4021
#define IDS_CLSID_REGPATH_XENROLL_NONLOCALIZED 4032
#define IDS_MICROSOFT_CERTIFICATE_SERVER_LOCALIZED_DESC_NAME 4033
#define IDS_CertGetConfig_REGPATH_NONLOCALIZED 4035
#define IDS_CertRequest_REGPATH_NONLOCALIZED 4036
#define IDS_XEnroll_REGPATH_NONLOCALIZED 4037
#define IDS_ERR_UNABLE_TO_GET_REQUIRED_CLSID 4038
#define IDS_ERR_UNABLE_TO_BUILD_CLASS_FROM_READ_IN_CLSID 4039
#define IDS_ERR_HAPPENED_DISPLAY_HRESULT 4040
#define IDS_ERR_DISPLAY__HRESULT__S_OK  4041
#define IDS_ERR_DISPLAY__HRESULT__S_FALSE 4042
#define IDS_ERR_DISPLAY__HRESULT__E_FAIL 4043
#define IDS_ERR_DISPLAY__HRESULT__NOERROR 4044
#define IDS_ERR_DISPLAY__HRESULT__CO_E_CLASSSTRING 4045
#define IDS_ERR_DISPLAY__HRESULT__REGDB_E_WRITEREGDB 4046
#define IDS_ERR_DISPLAY__HRESULT__MAYBE_WIN32_ERR 4047
#define IDS_ERR_DISPLAY__HRESULT__CRYPT_E_INVALID_X500_STRING 4048
#define IDS_ERR_DISPLAY__HRESULT__REGDB_E_IIDNOTREG 4049
#define IDS_ERR_DISPLAY__HRESULT__REGDB_E_CLASSNOTREG 4050
#define IDS_ERR_DISPLAY__HRESULT__CLSID_INIT_ERROR 4060
#define IDS_ERR_DISPLAY__HRESULT__CANT_CREATE_XENROLL 4061
#define IDS_ERR_DISPLAY__HRESULT__CANT_CREATE_ICERTREQUEST 4062
#define IDS_ERR_DISPLAY__HRESULT__CANT_CREATE_ICERTGETCONFIG 4063
#define IDS_ERR_DISPLAY__HRESULT__ICERTGETCONFIG_CALL_FAILED 4064
#define IDS_ERR_DISPLAY__HRESULT__EXPORTABLE_KEYS_CALL_FAILED 4065
#define IDS_IISSERVERNAME               4066
#define IDS_ERR_DISPLAY__HRESULT__CREATEPKCS10_CALL_FAILED 4067
#define IDS_ERR_DISPLAY__HRESULT__ACCEPTFILEPKCS7_CALL_FAILED 4068
#define IDS_ERR_DISPLAY__HRESULT__ACCEPTPKCS7_CALL_FAILED 4069
#define IDS_ERR_DISPLAY__HRESULT__PKCS10_ZERO_SIZED 4070
#define IDS_ERR_DISPLAY__HRESULT__ICERTREQUEST_SUBMIT_FAILED 4072
#define IDS_ERR_DISPLAY__HRESULT__ICERTREQUESTGETCERTIFICATE_FAILED 4074
#define IDS_ERR_DISPLAY__HRESULT__CERTAUTH_PLEASE_CALL 4075
#define IDS_ERR_DISPLAY__HRESULT__CERTAUTH_NOT_STARTED 4076
#define IDS_ERR_DISPLAY__HRESULT__CERTAUTH_KEY_NOT_FOUND 4077
#define IDS_ERR_DISPLAY__HRESULT__CERTAUTH_WAS_GIVEN_INVALID_DATA 4078
#define IDS_ERR_DISPLAY__HRESULT__CERTAUTH_REQ_TOO_BIG 4079
#define IDS_ERR_DISPLAY__HRESULT__CERTAUTH_INVALID_REQUEST 4080
#define IDS_ERR_DISPLAY__HRESULT__MYSTOREFLAGS_ACCESS_FAILED 4081
#define IDS_ERR_DISPLAY__HRESULT__ACCEPTPKCS7_ROOTSTORE_NM_SET 4082
#define IDS_INCOMPLETE_BECAUSE_OF_LOW_MEMORY_AVAILABILITY 5001
#define IDS_FILE_PICK_KEYRING_BCKUP     5002
#define IDS_FILE_PICK_CERTFILE2WRITE    5003
#define IDS_MD_CERT_ENROLL_NONE         5005
#define IDS_MD_CERT_ENROLL_ENTERING_DATA_ERROR 5006
#define IDS_MD_CERT_ERROR_DURING_ENROLL_BEFORE_SENDING_TO_CA 5007
#define IDS_MD_CERT_ENROLL_ERR_PROCESSING_PKCS7_OUTOFBAND_B4_XENROLL 5008
#define IDS_MD_CERT_ENROLL_RECVED_ERR_FROM_CA 5009
#define IDS_MD_CERT_ENROLL_RECVED_ERR_FROM_ENROLL 5010
#define IDS_MD_CERT_ENROLL_BAD_PKCS7_RECVED_OUTOFBAND 5011
#define IDS_MD_CERT_ENROLL_RENEWAL_REQ_ERROR 5012
#define IDS_MD_CERT_ENROLL_ENTERING_DATA 5013
#define IDS_MD_CERT_ENROLL_PROCESSING_PKCS7_OUTOFBAND 5014
#define IDS_MD_CERT_ENROLL_SENT_TO_CA   5015
#define IDS_MD_CERT_ENROLL_RECVED_OK_FROM_CA_WAITING4ENROLL 5016
#define IDS_MD_CERT_ENROLL_ENROLL_SUCCESS 5017
#define IDS_MD_CERT_ENROLL_RENEWAL_REQ_STARTED 5018
#define IDS_MD_CERT_ENROLL_IMPORT_OF_KEYRING_BACKUP_FAILED 5019
#define IDS_YOU_ALREADY_HAVE_AN_OOB_CERTIFICATE_REQ 5020
#define IDS_YOU_DONT_HAVE_ANY_OUTSTANDING_OFFLINE_CERTIFICATE_REQUESTS 5021
#define IDS_YOU_CURRENTLY_HAVE_A_CERTIFICATE_INSTALLED_ON_THIS_VIRUTAL_SERVER 5022
#define IDS_WOULD_YOU_LIKE_TO_VIEW_THE_CERTIFICATE_THAT_YOU_JUST_IMPORTED 5023
#define IDS_YOUR_IMPORT_OF_THE_KEYRING_BACKUP_FILE_FAILED 5024
#define IDS_WOULD_YOU_LIKE_TO_VIEW_THE_CERTIFICATE 5025
#define IDS_YOU_ALREADY_HAVE_A_CERTIFICATE 5026
#define IDS_YOU_DO_NOT_CURRENTLY_HAVE_A_CERTIFICATE_TO_RENEW 5027
#define IDS_INTERNAL_ERROR_COULD_NOT_RETRIEVE_CERTIFICATE 5028
#define IDS_INTERNAL_ERROR_COULD_NOT_STORE_CERTIFICATE 5029
#define IDS_CONSTRUCTING_A_NEW_CTL_FOR_YOUR_VIRTUAL_WEB_SERVER 5030
#define IDS_USER_INPUT_CONTAINS_CHARACTERS_THAT_ARE_NOT_ALLOWED 5031
#define IDS_TITLE_CREATE_CTL_WIZ        5032
#define IDS_REVERSE_DNS_NAME_BASED_ON_YOUR_VSERVER_DIFFERS_FROM_REG 5033
#define IDS_CAN_NOT_OPEN_SYSTEM_CERTIFICATE_STORES 5034
#define IDS_CAN_NOT_CLOSE_SYSTEM_CERTIFICATE_STORES 5035
#define IDS_INTERNAL_ERROR_PLEASE_CONTACT_CUSTOMER_HELP 5036
#define IDS_COULD_NOT_ACCESS_THE_METABASE 5037
#define IDS_ERR_CERTWIZ_TITLE           5038
#define IDS_ERR_DISPLAY__OOB_INVALID_FILE_WAS_GIVEN 5039
#define IDS_CHOOSE_PREEXISTING_CERT4THIS_SERVER 5040
#define IDS_ARE_YOU_SURE_YOU_WANT_TO_CANCEL 5041
#define IDS_KEYRING_BACKUP_FILE_IMPORT  5042
#define IDS_SETTING_CONTAINER_NAME_FAILED_IN_XENROLL 5046
#define IDS_YOU_DO_NOT_CURRENTLY_HAVE_A_CERTIFICATE_NEED_ONE4CTL 5048
#define IDS_YOU_ALREADY_HAVE_A_CTL      5049
#define IDS_YOU_DO_NOT_CURRENTLY_HAVE_A_CERTIFICATE_TO_DELETE 5050
#define IDS_ERR_DISPLAY__HRESULT__ACCEPTFILEPKCS7WORKED_BUT_FETCHING_CERT_FAILED 5051
#define IDS_OVERWRITEFILE               5052
#define IDS_WE_COULD_NOT_CREATE_FILE_WS 5053
#define IDS_ERR_DISPLAY__HRESULT__PUT_RENEWALCERTIFICATE_CALL_FAILED 5054
#define IDS_NO_SERVER_INSTANCE_SET      5055
#define IDD_TIPS_BEFORE__CTL_WIZARD     30131
#define IDD_COMPLETION_PAGE             30132
#define IDD_IMP_KEYRING_GET_PASSWD      30133
#define IDD_NK_KEYR_IMPORTFILE_INFO     30134
#define IDD_WZ_CTLADMIN_1_WELCOME       30135
#define IDD_NK_FINCERT_1_GETFILENM      30136
#define IDD_NK_FINCERT_2_FILEDATA       30137
#define IDD_WZ_CTLGET_2_WHAT_TASK       30138
#define IDD_WZ_CTL_CREATE_GETINFO1      30139
#define IDD_WZwo_CERTGET_2_WHAT_TASK    30140
#define IDD_WZwo_CERTGET_3_CHOOSE_CA    30141
#define IDD_WZwo_CERTGET_4_KEY_LENGTH   30142
#define IDD_WZwo_CERTGET_5_ORG_INFO     30143
#define IDD_WZwo_CERTGET_6_DN_INFO      30144
#define IDD_WZwo_CERTGET_7_COUNTRY_INFO 30145
#define IDD_WZwo_CERTGET_8_CONTACT_INFO 30146
#define IDD_WZwo_CERTGET_9_FILE_INFO    30147
#define IDD_WZwo_CERTOOB_1_FINCERT_GETFILENM 30148
#define IDD_WZwo_CERTGET_10_CONGRADS_CERT_INSTALLED 30149
#define IDD_WZerr_CERTWIZ_GENERAL_ERROR_PAGE 30150
#define IDS_DONE                        30151
#define IDD_WZwo_CERTGET_2_WHAT_TASK2   30151
#define IDD_WZw_CERTMOD_2_WHAT_TASK3    30152
#define IDD_WZw_CERTMOD_3_REMOVE_CERT   30153
#define IDS_DONT_HAVE_A_PENDING_CERT_REQUEST 30154
#define IDD_WZ_PROMPT_FOR_FRIENDLY_NAME 30154
#define IDS_ERROR_RESULT_PHRASE         30155
#define IDS_UNKNOWN_ERROR               30156
#define IDS_CAUGHT_AN_UNKNOWN_EXCEPTION 30157
#define IDS_CERTIFICATE_WIZARD_CHOOSE_A_CERTIFICATE 30158
#define IDS_YES                         30159
#define IDS_OK                          30160
#define IDS_CERT_HAS_BEEN_REMOVED       30161
#define IDS_COULDNT_MAP_CERT_TO_VALID_CERT_STORE_NAME 30162
#define IDS_SETTING_CONTAINER_NAME_FAILED 30163
#define IDS_ERR_DISPLAY__HRESULT__USE_MD5_CALL_FAILED 30164
#define IDS_ERROR_GETTING_KEY_CONTAINER_NAME_FOR_THE_CERT 30166
#define IDS_ERROR_STORING_EITHER_THE_KEY_CONTAINER_OR_STORE_NAME_FOR_CERT 30167
#define IDS_COMMON_NAME                 30168
#define IDS_FRIENDLY_NAME               30169
#define IDS_EXPIRATION                  30170
#define IDS_PURPOSE                     30171
#define IDS_ISSUED_BY                   30172
#define IDS_STORE_NAME                  30173
#define IDS_EXPIRED                     30174
#define IDS_NOT_YET_VALID               30175
#define IDS_YOU_MUST_SELECT_A_CERT_THEN_PRESS_FINISH 30176
#define IDS_ANY_PURPOSE                 30177
#define IDS_SERVERCERT__PLUS__CTL_SIGNING 30178
#define IDS_CLOCK_SKEW_PART1            30179
#define IDS_CLOCK_SKEW_PART2            30180
#define IDS_GETHOSTNAME_FAILED_RETURNING_SOCKET 30182
#define IDS_WSAEFAULT                   30183
#define IDS_WSAEFAULT_NAMED_PARAM_NOT_VALID 30184
#define IDS_WSANOTINITIALISED           30185
#define IDS_WSAEINPROGRESS              30186
#define IDS_WE_COULD_NOT_OPEN_FILE_FOR_READING 30187
#define IDS_ERROR_WHILE_READING_FILE__S__ERROR_CODE__D 30188
#define IDS_INSUFFICIENT_MEMORY_WHILE_READING_FILE_S 30189
#define IDS_ERR_DISPLAY__HRESULT__USE_PROV_RSA_SCHANNEL_CALL_FAILED 30191
#define IDS_LOCALHOST                   30193
#define IDS_HRESULT_ERROR_CODE          30194
#define IDS_ERR_DISPLAY__HRESULT__CREATEPKCS10_CALL_FAILED__NTE_EXISTS 30195
#define IDS_NO_SPECIFIC_ERROR_STRING_WAS_FOUND_IN_THE_INTERNATIONALIZED_STRING_TABLE 30196
#define IDS_WE_CURRENTLY_DONT_SUPPORT_REMOTE_CERTSERVER_ONLINE_INTERFACES 30197
#define IDS_WE_CURRENTLY_DONT_SUPPORT_REMOTE_ADMIN_OF_SERVERS 30198
#define IDS_GET_COMPUTER_NAME_FAILED    30199
#define IDS_ERROR_LOADING_RESOURCE_STRING_HAVING_ID 30200
#define IDS_UNKNOWN_ERROR_CODE          30201
#define IDS_ENCRYPTION_NOT_ALLOWED_BASED_ON_THE_MACHINE_CONFIG_DATA 30202
#define IDS__NTE_BAD_FLAGS__ERROR       30203
#define IDS__NTE_BAD_ALGID__ERROR       30204
#define IDS__RPC_E_DISCONNECTED         30205
#define IDS__RPC_E_RETRY                30206
#define IDS_FILE_PICK_CERTFILE2READ     30207
#define IDS_ENTER_COMPUTER_NAME_HERE    30208
#define IDS_AN_ERROR_WAS_ENCOUNTERED_IN_CALL_xxx_PRODUCING_AN_ERROR_CODE_OF 30209
#define IDS_LIMIT_THE_LENGTH_OF_THIS_FIELD 30210
#define IDS_CERTSERVER_IS_PROBABLY_NOT_INSTALLED 30211
#define IDS_PROBLEM_WHEN_RUNNING_X_Y_OPERATION 30212
#define IDS_REGISTER                    30213
#define IDS_UNREGISTER                  30214
#define IDS_PROBLEM_WRITING_TO_FILE_WS_ERROR_D 30215
#define IDS_GETTEMPPATH_FOR_S_PRODUCED_ERROR_D 30216
#define IDS_GETTEMPFILENAME_FOR_S_GAVE_ERROR_D 30217
#define IDS_CREATEFILE_FOR_S_GAVE_ERROR_D 30218
#define IDS_TEMP_FILE_S_NOT_EMPTY_AFTER_WE_CREATED_IT 30219
#define IDS_WRITING_FILE_S_PRODUCED_ERROR_D 30220
#define IDS_CLOSE_FILEHANDLE_FOR_S_GAVE_ERROR_D 30221
#define IDS_CERT_ATTEMPTING_TO_RENEW_VIA_OOB_DOES_NOT_MATCH_CURRENT 30222
#define IDS_PLEASE_CONFIRM__RENEW_CERT_NOT_CURRENTLY_ASSIGNED 30223
#define IDS_CANCELLING_THE_RENEW_OPERATION 30224
#define IDS_WE_COULDNT_FIND_SAVED_OFFLINE_INFO_ABOUT_THIS_CERT_USING_PKCS7 30225
#define IDS_COUNTRY_CODES_ARE_2_LETTERS_LONG 30226
#define IDS_RENEWAL_INFORMATION_FOR_CERT_NOT_AVAILABLE                30227
#define IDS_INTERNAL_ERROR_PLEASE_CONTACT_YOUR_SYSTEM_ADMIN           30228
#define IDS_INTERNAL_ERROR_PLEASE_CONTACT_YOUR_SYSTEM_ADMIN_ERROR__D  30229 
#define IDS_EMPTY_STRING                                              30231

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        241
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         256
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\certmap\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\certmap\mapwpge.cpp ===
// MapWPge.cpp : implementation file
//

#include "stdafx.h"
#include <iadmw.h>
#include "certmap.h"

extern "C"
    {
    #include <wincrypt.h>
    #include <sslsp.h>
    }

#include "Iismap.hxx"
#include "Iiscmr.hxx"

#include "brwsdlg.h"
#include "ListRow.h"
#include "ChkLstCt.h"

#include "MapWPge.h"
#include "Ed11Maps.h"
#include "EdWldRul.h"

#include <iiscnfgp.h>
#include "wrapmb.h"

#include "WWzOne.h"
#include "WWzTwo.h"
#include "WWzThree.h"

#include <lmcons.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


#define COL_NUM_ENABLED                 0
#define COL_NUM_DESCRIPTION             1
#define COL_NUM_NTACCOUNT               2


#define MB_EXTEND_KEY   "CertW"

/////////////////////////////////////////////////////////////////////////////
// CMapWildcardsPge property page

IMPLEMENT_DYNCREATE(CMapWildcardsPge, CPropertyPage)

//---------------------------------------------------------------------------
CMapWildcardsPge::CMapWildcardsPge() : CPropertyPage(CMapWildcardsPge::IDD),
    m_fDirty(FALSE)
    {
    //{{AFX_DATA_INIT(CMapWildcardsPge)
    m_bool_enable = FALSE;
    //}}AFX_DATA_INIT
    }

//---------------------------------------------------------------------------
CMapWildcardsPge::~CMapWildcardsPge()
    {
    }

//---------------------------------------------------------------------------
void CMapWildcardsPge::DoDataExchange(CDataExchange* pDX)
    {
    CPropertyPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CMapWildcardsPge)
    DDX_Control(pDX, IDC_LIST, m_clistctrl_list);
    DDX_Control(pDX, IDC_MOVE_UP, m_cbutton_up);
    DDX_Control(pDX, IDC_MOVE_DOWN, m_cbutton_down);
    DDX_Control(pDX, IDC_ADD, m_cbutton_add);
    DDX_Control(pDX, IDC_DELETE, m_cbutton_delete);
    DDX_Control(pDX, IDC_EDIT, m_cbutton_editrule);
    DDX_Check(pDX, IDC_ENABLE, m_bool_enable);
    //}}AFX_DATA_MAP
    }


//---------------------------------------------------------------------------
BEGIN_MESSAGE_MAP(CMapWildcardsPge, CPropertyPage)
    //{{AFX_MSG_MAP(CMapWildcardsPge)
    ON_BN_CLICKED(IDC_MOVE_DOWN, OnMoveDown)
    ON_BN_CLICKED(IDC_MOVE_UP, OnMoveUp)
    ON_BN_CLICKED(IDC_ADD, OnAdd)
    ON_BN_CLICKED(IDC_DELETE, OnDelete)
    ON_BN_CLICKED(IDC_EDIT, OnEdit)
    ON_NOTIFY(LVN_ITEMCHANGED, IDC_LIST, OnItemchangedList)
    ON_NOTIFY(NM_DBLCLK, IDC_LIST, OnDblclkList)
    ON_BN_CLICKED(IDC_ENABLE, OnEnable)
    //}}AFX_MSG_MAP
    ON_COMMAND(ID_HELP_FINDER,  DoHelp)
    ON_COMMAND(ID_HELP,         DoHelp)
    ON_COMMAND(ID_CONTEXT_HELP, DoHelp)
    ON_COMMAND(ID_DEFAULT_HELP, DoHelp)
END_MESSAGE_MAP()

//---------------------------------------------------------------------------
void CMapWildcardsPge::DoHelp()
    {
    WinHelp( HIDD_CERTMAP_MAIN_ADVANCED );
    }

/////////////////////////////////////////////////////////////////////////////
// initialization routines

//---------------------------------------------------------------------------
// FInitMapper is called by the routine instantiating this page. After the object
// is first created is when it is called. It allows us to fail gracefully.
BOOL CMapWildcardsPge::FInit(IMSAdminBase* pMB)
    {
    BOOL            fAnswer = FALSE;
    PVOID           pData = NULL;
    DWORD           cbData = 0;
    BOOL            f;

    m_pMB = pMB;

    // before messing with the metabase, prepare the strings we will need
    CString         szBasePath = m_szMBPath;
    CString         szRelativePath = MB_EXTEND_KEY;
    CString         szObjectPath = m_szMBPath + _T('/') + szRelativePath;

    // prepare the metabase wrapper
    CWrapMetaBase   mbWrap;
    f = mbWrap.FInit(m_pMB);
    if ( !f ) return FALSE;

    // attempt to open the object we want to store into
    f = mbWrap.Open( szObjectPath, METADATA_PERMISSION_READ );

    // if that worked, load the data
    if ( f )
        {
        // first, get the size of the data that we are looking for
        pData = mbWrap.GetData( _T(""), MD_SERIAL_CERTW, IIS_MD_UT_SERVER, BINARY_METADATA, &cbData );

        // if we successfully got the data, unserialize it
        // WARNING: m_mapper.Unserialize changes the value of the pointer that is passed in. Pass
        // in a copy of the pointer
        PUCHAR  pDataCopy = (PUCHAR)pData;
        if ( pData )
            fAnswer = m_mapper.Unserialize( (PUCHAR*)&pDataCopy, &cbData );

        // close the object
        f = mbWrap.Close();

        // cleanup
        if ( pData )
            mbWrap.FreeWrapData( pData );
        }

    // return the answer
    return fAnswer;
    }

//---------------------------------------------------------------------------
BOOL CMapWildcardsPge::OnInitDialog()
    {
    //call the parental oninitdialog
    BOOL f = CPropertyPage::OnInitDialog();

    // if the initinalization (sp?) succeeded, init the list and other items
    if ( f )
        {
        // init the contents of the list
        FInitRulesList();

        // Fill the mapping list with the stored items
        FillRulesList();

        // set the initial button states
        EnableDependantButtons();
        }

    // set the initial state of the enable button
    // get the globals object
    CCertGlobalRuleInfo* pGlob = m_mapper.GetGlobalRulesInfo();
    m_bool_enable = pGlob->GetRulesEnabled();

    // set any changes in the info into place
    UpdateData(FALSE);

    // return the answer
    return f;
    }

//---------------------------------------------------------------------------
BOOL CMapWildcardsPge::FInitRulesList()
    {
    CString sz;
    int             i;

    // setup the friendly name column
    sz.Empty();
    i = m_clistctrl_list.InsertColumn( COL_NUM_ENABLED, sz, LVCFMT_LEFT, 20 );

    // setup the description column
    sz.LoadString( IDS_WILD_DESCRIPTION );
    i = m_clistctrl_list.InsertColumn( COL_NUM_DESCRIPTION, sz, LVCFMT_LEFT, 238 );

    // setup the account column
    sz.LoadString( IDS_WILD_ACCOUNT );
    i = m_clistctrl_list.InsertColumn( COL_NUM_NTACCOUNT, sz, LVCFMT_LEFT, 220 );

    return TRUE;
    }

//---------------------------------------------------------------------------
// fill in the rules. Get the order for the rules from the globals object. That
// way there is no need to sort them later
BOOL CMapWildcardsPge::FillRulesList()
    {
    // get the globals object
    CCertGlobalRuleInfo* pGlob = m_mapper.GetGlobalRulesInfo();

    // get the number of rules (actually its a number of rule order - but they are the same thing)
    DWORD   cbRules = m_mapper.GetRuleCount();

    // get the pointer to the order array
    DWORD*  pOrder = pGlob->GetRuleOrderArray();

    // for each item in the mapper object, add it to the list control
    for ( DWORD j = 0; j < cbRules; j++ )
        {
        CCertMapRule*   pRule;
        DWORD                   iRule = pOrder[j];

        // get the mapping
        pRule = m_mapper.GetRule( iRule );

        // if that worked, add it to the list
        if ( pRule )
            {
            // add it to the list
            AddRuleToList( pRule, iRule, 0xffffffff );
            }
        }

    // it worked - so ok.
    return TRUE;
    }

//---------------------------------------------------------------------------
int CMapWildcardsPge::AddRuleToList( CCertMapRule* pRule, DWORD iRule, int iInsert )
    {
    CString sz;
    int             i;

    if ( !pRule )
        return -1;

    // if the item to be inserted is to be the last, set it up
    if ( iInsert == 0xffffffff )
        iInsert = m_clistctrl_list.GetItemCount();

    // get the appropriate "enabled" string
    BOOL fEnabled = pRule->GetRuleEnabled();
    if ( fEnabled )
        sz.LoadString( IDS_ENABLED );
    else
        sz.Empty();

    // add the friendly name of the mapping
    // create the new entry in the list box. Do not sort on this entry - yet
    i = m_clistctrl_list.InsertItem( iInsert, sz );

    // add the friendly name of the rule
    sz = pRule->GetRuleName();
    // create the new entry in the list box. Do not sort on this entry - yet
    m_clistctrl_list.SetItemText( i, COL_NUM_DESCRIPTION, sz );

    // add the account name of the mapping
    if ( pRule->GetRuleDenyAccess() )
        sz.LoadString( IDS_DENYACCESS );
    else
        sz = pRule->GetRuleAccount();
    m_clistctrl_list.SetItemText( i, COL_NUM_NTACCOUNT, sz );

    // attach the mapper index to the item in the list - it may have a different
    // list index after the list has been sorted.
    m_clistctrl_list.SetItemData( i, iRule );

    // return whether or not the insertion succeeded
    return i;
    }

//---------------------------------------------------------------------------
// Note: supposedly, the order of the items in the list and the odrder
// of the items in the globals object should be the same
void CMapWildcardsPge::UpdateRuleInDispList( DWORD iList, CCertMapRule* pRule )
    {
    CString sz;

    // get the appropriate "enabled" string
    BOOL fEnabled = pRule->GetRuleEnabled();
    if ( fEnabled )
        sz.LoadString( IDS_ENABLED );
    else
        sz.Empty();

    // update the "Enabled" indicator
    m_clistctrl_list.SetItemText( iList, COL_NUM_ENABLED, sz );

    // update the mapping name
    sz = pRule->GetRuleName();
    m_clistctrl_list.SetItemText( iList, COL_NUM_DESCRIPTION, sz );

    // update the account name
    if ( pRule->GetRuleDenyAccess() )
        sz.LoadString( IDS_DENYACCESS );
    else
        sz = pRule->GetRuleAccount();
    m_clistctrl_list.SetItemText( iList, COL_NUM_NTACCOUNT, sz );
    }


//---------------------------------------------------------------------------
// editing a wildcard rule is rather complex, thus I am seperating that code
// out into that for the dialog itself. All we do is pass in the rule pointer
// and let it go at that.
BOOL CMapWildcardsPge::EditOneRule( CCertMapRule* pRule, BOOL fAsWizard )
    {
    // edit the item using a tabbed dialog / wizard
    CPropertySheet  propSheet;
    CWildWizOne     wwOne;
    CWildWizTwo     wwTwo;
    CWildWizThree   wwThree;

    // set the params
    wwOne.m_pMB = m_pMB;

    // fill in the data for the pages
    wwOne.m_pRule = pRule;
    wwOne.m_szMBPath = m_szMBPath;
    wwOne.m_fIsWizard = fAsWizard;
    wwOne.m_pPropSheet = &propSheet;

    wwTwo.m_pRule = pRule;
    wwTwo.m_szMBPath = m_szMBPath;
    wwTwo.m_fIsWizard = fAsWizard;
    wwTwo.m_pPropSheet = &propSheet;

    wwThree.m_pRule = pRule;
    wwThree.m_szMBPath = m_szMBPath;
    wwThree.m_fIsWizard = fAsWizard;
    wwThree.m_pPropSheet = &propSheet;

    // add the pages
    propSheet.AddPage( &wwOne );
    propSheet.AddPage( &wwTwo );
    propSheet.AddPage( &wwThree );

    // turn it into a wizard if necessary
    if ( fAsWizard )
        propSheet.SetWizardMode();

    // set the title of the wizard/tabbed dialog thing
    CString   szTitle;

    szTitle.LoadString( IDS_WILDWIZ_TITLE );

    propSheet.SetTitle( szTitle );

    // turn on help
    propSheet.m_psh.dwFlags |= PSH_HASHELP;
    wwOne.m_psp.dwFlags |= PSP_HASHELP;
    wwTwo.m_psp.dwFlags |= PSP_HASHELP;
    wwThree.m_psp.dwFlags |= PSP_HASHELP;

    // run the wizard and return if it ended with IDOK
    INT_PTR id = propSheet.DoModal();
    return ( (id == IDOK) || (id == ID_WIZFINISH) );

 /*
   CEditWildcardRule       ruleDlg;

    // prepare
    ruleDlg.m_pRule = pRule;
    ruleDlg.m_szMBPath = m_szMBPath;

    // run the dialog and return if it ended with IDOK
    return (ruleDlg.DoModal() == IDOK);
*/
    }

//---------------------------------------------------------------------------
// Yeah! the CEdit11Mappings works equally well for multiple rules! - just
// some modifications in this routine!
BOOL CMapWildcardsPge::EditMultipleRules()
    {
    CEdit11Mappings mapdlg;
    CCertMapRule*   pRule;
    BOOL                    fSetInitialState = FALSE;
    BOOL                    fEnable;


    // scan the list of seleted items for the proper initial enable button state
    // loop through the selected items, setting each one's mapping
    int     iList = -1;
    while( (iList = m_clistctrl_list.GetNextItem( iList, LVNI_SELECTED )) >= 0 )
        {
        // get the mapper index for the item
        // IA64 - this is OK to cast to DWORD as it is just an index
        DWORD iMapper = (DWORD)m_clistctrl_list.GetItemData( iList );

        // get the mapping item for updating purposes
        pRule = m_mapper.GetRule( iMapper );
        if ( !pRule )
            {
            AfxMessageBox( IDS_ERR_ACCESS_MAPPING );
            break;
            }

        // get the enable state of the mapping
        fEnable = pRule->GetRuleEnabled();

        // if this is the first time, just set the initial state
        if ( !fSetInitialState )
            {
            mapdlg.m_int_enable = fEnable;
            fSetInitialState = TRUE;
            }
        else
            {
            // if it is different, then go indeterminate and break
            if ( fEnable != mapdlg.m_int_enable )
                {
                mapdlg.m_int_enable = 2;
                break;
                }
            }
        }

    //
    // ANSI/UNICODE conversion - RonaldM
    //
    USES_CONVERSION;

    // run the mapping dialog
    if ( mapdlg.DoModal() == IDOK )
        {
        // loop through the selected items, setting each one's mapping
        int     iList = -1;
        while( (iList = m_clistctrl_list.GetNextItem( iList, LVNI_SELECTED )) >= 0 )
            {
            // get the mapper index for the item
            // IA64 - this is OK to cast to DWORD as it is just an index
            DWORD iMapper = (DWORD)m_clistctrl_list.GetItemData( iList );

            // get the mapping item for updating purposes
            pRule = m_mapper.GetRule( iMapper );
            if ( !pRule )
                {
                AfxMessageBox( IDS_ERR_ACCESS_MAPPING );
                break;
                }

            // set the enable flag if requested
            switch ( mapdlg.m_int_enable )
                {
                case 0:         // disable
                    pRule->SetRuleEnabled( FALSE );
                    break;
                case 1:         // enable
                    pRule->SetRuleEnabled( TRUE );
                    break;
                }

            // set the NT account field of the mapping object
            pRule->SetRuleAccount( T2A ((LPTSTR)(LPCTSTR)mapdlg.m_sz_accountname) );

            // update it in the list control too
            UpdateRuleInDispList( iList, pRule );
            }

        // activate the apply button
        SetModified();
        m_fDirty = TRUE;

        // return true because the user said "OK"
        return TRUE;
        }

    // return FALSE because the user did not say "OK"
    return FALSE;
    }

//---------------------------------------------------------------------------
void CMapWildcardsPge::EnableDependantButtons()
    {
    // the whole purpose of this routine is to gray or activate
    // the edit and delete buttons depending on whether or not anything
    // is selected. So start by getting the selection count
    UINT    cItemsSel = m_clistctrl_list.GetSelectedCount();

    // if there is only one item selected, then possibly activate the up/down buttons
    if ( cItemsSel == 1 )
        {
        m_cbutton_up.EnableWindow( TRUE );
        m_cbutton_down.EnableWindow( TRUE );
        }
    else
        {
        m_cbutton_up.EnableWindow( FALSE );
        m_cbutton_down.EnableWindow( FALSE );
        }

    // now the more general case of multiple selections
    if ( cItemsSel > 0 )
        {
        // there are items selected
        m_cbutton_editrule.EnableWindow( TRUE );
        m_cbutton_delete.EnableWindow( TRUE );
        }
    else
        {
        // nope. Nothing selected
        m_cbutton_editrule.EnableWindow( FALSE );
        m_cbutton_delete.EnableWindow( FALSE );
        }

    // always enable the add button
    m_cbutton_add.EnableWindow( TRUE );
    }


/////////////////////////////////////////////////////////////////////////////
// CMapWildcardsPge message handlers

//---------------------------------------------------------------------------
BOOL CMapWildcardsPge::OnApply()
    {
    BOOL                            f;
    CStoreXBF                       xbf;
    METADATA_HANDLE         hm;

    // if no changes have been made, then don't do anything
    if ( !m_fDirty )
        return TRUE;

    UpdateData( TRUE );

    CWaitCursor wait;

    // set the current value of enable into place
    // get the globals object
    CCertGlobalRuleInfo* pGlob = m_mapper.GetGlobalRulesInfo();
    pGlob->SetRulesEnabled( m_bool_enable );

    // serialize the reference to the mapper itself
    f = m_mapper.Serialize( &xbf );

    // before messing with the metabase, prepare the strings we will need
    CString         szBasePath = m_szMBPath;
    CString         szRelativePath = MB_EXTEND_KEY;
    CString         szObjectPath = m_szMBPath + _T('/') + szRelativePath;

    // prepare the metabase wrapper
    CWrapMetaBase   mbWrap;
    f = mbWrap.FInit(m_pMB);

    // attempt to open the object we want to store into
    f = mbWrap.Open( szObjectPath, METADATA_PERMISSION_WRITE );

    // if that did not work, we need to add the object
    if ( !f )
        {
        // need a slash after the namespace extention now
        szBasePath += _T('/');

        // open the base object
        f = mbWrap.Open( szBasePath, METADATA_PERMISSION_WRITE );
        if ( !f )
            {
            AfxMessageBox(IDS_ERR_ACCESS_MAPPING);
            return FALSE;
            }

        // add the object we want
        f = mbWrap.AddObject( szRelativePath );
        if ( !f )
            {
            AfxMessageBox(IDS_ERR_ACCESS_MAPPING);
            mbWrap.Close();
            return FALSE;
            }

        // close the base object
        f = mbWrap.Close();

        // attempt to open the object we want to store into
        f = mbWrap.Open( szObjectPath, METADATA_PERMISSION_WRITE );
        }

    // set the data into place in the object - IF we were ablt to open it
    if ( f )
        mbWrap.SetData( _T(""), MD_SERIAL_CERTW, IIS_MD_UT_SERVER, BINARY_METADATA, xbf.GetBuff(), xbf.GetUsed(), METADATA_SECURE );

    // close the object
    f = mbWrap.Close();

    // save the changes to the metabase
    f = mbWrap.Save();

    // tell the persistence object to tuck away the reference so that we may find it later
    // f = m_persist.FSave( xbf.GetBuff(), xbf.GetUsed() );

    // deactivate the apply button
    SetModified( FALSE );
    m_fDirty = FALSE;

    //  return f;
    return TRUE;
    }

//---------------------------------------------------------------------------
void CMapWildcardsPge::OnMove( int delta )
    {
    int    iList;

    ASSERT( delta != 0 );

    // make sure there is only one item selected
    ASSERT( m_clistctrl_list.GetSelectedCount() == 1 );

    // Get the list index of the item in question.
    // this is also the index into the rule order array
    iList = m_clistctrl_list.GetNextItem( -1, LVNI_SELECTED );

    // get the globals object
    CCertGlobalRuleInfo* pGlob = m_mapper.GetGlobalRulesInfo();

    // get the number of rules (actually its a number of rule order - but they are the same thing)
    int     cbRules = pGlob->GetRuleOrderCount();

    // test against the edge conditions
    if ( ((iList == 0) && (delta < 0)) | ((iList == (cbRules - 1)) && (delta > 0)) )
        return;

    // get the pointer to the order array
    DWORD * pOrder = pGlob->GetRuleOrderArray();

    // calculate the new position in the array
    int iNewPosition = iList + delta;

    // store away the mapper's iIndex (not the position) of the item
    UINT iIndex = pOrder[iList];

    // swap the positions
    DWORD itemp = pOrder[iNewPosition];
    pOrder[iNewPosition] = pOrder[iList];
    pOrder[iList] = itemp;

    ASSERT( pOrder[iNewPosition] == iIndex );

    // unfortunately, we can't just do that with the display list. We have to remove the
    // the item, then re-insert it. Its a flaw in the CListCtrl object. Arg.
    // we have to get the item too
    CCertMapRule* pRule = m_mapper.GetRule( iIndex );

    // delete the item from the display list
    m_clistctrl_list.DeleteItem( iList );

    // re-insert it
    int iNew = AddRuleToList( pRule, iIndex, iNewPosition );

    // make sure it is visible in the list
    m_clistctrl_list.EnsureVisible( iNew, FALSE );

    // finally, because its been removed and re-inserted, we need to
    // re-select it as well - CListCtrl is such a pain at this
    LV_ITEM         lv;
    ZeroMemory( &lv, sizeof(lv) );
    lv.mask = LVIF_STATE;
    lv.iItem = iNew;
    lv.state = LVIS_SELECTED;
    lv.stateMask = LVIS_SELECTED;
    m_clistctrl_list.SetItem( &lv );

    // activate the apply button
    SetModified();
    m_fDirty = TRUE;
    }

//---------------------------------------------------------------------------
void CMapWildcardsPge::OnMoveDown()
    {
    OnMove( 1 );
    }

//---------------------------------------------------------------------------
void CMapWildcardsPge::OnMoveUp()
    {
    OnMove( -1 );
    }

//---------------------------------------------------------------------------
void CMapWildcardsPge::OnAdd()
    {
    CHAR sz[256];

    // create the new rule
    CCertMapRule * pNewRule = new CCertMapRule();

    if (pNewRule == NULL)
        return;

    // give the new rule some defaults
    LoadStringA(::AfxGetInstanceHandle(), IDS_DEFAULT_RULE, sz, 255 );

    pNewRule->SetRuleName( sz );
    pNewRule->SetRuleEnabled( TRUE );

    // Edit the rule. If it fails, remove it from the list
    if ( !EditOneRule( pNewRule, TRUE ) )
        {
        // kill the rule and return
        delete pNewRule;
        return;
        }

    // make a new mapper & get its index
    DWORD iNewRule = m_mapper.AddRule( pNewRule );

    // add the rule to the end of the display list. - It is added to the
    // end of the rule list by default
    AddRuleToList( pNewRule, iNewRule );

    // make sure it is visible in the list
    m_clistctrl_list.EnsureVisible( iNewRule, FALSE );

    // activate the apply button
    SetModified();
    m_fDirty = TRUE;
    }

//---------------------------------------------------------------------------
void CMapWildcardsPge::OnDelete()
    {
    // ask the user to confirm this decision
    if ( AfxMessageBox(IDS_CONFIRM_DELETE, MB_OKCANCEL) != IDOK )
        return;

    CWaitCursor wait;

    // loop through the selected items, setting each one's mapping
    int     iList = -1;
    while( (iList = m_clistctrl_list.GetNextItem( -1, LVNI_SELECTED )) >= 0 )
        {
        // get the mapper index for the item
        // IA64 - this is OK to cast to DWORD as it is just an index
        DWORD iMapper = (DWORD)m_clistctrl_list.GetItemData( iList );

        // delete the mapping from the mapper
        m_mapper.DeleteRule( iMapper );

        // delete the entry from the list box
        m_clistctrl_list.DeleteItem( iList );


        // because the index in the mapper for all the items below this
        // one changes when it is deleted, we must go and fix them all.
        DWORD numItems = m_clistctrl_list.GetItemCount();
        for ( DWORD iFix = iList; iFix < numItems; iFix++ )
            {
            // get the mapper index for the item to be fixed
            // IA64 - this is OK to cast to DWORD as it is just an index
            iMapper = (DWORD)m_clistctrl_list.GetItemData( iFix );

            // decrement it to reflect the change
            iMapper--;

            // put it back.
            m_clistctrl_list.SetItemData( iFix, iMapper );
            }
        }

    // activate the apply button
    SetModified();
    m_fDirty = TRUE;
    }

//---------------------------------------------------------------------------
void CMapWildcardsPge::OnEdit()
    {
    int             iList;
    DWORD           iRule;
    CCertMapRule*   pUpdateRule;

    // what happens here depends on if just one mapping is selected, or many
    switch( m_clistctrl_list.GetSelectedCount() )
        {
        case 0:         // do nothing - should not get here because button grays out
            ASSERT( FALSE );
            break;

        case 1:         // get the mapping for update and run single edit dialog
            // get index of the selected list item
            iList = m_clistctrl_list.GetNextItem( -1, LVNI_SELECTED );
            ASSERT( iList >= 0 );

            // get the mapper index for the item
            // IA64 - this is OK to cast to DWORD as it is just an index
            iRule = (DWORD)m_clistctrl_list.GetItemData( iList );

            // get the mapping item for updating purposes
            pUpdateRule = m_mapper.GetRule( iRule );

            if ( !pUpdateRule )
                {
                AfxMessageBox( IDS_ERR_ACCESS_MAPPING );
                break;
                }

            // edit the mapping, update it if successful, delete if not
            if ( EditOneRule(pUpdateRule) )
                {
                UpdateRuleInDispList( iList, pUpdateRule );
                // activate the apply button
                SetModified();
                m_fDirty = TRUE;
                }
            break;

        default:        // run the multi edit dialog
            EditMultipleRules();
            break;
        }
    }

//---------------------------------------------------------------------------
void CMapWildcardsPge::OnItemchangedList(NMHDR* pNMHDR, LRESULT* pResult)
    {
    NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;
    *pResult = 0;

    // enable the correct items
    EnableDependantButtons();
    }

//---------------------------------------------------------------------------
void CMapWildcardsPge::OnDblclkList(NMHDR* pNMHDR, LRESULT* pResult)
    {
    *pResult = 0;

    // if something in the list was double clicked, edit it
    if ( m_clistctrl_list.GetSelectedCount() > 0 )
       OnEdit();
    }

//---------------------------------------------------------------------------
void CMapWildcardsPge::OnEnable()
    {
    // activate the apply button
    SetModified();
    m_fDirty = TRUE;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\certmap\wrapmaps.cpp ===
/*++

Module Name:

    wrapmaps.cpp

Abstract:

    wrapper classes for the mapper classes provided by phillich. See the headers in iismap.hxx
    These wrappers simplify the code interfaces for accessing the data.

Author:

   Boyd Multerer        boydm
   Boyd Multerer        boydm       4/16/97

--*/

//C:\nt\public\sdk\lib\i386

#include "stdafx.h"
#include "WrapMaps.h"


//#define IISMDB_INDEX_CERT11_CERT        0
//#define IISMDB_INDEX_CERT11_NT_ACCT     1
//#define IISMDB_INDEX_CERT11_NAME        2
//#define IISMDB_INDEX_CERT11_ENABLED     3
//#define IISMDB_INDEX_CERT11_NB          4


//----------------------------------------------------------------
BOOL C11Mapping::GetCertificate( PUCHAR* ppCert, DWORD* pcbCert )
    {
    *ppCert = (PUCHAR)m_pCert;
    *pcbCert = m_cbCert;
    return TRUE;
    }

//----------------------------------------------------------------
BOOL C11Mapping::SetCertificate( PUCHAR pCert, DWORD cbCert )
    {
    // we want to store a copy of the certificate - first free any existing cert
    if ( m_pCert )
        {
        GlobalFree( m_pCert );
        cbCert = 0;
        m_pCert = NULL;
        }
    // copy in the new one
    m_pCert = (PVOID)GlobalAlloc( GPTR, cbCert );
    if ( !m_pCert ) return FALSE;
    CopyMemory( m_pCert, pCert, cbCert );
    m_cbCert = cbCert;
    return TRUE;
    }

//----------------------------------------------------------------
BOOL C11Mapping::GetNTAccount( CString &szAccount )
    {
    szAccount = m_szAccount;
    return TRUE;
    }

//----------------------------------------------------------------
BOOL C11Mapping::SetNTAccount( CString szAccount )
    {
    m_szAccount = szAccount;
    return TRUE;
    }

//----------------------------------------------------------------
BOOL C11Mapping::GetNTPassword( CString &szPassword )
    {
    szPassword = m_szPassword;
    return TRUE;
    }

//----------------------------------------------------------------
BOOL C11Mapping::SetNTPassword( CString szPassword )
    {
    m_szPassword = szPassword;
    return TRUE;
    }

//----------------------------------------------------------------
BOOL C11Mapping::GetMapName( CString &szName )
    {
    szName = m_szName;
    return TRUE;
    }

//----------------------------------------------------------------
BOOL C11Mapping::SetMapName( CString szName )
    {
    m_szName = szName;
    return TRUE;
    }

//----------------------------------------------------------------
// the enabled flag is considered try if the SIZE of data is greater
// than zero. Apparently the content doesn't matter.
BOOL C11Mapping::GetMapEnabled( BOOL* pfEnabled )
    {
    *pfEnabled = m_fEnabled;
    return TRUE;
    }

//----------------------------------------------------------------
// the enabled flag is considered try if the SIZE of data is greater
// than zero. Apparently the content doesn't matter.
BOOL C11Mapping::SetMapEnabled( BOOL fEnabled )
    {
    m_fEnabled = fEnabled;
    return TRUE;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\certmap\wrapmaps.h ===
// wrapmaps.h  -- 

 
#ifndef   _wrapmaps_h__31598_
#define   _wrapmaps_h__31598_

// see iismap.hxx for the parental classes


//--------------------------------------------------------
class C11Mapping
    {
    public:
    #define NEW_OBJECT  0xFFFFFFFF
    C11Mapping() : 
          m_fEnabled(TRUE),
          m_pCert(NULL),
          m_cbCert(0),
          iMD(NEW_OBJECT)
        {;}
    ~C11Mapping()
        {
        if ( m_pCert )
            GlobalFree( m_pCert );
        }

    BOOL GetCertificate( PUCHAR* ppCert, DWORD* pcbCert );
    BOOL SetCertificate( PUCHAR pCert, DWORD cbCert );

    BOOL GetNTAccount( CString &szAccount );
    BOOL SetNTAccount( CString szAccount );

    BOOL GetNTPassword( CString &szAccount );
    BOOL SetNTPassword( CString szAccount );

    BOOL GetMapName( CString &szName );
    BOOL SetMapName( CString szName );

    BOOL GetMapEnabled( BOOL* pfEnabled );
    BOOL SetMapEnabled( BOOL fEnabled );

//  BOOL GetMapIndex( DWORD* pIndex );
//  BOOL SetMapIndex( DWORD index );

    // name of this mapping's name in the metabase. If it is not in the metabase
    // (its new), then value is NEW_OBJECT
    DWORD       iMD;

    protected:
    #define BUFF_SIZE   MAX_PATH
        CString m_szAccount;
        CString m_szPassword;
        CString m_szName;
        BOOL    m_fEnabled;
        PVOID   m_pCert;
        DWORD   m_cbCert;
    };

#endif  /* _wrapmaps_h__31598_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\certmap\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently


 
#ifndef   _stdafx_h__2_12_98_
#define   _stdafx_h__2_12_98_

#define VC_EXTRALEAN        // Exclude rarely-used stuff from Windows headers
//
//
//Its never a good idea to hack the following since this will cause problems
//with MFC.
//
//Mail note on the subject:
// We orginally thought that we needed to build with WIN32_IE=0x0400 
// to pick up the new WIZARD97 stuff. MFC42.DLL was built with WIN32_IE=0x0300. 
// Unfortunately, the PROPSHEETPAGE and PROPSHEETHEADER structures (defined in 
// public\sdk\inc\prsht.h) grow between versions 0x0300 and 0x0400. This causes 
// MFC classes to grow, so there is a disconnect between classes in the IIS 
// components and within MFC, and everything quickly goes crazy. So crazy that
// even though some parts of IIS can use it we can not since GetPage(int i)
// from MFC's CPropertySheet will AV.
///////////////////////////
//#define HACK_WIN32IE
///////////////////////////

#ifdef HACK_WIN32IE
// we need to define _WIN32_IE for the new Wizard97 styles
#ifdef _WIN32_IE
# if (_WIN32_IE < 0x0400)
//#pragma warning("we are redefining _WIN32_IE  0x0500 because NT5 headers dont do it")
#  undef  _WIN32_IE
#  define _WIN32_IE  0x0500
# endif
#else
# define _WIN32_IE  0x0500
#endif
#endif /* HACK_WIN32IE */




//#ifndef _WIN32_WINNT
//  #define _WIN32_WINNT 0x0400
//#endif
#include <afxctl.h>         // MFC support for OLE Controls
#include <afxcmn.h>


// Delete the two includes below if you do not wish to use the MFC
//  database classes
#ifndef _UNICODE
#include <afxdb.h>          // MFC database classes
#include <afxdao.h>         // MFC DAO database classes
#endif //_UNICODE

//#include "Global.h"

#define NOT_COMPILING_COMPROP       // we dont want comprop to use
                    // comprop/resource.h -- use our
                    // certmap/resource.h file

//  ../comprop/comprop.h  defines COMDLL and sets it as the following, we want
//  to use '_COMSTATIC' in certmap.   So we define it here.  We included
//  a copy of how comprop will define COMDLL as FYI.
//  We define _MDKEYS_H_ so that ./comprop/comprop.h can be included w/o
//  trouble.  It defines many Unicode string assignments that do not compile
//  in ANSI mode.
//-----------------------------------------------------------------
#ifdef  COMDLL
# undef COMDLL
# define _COMSTATIC
#endif

#ifndef _MDKEYS_H_
#define _MDKEYS_H_
#endif

// #ifdef _COMEXPORT
//     #define COMDLL __declspec(dllexport)
// #elif defined(_COMIMPORT)
//     #define COMDLL __declspec(dllimport)
// #elif defined(_COMSTATIC)
//     #define COMDLL
// #else
//     #error "Must define either _COMEXPORT, _COMIMPORT or _COMSTATIC"
// #endif // _COMEXPORT




//list templates and such
#include <afxtempl.h>
#include <atlconv.h>



#include "resource.h"

/*
#include "Debug.h"
#include "Util.h"
*/



#endif  /* _stdafx_h__2_12_98_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\certmap\wrpmbwrp.cpp ===
/*++

Module Name:

    WrpMBWrp.cpp

Abstract:

    A wrapper for my metabase wrapper wrapper. Why? All it does is provide
        AFX support for CString classes. Everything else is passed on to the parent

Author:

   Boyd Multerer bmulterer@accessone.com

--*/

//C:\nt\public\sdk\lib\i386

#include "stdafx.h"
#include <iiscnfgp.h>
#include "wrapmb.h"

#include "WrpMBWrp.h"


//-----------------------------------------------------------------------------
BOOL CAFX_MetaWrapper::GetString( LPCTSTR pszPath, DWORD dwPropID, DWORD dwUserType,
                                                                 CString &sz, DWORD dwFlags )
        {
        PCHAR           pData = NULL;
        DWORD           cbData = 0;
        DWORD           err = 0;
        BOOL            f;

        // first, get the size of the data that we are looking for - it will fail because of the NULL,
        // but, the size we need should be in cbData;
        f = GetData( pszPath, dwPropID, dwUserType, STRING_METADATA, NULL, &cbData );

        // check the error - it should be some sort of memory error
        err = GetLastError();

        // it is ok that the GetData failed, but the reason had better be ERROR_INSUFFICIENT_BUFFER
        // otherwise, it is something we can't handle
        if ( err != ERROR_INSUFFICIENT_BUFFER )
                return FALSE;

        // allocate the buffer
        pData = (PCHAR)GlobalAlloc( GPTR, cbData + 1 );
        if ( !pData ) return FALSE;

        // zero out the buffer
        ZeroMemory( pData, cbData + 1 );

        // first, get the size of the data that we are looking for
        f = GetData( pszPath, dwPropID, dwUserType, STRING_METADATA, pData, &cbData );

        // if that getting failed, we need to cleanup
        if ( !f )
                {
                GlobalFree( pData );
                return FALSE;
                }

        // set the answer
        sz = pData;

        // clean up
        GlobalFree( pData );

        // return the allocated buffer
        return TRUE;
        }

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\certmap\wwzone.h ===
// WildWizOne.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CWildWizOne dialog

class CWildWizOne : public CPropertyPage
{
    DECLARE_DYNCREATE(CWildWizOne)

// Construction
public:
    CWildWizOne();
    ~CWildWizOne();

    // to make the buttons behave right
    BOOL            m_fIsWizard;
    CPropertySheet* m_pPropSheet;

    // the only public member
    CCertMapRule*   m_pRule;
    IMSAdminBase*   m_pMB;

    // base path to the metabase
    CString m_szMBPath;

    virtual BOOL OnApply();
    virtual BOOL OnInitDialog();

// Dialog Data
    //{{AFX_DATA(CWildWizOne)
    enum { IDD = IDD_WILDWIZ_1 };
    CString m_sz_description;
    BOOL    m_bool_enable;
    //}}AFX_DATA


// Overrides
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CWildWizOne)
    public:
    virtual BOOL OnSetActive();
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:
    // Generated message map functions
    //{{AFX_MSG(CWildWizOne)
    afx_msg void OnChangeDescription();
    afx_msg void OnEnableRule();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

    void DoHelp();

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\certmap\wwzthree.cpp ===
// WWzThree.cpp : implementation file
//

#include "stdafx.h"
#include <iadmw.h>
#include "certmap.h"

#include "ListRow.h"
#include "ChkLstCt.h"
extern "C"
    {
    #include <wincrypt.h>
    #include <sslsp.h>
    }
#include "Iismap.hxx"
#include "Iiscmr.hxx"

#include "brwsdlg.h"
#include "EdWldRul.h"
#include "EdtRulEl.h"

#include "WWzThree.h"

#include "cnfrmpsd.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define ACCESS_DENY         0
#define ACCESS_ACCEPT       1

/////////////////////////////////////////////////////////////////////////////
// CWildWizThree property page

IMPLEMENT_DYNCREATE(CWildWizThree, CPropertyPage)

CWildWizThree::CWildWizThree() : CPropertyPage(CWildWizThree::IDD)
{
    //{{AFX_DATA_INIT(CWildWizThree)
    m_int_DenyAccess = -1;
    m_sz_accountname = _T("");
    m_sz_password = _T("");
    //}}AFX_DATA_INIT
    m_bPassTyped = FALSE;
}

CWildWizThree::~CWildWizThree()
{
}

void CWildWizThree::DoDataExchange(CDataExchange* pDX)
{
    CPropertyPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CWildWizThree)
    DDX_Control(pDX, IDC_STATIC_PASSWORD, m_static_password);
    DDX_Control(pDX, IDC_STATIC_ACCOUNT, m_static_account);
    DDX_Control(pDX, IDC_BROWSE, m_btn_browse);
    DDX_Control(pDX, IDC_PASSWORD, m_cedit_password);
    DDX_Control(pDX, IDC_NTACCOUNT, m_cedit_accountname);
    DDX_Radio(pDX, IDC_REFUSE_LOGON, m_int_DenyAccess);
    DDX_Text(pDX, IDC_NTACCOUNT, m_sz_accountname);
    DDX_Text(pDX, IDC_PASSWORD, m_sz_password);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CWildWizThree, CPropertyPage)
    //{{AFX_MSG_MAP(CWildWizThree)
    ON_BN_CLICKED(IDC_BROWSE, OnBrowse)
    ON_EN_CHANGE(IDC_NTACCOUNT, OnChangeNtaccount)
    ON_EN_CHANGE(IDC_PASSWORD, OnChangePassword)
    ON_BN_CLICKED(IDC_ACCEPT_LOGON, OnAcceptLogon)
    ON_BN_CLICKED(IDC_REFUSE_LOGON, OnRefuseLogon)
    //}}AFX_MSG_MAP
    ON_COMMAND(ID_HELP_FINDER,  DoHelp)
    ON_COMMAND(ID_HELP,         DoHelp)
    ON_COMMAND(ID_CONTEXT_HELP, DoHelp)
    ON_COMMAND(ID_DEFAULT_HELP, DoHelp)
END_MESSAGE_MAP()

//---------------------------------------------------------------------------
void CWildWizThree::DoHelp()
    {
    WinHelp( HIDD_CERTMAP_ADV_RUL_MAPPING );
    }


//---------------------------------------------------------------------------
void CWildWizThree::EnableButtons()
    {
    UpdateData( TRUE );
    
    // if the access is set to refuse access, then disable the account
    // and password stuff.
    if ( m_int_DenyAccess == 0 )
        {
        // deny access
        m_static_password.EnableWindow( FALSE );
        m_static_account.EnableWindow( FALSE );
        m_btn_browse.EnableWindow( FALSE );
        m_cedit_password.EnableWindow( FALSE );
        m_cedit_accountname.EnableWindow( FALSE );
        }
    else
        {
        // give access
        m_static_password.EnableWindow( TRUE );
        m_static_account.EnableWindow( TRUE );
        m_btn_browse.EnableWindow( TRUE );
        m_cedit_password.EnableWindow( TRUE );
        m_cedit_accountname.EnableWindow( TRUE );
        }
    }

/////////////////////////////////////////////////////////////////////////////
// CWildWizThree message handlers

//---------------------------------------------------------------------------
BOOL CWildWizThree::OnApply()
    {
    //
    // UNICODE/ANSI Conversion -- RonaldM
    //
    USES_CONVERSION;

    // update the data
    UpdateData( TRUE );

    // only do the account checks if the option is set to accept
    if ( m_int_DenyAccess == ACCESS_ACCEPT )
        {
        // see if the account name is empty
        if ( m_sz_accountname.IsEmpty() )
            {
            AfxMessageBox( IDS_WANTACCOUNT );
            m_cedit_accountname.SetFocus();
            m_cedit_accountname.SetSel(0, -1);
            return FALSE;
            }
        }

    // confirm the password
    if ( m_bPassTyped && (m_int_DenyAccess == ACCESS_ACCEPT) )
        {
        CConfirmPassDlg dlgPass;
        dlgPass.m_szOrigPass = m_sz_password;
        if ( dlgPass.DoModal() != IDOK )
            {
            m_cedit_password.SetFocus();
            m_cedit_password.SetSel(0, -1);
            return FALSE;
            }
        }
    else
        {
        // restore the original password instead of the
        // standard ****** string
        m_sz_password = m_szOrigPass;
        UpdateData( FALSE );
        }

    // store the deny access radio buttons
    m_pRule->SetRuleDenyAccess( m_int_DenyAccess == ACCESS_DENY );

    // we have to set the account name into place here
    m_pRule->SetRuleAccount( T2A((LPTSTR)(LPCTSTR)m_sz_accountname) );

    // store the password
    m_pRule->SetRulePassword( T2A((LPTSTR)(LPCTSTR)m_sz_password) );

    // reset the password flags
    m_szOrigPass = m_sz_password;
    m_bPassTyped = FALSE;

    SetModified( FALSE );
    return TRUE;
    }

//---------------------------------------------------------------------------
BOOL CWildWizThree::OnInitDialog()
    {
    // call the parental oninitdialog
    BOOL f = CPropertyPage::OnInitDialog();

    // set the easy default strings 
    m_sz_accountname = m_pRule->GetRuleAccount();   // managed by CNTBrowsingDialog from here on

    // set up the deny access radio buttons
    if ( m_pRule->GetRuleDenyAccess() )
        m_int_DenyAccess = ACCESS_DENY;
    else
        m_int_DenyAccess = ACCESS_ACCEPT;

    // initialize the password
    m_sz_password = m_pRule->GetRulePassword();
    m_szOrigPass = m_sz_password;
    if ( !m_sz_password.IsEmpty() )
        m_sz_password.LoadString( IDS_SHOWN_PASSWORD );

    // exchange the data
    UpdateData( FALSE );
    EnableButtons();

    // success
    return TRUE;
    }

//---------------------------------------------------------------------------
BOOL CWildWizThree::OnSetActive() 
    {
    // if this is a wizard, gray out the back button
    if ( m_fIsWizard )
        m_pPropSheet->SetWizardButtons( PSWIZB_BACK | PSWIZB_FINISH );
    return CPropertyPage::OnSetActive();
    }

//---------------------------------------------------------------------------
BOOL CWildWizThree::OnWizardFinish()
    {
    for ( int i = 0; i < m_pPropSheet->GetPageCount( ); i++ )
        {
        if ( !m_pPropSheet->GetPage(i)->OnApply() )
            return FALSE;
        }
    return TRUE;
    }

//---------------------------------------------------------------------------
// run the user browser
void CWildWizThree::OnBrowse() 
{
   LPTSTR buf = m_sz_accountname.GetBuffer(MAX_PATH);
   GetIUsrAccount(NULL, this, buf, MAX_PATH);
   m_sz_accountname.ReleaseBuffer(-1);
   SetModified();
   UpdateData(FALSE);
}

//---------------------------------------------------------------------------
void CWildWizThree::OnChangeNtaccount() 
    {
    // we can now apply
    SetModified();
    }

//---------------------------------------------------------------------------
void CWildWizThree::OnChangePassword() 
    {
    m_bPassTyped = TRUE;
    // we can now apply
    SetModified();
    }

//---------------------------------------------------------------------------
void CWildWizThree::OnAcceptLogon() 
    {
    EnableButtons();
    // we can now apply
    SetModified();
    }

//---------------------------------------------------------------------------
void CWildWizThree::OnRefuseLogon() 
    {
    EnableButtons();
    // we can now apply
    SetModified();
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\certmap\wrpmbwrp.h ===
//-------------------------------
class CAFX_MetaWrapper : public CWrapMetaBase
    {
    public:
    BOOL GetString( LPCTSTR, DWORD dwPropID, DWORD dwUserType, CString &sz, DWORD dwFlags = METADATA_INHERIT );
    };
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\certmap\wwzone.cpp ===
// WildWizOne.cpp : implementation file
//

#include "stdafx.h"
#include <iadmw.h>
#include "certmap.h"

#include "ListRow.h"
#include "ChkLstCt.h"
extern "C"
    {
    #include <wincrypt.h>
    #include <sslsp.h>
    }
#include "Iismap.hxx"
#include "Iiscmr.hxx"

#include "brwsdlg.h"
#include "EdWldRul.h"
#include "EdtRulEl.h"

#include "WWzOne.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


/////////////////////////////////////////////////////////////////////////////
// CWildWizOne property page

IMPLEMENT_DYNCREATE(CWildWizOne, CPropertyPage)

CWildWizOne::CWildWizOne() : CPropertyPage(CWildWizOne::IDD)
{
    //{{AFX_DATA_INIT(CWildWizOne)
    m_sz_description = _T("");
    m_bool_enable = FALSE;
    //}}AFX_DATA_INIT
}

CWildWizOne::~CWildWizOne()
{
}

void CWildWizOne::DoDataExchange(CDataExchange* pDX)
{
    CPropertyPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CWildWizOne)
    DDX_Text(pDX, IDC_DESCRIPTION, m_sz_description);
    DDV_MaxChars(pDX, m_sz_description, 120);
    DDX_Check(pDX, IDC_ENABLE_RULE, m_bool_enable);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CWildWizOne, CPropertyPage)
    //{{AFX_MSG_MAP(CWildWizOne)
    ON_EN_CHANGE(IDC_DESCRIPTION, OnChangeDescription)
    ON_BN_CLICKED(IDC_ENABLE_RULE, OnEnableRule)
    //}}AFX_MSG_MAP
    ON_COMMAND(ID_HELP_FINDER,  DoHelp)
    ON_COMMAND(ID_HELP,         DoHelp)
    ON_COMMAND(ID_CONTEXT_HELP, DoHelp)
    ON_COMMAND(ID_DEFAULT_HELP, DoHelp)
END_MESSAGE_MAP()

//---------------------------------------------------------------------------
void CWildWizOne::DoHelp()
    {
    WinHelp( HIDD_CERTMAP_ADV_RUL_GENERAL );
    }

/////////////////////////////////////////////////////////////////////////////
// CWildWizOne message handlers

//---------------------------------------------------------------------------
BOOL CWildWizOne::OnInitDialog()
    {
    // call the parental oninitdialog
    BOOL f = CPropertyPage::OnInitDialog();

    // set the easy default strings 
    m_sz_description = m_pRule->GetRuleName();
    m_bool_enable = m_pRule->GetRuleEnabled();

    // exchange the data
    UpdateData( FALSE );

    // return the answer
    return f;
    }

//---------------------------------------------------------------------------
BOOL CWildWizOne::OnApply()
    {
    CERT_FIELD_ID   id;
    CString         szSub, sz;
    LPBYTE          pbBin;
    DWORD           cbBin;
    UINT            cItems;
    UINT            iItem;

    USES_CONVERSION;

    // update the data
    UpdateData( TRUE );

    // set the easy data

    m_pRule->SetRuleName( T2A((LPTSTR)(LPCTSTR)m_sz_description) );
    m_pRule->SetRuleEnabled( m_bool_enable );

    // it is valid
    SetModified( FALSE );
    return TRUE;
    }

//---------------------------------------------------------------------------
BOOL CWildWizOne::OnSetActive() 
    {
    // if this is a wizard, gray out the back button
    if ( m_fIsWizard )
        m_pPropSheet->SetWizardButtons( PSWIZB_NEXT );
    return CPropertyPage::OnSetActive();
    }

//---------------------------------------------------------------------------
void CWildWizOne::OnChangeDescription() 
    {
    // we can now apply
    SetModified();
    }

//---------------------------------------------------------------------------
void CWildWizOne::OnEnableRule() 
    {
    // we can now apply
    SetModified();
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\certobj\certlog.h ===
#include "stdafx.h"


BOOL EventlogRegistryInstall(void);
void EventlogRegistryUnInstall(void);
void ReportIt(DWORD dwEventID, LPCTSTR szMetabasePath);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\certobj\certificat.cpp ===
// IISCertObj.cpp : Implementation of CIISCertObj
#include "stdafx.h"
#include "CertObj.h"
#include "common.h"
#include "IISCertObj.h"
//#ifdef FULL_OBJECT
   #include "base64.h"
//#endif
#include <wincrypt.h>
#include <cryptui.h>

HRESULT ShutdownSSL(CString& server_name);
HCERTSTORE OpenMyStore(IEnroll * pEnroll, HRESULT * phResult);
BOOL InstallHashToMetabase(CRYPT_HASH_BLOB * pHash,BSTR machine_name,HRESULT * phResult);
CERT_CONTEXT * GetInstalledCert(HRESULT * phResult, CString csKeyPath);
BOOL TrustIsCertificateSelfSigned(PCCERT_CONTEXT pContext,DWORD dwEncoding,  DWORD dwFlags);
BOOL AddChainToStore(HCERTSTORE hCertStore,PCCERT_CONTEXT pCertContext,DWORD cStores,HCERTSTORE * rghStores,BOOL fDontAddRootCert,CERT_TRUST_STATUS* pChainTrustStatus);
HRESULT UninstallCert(CString csInstanceName);
DWORD  CreateGoodPassword(BYTE *szPwd,DWORD dwLen);
LPTSTR CreatePassword(int iSize);

#define TEMP_PASSWORD_LENGTH 50

//#define DEBUG_FLAG

#ifdef DEBUG_FLAG
    inline void _cdecl DebugTrace(LPTSTR lpszFormat, ...)
    {
	    int nBuf;
	    TCHAR szBuffer[512];
	    va_list args;
	    va_start(args, lpszFormat);

	    nBuf = _vsntprintf(szBuffer, sizeof(szBuffer), lpszFormat, args);
	    ASSERT(nBuf < sizeof(szBuffer)); //Output truncated as it was > sizeof(szBuffer)

	    OutputDebugString(szBuffer);
	    va_end(args);
    }
#else
    inline void _cdecl DebugTrace(LPTSTR , ...){}
#endif

#define IISDebugOutput DebugTrace


/////////////////////////////////////////////////////////////////////////////
// CIISCertObj
STDMETHODIMP CIISCertObj::put_ServerName(BSTR newVal)
{
    m_ServerName = newVal;
    return S_OK;
}

STDMETHODIMP CIISCertObj::put_UserName(BSTR newVal)
{
    m_UserName = newVal;
    return S_OK;
}

STDMETHODIMP CIISCertObj::put_UserPassword(BSTR newVal)
{
    m_UserPassword = newVal;
	return S_OK;
}

STDMETHODIMP CIISCertObj::put_InstanceName(BSTR newVal)
{
    m_InstanceName = newVal;
	return S_OK;
}

#ifdef FULL_OBJECT
STDMETHODIMP CIISCertObj::put_Password(BSTR newVal)
{
    m_Password = newVal;
    return S_OK;
}

STDMETHODIMP CIISCertObj::put_CommonName(BSTR newVal)
{
    m_CommonName = newVal;
    return S_OK;
}

STDMETHODIMP CIISCertObj::put_FriendlyName(BSTR newVal)
{
    m_FriendlyName = newVal;
    return S_OK;
}

STDMETHODIMP CIISCertObj::put_Organization(BSTR newVal)
{
    m_Organization = newVal;
    return S_OK;
}

STDMETHODIMP CIISCertObj::put_OrganizationUnit(BSTR newVal)
{
    m_OrganizationUnit = newVal;
    return S_OK;
}

STDMETHODIMP CIISCertObj::put_Locality(BSTR newVal)
{
    m_Locality = newVal;
    return S_OK;
}

STDMETHODIMP CIISCertObj::put_State(BSTR newVal)
{
    m_State = newVal;
    return S_OK;
}

STDMETHODIMP CIISCertObj::put_Country(BSTR newVal)
{
    m_Country = newVal;
    return S_OK;
}

STDMETHODIMP CIISCertObj::put_CertAuthority(BSTR newVal)
{
    m_CertAuthority = newVal;
    return S_OK;
}

STDMETHODIMP CIISCertObj::put_CertTemplate(BSTR newVal)
{
    m_CertTemplate = newVal;
    return S_OK;
}

STDMETHODIMP CIISCertObj::put_KeySize(int newVal)
{
    m_KeySize = newVal;
    return S_OK;
}

STDMETHODIMP CIISCertObj::put_SGC_Cert(BOOL newVal)
{
    m_SGC_Cert = newVal;
    return S_OK;
}

STDMETHODIMP CIISCertObj::LoadSettings(BSTR ApplicationKey, BSTR SettingsKey)
{
    return S_OK;
}

STDMETHODIMP CIISCertObj::SaveSettings(BSTR ApplicationKey, BSTR SettingsKey)
{
    return S_OK;
}

STDMETHODIMP CIISCertObj::CreateRequest(BSTR FileName)
{
    CString dn;
    HRESULT hr;
    TCHAR usage[] = _T(szOID_PKIX_KP_SERVER_AUTH);
    CCryptBlobIMalloc req_blob;

    if (FAILED(hr = CreateDNString(dn)))
        return hr;
    ATLASSERT(dn.length() > 0);
    if (FAILED(hr = GetEnroll()->createPKCS10WStr(dn, (LPTSTR)usage, req_blob)))
	{
        return hr;
	}
	// BASE64 encode pkcs 10
	DWORD cch; 
	char * psz;
	if (	ERROR_SUCCESS != Base64EncodeA(req_blob.GetData(), req_blob.GetSize(), NULL, &cch)
		||	NULL == (psz = (char *)_alloca(cch+1))
		||	ERROR_SUCCESS != Base64EncodeA(req_blob.GetData(), req_blob.GetSize(), psz, &cch)
		) 
	{
      ATLASSERT(FALSE);
		return E_FAIL;
	}

	return S_OK;
}

STDMETHODIMP CIISCertObj::RequestCert(BSTR CertAuthority)
{
	// TODO: Add your implementation code here

	return S_OK;
}

STDMETHODIMP CIISCertObj::ProcessResponse(BSTR FileName)
{
	// TODO: Add your implementation code here

	return S_OK;
}
#endif

STDMETHODIMP CIISCertObj::IsInstalled(BSTR InstanceName, VARIANT_BOOL * retval)
{
    HRESULT hr = S_OK;

    // Check mandatory properties
    if (InstanceName == NULL || *InstanceName == 0 || retval == NULL)
    {
        return ERROR_INVALID_PARAMETER;
    }

    m_InstanceName = InstanceName;

    CString csServerName = m_ServerName;

    if (csServerName.IsEmpty())
    {
        hr = IsInstalledRemote(InstanceName, retval);
        goto IsInstalled_Exit;
    }

    // There is a servername specified...
    // check if it's the local machine that was specified!
    if (IsServerLocal(csServerName))
    {
        hr = IsInstalledRemote(InstanceName, retval);
        goto IsInstalled_Exit;
    }

    // this must be a remote machine
    {
        //ASSERT(GetObject(&hr) != NULL);
        IIISCertObj * pObj;

        if (NULL != (pObj = GetObject(&hr)))
        {
            hr = pObj->put_InstanceName(InstanceName);
            hr = pObj->IsInstalledRemote(InstanceName, retval);
        }
    }

IsInstalled_Exit:
    return hr;
}


STDMETHODIMP CIISCertObj::IsInstalledRemote(BSTR InstanceName,VARIANT_BOOL * retval)
{
    HRESULT hr = S_OK;
    CERT_CONTEXT * pCertContext = NULL;

    // Check mandatory properties
    if (InstanceName == NULL || *InstanceName == 0 || retval == NULL)
    {
        return ERROR_INVALID_PARAMETER;
    }

    pCertContext = GetInstalledCert(&hr,InstanceName);
    if (FAILED(hr) || NULL == pCertContext)
    {
        hr = S_OK;
        *retval = FALSE;
    }
    else
    {
        hr = S_OK;
        *retval = TRUE;
        CertFreeCertificateContext(pCertContext);
    }
    return hr;
}


HRESULT CIISCertObj::RemoveCertProxy(IIISCertObj * pObj,BSTR InstanceName, BOOL bPrivateKey)
{
    HRESULT hr = E_FAIL;
    if (pObj)
    {
        hr = pObj->RemoveCert(InstanceName,bPrivateKey);
    }
    return hr;
}


STDMETHODIMP CIISCertObj::RemoveCert(BSTR InstanceName, BOOL bPrivateKey)
{
    HRESULT hr = E_FAIL;
    PCCERT_CONTEXT pCertContext = NULL;

    DWORD	cbKpi = 0;
    PCRYPT_KEY_PROV_INFO pKpi = NULL ;
    HCRYPTPROV hCryptProv = NULL;

    do
    {
        // get the certificate from the server
        pCertContext = GetInstalledCert(&hr,InstanceName);
        if (NULL == pCertContext)
        {
            break;
        }

        if (!CertGetCertificateContextProperty(pCertContext, CERT_KEY_PROV_INFO_PROP_ID, NULL, &cbKpi)) 
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            break;
        }

        pKpi = ( PCRYPT_KEY_PROV_INFO ) malloc( cbKpi );
        if ( NULL != pKpi )	
        {
            if (!CertGetCertificateContextProperty(pCertContext, CERT_KEY_PROV_INFO_PROP_ID, (void *)pKpi, &cbKpi)) 
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
                break;
            }

            // Delete the key container
            if (!CryptAcquireContext(&hCryptProv,pKpi->pwszContainerName,pKpi->pwszProvName,pKpi->dwProvType,pKpi->dwFlags | CRYPT_DELETEKEYSET | CRYPT_MACHINE_KEYSET))
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
                break;
            }

            if (NULL != pKpi){free(pKpi);}

            if (!CertSetCertificateContextProperty(pCertContext, CERT_KEY_PROV_INFO_PROP_ID, 0, NULL))
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
                break;
            }
        }

        //    uninstall the certificate from the site, reset SSL flag
        //    if we are exporting the private key, remove the cert from the storage
        //    and delete private key
        UninstallCert(InstanceName);

        // remove ssl key from metabase
        CString str = InstanceName;
        ShutdownSSL(str);

        // delete the private key
        if (bPrivateKey)
        {
            PCCERT_CONTEXT pcDup = NULL ;
            pcDup = CertDuplicateCertificateContext(pCertContext);
            if (pcDup)
            {
                if (!CertDeleteCertificateFromStore(pcDup))
                {
                    hr = HRESULT_FROM_WIN32(GetLastError());
                    break;
                }
            }
            else
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
            }
        }

        hr = ERROR_SUCCESS;

    } while (FALSE);

    if (pCertContext) {CertFreeCertificateContext(pCertContext);}
    return hr;
}

STDMETHODIMP CIISCertObj::Export(BSTR FileName,BSTR Password,BOOL bPrivateKey,BOOL bCertChain,BOOL bRemoveCert)
{
    HRESULT hr = S_OK;
    DWORD  cbEncodedSize = 0;
    char * pszEncodedString = NULL;
    DWORD  blob_cbData = 0;
    BYTE * blob_pbData = NULL;
    BOOL   blob_freeme = FALSE;

    BSTR bstrInstanceName = SysAllocString(m_InstanceName);

    // Check mandatory properties
    if (  FileName == NULL || *FileName == 0
        || Password == NULL || *Password == 0
        || bstrInstanceName == NULL || *bstrInstanceName == 0)
    {
        return ERROR_INVALID_PARAMETER;
    }

    IIISCertObj * pObj = GetObject(&hr);
    if (FAILED(hr))
    {
        goto Export_Exit;
    }

    // Call function go get data from the remote/local iis store
    // and return it back as a blob.  the blob could be returned back as Base64 encoded
    // so check that flag
    hr = ExportToBlobProxy(pObj, bstrInstanceName, Password, bPrivateKey, bCertChain, &cbEncodedSize, &pszEncodedString);
    if (FAILED(hr))
    {
        goto Export_Exit;
    }

    // check if things are kool
    if (bRemoveCert)
    {
        hr = RemoveCertProxy(pObj,bstrInstanceName, bPrivateKey);
        if (FAILED(hr))
        {
            goto Export_Exit;
        }
    }

    if (SUCCEEDED(hr))
    {
        int err;

        // The data we got back was Base64 encoded to remove nulls.
        // we need to decode it back to it's original format.
        if( (err = Base64DecodeA(pszEncodedString,cbEncodedSize,NULL,&blob_cbData)) != ERROR_SUCCESS ||
            (blob_pbData = (BYTE *) malloc(blob_cbData)) == NULL ||
            (err = Base64DecodeA(pszEncodedString,cbEncodedSize,blob_pbData,&blob_cbData)) != ERROR_SUCCESS ) 
        {
            SetLastError(err);
            hr = HRESULT_FROM_WIN32(err);
            return hr;
        }
        blob_freeme = TRUE;

        HANDLE hFile = CreateFile(FileName, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
        if (INVALID_HANDLE_VALUE == hFile)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            return hr;
        }

        DWORD written = 0;
        if (!WriteFile(hFile, blob_pbData, blob_cbData, &written, NULL))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }
        else
        {
            hr = S_OK;
        }
        CloseHandle(hFile);

        // Erase the memory that the private key used to be in!!!
        ZeroMemory(pszEncodedString, sizeof(cbEncodedSize));
        ZeroMemory(blob_pbData, sizeof(blob_cbData));
    }

Export_Exit:
    if (pObj != NULL)
    {
        if (pObj != this)
        {
            pObj->Release();pObj=NULL;
        }
    }

    if (blob_freeme){if (blob_pbData != NULL){free(blob_pbData);blob_pbData=NULL;}}
    if (pszEncodedString != NULL){CoTaskMemFree(pszEncodedString);pszEncodedString=NULL;}
    return hr;
}

//
// Proxy to the real call ExportToBlob()
// this function figures out how much space to allocate, and then calls ExportToBlob().
//
// if succeeded and they get the blob back,
// and the caller must call CoTaskMemFree()
//
HRESULT ExportToBlobProxy(IIISCertObj * pObj,BSTR InstanceName,BSTR Password,BOOL bPrivateKey,BOOL bCertChain,DWORD * pcbSize,char ** pBlobBinary)
{
    HRESULT hr = E_FAIL;
    DWORD  cbEncodedSize = 0;
    char * pszEncodedString = NULL;
    * pBlobBinary = _T('\0');

    // call the remote function that will run on the remote/local machine
    // and grab it's certificate from iis and send it back to us
    hr = pObj->ExportToBlob(InstanceName, Password, bPrivateKey, bCertChain, &cbEncodedSize, (char **) &pszEncodedString);
    if (ERROR_SUCCESS == hr)
    {
        // otherwise hey, we've got our data!
        // copy it back
        *pcbSize = cbEncodedSize;
        *pBlobBinary = pszEncodedString;
        hr = S_OK;
    }

    return hr;
}


STDMETHODIMP CIISCertObj::ExportToBlob(BSTR InstanceName,BSTR Password,BOOL bPrivateKey,BOOL bCertChain,DWORD *cbBufferSize,char **pbBuffer)
{
    HRESULT hr = E_FAIL;
    PCCERT_CONTEXT pCertContext = NULL;
    BOOL bStatus = FALSE;
    HCERTSTORE hStore = NULL;
    DWORD dwOpenFlags = CERT_STORE_READONLY_FLAG | CERT_STORE_ENUM_ARCHIVED_FLAG;
    CRYPT_DATA_BLOB DataBlob;
    ZeroMemory(&DataBlob, sizeof(CRYPT_DATA_BLOB));

    char *pszB64Out = NULL;
    DWORD pcchB64Out = 0;
    DWORD  err;

    //
    // get the certificate from the server
    //
    pCertContext = GetInstalledCert(&hr,InstanceName);
    if (NULL == pCertContext)
    {
        *cbBufferSize = 0;
        pbBuffer = NULL;
        goto ExportToBlob_Exit;
    }

    //
    // Export cert
    //
    // Open a temporary store to stick the cert in.
    hStore = CertOpenStore(CERT_STORE_PROV_MEMORY,X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,0,dwOpenFlags,NULL);
    if(NULL == hStore)
    {
        *cbBufferSize = 0;
        pbBuffer = NULL;
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto ExportToBlob_Exit;
    }

    //
    // get all the certs in the chain if we need to
    //
    if (bCertChain)
    {
        AddChainToStore(hStore, pCertContext, 0, 0, FALSE, NULL);
    }

    if(!CertAddCertificateContextToStore(hStore,pCertContext,CERT_STORE_ADD_REPLACE_EXISTING,NULL))
    {
        *cbBufferSize = 0;
        pbBuffer = NULL;
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto ExportToBlob_Exit;
    }

    // free cert context since we no longer need to hold it
    if (pCertContext) 
    {
        CertFreeCertificateContext(pCertContext);pCertContext=NULL;
    }

    DataBlob.cbData = 0;
    DataBlob.pbData = NULL;
    if (!PFXExportCertStoreEx(hStore,&DataBlob,Password,NULL,bPrivateKey ? EXPORT_PRIVATE_KEYS : 0))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto ExportToBlob_Exit;
    }
    if(DataBlob.cbData <= 0)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto ExportToBlob_Exit;
    }

    if(NULL == (DataBlob.pbData = (PBYTE) ::CoTaskMemAlloc(DataBlob.cbData)))
    {
        hr = E_OUTOFMEMORY;
        goto ExportToBlob_Exit;
    }

    //
    // at this point they have allocated enough memory
    // let's go and get the cert and put it into DataBlob
    //
    if(!PFXExportCertStoreEx(hStore,&DataBlob,Password,NULL,bPrivateKey ? EXPORT_PRIVATE_KEYS : 0))
    {
        if (DataBlob.pbData){CoTaskMemFree(DataBlob.pbData);DataBlob.pbData = NULL;}
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto ExportToBlob_Exit;
    }

    // Encode it so that it can be passed back as a string (there are no Nulls in it)
    err = Base64EncodeA(DataBlob.pbData,DataBlob.cbData,NULL,&pcchB64Out);
    if (err != ERROR_SUCCESS)
    {
        hr = E_FAIL;
        goto ExportToBlob_Exit;
    }

    // allocate some space and then try it.
    pcchB64Out = pcchB64Out * sizeof(char);
    pszB64Out = (char *) ::CoTaskMemAlloc(pcchB64Out);
    if (NULL == pszB64Out)
    {
        hr = HRESULT_FROM_WIN32(E_OUTOFMEMORY);
        goto ExportToBlob_Exit;
    }

    err = Base64EncodeA(DataBlob.pbData,DataBlob.cbData,pszB64Out,&pcchB64Out);
    if (err != ERROR_SUCCESS)
    {
        hr = E_FAIL;
        goto ExportToBlob_Exit;
    }

    // copy the new memory to pass back
    *cbBufferSize = pcchB64Out;

    *pbBuffer = (char *)::CoTaskMemAlloc(pcchB64Out);
    if (*pbBuffer == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto ExportToBlob_Exit;
    }
    //strcpy(*pbBuffer,pszB64Out);
    memcpy(*pbBuffer,pszB64Out,pcchB64Out);


    hr = ERROR_SUCCESS;

ExportToBlob_Exit:
    if (NULL != pszB64Out){CoTaskMemFree(pszB64Out);pszB64Out = NULL;}
    if (NULL != DataBlob.pbData){::CoTaskMemFree(DataBlob.pbData);DataBlob.pbData = NULL;}
    if (NULL != hStore){CertCloseStore(hStore, 0);hStore=NULL;}
    if (NULL != pCertContext) {CertFreeCertificateContext(pCertContext);pCertContext=NULL;}
    return hr;
}

STDMETHODIMP CIISCertObj::Import(BSTR FileName, BSTR Password)
{
    HRESULT hr = S_OK;
    BYTE * pbData = NULL;
    DWORD actual = 0, cbData = 0;
    BSTR bstrInstanceName = SysAllocString(m_InstanceName);

    // Check mandatory properties
    if (  FileName == NULL || *FileName == 0
        || Password == NULL || *Password == 0
        || bstrInstanceName == NULL || *bstrInstanceName == 0)
    {
        return ERROR_INVALID_PARAMETER;
    }

    HANDLE hFile = CreateFile(FileName, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    if (hFile == INVALID_HANDLE_VALUE)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        hFile = NULL;
        goto Import_Exit;
    }

    if (-1 == (cbData = ::GetFileSize(hFile, NULL)))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Import_Exit;
    }

    if (NULL == (pbData = (BYTE *)::CoTaskMemAlloc(cbData)))
    {
        hr = E_OUTOFMEMORY;
        goto Import_Exit;
    }
    if (ReadFile(hFile, pbData, cbData, &actual, NULL))
    {
        IIISCertObj * pObj = GetObject(&hr);
        if (SUCCEEDED(hr))
        {
            hr = ImportFromBlobProxy(pObj, bstrInstanceName, Password, actual, pbData);
        }
    }
    else
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Import_Exit;
    }

Import_Exit:
    if (pbData != NULL){::CoTaskMemFree(pbData);}
    if (hFile != NULL){CloseHandle(hFile);}
    return hr;
}

HRESULT ImportFromBlobProxy(IIISCertObj * pObj,BSTR InstanceName,BSTR Password,DWORD actual,BYTE *pData)
{
    HRESULT hr = E_FAIL;
    char *pszB64Out = NULL;
    DWORD pcchB64Out = 0;

    // base64 encode the data for transfer to the remote machine
    DWORD  err;
    pcchB64Out = 0;

    // Encode it so that it can be passed back as a string (there are no Nulls in it)
    err = Base64EncodeA(pData,actual,NULL,&pcchB64Out);
    if (err != ERROR_SUCCESS)
    {
        hr = E_FAIL;
        goto ImportFromBlobProxy_Exit;
    }

    // allocate some space and then try it.
    pcchB64Out = pcchB64Out * sizeof(char);
    pszB64Out = (char *) ::CoTaskMemAlloc(pcchB64Out);
    if (NULL == pszB64Out)
    {
        hr = HRESULT_FROM_WIN32(E_OUTOFMEMORY);
        goto ImportFromBlobProxy_Exit;
    }

    err = Base64EncodeA(pData,actual,pszB64Out,&pcchB64Out);
    if (err != ERROR_SUCCESS)
    {
        hr = E_FAIL;
        goto ImportFromBlobProxy_Exit;
    }

    // the data to send are now in these variables
    // pcchB64Out
    // pszB64Out

    hr = pObj->ImportFromBlob(InstanceName, Password, pcchB64Out, pszB64Out);
    if (SUCCEEDED(hr))
    {
        // otherwise hey, The data was imported!
        hr = S_OK;
    }

ImportFromBlobProxy_Exit:
    if (NULL != pszB64Out){CoTaskMemFree(pszB64Out);}
    return hr;
}

HRESULT CIISCertObj::ImportFromBlob(BSTR InstanceName,BSTR Password,DWORD count,char *pData)
{
    HRESULT hr = S_OK;
    CRYPT_DATA_BLOB blob;
    ZeroMemory(&blob, sizeof(CRYPT_DATA_BLOB));
    LPTSTR pPass = Password;
    BOOL   blob_freeme = FALSE;
    int err;

    // The data we got back was Base64 encoded to remove nulls.
    // we need to decode it back to it's original format.
    if( (err = Base64DecodeA(pData,count,NULL,&blob.cbData)) != ERROR_SUCCESS ||
        (blob.pbData = (BYTE *) malloc(blob.cbData)) == NULL ||
        (err = Base64DecodeA(pData,count,blob.pbData,&blob.cbData)) != ERROR_SUCCESS ) 
    {
        SetLastError(err);
        hr = HRESULT_FROM_WIN32(err);
        return hr;
    }
    blob_freeme = TRUE;

    if (!PFXVerifyPassword(&blob, pPass, 0))
    {
        // Try empty password
        if (pPass == NULL)
        {
            if (!PFXVerifyPassword(&blob, pPass = L'\0', 0))
            {
                hr = ERROR_INVALID_PARAMETER;
            }
        }
        else
        {
            hr = ERROR_INVALID_PARAMETER;
        }
    }
    if (SUCCEEDED(hr))
    {

    HCERTSTORE hStore = PFXImportCertStore(&blob, pPass, CRYPT_MACHINE_KEYSET|CRYPT_EXPORTABLE);
    if (hStore != NULL)
    {
        //add the certificate with private key to my store; and the rest
        //to the ca store
        PCCERT_CONTEXT	pCertContext = NULL;
        PCCERT_CONTEXT	pCertPre = NULL;
        while (  SUCCEEDED(hr)
        && NULL != (pCertContext = CertEnumCertificatesInStore(hStore, pCertPre))
        )
        {
            //check if the certificate has the property on it
            //make sure the private key matches the certificate
            //search for both machine key and user keys
            DWORD dwData = 0;
            if (CertGetCertificateContextProperty(pCertContext,CERT_KEY_PROV_INFO_PROP_ID, NULL, &dwData) &&  CryptFindCertificateKeyProvInfo(pCertContext, 0, NULL))
            {
                // This certificate should go to the My store
                HCERTSTORE hDestStore = CertOpenStore(CERT_STORE_PROV_SYSTEM,PKCS_7_ASN_ENCODING | X509_ASN_ENCODING,NULL,CERT_SYSTEM_STORE_LOCAL_MACHINE,L"MY");
                if (hDestStore != NULL)
                {
                    // Put it to store
                    if (CertAddCertificateContextToStore(hDestStore,pCertContext,CERT_STORE_ADD_REPLACE_EXISTING,NULL))
                    {
                        // Install to metabase
                        CRYPT_HASH_BLOB hash;
                        if (  CertGetCertificateContextProperty(pCertContext,CERT_SHA1_HASH_PROP_ID, NULL, &hash.cbData)
                            && NULL != (hash.pbData = (BYTE *)_alloca(hash.cbData))
                            && CertGetCertificateContextProperty(pCertContext, CERT_SHA1_HASH_PROP_ID, hash.pbData, &hash.cbData))
                        {
                            InstallHashToMetabase(&hash, InstanceName, &hr);
                        }
                        else
                        {
                            hr = HRESULT_FROM_WIN32(GetLastError());
                        }
                    }
                    else
                    {
                        hr = HRESULT_FROM_WIN32(GetLastError());
                    }
                    CertCloseStore(hDestStore, 0);
                }
                else
                {
                    hr = HRESULT_FROM_WIN32(GetLastError());
                }
            }  // my store certificate
            //see if the certificate is self-signed.
            //if it is selfsigned, goes to the root store
            else if (TrustIsCertificateSelfSigned(pCertContext,pCertContext->dwCertEncodingType, 0))
            {
                //Put it to the root store
                HCERTSTORE hDestStore=CertOpenStore(CERT_STORE_PROV_SYSTEM,PKCS_7_ASN_ENCODING | X509_ASN_ENCODING,NULL,CERT_SYSTEM_STORE_LOCAL_MACHINE,L"ROOT");
                if (hDestStore != NULL)
                {
                    // Put it to store
                    if (!CertAddCertificateContextToStore(hDestStore,pCertContext,CERT_STORE_ADD_REPLACE_EXISTING,NULL))
                    {
                        hr = HRESULT_FROM_WIN32(GetLastError());
                    }
                    CertCloseStore(hDestStore, 0);
                }
                else
                {
                    hr = HRESULT_FROM_WIN32(GetLastError());
                }
            }
            else
            {
                //Put it to the CA store
                HCERTSTORE hDestStore=CertOpenStore(CERT_STORE_PROV_SYSTEM,PKCS_7_ASN_ENCODING | X509_ASN_ENCODING,NULL,CERT_SYSTEM_STORE_LOCAL_MACHINE,L"CA");
                if (hDestStore != NULL)
                {
                    // Put it to store
                    if (!CertAddCertificateContextToStore(hDestStore,pCertContext,CERT_STORE_ADD_REPLACE_EXISTING,NULL))
                    {
                        hr = HRESULT_FROM_WIN32(GetLastError());
                    }
                    CertCloseStore(hDestStore, 0);
                }
                else
                {
                    hr = HRESULT_FROM_WIN32(GetLastError());
                }
            }
            pCertPre = pCertContext;
        } //while

        CertCloseStore(hStore, 0);
    }
    else
    hr = HRESULT_FROM_WIN32(GetLastError());
    }

//ImportFromBlob_Exit:
    if (blob_freeme){if (blob.pbData != NULL){free(blob.pbData);blob.pbData=NULL;}}
    return hr;
}

//////////////////////////////////////////////////////////////////
#ifdef FULL_OBJECT

HRESULT CIISCertObj::Init()
{
    HRESULT hr;
    if (!m_bInitDone)
    {
        do 
        {
            // setup IEnroll object properly
            DWORD dwFlags;
            if (FAILED(hr = GetEnroll()->get_MyStoreFlags(&dwFlags)))
            {
                break;
            }
            dwFlags &= ~CERT_SYSTEM_STORE_LOCATION_MASK;
            dwFlags |= CERT_SYSTEM_STORE_LOCAL_MACHINE;

            // following call will change Request store flags also
            if (FAILED(hr = GetEnroll()->put_MyStoreFlags(dwFlags)))
            {
                break;
            }
            if (FAILED(hr = GetEnroll()->get_GenKeyFlags(&dwFlags)))
            {
                break;
            }
            dwFlags |= CRYPT_EXPORTABLE;

            if (FAILED(hr = GetEnroll()->put_GenKeyFlags(dwFlags))
                || FAILED(hr = GetEnroll()->put_KeySpec(AT_KEYEXCHANGE))
                || FAILED(hr = GetEnroll()->put_ProviderType(PROV_RSA_SCHANNEL))
                || FAILED(hr = GetEnroll()->put_DeleteRequestCert(TRUE)))
            {
                break;
            }
        } while (FALSE);
        m_bInitDone = SUCCEEDED(hr);
    }
    return hr;
}

IEnroll * CIISCertObj::GetEnroll()
{
    if (m_pEnroll == NULL)
    {
        HRESULT hr = CoCreateInstance(CLSID_CEnroll,NULL,CLSCTX_INPROC_SERVER,IID_IEnroll,(void **)&m_pEnroll);
    }
    return m_pEnroll;
}

HCERTSTORE OpenMyStore(IEnroll * pEnroll, HRESULT * phResult)
{
    ASSERT(NULL != phResult);
    HCERTSTORE hStore = NULL;
    hStore = CertOpenStore(CERT_STORE_PROV_SYSTEM,PKCS_7_ASN_ENCODING | X509_ASN_ENCODING,NULL,CERT_SYSTEM_STORE_LOCAL_MACHINE,L"MY");
    if (hStore == NULL)
    {
        *phResult = HRESULT_FROM_WIN32(GetLastError());
    }
    return hStore;
}
#endif

HRESULT ShutdownSSL(CString& server_name)
{
    CComAuthInfo auth;
    CString str = server_name;
    str += _T("/root");
    CMetaKey key(&auth, str,
    METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE);
    DWORD dwSslAccess;

    if (!key.Succeeded())
    {
        return key.QueryResult();
    }

    if (SUCCEEDED(key.QueryValue(MD_SSL_ACCESS_PERM, dwSslAccess)) && dwSslAccess > 0)
    {
        key.SetValue(MD_SSL_ACCESS_PERM, 0);
    }

    // Now we need to remove SSL setting from any virtual directory below
    CError err;
    CStringListEx data_paths;
    DWORD dwMDIdentifier, dwMDAttributes, dwMDUserType,dwMDDataType;

    VERIFY(CMetaKey::GetMDFieldDef(MD_SSL_ACCESS_PERM, dwMDIdentifier, dwMDAttributes, dwMDUserType,dwMDDataType));

    err = key.GetDataPaths( data_paths,dwMDIdentifier,dwMDDataType);
    if (err.Succeeded() && !data_paths.empty())
    {
        CStringListEx::iterator it = data_paths.begin();
        while (it != data_paths.end())
        {
            CString& str = (*it++);
            if (SUCCEEDED(key.QueryValue(MD_SSL_ACCESS_PERM, dwSslAccess, NULL, str)) && dwSslAccess > 0)
            {
                key.SetValue(MD_SSL_ACCESS_PERM, 0, NULL, str);
            }
        }
    }
    return key.QueryResult();
}

/*
	InstallHashToMetabase

	Function writes hash array to metabase. After that IIS 
	could use certificate with that hash from MY store.
	Function expects server_name in format lm\w3svc\<number>,
	i.e. from root node down to virtual server

 */
BOOL InstallHashToMetabase(CRYPT_HASH_BLOB * pHash,BSTR InstanceName,HRESULT * phResult)
{
    BOOL bRes = FALSE;
    CComAuthInfo auth;
    CString key_path = SZ_MBN_SEP_STR SZ_MBN_MACHINE SZ_MBN_SEP_STR; // SZ_MBN_WEB SZ_MBN_SEP_STR;
    key_path += InstanceName;
    CMetaKey key(&auth, key_path, METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE);
	if (key.Succeeded())
	{
		CBlob blob;
		blob.SetValue(pHash->cbData, pHash->pbData, TRUE);
		bRes = SUCCEEDED(*phResult = key.SetValue(MD_SSL_CERT_HASH, blob))
			&& SUCCEEDED(*phResult = key.SetValue(MD_SSL_CERT_STORE_NAME, CString(L"MY")));
	}
	else
	{
        *phResult = key.QueryResult();
	}
	return bRes;
}

#ifdef FULL_OBJECT
HRESULT CIISCertObj::CreateDNString(CString& str)
{
    str = _T("");
    str += _T("CN=") + m_CommonName;
    str += _T("\n,OU=") + m_OrganizationUnit;
    str += _T("\n,O=") + m_Organization;
    str += _T("\n,L=") + m_Locality;
    str += _T("\n,S=") + m_State;
    str += _T("\n,C=") + m_Country;
    return S_OK;
}
#endif

CERT_CONTEXT * GetInstalledCert(HRESULT * phResult, CString csKeyPath)
{
    //	ATLASSERT(GetEnroll() != NULL);
    ATLASSERT(phResult != NULL);
    CERT_CONTEXT * pCert = NULL;
    *phResult = S_OK;
    CComAuthInfo auth;
    CString key_path = SZ_MBN_SEP_STR SZ_MBN_MACHINE SZ_MBN_SEP_STR;// SZ_MBN_WEB SZ_MBN_SEP_STR;
    key_path += csKeyPath;

    CMetaKey key(&auth, key_path, METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE);
    if (key.Succeeded())
    {
        CString store_name;
        CBlob hash;
        if (SUCCEEDED(*phResult = key.QueryValue(MD_SSL_CERT_STORE_NAME, store_name)) &&
            SUCCEEDED(*phResult = key.QueryValue(MD_SSL_CERT_HASH, hash)))
        {
            // Open MY store. We assume that store type and flags
            // cannot be changed between installation and unistallation
            // of the sertificate.
            HCERTSTORE hStore = CertOpenStore(CERT_STORE_PROV_SYSTEM,PKCS_7_ASN_ENCODING | X509_ASN_ENCODING,NULL,CERT_SYSTEM_STORE_LOCAL_MACHINE,store_name);
            ASSERT(hStore != NULL);
            if (hStore != NULL)
            {
                // Now we need to find cert by hash
                CRYPT_HASH_BLOB crypt_hash;
                crypt_hash.cbData = hash.GetSize();
                crypt_hash.pbData = hash.GetData();
                pCert = (CERT_CONTEXT *)CertFindCertificateInStore(hStore,X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,0,CERT_FIND_HASH,(LPVOID)&crypt_hash,NULL);
                if (pCert == NULL)
                {
                    *phResult = HRESULT_FROM_WIN32(GetLastError());
                }
                VERIFY(CertCloseStore(hStore, 0));
            }
            else
            {
                *phResult = HRESULT_FROM_WIN32(GetLastError());
            }
        }
    }
    else
    {
        *phResult = key.QueryResult();
    }
    return pCert;
}


HRESULT UninstallCert(CString csInstanceName)
{
    CComAuthInfo auth;
    CString key_path = SZ_MBN_SEP_STR SZ_MBN_MACHINE SZ_MBN_SEP_STR;// SZ_MBN_WEB SZ_MBN_SEP_STR;
    key_path += csInstanceName;
    CMetaKey key(&auth, key_path, METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE);
    if (key.Succeeded())
    {
        CString store_name;
        key.QueryValue(MD_SSL_CERT_STORE_NAME, store_name);
        if (SUCCEEDED(key.DeleteValue(MD_SSL_CERT_HASH)))
        {
            key.DeleteValue(MD_SSL_CERT_STORE_NAME);
        }
    }
    return key.QueryResult();
}


IIISCertObj * CIISCertObj::GetObject(HRESULT * phr)
{
    IIISCertObj * pObj = NULL;
    pObj = GetObject(phr,m_ServerName,m_UserName,m_UserPassword);
    return pObj;
}


IIISCertObj * CIISCertObj::GetObject(HRESULT * phr,CString csServerName,CString csUserName,CString csUserPassword)
{
    if (csServerName.IsEmpty())
    {
        // object is null, but it's the local machine, so just return back this pointer
        m_pObj = this;
        goto GetObject_Exit;
    }

    // There is a servername specified...
    // check if it's the local machine that was specified!
    if (IsServerLocal(csServerName))
    {
        m_pObj = this;
        goto GetObject_Exit;
    }
    else
    {
        // there is a remote servername specified

        // let's see if the machine has the com object that we want....
        // we are using the user/name password that are in this object
        // so were probably on the local machine
        CComAuthInfo auth(csServerName,csUserName,csUserPassword);
        COSERVERINFO * pcsiName = auth.CreateServerInfoStruct();

        MULTI_QI res[1] = 
        {
            {&__uuidof(IIISCertObj), NULL, 0}
        };

        // Try to instantiante the object on the remote server...
        // with the supplied authentication info (pcsiName)
        //#define CLSCTX_SERVER    (CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER | CLSCTX_REMOTE_SERVER)
        //#define CLSCTX_ALL       (CLSCTX_INPROC_HANDLER | CLSCTX_SERVER)
 
        // this one seems to work with surrogates..
        *phr = CoCreateInstanceEx(CLSID_IISCertObj,NULL,CLSCTX_LOCAL_SERVER,pcsiName,1,res);
        if (FAILED(*phr))
        {
            //IISDebugOutput(_T("CoCreateInstanceEx on CLSID_IISCertObj failed! code=0x%x\n"),*phr);
            goto GetObject_Exit;
        }

        // at this point we were able to instantiate the com object on the server (local or remote)
        m_pObj = (IIISCertObj *)res[0].pItf;
        if (auth.UsesImpersonation())
        {
            *phr = auth.ApplyProxyBlanket(m_pObj);
        }
        auth.FreeServerInfoStruct(pcsiName);
    }

GetObject_Exit:
    //ASSERT(m_pObj != NULL);
    return m_pObj;
}


BOOL AddChainToStore(HCERTSTORE hCertStore,PCCERT_CONTEXT pCertContext,DWORD cStores,HCERTSTORE * rghStores,BOOL fDontAddRootCert,CERT_TRUST_STATUS * pChainTrustStatus)
{
    DWORD	i;
    CERT_CHAIN_ENGINE_CONFIG CertChainEngineConfig;
    HCERTCHAINENGINE hCertChainEngine = NULL;
    PCCERT_CHAIN_CONTEXT pCertChainContext = NULL;
    CERT_CHAIN_PARA CertChainPara;
    BOOL fRet = TRUE;
    PCCERT_CONTEXT pTempCertContext = NULL;

    //
    // create a new chain engine, then build the chain
    //
    memset(&CertChainEngineConfig, 0, sizeof(CertChainEngineConfig));
    CertChainEngineConfig.cbSize = sizeof(CertChainEngineConfig);
    CertChainEngineConfig.cAdditionalStore = cStores;
    CertChainEngineConfig.rghAdditionalStore = rghStores;
    CertChainEngineConfig.dwFlags = CERT_CHAIN_USE_LOCAL_MACHINE_STORE;

    if (!CertCreateCertificateChainEngine(&CertChainEngineConfig, &hCertChainEngine))
    {
        goto AddChainToStore_Error;
    }

	memset(&CertChainPara, 0, sizeof(CertChainPara));
	CertChainPara.cbSize = sizeof(CertChainPara);

	if (!CertGetCertificateChain(hCertChainEngine,pCertContext,NULL,NULL,&CertChainPara,0,NULL,&pCertChainContext))
	{
		goto AddChainToStore_Error;
	}

    //
    // make sure there is atleast 1 simple chain
    //
    if (pCertChainContext->cChain != 0)
	{
		i = 0;
		while (i < pCertChainContext->rgpChain[0]->cElement)
		{
			//
			// if we are supposed to skip the root cert,
			// and we are on the root cert, then continue
			//
			if (fDontAddRootCert && (pCertChainContext->rgpChain[0]->rgpElement[i]->TrustStatus.dwInfoStatus & CERT_TRUST_IS_SELF_SIGNED))
			{
                i++;
                continue;
			}

			CertAddCertificateContextToStore(hCertStore,pCertChainContext->rgpChain[0]->rgpElement[i]->pCertContext,CERT_STORE_ADD_REPLACE_EXISTING,&pTempCertContext);
            //
            // remove any private key property the certcontext may have on it.
            //
            if (pTempCertContext)
            {
                CertSetCertificateContextProperty(pTempCertContext, CERT_KEY_PROV_INFO_PROP_ID, 0, NULL);
                CertFreeCertificateContext(pTempCertContext);
            }

			i++;
		}
	}
	else
	{
		goto AddChainToStore_Error;
	}

	//
	// if the caller wants the status, then set it
	//
	if (pChainTrustStatus != NULL)
	{
		pChainTrustStatus->dwErrorStatus = pCertChainContext->TrustStatus.dwErrorStatus;
		pChainTrustStatus->dwInfoStatus = pCertChainContext->TrustStatus.dwInfoStatus;
	}

	
AddChainToStore_Exit:
	if (pCertChainContext != NULL)
	{
		CertFreeCertificateChain(pCertChainContext);
	}

	if (hCertChainEngine != NULL)
	{
		CertFreeCertificateChainEngine(hCertChainEngine);
	}
	return fRet;

AddChainToStore_Error:
	fRet = FALSE;
	goto AddChainToStore_Exit;
}


// This function is borrowed from trustapi.cpp
static BOOL TrustIsCertificateSelfSigned(PCCERT_CONTEXT pContext,DWORD dwEncoding, DWORD dwFlags)
{
    if (!(pContext) || (dwFlags != 0))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    if (!(CertCompareCertificateName(dwEncoding,&pContext->pCertInfo->Issuer,&pContext->pCertInfo->Subject)))
    {
        return(FALSE);
    }

    DWORD   dwFlag;

    dwFlag = CERT_STORE_SIGNATURE_FLAG;

    if (!(CertVerifySubjectCertificateContext(pContext, pContext, &dwFlag)) || 
        (dwFlag & CERT_STORE_SIGNATURE_FLAG))
    {
        return(FALSE);
    }

    return(TRUE);
}


STDMETHODIMP CIISCertObj::Copy(BSTR bstrDestinationServerName,BSTR bstrDestinationServerInstance,VARIANT varDestinationServerUserName, VARIANT varDestinationServerPassword)
{
    return CopyOrMove(FALSE,bstrDestinationServerName,bstrDestinationServerInstance,varDestinationServerUserName,varDestinationServerPassword);
}


STDMETHODIMP CIISCertObj::Move(BSTR bstrDestinationServerName,BSTR bstrDestinationServerInstance,VARIANT varDestinationServerUserName, VARIANT varDestinationServerPassword)
{
    return CopyOrMove(TRUE,bstrDestinationServerName,bstrDestinationServerInstance,varDestinationServerUserName,varDestinationServerPassword);
}


HRESULT CIISCertObj::CopyOrMove(BOOL bRemoveFromCertAfterCopy,BSTR bstrDestinationServerName,BSTR bstrDestinationServerInstance,VARIANT varDestinationServerUserName, VARIANT varDestinationServerPassword)
{
    HRESULT hr = E_FAIL;
    DWORD  cbEncodedSize = 0;
    char * pszEncodedString = NULL;
    BOOL   bGuessingUserNamePass = FALSE;
    
    DWORD  blob_cbData;
    BYTE * blob_pbData = NULL;
    BOOL   blob_freeme = FALSE;

    BOOL bPrivateKey = TRUE;
    BOOL bCertChain = FALSE;

    CString csDestinationServerName = bstrDestinationServerName;
    CString csDestinationServerUserName;
    CString csDestinationServerUserPassword;
    CString csTempPassword;

    IIISCertObj * pObj = NULL;
    IIISCertObj * pObj2 = NULL;
    BSTR bstrInstanceName = SysAllocString(m_InstanceName);

    // if the optional parameter serverusername isn't empty, use that; otherwise, use...
    if (V_VT(&varDestinationServerUserName) != VT_ERROR)
    {
		VARIANT varBstrUserName;
        VariantInit(&varBstrUserName);
		HRESULT hr = VariantChangeType(&varBstrUserName, &varDestinationServerUserName, 0, VT_BSTR);
		if (FAILED(hr)){goto Copy_Exit;}
        csDestinationServerUserName = V_BSTR(&varBstrUserName);
		VariantClear(&varBstrUserName);
    }
    else
    {
        // it's empty so don't use it
        //csDestinationServerUserName = varDestinationServerUserName;
        bGuessingUserNamePass = TRUE;
        csDestinationServerUserName = m_UserName;
    }

    // if the optional parameter serverusername isn't empty, use that; otherwise, use...
    if (V_VT(&varDestinationServerPassword) != VT_ERROR)
    {
		VARIANT varBstrUserPassword;
        VariantInit(&varBstrUserPassword);
		HRESULT hr = VariantChangeType(&varBstrUserPassword, &varDestinationServerPassword, 0, VT_BSTR);
		if (FAILED(hr)){goto Copy_Exit;}
        csDestinationServerUserPassword = V_BSTR(&varBstrUserPassword);
		VariantClear(&varBstrUserPassword);
    }
    else
    {
        if (TRUE == bGuessingUserNamePass)
        {
            csDestinationServerUserPassword = m_UserPassword;
        }
        else
        {
            // maybe the password was intended to be empty!
        }
    }

    // --------------------------
    // step 1.
    // 1st of all check if we have access to
    // both the servers!!!!
    // --------------------------

    // 1st we have to get the certblob from the Server#1
    // so call export to get the data
    hr = S_OK;
    pObj = GetObject(&hr);
    if (FAILED(hr))
    {
        return(hr);
    }

    // Logon to that server's CertObj.dll with the credentials supplied...
    //
    // if there were no credential's supplied then just use the ones that are in our object....
    //
    // if that doesn't work then try just the logged on user.
    pObj2 = GetObject(&hr,csDestinationServerName,csDestinationServerUserName,csDestinationServerUserPassword);
    if (FAILED(hr))
    {
        if (TRUE == bGuessingUserNamePass)
        {
            // try something else.
        }
        goto Copy_Exit;
    }

    //
    // Create a unique password
    //
    // use the new secure password generator
    // unfortunately this baby doesn't use unicode.
    // so we'll call it and then convert it to unicode afterwards.
    WCHAR * pwszPassword = CreatePassword(TEMP_PASSWORD_LENGTH);
    // if its null -- ah, we can still use that...
    BSTR bstrPassword = SysAllocString(pwszPassword);

    // -----------------------------------
    // step 2.
    // okay we have access to both servers
    // Grab the cert from server #1
    // -----------------------------------
    // Get data from the remote/local iis store return it back as a blob.
    // The blob could be returned back as Base64 encoded so check that flag
    hr = ExportToBlobProxy(pObj, bstrInstanceName, bstrPassword, bPrivateKey, bCertChain, &cbEncodedSize, &pszEncodedString);
    if (FAILED(hr))
    {
        goto Copy_Exit;
    }

    int err;
    // The data we got back was Base64 encoded to remove nulls.
    // we need to decode it back to it's original format.
    if( (err = Base64DecodeA(pszEncodedString,cbEncodedSize,NULL,&blob_cbData)) != ERROR_SUCCESS                    ||
        (blob_pbData = (BYTE *) malloc(blob_cbData)) == NULL      ||
        (err = Base64DecodeA(pszEncodedString,cbEncodedSize,blob_pbData,&blob_cbData)) != ERROR_SUCCESS ) 
    {
        SetLastError(err);
        hr = HRESULT_FROM_WIN32(err);
        return hr;
    }
    blob_freeme = TRUE;

    // -----------------------------------
    // step 3.
    // okay we have access to both servers
    // we have the cert blob from server#1 in memory
    // now we need to push this blob into the server#2
    // -----------------------------------
    hr = ImportFromBlobProxy(pObj2, bstrDestinationServerInstance, bstrPassword, blob_cbData, blob_pbData);
    if (FAILED(hr))
    {
        goto Copy_Exit;
    }

    // we successfully copied the cert from machine #1 to machine #2.
    // lets see if we need to delete the original cert!.
    if (TRUE == bRemoveFromCertAfterCopy)
    {
        hr = pObj->RemoveCert(bstrInstanceName, bPrivateKey);
        if (FAILED(hr))
        {
            goto Copy_Exit;
        }
    }

    hr = S_OK;
   
Copy_Exit:
    if (pwszPassword) {GlobalFree(pwszPassword);pwszPassword=NULL;}
    if (blob_freeme){if (blob_pbData != NULL){free(blob_pbData);blob_pbData=NULL;}}
    if (pszEncodedString != NULL){CoTaskMemFree(pszEncodedString);pszEncodedString=NULL;}
    return hr;
}



// password categories
enum {STRONG_PWD_UPPER=0,STRONG_PWD_LOWER,STRONG_PWD_NUM,STRONG_PWD_PUNC};
#define STRONG_PWD_CATS (STRONG_PWD_PUNC + 1)
#define NUM_LETTERS 26
#define NUM_NUMBERS 10
#define MIN_PWD_LEN 8

// password must contain at least one each of: 
// uppercase, lowercase, punctuation and numbers
DWORD CreateGoodPassword(BYTE *szPwd, DWORD dwLen) 
{
    if (dwLen-1 < MIN_PWD_LEN)
    {
        return ERROR_PASSWORD_RESTRICTION;
    }

    HCRYPTPROV hProv;
    DWORD dwErr = 0;

    if (CryptAcquireContext(&hProv,NULL,NULL,PROV_RSA_FULL,CRYPT_VERIFYCONTEXT) == FALSE) 
    {
        return GetLastError();
    }

    // zero it out and decrement the size to allow for trailing '\0'
    ZeroMemory(szPwd,dwLen);
    dwLen--;

    // generate a pwd pattern, each byte is in the range 
    // (0..255) mod STRONG_PWD_CATS
    // this indicates which character pool to take a char from
    BYTE *pPwdPattern = new BYTE[dwLen];
    BOOL fFound[STRONG_PWD_CATS];
    do 
    {
        // bug!bug! does CGR() ever fail?
        CryptGenRandom(hProv,dwLen,pPwdPattern);

        fFound[STRONG_PWD_UPPER] = 
        fFound[STRONG_PWD_LOWER] =
        fFound[STRONG_PWD_PUNC] =
        fFound[STRONG_PWD_NUM] = FALSE;

        for (DWORD i=0; i < dwLen; i++)
        {
            fFound[pPwdPattern[i] % STRONG_PWD_CATS] = TRUE;
        }
        // check that each character category is in the pattern
    } while (!fFound[STRONG_PWD_UPPER] || !fFound[STRONG_PWD_LOWER] || !fFound[STRONG_PWD_PUNC] || !fFound[STRONG_PWD_NUM]);

    // populate password with random data 
    // this, in conjunction with pPwdPattern, is
    // used to determine the actual data
    CryptGenRandom(hProv,dwLen,szPwd);

    for (DWORD i=0; i < dwLen; i++) 
    {
        BYTE bChar = 0;

        // there is a bias in each character pool because of the % function
        switch (pPwdPattern[i] % STRONG_PWD_CATS) 
        {
            case STRONG_PWD_UPPER : bChar = 'A' + szPwd[i] % NUM_LETTERS;
                break;
            case STRONG_PWD_LOWER : bChar = 'a' + szPwd[i] % NUM_LETTERS;
                break;
            case STRONG_PWD_NUM :   bChar = '0' + szPwd[i] % NUM_NUMBERS;
                break;
            case STRONG_PWD_PUNC :
            default:
                char *szPunc="!@#$%^&*()_-+=[{]};:\'\"<>,./?\\|~`";
                DWORD dwLenPunc = lstrlenA(szPunc);
                bChar = szPunc[szPwd[i] % dwLenPunc];
                break;
        }
        szPwd[i] = bChar;
    }

    delete pPwdPattern;

    if (hProv != NULL) 
    {
        CryptReleaseContext(hProv,0);
    }
    return dwErr;
}


// Creates a secure password
// caller must GlobalFree Return pointer
// iSize = size of password to create
LPTSTR CreatePassword(int iSize)
{
    LPTSTR pszPassword =  NULL;
    BYTE *szPwd = new BYTE[iSize];
    DWORD dwPwdLen = iSize;
    int i = 0;

    // use the new secure password generator
    // unfortunately this baby doesn't use unicode.
    // so we'll call it and then convert it to unicode afterwards.
    if (0 == CreateGoodPassword(szPwd,dwPwdLen))
    {
#if defined(UNICODE) || defined(_UNICODE)
        // convert it to unicode and copy it back into our unicode buffer.
        // compute the length
        i = MultiByteToWideChar(CP_ACP, 0, (LPSTR) szPwd, -1, NULL, 0);
        if (i <= 0) 
            {goto CreatePassword_Exit;}
        pszPassword = (LPTSTR) GlobalAlloc(GPTR, i * sizeof(TCHAR));
        if (!pszPassword)
            {goto CreatePassword_Exit;}
        i =  MultiByteToWideChar(CP_ACP, 0, (LPSTR) szPwd, -1, pszPassword, i);
        if (i <= 0) 
            {
            GlobalFree(pszPassword);
            pszPassword = NULL;
            goto CreatePassword_Exit;
            }
        // make sure ends with null
        pszPassword[i - 1] = 0;
#else
        pszPassword = (LPSTR) GlobalAlloc(GPTR, _tcslen((LPTSTR) szPwd) * sizeof(TCHAR));
#endif
    }

CreatePassword_Exit:
    if (szPwd){delete szPwd;szPwd=NULL;}
    return pszPassword;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\certobj\base64.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996-1996
//
// File:        base64.cpp
//
// Contents:    base64 encode/decode implementation
//
// History:     25-Jul-96       vich created
//
//---------------------------------------------------------------------------
//                3-Mar-98   tompop took and modified it.  Building
//                           both Ansi and Wchar versions of Encode/Decode
//                           base 64 for CertWizard, that is in IIS5's UI.
//                           We merged the examples from NT5's base64.cpp
//                           and ubase64.cpp files into this single file.
//					   5-Aug-98	  Sergei Antonov removed above mentioned stuff after tompop
//---------------------------------------------------------------------------
#include "stdafx.h"
#include <malloc.h>
#include <windows.h>
#include "base64.h"

// The following table translates an ascii subset to 6 bit values as follows
// (see rfc 1521):
//
//  input    hex (decimal)
//  'A' --> 0x00 (0)
//  'B' --> 0x01 (1)
//  ...
//  'Z' --> 0x19 (25)
//  'a' --> 0x1a (26)
//  'b' --> 0x1b (27)
//  ...
//  'z' --> 0x33 (51)
//  '0' --> 0x34 (52)
//  ...
//  '9' --> 0x3d (61)
//  '+' --> 0x3e (62)
//  '/' --> 0x3f (63)
//
// Encoded lines must be no longer than 76 characters.
// The final "quantum" is handled as follows:  The translation output shall
// always consist of 4 characters.  'x', below, means a translated character,
// and '=' means an equal sign.  0, 1 or 2 equal signs padding out a four byte
// translation quantum means decoding the four bytes would result in 3, 2 or 1
// unencoded bytes, respectively.
//
//  unencoded size    encoded data
//  --------------    ------------
//     1 byte       "xx=="
//     2 bytes      "xxx="
//     3 bytes      "xxxx"

#define CB_BASE64LINEMAX    64  // others use 64 -- could be up to 76

// Any other (invalid) input character value translates to 0x40 (64)

const BYTE abDecode[256] =
{
    /* 00: */ 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
    /* 10: */ 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
    /* 20: */ 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 62, 64, 64, 64, 63,
    /* 30: */ 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 64, 64, 64, 64, 64, 64,
    /* 40: */ 64,  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14,
    /* 50: */ 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 64, 64, 64, 64, 64,
    /* 60: */ 64, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,
    /* 70: */ 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 64, 64, 64, 64, 64,
    /* 80: */ 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
    /* 90: */ 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
    /* a0: */ 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
    /* b0: */ 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
    /* c0: */ 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
    /* d0: */ 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
    /* e0: */ 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
    /* f0: */ 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
};


const UCHAR abEncode[] =
    /*  0 thru 25: */ "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
    /* 26 thru 51: */ "abcdefghijklmnopqrstuvwxyz"
    /* 52 thru 61: */ "0123456789"
    /* 62 and 63: */  "+/";


DWORD
Base64DecodeA(const char * pchIn, DWORD cchIn, BYTE * pbOut, DWORD * pcbOut)
{
	DWORD err = ERROR_SUCCESS;
   DWORD cchInDecode, cbOutDecode;
   CHAR const *pchInEnd;
   CHAR const *pchInT;
   BYTE *pbOutT;

   // Count the translatable characters, skipping whitespace & CR-LF chars.
   cchInDecode = 0;
   pchInEnd = &pchIn[cchIn];
   for (pchInT = pchIn; pchInT < pchInEnd; pchInT++)
   {
		if (sizeof(abDecode) < (unsigned) *pchInT || abDecode[*pchInT] > 63)
		{
			// skip all whitespace
			if (	*pchInT == ' ' 
				||	*pchInT == '\t' 
				||	*pchInT == '\r' 
				||	*pchInT == '\n'
				)
			{
				continue;
			}

			if (0 != cchInDecode)
			{
				if ((cchInDecode % 4) == 0)
				{
					break;          // ends on quantum boundary
			}

			// The length calculation may stop in the middle of the last
			// translation quantum, because the equal sign padding
			// characters are treated as invalid input.  If the last
			// translation quantum is not 4 bytes long, it must be 2 or 3
			// bytes long.

			if (*pchInT == '=' && (cchInDecode % 4) != 1)
			{
				break;              // normal termination
			}
		}
      err = ERROR_INVALID_DATA;
      goto error;
	}
   cchInDecode++;
   }
    ATLASSERT(pchInT <= pchInEnd);
    pchInEnd = pchInT;      // don't process any trailing stuff again

    // We know how many translatable characters are in the input buffer, so now
    // set the output buffer size to three bytes for every four (or fraction of
    // four) input bytes.

    cbOutDecode = ((cchInDecode + 3) / 4) * 3;

    pbOutT = pbOut;

    if (NULL == pbOut)
    {
    pbOutT += cbOutDecode;
    }
    else
    {
    // Decode one quantum at a time: 4 bytes ==> 3 bytes

    ATLASSERT(cbOutDecode <= *pcbOut);
    pchInT = pchIn;
    while (cchInDecode > 0)
    {
        DWORD i;
        BYTE ab4[4];

        memset(ab4, 0, sizeof(ab4));
        for (i = 0; i < min(sizeof(ab4)/sizeof(ab4[0]), cchInDecode); i++)
        {
        while (
            sizeof(abDecode) > (unsigned) *pchInT &&
            63 < abDecode[*pchInT])
        {
            pchInT++;
        }
        ATLASSERT(pchInT < pchInEnd);
        ab4[i] = (BYTE) *pchInT++;
        }

        // Translate 4 input characters into 6 bits each, and deposit the
        // resulting 24 bits into 3 output bytes by shifting as appropriate.

        // out[0] = in[0]:in[1] 6:2
        // out[1] = in[1]:in[2] 4:4
        // out[2] = in[2]:in[3] 2:6

        *pbOutT++ =
        (BYTE) ((abDecode[ab4[0]] << 2) | (abDecode[ab4[1]] >> 4));

        if (i > 2)
        {
        *pbOutT++ =
          (BYTE) ((abDecode[ab4[1]] << 4) | (abDecode[ab4[2]] >> 2));
        }
        if (i > 3)
        {
        *pbOutT++ = (BYTE) ((abDecode[ab4[2]] << 6) | abDecode[ab4[3]]);
        }
        cchInDecode -= i;
    }
    ATLASSERT((DWORD) (pbOutT - pbOut) <= cbOutDecode);
    }
    *pcbOut = (DWORD)(pbOutT - pbOut);
error:
    return(err);
}

// Base64EncodeA 
//
// RETURNS  0 (i.e. ERROR_SUCCESS) on success
//


DWORD
Base64EncodeA(
    IN BYTE const *pbIn,
    IN DWORD cbIn,
    OUT CHAR *pchOut,
    OUT DWORD *pcchOut)
{
    CHAR *pchOutT;
    DWORD cchOutEncode;

    // Allocate enough memory for full final translation quantum.
    cchOutEncode = ((cbIn + 2) / 3) * 4;

    // and enough for CR-LF pairs for every CB_BASE64LINEMAX character line.
    cchOutEncode +=
		2 * ((cchOutEncode + CB_BASE64LINEMAX - 1) / CB_BASE64LINEMAX);

    pchOutT = pchOut;
	if (NULL == pchOut)
   {
		pchOutT += cchOutEncode;
   }
   else
   {
		DWORD cCol;

      ATLASSERT(cchOutEncode <= *pcchOut);
      cCol = 0;
      while ((long) cbIn > 0) // signed comparison -- cbIn can wrap
      {
         BYTE ab3[3];

         if (cCol == CB_BASE64LINEMAX/4)
         {
            cCol = 0;
            *pchOutT++ = '\r';
            *pchOutT++ = '\n';
         }
         cCol++;
         memset(ab3, 0, sizeof(ab3));

         ab3[0] = *pbIn++;
         if (cbIn > 1)
         {
           ab3[1] = *pbIn++;
           if (cbIn > 2)
           {
               ab3[2] = *pbIn++;
           }
         }

         *pchOutT++ = abEncode[ab3[0] >> 2];
         *pchOutT++ = abEncode[((ab3[0] << 4) | (ab3[1] >> 4)) & 0x3f];
         *pchOutT++ = (cbIn > 1)?
            abEncode[((ab3[1] << 2) | (ab3[2] >> 6)) & 0x3f] : '=';
         *pchOutT++ = (cbIn > 2)? abEncode[ab3[2] & 0x3f] : '=';

         cbIn -= 3;
      }
      *pchOutT++ = '\r';
      *pchOutT++ = '\n';
      ATLASSERT((DWORD) (pchOutT - pchOut) <= cchOutEncode);
   }
   *pcchOut = (DWORD)(pchOutT - pchOut);
   return(ERROR_SUCCESS);
}

// Base64EncodeW 
//
// RETURNS  0 (i.e. ERROR_SUCCESS) on success
//

DWORD Base64EncodeW(
    BYTE const *pbIn,
    DWORD cbIn,
    WCHAR *wszOut,
    DWORD *pcchOut)

{

    DWORD   cchOut;
    char   *pch = NULL;
    DWORD   cch;
    DWORD   err;

    ATLASSERT(pcchOut != NULL);

    // only want to know how much to allocate
    // we know all base64 char map 1-1 with unicode
    if( wszOut == NULL ) {

        // get the number of characters
        *pcchOut = 0;
        err = Base64EncodeA(
                pbIn,
                cbIn,
                NULL,
                pcchOut);
    }

    // otherwise we have an output buffer
    else {

        // char count is the same be it ascii or unicode,
        cchOut = *pcchOut;
        cch = 0;
        err = ERROR_OUTOFMEMORY;
        if( (pch = (char *) malloc(cchOut)) != NULL  &&
        
            (err = Base64EncodeA(
                pbIn,
                cbIn,
                pch,
                &cchOut)) == ERROR_SUCCESS      ) {

            // should not fail!
            cch = MultiByteToWideChar(0, 
                            0, 
                            pch, 
                            cchOut, 
                            wszOut, 
                            *pcchOut);

            // check to make sure we did not fail                            
            ATLASSERT(*pcchOut == 0 || cch != 0);                            
        }
    }

    if(pch != NULL)
        free(pch);

    return(err);
}

// Base64DecodeW 
//
// RETURNS  0 (i.e. ERROR_SUCCESS) on success
//

DWORD Base64DecodeW(
    const WCHAR * wszIn,
    DWORD cch,
    BYTE *pbOut,
    DWORD *pcbOut)
{

    char *pch;
    DWORD err = ERROR_SUCCESS;
    
    if( (pch = (char *) malloc(cch)) == NULL ) 
	 {
        err = ERROR_OUTOFMEMORY;
    }
    else if( WideCharToMultiByte(0, 0, wszIn, cch, pch, cch, 
                        NULL, NULL) == 0 ) 
	 {
        err = ERROR_NO_DATA;
    }
    else if( pbOut == NULL ) 
	 {
        *pcbOut = 0;
        err = Base64DecodeA(pch, cch, NULL, pcbOut);
    }
    else 
	 {
        err = Base64DecodeA(pch, cch, pbOut, pcbOut);
    }
    if(pch != NULL)
        free(pch);
    return(err);
}

#if 0
// sanity tests...  Lets make sure that the encode and decode
//                  works...

BOOL test_Base64EncodeW()
{
    BYTE  pbIn[120];            // for the test we just use the random stack data
    DWORD cbIn = sizeof( pbIn );
    
    WCHAR *wszB64Out;
    DWORD pcchB64Out;

    DWORD  err;
    
    // BASE64 encode pkcs 10
    if( (err = Base64EncodeW(
                pbIn,
                cbIn,
                NULL,
                &pcchB64Out)) != ERROR_SUCCESS     ||
        (wszB64Out = (WCHAR *) _alloca(pcchB64Out * sizeof(WCHAR))) == NULL  ||
        (err = Base64EncodeW(
                pbIn,
                cbIn,
                wszB64Out,
                &pcchB64Out)) != ERROR_SUCCESS ) 
    {
        SetLastError(err);
        return FALSE;  //goto ErrorBase64Encode;
    }


    // well the encode worked lets test the decode
    //
    // pcchB64Out holds the B64 data length
    // wszB64Out  holds the actual data

     DWORD blob_cbData;     // we store in these variables what
     BYTE* blob_pbData;     //  we read in..

    // They should match the stuff stored in:
    //    BYTE  pbIn[120];
    //    DWORD cbIn = sizeof( pbIn );
    // This we be tested after the decode.

    // base64 decode
    if( (err = Base64DecodeW(
            wszB64Out,
            pcchB64Out,
            NULL,
            &blob_cbData)) != ERROR_SUCCESS                    ||
        (blob_pbData = (BYTE *) _alloca(blob_cbData)) == NULL      ||
        (err = Base64DecodeW(
            wszB64Out,
            pcchB64Out,
            blob_pbData,
            &blob_cbData)) != ERROR_SUCCESS ) 
    {
        
        SetLastError(err);
        return(FALSE);  //goto ErrorBase64Decode;
    }



    //do compare

    
    return( (blob_cbData==cbIn)
            &&  (memcmp(blob_pbData, pbIn,cbIn)==0) );
    

 }
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\certmap\wwzthree.h ===
// WWzThree.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CWildWizThree dialog

class CWildWizThree : public CPropertyPage
{
    DECLARE_DYNCREATE(CWildWizThree)

// Construction
public:
    CWildWizThree();
    ~CWildWizThree();

    // to make the buttons behave right
    BOOL            m_fIsWizard;
    CPropertySheet* m_pPropSheet;

    // the only public member
    CCertMapRule*   m_pRule;

    // base path to the metabase
    CString m_szMBPath;

    virtual BOOL OnWizardFinish();
    virtual BOOL OnApply();
    virtual BOOL OnInitDialog();

    // Dialog Data
    //{{AFX_DATA(CWildWizThree)
    enum { IDD = IDD_WILDWIZ_3 };
    CStatic m_static_password;
    CStatic m_static_account;
    CButton m_btn_browse;
    CEdit   m_cedit_password;
    CEdit   m_cedit_accountname;
    int     m_int_DenyAccess;
    CString m_sz_accountname;
    CString m_sz_password;
    //}}AFX_DATA


// Overrides
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CWildWizThree)
    public:
    virtual BOOL OnSetActive();
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:
    // Generated message map functions
    //{{AFX_MSG(CWildWizThree)
    afx_msg void OnBrowse();
    afx_msg void OnChangeNtaccount();
    afx_msg void OnChangePassword();
    afx_msg void OnAcceptLogon();
    afx_msg void OnRefuseLogon();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

    void DoHelp();
    void EnableButtons();

    CString m_szOrigPass;
    BOOL    m_bPassTyped;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\certobj\base64.h ===
//
// base64.h
//
#ifndef _BASE64_H
#define _BASE64_H

DWORD Base64DecodeA(const char * pchIn, DWORD cchIn, BYTE * pbOut, DWORD * pcbOut);
DWORD Base64EncodeA(const BYTE * pbIn, DWORD cbIn, char * pchOut, DWORD * pcchOut);
DWORD Base64EncodeW(BYTE const *pbIn, DWORD cbIn, WCHAR *wszOut, DWORD *pcchOut);
DWORD Base64DecodeW(const WCHAR * wszIn, DWORD cch, BYTE *pbOut, DWORD *pcbOut);

#endif	//_BASE64_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\certmap\wwztwo.h ===
// WWzTwo.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CWildWizTwo dialog

class CWildWizTwo : public CPropertyPage
{
    DECLARE_DYNCREATE(CWildWizTwo)

// Construction
public:
    CWildWizTwo();
    ~CWildWizTwo();

    // to make the buttons behave right
    BOOL            m_fIsWizard;
    CPropertySheet* m_pPropSheet;

    // the only public member
    CCertMapRule*   m_pRule;

    // base path to the metabase
    CString m_szMBPath;

    virtual BOOL OnWizardFinish();
    virtual BOOL OnApply();
    virtual BOOL OnInitDialog();

// Dialog Data
    //{{AFX_DATA(CWildWizTwo)
    enum { IDD = IDD_WILDWIZ_2 };
    CListSelRowCtrl m_clistctrl_list;
    CButton m_cbutton_new;
    CButton m_cbutton_edit;
    CButton m_cbutton_delete;
    //}}AFX_DATA


// Overrides
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CWildWizTwo)
    public:
    virtual BOOL OnSetActive();
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:
    // Generated message map functions
    //{{AFX_MSG(CWildWizTwo)
    afx_msg void OnDelete();
    afx_msg void OnEdit();
    afx_msg void OnDblclkList(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnItemchangedList(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnNew();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

    void DoHelp();

    BOOL FInitRulesList();
    BOOL FillRulesList();

    // editing and updating
    void EnableDependantButtons();
    BOOL EditRule( DWORD iList );
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\certmap\wwztwo.cpp ===
// WWzTwo.cpp : implementation file
//

#include "stdafx.h"
#include <iadmw.h>
#include "certmap.h"

#include "ListRow.h"
#include "ChkLstCt.h"
extern "C"
    {
    #include <wincrypt.h>
    #include <sslsp.h>
    }
#include "Iismap.hxx"
#include "Iiscmr.hxx"

#include "brwsdlg.h"
#include "EdWldRul.h"
#include "EdtRulEl.h"

#include "WWzTwo.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define COL_CERT_FIELD          0
#define COL_SUB_FIELD           1
#define COL_MATCH_CRITERIA      2

/////////////////////////////////////////////////////////////////////////////
// CWildWizTwo property page

IMPLEMENT_DYNCREATE(CWildWizTwo, CPropertyPage)

CWildWizTwo::CWildWizTwo() : CPropertyPage(CWildWizTwo::IDD)
{
    //{{AFX_DATA_INIT(CWildWizTwo)
    //}}AFX_DATA_INIT
}

CWildWizTwo::~CWildWizTwo()
{
}

void CWildWizTwo::DoDataExchange(CDataExchange* pDX)
{
    CPropertyPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CWildWizTwo)
    DDX_Control(pDX, IDC_LIST, m_clistctrl_list);
    DDX_Control(pDX, IDC_NEW, m_cbutton_new);
    DDX_Control(pDX, IDC_EDIT, m_cbutton_edit);
    DDX_Control(pDX, IDC_DELETE, m_cbutton_delete);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CWildWizTwo, CPropertyPage)
    //{{AFX_MSG_MAP(CWildWizTwo)
    ON_BN_CLICKED(IDC_DELETE, OnDelete)
    ON_BN_CLICKED(IDC_EDIT, OnEdit)
    ON_NOTIFY(NM_DBLCLK, IDC_LIST, OnDblclkList)
    ON_NOTIFY(LVN_ITEMCHANGED, IDC_LIST, OnItemchangedList)
    ON_BN_CLICKED(IDC_NEW, OnNew)
    //}}AFX_MSG_MAP
    ON_COMMAND(ID_HELP_FINDER,  DoHelp)
    ON_COMMAND(ID_HELP,         DoHelp)
    ON_COMMAND(ID_CONTEXT_HELP, DoHelp)
    ON_COMMAND(ID_DEFAULT_HELP, DoHelp)
END_MESSAGE_MAP()

//---------------------------------------------------------------------------
void CWildWizTwo::DoHelp()
    {
    WinHelp( HIDD_CERTMAP_ADV_RUL_RULES );
    }

//---------------------------------------------------------------------------
BOOL CWildWizTwo::FInitRulesList()
    {
    CString sz;
    int     i;

    // setup the main field
    sz.LoadString( IDS_CERT_FIELD );

    i = m_clistctrl_list.InsertColumn( COL_CERT_FIELD, sz, LVCFMT_LEFT, 100 );

    // setup the sub field
    sz.LoadString( IDS_SUB_FIELD );
    i = m_clistctrl_list.InsertColumn( COL_SUB_FIELD, sz, LVCFMT_LEFT, 70 );

    // setup the match criteria column
    sz.LoadString( IDS_MATCH_CRITERIA );
    i = m_clistctrl_list.InsertColumn( COL_MATCH_CRITERIA, sz, LVCFMT_LEFT, 226 );

    return TRUE;
    }

//---------------------------------------------------------------------------
BOOL CWildWizTwo::FillRulesList()
    {
    CERT_FIELD_ID   idCertField;
    LPBYTE          pContent;
    DWORD           cbContent;
    LPSTR           psz;

    DWORD           flags;

    CString         sz;
    int             i;

    //
    // UNICODE/ANSI conversion -- RonaldM
    //
    USES_CONVERSION;

    // get the number of subfield rules
    DWORD cbRules = m_pRule->GetRuleElemCount();

    // loop the elements, adding each to the list
    for ( DWORD j = 0; j < cbRules; j++ )
        {
        // get the raw data for the rule element
        if ( !m_pRule->GetRuleElem( j, &idCertField, (PCHAR*)&pContent, &cbContent, &psz, &flags ) )
            continue;       // the call failed - try the next

        // start converting the data into readable form and adding it to the list
        sz = MapIdToField( idCertField );
        // create the new entry in the list box.
        i = m_clistctrl_list.InsertItem( j, sz );

        // add the subfield data
        sz = MapAsn1ToSubField( psz );
        m_clistctrl_list.SetItemText( i, COL_SUB_FIELD, sz );

        // add the content data - reuse the psz pointer
        if ( BinaryToMatchRequest( pContent, cbContent, &psz ) )
            m_clistctrl_list.SetItemText( i, COL_MATCH_CRITERIA, A2T(psz) );

        // finally, attach the id cert field as user data to the item
        DWORD   dw;
        BOOL    fMatchCapitalization = !(flags & CMR_FLAGS_CASE_INSENSITIVE);
        dw = ( (fMatchCapitalization << 16) | idCertField );
        m_clistctrl_list.SetItemData( i, dw );
        }

        return TRUE;
    }


//CMR_FLAGS_CASE_INSENSITIVE

// editing and updating

//---------------------------------------------------------------------------
void CWildWizTwo::EnableDependantButtons()
    {
    // the whole purpose of this routine is to gray or activate
    // the edit and delete buttons depending on whether or not anything
    // is selected. So start by getting the selection count
    UINT    cItemsSel = m_clistctrl_list.GetSelectedCount();

    if ( cItemsSel > 0 )
        {
        // there are items selected
        m_cbutton_edit.EnableWindow( TRUE );
        m_cbutton_delete.EnableWindow( TRUE );
        }
    else
        {
        // nope. Nothing selected
        m_cbutton_edit.EnableWindow( FALSE );
        m_cbutton_delete.EnableWindow( FALSE );
        }

    // always enable the new button
    m_cbutton_new.EnableWindow( TRUE );
    }

//---------------------------------------------------------------------------
BOOL CWildWizTwo::EditRule( DWORD iList )
    {
    // declare the editing dialog
    CEditRuleElement    editDlg;
    DWORD               dw;

    // fill in its data
    // IA64 - OK to cast as the data really is just a DWORD
    dw = (DWORD)m_clistctrl_list.GetItemData( iList );
    editDlg.m_bool_match_case = HIWORD( dw );
    editDlg.m_int_field = LOWORD( dw );
    editDlg.m_sz_subfield = m_clistctrl_list.GetItemText( iList, COL_SUB_FIELD );
    editDlg.m_sz_criteria = m_clistctrl_list.GetItemText( iList, COL_MATCH_CRITERIA );

    // run the dialog
    if ( editDlg.DoModal() == IDOK )
        {
        // must convert the field into a string too
        CERT_FIELD_ID id = (CERT_FIELD_ID)editDlg.m_int_field;
        CString sz = MapIdToField( id );
        m_clistctrl_list.SetItemText( iList, COL_CERT_FIELD, sz );

        dw = ( (editDlg.m_bool_match_case << 16) | id);
        m_clistctrl_list.SetItemData( iList, dw );
        m_clistctrl_list.SetItemText( iList, COL_SUB_FIELD, editDlg.m_sz_subfield );
        m_clistctrl_list.SetItemText( iList, COL_MATCH_CRITERIA, editDlg.m_sz_criteria );
 
        // we can now apply
        SetModified();
        }
    return TRUE;
    }


/////////////////////////////////////////////////////////////////////////////
// CWildWizTwo message handlers

//---------------------------------------------------------------------------
BOOL CWildWizTwo::OnInitDialog()
    {
    // call the parental oninitdialog
    BOOL f = CPropertyPage::OnInitDialog();

    // initialize the list
    FInitRulesList();
    FillRulesList();
    EnableDependantButtons();

    // return the answer
    return f;
    }

//---------------------------------------------------------------------------
BOOL CWildWizTwo::OnWizardFinish()
    {
    return OnApply();
    }

//---------------------------------------------------------------------------
BOOL CWildWizTwo::OnApply()
    {
    CERT_FIELD_ID   id;
    CString         szSub, sz;
    LPBYTE          pbBin;
    DWORD           cbBin;
    UINT            cItems;
    UINT            iItem;

    USES_CONVERSION;

    // update the data
    UpdateData( TRUE );

    //======== store the rule elements
    // start by resetting the entire rule - that way we don't have to
    // mess with individual elements in the list, allowing us to cancel. 
    // But that is ok, because we can just spin through
    // the ones in the list very quickly and re-add them

    // remove the existing elements from the list.
    cItems = m_pRule->GetRuleElemCount();
    for ( iItem = 0; iItem < cItems; iItem++ )
        m_pRule->DeleteRuleElem( 0 );

    // add all the items in the list
    cItems = m_clistctrl_list.GetItemCount();
    for ( iItem = 0; iItem < cItems; iItem++ )
        {
        // prepare the field id
        id = (CERT_FIELD_ID)LOWORD(m_clistctrl_list.GetItemData( iItem ));

        // prepare the caps flag
        BOOL    fCaps = HIWORD(m_clistctrl_list.GetItemData( iItem ));
        DWORD   flags = 0;
        if ( !fCaps )
            flags = CMR_FLAGS_CASE_INSENSITIVE;


        // prepare the subfield
        sz = m_clistctrl_list.GetItemText(iItem, COL_SUB_FIELD);

        LPSTR szA = T2A((LPTSTR)(LPCTSTR)sz);
        szSub = MapSubFieldToAsn1( szA );

        // prepare the data
        sz = m_clistctrl_list.GetItemText(iItem, COL_MATCH_CRITERIA);
        szA = T2A((LPTSTR)(LPCTSTR)sz);
        if ( !MatchRequestToBinary( szA, &pbBin, &cbBin) )
            continue;

        // add the element to the rule
        m_pRule->AddRuleElem( 0xffffffff, id, T2A((LPTSTR)(LPCTSTR)szSub), pbBin, cbBin, flags );

        // free the binary match data
        FreeMatchConversion( pbBin );
        }

    // return success
    SetModified( FALSE );
    return TRUE;
    }

//---------------------------------------------------------------------------
void CWildWizTwo::OnDelete() 
    {
    ASSERT( m_clistctrl_list.GetSelectedCount() == 1 );
    DWORD           iList;

    // get index of the selected list item
    iList = m_clistctrl_list.GetNextItem( -1, LVNI_SELECTED );
    ASSERT( iList >= 0 );

    // delete the item from the display list
    m_clistctrl_list.DeleteItem ( iList );

    // we can now apply
    SetModified();
    }

//---------------------------------------------------------------------------
void CWildWizTwo::OnEdit() 
    {
    ASSERT( m_clistctrl_list.GetSelectedCount() == 1 );
    DWORD           iList;

    // get index of the selected list item
    iList = m_clistctrl_list.GetNextItem( -1, LVNI_SELECTED );
    ASSERT( iList >= 0 );

    // edit the item
    EditRule( iList );
    }

//---------------------------------------------------------------------------
void CWildWizTwo::OnNew() 
    {
    // declare the editing dialog
    CEditRuleElement    editDlg;

    // fill in its data
    editDlg.m_bool_match_case = TRUE;
    editDlg.m_int_field = CERT_FIELD_SUBJECT;
    editDlg.m_sz_subfield = "O";

    editDlg.m_sz_criteria.LoadString( IDS_WILDSTRING );

    // run the dialog
    if ( editDlg.DoModal() == IDOK )
        {
        // get the index for adding to the end of the list
        int iEnd = m_clistctrl_list.GetItemCount();

        // Start with the cert field
        CERT_FIELD_ID id = (CERT_FIELD_ID)editDlg.m_int_field;
        CString sz = MapIdToField( id );
        int i = m_clistctrl_list.InsertItem( iEnd, sz );

        DWORD dw = ( (editDlg.m_bool_match_case << 16) | id);
        m_clistctrl_list.SetItemData( i, dw );
//      m_clistctrl_list.SetItemData( i, id );
        m_clistctrl_list.SetItemText( i, COL_SUB_FIELD, editDlg.m_sz_subfield );
        m_clistctrl_list.SetItemText( i, COL_MATCH_CRITERIA, editDlg.m_sz_criteria );

        // we can now apply
        SetModified();
        }
    }

//---------------------------------------------------------------------------
void CWildWizTwo::OnDblclkList(NMHDR* pNMHDR, LRESULT* pResult) 
    {
    *pResult = 0;
    // if something in the list was double clicked, edit it
    if ( m_clistctrl_list.GetSelectedCount() > 0 )
        OnEdit();
    }

//---------------------------------------------------------------------------
void CWildWizTwo::OnItemchangedList(NMHDR* pNMHDR, LRESULT* pResult) 
    {
    NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;
    *pResult = 0;

    // enable the correct items
    EnableDependantButtons();
    }

//---------------------------------------------------------------------------
BOOL CWildWizTwo::OnSetActive() 
    {
    // if this is a wizard, gray out the back button
    if ( m_fIsWizard )
        m_pPropSheet->SetWizardButtons( PSWIZB_BACK | PSWIZB_NEXT );
    return CPropertyPage::OnSetActive();
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\certobj\certobj.cpp ===
// CertObj.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To merge the proxy/stub code into the object DLL, add the file 
//      dlldatax.c to the project.  Make sure precompiled headers 
//      are turned off for this file, and add _MERGE_PROXYSTUB to the 
//      defines for the project.  
//
//      If you are not running WinNT4.0 or Win95 with DCOM, then you
//      need to remove the following define from dlldatax.c
//      #define _WIN32_WINNT 0x0400
//
//      Further, if you are running MIDL without /Oicf switch, you also 
//      need to remove the following define from dlldatax.c.
//      #define USE_STUBLESS_PROXY
//
//      Modify the custom build rule for CertObj.idl by adding the following 
//      files to the Outputs.
//          CertObj_p.c
//          dlldata.c
//      To build a separate proxy/stub DLL, 
//      run nmake -f CertObjps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "dlldatax.h"
#include "common.h"
#include "CertObj.h"
#include "CertObj_i.c"
#include "IISCertObj.h"
#include "certlog.h"
#include "dcomperm.h"

#ifdef _MERGE_PROXYSTUB
    extern "C" HINSTANCE hProxyDll;
#endif

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_IISCertObj, CIISCertObj)
END_OBJECT_MAP()


/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    lpReserved;
#ifdef _MERGE_PROXYSTUB
    if (!PrxDllMain(hInstance, dwReason, lpReserved))
        return FALSE;
#endif
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance, &LIBID_CERTOBJLib);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
#ifdef _MERGE_PROXYSTUB
    if (PrxDllCanUnloadNow() != S_OK)
        return S_FALSE;
#endif
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
#ifdef _MERGE_PROXYSTUB
    if (PrxDllGetClassObject(rclsid, riid, ppv) == S_OK)
        return S_OK;
#endif
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    HRESULT hRes = E_FAIL;

#ifdef _MERGE_PROXYSTUB
    hRes = PrxDllRegisterServer();
    if (FAILED(hRes))
        return hRes;
#endif
    if (RunningAsAdministrator())
    {
        // Add the event log entry
        EventlogRegistryInstall();

        // registers object, typelib and all interfaces in typelib
        hRes = _Module.RegisterServer(TRUE);
        if (SUCCEEDED(hRes))
        {
            if (ERROR_SUCCESS != ChangeAppIDLaunchACL(TEXT("{62B8CCBE-5A45-4372-8C4A-6A87DD3EDD60}"),TEXT("Administrators"),TRUE,TRUE))
            {
                _Module.UnregisterServer(TRUE);
                hRes = E_FAIL;
            }
            else
            {
                if (ERROR_SUCCESS != ChangeAppIDAccessACL(TEXT("{62B8CCBE-5A45-4372-8C4A-6A87DD3EDD60}"),TEXT("Administrators"),TRUE,TRUE))
                {
                    _Module.UnregisterServer(TRUE);
                    hRes = E_FAIL;
                }
                else
                {
                    hRes = S_OK;
                }
            }
        }
    }
    else
    {
        hRes = E_FAIL;
    }
   
    return hRes;
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    HRESULT hRes = E_FAIL;

#ifdef _MERGE_PROXYSTUB
    PrxDllUnregisterServer();
#endif
    if (RunningAsAdministrator())
    {
        EventlogRegistryUnInstall();
        ChangeAppIDLaunchACL(TEXT("{62B8CCBE-5A45-4372-8C4A-6A87DD3EDD60}"),TEXT("Administrators"),FALSE,FALSE);
        ChangeAppIDLaunchACL(TEXT("{62B8CCBE-5A45-4372-8C4A-6A87DD3EDD60}"),TEXT("everyone"),FALSE,FALSE);
        ChangeAppIDAccessACL(TEXT("{62B8CCBE-5A45-4372-8C4A-6A87DD3EDD60}"),TEXT("Administrators"),FALSE,FALSE);
        ChangeAppIDAccessACL(TEXT("{62B8CCBE-5A45-4372-8C4A-6A87DD3EDD60}"),TEXT("everyone"),FALSE,FALSE);
        hRes = _Module.UnregisterServer(TRUE);
    }
    else
    {
        hRes = E_FAIL;
    }
    return hRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\certobj\certutil.cpp ===
#include "stdafx.h"
#include "CertObj.h"
#include "common.h"

//////////////////////////////////////////////////////////////////

CString ReturnGoodMetabasePath(CString csInstanceName)
{
    CString key_path_lm = _T("");
    CString key_path = _T("");
    // csInstanceName will come in looking like
    // w3svc/1
    // or /lm/w3svc/1
    //
    // we want to it to go out as /lm/w3svc/1
    key_path_lm = SZ_MBN_SEP_STR SZ_MBN_MACHINE SZ_MBN_SEP_STR;// SZ_MBN_WEB SZ_MBN_SEP_STR;

    if (csInstanceName.GetLength() >= 4)
    {
        if (csInstanceName.Left(4) == key_path_lm)
        {
            key_path = csInstanceName;
        }
        else
        {
            key_path_lm = SZ_MBN_MACHINE SZ_MBN_SEP_STR;
            if (csInstanceName.Left(3) == key_path_lm)
            {
                key_path = csInstanceName;
            }
            else
            {
                key_path = key_path_lm;
                key_path += csInstanceName;
            }
        }
    }
    else
    {
        key_path = key_path_lm;
        key_path += csInstanceName;
    }

    return key_path;
}


HRESULT ShutdownSSL(CString& server_name)
{
    CComAuthInfo auth;
    CString str = server_name;
    str += _T("/root");
    CMetaKey key(&auth, str,
    METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE);
    DWORD dwSslAccess;

    if (!key.Succeeded())
    {
        return key.QueryResult();
    }

    if (SUCCEEDED(key.QueryValue(MD_SSL_ACCESS_PERM, dwSslAccess)) && dwSslAccess > 0)
    {
        key.SetValue(MD_SSL_ACCESS_PERM, 0);
    }

    // Now we need to remove SSL setting from any virtual directory below
    CError err;
    CStringListEx data_paths;
    DWORD dwMDIdentifier, dwMDAttributes, dwMDUserType,dwMDDataType;

    VERIFY(CMetaKey::GetMDFieldDef(MD_SSL_ACCESS_PERM, dwMDIdentifier, dwMDAttributes, dwMDUserType,dwMDDataType));

    err = key.GetDataPaths( data_paths,dwMDIdentifier,dwMDDataType);
    if (err.Succeeded() && !data_paths.empty())
    {
        CStringListEx::iterator it = data_paths.begin();
        while (it != data_paths.end())
        {
            CString& str = (*it++);
            if (SUCCEEDED(key.QueryValue(MD_SSL_ACCESS_PERM, dwSslAccess, NULL, str)) && dwSslAccess > 0)
            {
                key.SetValue(MD_SSL_ACCESS_PERM, 0, NULL, str);
            }
        }
    }
    return key.QueryResult();
}

BOOL AddChainToStore(HCERTSTORE hCertStore,PCCERT_CONTEXT pCertContext,DWORD cStores,HCERTSTORE * rghStores,BOOL fDontAddRootCert,CERT_TRUST_STATUS * pChainTrustStatus)
{
    DWORD	i;
    CERT_CHAIN_ENGINE_CONFIG CertChainEngineConfig;
    HCERTCHAINENGINE hCertChainEngine = NULL;
    PCCERT_CHAIN_CONTEXT pCertChainContext = NULL;
    CERT_CHAIN_PARA CertChainPara;
    BOOL fRet = TRUE;
    PCCERT_CONTEXT pTempCertContext = NULL;

    //
    // create a new chain engine, then build the chain
    //
    memset(&CertChainEngineConfig, 0, sizeof(CertChainEngineConfig));
    CertChainEngineConfig.cbSize = sizeof(CertChainEngineConfig);
    CertChainEngineConfig.cAdditionalStore = cStores;
    CertChainEngineConfig.rghAdditionalStore = rghStores;
    CertChainEngineConfig.dwFlags = CERT_CHAIN_USE_LOCAL_MACHINE_STORE;

    if (!CertCreateCertificateChainEngine(&CertChainEngineConfig, &hCertChainEngine))
    {
        goto AddChainToStore_Error;
    }

	memset(&CertChainPara, 0, sizeof(CertChainPara));
	CertChainPara.cbSize = sizeof(CertChainPara);

	if (!CertGetCertificateChain(hCertChainEngine,pCertContext,NULL,NULL,&CertChainPara,0,NULL,&pCertChainContext))
	{
		goto AddChainToStore_Error;
	}

    //
    // make sure there is atleast 1 simple chain
    //
    if (pCertChainContext->cChain != 0)
	{
		i = 0;
		while (i < pCertChainContext->rgpChain[0]->cElement)
		{
			//
			// if we are supposed to skip the root cert,
			// and we are on the root cert, then continue
			//
			if (fDontAddRootCert && (pCertChainContext->rgpChain[0]->rgpElement[i]->TrustStatus.dwInfoStatus & CERT_TRUST_IS_SELF_SIGNED))
			{
                i++;
                continue;
			}

			CertAddCertificateContextToStore(hCertStore,pCertChainContext->rgpChain[0]->rgpElement[i]->pCertContext,CERT_STORE_ADD_REPLACE_EXISTING,&pTempCertContext);
            //
            // remove any private key property the certcontext may have on it.
            //
            if (pTempCertContext)
            {
                CertSetCertificateContextProperty(pTempCertContext, CERT_KEY_PROV_INFO_PROP_ID, 0, NULL);
                CertFreeCertificateContext(pTempCertContext);
            }

			i++;
		}
	}
	else
	{
		goto AddChainToStore_Error;
	}

	//
	// if the caller wants the status, then set it
	//
	if (pChainTrustStatus != NULL)
	{
		pChainTrustStatus->dwErrorStatus = pCertChainContext->TrustStatus.dwErrorStatus;
		pChainTrustStatus->dwInfoStatus = pCertChainContext->TrustStatus.dwInfoStatus;
	}

	
AddChainToStore_Exit:
	if (pCertChainContext != NULL)
	{
		CertFreeCertificateChain(pCertChainContext);
	}

	if (hCertChainEngine != NULL)
	{
		CertFreeCertificateChainEngine(hCertChainEngine);
	}
	return fRet;

AddChainToStore_Error:
	fRet = FALSE;
	goto AddChainToStore_Exit;
}


// This function is borrowed from trustapi.cpp
BOOL TrustIsCertificateSelfSigned(PCCERT_CONTEXT pContext,DWORD dwEncoding, DWORD dwFlags)
{
    if (!(pContext) || (dwFlags != 0))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    if (!(CertCompareCertificateName(dwEncoding,&pContext->pCertInfo->Issuer,&pContext->pCertInfo->Subject)))
    {
        return(FALSE);
    }

    DWORD   dwFlag;

    dwFlag = CERT_STORE_SIGNATURE_FLAG;

    if (!(CertVerifySubjectCertificateContext(pContext, pContext, &dwFlag)) || 
        (dwFlag & CERT_STORE_SIGNATURE_FLAG))
    {
        return(FALSE);
    }

    return(TRUE);
}


HRESULT UninstallCert(CString csInstanceName)
{
    CComAuthInfo auth;
    CString key_path = ReturnGoodMetabasePath(csInstanceName);
    CMetaKey key(&auth, key_path, METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE);
    if (key.Succeeded())
    {
        CString store_name;
        key.QueryValue(MD_SSL_CERT_STORE_NAME, store_name);
        if (SUCCEEDED(key.DeleteValue(MD_SSL_CERT_HASH)))
        {
            key.DeleteValue(MD_SSL_CERT_STORE_NAME);
        }
    }
    return key.QueryResult();
}

CERT_CONTEXT * GetInstalledCert(HRESULT * phResult, CString csKeyPath)
{
    //	ATLASSERT(GetEnroll() != NULL);
    ATLASSERT(phResult != NULL);
    CERT_CONTEXT * pCert = NULL;
    *phResult = S_OK;
    CComAuthInfo auth;
    CString key_path = ReturnGoodMetabasePath(csKeyPath);

    CMetaKey key(&auth, key_path, METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE);
    if (key.Succeeded())
    {
        CString store_name;
        CBlob hash;
        if (SUCCEEDED(*phResult = key.QueryValue(MD_SSL_CERT_STORE_NAME, store_name)) &&
            SUCCEEDED(*phResult = key.QueryValue(MD_SSL_CERT_HASH, hash)))
        {
            // Open MY store. We assume that store type and flags
            // cannot be changed between installation and unistallation
            // of the sertificate.
            HCERTSTORE hStore = CertOpenStore(CERT_STORE_PROV_SYSTEM,PKCS_7_ASN_ENCODING | X509_ASN_ENCODING,NULL,CERT_SYSTEM_STORE_LOCAL_MACHINE,store_name);
            ASSERT(hStore != NULL);
            if (hStore != NULL)
            {
                // Now we need to find cert by hash
                CRYPT_HASH_BLOB crypt_hash;
                crypt_hash.cbData = hash.GetSize();
                crypt_hash.pbData = hash.GetData();
                pCert = (CERT_CONTEXT *)CertFindCertificateInStore(hStore,X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,0,CERT_FIND_HASH,(LPVOID)&crypt_hash,NULL);
                if (pCert == NULL)
                {
                    *phResult = HRESULT_FROM_WIN32(GetLastError());
                }
                VERIFY(CertCloseStore(hStore, 0));
            }
            else
            {
                *phResult = HRESULT_FROM_WIN32(GetLastError());
            }
        }
    }
    else
    {
        *phResult = key.QueryResult();
    }
    return pCert;
}


CERT_CONTEXT * GetInstalledCert(HRESULT * phResult,DWORD cbHashBlob, char * pHashBlob)
{
    ATLASSERT(phResult != NULL);
    CERT_CONTEXT * pCert = NULL;
    *phResult = S_OK;
    CString store_name = _T("MY");

    HCERTSTORE hStore = CertOpenStore(CERT_STORE_PROV_SYSTEM,PKCS_7_ASN_ENCODING | X509_ASN_ENCODING,NULL,CERT_SYSTEM_STORE_LOCAL_MACHINE,store_name);
    ASSERT(hStore != NULL);
    if (hStore != NULL)
    {
        // Now we need to find cert by hash
        CRYPT_HASH_BLOB crypt_hash;
        crypt_hash.cbData = cbHashBlob;
        crypt_hash.pbData = (BYTE *) pHashBlob;
        pCert = (CERT_CONTEXT *)CertFindCertificateInStore(hStore,X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,0,CERT_FIND_HASH,(LPVOID)&crypt_hash,NULL);
        if (pCert == NULL)
        {
            *phResult = HRESULT_FROM_WIN32(GetLastError());
        }
        VERIFY(CertCloseStore(hStore, 0));
    }
    else
    {
        *phResult = HRESULT_FROM_WIN32(GetLastError());
    }

    return pCert;
}



/*
	InstallHashToMetabase

	Function writes hash array to metabase. After that IIS 
	could use certificate with that hash from MY store.
	Function expects server_name in format lm\w3svc\<number>,
	i.e. from root node down to virtual server
*/
BOOL InstallHashToMetabase(CRYPT_HASH_BLOB * pHash,BSTR InstanceName,HRESULT * phResult)
{
    BOOL bRes = FALSE;
    CComAuthInfo auth;
    CString key_path = ReturnGoodMetabasePath(InstanceName);
    CMetaKey key(&auth, key_path, METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE);
	if (key.Succeeded())
	{
		CBlob blob;
		blob.SetValue(pHash->cbData, pHash->pbData, TRUE);
		bRes = SUCCEEDED(*phResult = key.SetValue(MD_SSL_CERT_HASH, blob))
			&& SUCCEEDED(*phResult = key.SetValue(MD_SSL_CERT_STORE_NAME, CString(L"MY")));
	}
	else
	{
        *phResult = key.QueryResult();
	}
	return bRes;
}


HRESULT HereIsBinaryGimmieVtArray(DWORD cbBinaryBufferSize,char *pbBinaryBuffer,VARIANT * lpVarDestObject,BOOL bReturnBinaryAsVT_VARIANT)
{
    HRESULT hr = S_OK;
    SAFEARRAY *aList = NULL;
    SAFEARRAYBOUND aBound;
    CHAR HUGEP *pArray = NULL;

    aBound.lLbound = 0;
    aBound.cElements = cbBinaryBufferSize;

    if (bReturnBinaryAsVT_VARIANT)
    {
       aList = SafeArrayCreate( VT_VARIANT, 1, &aBound );
    }
    else
    {
       aList = SafeArrayCreate( VT_UI1, 1, &aBound );
    }

    aList = SafeArrayCreate( VT_UI1, 1, &aBound );
    if ( aList == NULL )
    {
        hr = E_OUTOFMEMORY;
        goto HereIsBinaryGimmieVtArray_Exit;
    }

    hr = SafeArrayAccessData( aList, (void HUGEP * FAR *) &pArray );
    if (FAILED(hr))
    {
        goto HereIsBinaryGimmieVtArray_Exit;
    }

    memcpy( pArray, pbBinaryBuffer, aBound.cElements );
    SafeArrayUnaccessData( aList );

    if (bReturnBinaryAsVT_VARIANT)
    {
       V_VT(lpVarDestObject) = VT_ARRAY | VT_VARIANT;
    }
    else
    {
       V_VT(lpVarDestObject) = VT_ARRAY | VT_UI1;
    }

    V_ARRAY(lpVarDestObject) = aList;

    return hr;

HereIsBinaryGimmieVtArray_Exit:
    if (aList)
        {SafeArrayDestroy( aList );}

    return hr;
}


HRESULT
HereIsVtArrayGimmieBinary(
    VARIANT * lpVarSrcObject,
    DWORD * cbBinaryBufferSize,
    char **pbBinaryBuffer,
    BOOL bReturnBinaryAsVT_VARIANT
    )
{
    HRESULT hr = S_OK;
    LONG dwSLBound = 0;
    LONG dwSUBound = 0;
    CHAR HUGEP *pArray = NULL;

    if (NULL == cbBinaryBufferSize || NULL == pbBinaryBuffer)
    {
        hr = E_INVALIDARG;
        goto HereIsVtArrayGimmieBinary_Exit;
    }

    if (bReturnBinaryAsVT_VARIANT)
    {
        hr = VariantChangeType(lpVarSrcObject,lpVarSrcObject,0,VT_ARRAY | VT_VARIANT);
    }
    else
    {
        hr = VariantChangeType(lpVarSrcObject,lpVarSrcObject,0,VT_ARRAY | VT_UI1);
    }

    if (FAILED(hr)) 
    {
        if (hr != E_OUTOFMEMORY) 
        {
            hr = OLE_E_CANTCONVERT;
        }
        goto HereIsVtArrayGimmieBinary_Exit;
    }

    if (bReturnBinaryAsVT_VARIANT)
    {
        if( lpVarSrcObject->vt != (VT_ARRAY | VT_VARIANT)) 
        {
            hr = OLE_E_CANTCONVERT;
            goto HereIsVtArrayGimmieBinary_Exit;
        }
    }
    else
    {
        if( lpVarSrcObject->vt != (VT_ARRAY | VT_UI1)) 
        {
            hr = OLE_E_CANTCONVERT;
            goto HereIsVtArrayGimmieBinary_Exit;
        }
    }

    hr = SafeArrayGetLBound(V_ARRAY(lpVarSrcObject),1,(long FAR *) &dwSLBound );
    if (FAILED(hr))
        {goto HereIsVtArrayGimmieBinary_Exit;}

    hr = SafeArrayGetUBound(V_ARRAY(lpVarSrcObject),1,(long FAR *) &dwSUBound );
    if (FAILED(hr))
        {goto HereIsVtArrayGimmieBinary_Exit;}

    //*pbBinaryBuffer = (LPBYTE) AllocADsMem(dwSUBound - dwSLBound + 1);
    *pbBinaryBuffer = (char *) ::CoTaskMemAlloc(dwSUBound - dwSLBound + 1);
    if (*pbBinaryBuffer == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto HereIsVtArrayGimmieBinary_Exit;
    }

    *cbBinaryBufferSize = dwSUBound - dwSLBound + 1;

    hr = SafeArrayAccessData( V_ARRAY(lpVarSrcObject),(void HUGEP * FAR *) &pArray );
    if (FAILED(hr))
        {goto HereIsVtArrayGimmieBinary_Exit;}

    memcpy(*pbBinaryBuffer,pArray,dwSUBound-dwSLBound+1);
    SafeArrayUnaccessData( V_ARRAY(lpVarSrcObject) );

HereIsVtArrayGimmieBinary_Exit:
    return hr;
}

BOOL IsCertExportable(PCCERT_CONTEXT pCertContext)
{
    HCRYPTPROV  hCryptProv = NULL;
    DWORD       dwKeySpec = 0;
    BOOL        fCallerFreeProv = FALSE;
    BOOL        fReturn = FALSE;
    HCRYPTKEY   hKey = NULL;
    DWORD       dwPermissions = 0;
    DWORD       dwSize = 0;

    if (!pCertContext)
    {
        fReturn = FALSE;
        goto IsCertExportable_Exit;
    }

    //
    // first get the private key context
    //
    if (!CryptAcquireCertificatePrivateKey(
            pCertContext,
            CRYPT_ACQUIRE_USE_PROV_INFO_FLAG | CRYPT_ACQUIRE_COMPARE_KEY_FLAG,
            NULL,
            &hCryptProv,
            &dwKeySpec,
            &fCallerFreeProv))
    {
        fReturn = FALSE;
        goto IsCertExportable_Exit;
    }

    //
    // get the handle to the key
    //
    if (!CryptGetUserKey(hCryptProv, dwKeySpec, &hKey))
    {
        fReturn = FALSE;
        goto IsCertExportable_Exit;
    }

    //
    // finally, get the permissions on the key and check if it is exportable
    //
    dwSize = sizeof(dwPermissions);
    if (!CryptGetKeyParam(hKey, KP_PERMISSIONS, (PBYTE)&dwPermissions, &dwSize, 0))
    {
        fReturn = FALSE;
        goto IsCertExportable_Exit;
    }

    fReturn = (dwPermissions & CRYPT_EXPORT) ? TRUE : FALSE;

IsCertExportable_Exit:
    if (hKey != NULL){CryptDestroyKey(hKey);}
    if (fCallerFreeProv){CryptReleaseContext(hCryptProv, 0);}
    return fReturn;
}


BOOL FormatDateString(LPWSTR * pszReturn, FILETIME ft, BOOL fIncludeTime, BOOL fLongFormat)
{
   int cch;
   int cch2;
   SYSTEMTIME st;
   FILETIME localTime;
   LPWSTR psz = NULL;
    
   if (!FileTimeToLocalFileTime(&ft, &localTime))
   {
		return FALSE;
   }
    
   if (!FileTimeToSystemTime(&localTime, &st)) 
   {
		//
      // if the conversion to local time failed, then just use the original time
      //
      if (!FileTimeToSystemTime(&ft, &st)) 
      {
			return FALSE;
      }
   }

   cch = (GetTimeFormat(LOCALE_SYSTEM_DEFAULT, 0, &st, NULL, NULL, 0) +
          GetDateFormat(LOCALE_SYSTEM_DEFAULT, fLongFormat ? DATE_LONGDATE : 0, &st, NULL, NULL, 0) + 5);

   if (NULL == (psz = (LPWSTR) malloc((cch+5) * sizeof(WCHAR))))
   {
		return FALSE;
   }
    
   cch2 = GetDateFormat(LOCALE_SYSTEM_DEFAULT, fLongFormat ? DATE_LONGDATE : 0, &st, NULL, psz, cch);
   if (fIncludeTime)
   {
      psz[cch2-1] = ' ';
      GetTimeFormat(LOCALE_SYSTEM_DEFAULT, TIME_NOSECONDS, &st, NULL, &psz[cch2], cch-cch2);
   }

   if (psz)
   {
      *pszReturn = psz;
      return TRUE;
   }
   else
   {
      return FALSE;
   }
}


const WCHAR     RgwchHex[] = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'};
BOOL FormatMemBufToString(LPWSTR *ppString, LPBYTE pbData, DWORD cbData)
{   
    DWORD   i = 0;
    LPBYTE  pb;
    DWORD   numCharsInserted = 0;

    //
    // calculate the size needed
    //
    pb = pbData;
    while (pb <= &(pbData[cbData-1]))
    {   
        if (numCharsInserted == 4)
        {
            i += sizeof(WCHAR);
            numCharsInserted = 0;
        }
        else
        {
            i += 2 * sizeof(WCHAR);
            pb++;
            numCharsInserted += 2;  
        }
    }

    if (NULL == (*ppString = (LPWSTR) malloc(i+sizeof(WCHAR))))
    {
        return FALSE;
    }

    //
    // copy to the buffer
    //
    i = 0;
    numCharsInserted = 0;
    pb = pbData;
    while (pb <= &(pbData[cbData-1]))
    {   
        if (numCharsInserted == 4)
        {
            (*ppString)[i++] = L' ';
            numCharsInserted = 0;
        }
        else
        {
            (*ppString)[i++] = RgwchHex[(*pb & 0xf0) >> 4];
            (*ppString)[i++] = RgwchHex[*pb & 0x0f];
            pb++;
            numCharsInserted += 2;  
        }
    }
    (*ppString)[i] = 0;
    return TRUE;
}



BOOL MyGetOIDInfo(LPWSTR string, DWORD stringSize, LPSTR pszObjId)
{   
    /*
    PCCRYPT_OID_INFO pOIDInfo;
    pOIDInfo = CryptFindOIDInfo(CRYPT_OID_INFO_OID_KEY, pszObjId, 0);
    if (pOIDInfo != NULL)
    {
        if ((DWORD)wcslen(pOIDInfo->pwszName)+1 <= stringSize)
        {
            wcscpy(string, pOIDInfo->pwszName);
        }
        else
        {
            return FALSE;
        }
    }
    else
    {
    */
        return (MultiByteToWideChar(CP_ACP, 0, pszObjId, -1, string, stringSize) != 0);
    /*
    }
    return TRUE;
    */
}


#define ARRAYSIZE(x) (sizeof(x)/sizeof(x[0]))
#define STRING_ALLOCATION_SIZE 128
BOOL GetCertDescription(PCCERT_CONTEXT pCert, LPWSTR *ppString, DWORD * cbReturn, BOOL fMultiline)
{
    CERT_NAME_INFO  *pNameInfo;
    DWORD           cbNameInfo;
    WCHAR           szText[256];
    LPWSTR          pwszText;
    int             i,j;
    DWORD           numChars = 1; // 1 for the terminating 0
    DWORD           numAllocations = 1;
    void            *pTemp;

    //
    // decode the dnname into a CERT_NAME_INFO struct
    //
    if (!CryptDecodeObject(
                X509_ASN_ENCODING,
                X509_UNICODE_NAME,
                pCert->pCertInfo->Subject.pbData,
                pCert->pCertInfo->Subject.cbData,
                0,
                NULL,
                &cbNameInfo))
    {
        return FALSE;
    }
    if (NULL == (pNameInfo = (CERT_NAME_INFO *) malloc(cbNameInfo)))
    {
        return FALSE;
    }
    if (!CryptDecodeObject(
                X509_ASN_ENCODING,
                X509_UNICODE_NAME,
                pCert->pCertInfo->Subject.pbData,
                pCert->pCertInfo->Subject.cbData,
                0,
                pNameInfo,
                &cbNameInfo))
    {
        free (pNameInfo);
        return FALSE;
    }

    //
    // allocate an initial buffer for the DN name string, then if it grows larger
    // than the initial amount just grow as needed
    //
    *ppString = (LPWSTR) malloc(STRING_ALLOCATION_SIZE * sizeof(WCHAR));
    if (*ppString == NULL)
    {
        free (pNameInfo);
        return FALSE;
    }

    (*ppString)[0] = 0;


    //
    // loop for each rdn and add it to the string
    //
    for (i=pNameInfo->cRDN-1; i>=0; i--)
    {
        // if this is not the first iteration, then add a eol or a ", "
        if (i != (int)pNameInfo->cRDN-1)
        {
            if (numChars+2 >= (numAllocations * STRING_ALLOCATION_SIZE))
            {
                pTemp = realloc(*ppString, ++numAllocations * STRING_ALLOCATION_SIZE * sizeof(WCHAR));
                if (pTemp == NULL)
                {
                    free (pNameInfo);
                    free (*ppString);
                    return FALSE;
                }
                *ppString = (LPWSTR) pTemp;
            }
            
            if (fMultiline)
                wcscat(*ppString, L"\n");
            else
                wcscat(*ppString, L", ");

            numChars += 2;
        }

        for (j=pNameInfo->rgRDN[i].cRDNAttr-1; j>=0; j--)
        {
            // if this is not the first iteration, then add a eol or a ", "
            if (j != (int)pNameInfo->rgRDN[i].cRDNAttr-1)
            {
                if (numChars+2 >= (numAllocations * STRING_ALLOCATION_SIZE))
                {
                    pTemp = realloc(*ppString, ++numAllocations * STRING_ALLOCATION_SIZE * sizeof(WCHAR));
                    if (pTemp == NULL)
                    {
                        free (pNameInfo);
                        free (*ppString);
                        return FALSE;
                    }
                    *ppString = (LPWSTR) pTemp;
                }
                
                if (fMultiline)
                    wcscat(*ppString, L"\n");
                else
                    wcscat(*ppString, L", ");

                numChars += 2;  
            }
            
            //
            // add the field name to the string if it is Multiline display
            //

            if (fMultiline)
            {
                if (!MyGetOIDInfo(szText, ARRAYSIZE(szText), pNameInfo->rgRDN[i].rgRDNAttr[j].pszObjId))
                {
                    free (pNameInfo);
                    return FALSE;
                }

                if ((numChars + wcslen(szText) + 3) >= (numAllocations * STRING_ALLOCATION_SIZE))
                {
                    // increment the number of allocation blocks until it is large enough
                    while ((numChars + wcslen(szText) + 3) >= (++numAllocations * STRING_ALLOCATION_SIZE));

                    pTemp = realloc(*ppString, numAllocations * STRING_ALLOCATION_SIZE * sizeof(WCHAR));
                    if (pTemp == NULL)
                    {
                        free (pNameInfo);
                        free (*ppString);
                        return FALSE;
                    }
                    *ppString = (LPWSTR) pTemp;
                }

                numChars += wcslen(szText) + 1;
                wcscat(*ppString, szText);
                wcscat(*ppString, L"=");  // delimiter
            }

            //
            // add the value to the string
            //
            if (CERT_RDN_ENCODED_BLOB == pNameInfo->rgRDN[i].rgRDNAttr[j].dwValueType ||
                        CERT_RDN_OCTET_STRING == pNameInfo->rgRDN[i].rgRDNAttr[j].dwValueType)
            {
                // translate the buffer to a text string and display it that way
                if (FormatMemBufToString(
                        &pwszText, 
                        pNameInfo->rgRDN[i].rgRDNAttr[j].Value.pbData,
                        pNameInfo->rgRDN[i].rgRDNAttr[j].Value.cbData))
                {
                    if ((numChars + wcslen(pwszText)) >= (numAllocations * STRING_ALLOCATION_SIZE))
                    {
                        // increment the number of allocation blocks until it is large enough
                        while ((numChars + wcslen(pwszText)) >= (++numAllocations * STRING_ALLOCATION_SIZE));

                        pTemp = realloc(*ppString, numAllocations * STRING_ALLOCATION_SIZE * sizeof(WCHAR));
                        if (pTemp == NULL)
                        {
                            free (pwszText);
                            free (pNameInfo);
                            free (*ppString);
                            return FALSE;
                        }
                        *ppString = (LPWSTR) pTemp;
                    }
                    
                    wcscat(*ppString, pwszText);
                    numChars += wcslen(pwszText);

                    free (pwszText);
                }
            }
            else 
            {
                // buffer is already a string so just copy it
                
                if ((numChars + (pNameInfo->rgRDN[i].rgRDNAttr[j].Value.cbData/sizeof(WCHAR))) 
                        >= (numAllocations * STRING_ALLOCATION_SIZE))
                {
                    // increment the number of allocation blocks until it is large enough
                    while ((numChars + (pNameInfo->rgRDN[i].rgRDNAttr[j].Value.cbData/sizeof(WCHAR))) 
                            >= (++numAllocations * STRING_ALLOCATION_SIZE));

                    pTemp = realloc(*ppString, numAllocations * STRING_ALLOCATION_SIZE * sizeof(WCHAR));
                    if (pTemp == NULL)
                    {
                        free (pNameInfo);
                        free (*ppString);
                        return FALSE;
                    }
                    *ppString = (LPWSTR) pTemp;
                }

                wcscat(*ppString, (LPWSTR) pNameInfo->rgRDN[i].rgRDNAttr[j].Value.pbData);
                numChars += (pNameInfo->rgRDN[i].rgRDNAttr[j].Value.cbData/sizeof(WCHAR));
            }
        }
    }


    {

        // issued to
        LPWSTR pwName = NULL;
	    DWORD cchName = CertGetNameString(pCert, CERT_NAME_SIMPLE_DISPLAY_TYPE, CERT_NAME_ISSUER_FLAG, NULL, NULL, 0);
	    if (cchName > 1 && (NULL != ( pwName = (LPWSTR) malloc (cchName * sizeof(WCHAR) ))))
	    {
            BOOL bRes = FALSE;
		    bRes = (1 != CertGetNameString(pCert, CERT_NAME_SIMPLE_DISPLAY_TYPE, CERT_NAME_ISSUER_FLAG, NULL, pwName, cchName));
            if (bRes)
            {
                wcscat(*ppString, (LPWSTR) L"\n");
                numChars += 2;
                // append it on to the string.
                //#define CERT_INFO_ISSUER_FLAG                       4
                wcscat(*ppString, (LPWSTR) L"4=");
                numChars += 2;
                // append it on to the string.
                wcscat(*ppString, (LPWSTR) pwName);
                numChars += (cchName);
            }
            if (pwName) {free(pwName);pwName=NULL;}
	    }

	    // expiration date
	    if (FormatDateString(&pwName, pCert->pCertInfo->NotAfter, FALSE, FALSE))
	    {
            wcscat(*ppString, (LPWSTR) L"\n");
            numChars += 2;
            // append it on to the string.
            //#define CERT_INFO_NOT_AFTER_FLAG                    6
            wcscat(*ppString, (LPWSTR) L"6=");
            numChars += 2;
            // append it on to the string.
            wcscat(*ppString, (LPWSTR) pwName);
            numChars += wcslen(pwName);
            if (pwName) {free(pwName);pwName = NULL;}
	    }
    }

    *cbReturn = numChars;
    free (pNameInfo);
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\certobj\certobjlog.cpp ===
#include "stdafx.h"
#include "CertObj.h"
#include "common.h"
#include "certobjlog.h"

HANDLE g_hEventLog = NULL;

// #define EVENTLOG_SUCCESS                0x0000
// #define EVENTLOG_ERROR_TYPE             0x0001
// #define EVENTLOG_WARNING_TYPE           0x0002
// #define EVENTLOG_INFORMATION_TYPE       0x0004
// #define EVENTLOG_AUDIT_SUCCESS          0x0008
// #define EVENTLOG_AUDIT_FAILURE          0x0010

void EventlogReportEvent
(
    WORD wType, 
    DWORD dwEventID, 
    LPCTSTR pFormat, 
    ...
)
{
    TCHAR    chMsg[256];
    HANDLE  hEventSource;
    LPTSTR  lpszStrings[1];
    va_list	pArg;

    va_start(pArg, pFormat);
    _vstprintf(chMsg, pFormat, pArg);
    va_end(pArg);

    lpszStrings[0] = chMsg;

    if (g_hEventLog != NULL)
    {
        ReportEvent(g_hEventLog, wType, 0, dwEventID, NULL, 1, 0, (LPCTSTR*) &lpszStrings[0], NULL);
    }
}

BOOL EventlogRegistryInstall(void)
{
    HKEY    hKey;
    int     err;
    DWORD   disp;

    //
    // Create registry entries, whether event logging is currently
    // enabled or not.
    //
    err = RegCreateKeyEx(   HKEY_LOCAL_MACHINE,
                            TEXT("System\\CurrentControlSet\\Services\\EventLog\\System\\CertObj"),
                            0,
                            TEXT(""),
                            REG_OPTION_NON_VOLATILE,
                            KEY_WRITE,
                            NULL,
                            &hKey,
                            &disp);
    if (err)
    {
        return(FALSE);
    }

    if (disp == REG_CREATED_NEW_KEY)
    {
        RegSetValueEx(  hKey,
                        TEXT("EventMessageFile"),
                        0,
                        REG_EXPAND_SZ,
                        (PBYTE) TEXT("%SystemRoot%\\system32\\inetsrv\\certobj.dll"),
                        sizeof(TEXT("%SystemRoot%\\system32\\inetsrv\\certobj.dll")));

        // disp = 7;
        disp = EVENTLOG_ERROR_TYPE          |
                    EVENTLOG_WARNING_TYPE   |
                    EVENTLOG_INFORMATION_TYPE ;
        
        RegSetValueEx(  hKey,
                        TEXT("TypesSupported"),
                        0,
                        REG_DWORD,
                        (PBYTE) &disp,
                        sizeof(DWORD) );

        RegFlushKey(hKey);
    }

    RegCloseKey(hKey);

    return(TRUE);
}

void EventlogRegistryUnInstall(void)
{
    HKEY hKey;
    DWORD dwStatus;
    TCHAR szBuf[MAX_PATH*2+1];

    // remove event source out of application and system
    _stprintf(szBuf, _TEXT("SYSTEM\\CurrentControlSet\\Services\\EventLog\\Application"));
    if((dwStatus=RegOpenKeyEx(HKEY_LOCAL_MACHINE, szBuf, 0, KEY_ALL_ACCESS, &hKey)) != ERROR_SUCCESS)
    {
        return;
    }

    RegDeleteKey(hKey, _T("CertObj"));
    RegCloseKey(hKey);

    _stprintf(szBuf, _TEXT("SYSTEM\\CurrentControlSet\\Services\\EventLog\\System"));
    if((dwStatus=RegOpenKeyEx(HKEY_LOCAL_MACHINE, szBuf, 0, KEY_ALL_ACCESS, &hKey)) != ERROR_SUCCESS)
    {
        return;
    }

    RegDeleteKey(hKey, _T("CertObj"));
    RegCloseKey(hKey);

    return;
}

void EventLogInit(void)
{
    g_hEventLog = RegisterEventSource( NULL, L"CertObj" );
    return;
}

void EventLogCleanup(void)
{
    if ( g_hEventLog != NULL )
    {
        DeregisterEventSource( g_hEventLog );
        g_hEventLog = NULL;
    }
    return;
}

void ReportIt(DWORD dwEventID, LPCTSTR szMetabasePath)
{
    if (!g_hEventLog){EventLogInit();}

    switch (dwEventID) 
    {
        case CERTOBJ_CERT_EXPORT_SUCCEED:
            EventlogReportEvent(EVENTLOG_INFORMATION_TYPE, dwEventID, szMetabasePath);
            break;
        case CERTOBJ_CERT_EXPORT_FAILED:
            EventlogReportEvent(EVENTLOG_INFORMATION_TYPE, dwEventID, szMetabasePath);
            break;

        case CERTOBJ_CERT_IMPORT_SUCCEED:
            EventlogReportEvent(EVENTLOG_INFORMATION_TYPE, dwEventID, szMetabasePath);
            break;
        case CERTOBJ_CERT_IMPORT_FAILED:
            EventlogReportEvent(EVENTLOG_INFORMATION_TYPE, dwEventID, szMetabasePath);
            break;

        case CERTOBJ_CERT_IMPORT_CERT_STORE_SUCCEED:
            EventlogReportEvent(EVENTLOG_INFORMATION_TYPE, dwEventID, szMetabasePath);
            break;
        case CERTOBJ_CERT_IMPORT_CERT_STORE_FAILED:
            EventlogReportEvent(EVENTLOG_INFORMATION_TYPE, dwEventID, szMetabasePath);
            break;

        case CERTOBJ_CERT_REMOVE_SUCCEED:
            EventlogReportEvent(EVENTLOG_INFORMATION_TYPE, dwEventID, szMetabasePath);
            break;
        case CERTOBJ_CERT_REMOVE_FAILED:
            EventlogReportEvent(EVENTLOG_INFORMATION_TYPE, dwEventID, szMetabasePath);
            break;

        default:
             break;

    }
    if (g_hEventLog) {EventLogCleanup();}
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\certobj\dlldatax.h ===
#if !defined(AFX_DLLDATAX_H__89EF842D_58E5_4014_9FF4_3C845E2C78F3__INCLUDED_)
#define AFX_DLLDATAX_H__89EF842D_58E5_4014_9FF4_3C845E2C78F3__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifdef _MERGE_PROXYSTUB

extern "C" 
{
BOOL WINAPI PrxDllMain(HINSTANCE hInstance, DWORD dwReason, 
	LPVOID lpReserved);
STDAPI PrxDllCanUnloadNow(void);
STDAPI PrxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv);
STDAPI PrxDllRegisterServer(void);
STDAPI PrxDllUnregisterServer(void);
}

#endif

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DLLDATAX_H__89EF842D_58E5_4014_9FF4_3C845E2C78F3__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\certobj\iiscertobj.cpp ===
// IISCertObj.cpp : Implementation of CIISCertObj
#include "stdafx.h"
#include "common.h"
#include "CertObj.h"
#include "IISCertObj.h"
#include "base64.h"
#include "password.h"
#include "certutil.h"
#include "certobjlog.h"
#include "certlog.h"

#define TEMP_PASSWORD_LENGTH 50

/////////////////////////////////////////////////////////////////////////////
// CIISCertObj
STDMETHODIMP CIISCertObj::put_ServerName(BSTR newVal)
{
    // buffer overflow paranoia, make sure it's less than 255 characters long
    if (wcslen(newVal) > _MAX_PATH){return RPC_S_STRING_TOO_LONG;}

    m_ServerName = newVal;
    return S_OK;
}

STDMETHODIMP CIISCertObj::put_UserName(BSTR newVal)
{
    // buffer overflow paranoia, make sure it's less than 255 characters long
    if (wcslen(newVal) > _MAX_PATH){return RPC_S_STRING_TOO_LONG;}

    m_UserName = newVal;
    return S_OK;
}

STDMETHODIMP CIISCertObj::put_UserPassword(BSTR newVal)
{
    // buffer overflow paranoia, make sure it's less than 255 characters long
    if (wcslen(newVal) > _MAX_PATH){return RPC_S_STRING_TOO_LONG;}

    m_UserPassword = newVal;
	return S_OK;
}

STDMETHODIMP CIISCertObj::put_InstanceName(BSTR newVal)
{
    // buffer overflow paranoia, make sure it's less than 255 characters long
    if (wcslen(newVal) > _MAX_PATH){return RPC_S_STRING_TOO_LONG;}

    m_InstanceName = newVal;
	return S_OK;
}

IIISCertObj * CIISCertObj::GetObject(HRESULT * phr)
{
    IIISCertObj * pObj = NULL;
    pObj = GetObject(phr,m_ServerName,m_UserName,m_UserPassword);
    return pObj;
}

IIISCertObj * CIISCertObj::GetObject(HRESULT * phr,CString csServerName,CString csUserName,CString csUserPassword)
{
    if (csServerName.IsEmpty())
    {
        // object is null, but it's the local machine, so just return back this pointer
        m_pObj = this;
        goto GetObject_Exit;
    }

    // There is a servername specified...
    // check if it's the local machine that was specified!
    if (IsServerLocal(csServerName))
    {
        m_pObj = this;
        goto GetObject_Exit;
    }
    else
    {
        // there is a remote servername specified

        // let's see if the machine has the com object that we want....
        // we are using the user/name password that are in this object
        // so were probably on the local machine
        CComAuthInfo auth(csServerName,csUserName,csUserPassword);
        // RPC_C_AUTHN_LEVEL_DEFAULT       0 
        // RPC_C_AUTHN_LEVEL_NONE          1 
        // RPC_C_AUTHN_LEVEL_CONNECT       2 
        // RPC_C_AUTHN_LEVEL_CALL          3 
        // RPC_C_AUTHN_LEVEL_PKT           4 
        // RPC_C_AUTHN_LEVEL_PKT_INTEGRITY 5 
        // RPC_C_AUTHN_LEVEL_PKT_PRIVACY   6 
        COSERVERINFO * pcsiName = auth.CreateServerInfoStruct(RPC_C_AUTHN_LEVEL_PKT_PRIVACY);
        
        MULTI_QI res[1] = 
        {
            {&__uuidof(IIISCertObj), NULL, 0}
        };

        // Try to instantiante the object on the remote server...
        // with the supplied authentication info (pcsiName)
        //#define CLSCTX_SERVER    (CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER | CLSCTX_REMOTE_SERVER)
        //#define CLSCTX_ALL       (CLSCTX_INPROC_HANDLER | CLSCTX_SERVER)
        //if (NULL == pcsiName){IISDebugOutput(_T("CIISCertObj::GetObject:pcsiName=NULL failed!!!\n"));}
 
        // this one seems to work with surrogates..
        *phr = CoCreateInstanceEx(CLSID_IISCertObj,NULL,CLSCTX_LOCAL_SERVER,pcsiName,1,res);
        if (FAILED(*phr))
        {
            //IISDebugOutput(_T("CoCreateInstanceEx on CLSID_IISCertObj failed! code=0x%x\n"),*phr);
            IISDebugOutput(_T("CIISCertObj::GetObject:CoCreateInstanceEx failed:0x%x, csServerName=%s,csUserName=%s,csUserPassword=%s\n"),*phr,(LPCTSTR) csServerName,(LPCTSTR) csUserName,(LPCTSTR) csUserPassword);
            goto GetObject_Exit;
        }

        // at this point we were able to instantiate the com object on the server (local or remote)
        m_pObj = (IIISCertObj *)res[0].pItf;
        if (auth.UsesImpersonation())
        {
            *phr = auth.ApplyProxyBlanket(m_pObj);
        }
        auth.FreeServerInfoStruct(pcsiName);
    }

GetObject_Exit:
    //ASSERT(m_pObj != NULL);
    return m_pObj;
}


STDMETHODIMP CIISCertObj::IsInstalled(VARIANT_BOOL * retval)
{
    HRESULT hr = S_OK;
    BSTR bstrInstanceName = SysAllocString(m_InstanceName);

    // Check mandatory properties
    if (bstrInstanceName == NULL || *bstrInstanceName == 0 || retval == NULL)
    {
        return ERROR_INVALID_PARAMETER;
    }

    // ------------------------
    // buffer overflow paranoia
    // check all parameters...
    // ------------------------
    if (wcslen(bstrInstanceName) > _MAX_PATH){return RPC_S_STRING_TOO_LONG;}

    CString csServerName = m_ServerName;
    if (csServerName.IsEmpty())
    {
        hr = IsInstalledRemote(retval);
        goto IsInstalled_Exit;
    }

    // There is a servername specified...
    // check if it's the local machine that was specified!
    if (IsServerLocal(csServerName))
    {
        hr = IsInstalledRemote(retval);
        goto IsInstalled_Exit;
    }

    // this must be a remote machine
    {
        //ASSERT(GetObject(&hr) != NULL);
        IIISCertObj * pObj;

        if (NULL != (pObj = GetObject(&hr)))
        {
            hr = pObj->put_InstanceName(bstrInstanceName);
            if (SUCCEEDED(hr))
            {
                hr = pObj->IsInstalledRemote(retval);
            }
        }
    }

IsInstalled_Exit:
    return hr;
}


STDMETHODIMP CIISCertObj::IsInstalledRemote(VARIANT_BOOL * retval)
{
    HRESULT hr = S_OK;
    CERT_CONTEXT * pCertContext = NULL;
    BSTR bstrInstanceName = SysAllocString(m_InstanceName);

    // Check mandatory properties
    if (bstrInstanceName == NULL || *bstrInstanceName == 0 || retval == NULL)
    {
        return ERROR_INVALID_PARAMETER;
    }

    // ------------------------
    // buffer overflow paranoia
    // check all parameters...
    // ------------------------
    if (wcslen(bstrInstanceName) > _MAX_PATH){return RPC_S_STRING_TOO_LONG;}

    pCertContext = GetInstalledCert(&hr,bstrInstanceName);
    if (FAILED(hr) || NULL == pCertContext)
    {
        hr = S_OK;
        *retval = FALSE;
    }
    else
    {
        hr = S_OK;
        *retval = TRUE;
        CertFreeCertificateContext(pCertContext);
    }
    return hr;
}

STDMETHODIMP CIISCertObj::IsExportable(VARIANT_BOOL * retval)
{
    HRESULT hr = S_OK;
    BSTR bstrInstanceName = SysAllocString(m_InstanceName);

    // Check mandatory properties
    if (bstrInstanceName == NULL || *bstrInstanceName == 0 || retval == NULL)
    {
        return ERROR_INVALID_PARAMETER;
    }

    // ------------------------
    // buffer overflow paranoia
    // check all parameters...
    // ------------------------
    if (wcslen(bstrInstanceName) > _MAX_PATH){return RPC_S_STRING_TOO_LONG;}

    CString csServerName = m_ServerName;
    if (csServerName.IsEmpty())
    {
        hr = IsExportableRemote(retval);
        goto IsExportable_Exit;
    }

    // There is a servername specified...
    // check if it's the local machine that was specified!
    if (IsServerLocal(csServerName))
    {
        hr = IsExportableRemote(retval);
        goto IsExportable_Exit;
    }

    // this must be a remote machine
    {
        //ASSERT(GetObject(&hr) != NULL);
        IIISCertObj * pObj;

        if (NULL != (pObj = GetObject(&hr)))
        {
            hr = pObj->put_InstanceName(bstrInstanceName);
            if (SUCCEEDED(hr))
            {
                hr = pObj->IsExportableRemote(retval);
            }
        }
    }

IsExportable_Exit:
    return hr;
}

STDMETHODIMP CIISCertObj::IsExportableRemote(VARIANT_BOOL * retval)
{
    HRESULT hr = S_OK;
    CERT_CONTEXT * pCertContext = NULL;
    BSTR bstrInstanceName = SysAllocString(m_InstanceName);

    // Check mandatory properties
    if (bstrInstanceName == NULL || *bstrInstanceName == 0 || retval == NULL)
    {
        return ERROR_INVALID_PARAMETER;
    }

    // ------------------------
    // buffer overflow paranoia
    // check all parameters...
    // ------------------------
    if (wcslen(bstrInstanceName) > _MAX_PATH){return RPC_S_STRING_TOO_LONG;}

    pCertContext = GetInstalledCert(&hr,bstrInstanceName);
    if (FAILED(hr) || NULL == pCertContext)
    {
        hr = S_OK;
        *retval = FALSE;
    }
    else
    {
        // check if it's exportable!
        hr = S_OK;
        if (TRUE == IsCertExportable(pCertContext))
        {
            *retval = TRUE;
        }
        else
        {
            *retval = FALSE;
        }
        if (pCertContext) {CertFreeCertificateContext(pCertContext);}
    }
    return hr;
}

STDMETHODIMP CIISCertObj::GetCertInfo(VARIANT * pVtArray)
{
    HRESULT hr = ERROR_CALL_NOT_IMPLEMENTED;
    CERT_CONTEXT * pCertContext = NULL;
    BSTR bstrInstanceName = SysAllocString(m_InstanceName);

    // Check mandatory properties
    if (bstrInstanceName == NULL || *bstrInstanceName == 0)
    {
        return ERROR_INVALID_PARAMETER;
    }
   
    // ------------------------
    // buffer overflow paranoia
    // check all parameters...
    // ------------------------
    if (wcslen(bstrInstanceName) > _MAX_PATH){return RPC_S_STRING_TOO_LONG;}

    CString csServerName = m_ServerName;
    if (csServerName.IsEmpty())
    {
        hr = GetCertInfoRemote(pVtArray);
        goto GetCertInfo_Exit;
    }

    // There is a servername specified...
    // check if it's the local machine that was specified!
    if (IsServerLocal(csServerName))
    {
        hr = GetCertInfoRemote(pVtArray);
        goto GetCertInfo_Exit;
    }

    // this must be a remote machine
    {
        //ASSERT(GetObject(&hr) != NULL);
        IIISCertObj * pObj;

        if (NULL != (pObj = GetObject(&hr)))
        {
            hr = pObj->put_InstanceName(bstrInstanceName);
            if (SUCCEEDED(hr))
            {
                hr = pObj->GetCertInfoRemote(pVtArray);
            }
        }
    }

GetCertInfo_Exit:
    return hr;
}

STDMETHODIMP CIISCertObj::GetCertInfoRemote(VARIANT * pVtArray)
{
    HRESULT hr = ERROR_CALL_NOT_IMPLEMENTED;
    CERT_CONTEXT * pCertContext = NULL;
    BSTR bstrInstanceName = SysAllocString(m_InstanceName);

    // Check mandatory properties
    if (bstrInstanceName == NULL || *bstrInstanceName == 0)
    {
        return ERROR_INVALID_PARAMETER;
    }
   
    // ------------------------
    // buffer overflow paranoia
    // check all parameters...
    // ------------------------
    if (wcslen(bstrInstanceName) > _MAX_PATH){return RPC_S_STRING_TOO_LONG;}

    pCertContext = GetInstalledCert(&hr,bstrInstanceName);
    if (FAILED(hr) || NULL == pCertContext)
    {
        hr = S_FALSE;
    }
    else
    {
        DWORD cb = 0;
        LPWSTR pwszText = NULL;
        if (TRUE == GetCertDescription(pCertContext,&pwszText,&cb,TRUE))
        {
            hr = S_OK;
            hr = HereIsBinaryGimmieVtArray(cb * sizeof(WCHAR),(char *) pwszText,pVtArray,FALSE);
        }
        else
        {
            hr = S_FALSE;
        }
    }
    if (pCertContext) {CertFreeCertificateContext(pCertContext);}
    return hr;
}

STDMETHODIMP CIISCertObj::RemoveCert(BOOL bPrivateKey)
{
    HRESULT hr = E_FAIL;
    PCCERT_CONTEXT pCertContext = NULL;

    DWORD	cbKpi = 0;
    PCRYPT_KEY_PROV_INFO pKpi = NULL ;
    HCRYPTPROV hCryptProv = NULL;

    BOOL bPleaseLogFailure = FALSE;

    BSTR bstrInstanceName = SysAllocString(m_InstanceName);

    // Check mandatory properties
    if (bstrInstanceName == NULL || *bstrInstanceName == 0)
    {
        return ERROR_INVALID_PARAMETER;
    }

    // ------------------------
    // buffer overflow paranoia
    // check all parameters...
    // ------------------------
    if (wcslen(bstrInstanceName) > _MAX_PATH){return RPC_S_STRING_TOO_LONG;}


    do
    {
        // get the certificate from the server
        pCertContext = GetInstalledCert(&hr,bstrInstanceName);
        if (NULL == pCertContext)
        {
            break;
        }

        bPleaseLogFailure = TRUE;
        if (!CertGetCertificateContextProperty(pCertContext, CERT_KEY_PROV_INFO_PROP_ID, NULL, &cbKpi)) 
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            break;
        }

        pKpi = ( PCRYPT_KEY_PROV_INFO ) malloc( cbKpi );
        if ( NULL != pKpi )	
        {
            if (!CertGetCertificateContextProperty(pCertContext, CERT_KEY_PROV_INFO_PROP_ID, (void *)pKpi, &cbKpi)) 
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
                break;
            }

            // Delete the key container
            if (!CryptAcquireContext(&hCryptProv,pKpi->pwszContainerName,pKpi->pwszProvName,pKpi->dwProvType,pKpi->dwFlags | CRYPT_DELETEKEYSET | CRYPT_MACHINE_KEYSET))
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
                break;
            }

            if (NULL != pKpi){free(pKpi);}

            if (!CertSetCertificateContextProperty(pCertContext, CERT_KEY_PROV_INFO_PROP_ID, 0, NULL))
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
                break;
            }
        }

        //    uninstall the certificate from the site, reset SSL flag
        //    if we are exporting the private key, remove the cert from the storage
        //    and delete private key
        UninstallCert(bstrInstanceName);

        // remove ssl key from metabase
        CString str = bstrInstanceName;
        ShutdownSSL(str);

        // delete the private key
        if (bPrivateKey)
        {
            PCCERT_CONTEXT pcDup = NULL ;
            pcDup = CertDuplicateCertificateContext(pCertContext);
            if (pcDup)
            {
                if (!CertDeleteCertificateFromStore(pcDup))
                {
                    hr = HRESULT_FROM_WIN32(GetLastError());
                    break;
                }
            }
            else
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
            }
        }

        hr = ERROR_SUCCESS;

        ReportIt(CERTOBJ_CERT_REMOVE_SUCCEED, bstrInstanceName);
        bPleaseLogFailure = FALSE;

    } while (FALSE);


    if (bPleaseLogFailure)
    {
        ReportIt(CERTOBJ_CERT_REMOVE_FAILED, bstrInstanceName);
    }

    if (pCertContext) {CertFreeCertificateContext(pCertContext);}
    return hr;
}

STDMETHODIMP CIISCertObj::Import(BSTR FileName, BSTR Password, BOOL bAllowExport)
{
    HRESULT hr = S_OK;
    BYTE * pbData = NULL;
    DWORD actual = 0, cbData = 0;
    BOOL bPleaseLogFailure = FALSE;
    BSTR bstrInstanceName = SysAllocString(m_InstanceName);

    // Check mandatory properties
    if (  FileName == NULL || *FileName == 0
        || Password == NULL || *Password == 0
        || bstrInstanceName == NULL || *bstrInstanceName == 0)
    {
        return ERROR_INVALID_PARAMETER;
    }

    // ------------------------
    // buffer overflow paranoia
    // check all parameters...
    // ------------------------
    if (wcslen(FileName) > _MAX_PATH){return RPC_S_STRING_TOO_LONG;}
    if (wcslen(Password) > _MAX_PATH){return RPC_S_STRING_TOO_LONG;}

    HANDLE hFile = CreateFile(FileName, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    if (hFile == INVALID_HANDLE_VALUE)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        hFile = NULL;
        goto Import_Exit;
    }

    if (-1 == (cbData = ::GetFileSize(hFile, NULL)))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Import_Exit;
    }

    if (NULL == (pbData = (BYTE *)::CoTaskMemAlloc(cbData)))
    {
        hr = E_OUTOFMEMORY;
        goto Import_Exit;
    }
    if (ReadFile(hFile, pbData, cbData, &actual, NULL))
    {
        IIISCertObj * pObj = GetObject(&hr);
        if (SUCCEEDED(hr))
        {
            bPleaseLogFailure = TRUE;

            hr = ImportFromBlobProxy(pObj, bstrInstanceName, Password, TRUE, bAllowExport, actual, pbData, 0, NULL);
            if (SUCCEEDED(hr))
            {
                ReportIt(CERTOBJ_CERT_IMPORT_SUCCEED, bstrInstanceName);
                bPleaseLogFailure = FALSE;
            }
        }
    }
    else
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Import_Exit;
    }

    if (bPleaseLogFailure)
    {
        ReportIt(CERTOBJ_CERT_EXPORT_FAILED, bstrInstanceName);
    }

Import_Exit:
    if (pbData != NULL)
    {
        ZeroMemory(pbData, cbData);
        ::CoTaskMemFree(pbData);
    }
    if (hFile != NULL){CloseHandle(hFile);}
    return hr;
}


STDMETHODIMP CIISCertObj::ImportToCertStore(BSTR FileName, BSTR Password, BOOL bAllowExport, VARIANT * pVtArray)
{
    HRESULT hr = S_OK;
    BYTE * pbData = NULL;
    DWORD actual = 0, cbData = 0;
    BOOL bPleaseLogFailure = FALSE;
    BSTR bstrInstanceName = SysAllocString(_T("none"));

    // Check mandatory properties
    if (  FileName == NULL || *FileName == 0
        || Password == NULL || *Password == 0)
    {
        return ERROR_INVALID_PARAMETER;
    }

    // ------------------------
    // buffer overflow paranoia
    // check all parameters...
    // ------------------------
    if (wcslen(FileName) > _MAX_PATH){return RPC_S_STRING_TOO_LONG;}
    if (wcslen(Password) > _MAX_PATH){return RPC_S_STRING_TOO_LONG;}


    HANDLE hFile = CreateFile(FileName, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    if (hFile == INVALID_HANDLE_VALUE)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        hFile = NULL;
        goto Import_Exit;
    }

    if (-1 == (cbData = ::GetFileSize(hFile, NULL)))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Import_Exit;
    }

    if (NULL == (pbData = (BYTE *)::CoTaskMemAlloc(cbData)))
    {
        hr = E_OUTOFMEMORY;
        goto Import_Exit;
    }

    if (ReadFile(hFile, pbData, cbData, &actual, NULL))
    {
        IIISCertObj * pObj = GetObject(&hr);
        if (SUCCEEDED(hr))
        {
            DWORD  cbHashBufferSize = 0;
            char * pszHashBuffer = NULL;

            bPleaseLogFailure = TRUE;

            hr = ImportFromBlobProxy(pObj, bstrInstanceName, Password, FALSE, bAllowExport, actual, pbData, &cbHashBufferSize, &pszHashBuffer);
            if (SUCCEEDED(hr))
            {
                //ReportIt(CERTOBJ_CERT_IMPORT_CERT_STORE_SUCCEED, bstrInstanceName);
                bPleaseLogFailure = FALSE;
                //IISDebugOutput(_T("ImportFromBlobProxy: returned %d,%p\n"),cbHashBufferSize,pszHashBuffer);
                hr = HereIsBinaryGimmieVtArray(cbHashBufferSize,pszHashBuffer,pVtArray,FALSE);
            }
            // free the memory that was alloced for us
            if (0 != cbHashBufferSize)
            {
                if (pszHashBuffer)
                {
                    ::CoTaskMemFree(pszHashBuffer);
                }
            }
        }
    }
    else
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Import_Exit;
    }

Import_Exit:
    if (bPleaseLogFailure)
    {
        //ReportIt(CERTOBJ_CERT_IMPORT_CERT_STORE_FAILED, bstrInstanceName);
    }
    if (pbData != NULL)
    {
        ZeroMemory(pbData, cbData);
        ::CoTaskMemFree(pbData);
    }
    if (hFile != NULL){CloseHandle(hFile);}
    return hr;
}

HRESULT ImportFromBlobWork(BSTR InstanceName,BSTR Password,BOOL bInstallToMetabase,BOOL bAllowExport, DWORD count,char *pData,DWORD *cbHashBufferSize,char **pbHashBuffer)
{
    HRESULT hr = S_OK;
    CRYPT_DATA_BLOB blob;
    ZeroMemory(&blob, sizeof(CRYPT_DATA_BLOB));
    LPTSTR pPass = Password;
    BOOL   blob_freeme = FALSE;
    int err;

    // Check mandatory properties
    if (   Password == NULL || *Password == 0
        || InstanceName == NULL || *InstanceName == 0)
    {
        return ERROR_INVALID_PARAMETER;
    }

    // ------------------------
    // buffer overflow paranoia
    // check all parameters...
    // ------------------------
    if (wcslen(InstanceName) > _MAX_PATH){return RPC_S_STRING_TOO_LONG;}
    if (wcslen(Password) > _MAX_PATH){return RPC_S_STRING_TOO_LONG;}


    // The data we got back was Base64 encoded to remove nulls.
    // we need to decode it back to it's original format.
    if( (err = Base64DecodeA(pData,count,NULL,&blob.cbData)) != ERROR_SUCCESS ||
        (blob.pbData = (BYTE *) malloc(blob.cbData)) == NULL ||
        (err = Base64DecodeA(pData,count,blob.pbData,&blob.cbData)) != ERROR_SUCCESS ) 
    {
        SetLastError(err);
        hr = HRESULT_FROM_WIN32(err);
        return hr;
    }
    blob_freeme = TRUE;

    if (!PFXVerifyPassword(&blob, pPass, 0))
    {
        // Try empty password
        if (pPass == NULL)
        {
            if (!PFXVerifyPassword(&blob, pPass = L'\0', 0))
            {
                hr = ERROR_INVALID_PARAMETER;
            }
        }
        else
        {
            hr = ERROR_INVALID_PARAMETER;
        }
    }
    if (SUCCEEDED(hr))
    {
        //  CRYPT_EXPORTABLE - which would then specify that any imported keys should 
        //     be marked as exportable (see documentation on CryptImportKey)
        //  CRYPT_USER_PROTECTED - (see documentation on CryptImportKey)
        //  PKCS12_NO_DATA_COMMIT - will unpack the pfx blob but does not persist its contents.
        //                       In this case, returns BOOL indicating successful unpack.
        //  CRYPT_MACHINE_KEYSET - used to force the private key to be stored in the
        //                        the local machine and not the current user.
        //  CRYPT_USER_KEYSET - used to force the private key to be stored in the
        //                      the current user and not the local machine, even if
        //                      the pfx blob specifies that it should go into local machine.
        HCERTSTORE hStore = PFXImportCertStore(&blob, pPass, (bAllowExport ? CRYPT_MACHINE_KEYSET|CRYPT_EXPORTABLE : CRYPT_MACHINE_KEYSET));
        if (hStore != NULL)
        {
            //add the certificate with private key to my store; and the rest
            //to the ca store
            PCCERT_CONTEXT	pCertContext = NULL;
            PCCERT_CONTEXT	pCertPre = NULL;
            while (  SUCCEEDED(hr)
            && NULL != (pCertContext = CertEnumCertificatesInStore(hStore, pCertPre))
            )
            {
                //check if the certificate has the property on it
                //make sure the private key matches the certificate
                //search for both machine key and user keys
                DWORD dwData = 0;
                if (CertGetCertificateContextProperty(pCertContext,CERT_KEY_PROV_INFO_PROP_ID, NULL, &dwData) &&  CryptFindCertificateKeyProvInfo(pCertContext, 0, NULL))
                {
                    // This certificate should go to the My store
                    HCERTSTORE hDestStore = CertOpenStore(CERT_STORE_PROV_SYSTEM,PKCS_7_ASN_ENCODING | X509_ASN_ENCODING,NULL,CERT_SYSTEM_STORE_LOCAL_MACHINE,L"MY");
                    if (hDestStore != NULL)
                    {
                        // Put it to store
                        if (CertAddCertificateContextToStore(hDestStore,pCertContext,CERT_STORE_ADD_REPLACE_EXISTING,NULL))
                        {
                            // Succeeded to put it to the storage
                            hr = S_OK;

                            // Install to metabase
                            CRYPT_HASH_BLOB hash;
                            if (  CertGetCertificateContextProperty(pCertContext,CERT_SHA1_HASH_PROP_ID, NULL, &hash.cbData)
                                && NULL != (hash.pbData = (BYTE *)_alloca(hash.cbData))
                                && CertGetCertificateContextProperty(pCertContext, CERT_SHA1_HASH_PROP_ID, hash.pbData, &hash.cbData))
                            {
                                if (TRUE == bInstallToMetabase)
                                {
                                    // returns error code in hr
                                    InstallHashToMetabase(&hash, InstanceName, &hr);
                                }
  
                                // check if we need to return back the hash
                                if (NULL != pbHashBuffer)
                                {
                                    *pbHashBuffer = (char *) ::CoTaskMemAlloc(hash.cbData);
                                    if (NULL == *pbHashBuffer)
                                    {
                                        hr = E_OUTOFMEMORY;
                                        *pbHashBuffer = NULL;
                                        *cbHashBufferSize = 0;
                                    }
                                    else
                                    {
                                        *cbHashBufferSize = hash.cbData;
                                        memcpy(*pbHashBuffer,hash.pbData,hash.cbData);
                                    }
                                }

                            }
                            else
                            {
                                hr = HRESULT_FROM_WIN32(GetLastError());
                            }
                        }
                        else
                        {
                            hr = HRESULT_FROM_WIN32(GetLastError());
                        }
                        CertCloseStore(hDestStore, 0);
                    }
                    else
                    {
                        hr = HRESULT_FROM_WIN32(GetLastError());
                    }
                }  // my store certificate
                //see if the certificate is self-signed.
                //if it is selfsigned, goes to the root store
                else if (TrustIsCertificateSelfSigned(pCertContext,pCertContext->dwCertEncodingType, 0))
                {
                    //Put it to the root store
                    HCERTSTORE hDestStore=CertOpenStore(CERT_STORE_PROV_SYSTEM,PKCS_7_ASN_ENCODING | X509_ASN_ENCODING,NULL,CERT_SYSTEM_STORE_LOCAL_MACHINE,L"ROOT");
                    if (hDestStore != NULL)
                    {
                        // Put it to store
                        if (!CertAddCertificateContextToStore(hDestStore,pCertContext,CERT_STORE_ADD_REPLACE_EXISTING,NULL))
                        {
                            hr = HRESULT_FROM_WIN32(GetLastError());
                        }
                        CertCloseStore(hDestStore, 0);
                    }
                    else
                    {
                        hr = HRESULT_FROM_WIN32(GetLastError());
                    }
                }
                else
                {
                    //Put it to the CA store
                    HCERTSTORE hDestStore=CertOpenStore(CERT_STORE_PROV_SYSTEM,PKCS_7_ASN_ENCODING | X509_ASN_ENCODING,NULL,CERT_SYSTEM_STORE_LOCAL_MACHINE,L"CA");
                    if (hDestStore != NULL)
                    {
                        // Put it to store
                        if (!CertAddCertificateContextToStore(hDestStore,pCertContext,CERT_STORE_ADD_REPLACE_EXISTING,NULL))
                        {
                            hr = HRESULT_FROM_WIN32(GetLastError());
                        }
                        CertCloseStore(hDestStore, 0);
                    }
                    else
                    {
                        hr = HRESULT_FROM_WIN32(GetLastError());
                    }
                }
                pCertPre = pCertContext;
            } //while

            CertCloseStore(hStore, 0);
        }
        else
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }
    }

//ImportFromBlobWork_Exit:
    if (blob_freeme)
    {
        if (blob.pbData != NULL)
        {
            ZeroMemory(blob.pbData, blob.cbData);
            free(blob.pbData);blob.pbData=NULL;
        }
    }
    return hr;
}


HRESULT CIISCertObj::ImportFromBlob(BSTR InstanceName,BSTR Password,BOOL bInstallToMetabase,BOOL bAllowExport,DWORD count,char *pData)
{
    HRESULT hr;

    // Check mandatory properties
    if (   Password == NULL || *Password == 0
        || InstanceName == NULL || *InstanceName == 0)
    {
        return ERROR_INVALID_PARAMETER;
    }

    // ------------------------
    // buffer overflow paranoia
    // check all parameters...
    // ------------------------
    if (wcslen(InstanceName) > _MAX_PATH){return RPC_S_STRING_TOO_LONG;}
    if (wcslen(Password) > _MAX_PATH){return RPC_S_STRING_TOO_LONG;}

    hr = ImportFromBlobWork(InstanceName,Password,bInstallToMetabase,bAllowExport,count,pData,0,NULL);
    return hr;
}


HRESULT CIISCertObj::ImportFromBlobGetHash(BSTR InstanceName,BSTR Password,BOOL bInstallToMetabase,BOOL bAllowExport,DWORD count,char *pData,DWORD *cbHashBufferSize,char **pbHashBuffer)
{
    HRESULT hr;

    // Check mandatory properties
    if (   Password == NULL || *Password == 0
        || InstanceName == NULL || *InstanceName == 0)
    {
        return ERROR_INVALID_PARAMETER;
    }

    // ------------------------
    // buffer overflow paranoia
    // check all parameters...
    // ------------------------
    if (wcslen(InstanceName) > _MAX_PATH){return RPC_S_STRING_TOO_LONG;}
    if (wcslen(Password) > _MAX_PATH){return RPC_S_STRING_TOO_LONG;}

    hr = ImportFromBlobWork(InstanceName,Password,bInstallToMetabase,bAllowExport,count,pData,cbHashBufferSize,pbHashBuffer);
    return hr;
}


STDMETHODIMP CIISCertObj::Export(BSTR FileName,BSTR Password,BOOL bPrivateKey,BOOL bCertChain,BOOL bRemoveCert)
{
    HRESULT hr = S_OK;
    DWORD  cbEncodedSize = 0;
    char * pszEncodedString = NULL;
    DWORD  blob_cbData = 0;
    BYTE * blob_pbData = NULL;
    BOOL   blob_freeme = FALSE;
    BOOL   bPleaseLogFailure = FALSE;

    BSTR bstrInstanceName = SysAllocString(m_InstanceName);

    // Check mandatory properties
    if (  FileName == NULL || *FileName == 0
        || Password == NULL || *Password == 0
        || bstrInstanceName == NULL || *bstrInstanceName == 0)
    {
        return ERROR_INVALID_PARAMETER;
    }

    // ------------------------
    // buffer overflow paranoia
    // check all parameters...
    // ------------------------
    if (wcslen(FileName) > _MAX_PATH){return RPC_S_STRING_TOO_LONG;}
    if (wcslen(Password) > _MAX_PATH){return RPC_S_STRING_TOO_LONG;}
    if (wcslen(bstrInstanceName) > _MAX_PATH){return RPC_S_STRING_TOO_LONG;}

    IIISCertObj * pObj = GetObject(&hr);
    if (FAILED(hr))
    {
        goto Export_Exit;
    }

    // Call function go get data from the remote/local iis store
    // and return it back as a blob.  the blob could be returned back as Base64 encoded
    // so check that flag
    hr = ExportToBlobProxy(pObj, bstrInstanceName, Password, bPrivateKey, bCertChain, &cbEncodedSize, &pszEncodedString);
    if (FAILED(hr))
    {
        goto Export_Exit;
    }

    // check if things are kool
    if (bRemoveCert)
    {
        hr = RemoveCertProxy(pObj,bstrInstanceName, bPrivateKey);
        if (FAILED(hr))
        {
            goto Export_Exit;
        }
    }

    if (SUCCEEDED(hr))
    {
        int err;

        bPleaseLogFailure = TRUE;

        // The data we got back was Base64 encoded to remove nulls.
        // we need to decode it back to it's original format.
        if( (err = Base64DecodeA(pszEncodedString,cbEncodedSize,NULL,&blob_cbData)) != ERROR_SUCCESS ||
            (blob_pbData = (BYTE *) malloc(blob_cbData)) == NULL ||
            (err = Base64DecodeA(pszEncodedString,cbEncodedSize,blob_pbData,&blob_cbData)) != ERROR_SUCCESS ) 
        {
            SetLastError(err);
            hr = HRESULT_FROM_WIN32(err);
            return hr;
        }
        blob_freeme = TRUE;

        HANDLE hFile = CreateFile(FileName, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
        if (INVALID_HANDLE_VALUE == hFile)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            return hr;
        }

        DWORD written = 0;
        if (!WriteFile(hFile, blob_pbData, blob_cbData, &written, NULL))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }
        else
        {
            hr = S_OK;
            ReportIt(CERTOBJ_CERT_EXPORT_SUCCEED, bstrInstanceName);
            bPleaseLogFailure = FALSE;
        }
        CloseHandle(hFile);

    }

Export_Exit:
    if (bPleaseLogFailure)
    {
        ReportIt(CERTOBJ_CERT_EXPORT_FAILED, bstrInstanceName);
    }
    if (pObj != NULL)
    {
        if (pObj != this)
        {
            pObj->Release();pObj=NULL;
        }
    }

    if (blob_freeme)
    {
        if (blob_pbData != NULL)
        {
            // Erase the memory that the private key used to be in!!!
            ZeroMemory(blob_pbData, blob_cbData);
            free(blob_pbData);blob_pbData=NULL;
        }
    }
    if (pszEncodedString != NULL)
    {
        // Erase the memory that the private key used to be in!!!
        ZeroMemory(pszEncodedString, cbEncodedSize);
        CoTaskMemFree(pszEncodedString);pszEncodedString=NULL;
    }
    return hr;
}

STDMETHODIMP CIISCertObj::ExportToBlob(BSTR InstanceName,BSTR Password,BOOL bPrivateKey,BOOL bCertChain,DWORD *cbBufferSize,char **pbBuffer)
{
    HRESULT hr = E_FAIL;
    PCCERT_CONTEXT pCertContext = NULL;
    BOOL bStatus = FALSE;
    HCERTSTORE hStore = NULL;
    DWORD dwOpenFlags = CERT_STORE_READONLY_FLAG | CERT_STORE_ENUM_ARCHIVED_FLAG;
    CRYPT_DATA_BLOB DataBlob;
    ZeroMemory(&DataBlob, sizeof(CRYPT_DATA_BLOB));

    char *pszB64Out = NULL;
    DWORD pcchB64Out = 0;
    DWORD  err;
    DWORD dwExportFlags = EXPORT_PRIVATE_KEYS| REPORT_NO_PRIVATE_KEY;

    // Check mandatory properties
    if (   Password == NULL || *Password == 0
        || InstanceName == NULL || *InstanceName == 0)
    {
        return ERROR_INVALID_PARAMETER;
    }

    // ------------------------
    // buffer overflow paranoia
    // check all parameters...
    // ------------------------
    if (wcslen(Password) > _MAX_PATH){return RPC_S_STRING_TOO_LONG;}
    if (wcslen(InstanceName) > _MAX_PATH){return RPC_S_STRING_TOO_LONG;}

    //
    // get the certificate from the server
    //
    pCertContext = GetInstalledCert(&hr,InstanceName);
    if (NULL == pCertContext)
    {
        *cbBufferSize = 0;
        pbBuffer = NULL;
        goto ExportToBlob_Exit;
    }

    //
    // Export cert
    //
    // Open a temporary store to stick the cert in.
    hStore = CertOpenStore(CERT_STORE_PROV_MEMORY,X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,0,dwOpenFlags,NULL);
    if(NULL == hStore)
    {
        *cbBufferSize = 0;
        pbBuffer = NULL;
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto ExportToBlob_Exit;
    }

    //
    // get all the certs in the chain if we need to
    //
    if (bCertChain)
    {
        AddChainToStore(hStore, pCertContext, 0, 0, FALSE, NULL);
    }

    if(!CertAddCertificateContextToStore(hStore,pCertContext,CERT_STORE_ADD_REPLACE_EXISTING,NULL))
    {
        *cbBufferSize = 0;
        pbBuffer = NULL;
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto ExportToBlob_Exit;
    }

    // free cert context since we no longer need to hold it
    if (pCertContext) 
    {
        CertFreeCertificateContext(pCertContext);pCertContext=NULL;
    }

    DataBlob.cbData = 0;
    DataBlob.pbData = NULL;

    if (!PFXExportCertStoreEx(hStore,&DataBlob,Password,NULL, (bPrivateKey ? dwExportFlags : 0 )  | REPORT_NOT_ABLE_TO_EXPORT_PRIVATE_KEY) )
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto ExportToBlob_Exit;
    }
    if(DataBlob.cbData <= 0)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto ExportToBlob_Exit;
    }

    if(NULL == (DataBlob.pbData = (PBYTE) ::CoTaskMemAlloc(DataBlob.cbData)))
    {
        hr = E_OUTOFMEMORY;
        goto ExportToBlob_Exit;
    }

    //
    // at this point they have allocated enough memory
    // let's go and get the cert and put it into DataBlob
    //
    if(!PFXExportCertStoreEx(hStore,&DataBlob,Password,NULL,(bPrivateKey ? dwExportFlags : 0 )  | REPORT_NOT_ABLE_TO_EXPORT_PRIVATE_KEY))
    {
        if (DataBlob.pbData){CoTaskMemFree(DataBlob.pbData);DataBlob.pbData = NULL;}
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto ExportToBlob_Exit;
    }

    // Encode it so that it can be passed back as a string (there are no Nulls in it)
    err = Base64EncodeA(DataBlob.pbData,DataBlob.cbData,NULL,&pcchB64Out);
    if (err != ERROR_SUCCESS)
    {
        hr = E_FAIL;
        goto ExportToBlob_Exit;
    }

    // allocate some space and then try it.
    pcchB64Out = pcchB64Out * sizeof(char);
    pszB64Out = (char *) ::CoTaskMemAlloc(pcchB64Out);
    if (NULL == pszB64Out)
    {
        hr = E_OUTOFMEMORY;
        goto ExportToBlob_Exit;
    }

    err = Base64EncodeA(DataBlob.pbData,DataBlob.cbData,pszB64Out,&pcchB64Out);
    if (err != ERROR_SUCCESS)
    {
        if (NULL != pszB64Out){CoTaskMemFree(pszB64Out);pszB64Out = NULL;}
        hr = E_FAIL;
        goto ExportToBlob_Exit;
    }

    // copy the new memory to pass back
    *cbBufferSize = pcchB64Out;
    *pbBuffer = pszB64Out;

    hr = ERROR_SUCCESS;

ExportToBlob_Exit:
    if (NULL != DataBlob.pbData)
    {
        // perhaspse will this up with zeros...
        ZeroMemory(DataBlob.pbData, DataBlob.cbData);
        ::CoTaskMemFree(DataBlob.pbData);DataBlob.pbData = NULL;
    }
    if (NULL != hStore){CertCloseStore(hStore, 0);hStore=NULL;}
    if (NULL != pCertContext) {CertFreeCertificateContext(pCertContext);pCertContext=NULL;}
    return hr;
}

STDMETHODIMP CIISCertObj::CopyToCertStore(BOOL bAllowExport,BSTR bstrDestinationServerName,VARIANT varDestinationServerUserName, VARIANT varDestinationServerPassword,VARIANT * pVtArray)
{
    // Check mandatory properties
    if (bstrDestinationServerName == NULL || *bstrDestinationServerName == 0)
    {
        return ERROR_INVALID_PARAMETER;
    }

    // ------------------------
    // buffer overflow paranoia
    // check all parameters...
    // ------------------------
    if (wcslen(bstrDestinationServerName) > _MAX_PATH){return RPC_S_STRING_TOO_LONG;}

    return CopyOrMove(FALSE,TRUE,bAllowExport,pVtArray,bstrDestinationServerName,L"none",varDestinationServerUserName,varDestinationServerPassword);
}

STDMETHODIMP CIISCertObj::Copy(BOOL bAllowExport, BSTR bstrDestinationServerName,BSTR bstrDestinationServerInstance,VARIANT varDestinationServerUserName, VARIANT varDestinationServerPassword)
{
    VARIANT VtArray;

    // Check mandatory properties
    if (   bstrDestinationServerName == NULL || *bstrDestinationServerName == 0
        || bstrDestinationServerInstance == NULL || *bstrDestinationServerInstance == 0)
    {
        return ERROR_INVALID_PARAMETER;
    }

    // ------------------------
    // buffer overflow paranoia
    // check all parameters...
    // ------------------------
    if (wcslen(bstrDestinationServerName) > _MAX_PATH){return RPC_S_STRING_TOO_LONG;}
    if (wcslen(bstrDestinationServerInstance) > _MAX_PATH){return RPC_S_STRING_TOO_LONG;}

    return CopyOrMove(FALSE,FALSE,bAllowExport,&VtArray,bstrDestinationServerName,bstrDestinationServerInstance,varDestinationServerUserName,varDestinationServerPassword);
}

STDMETHODIMP CIISCertObj::Move(BOOL bAllowExport, BSTR bstrDestinationServerName,BSTR bstrDestinationServerInstance,VARIANT varDestinationServerUserName, VARIANT varDestinationServerPassword)
{
    VARIANT VtArray;

    // Check mandatory properties
    if (   bstrDestinationServerName == NULL || *bstrDestinationServerName == 0
        || bstrDestinationServerInstance == NULL || *bstrDestinationServerInstance == 0)
    {
        return ERROR_INVALID_PARAMETER;
    }

    // ------------------------
    // buffer overflow paranoia
    // check all parameters...
    // ------------------------
    if (wcslen(bstrDestinationServerName) > _MAX_PATH){return RPC_S_STRING_TOO_LONG;}
    if (wcslen(bstrDestinationServerInstance) > _MAX_PATH){return RPC_S_STRING_TOO_LONG;}

    return CopyOrMove(TRUE,FALSE,bAllowExport,&VtArray,bstrDestinationServerName,bstrDestinationServerInstance,varDestinationServerUserName,varDestinationServerPassword);
}

HRESULT CIISCertObj::CopyOrMove(BOOL bRemoveFromCertAfterCopy,BOOL bCopyCertDontInstallRetHash,BOOL bAllowExport, VARIANT * pVtArray, BSTR bstrDestinationServerName,BSTR bstrDestinationServerInstance,VARIANT varDestinationServerUserName, VARIANT varDestinationServerPassword)
{
    HRESULT hr = E_FAIL;
    DWORD  cbEncodedSize = 0;
    char * pszEncodedString = NULL;
    BOOL   bGuessingUserNamePass = FALSE;
    
    DWORD  blob_cbData;
    BYTE * blob_pbData = NULL;
    BOOL   blob_freeme = FALSE;

    BOOL bPrivateKey = TRUE;
    BOOL bCertChain = FALSE;

    CString csDestinationServerName = bstrDestinationServerName;
    CString csDestinationServerUserName;
    CString csDestinationServerUserPassword;
    CString csTempPassword;

    IIISCertObj * pObj = NULL;
    IIISCertObj * pObj2 = NULL;
    BSTR bstrInstanceName = SysAllocString(m_InstanceName);

    // Check mandatory properties
    if (   bstrDestinationServerName == NULL || *bstrDestinationServerName == 0
        || bstrDestinationServerInstance == NULL || *bstrDestinationServerInstance == 0)
    {
        return ERROR_INVALID_PARAMETER;
    }

    // ------------------------
    // buffer overflow paranoia
    // check all parameters...
    // ------------------------
    if (wcslen(bstrDestinationServerName) > _MAX_PATH){return RPC_S_STRING_TOO_LONG;}
    if (wcslen(bstrDestinationServerInstance) > _MAX_PATH){return RPC_S_STRING_TOO_LONG;}


    // if the optional parameter serverusername isn't empty, use that; otherwise, use...
    if (V_VT(&varDestinationServerUserName) != VT_ERROR)
    {
		VARIANT varBstrUserName;
        VariantInit(&varBstrUserName);
		HRESULT hr = VariantChangeType(&varBstrUserName, &varDestinationServerUserName, 0, VT_BSTR);
		if (FAILED(hr)){goto Copy_Exit;}
        csDestinationServerUserName = V_BSTR(&varBstrUserName);
		VariantClear(&varBstrUserName);
    }
    else
    {
        // it's empty so don't use it
        //csDestinationServerUserName = varDestinationServerUserName;
        bGuessingUserNamePass = TRUE;
        csDestinationServerUserName = m_UserName;
    }

    // if the optional parameter serverusername isn't empty, use that; otherwise, use...
    if (V_VT(&varDestinationServerPassword) != VT_ERROR)
    {
		VARIANT varBstrUserPassword;
        VariantInit(&varBstrUserPassword);
		HRESULT hr = VariantChangeType(&varBstrUserPassword, &varDestinationServerPassword, 0, VT_BSTR);
		if (FAILED(hr)){goto Copy_Exit;}
        csDestinationServerUserPassword = V_BSTR(&varBstrUserPassword);
		VariantClear(&varBstrUserPassword);
    }
    else
    {
        if (TRUE == bGuessingUserNamePass)
        {
            csDestinationServerUserPassword = m_UserPassword;
        }
        else
        {
            // maybe the password was intended to be empty!
        }
    }

    // --------------------------
    // step 1.
    // 1st of all check if we have access to
    // both the servers!!!!
    // --------------------------

    // 1st we have to get the certblob from the Server#1
    // so call export to get the data
    hr = S_OK;
    pObj = GetObject(&hr);
    if (FAILED(hr))
    {
        IISDebugOutput(_T("CIISCertObj::CopyOrMove:Copy GetObject:0x%x\n"),hr);
        return(hr);
    }

    // Logon to that server's CertObj.dll with the credentials supplied...
    //
    // if there were no credential's supplied then just use the ones that are in our object....
    //
    // if that doesn't work then try just the logged on user.
    pObj2 = GetObject(&hr,csDestinationServerName,csDestinationServerUserName,csDestinationServerUserPassword);
    if (FAILED(hr))
    {
        IISDebugOutput(_T("CIISCertObj::CopyOrMove:Copy GetObject (remote):0x%x\n"),hr);
        IISDebugOutput(_T("CIISCertObj::CopyOrMove:Copy csDestinationServerName=%s,csDestinationServerUserName=%s,csDestinationServerUserPassword=%s\n"),(LPCTSTR) csDestinationServerName,(LPCTSTR) csDestinationServerUserName,(LPCTSTR) csDestinationServerUserPassword);
        if (TRUE == bGuessingUserNamePass)
        {
            // try something else.
        }
        goto Copy_Exit;
    }

    //
    // Create a unique password
    //
    // use the new secure password generator
    // unfortunately this baby doesn't use unicode.
    // so we'll call it and then convert it to unicode afterwards.
    WCHAR * pwszPassword = CreatePassword(TEMP_PASSWORD_LENGTH);
    // if its null -- ah, we can still use that...
    BSTR bstrPassword = SysAllocString(pwszPassword);

    // -----------------------------------
    // step 2.
    // okay we have access to both servers
    // Grab the cert from server #1
    // -----------------------------------
    // Get data from the remote/local iis store return it back as a blob.
    // The blob could be returned back as Base64 encoded so check that flag
    hr = ExportToBlobProxy(pObj, bstrInstanceName, bstrPassword, bPrivateKey, bCertChain, &cbEncodedSize, &pszEncodedString);
    if (FAILED(hr))
    {
        goto Copy_Exit;
    }

    int err;
    // The data we got back was Base64 encoded to remove nulls.
    // we need to decode it back to it's original format.
    if( (err = Base64DecodeA(pszEncodedString,cbEncodedSize,NULL,&blob_cbData)) != ERROR_SUCCESS                    ||
        (blob_pbData = (BYTE *) malloc(blob_cbData)) == NULL      ||
        (err = Base64DecodeA(pszEncodedString,cbEncodedSize,blob_pbData,&blob_cbData)) != ERROR_SUCCESS ) 
    {
        SetLastError(err);
        hr = HRESULT_FROM_WIN32(err);
        return hr;
    }
    blob_freeme = TRUE;

    // -----------------------------------
    // step 3.
    // okay we have access to both servers
    // we have the cert blob from server#1 in memory
    // now we need to push this blob into the server#2
    // -----------------------------------
    if (bCopyCertDontInstallRetHash)
    {
        DWORD  cbHashBufferSize = 0;
        char * pszHashBuffer = NULL;
        BSTR bstrInstanceNameDummy = SysAllocString(_T("none"));

        hr = ImportFromBlobProxy(pObj2, bstrInstanceNameDummy, bstrPassword, FALSE, bAllowExport, blob_cbData, blob_pbData, &cbHashBufferSize, &pszHashBuffer);
        if (SUCCEEDED(hr))
        {
            hr = HereIsBinaryGimmieVtArray(cbHashBufferSize,pszHashBuffer,pVtArray,FALSE);
        }
        // free the memory that was alloced for us
        if (0 != cbHashBufferSize)
        {
            if (pszHashBuffer)
            {
                ::CoTaskMemFree(pszHashBuffer);
            }
        }
    }
    else
    {
        hr = ImportFromBlobProxy(pObj2, bstrDestinationServerInstance, bstrPassword, TRUE, bAllowExport, blob_cbData, blob_pbData, 0, NULL);
    }
    if (FAILED(hr))
    {
        goto Copy_Exit;
    }

    // we successfully copied the cert from machine #1 to machine #2.
    // lets see if we need to delete the original cert!.
    if (TRUE == bRemoveFromCertAfterCopy)
    {
        hr = pObj->put_InstanceName(bstrInstanceName);
        if (SUCCEEDED(hr))
        {
            hr = pObj->RemoveCert(bPrivateKey);
            if (FAILED(hr))
                {goto Copy_Exit;}
        }
    }

    hr = S_OK;
   
Copy_Exit:
    if (pwszPassword) {GlobalFree(pwszPassword);pwszPassword=NULL;}
    if (blob_freeme)
    {
        if (blob_pbData != NULL)
        {
            ZeroMemory(blob_pbData, blob_cbData);
            free(blob_pbData);blob_pbData=NULL;
        }
    }
    if (pszEncodedString != NULL)
    {
        ZeroMemory(pszEncodedString,cbEncodedSize);
        CoTaskMemFree(pszEncodedString);pszEncodedString=NULL;
    }
    return hr;
}


//////////////////////////////////////////////////
// These are not part of the class


HRESULT RemoveCertProxy(IIISCertObj * pObj,BSTR bstrInstanceName, BOOL bPrivateKey)
{
    HRESULT hr = E_FAIL;

    // Check mandatory properties
    if (bstrInstanceName == NULL || *bstrInstanceName == 0)
    {
        return ERROR_INVALID_PARAMETER;
    }
    
    // ------------------------
    // buffer overflow paranoia
    // check all parameters...
    // ------------------------
    if (wcslen(bstrInstanceName) > _MAX_PATH){return RPC_S_STRING_TOO_LONG;}


    if (pObj)
    {
        hr = pObj->put_InstanceName(bstrInstanceName);
        if (SUCCEEDED(hr))
        {
            hr = pObj->RemoveCert(bPrivateKey);
        }
    }
    return hr;
}


HRESULT ImportFromBlobProxy(IIISCertObj * pObj,BSTR InstanceName,BSTR Password,BOOL bInstallToMetabase,BOOL bAllowExport, DWORD actual,BYTE *pData,DWORD *cbHashBufferSize,char **pbHashBuffer)
{
    HRESULT hr = E_FAIL;
    char *pszB64Out = NULL;
    DWORD pcchB64Out = 0;

    // base64 encode the data for transfer to the remote machine
    DWORD  err;
    pcchB64Out = 0;

    // Check mandatory properties
    if (InstanceName == NULL || *InstanceName == 0)
    {
        return ERROR_INVALID_PARAMETER;
    }
    
    // ------------------------
    // buffer overflow paranoia
    // check all parameters...
    // ------------------------
    if (wcslen(InstanceName) > _MAX_PATH){return RPC_S_STRING_TOO_LONG;}


    // Encode it so that it can be passed back as a string (there are no Nulls in it)
    err = Base64EncodeA(pData,actual,NULL,&pcchB64Out);
    if (err != ERROR_SUCCESS)
    {
        hr = E_FAIL;
        goto ImportFromBlobProxy_Exit;
    }

    // allocate some space and then try it.
    pcchB64Out = pcchB64Out * sizeof(char);
    pszB64Out = (char *) ::CoTaskMemAlloc(pcchB64Out);
    if (NULL == pszB64Out)
    {
        hr = E_OUTOFMEMORY;
        goto ImportFromBlobProxy_Exit;
    }

    err = Base64EncodeA(pData,actual,pszB64Out,&pcchB64Out);
    if (err != ERROR_SUCCESS)
    {
        hr = E_FAIL;
        goto ImportFromBlobProxy_Exit;
    }

    // the data to send are now in these variables
    // pcchB64Out
    // pszB64Out
    if (NULL == pbHashBuffer)
    {
        hr = pObj->ImportFromBlob(InstanceName, Password, bInstallToMetabase, bAllowExport, pcchB64Out, pszB64Out);
    }
    else
    {
        hr = pObj->ImportFromBlobGetHash(InstanceName, Password, bInstallToMetabase, bAllowExport, pcchB64Out, pszB64Out, cbHashBufferSize, pbHashBuffer);
    }
    if (SUCCEEDED(hr))
    {
        // otherwise hey, The data was imported!
        hr = S_OK;
    }

ImportFromBlobProxy_Exit:
    if (NULL != pszB64Out)
    {
        ZeroMemory(pszB64Out,pcchB64Out);
        CoTaskMemFree(pszB64Out);
    }
    return hr;
}


//
// Proxy to the real call ExportToBlob()
// this function figures out how much space to allocate, and then calls ExportToBlob().
//
// if succeeded and they get the blob back,
// and the caller must call CoTaskMemFree()
//
HRESULT ExportToBlobProxy(IIISCertObj * pObj,BSTR InstanceName,BSTR Password,BOOL bPrivateKey,BOOL bCertChain,DWORD * pcbSize,char ** pBlobBinary)
{
    HRESULT hr = E_FAIL;
    DWORD  cbEncodedSize = 0;
    char * pszEncodedString = NULL;
    * pBlobBinary = _T('\0');

    // Check mandatory properties
    if (   InstanceName == NULL || *InstanceName == 0
        || Password == NULL || *Password == 0
        )
    {
        return ERROR_INVALID_PARAMETER;
    }
    
    // ------------------------
    // buffer overflow paranoia
    // check all parameters...
    // ------------------------
    if (wcslen(InstanceName) > _MAX_PATH){return RPC_S_STRING_TOO_LONG;}
    if (wcslen(Password) > _MAX_PATH){return RPC_S_STRING_TOO_LONG;}


    // call the remote function that will run on the remote/local machine
    // and grab it's certificate from iis and send it back to us
    hr = pObj->ExportToBlob(InstanceName, Password, bPrivateKey, bCertChain, &cbEncodedSize, (char **) &pszEncodedString);
    if (ERROR_SUCCESS == hr)
    {
        // otherwise hey, we've got our data!
        // copy it back
        *pcbSize = cbEncodedSize;
        *pBlobBinary = pszEncodedString;
        hr = S_OK;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\certobj\dcomperm.h ===
#include "stdafx.h"

BOOL RunningAsAdministrator(void);
DWORD ChangeAppIDLaunchACL (LPTSTR AppID,LPTSTR Principal,BOOL SetPrincipal,BOOL Permit);
DWORD ChangeAppIDAccessACL (LPTSTR AppID,LPTSTR Principal,BOOL SetPrincipal,BOOL Permit);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\certobj\certutil.h ===
#include "stdafx.h"


CERT_CONTEXT * GetInstalledCert(HRESULT * phResult, CString csKeyPath);
HRESULT ShutdownSSL(CString& server_name);
BOOL    InstallHashToMetabase(CRYPT_HASH_BLOB * pHash,BSTR InstanceName,HRESULT * phResult);
BOOL    AddChainToStore(HCERTSTORE hCertStore,PCCERT_CONTEXT pCertContext,DWORD cStores,HCERTSTORE * rghStores,BOOL fDontAddRootCert,CERT_TRUST_STATUS * pChainTrustStatus);
HRESULT UninstallCert(CString csInstanceName);
BOOL    TrustIsCertificateSelfSigned(PCCERT_CONTEXT pContext,DWORD dwEncoding, DWORD dwFlags);
HRESULT HereIsBinaryGimmieVtArray(DWORD cbBinaryBufferSize,char *pbBinaryBuffer,VARIANT * lpVarDestObject,BOOL bReturnBinaryAsVT_VARIANT);
HRESULT HereIsVtArrayGimmieBinary(VARIANT * lpVarSrcObject,DWORD * cbBinaryBufferSize,char **pbBinaryBuffer,BOOL bReturnBinaryAsVT_VARIANT);
void CertObj_LogError(void);
BOOL IsCertExportable(PCCERT_CONTEXT pCertContext);
BOOL GetCertDescription(PCCERT_CONTEXT pCert, LPWSTR *ppString, DWORD * cbReturn, BOOL fMultiline);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\certobj\dlldatax.c ===
// wrapper for dlldata.c

#ifdef _MERGE_PROXYSTUB // merge proxy stub DLL

#define REGISTER_PROXY_DLL //DllRegisterServer, etc.

#define _WIN32_WINNT 0x0400	//for WinNT 4.0 or Win95 with DCOM
#define USE_STUBLESS_PROXY	//defined only with MIDL switch /Oicf

#pragma comment(lib, "rpcndr.lib")
#pragma comment(lib, "rpcns4.lib")
#pragma comment(lib, "rpcrt4.lib")

#define DllMain				PrxDllMain
#define DllRegisterServer	PrxDllRegisterServer
#define DllUnregisterServer PrxDllUnregisterServer
#define DllGetClassObject   PrxDllGetClassObject
#define DllCanUnloadNow     PrxDllCanUnloadNow

#include "dlldata.c"
#include "CertObj_p.c"

#ifdef _NOPROXY //no midl generated dlldata.c

#define STRICT 1
#include <ole2.h>

BOOL WINAPI PrxDllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{return TRUE;}

STDAPI PrxDllCanUnloadNow(void){return S_OK;}

STDAPI PrxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{return CLASS_E_CLASSNOTAVAILABLE;}

STDAPI PrxDllRegisterServer(void){return S_OK;}

STDAPI PrxDllUnregisterServer(void){return S_OK;}

#endif //!PROXY_DELEGATION

#endif //_MERGE_PROXYSTUB
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\certobj\dcomperm.cpp ===
#include "stdafx.h"
#include "dcomperm.h"


//
// Check whether we are running as administrator on the machine
// or not
//
BOOL RunningAsAdministrator(void)
{
    BOOL   fReturn = FALSE;
    PSID   psidAdmin;
    DWORD  err;
    
    SID_IDENTIFIER_AUTHORITY SystemSidAuthority= SECURITY_NT_AUTHORITY;
    
    if ( AllocateAndInitializeSid ( &SystemSidAuthority, 2, 
            SECURITY_BUILTIN_DOMAIN_RID, 
            DOMAIN_ALIAS_RID_ADMINS,
            0, 0, 0, 0, 0, 0, &psidAdmin) )
    {
        if (!CheckTokenMembership( NULL, psidAdmin, &fReturn )) 
        {
            err = GetLastError();
        }

        FreeSid ( psidAdmin);
    }
   
    return ( fReturn );
}

DWORD
CopyACL (
    PACL OldACL,
    PACL NewACL
    )
{
    ACL_SIZE_INFORMATION  aclSizeInfo;
    LPVOID                ace;
    ACE_HEADER            *aceHeader;
    ULONG                 i;
    DWORD                 returnValue = ERROR_SUCCESS;

    if (0 == IsValidAcl(OldACL))
    {
        returnValue = ERROR_INVALID_ACL;
        return returnValue;
    }

    if (0 == GetAclInformation (OldACL, (LPVOID) &aclSizeInfo, (DWORD) sizeof (aclSizeInfo), AclSizeInformation))
    {
        returnValue = GetLastError();
        return returnValue;
    }

    //
    // Copy all of the ACEs to the new ACL
    //

    for (i = 0; i < aclSizeInfo.AceCount; i++)
    {
        //
        // Get the ACE and header info
        //

        if (!GetAce (OldACL, i, &ace))
        {
            returnValue = GetLastError();
            return returnValue;
        }

        aceHeader = (ACE_HEADER *) ace;

        //
        // Add the ACE to the new list
        //

        if (!AddAce (NewACL, ACL_REVISION, 0xffffffff, ace, aceHeader->AceSize))
        {
            returnValue = GetLastError();
            return returnValue;
        }
    }

    return returnValue;
}


DWORD
GetPrincipalSID (
    LPCTSTR Principal,
    PSID *Sid,
    BOOL *pbWellKnownSID
    )
{

    DWORD returnValue=ERROR_SUCCESS;
    SID_IDENTIFIER_AUTHORITY SidIdentifierNTAuthority = SECURITY_NT_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY SidIdentifierWORLDAuthority = SECURITY_WORLD_SID_AUTHORITY;
    PSID_IDENTIFIER_AUTHORITY pSidIdentifierAuthority;
    BYTE Count;
    DWORD dwRID[8];
    TCHAR pszPrincipal[MAX_PATH];

    *pbWellKnownSID = TRUE;
    memset(&(dwRID[0]), 0, 8 * sizeof(DWORD));

    wcscpy(pszPrincipal, Principal);
    _wcslwr(pszPrincipal);
    if ( wcsstr(pszPrincipal, TEXT("administrators")) != NULL ) {
        // Administrators group
        pSidIdentifierAuthority = &SidIdentifierNTAuthority;
        Count = 2;
        dwRID[0] = SECURITY_BUILTIN_DOMAIN_RID;
        dwRID[1] = DOMAIN_ALIAS_RID_ADMINS;
    } else if ( wcsstr(pszPrincipal, TEXT("system")) != NULL) {
        // SYSTEM
        pSidIdentifierAuthority = &SidIdentifierNTAuthority;
        Count = 1;
        dwRID[0] = SECURITY_LOCAL_SYSTEM_RID;
    } else if ( wcsstr(pszPrincipal, TEXT("interactive")) != NULL) {
        // INTERACTIVE
        pSidIdentifierAuthority = &SidIdentifierNTAuthority;
        Count = 1;
        dwRID[0] = SECURITY_INTERACTIVE_RID;
    } else if ( wcsstr(pszPrincipal, TEXT("everyone")) != NULL) {
        // Everyone
        pSidIdentifierAuthority = &SidIdentifierWORLDAuthority;
        Count = 1;
        dwRID[0] = SECURITY_WORLD_RID;
    } else {
        *pbWellKnownSID = FALSE;
    }

    if (*pbWellKnownSID) {
        if ( !AllocateAndInitializeSid(pSidIdentifierAuthority,
                                    (BYTE)Count,
                                            dwRID[0],
                                            dwRID[1],
                                            dwRID[2],
                                            dwRID[3],
                                            dwRID[4],
                                            dwRID[5],
                                            dwRID[6],
                                            dwRID[7],
                                    Sid) ) {
            returnValue = GetLastError();
        }
    } else {
        // get regular account sid
        DWORD        sidSize;
        TCHAR        refDomain [256];
        DWORD        refDomainSize;
        SID_NAME_USE snu;

        sidSize = 0;
        refDomainSize = 255;

        LookupAccountName (NULL,
                           pszPrincipal,
                           *Sid,
                           &sidSize,
                           refDomain,
                           &refDomainSize,
                           &snu);

        returnValue = GetLastError();

        if (returnValue == ERROR_INSUFFICIENT_BUFFER) {
            *Sid = (PSID) malloc (sidSize);
            if (!*Sid)
            {
                SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                return GetLastError();
            }
            refDomainSize = 255;

            if (!LookupAccountName (NULL,
                                    pszPrincipal,
                                    *Sid,
                                    &sidSize,
                                    refDomain,
                                    &refDomainSize,
                                    &snu))
            {
                returnValue = GetLastError();
            } else {
                returnValue = ERROR_SUCCESS;
            }
        }
    }

    return returnValue;
}


DWORD
AddAccessDeniedACEToACL (
    PACL *Acl,
    DWORD PermissionMask,
    LPTSTR Principal
    )
{
    ACL_SIZE_INFORMATION  aclSizeInfo;
    int                   aclSize;
    DWORD                 returnValue = ERROR_SUCCESS;
    PSID                  principalSID = NULL;
    PACL                  oldACL, newACL;
    BOOL                  bWellKnownSID = FALSE;
    oldACL = *Acl;

    returnValue = GetPrincipalSID (Principal, &principalSID, &bWellKnownSID);
    if (returnValue != ERROR_SUCCESS)
        return returnValue;

    GetAclInformation (oldACL,
                       (LPVOID) &aclSizeInfo,
                       (DWORD) sizeof (ACL_SIZE_INFORMATION),
                       AclSizeInformation);

    aclSize = aclSizeInfo.AclBytesInUse +
              sizeof (ACL) + sizeof (ACCESS_DENIED_ACE) +
              GetLengthSid (principalSID) - sizeof (DWORD);

    newACL = (PACL) new BYTE [aclSize];

    if (!InitializeAcl (newACL, aclSize, ACL_REVISION))
    {
        returnValue = GetLastError();
        goto cleanup;
    }

    if (!AddAccessDeniedAce (newACL, ACL_REVISION2, PermissionMask, principalSID))
    {
        returnValue = GetLastError();
        goto cleanup;
    }

    returnValue = CopyACL (oldACL, newACL);
    if (returnValue != ERROR_SUCCESS)
    {
        goto cleanup;
    }

    *Acl = newACL;
	newACL = NULL;

cleanup:

	// BugFix: 57654 Whistler
	//         Prefix bug leaking memory in error condition.
	//         By setting the newACL to NULL above if we have
	//         relinquished the memory to *Acl, we avoid releasing
	//         memory we have passed back to the caller.
	//         EBK 5/5/2000		
	if (newACL)
	{
		delete[] newACL;
		newACL = NULL;
	}

    if (principalSID) {
        if (bWellKnownSID)
            FreeSid (principalSID);
        else
            free (principalSID);
    }

    return returnValue;
}



DWORD
AddAccessAllowedACEToACL (
    PACL *Acl,
    DWORD PermissionMask,
    LPTSTR Principal
    )
{
    ACL_SIZE_INFORMATION  aclSizeInfo;
    int                   aclSize;
    DWORD                 returnValue = ERROR_SUCCESS;
    PSID                  principalSID = NULL;
    PACL                  oldACL = NULL;
    PACL                  newACL = NULL;
    BOOL                  bWellKnownSID = FALSE;

    oldACL = *Acl;

    // check if the acl we got passed in is valid!
    if (0 == IsValidAcl(oldACL))
    {
        returnValue = ERROR_INVALID_ACL;
        goto cleanup;
    }

    returnValue = GetPrincipalSID (Principal, &principalSID, &bWellKnownSID);
    if (returnValue != ERROR_SUCCESS)
    {
        return returnValue;
    }

    if (0 == GetAclInformation (oldACL, (LPVOID) &aclSizeInfo, (DWORD) sizeof (ACL_SIZE_INFORMATION), AclSizeInformation))
    {
        returnValue = GetLastError();
        goto cleanup;
    }

    aclSize = aclSizeInfo.AclBytesInUse +
              sizeof (ACL) + sizeof (ACCESS_ALLOWED_ACE) +
              GetLengthSid (principalSID) - sizeof (DWORD);

    newACL = (PACL) new BYTE [aclSize];

    if (!InitializeAcl (newACL, aclSize, ACL_REVISION))
    {
        returnValue = GetLastError();
        goto cleanup;
    }

    returnValue = CopyACL (oldACL, newACL);
    if (returnValue != ERROR_SUCCESS)
    {
        goto cleanup;
    }

    //if (!AddAccessAllowedAce (newACL, ACL_REVISION2, PermissionMask, principalSID))
    if (!AddAccessAllowedAce (newACL, ACL_REVISION, PermissionMask, principalSID))
    {
        returnValue = GetLastError();
        goto cleanup;
    }

    // check if the acl is valid!
    /*
    if (0 == IsValidAcl(newACL))
    {
        returnValue = ERROR_INVALID_ACL;
        goto cleanup;
    }
    */

    // cleanup old memory whose pointer we're replacing
    // okay to leak in setup... (need to comment out or else av's)
    //if (*Acl) {delete(*Acl);}
    *Acl = newACL;
    newACL = NULL;

cleanup:
    if (principalSID) {
        if (bWellKnownSID)
            FreeSid (principalSID);
        else
            free (principalSID);
    }
    if (newACL)
    {
		delete [] newACL;
		newACL = NULL;
    }

    return returnValue;
}

DWORD
RemovePrincipalFromACL (
    PACL Acl,
    LPTSTR Principal
    )
{
    ACL_SIZE_INFORMATION    aclSizeInfo;
    ULONG                   i;
    LPVOID                  ace;
    ACCESS_ALLOWED_ACE      *accessAllowedAce;
    ACCESS_DENIED_ACE       *accessDeniedAce;
    SYSTEM_AUDIT_ACE        *systemAuditAce;
    PSID                    principalSID = NULL;
    DWORD                   returnValue = ERROR_SUCCESS;
    ACE_HEADER              *aceHeader;
    BOOL                    bWellKnownSID = FALSE;

    returnValue = GetPrincipalSID (Principal, &principalSID, &bWellKnownSID);
    if (returnValue != ERROR_SUCCESS)
        return returnValue;

    GetAclInformation (Acl,
                       (LPVOID) &aclSizeInfo,
                       (DWORD) sizeof (ACL_SIZE_INFORMATION),
                       AclSizeInformation);

    for (i = 0; i < aclSizeInfo.AceCount; i++)
    {
        if (!GetAce (Acl, i, &ace))
        {
            returnValue = GetLastError();
            break;
        }

        aceHeader = (ACE_HEADER *) ace;

        if (aceHeader->AceType == ACCESS_ALLOWED_ACE_TYPE)
        {
            accessAllowedAce = (ACCESS_ALLOWED_ACE *) ace;

            if (EqualSid (principalSID, (PSID) &accessAllowedAce->SidStart))
            {
                DeleteAce (Acl, i);
                break;
            }
        } else

        if (aceHeader->AceType == ACCESS_DENIED_ACE_TYPE)
        {
            accessDeniedAce = (ACCESS_DENIED_ACE *) ace;

            if (EqualSid (principalSID, (PSID) &accessDeniedAce->SidStart))
            {
                DeleteAce (Acl, i);
                break;
            }
        } else

        if (aceHeader->AceType == SYSTEM_AUDIT_ACE_TYPE)
        {
            systemAuditAce = (SYSTEM_AUDIT_ACE *) ace;

            if (EqualSid (principalSID, (PSID) &systemAuditAce->SidStart))
            {
                DeleteAce (Acl, i);
                break;
            }
        }
    }

    if (principalSID) {
        if (bWellKnownSID)
            FreeSid (principalSID);
        else
            free (principalSID);
    }

    return returnValue;
}

DWORD
GetCurrentUserSID (
    PSID *Sid
    )
{
    DWORD dwReturn = ERROR_SUCCESS;
    TOKEN_USER  *tokenUser = NULL;
    HANDLE      tokenHandle = NULL;
    DWORD       tokenSize;
    DWORD       sidLength;

    if (OpenProcessToken (GetCurrentProcess(), TOKEN_QUERY, &tokenHandle))
    {
        GetTokenInformation (tokenHandle, TokenUser, tokenUser, 0, &tokenSize);

        tokenUser = (TOKEN_USER *) malloc (tokenSize);
        if (!tokenUser)
        {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            return GetLastError();
        }

        if (GetTokenInformation (tokenHandle, TokenUser, tokenUser, tokenSize, &tokenSize))
        {
            sidLength = GetLengthSid (tokenUser->User.Sid);
            *Sid = (PSID) malloc (sidLength);
            if (*Sid)
            {
                memcpy (*Sid, tokenUser->User.Sid, sidLength);
            }
            CloseHandle (tokenHandle);
        } else
            dwReturn = GetLastError();

        if (tokenUser)
            free(tokenUser);

    } else
        dwReturn = GetLastError();

    return dwReturn;
}

DWORD
CreateNewSD (
    SECURITY_DESCRIPTOR **SD
    )
{
    PACL    dacl = NULL;
    DWORD   sidLength;
    PSID    sid;
    PSID    groupSID;
    PSID    ownerSID;
    DWORD   returnValue;

    *SD = NULL;

    returnValue = GetCurrentUserSID (&sid);
    if (returnValue != ERROR_SUCCESS) {
        if (sid)
            free(sid);

        return returnValue;
    }

    sidLength = GetLengthSid (sid);

    *SD = (SECURITY_DESCRIPTOR *) malloc (
        (sizeof (ACL)+sizeof (ACCESS_ALLOWED_ACE)+sidLength) +
        (2 * sidLength) +
        sizeof (SECURITY_DESCRIPTOR));

    if (!*SD)
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        returnValue = GetLastError();
        return returnValue;
    }

    groupSID = (SID *) (*SD + 1);
    ownerSID = (SID *) (((BYTE *) groupSID) + sidLength);
    dacl = (ACL *) (((BYTE *) ownerSID) + sidLength);

    if (!InitializeSecurityDescriptor (*SD, SECURITY_DESCRIPTOR_REVISION))
    {
        free (*SD);
        free (sid);
        returnValue = GetLastError();
        return returnValue;
    }

    if (!InitializeAcl (dacl,
                        sizeof (ACL)+sizeof (ACCESS_ALLOWED_ACE)+sidLength,
                        ACL_REVISION2))
    {
        free (*SD);
        free (sid);
        returnValue = GetLastError();
        return returnValue;
    }

    if (!AddAccessAllowedAce (dacl,
                              ACL_REVISION2,
                              COM_RIGHTS_EXECUTE,
                              sid))
    {
        free (*SD);
        free (sid);
        returnValue = GetLastError();
        return returnValue;
    }

    if (!SetSecurityDescriptorDacl (*SD, TRUE, dacl, FALSE))
    {
        free (*SD);
        free (sid);
        returnValue = GetLastError();
        return returnValue;
    }

    memcpy (groupSID, sid, sidLength);
    if (!SetSecurityDescriptorGroup (*SD, groupSID, FALSE))
    {
        free (*SD);
        free (sid);
        returnValue = GetLastError();
        return returnValue;
    }

    memcpy (ownerSID, sid, sidLength);
    if (!SetSecurityDescriptorOwner (*SD, ownerSID, FALSE))
    {
        free (*SD);
        free (sid);
        returnValue = GetLastError();
        return returnValue;
    }

    // check if everything went ok 
    if (!IsValidSecurityDescriptor(*SD)) 
    {
        free (*SD);
        free (sid);
        returnValue = ERROR_INVALID_SECURITY_DESCR;
        return returnValue;
    }
    
    
    if (sid)
        free(sid);
    return ERROR_SUCCESS;
}


DWORD
MakeSDAbsolute (
    PSECURITY_DESCRIPTOR OldSD,
    PSECURITY_DESCRIPTOR *NewSD
    )
{
    PSECURITY_DESCRIPTOR  sd = NULL;
    DWORD                 descriptorSize;
    DWORD                 daclSize;
    DWORD                 saclSize;
    DWORD                 ownerSIDSize;
    DWORD                 groupSIDSize;
    PACL                  dacl = NULL;
    PACL                  sacl = NULL;
    PSID                  ownerSID = NULL;
    PSID                  groupSID = NULL;
    BOOL                  present;
    BOOL                  systemDefault;

    //
    // Get SACL
    //

    if (!GetSecurityDescriptorSacl (OldSD, &present, &sacl, &systemDefault))
        return GetLastError();

    if (sacl && present)
    {
        saclSize = sacl->AclSize;
    } else saclSize = 0;

    //
    // Get DACL
    //

    if (!GetSecurityDescriptorDacl (OldSD, &present, &dacl, &systemDefault))
        return GetLastError();


    if (dacl && present)
    {
        daclSize = dacl->AclSize;
    } else daclSize = 0;

    //
    // Get Owner
    //

    if (!GetSecurityDescriptorOwner (OldSD, &ownerSID, &systemDefault))
        return GetLastError();

    ownerSIDSize = GetLengthSid (ownerSID);

    //
    // Get Group
    //

    if (!GetSecurityDescriptorGroup (OldSD, &groupSID, &systemDefault))
        return GetLastError();

    groupSIDSize = GetLengthSid (groupSID);

    //
    // Do the conversion
    //

    descriptorSize = 0;

    MakeAbsoluteSD (OldSD, sd, &descriptorSize, dacl, &daclSize, sacl,
                    &saclSize, ownerSID, &ownerSIDSize, groupSID,
                    &groupSIDSize);

    sd = (PSECURITY_DESCRIPTOR) new BYTE [SECURITY_DESCRIPTOR_MIN_LENGTH];
    if (!sd)
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return GetLastError();
    }
    if (!InitializeSecurityDescriptor (sd, SECURITY_DESCRIPTOR_REVISION))
        return GetLastError();

    if (!MakeAbsoluteSD (OldSD, sd, &descriptorSize, dacl, &daclSize, sacl,
                         &saclSize, ownerSID, &ownerSIDSize, groupSID,
                         &groupSIDSize))
        return GetLastError();

    *NewSD = sd;
    return ERROR_SUCCESS;
}

DWORD
SetNamedValueSD (
    HKEY RootKey,
    LPTSTR KeyName,
    LPTSTR ValueName,
    SECURITY_DESCRIPTOR *SD
    )
{
    DWORD   returnValue;
    DWORD   disposition;
    HKEY    registryKey;

    //
    // Create new key or open existing key
    //

    returnValue = RegCreateKeyEx (RootKey, KeyName, 0, _T(""), 0, KEY_ALL_ACCESS, NULL, &registryKey, &disposition);
    if (returnValue != ERROR_SUCCESS)
        return returnValue;

    //
    // Write the security descriptor
    //

    returnValue = RegSetValueEx (registryKey, ValueName, 0, REG_BINARY, (LPBYTE) SD, GetSecurityDescriptorLength (SD));
    if (returnValue != ERROR_SUCCESS)
        return returnValue;

    RegCloseKey (registryKey);

    return ERROR_SUCCESS;
}

DWORD
GetNamedValueSD (
    HKEY RootKey,
    LPTSTR KeyName,
    LPTSTR ValueName,
    SECURITY_DESCRIPTOR **SD,
    BOOL *NewSD
    )
{
    DWORD               returnValue;
    HKEY                registryKey;
    DWORD               valueType;
    DWORD               valueSize = 0;

    *NewSD = FALSE;

    //
    // Get the security descriptor from the named value. If it doesn't
    // exist, create a fresh one.
    //

    returnValue = RegOpenKeyEx (RootKey, KeyName, 0, KEY_ALL_ACCESS, &registryKey);

    if (returnValue != ERROR_SUCCESS)
    {
        if (returnValue == ERROR_FILE_NOT_FOUND)
        {
            *SD = NULL;
            returnValue = CreateNewSD (SD);
            if (returnValue != ERROR_SUCCESS) {
                if (*SD)
                    free(*SD);
                return returnValue;
            }

            *NewSD = TRUE;
            return ERROR_SUCCESS;
        } else
            return returnValue;
    }

    returnValue = RegQueryValueEx (registryKey, ValueName, NULL, &valueType, NULL, &valueSize);

    if (returnValue && returnValue != ERROR_INSUFFICIENT_BUFFER)
    {
        *SD = NULL;
        returnValue = CreateNewSD (SD);
        if (returnValue != ERROR_SUCCESS) {
            if (*SD)
                free(*SD);
            return returnValue;
        }

        *NewSD = TRUE;
    } else
    {
        *SD = (SECURITY_DESCRIPTOR *) malloc (valueSize);
        if (!*SD)
        {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            return GetLastError();
        }

        returnValue = RegQueryValueEx (registryKey,
                                       ValueName,
                                       NULL,
                                       &valueType,
                                       (LPBYTE) *SD,
                                       &valueSize);
        if (returnValue)
        {
            if (*SD)
                free (*SD);

            *SD = NULL;
            returnValue = CreateNewSD (SD);
            if (returnValue != ERROR_SUCCESS) {
                if (*SD)
                    free(*SD);
                return returnValue;
            }

            *NewSD = TRUE;
        }
    }

    RegCloseKey (registryKey);

    return ERROR_SUCCESS;
}

DWORD
AddPrincipalToNamedValueSD (
    HKEY RootKey,
    LPTSTR KeyName,
    LPTSTR ValueName,
    LPTSTR Principal,
    BOOL Permit
    )
{
    DWORD               returnValue = ERROR_SUCCESS;
    SECURITY_DESCRIPTOR *sd = NULL;
    SECURITY_DESCRIPTOR *sdSelfRelative = NULL;
    SECURITY_DESCRIPTOR *sdAbsolute = NULL;
    DWORD               secDescSize;
    BOOL                present;
    BOOL                defaultDACL;
    PACL                dacl;
    BOOL                newSD = FALSE;
    BOOL                fFreeAbsolute = TRUE;


    returnValue = GetNamedValueSD (RootKey, KeyName, ValueName, &sd, &newSD);

    //
    // Get security descriptor from registry or create a new one
    //

    if (returnValue != ERROR_SUCCESS)
        return returnValue;

    if (!GetSecurityDescriptorDacl (sd, &present, &dacl, &defaultDACL)) {
        returnValue = GetLastError();
        goto Cleanup;
    }

    if (newSD)
    {
        AddAccessAllowedACEToACL (&dacl, COM_RIGHTS_EXECUTE, TEXT("SYSTEM"));
        AddAccessAllowedACEToACL (&dacl, COM_RIGHTS_EXECUTE, TEXT("INTERACTIVE"));
    }

    //
    // Add the Principal that the caller wants added
    //

    if (Permit)
        returnValue = AddAccessAllowedACEToACL (&dacl, COM_RIGHTS_EXECUTE, Principal);
    else
        returnValue = AddAccessDeniedACEToACL (&dacl, GENERIC_ALL, Principal);

    if (returnValue != ERROR_SUCCESS)
        goto Cleanup;

    //
    // Make the security descriptor absolute if it isn't new
    //

    if (!newSD) {
        MakeSDAbsolute ((PSECURITY_DESCRIPTOR) sd, (PSECURITY_DESCRIPTOR *) &sdAbsolute);
        fFreeAbsolute = TRUE;
    } else {
        sdAbsolute = sd;
        fFreeAbsolute = FALSE;
    }

    //
    // Set the discretionary ACL on the security descriptor
    //

    if (!SetSecurityDescriptorDacl (sdAbsolute, TRUE, dacl, FALSE)) {
        returnValue = GetLastError();
        goto Cleanup;
    }

    //
    // Make the security descriptor self-relative so that we can
    // store it in the registry
    //

    secDescSize = 0;
    MakeSelfRelativeSD (sdAbsolute, sdSelfRelative, &secDescSize);
    sdSelfRelative = (SECURITY_DESCRIPTOR *) malloc (secDescSize);
    if (!sdSelfRelative)
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        returnValue = GetLastError();
        goto Cleanup;
    }


    if (!MakeSelfRelativeSD (sdAbsolute, sdSelfRelative, &secDescSize)) {
        returnValue = GetLastError();
        goto Cleanup;
    }

    //
    // Store the security descriptor in the registry
    //

    SetNamedValueSD (RootKey, KeyName, ValueName, sdSelfRelative);

Cleanup:
    if (sd)
        free (sd);
    if (sdSelfRelative)
        free (sdSelfRelative);
    if (fFreeAbsolute && sdAbsolute)
        free (sdAbsolute);

    return returnValue;
}

DWORD
RemovePrincipalFromNamedValueSD (
    HKEY RootKey,
    LPTSTR KeyName,
    LPTSTR ValueName,
    LPTSTR Principal
    )
{
    DWORD               returnValue = ERROR_SUCCESS;
    SECURITY_DESCRIPTOR *sd = NULL;
    SECURITY_DESCRIPTOR *sdSelfRelative = NULL;
    SECURITY_DESCRIPTOR *sdAbsolute = NULL;
    DWORD               secDescSize;
    BOOL                present;
    BOOL                defaultDACL;
    PACL                dacl = NULL;
    BOOL                newSD = FALSE;
    BOOL                fFreeAbsolute = TRUE;

    returnValue = GetNamedValueSD (RootKey, KeyName, ValueName, &sd, &newSD);

    //
    // Get security descriptor from registry or create a new one
    //

    if (returnValue != ERROR_SUCCESS)
        return returnValue;

    if (!GetSecurityDescriptorDacl (sd, &present, &dacl, &defaultDACL)) {
        returnValue = GetLastError();
        goto Cleanup;
    }

    //
    // If the security descriptor is new, add the required Principals to it
    //

    if (newSD)
    {
        AddAccessAllowedACEToACL (&dacl, COM_RIGHTS_EXECUTE, TEXT("SYSTEM"));
        AddAccessAllowedACEToACL (&dacl, COM_RIGHTS_EXECUTE, TEXT("INTERACTIVE"));
    }

    //
    // Remove the Principal that the caller wants removed
    //

    returnValue = RemovePrincipalFromACL (dacl, Principal);
    if (returnValue != ERROR_SUCCESS)
        goto Cleanup;

    //
    // Make the security descriptor absolute if it isn't new
    //

    if (!newSD) {
        MakeSDAbsolute ((PSECURITY_DESCRIPTOR) sd, (PSECURITY_DESCRIPTOR *) &sdAbsolute);
        fFreeAbsolute = TRUE;
    } else {
        sdAbsolute = sd;
        fFreeAbsolute = FALSE;
    }

    //
    // Set the discretionary ACL on the security descriptor
    //

    if (!SetSecurityDescriptorDacl (sdAbsolute, TRUE, dacl, FALSE)) {
        returnValue = GetLastError();
        goto Cleanup;
    }

    //
    // Make the security descriptor self-relative so that we can
    // store it in the registry
    //

    secDescSize = 0;
    MakeSelfRelativeSD (sdAbsolute, sdSelfRelative, &secDescSize);
    sdSelfRelative = (SECURITY_DESCRIPTOR *) malloc (secDescSize);
    if (!sdSelfRelative)
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        returnValue = GetLastError();
        goto Cleanup;
    }

    if (!MakeSelfRelativeSD (sdAbsolute, sdSelfRelative, &secDescSize)) {
        returnValue = GetLastError();
        goto Cleanup;
    }

    //
    // Store the security descriptor in the registry
    //

    SetNamedValueSD (RootKey, KeyName, ValueName, sdSelfRelative);

Cleanup:
    if (sd)
        free (sd);
    if (sdSelfRelative)
        free (sdSelfRelative);
    if (fFreeAbsolute && sdAbsolute)
        free (sdAbsolute);

    return returnValue;
}

DWORD
ChangeAppIDAccessACL (
    LPTSTR AppID,
    LPTSTR Principal,
    BOOL SetPrincipal,
    BOOL Permit
    )
{
    TCHAR   keyName [256];
    DWORD   err;

    wcscpy(keyName, TEXT("APPID\\"));
    wcscat(keyName, AppID);

    if (SetPrincipal)
    {
        err = RemovePrincipalFromNamedValueSD (HKEY_CLASSES_ROOT,
                                               keyName,
                                               TEXT("AccessPermission"),
                                               Principal);
        err = AddPrincipalToNamedValueSD (HKEY_CLASSES_ROOT,
                                          keyName,
                                          TEXT("AccessPermission"),
                                          Principal,
                                          Permit);
    }
    else
    {
        err = RemovePrincipalFromNamedValueSD (HKEY_CLASSES_ROOT,
                                               keyName,
                                               TEXT("AccessPermission"),
                                               Principal);
    }

    return err;
}

DWORD
ChangeAppIDLaunchACL (
    LPTSTR AppID,
    LPTSTR Principal,
    BOOL SetPrincipal,
    BOOL Permit
    )
{

    TCHAR   keyName [256];
    DWORD   err;

    wcscpy(keyName, TEXT("APPID\\"));
    wcscat(keyName, AppID);

    if (SetPrincipal)
    {
        err = RemovePrincipalFromNamedValueSD (HKEY_CLASSES_ROOT,
                                               keyName,
                                               TEXT("LaunchPermission"),
                                               Principal);
        err = AddPrincipalToNamedValueSD (HKEY_CLASSES_ROOT,
                                          keyName,
                                          TEXT("LaunchPermission"),
                                          Principal,
                                          Permit);
    }
    else
    {
        err = RemovePrincipalFromNamedValueSD (HKEY_CLASSES_ROOT,
                                               keyName,
                                               TEXT("LaunchPermission"),
                                               Principal);
    }

    return err;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\certobjt\iisdebug.h ===
#include <windows.h>
#include <tchar.h>

#define DEBUG_FLAG

#ifdef DEBUG_FLAG
    inline void _cdecl DebugTrace(LPTSTR lpszFormat, ...)
    {
	    int nBuf;
	    TCHAR szBuffer[512];
	    va_list args;
	    va_start(args, lpszFormat);

	    nBuf = _vsntprintf(szBuffer, sizeof(szBuffer), lpszFormat, args);
	    //ASSERT(nBuf < sizeof(szBuffer)); //Output truncated as it was > sizeof(szBuffer)

	    OutputDebugString(szBuffer);
	    va_end(args);
    }
#else
    inline void _cdecl DebugTrace(LPTSTR , ...){}
#endif

#define IISDebugOutput DebugTrace
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\certobj\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\certobj\password.h ===
#include "stdafx.h"

DWORD  CreateGoodPassword(BYTE *szPwd,DWORD dwLen);
LPTSTR CreatePassword(int iSize);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\certobj\iiscertobj.h ===
// IISCertObj.h : Declaration of the CIISCertObj

#ifndef __IISCERTOBJ_H_
#define __IISCERTOBJ_H_

#include "resource.h"       // main symbols


#ifdef FULL_OBJECT

class CCryptBlob
{
public:
	CCryptBlob()
	{
		m_blob.cbData = 0;
		m_blob.pbData = NULL;
	}
	virtual ~CCryptBlob()
	{
	}
	DWORD GetSize() {return m_blob.cbData;}
	BYTE * GetData() {return m_blob.pbData;}
	void Set(DWORD cb, BYTE * pb)
	{
		Destroy();
		m_blob.cbData = cb;
		m_blob.pbData = pb;
	}
	BOOL Resize(DWORD cb);
	operator CRYPT_DATA_BLOB *()
	{
		return &m_blob;
	}

protected:
	void Destroy()
	{
		if (m_blob.pbData != NULL)
			Free(m_blob.pbData);
	}
	virtual BYTE * Realloc(BYTE * pb, DWORD cb) = 0;
	virtual void Free(BYTE * pb) = 0;
	CRYPT_DATA_BLOB m_blob;
};

class CCryptBlobIMalloc : public CCryptBlob
{
public:
	virtual ~CCryptBlobIMalloc()
	{
		CCryptBlob::Destroy();
	}

protected:
	virtual BYTE * Realloc(BYTE * pb, DWORD cb)
	{
		return (BYTE *)CoTaskMemRealloc(pb, cb);
	}
	virtual void Free(BYTE * pb)
	{
		CoTaskMemFree(pb);
	}
};

class CCryptBlobLocal : public CCryptBlob
{
public:
	virtual ~CCryptBlobLocal()
	{
		CCryptBlob::Destroy();
	}

protected:
	virtual BYTE * Realloc(BYTE * pb, DWORD cb)
	{
		return (BYTE *)realloc(pb, cb);
	}
	virtual void Free(BYTE * pb)
	{
		free(pb);
	}
};
#endif // FULL_OBJECT


/////////////////////////////////////////////////////////////////////////////
// CIISCertObj
class ATL_NO_VTABLE CIISCertObj : 
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CIISCertObj, &CLSID_IISCertObj>,
    public IDispatchImpl<IIISCertObj, &IID_IIISCertObj, &LIBID_CERTOBJLib>
{
public:
    CIISCertObj(){}
    ~CIISCertObj(){}

DECLARE_REGISTRY_RESOURCEID(IDR_IISCERTOBJ)
DECLARE_NOT_AGGREGATABLE(CIISCertObj)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CIISCertObj)
	COM_INTERFACE_ENTRY(IIISCertObj)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// IIISCertObj
public:
    STDMETHOD(put_InstanceName)(BSTR newVal);
    STDMETHOD(put_UserName)(BSTR newVal);
    STDMETHOD(put_UserPassword)(BSTR newVal);
    STDMETHOD(put_ServerName)(BSTR newVal);
    STDMETHOD(IsInstalled)(VARIANT_BOOL * retval);
    STDMETHOD(IsInstalledRemote)(VARIANT_BOOL * retval);
    STDMETHOD(IsExportable)(VARIANT_BOOL * retval);
    STDMETHOD(IsExportableRemote)(VARIANT_BOOL * retval);
    STDMETHOD(GetCertInfo)(VARIANT * pVtArray);
    STDMETHOD(GetCertInfoRemote)(VARIANT * pVtArray);
    STDMETHOD(Copy)(BOOL bAllowExport, BSTR DestinationServerName, BSTR DestinationServerInstance, VARIANT DestinationServerUserName OPTIONAL, VARIANT DestinationServerPassword OPTIONAL);
    STDMETHOD(CopyToCertStore)(BOOL bAllowExport, BSTR bstrDestinationServerName,VARIANT varDestinationServerUserName,VARIANT varDestinationServerPassword,VARIANT * pVtArray);
    STDMETHOD(Move)(BOOL bAllowExport,BSTR DestinationServerName, BSTR DestinationServerInstance, VARIANT DestinationServerUserName OPTIONAL, VARIANT DestinationServerPassword OPTIONAL);
    STDMETHOD(RemoveCert)(BOOL bPrivateKey);
    STDMETHOD(Import)(BSTR FileName, BSTR Password, BOOL bAllowExport);
    STDMETHOD(ImportToCertStore)(BSTR FileName, BSTR Password, BOOL bAllowExport, VARIANT* BinaryVariant);
    STDMETHOD(ImportFromBlob)(BSTR InstanceName, BSTR Password, BOOL bInstallToMetabase, BOOL bAllowExport, DWORD pcbSize, char * pBlobBinary);
    STDMETHOD(ImportFromBlobGetHash)(BSTR InstanceName, BSTR Password, BOOL bInstallToMetabase, BOOL bAllowExport, DWORD pcbSize, char * pBlobBinary, DWORD * pcbCertHashSize, char ** bCertHash);
    STDMETHOD(Export)(BSTR FileName, BSTR Password, BOOL bPrivateKey, BOOL bCertChain, BOOL bRemoveCert);
    STDMETHOD(ExportToBlob)(BSTR InstanceName, BSTR Password, BOOL bPrivateKey, BOOL bCertChain, DWORD * pcbSize, char ** pBlobBinary);

private:
    CString m_ServerName;
    CString m_UserName;
    CString m_UserPassword;
    CString m_InstanceName;
    CComPtr<IIISCertObj> m_pObj;
    IIISCertObj * GetObject(HRESULT * phr);
    IIISCertObj * GetObject(HRESULT * phr, CString csServerName,CString csUserName OPTIONAL,CString csUserPassword OPTIONAL);
    HRESULT CopyOrMove(BOOL bRemoveFromCertAfterCopy,BOOL bCopyCertDontInstallRetHash,BOOL bAllowExport,VARIANT * pVtArray,BSTR bstrDestinationServerName,BSTR bstrDestinationServerInstance,VARIANT varDestinationServerUserName, VARIANT varDestinationServerPassword);
};
HRESULT RemoveCertProxy(IIISCertObj * pObj,BSTR InstanceName, BOOL bPrivateKey);
HRESULT ImportFromBlobProxy(IIISCertObj * pObj,BSTR InstanceName,BSTR Password,BOOL bInstallToMetabase,BOOL bAllowExport,DWORD actual,BYTE *pData,DWORD *cbHashBufferSize,char **pbHashBuffer);
HRESULT ExportToBlobProxy(IIISCertObj * pObj,BSTR InstanceName,BSTR Password,BOOL bPrivateKey,BOOL bCertChain,DWORD * pcbSize,char ** pBlobBinary);



#ifdef FULL_OBJECT

class ATL_NO_VTABLE CIISCertificate : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CIISCertObj, &CLSID_IISCertObj>,
	public IDispatchImpl<IIISCertObj, &IID_IIISCertObj, &LIBID_CERTOBJLib>
{
public:
   CIISCertificate() :m_bInitDone(FALSE),m_pEnroll(NULL)
	{
	}
   ~CIISCertificate()
   {
      if (m_pEnroll != NULL)
      {
         m_pEnroll->Release();
      }
   }

DECLARE_REGISTRY_RESOURCEID(IDR_IISCERTOBJ)
DECLARE_NOT_AGGREGATABLE(CIISCertificate)
DECLARE_PROTECT_FINAL_CONSTRUCT()

// IIISCertificate
public:
	STDMETHOD(CreateRequest)(BSTR FileName);
	STDMETHOD(ProcessResponse)(BSTR FileName);
	STDMETHOD(RequestCert)(BSTR CertAuthority);
	STDMETHOD(LoadSettings)(BSTR ApplicationKey, BSTR SettingsKey);
	STDMETHOD(SaveSettings)(BSTR ApplicationKey, BSTR SettingsKey);
	STDMETHOD(put_SGC_Cert)(BOOL newVal);
	STDMETHOD(put_KeySize)(int newVal);
	STDMETHOD(put_CertTemplate)(BSTR newVal);
	STDMETHOD(put_CertAuthority)(BSTR newVal);
	STDMETHOD(put_Country)(BSTR newVal);
	STDMETHOD(put_State)(BSTR newVal);
	STDMETHOD(put_Locality)(BSTR newVal);
	STDMETHOD(put_OrganizationUnit)(BSTR newVal);
	STDMETHOD(put_Organization)(BSTR newVal);
	STDMETHOD(put_FriendlyName)(BSTR newVal);
	STDMETHOD(put_CommonName)(BSTR newVal);
	STDMETHOD(put_Password)(BSTR newVal);

    STDMETHOD(put_InstanceName)(BSTR newVal);
	STDMETHOD(put_UserName)(BSTR newVal);
	STDMETHOD(put_UserPassword)(BSTR newVal);
	STDMETHOD(put_ServerName)(BSTR newVal);

private:
   CComPtr<IIISCertObj> m_pObj;
   CString m_InstanceName;
   CString m_ServerName;
   CString m_UserName;
   CString m_UserPassword;

   CString m_Password;
   CString m_CommonName;
   CString m_FriendlyName;
   CString m_Organization;
   CString m_OrganizationUnit;
   CString m_Locality;
   CString m_State;
   CString m_Country;
   CString m_CertAuthority;
   CString m_CertTemplate;

   int m_KeySize;
   BOOL m_SGC_Cert;
   BOOL m_bInitDone;
   IEnroll * m_pEnroll;

   IIISCertObj * GetObject(HRESULT * phr);
   IIISCertObj * GetObject(HRESULT * phr, CString csServerName,CString csUserName OPTIONAL,CString csUserPassword OPTIONAL);

   STDMETHOD(Init)();
   STDMETHOD(CreateDNString)(CString& str);
   IEnroll * GetEnroll();
};
#endif // FULL_OBJECT

#endif //__IISCERTOBJ_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\certobj\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by CertObj.rc
//
#define IDS_PROJNAME                    100
#define IDR_IISCERTOBJ                  101

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\certobj\iisdebug.h ===
#include "stdafx.h"

//#define DEBUG_FLAG

#ifdef DEBUG_FLAG
    inline void _cdecl DebugTrace(LPTSTR lpszFormat, ...)
    {
	    int nBuf;
	    TCHAR szBuffer[512];
	    va_list args;
	    va_start(args, lpszFormat);

	    nBuf = _vsntprintf(szBuffer, sizeof(szBuffer), lpszFormat, args);
            //ASSERT(nBuf < sizeof(szBuffer)); //Output truncated as it was > sizeof(szBuffer)

	    OutputDebugString(szBuffer);
	    va_end(args);
    }
#else
    inline void _cdecl DebugTrace(LPTSTR , ...){}
#endif

#define IISDebugOutput DebugTrace
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\certobj\password.cpp ===
#include "stdafx.h"
#include "password.h"

// password categories
enum {STRONG_PWD_UPPER=0,STRONG_PWD_LOWER,STRONG_PWD_NUM,STRONG_PWD_PUNC};
#define STRONG_PWD_CATS (STRONG_PWD_PUNC + 1)
#define NUM_LETTERS 26
#define NUM_NUMBERS 10
#define MIN_PWD_LEN 8

// password must contain at least one each of: 
// uppercase, lowercase, punctuation and numbers
DWORD CreateGoodPassword(BYTE *szPwd, DWORD dwLen) 
{
    if (dwLen-1 < MIN_PWD_LEN)
    {
        return ERROR_PASSWORD_RESTRICTION;
    }

    HCRYPTPROV hProv;
    DWORD dwErr = 0;

    if (CryptAcquireContext(&hProv,NULL,NULL,PROV_RSA_FULL,CRYPT_VERIFYCONTEXT) == FALSE) 
    {
        return GetLastError();
    }

    // zero it out and decrement the size to allow for trailing '\0'
    ZeroMemory(szPwd,dwLen);
    dwLen--;

    // generate a pwd pattern, each byte is in the range 
    // (0..255) mod STRONG_PWD_CATS
    // this indicates which character pool to take a char from
    BYTE *pPwdPattern = new BYTE[dwLen];
    BOOL fFound[STRONG_PWD_CATS];
    do 
    {
        // bug!bug! does CGR() ever fail?
        CryptGenRandom(hProv,dwLen,pPwdPattern);

        fFound[STRONG_PWD_UPPER] = 
        fFound[STRONG_PWD_LOWER] =
        fFound[STRONG_PWD_PUNC] =
        fFound[STRONG_PWD_NUM] = FALSE;

        for (DWORD i=0; i < dwLen; i++)
        {
            fFound[pPwdPattern[i] % STRONG_PWD_CATS] = TRUE;
        }
        // check that each character category is in the pattern
    } while (!fFound[STRONG_PWD_UPPER] || !fFound[STRONG_PWD_LOWER] || !fFound[STRONG_PWD_PUNC] || !fFound[STRONG_PWD_NUM]);

    // populate password with random data 
    // this, in conjunction with pPwdPattern, is
    // used to determine the actual data
    CryptGenRandom(hProv,dwLen,szPwd);

    for (DWORD i=0; i < dwLen; i++) 
    {
        BYTE bChar = 0;

        // there is a bias in each character pool because of the % function
        switch (pPwdPattern[i] % STRONG_PWD_CATS) 
        {
            case STRONG_PWD_UPPER : bChar = 'A' + szPwd[i] % NUM_LETTERS;
                break;
            case STRONG_PWD_LOWER : bChar = 'a' + szPwd[i] % NUM_LETTERS;
                break;
            case STRONG_PWD_NUM :   bChar = '0' + szPwd[i] % NUM_NUMBERS;
                break;
            case STRONG_PWD_PUNC :
            default:
                char *szPunc="!@#$%^&*()_-+=[{]};:\'\"<>,./?\\|~`";
                DWORD dwLenPunc = lstrlenA(szPunc);
                bChar = szPunc[szPwd[i] % dwLenPunc];
                break;
        }
        szPwd[i] = bChar;
    }

    delete pPwdPattern;

    if (hProv != NULL) 
    {
        CryptReleaseContext(hProv,0);
    }
    return dwErr;
}


// Creates a secure password
// caller must GlobalFree Return pointer
// iSize = size of password to create
LPTSTR CreatePassword(int iSize)
{
    LPTSTR pszPassword =  NULL;
    BYTE *szPwd = new BYTE[iSize];
    DWORD dwPwdLen = iSize;
    int i = 0;

    // use the new secure password generator
    // unfortunately this baby doesn't use unicode.
    // so we'll call it and then convert it to unicode afterwards.
    if (0 == CreateGoodPassword(szPwd,dwPwdLen))
    {
#if defined(UNICODE) || defined(_UNICODE)
        // convert it to unicode and copy it back into our unicode buffer.
        // compute the length
        i = MultiByteToWideChar(CP_ACP, 0, (LPSTR) szPwd, -1, NULL, 0);
        if (i <= 0) 
            {goto CreatePassword_Exit;}
        pszPassword = (LPTSTR) GlobalAlloc(GPTR, i * sizeof(TCHAR));
        if (!pszPassword)
            {goto CreatePassword_Exit;}
        i =  MultiByteToWideChar(CP_ACP, 0, (LPSTR) szPwd, -1, pszPassword, i);
        if (i <= 0) 
            {
            GlobalFree(pszPassword);
            pszPassword = NULL;
            goto CreatePassword_Exit;
            }
        // make sure ends with null
        pszPassword[i - 1] = 0;
#else
        pszPassword = (LPSTR) GlobalAlloc(GPTR, _tcslen((LPTSTR) szPwd) * sizeof(TCHAR));
#endif
    }

CreatePassword_Exit:
    if (szPwd){delete szPwd;szPwd=NULL;}
    return pszPassword;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\certobj\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(_STDAFX_H)
#define _STDAFX_H

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0500
#endif
#define _ATL_APARTMENT_THREADED

#include <windows.h>

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

#include <comdef.h>
#include <xenroll.h>

#define _WTL_NO_CSTRING

#include <atlwin.h>
#include <atlapp.h>
#include <atldlgs.h>
#include <atlmisc.h>
#include <atlctrls.h>
#include <atlddx.h>
#include <atlcrack.h>

#include <list>
#include <map>
#include <stack>
#include <set>
#include <memory>

#include "iisdebug.h"

#include <shlwapi.h>
//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(_STDAFX)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\certwiz\base64.h ===
//
// base64.h
//
#ifndef _BASE64_H
#define _BASE64_H

DWORD Base64DecodeA(const char * pchIn, DWORD cchIn, BYTE * pbOut, DWORD * pcbOut);
DWORD Base64EncodeA(const BYTE * pbIn, DWORD cbIn, char * pchOut, DWORD * pcchOut);
DWORD Base64EncodeW(BYTE const *pbIn, DWORD cbIn, WCHAR *wszOut, DWORD *pcchOut);
DWORD Base64DecodeW(const WCHAR * wszIn, DWORD cch, BYTE *pbOut, DWORD *pcbOut);

#endif	//_BASE64_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\certwiz\base64.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996-1996
//
// File:        base64.cpp
//
// Contents:    base64 encode/decode implementation
//
// History:     25-Jul-96       vich created
//
//---------------------------------------------------------------------------
//               3-Mar-98   tompop took and modified it.  Building
//                          both Ansi and Wchar versions of Encode/Decode
//                          base 64 for CertWizard, that is in IIS5's UI.
//                          We merged the examples from NT5's base64.cpp
//                          and ubase64.cpp files into this single file.
//						5-Aug-98	 Sergei Antonov removed above mentioned stuff after tompop
//---------------------------------------------------------------------------
#include "stdafx.h"
#include <malloc.h>
#include <windows.h>
#include "base64.h"

// The following table translates an ascii subset to 6 bit values as follows
// (see rfc 1521):
//
//  input    hex (decimal)
//  'A' --> 0x00 (0)
//  'B' --> 0x01 (1)
//  ...
//  'Z' --> 0x19 (25)
//  'a' --> 0x1a (26)
//  'b' --> 0x1b (27)
//  ...
//  'z' --> 0x33 (51)
//  '0' --> 0x34 (52)
//  ...
//  '9' --> 0x3d (61)
//  '+' --> 0x3e (62)
//  '/' --> 0x3f (63)
//
// Encoded lines must be no longer than 76 characters.
// The final "quantum" is handled as follows:  The translation output shall
// always consist of 4 characters.  'x', below, means a translated character,
// and '=' means an equal sign.  0, 1 or 2 equal signs padding out a four byte
// translation quantum means decoding the four bytes would result in 3, 2 or 1
// unencoded bytes, respectively.
//
//  unencoded size    encoded data
//  --------------    ------------
//     1 byte       "xx=="
//     2 bytes      "xxx="
//     3 bytes      "xxxx"

#define CB_BASE64LINEMAX    64  // others use 64 -- could be up to 76

// Any other (invalid) input character value translates to 0x40 (64)

const BYTE abDecode[256] =
{
    /* 00: */ 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
    /* 10: */ 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
    /* 20: */ 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 62, 64, 64, 64, 63,
    /* 30: */ 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 64, 64, 64, 64, 64, 64,
    /* 40: */ 64,  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14,
    /* 50: */ 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 64, 64, 64, 64, 64,
    /* 60: */ 64, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,
    /* 70: */ 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 64, 64, 64, 64, 64,
    /* 80: */ 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
    /* 90: */ 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
    /* a0: */ 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
    /* b0: */ 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
    /* c0: */ 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
    /* d0: */ 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
    /* e0: */ 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
    /* f0: */ 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
};


const UCHAR abEncode[] =
    /*  0 thru 25: */ "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
    /* 26 thru 51: */ "abcdefghijklmnopqrstuvwxyz"
    /* 52 thru 61: */ "0123456789"
    /* 62 and 63: */  "+/";


DWORD
Base64DecodeA(const char * pchIn, DWORD cchIn, BYTE * pbOut, DWORD * pcbOut)
{
	DWORD err = ERROR_SUCCESS;
   DWORD cchInDecode, cbOutDecode;
   CHAR const *pchInEnd;
   CHAR const *pchInT;
   BYTE *pbOutT;

   // Count the translatable characters, skipping whitespace & CR-LF chars.
   cchInDecode = 0;
   pchInEnd = &pchIn[cchIn];
   for (pchInT = pchIn; pchInT < pchInEnd; pchInT++)
   {
		if (sizeof(abDecode) < (unsigned) *pchInT || abDecode[*pchInT] > 63)
		{
			// skip all whitespace
			if (	*pchInT == ' ' 
				||	*pchInT == '\t' 
				||	*pchInT == '\r' 
				||	*pchInT == '\n'
				)
			{
				continue;
			}

			if (0 != cchInDecode)
			{
				if ((cchInDecode % 4) == 0)
				{
					break;          // ends on quantum boundary
			}

			// The length calculation may stop in the middle of the last
			// translation quantum, because the equal sign padding
			// characters are treated as invalid input.  If the last
			// translation quantum is not 4 bytes long, it must be 2 or 3
			// bytes long.

			if (*pchInT == '=' && (cchInDecode % 4) != 1)
			{
				break;              // normal termination
			}
		}
      err = ERROR_INVALID_DATA;
      goto error;
	}
   cchInDecode++;
   }
    ASSERT(pchInT <= pchInEnd);
    pchInEnd = pchInT;      // don't process any trailing stuff again

    // We know how many translatable characters are in the input buffer, so now
    // set the output buffer size to three bytes for every four (or fraction of
    // four) input bytes.

    cbOutDecode = ((cchInDecode + 3) / 4) * 3;

    pbOutT = pbOut;

    if (NULL == pbOut)
    {
    pbOutT += cbOutDecode;
    }
    else
    {
    // Decode one quantum at a time: 4 bytes ==> 3 bytes

    ASSERT(cbOutDecode <= *pcbOut);
    pchInT = pchIn;
    while (cchInDecode > 0)
    {
        DWORD i;
        BYTE ab4[4];

        memset(ab4, 0, sizeof(ab4));
        for (i = 0; i < min(sizeof(ab4)/sizeof(ab4[0]), cchInDecode); i++)
        {
        while (
            sizeof(abDecode) > (unsigned) *pchInT &&
            63 < abDecode[*pchInT])
        {
            pchInT++;
        }
        ASSERT(pchInT < pchInEnd);
        ab4[i] = (BYTE) *pchInT++;
        }

        // Translate 4 input characters into 6 bits each, and deposit the
        // resulting 24 bits into 3 output bytes by shifting as appropriate.

        // out[0] = in[0]:in[1] 6:2
        // out[1] = in[1]:in[2] 4:4
        // out[2] = in[2]:in[3] 2:6

        *pbOutT++ =
        (BYTE) ((abDecode[ab4[0]] << 2) | (abDecode[ab4[1]] >> 4));

        if (i > 2)
        {
        *pbOutT++ =
          (BYTE) ((abDecode[ab4[1]] << 4) | (abDecode[ab4[2]] >> 2));
        }
        if (i > 3)
        {
        *pbOutT++ = (BYTE) ((abDecode[ab4[2]] << 6) | abDecode[ab4[3]]);
        }
        cchInDecode -= i;
    }
    ASSERT((DWORD) (pbOutT - pbOut) <= cbOutDecode);
    }
    *pcbOut = (DWORD)(pbOutT - pbOut);
error:
    return(err);
}

// Base64EncodeA 
//
// RETURNS  0 (i.e. ERROR_SUCCESS) on success
//


DWORD
Base64EncodeA(
    IN BYTE const *pbIn,
    IN DWORD cbIn,
    OUT CHAR *pchOut,
    OUT DWORD *pcchOut)
{
    CHAR *pchOutT;
    DWORD cchOutEncode;

    // Allocate enough memory for full final translation quantum.
    cchOutEncode = ((cbIn + 2) / 3) * 4;

    // and enough for CR-LF pairs for every CB_BASE64LINEMAX character line.
    cchOutEncode +=
		2 * ((cchOutEncode + CB_BASE64LINEMAX - 1) / CB_BASE64LINEMAX);

    pchOutT = pchOut;
	if (NULL == pchOut)
   {
		pchOutT += cchOutEncode;
   }
   else
   {
		DWORD cCol;

    ASSERT(cchOutEncode <= *pcchOut);
    cCol = 0;
    while ((long) cbIn > 0) // signed comparison -- cbIn can wrap
    {
        BYTE ab3[3];

        if (cCol == CB_BASE64LINEMAX/4)
        {
        cCol = 0;
        *pchOutT++ = '\r';
        *pchOutT++ = '\n';
        }
        cCol++;
        memset(ab3, 0, sizeof(ab3));

        ab3[0] = *pbIn++;
        if (cbIn > 1)
        {
        ab3[1] = *pbIn++;
        if (cbIn > 2)
        {
            ab3[2] = *pbIn++;
        }
        }

        *pchOutT++ = abEncode[ab3[0] >> 2];
        *pchOutT++ = abEncode[((ab3[0] << 4) | (ab3[1] >> 4)) & 0x3f];
        *pchOutT++ = (cbIn > 1)?
            abEncode[((ab3[1] << 2) | (ab3[2] >> 6)) & 0x3f] : '=';
        *pchOutT++ = (cbIn > 2)? abEncode[ab3[2] & 0x3f] : '=';

        cbIn -= 3;
    }
    *pchOutT++ = '\r';
    *pchOutT++ = '\n';
    ASSERT((DWORD) (pchOutT - pchOut) <= cchOutEncode);
    }
    *pcchOut = (DWORD)(pchOutT - pchOut);
    return(ERROR_SUCCESS);
}

// Base64EncodeW 
//
// RETURNS  0 (i.e. ERROR_SUCCESS) on success
//

DWORD Base64EncodeW(
    BYTE const *pbIn,
    DWORD cbIn,
    WCHAR *wszOut,
    DWORD *pcchOut)

{

    DWORD   cchOut;
    char   *pch = NULL;
    DWORD   cch;
    DWORD   err;

    ASSERT(pcchOut != NULL);

    // only want to know how much to allocate
    // we know all base64 char map 1-1 with unicode
    if( wszOut == NULL ) {

        // get the number of characters
        *pcchOut = 0;
        err = Base64EncodeA(
                pbIn,
                cbIn,
                NULL,
                pcchOut);
    }

    // otherwise we have an output buffer
    else {

        // char count is the same be it ascii or unicode,
        cchOut = *pcchOut;
        cch = 0;
        err = ERROR_OUTOFMEMORY;
        if( (pch = (char *) malloc(cchOut)) != NULL  &&
        
            (err = Base64EncodeA(
                pbIn,
                cbIn,
                pch,
                &cchOut)) == ERROR_SUCCESS      ) {

            // should not fail!
            cch = MultiByteToWideChar(0, 
                            0, 
                            pch, 
                            cchOut, 
                            wszOut, 
                            *pcchOut);

            // check to make sure we did not fail                            
            ASSERT(*pcchOut == 0 || cch != 0);                            
        }
    }

    if(pch != NULL)
        free(pch);

    return(err);
}

// Base64DecodeW 
//
// RETURNS  0 (i.e. ERROR_SUCCESS) on success
//

DWORD Base64DecodeW(
    const WCHAR * wszIn,
    DWORD cch,
    BYTE *pbOut,
    DWORD *pcbOut)
{

    char *pch;
    DWORD err = ERROR_SUCCESS;
    
    if( (pch = (char *) malloc(cch)) == NULL ) 
	 {
        err = ERROR_OUTOFMEMORY;
    }
    else if( WideCharToMultiByte(0, 0, wszIn, cch, pch, cch, 
                        NULL, NULL) == 0 ) 
	 {
        err = ERROR_NO_DATA;
    }
    else if( pbOut == NULL ) 
	 {
        *pcbOut = 0;
        err = Base64DecodeA(pch, cch, NULL, pcbOut);
    }
    else 
	 {
        err = Base64DecodeA(pch, cch, pbOut, pcbOut);
    }
    if(pch != NULL)
        free(pch);
    return(err);
}

#if 0
// sanity tests...  Lets make sure that the encode and decode
//                  works...

BOOL test_Base64EncodeW()
{
    BYTE  pbIn[120];            // for the test we just use the random stack data
    DWORD cbIn = sizeof( pbIn );
    
    WCHAR *wszB64Out;
    DWORD pcchB64Out;

    DWORD  err;
    
    // BASE64 encode pkcs 10
    if( (err = Base64EncodeW(
                pbIn,
                cbIn,
                NULL,
                &pcchB64Out)) != ERROR_SUCCESS     ||
        (wszB64Out = (WCHAR *) _alloca(pcchB64Out * sizeof(WCHAR))) == NULL  ||
        (err = Base64EncodeW(
                pbIn,
                cbIn,
                wszB64Out,
                &pcchB64Out)) != ERROR_SUCCESS ) 
    {
        SetLastError(err);
        return FALSE;  //goto ErrorBase64Encode;
    }


    // well the encode worked lets test the decode
    //
    // pcchB64Out holds the B64 data length
    // wszB64Out  holds the actual data

     DWORD blob_cbData;     // we store in these variables what
     BYTE* blob_pbData;     //  we read in..

    // They should match the stuff stored in:
    //    BYTE  pbIn[120];
    //    DWORD cbIn = sizeof( pbIn );
    // This we be tested after the decode.

    // base64 decode
    if( (err = Base64DecodeW(
            wszB64Out,
            pcchB64Out,
            NULL,
            &blob_cbData)) != ERROR_SUCCESS                    ||
        (blob_pbData = (BYTE *) _alloca(blob_cbData)) == NULL      ||
        (err = Base64DecodeW(
            wszB64Out,
            pcchB64Out,
            blob_pbData,
            &blob_cbData)) != ERROR_SUCCESS ) 
    {
        
        SetLastError(err);
        return(FALSE);  //goto ErrorBase64Decode;
    }



    //do compare

    
    return( (blob_cbData==cbIn)
            &&  (memcmp(blob_pbData, pbIn,cbIn)==0) );
    

 }
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\certwiz\bookendpage.cpp ===
//
// BookEndPage.cpp
//
#include "stdafx.h"
#include "BookEndPage.h"

IMPLEMENT_DYNCREATE(CIISWizardBookEnd2, CIISWizardPage)

CIISWizardBookEnd2::CIISWizardBookEnd2(
		HRESULT * phResult,
		UINT nIDWelcomeTxtSuccess,
		UINT nIDWelcomeTxtFailure,
		UINT nIDCaption,
		UINT * pnIDBodyTxtSuccess,
		CString * pBodyTxtSuccess,
		UINT * pnIDBodyTxtFailure,
		CString * pBodyTxtFailure,
		UINT nIDClickTxt,
		UINT nIDTemplate
		)
	: CIISWizardPage(nIDTemplate ? nIDTemplate : CIISWizardBookEnd2::IDD, nIDCaption),
	m_phResult(phResult),
	m_nIDWelcomeTxtSuccess(nIDWelcomeTxtSuccess),
	m_nIDWelcomeTxtFailure(nIDWelcomeTxtFailure),
	m_pnIDBodyTxtSuccess(pnIDBodyTxtSuccess),
	m_pBodyTxtSuccess(pBodyTxtSuccess),
	m_pnIDBodyTxtFailure(pnIDBodyTxtFailure),
	m_pBodyTxtFailure(pBodyTxtFailure),
	m_nIDClickTxt(nIDClickTxt),
	m_bTemplateAvailable(nIDTemplate != 0)
{
    ASSERT(m_phResult != NULL); // Must know success/failure
}

CIISWizardBookEnd2::CIISWizardBookEnd2(
		UINT nIDTemplate,
		UINT nIDCaption,
		UINT * pnIDBodyTxt,
		CString * pBodyTxt,
		UINT nIDWelcomeTxt,        
		UINT nIDClickTxt
		)
	: CIISWizardPage(nIDTemplate ? nIDTemplate : CIISWizardBookEnd2::IDD, nIDCaption),
   m_phResult(NULL),
	m_nIDWelcomeTxtSuccess(nIDWelcomeTxt),
	m_nIDWelcomeTxtFailure(USE_DEFAULT_CAPTION),
	m_pnIDBodyTxtSuccess(pnIDBodyTxt),
	m_pBodyTxtSuccess(pBodyTxt),
	m_pnIDBodyTxtFailure(NULL),
	m_pBodyTxtFailure(NULL),
	m_nIDClickTxt(nIDClickTxt),
	m_bTemplateAvailable(nIDTemplate != 0)
{
}

BOOL
CIISWizardBookEnd2::OnSetActive()
{
   if (!m_strWelcome.IsEmpty())
		SetDlgItemText(IDC_STATIC_WZ_WELCOME, m_strWelcome);
	if (!m_strBody.IsEmpty())
		SetDlgItemText(IDC_STATIC_WZ_BODY, m_strBody);
	if (!m_strClick.IsEmpty())
		SetDlgItemText(IDC_STATIC_WZ_CLICK, m_strClick);
	
	SetWizardButtons(IsWelcomePage() ? PSWIZB_NEXT : PSWIZB_FINISH);
	
	return CIISWizardPage::OnSetActive();
}

//
// Message Map
//
BEGIN_MESSAGE_MAP(CIISWizardBookEnd2, CIISWizardPage)
    //{{AFX_MSG_MAP(CIISWizardBookEnd)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

BOOL 
CIISWizardBookEnd2::OnInitDialog() 
{
	CIISWizardPage::OnInitDialog();

   //
   // Make the "Click 'foo' to continue" message bold as well.
   //
//   ApplyFontToControls(this, GetBoldFont(), IDC_STATIC_WZ_CLICK, IDC_STATIC_WZ_CLICK);

	if (m_nIDClickTxt)
	{
		VERIFY(m_strClick.LoadString(m_nIDClickTxt));
	}
   if (IsWelcomePage())
   {
		if (m_nIDWelcomeTxtSuccess)
		{
			VERIFY(m_strWelcome.LoadString(m_nIDWelcomeTxtSuccess));
		}
		if (m_pBodyTxtSuccess != NULL)
		{
			m_strBody = *m_pBodyTxtSuccess;
		}
		else if (m_pnIDBodyTxtSuccess != NULL)
		{
			VERIFY(m_strBody.LoadString(*m_pnIDBodyTxtSuccess));
		}
   }
   else
   {
		CError err(*m_phResult);
		if (err.Succeeded())		
		{
			if (m_nIDWelcomeTxtSuccess)
			{
				VERIFY(m_strWelcome.LoadString(m_nIDWelcomeTxtSuccess));
			}
			if (m_pBodyTxtSuccess != NULL && !m_pBodyTxtSuccess->IsEmpty())
			{
				m_strBody = *m_pBodyTxtSuccess;
			}
			else if (m_pnIDBodyTxtSuccess != NULL && *m_pnIDBodyTxtSuccess != USE_DEFAULT_CAPTION)
			{
				VERIFY(m_strBody.LoadString(*m_pnIDBodyTxtSuccess));
			}
		}
		else
		{
			if (m_nIDWelcomeTxtFailure)
			{
				VERIFY(m_strWelcome.LoadString(m_nIDWelcomeTxtFailure));
			}
			if (m_pBodyTxtFailure != NULL && !m_pBodyTxtFailure->IsEmpty())
			{
				m_strBody = *m_pBodyTxtFailure;
			}
			else if (m_pnIDBodyTxtFailure != NULL && *m_pnIDBodyTxtFailure != USE_DEFAULT_CAPTION)
			{
				VERIFY(m_strBody.LoadString(*m_pnIDBodyTxtFailure));
			}
			else
			{
				// Build body text string and expand error messages
				m_strBody = _T("%h");
				err.TextFromHRESULTExpand(m_strBody);
			}
		}
   }

	SetWizardButtons(IsWelcomePage() ? PSWIZB_NEXT : PSWIZB_FINISH);
	// We don't have documented way to disable Cancel button
   if (!IsWelcomePage())
		GetParent()->GetDlgItem(IDCANCEL)->EnableWindow(FALSE);

   return TRUE;  
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\certobjt\main.cpp ===
#include <stdio.h>

#define INITGUID // must be before guid stuff

#include "iisdebug.h"

#include "certobj.h"      // Interface header
#include "certobj_i.c"

BOOL TestCertObj(void);

LPSTR StripWhitespace( LPSTR pszString )
{
    LPSTR pszTemp = NULL;

    if ( pszString == NULL ) {
        return NULL;
    }

    while ( *pszString == ' ' || *pszString == '\t' ) {
        pszString += 1;
    }

    // Catch case where string consists entirely of whitespace or empty string.
    if ( *pszString == '\0' ) {
        return pszString;
    }

    pszTemp = pszString;

    pszString += lstrlenA(pszString) - 1;

    while ( *pszString == ' ' || *pszString == '\t' ) {
        *pszString = '\0';
        pszString -= 1;
    }

    return pszTemp;
}

void
ShowHelp()
{
    wprintf(L"tests the CertObj control\n\n");
    return;
}

int __cdecl 
main(
     int argc,
     char *argv[]
)
{
    BOOL fRet = FALSE;
    int argno;
	char * pArg = NULL;
	char * pCmdStart = NULL;
    char szTempString[MAX_PATH];

    int iGotParamS = FALSE;
    int iGotParamP = FALSE;
    int iDoA  = FALSE;

    WCHAR wszDirPath[MAX_PATH];
    WCHAR wszTempString_S[MAX_PATH];
    WCHAR wszTempString_P[MAX_PATH];
    
    wszDirPath[0] = '\0';
    wszTempString_S[0] = '\0';
    wszTempString_P[0] = '\0';

    for(argno=1; argno<argc; argno++) {
        if ( argv[argno][0] == '-'  || argv[argno][0] == '/' ) {
            switch (argv[argno][1]) {
                case 'a':
                case 'A':
                    iDoA = TRUE;
                    break;
                case 's':
                case 'S':
					// Get the string for this flag
					pArg = CharNextA(argv[argno]);
					pArg = CharNextA(pArg);
					if (*pArg == ':') {
						pArg = CharNextA(pArg);

						// Check if it's quoted
						if (*pArg == '\"') {
							pArg = CharNextA(pArg);
							pCmdStart = pArg;
							while ((*pArg) && (*pArg != '\"')){pArg = CharNextA(pArg);}
                        } else {
							pCmdStart = pArg;
							while (*pArg){pArg = CharNextA(pArg);}
						}
						*pArg = '\0';
						lstrcpyA(szTempString, StripWhitespace(pCmdStart));

						// Convert to unicode
						MultiByteToWideChar(CP_ACP, 0, (LPCSTR)szTempString, -1, (LPWSTR) wszTempString_S, 50);

                        iGotParamS = TRUE;
					}
                    break;
                case 'p':
                case 'P':
					// Get the string for this flag
					pArg = CharNextA(argv[argno]);
					pArg = CharNextA(pArg);
					if (*pArg == ':') {
						pArg = CharNextA(pArg);

						// Check if it's quoted
						if (*pArg == '\"') {
							pArg = CharNextA(pArg);
							pCmdStart = pArg;
							while ((*pArg) && (*pArg != '\"')){pArg = CharNextA(pArg);}
                        } else {
							pCmdStart = pArg;
							while (*pArg){pArg = CharNextA(pArg);}
						}
						*pArg = '\0';
						lstrcpyA(szTempString, StripWhitespace(pCmdStart));

						// Convert to unicode
						MultiByteToWideChar(CP_ACP, 0, (LPCSTR)szTempString, -1, (LPWSTR) wszTempString_P, 50);

                        iGotParamP = TRUE;
					}
                    break;
                case '?':
                    goto main_exit_with_help;
                    break;
                }
        } else {
            if ( *wszDirPath == '\0' ) {
                // if no arguments, then get the filename portion
                MultiByteToWideChar(CP_ACP, 0, argv[argno], -1, (LPWSTR) wszDirPath, 50);
            }
        }
    }

    fRet = TestCertObj();
    goto main_exit_gracefully;


main_exit_gracefully:
    exit(fRet);

main_exit_with_help:
    ShowHelp();
    exit(fRet);
}

HRESULT
HereIsVtArrayGimmieBinary(
    VARIANT * lpVarSrcObject,
    DWORD * cbBinaryBufferSize,
    char **pbBinaryBuffer,
    BOOL bReturnBinaryAsVT_VARIANT
    )
{
    HRESULT hr = S_OK;
    LONG dwSLBound = 0;
    LONG dwSUBound = 0;
    CHAR HUGEP *pArray = NULL;

    if (NULL == cbBinaryBufferSize || NULL == pbBinaryBuffer)
    {
        hr = E_INVALIDARG;
        goto HereIsVtArrayGimmieBinary_Exit;
    }

    if (bReturnBinaryAsVT_VARIANT)
    {
        hr = VariantChangeType(lpVarSrcObject,lpVarSrcObject,0,VT_ARRAY | VT_VARIANT);
    }
    else
    {
        hr = VariantChangeType(lpVarSrcObject,lpVarSrcObject,0,VT_ARRAY | VT_UI1);
    }

    if (FAILED(hr)) 
    {
        if (hr != E_OUTOFMEMORY) 
        {
            IISDebugOutput(_T("OLE_E_CANTCONVERT 1,hr=0x%x\n"),hr);
            hr = OLE_E_CANTCONVERT;
        }
        goto HereIsVtArrayGimmieBinary_Exit;
    }

    if (bReturnBinaryAsVT_VARIANT)
    {
        if( lpVarSrcObject->vt != (VT_ARRAY | VT_VARIANT)) 
        {
            hr = OLE_E_CANTCONVERT;
            goto HereIsVtArrayGimmieBinary_Exit;
        }
    }
    else
    {
        if( lpVarSrcObject->vt != (VT_ARRAY | VT_UI1)) 
        {
            hr = OLE_E_CANTCONVERT;
            IISDebugOutput(_T("OLE_E_CANTCONVERT 2\n"));
            goto HereIsVtArrayGimmieBinary_Exit;
        }
    }

    hr = SafeArrayGetLBound(V_ARRAY(lpVarSrcObject),1,(long FAR *) &dwSLBound );
    if (FAILED(hr))
        {goto HereIsVtArrayGimmieBinary_Exit;}

    hr = SafeArrayGetUBound(V_ARRAY(lpVarSrcObject),1,(long FAR *) &dwSUBound );
    if (FAILED(hr))
        {goto HereIsVtArrayGimmieBinary_Exit;}

    //*pbBinaryBuffer = (LPBYTE) AllocADsMem(dwSUBound - dwSLBound + 1);
    *pbBinaryBuffer = (char *) ::CoTaskMemAlloc(dwSUBound - dwSLBound + 1);
    if (*pbBinaryBuffer == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto HereIsVtArrayGimmieBinary_Exit;
    }

    *cbBinaryBufferSize = dwSUBound - dwSLBound + 1;

    hr = SafeArrayAccessData( V_ARRAY(lpVarSrcObject),(void HUGEP * FAR *) &pArray );
    if (FAILED(hr))
        {goto HereIsVtArrayGimmieBinary_Exit;}

    memcpy(*pbBinaryBuffer,pArray,dwSUBound-dwSLBound+1);
    SafeArrayUnaccessData( V_ARRAY(lpVarSrcObject) );

HereIsVtArrayGimmieBinary_Exit:
    return hr;
}


BOOL
TestCertObj(void)
{
    BOOL fRet = FALSE;
    HRESULT hr;
    IIISCertObj *pTheObject = NULL;

    BSTR bstrFileName = SysAllocString(L"c:\\test.pfx");
    BSTR bstrFilePassword = SysAllocString(L"www");
    VARIANT VtArray;
    DWORD cbBinaryBufferSize = 0;
    char * pbBinaryBuffer = NULL;


    IISDebugOutput(_T("TestCertObj: Start\n"));

    if( FAILED (CoInitializeEx( NULL, COINIT_MULTITHREADED )))
    {
        return FALSE;
    }

    // Try to instantiante the object on the remote server...
    // with the supplied authentication info (pcsiName)
    //#define CLSCTX_SERVER    (CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER | CLSCTX_REMOTE_SERVER)
    //#define CLSCTX_ALL       (CLSCTX_INPROC_HANDLER | CLSCTX_SERVER)

    // this one seems to work with surrogates..
    hr = CoCreateInstance(CLSID_IISCertObj,NULL,CLSCTX_SERVER,IID_IIISCertObj,(void **)&pTheObject);
    if (FAILED(hr))
    {
        IISDebugOutput(_T("CoCreateInstanceEx on CLSID_IISCertObj failed! code=0x%x\n"),hr);
        goto TestCertObj_Exit;
    }

    // at this point we were able to instantiate the com object on the server (local or remote)
    hr = pTheObject->ImportToCertStore(bstrFileName, bstrFilePassword,&VtArray);
    IISDebugOutput(_T("returned ImportToCertStore, code=0x%x\n"),hr);

    // we have a VtArray now.
    // change it back to a binary blob
    hr = HereIsVtArrayGimmieBinary(&VtArray,&cbBinaryBufferSize,&pbBinaryBuffer,FALSE);
    IISDebugOutput(_T("returned HereIsVtArrayGimmieBinary, code=0x%x\n"),hr);

    IISDebugOutput(_T("Blob=%d,%p\n"),cbBinaryBufferSize,pbBinaryBuffer);
    DebugBreak();


TestCertObj_Exit:
    if (pTheObject)
    {
        pTheObject->Release();
        pTheObject = NULL;
    }
    CoUninitialize();
    IISDebugOutput(_T("TestCertObj: End\n"));
    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\certwiz\certexportimport.cpp ===
#include "StdAfx.h"
#include "base64.h"
#include <malloc.h>
#include <wincrypt.h>

#ifndef USE_LOCAL_IMPLEMENTATION
    HRESULT ImportCertFromFile(BSTR FileName, BSTR Password, BSTR bstrInstanceName){return HRESULT_FROM_WIN32(ERROR_CALL_NOT_IMPLEMENTED);}
    HRESULT ExportCertToFile(BSTR bstrInstanceName, BSTR FileName,BSTR Password,BOOL bPrivateKey,BOOL bCertChain){return HRESULT_FROM_WIN32(ERROR_CALL_NOT_IMPLEMENTED);}
#else


CString ReturnGoodMetabasePath(CString csInstanceName)
{
    CString key_path_lm = _T("");
    CString key_path = _T("");
    // csInstanceName will come in looking like
    // w3svc/1
    // or /lm/w3svc/1
    //
    // we want to it to go out as /lm/w3svc/1
    key_path_lm = SZ_MBN_SEP_STR SZ_MBN_MACHINE SZ_MBN_SEP_STR;// SZ_MBN_WEB SZ_MBN_SEP_STR;

    if (csInstanceName.GetLength() >= 4)
    {
        if (csInstanceName.Left(4) == key_path_lm)
        {
            key_path = csInstanceName;
        }
        else
        {
            key_path_lm = SZ_MBN_MACHINE SZ_MBN_SEP_STR;
            if (csInstanceName.Left(3) == key_path_lm)
            {
                key_path = csInstanceName;
            }
            else
            {
                key_path = key_path_lm;
                key_path += csInstanceName;
            }
        }
    }
    else
    {
        key_path = key_path_lm;
        key_path += csInstanceName;
    }

    return key_path;
}


CERT_CONTEXT * GetInstalledCert(HRESULT * phResult, CString csKeyPath)
{
    ATLASSERT(phResult != NULL);
    CERT_CONTEXT * pCert = NULL;
    *phResult = S_OK;
    CComAuthInfo auth;
    CString key_path = ReturnGoodMetabasePath(csKeyPath);

    CMetaKey key(&auth, key_path, METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE);
    if (key.Succeeded())
    {
        CString store_name;
        CBlob hash;
        if (SUCCEEDED(*phResult = key.QueryValue(MD_SSL_CERT_STORE_NAME, store_name)) &&
            SUCCEEDED(*phResult = key.QueryValue(MD_SSL_CERT_HASH, hash)))
        {
            // Open MY store. We assume that store type and flags
            // cannot be changed between installation and unistallation
            // of the sertificate.
            HCERTSTORE hStore = CertOpenStore(CERT_STORE_PROV_SYSTEM,PKCS_7_ASN_ENCODING | X509_ASN_ENCODING,NULL,CERT_SYSTEM_STORE_LOCAL_MACHINE,store_name);
            ASSERT(hStore != NULL);
            if (hStore != NULL)
            {
                // Now we need to find cert by hash
                CRYPT_HASH_BLOB crypt_hash;
                crypt_hash.cbData = hash.GetSize();
                crypt_hash.pbData = hash.GetData();
                pCert = (CERT_CONTEXT *)CertFindCertificateInStore(hStore,X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,0,CERT_FIND_HASH,(LPVOID)&crypt_hash,NULL);
                if (pCert == NULL)
                {
                    *phResult = HRESULT_FROM_WIN32(GetLastError());
                }
                VERIFY(CertCloseStore(hStore, 0));
            }
            else
            {
                *phResult = HRESULT_FROM_WIN32(GetLastError());
            }
        }
    }
    else
    {
        *phResult = key.QueryResult();
    }
    return pCert;
}


BOOL AddChainToStore(HCERTSTORE hCertStore,PCCERT_CONTEXT pCertContext,DWORD cStores,HCERTSTORE * rghStores,BOOL fDontAddRootCert,CERT_TRUST_STATUS * pChainTrustStatus)
{
    DWORD	i;
    CERT_CHAIN_ENGINE_CONFIG CertChainEngineConfig;
    HCERTCHAINENGINE hCertChainEngine = NULL;
    PCCERT_CHAIN_CONTEXT pCertChainContext = NULL;
    CERT_CHAIN_PARA CertChainPara;
    BOOL fRet = TRUE;
    PCCERT_CONTEXT pTempCertContext = NULL;

    //
    // create a new chain engine, then build the chain
    //
    memset(&CertChainEngineConfig, 0, sizeof(CertChainEngineConfig));
    CertChainEngineConfig.cbSize = sizeof(CertChainEngineConfig);
    CertChainEngineConfig.cAdditionalStore = cStores;
    CertChainEngineConfig.rghAdditionalStore = rghStores;
    CertChainEngineConfig.dwFlags = CERT_CHAIN_USE_LOCAL_MACHINE_STORE;

    if (!CertCreateCertificateChainEngine(&CertChainEngineConfig, &hCertChainEngine))
    {
        goto AddChainToStore_Error;
    }

	memset(&CertChainPara, 0, sizeof(CertChainPara));
	CertChainPara.cbSize = sizeof(CertChainPara);

	if (!CertGetCertificateChain(hCertChainEngine,pCertContext,NULL,NULL,&CertChainPara,0,NULL,&pCertChainContext))
	{
		goto AddChainToStore_Error;
	}

    //
    // make sure there is atleast 1 simple chain
    //
    if (pCertChainContext->cChain != 0)
	{
		i = 0;
		while (i < pCertChainContext->rgpChain[0]->cElement)
		{
			//
			// if we are supposed to skip the root cert,
			// and we are on the root cert, then continue
			//
			if (fDontAddRootCert && (pCertChainContext->rgpChain[0]->rgpElement[i]->TrustStatus.dwInfoStatus & CERT_TRUST_IS_SELF_SIGNED))
			{
                i++;
                continue;
			}

			CertAddCertificateContextToStore(hCertStore,pCertChainContext->rgpChain[0]->rgpElement[i]->pCertContext,CERT_STORE_ADD_REPLACE_EXISTING,&pTempCertContext);
            //
            // remove any private key property the certcontext may have on it.
            //
            if (pTempCertContext)
            {
                CertSetCertificateContextProperty(pTempCertContext, CERT_KEY_PROV_INFO_PROP_ID, 0, NULL);
                CertFreeCertificateContext(pTempCertContext);
            }

			i++;
		}
	}
	else
	{
		goto AddChainToStore_Error;
	}

	//
	// if the caller wants the status, then set it
	//
	if (pChainTrustStatus != NULL)
	{
		pChainTrustStatus->dwErrorStatus = pCertChainContext->TrustStatus.dwErrorStatus;
		pChainTrustStatus->dwInfoStatus = pCertChainContext->TrustStatus.dwInfoStatus;
	}

	
AddChainToStore_Exit:
	if (pCertChainContext != NULL)
	{
		CertFreeCertificateChain(pCertChainContext);
	}

	if (hCertChainEngine != NULL)
	{
		CertFreeCertificateChainEngine(hCertChainEngine);
	}
	return fRet;

AddChainToStore_Error:
	fRet = FALSE;
	goto AddChainToStore_Exit;
}


HRESULT ExportToBlob(BSTR InstanceName,BSTR Password,BOOL bPrivateKey,BOOL bCertChain,DWORD *cbBufferSize,char **pbBuffer)
{
    HRESULT hr = E_FAIL;
    PCCERT_CONTEXT pCertContext = NULL;
    BOOL bStatus = FALSE;
    HCERTSTORE hStore = NULL;
    DWORD dwOpenFlags = CERT_STORE_READONLY_FLAG | CERT_STORE_ENUM_ARCHIVED_FLAG;
    CRYPT_DATA_BLOB DataBlob;
    ZeroMemory(&DataBlob, sizeof(CRYPT_DATA_BLOB));

    char *pszB64Out = NULL;
    DWORD pcchB64Out = 0;
    DWORD  err;

    //
    // get the certificate from the server
    //
    pCertContext = GetInstalledCert(&hr,InstanceName);
    if (NULL == pCertContext)
    {
        *cbBufferSize = 0;
        pbBuffer = NULL;
        goto ExportToBlob_Exit;
    }

    //
    // Export cert
    //
    // Open a temporary store to stick the cert in.
    hStore = CertOpenStore(CERT_STORE_PROV_MEMORY,X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,0,dwOpenFlags,NULL);
    if(NULL == hStore)
    {
        *cbBufferSize = 0;
        pbBuffer = NULL;
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto ExportToBlob_Exit;
    }

    //
    // get all the certs in the chain if we need to
    //
    if (bCertChain)
    {
        AddChainToStore(hStore, pCertContext, 0, 0, FALSE, NULL);
    }

    if(!CertAddCertificateContextToStore(hStore,pCertContext,CERT_STORE_ADD_REPLACE_EXISTING,NULL))
    {
        *cbBufferSize = 0;
        pbBuffer = NULL;
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto ExportToBlob_Exit;
    }

    // free cert context since we no longer need to hold it
    if (pCertContext) 
    {
        CertFreeCertificateContext(pCertContext);pCertContext=NULL;
    }

    DataBlob.cbData = 0;
    DataBlob.pbData = NULL;
    if (!PFXExportCertStoreEx(hStore,&DataBlob,Password,NULL,bPrivateKey ? EXPORT_PRIVATE_KEYS : 0))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto ExportToBlob_Exit;
    }
    if(DataBlob.cbData <= 0)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto ExportToBlob_Exit;
    }

    if(NULL == (DataBlob.pbData = (PBYTE) ::CoTaskMemAlloc(DataBlob.cbData)))
    {
        hr = E_OUTOFMEMORY;
        goto ExportToBlob_Exit;
    }

    //
    // at this point they have allocated enough memory
    // let's go and get the cert and put it into DataBlob
    //
    if(!PFXExportCertStoreEx(hStore,&DataBlob,Password,NULL,bPrivateKey ? EXPORT_PRIVATE_KEYS : 0))
    {
        if (DataBlob.pbData){CoTaskMemFree(DataBlob.pbData);DataBlob.pbData = NULL;}
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto ExportToBlob_Exit;
    }

    // Encode it so that it can be passed back as a string (there are no Nulls in it)
    err = Base64EncodeA(DataBlob.pbData,DataBlob.cbData,NULL,&pcchB64Out);
    if (err != ERROR_SUCCESS)
    {
        hr = E_FAIL;
        goto ExportToBlob_Exit;
    }

    // allocate some space and then try it.
    pcchB64Out = pcchB64Out * sizeof(char);
    pszB64Out = (char *) ::CoTaskMemAlloc(pcchB64Out);
    if (NULL == pszB64Out)
    {
        hr = E_OUTOFMEMORY;
        goto ExportToBlob_Exit;
    }

    err = Base64EncodeA(DataBlob.pbData,DataBlob.cbData,pszB64Out,&pcchB64Out);
    if (err != ERROR_SUCCESS)
    {
        if (NULL != pszB64Out){CoTaskMemFree(pszB64Out);pszB64Out = NULL;}
        hr = E_FAIL;
        goto ExportToBlob_Exit;
    }

    // copy the new memory to pass back
    *cbBufferSize = pcchB64Out;
    *pbBuffer = pszB64Out;

    hr = ERROR_SUCCESS;

ExportToBlob_Exit:
    if (NULL != DataBlob.pbData)
    {
        // perhaspse will this up with zeros...
        ZeroMemory(DataBlob.pbData, DataBlob.cbData);
        ::CoTaskMemFree(DataBlob.pbData);DataBlob.pbData = NULL;
    }
    if (NULL != hStore){CertCloseStore(hStore, 0);hStore=NULL;}
    if (NULL != pCertContext) {CertFreeCertificateContext(pCertContext);pCertContext=NULL;}
    return hr;
}


HRESULT ExportCertToFile(BSTR bstrInstanceName, BSTR FileName,BSTR Password,BOOL bPrivateKey,BOOL bCertChain)
{
    HRESULT hr = S_OK;
    DWORD  cbEncodedSize = 0;
    char * pszEncodedString = NULL;
    DWORD  blob_cbData = 0;
    BYTE * blob_pbData = NULL;
    BOOL   blob_freeme = FALSE;

    // Check mandatory properties
    if (  FileName == NULL || *FileName == 0
        || Password == NULL || *Password == 0
        || bstrInstanceName == NULL || *bstrInstanceName == 0)
    {
        return ERROR_INVALID_PARAMETER;
    }

    // Call function go get data from the remote/local iis store
    // and return it back as a blob.  the blob could be returned back as Base64 encoded
    // so check that flag
    hr = ExportToBlob(bstrInstanceName,Password,bPrivateKey,bCertChain,&cbEncodedSize, &pszEncodedString);
    if (FAILED(hr))
    {
        goto Export_Exit;
    }

    if (SUCCEEDED(hr))
    {
        int err;

        // The data we got back was Base64 encoded to remove nulls.
        // we need to decode it back to it's original format.
        if( (err = Base64DecodeA(pszEncodedString,cbEncodedSize,NULL,&blob_cbData)) != ERROR_SUCCESS ||
            (blob_pbData = (BYTE *) malloc(blob_cbData)) == NULL ||
            (err = Base64DecodeA(pszEncodedString,cbEncodedSize,blob_pbData,&blob_cbData)) != ERROR_SUCCESS ) 
        {
            SetLastError(err);
            hr = HRESULT_FROM_WIN32(err);
            return hr;
        }
        blob_freeme = TRUE;

        HANDLE hFile = CreateFile(FileName, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
        if (INVALID_HANDLE_VALUE == hFile)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            return hr;
        }

        DWORD written = 0;
        if (!WriteFile(hFile, blob_pbData, blob_cbData, &written, NULL))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }
        else
        {
            hr = S_OK;
        }
        CloseHandle(hFile);

    }

Export_Exit:
    if (blob_freeme)
    {
        if (blob_pbData != NULL)
        {
            // Erase the memory that the private key used to be in!!!
            ZeroMemory(blob_pbData, blob_cbData);
            free(blob_pbData);blob_pbData=NULL;
        }
    }
    if (pszEncodedString != NULL)
    {
        // Erase the memory that the private key used to be in!!!
        ZeroMemory(pszEncodedString, cbEncodedSize);
        CoTaskMemFree(pszEncodedString);pszEncodedString=NULL;
    }
    return hr;
}


BOOL InstallHashToMetabase(CRYPT_HASH_BLOB * pHash,BSTR InstanceName,HRESULT * phResult)
{
    BOOL bRes = FALSE;
    CComAuthInfo auth;
    CString key_path = ReturnGoodMetabasePath(InstanceName);
    CMetaKey key(&auth, key_path, METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE);
	if (key.Succeeded())
	{
		CBlob blob;
		blob.SetValue(pHash->cbData, pHash->pbData, TRUE);
		bRes = SUCCEEDED(*phResult = key.SetValue(MD_SSL_CERT_HASH, blob))
			&& SUCCEEDED(*phResult = key.SetValue(MD_SSL_CERT_STORE_NAME, CString(L"MY")));
	}
	else
	{
        *phResult = key.QueryResult();
	}
	return bRes;
}


// This function is borrowed from trustapi.cpp
BOOL TrustIsCertificateSelfSigned(PCCERT_CONTEXT pContext,DWORD dwEncoding, DWORD dwFlags)
{
    if (!(pContext) || (dwFlags != 0))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    if (!(CertCompareCertificateName(dwEncoding,&pContext->pCertInfo->Issuer,&pContext->pCertInfo->Subject)))
    {
        return(FALSE);
    }

    DWORD   dwFlag;

    dwFlag = CERT_STORE_SIGNATURE_FLAG;

    if (!(CertVerifySubjectCertificateContext(pContext, pContext, &dwFlag)) || 
        (dwFlag & CERT_STORE_SIGNATURE_FLAG))
    {
        return(FALSE);
    }

    return(TRUE);
}


HRESULT ImportFromBlobHash(BSTR InstanceName,BSTR Password,BOOL bInstallToMetabase,DWORD count,char *pData,DWORD *cbHashBufferSize,char **pbHashBuffer)
{
    HRESULT hr = S_OK;
    CRYPT_DATA_BLOB blob;
    ZeroMemory(&blob, sizeof(CRYPT_DATA_BLOB));
    LPTSTR pPass = Password;
    BOOL   blob_freeme = FALSE;
    int err;

    // The data we got back was Base64 encoded to remove nulls.
    // we need to decode it back to it's original format.
    if( (err = Base64DecodeA(pData,count,NULL,&blob.cbData)) != ERROR_SUCCESS ||
        (blob.pbData = (BYTE *) malloc(blob.cbData)) == NULL ||
        (err = Base64DecodeA(pData,count,blob.pbData,&blob.cbData)) != ERROR_SUCCESS ) 
    {
        SetLastError(err);
        hr = HRESULT_FROM_WIN32(err);
        return hr;
    }
    blob_freeme = TRUE;

    if (!PFXVerifyPassword(&blob, pPass, 0))
    {
        // Try empty password
        if (pPass == NULL)
        {
            if (!PFXVerifyPassword(&blob, pPass = L'\0', 0))
            {
                hr = ERROR_INVALID_PARAMETER;
            }
        }
        else
        {
            hr = ERROR_INVALID_PARAMETER;
        }
    }
    if (SUCCEEDED(hr))
    {
        HCERTSTORE hStore = PFXImportCertStore(&blob, pPass, CRYPT_MACHINE_KEYSET|CRYPT_EXPORTABLE);
        if (hStore != NULL)
        {
            //add the certificate with private key to my store; and the rest
            //to the ca store
            PCCERT_CONTEXT	pCertContext = NULL;
            PCCERT_CONTEXT	pCertPre = NULL;
            while (  SUCCEEDED(hr)
            && NULL != (pCertContext = CertEnumCertificatesInStore(hStore, pCertPre))
            )
            {
                //check if the certificate has the property on it
                //make sure the private key matches the certificate
                //search for both machine key and user keys
                DWORD dwData = 0;
                if (CertGetCertificateContextProperty(pCertContext,CERT_KEY_PROV_INFO_PROP_ID, NULL, &dwData) &&  CryptFindCertificateKeyProvInfo(pCertContext, 0, NULL))
                {
                    // This certificate should go to the My store
                    HCERTSTORE hDestStore = CertOpenStore(CERT_STORE_PROV_SYSTEM,PKCS_7_ASN_ENCODING | X509_ASN_ENCODING,NULL,CERT_SYSTEM_STORE_LOCAL_MACHINE,L"MY");
                    if (hDestStore != NULL)
                    {
                        // Put it to store
                        if (CertAddCertificateContextToStore(hDestStore,pCertContext,CERT_STORE_ADD_REPLACE_EXISTING,NULL))
                        {
                            // Succeeded to put it to the storage
                            hr = S_OK;

                            // Install to metabase
                            CRYPT_HASH_BLOB hash;
                            if (  CertGetCertificateContextProperty(pCertContext,CERT_SHA1_HASH_PROP_ID, NULL, &hash.cbData)
                                && NULL != (hash.pbData = (BYTE *)_alloca(hash.cbData))
                                && CertGetCertificateContextProperty(pCertContext, CERT_SHA1_HASH_PROP_ID, hash.pbData, &hash.cbData))
                            {
                                if (TRUE == bInstallToMetabase)
                                {
                                    // returns error code in hr
                                    InstallHashToMetabase(&hash, InstanceName, &hr);
                                }
  
                                // check if we need to return back the hash
                                if (NULL != pbHashBuffer)
                                {
                                    *pbHashBuffer = (char *) ::CoTaskMemAlloc(hash.cbData);
                                    if (NULL == *pbHashBuffer)
                                    {
                                        hr = E_OUTOFMEMORY;
                                        *pbHashBuffer = NULL;
                                        *cbHashBufferSize = 0;
                                    }
                                    else
                                    {
                                        *cbHashBufferSize = hash.cbData;
                                        memcpy(*pbHashBuffer,hash.pbData,hash.cbData);
                                    }
                                }

                            }
                            else
                            {
                                hr = HRESULT_FROM_WIN32(GetLastError());
                            }
                        }
                        else
                        {
                            hr = HRESULT_FROM_WIN32(GetLastError());
                        }
                        CertCloseStore(hDestStore, 0);
                    }
                    else
                    {
                        hr = HRESULT_FROM_WIN32(GetLastError());
                    }
                }  // my store certificate
                //see if the certificate is self-signed.
                //if it is selfsigned, goes to the root store
                else if (TrustIsCertificateSelfSigned(pCertContext,pCertContext->dwCertEncodingType, 0))
                {
                    //Put it to the root store
                    HCERTSTORE hDestStore=CertOpenStore(CERT_STORE_PROV_SYSTEM,PKCS_7_ASN_ENCODING | X509_ASN_ENCODING,NULL,CERT_SYSTEM_STORE_LOCAL_MACHINE,L"ROOT");
                    if (hDestStore != NULL)
                    {
                        // Put it to store
                        if (!CertAddCertificateContextToStore(hDestStore,pCertContext,CERT_STORE_ADD_REPLACE_EXISTING,NULL))
                        {
                            hr = HRESULT_FROM_WIN32(GetLastError());
                        }
                        CertCloseStore(hDestStore, 0);
                    }
                    else
                    {
                        hr = HRESULT_FROM_WIN32(GetLastError());
                    }
                }
                else
                {
                    //Put it to the CA store
                    HCERTSTORE hDestStore=CertOpenStore(CERT_STORE_PROV_SYSTEM,PKCS_7_ASN_ENCODING | X509_ASN_ENCODING,NULL,CERT_SYSTEM_STORE_LOCAL_MACHINE,L"CA");
                    if (hDestStore != NULL)
                    {
                        // Put it to store
                        if (!CertAddCertificateContextToStore(hDestStore,pCertContext,CERT_STORE_ADD_REPLACE_EXISTING,NULL))
                        {
                            hr = HRESULT_FROM_WIN32(GetLastError());
                        }
                        CertCloseStore(hDestStore, 0);
                    }
                    else
                    {
                        hr = HRESULT_FROM_WIN32(GetLastError());
                    }
                }
                pCertPre = pCertContext;
            } //while

            CertCloseStore(hStore, 0);
        }
        else
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }
    }

//ImportFromBlobHash_Exit:
    if (blob_freeme)
    {
        if (blob.pbData != NULL)
        {
            ZeroMemory(blob.pbData, blob.cbData);
            free(blob.pbData);blob.pbData=NULL;
        }
    }
    return hr;
}


HRESULT ImportFromBlobProxy(BSTR InstanceName,BSTR Password,BOOL bInstallToMetabase,DWORD actual,BYTE *pData,DWORD *cbHashBufferSize,char **pbHashBuffer)
{
    HRESULT hr = E_FAIL;
    char *pszB64Out = NULL;
    DWORD pcchB64Out = 0;

    // base64 encode the data for transfer to the remote machine
    DWORD  err;
    pcchB64Out = 0;

    // Encode it so that it can be passed back as a string (there are no Nulls in it)
    err = Base64EncodeA(pData,actual,NULL,&pcchB64Out);
    if (err != ERROR_SUCCESS)
    {
        hr = E_FAIL;
        goto ImportFromBlobProxy_Exit;
    }

    // allocate some space and then try it.
    pcchB64Out = pcchB64Out * sizeof(char);
    pszB64Out = (char *) ::CoTaskMemAlloc(pcchB64Out);
    if (NULL == pszB64Out)
    {
        hr = E_OUTOFMEMORY;
        goto ImportFromBlobProxy_Exit;
    }

    err = Base64EncodeA(pData,actual,pszB64Out,&pcchB64Out);
    if (err != ERROR_SUCCESS)
    {
        hr = E_FAIL;
        goto ImportFromBlobProxy_Exit;
    }

    // the data to send are now in these variables
    // pcchB64Out
    // pszB64Out
    if (NULL != pbHashBuffer)
    {
        hr = ImportFromBlobHash(InstanceName,Password,bInstallToMetabase,pcchB64Out,pszB64Out,cbHashBufferSize,pbHashBuffer);
    }
    if (SUCCEEDED(hr))
    {
        // otherwise hey, The data was imported!
        hr = S_OK;
    }

ImportFromBlobProxy_Exit:
    if (NULL != pszB64Out)
    {
        ZeroMemory(pszB64Out,pcchB64Out);
        CoTaskMemFree(pszB64Out);
    }
    return hr;
}


HRESULT ImportCertFromFile(BSTR FileName, BSTR Password, BSTR bstrInstanceName)
{
    HRESULT hr = S_OK;
    BYTE * pbData = NULL;
    DWORD actual = 0, cbData = 0;

    // Check mandatory properties
    if (  FileName == NULL || *FileName == 0
        || Password == NULL || *Password == 0
        || bstrInstanceName == NULL || *bstrInstanceName == 0)
    {
        return ERROR_INVALID_PARAMETER;
    }

    HANDLE hFile = CreateFile(FileName, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    if (hFile == INVALID_HANDLE_VALUE)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        hFile = NULL;
        goto Import_Exit;
    }

    if (-1 == (cbData = ::GetFileSize(hFile, NULL)))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Import_Exit;
    }

    if (NULL == (pbData = (BYTE *)::CoTaskMemAlloc(cbData)))
    {
        hr = E_OUTOFMEMORY;
        goto Import_Exit;
    }
    if (ReadFile(hFile, pbData, cbData, &actual, NULL))
    {
        hr = ImportFromBlobProxy(bstrInstanceName, Password, TRUE, actual, pbData, 0, NULL);
    }
    else
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Import_Exit;
    }

Import_Exit:
    if (pbData != NULL)
    {
        ZeroMemory(pbData, cbData);
        ::CoTaskMemFree(pbData);
    }
    if (hFile != NULL){CloseHandle(hFile);}
    return hr;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\certwiz\certcontentspages.h ===
//
// CertContentsPages.h
//
#ifndef _CERT_CONTENTS_PAGES_H
#define _CERT_CONTENTS_PAGES_H

#include "Certificat.h"

class CCertContentsPage : public CIISWizardPage
{
	DECLARE_DYNCREATE(CCertContentsPage)

// Construction
public:
	CCertContentsPage(UINT id = 0, CCertificate * pCert = NULL);
	~CCertContentsPage();

	CCertificate * GetCertificate() {return m_pCert;}

// Dialog Data
	//{{AFX_DATA(CCertContentsPage)
	//}}AFX_DATA
	CCertificate * m_pCert;

// Overrides
	virtual BOOL GetCertDescription(CERT_DESCRIPTION& cd)
	{
		return FALSE;
	}
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CCertContentsPage)
	public:
	virtual LRESULT OnWizardBack() 
	{
		ASSERT(FALSE);
		return 1;
	}
	virtual LRESULT OnWizardNext() 
	{
		ASSERT(FALSE);
		return 1;
	}
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CCertContentsPage)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

class CInstallCertPage : public CCertContentsPage
{
	enum 
	{
		IDD = IDD_PAGE_WIZ_INSTALL_CERT,
		IDD_PAGE_NEXT = IDD_PAGE_WIZ_FINAL_INSTALL,
		IDD_PAGE_PREV = IDD_PAGE_WIZ_CHOOSE_CERT
	};
	DECLARE_DYNCREATE(CInstallCertPage)

public:
	CInstallCertPage(CCertificate * pCert = NULL)
		: CCertContentsPage(CInstallCertPage::IDD, pCert)
	{
	}

	virtual BOOL GetCertDescription(CERT_DESCRIPTION& cd);
	virtual LRESULT OnWizardBack() {return IDD_PAGE_PREV;}
	virtual LRESULT OnWizardNext();
};

class CReplaceCertPage : public CCertContentsPage
{
	enum
	{
		IDD = IDD_PAGE_WIZ_REPLACE_CERT,
		IDD_PAGE_NEXT = IDD_PAGE_WIZ_FINAL_REPLACE,
		IDD_PAGE_PREV = IDD_PAGE_WIZ_CHOOSE_CERT
	};
	DECLARE_DYNCREATE(CReplaceCertPage)

public:
	CReplaceCertPage(CCertificate * pCert = NULL)
		: CCertContentsPage(CReplaceCertPage::IDD, pCert)
	{
	}

	virtual BOOL GetCertDescription(CERT_DESCRIPTION& cd);
	virtual LRESULT OnWizardBack() {return IDD_PAGE_PREV;}
	virtual LRESULT OnWizardNext();
};

class CInstallKeyPage : public CCertContentsPage
{
	enum 
	{
		IDD = IDD_PAGE_WIZ_INSTALL_KEYCERT,
		IDD_PAGE_NEXT = IDD_PAGE_WIZ_FINAL_INSTALL,
		IDD_PAGE_PREV = IDD_PAGE_WIZ_GET_PASSWORD
	};
	DECLARE_DYNCREATE(CInstallKeyPage)

public:
	CInstallKeyPage(CCertificate * pCert = NULL)
		: CCertContentsPage(CInstallKeyPage::IDD, pCert)
	{
	}

	virtual BOOL GetCertDescription(CERT_DESCRIPTION& cd);
	virtual LRESULT OnWizardBack() {return IDD_PAGE_PREV;}
	virtual LRESULT OnWizardNext();
	virtual BOOL OnSetActive();
};


class CInstallImportPFXPage : public CCertContentsPage
{
	enum 
	{
		IDD = IDD_PAGE_WIZ_INSTALL_IMPORT_PFX,
		IDD_PAGE_NEXT = IDD_PAGE_WIZ_FINAL_INSTALL_IMPORT_PFX,
		IDD_PAGE_PREV = IDD_PAGE_WIZ_GET_IMPORT_PFX_PASSWORD
	};
	DECLARE_DYNCREATE(CInstallImportPFXPage)

public:
	CInstallImportPFXPage(CCertificate * pCert = NULL)
		: CCertContentsPage(CInstallImportPFXPage::IDD, pCert)
	{
	}

	virtual BOOL GetCertDescription(CERT_DESCRIPTION& cd);
	virtual LRESULT OnWizardBack() {return IDD_PAGE_PREV;}
	virtual LRESULT OnWizardNext();
	virtual BOOL OnSetActive();
};

class CInstallExportPFXPage : public CCertContentsPage
{
	enum 
	{
		IDD = IDD_PAGE_WIZ_INSTALL_EXPORT_PFX,
		IDD_PAGE_NEXT = IDD_PAGE_WIZ_FINAL_INSTALL_EXPORT_PFX,
		IDD_PAGE_PREV = IDD_PAGE_WIZ_GET_EXPORT_PFX_PASSWORD
	};
	DECLARE_DYNCREATE(CInstallExportPFXPage)

public:
	CInstallExportPFXPage(CCertificate * pCert = NULL)
		: CCertContentsPage(CInstallExportPFXPage::IDD, pCert)
	{
	}

	virtual BOOL GetCertDescription(CERT_DESCRIPTION& cd);
	virtual LRESULT OnWizardBack() {return IDD_PAGE_PREV;}
	virtual LRESULT OnWizardNext();
	virtual BOOL OnSetActive();
};

class CInstallRespPage : public CCertContentsPage
{
	enum 
	{
		IDD = IDD_PAGE_WIZ_INSTALL_RESP,
		IDD_PAGE_NEXT = IDD_PAGE_WIZ_FINAL_INSTALL,
		IDD_PAGE_PREV = IDD_PAGE_WIZ_GETRESP_FILE
	};
	DECLARE_DYNCREATE(CInstallRespPage)

public:
	CInstallRespPage(CCertificate * pCert = NULL)
		: CCertContentsPage(CInstallRespPage::IDD, pCert)
	{
	}

	virtual BOOL GetCertDescription(CERT_DESCRIPTION& cd);
	virtual LRESULT OnWizardBack() {return IDD_PAGE_PREV;}
	virtual LRESULT OnWizardNext();
	virtual BOOL OnSetActive();
};

class CRequestCancelPage : public CCertContentsPage
{
	enum
	{
		IDD = IDD_PAGE_WIZ_CANCEL_REQUEST,
		IDD_PAGE_NEXT = IDD_PAGE_WIZ_FINAL_CANCEL,
		IDD_PAGE_PREV = IDD_PAGE_WIZ_PENDING_WHAT_TODO
	};
	DECLARE_DYNCREATE(CRequestCancelPage)

public:
	CRequestCancelPage(CCertificate * pCert = NULL)
		: CCertContentsPage(CRequestCancelPage::IDD, pCert)
	{
	}

	virtual BOOL GetCertDescription(CERT_DESCRIPTION& cd);
	virtual LRESULT OnWizardBack() {return IDD_PAGE_PREV;}
	virtual LRESULT OnWizardNext();
};

class CRemoveCertPage : public CCertContentsPage
{
	enum
	{
		IDD = IDD_PAGE_WIZ_REMOVE_CERT,
		IDD_PAGE_NEXT = IDD_PAGE_WIZ_FINAL_REMOVE,
		IDD_PAGE_PREV = IDD_PAGE_WIZ_MANAGE_CERT
	};
	DECLARE_DYNCREATE(CRemoveCertPage)

public:
	CRemoveCertPage(CCertificate * pCert = NULL)
		: CCertContentsPage(CRemoveCertPage::IDD, pCert)
	{
	}

	virtual BOOL GetCertDescription(CERT_DESCRIPTION& cd);
	virtual LRESULT OnWizardBack() {return IDD_PAGE_PREV;}
	virtual LRESULT OnWizardNext();
};

class CRequestToFilePage : public CCertContentsPage
{
	enum 
	{
		IDD = IDD_PAGE_WIZ_REQUEST_DUMP,
		IDD_PAGE_NEXT = IDD_PAGE_WIZ_FINAL_TO_FILE,
		IDD_PAGE_PREV = IDD_PAGE_WIZ_CHOOSE_FILENAME
	};
	DECLARE_DYNCREATE(CRequestToFilePage)

public:
	CRequestToFilePage(CCertificate * pCert = NULL)
		: CCertContentsPage(CRequestToFilePage::IDD, pCert)
	{
	}

	virtual BOOL OnSetActive();
	virtual LRESULT OnWizardBack() {return IDD_PAGE_PREV;}
	virtual LRESULT OnWizardNext();
};

class CRequestToFilePageRenew : public CCertContentsPage
{
	enum 
	{
		IDD = IDD_PAGE_WIZ_REQUEST_DUMP_RENEW,
		IDD_PAGE_NEXT = IDD_PAGE_WIZ_FINAL_TO_FILE,
		IDD_PAGE_PREV = IDD_PAGE_WIZ_CHOOSE_FILENAME_RENEW
	};
	DECLARE_DYNCREATE(CRequestToFilePageRenew)

public:
	CRequestToFilePageRenew(CCertificate * pCert = NULL)
		: CCertContentsPage(CRequestToFilePageRenew::IDD, pCert)
	{
	}

	virtual BOOL OnSetActive();
	virtual LRESULT OnWizardBack() {return IDD_PAGE_PREV;}
	virtual LRESULT OnWizardNext();
};

class COnlineRequestSubmit : public CCertContentsPage
{
	enum
	{
		IDD = IDD_PAGE_WIZ_ONLINE_DUMP,
		IDD_PAGE_NEXT = IDD_PAGE_WIZ_FINAL_INSTALL,
		IDD_PAGE_PREV = IDD_PAGE_WIZ_CHOOSE_ONLINE
	};
	DECLARE_DYNCREATE(COnlineRequestSubmit)
public:
	COnlineRequestSubmit(CCertificate * pCert = NULL)
		: CCertContentsPage(COnlineRequestSubmit::IDD, pCert)
	{
	}

	virtual BOOL GetCertDescription(CERT_DESCRIPTION& cd);
	virtual LRESULT OnWizardBack() {return IDD_PAGE_PREV;}
	virtual LRESULT OnWizardNext();
	virtual BOOL OnSetActive();
};



class CInstallCopyFromRemotePage : public CCertContentsPage
{
	enum 
	{
		IDD = IDD_PAGE_WIZ_INSTALL_COPY_FROM_REMOTE,
		IDD_PAGE_NEXT = IDD_PAGE_WIZ_FINAL_INSTALL_COPY_FROM_REMOTE,
		IDD_PAGE_PREV = IDD_PAGE_WIZ_CHOOSE_SERVER_SITE
	};
	DECLARE_DYNCREATE(CInstallCopyFromRemotePage)

public:
	CInstallCopyFromRemotePage(CCertificate * pCert = NULL)
		: CCertContentsPage(CInstallCopyFromRemotePage::IDD, pCert)
	{
	}

	virtual BOOL GetCertDescription(CERT_DESCRIPTION& cd);
	virtual LRESULT OnWizardBack() {return IDD_PAGE_PREV;}
	virtual LRESULT OnWizardNext();
};


class CInstallMoveFromRemotePage : public CCertContentsPage
{
	enum 
	{
		IDD = IDD_PAGE_WIZ_INSTALL_MOVE_FROM_REMOTE,
		IDD_PAGE_NEXT = IDD_PAGE_WIZ_FINAL_INSTALL_MOVE_FROM_REMOTE,
		IDD_PAGE_PREV = IDD_PAGE_WIZ_CHOOSE_SERVER_SITE
	};
	DECLARE_DYNCREATE(CInstallMoveFromRemotePage)

public:
	CInstallMoveFromRemotePage(CCertificate * pCert = NULL)
		: CCertContentsPage(CInstallMoveFromRemotePage::IDD, pCert)
	{
	}

	virtual BOOL GetCertDescription(CERT_DESCRIPTION& cd);
	virtual LRESULT OnWizardBack() {return IDD_PAGE_PREV;}
	virtual LRESULT OnWizardNext();
};



class CInstallCopyToRemotePage : public CCertContentsPage
{
	enum 
	{
		IDD = IDD_PAGE_WIZ_INSTALL_COPY_TO_REMOTE,
		IDD_PAGE_NEXT = IDD_PAGE_WIZ_FINAL_INSTALL_COPY_TO_REMOTE,
		IDD_PAGE_PREV = IDD_PAGE_WIZ_CHOOSE_SERVER_SITE
	};
	DECLARE_DYNCREATE(CInstallCopyToRemotePage)

public:
	CInstallCopyToRemotePage(CCertificate * pCert = NULL)
		: CCertContentsPage(CInstallCopyToRemotePage::IDD, pCert)
	{
	}

	virtual BOOL GetCertDescription(CERT_DESCRIPTION& cd);
	virtual LRESULT OnWizardBack() {return IDD_PAGE_PREV;}
	virtual LRESULT OnWizardNext();
};


class CInstallMoveToRemotePage : public CCertContentsPage
{
	enum 
	{
		IDD = IDD_PAGE_WIZ_INSTALL_MOVE_TO_REMOTE,
		IDD_PAGE_NEXT = IDD_PAGE_WIZ_FINAL_INSTALL_MOVE_TO_REMOTE,
		IDD_PAGE_PREV = IDD_PAGE_WIZ_CHOOSE_SERVER_SITE
	};
	DECLARE_DYNCREATE(CInstallMoveToRemotePage)

public:
	CInstallMoveToRemotePage(CCertificate * pCert = NULL)
		: CCertContentsPage(CInstallMoveToRemotePage::IDD, pCert)
	{
	}

	virtual BOOL GetCertDescription(CERT_DESCRIPTION& cd);
	virtual LRESULT OnWizardBack() {return IDD_PAGE_PREV;}
	virtual LRESULT OnWizardNext();
};
#endif	//_CERT_CONTENTS_PAGES_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\certwiz\certexportimport.h ===
#include <wincrypt.h>
#include <CertCli.h>
#include <xenroll.h>

HRESULT ExportCertToFile(BSTR bstrInstanceName, BSTR FileName,BSTR Password,BOOL bPrivateKey,BOOL bCertChain);
HRESULT ImportCertFromFile(BSTR FileName, BSTR Password, BSTR bstrInstanceName);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\certwiz\certutil.cpp ===
//
// CertUtil.cpp
//
#include "StdAfx.h"
#include "CertUtil.h"
#include "base64.h"
#include <malloc.h>
#include "Certificat.h"
#include <wincrypt.h>
#include "Resource.h"
#include "Shlwapi.h"
#include "CertCA.h"
#include "cryptui.h"

// for certobj object
#include "certobj.h"


#define ISNUM(cChar)				((cChar >= _T('0')) && (cChar <= _T('9'))) ? (TRUE) : (FALSE)

const CLSID CLSID_CCertConfig =
	{0x372fce38, 0x4324, 0x11d0, {0x88, 0x10, 0x00, 0xa0, 0xc9, 0x03, 0xb8, 0x3c}};

const GUID IID_ICertConfig = 
	{0x372fce34, 0x4324, 0x11d0, {0x88, 0x10, 0x00, 0xa0, 0xc9, 0x03, 0xb8, 0x3c}};

#define	CRYPTUI_MAX_STRING_SIZE		768
#define ARRAYSIZE(x) (sizeof(x)/sizeof(x[0]))

BOOL
GetOnlineCAList(CStringList& list, const CString& certType, HRESULT * phRes)
{
	BOOL bRes = TRUE;
   HRESULT hr = S_OK;
   DWORD errBefore = GetLastError();
   DWORD dwCACount = 0;

   HCAINFO hCurCAInfo = NULL;
   HCAINFO hPreCAInfo = NULL;
   
   if (certType.IsEmpty())
		return FALSE;

   *phRes = CAFindByCertType(certType, NULL, 0, &hCurCAInfo);
   if (FAILED(*phRes) || NULL == hCurCAInfo)
   {
		if (S_OK == hr)
         hr=E_FAIL;   
		return FALSE;
   }

   //get the CA count
   if (0 == (dwCACount = CACountCAs(hCurCAInfo)))
   {
      *phRes = E_FAIL;
		return FALSE;
   }
	WCHAR ** ppwstrName, ** ppwstrMachine;
   while (hCurCAInfo)
   {
		//get the CA information
      if (	SUCCEEDED(CAGetCAProperty(hCurCAInfo, CA_PROP_DISPLAY_NAME, &ppwstrName))
			&& SUCCEEDED(CAGetCAProperty(hCurCAInfo, CA_PROP_DNSNAME, &ppwstrMachine))
			)
      {
			CString config;
			config = *ppwstrMachine;
			config += L"\\";
			config += *ppwstrName;
			list.AddTail(config);
			CAFreeCAProperty(hCurCAInfo, ppwstrName);
			CAFreeCAProperty(hCurCAInfo, ppwstrMachine);
      }
		else
		{
			bRes = FALSE;
			break;
		}

      hPreCAInfo = hCurCAInfo;
		if (FAILED(*phRes = CAEnumNextCA(hPreCAInfo, &hCurCAInfo)))
		{
			bRes = FALSE;
			break;
		}
      CACloseCA(hPreCAInfo);
	  hPreCAInfo = NULL;
   }
   
   if (hPreCAInfo)
      CACloseCA(hPreCAInfo);
   if (hCurCAInfo)
      CACloseCA(hCurCAInfo);

   SetLastError(errBefore);

	return bRes;
}

PCCERT_CONTEXT
GetRequestContext(CCryptBlob& pkcs7, HRESULT * phRes)
{
	ASSERT(phRes != NULL);
	BOOL bRes = FALSE;
   HCERTSTORE hStoreMsg = NULL;
   PCCERT_CONTEXT pCertContextMsg = NULL;

   if (!CryptQueryObject(CERT_QUERY_OBJECT_BLOB,
            (PCERT_BLOB)pkcs7,
            (CERT_QUERY_CONTENT_FLAG_CERT |
            CERT_QUERY_CONTENT_FLAG_PKCS7_SIGNED |
            CERT_QUERY_CONTENT_FLAG_SERIALIZED_STORE |
            CERT_QUERY_CONTENT_FLAG_PKCS7_UNSIGNED) ,
            CERT_QUERY_FORMAT_FLAG_ALL,
            0,
            NULL,
            NULL,
            NULL,
            &hStoreMsg,
            NULL,
            NULL)
      || NULL == (pCertContextMsg = CertFindCertificateInStore(
            hStoreMsg,
            X509_ASN_ENCODING,
            0,
            CERT_FIND_ANY,
            NULL,
            NULL)) 
      )
   {
		*phRes = HRESULT_FROM_WIN32(GetLastError());
   }
   return pCertContextMsg;
}


BOOL GetRequestInfoFromPKCS10(CCryptBlob& pkcs10, 
										PCERT_REQUEST_INFO * pReqInfo,
										HRESULT * phRes)
{
	ASSERT(pReqInfo != NULL);
	ASSERT(phRes != NULL);
	BOOL bRes = FALSE;
	DWORD req_info_size;
	if (!(bRes = CryptDecodeObjectEx(
							X509_ASN_ENCODING | PKCS_7_ASN_ENCODING, 
							X509_CERT_REQUEST_TO_BE_SIGNED,
							pkcs10.GetData(), 
							pkcs10.GetSize(), 
							CRYPT_DECODE_ALLOC_FLAG,
							NULL,
							pReqInfo, 
							&req_info_size)))
	{
		TRACE(_T("Error from CryptDecodeObjectEx: %xd\n"), GetLastError());
		*phRes = HRESULT_FROM_WIN32(GetLastError());
	}
	return bRes;
}

#if 0
// This function extracts data from pkcs7 format
BOOL GetRequestInfoFromRenewalRequest(CCryptBlob& renewal_req,
                              PCCERT_CONTEXT * pSignerCert,
                              HCERTSTORE hStore,
										PCERT_REQUEST_INFO * pReqInfo,
										HRESULT * phRes)
{
   BOOL bRes;
   CRYPT_DECRYPT_MESSAGE_PARA decr_para;
   CRYPT_VERIFY_MESSAGE_PARA ver_para;

   decr_para.cbSize = sizeof(decr_para);
   decr_para.dwMsgAndCertEncodingType = X509_ASN_ENCODING | PKCS_7_ASN_ENCODING;
   decr_para.cCertStore = 1;
   decr_para.rghCertStore = &hStore;

   ver_para.cbSize = sizeof(ver_para);
   ver_para.dwMsgAndCertEncodingType = X509_ASN_ENCODING | PKCS_7_ASN_ENCODING;
   ver_para.hCryptProv = 0;
   ver_para.pfnGetSignerCertificate = NULL;
   ver_para.pvGetArg = NULL;

   DWORD dwMsgType;
   DWORD dwInnerContentType;
   DWORD cbDecoded;

   if (bRes = CryptDecodeMessage(
                  CMSG_SIGNED_FLAG,
                  &decr_para,
                  &ver_para,
                  0,
                  renewal_req.GetData(),
                  renewal_req.GetSize(),
                  0,
                  &dwMsgType,
                  &dwInnerContentType,
                  NULL,
                  &cbDecoded,
                  NULL,
                  pSignerCert))
   {
      CCryptBlobLocal decoded_req;
      decoded_req.Resize(cbDecoded);
      if (bRes = CryptDecodeMessage(
                  CMSG_SIGNED_FLAG,
                  &decr_para,
                  &ver_para,
                  0,
                  renewal_req.GetData(),
                  renewal_req.GetSize(),
                  0,
                  &dwMsgType,
                  &dwInnerContentType,
                  decoded_req.GetData(),
                  &cbDecoded,
                  NULL,
                  pSignerCert))
      {
         bRes = GetRequestInfoFromPKCS10(decoded_req,
                  pReqInfo, phRes);
      }
   }
   if (!bRes)
   {
	   *phRes = HRESULT_FROM_WIN32(GetLastError());
   }
   return bRes;
}
#endif

HCERTSTORE
OpenRequestStore(IEnroll * pEnroll, HRESULT * phResult)
{
	ASSERT(NULL != phResult);
	HCERTSTORE hStore = NULL;
	WCHAR * bstrStoreName, * bstrStoreType;
	long dwStoreFlags;
	VERIFY(SUCCEEDED(pEnroll->get_RequestStoreNameWStr(&bstrStoreName)));
	VERIFY(SUCCEEDED(pEnroll->get_RequestStoreTypeWStr(&bstrStoreType)));
	VERIFY(SUCCEEDED(pEnroll->get_RequestStoreFlags(&dwStoreFlags)));
	size_t store_type_len = _tcslen(bstrStoreType);
	char * szStoreProvider = (char *)_alloca(store_type_len + 1);
	ASSERT(szStoreProvider != NULL);
	size_t n = wcstombs(szStoreProvider, bstrStoreType, store_type_len);
	szStoreProvider[n] = '\0';
	hStore = CertOpenStore(
		szStoreProvider,
      PKCS_7_ASN_ENCODING | X509_ASN_ENCODING,
		NULL,
		dwStoreFlags,
		bstrStoreName
		);
	CoTaskMemFree(bstrStoreName);
	CoTaskMemFree(bstrStoreType);
	if (hStore == NULL)
		*phResult = HRESULT_FROM_WIN32(GetLastError());
	return hStore;
}

HCERTSTORE
OpenMyStore(IEnroll * pEnroll, HRESULT * phResult)
{
	ASSERT(NULL != phResult);
	HCERTSTORE hStore = NULL;
	BSTR bstrStoreName, bstrStoreType;
	long dwStoreFlags;
	VERIFY(SUCCEEDED(pEnroll->get_MyStoreNameWStr(&bstrStoreName)));
	VERIFY(SUCCEEDED(pEnroll->get_MyStoreTypeWStr(&bstrStoreType)));
	VERIFY(SUCCEEDED(pEnroll->get_MyStoreFlags(&dwStoreFlags)));
	size_t store_type_len = _tcslen(bstrStoreType);
	char * szStoreProvider = (char *)_alloca(store_type_len + 1);
	ASSERT(szStoreProvider != NULL);
	size_t n = wcstombs(szStoreProvider, bstrStoreType, store_type_len);
	ASSERT(n != -1);
	// this converter doesn't set zero byte!!!
	szStoreProvider[n] = '\0';
	hStore = CertOpenStore(
		szStoreProvider,
      PKCS_7_ASN_ENCODING | X509_ASN_ENCODING,
		NULL,
		dwStoreFlags,
		bstrStoreName
		);
	CoTaskMemFree(bstrStoreName);
	CoTaskMemFree(bstrStoreType);
	if (hStore == NULL)
		*phResult = HRESULT_FROM_WIN32(GetLastError());
	return hStore;
}

BOOL
GetStringProperty(PCCERT_CONTEXT pCertContext,
						DWORD propId,
						CString& str,
						HRESULT * phRes)
{
	BOOL bRes = FALSE;
	DWORD cb;
	BYTE * prop;
	// compare property value
	if (	CertGetCertificateContextProperty(pCertContext, propId, NULL, &cb)
		&& (NULL != (prop = (BYTE *)_alloca(cb)))
		&& CertGetCertificateContextProperty(pCertContext, propId, prop, &cb)
		)
	{
		// decode this instance name property
		DWORD cbData = 0;
		void * pData = NULL;
		if (	CryptDecodeObject(CRYPT_ASN_ENCODING, X509_UNICODE_ANY_STRING,
							prop, cb, 0, NULL, &cbData)
			&&	NULL != (pData = _alloca(cbData))
			&& CryptDecodeObject(CRYPT_ASN_ENCODING, X509_UNICODE_ANY_STRING,
							prop, cb, 0, pData, &cbData)
			)
		{
			CERT_NAME_VALUE * pName = (CERT_NAME_VALUE *)pData;
			DWORD cch = pName->Value.cbData/sizeof(TCHAR);
			void * p = str.GetBuffer(cch);
			memcpy(p, pName->Value.pbData, pName->Value.cbData);
			str.ReleaseBuffer(cch);
			bRes = TRUE;
		}
	}
	if (!bRes)
		*phRes = HRESULT_FROM_WIN32(GetLastError());
	return bRes;
}

BOOL
GetBlobProperty(PCCERT_CONTEXT pCertContext,
					 DWORD propId,
					 CCryptBlob& blob,
					 HRESULT * phRes)
{
	BOOL bRes = FALSE;
	DWORD cb;
	// compare property value
	if (	CertGetCertificateContextProperty(pCertContext, propId, NULL, &cb)
		&& blob.Resize(cb)
		&& CertGetCertificateContextProperty(pCertContext, propId, blob.GetData(), &cb)
		)
	{
		bRes = TRUE;
	}
	if (!bRes)
		*phRes = HRESULT_FROM_WIN32(GetLastError());
	return bRes;
}

PCCERT_CONTEXT
GetPendingDummyCert(const CString& inst_name, 
						  IEnroll * pEnroll, 
						  HRESULT * phRes)
{
	PCCERT_CONTEXT pRes = NULL;
	HCERTSTORE hStore = OpenRequestStore(pEnroll, phRes);
	if (hStore != NULL)
	{
		DWORD dwPropId = CERTWIZ_INSTANCE_NAME_PROP_ID;
		PCCERT_CONTEXT pDummyCert = NULL;
		while (NULL != (pDummyCert = CertFindCertificateInStore(hStore, 
													X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
													0, CERT_FIND_PROPERTY, 
													(LPVOID)&dwPropId, pDummyCert)))
		{
			CString str;
			if (GetStringProperty(pDummyCert, dwPropId, str, phRes))
			{
				if (str.CompareNoCase(inst_name) == 0)
				{
					pRes = pDummyCert;
					break;
				}
			}
		}
		CertCloseStore(hStore, CERT_CLOSE_STORE_CHECK_FLAG);
	}
	return pRes;
}

PCCERT_CONTEXT
GetReqCertByKey(IEnroll * pEnroll, CERT_PUBLIC_KEY_INFO * pKeyInfo, HRESULT * phResult)
{
	PCCERT_CONTEXT pRes = NULL;
	HCERTSTORE hStore = OpenRequestStore(pEnroll, phResult);
	if (hStore != NULL)
	{
		if (NULL != (pRes = CertFindCertificateInStore(hStore, 
				X509_ASN_ENCODING | PKCS_7_ASN_ENCODING, 
				0, CERT_FIND_PUBLIC_KEY, (LPVOID)pKeyInfo, NULL)))
		{
			*phResult = S_OK;
		}
		VERIFY(SUCCEEDED(CertCloseStore(hStore, CERT_CLOSE_STORE_CHECK_FLAG)));
	}
	return pRes;
}

#define CERT_QUERY_CONTENT_FLAGS\
								CERT_QUERY_CONTENT_FLAG_CERT\
								|CERT_QUERY_CONTENT_FLAG_PKCS7_SIGNED\
								|CERT_QUERY_CONTENT_FLAG_SERIALIZED_STORE\
								|CERT_QUERY_CONTENT_FLAG_PKCS7_UNSIGNED

PCCERT_CONTEXT
GetCertContextFromPKCS7File(const CString& resp_file_name, 
									CERT_PUBLIC_KEY_INFO * pKeyInfo,
									HRESULT * phResult)
{
	ASSERT(phResult != NULL);
	PCCERT_CONTEXT pRes = NULL;
	HANDLE hFile;

	if (INVALID_HANDLE_VALUE != (hFile = CreateFile(resp_file_name,
						GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 
						FILE_ATTRIBUTE_NORMAL, NULL)))
	{
		// find the length of the buffer
		DWORD cbData = GetFileSize(hFile, NULL);
		BYTE * pbData;
		// alloc temp buffer
		if ((pbData = (BYTE *)_alloca(cbData)) != NULL) 
		{
			DWORD cb = 0;
			if (ReadFile(hFile, pbData, cbData, &cb, NULL))
			{
				ASSERT(cb == cbData);
				pRes = GetCertContextFromPKCS7(pbData, cb, pKeyInfo, phResult);
			}
			else
				*phResult = HRESULT_FROM_WIN32(GetLastError());
		}
		CloseHandle(hFile);
	}
	else
		*phResult = HRESULT_FROM_WIN32(GetLastError());
	return pRes;
}

PCCERT_CONTEXT
GetCertContextFromPKCS7(const BYTE * pbData,
								DWORD cbData,
								CERT_PUBLIC_KEY_INFO * pKeyInfo,
								HRESULT * phResult)
{
	ASSERT(phResult != NULL);
	PCCERT_CONTEXT pRes = NULL;
	CRYPT_DATA_BLOB blob;
	memset(&blob, 0, sizeof(CRYPT_DATA_BLOB));
	blob.cbData = cbData;
	blob.pbData = (BYTE *)pbData;

   HCERTSTORE hStoreMsg = NULL;

	if(CryptQueryObject(CERT_QUERY_OBJECT_BLOB, 
            &blob,
            (CERT_QUERY_CONTENT_FLAG_CERT |
            CERT_QUERY_CONTENT_FLAG_PKCS7_SIGNED |
            CERT_QUERY_CONTENT_FLAG_SERIALIZED_STORE |
            CERT_QUERY_CONTENT_FLAG_PKCS7_UNSIGNED) ,
            CERT_QUERY_FORMAT_FLAG_ALL,
            0, 
            NULL, 
            NULL, 
            NULL, 
            &hStoreMsg, 
            NULL, 
            NULL))
	{
		if (pKeyInfo != NULL)
			pRes = CertFindCertificateInStore(hStoreMsg, 
                        X509_ASN_ENCODING,
								0, 
                        CERT_FIND_PUBLIC_KEY, 
                        pKeyInfo, 
                        NULL);
		else
			pRes = CertFindCertificateInStore(hStoreMsg, 
                        X509_ASN_ENCODING,
								0, 
                        CERT_FIND_ANY, 
                        NULL, 
                        NULL);
		if (pRes == NULL)
			*phResult = HRESULT_FROM_WIN32(GetLastError());
		CertCloseStore(hStoreMsg, CERT_CLOSE_STORE_CHECK_FLAG);
	}
	else
		*phResult = HRESULT_FROM_WIN32(GetLastError());
	return pRes;
}

BOOL 
FormatDateString(CString& str, FILETIME ft, BOOL fIncludeTime, BOOL fLongFormat)
{
	int cch;
   int cch2;
   LPWSTR psz;
   SYSTEMTIME st;
   FILETIME localTime;
    
   if (!FileTimeToLocalFileTime(&ft, &localTime))
   {
		return FALSE;
   }
    
   if (!FileTimeToSystemTime(&localTime, &st)) 
   {
		//
      // if the conversion to local time failed, then just use the original time
      //
      if (!FileTimeToSystemTime(&ft, &st)) 
      {
			return FALSE;
      }
   }

   cch = (GetTimeFormat(LOCALE_SYSTEM_DEFAULT, 0, &st, NULL, NULL, 0) +
          GetDateFormat(LOCALE_SYSTEM_DEFAULT, fLongFormat ? DATE_LONGDATE : 0, &st, NULL, NULL, 0) + 5);

   if (NULL == (psz = str.GetBuffer((cch+5) * sizeof(WCHAR))))
   {
		return FALSE;
   }
    
   cch2 = GetDateFormat(LOCALE_SYSTEM_DEFAULT, fLongFormat ? DATE_LONGDATE : 0, &st, NULL, psz, cch);

   if (fIncludeTime)
   {
		psz[cch2-1] = ' ';
      GetTimeFormat(LOCALE_SYSTEM_DEFAULT, TIME_NOSECONDS, &st, NULL, &psz[cch2], cch-cch2);
   }
	str.ReleaseBuffer();  
   return TRUE;
}

BOOL MyGetOIDInfo(LPWSTR string, DWORD stringSize, LPSTR pszObjId)
{   
    PCCRYPT_OID_INFO pOIDInfo;
            
    if (NULL != (pOIDInfo = CryptFindOIDInfo(CRYPT_OID_INFO_OID_KEY, pszObjId, 0)))
    {
        if ((DWORD)wcslen(pOIDInfo->pwszName)+1 <= stringSize)
        {
            wcscpy(string, pOIDInfo->pwszName);
        }
        else
        {
            return FALSE;
        }
    }
    else
    {
        return (MultiByteToWideChar(CP_ACP, 0, pszObjId, -1, string, stringSize) != 0);
    }
    return TRUE;
}

BOOL
GetKeyUsageProperty(PCCERT_CONTEXT pCertContext, 
						  CERT_ENHKEY_USAGE ** pKeyUsage, 
						  BOOL fPropertiesOnly, 
						  HRESULT * phRes)
{
	DWORD cb = 0;
	BOOL bRes = FALSE;
   if (!CertGetEnhancedKeyUsage(pCertContext,
                                fPropertiesOnly ? CERT_FIND_PROP_ONLY_ENHKEY_USAGE_FLAG : 0,
                                NULL,
                                &cb))
   {
		*phRes = HRESULT_FROM_WIN32(GetLastError());
		goto ErrExit;
   }
   if (NULL == (*pKeyUsage = (CERT_ENHKEY_USAGE *)malloc(cb)))
   {
		*phRes = E_OUTOFMEMORY;
		goto ErrExit;
   }
   if (!CertGetEnhancedKeyUsage (pCertContext,
                                 fPropertiesOnly ? CERT_FIND_PROP_ONLY_ENHKEY_USAGE_FLAG : 0,
                                 *pKeyUsage,
                                 &cb))
   {
		free(*pKeyUsage);
		*phRes = HRESULT_FROM_WIN32(GetLastError());
		goto ErrExit;
   }
	*phRes = S_OK;
	bRes = TRUE;
ErrExit:
	return bRes;
}

BOOL
GetFriendlyName(PCCERT_CONTEXT pCertContext,
					 CString& name,
					 HRESULT * phRes)
{
	BOOL bRes = FALSE;
	DWORD cb;
	BYTE * pName = NULL;

	if (	CertGetCertificateContextProperty(pCertContext, CERT_FRIENDLY_NAME_PROP_ID, NULL, &cb)
		&&	NULL != (pName = (BYTE *)name.GetBuffer((cb + 1)/sizeof(TCHAR)))
		&&	CertGetCertificateContextProperty(pCertContext, CERT_FRIENDLY_NAME_PROP_ID, pName, &cb)
		)
	{
		pName[cb] = 0;
		bRes = TRUE;
	}
	else
	{
		*phRes = HRESULT_FROM_WIN32(GetLastError());
	}
	if (pName != NULL && name.IsEmpty())
	{
		name.ReleaseBuffer();
	}
	return bRes;
}

BOOL
GetNameString(PCCERT_CONTEXT pCertContext,
				  DWORD type,
				  DWORD flag,
				  CString& name,
				  HRESULT * phRes)
{
	BOOL bRes = FALSE;
	LPTSTR pName;
	DWORD cchName = CertGetNameString(pCertContext, type, flag, NULL, NULL, 0);
	if (cchName > 1 && (NULL != (pName = name.GetBuffer(cchName))))
	{
		bRes = (1 != CertGetNameString(pCertContext, type, flag, NULL, pName, cchName));
		name.ReleaseBuffer();
	}
	else
	{
		*phRes = HRESULT_FROM_WIN32(GetLastError());
	}
	return bRes;
}

BOOL
ContainsKeyUsageProperty(PCCERT_CONTEXT pCertContext, 
						 CArray<LPCSTR, LPCSTR>& uses,
						 HRESULT * phRes
						 )
{
	BOOL bRes = FALSE;
	CERT_ENHKEY_USAGE * pKeyUsage = NULL;
	if (	uses.GetSize() > 0
		&&	GetKeyUsageProperty(pCertContext, &pKeyUsage, FALSE, phRes)
		)
	{
		if (pKeyUsage->cUsageIdentifier == 0)
		{
			bRes = FALSE;
		}
		else
		{
			for (DWORD i = 0; i < pKeyUsage->cUsageIdentifier; i++)
			{
				// Our friends from CAPI made this property ASCII even for 
				// UNICODE program
				for (int n = 0; n < uses.GetSize(); n++)
				{
					if (strstr(pKeyUsage->rgpszUsageIdentifier[i], uses[n]) != NULL)
					{
						bRes = TRUE;
						break;
					}
				}
			}
		}
		free(pKeyUsage);
	}
	return bRes;
}

BOOL 
FormatEnhancedKeyUsageString(CString& str, 
									  PCCERT_CONTEXT pCertContext, 
									  BOOL fPropertiesOnly, 
									  BOOL fMultiline,
									  HRESULT * phRes)
{
	CERT_ENHKEY_USAGE * pKeyUsage = NULL;
	WCHAR szText[CRYPTUI_MAX_STRING_SIZE];
	BOOL bRes = FALSE;

	if (GetKeyUsageProperty(pCertContext, &pKeyUsage, fPropertiesOnly, phRes))
	{
		// loop for each usage and add it to the display string
		for (DWORD i = 0; i < pKeyUsage->cUsageIdentifier; i++)
		{
			if (!(bRes = MyGetOIDInfo(szText, ARRAYSIZE(szText), pKeyUsage->rgpszUsageIdentifier[i])))
				break;
			// add delimeter if not first iteration
			if (i != 0)
			{
				str += fMultiline ? L"\n" : L", ";
			}
			// add the enhanced key usage string
			str += szText;
		}
		free (pKeyUsage);
	}
	else
	{
		str.LoadString(IDS_ANY);
		bRes = TRUE;
	}
	return bRes;
}

BOOL
GetServerComment(const CString& machine_name,
					  const CString& server_name,
					  CString& comment,
					  HRESULT * phResult)
{
	ASSERT(!machine_name.IsEmpty());
	ASSERT(!server_name.IsEmpty());
	*phResult = S_OK;
    CComAuthInfo auth(machine_name);
	CMetaKey key(&auth,
            server_name,
				METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE
				);
	if (key.Succeeded())
	{
		return SUCCEEDED(*phResult = key.QueryValue(MD_SERVER_COMMENT, comment));
	}
	else
	{
		*phResult = key.QueryResult();
		return FALSE;
	}
}

/*
		GetInstalledCert

		Function reads cert hash attribute from metabase
		using machine_name and server name as server instance
		description, then looks in MY store for a certificate
		with hash equal found in metabase.
		Return is cert context pointer or NULL, if cert wasn't
		found or certificate store wasn't opened.
		On return HRESULT * is filled by error code.
 */
PCCERT_CONTEXT
GetInstalledCert(const CString& machine_name, 
					  const CString& server_name,
					  IEnroll * pEnroll,
					  HRESULT * phResult)
{
	ASSERT(pEnroll != NULL);
	ASSERT(phResult != NULL);
	ASSERT(!machine_name.IsEmpty());
	ASSERT(!server_name.IsEmpty());
	PCCERT_CONTEXT pCert = NULL;
	*phResult = S_OK;
   CComAuthInfo auth(machine_name);
	CMetaKey key(&auth, server_name,
				METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE
				);
	if (key.Succeeded())
	{
		CString store_name;
		CBlob hash;
		if (	SUCCEEDED(*phResult = key.QueryValue(MD_SSL_CERT_STORE_NAME, store_name))
			&&	SUCCEEDED(*phResult = key.QueryValue(MD_SSL_CERT_HASH, hash))
			)
		{
			// Open MY store. We assume that store type and flags
			// cannot be changed between installation and unistallation
			// of the sertificate.
			HCERTSTORE hStore = OpenMyStore(pEnroll, phResult);
			ASSERT(hStore != NULL);
			if (hStore != NULL)
			{
				// Now we need to find cert by hash
				CRYPT_HASH_BLOB crypt_hash;
				crypt_hash.cbData = hash.GetSize();
				crypt_hash.pbData = hash.GetData();
				pCert = CertFindCertificateInStore(hStore, 
												X509_ASN_ENCODING | PKCS_7_ASN_ENCODING, 
												0, CERT_FIND_HASH, (LPVOID)&crypt_hash, NULL);
				if (pCert == NULL)
					*phResult = HRESULT_FROM_WIN32(GetLastError());
				VERIFY(CertCloseStore(hStore, 0));
			}
		}
	}
	else
		*phResult = key.QueryResult();
	return pCert;
}


/*
		GetInstalledCert

		Function reads cert hash attribute from metabase
		using machine_name and server name as server instance
		description, then looks in MY store for a certificate
		with hash equal found in metabase.
		Return is cert context pointer or NULL, if cert wasn't
		found or certificate store wasn't opened.
		On return HRESULT * is filled by error code.
 */
CRYPT_HASH_BLOB *
GetInstalledCertHash(const CString& machine_name, 
					  const CString& server_name,
					  IEnroll * pEnroll,
					  HRESULT * phResult)
{
	ASSERT(pEnroll != NULL);
	ASSERT(phResult != NULL);
	ASSERT(!machine_name.IsEmpty());
	ASSERT(!server_name.IsEmpty());
    CRYPT_HASH_BLOB * pHashBlob = NULL;
	*phResult = S_OK;
    CComAuthInfo auth(machine_name);
	CMetaKey key(&auth, server_name,
				METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE
				);
	if (key.Succeeded())
	{
		CString store_name;
		CBlob hash;
		if (	SUCCEEDED(*phResult = key.QueryValue(MD_SSL_CERT_STORE_NAME, store_name))
			&&	SUCCEEDED(*phResult = key.QueryValue(MD_SSL_CERT_HASH, hash))
			)
		{
            pHashBlob = new CRYPT_HASH_BLOB;
            if (pHashBlob)
            {
                pHashBlob->cbData = hash.GetSize();
                pHashBlob->pbData = (BYTE *) ::CoTaskMemAlloc(pHashBlob->cbData);
                if (pHashBlob->pbData)
                {
                    memcpy(pHashBlob->pbData,hash.GetData(),pHashBlob->cbData);
                }
            }
		}
	}
	else
    {
		*phResult = key.QueryResult();
    }
	return pHashBlob;
}


/*
	InstallHashToMetabase

	Function writes hash array to metabase. After that IIS 
	could use certificate with that hash from MY store.
	Function expects server_name in format lm\w3svc\<number>,
	i.e. from root node down to virtual server

 */
BOOL
InstallHashToMetabase(CRYPT_HASH_BLOB * pHash,
					  const CString& machine_name, 
					  const CString& server_name,
					  HRESULT * phResult)
{
	BOOL bRes = FALSE;
   CComAuthInfo auth(machine_name);
	CMetaKey key(&auth, server_name,
						METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE
						);
	if (key.Succeeded())
	{
		CBlob blob;
		blob.SetValue(pHash->cbData, pHash->pbData, TRUE);
		bRes = SUCCEEDED(*phResult = key.SetValue(MD_SSL_CERT_HASH, blob)) 
			&& SUCCEEDED(*phResult = key.SetValue(MD_SSL_CERT_STORE_NAME, CString(L"MY")));
	}
	else
	{
		TRACE(_T("Failed to open metabase key. Error 0x%x\n"), key.QueryResult());
		*phResult = key.QueryResult();
	}
	return bRes;
}

/*
	InstallCertByHash

	Function looks in MY store for certificate which has hash
	equal to pHash parameter. If cert is found, it is installed
	to metabase.
	This function is used after xenroll accept() method, which
	puts certificate to store

 */
BOOL 
InstallCertByHash(CRYPT_HASH_BLOB * pHash,
					  const CString& machine_name, 
					  const CString& server_name,
					  IEnroll * pEnroll,
					  HRESULT * phResult)

{
	BOOL bRes = FALSE;
	// we are looking to MY store only
	HCERTSTORE hStore = OpenMyStore(pEnroll, phResult);
	if (hStore != NULL)
	{
		PCCERT_CONTEXT pCert = CertFindCertificateInStore(hStore, 
												X509_ASN_ENCODING | PKCS_7_ASN_ENCODING, 
												0, CERT_FIND_HASH, (LPVOID)pHash, NULL);
		// now install cert info to IIS MetaBase
		if (pCert != NULL)
		{
			bRes = InstallHashToMetabase(pHash, 
							machine_name, server_name, phResult);
			CertFreeCertificateContext(pCert);
		}
		else
		{
			TRACE(_T("FAILED: certificate installation, error 0x%x\n"), GetLastError());
			// We definitely need to store the hash of the cert, so error out
			*phResult = HRESULT_FROM_WIN32(GetLastError());
		}
		VERIFY(CertCloseStore(hStore, 0));
	}
	return bRes;
}

HRESULT
CreateRequest_Base64(const BSTR bstr_dn, 
                     IEnroll * pEnroll, 
                     BSTR csp_name,
                     DWORD csp_type,
                     BSTR * pOut)
{
	ASSERT(pOut != NULL);
	ASSERT(bstr_dn != NULL);
	HRESULT hRes = S_OK;
	CString strUsage(szOID_PKIX_KP_SERVER_AUTH);
	CRYPT_DATA_BLOB request = {0, NULL};
   pEnroll->put_ProviderType(csp_type);
   pEnroll->put_ProviderNameWStr(csp_name);
	if (SUCCEEDED(hRes = pEnroll->createPKCS10WStr(
									bstr_dn, 
									(LPTSTR)(LPCTSTR)strUsage, 
									&request)))
	{
		WCHAR * wszRequestB64 = NULL;
		DWORD cch = 0;
		DWORD err = ERROR_SUCCESS;
		// BASE64 encode pkcs 10
		if (	(err = Base64EncodeW(request.pbData, request.cbData, NULL, &cch)) == ERROR_SUCCESS 
			&&	(wszRequestB64 = (WCHAR *)_alloca(cch * sizeof(WCHAR))) != NULL     
			&&	(err = Base64EncodeW(request.pbData, request.cbData, wszRequestB64, &cch)) == ERROR_SUCCESS 
			) 
		{
			if ((*pOut = SysAllocStringLen(wszRequestB64, cch)) == NULL ) 
			{
				hRes = HRESULT_FROM_WIN32(ERROR_OUTOFMEMORY);
			}
		}
		else
			hRes = HRESULT_FROM_WIN32(err);
		if (request.pbData != NULL)
         CoTaskMemFree(request.pbData);
	}
	return hRes;	
}

BOOL
AttachFriendlyName(PCCERT_CONTEXT pContext, 
						 const CString& name,
						 HRESULT * phRes)
{
    IISDebugOutput(_T("AttachFriendlyName:name=%s,start\n"),name);

	BOOL bRes = TRUE;
	CRYPT_DATA_BLOB blob_name;
	blob_name.pbData = (LPBYTE)(LPCTSTR)name;
	blob_name.cbData = (name.GetLength() + 1) * sizeof(WCHAR);
	if (!(bRes = CertSetCertificateContextProperty(pContext,
						CERT_FRIENDLY_NAME_PROP_ID, 0, &blob_name)))
	{
		ASSERT(phRes != NULL);
		*phRes = HRESULT_FROM_WIN32(GetLastError());
	}
    else
    {
        IISDebugOutput(_T("AttachFriendlyName:name=%s,SUCCESS\n"),name);
    }
    IISDebugOutput(_T("AttachFriendlyName:name=%s,end\n"),name);
	return bRes;
}

BOOL GetHashProperty(PCCERT_CONTEXT pCertContext, 
							CCryptBlob& blob, 
							HRESULT * phRes)
{
	DWORD cb;
	if (CertGetCertificateContextProperty(pCertContext, CERT_SHA1_HASH_PROP_ID, NULL, &cb))
	{
		if (blob.Resize(cb))
		{
			if (CertGetCertificateContextProperty(pCertContext, 
								CERT_SHA1_HASH_PROP_ID, blob.GetData(), &cb))
				return TRUE;
		}
	}
	*phRes = HRESULT_FROM_WIN32(GetLastError());
	return FALSE;
}

BOOL 
EncodeString(CString& str, 
				 CCryptBlob& blob, 
				 HRESULT * phRes)
{
	BOOL bRes = FALSE;
	DWORD cb;
	CERT_NAME_VALUE name_value;
	name_value.dwValueType = CERT_RDN_BMP_STRING;
	name_value.Value.cbData = 0;
	name_value.Value.pbData = (LPBYTE)(LPCTSTR)str;
	if (	CryptEncodeObject(CRYPT_ASN_ENCODING, X509_UNICODE_ANY_STRING,
										&name_value, NULL, &cb) 
		&&	blob.Resize(cb)
		&&	CryptEncodeObject(CRYPT_ASN_ENCODING, X509_UNICODE_ANY_STRING,
										&name_value, blob.GetData(), &cb) 
		)
	{
		bRes = TRUE;
	}
	else
		*phRes = HRESULT_FROM_WIN32(GetLastError());
	return bRes;
}

#define CERTWIZ_RENEWAL_DATA	((LPCSTR)1000)

BOOL 
EncodeBlob(CCryptBlob& in, 
			  CCryptBlob& out, 
			  HRESULT * phRes)
{
	BOOL bRes = FALSE;
	DWORD cb;
	if (	CryptEncodeObject(CRYPT_ASN_ENCODING, CERTWIZ_RENEWAL_DATA, in, NULL, &cb) 
		&&	out.Resize(cb)
		&&	CryptEncodeObject(CRYPT_ASN_ENCODING, CERTWIZ_RENEWAL_DATA, in, out.GetData(), &cb) 
		)
	{
		bRes = TRUE;
	}
	else
		*phRes = HRESULT_FROM_WIN32(GetLastError());
	return bRes;
}

BOOL
DecodeBlob(CCryptBlob& in,
			  CCryptBlob& out,
			  HRESULT * phRes)
{
	BOOL bRes = FALSE;
	DWORD cb;
	if (	CryptDecodeObject(CRYPT_ASN_ENCODING, CERTWIZ_RENEWAL_DATA, 
						in.GetData(),
						in.GetSize(), 
						0, 
						NULL, &cb) 
		&&	out.Resize(cb)
		&&	CryptDecodeObject(CRYPT_ASN_ENCODING, CERTWIZ_RENEWAL_DATA, 
						in.GetData(),
						in.GetSize(), 
						0, 
						out.GetData(), 
						&cb) 
		)
	{
		bRes = TRUE;
	}
	else
		*phRes = HRESULT_FROM_WIN32(GetLastError());
	return bRes;
}

BOOL 
EncodeInteger(int number, 
				 CCryptBlob& blob, 
				 HRESULT * phRes)
{
	BOOL bRes = FALSE;
	DWORD cb;
	if (	CryptEncodeObject(CRYPT_ASN_ENCODING, X509_INTEGER,
										&number, NULL, &cb) 
		&&	blob.Resize(cb)
		&&	CryptEncodeObject(CRYPT_ASN_ENCODING, X509_INTEGER,
										&number, blob.GetData(), &cb) 
		)
	{
		bRes = TRUE;
	}
	else
		*phRes = HRESULT_FROM_WIN32(GetLastError());
	return bRes;
}

const WCHAR     RgwchHex[] = {'0', '1', '2', '3', '4', '5', '6', '7',
                              '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'};

static BOOL 
FormatMemBufToString(CString& str, LPBYTE pbData, DWORD cbData)
{   
    DWORD   i = 0;
    LPBYTE  pb;
    DWORD   numCharsInserted = 0;
	 LPTSTR pString;
    
    //
    // calculate the size needed
    //
    pb = pbData;
    while (pb <= &(pbData[cbData-1]))
    {   
        if (numCharsInserted == 4)
        {
            i += sizeof(WCHAR);
            numCharsInserted = 0;
        }
        else
        {
            i += 2 * sizeof(WCHAR);
            pb++;
            numCharsInserted += 2;  
        }
    }

    if (NULL == (pString = str.GetBuffer(i)))
    {
        return FALSE;
    }

    //
    // copy to the buffer
    //
    i = 0;
    numCharsInserted = 0;
    pb = pbData;
    while (pb <= &(pbData[cbData-1]))
    {   
        if (numCharsInserted == 4)
        {
            pString[i++] = L' ';
            numCharsInserted = 0;
        }
        else
        {
            pString[i++] = RgwchHex[(*pb & 0xf0) >> 4];
            pString[i++] = RgwchHex[*pb & 0x0f];
            pb++;
            numCharsInserted += 2;  
        }
    }
    pString[i] = 0;
	 str.ReleaseBuffer();
    return TRUE;
}


void FormatRdnAttr(CString& str, DWORD dwValueType, CRYPT_DATA_BLOB& blob, BOOL fAppend)
{
	if (	CERT_RDN_ENCODED_BLOB == dwValueType 
		||	CERT_RDN_OCTET_STRING == dwValueType
		)
	{
		// translate the buffer to a text string
      FormatMemBufToString(str, blob.pbData, blob.cbData);
   }
	else 
   {
        // buffer is already a string so just copy/append to it
        if (fAppend)
        {
            str += (LPTSTR)blob.pbData;
        }
        else
        {
            // don't concatenate these entries...
            str = (LPTSTR)blob.pbData;
        }
   }
}

BOOL
CreateDirectoryFromPath(LPCTSTR szPath, LPSECURITY_ATTRIBUTES lpSA)
/*++

Routine Description:

    Creates the directory specified in szPath and any other "higher"
        directories in the specified path that don't exist.

Arguments:

    IN  LPCTSTR szPath
        directory path to create (assumed to be a DOS path, not a UNC)

    IN  LPSECURITY_ATTRIBUTES   lpSA
        pointer to security attributes argument used by CreateDirectory


Return Value:

    TRUE    if directory(ies) created
    FALSE   if error (GetLastError to find out why)

--*/
{
	LPTSTR pLeftHalf, pNext;
	CString RightHalf;
	// 1. We are supporting only absolute paths. Caller should decide which
	//		root to use and build the path
	if (PathIsRelative(szPath))
	{
		ASSERT(FALSE);
		return FALSE;
	}

	pLeftHalf = (LPTSTR)szPath;
	pNext = PathSkipRoot(pLeftHalf);

	do {
		// copy the chunk between pLeftHalf and pNext to the
		// local buffer
		while (pLeftHalf < pNext)
			RightHalf += *pLeftHalf++;
		// check if new path exists
		int index = RightHalf.GetLength() - 1;
		BOOL bBackslash = FALSE, bContinue = FALSE;
		if (bBackslash = (RightHalf[index] == L'\\'))
		{
			RightHalf.SetAt(index, 0);
		}
		bContinue = PathIsUNCServerShare(RightHalf);
		if (bBackslash)
			RightHalf.SetAt(index, L'\\');
		if (bContinue || PathIsDirectory(RightHalf))
			continue;
		else if (PathFileExists(RightHalf))
		{
			// we cannot create this directory 
			// because file with this name already exists
			SetLastError(ERROR_ALREADY_EXISTS);
			return FALSE;
		}
		else
		{
			// no file no directory, create
			if (!CreateDirectory(RightHalf, lpSA))
				return FALSE;
		}
	}
   while (NULL != (pNext = PathFindNextComponent(pLeftHalf)));
	return TRUE;
}

BOOL
CompactPathToWidth(CWnd * pControl, CString& strPath)
{
	BOOL bRes;
	CRect rc;
	CFont * pFont = pControl->GetFont(), * pFontTmp;
	CDC * pdc = pControl->GetDC(), dc;
	LPTSTR pPath = strPath.GetBuffer(MAX_PATH);

	dc.CreateCompatibleDC(pdc);
	pFontTmp = dc.SelectObject(pFont);
	pControl->GetClientRect(&rc);
	
	bRes = PathCompactPath(dc.GetSafeHdc(), pPath, rc.Width());
	
	dc.SelectObject(pFontTmp);
	pControl->ReleaseDC(pdc);
	strPath.ReleaseBuffer();

	return bRes;
}

BOOL
GetKeySizeLimits(IEnroll * pEnroll, 
					  DWORD * min, DWORD * max, DWORD * def, 
					  BOOL bGSC,
					  HRESULT * phRes)
{
   HCRYPTPROV hProv = NULL;
	long dwProviderType;
   DWORD dwFlags, cbData;
	BSTR bstrProviderName;
   PROV_ENUMALGS_EX paramData;
	BOOL bRes = FALSE;
	
	VERIFY(SUCCEEDED(pEnroll->get_ProviderNameWStr(&bstrProviderName)));
	VERIFY(SUCCEEDED(pEnroll->get_ProviderType(&dwProviderType)));

	if (!CryptAcquireContext(
                &hProv,
                NULL,
                bstrProviderName,
                dwProviderType,
                CRYPT_VERIFYCONTEXT))
   {
		*phRes = GetLastError();
		return FALSE;
   }

   for (int i = 0; ; i++)
   {
		dwFlags = 0 == i ? CRYPT_FIRST : 0;
      cbData = sizeof(paramData);
      if (!CryptGetProvParam(hProv, PP_ENUMALGS_EX, (BYTE*)&paramData, &cbData, dwFlags))
      {
         if (HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS) == GetLastError())
         {
				// out of for loop
				*phRes = S_OK;
				bRes = TRUE;
         }
			else
			{
				*phRes = GetLastError();
			}
         break;
      }
      if (ALG_CLASS_KEY_EXCHANGE == GET_ALG_CLASS(paramData.aiAlgid))
      {
			*min = paramData.dwMinLen;
         *max = paramData.dwMaxLen;
			*def = paramData.dwDefaultLen;
			bRes = TRUE;
			*phRes = S_OK;
         break;
      }
   }
	if (NULL != hProv)
   {
		CryptReleaseContext(hProv, 0);
   }
	return bRes;
}

HRESULT ShutdownSSL(CString& machine_name, CString& server_name)
{
    CString str = server_name;
    str += _T("/root");
    CComAuthInfo auth(machine_name);
    CMetaKey key(&auth, str,METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE);

    DWORD dwSslAccess;
    if (	key.Succeeded() 
        && SUCCEEDED(key.QueryValue(MD_SSL_ACCESS_PERM, dwSslAccess))
        &&	dwSslAccess > 0
        )
    {
        // bug356587 should remove SslAccessPerm property and not set to 0 when Cert Removed
        key.SetValue(MD_SSL_ACCESS_PERM, 0);
        key.DeleteValue(MD_SSL_ACCESS_PERM);
        key.DeleteValue(MD_SECURE_BINDINGS);
    }

    // Now we need to remove SSL setting from any virtual directory below
    CError err;
    CStringListEx strlDataPaths;
    DWORD dwMDIdentifier, dwMDAttributes, dwMDUserType,dwMDDataType;

    VERIFY(CMetaKey::GetMDFieldDef(MD_SSL_ACCESS_PERM, dwMDIdentifier, dwMDAttributes, dwMDUserType,dwMDDataType));

    err = key.GetDataPaths(strlDataPaths,dwMDIdentifier,dwMDDataType);

    if (err.Succeeded() && !strlDataPaths.IsEmpty())
    {
        POSITION pos = strlDataPaths.GetHeadPosition();
        while (pos)
        {
            CString& str = strlDataPaths.GetNext(pos);
            if (SUCCEEDED(key.QueryValue(MD_SSL_ACCESS_PERM, dwSslAccess, NULL, str)) &&	dwSslAccess > 0)
            {
                key.SetValue(MD_SSL_ACCESS_PERM, 0, NULL, str);
                key.DeleteValue(MD_SSL_ACCESS_PERM, str);
                key.DeleteValue(MD_SECURE_BINDINGS, str);
            }
        }
    }
    return key.QueryResult();
}


BOOL 
GetServerComment(const CString& machine_name,
                      const CString& user_name,
                      const CString& user_password,
                      CString& MetabaseNode,
                      CString& comment,
                      HRESULT * phResult
                      )
{
	ASSERT(!machine_name.IsEmpty());
	*phResult = S_OK;

    if (user_name.IsEmpty())
    {
        CComAuthInfo auth(machine_name);
        CMetaKey key(&auth,MetabaseNode,METADATA_PERMISSION_READ);
	    if (key.Succeeded())
	    {
		    return SUCCEEDED(*phResult = key.QueryValue(MD_SERVER_COMMENT, comment));
	    }
	    else
	    {
		    *phResult = key.QueryResult();
		    return FALSE;
	    }

    }
    else
    {
        CComAuthInfo auth(machine_name,user_name,user_password);
        CMetaKey key(&auth,MetabaseNode,METADATA_PERMISSION_READ);
	    if (key.Succeeded())
	    {
            return SUCCEEDED(*phResult = key.QueryValue(MD_SERVER_COMMENT, comment));
	    }
	    else
	    {
		    *phResult = key.QueryResult();
		    return FALSE;
	    }
    }
   
}


BOOL IsSiteTypeMetabaseNode(CString & MetabasePath)
{
    BOOL bReturn = FALSE;
    INT iPos1 = 0;
    CString PathCopy = MetabasePath;
    CString PathCopy2;
    TCHAR MyChar;

    // check if ends with a slash...
    // if it does, then cut it off
    if (PathCopy.Right(1) == _T('/'))
    {
        iPos1 = PathCopy.ReverseFind(_T('/'));
        if (iPos1 != -1)
        {
            PathCopy.SetAt(iPos1,_T('0'));
        }
    }

    iPos1 = PathCopy.ReverseFind((TCHAR) _T('/'));
    if (iPos1 == -1)
    {
        goto IsSiteTypeMetabaseNode_Exit;
    }
    PathCopy2 = PathCopy.Right(PathCopy.GetLength() - iPos1);
    PathCopy2.TrimRight();
    for (INT i = 0; i < PathCopy2.GetLength(); i++)
    {
        MyChar = PathCopy2.GetAt(i);
        if (MyChar != _T(' ') && MyChar != _T('/'))
        {
            if (FALSE == ISNUM(MyChar))
            {
                goto IsSiteTypeMetabaseNode_Exit;
            }
        }
    }
    bReturn = TRUE;

IsSiteTypeMetabaseNode_Exit:
    return bReturn;
}

HRESULT EnumSites(CString& machine_name,CString& user_name,CString& user_password,CStringListEx * MyStringList)
{
    HRESULT hr = E_FAIL;
    CString str = _T("LM/W3SVC");
    CString strChildPath = _T("");
    CString strServerComment;
    CComAuthInfo auth(machine_name,user_name,user_password);
    CMetaKey key(&auth,str,METADATA_PERMISSION_READ);

    hr = key.QueryResult();
    if (key.Succeeded())
    {
        // Do a Get data paths on this key.
        CError err;
        CStringListEx strlDataPaths;
        CBlob hash;
        DWORD dwMDIdentifier, dwMDAttributes, dwMDUserType,dwMDDataType;

        VERIFY(CMetaKey::GetMDFieldDef(MD_SERVER_BINDINGS, dwMDIdentifier, dwMDAttributes, dwMDUserType,dwMDDataType));
        err = key.GetDataPaths(strlDataPaths,dwMDIdentifier,dwMDDataType);
        if (err.Succeeded() && !strlDataPaths.IsEmpty())
        {
            POSITION pos = strlDataPaths.GetHeadPosition();
            while (pos)
            {
                CString& strJustTheEnd = strlDataPaths.GetNext(pos);

                strChildPath = str + strJustTheEnd;
                if (TRUE == IsSiteTypeMetabaseNode(strChildPath))
                {
                    MyStringList->AddTail(strChildPath);
                }
            }
        }
        hr = key.QueryResult();
    }

    return hr;
}

HRESULT EnumSitesWithCertInstalled(CString& machine_name,CString& user_name,CString& user_password,CStringListEx * MyStringList)
{
    HRESULT hr = E_FAIL;
    CString str = _T("LM/W3SVC");
    CString strChildPath = _T("");
    CString strServerComment;
    CComAuthInfo auth(machine_name,user_name,user_password);
    CMetaKey key(&auth,str,METADATA_PERMISSION_READ);

    hr = key.QueryResult();
    if (key.Succeeded())
    {
        // Do a Get data paths on this key.
        CError err;
        CStringListEx strlDataPaths;
        CBlob hash;
        DWORD dwMDIdentifier, dwMDAttributes, dwMDUserType,dwMDDataType;

        //MD_SSL_CERT_STORE_NAME
        //MD_SSL_CERT_HASH, hash
        VERIFY(CMetaKey::GetMDFieldDef(MD_SSL_CERT_HASH, dwMDIdentifier, dwMDAttributes, dwMDUserType,dwMDDataType));
        err = key.GetDataPaths(strlDataPaths,dwMDIdentifier,dwMDDataType);
        if (err.Succeeded() && !strlDataPaths.IsEmpty())
        {
            POSITION pos = strlDataPaths.GetHeadPosition();
            while (pos)
            {
                CString& strJustTheEnd = strlDataPaths.GetNext(pos);

                strChildPath = str + strJustTheEnd;
                if (TRUE == IsSiteTypeMetabaseNode(strChildPath))
                {
                    MyStringList->AddTail(strChildPath);
                }
            }
        }
        hr = key.QueryResult();
    }

    return hr;
}


HRESULT IsCertUsedBySSLBelowMe(CString& machine_name, CString& server_name, CStringList& listFillMe)
{
    CString str = server_name;
    str += _T("/root");
    CComAuthInfo auth(machine_name);
    CMetaKey key(&auth, str,METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE);

    DWORD dwSslAccess;
    if (	key.Succeeded() 
        && SUCCEEDED(key.QueryValue(MD_SSL_ACCESS_PERM, dwSslAccess))
        &&	dwSslAccess > 0
        )
    {
        // it's used on my node...
        // return back something to say it's used...
        listFillMe.AddTail(str);
    }

    // Now check if it's being used below me...
    CError err;
    CStringListEx strlDataPaths;
    DWORD dwMDIdentifier, dwMDAttributes, dwMDUserType,dwMDDataType;

    VERIFY(CMetaKey::GetMDFieldDef(MD_SSL_ACCESS_PERM, dwMDIdentifier, dwMDAttributes, dwMDUserType,dwMDDataType));

    err = key.GetDataPaths(strlDataPaths,dwMDIdentifier,dwMDDataType);

    if (err.Succeeded() && !strlDataPaths.IsEmpty())
    {
        POSITION pos = strlDataPaths.GetHeadPosition();
        while (pos)
        {
            CString& str = strlDataPaths.GetNext(pos);
            if (SUCCEEDED(key.QueryValue(MD_SSL_ACCESS_PERM, dwSslAccess, NULL, str)) &&	dwSslAccess > 0)
            {
                // yes, it's being used here...
                // return back something to say it's used...
                listFillMe.AddTail(str);
            }
        }
    }
    return key.QueryResult();
}



HRESULT
HereIsVtArrayGimmieBinary(
    VARIANT * lpVarSrcObject,
    DWORD * cbBinaryBufferSize,
    char **pbBinaryBuffer,
    BOOL bReturnBinaryAsVT_VARIANT
    )
{
    HRESULT hr = S_OK;
    LONG dwSLBound = 0;
    LONG dwSUBound = 0;
    CHAR HUGEP *pArray = NULL;

    if (NULL == cbBinaryBufferSize || NULL == pbBinaryBuffer)
    {
        hr = E_INVALIDARG;
        goto HereIsVtArrayGimmieBinary_Exit;
    }

    if (bReturnBinaryAsVT_VARIANT)
    {
        hr = VariantChangeType(lpVarSrcObject,lpVarSrcObject,0,VT_ARRAY | VT_VARIANT);
    }
    else
    {
        hr = VariantChangeType(lpVarSrcObject,lpVarSrcObject,0,VT_ARRAY | VT_UI1);
    }

    if (FAILED(hr)) 
    {
        if (hr != E_OUTOFMEMORY) 
        {
            hr = OLE_E_CANTCONVERT;
        }
        goto HereIsVtArrayGimmieBinary_Exit;
    }

    if (bReturnBinaryAsVT_VARIANT)
    {
        if( lpVarSrcObject->vt != (VT_ARRAY | VT_VARIANT)) 
        {
            hr = OLE_E_CANTCONVERT;
            goto HereIsVtArrayGimmieBinary_Exit;
        }
    }
    else
    {
        if( lpVarSrcObject->vt != (VT_ARRAY | VT_UI1)) 
        {
            hr = OLE_E_CANTCONVERT;
            goto HereIsVtArrayGimmieBinary_Exit;
        }
    }

    hr = SafeArrayGetLBound(V_ARRAY(lpVarSrcObject),1,(long FAR *) &dwSLBound );
    if (FAILED(hr))
        {goto HereIsVtArrayGimmieBinary_Exit;}

    hr = SafeArrayGetUBound(V_ARRAY(lpVarSrcObject),1,(long FAR *) &dwSUBound );
    if (FAILED(hr))
        {goto HereIsVtArrayGimmieBinary_Exit;}

    //*pbBinaryBuffer = (LPBYTE) AllocADsMem(dwSUBound - dwSLBound + 1);
    *pbBinaryBuffer = (char *) ::CoTaskMemAlloc(dwSUBound - dwSLBound + 1);
    if (*pbBinaryBuffer == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto HereIsVtArrayGimmieBinary_Exit;
    }

    *cbBinaryBufferSize = dwSUBound - dwSLBound + 1;

    hr = SafeArrayAccessData( V_ARRAY(lpVarSrcObject),(void HUGEP * FAR *) &pArray );
    if (FAILED(hr))
        {goto HereIsVtArrayGimmieBinary_Exit;}

    memcpy(*pbBinaryBuffer,pArray,dwSUBound-dwSLBound+1);
    SafeArrayUnaccessData( V_ARRAY(lpVarSrcObject) );

HereIsVtArrayGimmieBinary_Exit:
    return hr;
}


CERT_CONTEXT * GetInstalledCertFromHash(HRESULT * phResult,DWORD cbHashBlob, char * pHashBlob)
{
    ATLASSERT(phResult != NULL);
    CERT_CONTEXT * pCert = NULL;
    *phResult = S_OK;
    CString store_name = _T("MY");

    HCERTSTORE hStore = CertOpenStore(CERT_STORE_PROV_SYSTEM,PKCS_7_ASN_ENCODING | X509_ASN_ENCODING,NULL,CERT_SYSTEM_STORE_LOCAL_MACHINE,store_name);
    ASSERT(hStore != NULL);
    if (hStore != NULL)
    {
        // Now we need to find cert by hash
        CRYPT_HASH_BLOB crypt_hash;
        crypt_hash.cbData = cbHashBlob;
        crypt_hash.pbData = (BYTE *) pHashBlob;
        pCert = (CERT_CONTEXT *)CertFindCertificateInStore(hStore,X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,0,CERT_FIND_HASH,(LPVOID)&crypt_hash,NULL);
        if (pCert == NULL)
        {
            *phResult = HRESULT_FROM_WIN32(GetLastError());
        }
        VERIFY(CertCloseStore(hStore, 0));
    }
    else
    {
        *phResult = HRESULT_FROM_WIN32(GetLastError());
    }

    return pCert;
}


BOOL ViewCertificateDialog(CRYPT_HASH_BLOB* pcrypt_hash, HWND hWnd)
{
    BOOL bReturn = FALSE;
    HCERTSTORE hStore = NULL;
    PCCERT_CONTEXT pCert = NULL;
	CString store_name = _T("MY");


	hStore = CertOpenStore(
            CERT_STORE_PROV_SYSTEM,
            PKCS_7_ASN_ENCODING | X509_ASN_ENCODING,
           	NULL,
            CERT_SYSTEM_STORE_LOCAL_MACHINE,
            store_name
            );
    if (hStore != NULL)
    {
		// Now we need to find cert by hash
		//CRYPT_HASH_BLOB crypt_hash;
		//crypt_hash.cbData = hash.GetSize();
		//crypt_hash.pbData = hash.GetData();
		pCert = CertFindCertificateInStore(hStore, 
			X509_ASN_ENCODING | PKCS_7_ASN_ENCODING, 
			0, CERT_FIND_HASH, (LPVOID)pcrypt_hash, NULL);
    }

	if (pCert)
	{
		BOOL fPropertiesChanged;
		CRYPTUI_VIEWCERTIFICATE_STRUCT vcs;
		HCERTSTORE hCertStore = ::CertDuplicateStore(hStore);
		::ZeroMemory (&vcs, sizeof (vcs));
		vcs.dwSize = sizeof (vcs);
        vcs.hwndParent = hWnd;
		vcs.dwFlags = 0;
		vcs.cStores = 1;
		vcs.rghStores = &hCertStore;
		vcs.pCertContext = pCert;
		::CryptUIDlgViewCertificate(&vcs, &fPropertiesChanged);
		::CertCloseStore (hCertStore, 0);
        bReturn = TRUE;
	}
    else
    {
        // it failed
    }
    if (pCert != NULL)
        ::CertFreeCertificateContext(pCert);
    if (hStore != NULL)
        ::CertCloseStore(hStore, 0);

    return bReturn;
}

/*

  -----Original Message-----
From: 	Helle Vu (SPECTOR)  
Sent:	Friday, April 27, 2001 6:02 PM
To:	Aaron Lee; Trevor Freeman
Cc:	Sergei Antonov
Subject:	RE: bug 31010

Perfect timing, I was just about to send you an update on this:

I talked to Trevor about this, and he suggested the best thing to do for IIS would be the following (Trevor, please double-check I got this right):
If there is an EKU, and it has serverauth, display it in the list to pick web server certs from
If no EKU, look at basic constraints:
    * If we do not have basic constraints, do display it in the list to pick web server certs from
    * If we do have basic constraints with Subject Type =CA, don't display it in the list to pick web server certs from (this will filter out CA certs)
    * If we do have basic constraints with SubectType !=CA, do display it in the list to pick web server certs from 
*/

/*
===== Opened by kshenoy on 11/13/2000 02:26PM =====
Add Existing certificate option in "Web Server Certificate Request wizard"  should not list CA certificates in the filter
but only End entity certificates with "Server Authentication" EKU

Since CA certificates by default have all the EKUs the filter will list CA certificates apart from 
end entity certificates with "Server Auth" EKU.

In order to check if a given certificate is a CA or end entity you can look at the Basic Constraints 
extension of the certificate if present. This will be present in CA certificates and set to SubjectType=CA.
If present in end entity certificates it will be set to "ServerAuth"
*/

int CheckCertConstraints(PCCERT_CONTEXT pCC)
{
    PCERT_EXTENSION pCExt;
    LPCSTR pszObjId;
    DWORD i;
    CERT_BASIC_CONSTRAINTS_INFO *pConstraints=NULL;
    CERT_BASIC_CONSTRAINTS2_INFO *p2Constraints=NULL;
    DWORD ConstraintSize=0;
    int ReturnValue = FAILURE;
    BOOL Using2=FALSE;
    void* ConstraintBlob=NULL;

    pszObjId = szOID_BASIC_CONSTRAINTS;

    pCExt = CertFindExtension(pszObjId,pCC->pCertInfo->cExtension,pCC->pCertInfo->rgExtension);
    if (pCExt == NULL) 
    {
        pszObjId = szOID_BASIC_CONSTRAINTS2;
        pCExt = CertFindExtension(pszObjId,pCC->pCertInfo->cExtension,pCC->pCertInfo->rgExtension);
        Using2=TRUE;
    }
    
    if (pCExt == NULL) 
    {
        ReturnValue = DID_NOT_FIND_CONSTRAINT;
        goto CheckCertConstraints_Exit;
    }

    // Decode extension
    if (!CryptDecodeObject(X509_ASN_ENCODING,pCExt->pszObjId,pCExt->Value.pbData,pCExt->Value.cbData,0,NULL,&ConstraintSize)) 
    {
        goto CheckCertConstraints_Exit;
    }

    ConstraintBlob = malloc(ConstraintSize);
    if (ConstraintBlob == NULL) 
    {
        goto CheckCertConstraints_Exit;
    }

    if (!CryptDecodeObject(X509_ASN_ENCODING,pCExt->pszObjId,pCExt->Value.pbData,pCExt->Value.cbData,0,(void*)ConstraintBlob,&ConstraintSize)) 
    {
       goto CheckCertConstraints_Exit;
        
    }

    if (Using2) 
    {
        p2Constraints=(CERT_BASIC_CONSTRAINTS2_INFO*)ConstraintBlob;
        if (!p2Constraints->fCA) 
        {
            // there is a constraint, and it's not a CA
            ReturnValue = FOUND_CONSTRAINT;
        }
        else
        {
            // This is a CA.  CA cannot be used as a 'server auth'
            ReturnValue = FOUND_CONSTRAINT_BUT_THIS_IS_A_CA_OR_ITS_NOT_AN_END_ENTITY;
        }
    }
    else 
    {
        pConstraints=(CERT_BASIC_CONSTRAINTS_INFO*)ConstraintBlob;
        if (((pConstraints->SubjectType.cbData * 8) - pConstraints->SubjectType.cUnusedBits) >= 2) 
        {
            if ((*pConstraints->SubjectType.pbData) & CERT_END_ENTITY_SUBJECT_FLAG) 
            {
                // there is a valid constraint
                ReturnValue = FOUND_CONSTRAINT;
            }
            else
            {
                // this is not an 'end entity' so hey -- we can't use it.
                ReturnValue = FOUND_CONSTRAINT_BUT_THIS_IS_A_CA_OR_ITS_NOT_AN_END_ENTITY;
            }

        }
    }
        
CheckCertConstraints_Exit:
    if (ConstraintBlob){free(ConstraintBlob);}
    return (ReturnValue);

}


BOOL IsCertExportable(PCCERT_CONTEXT pCertContext)
{
    HCRYPTPROV  hCryptProv = NULL;
    DWORD       dwKeySpec = 0;
    BOOL        fCallerFreeProv = FALSE;
    BOOL        fReturn = FALSE;
    HCRYPTKEY   hKey = NULL;
    DWORD       dwPermissions = 0;
    DWORD       dwSize = 0;

    if (!pCertContext)
    {
        fReturn = FALSE;
        goto IsCertExportable_Exit;
    }

    //
    // first get the private key context
    //
    if (!CryptAcquireCertificatePrivateKey(
            pCertContext,
            CRYPT_ACQUIRE_USE_PROV_INFO_FLAG | CRYPT_ACQUIRE_COMPARE_KEY_FLAG,
            NULL,
            &hCryptProv,
            &dwKeySpec,
            &fCallerFreeProv))
    {
        fReturn = FALSE;
        goto IsCertExportable_Exit;
    }

    //
    // get the handle to the key
    //
    if (!CryptGetUserKey(hCryptProv, dwKeySpec, &hKey))
    {
        fReturn = FALSE;
        goto IsCertExportable_Exit;
    }

    //
    // finally, get the permissions on the key and check if it is exportable
    //
    dwSize = sizeof(dwPermissions);
    if (!CryptGetKeyParam(hKey, KP_PERMISSIONS, (PBYTE)&dwPermissions, &dwSize, 0))
    {
        fReturn = FALSE;
        goto IsCertExportable_Exit;
    }

    fReturn = (dwPermissions & CRYPT_EXPORT) ? TRUE : FALSE;

IsCertExportable_Exit:
    if (hKey != NULL){CryptDestroyKey(hKey);}
    if (fCallerFreeProv){CryptReleaseContext(hCryptProv, 0);}
    return fReturn;
}


BOOL IsCertExportableOnRemoteMachine(CString ServerName,CString UserName,CString UserPassword,CString InstanceName)
{
	BOOL bRes = FALSE;
    BOOL bPleaseDoCoUninit = FALSE;
    HRESULT hResult = E_FAIL;
    IIISCertObj *pTheObject = NULL;
    VARIANT_BOOL varBool = VARIANT_FALSE;

    BSTR bstrServerName = SysAllocString(ServerName);
    BSTR bstrUserName = SysAllocString(UserName);
    BSTR bstrUserPassword = SysAllocString(UserPassword);
    BSTR bstrInstanceName = SysAllocString(InstanceName);

    hResult = CoInitialize(NULL);
    if(FAILED(hResult))
    {
        return bRes;
    }
    bPleaseDoCoUninit = TRUE;

    // this one seems to work with surrogates..
    hResult = CoCreateInstance(CLSID_IISCertObj,NULL,CLSCTX_SERVER,IID_IIISCertObj,(void **)&pTheObject);
    if (FAILED(hResult))
    {
        goto InstallCopyMoveFromRemote_Exit;
    }

    // at this point we were able to instantiate the com object on the server (local or remote)
    pTheObject->put_ServerName(bstrServerName);
    pTheObject->put_UserName(bstrUserName);
    pTheObject->put_UserPassword(bstrUserPassword);
    pTheObject->put_InstanceName(bstrInstanceName);

    hResult = pTheObject->IsExportable(&varBool);
    if (FAILED(hResult))
    {
        goto InstallCopyMoveFromRemote_Exit;
    }

    if (varBool == VARIANT_FALSE) 
    {
        bRes = FALSE;
    }
    else
    {
        bRes = TRUE;
    }

InstallCopyMoveFromRemote_Exit:
    if (pTheObject)
    {
        pTheObject->Release();
        pTheObject = NULL;
    }
    if (bPleaseDoCoUninit)
    {
        CoUninitialize();
    }

    if (bstrServerName) {SysFreeString(bstrServerName);}
    if (bstrUserName) {SysFreeString(bstrUserName);}
    if (bstrUserPassword) {SysFreeString(bstrUserPassword);}
    if (bstrInstanceName) {SysFreeString(bstrInstanceName);}
	return bRes;
}

BOOL DumpCertDesc(char * pBlobInfo)
{
	BOOL bRes = FALSE;

	IISDebugOutput(_T("blob=%s\n"),pBlobInfo);

	bRes = TRUE;
	return bRes;
}


BOOL GetCertDescInfo(CString ServerName,CString UserName,CString UserPassword,CString InstanceName)
{
    BOOL bReturn = FALSE;
    HRESULT hResult = E_FAIL;
    IIISCertObj *pTheObject = NULL;
    DWORD cbBinaryBufferSize = 0;
    char * pbBinaryBuffer = NULL;
    BOOL bPleaseDoCoUninit = FALSE;
    BSTR bstrServerName = SysAllocString(ServerName);
    BSTR bstrUserName = SysAllocString(UserName);
    BSTR bstrUserPassword = SysAllocString(UserPassword);
    BSTR bstrInstanceName = SysAllocString(InstanceName);
    VARIANT VtArray;

    hResult = CoInitialize(NULL);
    if(FAILED(hResult))
    {
        return bReturn;
    }
    bPleaseDoCoUninit = TRUE;

    // this one seems to work with surrogates..
    hResult = CoCreateInstance(CLSID_IISCertObj,NULL,CLSCTX_SERVER,IID_IIISCertObj,(void **)&pTheObject);
    if (FAILED(hResult))
    {
        goto GetCertDescInfo_Exit;
    }

    pTheObject->put_ServerName(bstrServerName);
    pTheObject->put_UserName(bstrUserName);
    pTheObject->put_UserPassword(bstrUserPassword);
    pTheObject->put_InstanceName(bstrInstanceName);

    hResult = pTheObject->GetCertInfo(&VtArray);
    if (FAILED(hResult))
    {
        goto GetCertDescInfo_Exit;
    }

    // we have a VtArray now.
    // change it back to a binary blob
    hResult = HereIsVtArrayGimmieBinary(&VtArray,&cbBinaryBufferSize,&pbBinaryBuffer,FALSE);
    if (FAILED(hResult))
    {
        goto GetCertDescInfo_Exit;
    }

    // Dump it out!
    DumpCertDesc(pbBinaryBuffer);


    bReturn = TRUE;

GetCertDescInfo_Exit:
    if (pTheObject)
    {
        pTheObject->Release();
        pTheObject = NULL;
    }
    if (pbBinaryBuffer)
    {
        CoTaskMemFree(pbBinaryBuffer);
    }
    if (bPleaseDoCoUninit)
    {
        CoUninitialize();
    }
	return bReturn;
}


BOOL IsWhistlerWorkstation(void)
{
    BOOL WorkstationSKU = FALSE;
    OSVERSIONINFOEX osvi;
    //
    // Determine if we are installing Personal/Professional SKU
    //
    ZeroMemory( &osvi, sizeof( OSVERSIONINFOEX ) );
    osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
    GetVersionEx((OSVERSIONINFO *) &osvi);
    if (osvi.wProductType == VER_NT_WORKSTATION)
    {
        WorkstationSKU = TRUE;
    }
    return WorkstationSKU;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\certwiz\certcontentspages.cpp ===
//
// CertContentsPages.cpp
//
#include "stdafx.h"
#include "resource.h"
#include "CertContentsPages.h"
#include "Certificat.h"
#include "CertUtil.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

////////////////////// Local helper functions ////////////////////////
static void
AppendField(CString& str, UINT id, const CString& text)
{
	CString strName;
	if (!text.IsEmpty())
	{
		if (strName.LoadString(id))
		{
			str += strName;
			str += _T("\t");
			str += text;
			str += _T("\r\n");
		}
	}
}

static void 
FormatCertDescription(CERT_DESCRIPTION& desc, CString& str)
{
	AppendField(str, IDS_ISSUED_TO, desc.m_CommonName);
	AppendField(str, IDS_ISSUED_BY, desc.m_CAName);
	AppendField(str, IDS_EXPIRATION_DATE, desc.m_ExpirationDate);
	AppendField(str, IDS_PURPOSE, desc.m_Usage);
	AppendField(str, IDS_FRIENDLY_NAME, desc.m_FriendlyName);
	AppendField(str, IDS_COUNTRY, desc.m_Country);
	AppendField(str, IDS_STATE, desc.m_State);
	AppendField(str, IDS_LOCALITY, desc.m_Locality);
	AppendField(str, IDS_ORGANIZATION, desc.m_Organization);
	AppendField(str, IDS_ORGANIZATION_UNIT, desc.m_OrganizationUnit);
}

#if 0
static void
FormatCertContactInfo(CCertificate * pCert, CString& str)
{
	AppendField(str, IDS_CONTACT_NAME, pCert->m_ContactName);
	AppendField(str, IDS_CONTACT_ADDRESS, pCert->m_ContactAddress);
	CString strPhone = pCert->m_ContactPhone;
	if (!pCert->m_ContactPhoneExt.IsEmpty())
	{
		strPhone += _T("x");
		strPhone += pCert->m_ContactPhoneExt;
	}
	AppendField(str, IDS_CONTACT_PHONE, strPhone);
}
#endif

static BOOL
ExtractDescription(CCertificate * pCert, CERT_DESCRIPTION& cd)
{
	ASSERT(pCert != NULL);
	cd.m_CommonName = pCert->m_CommonName;
	cd.m_FriendlyName = pCert->m_FriendlyName;
	cd.m_Country = pCert->m_Country;
	cd.m_State = pCert->m_State;
	cd.m_Locality = pCert->m_Locality;
	cd.m_Organization = pCert->m_Organization;
	cd.m_OrganizationUnit = pCert->m_OrganizationUnit;
	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CCertContentsPage base property page

IMPLEMENT_DYNCREATE(CCertContentsPage, CIISWizardPage)

CCertContentsPage::CCertContentsPage(UINT id, CCertificate * pCert) 
	: CIISWizardPage(id, IDS_CERTWIZ, TRUE),
	m_pCert(pCert)
{
	ASSERT(id != 0);
}

CCertContentsPage::~CCertContentsPage()
{
}

void CCertContentsPage::DoDataExchange(CDataExchange* pDX)
{
	CIISWizardPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CCertContentsPage)
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CCertContentsPage, CIISWizardPage)
	//{{AFX_MSG_MAP(CCertContentsPage)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

// OnSetActive we format cert contents and put it to edit
// control with predefined ID. We should do it here, because
// if user will get back and reselect certificate, text should 
// also be changed
//
BOOL
CCertContentsPage::OnSetActive()
{
	CERT_DESCRIPTION cd;
	if (CIISWizardPage::OnSetActive())
	{
		// If page defines GetCertDescription() then it want this
		// data to be displayed
		if (GetCertDescription(cd))
		{
			ASSERT(NULL != GetDlgItem(IDC_CERT_CONTENTS));
			CString str;
			FormatCertDescription(cd, str);
			GetDlgItem(IDC_CERT_CONTENTS)->SetWindowText(str);
		}
		return TRUE;
	}
	return FALSE;
}

BOOL CCertContentsPage::OnInitDialog() 
{
	ASSERT(m_pCert != NULL);
	CIISWizardPage::OnInitDialog();
	ASSERT(NULL != GetDlgItem(IDC_CERT_CONTENTS));
	CEdit * pEdit = (CEdit *)CWnd::FromHandle(GetDlgItem(IDC_CERT_CONTENTS)->m_hWnd);
	CRect rcEdit;
	pEdit->GetClientRect(&rcEdit);
	int baseunitX = LOWORD(GetDialogBaseUnits());
	int width_units = MulDiv(rcEdit.Width(), 4, baseunitX);
	//pEdit->SetTabStops(MulDiv(45, width_units, 100));
	pEdit->SetTabStops(width_units/2);
    
	return TRUE;
}

////////////////////////////////////////////////////////////////////////////////////////
// CInstallCertPage

IMPLEMENT_DYNCREATE(CInstallCertPage, CCertContentsPage)

BOOL 
CInstallCertPage::GetCertDescription(CERT_DESCRIPTION& cd)
{
	return GetCertificate()->GetSelectedCertDescription(cd);
}

LRESULT
CInstallCertPage::OnWizardNext()
{
	GetCertificate()->InstallSelectedCert();
	return IDD_PAGE_NEXT;
}

////////////////////////////////////////////////////////////////////////////////////////
// CReplaceCertPage

IMPLEMENT_DYNCREATE(CReplaceCertPage, CCertContentsPage)

BOOL 
CReplaceCertPage::GetCertDescription(CERT_DESCRIPTION& cd)
{
	return GetCertificate()->GetSelectedCertDescription(cd);
}

LRESULT
CReplaceCertPage::OnWizardNext()
{
	GetCertificate()->InstallSelectedCert();
	return IDD_PAGE_NEXT;
}

////////////////////////////////////////////////////////////////////////////////////////
// CInstallKeyPage

IMPLEMENT_DYNCREATE(CInstallKeyPage, CCertContentsPage)

BOOL
CInstallKeyPage::OnSetActive()
{
	ASSERT(NULL != GetDlgItem(IDC_CERT_CONTENTS));
	ASSERT(NULL != GetDlgItem(IDC_FILE_NAME));
	if (CCertContentsPage::OnSetActive())
	{
		CString strPath = GetCertificate()->m_KeyFileName;
		CompactPathToWidth(GetDlgItem(IDC_FILE_NAME), strPath);
		SetDlgItemText(IDC_FILE_NAME, strPath);
		return TRUE;
	}
	return FALSE;
}

BOOL 
CInstallKeyPage::GetCertDescription(CERT_DESCRIPTION& cd)
{
	return GetCertificate()->GetKeyCertDescription(cd);
}

LRESULT
CInstallKeyPage::OnWizardNext()
{
	GetCertificate()->InstallKeyRingCert();
	return IDD_PAGE_NEXT;
}


////////////////////////////////////////////////////////////////////////////////////////
// CInstallImportPFXPage

IMPLEMENT_DYNCREATE(CInstallImportPFXPage, CCertContentsPage)

BOOL
CInstallImportPFXPage::OnSetActive()
{
	ASSERT(NULL != GetDlgItem(IDC_CERT_CONTENTS));
	ASSERT(NULL != GetDlgItem(IDC_FILE_NAME));
	if (CCertContentsPage::OnSetActive())
	{
		CString strPath = GetCertificate()->m_KeyFileName;
		CompactPathToWidth(GetDlgItem(IDC_FILE_NAME), strPath);
		SetDlgItemText(IDC_FILE_NAME, strPath);
		return TRUE;
	}
	return FALSE;
}

BOOL 
CInstallImportPFXPage::GetCertDescription(CERT_DESCRIPTION& cd)
{
	return GetCertificate()->GetPFXFileCertDescription(cd);
}

LRESULT
CInstallImportPFXPage::OnWizardNext()
{
    GetCertificate()->InstallImportPFXCert();
	return IDD_PAGE_NEXT;
}


////////////////////////////////////////////////////////////////////////////////////////
// CInstallExportPFXPage

IMPLEMENT_DYNCREATE(CInstallExportPFXPage, CCertContentsPage)

BOOL
CInstallExportPFXPage::OnSetActive()
{
	ASSERT(NULL != GetDlgItem(IDC_CERT_CONTENTS));
	ASSERT(NULL != GetDlgItem(IDC_FILE_NAME));
	if (CCertContentsPage::OnSetActive())
	{
		CString strPath = GetCertificate()->m_KeyFileName;
		CompactPathToWidth(GetDlgItem(IDC_FILE_NAME), strPath);
		SetDlgItemText(IDC_FILE_NAME, strPath);
		return TRUE;
	}
	return FALSE;
}

BOOL 
CInstallExportPFXPage::GetCertDescription(CERT_DESCRIPTION& cd)
{
    
    //return GetCertificate()->GetKeyCertDescription(cd);
    return GetCertificate()->GetInstalledCertDescription(cd);
}

LRESULT
CInstallExportPFXPage::OnWizardNext()
{
	GetCertificate()->InstallExportPFXCert();
	return IDD_PAGE_NEXT;
}


////////////////////////////////////////////////////////////////////////////////////////
// CInstallRespPage

IMPLEMENT_DYNCREATE(CInstallRespPage, CCertContentsPage)

BOOL
CInstallRespPage::OnSetActive()
{
	ASSERT(NULL != GetDlgItem(IDC_CERT_CONTENTS));
	ASSERT(NULL != GetDlgItem(IDC_FILE_NAME));
	if (CCertContentsPage::OnSetActive())
	{
		CString strPath = GetCertificate()->m_RespFileName;
		CompactPathToWidth(GetDlgItem(IDC_FILE_NAME), strPath);
		SetDlgItemText(IDC_FILE_NAME, strPath);
		return TRUE;
	}
	return FALSE;
}

BOOL 
CInstallRespPage::GetCertDescription(CERT_DESCRIPTION& cd)
{
	return GetCertificate()->GetResponseCertDescription(cd);
}

LRESULT
CInstallRespPage::OnWizardNext()
{
	GetCertificate()->InstallResponseCert();
	return IDD_PAGE_NEXT;
}

////////////////////////////////////////////////////////////////////////////////////////
// CRemoveCertPage

IMPLEMENT_DYNCREATE(CRemoveCertPage, CCertContentsPage)

static BOOL
AnswerIsYes2(UINT id, CString& file)
{
	CString strMessage;
	AfxFormatString1(strMessage, id, file);
	return (IDYES == AfxMessageBox(strMessage, MB_ICONEXCLAMATION | MB_YESNO));
}


BOOL 
CRemoveCertPage::GetCertDescription(CERT_DESCRIPTION& cd)
{
	CCertificate * pCert = GetCertificate();
	ASSERT(NULL != pCert);
	return pCert->GetInstalledCertDescription(cd);
}

LRESULT
CRemoveCertPage::OnWizardNext()
{
	CCertificate * pCert = GetCertificate();
	ASSERT(NULL != pCert);
    int iReallyRemoveCert = FALSE;
    int iTheReturn = 1;

    CStringList listNodesUsingThisCert;

    // check if this cert is being used first...
    IsCertUsedBySSLBelowMe(pCert->m_MachineName,pCert->m_WebSiteInstanceName,listNodesUsingThisCert);
    if (listNodesUsingThisCert.IsEmpty())
    {
        iReallyRemoveCert = TRUE;
    }
    else
    {
        // if the cert is being used, then
        // don't let them remove it
        CString csStringCount;
        csStringCount.Format(_T("%d"), listNodesUsingThisCert.GetCount());
        if (TRUE == AnswerIsYes2(IDS_CERT_BEING_USED, csStringCount))
        {
            iReallyRemoveCert = TRUE;
        }
        else
        {
            iTheReturn = 1;
        }
    }

    if (iReallyRemoveCert)
    {
        // go ahead and remove the cert
	    if (	FAILED(pCert->UninstallCert())
		    ||	FAILED(ShutdownSSL(pCert->m_MachineName, pCert->m_WebSiteInstanceName))
		    )
        {
		    GetCertificate()->SetBodyTextID(IDS_REMOVE_CERT_FAILED);
        }
        iTheReturn = IDD_PAGE_NEXT;
    }

    return iTheReturn;
}

////////////////////////////////////////////////////////////////////////////////////////
// CRequestCancelPage

IMPLEMENT_DYNCREATE(CRequestCancelPage, CCertContentsPage)

//
// In this case we should get request from the dummy cert in REQUEST store,
// because we dropping request without any connection to response.
//
BOOL 
CRequestCancelPage::GetCertDescription(CERT_DESCRIPTION& cd)
{
	return FALSE;
}

LRESULT
CRequestCancelPage::OnWizardNext()
{
	GetCertificate()->CancelRequest();
	return IDD_PAGE_NEXT;
}

/////////////////////////////////////////////////////////////////////////////
// CRequestToFilePage property page

IMPLEMENT_DYNCREATE(CRequestToFilePage, CCertContentsPage)

// This page prepares and shows contents itself
// We should format contact info first, then description
// default method could do only description
//
BOOL CRequestToFilePage::OnSetActive() 
{
	if (CCertContentsPage::OnSetActive())
	{
		ASSERT(GetCertificate() != NULL);
		ASSERT(GetDlgItem(IDC_CERT_CONTENTS) != NULL);
		ASSERT(GetDlgItem(IDC_FILE_NAME) != NULL);

		if (GetCertificate()->GetStatusCode() == CCertificate::REQUEST_RENEW_CERT)
		{
			GetCertificate()->LoadRenewalData();
		}
		
		CString str;
//		FormatCertContactInfo(m_pCert, str);

		CERT_DESCRIPTION cd;
		ExtractDescription(GetCertificate(), cd);
		FormatCertDescription(cd, str);
		
		SetDlgItemText(IDC_CERT_CONTENTS, str);
		
		CString strPath = m_pCert->m_ReqFileName;
		CompactPathToWidth(GetDlgItem(IDC_FILE_NAME), strPath);
		SetDlgItemText(IDC_FILE_NAME, strPath);

		return TRUE;
	}
	return FALSE;
}

LRESULT CRequestToFilePage::OnWizardNext() 
{
	GetCertificate()->PrepareRequest();
	return IDD_PAGE_NEXT;
}


/////////////////////////////////////////////////////////////////////////////
// CRequestToFilePageRenew property page

IMPLEMENT_DYNCREATE(CRequestToFilePageRenew, CCertContentsPage)

// This page prepares and shows contents itself
// We should format contact info first, then description
// default method could do only description
//
BOOL CRequestToFilePageRenew::OnSetActive() 
{
	if (CCertContentsPage::OnSetActive())
	{
		ASSERT(GetCertificate() != NULL);
		ASSERT(GetDlgItem(IDC_CERT_CONTENTS) != NULL);
		ASSERT(GetDlgItem(IDC_FILE_NAME) != NULL);

		if (GetCertificate()->GetStatusCode() == CCertificate::REQUEST_RENEW_CERT)
		{
			GetCertificate()->LoadRenewalData();
		}
		
		CString str;
//		FormatCertContactInfo(m_pCert, str);

		CERT_DESCRIPTION cd;
		ExtractDescription(GetCertificate(), cd);
		FormatCertDescription(cd, str);
		
		SetDlgItemText(IDC_CERT_CONTENTS, str);
		
		CString strPath = m_pCert->m_ReqFileName;
		CompactPathToWidth(GetDlgItem(IDC_FILE_NAME), strPath);
		SetDlgItemText(IDC_FILE_NAME, strPath);

		return TRUE;
	}
	return FALSE;
}

LRESULT CRequestToFilePageRenew::OnWizardNext() 
{
	GetCertificate()->PrepareRequest();
	return IDD_PAGE_NEXT;
}

/////////////////////////////////////////////////////////////////////////////
// COnlineRequestSubmit property page

IMPLEMENT_DYNCREATE(COnlineRequestSubmit, CCertContentsPage)

BOOL 
COnlineRequestSubmit::GetCertDescription(CERT_DESCRIPTION& cd)
{
	// we have all data in CCertificate
	return ExtractDescription(GetCertificate(), cd);
}

LRESULT COnlineRequestSubmit::OnWizardNext() 
{
	LRESULT id = IDD_PAGE_NEXT;
	BeginWaitCursor();
	if (GetCertificate()->GetStatusCode() == CCertificate::REQUEST_RENEW_CERT)
		GetCertificate()->SubmitRenewalRequest();
	else if (m_pCert->GetStatusCode() == CCertificate::REQUEST_NEW_CERT)
		GetCertificate()->SubmitRequest();
	else
		id = 1;
	EndWaitCursor();
	return id;
}

BOOL COnlineRequestSubmit::OnSetActive() 
{
	ASSERT(GetCertificate() != NULL);
	ASSERT(GetDlgItem(IDC_CA_NAME) != NULL);
    ASSERT(GetDlgItem(IDC_CA_NAME2) != NULL);
   
	if (CCertContentsPage::OnSetActive())
	{
        CString csTemp1;
        // Make it look good
        csTemp1 = GetCertificate()->m_ConfigCA;
        int iFind = csTemp1.Find(_T("\\"));
        if (iFind != -1)
        {
            int iLength = csTemp1.GetLength();
            CString csTemp2;

            csTemp2 = csTemp1.Left(iFind);
            SetDlgItemText(IDC_CA_NAME, csTemp2);

            csTemp2 = csTemp1.Right(iLength - iFind - 1);
            SetDlgItemText(IDC_CA_NAME2, csTemp2);
        }
        else
        {
            SetDlgItemText(IDC_CA_NAME, csTemp1);
        }

		return TRUE;
	}
	return FALSE;
}



////////////////////////////////////////////////////////////////////////////////////////
// CInstallCopyFromRemotePage

IMPLEMENT_DYNCREATE(CInstallCopyFromRemotePage, CCertContentsPage)

BOOL 
CInstallCopyFromRemotePage::GetCertDescription(CERT_DESCRIPTION& cd)
{
	return GetCertificate()->GetPFXFileCertDescription(cd);
}

LRESULT
CInstallCopyFromRemotePage::OnWizardNext()
{
    GetCertificate()->InstallCopyMoveFromRemote();
	return IDD_PAGE_NEXT;
}

////////////////////////////////////////////////////////////////////////////////////////
// CInstallMoveFromRemotePage

IMPLEMENT_DYNCREATE(CInstallMoveFromRemotePage, CCertContentsPage)

BOOL 
CInstallMoveFromRemotePage::GetCertDescription(CERT_DESCRIPTION& cd)
{
	return GetCertificate()->GetPFXFileCertDescription(cd);
}

LRESULT
CInstallMoveFromRemotePage::OnWizardNext()
{
    GetCertificate()->InstallCopyMoveFromRemote();
	return IDD_PAGE_NEXT;
}


////////////////////////////////////////////////////////////////////////////////////////
// CInstallCopyFromRemotePage

IMPLEMENT_DYNCREATE(CInstallCopyToRemotePage, CCertContentsPage)

BOOL 
CInstallCopyToRemotePage::GetCertDescription(CERT_DESCRIPTION& cd)
{
	return GetCertificate()->GetInstalledCertDescription(cd);
}

LRESULT
CInstallCopyToRemotePage::OnWizardNext()
{
    GetCertificate()->InstallCopyMoveToRemote();
	return IDD_PAGE_NEXT;
}

////////////////////////////////////////////////////////////////////////////////////////
// CInstallMoveFromRemotePage

IMPLEMENT_DYNCREATE(CInstallMoveToRemotePage, CCertContentsPage)

BOOL 
CInstallMoveToRemotePage::GetCertDescription(CERT_DESCRIPTION& cd)
{
	return GetCertificate()->GetInstalledCertDescription(cd);
}

LRESULT
CInstallMoveToRemotePage::OnWizardNext()
{
    GetCertificate()->InstallCopyMoveToRemote();
	return IDD_PAGE_NEXT;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\certwiz\bookendpage.h ===
//
// BookEndPage.h
//
#ifndef _BOOKENDPAGE_H
#define _BOOKENDPAGE_H

#include "Wizard.h"

class CIISWizardBookEnd2 : public CIISWizardPage
/*++

Class Description:

    Welcome / Completion Page

Public Interface:

    CIISWizardBookEnd2    : Constructor

Notes:

    The resource template is not required.  If not provided,
    a default template will be used.

    Special control IDs (on the dialog template):
    ---------------------------------------------

        IDC_STATIC_WZ_WELCOME    - Welcome text displayed in bold
        IDC_STATIC_WZ_BODY       - Body text will be placed here
        IDC_STATIC_WZ_CLICK      - Click instructions.

    The click instructions default to something sensible, and body text
    will default to the error text on a failure page and to nothing on 
    success and welcome page.  The body text may include the %h/%H 
    escape sequences for CError on a success/failure page.

--*/
{
    DECLARE_DYNCREATE(CIISWizardBookEnd2)

public:
    //
    // Constructor for success/failure completion page
    //
    CIISWizardBookEnd2(
        HRESULT * phResult,
        UINT nIDWelcomeTxtSuccess	= USE_DEFAULT_CAPTION,
        UINT nIDWelcomeTxtFailure	= USE_DEFAULT_CAPTION,
        UINT nIDCaption					= USE_DEFAULT_CAPTION,
        UINT * nIDBodyTxtSuccess		= NULL,
		  CString * pBodyTxtSuccess	= NULL,
        UINT * nIDBodyTxtFailure		= NULL,
		  CString * pBodyTxtFailure	= NULL,
        UINT nIDClickTxt				= USE_DEFAULT_CAPTION,
        UINT nIDTemplate				= 0
        );

    //
    // Constructor for a welcome page
    //
    CIISWizardBookEnd2(
        UINT nIDTemplate        = 0,
        UINT nIDCaption         = USE_DEFAULT_CAPTION,
        UINT * nIDBodyTxt       = NULL,
		  CString * pBodyTxt		  = NULL,
        UINT nIDWelcomeTxt      = USE_DEFAULT_CAPTION,
        UINT nIDClickTxt        = USE_DEFAULT_CAPTION
        );

//
// Dialog Data
//
protected:
    //{{AFX_DATA(CIISWizardBookEnd2)
    enum { IDD = IDD_WIZARD_BOOKEND };
    //}}AFX_DATA

//
// Overrides
//
protected:
   //{{AFX_VIRTUAL(CIISWizardBookEnd)
   public:
	virtual BOOL OnSetActive();
   //}}AFX_VIRTUAL

//
// Implementation
//
protected:
    // Generated message map functions
    //{{AFX_MSG(CPWTemplate)
    virtual BOOL OnInitDialog();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

    BOOL IsWelcomePage() const {return m_phResult == NULL;}
	 BOOL IsTemplateAvailable() const {return m_bTemplateAvailable;}

private:
    HRESULT * m_phResult;
	 UINT m_nIDWelcomeTxtSuccess;
	 UINT m_nIDWelcomeTxtFailure;
	 UINT * m_pnIDBodyTxtSuccess;
	 CString * m_pBodyTxtSuccess;
	 UINT * m_pnIDBodyTxtFailure;
	 CString * m_pBodyTxtFailure;
	 UINT m_nIDClickTxt;
	 BOOL m_bTemplateAvailable;

	 CString m_strWelcome, m_strBody, m_strClick;
};

#endif	//_BOOKENDPAGE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\certwiz\certificat.h ===
//
// Certificat.h
//
#ifndef _CERTIFICAT_H
#define _CERTIFICAT_H

#include <xenroll.h>

#define CERTWIZ_INSTANCE_NAME_PROP_ID   (CERT_FIRST_USER_PROP_ID + 0x1000)
#define CERTWIZ_REQUEST_FLAG_PROP_ID   (CERT_FIRST_USER_PROP_ID + 0x1001)
#define CERTWIZ_REQUEST_TEXT_PROP_ID   (CERT_FIRST_USER_PROP_ID + 0x1002)

#define CERT_HASH_LENGTH		40
typedef struct _CERT_DESCRIPTION
{
	CString m_CommonName;
	CString m_FriendlyName;
	CString m_Country;
	CString m_State;
	CString m_Locality;
	CString m_Organization;
	CString m_OrganizationUnit;
	CString m_CAName;
	CString m_ExpirationDate;
	CString m_Usage;
	BYTE m_hash[CERT_HASH_LENGTH];
	DWORD m_hash_length;
} CERT_DESCRIPTION;

class CCertDescList : public CList<CERT_DESCRIPTION *, CERT_DESCRIPTION *&>
{
public:
	CCertDescList() {}
	~CCertDescList();
};

class CCryptBlob
{
public:
	CCryptBlob()
	{
		m_blob.cbData = 0;
		m_blob.pbData = NULL;
	}
	virtual ~CCryptBlob()
	{
	}
	DWORD GetSize() {return m_blob.cbData;}
	BYTE * GetData() {return m_blob.pbData;}
	void Set(DWORD cb, BYTE * pb)
	{
		Destroy();
		m_blob.cbData = cb;
		m_blob.pbData = pb;
	}
	BOOL Resize(DWORD cb);
	operator CRYPT_DATA_BLOB *()
	{
		return &m_blob;
	}

protected:
	void Destroy()
	{
		if (m_blob.pbData != NULL)
			Free(m_blob.pbData);
	}
	virtual BYTE * Realloc(BYTE * pb, DWORD cb) = 0;
	virtual void Free(BYTE * pb) = 0;
	CRYPT_DATA_BLOB m_blob;
};

class CCryptBlobIMalloc : public CCryptBlob
{
public:
	virtual ~CCryptBlobIMalloc()
	{
		CCryptBlob::Destroy();
	}

protected:
	virtual BYTE * Realloc(BYTE * pb, DWORD cb)
	{
		return (BYTE *)CoTaskMemRealloc(pb, cb);
	}
	virtual void Free(BYTE * pb)
	{
		CoTaskMemFree(pb);
	}
};

class CCryptBlobLocal : public CCryptBlob
{
public:
	virtual ~CCryptBlobLocal()
	{
		CCryptBlob::Destroy();
	}

protected:
	virtual BYTE * Realloc(BYTE * pb, DWORD cb)
	{
		return (BYTE *)realloc(pb, cb);
	}
	virtual void Free(BYTE * pb)
	{
		free(pb);
	}
};

extern const TCHAR szState[];
extern const TCHAR szStateMRU[];
extern const TCHAR szLocality[];
extern const TCHAR szLocalityMRU[];
extern const TCHAR szOrganization[];
extern const TCHAR szOrganizationMRU[];
extern const TCHAR szOrganizationUnit[];
extern const TCHAR szOrganizationUnitMRU[];

class CCertificate : public CObject
{
	DECLARE_DYNCREATE(CCertificate)
public:
	CCertificate();
	~CCertificate();

	enum
	{
		CA_OFFLINE = 0,
		CA_ONLINE = 1
	};
	enum
	{
		REQUEST_UNDEFINED,
		REQUEST_NEW_CERT,				// if we generating fresh new certificate
		REQUEST_RENEW_CERT,			// if we generating cert for renewal
		REQUEST_REPLACE_CERT,		// replace currect cert by someone from MY store
		REQUEST_INSTALL_CERT,		// get existing certificate for empty web server
		REQUEST_PROCESS_PENDING,	// accept and install response from CA
		REQUEST_IMPORT_KEYRING,
        REQUEST_IMPORT_CERT,
        REQUEST_EXPORT_CERT,
        REQUEST_COPY_MOVE_FROM_REMOTE,
        REQUEST_COPY_MOVE_TO_REMOTE,
		STATUS_CODE_LAST
	};
	enum
	{
		USE_ERROR_STRING_PARAM = -2,
		USE_ERROR_STRING_ID = -1,
		USE_ERROR_STRING_DEFAULT = USE_DEFAULT_CAPTION
	};
	BOOL Init();
    BOOL IsCertObjInstalled();
	BOOL SaveSettings();
	BOOL SetSecuritySettings();
	BOOL WriteRequest();
	BOOL PrepareRequest();
	BOOL PrepareRequestString(CString& request_text, CCryptBlob& request_blob);
	BOOL WriteRequestString(CString& request);
	BOOL SubmitRequest();
	BOOL SubmitRenewalRequest();
	BOOL WriteRenewalRequest();
	void DumpHeader(CString& str);
	void DumpOnlineHeader(CString& str);
	BOOL GetSelectedCertDescription(CERT_DESCRIPTION& cd);

	BOOL GetPFXFileCertDescription(CERT_DESCRIPTION& cd)
	{
		return GetCertDescription(GetPFXFileCert(), cd);
	}
	BOOL GetKeyCertDescription(CERT_DESCRIPTION& cd)
	{
		return GetCertDescription(GetKeyRingCert(), cd);
	}
	BOOL GetInstalledCertDescription(CERT_DESCRIPTION& cd)
	{
		return GetCertDescription(GetInstalledCert(), cd);
	}
	BOOL GetResponseCertDescription(CERT_DESCRIPTION& cd);
	BOOL HasPendingRequest()
	{
		return (NULL != GetPendingRequest());
	}
	BOOL HasInstalledCert();
	BOOL InstallResponseCert();
	HRESULT UninstallCert();
	BOOL InstallSelectedCert();
	BOOL InstallKeyRingCert();
    BOOL InstallImportPFXCert();
    BOOL InstallExportPFXCert();
    BOOL InstallCopyMoveFromRemote();
    BOOL InstallCopyMoveToRemote();
	BOOL ReplaceInstalled();
	BOOL CancelRequest();
	PCCERT_CONTEXT GetPendingRequest();
	PCCERT_CONTEXT GetResponseCert();
	PCCERT_CONTEXT GetInstalledCert();
	PCCERT_CONTEXT GetKeyRingCert();
    PCCERT_CONTEXT GetPFXFileCert();
	void DeleteKeyRingCert()
	{
		if (m_pKeyRingCert != NULL)
		{
			CertFreeCertificateContext(m_pKeyRingCert);
			m_pKeyRingCert = NULL;
		}
	}
	IEnroll * GetEnrollObject();
	int GetStatusCode() 
	{
		return m_status_code;
	}
	void SetStatusCode(int code) 
	{
		ASSERT(code >= 0 && code < STATUS_CODE_LAST);
		m_status_code = code;
	}
	BOOL FindInstanceNameForResponse(CString& str);
	BOOL IsResponseInstalled(CString& str);
	BOOL GetCertDescList(CCertDescList& list);
	BOOL LoadRenewalData();
	int MyStoreCertCount();

	void SetBodyTextID(int nID)
	{
		m_idErrorText = nID;
		m_strErrorText.Empty();
	}
	void SetBodyTextString(const CString& str)
	{
		m_strErrorText = str;
		m_idErrorText = USE_ERROR_STRING_PARAM;
	}
	void GetCertificateTemplate(CString& str)
	{
		str = _T("CertificateTemplate:");
		str += m_CertificateTemplate;
	}

protected:
	void CreateDN(CString& str);
	BOOL WriteHeader();
	BOOL WriteRequestBody();
	BOOL GetCertDescription(PCCERT_CONTEXT pCert,
									CERT_DESCRIPTION& desc);

public:
	int		m_CAType;
	CString	m_ConfigCA;
	CString	m_CertificateTemplate;

	CString	m_FriendlyName;
	int		m_KeyLength;
	CString	m_CommonName;
	CString	m_OrganizationUnit;
	CString	m_Organization;
	CString	m_Locality;
	CString	m_State;
	CString	m_Country;

	CStringList m_OnlineCAList;
	CString	m_MachineName;
	CString	m_WebSiteInstanceName;

    BOOL    m_DeleteAfterCopy;
    CString	m_MachineName_Remote;
    CString	m_UserName_Remote;
    CString	m_UserPassword_Remote;
    CString	m_WebSiteInstanceName_Remote;

	CString	m_ReqFileName;
	CString	m_RespFileName;
	CString	m_KeyFileName;
	CString	m_KeyPassword;
    BOOL    m_DefaultCSP;
    DWORD   m_DefaultProviderType;
    DWORD   m_CustomProviderType;
    CString m_CspName;
	CRYPT_HASH_BLOB * m_pSelectedCertHash;

	UINT	m_idErrorText;
	CString	m_strErrorText;
	CString m_strRenewalRequest;
	HRESULT	m_hResult;

	BOOL m_CreateDirectory;
	BOOL m_SGCcertificat;

    BOOL m_ExportPFXPrivateKey;
    BOOL m_CertObjInstalled;
    BOOL m_MarkAsExportable;

protected:
	PCCERT_CONTEXT m_pPendingRequest;
	PCCERT_CONTEXT m_RespCertContext;
	PCCERT_CONTEXT m_pInstalledCert;
	PCCERT_CONTEXT m_pKeyRingCert;
	IEnroll * m_pEnroll;
	int m_status_code;				// what we are doing in this session
};

#endif	// _CERTIFICAT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\certwiz\certificat.cpp ===
//
// Certificat.cpp
//
#include "StdAfx.h"
#include "CertWiz.h"
#include "Certificat.h"
#include "certutil.h"
#include <malloc.h>
#include "base64.h"
#include "resource.h"
#include <certupgr.h>
#include <certca.h>
#include "mru.h"
#include "Shlwapi.h"
#include <cryptui.h>

// for certobj object
#include "certobj.h"
#include "certobj_i.c"

const CLSID CLSID_CEnroll = 
	{0x43F8F289, 0x7A20, 0x11D0, {0x8F, 0x06, 0x00, 0xC0, 0x4F, 0xC2, 0x95, 0xE1}};

const IID IID_IEnroll = 
	{0xacaa7838, 0x4585, 0x11d1, {0xab, 0x57, 0x00, 0xc0, 0x4f, 0xc2, 0x95, 0xe1}};

const IID IID_ICEnroll2 = 
	{0x704ca730, 0xc90b, 0x11d1, {0x9b, 0xec, 0x00, 0xc0, 0x4f, 0xc2, 0x95, 0xe1}};
const CLSID CLSID_CCertRequest = 
	{0x98aff3f0, 0x5524, 0x11d0, {0x88, 0x12, 0x00, 0xa0, 0xc9, 0x03, 0xb8, 0x3c}};
const IID IID_ICertRequest = 
	{0x014e4840, 0x5523, 0x11d0, {0x88, 0x12, 0x00, 0xa0, 0xc9, 0x03, 0xb8, 0x3c}};

WCHAR * bstrEmpty = L"";

extern CCertWizApp theApp;

BOOL 
CCryptBlob::Resize(DWORD cb)
{
	if (cb > GetSize())
	{
		if (NULL != 
				(m_blob.pbData = Realloc(m_blob.pbData, cb)))
		{
			m_blob.cbData = cb;
			return TRUE;
		}
		return FALSE;
	}
	return TRUE;
}

IMPLEMENT_DYNAMIC(CCertificate, CObject)

CCertificate::CCertificate()
	: m_CAType(CA_OFFLINE), 
	m_KeyLength(512),
	m_pPendingRequest(NULL),
	m_RespCertContext(NULL),
	m_pInstalledCert(NULL),
	m_pKeyRingCert(NULL),
	m_pEnroll(NULL),
	m_status_code(-1),
	m_CreateDirectory(FALSE),
	m_SGCcertificat(FALSE),
   m_DefaultCSP(TRUE),
   m_DefaultProviderType(PROV_RSA_SCHANNEL),
   m_ExportPFXPrivateKey(FALSE),
   m_CertObjInstalled(FALSE)
{
}

CCertificate::~CCertificate()
{
	if (m_pPendingRequest != NULL)
		CertFreeCertificateContext(m_pPendingRequest);
	if (m_RespCertContext != NULL)
		CertFreeCertificateContext(m_RespCertContext);
	if (m_pInstalledCert != NULL)
		CertFreeCertificateContext(m_pInstalledCert);
	if (m_pKeyRingCert != NULL)
		CertFreeCertificateContext(m_pKeyRingCert);
	if (m_pEnroll != NULL)
		m_pEnroll->Release();
}

const TCHAR szResponseFileName[] = _T("ResponseFileName");
const TCHAR szKeyRingFileName[] = _T("KeyRingFileName");
const TCHAR szRequestFileName[] = _T("RequestFileName");
const TCHAR szCertificateTemplate[] = _T("CertificateTemplate");
const TCHAR szState[] = _T("State");
const TCHAR szStateMRU[] = _T("StateMRU");
const TCHAR szLocality[] = _T("Locality");
const TCHAR szLocalityMRU[] = _T("LocalityMRU");
const TCHAR szOrganization[] = _T("Organization");
const TCHAR szOrganizationMRU[] = _T("OrganizationMRU");
const TCHAR szOrganizationUnit[] = _T("OrganizationUnit");
const TCHAR szOrganizationUnitMRU[] = _T("OrganizationUnitMRU");
const TCHAR szMachineNameRemote[] = _T("MachineNameRemote");
const TCHAR szUserNameRemote[] = _T("UserNameRemote");
const TCHAR szWebSiteInstanceNameRemote[] = _T("WebSiteInstanceNameRemote");


#define QUERY_NAME(x,y)\
	do {\
		if (ERROR_SUCCESS == RegQueryValueEx(hKey, (x), NULL, &dwType, NULL, &cbData))\
		{\
			ASSERT(dwType == REG_SZ);\
			pName = (BYTE *)(y).GetBuffer(cbData);\
			RegQueryValueEx(hKey, (x), NULL, &dwType, pName, &cbData);\
			if (pName != NULL)\
			{\
				(y).ReleaseBuffer();\
				pName = NULL;\
			}\
		}\
	} while (0)


BOOL
CCertificate::Init()
{
	ASSERT(!m_MachineName.IsEmpty());
	ASSERT(!m_WebSiteInstanceName.IsEmpty());
	// get web site description from metabase, it could be empty
	// do not panic in case of error
	if (!GetServerComment(m_MachineName, m_WebSiteInstanceName, m_FriendlyName, &m_hResult))
		m_hResult = S_OK;
	m_CommonName = m_MachineName;
	m_CommonName.MakeLower();

    m_MachineName_Remote = m_MachineName;
    m_WebSiteInstanceName_Remote = m_WebSiteInstanceName;

	HKEY hKey = theApp.RegOpenKeyWizard();
	DWORD dwType;
	DWORD cbData;
	if (hKey != NULL)
	{
		BYTE * pName = NULL;
		QUERY_NAME(szRequestFileName, m_ReqFileName);
		QUERY_NAME(szResponseFileName, m_RespFileName);
		QUERY_NAME(szKeyRingFileName, m_KeyFileName);
        QUERY_NAME(szMachineNameRemote, m_MachineName_Remote);
        QUERY_NAME(szUserNameRemote, m_UserName_Remote);
        QUERY_NAME(szWebSiteInstanceNameRemote, m_WebSiteInstanceName_Remote);
		QUERY_NAME(szCertificateTemplate, m_CertificateTemplate);
		QUERY_NAME(szState, m_State);
		QUERY_NAME(szLocality, m_Locality);
		QUERY_NAME(szOrganization, m_Organization);
		QUERY_NAME(szOrganizationUnit, m_OrganizationUnit);
		RegCloseKey(hKey);
	}
#ifdef _DEBUG
	else
	{
		TRACE(_T("Failed to open Registry key for Wizard parameters\n"));
	}
#endif
	if (m_CertificateTemplate.IsEmpty())
	{
		// User didn't defined anything -- use standard name
		m_CertificateTemplate = wszCERTTYPE_WEBSERVER;
	}

    // Set flag to tell if com certobj is installed
    m_CertObjInstalled = IsCertObjInstalled();
	return TRUE;
}

#define SAVE_NAME(x,y)\
		do {\
			if (!(y).IsEmpty())\
			{\
				VERIFY(ERROR_SUCCESS == RegSetValueEx(hKey, (x), 0, REG_SZ, \
						(const BYTE *)(LPCTSTR)(y), \
						sizeof(TCHAR) * ((y).GetLength() + 1)));\
			}\
		} while (0)

BOOL
CCertificate::SaveSettings()
{
	HKEY hKey = theApp.RegOpenKeyWizard();
	if (hKey != NULL)
	{
		switch (GetStatusCode())
		{
		case REQUEST_NEW_CERT:
		case REQUEST_RENEW_CERT:
			SAVE_NAME(szState, m_State);
			AddToMRU(szStateMRU, m_State);
			SAVE_NAME(szLocality, m_Locality);
			AddToMRU(szLocalityMRU, m_Locality);
			SAVE_NAME(szOrganization, m_Organization);
			AddToMRU(szOrganizationMRU, m_Organization);
			SAVE_NAME(szOrganizationUnit, m_OrganizationUnit);
			AddToMRU(szOrganizationUnitMRU, m_OrganizationUnit);
			SAVE_NAME(szRequestFileName, m_ReqFileName);
			break;
		case REQUEST_PROCESS_PENDING:
			SAVE_NAME(szResponseFileName, m_RespFileName);
			break;
		case REQUEST_IMPORT_KEYRING:
			SAVE_NAME(szKeyRingFileName, m_KeyFileName);
			break;
		case REQUEST_IMPORT_CERT:
        case REQUEST_EXPORT_CERT:
			SAVE_NAME(szKeyRingFileName, m_KeyFileName);
			break;
		case REQUEST_COPY_MOVE_FROM_REMOTE:
        case REQUEST_COPY_MOVE_TO_REMOTE:
			SAVE_NAME(szKeyRingFileName, m_KeyFileName);
            SAVE_NAME(szMachineNameRemote, m_MachineName_Remote);
            SAVE_NAME(szUserNameRemote, m_UserName_Remote);
            SAVE_NAME(szWebSiteInstanceNameRemote, m_WebSiteInstanceName_Remote);
			break;
		default:
			break;
		}
		RegCloseKey(hKey);
		return TRUE;
	}
#ifdef _DEBUG
	else
	{
		TRACE(_T("Failed to open Registry key for Wizard parameters\n"));
	}
#endif
	return FALSE;
}

BOOL
CCertificate::SetSecuritySettings()
{
	long dwGenKeyFlags;
	if (SUCCEEDED(GetEnrollObject()->get_GenKeyFlags(&dwGenKeyFlags)))
	{
		dwGenKeyFlags &= 0x0000FFFF;
		dwGenKeyFlags |= (m_KeyLength << 16);
		if (m_SGCcertificat)
			dwGenKeyFlags |= CRYPT_SGCKEY;
		return (SUCCEEDED(GetEnrollObject()->put_GenKeyFlags(dwGenKeyFlags)));
	}
	return FALSE;
}

// defines taken from the old KeyGen utility
#define MESSAGE_HEADER  "-----BEGIN NEW CERTIFICATE REQUEST-----\r\n"
#define MESSAGE_TRAILER "-----END NEW CERTIFICATE REQUEST-----\r\n"

BOOL
CCertificate::WriteRequestString(CString& request)
{
	ASSERT(!PathIsRelative(m_ReqFileName));

	BOOL bRes = FALSE;
	try {
		CString strPath;

		strPath = m_ReqFileName;
		LPTSTR pPath = strPath.GetBuffer(strPath.GetLength());
		PathRemoveFileSpec(pPath);
		if (!PathIsDirectory(pPath))
		{
			if (!CreateDirectoryFromPath(strPath, NULL))
			{
				m_hResult = HRESULT_FROM_WIN32(GetLastError());
				SetBodyTextID(USE_DEFAULT_CAPTION);
				return FALSE;
			}
		}
		strPath.ReleaseBuffer();
		HANDLE hFile = ::CreateFile(m_ReqFileName,
			GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
		if (hFile != INVALID_HANDLE_VALUE)
		{
			DWORD cb = request.GetLength();
			char * ascii_buf = (char *)_alloca(cb);
			wcstombs(ascii_buf, request, cb);
			bRes = ::WriteFile(hFile, ascii_buf, cb, &cb, NULL);
			::CloseHandle(hFile);
		}
		else
		{
			m_hResult = HRESULT_FROM_WIN32(GetLastError());
			SetBodyTextID(USE_DEFAULT_CAPTION);
		}
	}
	catch (CFileException * e)
	{
		TCHAR   szCause[255];
		e->GetErrorMessage(szCause, 255);
		TRACE(_T("Got CFileException with error: %s\n"), szCause);
		m_hResult = HRESULT_FROM_WIN32(e->m_lOsError);
	}
	catch (CException * e)
	{
		TCHAR   szCause[255];
		e->GetErrorMessage(szCause, 255);
		TRACE(_T("Got CException with error: %s\n"), szCause);
		m_hResult = HRESULT_FROM_WIN32(GetLastError());
	}
	return bRes;
}

#define HEADER_SERVER_         _T("Server:\t%s\r\n\r\n")
#define HEADER_COMMON_NAME_    _T("Common-name:\t%s\r\n")
#define HEADER_FRIENDLY_NAME_  _T("Friendly name:\t%s\r\n")
#define HEADER_ORG_UNIT_       _T("Organization Unit:\t%s\r\n")
#define HEADER_ORGANIZATION_   _T("Organization:\t%s\r\n")
#define HEADER_LOCALITY_       _T("Locality:\t%s\r\n")
#define HEADER_STATE_          _T("State:\t%s\r\n")
#define HEADER_COUNTRY_        _T("Country:\t%s\r\n")

static void WRITE_LINE(CString& str, TCHAR * format, CString& data)
{
   CString buf;
   buf.Format(format, data);
	str += buf;
}

void
CCertificate::DumpHeader(CString& str)
{
	DumpOnlineHeader(str);
}

void
CCertificate::DumpOnlineHeader(CString& str)
{
	WRITE_LINE(str, HEADER_SERVER_, m_CommonName);
	WRITE_LINE(str, HEADER_FRIENDLY_NAME_, m_FriendlyName);
	WRITE_LINE(str, HEADER_ORG_UNIT_, m_OrganizationUnit);
	WRITE_LINE(str, HEADER_ORGANIZATION_, m_Organization);
	WRITE_LINE(str, HEADER_LOCALITY_, m_Locality);;
	WRITE_LINE(str, HEADER_STATE_, m_State);
	WRITE_LINE(str, HEADER_COUNTRY_, m_Country);
}

BOOL
CCertificate::GetSelectedCertDescription(CERT_DESCRIPTION& cd)
{
	BOOL bRes = FALSE;
	ASSERT(m_pSelectedCertHash != NULL);
	HCERTSTORE hStore = OpenMyStore(GetEnrollObject(), &m_hResult);
	if (hStore != NULL)
	{
		PCCERT_CONTEXT pCert = CertFindCertificateInStore(hStore,
				CRYPT_ASN_ENCODING,
				0,
				CERT_FIND_HASH,
				m_pSelectedCertHash,
				NULL);
		if (pCert != NULL)
		{
			bRes = GetCertDescription(pCert, cd);
			CertFreeCertificateContext(pCert);
		}
		CertCloseStore(hStore, 0);
	}
	return bRes;
}

void CCertificate::CreateDN(CString& str)
{
	str.Empty();
	str += _T("CN=") + m_CommonName;
	str += _T("\n,OU=") + m_OrganizationUnit;
	str += _T("\n,O=") + m_Organization;
	str += _T("\n,L=") + m_Locality;
	str += _T("\n,S=") + m_State;
	str += _T("\n,C=") + m_Country;
}

PCCERT_CONTEXT
CCertificate::GetPendingRequest()
{
	if (m_pPendingRequest == NULL)
	{
		ASSERT(!m_WebSiteInstanceName.IsEmpty());
		m_pPendingRequest = GetPendingDummyCert(m_WebSiteInstanceName, 
						GetEnrollObject(), &m_hResult);
	}
	return m_pPendingRequest;
}

PCCERT_CONTEXT
CCertificate::GetInstalledCert()
{
	if (m_pInstalledCert == NULL)
	{
		m_pInstalledCert = ::GetInstalledCert(m_MachineName,
		      m_WebSiteInstanceName,
				GetEnrollObject(),
				&m_hResult);
	}
	return m_pInstalledCert;
}


PCCERT_CONTEXT
CCertificate::GetPFXFileCert()
{
	ASSERT(!m_KeyFileName.IsEmpty());
	ASSERT(!m_KeyPassword.IsEmpty());
    IIISCertObj *pTheObject = NULL;
    DWORD cbBinaryBufferSize = 0;
    char * pbBinaryBuffer = NULL;
    BOOL bPleaseDoCoUninit = FALSE;
    BOOL bAllowExport = m_MarkAsExportable;

    if (FALSE == m_CertObjInstalled)
    {
        m_pKeyRingCert = NULL;
        goto GetPFXFileCert_Exit;
    }

	if (m_pKeyRingCert == NULL)
	{
        BSTR bstrFileName = SysAllocString(m_KeyFileName);
        BSTR bstrFilePassword = SysAllocString(m_KeyPassword);
        VARIANT VtArray;

        m_hResult = CoInitialize(NULL);
        if(FAILED(m_hResult))
        {
            return NULL;
        }
        bPleaseDoCoUninit = TRUE;

        // this one seems to work with surrogates..
        m_hResult = CoCreateInstance(CLSID_IISCertObj,NULL,CLSCTX_SERVER,IID_IIISCertObj,(void **)&pTheObject);
        if (FAILED(m_hResult))
        {
            goto GetPFXFileCert_Exit;
        }

        // at this point we were able to instantiate the com object on the server (local or remote)
        m_hResult = pTheObject->ImportToCertStore(bstrFileName, bstrFilePassword, bAllowExport, &VtArray);
        if (FAILED(m_hResult))
        {
            m_pKeyRingCert = NULL;
            goto GetPFXFileCert_Exit;
        }

        // we have a VtArray now.
        // change it back to a binary blob
        m_hResult = HereIsVtArrayGimmieBinary(&VtArray,&cbBinaryBufferSize,&pbBinaryBuffer,FALSE);
        if (FAILED(m_hResult))
        {
            m_pKeyRingCert = NULL;
            goto GetPFXFileCert_Exit;
        }

        // we have the hash now.
        // we can use it to lookup the cert and get the PCCERT_CONTEXT

        // Get the pointer to the cert...
        m_pKeyRingCert = GetInstalledCertFromHash(&m_hResult,cbBinaryBufferSize,pbBinaryBuffer);
	}

GetPFXFileCert_Exit:
    if (pTheObject)
    {
        pTheObject->Release();
        pTheObject = NULL;
    }
    if (pbBinaryBuffer)
    {
        CoTaskMemFree(pbBinaryBuffer);
    }
    if (bPleaseDoCoUninit)
    {
        CoUninitialize();
    }
	return m_pKeyRingCert;
}


PCCERT_CONTEXT
CCertificate::GetKeyRingCert()
{
	ASSERT(!m_KeyFileName.IsEmpty());
	ASSERT(!m_KeyPassword.IsEmpty());
	if (m_pKeyRingCert == NULL)
	{
		int len = m_KeyPassword.GetLength() * 2;
		char * ascii_password = (char *)_alloca(len + 1);
		ASSERT(ascii_password != NULL);
		size_t n;
		VERIFY(-1 != (n = wcstombs(ascii_password, m_KeyPassword, len)));
		ascii_password[n] = '\0';
		m_pKeyRingCert = ::ImportKRBackupToCAPIStore(
										(LPTSTR)(LPCTSTR)m_KeyFileName,
										ascii_password,
										_T("MY"));
		if (m_pKeyRingCert == NULL)
		{
			m_hResult = HRESULT_FROM_WIN32(GetLastError());
		}
		
	}
	return m_pKeyRingCert;
}

/* INTRINSA suppress=null_pointers, uninitialized */
PCCERT_CONTEXT
CCertificate::GetResponseCert()
{
	if (m_RespCertContext == NULL)
	{
		ASSERT(!m_RespFileName.IsEmpty());
		m_RespCertContext = GetCertContextFromPKCS7File(
					m_RespFileName,
					&GetPendingRequest()->pCertInfo->SubjectPublicKeyInfo,
					&m_hResult);
		ASSERT(SUCCEEDED(m_hResult));
	}
	return m_RespCertContext;
}

BOOL 
CCertificate::GetResponseCertDescription(CERT_DESCRIPTION& cd)
{
	CERT_DESCRIPTION cdReq;
	if (GetCertDescription(GetResponseCert(), cd))
	{
		if (GetCertDescription(GetPendingRequest(), cdReq))
		{
			cd.m_FriendlyName = cdReq.m_FriendlyName;
		}
		return TRUE;
	}
	return FALSE;
}

/*------------------------------------------------------------------------------
	IsResponseInstalled

	Function checks if certificate from the response file
	m_RespFileName was istalled to some server. If possible,
	it returns name of this server in str.
	Returns FALSE if certificate is not found in MY store or
	if this store cannot be opened
*/

BOOL
CCertificate::IsResponseInstalled(
						CString& str				// return server instance name (not yet implemented)
						)
{
	BOOL bRes = FALSE;
	// get cert context from response file
	PCCERT_CONTEXT pContext = GetCertContextFromPKCS7File(
		m_RespFileName, NULL, &m_hResult);
	if (pContext != NULL)
	{
		HCERTSTORE hStore = OpenMyStore(GetEnrollObject(), &m_hResult);
		if (hStore != NULL)
		{
			PCCERT_CONTEXT pCert = NULL;
			while (NULL != (pCert = CertEnumCertificatesInStore(hStore, pCert)))
			{
				// do not include installed cert to the list
				if (CertCompareCertificate(X509_ASN_ENCODING,
								pContext->pCertInfo, pCert->pCertInfo))
				{
					bRes = TRUE;
					// Try to find, where is was installed
					break;
				}
			}
			if (pCert != NULL)
				CertFreeCertificateContext(pCert);
		}
	}
	return bRes;
}

BOOL
CCertificate::FindInstanceNameForResponse(CString& str)
{
	BOOL bRes = FALSE;
	// get cert context from response file
	PCCERT_CONTEXT pContext = GetCertContextFromPKCS7File(
		m_RespFileName, NULL, &m_hResult);
	if (pContext != NULL)
	{
		// find dummy cert in REQUEST store that has public key
		// the same as in this context
		PCCERT_CONTEXT pReq = GetReqCertByKey(GetEnrollObject(), 
			&pContext->pCertInfo->SubjectPublicKeyInfo, &m_hResult);
		if (pReq != NULL)
		{
			// get friendly name prop from this dummy cert
			if (!GetFriendlyName(pReq, str, &m_hResult))
			{
				// get instance name prop from this dummy cert
				DWORD cb;
				BYTE * prop;
				if (	CertGetCertificateContextProperty(pReq, CERTWIZ_INSTANCE_NAME_PROP_ID, NULL, &cb)
					&& (NULL != (prop = (BYTE *)_alloca(cb)))
					&& CertGetCertificateContextProperty(pReq, CERTWIZ_INSTANCE_NAME_PROP_ID, prop, &cb)
					)
				{
					// decode this instance name property
					DWORD cbData = 0;
					BYTE * data = NULL;
					if (	CryptDecodeObject(CRYPT_ASN_ENCODING, X509_UNICODE_ANY_STRING,
								prop, cb, 0, NULL, &cbData)
						&&	(NULL != (data = (BYTE *)_alloca(cbData)))
						&& CryptDecodeObject(CRYPT_ASN_ENCODING, X509_UNICODE_ANY_STRING,
								prop, cb, 0, data, &cbData)
						)
					{
						CERT_NAME_VALUE * p = (CERT_NAME_VALUE *)data;
						CString strInstanceName = (LPCTSTR)p->Value.pbData;
						// now try to get comment from this server
						if (GetServerComment(m_MachineName, strInstanceName, str, &m_hResult))
						{
							if (str.IsEmpty())
							{
								// generate something like [Web Site #n]
								str.LoadString(IDS_WEB_SITE_N);
								int len = strInstanceName.GetLength();
								for (int i = len - 1, count = 0; i >= 0; i--, count++)
								{
									if (!_istdigit(strInstanceName.GetAt(i)))
										break;
								}
								ASSERT(count < len);
								AfxFormatString1(str, IDS_WEB_SITE_N, strInstanceName.Right(count));
							}
						}
						m_hResult = S_OK;
						bRes = TRUE;
					}
				}
			}
			CertFreeCertificateContext(pReq);
		}
		else
		{
			// probably this request was deleted from the request store
		}
		CertFreeCertificateContext(pContext);
	}
	return bRes;
}

IEnroll * 
CCertificate::GetEnrollObject()
{
	if (m_pEnroll == NULL)
	{
		m_hResult = CoCreateInstance(CLSID_CEnroll,
				NULL,
				CLSCTX_INPROC_SERVER,
				IID_IEnroll,
				(void **)&m_pEnroll);
		// now we need to change defaults for this
		// object to LOCAL_MACHINE
		if (m_pEnroll != NULL)
		{
			long dwFlags;
			VERIFY(SUCCEEDED(m_pEnroll->get_MyStoreFlags(&dwFlags)));
			dwFlags &= ~CERT_SYSTEM_STORE_LOCATION_MASK;
			dwFlags |= CERT_SYSTEM_STORE_LOCAL_MACHINE;
			// following call will change Request store flags also
			VERIFY(SUCCEEDED(m_pEnroll->put_MyStoreFlags(dwFlags)));
			VERIFY(SUCCEEDED(m_pEnroll->get_GenKeyFlags(&dwFlags)));
			dwFlags |= CRYPT_EXPORTABLE;
			VERIFY(SUCCEEDED(m_pEnroll->put_GenKeyFlags(dwFlags)));
			VERIFY(SUCCEEDED(m_pEnroll->put_KeySpec(AT_KEYEXCHANGE)));
			VERIFY(SUCCEEDED(m_pEnroll->put_ProviderType(m_DefaultProviderType)));
			VERIFY(SUCCEEDED(m_pEnroll->put_DeleteRequestCert(TRUE)));
		}
	}
	ASSERT(m_pEnroll != NULL);
	return m_pEnroll;
}

BOOL
CCertificate::HasInstalledCert()
{
	BOOL bResult = FALSE;
   CComAuthInfo auth;
	CMetaKey key(&auth,
				m_WebSiteInstanceName,
				METADATA_PERMISSION_READ,
				METADATA_MASTER_ROOT_HANDLE
            );
	if (key.Succeeded())
	{
		CString store_name;
		CBlob blob;
		if (	S_OK == key.QueryValue(MD_SSL_CERT_HASH, blob)
			&& S_OK == key.QueryValue(MD_SSL_CERT_STORE_NAME, store_name)
			)
		{
			bResult = TRUE;
		}
	}
	return bResult;
}

HRESULT
CCertificate::UninstallCert()
{
   CComAuthInfo auth;
	CMetaKey key(
            &auth,
				m_WebSiteInstanceName,
				METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE,
				METADATA_MASTER_ROOT_HANDLE
            );
	if (key.Succeeded())
	{
		CString store_name;
		key.QueryValue(MD_SSL_CERT_STORE_NAME, store_name);
		if (SUCCEEDED(key.DeleteValue(MD_SSL_CERT_HASH)))
        {
			key.DeleteValue(MD_SSL_CERT_STORE_NAME);
        }
	}
	return m_hResult = key.QueryResult();
}

BOOL CCertificate::WriteRequestBody()
{
	ASSERT(!m_ReqFileName.IsEmpty());

	HRESULT hr;
	BOOL bRes = FALSE;
	CString strDN;
	CreateDN(strDN);
	ASSERT(!strDN.IsEmpty());
	CString strUsage(szOID_PKIX_KP_SERVER_AUTH);
	CCryptBlobIMalloc request;
   GetEnrollObject()->put_ProviderType(m_DefaultCSP ? 
      m_DefaultProviderType : m_CustomProviderType);
   if (!m_DefaultCSP)
   {
      GetEnrollObject()->put_ProviderNameWStr((LPTSTR)(LPCTSTR)m_CspName);
      GetEnrollObject()->put_KeySpec(AT_SIGNATURE);
   }
	if (SUCCEEDED(hr = GetEnrollObject()->createPKCS10WStr((LPTSTR)(LPCTSTR)strDN, 
																		(LPTSTR)(LPCTSTR)strUsage, 
																		request)))
	{
		// BASE64 encode pkcs 10
		DWORD err, cch; 
		char * psz;
		if (	(err = Base64EncodeA(request.GetData(), request.GetSize(), NULL, &cch)) == ERROR_SUCCESS     
			&&	(psz = (char *)_alloca(cch)) != NULL     
			&&	(err = Base64EncodeA(request.GetData(), request.GetSize(), psz, &cch)) == ERROR_SUCCESS 
			) 
		{
			HANDLE hFile = ::CreateFile(m_ReqFileName,
					GENERIC_WRITE, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
         if (hFile == INVALID_HANDLE_VALUE)
            return FALSE;

			DWORD written;
			::SetFilePointer(hFile, 0, NULL, FILE_END);
			::WriteFile(hFile, MESSAGE_HEADER, sizeof(MESSAGE_HEADER) - 1, &written, NULL);
			::WriteFile(hFile, psz, cch, &written, NULL);
			::WriteFile(hFile, MESSAGE_TRAILER, sizeof(MESSAGE_TRAILER) - 1, &written, NULL);
			::CloseHandle(hFile);

			// get back request from encoded data
			PCERT_REQUEST_INFO req_info;
			VERIFY(GetRequestInfoFromPKCS10(request, &req_info, &m_hResult));
			// find dummy cert put to request store by createPKCS10 call
			HCERTSTORE hStore = OpenRequestStore(GetEnrollObject(), &m_hResult);
			if (hStore != NULL)
			{
				PCCERT_CONTEXT pDummyCert = CertFindCertificateInStore(hStore,
															CRYPT_ASN_ENCODING,
															0,
															CERT_FIND_PUBLIC_KEY,
															(void *)&req_info->SubjectPublicKeyInfo,
															NULL);
				if (pDummyCert != NULL)
				{
					// now we need to attach web server instance name to this cert
					// encode string into data blob
					CRYPT_DATA_BLOB name;
					CERT_NAME_VALUE name_value;
					name_value.dwValueType = CERT_RDN_BMP_STRING;
					name_value.Value.cbData = 0;
					name_value.Value.pbData = (LPBYTE)(LPCTSTR)m_WebSiteInstanceName;
					{
						if (	!CryptEncodeObject(CRYPT_ASN_ENCODING, X509_UNICODE_ANY_STRING,
									&name_value, NULL, &name.cbData) 
							||	(name.pbData = (BYTE *)_alloca(name.cbData)) == NULL  
							||	!CryptEncodeObject(CRYPT_ASN_ENCODING, X509_UNICODE_ANY_STRING,
									&name_value, name.pbData, &name.cbData) 
							)
						{
							ASSERT(FALSE);
						}
						VERIFY(bRes = CertSetCertificateContextProperty(pDummyCert, 
										CERTWIZ_INSTANCE_NAME_PROP_ID, 0, &name));
					}
					// put friendly name to dummy cert -- we will reuse it later
					m_FriendlyName.ReleaseBuffer();
					AttachFriendlyName(pDummyCert, m_FriendlyName, &m_hResult);
					// we also need to put some flag to show what we are waiting for:
					//	new sertificate or renewing certificate
					CRYPT_DATA_BLOB flag;
					if (	!CryptEncodeObject(CRYPT_ASN_ENCODING, X509_INTEGER,
								&m_status_code, NULL, &flag.cbData) 
						||	(flag.pbData = (BYTE *)_alloca(flag.cbData)) == NULL  
						||	!CryptEncodeObject(CRYPT_ASN_ENCODING, X509_INTEGER,
								&m_status_code, flag.pbData, &flag.cbData) 
						)
					{
						ASSERT(FALSE);
					}
					VERIFY(bRes = CertSetCertificateContextProperty(pDummyCert, 
									CERTWIZ_REQUEST_FLAG_PROP_ID, 0, &flag));
					CertFreeCertificateContext(pDummyCert);
				}
				CertCloseStore(hStore, CERT_CLOSE_STORE_CHECK_FLAG);
			}
			LocalFree(req_info);
		}
		bRes = TRUE;
	}
	return bRes;
}

BOOL
CCertificate::InstallResponseCert()
{
	BOOL bRes = FALSE;
	CCryptBlobLocal blobRequestText;

	// Get all our data attached to dummy cert
	GetFriendlyName(GetPendingRequest(), m_FriendlyName, &m_hResult);
	ASSERT(!m_FriendlyName.IsEmpty());
	GetBlobProperty(GetPendingRequest(), 
		CERTWIZ_REQUEST_TEXT_PROP_ID, blobRequestText, &m_hResult);
	ASSERT(blobRequestText.GetSize() != 0);

	CCryptBlobLocal hash_blob;
	if (::GetHashProperty(GetResponseCert(), hash_blob, &m_hResult))
	{
		if (SUCCEEDED(m_hResult = GetEnrollObject()->acceptFilePKCS7WStr(
				(LPTSTR)(LPCTSTR)m_RespFileName))
		&& InstallCertByHash(hash_blob, m_MachineName, m_WebSiteInstanceName, 
            GetEnrollObject(), &m_hResult)
		)
		{
			// reattach friendly name and request text to installed cert
			m_FriendlyName.ReleaseBuffer();
			AttachFriendlyName(GetInstalledCert(), m_FriendlyName, &m_hResult);
			bRes = CertSetCertificateContextProperty(GetInstalledCert(), 
			   CERTWIZ_REQUEST_TEXT_PROP_ID, 0, blobRequestText);
		}
	}
	if (!bRes)
	{
		SetBodyTextID(USE_DEFAULT_CAPTION);
	}
	return bRes;
}


BOOL
CCertificate::InstallCopyMoveFromRemote()
{
	ASSERT(!m_KeyFileName.IsEmpty());
	ASSERT(!m_KeyPassword.IsEmpty());
    ASSERT(!m_WebSiteInstanceName.IsEmpty());

	BOOL bRes = FALSE;
    BOOL bPleaseDoCoUninit = FALSE;

    IIISCertObj *pTheObject = NULL;

    VARIANT varUserName;
    VARIANT varUserPassword;
    VARIANT * pvarUserName = &varUserName;
    VARIANT * pvarUserPassword = &varUserPassword;
    VariantInit(pvarUserName);
    VariantInit(pvarUserPassword);
    BOOL bAllowExport = m_MarkAsExportable;

    if (FALSE == m_CertObjInstalled)
    {
        goto InstallCopyMoveFromRemote_Exit;
    }

    pvarUserName->bstrVal = SysAllocString(_T(""));
    pvarUserPassword->bstrVal = SysAllocString(_T(""));
    V_VT(pvarUserName) = VT_BSTR;
    V_VT(pvarUserPassword) = VT_BSTR;

    // set the properties to the remote server's info
    // when we call copy, it will connect to the 
    // remote object and copy it back into our object

    // local machine
    BSTR bstrServerName = SysAllocString(m_MachineName);
    BSTR bstrUserName = SysAllocString(_T(""));
    BSTR bstrUserPassword = SysAllocString(_T(""));
    BSTR bstrInstanceName = SysAllocString(m_WebSiteInstanceName);
    // remote machine
    BSTR bstrUserName_Remote = SysAllocString(m_UserName_Remote);
    BSTR bstrUserPassword_Remote = SysAllocString(m_UserPassword_Remote);
    BSTR bstrServerName_Remote = SysAllocString(m_MachineName_Remote);
    BSTR bstrInstanceName_Remote = SysAllocString(m_WebSiteInstanceName_Remote);
   
    m_hResult = CoInitialize(NULL);
    if(FAILED(m_hResult))
    {
        return bRes;
    }
    bPleaseDoCoUninit = TRUE;

    // this one seems to work with surrogates..
    m_hResult = CoCreateInstance(CLSID_IISCertObj,NULL,CLSCTX_SERVER,IID_IIISCertObj,(void **)&pTheObject);
    if (FAILED(m_hResult))
    {
        goto InstallCopyMoveFromRemote_Exit;
    }

    // at this point we were able to instantiate the com object on the server (local or remote)
    pTheObject->put_ServerName(bstrServerName_Remote);
    pTheObject->put_UserName(bstrUserName_Remote);
    pTheObject->put_UserPassword(bstrUserPassword_Remote);
    pTheObject->put_InstanceName(bstrInstanceName_Remote);
    if (m_DeleteAfterCopy)
    {
        m_hResult = pTheObject->Move(bAllowExport, bstrServerName,bstrInstanceName,varUserName,varUserPassword);
    }
    else
    {
        m_hResult = pTheObject->Copy(bAllowExport, bstrServerName,bstrInstanceName,varUserName,varUserPassword);
    }
    if (FAILED(m_hResult))
    {
        goto InstallCopyMoveFromRemote_Exit;
    }

    bRes = TRUE;

InstallCopyMoveFromRemote_Exit:
    if (pvarUserName)
    {
        VariantClear(pvarUserName);
    }
    if (pvarUserPassword)
    {
        VariantClear(pvarUserPassword);
    }
	if (!bRes)
	{
		SetBodyTextID(USE_DEFAULT_CAPTION);
	}
    if (pTheObject)
    {
        pTheObject->Release();
        pTheObject = NULL;
    }
    if (bPleaseDoCoUninit)
    {
        CoUninitialize();
    }
	return bRes;
}


BOOL CCertificate::IsCertObjInstalled()
{
    BOOL bReturn = FALSE;
    HRESULT hRes = E_FAIL;
    BOOL bPleaseDoCoUninit = FALSE;
    IIISCertObj *pTheObject = NULL;

    hRes = CoInitialize(NULL);
    if(FAILED(hRes))
    {
        bReturn = FALSE;
        goto IsCertObjInstalled_Exit;
    }
    bPleaseDoCoUninit = TRUE;

    // this one seems to work with surrogates..
    hRes = CoCreateInstance(CLSID_IISCertObj,NULL,CLSCTX_SERVER,IID_IIISCertObj,(void **)&pTheObject);
    if (FAILED(hRes))
    {
        bReturn = FALSE;
        goto IsCertObjInstalled_Exit;
    }
    if (pTheObject)
    {
        bReturn = TRUE;
        pTheObject->Release();
        pTheObject = NULL;

    }

IsCertObjInstalled_Exit:
    if (bPleaseDoCoUninit)
    {
        CoUninitialize();
    }
    return bReturn;
}


BOOL
CCertificate::InstallCopyMoveToRemote()
{
	ASSERT(!m_KeyFileName.IsEmpty());
	ASSERT(!m_KeyPassword.IsEmpty());
    ASSERT(!m_WebSiteInstanceName.IsEmpty());

	BOOL bRes = FALSE;
    BOOL bPleaseDoCoUninit = FALSE;

    IIISCertObj *pTheObject = NULL;

    VARIANT varUserName_Remote;
    VARIANT varUserPassword_Remote;
    VARIANT * pvarUserName_Remote = &varUserName_Remote;
    VARIANT * pvarUserPassword_Remote = &varUserPassword_Remote;
    VariantInit(pvarUserName_Remote);
    VariantInit(pvarUserPassword_Remote);
    BOOL bAllowExport = m_MarkAsExportable;

    if (FALSE == m_CertObjInstalled)
    {
        goto InstallCopyMoveToRemote_Exit;
    }

    pvarUserName_Remote->bstrVal = SysAllocString(m_UserName_Remote);
    pvarUserPassword_Remote->bstrVal = SysAllocString(m_UserPassword_Remote);
    V_VT(pvarUserName_Remote) = VT_BSTR;
    V_VT(pvarUserPassword_Remote) = VT_BSTR;

    // set the properties to the remote server's info
    // when we call copy, it will connect to the 
    // remote object and copy it back into our object

    // local machine
    BSTR bstrServerName = SysAllocString(_T(""));
    BSTR bstrUserName = SysAllocString(_T(""));
    BSTR bstrUserPassword = SysAllocString(_T(""));
    BSTR bstrInstanceName = SysAllocString(m_WebSiteInstanceName);
    // remote machine
    BSTR bstrServerName_Remote = SysAllocString(m_MachineName_Remote);
    BSTR bstrInstanceName_Remote = SysAllocString(m_WebSiteInstanceName_Remote);
   
    m_hResult = CoInitialize(NULL);
    if(FAILED(m_hResult))
    {
        return bRes;
    }
    bPleaseDoCoUninit = TRUE;

    // this one seems to work with surrogates..
    m_hResult = CoCreateInstance(CLSID_IISCertObj,NULL,CLSCTX_SERVER,IID_IIISCertObj,(void **)&pTheObject);
    if (FAILED(m_hResult))
    {
        goto InstallCopyMoveToRemote_Exit;
    }

    // at this point we were able to instantiate the com object on the server (local or remote)
    pTheObject->put_ServerName(bstrServerName);
    pTheObject->put_UserName(bstrUserName);
    pTheObject->put_UserPassword(bstrUserPassword);
    pTheObject->put_InstanceName(bstrInstanceName);
    if (m_DeleteAfterCopy)
    {
        m_hResult = pTheObject->Move(bAllowExport, bstrServerName_Remote,bstrInstanceName_Remote,varUserName_Remote,varUserPassword_Remote);
    }
    else
    {
        m_hResult = pTheObject->Copy(bAllowExport, bstrServerName_Remote,bstrInstanceName_Remote,varUserName_Remote,varUserPassword_Remote);
    }
    if (FAILED(m_hResult))
    {
        goto InstallCopyMoveToRemote_Exit;
    }

    m_hResult = S_OK;
    bRes = TRUE;

InstallCopyMoveToRemote_Exit:
    if (pvarUserName_Remote)
    {
        VariantClear(pvarUserName_Remote);
    }
    if (pvarUserPassword_Remote)
    {
        VariantClear(pvarUserPassword_Remote);
    }
	if (!bRes)
	{
		SetBodyTextID(USE_DEFAULT_CAPTION);
	}
    if (pTheObject)
    {
        pTheObject->Release();
        pTheObject = NULL;
    }
    if (bPleaseDoCoUninit)
    {
        CoUninitialize();
    }
	return bRes;
}

// We don't have initial request for KeyRing certificate, therefore we will
// not be able to renew this certificate
//
BOOL
CCertificate::InstallExportPFXCert()
{
	ASSERT(!m_KeyFileName.IsEmpty());
	ASSERT(!m_KeyPassword.IsEmpty());
    ASSERT(!m_WebSiteInstanceName.IsEmpty());

	BOOL bRes = FALSE;
    BOOL bPleaseDoCoUninit = FALSE;

    IIISCertObj *pTheObject = NULL;

    BOOL bExportThePrivateKeyToo = m_ExportPFXPrivateKey;

    if (FALSE == m_CertObjInstalled)
    {
        goto InstallExportPFXCert_Exit;
    }

    // since this is the local machine
    // make sure all this stuff is not set.
    BSTR bstrServerName = SysAllocString(_T(""));
    BSTR bstrUserName = SysAllocString(_T(""));
    BSTR bstrUserPassword = SysAllocString(_T(""));

    // create bstrs for these member cstrings
    BSTR bstrFileName = SysAllocString(m_KeyFileName);
    BSTR bstrFilePassword = SysAllocString(m_KeyPassword);
    BSTR bstrInstanceName = SysAllocString(m_WebSiteInstanceName);

    m_hResult = CoInitialize(NULL);
    if(FAILED(m_hResult))
    {
        return bRes;
    }
    bPleaseDoCoUninit = TRUE;

    // this one seems to work with surrogates..
    m_hResult = CoCreateInstance(CLSID_IISCertObj,NULL,CLSCTX_SERVER,IID_IIISCertObj,(void **)&pTheObject);
    if (FAILED(m_hResult))
    {
        goto InstallExportPFXCert_Exit;
    }

    // at this point we were able to instantiate the com object on the server (local or remote)
    pTheObject->put_ServerName(bstrServerName);
    pTheObject->put_UserName(bstrUserName);
    pTheObject->put_UserPassword(bstrUserPassword);
    pTheObject->put_InstanceName(bstrInstanceName);
    m_hResult = pTheObject->Export(bstrFileName,bstrFilePassword,bExportThePrivateKeyToo,FALSE,FALSE);
    if (FAILED(m_hResult))
    {
        goto InstallExportPFXCert_Exit;
    }

    m_hResult = S_OK;
    bRes = TRUE;

InstallExportPFXCert_Exit:
	if (!bRes)
	{
		SetBodyTextID(USE_DEFAULT_CAPTION);
	}
    if (pTheObject)
    {
        pTheObject->Release();
        pTheObject = NULL;
    }
    if (bPleaseDoCoUninit)
    {
        CoUninitialize();
    }
	return bRes;
}

//
BOOL
CCertificate::InstallImportPFXCert()
{
	BOOL bRes = FALSE;

	CCryptBlobLocal hash_blob;
	if (::GetHashProperty(GetKeyRingCert(), hash_blob, &m_hResult))
	{
		HRESULT hr;
		CString name;
		::GetFriendlyName(GetKeyRingCert(), name, &hr);
		if (CRYPT_E_NOT_FOUND == hr || name.IsEmpty())
		{
			CERT_DESCRIPTION desc;
			if (GetCertDescription(GetKeyRingCert(), desc))
            {
				bRes = AttachFriendlyName(GetKeyRingCert(), desc.m_CommonName, &hr);
            }
		}
		ASSERT(bRes);
		bRes = InstallCertByHash(hash_blob, m_MachineName, m_WebSiteInstanceName, 
						GetEnrollObject(), &m_hResult);
	}
	if (!bRes)
	{
		SetBodyTextID(USE_DEFAULT_CAPTION);
	}
	return bRes;
}

// We don't have initial request for KeyRing certificate, therefore we will
// not be able to renew this certificate
//
BOOL
CCertificate::InstallKeyRingCert()
{
	BOOL bRes = FALSE;

	CCryptBlobLocal hash_blob;
	if (::GetHashProperty(GetKeyRingCert(), hash_blob, &m_hResult))
	{
		HRESULT hr;
		CString name;
		::GetFriendlyName(GetKeyRingCert(), name, &hr);
		if (CRYPT_E_NOT_FOUND == hr || name.IsEmpty())
		{
			CERT_DESCRIPTION desc;
			if (GetCertDescription(GetKeyRingCert(), desc))
            {
				bRes = AttachFriendlyName(GetKeyRingCert(), desc.m_CommonName, &hr);
            }
		}
		ASSERT(bRes);
		bRes = InstallCertByHash(hash_blob, m_MachineName, m_WebSiteInstanceName, 
						GetEnrollObject(), &m_hResult);
	}
	if (!bRes)
	{
		SetBodyTextID(USE_DEFAULT_CAPTION);
	}
	return bRes;
}

// Instead of renewal we create new certificate based on parameters
// from the current one. After creation we install this certificate in place
// of current one and deleting the old one from store. Even if IIS has an
// opened SSL connection it should get a notification and update the certificate
// data.
//
BOOL
CCertificate::SubmitRenewalRequest()
{
   BOOL bRes = LoadRenewalData();
   if (bRes)
   {
       bRes = SetSecuritySettings();
       if (bRes)
       {
          PCCERT_CONTEXT pCurrent = GetInstalledCert();
          m_pInstalledCert = NULL;
          if (bRes = SubmitRequest())
          {
             CertDeleteCertificateFromStore(pCurrent);
          }
       }
   }
   return bRes;
}

BOOL CCertificate::SubmitRequest()
{
	ASSERT(!m_ConfigCA.IsEmpty());
	BOOL bRes = FALSE;
	ICertRequest * pRequest = NULL;
	if (SUCCEEDED(m_hResult = CoCreateInstance(CLSID_CCertRequest, NULL, 
					CLSCTX_INPROC_SERVER, IID_ICertRequest, (void **)&pRequest)))
	{
		CString strDN;
		CreateDN(strDN);
		BSTR request = NULL;
		if (SUCCEEDED(m_hResult = CreateRequest_Base64(
                           (BSTR)(LPCTSTR)strDN, 
									GetEnrollObject(), 
                           m_DefaultCSP ? NULL : (LPTSTR)(LPCTSTR)m_CspName,
                           m_DefaultCSP ? m_DefaultProviderType : m_CustomProviderType,
                           &request)))
		{
			ASSERT(pRequest != NULL);
			CString attrib;
			GetCertificateTemplate(attrib);
			LONG disp;
			m_hResult = pRequest->Submit(CR_IN_BASE64 | CR_IN_PKCS10,
						request, 
						(BSTR)(LPCTSTR)attrib, 
						(LPTSTR)(LPCTSTR)m_ConfigCA, 
						&disp);
#ifdef _DEBUG
			if (FAILED(m_hResult))
				TRACE(_T("Submit request returned HRESULT %x; Disposition %x\n"), 
								m_hResult, disp);
#endif
			if (SUCCEEDED(m_hResult))
			{
				if (disp == CR_DISP_ISSUED)
				{
					BSTR bstrOutCert = NULL;
					if (SUCCEEDED(m_hResult = 
							pRequest->GetCertificate(CR_OUT_BASE64 /*| CR_OUT_CHAIN */, &bstrOutCert)))
					{
						CRYPT_DATA_BLOB blob;
						blob.cbData = SysStringByteLen(bstrOutCert);
						blob.pbData = (BYTE *)bstrOutCert;
						m_hResult = GetEnrollObject()->acceptPKCS7Blob(&blob);
						if (SUCCEEDED(m_hResult))
						{
							PCCERT_CONTEXT pContext = GetCertContextFromPKCS7(blob.pbData, blob.cbData, 
																			NULL, &m_hResult);
							ASSERT(pContext != NULL);
							if (pContext != NULL)
							{
								BYTE HashBuffer[40];                // give it some extra size
								DWORD dwHashSize = sizeof(HashBuffer);
								if (CertGetCertificateContextProperty(pContext,
																			CERT_SHA1_HASH_PROP_ID,
																			(VOID *) HashBuffer,
																			&dwHashSize))
								{
									CRYPT_HASH_BLOB hash_blob = {dwHashSize, HashBuffer};
									if (!(bRes = InstallHashToMetabase(&hash_blob, 
													m_MachineName, 
													m_WebSiteInstanceName, 
													&m_hResult)))
									{
										SetBodyTextID(IDS_CERT_INSTALLATION_FAILURE);
									}
								}
								CertFreeCertificateContext(pContext);
							}
							// now put extra properties to the installed cert
							if (NULL != (pContext = GetInstalledCert()))
							{
								if (!(bRes = AttachFriendlyName(pContext, m_FriendlyName, &m_hResult)))
								{
									SetBodyTextID(IDS_CERT_INSTALLATION_FAILURE);
								}
							}
						}
                        if (bstrOutCert){SysFreeString(bstrOutCert);}
					}
				}
				else
				{
					switch (disp) 
					{
						case CR_DISP_INCOMPLETE:           
						case CR_DISP_ERROR:                
						case CR_DISP_DENIED:               
						case CR_DISP_ISSUED_OUT_OF_BAND:   
						case CR_DISP_UNDER_SUBMISSION:
							{
								BSTR bstr = NULL;
								if (SUCCEEDED(pRequest->GetDispositionMessage(&bstr)))
								{
									SetBodyTextString(CString(bstr));
                                    if (bstr) {SysFreeString(bstr);}
								}
								m_hResult = !S_OK;
							}
							break;
						default:                           
							SetBodyTextID(IDS_INTERNAL_ERROR);
							break;
					} 
				}
			}
			else	// !SUCCEEDED
			{
				// clear out any error IDs and strings
				// we will use default processing of m_hResult
				SetBodyTextID(USE_DEFAULT_CAPTION);
			}
            if (request){SysFreeString(request);}
		}
		pRequest->Release();
	}
	return bRes;
}

BOOL 
CCertificate::PrepareRequestString(CString& request_text, CCryptBlob& request_blob)
{
	CString strDN;
	TCHAR szUsage[] = _T(szOID_PKIX_KP_SERVER_AUTH);

   if (m_status_code == REQUEST_RENEW_CERT)
   {
      if (FALSE == LoadRenewalData())
      {
          return FALSE;
      }
      if (FALSE == SetSecuritySettings())
      {
          return FALSE;
      }
   }
	CreateDN(strDN);
	ASSERT(!strDN.IsEmpty());
   GetEnrollObject()->put_ProviderType(m_DefaultCSP ? 
      m_DefaultProviderType : m_CustomProviderType);
   if (!m_DefaultCSP)
   {
      GetEnrollObject()->put_ProviderNameWStr((LPTSTR)(LPCTSTR)m_CspName);
      // We are supporting only these two types of CSP, it is pretty safe to
      // have just two options, because we are using the same two types when
      // we are populating CSP selection list.
      if (m_CustomProviderType == PROV_DH_SCHANNEL)
         GetEnrollObject()->put_KeySpec(AT_SIGNATURE);
      else if (m_CustomProviderType == PROV_RSA_SCHANNEL)
         GetEnrollObject()->put_KeySpec(AT_KEYEXCHANGE);
   }
	if (FAILED(m_hResult = GetEnrollObject()->createPKCS10WStr((LPTSTR)(LPCTSTR)strDN, 
							szUsage, request_blob))
      )
	{
		SetBodyTextID(USE_DEFAULT_CAPTION);
		return FALSE;
	}

	// BASE64 encode pkcs 10
	DWORD err, cch; 
	char * psz;
	if (	ERROR_SUCCESS != (err = Base64EncodeA(request_blob.GetData(), request_blob.GetSize(), NULL, &cch))
		||	NULL == (psz = (char *)_alloca(cch+1))
		||	ERROR_SUCCESS != (err = Base64EncodeA(request_blob.GetData(), request_blob.GetSize(), psz, &cch))
		) 
	{
		return FALSE;
	}
	psz[cch] = '\0';
	request_text = MESSAGE_HEADER;
	request_text += psz;
	request_text += MESSAGE_TRAILER;

	return TRUE;
}

BOOL
CCertificate::PrepareRequest()
{
	BOOL bRes = FALSE;
	CString request_text;
	CCryptBlobIMalloc request_blob;
	if (PrepareRequestString(request_text, request_blob))
	{
		if (WriteRequestString(request_text))
		{
			CCryptBlobLocal name_blob, request_store_blob, status_blob;
			// prepare data we want to attach to dummy request
			if (	EncodeString(m_WebSiteInstanceName, name_blob, &m_hResult)
				&& EncodeInteger(m_status_code, status_blob, &m_hResult)
				)
			{
				// get back request from encoded data
            PCERT_REQUEST_INFO pReqInfo;
            bRes = GetRequestInfoFromPKCS10(request_blob, &pReqInfo, &m_hResult);
            if (bRes)
				{
					// find dummy cert put to request store by createPKCS10 call
					HCERTSTORE hStore = OpenRequestStore(GetEnrollObject(), &m_hResult);
					if (hStore != NULL)
					{
						PCCERT_CONTEXT pDummyCert = CertFindCertificateInStore(hStore,
															CRYPT_ASN_ENCODING,
															0,
															CERT_FIND_PUBLIC_KEY,
                                             (void *)&pReqInfo->SubjectPublicKeyInfo,
															NULL);
						if (pDummyCert != NULL)
						{
							if (	CertSetCertificateContextProperty(pDummyCert, 
											CERTWIZ_INSTANCE_NAME_PROP_ID, 0, name_blob)
								&&	CertSetCertificateContextProperty(pDummyCert, 
											CERTWIZ_REQUEST_FLAG_PROP_ID, 0, status_blob)
								// put friendly name to dummy cert -- we will reuse it later
								&&	AttachFriendlyName(pDummyCert, m_FriendlyName, &m_hResult)
								)
							{
								bRes = TRUE;
			               // put certificate text to the clipboard
			               if (OpenClipboard(GetFocus()))
			               {
                           size_t len = request_text.GetLength() + 1;
				               HANDLE hMem = GlobalAlloc(GMEM_MOVEABLE | GMEM_DDESHARE, len);
				               LPSTR pMem = (LPSTR)GlobalLock(hMem);
                           if (pMem != NULL)
                           {
                              wcstombs(pMem, request_text, len);
				                  GlobalUnlock(hMem);
				                  SetClipboardData(CF_TEXT, hMem);
                           }
				               CloseClipboard();
			               }
							}
							else
							{
								m_hResult = HRESULT_FROM_WIN32(GetLastError());
							}
							CertFreeCertificateContext(pDummyCert);
						}
						CertCloseStore(hStore, CERT_CLOSE_STORE_CHECK_FLAG);
					}
               LocalFree(pReqInfo);
				}
			}
		}
	}
   if (!bRes)
		SetBodyTextID(USE_DEFAULT_CAPTION);

	return bRes;
}

BOOL CCertificate::LoadRenewalData()
{
    // we need to obtain data from the installed cert
    CERT_DESCRIPTION desc;
    ASSERT(GetInstalledCert() != NULL);
    BOOL res = FALSE;
	DWORD cbData;
	BYTE * pByte = NULL;
    DWORD len = 0;

    if (!GetCertDescription(GetInstalledCert(), desc))
    {
        res = FALSE;
        goto ErrorExit;
    }

	m_CommonName = desc.m_CommonName;
	m_FriendlyName = desc.m_FriendlyName;
	m_Country = desc.m_Country;
	m_State = desc.m_State;
	m_Locality = desc.m_Locality;
	m_Organization = desc.m_Organization;
	m_OrganizationUnit = desc.m_OrganizationUnit;

    len = CertGetPublicKeyLength(X509_ASN_ENCODING | PKCS_7_ASN_ENCODING, &GetInstalledCert()->pCertInfo->SubjectPublicKeyInfo);
    if (len == 0)
    {
        m_hResult = HRESULT_FROM_WIN32(GetLastError());
        goto ErrorExit;
    }
    m_KeyLength = len;

	// compare property value
	if (CertGetCertificateContextProperty(GetInstalledCert(), CERT_KEY_PROV_INFO_PROP_ID, NULL, &cbData)
		&& (NULL != (pByte = (BYTE *)_alloca(cbData)))
		&& CertGetCertificateContextProperty(GetInstalledCert(), CERT_KEY_PROV_INFO_PROP_ID, pByte, &cbData)
        )
    {
        CRYPT_KEY_PROV_INFO * pProvInfo = (CRYPT_KEY_PROV_INFO *)pByte;

        if (pProvInfo->dwProvType != m_DefaultProviderType)
        {
            m_DefaultCSP = FALSE;
            m_CustomProviderType = pProvInfo->dwProvType;
            m_CspName = pProvInfo->pwszProvName;
        }

        CArray<LPCSTR, LPCSTR> uses;
        uses.Add(szOID_SERVER_GATED_CRYPTO);
        uses.Add(szOID_SGC_NETSCAPE);
        m_SGCcertificat = ContainsKeyUsageProperty(GetInstalledCert(), uses, &m_hResult);

        res = TRUE;
    }
    else
    {
         m_hResult = HRESULT_FROM_WIN32(GetLastError());
         goto ErrorExit;
    }

ErrorExit:
    return res;
}

#if 0
BOOL
CCertificate::WriteRenewalRequest()
{
	BOOL bRes = FALSE;
	if (GetInstalledCert() != NULL)
	{
		BSTR bstrRequest;
		if (	SUCCEEDED(m_hResult = GetEnrollObject()->put_RenewalCertificate(GetInstalledCert()))
			&& SUCCEEDED(m_hResult = CreateRequest_Base64(bstrEmpty, 
                     GetEnrollObject(), 
                     m_DefaultCSP ? NULL : (LPTSTR)(LPCTSTR)m_CspName,
                     m_DefaultCSP ? m_DefaultProviderType : m_CustomProviderType,
                     &bstrRequest))
			)
		{
			CString str = MESSAGE_HEADER;
			str += bstrRequest;
			str += MESSAGE_TRAILER;
			if (WriteRequestString(str))
			{
				CCryptBlobLocal name_blob, status_blob;
				CCryptBlobIMalloc request_blob;
				request_blob.Set(SysStringLen(bstrRequest), (BYTE *)bstrRequest);
				// prepare data we want to attach to dummy request
				if (	EncodeString(m_WebSiteInstanceName, name_blob, &m_hResult)
					&& EncodeInteger(m_status_code, status_blob, &m_hResult)
					)
				{
					// get back request from encoded data
					PCERT_REQUEST_INFO req_info;
					if (GetRequestInfoFromPKCS10(request_blob, &req_info, &m_hResult))
					{
						// find dummy cert put to request store by createPKCS10 call
						HCERTSTORE hStore = OpenRequestStore(GetEnrollObject(), &m_hResult);
						if (hStore != NULL)
						{
							PCCERT_CONTEXT pDummyCert = CertFindCertificateInStore(hStore,
																	CRYPT_ASN_ENCODING,
																	0,
																	CERT_FIND_PUBLIC_KEY,
																	(void *)&req_info->SubjectPublicKeyInfo,
																	NULL);
							if (pDummyCert != NULL)
							{
								if (	CertSetCertificateContextProperty(pDummyCert, 
													CERTWIZ_INSTANCE_NAME_PROP_ID, 0, name_blob)
									&&	CertSetCertificateContextProperty(pDummyCert, 
													CERTWIZ_REQUEST_FLAG_PROP_ID, 0, status_blob)
  									// put friendly name to dummy cert -- we will reuse it later
									&&	AttachFriendlyName(pDummyCert, m_FriendlyName, &m_hResult)
									)
								{
									bRes = TRUE;
								}
								else
								{
									m_hResult = HRESULT_FROM_WIN32(GetLastError());
								}
								CertFreeCertificateContext(pDummyCert);
							}
							CertCloseStore(hStore, CERT_CLOSE_STORE_CHECK_FLAG);
						}
						LocalFree(req_info);
					}
				}
			}
		}
	}
	return bRes;
}
#endif

CCertDescList::~CCertDescList()
{
	POSITION pos = GetHeadPosition();
	while (pos != NULL)
	{
		CERT_DESCRIPTION * pDesc = GetNext(pos);
		delete pDesc;
	}
}

BOOL
CCertificate::GetCertDescription(PCCERT_CONTEXT pCert,
											CERT_DESCRIPTION& desc)
{
	BOOL bRes = FALSE;
	DWORD cb;
	UINT i, j;
	CERT_NAME_INFO * pNameInfo;

	if (pCert == NULL)
		goto ErrExit;

	if (	!CryptDecodeObject(X509_ASN_ENCODING, X509_UNICODE_NAME,
					pCert->pCertInfo->Subject.pbData,
					pCert->pCertInfo->Subject.cbData,
					0, NULL, &cb)
		||	NULL == (pNameInfo = (CERT_NAME_INFO *)_alloca(cb))
		|| !CryptDecodeObject(X509_ASN_ENCODING, X509_UNICODE_NAME,
					pCert->pCertInfo->Subject.pbData,
					pCert->pCertInfo->Subject.cbData,
					0, 
					pNameInfo, &cb)
					)
	{
		goto ErrExit;
	}

	for (i = 0; i < pNameInfo->cRDN; i++)
	{
		CERT_RDN rdn = pNameInfo->rgRDN[i];
		for (j = 0; j < rdn.cRDNAttr; j++)
		{
			CERT_RDN_ATTR attr = rdn.rgRDNAttr[j];
			if (strcmp(attr.pszObjId, szOID_COMMON_NAME) == 0)
			{
				FormatRdnAttr(desc.m_CommonName, attr.dwValueType, attr.Value, FALSE);
			}
			else if (strcmp(attr.pszObjId, szOID_COUNTRY_NAME) == 0)
			{
				FormatRdnAttr(desc.m_Country, attr.dwValueType, attr.Value, TRUE);
			}
			else if (strcmp(attr.pszObjId, szOID_LOCALITY_NAME) == 0)
			{
				FormatRdnAttr(desc.m_Locality, attr.dwValueType, attr.Value, TRUE);
			}
			else if (strcmp(attr.pszObjId, szOID_STATE_OR_PROVINCE_NAME) == 0)
			{
				FormatRdnAttr(desc.m_State, attr.dwValueType, attr.Value, TRUE);
			}
			else if (strcmp(attr.pszObjId, szOID_ORGANIZATION_NAME) == 0)
			{
				FormatRdnAttr(desc.m_Organization, attr.dwValueType, attr.Value, TRUE);
			}
			else if (strcmp(attr.pszObjId, szOID_ORGANIZATIONAL_UNIT_NAME) == 0)
			{
				FormatRdnAttr(desc.m_OrganizationUnit, attr.dwValueType, attr.Value, TRUE);
			}
		}
	}
	// issued to
	if (!GetNameString(pCert, CERT_NAME_SIMPLE_DISPLAY_TYPE, CERT_NAME_ISSUER_FLAG, 
								desc.m_CAName, &m_hResult))
		goto ErrExit;

	// expiration date
	if (!FormatDateString(desc.m_ExpirationDate, pCert->pCertInfo->NotAfter, FALSE, FALSE))
	{
		goto ErrExit;
	}

	// purpose
	if (!FormatEnhancedKeyUsageString(desc.m_Usage, pCert, FALSE, FALSE, &m_hResult))
	{
		// According to local experts, we should also use certs without this property set
		ASSERT(FALSE);
		//goto ErrExit;
	}

	// friendly name
	if (!GetFriendlyName(pCert, desc.m_FriendlyName, &m_hResult))
	{
		desc.m_FriendlyName.LoadString(IDS_FRIENDLYNAME_NONE);
	}

	bRes = TRUE;

ErrExit:
	return bRes;
}

int
CCertificate::MyStoreCertCount()
{
	int count = 0;
	HCERTSTORE hStore = OpenMyStore(GetEnrollObject(), &m_hResult);
	if (hStore != NULL)
	{
		PCCERT_CONTEXT pCert = NULL;
		CArray<LPCSTR, LPCSTR> uses;
		uses.Add(szOID_PKIX_KP_SERVER_AUTH);
		uses.Add(szOID_SERVER_GATED_CRYPTO);
		uses.Add(szOID_SGC_NETSCAPE);
		while (NULL != (pCert = CertEnumCertificatesInStore(hStore, pCert)))
		{
			// do not include installed cert to the list
			if (	GetInstalledCert() != NULL 
				&&	CertCompareCertificate(X509_ASN_ENCODING,
							GetInstalledCert()->pCertInfo, pCert->pCertInfo)
				)
            {
				continue;
            }

            //If no EKU, look at basic constraints:
            //If we do not have basic constraints, do display it in the list to pick web server certs from
            //If we do have basic constraints with Subject Type =CA, don't display it in the list to pick web server certs from (this will filter out CA certs)
            //If we do have basic constraints with SubectType !=CA, do display it in the list to pick web server certs from 
			if (!ContainsKeyUsageProperty(pCert, uses, &m_hResult))
			{
                // check other stuff
                if (DID_NOT_FIND_CONSTRAINT == CheckCertConstraints(pCert))
                {
                    // add it up.
                }
                else if (FOUND_CONSTRAINT_BUT_THIS_IS_A_CA_OR_ITS_NOT_AN_END_ENTITY == CheckCertConstraints(pCert))
                {
				    continue;
                }
                else
                {
                    continue;
                }
			}
			count++;
		}
		if (pCert != NULL)
			CertFreeCertificateContext(pCert);
		VERIFY(CertCloseStore(hStore, 0));
	}
	return count;
}

BOOL
CCertificate::GetCertDescList(CCertDescList& list)
{
	ASSERT(list.GetCount() == 0);
	BOOL bRes = FALSE;
	// we are looking to MY store only
	HCERTSTORE hStore = OpenMyStore(GetEnrollObject(), &m_hResult);
	if (hStore != NULL)
	{
		PCCERT_CONTEXT pCert = NULL;
		// do not include certs with improper usage
		CArray<LPCSTR, LPCSTR> uses;
		uses.Add(szOID_PKIX_KP_SERVER_AUTH);
		uses.Add(szOID_SERVER_GATED_CRYPTO);
		uses.Add(szOID_SGC_NETSCAPE);
		while (NULL != (pCert = CertEnumCertificatesInStore(hStore, pCert)))
		{
			// do not include installed cert to the list
			if (	GetInstalledCert() != NULL 
				&&	CertCompareCertificate(X509_ASN_ENCODING,
							GetInstalledCert()->pCertInfo, pCert->pCertInfo)
                            )
            {
                continue;
            }

            //If no EKU, look at basic constraints:
            //If we do not have basic constraints, do display it in the list to pick web server certs from
            //If we do have basic constraints with Subject Type =CA, don't display it in the list to pick web server certs from (this will filter out CA certs)
            //If we do have basic constraints with SubectType !=CA, do display it in the list to pick web server certs from 
			if (!ContainsKeyUsageProperty(pCert, uses, &m_hResult))
			{
                // check other stuff
                if (DID_NOT_FIND_CONSTRAINT == CheckCertConstraints(pCert) || FOUND_CONSTRAINT == CheckCertConstraints(pCert))
                {
                    // it's okay, add it to the list
                }
                else 
                {
				    if (SUCCEEDED(m_hResult) || m_hResult == CRYPT_E_NOT_FOUND)
					    continue;
				    else
					    goto ErrExit;
                }
			}
			CERT_DESCRIPTION * pDesc = new CERT_DESCRIPTION;
			pDesc->m_hash_length = CERT_HASH_LENGTH;
			if (!GetCertDescription(pCert, *pDesc))
			{
				delete pDesc;
				if (m_hResult == CRYPT_E_NOT_FOUND)
					continue;
				goto ErrExit;
			}
			if (!CertGetCertificateContextProperty(pCert, 
										CERT_SHA1_HASH_PROP_ID, 
										(VOID *)pDesc->m_hash, 
										&pDesc->m_hash_length))
			{
				delete pDesc;
				m_hResult = HRESULT_FROM_WIN32(GetLastError());
				goto ErrExit;
			}
			list.AddTail(pDesc);
		}
		bRes = TRUE;
ErrExit:
		if (pCert != NULL)
			CertFreeCertificateContext(pCert);
		VERIFY(CertCloseStore(hStore, 0));
	}
	return bRes;
}

BOOL 
CCertificate::ReplaceInstalled()
{
	// Current cert will be left in the store for next use
	// Selected cert will be installed instead
	return InstallSelectedCert();
}

BOOL 
CCertificate::CancelRequest()
{
	// we are just removing dummy cert from the REQUEST store
	if (NULL != GetPendingRequest())
	{
		BOOL bRes = CertDeleteCertificateFromStore(GetPendingRequest());
		if (!bRes)
		{
			m_hResult = HRESULT_FROM_WIN32(GetLastError());
			SetBodyTextID(USE_DEFAULT_CAPTION);
		}
		else
			m_pPendingRequest = NULL;
		return bRes;
	}
	return FALSE;
}

BOOL 
CCertificate::InstallSelectedCert()
{
	BOOL bRes = FALSE;
	HRESULT hr;
	// local authorities required that cert should have some
	// friendly name. We will put common name when friendly name is not available
	HCERTSTORE hStore = OpenMyStore(GetEnrollObject(), &hr);
	if (hStore != NULL)
	{
		PCCERT_CONTEXT pCert = CertFindCertificateInStore(hStore, 
												X509_ASN_ENCODING | PKCS_7_ASN_ENCODING, 
												0, CERT_FIND_HASH, 
												(LPVOID)m_pSelectedCertHash, 
												NULL);
		if (pCert != NULL)
		{
			CString name;
			::GetFriendlyName(pCert, name, &hr);
			if (CRYPT_E_NOT_FOUND == hr || name.IsEmpty())
			{
				CERT_DESCRIPTION desc;
				if (GetCertDescription(pCert, desc))
                {
					bRes = AttachFriendlyName(pCert, desc.m_CommonName, &hr);
                }
			}
		}
		VERIFY(CertCloseStore(hStore, 0));
	}
	ASSERT(bRes);
	// we are just rewriting current settings
	// current cert will be left in MY store
	bRes = ::InstallCertByHash(m_pSelectedCertHash,
							m_MachineName, 
							m_WebSiteInstanceName, 
							GetEnrollObject(),
							&m_hResult);
	if (!bRes)
	{
		SetBodyTextID(USE_DEFAULT_CAPTION);
	}
	return bRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\certwiz\certutil.h ===
//
// CertUtil.h
//
#ifndef _CERTUTIL_H
#define _CERTUTIL_H

#include <wincrypt.h>
#include <CertCli.h>
#include <xenroll.h>
#include "Certificat.h"

BOOL GetOnlineCAList(CStringList& list, const CString& certType, HRESULT * phRes);
BOOL GetRequestInfoFromPKCS10(CCryptBlob& pkcs10, 
										PCERT_REQUEST_INFO * pReqInfo,
										HRESULT * phRes);
PCCERT_CONTEXT GetPendingDummyCert(const CString& inst_name, 
											  IEnroll * pEnroll,
											  HRESULT * phRes);
HCERTSTORE OpenRequestStore(IEnroll * pEnroll, HRESULT * phResult);
HCERTSTORE OpenMyStore(IEnroll * pEnroll, HRESULT * phResult);
PCCERT_CONTEXT GetCertContextFromPKCS7File(const CString& resp_file_name, 
														CERT_PUBLIC_KEY_INFO * pKeyInfo,
														HRESULT * phResult);
PCCERT_CONTEXT GetCertContextFromPKCS7(const BYTE * pbData, DWORD cbData,
													CERT_PUBLIC_KEY_INFO * pKeyInfo,
													HRESULT * phResult);
PCCERT_CONTEXT GetRequestContext(CCryptBlob& pkcs10, HRESULT * phRes);
BOOL GetRequestInfoFromPKCS10(CCryptBlob& pkcs10, 
										PCERT_REQUEST_INFO * pReqInfo,
										HRESULT * phRes);
//BOOL GetRequestInfoFromRenewalRequest(CCryptBlob& renewal_req,
//                              PCCERT_CONTEXT * pSignerCert,
//                              HCERTSTORE hStore,
//										PCERT_REQUEST_INFO * pReqInfo,
//										HRESULT * phRes);
PCCERT_CONTEXT GetReqCertByKey(IEnroll * pEnroll, 
										 CERT_PUBLIC_KEY_INFO * pKeyInfo, 
										 HRESULT * phResult);

BOOL FormatDateString(CString& str, 
							 FILETIME ft, 
							 BOOL fIncludeTime, 
							 BOOL fLongFormat);
BOOL
GetKeyUsageProperty(PCCERT_CONTEXT pCertContext, 
						  CERT_ENHKEY_USAGE ** pKeyUsage, 
						  BOOL fPropertiesOnly, 
						  HRESULT * phRes);
BOOL
ContainsKeyUsageProperty(PCCERT_CONTEXT pCertContext, 
						 CArray<LPCSTR, LPCSTR>& uses, 
						 HRESULT * phRes);
BOOL FormatEnhancedKeyUsageString(CString& str, 
											 PCCERT_CONTEXT pCertContext, 
											 BOOL fPropertiesOnly, 
											 BOOL fMultiline,
											 HRESULT * phRes);
PCCERT_CONTEXT
GetInstalledCert(const CString& machine_name, 
					  const CString& server_name,
					  IEnroll * pEnroll,
					  HRESULT * phResult);
BOOL 
InstallCertByHash(CRYPT_HASH_BLOB * pHash,
					  const CString& machine_name, 
					  const CString& server_name,
					  IEnroll * pEnroll,
					  HRESULT * phResult);
BOOL
InstallHashToMetabase(CRYPT_HASH_BLOB * pHash,
					  const CString& machine_name, 
					  const CString& server_name,
					  HRESULT * phResult);
HRESULT CreateRequest_Base64(const BSTR bstr_dn, 
                             IEnroll * pEnroll,
                             BSTR csp_name,
                             DWORD csp_type,
                             BSTR * pOut);
BOOL AttachFriendlyName(PCCERT_CONTEXT pContext, const CString& name, HRESULT * phRes);
BOOL GetFriendlyName(PCCERT_CONTEXT pCertContext,
					 CString& name,
					 HRESULT * phRes);
BOOL GetNameString(PCCERT_CONTEXT pCertContext,
				  DWORD type,
				  DWORD flag,
				  CString& name,
				  HRESULT * phRes);
BOOL GetHashProperty(PCCERT_CONTEXT pCertContext, CCryptBlob& hash_blob, HRESULT * phRes);
BOOL GetStringProperty(PCCERT_CONTEXT pCertContext, DWORD propId, CString& str, HRESULT * phRes);
BOOL GetBlobProperty(PCCERT_CONTEXT pCertContext,
					 DWORD propId,
					 CCryptBlob& blob,
					 HRESULT * phRes);

BOOL EncodeString(CString& str, CCryptBlob& blob, HRESULT * phRes);
BOOL EncodeInteger(int number, CCryptBlob& blob, HRESULT * phRes);
BOOL EncodeBlob(CCryptBlob& in, CCryptBlob& out, HRESULT * phRes);
BOOL DecodeBlob(CCryptBlob& in, CCryptBlob& out, HRESULT * phRes);
BOOL GetServerComment(const CString& machine_name, const CString& server_name,
					  CString& comment, HRESULT * phResult);
void FormatRdnAttr(CString& str, DWORD dwValueType, CRYPT_DATA_BLOB& blob, BOOL fAppend);

BOOL CreateDirectoryFromPath(LPCTSTR szPath, LPSECURITY_ATTRIBUTES lpSA);

BOOL CompactPathToWidth(CWnd * pControl, CString& strPath);

BOOL GetKeySizeLimits(IEnroll * pEnroll, 
					  DWORD * min, DWORD * max, DWORD * def, 
					  BOOL bGSC,
					  HRESULT * phRes);
HRESULT ShutdownSSL(CString& machine_name, CString& server_name);
HRESULT HereIsVtArrayGimmieBinary(VARIANT * lpVarSrcObject,DWORD * cbBinaryBufferSize,char **pbBinaryBuffer,BOOL bReturnBinaryAsVT_VARIANT);
CERT_CONTEXT * GetInstalledCertFromHash(HRESULT * phResult,DWORD cbHashBlob, char * pHashBlob);
BOOL ViewCertificateDialog(CRYPT_HASH_BLOB* pcrypt_hash, HWND hWnd);
HRESULT IsCertUsedBySSLBelowMe(CString& machine_name, CString& server_name, CStringList& listFillMe);

CRYPT_HASH_BLOB * GetInstalledCertHash(const CString& machine_name,const CString& server_name,IEnroll * pEnroll,HRESULT * phResult);
HRESULT EnumSitesWithCertInstalled(CString& machine_name,CString& user_name,CString& user_password,CStringListEx * MyStringList);
BOOL GetServerComment(const CString& machine_name,const CString& user_name,const CString& user_password,CString& MetabaseNode,CString& comment,HRESULT * phResult);
HRESULT EnumSites(CString& machine_name,CString& user_name,CString& user_password,CStringListEx * MyStringList);

#define FAILURE                                                     0
#define DID_NOT_FIND_CONSTRAINT                                     1
#define FOUND_CONSTRAINT_BUT_THIS_IS_A_CA_OR_ITS_NOT_AN_END_ENTITY  2
#define FOUND_CONSTRAINT                                            3
int CheckCertConstraints(PCCERT_CONTEXT pCC);
BOOL IsCertExportable(PCCERT_CONTEXT pCertContext);
BOOL IsCertExportableOnRemoteMachine(CString ServerName,CString UserName,CString UserPassword,CString InstanceName);
BOOL DumpCertDesc(char * pBlobInfo);
BOOL GetCertDescInfo(CString ServerName,CString UserName,CString UserPassword,CString InstanceName);
BOOL IsWhistlerWorkstation(void);

#endif	//_CERTUTIL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\certwiz\choosecatype.cpp ===
// ChooseCAType.cpp : implementation file
//

#include "stdafx.h"
#include "CertWiz.h"
#include "ChooseCAType.h"
#include "CertUtil.H"
#include "Certificat.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CChooseCAType property page

IMPLEMENT_DYNCREATE(CChooseCAType, CIISWizardPage)

CChooseCAType::CChooseCAType(CCertificate * pCert) 
	: CIISWizardPage(CChooseCAType::IDD, IDS_CERTWIZ, TRUE),
	m_pCert(pCert)

{
	//{{AFX_DATA_INIT(CChooseCAType)
	m_Index = -1;
	//}}AFX_DATA_INIT
}

CChooseCAType::~CChooseCAType()
{
}

void CChooseCAType::DoDataExchange(CDataExchange* pDX)
{
	CIISWizardPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CChooseCAType)
	DDX_Radio(pDX, IDC_OFFLINE_RADIO, m_Index);
	//}}AFX_DATA_MAP
}

LRESULT 
CChooseCAType::OnWizardBack()
/*++
Routine Description:
    Prev button handler

Arguments:
    None

Return Value:
	0 to automatically advance to the prev page;
	1 to prevent the page from changing. 
	To jump to a page other than the prev one, 
	return the identifier of the dialog to be displayed.
--*/
{
	if (m_pCert->GetStatusCode() == CCertificate::REQUEST_RENEW_CERT)
		return IDD_PAGE_PREV_RENEW;
	else if (m_pCert->GetStatusCode() == CCertificate::REQUEST_NEW_CERT)
		return IDD_PAGE_PREV_NEW;
	ASSERT(FALSE);
	return 1;
}

LRESULT 
CChooseCAType::OnWizardNext()
/*++
Routine Description:
    Next button handler

Arguments:
    None

Return Value:
	0 to automatically advance to the next page;
	1 to prevent the page from changing. 
	To jump to a page other than the next one, 
	return the identifier of the dialog to be displayed.
--*/
{
	LRESULT id = 1;
	UpdateData();
	m_pCert->m_CAType = m_Index == 0 ? 
		CCertificate::CA_OFFLINE : CCertificate::CA_ONLINE;
	if (m_pCert->GetStatusCode() == CCertificate::REQUEST_RENEW_CERT)
	{
		if (m_pCert->m_CAType == CCertificate::CA_OFFLINE)
			id = IDD_PAGE_NEXT_RENEW_OFFLINE;
		else if (m_pCert->m_CAType == CCertificate::CA_ONLINE)
			id = IDD_PAGE_NEXT_RENEW_ONLINE;
	}
	else if (m_pCert->GetStatusCode() == CCertificate::REQUEST_NEW_CERT)
		id = IDD_PAGE_NEXT_NEW;
	return id;
}

BEGIN_MESSAGE_MAP(CChooseCAType, CIISWizardPage)
	//{{AFX_MSG_MAP(CChooseCAType)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CChooseCAType message handlers

//#define _NO_DISABLE

BOOL CChooseCAType::OnInitDialog() 
{
	CIISWizardPage::OnInitDialog();
	ASSERT(m_pCert != NULL);
	m_Index = m_pCert->m_CAType == CCertificate::CA_OFFLINE ? 0 : 1;
	CString temp;
	m_pCert->GetCertificateTemplate(temp);
#ifdef _NO_DISABLE
	VERIFY(GetOnlineCAList(m_pCert->m_OnlineCAList, L"WebServer", &m_pCert->m_hResult));
#else
	if (!GetOnlineCAList(m_pCert->m_OnlineCAList, L"WebServer", &m_pCert->m_hResult))
	{
		// none online CA present: disable online CA button
		GetDlgItem(IDC_ONLINE_RADIO)->EnableWindow(FALSE);
		m_Index = 0;
	}
#endif
	UpdateData(FALSE);
	return FALSE;
}

BOOL CChooseCAType::OnSetActive() 
{
	SetWizardButtons(PSWIZB_BACK | PSWIZB_NEXT);
	return CIISWizardPage::OnSetActive();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\certwiz\certwiz.h ===
#if !defined(AFX_CERTWIZ_H__D4BE8638_0C85_11D2_91B1_00C04F8C8761__INCLUDED_)
#define AFX_CERTWIZ_H__D4BE8638_0C85_11D2_91B1_00C04F8C8761__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

// CertWiz.h : main header file for CERTWIZ.DLL

#if !defined( __AFXCTL_H__ )
	#error include 'afxctl.h' before including this file
#endif

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CCertWizApp : See CertWiz.cpp for implementation.

class CCertWizApp : public COleControlModule
{
public:
	BOOL InitInstance();
	int ExitInstance();
	HKEY RegOpenKeyWizard();
	void GetRegistryPath(CString& str);
};

// Implemented in orginfopage.cpp
void DDV_MaxCharsCombo(CDataExchange* pDX, UINT ControlID, CString const& value, int nChars);

extern const GUID CDECL _tlid;
extern const WORD _wVerMajor;
extern const WORD _wVerMinor;

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_CERTWIZ_H__D4BE8638_0C85_11D2_91B1_00C04F8C8761__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\certwiz\certwiz.cpp ===
// CertWiz.cpp : Implementation of CCertWizApp and DLL registration.

#include "stdafx.h"
#include "CertWiz.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


CCertWizApp NEAR theApp;

const GUID CDECL BASED_CODE _tlid =
		{ 0xd4be862f, 0xc85, 0x11d2, { 0x91, 0xb1, 0, 0xc0, 0x4f, 0x8c, 0x87, 0x61 } };
const WORD _wVerMajor = 1;
const WORD _wVerMinor = 0;

const TCHAR szRegistryKey[] = _T("SOFTWARE\\Microsoft\\InetMgr");
const TCHAR szWizardKey[] = _T("CertWiz");

///////////////////////////////////////////////////////////////////////////
// CCertWizApp::InitInstance - DLL initialization

BOOL CCertWizApp::InitInstance()
{
	BOOL bInit = COleControlModule::InitInstance();
	if (bInit)
	{
		AfxEnableControlContainer();
		InitCommonDll();

        CString sz;
        // set the name of the application correctly
        sz.LoadString(IDS_CERTWIZ);
        // free the existing name, and copy in the new one
        free((void*)m_pszAppName);
        m_pszAppName = _tcsdup(sz);
	}
	return bInit;
}

////////////////////////////////////////////////////////////////////////////
// CCertWizApp::ExitInstance - DLL termination

int CCertWizApp::ExitInstance()
{
	// TODO: Add your own module termination code here.

	return COleControlModule::ExitInstance();
}

HKEY
CCertWizApp::RegOpenKeyWizard()
{
	HKEY hKey = NULL;
	
	CString strKey;
	GetRegistryPath(strKey);
    
	VERIFY(ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, strKey, 0, KEY_ALL_ACCESS, &hKey));
	return hKey;
}

void
CCertWizApp::GetRegistryPath(CString& str)
{
	str = szRegistryKey;
	str += _T("\\");
	str += szWizardKey;
}


/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if (!AfxOleRegisterTypeLib(AfxGetInstanceHandle(), _tlid))
		return ResultFromScode(SELFREG_E_TYPELIB);
	if (!COleObjectFactoryEx::UpdateRegistryAll(TRUE))
		return ResultFromScode(SELFREG_E_CLASS);
	
	HKEY hKey;
	int rc = NOERROR;
	if (ERROR_SUCCESS == (rc = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
							szRegistryKey, 0, KEY_CREATE_SUB_KEY, &hKey)))
	{
		HKEY hWizardKey;
		if (ERROR_SUCCESS == (rc = RegCreateKey(hKey, szWizardKey, &hWizardKey)))
		{
			RegCloseKey(hWizardKey);
		}
		RegCloseKey(hKey);
	}

	return rc;
}


/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if (!AfxOleUnregisterTypeLib(_tlid, _wVerMajor, _wVerMinor))
		return ResultFromScode(SELFREG_E_TYPELIB);
	if (!COleObjectFactoryEx::UpdateRegistryAll(FALSE))
		return ResultFromScode(SELFREG_E_CLASS);
	// remove CertWiz data from the Registry
	HKEY hKey;
	if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, 
								szRegistryKey, 0, KEY_ALL_ACCESS, &hKey))
	{
		RegDeleteKey(hKey, szWizardKey);
		RegCloseKey(hKey);
	}

	return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\certwiz\certwizctl.h ===
#if !defined(AFX_CERTWIZCTL_H__D4BE863F_0C85_11D2_91B1_00C04F8C8761__INCLUDED_)
#define AFX_CERTWIZCTL_H__D4BE863F_0C85_11D2_91B1_00C04F8C8761__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

// CertWizCtl.h : Declaration of the CCertWizCtrl ActiveX Control class.

/////////////////////////////////////////////////////////////////////////////
// CCertWizCtrl : See CertWizCtl.cpp for implementation.

class CCertWizCtrl : public COleControl
{
	DECLARE_DYNCREATE(CCertWizCtrl)

// Constructor
public:
	CCertWizCtrl();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CCertWizCtrl)
	public:
	virtual void OnDraw(CDC* pdc, const CRect& rcBounds, const CRect& rcInvalid);
	virtual void DoPropExchange(CPropExchange* pPX);
	virtual void OnResetState();
	virtual DWORD GetControlFlags();
	virtual void OnClick(USHORT iButton);
	//}}AFX_VIRTUAL

// Implementation
protected:
	~CCertWizCtrl();

	DECLARE_OLECREATE_EX(CCertWizCtrl)    // Class factory and guid
	DECLARE_OLETYPELIB(CCertWizCtrl)      // GetTypeInfo
//	DECLARE_PROPPAGEIDS(CCertWizCtrl)     // Property page IDs
	DECLARE_OLECTLTYPE(CCertWizCtrl)		// Type name and misc status

	// Subclassed control support
	BOOL PreCreateWindow(CREATESTRUCT& cs);
	BOOL IsSubclassedControl();
	LRESULT OnOcmCommand(WPARAM wParam, LPARAM lParam);

// Message maps
	//{{AFX_MSG(CCertWizCtrl)
		// NOTE - ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

// Dispatch maps
	//{{AFX_DISPATCH(CCertWizCtrl)
	afx_msg void SetMachineName(LPCTSTR MachineName);
	afx_msg void SetServerInstance(LPCTSTR InstanceName);
	//}}AFX_DISPATCH
	DECLARE_DISPATCH_MAP()

// Event maps
	//{{AFX_EVENT(CCertWizCtrl)
	//}}AFX_EVENT
	DECLARE_EVENT_MAP()

// Dispatch and event IDs
public:
	enum {
	//{{AFX_DISP_ID(CCertWizCtrl)
	dispidSetMachineName = 1L,
	dispidSetServerInstance = 2L,
	//}}AFX_DISP_ID
	};
// This project will build only for Unicode
#ifdef _UNICODE
protected:
	CString m_MachineName, m_InstanceName;
#endif
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_CERTWIZCTL_H__D4BE863F_0C85_11D2_91B1_00C04F8C8761__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\certwiz\certwizctl.cpp ===
// CertWizCtl.cpp : Implementation of the CCertWizCtrl ActiveX Control class.

#include "stdafx.h"
#include "CertWiz.h"
#include "CertWizCtl.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


IMPLEMENT_DYNCREATE(CCertWizCtrl, COleControl)


/////////////////////////////////////////////////////////////////////////////
// Message map

BEGIN_MESSAGE_MAP(CCertWizCtrl, COleControl)
	//{{AFX_MSG_MAP(CCertWizCtrl)
	// NOTE - ClassWizard will add and remove message map entries
	//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG_MAP
	ON_MESSAGE(OCM_COMMAND, OnOcmCommand)
	ON_OLEVERB(AFX_IDS_VERB_PROPERTIES, OnProperties)
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// Dispatch map

BEGIN_DISPATCH_MAP(CCertWizCtrl, COleControl)
	//{{AFX_DISPATCH_MAP(CCertWizCtrl)
	DISP_FUNCTION(CCertWizCtrl, "SetMachineName", SetMachineName, VT_EMPTY, VTS_BSTR)
	DISP_FUNCTION(CCertWizCtrl, "SetServerInstance", SetServerInstance, VT_EMPTY, VTS_BSTR)
	DISP_STOCKFUNC_DOCLICK()
	//}}AFX_DISPATCH_MAP
END_DISPATCH_MAP()


/////////////////////////////////////////////////////////////////////////////
// Event map

BEGIN_EVENT_MAP(CCertWizCtrl, COleControl)
	//{{AFX_EVENT_MAP(CCertWizCtrl)
	//}}AFX_EVENT_MAP
END_EVENT_MAP()


/////////////////////////////////////////////////////////////////////////////
// Property pages

// TODO: Add more property pages as needed.  Remember to increase the count!
//BEGIN_PROPPAGEIDS(CCertWizCtrl, 1)
//	PROPPAGEID(CCertWizPropPage::guid)
//END_PROPPAGEIDS(CCertWizCtrl)


/////////////////////////////////////////////////////////////////////////////
// Initialize class factory and guid

IMPLEMENT_OLECREATE_EX(CCertWizCtrl, "CERTWIZ.CertWizCtrl.1",
	0xd4be8632, 0xc85, 0x11d2, 0x91, 0xb1, 0, 0xc0, 0x4f, 0x8c, 0x87, 0x61)


/////////////////////////////////////////////////////////////////////////////
// Type library ID and version

IMPLEMENT_OLETYPELIB(CCertWizCtrl, _tlid, _wVerMajor, _wVerMinor)


/////////////////////////////////////////////////////////////////////////////
// Interface IDs

const IID BASED_CODE IID_DCertWiz =
		{ 0xd4be8630, 0xc85, 0x11d2, { 0x91, 0xb1, 0, 0xc0, 0x4f, 0x8c, 0x87, 0x61 } };
const IID BASED_CODE IID_DCertWizEvents =
		{ 0xd4be8631, 0xc85, 0x11d2, { 0x91, 0xb1, 0, 0xc0, 0x4f, 0x8c, 0x87, 0x61 } };


/////////////////////////////////////////////////////////////////////////////
// Control type information

static const DWORD BASED_CODE _dwCertWizOleMisc =
	OLEMISC_INVISIBLEATRUNTIME |
	OLEMISC_SETCLIENTSITEFIRST |
	OLEMISC_INSIDEOUT |
	OLEMISC_CANTLINKINSIDE |
	OLEMISC_RECOMPOSEONRESIZE;

IMPLEMENT_OLECTLTYPE(CCertWizCtrl, IDS_CERTWIZ, _dwCertWizOleMisc)


/////////////////////////////////////////////////////////////////////////////
// CCertWizCtrl::CCertWizCtrlFactory::UpdateRegistry -
// Adds or removes system registry entries for CCertWizCtrl

BOOL CCertWizCtrl::CCertWizCtrlFactory::UpdateRegistry(BOOL bRegister)
{
	// TODO: Verify that your control follows apartment-model threading rules.
	// Refer to MFC TechNote 64 for more information.
	// If your control does not conform to the apartment-model rules, then
	// you must modify the code below, changing the 6th parameter from
	// afxRegApartmentThreading to 0.

	if (bRegister)
		return AfxOleRegisterControlClass(
			AfxGetInstanceHandle(),
			m_clsid,
			m_lpszProgID,
			IDS_CERTWIZ,
			IDB_CERTWIZ,
			afxRegApartmentThreading,
			_dwCertWizOleMisc,
			_tlid,
			_wVerMajor,
			_wVerMinor);
	else
		return AfxOleUnregisterClass(m_clsid, m_lpszProgID);
}


/////////////////////////////////////////////////////////////////////////////
// CCertWizCtrl::CCertWizCtrl - Constructor

CCertWizCtrl::CCertWizCtrl()
{
	InitializeIIDs(&IID_DCertWiz, &IID_DCertWizEvents);

	// TODO: Initialize your control's instance data here.
}


/////////////////////////////////////////////////////////////////////////////
// CCertWizCtrl::~CCertWizCtrl - Destructor

CCertWizCtrl::~CCertWizCtrl()
{
	// TODO: Cleanup your control's instance data here.
}


/////////////////////////////////////////////////////////////////////////////
// CCertWizCtrl::OnDraw - Drawing function

void CCertWizCtrl::OnDraw(
			CDC* pdc, const CRect& rcBounds, const CRect& rcInvalid)
{
	DoSuperclassPaint(pdc, rcBounds);
}


/////////////////////////////////////////////////////////////////////////////
// CCertWizCtrl::DoPropExchange - Persistence support

void CCertWizCtrl::DoPropExchange(CPropExchange* pPX)
{
	ExchangeVersion(pPX, MAKELONG(_wVerMinor, _wVerMajor));
	COleControl::DoPropExchange(pPX);

	// TODO: Call PX_ functions for each persistent custom property.

}


/////////////////////////////////////////////////////////////////////////////
// CCertWizCtrl::GetControlFlags -
// Flags to customize MFC's implementation of ActiveX controls.
//
// For information on using these flags, please see MFC technical note
// #nnn, "Optimizing an ActiveX Control".
DWORD CCertWizCtrl::GetControlFlags()
{
	DWORD dwFlags = COleControl::GetControlFlags();


	// The control can activate without creating a window.
	// TODO: when writing the control's message handlers, avoid using
	//		the m_hWnd member variable without first checking that its
	//		value is non-NULL.
	dwFlags |= windowlessActivate;
	return dwFlags;
}


/////////////////////////////////////////////////////////////////////////////
// CCertWizCtrl::OnResetState - Reset control to default state

void CCertWizCtrl::OnResetState()
{
	COleControl::OnResetState();  // Resets defaults found in DoPropExchange

	// TODO: Reset any other control state here.
}


/////////////////////////////////////////////////////////////////////////////
// CCertWizCtrl::PreCreateWindow - Modify parameters for CreateWindowEx

BOOL CCertWizCtrl::PreCreateWindow(CREATESTRUCT& cs)
{
	cs.lpszClass = _T("BUTTON");
	return COleControl::PreCreateWindow(cs);
}


/////////////////////////////////////////////////////////////////////////////
// CCertWizCtrl::IsSubclassedControl - This is a subclassed control

BOOL CCertWizCtrl::IsSubclassedControl()
{
	return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
// CCertWizCtrl::OnOcmCommand - Handle command messages

LRESULT CCertWizCtrl::OnOcmCommand(WPARAM wParam, LPARAM lParam)
{
#ifdef _WIN32
	WORD wNotifyCode = HIWORD(wParam);
#else
	WORD wNotifyCode = HIWORD(lParam);
#endif

	// TODO: Switch on wNotifyCode here.

	return 0;
}


/////////////////////////////////////////////////////////////////////////////
// CCertWizCtrl message handlers

#include "WelcomePage.h"
#include "FinalPages.h"
#include "CertContentsPages.h"
#include "GetWhatPage.h"
#include "ChooseCAType.h"
#include "SecuritySettingsPage.h"
#include "ChooseCspPage.h"
#include "OrgInfoPage.h"
#include "SiteNamePage.h"
#include "GeoInfoPage.h"
#include "ChooseFileName.h"
#include "ChooseOnlinePage.h"
#include "WhatToDoPendingPage.h"
#include "ManageCertPage.h"
#include "ChooseCertPage.h"
#include "KeyPasswordPage.h"
#include "Certificat.h"
#include "CopyMoveCertRemotePage.h"
#include "ChooseServerPages.h"
#include "ChooseServerSitePages.h"

void CCertWizCtrl::OnClick(USHORT iButton) 
{
	CIISWizardSheet propsheet(IDB_WIZ_LEFT, IDB_WIZ_TOP);

	CCertificate * cert = new CCertificate;

	ASSERT(!m_InstanceName.IsEmpty());
	cert->m_WebSiteInstanceName = m_InstanceName;
	cert->m_MachineName = m_MachineName;
	VERIFY(cert->Init());

	CWelcomePage welcome_page(cert);
	CGetWhatPage get_what_page(cert);
	CChooseCAType choose_ca_page(cert);
	CSecuritySettingsPage security_settings_page(cert);
    CChooseCspPage csp_page(cert);
	COrgInfoPage org_info_page(cert);
	CSiteNamePage site_name_page(cert);
	CGeoInfoPage geo_info_page(cert);
	CChooseReqFile choose_reqfile_name(cert);
    CChooseReqFileRenew choose_reqfile_name_renew(cert);
	CChooseRespFile choose_respfile_name(cert);
	CChooseKeyFile choose_keyfile_name(cert);
	CRequestToFilePage check_request(cert);
    CRequestToFilePageRenew check_request_renew(cert);
	CFinalToFilePage final_tofile_page(&cert->m_hResult, cert);
	CChooseOnlinePage choose_online(cert);
	COnlineRequestSubmit online_request_dump(cert);
	CWhatToDoPendingPage what_pending(cert);
	CInstallRespPage install_resp(cert);
	CManageCertPage manage_cert(cert);
	CFinalInstalledPage final_install(&cert->m_hResult, cert);
	CRemoveCertPage remove_cert(cert);
	CFinalRemovePage final_remove(&cert->m_hResult, cert);
	CReplaceCertPage replace_cert(cert);
	CFinalReplacedPage final_replace(&cert->m_hResult, cert);
	CChooseCertPage choose_cert(cert);
	CInstallCertPage install_cert(cert);
	CRequestCancelPage cancel_request(cert);
	CFinalCancelPage final_cancel(&cert->m_hResult, cert);
	CKeyPasswordPage key_password_page(cert);
	CInstallKeyPage install_key(cert);
    // new stuff for iis6
    CCopyMoveCertFromRemotePage copy_move_from_cert_remote_page(cert);
    CCopyMoveCertToRemotePage copy_move_to_cert_remote_page(cert);
    CChooseImportPFXFile choose_import_pfx_file_name(cert);
    CChooseExportPFXFile choose_export_pfx_file_name(cert);
    CImportPFXPasswordPage import_pfx_password_name(cert);
    CExportPFXPasswordPage export_pfx_password_name(cert);
    CInstallImportPFXPage install_import_pfx_key(cert);
    CInstallExportPFXPage install_export_pfx_key(cert);
    CFinalInstalledImportPFXPage final_import_pfx(&cert->m_hResult, cert);
    CFinalInstalledExportPFXPage final_export_pfx(&cert->m_hResult, cert);
    CChooseServerPages choose_server_name(cert);
    CChooseServerSitePages choose_server_site_name(cert);
    CChooseServerPagesTo choose_server_name_to(cert);
    CChooseServerSitePagesTo choose_server_site_name_to(cert);
    CInstallCopyFromRemotePage install_copy_from_remote(cert);
    CInstallMoveFromRemotePage install_move_from_remote(cert);
    CInstallCopyToRemotePage install_copy_to_remote(cert);
    CInstallMoveToRemotePage install_move_to_remote(cert);
    CFinalInstalledCopyFromRemotePage final_copy_from_remote(&cert->m_hResult, cert);
    CFinalInstalledMoveFromRemotePage final_move_from_remote(&cert->m_hResult, cert);
    CFinalInstalledCopyToRemotePage final_copy_to_remote(&cert->m_hResult, cert);
    CFinalInstalledMoveToRemotePage final_move_to_remote(&cert->m_hResult, cert);

	propsheet.AddPage(&welcome_page);
	propsheet.AddPage(&get_what_page);
	propsheet.AddPage(&choose_ca_page);
	propsheet.AddPage(&security_settings_page);
    propsheet.AddPage(&csp_page);
	propsheet.AddPage(&org_info_page);
	propsheet.AddPage(&site_name_page);
	propsheet.AddPage(&geo_info_page);
	propsheet.AddPage(&choose_reqfile_name);
    propsheet.AddPage(&choose_reqfile_name_renew);
	propsheet.AddPage(&choose_respfile_name);
	propsheet.AddPage(&choose_keyfile_name);
	propsheet.AddPage(&check_request);
    propsheet.AddPage(&check_request_renew);
	propsheet.AddPage(&final_tofile_page);
	propsheet.AddPage(&choose_online);
	propsheet.AddPage(&online_request_dump);
	propsheet.AddPage(&what_pending);
	propsheet.AddPage(&install_resp);
	propsheet.AddPage(&manage_cert);
	propsheet.AddPage(&final_install);
	propsheet.AddPage(&remove_cert);
	propsheet.AddPage(&final_remove);
	propsheet.AddPage(&choose_cert);
	propsheet.AddPage(&replace_cert);
	propsheet.AddPage(&final_replace);
	propsheet.AddPage(&install_cert);
	propsheet.AddPage(&cancel_request);
	propsheet.AddPage(&final_cancel);
	propsheet.AddPage(&key_password_page);
	propsheet.AddPage(&install_key);
    // new stuff for iis6
    propsheet.AddPage(&copy_move_from_cert_remote_page);
    propsheet.AddPage(&copy_move_to_cert_remote_page);
    propsheet.AddPage(&choose_import_pfx_file_name);
    propsheet.AddPage(&choose_export_pfx_file_name);
    propsheet.AddPage(&import_pfx_password_name);
    propsheet.AddPage(&export_pfx_password_name);
    propsheet.AddPage(&install_import_pfx_key);
    propsheet.AddPage(&install_export_pfx_key);
    propsheet.AddPage(&final_import_pfx);
    propsheet.AddPage(&final_export_pfx);
    propsheet.AddPage(&choose_server_name);
    propsheet.AddPage(&choose_server_site_name);
    propsheet.AddPage(&choose_server_name_to);
    propsheet.AddPage(&choose_server_site_name_to);
    propsheet.AddPage(&install_copy_from_remote);
    propsheet.AddPage(&install_move_from_remote);
    propsheet.AddPage(&install_copy_to_remote);
    propsheet.AddPage(&install_move_to_remote);
    propsheet.AddPage(&final_copy_from_remote);
    propsheet.AddPage(&final_move_from_remote);
    propsheet.AddPage(&final_copy_to_remote);
    propsheet.AddPage(&final_move_to_remote);

	if (IDCANCEL != propsheet.DoModal())
	{
		// save our settings to the Registry
		VERIFY(cert->SaveSettings());
	}
   delete cert;
}

void CCertWizCtrl::SetMachineName(LPCTSTR MachineName) 
{
	m_MachineName = MachineName;
}

void CCertWizCtrl::SetServerInstance(LPCTSTR InstanceName) 
{
	m_InstanceName = InstanceName;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\certwiz\choosecertpage.cpp ===
// ReplaceChooseCert.cpp : implementation file
//

#include "stdafx.h"
#include "CertWiz.h"
#include "ChooseCertPage.h"
#include "Certificat.h"
#include "CertUtil.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define COL_COMMON_NAME				0
#define COL_CA_NAME					1
#define COL_EXPIRATION_DATE		2
#define COL_PURPOSE					3
#define COL_FRIENDLY_NAME			4
#define COL_COMMON_NAME_WID		100
#define COL_CA_NAME_WID				100
#define COL_EXPIRATION_DATE_WID	100
#define COL_PURPOSE_WID				100
#define COL_FRIENDLY_NAME_WID		100

int
CCertListCtrl::GetSelectedIndex()
{
#if _AFX_VER >= 0x0600
	POSITION pos = GetFirstSelectedItemPosition();
	return pos != NULL ? GetNextSelectedItem(pos) : -1;
#else
	// I guess we should do it in a hard way
	int count = GetItemCount();
	int index = -1;
	for (int i = 0; i < count; i++)
	{
		if (GetItemState(i, LVIS_SELECTED))
		{
			index = i;
			break;
		}
	}
	return index;
#endif
}

void
CCertListCtrl::AdjustStyle()
{
#if _AFX_VER >= 0x0600
	DWORD dwStyle = m_CertList.GetExtendedStyle();
	m_CertList.SetExtendedStyle(dwStyle | LVS_EX_FULLROWSELECT | LVS_EX_HEADERDRAGDROP);
#else
	ASSERT(m_hWnd != NULL);
	DWORD dwStyle = ListView_GetExtendedListViewStyle(m_hWnd);
	ListView_SetExtendedListViewStyle(m_hWnd,
		dwStyle | LVS_EX_FULLROWSELECT | LVS_EX_HEADERDRAGDROP);
#endif
}

/////////////////////////////////////////////////////////////////////////////
// CChooseCertPage property page

IMPLEMENT_DYNCREATE(CChooseCertPage, CIISWizardPage)

CChooseCertPage::CChooseCertPage(CCertificate * pCert)
	: CIISWizardPage(CChooseCertPage::IDD, IDS_CERTWIZ, TRUE),
	m_pCert(pCert)
{
	//{{AFX_DATA_INIT(CChooseCertPage)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}

CChooseCertPage::~CChooseCertPage()
{
}

void CChooseCertPage::DoDataExchange(CDataExchange* pDX)
{
	CIISWizardPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CChooseCertPage)
	DDX_Control(pDX, IDC_CERT_LIST, m_CertList);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CChooseCertPage, CIISWizardPage)
	//{{AFX_MSG_MAP(CChooseCertPage)
	ON_NOTIFY(NM_CLICK, IDC_CERT_LIST, OnClickCertList)
    ON_NOTIFY(NM_DBLCLK, IDC_CERT_LIST, OnDblClickCertList)
	ON_WM_DESTROY()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CChooseCertPage message handlers

LRESULT CChooseCertPage::OnWizardBack()
{
	LRESULT id = 1;
	switch (m_pCert->GetStatusCode())
	{
	case CCertificate::REQUEST_REPLACE_CERT:
		id = IDD_PAGE_PREV_REPLACE;
		break;
	case CCertificate::REQUEST_INSTALL_CERT:
		id = IDD_PAGE_PREV_INSTALL;
		break;
	default:
		ASSERT(FALSE);
	}
	return id;
}

LRESULT CChooseCertPage::OnWizardNext()
{
	// get hash pointer for selected cert
	int index = m_CertList.GetSelectedIndex();
	ASSERT(index != -1);
	// find cert in store
	CRYPT_HASH_BLOB * pHash = (CRYPT_HASH_BLOB *)m_CertList.GetItemData(index);
	ASSERT(pHash != NULL);
	
	m_pCert->m_pSelectedCertHash = pHash;

	LRESULT id = 1;
	switch (m_pCert->GetStatusCode())
	{
	case CCertificate::REQUEST_REPLACE_CERT:
		id = IDD_PAGE_NEXT_REPLACE;
		break;
	case CCertificate::REQUEST_INSTALL_CERT:
		id = IDD_PAGE_NEXT_INSTALL;
		break;
	default:
		ASSERT(FALSE);
	}
	return id;
}

BOOL CChooseCertPage::OnSetActive()
{
	// If nothing is selected -- stay here
	SetWizardButtons(-1 == m_CertList.GetSelectedIndex() ?
					PSWIZB_BACK : PSWIZB_BACK | PSWIZB_NEXT);
	return CIISWizardPage::OnSetActive();
}

BOOL CChooseCertPage::OnInitDialog()
{
	ASSERT(m_pCert != NULL);

	CIISWizardPage::OnInitDialog();

	CString str;
	str.LoadString(IDS_ISSUED_TO);
	m_CertList.InsertColumn(COL_COMMON_NAME, str, LVCFMT_LEFT, COL_COMMON_NAME_WID);
	str.LoadString(IDS_ISSUED_BY);
	m_CertList.InsertColumn(COL_CA_NAME, str, LVCFMT_LEFT, COL_CA_NAME_WID);
	str.LoadString(IDS_EXPIRATION_DATE);
	m_CertList.InsertColumn(COL_EXPIRATION_DATE, str, LVCFMT_LEFT, COL_EXPIRATION_DATE_WID);
	str.LoadString(IDS_PURPOSE);
	m_CertList.InsertColumn(COL_PURPOSE, str, LVCFMT_LEFT, COL_PURPOSE_WID);
	str.LoadString(IDS_FRIENDLY_NAME);
	m_CertList.InsertColumn(COL_FRIENDLY_NAME, str, LVCFMT_LEFT, COL_FRIENDLY_NAME_WID);

	m_CertList.AdjustStyle();

	if (m_pCert->GetCertDescList(m_DescList))
	{
		int item = 0;
		POSITION pos = m_DescList.GetHeadPosition();
		LV_ITEMW lvi;
		//
		// set up the fields in the list view item struct that don't change from item to item
		//
		memset(&lvi, 0, sizeof(LV_ITEMW));
		lvi.mask = LVIF_TEXT;

		m_CertList.SetItemCount((int)m_DescList.GetCount());

		while (pos != NULL)
		{
			CERT_DESCRIPTION * pDesc = m_DescList.GetNext(pos);
			int i;

			lvi.iItem = item;
			lvi.iSubItem = 0;
			lvi.pszText = (LPTSTR)(LPCTSTR)pDesc->m_CommonName;
			lvi.cchTextMax = pDesc->m_CommonName.GetLength();
			i = m_CertList.InsertItem(&lvi);
			ASSERT(i != -1);

			lvi.iItem = i;
			lvi.iSubItem = COL_CA_NAME;
			lvi.pszText = (LPTSTR)(LPCTSTR)pDesc->m_CAName;
			lvi.cchTextMax = pDesc->m_CAName.GetLength();
			VERIFY(m_CertList.SetItem(&lvi));

			lvi.iSubItem = COL_EXPIRATION_DATE;
			lvi.pszText = (LPTSTR)(LPCTSTR)pDesc->m_ExpirationDate;
			lvi.cchTextMax = pDesc->m_ExpirationDate.GetLength();
			VERIFY(m_CertList.SetItem(&lvi));

			lvi.iSubItem = COL_PURPOSE;
			lvi.pszText = (LPTSTR)(LPCTSTR)pDesc->m_Usage;
			lvi.cchTextMax = pDesc->m_Usage.GetLength();
			VERIFY(m_CertList.SetItem(&lvi));

			lvi.iSubItem = COL_FRIENDLY_NAME;
			lvi.pszText = (LPTSTR)(LPCTSTR)pDesc->m_FriendlyName;
			lvi.cchTextMax = pDesc->m_FriendlyName.GetLength();
			VERIFY(m_CertList.SetItem(&lvi));

			// create CRYPT_HASH_BLOB from desc data and put it to list item
			CRYPT_HASH_BLOB * pHashBlob = new CRYPT_HASH_BLOB;
			ASSERT(pHashBlob != NULL);
			pHashBlob->cbData = pDesc->m_hash_length;
			pHashBlob->pbData = pDesc->m_hash;
			VERIFY(m_CertList.SetItemData(item, (LONG_PTR)pHashBlob));

			item++;
		}
	}
	return TRUE;
}

void CChooseCertPage::OnClickCertList(NMHDR* pNMHDR, LRESULT* pResult)
{
	SetWizardButtons(-1 == m_CertList.GetSelectedIndex() ?
					PSWIZB_BACK : PSWIZB_BACK | PSWIZB_NEXT);
	*pResult = 0;
}

void CChooseCertPage::OnDblClickCertList(NMHDR* pNMHDR, LRESULT* pResult)
{
    // Get the hash for the certificate that is clicked on...
	int index = m_CertList.GetSelectedIndex();
    if (index != -1)
    {
	    // find cert in store
	    CRYPT_HASH_BLOB * pHash = (CRYPT_HASH_BLOB *)m_CertList.GetItemData(index);
        m_pCert->m_pSelectedCertHash = pHash;
        ViewCertificateDialog(pHash,m_hWnd);
        // don't need to make modal, so the user can compare certs side-by-side
        //ViewCertificateDialog(pHash,NULL);
    }
    return;
}

void CChooseCertPage::OnDestroy()
{
	// before dialog will be desroyed we need to delete all
	// the item data pointers
	int count = m_CertList.GetItemCount();
	for (int index = 0; index < count; index++)
	{
		CRYPT_HASH_BLOB * pData = (CRYPT_HASH_BLOB *)m_CertList.GetItemData(index);
		delete pData;
	}
	CIISWizardPage::OnDestroy();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\certwiz\choosecatype.h ===
#if !defined(AFX_CHOOSECATYPE_H__1FE282A3_29AD_11D2_97AD_000000000000__INCLUDED_)
#define AFX_CHOOSECATYPE_H__1FE282A3_29AD_11D2_97AD_000000000000__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// ChooseCAType.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CChooseCAType dialog
class CCertificate;

class CChooseCAType : public CIISWizardPage
{
	DECLARE_DYNCREATE(CChooseCAType)

// Construction
public:
	CChooseCAType(CCertificate * pCert = NULL);
	~CChooseCAType();

	enum
	{
		IDD_PAGE_NEXT_NEW = IDD_PAGE_WIZ_SECURITY_SETTINGS,
		IDD_PAGE_PREV_NEW = IDD_PAGE_WIZ_GET_WHAT,
		IDD_PAGE_NEXT_RENEW_OFFLINE = IDD_PAGE_WIZ_CHOOSE_FILENAME_RENEW,
		IDD_PAGE_NEXT_RENEW_ONLINE = IDD_PAGE_WIZ_CHOOSE_ONLINE,
		IDD_PAGE_PREV_RENEW = IDD_PAGE_WIZ_MANAGE_CERT
	};
// Dialog Data
	//{{AFX_DATA(CChooseCAType)
	enum { IDD = IDD_PAGE_WIZ_CHOOSE_CATYPE };
	int		m_Index;
	//}}AFX_DATA
	CCertificate * m_pCert;

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CChooseCAType)
	public:
	virtual LRESULT OnWizardNext();
	virtual LRESULT OnWizardBack();
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CChooseCAType)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_CHOOSECATYPE_H__1FE282A3_29AD_11D2_97AD_000000000000__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\certwiz\choosecertpage.h ===
#if !defined(AFX_REPLACECHOOSECERT_H__F126182F_4039_11D2_9318_0060088FF80E__INCLUDED_)
#define AFX_REPLACECHOOSECERT_H__F126182F_4039_11D2_9318_0060088FF80E__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// ChooseCertPage.h : header file
//
#include "Certificat.h"
/////////////////////////////////////////////////////////////////////////////
// CChooseCertPage dialog

class CCertListCtrl : public CListCtrl
{
public:
	int GetSelectedIndex();
	void AdjustStyle();
};

class CChooseCertPage : public CIISWizardPage
{
	DECLARE_DYNCREATE(CChooseCertPage)

// Construction
public:
	CChooseCertPage(CCertificate * pCert = NULL);
	~CChooseCertPage();

	enum
	{
		IDD_PAGE_NEXT_REPLACE = IDD_PAGE_WIZ_REPLACE_CERT,
		IDD_PAGE_NEXT_INSTALL = IDD_PAGE_WIZ_INSTALL_CERT,
		IDD_PAGE_PREV_REPLACE = IDD_PAGE_WIZ_MANAGE_CERT,
		IDD_PAGE_PREV_INSTALL = IDD_PAGE_WIZ_GET_WHAT
	};
// Dialog Data
	//{{AFX_DATA(CChooseCertPage)
	enum { IDD = IDD_PAGE_WIZ_CHOOSE_CERT };
	CCertListCtrl	m_CertList;
	//}}AFX_DATA
	CCertificate * m_pCert;
	CCertDescList m_DescList;


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CChooseCertPage)
	public:
	virtual LRESULT OnWizardBack();
	virtual LRESULT OnWizardNext();
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CChooseCertPage)
	virtual BOOL OnInitDialog();
	afx_msg void OnClickCertList(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnDblClickCertList(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnDestroy();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_REPLACECHOOSECERT_H__F126182F_4039_11D2_9318_0060088FF80E__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\certwiz\chooseonlinepage.cpp ===
// ChooseCAPage.cpp : implementation file
//

#include "stdafx.h"
#include "CertWiz.h"
#include "ChooseOnlinePage.h"
#include "Certificat.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CChooseOnlinePage property page

IMPLEMENT_DYNCREATE(CChooseOnlinePage, CIISWizardPage)

CChooseOnlinePage::CChooseOnlinePage(CCertificate * pCert) 
	: CIISWizardPage(CChooseOnlinePage::IDD, IDS_CERTWIZ, TRUE),
	m_pCert(pCert)
{
	//{{AFX_DATA_INIT(CChooseOnlinePage)
	m_CAIndex = -1;
	//}}AFX_DATA_INIT
}

CChooseOnlinePage::~CChooseOnlinePage()
{
}

void CChooseOnlinePage::DoDataExchange(CDataExchange* pDX)
{
	CIISWizardPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CChooseOnlinePage)
	DDX_CBIndex(pDX, IDC_CA_ONLINE_LIST, m_CAIndex);
	//}}AFX_DATA_MAP
}

LRESULT 
CChooseOnlinePage::OnWizardBack()
/*++
Routine Description:
    Prev button handler

Arguments:
    None

Return Value:
	0 to automatically advance to the prev page;
	1 to prevent the page from changing. 
	To jump to a page other than the prev one, 
	return the identifier of the dialog to be displayed.
--*/
{
	if (m_pCert->GetStatusCode() == CCertificate::REQUEST_RENEW_CERT)
		return IDD_PAGE_PREV_RENEW;
	else if (m_pCert->GetStatusCode() == CCertificate::REQUEST_NEW_CERT)
		return IDD_PAGE_PREV_NEW;
	else
		return 1;
}

LRESULT 
CChooseOnlinePage::OnWizardNext()
/*++
Routine Description:
    Next button handler

Arguments:
    None

Return Value:
	0 to automatically advance to the next page;
	1 to prevent the page from changing. 
	To jump to a page other than the next one, 
	return the identifier of the dialog to be displayed.
--*/
{
	UpdateData();
	CComboBox * pCombo = (CComboBox *)CWnd::FromHandle(
		GetDlgItem(IDC_CA_ONLINE_LIST)->m_hWnd);
	pCombo->GetLBText(m_CAIndex, m_pCert->m_ConfigCA);
	return IDD_PAGE_NEXT;
}

BEGIN_MESSAGE_MAP(CChooseOnlinePage, CIISWizardPage)
	//{{AFX_MSG_MAP(CChooseCAPage)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CChooseCAPage message handlers

BOOL CChooseOnlinePage::OnInitDialog() 
{
	m_CAIndex = 0;
	// We need to create controls first
	CIISWizardPage::OnInitDialog();
	ASSERT(m_pCert != NULL);
	GetDlgItem(IDC_CA_ONLINE_LIST)->SetFocus();
	CComboBox * pCombo = (CComboBox *)CWnd::FromHandle(
		GetDlgItem(IDC_CA_ONLINE_LIST)->m_hWnd);
	CString str;
	POSITION pos = m_pCert->m_OnlineCAList.GetHeadPosition();
	while (pos != NULL)
	{
		str = m_pCert->m_OnlineCAList.GetNext(pos);
		pCombo->AddString(str);
	}
	int idx;
	if (	!m_pCert->m_ConfigCA.IsEmpty()
		&&	CB_ERR != (idx = pCombo->FindString(-1, m_pCert->m_ConfigCA))
		)
	{
		pCombo->SetCurSel(idx);
	}
	else
		pCombo->SetCurSel(0);
	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\certwiz\choosecsppage.cpp ===
// ChooseCspPage.cpp : implementation file
//

#include "stdafx.h"
#include "CertWiz.h"
#include "ChooseCspPage.h"
#include "Certificat.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CChooseCertPage property page

IMPLEMENT_DYNCREATE(CChooseCspPage, CIISWizardPage)

CChooseCspPage::CChooseCspPage(CCertificate * pCert)
	: CIISWizardPage(CChooseCspPage::IDD, IDS_CERTWIZ, TRUE),
	m_pCert(pCert)
{
	//{{AFX_DATA_INIT(CChooseCspPage)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}

CChooseCspPage::~CChooseCspPage()
{
}

void CChooseCspPage::DoDataExchange(CDataExchange* pDX)
{
	CIISWizardPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CChooseCspPage)
	DDX_Control(pDX, IDC_CSP_LIST, m_List);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CChooseCspPage, CIISWizardPage)
	//{{AFX_MSG_MAP(CChooseCspPage)
	ON_LBN_SELCHANGE(IDC_CSP_LIST, OnListSelChange)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CChooseCspPage message handlers

LRESULT CChooseCspPage::OnWizardBack()
{
   return IDD_PREV_PAGE;
}

LRESULT CChooseCspPage::OnWizardNext()
{
	int index = m_List.GetCurSel();
	ASSERT(index != LB_ERR);
	m_List.GetText(index, m_pCert->m_CspName);
   m_pCert->m_CustomProviderType = (DWORD) m_List.GetItemData(index);
   return IDD_NEXT_PAGE;
}

BOOL CChooseCspPage::OnSetActive()
{
	// If nothing is selected -- stay here
   if (!m_pCert->m_CspName.IsEmpty())
   {
      m_List.SelectString(-1, m_pCert->m_CspName);
   }
	SetWizardButtons(LB_ERR == m_List.GetCurSel() ?
					PSWIZB_BACK : PSWIZB_BACK | PSWIZB_NEXT);
	return CIISWizardPage::OnSetActive();
}

BOOL CChooseCspPage::OnInitDialog()
{
	ASSERT(m_pCert != NULL);

	CIISWizardPage::OnInitDialog();

	CString str;
   BSTR bstrProvName = NULL;
   DWORD dwType, nProv;
   int j;
   HRESULT hr;

   // array of compatible CSP provider types (see wincrypt.h)
   DWORD IISProvType[] = 
   { 
      PROV_RSA_SCHANNEL,
      PROV_DH_SCHANNEL
   };

   IEnroll * pEnroll = m_pCert->GetEnrollObject();
   ASSERT(pEnroll != NULL);

   // Loop, for each Prov Type
   for (j = 0; j < (sizeof(IISProvType)/sizeof(DWORD)); j++)
   {
      nProv = 0;
    
      // check specific prov type
      dwType = IISProvType[j];
      // pEnroll is previously instantiated ICEnroll interface pointer
      hr = pEnroll->put_ProviderType(dwType);
      if (FAILED(hr))
      {
         TRACE(_T("Failed put_ProviderType - %x\n"), hr);
         goto error;
      }
      // enumerate the CSPs of this type
      int idx;
      while (S_OK == (hr  = pEnroll->enumProvidersWStr(nProv, 0, &bstrProvName)))
      {
         TRACE(_T("Provider %ws (type %d )\n"), bstrProvName, dwType );
         // increment the index
         nProv++;
         // Free this string, so it can be re-used.
         idx = m_List.AddString(bstrProvName);
         m_List.SetItemData(idx, dwType);
         if (NULL != bstrProvName)
         {
            CoTaskMemFree(bstrProvName);
            bstrProvName = NULL;
         }
      }
      // Print message if provider type doesn't have any CSPs.
      if (0 == nProv)
      {
         TRACE(_T("There were no CSPs of type %d\n"), dwType );
      }
   }

error:
   // Clean up resources, etc.
   if (NULL != bstrProvName)
      CoTaskMemFree(bstrProvName);

	return TRUE;
}

void CChooseCspPage::OnListSelChange()
{
	SetWizardButtons(-1 == m_List.GetCurSel() ?
					PSWIZB_BACK : PSWIZB_BACK | PSWIZB_NEXT);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\certwiz\choosecsppage.h ===
#if !defined(_CHOOSECSPPAGE_H)
#define _CHOOSECSPPAGE_H

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// ChooseCertPage.h : header file
//
#include "Certificat.h"
/////////////////////////////////////////////////////////////////////////////
// CChooseCertPage dialog

class CChooseCspPage : public CIISWizardPage
{
	DECLARE_DYNCREATE(CChooseCspPage)

// Construction
public:
	CChooseCspPage(CCertificate * pCert = NULL);
	~CChooseCspPage();

	enum
	{
		IDD_PREV_PAGE = IDD_PAGE_WIZ_SECURITY_SETTINGS,
		IDD_NEXT_PAGE = IDD_PAGE_WIZ_ORG_INFO,
	};
// Dialog Data
	//{{AFX_DATA(CChooseCspPage)
	enum { IDD = IDD_PAGE_WIZ_CHOOSE_CSP };
	CListBox	m_List;
	//}}AFX_DATA
	CCertificate * m_pCert;


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CChooseCspPage)
	public:
	virtual LRESULT OnWizardBack();
	virtual LRESULT OnWizardNext();
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CChooseCspPage)
	virtual BOOL OnInitDialog();
	afx_msg void OnListSelChange();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(_CHOOSECSPPAGE_H)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\certwiz\chooseserverpages.h ===
// ChooseServerPages.h: interface for the CChooseServerPages class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_CHOOSESERVERPAGES_H__CB354F31_7FB7_4909_B605_F5F8B037914C__INCLUDED_)
#define AFX_CHOOSESERVERPAGES_H__CB354F31_7FB7_4909_B605_F5F8B037914C__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

/////////////////////////////////////////////////////////////////////////////
// CChooseServerPages dialog
class CCertificate;

class CChooseServerPages : public CIISWizardPage
{
	DECLARE_DYNCREATE(CChooseServerPages)

// Construction
public:
	CChooseServerPages(CCertificate * pCert = NULL);
	~CChooseServerPages();

	enum
	{
		IDD_PAGE_PREV = IDD_PAGE_WIZ_CHOOSE_COPY_MOVE_FROM_REMOTE,
		IDD_PAGE_NEXT = IDD_PAGE_WIZ_CHOOSE_SERVER_SITE
	};
// Dialog Data
	//{{AFX_DATA(CChooseServerPages)
	enum { IDD = IDD_PAGE_WIZ_CHOOSE_SERVER };
	CString	m_ServerName;
    CString	m_UserName;
    CString	m_UserPassword;
	//}}AFX_DATA
	CCertificate * m_pCert;


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CChooseServerPages)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	public:
	virtual LRESULT OnWizardNext();
	virtual LRESULT OnWizardBack();
	virtual BOOL OnSetActive();
	virtual BOOL OnKillActive();
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CChooseServerPages)
	afx_msg void OnEditchangeServerName();
    afx_msg void OnEditchangeUserName();
    afx_msg void OnEditchangeUserPassword();
    afx_msg void OnBrowseForMachine();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};


class CChooseServerPagesTo : public CIISWizardPage
{
	DECLARE_DYNCREATE(CChooseServerPagesTo)

// Construction
public:
	CChooseServerPagesTo(CCertificate * pCert = NULL);
	~CChooseServerPagesTo();

	enum
	{
		IDD_PAGE_PREV = IDD_PAGE_WIZ_CHOOSE_COPY_MOVE_TO_REMOTE,
		IDD_PAGE_NEXT = IDD_PAGE_WIZ_CHOOSE_SERVER_SITE_TO
	};
// Dialog Data
	//{{AFX_DATA(CChooseServerPagesTo)
	enum { IDD = IDD_PAGE_WIZ_CHOOSE_SERVER_TO };
	CString	m_ServerName;
    CString	m_UserName;
    CString	m_UserPassword;
	//}}AFX_DATA
	CCertificate * m_pCert;


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CChooseServerPagesTo)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	public:
	virtual LRESULT OnWizardNext();
	virtual LRESULT OnWizardBack();
	virtual BOOL OnSetActive();
	virtual BOOL OnKillActive();
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CChooseServerPagesTo)
	afx_msg void OnEditchangeServerName();
    afx_msg void OnEditchangeUserName();
    afx_msg void OnEditchangeUserPassword();
    afx_msg void OnBrowseForMachine();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};


#endif // !defined(AFX_CHOOSESERVERPAGES_H__CB354F31_7FB7_4909_B605_F5F8B037914C__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\certwiz\choosefilename.cpp ===
// ChooseFileNamePage.cpp : implementation file
//

#include "stdafx.h"
#include "CertWiz.h"
#include "ChooseFileName.h"
#include "Certificat.h"
#include "Shlwapi.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CChooseFileNamePage property page

IMPLEMENT_DYNCREATE(CChooseFileNamePage, CIISWizardPage)

static BOOL
AnswerIsYes(UINT id, CString& file)
{
	CString strMessage;
	AfxFormatString1(strMessage, id, file);
	return (IDYES == AfxMessageBox(strMessage, MB_ICONEXCLAMATION | MB_YESNO));
}

CChooseFileNamePage::CChooseFileNamePage(UINT id, 
													  UINT defaultID,
													  UINT extID,
													  UINT filterID,
													  CString * pOutFileName,
                                                      CString csAdditionalInfo) 
	: CIISWizardPage(id, IDS_CERTWIZ, TRUE),
	m_id(id),
	m_defaultID(defaultID),
	m_DoReplaceFile(FALSE),
	m_pOutFileName(pOutFileName),
    m_AdditionalInfo(csAdditionalInfo)
{
	//{{AFX_DATA_INIT(CChooseFileNamePage)
	m_FileName = _T("");
	//}}AFX_DATA_INIT
	if (extID != 0)
		ext.LoadString(extID);
	if (filterID != 0)
		filter.LoadString(filterID);
	// replace '!'s in this string to null chars
	for (int i = 0; i < filter.GetLength(); i++)
	{
		if (filter[i] == L'!')
			filter.SetAt(i, L'\0');
	}
}

CChooseFileNamePage::~CChooseFileNamePage()
{
}

void CChooseFileNamePage::DoDataExchange(CDataExchange* pDX)
{
	CIISWizardPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CChooseFileNamePage)
	DDX_Text(pDX, IDC_FILE_NAME, m_FileName);
	//}}AFX_DATA_MAP
}

LRESULT 
CChooseFileNamePage::OnWizardBack()
{
	ASSERT(FALSE);
	return 1;
}

#if 0
#define SHOW_MESSAGE_BOX(id,str)\
	do {\
		CString strMessage;\
		AfxFormatString1(strMessage, (id), (str));\
		if (IDNO == AfxMessageBox(strMessage, MB_ICONEXCLAMATION | MB_YESNO))\
		{\
			CEdit * pEdit = (CEdit *)CWnd::FromHandle(GetDlgItem(IDC_FILE_NAME)->m_hWnd);\
			pEdit->SetSel(0, -1);\
			pEdit->SetFocus();\
			return 1;\
		}\
	} while(FALSE)
#endif

LRESULT CChooseFileNamePage::DoWizardNext(LRESULT id)
{
	if (id != 1)
	{
		ASSERT(m_pOutFileName != NULL);
		*m_pOutFileName = m_FileName;
	}
	else
	{
		UpdateData(FALSE);
		SetWizardButtons(PSWIZB_BACK);
		GetDlgItem(IDC_FILE_NAME)->SendMessage(EM_SETSEL, 0, -1);
		GetDlgItem(IDC_FILE_NAME)->SetFocus();
		MessageBeep(MB_ICONQUESTION);
	}
	return id;
}

BOOL CChooseFileNamePage::OnSetActive()
{
	SetWizardButtons(m_FileName.IsEmpty() ? 
			PSWIZB_BACK : PSWIZB_BACK | PSWIZB_NEXT);
   return CIISWizardPage::OnSetActive();
}

BEGIN_MESSAGE_MAP(CChooseFileNamePage, CIISWizardPage)
	//{{AFX_MSG_MAP(CChooseCAPage)
	ON_BN_CLICKED(IDC_BROWSE_BTN, OnBrowseBtn)
	ON_EN_CHANGE(IDC_FILE_NAME, OnChangeFileName)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CChooseCAPage message handlers

void CChooseFileNamePage::OnBrowseBtn() 
{
	ASSERT(FALSE);
}

void CChooseFileNamePage::Browse(CString& strPath, CString& strFile)
{
	if (strPath.IsEmpty())
	{
		::GetCurrentDirectory(MAX_PATH, strPath.GetBuffer(MAX_PATH + 1));
		strPath.ReleaseBuffer();
	}

	CFileDialog fileName(IsReadFileDlg());
	fileName.m_ofn.Flags |= OFN_NOCHANGEDIR | OFN_OVERWRITEPROMPT;
	if (IsReadFileDlg())
		fileName.m_ofn.Flags |= OFN_PATHMUSTEXIST;
	else
		fileName.m_ofn.Flags |= OFN_NOREADONLYRETURN;
	// We need to disable hook to show new style of File Dialog
	fileName.m_ofn.Flags &= ~(OFN_ENABLEHOOK);
	CString strExt = _T("*");
	strExt += ext;
	fileName.m_ofn.lpstrDefExt = strExt;
	fileName.m_ofn.lpstrFile = strFile.GetBuffer(MAX_PATH+1);
	fileName.m_ofn.nMaxFile = MAX_PATH;
	fileName.m_ofn.lpstrInitialDir = strPath.IsEmpty() ? NULL : (LPCTSTR)strPath;
	fileName.m_ofn.lpstrFilter = filter;
	fileName.m_ofn.nFilterIndex = 0;
	if (IDOK == fileName.DoModal())
	{
		ASSERT(NULL != GetDlgItem(IDC_FILE_NAME));
		CString strPrev;
		GetDlgItemText(IDC_FILE_NAME, strPrev);
		if (strPrev.CompareNoCase(strFile) != 0)
		{
			SetDlgItemText(IDC_FILE_NAME, strFile);
			m_DoReplaceFile = TRUE;
			FileNameChanged();
		}
	}
	strFile.ReleaseBuffer();
}

BOOL CChooseFileNamePage::OnInitDialog() 
{
	CIISWizardPage::OnInitDialog();

   if (GetDlgItem(IDC_FILE_NAME) != NULL)
   {
	   SHAutoComplete(GetDlgItem(IDC_FILE_NAME)->m_hWnd, SHACF_FILESYSTEM);
	   GetDlgItem(IDC_FILE_NAME)->SetFocus();
   }
	SetWizardButtons(m_FileName.IsEmpty() ? 
			PSWIZB_BACK : PSWIZB_BACK | PSWIZB_NEXT);
	return FALSE;
}

void CChooseFileNamePage::OnChangeFileName() 
{
	UpdateData(TRUE);
	//
	// Our replacement flag is not valid now:
	// It may be set to TRUE only when name was entered through
	// FileOpen dialog box which asks user about replacing itself
	//
	m_DoReplaceFile = FALSE;
	SetWizardButtons(m_FileName.IsEmpty() ? 
			PSWIZB_BACK : PSWIZB_BACK | PSWIZB_NEXT);
	// call virtual handler to notify inherited classes
	FileNameChanged();
}

BOOL IsValidFilenameChar(TCHAR cChar)
{
   switch (PathGetCharType((TCHAR)cChar))
   {
        case GCT_INVALID:
        case GCT_WILD:
        case GCT_SEPARATOR:
            return FALSE;
        case GCT_LFNCHAR:
        case GCT_SHORTCHAR:
            break;
   }
   return TRUE;
}

CString GimmieValidFilenameFromString(LPCTSTR path)
{
    CString str;
    // remove all bad characters
    // remove forward slashes
    // remove commas, semicolons...
    str = _T("");
    UINT len = lstrlen(path);
    TCHAR c = _T('');

    for (UINT i = 0; i < len; i++)
    {
        c = path[i];
        if (c != _T('\"'))
        {
            if (TRUE == IsValidFilenameChar(c))
            {
                str = str + c;
            }
        }
    }
    return str;
}

void
CChooseFileNamePage::GetDefaultFileName(CString& str)
{
	if (m_defaultID != 0)
    {
        // check for special type of file
        // which includes a %s string...
        if (m_defaultID == IDS_PFX_FILE_DEFAULT)
        {
            CString str1;
            str1.LoadString(m_defaultID);
            if (str1.Find(_T("%s")) != -1)
            {
                TCHAR szComputerName[MAX_COMPUTERNAME_LENGTH + 1];
                DWORD dwSize = sizeof(szComputerName);

                if (GetComputerName(szComputerName, &dwSize))
                {
                    CString csOurFileName;
                    csOurFileName = szComputerName;

                    // m_AdditionalInfo should contain
                    // /LM/W3SVC/1 at this point
                    // let's make a filename from it.
                    if (m_AdditionalInfo.GetLength() >= 4)
                    {
                        CString key_path_lm = SZ_MBN_SEP_STR SZ_MBN_MACHINE SZ_MBN_SEP_STR;
                        if (m_AdditionalInfo.Left(4) == key_path_lm)
                        {
                            m_AdditionalInfo = m_AdditionalInfo.Right(m_AdditionalInfo.GetLength() - 4);
                        }
                        else
                        {
                            key_path_lm = SZ_MBN_MACHINE SZ_MBN_SEP_STR;
                            if (m_AdditionalInfo.Left(3) == key_path_lm)
                            {
                                m_AdditionalInfo = m_AdditionalInfo.Right(m_AdditionalInfo.GetLength() - 3);
                            }
                        }
                    }

                    csOurFileName = csOurFileName + _T("_") + GimmieValidFilenameFromString(m_AdditionalInfo);

                    // add on other things...
                    str.Format(str1, csOurFileName);
                }
                else
                {
                    str.Format(str1, _T("1"));
                }
            }
            else
            {
                str.LoadString(m_defaultID);
            }
        }
        else
        {
		    str.LoadString(m_defaultID);
        }
    }
	// set system disk letter to the string
	TCHAR sz[MAX_PATH];
	if (MAX_PATH >= GetSystemDirectory(sz, MAX_PATH))
	{
		str.SetAt(0, sz[0]);
		str.MakeLower();
	}
}

/////////////////////////////////////////////////////////////////////////////
// CChooseReadFileName property page
IMPLEMENT_DYNCREATE(CChooseReadFileName, CChooseFileNamePage)

CChooseReadFileName::CChooseReadFileName(UINT id,
											UINT defaultID,
											UINT extID,
											UINT filterID,
											CString * pOutFileName,
                                            CString csAdditionalInfo
											)
	: CChooseFileNamePage(id, defaultID, extID, filterID, pOutFileName, csAdditionalInfo)
{
}

BEGIN_MESSAGE_MAP(CChooseReadFileName, CChooseFileNamePage)
	//{{AFX_MSG_MAP(CChooseReadFileName)
	ON_BN_CLICKED(IDC_BROWSE_BTN, OnBrowseBtn)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

BOOL
CChooseReadFileName::OnInitDialog()
{
	GetDefaultFileName(m_FileName);
	// check if this default file exists
	if (!PathFileExists(m_FileName))
	{
		// try to find first file with this extension
		CString find_str = m_FileName;
		WIN32_FIND_DATA find_data;
		PathRemoveFileSpec(find_str.GetBuffer(MAX_PATH));
		find_str.ReleaseBuffer();
		find_str += _T("*");
		find_str += ext;
		HANDLE hFind = FindFirstFile(find_str, &find_data);
		if (	hFind != INVALID_HANDLE_VALUE 
			&& (find_data.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0
			)
		{
			PathRemoveFileSpec(m_FileName.GetBuffer(MAX_PATH));
			m_FileName.ReleaseBuffer();
			m_FileName += find_data.cFileName;
			FindClose(hFind);
		}
		else
		{
			// if nothing found, just attach *.exe to the path
			// it will prevent user from just clicking Next
			m_FileName = find_str;
		}
	}
	return CChooseFileNamePage::OnInitDialog();
}

LRESULT
CChooseReadFileName::OnWizardNext()
{
	LRESULT id = 0;
	CString buf;

	UpdateData();
	// check if this file exists
	if (	!PathFileExists(m_FileName) 
		&&	!PathIsDirectory(m_FileName)
		)
	{
		// try with default extension if it is just filename
		CString str = m_FileName;
		LPTSTR p = PathFindExtension(str);
		if (p != NULL && *p == 0)
		{
			str += ext;
			if (PathFileExists(str))
			{
				m_FileName = str;
				goto DoNext;
			}
		}
		AfxFormatString1(buf, IDS_FILE_DOES_NOT_EXIST, m_FileName);
		AfxMessageBox(buf, MB_OK);
		id = 1;
	}
	else if (PathIsDirectory(m_FileName))
	{
		AfxFormatString1(buf, IDS_FILE_IS_DIRECTORY, m_FileName);
		AfxMessageBox(buf, MB_OK);
		if (m_FileName.Right(1) != L'\\')
			m_FileName += _T("\\");
		id = 1;
	}
DoNext:
	return DoWizardNext(id);
}

void CChooseReadFileName::OnBrowseBtn() 
{
	CString strFile, strPath;
	GetDlgItemText(IDC_FILE_NAME, m_FileName);

	if (!PathFileExists(m_FileName))
	{
		int n = m_FileName.ReverseFind(_T('\\'));
		if (n != -1)
		{
			strPath = m_FileName.Left(n);
			if (!PathFileExists(strPath))
			{
				strPath.Empty();
				strFile = m_FileName.Right(m_FileName.GetLength() - n - 1);
			}
			else if (PathIsDirectory(strPath))
			{
				strFile = m_FileName.Right(m_FileName.GetLength() - n - 1);
			}
		}
		else
			strFile = m_FileName;
	} 
	else if (PathIsDirectory(m_FileName)) 
	{
		strPath = m_FileName;
	}
	else
	{
		// split filename and path
		strPath = m_FileName;
		PathRemoveFileSpec(strPath.GetBuffer(0));
		strPath.ReleaseBuffer();
		strFile = PathFindFileName(m_FileName);
	}
	CChooseFileNamePage::Browse(strPath, strFile);
}

/////////////////////////////////////////////////////////////////////////////
// CChooseWriteFileName

IMPLEMENT_DYNCREATE(CChooseWriteFileName, CChooseFileNamePage)

CChooseWriteFileName::CChooseWriteFileName(UINT id,
											UINT defaultID,
											UINT extID,
											UINT filterID,
											CString * pOutFileName,
                                            CString csAdditionalInfo
											)
	: CChooseFileNamePage(id, defaultID, extID, filterID, pOutFileName, csAdditionalInfo)
{
}

BEGIN_MESSAGE_MAP(CChooseWriteFileName, CChooseFileNamePage)
	//{{AFX_MSG_MAP(CChooseWriteFileName)
	ON_BN_CLICKED(IDC_BROWSE_BTN, OnBrowseBtn)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

BOOL
CChooseWriteFileName::OnInitDialog()
{
	GetDefaultFileName(m_FileName);
	return CChooseFileNamePage::OnInitDialog();
}

LRESULT 
CChooseWriteFileName::OnWizardNext()
{
	LRESULT id = 0;
	UpdateData();
	CString fileName = m_FileName, strPathOnly;
	if (PathIsURL(fileName))
	{
		// we cannot use URLs
		id = 1;
		goto ExitPoint;
	}
	if (PathIsUNC(fileName))
	{
		if (PathIsUNCServer(fileName))
		{
			// path is incomplete
			id = 1;
			goto ExitPoint;
		}
		if (PathIsUNCServerShare(fileName))
		{
			// path is incomplete
			id = 1;
			goto ExitPoint;
		}
	}
	// If it is not an UNC, then make sure we have absolute path
	else if (PathIsRelative(fileName))
	{
		// We will make path from default drive root, 
		// not from current directory
		CString path;
		if (0 != GetCurrentDirectory(MAX_PATH, path.GetBuffer(MAX_PATH)))
		{
			TCHAR szRoot[5];
			fileName = PathBuildRoot(szRoot, PathGetDriveNumber(path));
			PathAppend(fileName.GetBuffer(MAX_PATH), m_FileName);
			fileName.ReleaseBuffer();
		}
		else
			ASSERT(FALSE);
	}

	// Check if we already have file with this name
	if (PathFileExists(fileName))
	{
		// if it is directory, do nothing, file spec is incomplete
		if (PathIsDirectory(fileName))
			id = 1;
		else
		{
			if (!m_DoReplaceFile)
				id = AnswerIsYes(IDS_REPLACE_FILE, fileName) ? 0 : 1;
		}
		goto ExitPoint;
	}

	// File does not exists
	//
	// we should check, if target directory exists
	strPathOnly = fileName;
	if (strPathOnly.Right(1) != _T('\\'))
	{
		if (PathRemoveFileSpec(strPathOnly.GetBuffer(MAX_PATH)))
		{
			if (PathIsUNCServerShare(strPathOnly))
			{
				// check if we have write access to this
				if (GetFileAttributes(strPathOnly) & FILE_ATTRIBUTE_READONLY)
				{
					id = 1; 
					goto ExitPoint;
				}
			}
			if (!PathIsDirectory(strPathOnly))
			{
				id = AnswerIsYes(IDS_ASK_CREATE_DIR, strPathOnly) ? 0 : 1;
				goto ExitPoint;
			}
		}
		strPathOnly.ReleaseBuffer();
		// If user entered filename with dot only (qqqq.) it means
		// that no extension should be used
		if (fileName.Right(1) == _T("."))
		{
			// remove this dot and check if this file exists
			fileName.ReleaseBuffer(fileName.GetLength() - 1);
			if (PathIsDirectory(fileName))
			{
				id = 1;
			}
			else if (PathFileExists(fileName))
			{
				id = AnswerIsYes(IDS_REPLACE_FILE, fileName) ? 0 : 1;
			}
			goto ExitPoint;
		}
	}
	else
	{
		// not clear, what to do with this
		id = 1;
		goto ExitPoint;
	}
	// It could be just a file name, without extension, try
	// with default extension now
	if (PathFindExtension(fileName) == NULL)
	{
		fileName += ext;
		if (PathIsDirectory(fileName))
		{
			id = 1;
		}
		else if (PathFileExists(fileName))
		{
			id = AnswerIsYes(IDS_REPLACE_FILE, fileName) ? 0 : 1;
		}
		goto ExitPoint;
	}

ExitPoint:

	fileName.MakeLower();
	m_FileName = fileName;
	// prepare to go to the next page
	return DoWizardNext(id);
}

// I try to start FileOpen dialog in some reasonable directory
// 
void CChooseWriteFileName::OnBrowseBtn()
{
	CString strPath, strFile;
	UpdateData();
	strPath = m_FileName;
	if (!PathIsDirectory(strPath))
	{
		LPTSTR pPath = strPath.GetBuffer(strPath.GetLength());
		if (PathRemoveFileSpec(pPath))
		{
			// check if path part of filename exists
			if (PathIsDirectory(pPath))
			{
				// we will use non-path part of spec as a filename
				strFile = PathFindFileName(m_FileName);
			}
			else
			{
				// it is wrong path, use default one
				// TODO: actually I need to take from filespec all existent
				// chunks of path and filename, for example c:\aa\bb\cc\dd.txt,
				// if c:\aa\bb exists, then strPath should be set to c:\aa\bb,
				// and strFile to dd.txt
				strPath.Empty();
			}
		}
		else
		{
			// it is filename only
			strFile = m_FileName;
			strPath.Empty();
		}
		strPath.ReleaseBuffer();
	}
	CChooseFileNamePage::Browse(strPath, strFile);
}

/////////////////////////////////////////////////////////////////////////////
// CChooseRespFile property page

IMPLEMENT_DYNCREATE(CChooseRespFile, CChooseFileNamePage)

CChooseRespFile::CChooseRespFile(CCertificate * pCert) 
	: CChooseReadFileName(CChooseRespFile::IDD,
								 IDS_RESP_FILE_DEFAULT,
								 IDS_RESP_FILE_EXT,
								 IDS_RESP_FILE_FILTER,
								 &pCert->m_RespFileName,
                                 pCert->m_WebSiteInstanceName
                                 ),
	m_pCert(pCert)
{
	//{{AFX_DATA_INIT(CChooseRespFile)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}

CChooseRespFile::~CChooseRespFile()
{
}

void CChooseRespFile::FileNameChanged()
{
	// we should remove any error messages now
	SetDlgItemText(IDC_ERROR_MSG, _T(""));
	GetDlgItem(IDC_ERROR_MSG)->InvalidateRect(NULL, TRUE);
	GetDlgItem(IDC_ERROR_MSG)->UpdateWindow();
}

void CChooseRespFile::DoDataExchange(CDataExchange* pDX)
{
	CChooseReadFileName::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CChooseRespFile)
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CChooseRespFile, CChooseReadFileName)
	//{{AFX_MSG_MAP(CChooseRespFile)
    ON_WM_CTLCOLOR()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CChooseRespFile message handlers

HBRUSH 
CChooseRespFile::OnCtlColor(
    IN CDC * pDC, 
    IN CWnd * pWnd, 
    IN UINT nCtlColor
    )
{
	if (pWnd->GetDlgCtrlID() == IDC_ERROR_MSG)
	{
		//
		// Default processing...
		//
		return CPropertyPage::OnCtlColor(pDC, pWnd, nCtlColor);
	}
	else
		return CIISWizardPage::OnCtlColor(pDC, pWnd, nCtlColor);
}

LRESULT CChooseRespFile::OnWizardNext() 
{
	LRESULT id = 1;
	// Parent class will check all about files
	if (1 != CChooseReadFileName::OnWizardNext())
	{
		m_pCert->m_RespFileName = m_FileName;
		if (m_pCert->GetResponseCert() == NULL)
		{
			CString strInstanceName;
			CString str;
			// it is possible, that this is wrong response file
			// we will try to inform user, for which site this response
			// file was created
			if (m_pCert->FindInstanceNameForResponse(strInstanceName))
			{
				AfxFormatString1(str, IDS_CERTKEY_MISMATCH_ERROR1, strInstanceName);
			}
			// it is possible that this certificate response file already have been processed
			// in this case it should be in MY store
			else if (m_pCert->IsResponseInstalled(strInstanceName))
			{
				if (!strInstanceName.IsEmpty())
					AfxFormatString1(str, 
						IDS_CERTKEY_ALREADY_INSTALLED_WHERE, strInstanceName);
				else
					str.LoadString(IDS_CERTKEY_ALREADY_INSTALLED);
			}
			else
			{
				// request probably was canceled
				str.LoadString(IDS_CERTKEY_MISMATCH_ERROR2);
			}
			SetDlgItemText(IDC_ERROR_MSG, str);
			SetWizardButtons(PSWIZB_BACK);
		}
		else
			id = IDD_PAGE_NEXT;
	}
	return id;
}

LRESULT 
CChooseRespFile::OnWizardBack()
{
	return IDD_PAGE_PREV;
}

/////////////////////////////////////////////////////////////////////////////
// CChooseReqFile property page

IMPLEMENT_DYNCREATE(CChooseReqFile, CChooseWriteFileName)

CChooseReqFile::CChooseReqFile(CCertificate * pCert) 
	: CChooseWriteFileName(CChooseReqFile::IDD,
								 IDS_REQ_FILE_DEFAULT,
								 IDS_REQ_FILE_EXT,
								 IDS_REQ_FILE_FILTER,
								 &pCert->m_ReqFileName,
                                 pCert->m_WebSiteInstanceName
                                 ),
	m_pCert(pCert)
{
	//{{AFX_DATA_INIT(CChooseRespFile)
	//}}AFX_DATA_INIT
}

CChooseReqFile::~CChooseReqFile()
{
}

void CChooseReqFile::DoDataExchange(CDataExchange* pDX)
{
	CChooseWriteFileName::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CChooseRespFile)
	//}}AFX_DATA_MAP
}

LRESULT 
CChooseReqFile::OnWizardBack()
{
	return IDD_PAGE_PREV;
}

LRESULT 
CChooseReqFile::OnWizardNext()
{
	if (CChooseWriteFileName::OnWizardNext() != 1)
		return IDD_PAGE_NEXT;
	return 1;
}

BEGIN_MESSAGE_MAP(CChooseReqFile, CChooseWriteFileName)
	//{{AFX_MSG_MAP(CChooseReqFile)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CChooseReqFile property page

IMPLEMENT_DYNCREATE(CChooseReqFileRenew, CChooseWriteFileName)

CChooseReqFileRenew::CChooseReqFileRenew(CCertificate * pCert) 
	: CChooseWriteFileName(CChooseReqFileRenew::IDD,
								 IDS_REQ_FILE_DEFAULT,
								 IDS_REQ_FILE_EXT,
								 IDS_REQ_FILE_FILTER,
								 &pCert->m_ReqFileName,
                                 pCert->m_WebSiteInstanceName
                                 ),
	m_pCert(pCert)
{
	//{{AFX_DATA_INIT(CChooseRespFile)
	//}}AFX_DATA_INIT
}

CChooseReqFileRenew::~CChooseReqFileRenew()
{
}

void CChooseReqFileRenew::DoDataExchange(CDataExchange* pDX)
{
	CChooseWriteFileName::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CChooseRespFile)
	//}}AFX_DATA_MAP
}

LRESULT 
CChooseReqFileRenew::OnWizardBack()
{
	return IDD_PAGE_PREV;
}

LRESULT 
CChooseReqFileRenew::OnWizardNext()
{
	if (CChooseWriteFileName::OnWizardNext() != 1)
		return IDD_PAGE_NEXT;
	return 1;
}

BEGIN_MESSAGE_MAP(CChooseReqFileRenew, CChooseWriteFileName)
	//{{AFX_MSG_MAP(CChooseReqFileRenew)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CChooseReqFileRenew message handlers



/////////////////////////////////////////////////////////////////////////////
// CChooseKeyFile property page

IMPLEMENT_DYNCREATE(CChooseKeyFile, CChooseReadFileName)

CChooseKeyFile::CChooseKeyFile(CCertificate * pCert) 
	: CChooseReadFileName(CChooseKeyFile::IDD,
								 IDS_KEY_FILE_DEFAULT,
								 IDS_KEY_FILE_EXT,
								 IDS_KEY_FILE_FILTER,
								 &pCert->m_KeyFileName,
                                 pCert->m_WebSiteInstanceName),
	m_pCert(pCert)
{
}

CChooseKeyFile::~CChooseKeyFile()
{
}

void CChooseKeyFile::DoDataExchange(CDataExchange* pDX)
{
	CChooseReadFileName::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CChooseRespFile)
	//}}AFX_DATA_MAP
}

LRESULT 
CChooseKeyFile::OnWizardBack()
{
	return IDD_PAGE_PREV;
}

LRESULT 
CChooseKeyFile::OnWizardNext()
{
	CString strFileName = m_pCert->m_KeyFileName;
	if (CChooseReadFileName::OnWizardNext() != 1)
	{
		// if file name was changed then probably password is wrong now
		// and if cert context was imported before -- it is also invalid
		//
		if (m_pCert->m_KeyFileName.CompareNoCase(strFileName))
		{
			m_pCert->m_KeyPassword.Empty();
			m_pCert->DeleteKeyRingCert();
		}
		return IDD_PAGE_NEXT;
	}
	return 1;
}

BEGIN_MESSAGE_MAP(CChooseKeyFile, CChooseReadFileName)
	//{{AFX_MSG_MAP(CChooseKeyFile)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CChooseImportPFXFile property page

IMPLEMENT_DYNCREATE(CChooseImportPFXFile, CChooseReadFileName)

CChooseImportPFXFile::CChooseImportPFXFile(CCertificate * pCert) 
	: CChooseReadFileName(CChooseImportPFXFile::IDD,
								 IDS_PFX_FILE_DEFAULT,
								 IDS_PFX_FILE_EXT,
								 IDS_PFX_FILE_FILTER,
                                 &pCert->m_KeyFileName,
                                 pCert->m_WebSiteInstanceName),
	m_pCert(pCert)
{
    //{{AFX_DATA_INIT(CChooseImportPFXFile)
    m_MarkAsExportable =  FALSE;
    //}}AFX_DATA_INIT
}

CChooseImportPFXFile::~CChooseImportPFXFile()
{
}

void CChooseImportPFXFile::DoDataExchange(CDataExchange* pDX)
{
	CChooseReadFileName::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CChooseImportPFXFile)
    DDX_Check(pDX, IDC_MARK_AS_EXPORTABLE, m_MarkAsExportable);
	//}}AFX_DATA_MAP
}

LRESULT 
CChooseImportPFXFile::OnWizardBack()
{
	return IDD_PAGE_PREV;
}

LRESULT 
CChooseImportPFXFile::OnWizardNext()
{
    m_pCert->m_MarkAsExportable = m_MarkAsExportable;

	CString strFileName = m_pCert->m_KeyFileName;
	if (CChooseReadFileName::OnWizardNext() != 1)
	{
        /*
		// if file name was changed then probably password is wrong now
		// and if cert context was imported before -- it is also invalid
		//
		if (m_pCert->m_KeyFileName.CompareNoCase(strFileName))
		{
			m_pCert->m_KeyPassword.Empty();
			m_pCert->DeleteKeyRingCert();
		}
        */
		return IDD_PAGE_NEXT;
	}
	return 1;
}

void CChooseImportPFXFile::OnExportable() 
{
   UpdateData();
}


BEGIN_MESSAGE_MAP(CChooseImportPFXFile, CChooseReadFileName)
	//{{AFX_MSG_MAP(CChooseImportPFXFile)
    ON_BN_CLICKED(IDC_MARK_AS_EXPORTABLE, OnExportable)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CChooseExportPFXFile property page

IMPLEMENT_DYNCREATE(CChooseExportPFXFile, CChooseWriteFileName)

CChooseExportPFXFile::CChooseExportPFXFile(CCertificate * pCert) 
	: CChooseWriteFileName(CChooseExportPFXFile::IDD,
								 IDS_PFX_FILE_DEFAULT,
								 IDS_PFX_FILE_EXT,
								 IDS_PFX_FILE_FILTER,
								 &pCert->m_KeyFileName,
                                 pCert->m_WebSiteInstanceName
                                 ),
	m_pCert(pCert)
{
	//{{AFX_DATA_INIT(CChooseExportPFXFile)
	//}}AFX_DATA_INIT
}

CChooseExportPFXFile::~CChooseExportPFXFile()
{
}

void CChooseExportPFXFile::DoDataExchange(CDataExchange* pDX)
{
	CChooseWriteFileName::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CChooseExportPFXFile)
	//}}AFX_DATA_MAP
}

LRESULT 
CChooseExportPFXFile::OnWizardBack()
{
	return IDD_PAGE_PREV;
}

LRESULT 
CChooseExportPFXFile::OnWizardNext()
{
	if (CChooseWriteFileName::OnWizardNext() != 1)
		return IDD_PAGE_NEXT;
	return 1;
}

BEGIN_MESSAGE_MAP(CChooseExportPFXFile, CChooseWriteFileName)
	//{{AFX_MSG_MAP(CChooseExportPFXFile)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\certwiz\chooseserverpages.cpp ===
// ChooseServerPages.cpp: implementation of the CChooseServerPages class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "certwiz.h"
#include "Certificat.h"
#include "ChooseServerPages.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

/////////////////////////////////////////////////////////////////////////////
// CChooseServerPages property page

IMPLEMENT_DYNCREATE(CChooseServerPages, CIISWizardPage)

CChooseServerPages::CChooseServerPages(CCertificate * pCert) 
	: CIISWizardPage(CChooseServerPages::IDD, IDS_CERTWIZ, TRUE),
	m_pCert(pCert)
{
	//{{AFX_DATA_INIT(CChooseServerPages)
	m_ServerName = _T("");
    m_UserName = _T("");
    m_UserPassword = _T("");
	//}}AFX_DATA_INIT
}

CChooseServerPages::~CChooseServerPages()
{
}

void CChooseServerPages::DoDataExchange(CDataExchange* pDX)
{
	CIISWizardPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CChooseServerPages)
	DDX_Text(pDX, IDC_SERVER_NAME, m_ServerName);
    DDX_Text(pDX, IDC_USER_NAME, m_UserName);
    DDX_Text(pDX, IDC_USER_PASSWORD, m_UserPassword);
	DDV_MaxChars(pDX, m_ServerName, 64);
	//}}AFX_DATA_MAP
}

LRESULT 
CChooseServerPages::OnWizardBack()
/*++
Routine Description:
    Prev button handler

Arguments:
    None

Return Value:
	0 to automatically advance to the prev page;
	1 to prevent the page from changing. 
	To jump to a page other than the prev one, 
	return the identifier of the dialog to be displayed.
--*/
{
	return IDD_PAGE_PREV;
}

LRESULT 
CChooseServerPages::OnWizardNext()
{
	UpdateData(TRUE);
	if (0 != m_ServerName.Compare(m_pCert->m_MachineName_Remote))
	{
		m_pCert->m_MachineName_Remote = m_ServerName;
	}
    m_pCert->m_UserName_Remote = m_UserName;
    m_pCert->m_UserPassword_Remote = m_UserPassword;

	return IDD_PAGE_NEXT;
}

BOOL 
CChooseServerPages::OnSetActive() 
{
	ASSERT(m_pCert != NULL);
	m_ServerName = m_pCert->m_MachineName_Remote;
    m_UserName = m_pCert->m_UserName_Remote;
    m_UserPassword = m_pCert->m_UserPassword_Remote;
	UpdateData(FALSE);
	SetWizardButtons(m_ServerName.IsEmpty() ?
			PSWIZB_BACK : PSWIZB_BACK | PSWIZB_NEXT);
	return CIISWizardPage::OnSetActive();
}

BOOL
CChooseServerPages::OnKillActive()
{
	UpdateData();
	m_pCert->m_MachineName_Remote = m_ServerName;
    m_pCert->m_UserName_Remote = m_UserName;
    m_pCert->m_UserPassword_Remote = m_UserPassword;
	return CIISWizardPage::OnKillActive();
}

BEGIN_MESSAGE_MAP(CChooseServerPages, CIISWizardPage)
	//{{AFX_MSG_MAP(CChooseServerPages)
	ON_EN_CHANGE(IDC_SERVER_NAME, OnEditchangeServerName)
    ON_EN_CHANGE(IDC_USER_NAME, OnEditchangeUserName)
    ON_EN_CHANGE(IDC_USER_PASSWORD, OnEditchangeUserPassword)
    ON_BN_CLICKED(IDC_BROWSE_BTN, OnBrowseForMachine)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CSiteNamePage message handlers

void CChooseServerPages::OnEditchangeServerName() 
{
	UpdateData(TRUE);	
	SetWizardButtons(m_ServerName.IsEmpty() ? 
			PSWIZB_BACK : PSWIZB_BACK | PSWIZB_NEXT);
	CString str;
	SetDlgItemText(IDC_ERROR_TEXT, str);
}


void CChooseServerPages::OnEditchangeUserName() 
{
	UpdateData(TRUE);	
	SetWizardButtons(m_ServerName.IsEmpty() ? 
			PSWIZB_BACK : PSWIZB_BACK | PSWIZB_NEXT);
	CString str;
	SetDlgItemText(IDC_ERROR_TEXT, str);
}


void CChooseServerPages::OnEditchangeUserPassword() 
{
	UpdateData(TRUE);	
	SetWizardButtons(m_ServerName.IsEmpty() ? 
			PSWIZB_BACK : PSWIZB_BACK | PSWIZB_NEXT);
	CString str;
	SetDlgItemText(IDC_ERROR_TEXT, str);
}

void CChooseServerPages::OnBrowseForMachine()
{
    CGetComputer picker;
    if (picker.GetComputer(m_hWnd))
    {
        SetDlgItemText(IDC_SERVER_NAME, picker.m_strComputerName);
    }

    return;
}


/////////////////////////////////////////////////////////////////////////////
// CChooseServerPages property page

IMPLEMENT_DYNCREATE(CChooseServerPagesTo, CIISWizardPage)

CChooseServerPagesTo::CChooseServerPagesTo(CCertificate * pCert) 
	: CIISWizardPage(CChooseServerPagesTo::IDD, IDS_CERTWIZ, TRUE),
	m_pCert(pCert)
{
	//{{AFX_DATA_INIT(CChooseServerPagesTo)
	m_ServerName = _T("");
    m_UserName = _T("");
    m_UserPassword = _T("");
	//}}AFX_DATA_INIT
}

CChooseServerPagesTo::~CChooseServerPagesTo()
{
}

void CChooseServerPagesTo::DoDataExchange(CDataExchange* pDX)
{
	CIISWizardPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CChooseServerPagesTo)
	DDX_Text(pDX, IDC_SERVER_NAME, m_ServerName);
    DDX_Text(pDX, IDC_USER_NAME, m_UserName);
    DDX_Text(pDX, IDC_USER_PASSWORD, m_UserPassword);
	DDV_MaxChars(pDX, m_ServerName, 64);
	//}}AFX_DATA_MAP
}

LRESULT 
CChooseServerPagesTo::OnWizardBack()
/*++
Routine Description:
    Prev button handler

Arguments:
    None

Return Value:
	0 to automatically advance to the prev page;
	1 to prevent the page from changing. 
	To jump to a page other than the prev one, 
	return the identifier of the dialog to be displayed.
--*/
{
	return IDD_PAGE_PREV;
}

LRESULT 
CChooseServerPagesTo::OnWizardNext()
{
	UpdateData(TRUE);
	if (0 != m_ServerName.Compare(m_pCert->m_MachineName_Remote))
	{
		m_pCert->m_MachineName_Remote = m_ServerName;
	}
    m_pCert->m_UserName_Remote = m_UserName;
    m_pCert->m_UserPassword_Remote = m_UserPassword;

	return IDD_PAGE_NEXT;
}

BOOL 
CChooseServerPagesTo::OnSetActive() 
{
	ASSERT(m_pCert != NULL);
	m_ServerName = m_pCert->m_MachineName_Remote;
    m_UserName = m_pCert->m_UserName_Remote;
    m_UserPassword = m_pCert->m_UserPassword_Remote;
	UpdateData(FALSE);
	SetWizardButtons(m_ServerName.IsEmpty() ?
			PSWIZB_BACK : PSWIZB_BACK | PSWIZB_NEXT);
	return CIISWizardPage::OnSetActive();
}

BOOL
CChooseServerPagesTo::OnKillActive()
{
	UpdateData();
	m_pCert->m_MachineName_Remote = m_ServerName;
    m_pCert->m_UserName_Remote = m_UserName;
    m_pCert->m_UserPassword_Remote = m_UserPassword;
	return CIISWizardPage::OnKillActive();
}

BEGIN_MESSAGE_MAP(CChooseServerPagesTo, CIISWizardPage)
	//{{AFX_MSG_MAP(CChooseServerPagesTo)
	ON_EN_CHANGE(IDC_SERVER_NAME, OnEditchangeServerName)
    ON_EN_CHANGE(IDC_USER_NAME, OnEditchangeUserName)
    ON_EN_CHANGE(IDC_USER_PASSWORD, OnEditchangeUserPassword)
    ON_BN_CLICKED(IDC_BROWSE_BTN, OnBrowseForMachine)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CSiteNamePage message handlers

void CChooseServerPagesTo::OnEditchangeServerName() 
{
	UpdateData(TRUE);	
	SetWizardButtons(m_ServerName.IsEmpty() ? 
			PSWIZB_BACK : PSWIZB_BACK | PSWIZB_NEXT);
	CString str;
	SetDlgItemText(IDC_ERROR_TEXT, str);
}


void CChooseServerPagesTo::OnEditchangeUserName() 
{
	UpdateData(TRUE);	
	SetWizardButtons(m_ServerName.IsEmpty() ? 
			PSWIZB_BACK : PSWIZB_BACK | PSWIZB_NEXT);
	CString str;
	SetDlgItemText(IDC_ERROR_TEXT, str);
}


void CChooseServerPagesTo::OnEditchangeUserPassword() 
{
	UpdateData(TRUE);	
	SetWizardButtons(m_ServerName.IsEmpty() ? 
			PSWIZB_BACK : PSWIZB_BACK | PSWIZB_NEXT);
	CString str;
	SetDlgItemText(IDC_ERROR_TEXT, str);
}

void CChooseServerPagesTo::OnBrowseForMachine()
{
    CGetComputer picker;
    if (picker.GetComputer(m_hWnd))
    {
        SetDlgItemText(IDC_SERVER_NAME, picker.m_strComputerName);
    }
   
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\certwiz\chooseonlinepage.h ===
#if !defined(AFX_CHOOSEONLINEPAGE_H__5760F32A_144F_11D2_8A1E_000000000000__INCLUDED_)
#define AFX_CHOOSEONLINEPAGE_H__5760F32A_144F_11D2_8A1E_000000000000__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// ChooseOnlinePage.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CChooseCAPage dialog
class CCertificate;

class CChooseOnlinePage : public CIISWizardPage
{
	DECLARE_DYNCREATE(CChooseOnlinePage)

// Construction
public:
	CChooseOnlinePage(CCertificate * pCert = NULL);
	~CChooseOnlinePage();

	enum
	{
		IDD_PAGE_NEXT = IDD_PAGE_WIZ_ONLINE_DUMP,
		IDD_PAGE_PREV_NEW = IDD_PAGE_WIZ_GEO_INFO,
		IDD_PAGE_PREV_RENEW = IDD_PAGE_WIZ_CHOOSE_CATYPE
	};
// Dialog Data
	//{{AFX_DATA(CChooseCAPage)
	enum { IDD = IDD_PAGE_WIZ_CHOOSE_ONLINE };
	int		m_CAIndex;
	//}}AFX_DATA
	CCertificate * m_pCert;

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CChooseOnlinePage)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	public:
	virtual LRESULT OnWizardNext();
	virtual LRESULT OnWizardBack();
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CChooseOnlinePage)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_CHOOSEONLINEPAGE_H__5760F32A_144F_11D2_8A1E_000000000000__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\certwiz\choosefilename.h ===
#if !defined(_CHOOSEFILENAMEPAGE_H)
#define _CHOOSEFILENAMEPAGE_H

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// ChooseFileNamePage.h : header file
//
#include "Certificat.h"

/////////////////////////////////////////////////////////////////////////////
// CChooseFileNamePage dialog
//class CCertificate;

class CChooseFileNamePage : public CIISWizardPage
{
	DECLARE_DYNCREATE(CChooseFileNamePage)

// Construction
public:
	CChooseFileNamePage(	UINT id = 0, 
							   UINT defaultID = 0,
								UINT extID = 0,
								UINT filterID = 0,
								CString * pOutFileName = NULL,
                                CString  csAdditionalInfo = _T("")
								);
	~CChooseFileNamePage();

// Dialog Data
	//{{AFX_DATA(CChooseCAPage)
	CString	m_FileName;
	//}}AFX_DATA
	BOOL m_DoReplaceFile;
	UINT m_id, m_defaultID;
	CString ext, filter;
	CString * m_pOutFileName;
    CString m_AdditionalInfo;

// Overrides
	virtual void FileNameChanged() 
	{
	}
	virtual BOOL IsReadFileDlg()
	{
		ASSERT(FALSE);
		return FALSE;
	}
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CChooseCAPage)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	public:
	virtual LRESULT OnWizardNext()
		{
			ASSERT(FALSE);
			return 1;
		}
	virtual LRESULT OnWizardBack();
	virtual BOOL OnSetActive();
	//}}AFX_VIRTUAL

// Implementation
protected:
	void GetDefaultFileName(CString& str);
	void Browse(CString& strPath, CString& strFile);
	LRESULT DoWizardNext(LRESULT id);
	// Generated message map functions
	//{{AFX_MSG(CChooseCAPage)
	afx_msg void OnBrowseBtn();
	virtual BOOL OnInitDialog();
	afx_msg void OnChangeFileName();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

class CChooseReadFileName : public CChooseFileNamePage
{
	DECLARE_DYNCREATE(CChooseReadFileName)
// Construction
public:
	CChooseReadFileName(	UINT id = 0, 
							   UINT defaultID = 0,
								UINT extID = 0,
								UINT filterID = 0,
								CString * pOutFileName = NULL,
                                CString  csAdditionalInfo = _T("")
								);
	~CChooseReadFileName() 
	{
	}
// Overrides
	virtual void FileNameChanged() 
	{
	}
	virtual BOOL IsReadFileDlg()
	{
		return TRUE;
	}
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CChooseCAPage)
	protected:
//	virtual void DoDataExchange(CDataExchange* pDX)
//		{
//			CChooseFileNamePage::DoDataExchange(pDX);
//		}
	public:
	virtual LRESULT OnWizardNext();
	virtual LRESULT OnWizardBack() {return 1;}
	virtual BOOL OnSetActive()
		{
			return CChooseFileNamePage::OnSetActive();
		}
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CChooseCAPage)
	afx_msg void OnBrowseBtn();
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

class CChooseWriteFileName : public CChooseFileNamePage
{
	DECLARE_DYNCREATE(CChooseWriteFileName)
// Construction
public:
	CChooseWriteFileName(UINT id = 0, 
							   UINT defaultID = 0,
								UINT extID = 0,
								UINT filterID = 0,
								CString * pOutFileName = NULL,
                                CString  csAdditionalInfo = _T("")
								);
	~CChooseWriteFileName() {}
// Overrides
	virtual void FileNameChanged() {}
	virtual BOOL IsReadFileDlg()
	{
		return FALSE;
	}
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CChooseCAPage)
	protected:
//	virtual void DoDataExchange(CDataExchange* pDX)
//		{
//			CChooseFileNamePage::DoDataExchange(pDX);
//		}
	public:
	virtual LRESULT OnWizardNext();
	virtual LRESULT OnWizardBack() {return 1;}
	virtual BOOL OnSetActive()
		{
			return CChooseFileNamePage::OnSetActive();
		}
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CChooseCAPage)
	afx_msg void OnBrowseBtn();
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

class CChooseRespFile : public CChooseReadFileName
{
	DECLARE_DYNCREATE(CChooseRespFile)

// Construction
public:
	CChooseRespFile(CCertificate * pCert = NULL);
	~CChooseRespFile();

	enum
	{
		IDD_PAGE_PREV	=	IDD_PAGE_WIZ_PENDING_WHAT_TODO,
		IDD_PAGE_NEXT	= IDD_PAGE_WIZ_INSTALL_RESP,
	};
// Dialog Data
	//{{AFX_DATA(CChooseRespFile)
	enum { IDD = IDD_PAGE_WIZ_GETRESP_FILE };
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA
	CCertificate * m_pCert;


// Overrides
	virtual void FileNameChanged();
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CChooseRespFile)
	public:
	virtual LRESULT OnWizardNext();
	virtual LRESULT OnWizardBack();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CChooseRespFile)
    afx_msg HBRUSH OnCtlColor(CDC * pDC, CWnd * pWnd, UINT nCtlColor);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

class CChooseReqFile : public CChooseWriteFileName
{
	DECLARE_DYNCREATE(CChooseReqFile)

// Construction
public:
	CChooseReqFile(CCertificate * pCert = NULL);
	~CChooseReqFile();

	enum
	{
		IDD_PAGE_PREV = IDD_PAGE_WIZ_GEO_INFO,
		IDD_PAGE_NEXT = IDD_PAGE_WIZ_REQUEST_DUMP
	};
// Dialog Data
	//{{AFX_DATA(CChooseReqFile)
	enum { IDD = IDD_PAGE_WIZ_CHOOSE_FILENAME };
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA
	CCertificate * m_pCert;


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CChooseReqFile)
	public:
	virtual LRESULT OnWizardNext();
	virtual LRESULT OnWizardBack();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CChooseReqFile)
		// NOTE: the ClassWizard will add member functions here
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

class CChooseReqFileRenew : public CChooseWriteFileName
{
	DECLARE_DYNCREATE(CChooseReqFileRenew)

// Construction
public:
	CChooseReqFileRenew(CCertificate * pCert = NULL);
	~CChooseReqFileRenew();

	enum
	{
		IDD_PAGE_PREV = IDD_PAGE_WIZ_CHOOSE_CATYPE,
		IDD_PAGE_NEXT = IDD_PAGE_WIZ_REQUEST_DUMP_RENEW
	};
// Dialog Data
	//{{AFX_DATA(CChooseReqFileRenew)
	enum { IDD = IDD_PAGE_WIZ_CHOOSE_FILENAME_RENEW };
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA
	CCertificate * m_pCert;


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CChooseReqFileRenew)
	public:
	virtual LRESULT OnWizardNext();
	virtual LRESULT OnWizardBack();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CChooseReqFileRenew)
		// NOTE: the ClassWizard will add member functions here
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

class CChooseKeyFile : public CChooseReadFileName
{
	DECLARE_DYNCREATE(CChooseKeyFile)

// Construction
public:
	CChooseKeyFile(CCertificate * pCert = NULL);
	~CChooseKeyFile();

	enum
	{
		IDD_PAGE_PREV	= IDD_PAGE_WIZ_GET_WHAT,
		IDD_PAGE_NEXT	= IDD_PAGE_WIZ_GET_PASSWORD,
	};
// Dialog Data
	//{{AFX_DATA(CChooseKeyFile)
	enum { IDD = IDD_PAGE_WIZ_GETKEY_FILE };
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA
	CCertificate * m_pCert;


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CChooseKeyFile)
	public:
	virtual LRESULT OnWizardNext();
	virtual LRESULT OnWizardBack();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CChooseKeyFile)
		// NOTE: the ClassWizard will add member functions here
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};


class CChooseImportPFXFile : public CChooseReadFileName
{
	DECLARE_DYNCREATE(CChooseImportPFXFile)

// Construction
public:
	CChooseImportPFXFile(CCertificate * pCert = NULL);
	~CChooseImportPFXFile();

	enum
	{
		IDD_PAGE_PREV	= IDD_PAGE_WIZ_GET_WHAT,
		IDD_PAGE_NEXT	= IDD_PAGE_WIZ_GET_IMPORT_PFX_PASSWORD,
	};
// Dialog Data
	//{{AFX_DATA(CChooseImportPFXFile)
	enum { IDD = IDD_PAGE_WIZ_GET_IMPORT_PFX_FILE };
    BOOL m_MarkAsExportable;
	//}}AFX_DATA
	CCertificate * m_pCert;
    

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CChooseImportPFXFile)
	public:
	virtual LRESULT OnWizardNext();
	virtual LRESULT OnWizardBack();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CChooseImportPFXFile)
		// NOTE: the ClassWizard will add member functions here
    afx_msg void OnExportable();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


class CChooseExportPFXFile : public CChooseWriteFileName
{
	DECLARE_DYNCREATE(CChooseExportPFXFile)

// Construction
public:
	CChooseExportPFXFile(CCertificate * pCert = NULL);
	~CChooseExportPFXFile();

	enum
	{
		IDD_PAGE_PREV = IDD_PAGE_WIZ_MANAGE_CERT,
		IDD_PAGE_NEXT = IDD_PAGE_WIZ_GET_EXPORT_PFX_PASSWORD,
	};
// Dialog Data
	//{{AFX_DATA(CChooseExportPFXFile)
	enum { IDD = IDD_PAGE_WIZ_GET_EXPORT_PFX_FILE };
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA
	CCertificate * m_pCert;


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CChooseExportPFXFile)
	public:
	virtual LRESULT OnWizardNext();
	virtual LRESULT OnWizardBack();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CChooseExportPFXFile)
		// NOTE: the ClassWizard will add member functions here
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};


//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(_CHOOSEFILENAMEPAGE_H)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\certwiz\chooseserversite.cpp ===
// ChooseServerSite.cpp : implementation file
//

#include "stdafx.h"
#include "certwiz.h"
#include "Certificat.h"
#include "CertUtil.h"
#include "ChooseServerSite.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define COL_SITE_INSTANCE     0
#define COL_SITE_DESC         1
#define COL_SITE_INSTANCE_WID 50
#define COL_SITE_DESC_WID     100

/////////////////////////////////////////////////////////////////////////////
// CChooseServerSite


CChooseServerSite::CChooseServerSite(BOOL bShowOnlyCertSites, CString& strSiteReturned,CCertificate * pCert,IN CWnd * pParent OPTIONAL) 
: CDialog(CChooseServerSite::IDD,pParent)
{
    m_ShowOnlyCertSites = bShowOnlyCertSites;
    m_strSiteReturned = strSiteReturned;
    m_pCert = pCert;
	//{{AFX_DATA_INIT(CChooseServerSite)
	//}}AFX_DATA_INIT
}

CChooseServerSite::~CChooseServerSite()
{
}

void CChooseServerSite::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CChooseServerSite)
	DDX_Control(pDX, IDC_SITE_LIST, m_ServerSiteList);
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CChooseServerSite, CDialog)
	//{{AFX_MSG_MAP(CChooseServerSite)
    ON_NOTIFY(NM_CLICK, IDC_SITE_LIST, OnClickSiteList)
    ON_NOTIFY(NM_DBLCLK, IDC_SITE_LIST, OnDblClickSiteList)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CChooseServerSite message handlers

BOOL CChooseServerSite::OnInitDialog()
{
	CDialog::OnInitDialog();
    HRESULT hr;
    CString MachineName_Remote;
    CString UserName_Remote;
    CString UserPassword_Remote;
    CMapStringToString MetabaseSiteKeyWithSiteDescValueList;
    CStringListEx strlDataPaths;

	CCertListCtrl* pControl = (CCertListCtrl *)CWnd::FromHandle(GetDlgItem(IDC_SITE_LIST)->m_hWnd);
	CRect rcControl;
	pControl->GetClientRect(&rcControl);

    // make the list have column headers
	CString str;
    str= _T("");

    str.LoadString(IDS_SITE_NUM_COLUMN);
	m_ServerSiteList.InsertColumn(COL_SITE_INSTANCE, str, LVCFMT_LEFT, COL_SITE_INSTANCE_WID);

	str.LoadString(IDS_WEB_SITE_COLUMN);
	m_ServerSiteList.InsertColumn(COL_SITE_DESC, str, LVCFMT_LEFT, rcControl.Width() - COL_SITE_INSTANCE_WID);

	m_ServerSiteList.AdjustStyle();

    // Use machine/username/userpassword
    // to connect to the machine
    // and enumerate all the sites on that machine.
    // return back a string1=string2 pair
    // string1 = /w3svc/1
    // string2 = "site description"

    // present a dialog so the user can choose which one they want...
    // m_ServerSiteInstance = /w3svc/1
    // m_ServerSiteDescription = "site description"

    MachineName_Remote = m_pCert->m_MachineName_Remote;
    UserName_Remote = m_pCert->m_UserName_Remote;
    UserPassword_Remote = m_pCert->m_UserPassword_Remote;

    if (m_ShowOnlyCertSites)
    {
        hr = EnumSitesWithCertInstalled(MachineName_Remote,UserName_Remote,UserPassword_Remote,&strlDataPaths);
    }
    else
    {
        hr = EnumSites(MachineName_Remote,UserName_Remote,UserPassword_Remote,&strlDataPaths);
    }

    if (strlDataPaths.IsEmpty())
    {
        //IISDebugOutput(_T("strlDataPaths IsEmpty()!!!!!!\n"));
    }
    else
    {
        POSITION pos;
        CString name;
        CString value = _T("");
        CString SiteInstance;

        int item = 0;
        LV_ITEMW lvi;

    	//
		// set up the fields in the list view item struct that don't change from item to item
		//
		memset(&lvi, 0, sizeof(LV_ITEMW));
		lvi.mask = LVIF_TEXT;

        // loop thru the list and display all the stuff on a dialog box...
        pos = strlDataPaths.GetHeadPosition();
        while (pos) 
        {
            int i = 0;
            name = strlDataPaths.GetAt(pos);

            value = _T("");
            
            SiteInstance.Format(_T("%d"), CMetabasePath::GetInstanceNumber(name));
			lvi.iItem = item;
			lvi.iSubItem = COL_SITE_INSTANCE;
			lvi.pszText = (LPTSTR)(LPCTSTR)SiteInstance;
			lvi.cchTextMax = SiteInstance.GetLength();
			i = m_ServerSiteList.InsertItem(&lvi);
			ASSERT(i != -1);

			lvi.iItem = i;
			lvi.iSubItem = COL_SITE_DESC;
			lvi.pszText = (LPTSTR)(LPCTSTR)value;
			lvi.cchTextMax = value.GetLength();
			VERIFY(m_ServerSiteList.SetItem(&lvi));

            // set item data with the pointer to the Strings
            CString * pDataItemString = new CString(name);
            VERIFY(m_ServerSiteList.SetItemData(item, (LONG_PTR)pDataItemString));

			item++;
            strlDataPaths.GetNext(pos);
        }

        FillListWithMetabaseSiteDesc();
    }

   
	return TRUE;
}


BOOL CChooseServerSite::FillListWithMetabaseSiteDesc()
{
	int count = m_ServerSiteList.GetItemCount();
    CString strMetabaseKey;
    CString value = _T("");
    CString strDescription;
    HRESULT hr = E_FAIL;
    CString MachineName_Remote;
    CString UserName_Remote;
    CString UserPassword_Remote;
    MachineName_Remote = m_pCert->m_MachineName_Remote;
    UserName_Remote = m_pCert->m_UserName_Remote;
    UserPassword_Remote = m_pCert->m_UserPassword_Remote;
    CString * pMetabaseKey;

    for (int index = 0; index < count; index++)
    {
        pMetabaseKey = (CString *) m_ServerSiteList.GetItemData(index);
        if (pMetabaseKey)
        {
            strMetabaseKey = *pMetabaseKey;
            // Go get the site's description;
            if (TRUE == GetServerComment(MachineName_Remote,UserName_Remote,UserPassword_Remote,strMetabaseKey,strDescription,&hr))
            {
                value = strDescription;
            }
            else
            {
                value = strMetabaseKey;
            }
            m_ServerSiteList.SetItemText(index, COL_SITE_DESC,value);
        }
    }

    return TRUE;
}

void CChooseServerSite::OnDblClickSiteList(NMHDR* pNMHDR, LRESULT* pResult)
{
    // Get the hash for the certificate that is clicked on...
    m_Index = m_ServerSiteList.GetSelectedIndex();
    if (m_Index != -1)
    {
        // Get the metabase key..
        CString * pMetabaseKey = NULL;
        pMetabaseKey = (CString *) m_ServerSiteList.GetItemData(m_Index);
        if (pMetabaseKey)
        {
            m_strSiteReturned = *pMetabaseKey;
            // use the metabase key to lookup the hash
	        // find cert in store
            CRYPT_HASH_BLOB * pHash = NULL;
            HRESULT hr;
            // go lookup the certhash from the metabase
            if (0 == _tcsicmp(m_pCert->m_MachineName_Remote,m_pCert->m_MachineName))
            {
		        pHash = GetInstalledCertHash(m_pCert->m_MachineName_Remote,m_strSiteReturned,m_pCert->GetEnrollObject(),&hr);
                if (pHash)
                {
                    ViewCertificateDialog(pHash,m_hWnd);
                    if (pHash){CoTaskMemFree(pHash);}
                }
            }
        }
    }
    return;
}


void CChooseServerSite::OnOK() 
{
	m_Index = m_ServerSiteList.GetSelectedIndex();
    m_strSiteReturned = _T("");
    if (m_Index != -1)
    {
        CString * pMetabaseKey = NULL;
        pMetabaseKey = (CString *) m_ServerSiteList.GetItemData(m_Index);
        if (pMetabaseKey)
        {
            m_strSiteReturned = *pMetabaseKey;

            if (m_ShowOnlyCertSites)
            {
                // check if the returned site has an exportable certificate on it...
                if (FALSE == IsCertExportableOnRemoteMachine(m_pCert->m_MachineName_Remote,m_pCert->m_UserName_Remote,m_pCert->m_UserPassword_Remote,m_strSiteReturned))
                {
                    // tell the user that certificat that they chose is not exportable.
                    CString buf;
                    buf.LoadString(IDS_CERT_NOT_EXPORTABLE);
                    AfxMessageBox(buf, MB_OK);
                    return;
                }
            }
        }
    }

    CDialog::OnOK();
}

void CChooseServerSite::OnClickSiteList(NMHDR* pNMHDR, LRESULT* pResult)
{
	//SetWizardButtons(-1 == m_ServerSiteList.GetSelectedIndex() ? PSWIZB_BACK : PSWIZB_BACK | PSWIZB_NEXT);
    m_Index = m_ServerSiteList.GetSelectedIndex();
	*pResult = 0;
}


void CChooseServerSite::OnDestroy()
{
	// before dialog will be desroyed we need to delete all
	// the item data pointers
	int count = m_ServerSiteList.GetItemCount();
	for (int index = 0; index < count; index++)
	{
		CString * pData = (CString *) m_ServerSiteList.GetItemData(index);
		delete pData;
	}
	CDialog::OnDestroy();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\certwiz\chooseserversite.h ===
#if !defined(AFX_CHOOSESERVERSITE_H__25260090_DB36_49E2_9435_7519047DDF49__INCLUDED_)
#define AFX_CHOOSESERVERSITE_H__25260090_DB36_49E2_9435_7519047DDF49__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// ChooseServerSite.h : header file
//
#include "Certificat.h"

/////////////////////////////////////////////////////////////////////////////
// CChooseServerSite window

class CCertificate;


class CCertListCtrl : public CListCtrl
{
public:
	int GetSelectedIndex();
	void AdjustStyle();
};



class CChooseServerSite : public CDialog
{

// Construction
public:
    CChooseServerSite(BOOL bShowOnlyCertSites, CString& strSiteReturned, CCertificate * pCert = NULL,IN CWnd * pParent = NULL OPTIONAL);
    ~CChooseServerSite();

// Dialog Data
    //{{AFX_DATA(CChooseServerSite)
    enum {IDD = IDD_DIALOG_CHOOSE_SITE};
    CCertListCtrl m_ServerSiteList;
    //}}AFX_DATA
    CCertificate * m_pCert;
    CString m_strSiteReturned;
    int m_Index;
    BOOL m_ShowOnlyCertSites;

// Overrides
	//{{AFX_VIRTUAL(CChooseServerSite)
	protected:
    virtual void DoDataExchange(CDataExchange * pDX);
	//}}AFX_VIRTUAL

	// Generated message map functions
protected:
	//{{AFX_MSG(CChooseServerSite)
    virtual BOOL OnInitDialog();
    virtual void OnOK();
	afx_msg void OnClickSiteList(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnDblClickSiteList(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnDestroy();
	//}}AFX_MSG
    BOOL FillListWithMetabaseSiteDesc();

	DECLARE_MESSAGE_MAP()
private:
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_CHOOSESERVERSITE_H__25260090_DB36_49E2_9435_7519047DDF49__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\certwiz\chooseserversitepages.cpp ===
// ChooseServerSitePages.cpp: implementation of the CChooseServerSitePages class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "certwiz.h"
#include "Certificat.h"
#include "Certutil.h"
#include "ChooseServerSite.h"
#include "ChooseServerSitePages.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

/////////////////////////////////////////////////////////////////////////////
// CChooseServerSitePages property page

IMPLEMENT_DYNCREATE(CChooseServerSitePages, CIISWizardPage)

CChooseServerSitePages::CChooseServerSitePages(CCertificate * pCert) 
	: CIISWizardPage(CChooseServerSitePages::IDD, IDS_CERTWIZ, TRUE),
	m_pCert(pCert)
{
	//{{AFX_DATA_INIT(CChooseServerSitePages)
	m_ServerSiteInstance = 0;
    m_ServerSiteInstancePath = _T("");
    m_ServerSiteDescription = _T("");
	//}}AFX_DATA_INIT
}

CChooseServerSitePages::~CChooseServerSitePages()
{
}

void CChooseServerSitePages::DoDataExchange(CDataExchange* pDX)
{
	CIISWizardPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CChooseServerSitePages)
	DDX_Text(pDX, IDC_SERVER_SITE_NAME, m_ServerSiteInstance);
	//}}AFX_DATA_MAP
}

LRESULT 
CChooseServerSitePages::OnWizardBack()
/*++
Routine Description:
    Prev button handler

Arguments:
    None

Return Value:
	0 to automatically advance to the prev page;
	1 to prevent the page from changing. 
	To jump to a page other than the prev one, 
	return the identifier of the dialog to be displayed.
--*/
{
	return IDD_PAGE_PREV;
}

LRESULT 
CChooseServerSitePages::OnWizardNext()
{
    LRESULT lres = IDD_PAGE_NEXT;
	UpdateData(TRUE);

    // Get the site # and create an instance path
    m_ServerSiteInstancePath.Format(_T("/LM/W3SVC/%d"),m_ServerSiteInstance);

    m_pCert->m_WebSiteInstanceName_Remote = m_ServerSiteInstancePath;
    if (m_pCert->m_DeleteAfterCopy)
    {
        lres = IDD_PAGE_NEXT2;
    }
    else
    {
        lres = IDD_PAGE_NEXT;
    }
	return lres;
}

BOOL 
CChooseServerSitePages::OnSetActive() 
{
	ASSERT(m_pCert != NULL);
    m_ServerSiteInstancePath = m_pCert->m_WebSiteInstanceName_Remote;
    m_ServerSiteInstance = CMetabasePath::GetInstanceNumber(m_ServerSiteInstancePath);

    UpdateData(FALSE);
	SetWizardButtons(m_ServerSiteInstance <=0 ? PSWIZB_BACK : PSWIZB_BACK | PSWIZB_NEXT);
	return CIISWizardPage::OnSetActive();
}

BOOL
CChooseServerSitePages::OnKillActive()
{
	UpdateData();
	m_pCert->m_WebSiteInstanceName_Remote = m_ServerSiteInstancePath;
	return CIISWizardPage::OnKillActive();
}

BEGIN_MESSAGE_MAP(CChooseServerSitePages, CIISWizardPage)
	//{{AFX_MSG_MAP(CChooseServerSitePages)
	ON_EN_CHANGE(IDC_SERVER_SITE_NAME, OnEditchangeServerSiteName)
    ON_BN_CLICKED(IDC_BROWSE_BTN, OnBrowseForMachineWebSite)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CSiteNamePage message handlers

void CChooseServerSitePages::OnEditchangeServerSiteName() 
{
	UpdateData(TRUE);	
	SetWizardButtons(m_ServerSiteInstance <=0 ? 
			PSWIZB_BACK : PSWIZB_BACK | PSWIZB_NEXT);
	CString str;
	SetDlgItemText(IDC_ERROR_TEXT, str);
}

void CChooseServerSitePages::OnBrowseForMachineWebSite()
{
    CString strWebSite;

    CChooseServerSite dlg(TRUE,strWebSite,m_pCert);
    if (dlg.DoModal() == IDOK)
    {
        // Get the one that they selected...
        strWebSite = dlg.m_strSiteReturned; 
        m_ServerSiteInstancePath = strWebSite;
        m_ServerSiteInstance = CMetabasePath::GetInstanceNumber(m_ServerSiteInstancePath);
        CString Temp;
        Temp.Format(_T("%d"),m_ServerSiteInstance);
        SetDlgItemText(IDC_SERVER_SITE_NAME, Temp);
    }

    return;
}

/////////////////////////////////////////////////////////////////////////////
// CChooseServerSitePages property page

IMPLEMENT_DYNCREATE(CChooseServerSitePagesTo, CIISWizardPage)

CChooseServerSitePagesTo::CChooseServerSitePagesTo(CCertificate * pCert) 
	: CIISWizardPage(CChooseServerSitePagesTo::IDD, IDS_CERTWIZ, TRUE),
	m_pCert(pCert)
{
	//{{AFX_DATA_INIT(CChooseServerSitePagesTo)
	m_ServerSiteInstance = 0;
    m_ServerSiteInstancePath = _T("");
    m_ServerSiteDescription = _T("");
	//}}AFX_DATA_INIT
}

CChooseServerSitePagesTo::~CChooseServerSitePagesTo()
{
}

void CChooseServerSitePagesTo::DoDataExchange(CDataExchange* pDX)
{
	CIISWizardPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CChooseServerSitePagesTo)
	DDX_Text(pDX, IDC_SERVER_SITE_NAME, m_ServerSiteInstance);
	//}}AFX_DATA_MAP
}

LRESULT 
CChooseServerSitePagesTo::OnWizardBack()
/*++
Routine Description:
    Prev button handler

Arguments:
    None

Return Value:
	0 to automatically advance to the prev page;
	1 to prevent the page from changing. 
	To jump to a page other than the prev one, 
	return the identifier of the dialog to be displayed.
--*/
{
	return IDD_PAGE_PREV;
}

LRESULT 
CChooseServerSitePagesTo::OnWizardNext()
{
    LRESULT lres = IDD_PAGE_NEXT;
	UpdateData(TRUE);

    // Get the site # and create an instance path
    m_ServerSiteInstancePath.Format(_T("/LM/W3SVC/%d"),m_ServerSiteInstance);
    
    m_pCert->m_WebSiteInstanceName_Remote = m_ServerSiteInstancePath;
    if (m_pCert->m_DeleteAfterCopy)
    {
        lres = IDD_PAGE_NEXT2;
    }
    else
    {
        lres = IDD_PAGE_NEXT;
    }

	return lres;
}

BOOL 
CChooseServerSitePagesTo::OnSetActive() 
{
	ASSERT(m_pCert != NULL);

	m_ServerSiteInstancePath = m_pCert->m_WebSiteInstanceName_Remote;
    m_ServerSiteInstance = CMetabasePath::GetInstanceNumber(m_ServerSiteInstancePath);

	UpdateData(FALSE);
	SetWizardButtons(m_ServerSiteInstance <=0 ? PSWIZB_BACK : PSWIZB_BACK | PSWIZB_NEXT);
	return CIISWizardPage::OnSetActive();
}

BOOL
CChooseServerSitePagesTo::OnKillActive()
{
	UpdateData();
	m_pCert->m_WebSiteInstanceName_Remote = m_ServerSiteInstancePath;
	return CIISWizardPage::OnKillActive();
}

BEGIN_MESSAGE_MAP(CChooseServerSitePagesTo, CIISWizardPage)
	//{{AFX_MSG_MAP(CChooseServerSitePagesTo)
	ON_EN_CHANGE(IDC_SERVER_SITE_NAME, OnEditchangeServerSiteName)
    ON_BN_CLICKED(IDC_BROWSE_BTN, OnBrowseForMachineWebSite)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CSiteNamePage message handlers

void CChooseServerSitePagesTo::OnEditchangeServerSiteName() 
{
	UpdateData(TRUE);	
	SetWizardButtons(m_ServerSiteInstance <=0 ? 
			PSWIZB_BACK : PSWIZB_BACK | PSWIZB_NEXT);
	CString str;
	SetDlgItemText(IDC_ERROR_TEXT, str);
}

void CChooseServerSitePagesTo::OnBrowseForMachineWebSite()
{
    CString strWebSite;

    CChooseServerSite dlg(FALSE,strWebSite,m_pCert);
    if (dlg.DoModal() == IDOK)
    {
        // Get the one that they selected...
        strWebSite = dlg.m_strSiteReturned; 
        m_ServerSiteInstancePath = strWebSite;
        m_ServerSiteInstance = CMetabasePath::GetInstanceNumber(m_ServerSiteInstancePath);
        CString Temp;
        Temp.Format(_T("%d"),m_ServerSiteInstance); 
        SetDlgItemText(IDC_SERVER_SITE_NAME, Temp);
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\certwiz\copymovecertremotepage.cpp ===
// CopyMoveCertRemotePage.cpp : implementation file
//

#include "stdafx.h"
#include "certwiz.h"
#include "CopyMoveCertRemotePage.h"
#include "Certificat.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CCopyMoveCertFromRemotePage property page

IMPLEMENT_DYNCREATE(CCopyMoveCertFromRemotePage, CIISWizardPage)

CCopyMoveCertFromRemotePage::CCopyMoveCertFromRemotePage(CCertificate * pCert)
	: CIISWizardPage(CCopyMoveCertFromRemotePage::IDD, IDS_CERTWIZ, TRUE),
	m_pCert(pCert)
{
	//{{AFX_DATA_INIT(CCopyMoveCertFromRemotePage)
    m_Index = -1;
    m_MarkAsExportable = FALSE;
	//}}AFX_DATA_INIT
}

CCopyMoveCertFromRemotePage::~CCopyMoveCertFromRemotePage()
{
}

void CCopyMoveCertFromRemotePage::DoDataExchange(CDataExchange* pDX)
{
    CIISWizardPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CCopyMoveCertFromRemotePage)
    DDX_Check(pDX, IDC_MARK_AS_EXPORTABLE, m_MarkAsExportable);
    DDX_Radio(pDX, IDC_COPY_FROM_REMOTE, m_Index);
	//}}AFX_DATA_MAP
}

void CCopyMoveCertFromRemotePage::OnExportable() 
{
   UpdateData();
}

BEGIN_MESSAGE_MAP(CCopyMoveCertFromRemotePage, CIISWizardPage)
	//{{AFX_MSG_MAP(CCopyMoveCertFromRemotePage)
	ON_BN_CLICKED(IDC_MARK_AS_EXPORTABLE, OnExportable)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CCopyMoveCertFromRemotePage message handlers

LRESULT CCopyMoveCertFromRemotePage::OnWizardBack() 
{
	return IDD_PAGE_PREV;
}

LRESULT CCopyMoveCertFromRemotePage::OnWizardNext() 
{
	LRESULT res = 1;
	UpdateData();
	switch (m_Index)
	{
	case CONTINUE_COPY_FROM_REMOTE:
        m_pCert->m_DeleteAfterCopy = FALSE;
        m_pCert->m_MarkAsExportable = m_MarkAsExportable;
		res = IDD_PAGE_NEXT_COPY_FROM_REMOTE;
		break;
	case CONTINUE_MOVE_FROM_REMOTE:
        m_pCert->m_DeleteAfterCopy = TRUE;
        m_pCert->m_MarkAsExportable = m_MarkAsExportable;
		res = IDD_PAGE_NEXT_MOVE_FROM_REMOTE;
		break;
	}
	return res;
}

BOOL CCopyMoveCertFromRemotePage::OnSetActive() 
{
	m_pCert->SetStatusCode(CCertificate::REQUEST_UNDEFINED);
	SetWizardButtons(PSWIZB_BACK | PSWIZB_NEXT);
	return CIISWizardPage::OnSetActive();
}

BOOL CCopyMoveCertFromRemotePage::OnInitDialog() 
{
	m_Index = 0;
	CIISWizardPage::OnInitDialog();

	return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
// CCopyMoveCertToRemotePage property page

IMPLEMENT_DYNCREATE(CCopyMoveCertToRemotePage, CIISWizardPage)

CCopyMoveCertToRemotePage::CCopyMoveCertToRemotePage(CCertificate * pCert)
	: CIISWizardPage(CCopyMoveCertToRemotePage::IDD, IDS_CERTWIZ, TRUE),
	m_pCert(pCert)
{
	//{{AFX_DATA_INIT(CCopyMoveCertToRemotePage)
    m_Index = -1;
    m_MarkAsExportable = FALSE;
	//}}AFX_DATA_INIT
}

CCopyMoveCertToRemotePage::~CCopyMoveCertToRemotePage()
{
}

void CCopyMoveCertToRemotePage::DoDataExchange(CDataExchange* pDX)
{
    CIISWizardPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CCopyMoveCertToRemotePage)
    DDX_Check(pDX, IDC_MARK_AS_EXPORTABLE, m_MarkAsExportable);
    DDX_Radio(pDX, IDC_COPY_TO_REMOTE, m_Index);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CCopyMoveCertToRemotePage, CIISWizardPage)
	//{{AFX_MSG_MAP(CCopyMoveCertToRemotePage)
	ON_BN_CLICKED(IDC_MARK_AS_EXPORTABLE, OnExportable)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CCopyMoveCertToRemotePage message handlers

LRESULT CCopyMoveCertToRemotePage::OnWizardBack() 
{
	return IDD_PAGE_PREV;
}

// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
LRESULT CCopyMoveCertToRemotePage::OnWizardNext() 
{
	LRESULT res = 1;
	UpdateData();

	switch (m_Index)
	{
	case CONTINUE_COPY_TO_REMOTE:
		//m_pCert->SetStatusCode(CCertificate::REQUEST_COPYREMOTE_CERT);
        m_pCert->m_DeleteAfterCopy = FALSE;
        m_pCert->m_MarkAsExportable = m_MarkAsExportable;
		res = IDD_PAGE_NEXT_COPY_TO_REMOTE;
		break;
	case CONTINUE_MOVE_TO_REMOTE:
        m_pCert->m_DeleteAfterCopy = TRUE;
        m_pCert->m_MarkAsExportable = m_MarkAsExportable;
		res = IDD_PAGE_NEXT_MOVE_TO_REMOTE;
		break;
	}

	return res;
}

BOOL CCopyMoveCertToRemotePage::OnSetActive() 
{
	m_pCert->SetStatusCode(CCertificate::REQUEST_UNDEFINED);
	SetWizardButtons(PSWIZB_BACK | PSWIZB_NEXT);
	return CIISWizardPage::OnSetActive();
}

BOOL CCopyMoveCertToRemotePage::OnInitDialog() 
{
	m_Index = 0;
	CIISWizardPage::OnInitDialog();
    // we should make some checks and disable some buttons
    if (!m_pCert->m_CertObjInstalled)
	{
		ASSERT(NULL != GetDlgItem(IDC_COPY_TO_REMOTE));
        ASSERT(NULL != GetDlgItem(IDC_MOVE_TO_REMOTE));
		GetDlgItem(IDC_COPY_TO_REMOTE)->EnableWindow(FALSE);
        GetDlgItem(IDC_MOVE_TO_REMOTE)->EnableWindow(FALSE);
	}
	return TRUE;
}

void CCopyMoveCertToRemotePage::OnExportable() 
{
   UpdateData();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\certwiz\countrycombobox.cpp ===
// CountryComboBox.cpp : implementation file
//

#include "stdafx.h"
#include "CertWiz.h"
#include "CountryComboBox.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

BEGIN_MESSAGE_MAP(CComboEdit, CEdit)
	ON_WM_CHAR()
END_MESSAGE_MAP()

void CComboEdit::OnChar(UINT nChar, UINT nRepCnt, UINT nFlags)
{
	if (m_pParent->OnEditChar(nChar))
		CEdit::OnChar(nChar, nRepCnt, nFlags);
}

BOOL CComboEdit::SubclassDlgItem(UINT nID, CCountryComboBox * pParent)
{
	ASSERT(pParent != NULL);
	m_pParent = pParent;
	return CEdit::SubclassDlgItem(nID, pParent);
}

BOOL CCountryComboBox::OnEditChar(UINT nChar)
{
	int index;
	int len = m_strInput.GetLength();
	if (nChar == VK_ESCAPE)
	{
		if (len == 0)
		{
			MessageBeep(MB_ICONQUESTION);
			return FALSE;
		}
		m_strInput.Empty();
		len = 0;
	}
	else if (nChar == VK_BACK)
	{
		if (len == 0)
		{
			MessageBeep(MB_ICONQUESTION);
			return FALSE;
		}
		m_strInput.ReleaseBuffer(--len);
	}
	else if (_istalpha((TCHAR) nChar) || VK_SPACE == nChar)
	{
		m_strInput += (TCHAR)nChar;
		len++;
	}
	else
	{
		MessageBeep(MB_ICONQUESTION);
		return FALSE;
	}
	if (len > 0 && len <= 2)
	{
		if (CB_ERR != (index = FindString(-1, m_strInput)))
		{
			m_Index = index;
			SetCurSel(m_Index);
			SetEditSel(0, m_strInput.GetLength());
		}
		else
		{
			// try to find it in country names list
			index = -1;
			POSITION pos = m_map_name_code.GetStartPosition();
			int i = 0;
			while (pos != NULL)
			{
				CString name, code;
				m_map_name_code.GetNextAssoc(pos, name, code);
				if (0 == _tcsnicmp(name, m_strInput, len))
				{
					index = i;
					break;
				}
				i++;
			}
			if (index != -1)
			{
				m_Index = index;
				SetCurSel(m_Index);
				SetEditSel(4, len);
			}
			else
			{
				m_strInput.ReleaseBuffer(--len);
				MessageBeep(MB_ICONQUESTION);
			}
		}
	}
	else if (len > 2)
	{
		// try to find it in country names list
		index = -1;
		POSITION pos = m_map_name_code.GetStartPosition();
		while (pos != NULL)
		{
			CString name, code;
			m_map_name_code.GetNextAssoc(pos, name, code);
			if (0 == _tcsnicmp(name, m_strInput, len))
			{
				index = FindString(-1, code);
				break;
			}
		}
		if (index != -1)
		{
			m_Index = index;
			SetCurSel(m_Index);
			SetEditSel(4, 4+len);
		}
		else
		{
			m_strInput.ReleaseBuffer(--len);
			MessageBeep(MB_ICONQUESTION);
		}
	}
	else
	{
		// just remove selection
		SetEditSel(-1, 0);
	}
	return FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// CCountryComboBox

CCountryComboBox::CCountryComboBox()
{
}

CCountryComboBox::~CCountryComboBox()
{
}

#define IDC_COMBOEDIT 1001

BOOL
CCountryComboBox::SubclassDlgItem(UINT nID, CWnd * pParent)
{
	return CComboBox::SubclassDlgItem(nID, pParent)
		&& m_edit.SubclassDlgItem(IDC_COMBOEDIT, this);
}

BOOL
CCountryComboBox::Init()
{
	BOOL rc = FALSE;
   CString strData, strCode, strName, str;
   for (int i = IDS_COUNTRIES_FIRST;; i++)
   {
      if (!strData.LoadString(i))
      {
         break;
      }
      if (strData.IsEmpty())
      {
         rc = TRUE;
         break;
      }
      strCode = strData.Left(2);
      strName = strData.Right(strData.GetLength() - 2);
      str = strCode;
      str += _T(" (");
      str += strName;
      str += _T(")");
	  if (CB_ERR == AddString(str))
	     break;
	  m_map_name_code.SetAt(strName, strCode);
   }
	return rc;
}


#define MAX_COUNTRY_NAME	64
#define MAX_COUNTRY_CODE	10
void CCountryComboBox::SetSelectedCountry(CString& country_code)
{
	int index;
    TCHAR szCountryName[MAX_COUNTRY_NAME+1];
    TCHAR sz3CharCountryCode[MAX_COUNTRY_CODE+1];
    int iRet = GetLocaleInfo(LOCALE_SYSTEM_DEFAULT, LOCALE_SISO3166CTRYNAME, sz3CharCountryCode, MAX_COUNTRY_CODE);
    iRet = GetLocaleInfo(LOCALE_SYSTEM_DEFAULT, LOCALE_SCOUNTRY, szCountryName, MAX_COUNTRY_NAME);

    if (country_code.IsEmpty())
	{
        // Try to look it up from the country name
        // i know this is kind of weird since we can look it up from
        // the countrycode, but this code has been like this for a while
        // and i don't want to break anything
		m_map_name_code.Lookup(szCountryName, country_code);
	}
	if (!country_code.IsEmpty() && CB_ERR != (index = FindString(-1, country_code) ))
	{
        SetCurSel(index);
    }
	else
    {
        int len = 0;
        POSITION pos = NULL;
        CString name, code;
        //IISDebugOutput((_T("No Match for:%s\n"),szCountryName));

        // we didn't find a match
        // try looping thru the m_map_name_code
        // to find a matching country code
        index = -1;
        len = _tcslen(sz3CharCountryCode);
		pos = m_map_name_code.GetStartPosition();
		while (pos != NULL)
		{
			m_map_name_code.GetNextAssoc(pos, name, code);
			if (0 == _tcsnicmp(code, sz3CharCountryCode, len))
			{
				index = FindString(-1, code);
				break;
			}
		}

        if (index == -1)
        {
            // if we still didn't find it
            // then search thru the list and look for a similiar
            // looking country name
            index = -1;
            len = _tcslen(szCountryName);
		    pos = m_map_name_code.GetStartPosition();
		    while (pos != NULL)
		    {
			    m_map_name_code.GetNextAssoc(pos, name, code);
			    if (0 == _tcsnicmp(name, szCountryName, len))
			    {
				    index = FindString(-1, code);
				    break;
			    }
		    }
        }
		if (index != -1)
		{
            SetCurSel(index);
		}
        else
        {
            SetCurSel(0);
        }
    }
}

void CCountryComboBox::GetSelectedCountry(CString& country_code)
{
	CString str;
	GetLBText(GetCurSel(), str);
	country_code = str.Left(2);
}

BEGIN_MESSAGE_MAP(CCountryComboBox, CComboBox)
	//{{AFX_MSG_MAP(CCountryComboBox)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CCountryComboBox message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\certwiz\copymovecertremotepage.h ===
#if !defined(AFX_COPYMOVECERTREMOTEPAGE_H__2BC5260E_AB68_43ED_9E7B_35794097905F__INCLUDED_)
#define AFX_COPYMOVECERTREMOTEPAGE_H__2BC5260E_AB68_43ED_9E7B_35794097905F__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// CopyMoveCertRemotePage.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CCopyMoveCertFromRemotePage dialog
class CCertificate;

class CCopyMoveCertFromRemotePage : public CIISWizardPage
{
	DECLARE_DYNCREATE(CCopyMoveCertFromRemotePage)

// Construction
public:
	CCopyMoveCertFromRemotePage(CCertificate * pCert = NULL);
	~CCopyMoveCertFromRemotePage();

	enum
	{
        IDD_PAGE_NEXT_COPY_FROM_REMOTE = IDD_PAGE_WIZ_CHOOSE_SERVER,
        IDD_PAGE_NEXT_MOVE_FROM_REMOTE = IDD_PAGE_WIZ_CHOOSE_SERVER,
		IDD_PAGE_PREV = IDD_PAGE_WIZ_GET_WHAT
	};
	enum
	{
        CONTINUE_COPY_FROM_REMOTE = 0,
        CONTINUE_MOVE_FROM_REMOTE
	};

// Dialog Data
	//{{AFX_DATA(CCopyMoveCertFromRemotePage)
	enum { IDD = IDD_PAGE_WIZ_CHOOSE_COPY_MOVE_FROM_REMOTE };
    int		m_Index;
	//}}AFX_DATA
    CCertificate * m_pCert;
    BOOL m_MarkAsExportable;


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CCopyMoveCertFromRemotePage)
	public:
	virtual LRESULT OnWizardBack();
	virtual LRESULT OnWizardNext();
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CCopyMoveCertFromRemotePage)
    virtual BOOL OnInitDialog();
    afx_msg void OnExportable();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};


class CCopyMoveCertToRemotePage : public CIISWizardPage
{
	DECLARE_DYNCREATE(CCopyMoveCertToRemotePage)

// Construction
public:
	CCopyMoveCertToRemotePage(CCertificate * pCert = NULL);
	~CCopyMoveCertToRemotePage();

	enum
	{
		IDD_PAGE_NEXT_COPY_TO_REMOTE = IDD_PAGE_WIZ_CHOOSE_SERVER_TO,
		IDD_PAGE_NEXT_MOVE_TO_REMOTE = IDD_PAGE_WIZ_CHOOSE_SERVER_TO,
		IDD_PAGE_PREV = IDD_PAGE_WIZ_MANAGE_CERT
	};
	enum
	{
		CONTINUE_COPY_TO_REMOTE = 0,
		CONTINUE_MOVE_TO_REMOTE
	};

// Dialog Data
	//{{AFX_DATA(CCopyMoveCertToRemotePage)
	enum { IDD = IDD_PAGE_WIZ_CHOOSE_COPY_MOVE_TO_REMOTE };
    int		m_Index;
	//}}AFX_DATA
    CCertificate * m_pCert;
    BOOL m_MarkAsExportable;


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CCopyMoveCertToRemotePage)
	public:
	virtual LRESULT OnWizardBack();
	virtual LRESULT OnWizardNext();
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CCopyMoveCertToRemotePage)
    virtual BOOL OnInitDialog();
    afx_msg void OnExportable();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};


//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_COPYMOVECERTREMOTEPAGE_H__2BC5260E_AB68_43ED_9E7B_35794097905F__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\certwiz\chooseserversitepages.h ===
// ChooseServerSitePages.h: interface for the CChooseServerSitePages class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_CHOOSESERVERSITEPAGES_H__B545F741_C25F_410C_93F6_56F98A5911BC__INCLUDED_)
#define AFX_CHOOSESERVERSITEPAGES_H__B545F741_C25F_410C_93F6_56F98A5911BC__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

/////////////////////////////////////////////////////////////////////////////
// CChooseServerSitePages dialog
class CCertificate;

class CChooseServerSitePages : public CIISWizardPage
{
	DECLARE_DYNCREATE(CChooseServerSitePages)

// Construction
public:
	CChooseServerSitePages(CCertificate * pCert = NULL);
	~CChooseServerSitePages();

	enum
	{
		IDD_PAGE_PREV = IDD_PAGE_WIZ_CHOOSE_SERVER,
		IDD_PAGE_NEXT = IDD_PAGE_WIZ_INSTALL_COPY_FROM_REMOTE,
        IDD_PAGE_NEXT2 = IDD_PAGE_WIZ_INSTALL_MOVE_FROM_REMOTE
	};
// Dialog Data
	//{{AFX_DATA(CChooseServerSitePages)
	enum { IDD = IDD_PAGE_WIZ_CHOOSE_SERVER_SITE };
    CString	m_ServerSiteDescription;
	DWORD m_ServerSiteInstance;
    CString	m_ServerSiteInstancePath;
	//}}AFX_DATA
	CCertificate * m_pCert;

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CChooseServerSitePages)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	public:
	virtual LRESULT OnWizardNext();
	virtual LRESULT OnWizardBack();
	virtual BOOL OnSetActive();
	virtual BOOL OnKillActive();
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CChooseServerSitePages)
	afx_msg void OnEditchangeServerSiteName();
    afx_msg void OnBrowseForMachineWebSite();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};




class CChooseServerSitePagesTo : public CIISWizardPage
{
	DECLARE_DYNCREATE(CChooseServerSitePagesTo)

// Construction
public:
	CChooseServerSitePagesTo(CCertificate * pCert = NULL);
	~CChooseServerSitePagesTo();

	enum
	{
		IDD_PAGE_PREV = IDD_PAGE_WIZ_CHOOSE_SERVER_TO,
		IDD_PAGE_NEXT = IDD_PAGE_WIZ_INSTALL_COPY_TO_REMOTE,
        IDD_PAGE_NEXT2 = IDD_PAGE_WIZ_INSTALL_MOVE_TO_REMOTE
	};
// Dialog Data
	//{{AFX_DATA(CChooseServerSitePagesTo)
	enum { IDD = IDD_PAGE_WIZ_CHOOSE_SERVER_SITE_TO };
    CString	m_ServerSiteDescription;
	DWORD m_ServerSiteInstance;
    CString	m_ServerSiteInstancePath;
	//}}AFX_DATA
	CCertificate * m_pCert;


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CChooseServerSitePagesTo)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	public:
	virtual LRESULT OnWizardNext();
	virtual LRESULT OnWizardBack();
	virtual BOOL OnSetActive();
	virtual BOOL OnKillActive();
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CChooseServerSitePagesTo)
	afx_msg void OnEditchangeServerSiteName();
    afx_msg void OnBrowseForMachineWebSite();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

#endif // !defined(AFX_CHOOSESERVERSITEPAGES_H__B545F741_C25F_410C_93F6_56F98A5911BC__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\certwiz\countrycombobox.h ===
#if !defined(AFX_COUNTRYCOMBOBOX_H__8F522A56_3E30_11D2_9313_0060088FF80E__INCLUDED_)
#define AFX_COUNTRYCOMBOBOX_H__8F522A56_3E30_11D2_9313_0060088FF80E__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// CountryComboBox.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CCountryComboBox window
class CCountryComboBox;

class CComboEdit : public CEdit
{
	CCountryComboBox * m_pParent;
public:
	BOOL SubclassDlgItem(UINT nID, CCountryComboBox * pParent);

	afx_msg void OnChar(UINT nChar, UINT nRepCnt, UINT nFlags);
	DECLARE_MESSAGE_MAP()
};

typedef struct _COUNTRY_DATA 
{
	TCHAR * code;
	TCHAR * name;
} COUNTRY_DATA;

class CCountryComboBox : public CComboBox
{
	CComboEdit m_edit;
	CMapStringToString m_map_name_code;
	CString m_strInput;
	int m_Index;

// Construction
public:
	CCountryComboBox();

// Attributes
public:

// Operations
public:
	BOOL SubclassDlgItem(UINT nID, CWnd * pParent);
	BOOL Init();
	BOOL OnEditChar(UINT nChar);
	void SetSelectedCountry(CString& country_code);
	void GetSelectedCountry(CString& country_code);

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CCountryComboBox)
	public:
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CCountryComboBox();

	// Generated message map functions
protected:
	//{{AFX_MSG(CCountryComboBox)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_COUNTRYCOMBOBOX_H__8F522A56_3E30_11D2_9313_0060088FF80E__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\certwiz\finalpages.cpp ===
// FinalInstalledPage.cpp : implementation file
//

#include "stdafx.h"
#include "CertWiz.h"
#include "FinalPages.h"
#include "Certificat.h"
#include "Certutil.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CFinalInstalledPage property page

IMPLEMENT_DYNCREATE(CFinalInstalledPage, CIISWizardBookEnd2)

CFinalInstalledPage::CFinalInstalledPage(HRESULT * phResult, CCertificate * pCert) 
	: CIISWizardBookEnd2(phResult,
		USE_DEFAULT_CAPTION,
		IDS_INSTALL_CERT_FAILURE_HEADER,
		IDS_CERTWIZ,
		&m_idBodyText,
		NULL,
		&pCert->m_idErrorText,
		&pCert->m_strErrorText,
		USE_DEFAULT_CAPTION,
		CFinalInstalledPage::IDD),
		m_pCert(pCert)
{
	m_idBodyText = IDS_CERT_INSTALLED_SUCCESS;
}

CFinalInstalledPage::~CFinalInstalledPage()
{
}

BEGIN_MESSAGE_MAP(CFinalInstalledPage, CIISWizardBookEnd2)
	//{{AFX_MSG_MAP(CFinalInstalledPage)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CFinalInstalledPage message handlers


/////////////////////////////////////////////////////////////////////////////
// CFinalReplacedPage property page

IMPLEMENT_DYNCREATE(CFinalReplacedPage, CIISWizardBookEnd2)

CFinalReplacedPage::CFinalReplacedPage(HRESULT * phResult, CCertificate * pCert) 
	: CIISWizardBookEnd2(phResult,
		USE_DEFAULT_CAPTION,
		IDS_INSTALL_CERT_FAILURE_HEADER,
		IDS_CERTWIZ,
		&m_idBodyText,
		NULL,
		&pCert->m_idErrorText,
		&pCert->m_strErrorText,
		USE_DEFAULT_CAPTION,
		CFinalReplacedPage::IDD),
		m_pCert(pCert)
{
	m_idBodyText = IDS_CERT_REPLACE_SUCCESS;
}

CFinalReplacedPage::~CFinalReplacedPage()
{
}

BEGIN_MESSAGE_MAP(CFinalReplacedPage, CIISWizardBookEnd2)
	//{{AFX_MSG_MAP(CFinalReplacedPage)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CFinalInstalledPage message handlers


/////////////////////////////////////////////////////////////////////////////
// CFinalRemovePage property page

IMPLEMENT_DYNCREATE(CFinalRemovePage, CIISWizardBookEnd2)

CFinalRemovePage::CFinalRemovePage(HRESULT * phResult, CCertificate * pCert) 
	: CIISWizardBookEnd2(phResult,
		USE_DEFAULT_CAPTION,
		IDS_REMOVE_CERT_FAILURE_HEADER,
		IDS_CERTWIZ,
		&m_idBodyText,
		NULL,
		&pCert->m_idErrorText,
		&pCert->m_strErrorText,
		USE_DEFAULT_CAPTION,
		CFinalRemovePage::IDD),
		m_pCert(pCert)
{
	m_idBodyText = IDS_CERT_REMOVE_SUCCESS;
}

CFinalRemovePage::~CFinalRemovePage()
{
}

void CFinalRemovePage::DoDataExchange(CDataExchange* pDX)
{
	CIISWizardBookEnd2::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CFinalRemovePage)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CFinalRemovePage, CIISWizardBookEnd2)
	//{{AFX_MSG_MAP(CFinalRemovePage)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CFinalRemovePage message handlers

BOOL CFinalRemovePage::OnInitDialog() 
{
	CIISWizardBookEnd2::OnInitDialog();
	ASSERT(m_pCert != NULL);
	if (m_pCert->m_hResult != S_OK)
	{
		// we need to replace text in template to error message
		CString str;
		str.LoadString(m_pCert->m_idErrorText);
		SetDlgItemText(IDC_STATIC_WZ_BODY, str);
        GetDlgItem(IDC_STATIC_WZ_BODY)->SendMessage(EM_SETSEL, -1, -1);
	}
	GetParent()->GetDlgItem(IDCANCEL)->EnableWindow(FALSE);
	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CFinalCancelPage property page

IMPLEMENT_DYNCREATE(CFinalCancelPage, CIISWizardBookEnd2)

CFinalCancelPage::CFinalCancelPage(HRESULT * phResult, CCertificate * pCert) 
	: CIISWizardBookEnd2(phResult,
		USE_DEFAULT_CAPTION,
		IDS_CANCEL_CERT_FAILURE_HEADER,
		IDS_CERTWIZ,
		&m_idBodyText,
		NULL,
		&pCert->m_idErrorText,
		&pCert->m_strErrorText,
		USE_DEFAULT_CAPTION,
		CFinalCancelPage::IDD),
		m_pCert(pCert)
{
	m_idBodyText = IDS_CERT_CANCEL_SUCCESS;
}

CFinalCancelPage::~CFinalCancelPage()
{
}

void CFinalCancelPage::DoDataExchange(CDataExchange* pDX)
{
	CIISWizardBookEnd2::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CFinalRemovePage)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CFinalCancelPage, CIISWizardBookEnd2)
	//{{AFX_MSG_MAP(CFinalCancelPage)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CFinalCancelPage message handlers

BOOL CFinalCancelPage::OnInitDialog() 
{
	CIISWizardBookEnd2::OnInitDialog();
	ASSERT(m_pCert != NULL);
	if (m_pCert->m_hResult != S_OK)
	{
		// we need to replace text in template to error message
		CString str;
		str.LoadString(m_pCert->m_idErrorText);
		SetDlgItemText(IDC_STATIC_WZ_BODY, str);
        GetDlgItem(IDC_STATIC_WZ_BODY)->SendMessage(EM_SETSEL, -1, -1);
	}
	GetParent()->GetDlgItem(IDCANCEL)->EnableWindow(FALSE);
	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CFinalToFilePage property page

IMPLEMENT_DYNCREATE(CFinalToFilePage, CIISWizardBookEnd2)

CFinalToFilePage::CFinalToFilePage(HRESULT * phResult, CCertificate * pCert) 
	: CIISWizardBookEnd2(phResult,
			USE_DEFAULT_CAPTION,
			IDS_FINAL_TO_FILE_FAILURE_HEADER,
			IDS_CERTWIZ,
			NULL,
			NULL,
			&pCert->m_idErrorText,
			&pCert->m_strErrorText,
			USE_DEFAULT_CAPTION,
			CFinalToFilePage::IDD),
	m_pCert(pCert)
{
}

CFinalToFilePage::~CFinalToFilePage()
{
}

void CFinalToFilePage::DoDataExchange(CDataExchange* pDX)
{
	CIISWizardBookEnd2::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CFinalToFilePage)
	DDX_Control(pDX, IDC_HOTLINK_CCODES, m_hotlink_codessite);
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CFinalToFilePage, CIISWizardBookEnd2)
	//{{AFX_MSG_MAP(CFinalToFilePage)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CFinalToFilePage message handlers

BOOL CFinalToFilePage::OnInitDialog() 
{
	ASSERT(NULL != m_pCert);
	CIISWizardBookEnd2::OnInitDialog();
	// in case of success we should prepare text and include
	// request file name into
	if (SUCCEEDED(m_pCert->m_hResult))
	{
		CString str, strPath;
      
      	strPath = m_pCert->m_ReqFileName;
		// If filename is too long, it will look ugly, we could
		// limit it to our static control width.
		VERIFY(CompactPathToWidth(GetDlgItem(IDC_STATIC_WZ_BODY), strPath));
// This MFC helper limits the format internally 
// to 256 characters: cannot use it here
//		AfxFormatString1(str, IDS_FINAL_TO_FILE_BODY_SUCCESS, m_pCert->m_ReqFileName);
		str.Format(IDS_CERT_REQUEST_SUCCESS, strPath);
		SetDlgItemText(IDC_STATIC_WZ_BODY, str);

		GetDlgItem(IDC_STATIC_WZ_BODY)->SendMessage(EM_SETSEL, -1, -1);
		//GetDlgItem(IDC_STATIC_WZ_BODY)->SetFocus();


		// setup the link to CA list
		m_hotlink_codessite.SetLink(IDS_MICROSOFT_CA_LINK);
	}
	else
	{
		// hide controls that are not for error message
		GetDlgItem(IDC_HOTLINK_CCODES)->ShowWindow(SW_HIDE);
		GetDlgItem(IDC_STATIC_WZ_BODY2)->ShowWindow(SW_HIDE);
	}
	SetWizardButtons(PSWIZB_FINISH);	
	GetParent()->GetDlgItem(IDCANCEL)->EnableWindow(FALSE);
	return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
// CFinalInstalledPage property page

IMPLEMENT_DYNCREATE(CFinalInstalledImportPFXPage, CIISWizardBookEnd2)

CFinalInstalledImportPFXPage::CFinalInstalledImportPFXPage(HRESULT * phResult, CCertificate * pCert) 
	: CIISWizardBookEnd2(phResult,
		USE_DEFAULT_CAPTION,
		IDS_INSTALL_CERT_FAILURE_HEADER,
		IDS_CERTWIZ,
		&m_idBodyText,
		NULL,
		&pCert->m_idErrorText,
		&pCert->m_strErrorText,
		USE_DEFAULT_CAPTION,
		CFinalInstalledImportPFXPage::IDD),
		m_pCert(pCert)
{
	m_idBodyText = IDS_CERT_INSTALLED_SUCCESS;
}

CFinalInstalledImportPFXPage::~CFinalInstalledImportPFXPage()
{
}

BEGIN_MESSAGE_MAP(CFinalInstalledImportPFXPage, CIISWizardBookEnd2)
	//{{AFX_MSG_MAP(CFinalInstalledImportPFXPage)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()



/////////////////////////////////////////////////////////////////////////////
// CFinalInstalledPage property page

IMPLEMENT_DYNCREATE(CFinalInstalledExportPFXPage, CIISWizardBookEnd2)

CFinalInstalledExportPFXPage::CFinalInstalledExportPFXPage(HRESULT * phResult, CCertificate * pCert) 
	: CIISWizardBookEnd2(phResult,
		USE_DEFAULT_CAPTION,
		IDS_INSTALL_CERT_FAILURE_HEADER,
		IDS_CERTWIZ,
		&m_idBodyText,
		NULL,
		&pCert->m_idErrorText,
		&pCert->m_strErrorText,
		USE_DEFAULT_CAPTION,
		CFinalInstalledExportPFXPage::IDD),
		m_pCert(pCert)
{
	m_idBodyText = IDS_PFX_EXPORT_SUCCESS;
}

CFinalInstalledExportPFXPage::~CFinalInstalledExportPFXPage()
{
}

BEGIN_MESSAGE_MAP(CFinalInstalledExportPFXPage, CIISWizardBookEnd2)
	//{{AFX_MSG_MAP(CFinalInstalledExportPFXPage)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()



/////////////////////////////////////////////////////////////////////////////
// CFinalInstalledPage property page

IMPLEMENT_DYNCREATE(CFinalInstalledCopyFromRemotePage, CIISWizardBookEnd2)

CFinalInstalledCopyFromRemotePage::CFinalInstalledCopyFromRemotePage(HRESULT * phResult, CCertificate * pCert) 
	: CIISWizardBookEnd2(phResult,
		USE_DEFAULT_CAPTION,
		IDS_INSTALL_CERT_FAILURE_HEADER,
		IDS_CERTWIZ,
		&m_idBodyText,
		NULL,
		&pCert->m_idErrorText,
		&pCert->m_strErrorText,
		USE_DEFAULT_CAPTION,
		CFinalInstalledCopyFromRemotePage::IDD),
		m_pCert(pCert)
{
	m_idBodyText = IDS_CERT_INSTALLED_SUCCESS;
}

CFinalInstalledCopyFromRemotePage::~CFinalInstalledCopyFromRemotePage()
{
}

BEGIN_MESSAGE_MAP(CFinalInstalledCopyFromRemotePage, CIISWizardBookEnd2)
	//{{AFX_MSG_MAP(CFinalInstalledCopyFromRemotePage)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CFinalInstalledPage property page

IMPLEMENT_DYNCREATE(CFinalInstalledMoveFromRemotePage, CIISWizardBookEnd2)

CFinalInstalledMoveFromRemotePage::CFinalInstalledMoveFromRemotePage(HRESULT * phResult, CCertificate * pCert) 
	: CIISWizardBookEnd2(phResult,
		USE_DEFAULT_CAPTION,
		IDS_INSTALL_CERT_FAILURE_HEADER,
		IDS_CERTWIZ,
		&m_idBodyText,
		NULL,
		&pCert->m_idErrorText,
		&pCert->m_strErrorText,
		USE_DEFAULT_CAPTION,
		CFinalInstalledMoveFromRemotePage::IDD),
		m_pCert(pCert)
{
	m_idBodyText = IDS_CERT_INSTALLED_SUCCESS;
}

CFinalInstalledMoveFromRemotePage::~CFinalInstalledMoveFromRemotePage()
{
}

BEGIN_MESSAGE_MAP(CFinalInstalledMoveFromRemotePage, CIISWizardBookEnd2)
	//{{AFX_MSG_MAP(CFinalInstalledMoveFromRemotePage)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CFinalInstalledPage property page

IMPLEMENT_DYNCREATE(CFinalInstalledCopyToRemotePage, CIISWizardBookEnd2)

CFinalInstalledCopyToRemotePage::CFinalInstalledCopyToRemotePage(HRESULT * phResult, CCertificate * pCert) 
	: CIISWizardBookEnd2(phResult,
		USE_DEFAULT_CAPTION,
		IDS_INSTALL_CERT_FAILURE_HEADER,
		IDS_CERTWIZ,
		&m_idBodyText,
		NULL,
		&pCert->m_idErrorText,
		&pCert->m_strErrorText,
		USE_DEFAULT_CAPTION,
		CFinalInstalledCopyToRemotePage::IDD),
		m_pCert(pCert)
{
	m_idBodyText = IDS_CERT_INSTALLED_SUCCESS;
}

CFinalInstalledCopyToRemotePage::~CFinalInstalledCopyToRemotePage()
{
}

BEGIN_MESSAGE_MAP(CFinalInstalledCopyToRemotePage, CIISWizardBookEnd2)
	//{{AFX_MSG_MAP(CFinalInstalledCopyToRemotePage)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CFinalInstalledPage property page

IMPLEMENT_DYNCREATE(CFinalInstalledMoveToRemotePage, CIISWizardBookEnd2)

CFinalInstalledMoveToRemotePage::CFinalInstalledMoveToRemotePage(HRESULT * phResult, CCertificate * pCert) 
	: CIISWizardBookEnd2(phResult,
		USE_DEFAULT_CAPTION,
		IDS_INSTALL_CERT_FAILURE_HEADER,
		IDS_CERTWIZ,
		&m_idBodyText,
		NULL,
		&pCert->m_idErrorText,
		&pCert->m_strErrorText,
		USE_DEFAULT_CAPTION,
		CFinalInstalledMoveToRemotePage::IDD),
		m_pCert(pCert)
{
	m_idBodyText = IDS_CERT_INSTALLED_SUCCESS;
}

CFinalInstalledMoveToRemotePage::~CFinalInstalledMoveToRemotePage()
{
}

BEGIN_MESSAGE_MAP(CFinalInstalledMoveToRemotePage, CIISWizardBookEnd2)
	//{{AFX_MSG_MAP(CFinalInstalledMoveToRemotePage)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\certwiz\geoinfopage.cpp ===
// GeoInfoPage.cpp : implementation file
//

#include "stdafx.h"
#include "CertWiz.h"
#include "GeoInfoPage.h"
#include "Certificat.h"
#include "mru.h"
#include "strutil.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CGeoInfoPage property page

IMPLEMENT_DYNCREATE(CGeoInfoPage, CIISWizardPage)

CGeoInfoPage::CGeoInfoPage(CCertificate * pCert) 
	: CIISWizardPage(CGeoInfoPage::IDD, IDS_CERTWIZ, TRUE),
	m_pCert(pCert)
{
	//{{AFX_DATA_INIT(CGeoInfoPage)
	m_Locality = _T("");
	m_State = _T("");
	m_Country = _T("");
	//}}AFX_DATA_INIT
}

CGeoInfoPage::~CGeoInfoPage()
{
}

void CGeoInfoPage::DoDataExchange(CDataExchange* pDX)
{
	CIISWizardPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CGeoInfoPage)
	DDX_Text(pDX, IDC_NEWKEY_LOCALITY, m_Locality);
	DDV_MaxCharsCombo(pDX, IDC_NEWKEY_LOCALITY, m_Locality, 64);
	DDX_Text(pDX, IDC_NEWKEY_STATE, m_State);
	DDV_MaxCharsCombo(pDX, IDC_NEWKEY_STATE, m_State, 64);
	DDX_CBString(pDX, IDC_NEWKEY_COUNTRY, m_Country);
	//}}AFX_DATA_MAP
}

LRESULT 
CGeoInfoPage::OnWizardPrev()
{
	return IDD_PAGE_PREV;
//	return m_pCert->m_CAType == CCertificate::CA_OFFLINE ?
//		IDD_PAGE_PREV_FILE : IDD_PAGE_PREV_ONLINE;
}

LRESULT 
CGeoInfoPage::OnWizardNext()
{
    LRESULT lres = 1;

	ASSERT(m_pCert != NULL);
	UpdateData(TRUE);
	m_pCert->m_Locality = m_Locality;
	m_pCert->m_State = m_State;
	m_countryCombo.GetSelectedCountry(m_pCert->m_Country);

    CString buf;
    buf.LoadString(IDS_INVALID_X500_CHARACTERS);

    if (!IsValidX500Chars(m_pCert->m_Country))
    {
        GetDlgItem(IDC_NEWKEY_COUNTRY)->SetFocus();
        AfxMessageBox(buf, MB_OK);
    }
    else if (!IsValidX500Chars(m_State))
    {
        GetDlgItem(IDC_NEWKEY_STATE)->SetFocus();
        AfxMessageBox(buf, MB_OK);
    }
    else if (!IsValidX500Chars(m_Locality))
    {
        GetDlgItem(IDC_NEWKEY_LOCALITY)->SetFocus();
        AfxMessageBox(buf, MB_OK);
    }
    else
    {
        lres = m_pCert->m_CAType == CCertificate::CA_OFFLINE ? IDD_PAGE_NEXT_FILE : IDD_PAGE_NEXT_ONLINE;
    }

	return lres;
}

BOOL CGeoInfoPage::OnSetActive()
{
	SetButtons();
	return CIISWizardPage::OnSetActive();
}

void CGeoInfoPage::SetButtons()
{
	UpdateData(TRUE);	
	SetWizardButtons(m_Country.IsEmpty() || m_Locality.IsEmpty() ? 
			PSWIZB_BACK : PSWIZB_BACK | PSWIZB_NEXT);
}

BEGIN_MESSAGE_MAP(CGeoInfoPage, CIISWizardPage)
	//{{AFX_MSG_MAP(CGeoInfoPage)
	ON_CBN_EDITCHANGE(IDC_NEWKEY_LOCALITY, OnChangeNewkeyLocality)
	ON_CBN_EDITCHANGE(IDC_NEWKEY_STATE, OnChangeNewkeyState)
	ON_CBN_EDITCHANGE(IDC_NEWKEY_COUNTRY, OnEditchangeNewkeyCountry)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CGeoInfoPage message handlers

BOOL CGeoInfoPage::OnInitDialog() 
{
	ASSERT(m_pCert != NULL);
	m_Locality = m_pCert->m_Locality;
	m_State = m_pCert->m_State;
	m_countryCombo.SubclassDlgItem(IDC_NEWKEY_COUNTRY, this);
	CIISWizardPage::OnInitDialog();
	m_countryCombo.Init();
	m_countryCombo.SetSelectedCountry(m_pCert->m_Country);
	// Load MRU names
	LoadMRUToCombo(this, IDC_NEWKEY_STATE, szStateMRU, m_State, MAX_MRU);
	LoadMRUToCombo(this, IDC_NEWKEY_LOCALITY, szLocalityMRU, m_Locality, MAX_MRU);
	SetButtons();
	GetDlgItem(IDC_NEWKEY_COUNTRY)->SetFocus();
	return FALSE;
}

void CGeoInfoPage::OnChangeNewkeyLocality() 
{
	SetButtons();
}

void CGeoInfoPage::OnChangeNewkeyState() 
{
	SetButtons();
}

void CGeoInfoPage::OnEditchangeNewkeyCountry() 
{
	SetButtons();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\certwiz\geoinfopage.h ===
#if !defined(_GEOINFOPAGE_H)
#define _GEOINFOPAGE_H

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// GeoInfoPage.h : header file
//
#include "CountryComboBox.h"

class CCertificate;

/////////////////////////////////////////////////////////////////////////////
// CGeoInfoPage dialog

class CGeoInfoPage : public CIISWizardPage
{
	DECLARE_DYNCREATE(CGeoInfoPage)

// Construction
public:
	CGeoInfoPage(CCertificate * pCert = NULL);
	~CGeoInfoPage();

	enum
	{
		IDD_PAGE_PREV = IDD_PAGE_WIZ_SITE_NAME,
		IDD_PAGE_NEXT_FILE = IDD_PAGE_WIZ_CHOOSE_FILENAME,
		IDD_PAGE_NEXT_ONLINE = IDD_PAGE_WIZ_CHOOSE_ONLINE
	};
// Dialog Data
	//{{AFX_DATA(CGeoInfoPage)
	enum { IDD = IDD_PAGE_WIZ_GEO_INFO };
	CString	m_Locality;
	CString	m_State;
	CString	m_Country;
	//}}AFX_DATA
	CCertificate * m_pCert;
	CCountryComboBox m_countryCombo;

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CGeoInfoPage)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	public:
	virtual LRESULT OnWizardNext();
	virtual LRESULT OnWizardPrev();
	virtual BOOL OnSetActive();
//	virtual BOOL OnKillActive();
	//}}AFX_VIRTUAL

// Implementation
protected:
	void SetButtons();
	void GetSelectedCountry(CString& str);
	void SetSelectedCountry(CString& str);
	// Generated message map functions
	//{{AFX_MSG(CGeoInfoPage)
	virtual BOOL OnInitDialog();
	afx_msg void OnChangeNewkeyLocality();
	afx_msg void OnChangeNewkeyState();
	afx_msg void OnEditchangeNewkeyCountry();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(_GEOINFOPAGE_H)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\certwiz\getwhatpage.h ===
#if !defined(AFX_GETWHATPAGE_H__E8F5A02F_1372_11D2_8A1D_000000000000__INCLUDED_)
#define AFX_GETWHATPAGE_H__E8F5A02F_1372_11D2_8A1D_000000000000__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// GetWhatPage.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CGetWhatPage window
class CCertificate;

class CGetWhatPage : public CIISWizardPage
{
	DECLARE_DYNCREATE(CGetWhatPage)
// Construction
public:
	CGetWhatPage(CCertificate * pCert = NULL);
	~CGetWhatPage();

	enum
	{
		IDD_PAGE_PREV = IDD_PAGE_WELCOME_START,
		IDD_PAGE_NEXT_NEW = IDD_PAGE_WIZ_CHOOSE_CATYPE,
		IDD_PAGE_NEXT_EXISTING = IDD_PAGE_WIZ_CHOOSE_CERT,
		IDD_PAGE_NEXT_IMPORT = IDD_PAGE_WIZ_GETKEY_FILE,
        IDD_PAGE_NEXT_IMPORT_PFX = IDD_PAGE_WIZ_GET_IMPORT_PFX_FILE,
        IDD_PAGE_NEXT_COPY_MOVE_REMOTE = IDD_PAGE_WIZ_CHOOSE_COPY_MOVE_FROM_REMOTE
	};
// Dialog Data
	//{{AFX_DATA(CGetWhatPage)
	enum { IDD = IDD_PAGE_WIZ_GET_WHAT };
	int		m_Index;
	//}}AFX_DATA
	CCertificate * m_pCert;

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CGetWhatPage)
   public:
   virtual BOOL OnSetActive();
	virtual LRESULT OnWizardPrev();
	virtual LRESULT OnWizardNext();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CGetWhatPage)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_GETWHATPAGE_H__E8F5A02F_1372_11D2_8A1D_000000000000__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\certwiz\getwhatpage.cpp ===
// GetWhatPage.cpp : implementation file
//

#include "stdafx.h"
#include "CertWiz.h"
#include "GetWhatPage.h"
#include "Certificat.h"
#include "certutil.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CGetWhatPage property page

IMPLEMENT_DYNCREATE(CGetWhatPage, CIISWizardPage)

CGetWhatPage::CGetWhatPage(CCertificate * pCert) 
	: CIISWizardPage(CGetWhatPage::IDD, IDS_CERTWIZ, TRUE),
	m_pCert(pCert)
{
	//{{AFX_DATA_INIT(CGetWhatPage)
	m_Index = -1;
	//}}AFX_DATA_INIT
}

CGetWhatPage::~CGetWhatPage()
{
}

void CGetWhatPage::DoDataExchange(CDataExchange* pDX)
{
	CIISWizardPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CGetWhatPage)
	DDX_Radio(pDX, IDC_RADIO0, m_Index);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CGetWhatPage, CIISWizardPage)
	//{{AFX_MSG_MAP(CGetWhatPage)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CWelcomePage message handlers

BOOL 
CGetWhatPage::OnSetActive() 
{
	m_pCert->SetStatusCode(CCertificate::REQUEST_UNDEFINED);
   SetWizardButtons(PSWIZB_BACK | PSWIZB_NEXT);
   return CIISWizardPage::OnSetActive();
}

enum 
{
	REQUEST_NEW_CERT = 0,
	INSTALL_EXISTING_CERT,
	IMPORT_KEYRING_CERT,
    IMPORT_CERT,
    COPY_MOVE_REMOTE_CERT,
};

LRESULT 
CGetWhatPage::OnWizardPrev()
{
	return IDD_PAGE_PREV;
}

LRESULT 
CGetWhatPage::OnWizardNext()
{
	UpdateData();
	switch (m_Index)
	{
	case REQUEST_NEW_CERT:
		m_pCert->SetStatusCode(CCertificate::REQUEST_NEW_CERT);
		return IDD_PAGE_NEXT_NEW;
	case INSTALL_EXISTING_CERT:
		m_pCert->SetStatusCode(CCertificate::REQUEST_INSTALL_CERT);
		return IDD_PAGE_NEXT_EXISTING;
	case IMPORT_KEYRING_CERT:
		m_pCert->SetStatusCode(CCertificate::REQUEST_IMPORT_KEYRING);
		return IDD_PAGE_NEXT_IMPORT;
	case IMPORT_CERT:
		m_pCert->SetStatusCode(CCertificate::REQUEST_IMPORT_CERT);
		return IDD_PAGE_NEXT_IMPORT_PFX;
	case COPY_MOVE_REMOTE_CERT:
		m_pCert->SetStatusCode(CCertificate::REQUEST_COPY_MOVE_FROM_REMOTE);
		return IDD_PAGE_NEXT_COPY_MOVE_REMOTE;
	default:
		ASSERT(FALSE);
	}
	return 1;
}

BOOL CGetWhatPage::OnInitDialog() 
{
	ASSERT(m_pCert != NULL);
	m_Index = 0;
	CIISWizardPage::OnInitDialog();
   if (GetDlgItem(IDC_RADIO0) != NULL)
   {
	   GetDlgItem(IDC_RADIO0)->SetFocus();
   }

   // Enable or disable controls based on weather certobj is installed
   GetDlgItem(IDC_RADIO3)->EnableWindow(m_pCert->m_CertObjInstalled);
   GetDlgItem(IDC_RADIO4)->EnableWindow(m_pCert->m_CertObjInstalled);

   if (m_pCert->m_CertObjInstalled)
   {
       GetDlgItem(IDC_RADIO3)->ShowWindow(SW_SHOW);
       GetDlgItem(IDC_RADIO4)->ShowWindow(SW_SHOW);
   }

   // Turn off for workstation.
   if (TRUE == IsWhistlerWorkstation())
   {
       GetDlgItem(IDC_RADIO3)->ShowWindow(SW_HIDE);
       GetDlgItem(IDC_RADIO4)->ShowWindow(SW_HIDE);
   }
   return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\certwiz\hotlink.cpp ===
// HotLink.cpp : implementation file
//

#include "stdafx.h"
#include "resource.h"
#include "HotLink.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define COLOR_BLUE			RGB(0, 0, 0xFF)
#define COLOR_YELLOW		RGB(0xff, 0x80, 0)

/////////////////////////////////////////////////////////////////////////////
// CHotLink

CHotLink::CHotLink():
    m_CapturedMouse(FALSE),
    m_fBrowse(FALSE),
    m_fExplore(FALSE),
    m_fOpen(TRUE),
    m_fInitializedFont(FALSE)
{
}

CHotLink::~CHotLink()
{
}

BEGIN_MESSAGE_MAP(CHotLink, CButton)
	//{{AFX_MSG_MAP(CHotLink)
	ON_WM_LBUTTONDOWN()
	ON_WM_LBUTTONUP()
	ON_WM_MOUSEMOVE()
	ON_WM_CAPTURECHANGED()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

//------------------------------------------------------------------------
// set the title string
void CHotLink::SetTitle( CString sz )
{
    // set the title
    SetWindowText( sz );
    // force the window to redraw
    Invalidate( TRUE );
}

/////////////////////////////////////////////////////////////////////////////
// CHotLink message handlers

//------------------------------------------------------------------------
void CHotLink::DrawItem( LPDRAWITEMSTRUCT lpDrawItemStruct )
{
	// prep the device context
	CDC* pdc = CDC::FromHandle(lpDrawItemStruct->hDC);

	// get the drawing rect
	CRect rect = lpDrawItemStruct->rcItem;
	CString sz;
	GetWindowText(sz);

	if (!m_fInitializedFont)
	{
		// get the window font
		LOGFONT logfont;
		HFONT hFont = (HFONT)SendMessage(WM_GETFONT, 0, 0);
		ASSERT(hFont != NULL);
		VERIFY(0 < GetObject(hFont, sizeof(LOGFONT), &logfont));

		// modify the font  - add underlining
		logfont.lfUnderline = TRUE;

        // set the font back
		HFONT hNewFont = ::CreateFontIndirect(&logfont);
		ASSERT(hNewFont != NULL);
		SendMessage(WM_SETFONT, (WPARAM)hNewFont, MAKELPARAM(TRUE, 0));
		// get the extents fo the text for later reference
		m_cpTextExtents = pdc->GetOutputTextExtent(sz);
		// get the main rect
		GetClientRect(m_rcText);

		// reduce it by the width of the text
		m_rcText.left = m_rcText.left + (m_rcText.Width() - m_cpTextExtents.cx) / 2;
		m_rcText.right = m_rcText.left + m_cpTextExtents.cx;
		m_rcText.top = m_rcText.top + (m_rcText.Height() - m_cpTextExtents.cy) / 2;
		m_rcText.bottom = m_rcText.top + m_cpTextExtents.cy;
		m_clrText = COLOR_BLUE;
		m_fInitializedFont = TRUE;
	}

	// draw the text in color that was set outside
	pdc->SetTextColor(m_clrText);
	
	// draw the text
	pdc->DrawText(sz, &rect, DT_CENTER|DT_SINGLELINE|DT_VCENTER);
}

//------------------------------------------------------------------------
// calculate the rectangle that surrounds the text
void CHotLink::GetTextRect( CRect &rect )
{
    // get the main rect
    GetClientRect( rect );

    // reduce it by margins
	// Calculations below are for centered text. To locate it inside
	// the dialog just make it tight and move control itself
	rect.left = rect.left + (rect.Width() - m_cpTextExtents.cx) / 2;
    rect.right = rect.left + m_cpTextExtents.cx;
	rect.top = rect.top + (rect.Height() - m_cpTextExtents.cy) / 2;
	rect.bottom = rect.top + m_cpTextExtents.cy;
}

//------------------------------------------------------------------------
void CHotLink::OnLButtonDown(UINT nFlags, CPoint point)
{
   	// don't do the hotlink thing if there is no text
	if (!m_strLink.IsEmpty() && !m_CapturedMouse && m_rcText.PtInRect(point))
   	{
		SetCapture();
      	m_CapturedMouse = TRUE;
   	}
}

//------------------------------------------------------------------------
void CHotLink::OnLButtonUp(UINT nFlags, CPoint point)
{
	// only bother if we have the capture
   if (m_CapturedMouse)
   {
		ReleaseCapture();
      	if ( m_fBrowse )
			Browse();
      	else if ( m_fExplore )
			Explore();
      	else if ( m_fOpen )
			Open();
	}
}

//------------------------------------------------------------------------
void CHotLink::Browse()
{
    ShellExecute(
        NULL,			// handle to parent window
        NULL,			// pointer to string that specifies operation to perform
        m_strLink,		// pointer to filename or folder name string
        NULL,			// pointer to string that specifies executable-file parameters
        NULL,			// pointer to string that specifies default directory
        SW_SHOW 		// whether file is shown when opened
       );
}

//------------------------------------------------------------------------
void CHotLink::Explore()
{
    ShellExecute(
        NULL,			// handle to parent window
        _T("explore"),	// pointer to string that specifies operation to perform
        m_strLink,		// pointer to filename or folder name string
        NULL,			// pointer to string that specifies executable-file parameters
        NULL,			// pointer to string that specifies default directory
        SW_SHOW 		// whether file is shown when opened
       );
}

//------------------------------------------------------------------------
void CHotLink::Open()
{
    ShellExecute(
        NULL,			// handle to parent window
        _T("open"),		// pointer to string that specifies operation to perform
        m_strLink,		// pointer to filename or folder name string
        NULL,			// pointer to string that specifies executable-file parameters
        NULL,			// pointer to string that specifies default directory
        SW_SHOW 		// whether file is shown when opened
       );
}

//------------------------------------------------------------------------
void CHotLink::OnMouseMove(UINT nFlags, CPoint point)
{
	CRect   rect;
	GetTextRect(rect);
	// if the mouse is over the hot area, show the right cursor
	if (rect.PtInRect(point))
	{
		::SetCursor(AfxGetApp()->LoadCursor(IDC_BROWSE_CUR));
		// also reset text color to *yellow*
		if (m_clrText != COLOR_YELLOW)
		{
			m_clrText = COLOR_YELLOW;
			InvalidateRect(m_rcText, FALSE);
			UpdateWindow();
		}
	}
	else 
	{
		if (m_clrText != COLOR_BLUE)
		// we are not pointing to text, render it in *blue*
		{
			m_clrText = COLOR_BLUE;
			InvalidateRect(m_rcText, FALSE);
			UpdateWindow();
		}
		// also remove capture and reset the cursor
		ReleaseCapture();
		::SetCursor(AfxGetApp()->LoadCursor(IDC_ARROW));
	}
}

void CHotLink::OnCaptureChanged(CWnd *pWnd) 
{
	m_clrText = COLOR_BLUE;
	InvalidateRect(m_rcText, FALSE);
	UpdateWindow();
	m_CapturedMouse = FALSE;
	CButton::OnCaptureChanged(pWnd);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\certwiz\hotlink.h ===
// HotLink.h : header file
//
#ifndef _HOTLINK_H
#define _HOTLINK_H

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

/////////////////////////////////////////////////////////////////////////////
// CHotLink window

class CHotLink : public CButton
{
// Construction
public:
	CHotLink();

// Attributes
public:
    BOOL    m_fBrowse;
    BOOL    m_fExplore;
    BOOL    m_fOpen;

// Operations
public:
    void Browse();
    void Explore();
    void Open();

    virtual void DrawItem( LPDRAWITEMSTRUCT lpDrawItemStruct );

    // set the title string
    void SetTitle( CString sz );
	void SetLink(const CString& sz)
	{
		m_strLink = sz;
	}
	void SetLink(UINT id)
	{
		VERIFY(m_strLink.LoadString(id));
	}

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CHotLink)
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CHotLink();

	// Generated message map functions
protected:
	//{{AFX_MSG(CHotLink)
	afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnLButtonUp(UINT nFlags, CPoint point);
	afx_msg void OnMouseMove(UINT nFlags, CPoint point);
	afx_msg void OnCaptureChanged(CWnd *pWnd);
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()

    // height and width of the displayed text
    void GetTextRect( CRect &rect );
    CSize   m_cpTextExtents;
	CRect m_rcText;
	COLORREF m_clrText;
	// URL for link could be not the same as caption
	CString m_strLink;

    // tracking the mouse flag
    BOOL    m_CapturedMouse;

    // init the font
    BOOL    m_fInitializedFont;
};

/////////////////////////////////////////////////////////////////////////////
#endif // _HOTLINK_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\certwiz\finalpages.h ===
#if !defined(AFX_FINALPAGES_H__98544A13_3C60_11D2_8180_0000F87A921B__INCLUDED_)
#define AFX_FINALPAGES_H__98544A13_3C60_11D2_8180_0000F87A921B__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// FinalPages.h : header file
//
#include "HotLink.h"
#include "BookEndPage.h"

class CCertificate;

/////////////////////////////////////////////////////////////////////////////
// CFinalInstalledPage dialog
class CFinalInstalledPage : public CIISWizardBookEnd2
{
	DECLARE_DYNCREATE(CFinalInstalledPage)

	enum
	{
		IDD_PAGE_PREV = IDD_PAGE_WIZ_INSTALL_RESP
	};
// Construction
public:
	CFinalInstalledPage(HRESULT * phResult = NULL, CCertificate * pCert = NULL);
	~CFinalInstalledPage();

// Dialog Data
	//{{AFX_DATA(CFinalInstalledPage)
	enum { IDD = IDD_PAGE_WIZ_FINAL_INSTALL };
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA
	CCertificate * m_pCert;
	UINT m_idBodyText;

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CFinalInstalledPage)
	public:
	protected:
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CFinalInstalledPage)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

/////////////////////////////////////////////////////////////////////////////
// CFinalReplacedPage dialog
class CFinalReplacedPage : public CIISWizardBookEnd2
{
	DECLARE_DYNCREATE(CFinalReplacedPage)

	enum
	{
		IDD_PAGE_PREV = IDD_PAGE_WIZ_REPLACE_CERT
	};
// Construction
public:
	CFinalReplacedPage(HRESULT * phResult = NULL, CCertificate * pCert = NULL);
	~CFinalReplacedPage();

// Dialog Data
	//{{AFX_DATA(CFinalReplacedPage)
	enum { IDD = IDD_PAGE_WIZ_FINAL_REPLACE };
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA
	CCertificate * m_pCert;
	UINT m_idBodyText;

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CFinalReplacedPage)
	public:
	protected:
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CFinalReplacedPage)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

/////////////////////////////////////////////////////////////////////////////
// CFinalRemovePage dialog
class CFinalRemovePage : public CIISWizardBookEnd2
{
	DECLARE_DYNCREATE(CFinalRemovePage)

// Construction
public:
	CFinalRemovePage(HRESULT * phResult = NULL, CCertificate * pCert = NULL);
	~CFinalRemovePage();

	enum
	{
		IDD_PAGE_PREV = IDD_PAGE_WIZ_REMOVE_CERT,
	};
// Dialog Data
	//{{AFX_DATA(CFinalRemovePage)
	enum { IDD = IDD_PAGE_WIZ_FINAL_REMOVE };
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA
	CCertificate * m_pCert;
	UINT m_idBodyText;


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CFinalRemovePage)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CFinalRemovePage)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

/////////////////////////////////////////////////////////////////////////////
// CFinalToFilePage dialog

class CFinalToFilePage : public CIISWizardBookEnd2
{
	DECLARE_DYNCREATE(CFinalToFilePage)

// Construction
public:
	CFinalToFilePage(HRESULT * phResult = NULL, CCertificate * pCert = NULL);
	~CFinalToFilePage();

	enum
	{
		IDD_PAGE_PREV = IDD_PAGE_WIZ_REQUEST_DUMP
	};
// Dialog Data
	//{{AFX_DATA(CFinalToFilePage)
	enum { IDD = IDD_PAGE_WIZ_FINAL_TO_FILE };
	CHotLink	m_hotlink_codessite;
	//}}AFX_DATA
	CCertificate * m_pCert;

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CFinalToFilePage)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	public:
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CFinalToFilePage)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

/////////////////////////////////////////////////////////////////////////////
// CFinalCancelPage dialog
class CFinalCancelPage : public CIISWizardBookEnd2
{
	DECLARE_DYNCREATE(CFinalCancelPage)

// Construction
public:
	CFinalCancelPage(HRESULT * phResult = NULL, CCertificate * pCert = NULL);
	~CFinalCancelPage();

	enum
	{
		IDD_PAGE_PREV = IDD_PAGE_WIZ_CANCEL_REQUEST,
	};
// Dialog Data
	//{{AFX_DATA(CFinalCancelPage)
	enum { IDD = IDD_PAGE_WIZ_FINAL_CANCEL };
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA
	CCertificate * m_pCert;
	UINT m_idBodyText;


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CFinalCancelPage)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CFinalCancelPage)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};



/////////////////////////////////////////////////////////////////////////////
// CFinalInstalledPage dialog
class CFinalInstalledImportPFXPage : public CIISWizardBookEnd2
{
	DECLARE_DYNCREATE(CFinalInstalledImportPFXPage)

	enum
	{
		IDD_PAGE_PREV = IDD_PAGE_WIZ_INSTALL_IMPORT_PFX
	};
// Construction
public:
	CFinalInstalledImportPFXPage(HRESULT * phResult = NULL, CCertificate * pCert = NULL);
	~CFinalInstalledImportPFXPage();

// Dialog Data
	//{{AFX_DATA(CFinalInstalledImportPFXPage)
	enum { IDD = IDD_PAGE_WIZ_FINAL_INSTALL_IMPORT_PFX };
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA
	CCertificate * m_pCert;
	UINT m_idBodyText;

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CFinalInstalledImportPFXPage)
	public:
	protected:
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CFinalInstalledImportPFXPage)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};



/////////////////////////////////////////////////////////////////////////////
// CFinalInstalledPage dialog
class CFinalInstalledExportPFXPage : public CIISWizardBookEnd2
{
	DECLARE_DYNCREATE(CFinalInstalledExportPFXPage)

	enum
	{
		IDD_PAGE_PREV = IDD_PAGE_WIZ_INSTALL_EXPORT_PFX
	};
// Construction
public:
	CFinalInstalledExportPFXPage(HRESULT * phResult = NULL, CCertificate * pCert = NULL);
	~CFinalInstalledExportPFXPage();

// Dialog Data
	//{{AFX_DATA(CFinalInstalledExportPFXPage)
	enum { IDD = IDD_PAGE_WIZ_FINAL_INSTALL_EXPORT_PFX };
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA
	CCertificate * m_pCert;
	UINT m_idBodyText;

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CFinalInstalledExportPFXPage)
	public:
	protected:
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CFinalInstalledExportPFXPage)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};


/////////////////////////////////////////////////////////////////////////////
// CFinalInstalledPage dialog
class CFinalInstalledCopyFromRemotePage : public CIISWizardBookEnd2
{
	DECLARE_DYNCREATE(CFinalInstalledCopyFromRemotePage)

	enum
	{
		IDD_PAGE_PREV = IDD_PAGE_WIZ_CHOOSE_SERVER_SITE
	};
// Construction
public:
	CFinalInstalledCopyFromRemotePage(HRESULT * phResult = NULL, CCertificate * pCert = NULL);
	~CFinalInstalledCopyFromRemotePage();

// Dialog Data
	//{{AFX_DATA(CFinalInstalledCopyFromRemotePage)
	enum { IDD = IDD_PAGE_WIZ_FINAL_INSTALL_COPY_FROM_REMOTE };
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA
	CCertificate * m_pCert;
	UINT m_idBodyText;

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CFinalInstalledCopyFromRemotePage)
	public:
	protected:
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CFinalInstalledCopyFromRemotePage)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

class CFinalInstalledMoveFromRemotePage : public CIISWizardBookEnd2
{
	DECLARE_DYNCREATE(CFinalInstalledMoveFromRemotePage)

	enum
	{
		IDD_PAGE_PREV = IDD_PAGE_WIZ_CHOOSE_SERVER_SITE
	};
// Construction
public:
	CFinalInstalledMoveFromRemotePage(HRESULT * phResult = NULL, CCertificate * pCert = NULL);
	~CFinalInstalledMoveFromRemotePage();

// Dialog Data
	//{{AFX_DATA(CFinalInstalledMoveFromRemotePage)
	enum { IDD = IDD_PAGE_WIZ_FINAL_INSTALL_MOVE_FROM_REMOTE };
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA
	CCertificate * m_pCert;
	UINT m_idBodyText;

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CFinalInstalledMoveFromRemotePage)
	public:
	protected:
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CFinalInstalledMoveFromRemotePage)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

class CFinalInstalledCopyToRemotePage : public CIISWizardBookEnd2
{
	DECLARE_DYNCREATE(CFinalInstalledCopyToRemotePage)

	enum
	{
		IDD_PAGE_PREV = IDD_PAGE_WIZ_CHOOSE_SERVER_SITE
	};
// Construction
public:
	CFinalInstalledCopyToRemotePage(HRESULT * phResult = NULL, CCertificate * pCert = NULL);
	~CFinalInstalledCopyToRemotePage();

// Dialog Data
	//{{AFX_DATA(CFinalInstalledCopyToRemotePage)
	enum { IDD = IDD_PAGE_WIZ_FINAL_INSTALL_COPY_TO_REMOTE };
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA
	CCertificate * m_pCert;
	UINT m_idBodyText;

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CFinalInstalledCopyToRemotePage)
	public:
	protected:
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CFinalInstalledCopyToRemotePage)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};


class CFinalInstalledMoveToRemotePage : public CIISWizardBookEnd2
{
	DECLARE_DYNCREATE(CFinalInstalledMoveToRemotePage)

	enum
	{
		IDD_PAGE_PREV = IDD_PAGE_WIZ_CHOOSE_SERVER_SITE
	};
// Construction
public:
	CFinalInstalledMoveToRemotePage(HRESULT * phResult = NULL, CCertificate * pCert = NULL);
	~CFinalInstalledMoveToRemotePage();

// Dialog Data
	//{{AFX_DATA(CFinalInstalledMoveToRemotePage)
	enum { IDD = IDD_PAGE_WIZ_FINAL_INSTALL_MOVE_TO_REMOTE };
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA
	CCertificate * m_pCert;
	UINT m_idBodyText;

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CFinalInstalledMoveToRemotePage)
	public:
	protected:
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CFinalInstalledMoveToRemotePage)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_FINALPAGES_H__98544A13_3C60_11D2_8180_0000F87A921B__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\certwiz\iisdebug.h ===
#include "stdafx.h"

//#define DEBUG_FLAG

#ifdef DEBUG_FLAG
    inline void _cdecl DebugTrace(LPTSTR lpszFormat, ...)
    {
	    int nBuf;
	    TCHAR szBuffer[512];
	    va_list args;
	    va_start(args, lpszFormat);

	    nBuf = _vsntprintf(szBuffer, sizeof(szBuffer), lpszFormat, args);
	    ASSERT(nBuf < sizeof(szBuffer)); //Output truncated as it was > sizeof(szBuffer)

	    OutputDebugString(szBuffer);
	    va_end(args);
    }
#else
    inline void _cdecl DebugTrace(LPTSTR , ...){}
#endif

#define IISDebugOutput DebugTrace
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\certwiz\keypasswordpage.cpp ===
// KeyPasswordPage.cpp : implementation file
//

#include "stdafx.h"
#include "CertWiz.h"
#include "KeyPasswordPage.h"
#include "Certificat.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CKeyPasswordPage property page

IMPLEMENT_DYNCREATE(CKeyPasswordPage, CIISWizardPage)

CKeyPasswordPage::CKeyPasswordPage(CCertificate * pCert) 
	: CIISWizardPage(CKeyPasswordPage::IDD, IDS_CERTWIZ, TRUE),
	m_pCert(pCert)
{
	//{{AFX_DATA_INIT(CKeyPasswordPage)
	m_Password = _T("");
	//}}AFX_DATA_INIT
}

CKeyPasswordPage::~CKeyPasswordPage()
{
}

void CKeyPasswordPage::DoDataExchange(CDataExchange* pDX)
{
	CIISWizardPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CKeyPasswordPage)
	DDX_Text(pDX, IDC_KEYPASSWORD, m_Password);
	DDV_MaxChars(pDX, m_Password, 64);
	//}}AFX_DATA_MAP
}

LRESULT 
CKeyPasswordPage::OnWizardBack()
/*++
Routine Description:
    Prev button handler

Arguments:
    None

Return Value:
	0 to automatically advance to the prev page;
	1 to prevent the page from changing. 
	To jump to a page other than the prev one, 
	return the identifier of the dialog to be displayed.
--*/
{
	return IDD_PAGE_PREV;
}

LRESULT 
CKeyPasswordPage::OnWizardNext()
{
	UpdateData(TRUE);
	if (0 != m_Password.Compare(m_pCert->m_KeyPassword))
	{
		m_pCert->DeleteKeyRingCert();
		m_pCert->m_KeyPassword = m_Password;
	}

	if (NULL == m_pCert->GetKeyRingCert())
	{
		// probably password was wrong
		CString txt;
		txt.LoadString(IDS_FAILED_IMPORT_KEY_FILE);
		ASSERT(GetDlgItem(IDC_ERROR_TEXT) != NULL);
		SetDlgItemText(IDC_ERROR_TEXT, txt);
		GetDlgItem(IDC_KEYPASSWORD)->SetFocus();
		GetDlgItem(IDC_KEYPASSWORD)->SendMessage(EM_SETSEL, 0, -1);
		SetWizardButtons(PSWIZB_BACK);
		return 1;
	}
	return IDD_PAGE_NEXT;
}

BOOL 
CKeyPasswordPage::OnSetActive() 
{
	ASSERT(m_pCert != NULL);
	m_Password = m_pCert->m_KeyPassword;
	UpdateData(FALSE);
	SetWizardButtons(m_Password.IsEmpty() || m_pCert->GetKeyRingCert() == NULL ?
			PSWIZB_BACK : PSWIZB_BACK | PSWIZB_NEXT);
	return CIISWizardPage::OnSetActive();
}

BOOL
CKeyPasswordPage::OnKillActive()
{
	UpdateData();
	m_pCert->m_KeyPassword = m_Password;
	return CIISWizardPage::OnKillActive();
}

BEGIN_MESSAGE_MAP(CKeyPasswordPage, CIISWizardPage)
	//{{AFX_MSG_MAP(CKeyPasswordPage)
	ON_EN_CHANGE(IDC_KEYPASSWORD, OnEditchangePassword)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CSiteNamePage message handlers

void CKeyPasswordPage::OnEditchangePassword() 
{
	UpdateData(TRUE);	
	SetWizardButtons(m_Password.IsEmpty() ? 
			PSWIZB_BACK : PSWIZB_BACK | PSWIZB_NEXT);
	CString str;
	SetDlgItemText(IDC_ERROR_TEXT, str);
}




/////////////////////////////////////////////////////////////////////////////
// CKeyPasswordPage property page

IMPLEMENT_DYNCREATE(CImportPFXPasswordPage, CIISWizardPage)

CImportPFXPasswordPage::CImportPFXPasswordPage(CCertificate * pCert) 
	: CIISWizardPage(CImportPFXPasswordPage::IDD, IDS_CERTWIZ, TRUE),
	m_pCert(pCert)
{
	//{{AFX_DATA_INIT(CImportPFXPasswordPage)
	m_Password = _T("");
	//}}AFX_DATA_INIT
}

CImportPFXPasswordPage::~CImportPFXPasswordPage()
{
}

void CImportPFXPasswordPage::DoDataExchange(CDataExchange* pDX)
{
	CIISWizardPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CImportPFXPasswordPage)
	DDX_Text(pDX, IDC_KEYPASSWORD, m_Password);
	DDV_MaxChars(pDX, m_Password, 64);
	//}}AFX_DATA_MAP
}

LRESULT 
CImportPFXPasswordPage::OnWizardBack()
/*++
Routine Description:
    Prev button handler

Arguments:
    None

Return Value:
	0 to automatically advance to the prev page;
	1 to prevent the page from changing. 
	To jump to a page other than the prev one, 
	return the identifier of the dialog to be displayed.
--*/
{
	return IDD_PAGE_PREV;
}

LRESULT 
CImportPFXPasswordPage::OnWizardNext()
{
	UpdateData(TRUE);
	if (0 != m_Password.Compare(m_pCert->m_KeyPassword))
	{
		m_pCert->DeleteKeyRingCert();
		m_pCert->m_KeyPassword = m_Password;
	}
	if (NULL == m_pCert->GetPFXFileCert())
	{
		// probably password was wrong
		CString txt;
		txt.LoadString(IDS_FAILED_IMPORT_PFX_FILE);
		ASSERT(GetDlgItem(IDC_ERROR_TEXT) != NULL);
		SetDlgItemText(IDC_ERROR_TEXT, txt);
		GetDlgItem(IDC_KEYPASSWORD)->SetFocus();
		GetDlgItem(IDC_KEYPASSWORD)->SendMessage(EM_SETSEL, 0, -1);
		SetWizardButtons(PSWIZB_BACK);
		return 1;
	}
	return IDD_PAGE_NEXT;
}

BOOL 
CImportPFXPasswordPage::OnSetActive() 
{
	ASSERT(m_pCert != NULL);
	m_Password = m_pCert->m_KeyPassword;
	UpdateData(FALSE);
	SetWizardButtons(m_Password.IsEmpty() || m_pCert->GetKeyRingCert() == NULL ?
			PSWIZB_BACK : PSWIZB_BACK | PSWIZB_NEXT);
	return CIISWizardPage::OnSetActive();
}

BOOL
CImportPFXPasswordPage::OnKillActive()
{
	UpdateData();
	m_pCert->m_KeyPassword = m_Password;
	return CIISWizardPage::OnKillActive();
}

BEGIN_MESSAGE_MAP(CImportPFXPasswordPage, CIISWizardPage)
	//{{AFX_MSG_MAP(CImportPFXPasswordPage)
	ON_EN_CHANGE(IDC_KEYPASSWORD, OnEditchangePassword)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CSiteNamePage message handlers

void CImportPFXPasswordPage::OnEditchangePassword() 
{
	UpdateData(TRUE);	
	SetWizardButtons(m_Password.IsEmpty() ? 
			PSWIZB_BACK : PSWIZB_BACK | PSWIZB_NEXT);
	CString str;
	SetDlgItemText(IDC_ERROR_TEXT, str);
}







/////////////////////////////////////////////////////////////////////////////
// CExportPFXPasswordPage property page

IMPLEMENT_DYNCREATE(CExportPFXPasswordPage, CIISWizardPage)

CExportPFXPasswordPage::CExportPFXPasswordPage(CCertificate * pCert) 
	: CIISWizardPage(CExportPFXPasswordPage::IDD, IDS_CERTWIZ, TRUE),
	m_pCert(pCert)
{
	//{{AFX_DATA_INIT(CExportPFXPasswordPage)
	m_Password = _T("");
    m_Export_Private_key = FALSE;
	//}}AFX_DATA_INIT
}

CExportPFXPasswordPage::~CExportPFXPasswordPage()
{
}

void CExportPFXPasswordPage::DoDataExchange(CDataExchange* pDX)
{
	CIISWizardPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CExportPFXPasswordPage)
	DDX_Text(pDX, IDC_KEYPASSWORD, m_Password);
	DDV_MaxChars(pDX, m_Password, 64);
    DDX_Check(pDX, IDC_CHK_EXPORT_PRIVATE, m_Export_Private_key);
	//}}AFX_DATA_MAP
}

LRESULT 
CExportPFXPasswordPage::OnWizardBack()
/*++
Routine Description:
    Prev button handler

Arguments:
    None

Return Value:
	0 to automatically advance to the prev page;
	1 to prevent the page from changing. 
	To jump to a page other than the prev one, 
	return the identifier of the dialog to be displayed.
--*/
{
	return IDD_PAGE_PREV;
}

LRESULT 
CExportPFXPasswordPage::OnWizardNext()
{
	UpdateData(TRUE);
	if (0 != m_Password.Compare(m_pCert->m_KeyPassword))
	{
		m_pCert->DeleteKeyRingCert();
		m_pCert->m_KeyPassword = m_Password;
        m_pCert->m_ExportPFXPrivateKey = m_Export_Private_key;
        m_pCert->m_ExportPFXPrivateKey = TRUE;
	}
    /*
	if (NULL == m_pCert->GetKeyRingCert())
	{
		// probably password was wrong
		CString txt;
		txt.LoadString(IDS_FAILED_IMPORT_KEY_FILE);
		ASSERT(GetDlgItem(IDC_ERROR_TEXT) != NULL);
		SetDlgItemText(IDC_ERROR_TEXT, txt);
		GetDlgItem(IDC_KEYPASSWORD)->SetFocus();
		GetDlgItem(IDC_KEYPASSWORD)->SendMessage(EM_SETSEL, 0, -1);
		SetWizardButtons(PSWIZB_BACK);
		return 1;
	}
    */
	return IDD_PAGE_NEXT;
}

BOOL 
CExportPFXPasswordPage::OnSetActive() 
{
	ASSERT(m_pCert != NULL);
	m_Password = m_pCert->m_KeyPassword;
	UpdateData(FALSE);
	SetWizardButtons(m_Password.IsEmpty() || m_pCert->GetKeyRingCert() == NULL ?
			PSWIZB_BACK : PSWIZB_BACK | PSWIZB_NEXT);
	return CIISWizardPage::OnSetActive();
}

BOOL
CExportPFXPasswordPage::OnKillActive()
{
	UpdateData();
	m_pCert->m_KeyPassword = m_Password;
	return CIISWizardPage::OnKillActive();
}

BEGIN_MESSAGE_MAP(CExportPFXPasswordPage, CIISWizardPage)
	//{{AFX_MSG_MAP(CExportPFXPasswordPage)
	ON_EN_CHANGE(IDC_KEYPASSWORD, OnEditchangePassword)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

void CExportPFXPasswordPage::OnEditchangePassword() 
{
	UpdateData(TRUE);	
	SetWizardButtons(m_Password.IsEmpty() ? 
			PSWIZB_BACK : PSWIZB_BACK | PSWIZB_NEXT);
	CString str;
	SetDlgItemText(IDC_ERROR_TEXT, str);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\certwiz\managecertpage.h ===
#if !defined(AFX_MANAGECERTPAGE_H__A57C38A8_3B7F_11D2_817E_0000F87A921B__INCLUDED_)
#define AFX_MANAGECERTPAGE_H__A57C38A8_3B7F_11D2_817E_0000F87A921B__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// ManageCertPage.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CManageCertPage dialog
class CCertificate;

class CManageCertPage : public CIISWizardPage
{
	DECLARE_DYNCREATE(CManageCertPage)

// Construction
public:
	CManageCertPage(CCertificate * pCert = NULL);
	~CManageCertPage();

	enum
	{
		IDD_PAGE_NEXT_RENEW = IDD_PAGE_WIZ_CHOOSE_CATYPE,
		IDD_PAGE_NEXT_REMOVE = IDD_PAGE_WIZ_REMOVE_CERT,
		IDD_PAGE_NEXT_REPLACE = IDD_PAGE_WIZ_CHOOSE_CERT,
        IDD_PAGE_NEXT_EXPORT_PFX = IDD_PAGE_WIZ_GET_EXPORT_PFX_FILE,
        IDD_PAGE_NEXT_COPY_MOVE_TO_REMOTE = IDD_PAGE_WIZ_CHOOSE_COPY_MOVE_TO_REMOTE,
		IDD_PAGE_PREV = IDD_PAGE_WELCOME_START
	};
	enum
	{
		CONTINUE_RENEW = 0,
		CONTINUE_REMOVE,
		CONTINUE_REPLACE,
        CONTINUE_EXPORT_PFX,
        CONTINUE_COPY_MOVE_TO_REMOTE,
	};
// Dialog Data
	//{{AFX_DATA(CManageCertPage)
	enum { IDD = IDD_PAGE_WIZ_MANAGE_CERT };
	int		m_Index;
	//}}AFX_DATA
	CCertificate * m_pCert;


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CManageCertPage)
	public:
	virtual LRESULT OnWizardBack();
	virtual LRESULT OnWizardNext();
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CManageCertPage)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_MANAGECERTPAGE_H__A57C38A8_3B7F_11D2_817E_0000F87A921B__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\certwiz\mru.h ===
//
// mru.h
//
#define MAX_MRU   10
BOOL LoadMRU(LPCTSTR mru_name, CComboBox * pCombo, int nMax);
BOOL AddToMRU(LPCTSTR mru_name, CString& str);
BOOL LoadMRUToCombo(CWnd * pDlg, int id, LPCTSTR mru_name, LPCTSTR str, int mru_size);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\certwiz\managecertpage.cpp ===
// ManageCertPage.cpp : implementation file
//

#include "stdafx.h"
#include "CertWiz.h"
#include "ManageCertPage.h"
#include "Certificat.h"
#include "certutil.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CManageCertPage property page

IMPLEMENT_DYNCREATE(CManageCertPage, CIISWizardPage)

CManageCertPage::CManageCertPage(CCertificate * pCert) 
	: CIISWizardPage(CManageCertPage::IDD, IDS_CERTWIZ, TRUE),
	m_pCert(pCert)
{
	//{{AFX_DATA_INIT(CManageCertPage)
	m_Index = -1;
	//}}AFX_DATA_INIT
}

CManageCertPage::~CManageCertPage()
{
}

void CManageCertPage::DoDataExchange(CDataExchange* pDX)
{
	CIISWizardPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CManageCertPage)
	DDX_Radio(pDX, IDC_RENEW_CERT, m_Index);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CManageCertPage, CIISWizardPage)
	//{{AFX_MSG_MAP(CManageCertPage)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CManageCertPage message handlers

LRESULT CManageCertPage::OnWizardBack() 
{
	return IDD_PAGE_PREV;
}

LRESULT CManageCertPage::OnWizardNext() 
{
	LRESULT res = 1;
	UpdateData();
	switch (m_Index)
	{
	case CONTINUE_RENEW:
		m_pCert->SetStatusCode(CCertificate::REQUEST_RENEW_CERT);
		res = IDD_PAGE_NEXT_RENEW;
		break;
	case CONTINUE_REMOVE:
		res = IDD_PAGE_NEXT_REMOVE;
		break;
	case CONTINUE_REPLACE:
		m_pCert->SetStatusCode(CCertificate::REQUEST_REPLACE_CERT);
		res = IDD_PAGE_NEXT_REPLACE;
		break;
	case CONTINUE_EXPORT_PFX:
		m_pCert->SetStatusCode(CCertificate::REQUEST_EXPORT_CERT);
		res = IDD_PAGE_NEXT_EXPORT_PFX;
		break;
	case CONTINUE_COPY_MOVE_TO_REMOTE:
		m_pCert->SetStatusCode(CCertificate::REQUEST_COPY_MOVE_TO_REMOTE);
		res = IDD_PAGE_NEXT_COPY_MOVE_TO_REMOTE;
		break;
	}
	return res;
}

BOOL CManageCertPage::OnSetActive() 
{
	m_pCert->SetStatusCode(CCertificate::REQUEST_UNDEFINED);
	SetWizardButtons(PSWIZB_BACK | PSWIZB_NEXT);
	return CIISWizardPage::OnSetActive();
}

BOOL CManageCertPage::OnInitDialog() 
{
	m_Index = 0;
	CIISWizardPage::OnInitDialog();
	// we should make some checks and disable some buttons
	if (m_pCert->MyStoreCertCount() == 0)
	{
		ASSERT(NULL != GetDlgItem(IDC_REPLACE_CERT));
		GetDlgItem(IDC_REPLACE_CERT)->EnableWindow(FALSE);
	}

    // Enable or disable controls based on weather certobj is installed
    GetDlgItem(IDC_EXPORT_PFX_CERT)->EnableWindow(m_pCert->m_CertObjInstalled);
    GetDlgItem(IDC_EXPORT_PFX_CERT2)->EnableWindow(m_pCert->m_CertObjInstalled);

    if (m_pCert->m_CertObjInstalled)
    {
        BOOL fExportable = FALSE;
        GetDlgItem(IDC_EXPORT_PFX_CERT)->ShowWindow(SW_SHOW);
        GetDlgItem(IDC_EXPORT_PFX_CERT2)->ShowWindow(SW_SHOW);

        fExportable = IsCertExportable(m_pCert->GetInstalledCert());
        // if it is not exportable, then grey it out
        GetDlgItem(IDC_EXPORT_PFX_CERT)->EnableWindow(fExportable);
        GetDlgItem(IDC_EXPORT_PFX_CERT2)->EnableWindow(fExportable);
    }

    // Turn off for workstation.
    if (TRUE == IsWhistlerWorkstation())
    {
        GetDlgItem(IDC_EXPORT_PFX_CERT)->ShowWindow(SW_HIDE);
        GetDlgItem(IDC_EXPORT_PFX_CERT2)->ShowWindow(SW_HIDE);
    }
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\certwiz\mru.cpp ===
//
// mru.cpp
//
#include "stdafx.h"
#include "CertWiz.h"

#include <commctrl.h>
#include <comctrlp.h>
#include <shlwapi.h>
#include "mru.h"

extern CCertWizApp NEAR theApp;

/***********************************************************************
	Thunks to internal functions in ComCtl32
 */

const TCHAR szComCtl32[] = _T("comctl32.dll");

#ifdef UNICODE
#define CREATE_LIST_ORD			400
#define ADD_MRU_STRING_ORD		401
#define ENUM_MRU_LIST_ORD		403
#define FIND_MRU_STRING_ORD	402
#else
#define CREATE_LIST_ORD			151
#define ADD_MRU_STRING_ORD		153
#define ENUM_MRU_LIST_ORD		154
#define FIND_MRU_STRING_ORD	155
#endif
#define FREE_LIST_ORD			152
#define DEL_MRU_STRING_ORD		156
#define DPA_SET_PTR_ORD			335

typedef HANDLE (CALLBACK *CREATE_MRU_LIST)(LPMRUINFO);
typedef void (CALLBACK *FREE_MRU_LIST)(HANDLE);
typedef int (CALLBACK *ADD_MRU_STRING)(HANDLE, LPCTSTR);
typedef int (CALLBACK *DEL_MRU_STRING)(HANDLE, int);
typedef int (CALLBACK *FIND_MRU_STRING)(HANDLE, LPCTSTR, LPINT);
typedef int (CALLBACK *ENUM_MRU_LIST)(HANDLE, int, LPVOID, UINT);

typedef struct _DPA * HDPA;
typedef BOOL (CALLBACK *DPA_SET_PTR)(HDPA hdpa, int i, LPVOID p);

static HINSTANCE
_GetComCtlInstance()
{
	static HANDLE g_hInst;
	if (g_hInst == NULL)
	{
		g_hInst = GetModuleHandle(szComCtl32);
		if (NULL == g_hInst)
			g_hInst = LoadLibrary(szComCtl32);
		ASSERT(NULL != g_hInst);
	}
	return (HINSTANCE)g_hInst;
}

static HANDLE 
_CreateMRUList(LPMRUINFO pmi)
{
	static CREATE_MRU_LIST pfnCreateMRUList;
	if (pfnCreateMRUList == NULL)
	{
		pfnCreateMRUList = (CREATE_MRU_LIST)GetProcAddress(
			_GetComCtlInstance(), (LPCSTR)CREATE_LIST_ORD);
	}
	ASSERT(pfnCreateMRUList != NULL);
	return pfnCreateMRUList(pmi);
}

static void
_FreeMRUList(HANDLE hMru)
{
	static FREE_MRU_LIST pfnFreeMRUList;
	if (pfnFreeMRUList == NULL)
	{
		pfnFreeMRUList = (FREE_MRU_LIST)GetProcAddress(
			_GetComCtlInstance(), (LPCSTR)FREE_LIST_ORD);
	}
	ASSERT(pfnFreeMRUList != NULL);
	pfnFreeMRUList(hMru);
}

static int
_AddMRUString(HANDLE hMru, LPCTSTR szString)
{
	static ADD_MRU_STRING pfnAddMRUString;
	if (pfnAddMRUString == NULL)
	{
		pfnAddMRUString = (ADD_MRU_STRING)GetProcAddress(
			_GetComCtlInstance(), (LPCSTR)ADD_MRU_STRING_ORD);
	}
	ASSERT(pfnAddMRUString != NULL);
	return pfnAddMRUString(hMru, szString);
}

static int
_DelMRUString(HANDLE hMru, int item)
{
	static DEL_MRU_STRING pfnDelMRUString;
	if (pfnDelMRUString == NULL)
	{
		pfnDelMRUString = (DEL_MRU_STRING)GetProcAddress(
			_GetComCtlInstance(), (LPCSTR)DEL_MRU_STRING_ORD);
	}
	ASSERT(pfnDelMRUString != NULL);
	return pfnDelMRUString(hMru, item);
}

static int
_EnumMRUList(HANDLE hMru, int nItem, LPVOID lpData, UINT uLen)
{
	static ENUM_MRU_LIST pfnEnumMRUList;
	if (pfnEnumMRUList == NULL)
	{
		pfnEnumMRUList = (ENUM_MRU_LIST)GetProcAddress(
			_GetComCtlInstance(), (LPCSTR)ENUM_MRU_LIST_ORD);
	}
	ASSERT(pfnEnumMRUList != NULL);
	return pfnEnumMRUList(hMru, nItem, lpData, uLen);
}

#if 0
static BOOL
_DPA_SetPtr(HDPA hdpa, int i, LPVOID p)
{
	static DPA_SET_PTR pfnDPASetPtr;
	if (pfnDPASetPtr == NULL)
	{
		pfnDPASetPtr = (DPA_SET_PTR)GetProcAddress(
			_GetComCtlInstance(), (LPCSTR)DPA_SET_PTR_ORD);
	}
	ASSERT(pfnDPASetPtr != NULL);
	return pfnDPASetPtr(hdpa, i, p);
}
#endif
/****************************************************************************/

HANDLE 
CreateMRU(const CString& mru_name, int nMax)
{
	MRUINFO mi =  
	{
		sizeof(MRUINFO),
      nMax,
      MRU_CACHEWRITE,
      theApp.RegOpenKeyWizard(),
      mru_name,
      NULL        // NOTE: use default string compare
   };

   //Call the comctl32 mru implementation to load the MRU from
   //the registry
   HANDLE hMRU = _CreateMRUList(&mi);
	RegCloseKey(mi.hKey);
	return hMRU;
}

BOOL 
GetMRUEntry(HANDLE hMRU, int iIndex, CString& str)
{
	BOOL bRes= FALSE;
   //Check for valid parameters
	ASSERT(hMRU != NULL);
     
	//Check for valid index
   if (iIndex >= 0 && iIndex <= _EnumMRUList(hMRU, -1, NULL, 0))
   {
		LPTSTR p = str.GetBuffer(MAX_PATH);
		bRes = (_EnumMRUList(hMRU, iIndex, p, MAX_PATH) > 0);
		str.ReleaseBuffer();
	}
	return bRes;
}

BOOL 
LoadMRU(LPCTSTR mru_name, CComboBox * pCombo, int nMax)
{   
	BOOL fRet = FALSE;
	HANDLE hMRU;
    
	ASSERT(mru_name != NULL && mru_name[0] != 0);
	ASSERT(nMax > 0);

   if (NULL != (hMRU = CreateMRU(mru_name, nMax)))
	{
		//First reset the hwndCombo
		pCombo->ResetContent();

		//Now load the hwndcombo with file list from MRU.
		int i = 0;
		while (nMax > 0)
		{
			CString name;
			if (GetMRUEntry(hMRU, i++, name))
			{
				pCombo->AddString(name);
				nMax--;
				fRet = TRUE;
			}
			else
				break;
		}
		_FreeMRUList(hMRU);
	}
   return fRet;
}

BOOL 
AddToMRU(LPCTSTR mru_name, CString& name)
{
   HANDLE hMRU = CreateMRU(mru_name, 10);
   if (hMRU)
   {
      _AddMRUString(hMRU, name);
		_FreeMRUList(hMRU);
		return TRUE;
	}
   return FALSE;
}

BOOL
LoadMRUToCombo(CWnd * pDlg, int id, LPCTSTR mru_name, LPCTSTR str, int mru_size)
{
	ASSERT(mru_name != NULL);
	ASSERT(str != NULL);
	CComboBox * pCombo = (CComboBox *)CComboBox::FromHandle(pDlg->GetDlgItem(id)->m_hWnd);
	if (LoadMRU(mru_name, pCombo, mru_size))
	{
		// select LRU name in combobox
		if (	CB_ERR == pCombo->SelectString(-1, str)
			&& !str[0] == 0
			)
		{
			// put our default to combobox edit
			pCombo->AddString(str);
			pCombo->SelectString(-1, str);
		}
		return TRUE;
	}
	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\certwiz\keypasswordpage.h ===
#if !defined(AFX_KEYPASSWORDPAGE_H__7209C46A_15CB_11D2_91BB_00C04F8C8761__INCLUDED_)
#define AFX_KEYPASSWORDPAGE_H__7209C46A_15CB_11D2_91BB_00C04F8C8761__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// KeyPassword.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CKeyPasswordPage dialog
class CCertificate;

class CKeyPasswordPage : public CIISWizardPage
{
	DECLARE_DYNCREATE(CKeyPasswordPage)

// Construction
public:
	CKeyPasswordPage(CCertificate * pCert = NULL);
	~CKeyPasswordPage();

	enum
	{
		IDD_PAGE_PREV = IDD_PAGE_WIZ_GETKEY_FILE,
		IDD_PAGE_NEXT = IDD_PAGE_WIZ_INSTALL_KEYCERT
	};
// Dialog Data
	//{{AFX_DATA(CKeyPasswordPage)
	enum { IDD = IDD_PAGE_WIZ_GET_PASSWORD };
	CString	m_Password;
	//}}AFX_DATA
	CCertificate * m_pCert;


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CKeyPasswordPage)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	public:
	virtual LRESULT OnWizardNext();
	virtual LRESULT OnWizardBack();
	virtual BOOL OnSetActive();
	virtual BOOL OnKillActive();
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CKeyPasswordPage)
	afx_msg void OnEditchangePassword();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};


class CImportPFXPasswordPage : public CIISWizardPage
{
	DECLARE_DYNCREATE(CImportPFXPasswordPage)

// Construction
public:
	CImportPFXPasswordPage(CCertificate * pCert = NULL);
	~CImportPFXPasswordPage();

	enum
	{
		IDD_PAGE_PREV = IDD_PAGE_WIZ_GET_IMPORT_PFX_FILE,
		IDD_PAGE_NEXT = IDD_PAGE_WIZ_INSTALL_IMPORT_PFX
	};
// Dialog Data
	//{{AFX_DATA(CImportPFXPasswordPage)
	enum { IDD = IDD_PAGE_WIZ_GET_IMPORT_PFX_PASSWORD };
	CString	m_Password;
	//}}AFX_DATA
	CCertificate * m_pCert;


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CImportPFXPasswordPage)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	public:
	virtual LRESULT OnWizardNext();
	virtual LRESULT OnWizardBack();
	virtual BOOL OnSetActive();
	virtual BOOL OnKillActive();
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CImportPFXPasswordPage)
	afx_msg void OnEditchangePassword();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};


class CExportPFXPasswordPage : public CIISWizardPage
{
	DECLARE_DYNCREATE(CExportPFXPasswordPage)

// Construction
public:
	CExportPFXPasswordPage(CCertificate * pCert = NULL);
	~CExportPFXPasswordPage();

	enum
	{
		IDD_PAGE_PREV = IDD_PAGE_WIZ_GET_EXPORT_PFX_FILE,
		IDD_PAGE_NEXT = IDD_PAGE_WIZ_INSTALL_EXPORT_PFX
	};
// Dialog Data
	//{{AFX_DATA(CExportPFXPasswordPage)
	enum { IDD = IDD_PAGE_WIZ_GET_EXPORT_PFX_PASSWORD };
	CString	m_Password;
    BOOL m_Export_Private_key;
	//}}AFX_DATA
	CCertificate * m_pCert;

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CExportPFXPasswordPage)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	public:
	virtual LRESULT OnWizardNext();
	virtual LRESULT OnWizardBack();
	virtual BOOL OnSetActive();
	virtual BOOL OnKillActive();
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CExportPFXPasswordPage)
	afx_msg void OnEditchangePassword();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};


//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_KEYPASSWORDPAGE_H__7209C46A_15CB_11D2_91BB_00C04F8C8761__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\certwiz\netutil.h ===
//
// NetUtil.h
//
#ifndef _NETUTIL_H
#define _NETUTIL_H

BOOL GetCurrentUserFullName(CString& name);

#define WIZ_CERT_REQUEST_STATUS_CONNECTION_FAILED		1
#define WIZ_CERT_REQUEST_STATUS_REQUEST_DENIED			2
#define WIZ_CERT_REQUEST_STATUS_CERT_ISSUED				3
#define WIZ_CERT_REQUEST_STATUS_ISSUED_SEPARATELY		4
#define WIZ_CERT_REQUEST_STATUS_UNDER_SUBMISSION		5
#define WIZ_CERT_REQUEST_STATUS_REQUEST_ERROR			6
#define WIZ_CERT_REQUEST_STATUS_INSTALL_FAILED			7



#endif	// _NETUTIL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\certwiz\notdefined.h ===
//
// notdefined.h
//
// This is temporal header file. We should use it until we will switch
// to latest version of MFC

// From WinUser.h
#if(WINVER < 0x0500)
#define IDC_HAND            MAKEINTRESOURCE(32649)
#endif /* WINVER < 0x0500 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\certwiz\netutil.cpp ===
//
// NetUtil.cpp
//
#include "stdafx.h"
#include <lm.h>
#include "NetUtil.h"

#include <wincrypt.h>
#include <certrpc.h>
#include <certcli.h>
#include <malloc.h>

#define LEVEL_1						1
#define LEVEL_2						2

BOOL GetCurrentUserFullName(CString& name)
{
	BOOL bRes = FALSE;
	NET_API_STATUS nas;
	WKSTA_USER_INFO_1 * pWksInfo = NULL;
	if (NERR_Success == (nas = NetWkstaUserGetInfo(NULL, 
										LEVEL_1, (BYTE **)&pWksInfo)))
	{
		USER_INFO_2 * pUserInfo = NULL;
		CString strServerName = _T("\\\\");
		ASSERT(pWksInfo->wkui1_logon_server[0] != 0);
		strServerName += pWksInfo->wkui1_logon_server;
		if (NERR_Success == (nas = NetUserGetInfo(
					(LPCWSTR)strServerName,
					(LPCWSTR)pWksInfo->wkui1_username,
					LEVEL_2,
					(BYTE **)&pUserInfo)))
		{
			name = pUserInfo->usri2_full_name;
			if (pUserInfo != NULL)
				NetApiBufferFree(pUserInfo);
			bRes = TRUE;
		}
		if (pWksInfo != NULL)
			NetApiBufferFree(pWksInfo);
	}
	return bRes;
}

#if 0
/*********************************** Direct Cert Request *********************************/

typedef struct _RPC_BINDING_LIST
{
	LPTSTR pszProtSeq;
   LPTSTR pszEndpoint;
} RPC_BINDING_LIST;

RPC_BINDING_LIST g_BindingList[] =
{
	{_T("ncacn_ip_tcp"), NULL},
   {_T("ncacn_np"), _T("\\pipe\\cert")}
};
DWORD g_BindingListSize = sizeof(g_BindingList)/sizeof(g_BindingList[0]);

typedef struct _RPC_ATHN_LIST
{
   DWORD dwAuthnLevel;
   DWORD dwAuthnService;
} RPC_ATHN_LIST;

RPC_ATHN_LIST g_AthnList[] =
{
   { RPC_C_AUTHN_LEVEL_PKT_INTEGRITY, RPC_C_AUTHN_GSS_NEGOTIATE},
   { RPC_C_AUTHN_LEVEL_NONE, RPC_C_AUTHN_NONE }
};
DWORD g_AthnListSize = sizeof(g_AthnList)/sizeof(g_AthnList[0]);

//-----------------------------------------------------------------------
//
// RetrivePKCS7FromCA
//
//------------------------------------------------------------------------
HRESULT 
RetrievePKCS7FromCA(CString& strCALocation,
                    CString& strCAName,
                    LPWSTR pwszRequestString,
                    CRYPT_DATA_BLOB * pPKCS10Blob,
                    CRYPT_DATA_BLOB * pPKCS7Blob,
                    DWORD * pdwStatus,
						  BOOL bRenew)
{
   HRESULT hr = E_FAIL;
   UINT id = 0;
	DWORD dwDisposition = 0;
	DWORD dwErr = 0;
	DWORD dwStatus = 0;
   RPC_STATUS rpcStatus = 0;

	CERTTRANSBLOB tbRequest = {0, NULL};
   CERTTRANSBLOB tbCert = {0, NULL};
   CERTTRANSBLOB tbCertChain = {0, NULL};
   CERTTRANSBLOB tbAttrib = {0, NULL};
   CERTTRANSBLOB tbDispositionMessage = {0, NULL};

   LPTSTR szStringBinding = NULL;
   RPC_BINDING_HANDLE hCARPCBinding = NULL;
   LPTSTR pszCAPrinceName = NULL;

   //input checking
   if (!pPKCS10Blob || !pPKCS7Blob)
      return E_INVALIDARG;

	for (DWORD i = 0; i < g_BindingListSize; i++)
   {
		if (RPC_S_OK != RpcNetworkIsProtseqValid(g_BindingList[i].pszProtSeq))
			continue;
		rpcStatus = RpcStringBindingCompose(NULL, 
										g_BindingList[i].pszProtSeq,
                              (LPTSTR)(LPCTSTR)strCALocation,
                              g_BindingList[i].pszEndpoint,
                              NULL,
                              &szStringBinding);
      if(rpcStatus != RPC_S_OK)
			continue;
		rpcStatus = RpcBindingFromStringBinding(szStringBinding, &hCARPCBinding);
      if (szStringBinding)
			RpcStringFree(&szStringBinding);
      if (rpcStatus != RPC_S_OK)
			continue;
      rpcStatus = RpcEpResolveBinding(hCARPCBinding, ICertPassage_v0_0_c_ifspec);
      if (rpcStatus == RPC_S_OK)
			break;
	}
   if (rpcStatus != RPC_S_OK)
   {
      dwStatus = WIZ_CERT_REQUEST_STATUS_CONNECTION_FAILED;
		hr = E_FAIL;
      goto CLEANUP;
   }

	//add the attribute to the request
   if (pwszRequestString)
   {
		tbAttrib.cb = (wcslen(pwszRequestString) + 1) * sizeof(WCHAR);
      tbAttrib.pb = (BYTE *)pwszRequestString;
   }

   //submit the request
   tbRequest.cb = pPKCS10Blob->cbData;
   tbRequest.pb = pPKCS10Blob->pbData;

   //set the RPC connect as the SNEGO connect, which can authenticate
   //a machine if supported by the system
   //do not need to check the return value since not supported by NT4/Win9x

   for (i = 0; i < g_AthnListSize; i++)
   {
		pszCAPrinceName = NULL;
      if (g_AthnList[i].dwAuthnService != RPC_C_AUTHN_NONE)
      {
			dwErr = RpcMgmtInqServerPrincNameA(hCARPCBinding, 
										g_AthnList[i].dwAuthnService,
                              (PBYTE *)&pszCAPrinceName);
         if (dwErr == RPC_S_UNKNOWN_AUTHN_SERVICE)
				continue;
		}
		dwErr = RpcBindingSetAuthInfo(hCARPCBinding,
										pszCAPrinceName,
                              g_AthnList[i].dwAuthnLevel,
                              g_AthnList[i].dwAuthnService,
                              NULL,
                              RPC_C_AUTHZ_NONE);
		if (pszCAPrinceName)
			RpcStringFree(&pszCAPrinceName);
		if (dwErr == RPC_S_UNKNOWN_AUTHN_SERVICE)
			continue;
      if (dwErr != RPC_S_OK)
			break;
		//determine the format flag
		DWORD dwFlags = CR_IN_BINARY | bRenew ? CR_IN_PKCS7 : CR_IN_PKCS10;
		DWORD dwRequestId = 0;
		__try
      {
			dwErr = CertServerRequest(
			    hCARPCBinding,
             dwFlags,
			    strCAName,
			    &dwRequestId,
			    &dwDisposition,
			    &tbAttrib,
			    &tbRequest,
			    &tbCertChain,
			    &tbCert,
			    &tbDispositionMessage);
		}
      __except(dwErr = GetExceptionCode(), EXCEPTION_EXECUTE_HANDLER)
      {
      }

      if (dwErr != RPC_S_UNKNOWN_AUTHN_SERVICE)
			break;
	}

	if (	dwErr == RPC_S_UNKNOWN_AUTHN_SERVICE 
		||	dwErr == RPC_S_SERVER_UNAVAILABLE 
		||	dwErr == RPC_S_SERVER_TOO_BUSY
		)
	{
      // We tried all of our auth services, but just couldn't connect
      dwStatus = WIZ_CERT_REQUEST_STATUS_CONNECTION_FAILED;
		hr = E_FAIL;
      goto CLEANUP;
	}

   //get the return code
   hr = HRESULT_FROM_WIN32(dwErr);

   //we want to detect the case when hr is S_OK and the
   //request is denied.  In this case, dwDispotion
   //is the REAL hresult code.
   if (hr == S_OK)
   {
		if(FAILED(dwDisposition))
      {
			hr = dwDisposition;
         dwDisposition = CR_DISP_DENIED;
      }
   }
   else
   {
		dwDisposition=CR_DISP_ERROR;
   }

   //map the dwDisposition
	switch (dwDisposition)
   {
   case CR_DISP_DENIED:
		dwStatus = WIZ_CERT_REQUEST_STATUS_REQUEST_DENIED;
		if (!FAILED(hr))
         hr = E_FAIL;
		break;

	case CR_DISP_ISSUED:
		dwStatus = WIZ_CERT_REQUEST_STATUS_CERT_ISSUED;
      break;

	case CR_DISP_ISSUED_OUT_OF_BAND:
		dwStatus = WIZ_CERT_REQUEST_STATUS_ISSUED_SEPARATELY;
      break;

	case CR_DISP_UNDER_SUBMISSION:
		dwStatus = WIZ_CERT_REQUEST_STATUS_UNDER_SUBMISSION;
      break;

	//we should never get CR_DISP_INCOMPLETE or CR_DISP_REVOKED
   //case    CR_DISP_INCOMPLETE:
   //case    CR_DISP_REVOKED:
   case CR_DISP_ERROR:
   default:
		dwStatus = WIZ_CERT_REQUEST_STATUS_REQUEST_ERROR;
		if (!FAILED(hr))
         hr=E_FAIL;
      break;
	}

   if (hr != S_OK)
      goto CLEANUP;

   //copy the PKCS7 blob
   pPKCS7Blob->cbData = tbCertChain.cb;
	pPKCS7Blob->pbData = new BYTE[tbCertChain.cb];

   if (NULL == pPKCS7Blob->pbData)
   {
		hr = E_OUTOFMEMORY;
      dwStatus = WIZ_CERT_REQUEST_STATUS_INSTALL_FAILED;
      goto CLEANUP;
   }
   memcpy(pPKCS7Blob->pbData,tbCertChain.pb,tbCertChain.cb);

   hr = S_OK;

CLEANUP:

	if (pdwStatus)
		*pdwStatus = dwStatus;

	if (tbCert.pb)
		CoTaskMemFree(tbCert.pb);

	if (tbCertChain.pb)
		CoTaskMemFree(tbCertChain.pb);

	if (tbDispositionMessage.pb)
		CoTaskMemFree(tbDispositionMessage.pb);

	if (hCARPCBinding)
		RpcBindingFree(&hCARPCBinding);

	return hr;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\certwiz\orginfopage.cpp ===
// OrgInfoPage.cpp : implementation file
//

#include "stdafx.h"
#include "CertWiz.h"
#include "OrgInfoPage.h"
#include "Certificat.h"
#include "mru.h"
#include "strutil.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

void DDV_MaxCharsCombo(CDataExchange* pDX, UINT ControlID, CString const& value, int nChars)
{
	ASSERT(nChars >= 1);        // allow them something
	if (pDX->m_bSaveAndValidate && value.GetLength() > nChars)
	{
		DDV_MaxChars(pDX, value, nChars);
	}
	else
	{
	  // limit the control max-chars automatically
	  pDX->m_pDlgWnd->SendDlgItemMessage(ControlID, CB_LIMITTEXT, nChars, 0);
	}
}

/////////////////////////////////////////////////////////////////////////////
// COrgInfoPage property page

IMPLEMENT_DYNCREATE(COrgInfoPage, CIISWizardPage)

COrgInfoPage::COrgInfoPage(CCertificate * pCert) 
	: CIISWizardPage(COrgInfoPage::IDD, IDS_CERTWIZ, TRUE),
	m_pCert(pCert)
{
	//{{AFX_DATA_INIT(COrgInfoPage)
	m_OrgName = _T("");
	m_OrgUnit = _T("");
	//}}AFX_DATA_INIT
}

COrgInfoPage::~COrgInfoPage()
{
}

void COrgInfoPage::DoDataExchange(CDataExchange* pDX)
{
	CIISWizardPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(COrgInfoPage)
	DDX_Text(pDX, IDC_NEWKEY_ORG, m_OrgName);
	DDV_MaxCharsCombo(pDX, IDC_NEWKEY_ORG, m_OrgName, 64);
	DDX_Text(pDX, IDC_NEWKEY_ORGUNIT, m_OrgUnit);
	DDV_MaxCharsCombo(pDX, IDC_NEWKEY_ORGUNIT, m_OrgUnit, 64);
	//}}AFX_DATA_MAP
}

LRESULT 
COrgInfoPage::OnWizardBack()
{
   return m_pCert->m_DefaultCSP ? IDD_PAGE_PREV : IDD_PREV_CSP;
}

LRESULT 
COrgInfoPage::OnWizardNext()
{
    LRESULT lret = 1;
	UpdateData(TRUE);
	m_pCert->m_Organization = m_OrgName;
	m_pCert->m_OrganizationUnit = m_OrgUnit;

    CString buf;
    buf.LoadString(IDS_INVALID_X500_CHARACTERS);
    if (!IsValidX500Chars(m_OrgName))
    {
        GetDlgItem(IDC_NEWKEY_ORG)->SetFocus();
        AfxMessageBox(buf, MB_OK);
    }
    else if (!IsValidX500Chars(m_OrgUnit))
    {
        GetDlgItem(IDC_NEWKEY_ORGUNIT)->SetFocus();
        AfxMessageBox(buf, MB_OK);
    }
    else
    {
        lret = IDD_PAGE_NEXT;
    }

	return lret;
}

BOOL 
COrgInfoPage::OnSetActive() 
{
	SetButtons();
   return CIISWizardPage::OnSetActive();
}

void COrgInfoPage::SetButtons()
{
	UpdateData(TRUE);	
	SetWizardButtons(m_OrgName.IsEmpty() || m_OrgUnit.IsEmpty() ? 
			PSWIZB_BACK : PSWIZB_BACK | PSWIZB_NEXT);
}

BEGIN_MESSAGE_MAP(COrgInfoPage, CIISWizardPage)
	//{{AFX_MSG_MAP(COrgInfoPage)
	ON_CBN_EDITCHANGE(IDC_NEWKEY_ORG, OnChangeName)
	ON_CBN_EDITCHANGE(IDC_NEWKEY_ORGUNIT, OnChangeName)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// COrgInfoPage message handlers

BOOL COrgInfoPage::OnInitDialog() 
{
	ASSERT(m_pCert != NULL);
	m_OrgName = m_pCert->m_Organization;
	m_OrgUnit = m_pCert->m_OrganizationUnit;
	
	CIISWizardPage::OnInitDialog();
		
	// Load MRU names
	LoadMRUToCombo(this, IDC_NEWKEY_ORG, szOrganizationMRU, m_OrgName, MAX_MRU);
	LoadMRUToCombo(this, IDC_NEWKEY_ORGUNIT, szOrganizationUnitMRU, m_OrgUnit, MAX_MRU);

	GetDlgItem(IDC_NEWKEY_ORG)->SetFocus();
	return FALSE;
}

void COrgInfoPage::OnChangeName() 
{
	SetButtons();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\certwiz\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\certwiz\securitysettingspage.cpp ===
// SecuritySettingsPage.cpp : implementation file
//

#include "stdafx.h"
#include "CertWiz.h"
#include "SecuritySettingsPage.h"
#include "Certificat.h"
#include "CertUtil.h"
#include "Shlwapi.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CSecuritySettingsPage property page

IMPLEMENT_DYNCREATE(CSecuritySettingsPage, CIISWizardPage)

CSecuritySettingsPage::CSecuritySettingsPage(CCertificate * pCert) 
	: CIISWizardPage(CSecuritySettingsPage::IDD, IDS_CERTWIZ, TRUE),
	m_pCert(pCert)
{
	//{{AFX_DATA_INIT(CSecuritySettingsPage)
	m_BitLengthIndex = -1;
	m_FriendlyName = _T("");
	m_SGC_cert = FALSE;
   m_choose_CSP = FALSE;
	//}}AFX_DATA_INIT
	m_lru_reg = m_lru_sgc = -1;
}

CSecuritySettingsPage::~CSecuritySettingsPage()
{
}

void CSecuritySettingsPage::DoDataExchange(CDataExchange* pDX)
{
	CIISWizardPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CSecuritySettingsPage)
	DDX_CBIndex(pDX, IDC_BIT_LENGTH, m_BitLengthIndex);
	DDX_Text(pDX, IDC_FRIENDLY_NAME, m_FriendlyName);
	DDV_MaxChars(pDX, m_FriendlyName, 256);
	DDX_Check(pDX, IDC_SGC_CERT, m_SGC_cert);
	DDX_Check(pDX, IDC_PROVIDER_SELECT, m_choose_CSP);
   DDX_Control(pDX, IDC_PROVIDER_SELECT, m_check_csp);
	//}}AFX_DATA_MAP
}

BOOL 
CSecuritySettingsPage::OnSetActive() 
{
	SetWizardButtons(m_FriendlyName.IsEmpty() ? 
			PSWIZB_BACK : PSWIZB_BACK | PSWIZB_NEXT);
	return CIISWizardPage::OnSetActive();
}

LRESULT 
CSecuritySettingsPage::OnWizardPrev()
/*++
Routine Description:
    Prev button handler

Arguments:
    None

Return Value:
	0 to automatically advance to the prev page;
	1 to prevent the page from changing. 
	To jump to a page other than the prev one, 
	return the identifier of the dialog to be displayed.
--*/
{
	return CSecuritySettingsPage::IDD_PREV_PAGE;
}

LRESULT 
CSecuritySettingsPage::OnWizardNext()
{
	TCHAR buf[6];
	UpdateData();
	
	m_pCert->m_FriendlyName = m_FriendlyName;
	GetDlgItem(IDC_BIT_LENGTH)->SendMessage(CB_GETLBTEXT, m_BitLengthIndex, (LPARAM)buf);
	m_pCert->m_KeyLength = StrToInt(buf);

	m_pCert->m_SGCcertificat = m_SGC_cert;
	if (m_SGC_cert)
	{
		// it was a smart move, but xenroll makes 512 bits default for SGC,
		// so we always creating 512 certs
//		if (m_pCert->m_KeyLength == (int)m_sgckey_limits.def)
//			m_pCert->m_KeyLength = 0;
	}
	else
	{
		if (m_pCert->m_KeyLength == (int)m_regkey_limits.def)
        {
			m_pCert->m_KeyLength = 0;
        }
	}

	VERIFY(m_pCert->SetSecuritySettings());
   m_pCert->m_DefaultCSP = !m_choose_CSP;
   return m_choose_CSP ? IDD_NEXT_CSP : IDD_NEXT_PAGE;
}

BEGIN_MESSAGE_MAP(CSecuritySettingsPage, CIISWizardPage)
	//{{AFX_MSG_MAP(CSecuritySettingsPage)
	ON_EN_CHANGE(IDC_FRIENDLY_NAME, OnChangeFriendlyName)
	ON_BN_CLICKED(IDC_SGC_CERT, OnSgcCert)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CSecuritySettingsPage message handlers

DWORD dwPredefinedKeyLength[] =
{
    0,    // 0 means default
    512,
    1024,
    2048,
    4096,
    8192,
    16384
};
#define COUNT_KEYLENGTH sizeof(dwPredefinedKeyLength)/sizeof(dwPredefinedKeyLength[0])

BOOL CSecuritySettingsPage::OnInitDialog() 
{
	ASSERT(m_pCert != NULL);
	m_FriendlyName = m_pCert->m_FriendlyName;
	CIISWizardPage::OnInitDialog();
	OnChangeFriendlyName();

	HRESULT hr;
	CString str;
	if (GetKeySizeLimits(m_pCert->GetEnrollObject(),
				&m_regkey_limits.min, 
				&m_regkey_limits.max, 
				&m_regkey_limits.def, 
				FALSE, 
				&hr))
	{
		for (int i = 0, n = 0; i < COUNT_KEYLENGTH; i++)
		{
			if (	dwPredefinedKeyLength[i] >= m_regkey_limits.min 
				&& dwPredefinedKeyLength[i] <= m_regkey_limits.max
				)
			{
				m_regkey_size_list.AddTail(dwPredefinedKeyLength[i]);
            if (m_pCert->GetStatusCode() == CCertificate::REQUEST_NEW_CERT)
            {
               if  (m_regkey_limits.def == (int)dwPredefinedKeyLength[i])
					   m_BitLengthIndex = n;
            }
				else
            {
               if  (m_pCert->m_KeyLength == (int)dwPredefinedKeyLength[i])
					   m_BitLengthIndex = n;
            }
            n++;
			}
		}
	}
	else
	{
		ASSERT(FALSE);
		m_pCert->m_hResult = hr;
	}
	if (m_BitLengthIndex == -1)
		m_BitLengthIndex = 0;

	// for SGC temporarily set only one size
	m_sgckey_limits.min = 1024;
	m_sgckey_limits.max = 1024;
	m_sgckey_limits.def = 1024;
	m_sgckey_size_list.AddTail(1024);
	
	m_SGC_cert = m_pCert->m_SGCcertificat;
   m_choose_CSP = !m_pCert->m_DefaultCSP;
	UpdateData(FALSE);
	
   SetupKeySizesCombo();

	GetDlgItem(IDC_FRIENDLY_NAME)->SetFocus();
	return FALSE;
}

void CSecuritySettingsPage::OnChangeFriendlyName() 
{
	UpdateData(TRUE);
	SetWizardButtons(m_FriendlyName.IsEmpty() ? 
			PSWIZB_BACK : PSWIZB_BACK | PSWIZB_NEXT);
}

void CSecuritySettingsPage::OnSgcCert() 
{
   UpdateData();
   SetupKeySizesCombo();
}

void CSecuritySettingsPage::SetupKeySizesCombo()
{
	// Currently, only one key size works with SGC flag:
	// 1024, so we need to limit combobox to this length, if 
	// button is checked
	CButton * pCheckBox = (CButton *)CWnd::FromHandle(GetDlgItem(IDC_SGC_CERT)->m_hWnd);
	CComboBox * pCombo = (CComboBox *)CWnd::FromHandle(GetDlgItem(IDC_BIT_LENGTH)->m_hWnd);
	int check_state = pCheckBox->GetCheck();
	int index, count;
	CList<int, int> * pList;
	if (m_SGC_cert)
	{
		// switch combo to previously selected SGC size
		m_lru_reg = pCombo->GetCurSel();
		index = m_lru_sgc;
		pList = &m_sgckey_size_list;
	}
	else
	{
		// switch combo to previously selected regular size
		m_lru_sgc = pCombo->GetCurSel();
		index = m_lru_reg;
		pList = &m_regkey_size_list;
	}
	// now refill the combo with key length and select the relevant last one
	pCombo->ResetContent();
	CString str;
	POSITION pos = pList->GetHeadPosition();
	while (pos != NULL)
	{
		str.Format(L"%d", pList->GetNext(pos));
		pCombo->AddString(str);
	}
	count = pCombo->GetCount();
   if (m_SGC_cert)
   {
      if (index == CB_ERR)
         index = 0;
   }
   else
   {
      if (index == CB_ERR)
         index = m_BitLengthIndex;
   }
   pCombo->SetCurSel(index);
	pCombo->EnableWindow(count > 1);
}

void CSecuritySettingsPage::OnSelectCsp() 
{
   m_pCert->m_DefaultCSP = m_check_csp.GetCheck() == 0;
   m_choose_CSP = !m_pCert->m_DefaultCSP;
   if (m_pCert->m_DefaultCSP)
      m_pCert->m_CspName.Empty();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\certwiz\sitenamepage.h ===
#if !defined(AFX_SITENAMEPAGE_H__7209C46A_15CB_11D2_91BB_00C04F8C8761__INCLUDED_)
#define AFX_SITENAMEPAGE_H__7209C46A_15CB_11D2_91BB_00C04F8C8761__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// SiteNamePage.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CSiteNamePage dialog
class CCertificate;

class CSiteNamePage : public CIISWizardPage
{
	DECLARE_DYNCREATE(CSiteNamePage)

// Construction
public:
	CSiteNamePage(CCertificate * pCert = NULL);
	~CSiteNamePage();

	enum
	{
		IDD_PAGE_PREV = IDD_PAGE_WIZ_ORG_INFO,
		IDD_PAGE_NEXT = IDD_PAGE_WIZ_GEO_INFO
	};
// Dialog Data
	//{{AFX_DATA(CSiteNamePage)
	enum { IDD = IDD_PAGE_WIZ_SITE_NAME };
	CString	m_CommonName;
	//}}AFX_DATA
	CCertificate * m_pCert;


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CSiteNamePage)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	public:
	virtual LRESULT OnWizardNext();
	virtual LRESULT OnWizardPrev();
	virtual BOOL OnSetActive();
	virtual BOOL OnKillActive();
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CSiteNamePage)
	afx_msg void OnEditchangeNewkeyCommonname();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_SITENAMEPAGE_H__7209C46A_15CB_11D2_91BB_00C04F8C8761__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\certwiz\orginfopage.h ===
#if !defined(AFX_ORGINFOPAGE_H__549054D7_1561_11D2_8A1F_000000000000__INCLUDED_)
#define AFX_ORGINFOPAGE_H__549054D7_1561_11D2_8A1F_000000000000__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// OrgInfoPage.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// COrgInfoPage dialog

class CCertificate;

class COrgInfoPage : public CIISWizardPage
{
	DECLARE_DYNCREATE(COrgInfoPage)

// Construction
public:
	COrgInfoPage(CCertificate * pCert = NULL);
	~COrgInfoPage();

	enum
	{
		IDD_PAGE_PREV = IDD_PAGE_WIZ_SECURITY_SETTINGS,
      IDD_PREV_CSP = IDD_PAGE_WIZ_CHOOSE_CSP,
		IDD_PAGE_NEXT = IDD_PAGE_WIZ_SITE_NAME
	};
// Dialog Data
	//{{AFX_DATA(COrgInfoPage)
	enum { IDD = IDD_PAGE_WIZ_ORG_INFO };
	CString	m_OrgName;
	CString	m_OrgUnit;
	//}}AFX_DATA
	CCertificate * m_pCert;

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(COrgInfoPage)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	public:
	virtual LRESULT OnWizardNext();
	virtual LRESULT OnWizardBack();
	virtual BOOL OnSetActive();
	//}}AFX_VIRTUAL

// Implementation
protected:
	void SetButtons();
	// Generated message map functions
	//{{AFX_MSG(COrgInfoPage)
	virtual BOOL OnInitDialog();
	afx_msg void OnChangeName();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_ORGINFOPAGE_H__549054D7_1561_11D2_8A1F_000000000000__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\certwiz\sitenamepage.cpp ===
// SiteNamePage.cpp : implementation file
//

#include "stdafx.h"
#include "CertWiz.h"
#include "SiteNamePage.h"
#include "Certificat.h"
#include "strutil.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CSiteNamePage property page

IMPLEMENT_DYNCREATE(CSiteNamePage, CIISWizardPage)

CSiteNamePage::CSiteNamePage(CCertificate * pCert) 
	: CIISWizardPage(CSiteNamePage::IDD, IDS_CERTWIZ, TRUE),
	m_pCert(pCert)
{
	//{{AFX_DATA_INIT(CSiteNamePage)
	m_CommonName = _T("");
	//}}AFX_DATA_INIT
}

CSiteNamePage::~CSiteNamePage()
{
}

void CSiteNamePage::DoDataExchange(CDataExchange* pDX)
{
	CIISWizardPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CSiteNamePage)
	DDX_Text(pDX, IDC_NEWKEY_COMMONNAME, m_CommonName);
	DDV_MaxChars(pDX, m_CommonName, 64);
	//}}AFX_DATA_MAP
}

LRESULT 
CSiteNamePage::OnWizardPrev()
/*++
Routine Description:
    Prev button handler

Arguments:
    None

Return Value:
	0 to automatically advance to the prev page;
	1 to prevent the page from changing. 
	To jump to a page other than the prev one, 
	return the identifier of the dialog to be displayed.
--*/
{
	return IDD_PAGE_PREV;
}

LRESULT 
CSiteNamePage::OnWizardNext()
/*++
Routine Description:
    Next button handler

Arguments:
    None

Return Value:
	0 to automatically advance to the next page;
	1 to prevent the page from changing. 
	To jump to a page other than the next one, 
	return the identifier of the dialog to be displayed.
--*/
{
    LRESULT lres = 1;
	UpdateData(TRUE);
	m_pCert->m_CommonName = m_CommonName;

    CString buf;
    buf.LoadString(IDS_INVALID_X500_CHARACTERS);
    if (!IsValidX500Chars(m_CommonName))
    {
        GetDlgItem(IDC_NEWKEY_COMMONNAME)->SetFocus();
        AfxMessageBox(buf, MB_OK);
    }
    else
    {
        lres = IDD_PAGE_NEXT;
    }
 	return lres;
}

BOOL 
CSiteNamePage::OnSetActive() 
/*++
Routine Description:
    Activation handler
	We could have empty name field on entrance, so we should
	disable Back button

Arguments:
    None

Return Value:
    TRUE for success, FALSE for failure
--*/
{
	ASSERT(m_pCert != NULL);
	m_CommonName = m_pCert->m_CommonName;
	UpdateData(FALSE);
	SetWizardButtons(m_CommonName.IsEmpty() ? 
			PSWIZB_BACK : PSWIZB_BACK | PSWIZB_NEXT);
   return CIISWizardPage::OnSetActive();
}

BOOL 
CSiteNamePage::OnKillActive() 
/*++
Routine Description:
    Activation handler
	We could leave this page only if we have good names
	entered or when Back button is clicked. In both cases
	we should enable both buttons

Arguments:
    None

Return Value:
    TRUE for success, FALSE for failure
--*/
{
	SetWizardButtons(PSWIZB_BACK | PSWIZB_NEXT);
   return CIISWizardPage::OnSetActive();
}

BEGIN_MESSAGE_MAP(CSiteNamePage, CIISWizardPage)
	//{{AFX_MSG_MAP(CSiteNamePage)
	ON_EN_CHANGE(IDC_NEWKEY_COMMONNAME, OnEditchangeNewkeyCommonname)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CSiteNamePage message handlers

void CSiteNamePage::OnEditchangeNewkeyCommonname() 
{
	UpdateData(TRUE);	
	SetWizardButtons(m_CommonName.IsEmpty() ? 
			PSWIZB_BACK : PSWIZB_BACK | PSWIZB_NEXT);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\certwiz\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by CertWiz.rc
//
#define IDS_CERTWIZ                     1
#define IDB_CERTWIZ                     1
#define IDS_CERTWIZ_PPG                 2
#define IDD_PAGE_WELCOME_START          132
#define IDS_CERTWIZ_PPG_CAPTION         200
#define IDD_PROPPAGE_CERTWIZ            200
#define IDB_WIZ_LEFT                    201
#define IDS_WELCOME_PAGE_CAPTION        201
#define IDC_COUNTRY_CODE_FILE           201
#define IDB_WIZ_TOP                     202
#define IDS_CHOOSE_CA_PAGE_CAPTION      202
#define IDC_CERT_LIST                   202
#define IDC_BROWSE_CUR                  203
#define IDC_INFO_FILENAME               203
#define IDS_REPLACE_FILE                203
#define IDC_OFFLINE_RADIO               204
#define IDS_PENDING_REQUEST             204
#define IDC_ONLINE_RADIO                205
#define IDS_NEW_CERT                    205
#define IDD_PAGE_WIZ_CHOOSE_IMPORT_EXPORT 205
#define IDC_FILE_NAME                   206
#define IDS_REQ_FILE_EXT                206
#define IDD_PAGE_WIZ_CHOOSE_COPY_MOVE_FROM_REMOTE 206
#define IDC_REQUEST_DUMP                207
#define IDS_RESP_FILE_EXT               207
#define IDD_PAGE_WIZ_IMPORT_CERT        207
#define IDC_STATUS_TEXT                 208
#define IDS_REQ_FILE_FILTER             208
#define IDD_PAGE_WIZ_EXPORT_CERT        208
#define IDC_BROWSE_BTN                  209
#define IDS_RESP_FILE_FILTER            209
#define IDD_PAGE_WIZ_GET_IMPORT_PFX_FILE 209
#define IDC_RESP_DUMP                   210
#define IDS_INSTALLED_CERT              210
#define IDD_PAGE_WIZ_GET_EXPORT_PFX_FILE 210
#define IDS_CERT_INSTALLATION_FAILURE   211
#define IDD_PAGE_WIZ_GET_IMPORT_PFX_PASSWORD 211
#define IDS_METABASE_OPEN_FAILURE       212
#define IDD_PAGE_WIZ_GET_EXPORT_PFX_PASSWORD 212
#define IDS_INSTALL_CERT_SUCCESS_HEADER 213
#define IDC_CA_NAME                     213
#define IDD_PAGE_WIZ_INSTALL_IMPORT_PFX 213
#define IDS_INSTALL_CERT_FAILURE_HEADER 214
#define IDC_TARGET_INSTANCE_NAME        214
#define IDD_PAGE_WIZ_INSTALL_EXPORT_PFX 214
#define IDC_CA_NAME2                    214
#define IDS_REMOVE_CERT_FAILED          215
#define IDC_CERT_DUMP                   215
#define IDD_PAGE_WIZ_FINAL_INSTALL_IMPORT_PFX 215
#define IDS_CR_DISP_INCOMPLETE          216
#define IDD_PAGE_WIZ_FINAL_INSTALL_EXPORT_PFX 216
#define IDS_CR_DISP_ERROR               217
#define IDC_KEYPASSWORD                 217
#define IDD_PAGE_WIZ_CHOOSE_COPY_MOVE_TO_REMOTE 217
#define IDS_CR_DISP_DENIED              218
#define IDC_ERROR_TEXT                  218
#define IDD_PAGE_WIZ_CHOOSE_SERVER      218
#define IDS_CR_DISP_ISSUED_OUT_OF_BAND  219
#define IDD_PAGE_WIZ_CHOOSE_SERVER_SITE 219
#define IDS_CR_DISP_UNDER_SUBMISSION    220
#define IDC_CERT_CONTENTS               220
#define IDD_PAGE_WIZ_FINAL_INSTALL_COPY_FROM_REMOTE 220
#define IDC_RADIO0                      221
#define IDC_PROCESS_PENDING             221
#define IDC_RENEW_CERT                  221
#define IDS_INTERNAL_ERROR              221
#define IDD_PAGE_WIZ_FINAL_INSTALL_MOVE_FROM_REMOTE 221
#define IDC_RADIO1                      222
#define IDC_KILL_PENDING                222
#define IDC_REMOVE_CERT                 222
#define IDS_RESPONSE_CERT_KEY_MISMATCH  222
#define IDD_PAGE_WIZ_INSTALL_COPY_FROM_REMOTE 222
#define IDS_ISSUED_TO                   223
#define IDC_ERROR_MSG                   223
#define IDD_PAGE_WIZ_INSTALL_MOVE_FROM_REMOTE 223
#define IDS_ISSUED_BY                   224
#define IDC_SGC_CERT                    224
#define IDD_PAGE_WIZ_INSTALL_COPY_TO_REMOTE 224
#define IDC_RADIO2                      225
#define IDS_EXPIRATION_DATE             225
#define IDD_PAGE_WIZ_INSTALL_MOVE_TO_REMOTE 225
#define IDS_PURPOSE                     226
#define IDC_RADIO3                      226
#define IDD_PAGE_WIZ_FINAL_INSTALL_COPY_TO_REMOTE 226
#define IDS_FRIENDLY_NAME               227
#define IDC_RADIO4                      227
#define IDD_PAGE_WIZ_FINAL_INSTALL_MOVE_TO_REMOTE 227
#define IDS_FRIENDLYNAME_NONE           228
#define IDD_PAGE_WIZ_CHOOSE_SERVER_TO   228
#define IDS_REMOVE_CERT_SUCCESS_HEADER  229
#define IDD_PAGE_WIZ_CHOOSE_SERVER_SITE_TO 229
#define IDC_REPLACE_CERT                230
#define IDS_REMOVE_CERT_FAILURE_HEADER  230
#define IDD_PAGE_WIZ_CHOOSE_FILENAME_RENEW 230
#define IDS_RESP_FILE_DEFAULT           231
#define IDS_REQ_FILE_DEFAULT            232
#define IDC_STATIC_WZ_BODY2             232
#define IDD_PAGE_WIZ_REQUEST_DUMP_RENEW 232
#define IDS_CANCEL_CERT_SUCCESS_HEADER  233
#define IDC_PHONE_EXT                   233
#define IDD_DIALOG_CHOOSE_SITE          233
#define IDS_CANCEL_CERT_FAILURE_HEADER  234
#define IDC_STATUS_LINE                 234
#define IDS_ASK_CREATE_DIR              235
#define IDC_PROVIDER_SELECT             235
#define IDS_FINAL_TO_FILE_SUCCESS_HEADER 236
#define IDS_FINAL_TO_FILE_FAILURE_HEADER 237
#define IDC_CSP_LIST                    237
#define IDS_CERTKEY_MISMATCH_ERROR1     238
#define IDC_IMPORT_PFX_CERT             238
#define IDS_CERTKEY_MISMATCH_ERROR2     239
#define IDC_EXPORT_PFX_CERT             239
#define IDS_WEB_SITE_N                  240
#define IDC_COPY_TO_REMOTE              240
#define IDC_EXPORT_PFX_CERT2            240
#define IDS_KEY_FILE_EXT                241
#define IDC_MOVE_TO_REMOTE              241
#define IDS_KEY_FILE_FILTER             242
#define IDC_COPY_FROM_REMOTE            242
#define IDC_USER_NAME                   242
#define IDS_KEY_FILE_DEFAULT            243
#define IDC_MOVE_FROM_REMOTE            243
#define IDC_USER_PASSWORD               243
#define IDC_STATIC_DESC                 244
#define IDS_FAILED_IMPORT_KEY_FILE      244
#define IDC_SERVER_NAME                 244
#define IDS_COUNTRY                     245
#define IDC_SERVER_SITE_NAME            245
#define IDC_STATIC_DESC_WHERE2MAIL_CERT 246
#define IDS_STATE                       246
#define IDC_CHK_EXPORT_PRIVATE          246
#define IDS_LOCALITY                    247
#define IDC_VIEW_CERT                   247
#define IDS_ORGANIZATION                248
#define IDS_ORGANIZATION_UNIT           249
#define IDS_ANY                         250
#define IDS_CERTKEY_ALREADY_INSTALLED   251
#define IDC_SITE_LIST                   251
#define IDS_CERTKEY_ALREADY_INSTALLED_WHERE 252
#define IDS_FINAL_TO_FILE_BODY_SUCCESS  253
#define IDC_MARK_AS_EXPORTABLE          253
#define IDS_CONTACT_NAME                254
#define IDC_STATIC_EXPORTABLE           254
#define IDS_CONTACT_ADDRESS             255
#define IDS_CONTACT_PHONE               256
#define IDS_FILE_DOES_NOT_EXIST         257
#define IDS_FILE_IS_DIRECTORY           258
#define IDS_CERT_REPLACE_SUCCESS        259
#define IDS_CERT_INSTALLED_SUCCESS      260
#define IDS_CERT_CANCEL_SUCCESS         261
#define IDS_CERT_REMOVE_SUCCESS         262
#define IDS_CERT_REQUEST_SUCCESS        263
#define IDS_MICROSOFT_CA_LINK           264
#define IDS_ALL                         265
#define IDS_WRONG_PHONE_NUMBER          266
#define IDS_INVALID_X500_CHARACTERS     267
#define IDS_PFX_FILE_EXT                268
#define IDS_PFX_FILE_FILTER             269
#define IDS_PFX_FILE_DEFAULT            270
#define IDS_CERT_BEING_USED             271
#define IDS_WEB_SITE_COLUMN             272
#define IDS_FAILED_IMPORT_PFX_FILE      273
#define IDS_PFX_EXPORT_SUCCESS          274
#define IDS_SITE_NUM_COLUMN             275
#define IDS_CERT_NOT_EXPORTABLE         276
#define IDC_NEWKEY_COUNTRY              1017
#define IDC_NEWKEY_ORG                  1018
#define IDC_NEWKEY_STATE                1019
#define IDC_NEWKEY_ORGUNIT              1020
#define IDC_NEWKEY_LOCALITY             1022
#define IDC_NEWKEY_COMMONNAME           1023
#define IDC_HOTLINK_CCODES              1052
#define IDC_NK_CA_FILE_RADIO            1070
#define IDC_NK_CA_ONLINE_RADIO          1071
#define IDC_NK_CA_ONLINE                1072
#define IDC_CA_ONLINE_LIST              1072
#define IDC_NKUI_USER_NAME              1073
#define IDC_CONTACT_NAME                1073
#define IDC_NK_CA_BROWSE                1074
#define IDC_NK_INFO_FILENAME            1080
#define IDC_NK_CA_FILE                  1082
#define IDC_NKUI_EMAIL_ADDRESS          1083
#define IDC_EMAIL_ADDRESS               1083
#define IDC_NKUI_PHONE_NUMBER           1084
#define IDC_PHONE_NUMBER                1084
#define IDC_NKKI_NAME                   1085
#define IDC_FRIENDLY_NAME               1085
#define IDC_NKKI_BITS                   1086
#define IDC_BIT_LENGTH                  1086
#define IDD_PAGE_WIZ_CHOOSE_CERT        2776
#define IDC_STATIC_WZ_WELCOME           4000
#define IDC_STATIC_WZ_TITLE             4001
#define IDC_STATIC_WZ_SUBTITLE          4002
#define IDC_STATIC_WZ_BODY              4003
#define IDC_STATIC_WZ_CLICK             4004
#define IDC_STATIC_WZ_HEADER_DIVIDER    4005
#define IDD_PAGE_WIZ_GET_WHAT           30140
#define IDD_PAGE_WIZ_CHOOSE_CA          30141
#define IDD_PAGE_WIZ_CHOOSE_ONLINE      30141
#define IDD_PAGE_WIZ_SECURITY_SETTINGS  30142
#define IDD_PAGE_WIZ_ORG_INFO           30143
#define IDD_PAGE_WIZ_SITE_NAME          30144
#define IDD_PAGE_WIZ_GEO_INFO           30145
#define IDD_PAGE_WIZ_CONTACT_INFO       30146
#define IDD_PAGE_WIZ_FILE_INFO          30147
#define IDD_PAGE_WIZ_FINAL_TO_FILE      30148
#define IDD_PAGE_WIZ_CHOOSE_CATYPE      30149
#define IDD_PAGE_WIZ_CHOOSE_FILENAME    30150
#define IDD_PAGE_WIZ_REQUEST_DUMP       30151
#define IDD_PAGE_WIZ_PENDING_WHAT_TODO  30152
#define IDD_PAGE_WIZ_GETRESP_FILE       30153
#define IDD_PAGE_WIZ_INSTALL_RESP       30154
#define IDD_PAGE_WIZ_MANAGE_CERT        30155
#define IDD_PAGE_WIZ_FINAL_INSTALL      30156
#define IDD_PAGE_WIZ_REMOVE_CERT        30157
#define IDD_PAGE_WIZ_FINAL_REMOVE       30158
#define IDD_PAGE_WIZ_ONLINE_DUMP        30159
#define IDD_PAGE_WIZ_ERROR_KEY_MISMATCH 30160
#define IDD_PAGE_WIZ_REPLACE_CERT       30161
#define IDD_PAGE_WIZ_INSTALL_CERT       30162
#define IDD_PAGE_WIZ_CANCEL_REQUEST     30163
#define IDD_PAGE_WIZ_FINAL_CANCEL       30164
#define IDD_PAGE_WIZ_GETKEY_FILE        30165
#define IDD_PAGE_WIZ_GET_PASSWORD       30166
#define IDD_PAGE_WIZ_INSTALL_KEYCERT    30167
#define IDD_PAGE_WIZ_FINAL_REPLACE      30168
#define IDD_PAGE_WIZ_CHOOSE_CSP         30169
#define IDS_COUNTRIES_FIRST             61000
#define ID_STATIC                       65535

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        234
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         255
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\certwiz\stdafx.h ===
#if !defined(AFX_STDAFX_H__D4BE8636_0C85_11D2_91B1_00C04F8C8761__INCLUDED_)
#define AFX_STDAFX_H__D4BE8636_0C85_11D2_91B1_00C04F8C8761__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers
#include <afxtempl.h>
#include <afxctl.h>         // MFC support for ActiveX Controls
#include <afxcmn.h>

#include <atlbase.h>
extern CComModule _Module;
#include <atlcom.h>
#include <atlwin.h>

// from \NT\PUBLIC\sdk\inc
#include "basetsd.h"		
#include "accctrl.h"

// from ..\ComProp
#include "Common.h"
#include "Wizard.h"

// for debug spew
#include "iisdebug.h"

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__D4BE8636_0C85_11D2_91B1_00C04F8C8761__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\certwiz\securitysettingspage.h ===
#if !defined(AFX_SECURITYSETTINGSPAGE_H__549054D4_1561_11D2_8A1F_000000000000__INCLUDED_)
#define AFX_SECURITYSETTINGSPAGE_H__549054D4_1561_11D2_8A1F_000000000000__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// SecuritySettingsPage.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CSecuritySettingsPage dialog
class CCertificate;

typedef struct _KEY_LIMITS
{
	DWORD min, max, def;
} KEY_LIMITS;

class CSecuritySettingsPage : public CIISWizardPage
{
	DECLARE_DYNCREATE(CSecuritySettingsPage)

// Construction
public:
	CSecuritySettingsPage(CCertificate * pCert = NULL);
	~CSecuritySettingsPage();

	enum
	{
		IDD_PREV_PAGE = IDD_PAGE_WIZ_CHOOSE_CA,
		IDD_NEXT_PAGE = IDD_PAGE_WIZ_ORG_INFO,
      IDD_NEXT_CSP = IDD_PAGE_WIZ_CHOOSE_CSP
	};
// Dialog Data
	//{{AFX_DATA(CSecuritySettingsPage)
	enum { IDD = IDD_PAGE_WIZ_SECURITY_SETTINGS };
	int		m_BitLengthIndex;
	CString	m_FriendlyName;
	BOOL	m_SGC_cert;
   BOOL  m_choose_CSP;
   CButton m_check_csp;
	//}}AFX_DATA
	CCertificate * m_pCert;
	CList<int, int> m_regkey_size_list;
	CList<int, int> m_sgckey_size_list;
	KEY_LIMITS	m_regkey_limits, m_sgckey_limits;
	int m_lru_reg, m_lru_sgc;

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CSecuritySettingsPage)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	public:
	virtual BOOL OnSetActive();
	virtual LRESULT OnWizardNext();
	virtual LRESULT OnWizardPrev();
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CSecuritySettingsPage)
	virtual BOOL OnInitDialog();
	afx_msg void OnChangeFriendlyName();
	afx_msg void OnSgcCert();
	afx_msg void OnSelectCsp();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
   void SetupKeySizesCombo();
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_SECURITYSETTINGSPAGE_H__549054D4_1561_11D2_8A1F_000000000000__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\certwiz\strutil.cpp ===
#include "stdafx.h"
#include "strutil.h"


BOOL IsValidX500Chars(CString csStringToCheck)
{
    BOOL iReturn = TRUE;

    if (csStringToCheck.IsEmpty())
    {
        goto IsValidX500Chars_Exit;
    }

    // check if the string has any commas or semi colons
    if (csStringToCheck.Find(_T(',')) != -1)
    {
        iReturn = FALSE;
        goto IsValidX500Chars_Exit;
    }

    if (csStringToCheck.Find(_T(';')) != -1)
    {
        iReturn = FALSE;
        goto IsValidX500Chars_Exit;
    }

IsValidX500Chars_Exit:
    return iReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\certwiz\strutil.h ===
#include "stdafx.h"

BOOL IsValidX500Chars(CString csStringToCheck);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\certwiz\welcomepage.h ===
#if !defined(AFX_WELCOMEPAGE_H__D4BE8672_0C85_11D2_91B1_00C04F8C8761__INCLUDED_)
#define AFX_WELCOMEPAGE_H__D4BE8672_0C85_11D2_91B1_00C04F8C8761__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// WelcomePage.h : header file
//
#include "BookEndPage.h"

/////////////////////////////////////////////////////////////////////////////
// CWelcomePage dialog
class CCertificate;

class CWelcomePage : public CIISWizardBookEnd2
{
	DECLARE_DYNCREATE(CWelcomePage)

// Construction
public:
	CWelcomePage(CCertificate * pCert = NULL);
	~CWelcomePage();

	enum
	{
		CONTINUE_UNDEFINED = 0,
		CONTINUE_NEW_CERT = 1,
		CONTINUE_PENDING_CERT = 2,
		CONTINUE_INSTALLED_CERT = 3
	};
	enum
	{
		IDD_PAGE_NEXT_NEW = IDD_PAGE_WIZ_GET_WHAT,
		IDD_PAGE_NEXT_PENDING = IDD_PAGE_WIZ_PENDING_WHAT_TODO,
		IDD_PAGE_NEXT_INSTALLED = IDD_PAGE_WIZ_MANAGE_CERT
	};
// Dialog Data
	//{{AFX_DATA(CWelcomePage)
	enum { IDD = IDD_PAGE_WELCOME_START };
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA
	CCertificate * m_pCert;
	int m_ContinuationFlag;


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CWelcomePage)
   public:
   virtual BOOL OnSetActive();
	virtual LRESULT OnWizardNext();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CWelcomePage)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_WELCOMEPAGE_H__D4BE8672_0C85_11D2_91B1_00C04F8C8761__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\certwiz\whattodopendingpage.cpp ===
// WhatToDoPendingPage.cpp : implementation file
//

#include "stdafx.h"
#include "CertWiz.h"
#include "WhatToDoPendingPage.h"
#include "Certificat.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CWhatToDoPendingPage property page

IMPLEMENT_DYNCREATE(CWhatToDoPendingPage, CIISWizardPage)

CWhatToDoPendingPage::CWhatToDoPendingPage(CCertificate * pCert) 
	: CIISWizardPage(CWhatToDoPendingPage::IDD, IDS_CERTWIZ, TRUE),
	m_pCert(pCert)
{
	//{{AFX_DATA_INIT(CWhatToDoPendingPage)
	m_Index = -1;
	//}}AFX_DATA_INIT
}

CWhatToDoPendingPage::~CWhatToDoPendingPage()
{
}

void CWhatToDoPendingPage::DoDataExchange(CDataExchange* pDX)
{
	CIISWizardPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CWhatToDoPendingPage)
	DDX_Radio(pDX, IDC_PROCESS_PENDING, m_Index);
	//}}AFX_DATA_MAP
}

BOOL 
CWhatToDoPendingPage::OnSetActive() 
{
	m_pCert->SetStatusCode(CCertificate::REQUEST_UNDEFINED);
   SetWizardButtons(PSWIZB_BACK | PSWIZB_NEXT);
   return CIISWizardPage::OnSetActive();
}

LRESULT 
CWhatToDoPendingPage::OnWizardNext()
{
	UpdateData();
	switch (m_Index)
	{
	case 0:
		m_pCert->SetStatusCode(CCertificate::REQUEST_PROCESS_PENDING);
		return IDD_PAGE_NEXT_PROCESS;
	case 1:
		return IDD_PAGE_NEXT_CANCEL;
	default:
		ASSERT(FALSE);
	}
	return 1;
}

LRESULT 
CWhatToDoPendingPage::OnWizardBack()
{
	return IDD_PAGE_PREV;
}

BEGIN_MESSAGE_MAP(CWhatToDoPendingPage, CIISWizardPage)
	//{{AFX_MSG_MAP(CWhatToDoPendingPage)
		// NOTE: the ClassWizard will add message map macros here
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CWhatToDoPendingPage message handlers
BOOL CWhatToDoPendingPage::OnInitDialog() 
{
	m_Index = 0;
	CIISWizardPage::OnInitDialog();
   if (GetDlgItem(IDC_PROCESS_PENDING))
   {
	   GetDlgItem(IDC_PROCESS_PENDING)->SetFocus();
   }
	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\certwiz\make_countries\make_countries.cpp ===
// make_countries.cpp : Defines the entry point for the console application.
//

#include "stdafx.h"
#include <iostream.h>
#include <fstream.h>
#include <stdio.h>

int __cdecl main(int argc, char* argv[])
{
   ifstream in("countries.txt");
   ofstream out("countries.rc");
   char inbuf[256], outbuf[256];
   int idx = 0;

   out << "STRINGTABLE DISCARDABLE" << endl;
   out << "BEGIN" << endl;

   while (in)
   {
      in.getline(inbuf, 256);
      if (idx == 0)
      {
         sprintf(outbuf, "\tIDS_COUNTRIES_FIRST\t\t\"%s\"", inbuf);
      }
      else
      {
         sprintf(outbuf, "\tIDS_COUNTRIES_FIRST+%d\t\t\"%s\"", idx, inbuf);
      }
      out << outbuf << endl;
      idx++;
   }

   out << "END" << endl;

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\certwiz\welcomepage.cpp ===
// WelcomePage.cpp : implementation file
//

#include "stdafx.h"
#include "CertWiz.h"
#include "WelcomePage.h"
#include "Certificat.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CWelcomePage property page

IMPLEMENT_DYNCREATE(CWelcomePage, CIISWizardBookEnd2)

CWelcomePage::CWelcomePage(CCertificate * pCert) 
	: CIISWizardBookEnd2(CWelcomePage::IDD, IDS_WELCOME_PAGE_CAPTION, &pCert->m_idErrorText),
	m_pCert(pCert),
	m_ContinuationFlag(CONTINUE_UNDEFINED)
{
	//{{AFX_DATA_INIT(CWelcomePage)
	//}}AFX_DATA_INIT
}

CWelcomePage::~CWelcomePage()
{
}

void CWelcomePage::DoDataExchange(CDataExchange* pDX)
{
	CIISWizardBookEnd2::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CWelcomePage)
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CWelcomePage, CIISWizardBookEnd2)
	//{{AFX_MSG_MAP(CWelcomePage)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CWelcomePage message handlers

LRESULT 
CWelcomePage::OnWizardNext()
/*++
Routine Description:
    Next button handler

Arguments:
    None

Return Value:
	0 to automatically advance to the next page;
	1 to prevent the page from changing. 
	To jump to a page other than the next one, 
	return the identifier of the dialog to be displayed.
--*/
{
	ASSERT(m_pCert != NULL);
	int id;
	switch (m_ContinuationFlag)
	{
	case CONTINUE_NEW_CERT:
		id = IDD_PAGE_NEXT_NEW;
		break;
	case CONTINUE_PENDING_CERT:
		id = IDD_PAGE_NEXT_PENDING;
		break;
	case CONTINUE_INSTALLED_CERT:
		id = IDD_PAGE_NEXT_INSTALLED;
		break;
	default:
		id = 1;
	}
	return id;
}

BOOL 
CWelcomePage::OnSetActive() 
/*++
Routine Description:
    Activation handler

Arguments:
    None

Return Value:
    TRUE for success, FALSE for failure
--*/
{
   SetWizardButtons(PSWIZB_NEXT);
   return CIISWizardBookEnd2::OnSetActive();
}

BOOL CWelcomePage::OnInitDialog() 
{
	ASSERT(!m_pCert->m_MachineName.IsEmpty());
	ASSERT(!m_pCert->m_WebSiteInstanceName.IsEmpty());
	// check status of web server
	// set status flag
	UINT id;
	if (m_pCert->HasPendingRequest())
	{
		m_ContinuationFlag = CONTINUE_PENDING_CERT;
		id = IDS_PENDING_REQUEST;
	}
	else if (m_pCert->HasInstalledCert())
	{
		m_ContinuationFlag = CONTINUE_INSTALLED_CERT;
		id = IDS_INSTALLED_CERT;
	}
	else
	{
		m_ContinuationFlag = CONTINUE_NEW_CERT;
		id = IDS_NEW_CERT;
	}
	m_pCert->SetBodyTextID(id);
	return CIISWizardBookEnd2::OnInitDialog();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\certwiz\make_countries\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	make_countries.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\cnfgprts\font.cpp ===
// Machine generated IDispatch wrapper class(es) created by Microsoft Visual C++

// NOTE: Do not modify the contents of this file.  If this class is regenerated by
//  Microsoft Visual C++, your modifications will be overwritten.


#include "stdafx.h"
#include "font.h"


/////////////////////////////////////////////////////////////////////////////
// COleFont properties

CString COleFont::GetName()
{
	CString result;
	GetProperty(0x0, VT_BSTR, (void*)&result);
	return result;
}

void COleFont::SetName(LPCTSTR propVal)
{
	SetProperty(0x0, VT_BSTR, propVal);
}

CY COleFont::GetSize()
{
	CY result;
	GetProperty(0x2, VT_CY, (void*)&result);
	return result;
}

void COleFont::SetSize(const CY& propVal)
{
	SetProperty(0x2, VT_CY, &propVal);
}

BOOL COleFont::GetBold()
{
	BOOL result;
	GetProperty(0x3, VT_BOOL, (void*)&result);
	return result;
}

void COleFont::SetBold(BOOL propVal)
{
	SetProperty(0x3, VT_BOOL, propVal);
}

BOOL COleFont::GetItalic()
{
	BOOL result;
	GetProperty(0x4, VT_BOOL, (void*)&result);
	return result;
}

void COleFont::SetItalic(BOOL propVal)
{
	SetProperty(0x4, VT_BOOL, propVal);
}

BOOL COleFont::GetUnderline()
{
	BOOL result;
	GetProperty(0x5, VT_BOOL, (void*)&result);
	return result;
}

void COleFont::SetUnderline(BOOL propVal)
{
	SetProperty(0x5, VT_BOOL, propVal);
}

BOOL COleFont::GetStrikethrough()
{
	BOOL result;
	GetProperty(0x6, VT_BOOL, (void*)&result);
	return result;
}

void COleFont::SetStrikethrough(BOOL propVal)
{
	SetProperty(0x6, VT_BOOL, propVal);
}

short COleFont::GetWeight()
{
	short result;
	GetProperty(0x7, VT_I2, (void*)&result);
	return result;
}

void COleFont::SetWeight(short propVal)
{
	SetProperty(0x7, VT_I2, propVal);
}

short COleFont::GetCharset()
{
	short result;
	GetProperty(0x8, VT_I2, (void*)&result);
	return result;
}

void COleFont::SetCharset(short propVal)
{
	SetProperty(0x8, VT_I2, propVal);
}

/////////////////////////////////////////////////////////////////////////////
// COleFont operations
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\certwiz\whattodopendingpage.h ===
#if !defined(AFX_WHATTODOPENDINGPAGE_H__6BF86387_2E29_11D2_816C_0000F87A921B__INCLUDED_)
#define AFX_WHATTODOPENDINGPAGE_H__6BF86387_2E29_11D2_816C_0000F87A921B__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// WhatToDoPendingPage.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CWhatToDoPendingPage dialog
class CCertificate;

class CWhatToDoPendingPage : public CIISWizardPage
{
	DECLARE_DYNCREATE(CWhatToDoPendingPage)

// Construction
public:
	CWhatToDoPendingPage(CCertificate * pCert = NULL);
	~CWhatToDoPendingPage();

	enum
	{
		IDD_PAGE_NEXT_PROCESS = IDD_PAGE_WIZ_GETRESP_FILE,
		IDD_PAGE_NEXT_CANCEL = IDD_PAGE_WIZ_CANCEL_REQUEST,
		IDD_PAGE_PREV = IDD_PAGE_WELCOME_START
	};

// Dialog Data
	//{{AFX_DATA(CWhatToDoPendingPage)
	enum { IDD = IDD_PAGE_WIZ_PENDING_WHAT_TODO };
	int		m_Index;
	//}}AFX_DATA
	CCertificate * m_pCert;


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CWhatToDoPendingPage)
	public:
	virtual BOOL OnSetActive();
	virtual LRESULT OnWizardBack();
	virtual LRESULT OnWizardNext();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CWhatToDoPendingPage)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};


#endif // !defined(AFX_WHATTODOPENDINGPAGE_H__6BF86387_2E29_11D2_816C_0000F87A921B__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\certwiz\make_countries\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__1C24BC61_D2FD_4002_A7AF_564E4AECFB4A__INCLUDED_)
#define AFX_STDAFX_H__1C24BC61_D2FD_4002_A7AF_564E4AECFB4A__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000


// TODO: reference additional headers your program requires here

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__1C24BC61_D2FD_4002_A7AF_564E4AECFB4A__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\cnfgprts\helpmap.h ===
// helpmaps for the logui project - handmade

#define HIDD_RATINGS_SERVICE                    0x50300
#define HIDD_RATINGS_RATING                     0x50301

#define HIDD_APPMAPS_MAPS                       0x50310
#define HIDD_APPMAPS_ASP_MAIN                   0x50311
#define HIDD_APPMAPS_ASP_DEBUG                  0x50312
#define HIDD_APPMAPS_OTHER                      0x50313
#define HIDD_APPMAPS_OUT_OF_PROC				0x50314
#define HIDD_APPMAPS_IN_PROC_GLOBAL				0x50315
#define HIDD_APPMAPS_EDIT_MAP                   0x50318
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\cnfgprts\cnfgprts.h ===
// cnfgprts.h : main header file for CNFGPRTS.DLL

#if !defined( __AFXCTL_H__ )
	#error include 'afxctl.h' before including this file
#endif

#include "resource.h"       // main symbols
#include "helpmap.h"       // main symbols

#define REGKEY_STP          _T("SOFTWARE\\Microsoft\\INetStp")
#define REGKEY_INSTALLKEY   _T("InstallPath")

/////////////////////////////////////////////////////////////////////////////
// CCnfgprtsApp : See cnfgprts.cpp for implementation.

class CCnfgprtsApp : public COleControlModule
{
public:
	BOOL InitInstance();
	int ExitInstance();
};

extern const GUID CDECL _tlid;
extern const WORD _wVerMajor;
extern const WORD _wVerMinor;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\cnfgprts\guid.cpp ===
/*++

   Copyright    (c)    1997    Microsoft Corporation

   Module  Name :

        guid.cpp

   Abstract:

        Initialization as required by initguid

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/

//
// Include Files
//
#include <stdafx.h>

#include <objbase.h>
#include <initguid.h>
#include <iadmw.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\cnfgprts\font.h ===
// Machine generated IDispatch wrapper class(es) created by Microsoft Visual C++

// NOTE: Do not modify the contents of this file.  If this class is regenerated by
//  Microsoft Visual C++, your modifications will be overwritten.

/////////////////////////////////////////////////////////////////////////////
// COleFont wrapper class

class COleFont : public COleDispatchDriver
{
public:
	COleFont() {}		// Calls COleDispatchDriver default constructor
	COleFont(LPDISPATCH pDispatch) : COleDispatchDriver(pDispatch) {}
	COleFont(const COleFont& dispatchSrc) : COleDispatchDriver(dispatchSrc) {}

// Attributes
public:
	CString GetName();
	void SetName(LPCTSTR);
	CY GetSize();
	void SetSize(const CY&);
	BOOL GetBold();
	void SetBold(BOOL);
	BOOL GetItalic();
	void SetItalic(BOOL);
	BOOL GetUnderline();
	void SetUnderline(BOOL);
	BOOL GetStrikethrough();
	void SetStrikethrough(BOOL);
	short GetWeight();
	void SetWeight(short);
	short GetCharset();
	void SetCharset(short);

// Operations
public:
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\cnfgprts\cnfgprts.cpp ===
// cnfgprts.cpp : Implementation of CCnfgprtsApp and DLL registration.

#include "stdafx.h"
#include "cnfgprts.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


CCnfgprtsApp NEAR theApp;

const GUID CDECL BASED_CODE _tlid =
		{ 0xba634600, 0xb771, 0x11d0, { 0x92, 0x96, 0, 0xc0, 0x4f, 0xb6, 0x67, 0x8b } };
const WORD _wVerMajor = 1;
const WORD _wVerMinor = 0;


////////////////////////////////////////////////////////////////////////////
// CCnfgprtsApp::InitInstance - DLL initialization

BOOL CCnfgprtsApp::InitInstance()
{
	BOOL bInit = COleControlModule::InitInstance();
    AfxEnableControlContainer( );

	if (bInit)
	    {
        // finally, we need to redirect the winhelp file location to something more desirable
        CString sz;
        CString szHelpLocation;
        sz.LoadString( IDS_HELPLOC_HELP );

        // expand the path
        ExpandEnvironmentStrings(
            sz,	                                        // pointer to string with environment variables 
            szHelpLocation.GetBuffer(MAX_PATH + 1),   // pointer to string with expanded environment variables  
            MAX_PATH                                    // maximum characters in expanded string 
           );
        szHelpLocation.ReleaseBuffer();

        // free the existing path, and copy in the new one
        if ( m_pszHelpFilePath )
            free((void*)m_pszHelpFilePath);
        m_pszHelpFilePath = _tcsdup(szHelpLocation);
	    }

	return bInit;
}


////////////////////////////////////////////////////////////////////////////
// CCnfgprtsApp::ExitInstance - DLL termination

int CCnfgprtsApp::ExitInstance()
{
	return COleControlModule::ExitInstance();
}


/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if (!AfxOleRegisterTypeLib(AfxGetInstanceHandle(), _tlid))
		return ResultFromScode(SELFREG_E_TYPELIB);

	if (!COleObjectFactoryEx::UpdateRegistryAll(TRUE))
		return ResultFromScode(SELFREG_E_CLASS);

	return NOERROR;
}


/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if (!AfxOleUnregisterTypeLib(_tlid, _wVerMajor, _wVerMinor))
		return ResultFromScode(SELFREG_E_TYPELIB);

	if (!COleObjectFactoryEx::UpdateRegistryAll(FALSE))
		return ResultFromScode(SELFREG_E_CLASS);

	return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\cnfgprts\loguictl.cpp ===
// LogUICtl.cpp : Implementation of the CLogUICtrl OLE control class.

#include "stdafx.h"
#include <iadmw.h>
#include "cnfgprts.h"
#include "LogUICtl.h"
#include "LogUIPpg.h"

#include "wrapmb.h"
#include "metatool.h"
#include <iiscnfg.h>

#include "initguid.h"
#include <inetcom.h>
#include <logtype.h>
#include <ilogobj.hxx>


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


IMPLEMENT_DYNCREATE(CLogUICtrl, COleControl)


/////////////////////////////////////////////////////////////////////////////
// Message map

BEGIN_MESSAGE_MAP(CLogUICtrl, COleControl)
    //{{AFX_MSG_MAP(CLogUICtrl)
    //}}AFX_MSG_MAP
    ON_MESSAGE(OCM_COMMAND, OnOcmCommand)
    ON_OLEVERB(AFX_IDS_VERB_PROPERTIES, OnProperties)
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// Dispatch map

BEGIN_DISPATCH_MAP(CLogUICtrl, COleControl)
    //{{AFX_DISPATCH_MAP(CLogUICtrl)
    DISP_FUNCTION(CLogUICtrl, "SetAdminTarget", SetAdminTarget, VT_EMPTY, VTS_BSTR VTS_BSTR)
    DISP_FUNCTION(CLogUICtrl, "ApplyLogSelection", ApplyLogSelection, VT_EMPTY, VTS_NONE)
    DISP_FUNCTION(CLogUICtrl, "SetComboBox", SetComboBox, VT_EMPTY, VTS_HANDLE)
    DISP_FUNCTION(CLogUICtrl, "Terminate", Terminate, VT_EMPTY, VTS_NONE)
    DISP_STOCKFUNC_DOCLICK()
    DISP_STOCKPROP_CAPTION()
    DISP_STOCKPROP_FONT()
    DISP_STOCKPROP_ENABLED()
    DISP_STOCKPROP_BORDERSTYLE()
    //}}AFX_DISPATCH_MAP
END_DISPATCH_MAP()


/////////////////////////////////////////////////////////////////////////////
// Event map

BEGIN_EVENT_MAP(CLogUICtrl, COleControl)
    //{{AFX_EVENT_MAP(CLogUICtrl)
    EVENT_STOCK_CLICK()
    EVENT_STOCK_KEYUP()
    EVENT_STOCK_KEYDOWN()
    EVENT_STOCK_KEYPRESS()
    //}}AFX_EVENT_MAP
END_EVENT_MAP()


/////////////////////////////////////////////////////////////////////////////
// Property pages

BEGIN_PROPPAGEIDS(CLogUICtrl, 2)
    PROPPAGEID(CLogUIPropPage::guid)
    PROPPAGEID(CLSID_CFontPropPage)
END_PROPPAGEIDS(CLogUICtrl)


/////////////////////////////////////////////////////////////////////////////
// Initialize class factory and guid

IMPLEMENT_OLECREATE_EX(CLogUICtrl, "CNFGPRTS.LogUICtrl.1",
    0xba634603, 0xb771, 0x11d0, 0x92, 0x96, 0, 0xc0, 0x4f, 0xb6, 0x67, 0x8b)


/////////////////////////////////////////////////////////////////////////////
// Type library ID and version

IMPLEMENT_OLETYPELIB(CLogUICtrl, _tlid, _wVerMajor, _wVerMinor)


/////////////////////////////////////////////////////////////////////////////
// Interface IDs

const IID BASED_CODE IID_DLogUI =
        { 0xba634601, 0xb771, 0x11d0, { 0x92, 0x96, 0, 0xc0, 0x4f, 0xb6, 0x67, 0x8b } };
const IID BASED_CODE IID_DLogUIEvents =
        { 0xba634602, 0xb771, 0x11d0, { 0x92, 0x96, 0, 0xc0, 0x4f, 0xb6, 0x67, 0x8b } };


/////////////////////////////////////////////////////////////////////////////
// Control type information

static const DWORD BASED_CODE _dwLogUIOleMisc =
    OLEMISC_ACTIVATEWHENVISIBLE |
    OLEMISC_SETCLIENTSITEFIRST |
    OLEMISC_INSIDEOUT |
    OLEMISC_CANTLINKINSIDE |
    OLEMISC_ACTSLIKEBUTTON |
    OLEMISC_RECOMPOSEONRESIZE;

IMPLEMENT_OLECTLTYPE(CLogUICtrl, IDS_LOGUI, _dwLogUIOleMisc)


/////////////////////////////////////////////////////////////////////////////
// CLogUICtrl::CLogUICtrlFactory::UpdateRegistry -
// Adds or removes system registry entries for CLogUICtrl

BOOL CLogUICtrl::CLogUICtrlFactory::UpdateRegistry(BOOL bRegister)
    {
    // TODO: Verify that your control follows apartment-model threading rules.
    // Refer to MFC TechNote 64 for more information.
    // If your control does not conform to the apartment-model rules, then
    // you must modify the code below, changing the 6th parameter from
    // afxRegApartmentThreading to 0.

    if (bRegister)
        return AfxOleRegisterControlClass(
            AfxGetInstanceHandle(),
            m_clsid,
            m_lpszProgID,
            IDS_LOGUI,
            IDB_LOGUI,
            afxRegApartmentThreading,
            _dwLogUIOleMisc,
            _tlid,
            _wVerMajor,
            _wVerMinor);
    else
        return AfxOleUnregisterClass(m_clsid, m_lpszProgID);
    }


/////////////////////////////////////////////////////////////////////////////
// CLogUICtrl::CLogUICtrl - Constructor

CLogUICtrl::CLogUICtrl():
        m_fUpdateFont( FALSE ),
        m_fComboInit( FALSE ),
        m_hAccel( NULL ),
        m_cAccel( 0 )
    {
    InitializeIIDs(&IID_DLogUI, &IID_DLogUIEvents);
    }


/////////////////////////////////////////////////////////////////////////////
// CLogUICtrl::~CLogUICtrl - Destructor

CLogUICtrl::~CLogUICtrl()
    {
    if ( m_hAccel )
        DestroyAcceleratorTable( m_hAccel );
    m_hAccel = NULL;
    }


/////////////////////////////////////////////////////////////////////////////
// CLogUICtrl::OnDraw - Drawing function

void CLogUICtrl::OnDraw(
            CDC* pdc, const CRect& rcBounds, const CRect& rcInvalid)
    {
    DoSuperclassPaint(pdc, rcBounds);
    }


/////////////////////////////////////////////////////////////////////////////
// CLogUICtrl::DoPropExchange - Persistence support

void CLogUICtrl::DoPropExchange(CPropExchange* pPX)
    {
    ExchangeVersion(pPX, MAKELONG(_wVerMinor, _wVerMajor));
    COleControl::DoPropExchange(pPX);

    }


/////////////////////////////////////////////////////////////////////////////
// CLogUICtrl::OnResetState - Reset control to default state

void CLogUICtrl::OnResetState()
    {
    COleControl::OnResetState();  // Resets defaults found in DoPropExchange
    }


/////////////////////////////////////////////////////////////////////////////
// CLogUICtrl::PreCreateWindow - Modify parameters for CreateWindowEx

BOOL CLogUICtrl::PreCreateWindow(CREATESTRUCT& cs)
    {
    if ( cs.style & WS_CLIPSIBLINGS )
        cs.style ^= WS_CLIPSIBLINGS;
    cs.lpszClass = _T("BUTTON");
    return COleControl::PreCreateWindow(cs);
    }


/////////////////////////////////////////////////////////////////////////////
// CLogUICtrl::IsSubclassedControl - This is a subclassed control

BOOL CLogUICtrl::IsSubclassedControl()
    {
    return TRUE;
    }


/////////////////////////////////////////////////////////////////////////////
// CLogUICtrl::OnOcmCommand - Handle command messages

LRESULT CLogUICtrl::OnOcmCommand(WPARAM wParam, LPARAM lParam)
{
#ifdef _WIN32
    WORD wNotifyCode = HIWORD(wParam);
#else
    WORD wNotifyCode = HIWORD(lParam);
#endif

    return 0;
}

/////////////////////////////////////////////////////////////////////////////
// CLogUICtrl message handlers

//---------------------------------------------------------------------------
// OLE Interfaced Routine
void CLogUICtrl::OnClick(USHORT iButton)
    {
    CWaitCursor wait;
    IID     iid;
    HRESULT h;
    OLECHAR* poch = NULL;

    // in case there are any errors, prepare the error string
    CString sz;
    // set the name of the application correctly
    sz.LoadString( IDS_LOG_ERR_TITLE );
    // free the existing name, and copy in the new one
    free((void*)AfxGetApp()->m_pszAppName);
    AfxGetApp()->m_pszAppName = _tcsdup(sz);

     // get the string IID of the current item in the combo box
    CString szIID;
    if ( GetSelectedStringIID( szIID ) )
        {
        // convert the string to an IID that we can use
        h = CLSIDFromString( (LPTSTR)(LPCTSTR)szIID, &iid );

        // do it to it
        ActivateLogProperties( (LPTSTR)(LPCTSTR)m_szMachine, iid );
        }

    // don't fire anything off
    COleControl::OnClick(iButton);
    }

//---------------------------------------------------------------------------
void CLogUICtrl::OnFontChanged()
    {
    m_fUpdateFont = TRUE;
    COleControl::OnFontChanged();
    }

//---------------------------------------------------------------------------
void CLogUICtrl::SetAdminTarget(LPCTSTR szMachineName, LPCTSTR szMetaTarget)
    {
    m_szMachine = szMachineName;
    m_szMetaObject = szMetaTarget;
    }

//---------------------------------------------------------------------------
void CLogUICtrl::ActivateLogProperties( OLECHAR* pocMachineName, REFIID clsidUI )
    {
    AFX_MANAGE_STATE(::AfxGetStaticModuleState());

    IClassFactory*      pcsfFactory = NULL;
    HRESULT             hresError;

    ILogUIPlugin*        pUI;

    hresError = CoGetClassObject( clsidUI, CLSCTX_INPROC, NULL,
                            IID_IClassFactory, (void**) &pcsfFactory);
    if (FAILED(hresError))
                return;

        // create the instance of the interface
        hresError = pcsfFactory->CreateInstance(NULL, IID_LOGGINGUI, (void **)&pUI);
        if (FAILED(hresError))
                {
                return;
                }

        // release the factory
        pcsfFactory->Release();

    // activate the logging ui
    hresError = pUI->OnProperties( (LPTSTR)(LPCTSTR)m_szMachine, (LPTSTR)(LPCTSTR)m_szMetaObject );

    // release the logging ui
    pUI->Release();
    }

//---------------------------------------------------------------------------
// OLE Interfaced Routine
// first we get the appropriate module IID string from the logging tree. Then
// we put it into place in the metabase target
void CLogUICtrl::ApplyLogSelection()
    {
    TCHAR   buff[MAX_PATH];
    BOOL    fGotIt;
    CString szGUID;

    // start with the current string in the combo box
    CString szName;
    m_comboBox.GetWindowText( szName );
    // if nothing is selected, fail
    if ( szName.IsEmpty() ) return;

    // prep the metabase
    IMSAdminBase* pMB;
    if ( !FInitMetabaseWrapperEx( (LPTSTR)(LPCTSTR)m_szMachine, &pMB ) )
        return;
    CWrapMetaBase   mbWrap;
    if ( !mbWrap.FInit(pMB) ) return;

    // open the root logging node
    if ( mbWrap.Open( _T("/lm/logging"), METADATA_PERMISSION_READ ) )
        {
        // get the guid ui string
        fGotIt = mbWrap.GetString( szName, MD_LOG_PLUGIN_MOD_ID, IIS_MD_UT_SERVER, buff, sizeof( buff ));
        mbWrap.Close();
        if ( fGotIt )
            szGUID = buff;
        }

    // open the target metabase location for writing
    if ( fGotIt )
        {
        SetMetaString(pMB, m_szMachine, m_szMetaObject, _T(""), MD_LOG_PLUGIN_ORDER,
                    IIS_MD_UT_SERVER, szGUID, TRUE);
        }

    // clean up
    FCloseMetabaseWrapperEx(&pMB);
    }

//---------------------------------------------------------------------------
BOOL CLogUICtrl::GetSelectedStringIID( CString &szIID )
    {
    if ( !m_fComboInit ) return FALSE;

    // start with the current string in the combo box
    CString szName;
    m_comboBox.GetWindowText( szName );
    // if nothing is selected, fail
    if ( szName.IsEmpty() ) return FALSE;

    // prep the metabase
    IMSAdminBase* pMB;
    if ( !FInitMetabaseWrapperEx( (LPTSTR)(LPCTSTR)m_szMachine, &pMB ) )
        return FALSE;
    CWrapMetaBase   mbWrap;
    if ( !mbWrap.FInit(pMB) ) return FALSE;

    // open the root logging node
    if ( mbWrap.Open( _T("/lm/logging"), METADATA_PERMISSION_READ ) )
        {
        // get the guid ui string
        TCHAR   buff[MAX_PATH];
        if ( mbWrap.GetString( szName, MD_LOG_PLUGIN_UI_ID, IIS_MD_UT_SERVER, buff, sizeof( buff )) )
            szIID = buff;
        mbWrap.Close();
        }

    // clean up
    FCloseMetabaseWrapperEx(&pMB);

    // return the answer
    return !szIID.IsEmpty();
    }

//---------------------------------------------------------------------------
// OLE Interfaced Routine
void CLogUICtrl::SetComboBox(HWND hComboBox)
    {
    TCHAR   buff[MAX_PATH];
    BOOL    f;
    DWORD dw;

    CString szAvailableList;
    CString szCurrentModGuid;
    CString szCurrentModName;

    // in case there are any errors, prepare the error string
    // set the name of the application correctly
    szAvailableList.LoadString( IDS_LOG_ERR_TITLE );
    // free the existing name, and copy in the new one
    free((void*)AfxGetApp()->m_pszAppName);
    AfxGetApp()->m_pszAppName = _tcsdup(szAvailableList);
    szAvailableList.Empty();

    // attach the combo box
    m_comboBox.Attach(hComboBox);
    m_fComboInit = TRUE;

    // fill in the combo box
    // prepare the metabase wrapper
    IMSAdminBase* pMB;
    if ( !FInitMetabaseWrapperEx( (LPTSTR)(LPCTSTR)m_szMachine, &pMB ) )
        return;
    CWrapMetaBase   mbWrap;
    if ( !mbWrap.FInit(pMB) ) return;

    // get the guid string of the currently selected logging module
    if ( mbWrap.Open( m_szMetaObject, METADATA_PERMISSION_READ ) )
        {
        // start by getting the current module ID
        f = mbWrap.GetString( _T(""), MD_LOG_PLUGIN_ORDER, IIS_MD_UT_SERVER, buff, sizeof(buff));
        szCurrentModGuid = buff;

        // if we couldn't get the value, then there is a problem
        if ( !f )
            {
            DWORD   err;
            err = GetLastError();
            AfxMessageBox( IDS_ERR_LOG_PLUGIN );
            }
        mbWrap.Close();
        }

    // unfortunately, we need to chop off the end to get the plugins available location
    DWORD   chFirst = m_szMetaObject.Find(_T('/')) + 1;
    CString szService = m_szMetaObject.Right(m_szMetaObject.GetLength() - chFirst);
    // be careful of the master properties node
    INT iSlash = szService.Find(_T('/'));
    if ( iSlash < 0 )
        szService = m_szMetaObject;     // it is the root node already
    else
        szService = m_szMetaObject.Left( szService.Find(_T('/')) + chFirst );

    // get the list of available modues
    if ( mbWrap.Open( szService, METADATA_PERMISSION_READ ) )
        {
        // get thelist of available ui modules
        WCHAR* pstr = (WCHAR*)mbWrap.GetData( _T("/info"), MD_LOG_PLUGINS_AVAILABLE, IIS_MD_UT_SERVER, STRING_METADATA, &dw, METADATA_INHERIT );
        if ( pstr )
            {
            szAvailableList = pstr;
            mbWrap.FreeWrapData( (PVOID)pstr );
            }

        // close the metabase
        mbWrap.Close();
        };

    // open the root logging node
    if ( !mbWrap.Open( _T("/lm/logging"), METADATA_PERMISSION_READ ) )
        return;

    // enumerate the sub-items, adding each to the combo-box - if it is in the avail list
    // the reason we are checking against the logging module GUID is that is how we
    // can tell which is the currently selected item
    DWORD   index = 0;
    BOOL    fFoundCurrent = FALSE;
    while ( mbWrap.EnumObjects(_T(""), buff, sizeof(buff), index) )
        {
        CString szName = buff;

        // make sure it is in the list of available modules
        if ( szAvailableList.Find(szName) < 0 )
            {
            index++;
            continue;
            }

        // check against the current item's guid
        f = mbWrap.GetString( szName, MD_LOG_PLUGIN_MOD_ID, IIS_MD_UT_SERVER, buff, sizeof(buff));
        if ( !fFoundCurrent && f )
            {
            if ( szCurrentModGuid == buff )
                {
                szCurrentModName = szName;
                fFoundCurrent = TRUE;
                }
            }

        // add the item to the combo box
        m_comboBox.AddString( szName );

        // increment the index
        index++;
        }

    // select the current item in the combo box
    m_comboBox.SelectString( -1, szCurrentModName );

    // close the metabase
    mbWrap.Close();

    // clean up
    FCloseMetabaseWrapperEx(&pMB);
    }

//---------------------------------------------------------------------------
// OLE Interfaced Routine
void CLogUICtrl::Terminate()
    {
    if ( m_fComboInit )
        m_comboBox.Detach();
    m_fComboInit = FALSE;
    }

//------------------------------------------------------------------------
// get the inetinfo path
BOOL CLogUICtrl::GetServerDirectory( CString &sz )
    {
        HKEY        hKey;
        TCHAR       chBuff[MAX_PATH+1];
        DWORD       err, type;
        DWORD       cbBuff;

    // get the server install path from the registry
    // open the registry key, if it exists
    err = RegOpenKeyEx(
            HKEY_LOCAL_MACHINE, // handle of open key
            REGKEY_STP,         // address of name of subkey to open
            0,                  // reserved
            KEY_READ,           // security access mask
            &hKey               // address of handle of open key
           );

    // if we did not open the key for any reason (say... it doesn't exist)
    // then leave right away
    if ( err != ERROR_SUCCESS )
        return FALSE;

    cbBuff = sizeof(chBuff);
    type = REG_SZ;
    err = RegQueryValueEx(
            hKey,               // handle of key to query
            REGKEY_INSTALLKEY,  // address of name of value to query
            NULL,               // reserved
            &type,              // address of buffer for value type
            (PUCHAR)chBuff,     // address of data buffer
            &cbBuff             // address of data buffer size
           );

    // close the key
    RegCloseKey( hKey );

    // if we did get the key for any reason (say... it doesn't exist)
    // then leave right away
    if ( err != ERROR_SUCCESS )
        return FALSE;

    // set the string
    sz = chBuff;

    // success
    return TRUE;
    }

//------------------------------------------------------------------------
void CLogUICtrl::OnAmbientPropertyChange(DISPID dispid)
    {
    BOOL    flag;
    UINT    style;

    // do the right thing depending on the dispid
    switch ( dispid )
        {
        case DISPID_AMBIENT_DISPLAYASDEFAULT:
            if ( GetAmbientProperty( DISPID_AMBIENT_DISPLAYASDEFAULT, VT_BOOL, &flag ) )
                {
                style = GetWindowLong(
                        GetSafeHwnd(), // handle of window
                        GWL_STYLE  // offset of value to retrieve
                        );
                if ( flag )
                    style |= BS_DEFPUSHBUTTON;
                else
                    style ^= BS_DEFPUSHBUTTON;
                SetWindowLong(
                        GetSafeHwnd(), // handle of window
                        GWL_STYLE,  // offset of value to retrieve
                        style
                        );
                Invalidate(TRUE);
                }
            break;
        };

    COleControl::OnAmbientPropertyChange(dispid);
    }

//------------------------------------------------------------------------
// an important method where we tell the container how to deal with us.
// pControlInfo is passed in by the container, although we are responsible
// for maintining the hAccel structure
void CLogUICtrl::OnGetControlInfo(LPCONTROLINFO pControlInfo)
    {
    // do a rudimentary check to see if we understand pControlInfo
    if ( !pControlInfo || pControlInfo->cb < sizeof(CONTROLINFO) )
        return;

    // set the accelerator handle into place
    pControlInfo->hAccel = m_hAccel;
    pControlInfo->cAccel = m_cAccel;

    // when we have focus, we do want the enter key
    pControlInfo->dwFlags = CTRLINFO_EATS_RETURN;
    }

//------------------------------------------------------------------------
// the ole control container object specifically filters out the space
// key so we do not get it as a OnMnemonic call. Thus we need to look
// for it ourselves
void CLogUICtrl::OnKeyUpEvent(USHORT nChar, USHORT nShiftState)
    {
    if ( nChar == _T(' ') )
        {
        OnClick((USHORT)GetDlgCtrlID());
        }
    COleControl::OnKeyUpEvent(nChar, nShiftState);
    }

//------------------------------------------------------------------------
void CLogUICtrl::OnMnemonic(LPMSG pMsg)
    {
    OnClick((USHORT)GetDlgCtrlID());
    COleControl::OnMnemonic(pMsg);
    }

//------------------------------------------------------------------------
void CLogUICtrl::OnTextChanged()
    {
    // get the new text
    CString sz = InternalGetText();

    // set the accelerator table
    SetAccelTable((LPCTSTR)sz);
    if ( SetAccelTable((LPCTSTR)sz) )
        // make sure the new accelerator table gets loaded
        ControlInfoChanged();

    // finish with the default handling.
    COleControl::OnTextChanged();
    }

//------------------------------------------------------------------------
BOOL CLogUICtrl::SetAccelTable( LPCTSTR pszCaption )
    {
    BOOL    fAnswer = FALSE;
    ACCEL   accel;
    int     iAccel;

    // get the new text
    CString sz = pszCaption;
    sz.MakeLower();

    // if the handle has already been allocated, free it
    if ( m_hAccel )
        {
        DestroyAcceleratorTable( m_hAccel );
        m_hAccel = NULL;
        m_cAccel = 0;
        }

    // if there is a & character, then declare the accelerator
    iAccel = sz.Find(_T('&'));
    if ( iAccel >= 0 )
        {
        // fill in the accererator record
        accel.fVirt = FALT;
        accel.key = sz.GetAt(iAccel + 1);
        accel.cmd = (USHORT)GetDlgCtrlID();

        m_hAccel = CreateAcceleratorTable( &accel, 1 );
        if ( m_hAccel )
            m_cAccel = 1;

        fAnswer = TRUE;
        }

    // return the answer
    return fAnswer;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\cnfgprts\loguippg.cpp ===
// LogUIPpg.cpp : Implementation of the CLogUIPropPage property page class.

#include "stdafx.h"
#include "cnfgprts.h"
#include "LogUIPpg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


IMPLEMENT_DYNCREATE(CLogUIPropPage, COlePropertyPage)


/////////////////////////////////////////////////////////////////////////////
// Message map

BEGIN_MESSAGE_MAP(CLogUIPropPage, COlePropertyPage)
	//{{AFX_MSG_MAP(CLogUIPropPage)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// Initialize class factory and guid

IMPLEMENT_OLECREATE_EX(CLogUIPropPage, "CNFGPRTS.LogUIPropPage.1",
	0xba634604, 0xb771, 0x11d0, 0x92, 0x96, 0, 0xc0, 0x4f, 0xb6, 0x67, 0x8b)


/////////////////////////////////////////////////////////////////////////////
// CLogUIPropPage::CLogUIPropPageFactory::UpdateRegistry -
// Adds or removes system registry entries for CLogUIPropPage

BOOL CLogUIPropPage::CLogUIPropPageFactory::UpdateRegistry(BOOL bRegister)
{
	if (bRegister)
		return AfxOleRegisterPropertyPageClass(
         AfxGetInstanceHandle(),
			m_clsid, 
         IDS_LOGUI_PPG,
         afxRegApartmentThreading
         );
	else
		return AfxOleUnregisterClass(m_clsid, NULL);
}


/////////////////////////////////////////////////////////////////////////////
// CLogUIPropPage::CLogUIPropPage - Constructor

CLogUIPropPage::CLogUIPropPage() :
	COlePropertyPage(IDD, IDS_LOGUI_PPG_CAPTION)
{
	//{{AFX_DATA_INIT(CLogUIPropPage)
	m_sz_caption = _T("");
	//}}AFX_DATA_INIT
}


/////////////////////////////////////////////////////////////////////////////
// CLogUIPropPage::DoDataExchange - Moves data between page and properties

void CLogUIPropPage::DoDataExchange(CDataExchange* pDX)
{
	//{{AFX_DATA_MAP(CLogUIPropPage)
	DDP_Text(pDX, IDC_CAPTIONEDIT, m_sz_caption, _T("Caption") );
	DDX_Text(pDX, IDC_CAPTIONEDIT, m_sz_caption);
	//}}AFX_DATA_MAP
	DDP_PostProcessing(pDX);
}


/////////////////////////////////////////////////////////////////////////////
// CLogUIPropPage message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\cnfgprts\loguictl.h ===
// LogUICtl.h : Declaration of the CLogUICtrl OLE control class.

/////////////////////////////////////////////////////////////////////////////
// CLogUICtrl : See LogUICtl.cpp for implementation.

class CLogUICtrl : public COleControl
{
	DECLARE_DYNCREATE(CLogUICtrl)

// Constructor
public:
	CLogUICtrl();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CLogUICtrl)
	public:
	virtual void OnDraw(CDC* pdc, const CRect& rcBounds, const CRect& rcInvalid);
	virtual void DoPropExchange(CPropExchange* pPX);
	virtual void OnResetState();
	virtual void OnClick(USHORT iButton);
	virtual void OnFontChanged();
	virtual void OnAmbientPropertyChange(DISPID dispid);
	virtual void OnGetControlInfo(LPCONTROLINFO pControlInfo);
	virtual void OnKeyUpEvent(USHORT nChar, USHORT nShiftState);
	virtual void OnMnemonic(LPMSG pMsg);
	virtual void OnTextChanged();
	//}}AFX_VIRTUAL

// Implementation
protected:
	~CLogUICtrl();

	DECLARE_OLECREATE_EX(CLogUICtrl)    // Class factory and guid
	DECLARE_OLETYPELIB(CLogUICtrl)      // GetTypeInfo
	DECLARE_PROPPAGEIDS(CLogUICtrl)     // Property page IDs
	DECLARE_OLECTLTYPE(CLogUICtrl)		// Type name and misc status

	// Subclassed control support
	BOOL PreCreateWindow(CREATESTRUCT& cs);
	BOOL IsSubclassedControl();
	LRESULT OnOcmCommand(WPARAM wParam, LPARAM lParam);

// Message maps
	//{{AFX_MSG(CLogUICtrl)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

// Dispatch maps
	//{{AFX_DISPATCH(CLogUICtrl)
	afx_msg void SetAdminTarget(LPCTSTR szMachineName, LPCTSTR szMetaTarget);
	afx_msg void ApplyLogSelection();
	afx_msg void SetComboBox(HWND hComboBox);
	afx_msg void Terminate();
	//}}AFX_DISPATCH
	DECLARE_DISPATCH_MAP()

// Event maps
	//{{AFX_EVENT(CLogUICtrl)
	//}}AFX_EVENT
	DECLARE_EVENT_MAP()

// Dispatch and event IDs
public:
	enum {
	//{{AFX_DISP_ID(CLogUICtrl)
	dispidSetAdminTarget = 1L,
	dispidApplyLogSelection = 2L,
	dispidSetComboBox = 3L,
	dispidTerminate = 4L,
	//}}AFX_DISP_ID
	};

protected:
    void ActivateLogProperties( OLECHAR* pocMachineName, REFIID clsidUI );

    BOOL GetSelectedStringIID( CString &szIID );

    BOOL GetServerDirectory( CString &sz );
//    BOOL RegisterMSLogUI();

    BOOL SetAccelTable( LPCTSTR pszCaption );

    BOOL 	m_fUpdateFont;
    CString m_szMachine;
    CString m_szMetaObject;

    BOOL        m_fComboInit;
    CComboBox   m_comboBox;

    
    // the accelerator table
    HACCEL  m_hAccel;
    WORD    m_cAccel;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\cnfgprts\mdobjs.h ===
#define SZ_W3_ROOT     _T("/lm/w3svc")
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\cnfgprts\ratadvpg.cpp ===
// RatAdvPg.cpp : implementation file
//

#include "stdafx.h"
#include <iadmw.h>
#include "cnfgprts.h"

#include "parserat.h"
#include "RatData.h"

#include "RatAdvPg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CRatAdvancedPage property page

IMPLEMENT_DYNCREATE(CRatAdvancedPage, CPropertyPage)

CRatAdvancedPage::CRatAdvancedPage() : CPropertyPage(CRatAdvancedPage::IDD)
{
	//{{AFX_DATA_INIT(CRatAdvancedPage)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}

CRatAdvancedPage::~CRatAdvancedPage()
{
}

void CRatAdvancedPage::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CRatAdvancedPage)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CRatAdvancedPage, CPropertyPage)
	//{{AFX_MSG_MAP(CRatAdvancedPage)
		// NOTE: the ClassWizard will add message map macros here
	//}}AFX_MSG_MAP
    ON_COMMAND(ID_HELP_FINDER,  DoHelp)
    ON_COMMAND(ID_HELP,         DoHelp)
    ON_COMMAND(ID_CONTEXT_HELP, DoHelp)
    ON_COMMAND(ID_DEFAULT_HELP, DoHelp)
END_MESSAGE_MAP()

//---------------------------------------------------------------------------
void CRatAdvancedPage::DoHelp()
    {
    }

/////////////////////////////////////////////////////////////////////////////
// CRatAdvancedPage message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\cnfgprts\metatool.cpp ===
// metatool.cpp : implementation file
//

// some common tools used for "smart" writing to the metabase

#include "stdafx.h"
#include <iadmw.h>

#define _COMIMPORT
#include <common.h>
#include <idlg.h>

#include "wrapmb.h"
#include "metatool.h"


//----------------------------------------------------------------
// open the metabase with an option to create the directory if it doesn't
// exist. It would be nice to move this into wrapmb, but that is too big
// a change for now. Maybe we can do that later.
BOOL OpenAndCreate( CWrapMetaBase* pmb, LPCTSTR pszTarget, DWORD perm, BOOL fCreate )
    {
    BOOL    f;
    CString szTarget = pszTarget;

    // start by just trying to open it. easy easy.
    if ( pmb->Open(szTarget, perm) )
        return TRUE;

    // if requested, try to create the key if it doesn't exist
    if ( fCreate )
        {
        // find the nearest openable parent directory and open it
        CString szPartial;
        CString szBase = szTarget;
        do
            {
            szBase = szBase.Left( szBase.ReverseFind(_T('/')) );
            szPartial = szTarget.Right( szTarget.GetLength() - szBase.GetLength() - 1 );
            f = pmb->Open( szBase, METADATA_PERMISSION_WRITE | perm );
            } while (!f && !szBase.IsEmpty());

        // if all that failed, fail
        if ( !f ) return FALSE;

        // create the key that we really want
        f = pmb->AddObject( szPartial );
        pmb->Close();

        // if all that failed, fail
        if ( !f ) return FALSE;

        // try again
        if ( pmb->Open(szTarget, perm) )
            return TRUE;
        }

    // total washout
    return FALSE;
    }

//----------------------------------------------------------------
// starting at the root, check for values set on sub-keys that may need to be overridden
// and propmt the user for what to do
void CheckInheritence( LPCTSTR pszServer, LPCTSTR pszInheritRoot, DWORD idData )
    {
    CComAuthInfo auth(pszServer);
    CInheritanceDlg dlgInherit(
            idData,
            FROM_WRITE_PROPERTY,
            &auth,
            pszInheritRoot
            );

    // if it worked, then run the dialog
    if ( !dlgInherit.IsEmpty() )
        dlgInherit.DoModal();
    }

// notice that the dwords and generic blobs are handled seperately even though
// we count route the dwords through the blob mechanisms. This is done for two
// reasone. 1) Handling dwords is much more efficient than handling blobs.
// and 2) Most of the values are dwords.

//----------------------------------------------------------------
// opens the metabase, writes out the value, then uses the inheritence
// checking functionality from the iisui.dll to check for the inherited
// properties and propt the user for what to do
BOOL SetMetaDword(IMSAdminBase* pMB, LPCTSTR pszServer, LPCTSTR pszMetaRoot, LPCTSTR pszSub, DWORD idData, DWORD iType, DWORD dwValue, BOOL fCheckInheritence)
    {
    BOOL    fAnswer = FALSE;
    BOOL    fChanged = TRUE;
    DWORD   dword;

    CWrapMetaBase   mbWrap;
    if ( !mbWrap.FInit(pMB) ) return FALSE;

      // open the target
    if ( OpenAndCreate( &mbWrap, pszMetaRoot, 
            METADATA_PERMISSION_WRITE | METADATA_PERMISSION_READ, TRUE ) )
        {
        // attempt to get the current value - no inheritence
        if ( mbWrap.GetDword(pszSub, idData, iType, &dword) )
            {
            // set the changed flag
            fChanged = (dwValue != dword);
            }

        // save it out, if it changed or is not there
        if ( fChanged )
            fAnswer = mbWrap.SetDword( pszSub, idData, iType, dwValue );

        // close the metabase
        mbWrap.Close();
        }
    else
        fChanged = FALSE;
  
    // set up and run the inheritence checking dialog
    if ( fCheckInheritence && fChanged )
        {
        CString szInheritRoot = pszMetaRoot;
        szInheritRoot += pszSub;
        CheckInheritence( pszServer, szInheritRoot, idData );
        }
    
    return fAnswer;
    }

//----------------------------------------------------------------
// assumes that the metabase is actually open to the parent of the one we are interested
// and that the real target name is passed into szSub
BOOL SetMetaData(IMSAdminBase* pMB, LPCTSTR pszServer, LPCTSTR pszMetaRoot, LPCTSTR pszSub, DWORD idData, DWORD iType, DWORD iDataType, PVOID pData, DWORD cbData, BOOL fCheckInheritence )
    {
    BOOL    fAnswer = FALSE;
    BOOL    fChanged = TRUE;
    DWORD   cbTestData;

    CWrapMetaBase   mbWrap;
    if ( !mbWrap.FInit(pMB) ) return FALSE;

      // open the target
    if ( OpenAndCreate( &mbWrap, pszMetaRoot,
            METADATA_PERMISSION_WRITE | METADATA_PERMISSION_READ, TRUE ) )
        {
        // attempt to get the current value - no inheritence
        PVOID pTestData = mbWrap.GetData( pszSub, idData, iType,
                            iDataType, &cbTestData );
        if ( pTestData )
            {
            // set the changed flag
            if ( cbData == cbTestData )
                {
                fChanged = (memcmp(pData, pTestData, cbData) != 0);
                }            
            mbWrap.FreeWrapData( pTestData );
            }

        // save it out, if it changed or is not there
        if ( fChanged )
            fAnswer = mbWrap.SetData( pszSub, idData, iType, iDataType, pData, cbData );

        // close the metabase
        mbWrap.Close();
        }
    else
        fChanged = FALSE;

    // set up and run the inheritence checking dialog
    if ( fCheckInheritence && fChanged )
        {
        CString szInheritRoot = pszMetaRoot;
        szInheritRoot += pszSub;
        CheckInheritence( pszServer, szInheritRoot, idData );
        }
    
    return fAnswer;
    }

//----------------------------------------------------------------
// assumes that the metabase is actually open to the parent of the one we are interested
// and that the real target name is passed into szSub
BOOL SetMetaString(IMSAdminBase* pMB, LPCTSTR pszServer, LPCTSTR pszMetaRoot, LPCTSTR pszSub, DWORD idData, DWORD iType, CString sz, BOOL fCheckInheritence)
    {
    return SetMetaData(pMB, pszServer, pszMetaRoot, pszSub, idData,
            iType, STRING_METADATA, (LPTSTR)(LPCTSTR)sz,
            (sz.GetLength()+1)*sizeof(TCHAR), fCheckInheritence );
    }

//----------------------------------------------------------------
// assumes that the metabase is actually open to the parent of the one we are interested
// and that the real target name is passed into szSub
// the cchmsz is the total count of characters in the multi string including the nulls
BOOL SetMetaMultiSz(IMSAdminBase* pMB, LPCTSTR pszServer, LPCTSTR pszMetaRoot, LPCTSTR pszSub, DWORD idData, DWORD iType, PVOID pData, DWORD cchmsz, BOOL fCheckInheritence )
    {
    return SetMetaData(pMB, pszServer, pszMetaRoot, pszSub, idData,
            iType, MULTISZ_METADATA, pData, (cchmsz+1)*sizeof(TCHAR), fCheckInheritence );
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\cnfgprts\metatool.h ===
BOOL SetMetaDword(IMSAdminBase* pMB, LPCTSTR pszServer, LPCTSTR pszMetaRoot, LPCTSTR pszSub, DWORD idData, DWORD iType, DWORD dwValue, BOOL fCheckInheritence);
BOOL SetMetaString(IMSAdminBase* pMB, LPCTSTR pszServer, LPCTSTR pszMetaRoot, LPCTSTR pszSub, DWORD idData, DWORD iType, CString sz, BOOL fCheckInheritence);
BOOL SetMetaData(IMSAdminBase* pMB, LPCTSTR pszServer, LPCTSTR pszMetaRoot, LPCTSTR pszSub, DWORD idData, DWORD iType, DWORD iDataType, PVOID pData, DWORD cbData, BOOL fCheckInheritence );
BOOL SetMetaMultiSz(IMSAdminBase* pMB, LPCTSTR pszServer, LPCTSTR pszMetaRoot, LPCTSTR pszSub, DWORD idData, DWORD iType, PVOID pData, DWORD cchmsz, BOOL fCheckInheritence );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\cnfgprts\loguippg.h ===
// LogUIPpg.h : Declaration of the CLogUIPropPage property page class.

////////////////////////////////////////////////////////////////////////////
// CLogUIPropPage : See LogUIPpg.cpp.cpp for implementation.

class CLogUIPropPage : public COlePropertyPage
{
	DECLARE_DYNCREATE(CLogUIPropPage)
	DECLARE_OLECREATE_EX(CLogUIPropPage)

// Constructor
public:
	CLogUIPropPage();

// Dialog Data
	//{{AFX_DATA(CLogUIPropPage)
	enum { IDD = IDD_PROPPAGE_LOGUI };
	CString	m_sz_caption;
	//}}AFX_DATA

// Implementation
protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support

// Message maps
protected:
	//{{AFX_MSG(CLogUIPropPage)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\cnfgprts\ratadvpg.h ===
// RatAdvPg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CRatAdvancedPage dialog

class CRatAdvancedPage : public CPropertyPage
{
	DECLARE_DYNCREATE(CRatAdvancedPage)

// Construction
public:
	CRatAdvancedPage();
	~CRatAdvancedPage();

    // the data
    CRatingsData*   m_pRatData;

// Dialog Data
	//{{AFX_DATA(CRatAdvancedPage)
	enum { IDD = IDD_RAT_ADVANCED };
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CRatAdvancedPage)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CRatAdvancedPage)
		// NOTE: the ClassWizard will add member functions here
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
    void DoHelp();
    };
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\cnfgprts\parserat.cpp ===
/****************************************************************************\
 *
 *   PARSERAT.C -- Code to parse .RAT files
 *
 *   Created:   Greg Jones
 *
\****************************************************************************/

/*Includes------------------------------------------------------------------*/
#include "stdafx.h"
#include "cnfgprts.h"

#include "parserat.h"
#include <iis64.h>

/****************************************************************************
Some design notes on how this parser works:

A ParenThing is:

'(' identifier [stuff] ')'

where [stuff] could be:
    a quoted string
    a number
    a boolean
    a series of ParenThings
    in the case of extensions:
        a quoted string, followed by
        one or more quoted strings and/or ParenThings

The entire .RAT file is a ParenThing, except that it has no identifier, just
a list of ParenThings inside it.


**********************************************************************
We pass the parser a schema for what things it expects -- we have
a big array listing identifiers for each different possible keyword, and
each parser call receives a smaller array containing only those indices
that are valid to occur within that object.

We make PicsRatingSystem, PicsCategory, and PicsEnum derive from a common
base class which supports a virtual function AddItem(ID,data).  So at the
top level, we construct an (empty) PicsRatingSystem.  We call the parser,
giving it a pointer to that guy, and a structure describing what to parse --
the ParenObject's token is a null string (since the global structure is the
one that doesn't start with a token before its first embedded ParenThing),
and we give a list saying the allowable things in a PicsRatingSystem are
PICS-version, rating-system, rating-service, default, description, extension,
icon, name, category.  There is a global table indicating a handler function
for every type of ParenThing, which knows how to create a data structure
completely describing that ParenThing.  (That data structure could be as
simple as a number or as complex as allocating and parsing a complete
PicsCategory object.)

The parser walks along, and for each ParenThing he finds, he identifies it
by looking up its token in the list provided by the caller. Each entry in
that list should include a field which indicates whether multiple things
of that identity are allowed (e.g., 'category') or not (e.g., rating-system).
If only one is allowed, then when the parser finds one he marks it as having
been found.

When the parser identifies the ParenThing, he calls its handler function to
completely parse the data in the ParenThing and return that object into an
LPVOID provided by the parser.  If that is successful, the parser then calls
its object's AddItem(ID,data) virtual function to add the specified item to
the object, relying on the object itself to know what type "data" points to --
a number, a pointer to a heap string which can be given to ETS::SetTo, a
pointer to a PicsCategory object which can be appended to an array, etc.

The RatFileParser class exists solely to provide a line number shared by
all the parsing routines.  This line number is updated as the parser walks
through the file, and is frozen as soon as an error is found.  This line
number can later be reported to the user to help localize errors in RAT files.

*****************************************************************************/

/*Globals-------------------------------------------------------------------*/

#define EXTTEXT(n) const CHAR n[]
#define TEXTCONST(name,text) EXTTEXT(name) = (text)

/* Text strings used in parsing rating labels. */

TEXTCONST(szNULL,"");
TEXTCONST(szDoubleCRLF,"\r\n\r\n");
TEXTCONST(szPicsOpening,"(PICS-");
TEXTCONST(szWhitespace," \t\r\n");
TEXTCONST(szExtendedAlphaNum,"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+-.,;:&=?!*~@#/");
TEXTCONST(szSingleCharTokens,"()\"");
TEXTCONST(szLeftParen,"(");
TEXTCONST(szRightParen,")");
TEXTCONST(szOptional,"optional");
TEXTCONST(szMandatory,"mandatory");
TEXTCONST(szAtOption,"at");
TEXTCONST(szByOption,"by");
TEXTCONST(szCommentOption,"comment");
TEXTCONST(szCompleteLabelOption,"complete-label");
TEXTCONST(szFullOption,"full");
TEXTCONST(szExtensionOption,"extension");
TEXTCONST(szGenericOption,"generic");
TEXTCONST(szShortGenericOption,"gen");
TEXTCONST(szForOption,"for");
TEXTCONST(szMICOption,"MIC-md5");
TEXTCONST(szMD5Option,"md5");
TEXTCONST(szOnOption,"on");
TEXTCONST(szSigOption,"signature-PKCS");
TEXTCONST(szUntilOption,"until");
TEXTCONST(szExpOption,"exp");
TEXTCONST(szRatings,"ratings");
TEXTCONST(szShortRatings,"r");
TEXTCONST(szError,"error");
TEXTCONST(szNoRatings,"no-ratings");
TEXTCONST(szLabelWord,"labels");
TEXTCONST(szShortLabelWord,"l");
TEXTCONST(szShortTrue,"t");
TEXTCONST(szTrue,"true");
TEXTCONST(szShortFalse,"f");
TEXTCONST(szFalse,"false");

TEXTCONST(szNegInf,"-INF");
TEXTCONST(szPosInf,"+INF");
TEXTCONST(szLabel,"label");
TEXTCONST(szName,"name");
TEXTCONST(szValue,"value");
TEXTCONST(szIcon,"icon");
TEXTCONST(szDescription, "description");
TEXTCONST(szCategory, "category");
TEXTCONST(szTransmitAs, "transmit-as");
TEXTCONST(szMin,"min");
TEXTCONST(szMax,"max");
TEXTCONST(szMultivalue,"multivalue");
TEXTCONST(szInteger,"integer");
TEXTCONST(szLabelOnly, "label-only");
TEXTCONST(szPicsVersion,"PICS-version");
TEXTCONST(szRatingSystem,"rating-system");
TEXTCONST(szRatingService,"rating-service");
TEXTCONST(szRatingBureau,"rating-bureau");
TEXTCONST(szBureauRequired,"bureau-required");
TEXTCONST(szDefault,"default");
TEXTCONST(szMultiValue,"multivalue");
TEXTCONST(szUnordered,"unordered");
TEXTCONST(szRatingBureauExtension,"www.w3.org/PICS/service-extensions/label-bureau");

/* define some error codes */
const HRESULT RAT_E_BASE = 0x80050000;                  /* just a guess at a free area for internal use */
const HRESULT RAT_E_EXPECTEDLEFT    = RAT_E_BASE + 1;   /* expected left paren */
const HRESULT RAT_E_EXPECTEDRIGHT   = RAT_E_BASE + 2;   /* expected right paren */
const HRESULT RAT_E_EXPECTEDTOKEN   = RAT_E_BASE + 3;   /* expected unquoted token */
const HRESULT RAT_E_EXPECTEDSTRING  = RAT_E_BASE + 4;   /* expected quoted string */
const HRESULT RAT_E_EXPECTEDNUMBER  = RAT_E_BASE + 5;   /* expected number */
const HRESULT RAT_E_EXPECTEDBOOL    = RAT_E_BASE + 6;   /* expected boolean */
const HRESULT RAT_E_DUPLICATEITEM   = RAT_E_BASE + 7;   /* AO_SINGLE item appeared twice */
const HRESULT RAT_E_MISSINGITEM     = RAT_E_BASE + 8;   /* AO_MANDATORY item not found */
const HRESULT RAT_E_UNKNOWNITEM     = RAT_E_BASE + 9;   /* unrecognized token */
const HRESULT RAT_E_UNKNOWNMANDATORY= RAT_E_BASE + 10;  /* unrecognized mandatory extension */

char PicsDelimChar='/';

class RatFileParser
{
public:
    UINT m_nLine;

    RatFileParser() { m_nLine = 1; }

    LPSTR EatQuotedString(LPSTR pIn);
    HRESULT ParseToOpening(LPSTR *ppIn, AllowableOption *paoExpected,
                           AllowableOption **ppFound);
    HRESULT ParseParenthesizedObject(
        LPSTR *ppIn,                    /* where we are in the text stream */
        AllowableOption aao[],          /* allowable things inside this object */
        PicsObjectBase *pObject         /* object to set parameters into */
    );
    char* FindNonWhite(char *pc);
};



/* White returns a pointer to the first whitespace character starting at pc.
 */
char* White(char *pc){
    assert(pc);
    while (1){
        if (*pc == '\0' ||
            *pc ==' ' ||
            *pc == '\t' ||
            *pc == '\r' ||
            *pc == '\n')
        {
            return pc;
        }
        pc++;
    }
}


/* NonWhite returns a pointer to the first non-whitespace character starting
 * at pc.
 */
char* NonWhite(char *pc){
    assert(pc);
    while (1){
        if (*pc != ' ' &&
            *pc != '\t' &&
            *pc != '\r' &&
            *pc != '\n')            /* includes null terminator */
        {
            return pc;
        }
        pc++;
    }
}


/* FindNonWhite returns a pointer to the first non-whitespace character starting
 * at pc.
 */
char* RatFileParser::FindNonWhite(char *pc)
{
    assert(pc);
    while (1)
    {
        if (*pc != ' ' &&
            *pc != '\t' &&
            *pc != '\r' &&
            *pc != '\n')            /* includes null terminator */
        {
            return pc;
        }
        if (*pc == '\n')
            m_nLine++;
        pc++;
    }
}

/* AppendSlash forces pszString to end in a single slash if it doesn't
 * already.  This may produce a technically invalid URL (for example,
 * "http://gregj/default.htm/", but we're only using the result for
 * comparisons against other paths similarly mangled.
 */
void AppendSlash(LPSTR pszString)
{
    LPSTR pszSlash = ::strrchrf(pszString, '/');

    if (pszSlash == NULL || *(pszSlash + 1) != '\0')
        ::strcatf(pszString, "/");
}

/* SkipWhitespace(&pszString)
 *
 * advances pszString past whitespace characters
 */
void SkipWhitespace(LPSTR *ppsz)
{
    UINT cchWhitespace = ::strspnf(*ppsz, szWhitespace);

    *ppsz += cchWhitespace;
}


/* FindTokenEnd(pszStart)
 *
 * Returns a pointer to the end of a contiguous range of similarly-typed
 * characters (whitespace, quote mark, punctuation, or alphanumerics).
 */
LPSTR FindTokenEnd(LPSTR pszStart)
{
    LPSTR pszEnd = pszStart;

    if (*pszEnd == '\0') {
        return pszEnd;
    }
    else if (strchr(szSingleCharTokens, *pszEnd)) {
        return ++pszEnd;
    }

    UINT cch;
    cch = ::strspnf(pszEnd, szWhitespace);
    if (cch > 0)
        return pszEnd + cch;

    cch = ::strspnf(pszEnd, szExtendedAlphaNum);
    if (cch > 0)
        return pszEnd + cch;

    return pszEnd;              /* unrecognized characters */
}


/* GetBool(LPSTR *ppszToken, BOOL *pfOut)
 *
 * Parses a boolean value at the given token and returns its value in *pfOut.
 * Legal values are 't', 'f', 'true', and 'false'.  If success, *ppszToken
 * is advanced past the boolean token and any following whitespace.  If failure,
 * *ppszToken is not modified.
 *
 * pfOut may be NULL if the caller just wants to eat the token and doesn't
 * care about its value.
 */
HRESULT GetBool(LPSTR *ppszToken, BOOL *pfOut)
{
    BOOL bValue;

    LPSTR pszTokenEnd = FindTokenEnd(*ppszToken);

    if (IsEqualToken(*ppszToken, pszTokenEnd, szShortTrue) ||
        IsEqualToken(*ppszToken, pszTokenEnd, szTrue)) {
        bValue = TRUE;
    }
    else if (IsEqualToken(*ppszToken, pszTokenEnd, szShortFalse) ||
        IsEqualToken(*ppszToken, pszTokenEnd, szFalse)) {
        bValue = FALSE;
    }
    else
        return ResultFromScode(MK_E_SYNTAX);

    if (pfOut != NULL)
        *pfOut = bValue;

    *ppszToken = pszTokenEnd;
    SkipWhitespace(ppszToken);

    return NOERROR;
}


/* GetQuotedToken(&pszThisToken, &pszQuotedToken)
 *
 * Sets pszQuotedToken to point to the contents of the doublequotes.
 * pszQuotedToken may be NULL if the caller just wants to eat the token.
 * Sets pszThisToken to point to the first character after the closing
 *   doublequote.
 * Fails if pszThisToken doesn't start with a doublequote or doesn't
 *   contain a closing doublequote.
 * The closing doublequote is replaced with a null terminator, iff the
 *   function does not fail.
 */
HRESULT GetQuotedToken(LPSTR *ppszThisToken, LPSTR *ppszQuotedToken)
{
    HRESULT hres = ResultFromScode(MK_E_SYNTAX);

    LPSTR pszStart = *ppszThisToken;
    if (*pszStart != '\"')
        return hres;

    pszStart++;
    LPSTR pszEndQuote = strchrf(pszStart, '\"');
    if (pszEndQuote == NULL)
        return hres;

    *pszEndQuote = '\0';
    if (ppszQuotedToken != NULL)
        *ppszQuotedToken = pszStart;
    *ppszThisToken = pszEndQuote+1;

    return NOERROR;
}


BOOL IsEqualToken(LPCSTR pszTokenStart, LPCSTR pszTokenEnd, LPCSTR pszTokenToMatch)
{
    UINT cbToken = strlenf(pszTokenToMatch);

    if (cbToken != (UINT)(pszTokenEnd - pszTokenStart) || strnicmpf(pszTokenStart, pszTokenToMatch, cbToken))
        return FALSE;

    return TRUE;
}


/* ParseLiteralToken(ppsz, pszToken) tries to match *ppsz against pszToken.
 * If they don't match, an error is returned.  If they do match, then *ppsz
 * is advanced past the token and any following whitespace.
 *
 * If ppszInvalid is NULL, then the function is non-destructive in the error
 * path, so it's OK to call ParseLiteralToken just to see if a possible literal
 * token is what's next; if the token isn't found, whatever was there didn't
 * get eaten or anything.
 *
 * If ppszInvalid is not NULL, then if the token doesn't match, *ppszInvalid
 * will be set to *ppsz.
 */
HRESULT ParseLiteralToken(LPSTR *ppsz, LPCSTR pszToken, LPCSTR *ppszInvalid)
{
    LPSTR pszTokenEnd = FindTokenEnd(*ppsz);

    if (!IsEqualToken(*ppsz, pszTokenEnd, pszToken)) {
        if (ppszInvalid != NULL)
            *ppszInvalid = *ppsz;
        return ResultFromScode(MK_E_SYNTAX);
    }

    *ppsz = pszTokenEnd;

    SkipWhitespace(ppsz);

    return NOERROR;
}


/* ParseNumber parses a numeric token at the specified position.  If the
 * number makes sense, the pointer is advanced to the end of the number
 * and past any following whitespace, and the numeric value is returned
 * in *pnOut.  Any non-numeric characters are considered to terminate the
 * number without error;  it is assumed that higher-level parsing code
 * will eventually reject such characters if they're not supposed to be
 * there.
 *
 * pnOut may be NULL if the caller doesn't care about the number being
 * returned and just wants to eat it.
 *
 * Floating point numbers of the form nnn.nnn are rounded to the next
 * higher integer and returned as such.
 */
HRESULT ParseNumber(LPSTR *ppszNumber, INT *pnOut)
{
    HRESULT hres = ResultFromScode(MK_E_SYNTAX);
    BOOL fNegative = FALSE;
    INT nAccum = 0;
    BOOL fNonZeroDecimal = FALSE;
    BOOL fInDecimal = FALSE;
    BOOL fFoundDigits = FALSE;

    LPSTR pszCurrent = *ppszNumber;

    /* Handle one sign character. */
    if (*pszCurrent == '+') {
        pszCurrent++;
    }
    else if (*pszCurrent == '-') {
        pszCurrent++;
        fNegative = TRUE;
    }

    for (;;) {
        if (*pszCurrent == '.') {
            fInDecimal = TRUE;
        }
        else if (*pszCurrent >= '0' && *pszCurrent <= '9') {
            fFoundDigits = TRUE;
            if (fInDecimal) {
                if (*pszCurrent > '0') {
                    fNonZeroDecimal = TRUE;
                }
            }
            else {
                nAccum = nAccum * 10 + (*pszCurrent - '0');
            }
        }
        else
            break;

        pszCurrent++;
    }

    if (fFoundDigits) {
        hres = NOERROR;
        if (fNonZeroDecimal)
            nAccum++;           /* round away from zero if decimal present */
        if (fNegative)
            nAccum = -nAccum;
    }

    if (SUCCEEDED(hres)) {
        if (pnOut != NULL)
            *pnOut = nAccum;
        *ppszNumber = pszCurrent;
        SkipWhitespace(ppszNumber);
    }

    return hres;
}

HRESULT ParsePseudoFloat(LPSTR *ppszNumber, INT *pnOut)
{
    HRESULT hres = ResultFromScode(MK_E_SYNTAX);
    INT val1, val2;
    BOOL fInDecimal = FALSE;
    CHAR achBuffer[ 256 ];      // ugly

    LPSTR pszCurrent = *ppszNumber;

    *achBuffer = '\0';

    /* Handle one sign character. */
    if (*pszCurrent == '+') {
        pszCurrent++;
    }
    else if (*pszCurrent == '-') {
        strcatf( achBuffer, "-" );
        pszCurrent++;
    }

    for (;;) {
        if (*pszCurrent == '.') {
            if ( fInDecimal ) break;
            fInDecimal = TRUE;
            strcatf( achBuffer, "." );
        }
        else if (*pszCurrent >= '0' && *pszCurrent <= '9') {
            CHAR achFoo[ 2 ] = { '\0', '\0' };
            achFoo[ 0 ] = *pszCurrent;
            strcatf( achBuffer, achFoo );
        }
        else
            break;

        pszCurrent++;
    }

    if ( !fInDecimal )
    {
        strcatf( achBuffer, ".0" );
    }

    if ( sscanf( achBuffer, "%d.%d", &val1, &val2 ) == 2 )
    {
        hres = NOERROR;
    }

    if (SUCCEEDED(hres)) {
        if (pnOut != NULL)
            *pnOut = ( ( val1 << 16 ) & 0xFFFF0000 ) | ( val2 & 0x0000FFFF );
        *ppszNumber = pszCurrent;
        SkipWhitespace(ppszNumber);
    }

    return hres;
}

const char szPicsVersionLabel[] = "PICS-";
const UINT cchLabel = (sizeof(szPicsVersionLabel)-1) / sizeof(szPicsVersionLabel[0]);

/* Returns a pointer to the closing doublequote of a quoted string, counting
 * linefeeds as we go.  Returns NULL if no closing doublequote found.
 */
LPSTR RatFileParser::EatQuotedString(LPSTR pIn)
{
    LPSTR pszQuote = strchrf(pIn, '\"');
    if (pszQuote == NULL)
        return NULL;

    pIn = strchrf(pIn, '\n');
    while (pIn != NULL && pIn < pszQuote) {
        m_nLine++;
        pIn = strchrf(pIn+1, '\n');
    }

    return pszQuote;
}

/***************************************************************************
    Member functions for ET* classes
***************************************************************************/

/* ETN */
#ifdef DEBUG
void  ETN::Set(int rIn){
    Init();
    r = rIn;
}
int ETN::Get(){
    assert(fIsInit());
    return r;
}
#endif

ETN* ETN::Duplicate(){
    ETN *pETN=new ETN;
    if (fIsInit()) pETN->Set(Get());
    return pETN;
}

/* ETB */
#ifdef DEBUG
BOOL ETB::Get()
{
    assert(fIsInit());
    return m_nFlags & ETB_VALUE;
}

void ETB::Set(BOOL b)
{
    m_nFlags = ETB_ISINIT | (b ? ETB_VALUE : 0);
}
#endif

ETB* ETB::Duplicate()
{
    assert(fIsInit());

    ETB *pETB = new ETB;
    if (pETB != NULL)
        pETB->m_nFlags = m_nFlags;
    return pETB;
}

/* ETS */

ETS::~ETS()
{
    if (pc != NULL) {
        delete pc;
        pc = NULL;
    }
}

#ifdef DEBUG
char* ETS::Get()
{
    assert(fIsInit());
    return pc;
}
#endif

void ETS::Set(const char *pIn)
{
    if (pc != NULL)
        delete pc;

    if (pIn != NULL) {
        pc = new char[strlenf(pIn) + 1];
        if (pc != NULL) {
            strcpyf(pc, pIn);
        }
    }
    else {
        pc = NULL;
    }
}


void ETS::SetTo(char *pIn)
{
    if (pc != NULL)
        delete pc;

    pc = pIn;
}


ETS* ETS::Duplicate()
{
    ETS *pETS=new ETS;
    if (pETS != NULL)
        pETS->Set(Get());
    return pETS;
}

/***************************************************************************
    Worker functions for inheriting category properties and other
    miscellaneous category stuff.
***************************************************************************/

HRESULT PicsCategory::InitializeMyDefaults(PicsCategory *pCategory)
    {
    if (!pCategory->etnMin.fIsInit()      && etnMin.fIsInit())
        pCategory->etnMin.Set(etnMin.Get());

    if (!pCategory->etnMax.fIsInit()      && etnMax.fIsInit())
        pCategory->etnMax.Set(etnMax.Get());

    if (!pCategory->etfMulti.fIsInit()    && etfMulti.fIsInit())
        pCategory->etfMulti.Set(etfMulti.Get());

    if (!pCategory->etfInteger.fIsInit()  && etfInteger.fIsInit())
        pCategory->etfInteger.Set(etfInteger.Get());

    if (!pCategory->etfLabelled.fIsInit() && etfLabelled.fIsInit())
        pCategory->etfLabelled.Set(etfLabelled.Get());

    if (!pCategory->etfUnordered.fIsInit() && etfUnordered.fIsInit())
        pCategory->etfUnordered.Set(etfUnordered.Get());

    return NOERROR;
    }


HRESULT PicsRatingSystem::InitializeMyDefaults(PicsCategory *pCategory)
{
    if (m_pDefaultOptions != NULL)
        return m_pDefaultOptions->InitializeMyDefaults(pCategory);

    return NOERROR;             /* no defaults to initialize */
}


HRESULT PicsDefault::InitializeMyDefaults(PicsCategory *pCategory)
{
    if (!pCategory->etnMin.fIsInit()      && etnMin.fIsInit())
        pCategory->etnMin.Set(etnMin.Get());

    if (!pCategory->etnMax.fIsInit()      && etnMax.fIsInit())
        pCategory->etnMax.Set(etnMax.Get());

    if (!pCategory->etfMulti.fIsInit()    && etfMulti.fIsInit())
        pCategory->etfMulti.Set(etfMulti.Get());

    if (!pCategory->etfInteger.fIsInit()  && etfInteger.fIsInit())
        pCategory->etfInteger.Set(etfInteger.Get());

    if (!pCategory->etfLabelled.fIsInit() && etfLabelled.fIsInit())
        pCategory->etfLabelled.Set(etfLabelled.Get());

    if (!pCategory->etfUnordered.fIsInit() && etfUnordered.fIsInit())
        pCategory->etfUnordered.Set(etfUnordered.Get());

    return NOERROR;
}


HRESULT PicsEnum::InitializeMyDefaults(PicsCategory *pCategory)
{
    return E_NOTIMPL;       /* should never have a category inherit from an enum */
}


PicsExtension::PicsExtension()
    : m_pszRatingBureau(NULL)
{
    /* nothing else */
}


PicsExtension::~PicsExtension()
{
    delete m_pszRatingBureau;
}


HRESULT PicsExtension::InitializeMyDefaults(PicsCategory *pCategory)
{
    return E_NOTIMPL;       /* should never have a category inherit from an extension */
}


void PicsCategory::FixupLimits()
{
    BOOL fLabelled = (etfLabelled.fIsInit() && etfLabelled.Get());

    /*fix up max and min values*/
    if (fLabelled ||
        (arrpPE.Length()>0 && (!etnMax.fIsInit() || !etnMax.fIsInit())))
    {
        if (arrpPE.Length() > 0)
        {
            if (!etnMax.fIsInit())
                etnMax.Set(N_INFINITY);
            if (!etnMin.fIsInit())
                etnMin.Set(P_INFINITY);
            for (int z=0;z<arrpPE.Length();++z)
            {
                if (arrpPE[z]->etnValue.Get() > etnMax.Get()) etnMax.Set(arrpPE[z]->etnValue.Get());
                if (arrpPE[z]->etnValue.Get() < etnMin.Get()) etnMin.Set(arrpPE[z]->etnValue.Get());
            }
        }
        else {
            etfLabelled.Set(FALSE); /* no enum labels?  better not have labelled flag then */
            fLabelled = FALSE;
        }
    }

    /*sort labels by value*/
    if (fLabelled)
    {
        int x,y;
        PicsEnum *pPE;
        for (x=0;x<arrpPE.Length()-1;++x){
            for (y=x+1;y<arrpPE.Length();++y){
                if (arrpPE[y]->etnValue.Get() < arrpPE[x]->etnValue.Get()){
                    pPE = arrpPE[x];
                    arrpPE[x] = arrpPE[y];
                    arrpPE[y] = pPE;
                }
            }
        }
    }
}


void PicsCategory::SetParents(PicsRatingSystem *pOwner)
{
    pPRS = pOwner;
    UINT cSubCategories = arrpPC.Length();
    for (UINT i = 0; i < cSubCategories; i++) {
        InitializeMyDefaults(arrpPC[i]);    /* subcategory inherits our defaults */
        arrpPC[i]->SetParents(pOwner);      /* process all subcategories */
    }
    FixupLimits();      /* inheritance is done, make sure limits make sense */
}


/***************************************************************************
    Handler functions which know how to parse the various kinds of content
    which can occur within a parenthesized object.
***************************************************************************/

HRESULT RatParseString(LPSTR *ppszIn, LPVOID *ppOut, RatFileParser *pParser)
{
    *ppOut = NULL;

    LPSTR pszCurrent = *ppszIn;

    if (*pszCurrent != '\"')
        return RAT_E_EXPECTEDSTRING;

    pszCurrent++;

    LPSTR pszEnd = pParser->EatQuotedString(pszCurrent);
    if (pszEnd == NULL)
        return RAT_E_EXPECTEDSTRING;

    UINT cbString = DIFF(pszEnd - pszCurrent);
    LPSTR pszNew = new char[cbString + 1];
    if (pszNew == NULL)
        return E_OUTOFMEMORY;

    memcpyf(pszNew, pszCurrent, cbString);
    pszNew[cbString] = '\0';

    *ppOut = (LPVOID)pszNew;
    *ppszIn = pParser->FindNonWhite(pszEnd + 1);

    return NOERROR;
}


HRESULT RatParseNumber(LPSTR *ppszIn, LPVOID *ppOut, RatFileParser *pParser)
{
    int n;

    LPSTR pszCurrent = *ppszIn;
    HRESULT hres = ::ParseNumber(&pszCurrent, &n);

    if (FAILED(hres))
        return RAT_E_EXPECTEDNUMBER;

    *(int *)ppOut = n;

    LPSTR pszNewline = strchrf(*ppszIn, '\n');
    while (pszNewline != NULL && pszNewline < pszCurrent) {
        pParser->m_nLine++;
        pszNewline = strchrf(pszNewline+1, '\n');
    }
    *ppszIn = pszCurrent;

    return NOERROR;
}

HRESULT RatParsePseudoFloat(LPSTR *ppszIn, LPVOID *ppOut, RatFileParser *pParser)
{
    INT n;

    LPSTR pszCurrent = *ppszIn;
    HRESULT hres = ::ParsePseudoFloat(&pszCurrent, &n);

    if (FAILED(hres))
        return RAT_E_EXPECTEDNUMBER;

    *(INT *)ppOut = n;

    LPSTR pszNewline = strchrf(*ppszIn, '\n');
    while (pszNewline != NULL && pszNewline < pszCurrent) {
        pParser->m_nLine++;
        pszNewline = strchrf(pszNewline+1, '\n');
    }
    *ppszIn = pszCurrent;

    return NOERROR;
}

HRESULT RatParseBool(LPSTR *ppszIn, LPVOID *ppOut, RatFileParser *pParser)
{
    BOOL b;

    /* PICS spec allows a terse way of specifying a TRUE boolean -- leaving
     * out the value entirely.  In a .RAT file, the result looks like
     *
     * (unordered)
     * (multivalue)
     *
     * and so on.  Called has pointed us at non-whitespace, so if we see
     * a closing paren, we know the .RAT file author used this syntax.
     */
    if (**ppszIn == ')') {
        b = TRUE;
    }
    else {
        LPSTR pszCurrent = *ppszIn;
        HRESULT hres = ::GetBool(&pszCurrent, &b);

        if (FAILED(hres))
            return RAT_E_EXPECTEDBOOL;

        LPSTR pszNewline = strchrf(*ppszIn, '\n');
        while (pszNewline != NULL && pszNewline < pszCurrent) {
            pParser->m_nLine++;
            pszNewline = strchrf(pszNewline+1, '\n');
        }
        *ppszIn = pszCurrent;
    }

    *(LPBOOL)ppOut = b;

    return NOERROR;
}


AllowableOption aaoPicsCategory[] = {
    { ROID_TRANSMITAS, AO_SINGLE | AO_MANDATORY },
    { ROID_NAME, AO_SINGLE },
    { ROID_DESCRIPTION, AO_SINGLE },
    { ROID_ICON, AO_SINGLE },
    { ROID_EXTENSION, 0 },
    { ROID_INTEGER, AO_SINGLE },
    { ROID_LABELONLY, AO_SINGLE },
    { ROID_MIN, AO_SINGLE },
    { ROID_MAX, AO_SINGLE },
    { ROID_MULTIVALUE, AO_SINGLE },
    { ROID_UNORDERED, AO_SINGLE },
    { ROID_LABEL, 0 },
    { ROID_CATEGORY, 0 },
    { ROID_INVALID, 0 }
};
const UINT caoPicsCategory = sizeof(aaoPicsCategory) / sizeof(aaoPicsCategory[0]);

HRESULT RatParseCategory(LPSTR *ppszIn, LPVOID *ppOut, RatFileParser *pParser)
{
    /* We must make a copy of the allowable options array because the
     * parser will fiddle with the flags in the entries -- specifically,
     * setting AO_SEEN.  It wouldn't be thread-safe to do this to a
     * static array.
     */
    AllowableOption aao[caoPicsCategory];

    ::memcpyf(aao, ::aaoPicsCategory, sizeof(aao));

    PicsCategory *pCategory = new PicsCategory;
    if (pCategory == NULL)
        return E_OUTOFMEMORY;

    HRESULT hres = pParser->ParseParenthesizedObject(
                        ppszIn,                 /* var containing current ptr */
                        aao,                    /* what's legal in this object */
                        pCategory);             /* object to add items back to */

    if (FAILED(hres)) {
        delete pCategory;
        return hres;
    }

    *ppOut = (LPVOID)pCategory;
    return NOERROR;
}


AllowableOption aaoPicsEnum[] = {
    { ROID_NAME, AO_SINGLE },
    { ROID_DESCRIPTION, AO_SINGLE },
    { ROID_VALUE, AO_SINGLE | AO_MANDATORY },
    { ROID_ICON, AO_SINGLE },
    { ROID_INVALID, 0 }
};
const UINT caoPicsEnum = sizeof(aaoPicsEnum) / sizeof(aaoPicsEnum[0]);

HRESULT RatParseLabel(LPSTR *ppszIn, LPVOID *ppOut, RatFileParser *pParser)
{
    /* We must make a copy of the allowable options array because the
     * parser will fiddle with the flags in the entries -- specifically,
     * setting AO_SEEN.  It wouldn't be thread-safe to do this to a
     * static array.
     */
    AllowableOption aao[caoPicsEnum];

    ::memcpyf(aao, ::aaoPicsEnum, sizeof(aao));

    PicsEnum *pEnum = new PicsEnum;
    if (pEnum == NULL)
        return E_OUTOFMEMORY;

    HRESULT hres = pParser->ParseParenthesizedObject(
                        ppszIn,                 /* var containing current ptr */
                        aao,                    /* what's legal in this object */
                        pEnum);                 /* object to add items back to */

    if (FAILED(hres)) {
        delete pEnum;
        return hres;
    }

    *ppOut = (LPVOID)pEnum;
    return NOERROR;
}


AllowableOption aaoPicsDefault[] = {
    { ROID_EXTENSION, 0 },
    { ROID_INTEGER, AO_SINGLE },
    { ROID_LABELONLY, AO_SINGLE },
    { ROID_MAX, AO_SINGLE },
    { ROID_MIN, AO_SINGLE },
    { ROID_MULTIVALUE, AO_SINGLE },
    { ROID_UNORDERED, AO_SINGLE },
    { ROID_INVALID, 0 }
};
const UINT caoPicsDefault = sizeof(aaoPicsDefault) / sizeof(aaoPicsDefault[0]);

HRESULT RatParseDefault(LPSTR *ppszIn, LPVOID *ppOut, RatFileParser *pParser)
{
    /* We must make a copy of the allowable options array because the
     * parser will fiddle with the flags in the entries -- specifically,
     * setting AO_SEEN.  It wouldn't be thread-safe to do this to a
     * static array.
     */
    AllowableOption aao[caoPicsDefault];

    ::memcpyf(aao, ::aaoPicsDefault, sizeof(aao));

    PicsDefault *pDefault = new PicsDefault;
    if (pDefault == NULL)
        return E_OUTOFMEMORY;

    HRESULT hres = pParser->ParseParenthesizedObject(
                        ppszIn,                 /* var containing current ptr */
                        aao,                    /* what's legal in this object */
                        pDefault);              /* object to add items back to */

    if (FAILED(hres)) {
        delete pDefault;
        return hres;
    }

    *ppOut = (LPVOID)pDefault;
    return NOERROR;
}


AllowableOption aaoPicsExtension[] = {
    { ROID_MANDATORY, AO_SINGLE },
    { ROID_OPTIONAL, AO_SINGLE },
    { ROID_INVALID, 0 }
};
const UINT caoPicsExtension = sizeof(aaoPicsExtension) / sizeof(aaoPicsExtension[0]);

HRESULT RatParseExtension(LPSTR *ppszIn, LPVOID *ppOut, RatFileParser *pParser)
{
    /* We must make a copy of the allowable options array because the
     * parser will fiddle with the flags in the entries -- specifically,
     * setting AO_SEEN.  It wouldn't be thread-safe to do this to a
     * static array.
     */
    AllowableOption aao[caoPicsExtension];

    ::memcpyf(aao, ::aaoPicsExtension, sizeof(aao));

    PicsExtension *pExtension = new PicsExtension;
    if (pExtension == NULL)
        return E_OUTOFMEMORY;

    HRESULT hres = pParser->ParseParenthesizedObject(
                        ppszIn,                 /* var containing current ptr */
                        aao,                    /* what's legal in this object */
                        pExtension);            /* object to add items back to */

    if (FAILED(hres)) {
        delete pExtension;
        return hres;
    }

    *ppOut = (LPVOID)pExtension;
    return NOERROR;
}


/* Since the only extension we support right now is the one for a label
 * bureau, we just return the first quoted string we find if the caller
 * wants it.  If ppOut is NULL, then it's some other extension and the
 * caller doesn't care about the data, he just wants it eaten.
 */
HRESULT ParseRatExtensionData(LPSTR *ppszIn, RatFileParser *pParser, LPSTR *ppOut)
{
    HRESULT hres = NOERROR;

    LPSTR pszCurrent = *ppszIn;

    /* Must look for closing ')' ourselves to terminate */
    while (*pszCurrent != ')') {
        if (*pszCurrent == '(') {
            pszCurrent = pParser->FindNonWhite(pszCurrent+1);       /* skip paren and whitespace */
            hres = ParseRatExtensionData(&pszCurrent, pParser, ppOut);  /* parentheses contain data */
            if (FAILED(hres))
                return hres;
            if (*pszCurrent != ')')
                return RAT_E_EXPECTEDRIGHT;

            pszCurrent = pParser->FindNonWhite(pszCurrent+1);   /* skip close ) and whitespace */
        }
        else if (*pszCurrent == '\"') {             /* should be just a quoted string */
            if (ppOut != NULL && *ppOut == NULL) {
                hres = RatParseString(&pszCurrent, (LPVOID *)ppOut, pParser);
            }
            else {
                ++pszCurrent;
                LPSTR pszEndQuote = pParser->EatQuotedString(pszCurrent);
                if (pszEndQuote == NULL)
                    return RAT_E_EXPECTEDSTRING;
                pszCurrent = pParser->FindNonWhite(pszEndQuote+1);  /* skip close " and whitespace */
            }
        }
        else
            return RAT_E_UNKNOWNITEM;               /* general bad syntax */
    }

    /* Caller will skip over final ')' for us. */

    *ppszIn = pszCurrent;

    return NOERROR;
}


HRESULT RatParseMandatory(LPSTR *ppszIn, LPVOID *ppOut, RatFileParser *pParser)
{
    LPSTR pszCurrent = *ppszIn;

    /* First thing better be a quoted URL identifying the extension. */
    if (*pszCurrent != '\"')
        return RAT_E_EXPECTEDSTRING;

    pszCurrent++;
    LPSTR pszEnd = pParser->EatQuotedString(pszCurrent);
    if (pszCurrent == NULL)
        return RAT_E_EXPECTEDSTRING;            /* missing closing " */

    /* See if it's the extension for a label bureau. */

    LPSTR pszBureau = NULL;
    LPSTR *ppData = NULL;
    if (IsEqualToken(pszCurrent, pszEnd, ::szRatingBureauExtension)) {
        ppData = &pszBureau;
    }

    pszCurrent = pParser->FindNonWhite(pszEnd+1);       /* skip closing " and whitespace */

    HRESULT hres = ParseRatExtensionData(&pszCurrent, pParser, ppData);
    if (FAILED(hres))
        return hres;

    *ppOut = pszBureau;     /* return label bureau string if that's what we found */
    *ppszIn = pszCurrent;

    if (ppData == NULL)
        return RAT_E_UNKNOWNMANDATORY;      /* we didn't recognize it */
    else
        return NOERROR;
}


/* RatParseOptional uses the code in RatParseMandatory to parse the extension
 * data, in case an extension that should be optional comes in as mandatory.
 * We then detect RatParseMandatory rejecting the thing as unrecognized and
 * allow it through, since here it's optional.
 */
HRESULT RatParseOptional(LPSTR *ppszIn, LPVOID *ppOut, RatFileParser *pParser)
{
    HRESULT hres = RatParseMandatory(ppszIn, ppOut, pParser);
    if (hres == RAT_E_UNKNOWNMANDATORY)
        hres = S_OK;

    return hres;
}


/***************************************************************************
    Code to identify the opening keyword of a parenthesized object and
    associate it with content.
***************************************************************************/

/* The following array is indexed by RatObjectID values. */
struct {
    LPCSTR pszToken;            /* token by which we identify it */
    RatObjectHandler pHandler;  /* function which parses the object's contents */
} aObjectDescriptions[] = {
    { szNULL, NULL },
    { NULL, NULL },             /* placeholder for comparing against no token */
    { szPicsVersion, RatParsePseudoFloat },
    { szRatingSystem, RatParseString },
    { szRatingService, RatParseString },
    { szRatingBureau, RatParseString },
    { szBureauRequired, RatParseBool },
    { szCategory, RatParseCategory },
    { szTransmitAs, RatParseString },
    { szLabel, RatParseLabel },
    { szValue, RatParseNumber },
    { szDefault, RatParseDefault },
    { szDescription, RatParseString },
    { szExtensionOption, RatParseExtension },
    { szMandatory, RatParseMandatory },
    { szOptional, RatParseOptional },
    { szIcon, RatParseString },
    { szInteger, RatParseBool },
    { szLabelOnly, RatParseBool },
    { szMax, RatParseNumber },
    { szMin, RatParseNumber },
    { szMultiValue, RatParseBool },
    { szName, RatParseString },
    { szUnordered, RatParseBool }
};


/* ParseToOpening eats the opening '(' of a parenthesized object, and
 * verifies that the token just inside it is one of the expected ones.
 * If so, *ppIn is advanced past that token to the next non-whitespace
 * character;  otherwise, an error is returned.
 *
 * For example, if *ppIn is pointing at "(PICS-version 1.1)", and
 * ROID_PICSVERSION is in the allowable option table supplied, then
 * NOERROR is returned and *ppIn will point at "1.1)".
 *
 * If the function is successful, *ppFound is set to point to the element
 * in the allowable-options table which matches the type of thing this
 * object actually is.
 */
HRESULT RatFileParser::ParseToOpening(LPSTR *ppIn, AllowableOption *paoExpected,
                                      AllowableOption **ppFound)
{
    LPSTR pszCurrent = *ppIn;

    pszCurrent = FindNonWhite(pszCurrent);
    if (*pszCurrent != '(')
        return RAT_E_EXPECTEDLEFT;

    pszCurrent = FindNonWhite(pszCurrent+1);    /* skip '(' and whitespace */
    LPSTR pszTokenEnd = FindTokenEnd(pszCurrent);

    for (; paoExpected->roid != ROID_INVALID; paoExpected++) {
        LPCSTR pszThisToken = aObjectDescriptions[paoExpected->roid].pszToken;

        /* Special case for beginning of RAT file structure: no token at all. */
        if (pszThisToken == NULL) {
            if (*pszCurrent == '(') {
                *ppIn = pszCurrent;
                *ppFound = paoExpected;
                return NOERROR;
            }
            else {
                return RAT_E_EXPECTEDLEFT;
            }
        }
        else if (IsEqualToken(pszCurrent, pszTokenEnd, pszThisToken))
            break;

    }

    if (paoExpected->roid != ROID_INVALID) {
        *ppIn = FindNonWhite(pszTokenEnd);  /* skip token and whitespace */
        *ppFound = paoExpected;
        return NOERROR;
    }
    else
        return RAT_E_UNKNOWNITEM;
}


/***************************************************************************
    The top-level entrypoint for parsing out a whole rating system.
***************************************************************************/

AllowableOption aaoPicsRatingSystem[] = {
    { ROID_PICSVERSION, AO_SINGLE | AO_MANDATORY },
    { ROID_RATINGSYSTEM, AO_SINGLE | AO_MANDATORY },
    { ROID_RATINGSERVICE, AO_SINGLE | AO_MANDATORY },
    { ROID_RATINGBUREAU, AO_SINGLE },
    { ROID_BUREAUREQUIRED, AO_SINGLE },
    { ROID_DEFAULT, 0 },
    { ROID_DESCRIPTION, AO_SINGLE },
    { ROID_EXTENSION, 0 },
    { ROID_ICON, AO_SINGLE },
    { ROID_NAME, AO_SINGLE },
    { ROID_CATEGORY, AO_MANDATORY },
    { ROID_INVALID, 0 }
};
const UINT caoPicsRatingSystem = sizeof(aaoPicsRatingSystem) / sizeof(aaoPicsRatingSystem[0]);

HRESULT PicsRatingSystem::Parse(LPSTR pIn)
{
    /* This guy is small enough to just init directly on the stack */
    AllowableOption aaoRoot[] = { { ROID_PICSDOCUMENT, 0 }, { ROID_INVALID, 0 } };
    AllowableOption aao[caoPicsRatingSystem];

    ::memcpyf(aao, ::aaoPicsRatingSystem, sizeof(aao));

    AllowableOption *pFound;

    RatFileParser parser;

    HRESULT hres = parser.ParseToOpening(&pIn, aaoRoot, &pFound);
    if (FAILED(hres))
        return hres;                        /* some error early on */

    hres = parser.ParseParenthesizedObject(
                        &pIn,                   /* var containing current ptr */
                        aao,                    /* what's legal in this object */
                        this);                  /* object to add items back to */

    if (FAILED(hres))
        nErrLine = parser.m_nLine;

    return hres;
}


/***************************************************************************
    Callbacks into the various class objects to add parsed properties.
***************************************************************************/

HRESULT PicsRatingSystem::AddItem(RatObjectID roid, LPVOID pData)
{
    HRESULT hres = S_OK;

    switch (roid) {
    case ROID_PICSVERSION:
        etnPicsVersion.Set((INT_PTR)pData);
        break;

    case ROID_RATINGSYSTEM:
        etstrRatingSystem.SetTo((LPSTR)pData);
        break;

    case ROID_RATINGSERVICE:
        etstrRatingService.SetTo((LPSTR)pData);
        break;

    case ROID_RATINGBUREAU:
        etstrRatingBureau.SetTo((LPSTR)pData);
        break;

    case ROID_BUREAUREQUIRED:
        etbBureauRequired.Set((INT_PTR)pData);
        break;

    case ROID_DEFAULT:
        m_pDefaultOptions = (PicsDefault *)pData;
        break;

    case ROID_DESCRIPTION:
        etstrDesc.SetTo((LPSTR)pData);
        break;

    case ROID_EXTENSION:
        {
            /* just eat extensions for now */
            PicsExtension *pExtension = (PicsExtension *)pData;
            if (pExtension != NULL) {
                /* If this is a rating bureau extension, take his bureau
                 * string and store it in this PicsRatingSystem.  We now
                 * own the memory, so NULL out the extension's pointer to
                 * it so he won't delete it.
                 */
                if (pExtension->m_pszRatingBureau != NULL) {
                    etstrRatingBureau.SetTo(pExtension->m_pszRatingBureau);
                    pExtension->m_pszRatingBureau = NULL;
                }
                delete pExtension;
            }
        }
        break;

    case ROID_ICON:
        etstrIcon.SetTo((LPSTR)pData);
        break;

    case ROID_NAME:
        etstrName.SetTo((LPSTR)pData);
        break;

    case ROID_CATEGORY:
        {
            PicsCategory *pCategory = (PicsCategory *)pData;
            hres = arrpPC.Append(pCategory) ? S_OK : E_OUTOFMEMORY;
            if (FAILED(hres)) {
                delete pCategory;
            }
            else {
                InitializeMyDefaults(pCategory);    /* category inherits default settings */
                pCategory->SetParents(this);    /* set pPRS fields in whole tree */
            }
        }
        break;

    default:
        assert(FALSE);  /* shouldn't have been given a ROID that wasn't in
                         * the table we passed to the parser! */
        hres = E_UNEXPECTED;
        break;
    }

    return hres;
}

void PicsRatingSystem::Dump( void )
{
    fprintf( stdout,
             "Rating system: %s\n"
             "Version: %d.%d\n"
             "Rating Service: %s\n"
             "Rating bureau: %s\n"
             "Bureau required: %s\n"
             "Description: %s\n"
             "Icon: %s\n"
             "Name: %s\n"
             "Number of categories: %d\n",
             etstrRatingSystem.Get(),
             ( etnPicsVersion.Get() & 0xFFFF0000 ) >> 16,
             etnPicsVersion.Get() & 0x0000FFFF,
             etstrRatingService.Get(),
             etstrRatingBureau.Get(),
             etbBureauRequired.Get() ? "TRUE" : "FALSE",
             etstrDesc.Get(),
             etstrIcon.Get(),
             etstrName.Get(),
             arrpPC.Length() );

    int iCounter = 0;
    for( ; iCounter < arrpPC.Length(); iCounter++ )
    {
        arrpPC[ iCounter ]->Dump();
    }
}

//---------------------------------------------------------------
// boydm
void PicsRatingSystem::OutputLabels( CString &sz, CString szURL, CString szName, CString szStart, CString szEnd )
    {
    CString szScratch;
    CString szTemp;

    INT_PTR   dwVersion = etnPicsVersion.Get();

    // start with the name, and the version number
    szTemp = szPicsOpening;
    szScratch.Format( _T("%s%d.%d"), szTemp, HIWORD(dwVersion), LOWORD(dwVersion) );
    sz += szScratch;

    // add in the URL string - surrounded by quotes and a return
    sz += _T(" \"http://www.rsac.org/ratingsv01.html\" ");

    // start the labels
    sz += szShortLabelWord;
    sz += _T(" ");

    // if it is there, add the by name string
    if ( !szName.IsEmpty() )
        {
        sz += szByOption;
        sz += _T(" \"");
        sz += szName;
        sz += _T("\" ");
        }

    // if it is there, add the start string
    if ( !szStart.IsEmpty() )
        {
        sz += szOnOption;
        sz += _T(" \"");
        sz += szStart;
        sz += _T("\" ");
        }

    // if it is there, add the expiration string
    if ( !szEnd.IsEmpty() )
        {
        sz += szExpOption;
        sz += _T(" \"");
        sz += szEnd;
        sz += _T("\" ");
        }

    // add in the categorical ratings
    DWORD   nCat = arrpPC.Length();
    sz += szShortRatings;
    sz += _T(" (");
    for ( DWORD iCat = 0; iCat < nCat; iCat++ )
        {
        arrpPC[iCat]->OutputLabel( sz );
        }
    // trim any trailing whitespace
    sz.TrimRight();
    // close with a parenthesis
    sz += _T(')');

    // end with the closing parenthesis
    sz += _T(")");
    }



//---------------------------------------------------------------
HRESULT PicsCategory::AddItem(RatObjectID roid, LPVOID pData)
{
    HRESULT hres = S_OK;

    switch (roid) {
    case ROID_TRANSMITAS:
        etstrTransmitAs.SetTo((LPSTR)pData);
        break;

    case ROID_NAME:
        etstrName.SetTo((LPSTR)pData);
        break;

    case ROID_DESCRIPTION:
        etstrDesc.SetTo((LPSTR)pData);
        break;

    case ROID_ICON:
        etstrIcon.SetTo((LPSTR)pData);
        break;

    case ROID_EXTENSION:
        {           /* we support no extensions below the rating system level */
            PicsExtension *pExtension = (PicsExtension *)pData;
            if (pExtension != NULL)
                delete pExtension;
        }
        break;

    case ROID_INTEGER:
        etfInteger.Set((INT_PTR)pData);
        break;

    case ROID_LABELONLY:
        etfLabelled.Set((INT_PTR)pData);
        break;

    case ROID_MULTIVALUE:
        etfMulti.Set((INT_PTR)pData);
        break;

    case ROID_UNORDERED:
        etfUnordered.Set((INT_PTR)pData);
        break;

    case ROID_MIN:
        etnMin.Set((INT_PTR)pData);
        break;

    case ROID_MAX:
        etnMax.Set((INT_PTR)pData);
        break;

    case ROID_LABEL:
        {
            PicsEnum *pEnum = (PicsEnum *)pData;
            hres = arrpPE.Append(pEnum) ? S_OK : E_OUTOFMEMORY;
            if (FAILED(hres))
                delete pEnum;
        }
        break;

    case ROID_CATEGORY:
        {
            PicsCategory *pCategory = (PicsCategory *)pData;

            /* For a nested category, synthesize the transmit-name from
             * ours and the child's (e.g., parent category 'color' plus
             * child category 'hue' becomes 'color/hue'.
             *
             * Note that the memory we allocate for the new name will be
             * owned by pCategory->etstrTransmitAs.  There is no memory
             * leak there.
             */
            UINT cbCombined = strlenf(etstrTransmitAs.Get()) +
                              strlenf(pCategory->etstrTransmitAs.Get()) +
                              2;        /* for PicsDelimChar + null */
            LPSTR pszTemp = new char[cbCombined];
            if (pszTemp == NULL)
                hres = E_OUTOFMEMORY;
            else {
                sprintf(pszTemp, "%s%c%s", etstrTransmitAs.Get(),
                         PicsDelimChar, pCategory->etstrTransmitAs.Get());
                pCategory->etstrTransmitAs.SetTo(pszTemp);
                hres = arrpPC.Append(pCategory) ? S_OK : E_OUTOFMEMORY;
            }

            if (FAILED(hres)) {
                delete pCategory;
            }
        }
        break;

    default:
        assert(FALSE);  /* shouldn't have been given a ROID that wasn't in
                         * the table we passed to the parser! */
        hres = E_UNEXPECTED;
        break;
    }

    return hres;
}

void PicsCategory::Dump( void )
{
    fprintf( stdout,
             "  Transmit As: %s  Name: %s  Description: %s  Icon: %s\n",
             etstrTransmitAs.Get(),
             etstrName.Get(),
             etstrDesc.Get(),
             etstrIcon.Get() );

    int iCounter = 0;
    for( ; iCounter < arrpPE.Length(); iCounter++ )
    {
        arrpPE[ iCounter ]->Dump();
    }
}

//---------------------------------------------------------------
void PicsCategory::OutputLabel( CString &sz )
    {
    CString szCat;
    CString szTransmit = etstrTransmitAs.Get();
    // prepare the category string
    szCat.Format( _T("%s %d "), szTransmit, currentValue );
    sz += szCat;
    }

//---------------------------------------------------------------
BOOL PicsCategory::FSetValuePair( CHAR chCat, WORD value )
    {
    CString szCat = etstrTransmitAs.Get();

    // first check to see if this is the right category
    if ( szCat == chCat )
        {
        // success! set the value and return
        currentValue = value;
        return TRUE;
        }

    // try its categorical children
    DWORD nCat = arrpPC.Length();
    for ( DWORD iCat = 0; iCat < nCat; iCat++ )
        {
        // stop at the first successful setting
        if ( arrpPC[iCat]->FSetValuePair(chCat, value) )
            return TRUE;
        }

    // nope
    return FALSE;
    }

//---------------------------------------------------------------
HRESULT PicsEnum::AddItem(RatObjectID roid, LPVOID pData)
{
    HRESULT hres = S_OK;

    switch (roid) {
    case ROID_NAME:
        etstrName.SetTo((LPSTR)pData);
        break;

    case ROID_DESCRIPTION:
        etstrDesc.SetTo((LPSTR)pData);
        break;

    case ROID_ICON:
        etstrIcon.SetTo((LPSTR)pData);
        break;

    case ROID_VALUE:
        etnValue.Set((INT_PTR)pData);
        break;

    default:
        assert(FALSE);  /* shouldn't have been given a ROID that wasn't in
                         * the table we passed to the parser! */
        hres = E_UNEXPECTED;
        break;
    }

    return hres;
}

void PicsEnum::Dump( void )
{
    fprintf( stdout,
             "    %s %s %s %d\n",
             etstrName.Get(),
             etstrDesc.Get(),
             etstrIcon.Get(),
             etnValue.Get() );
}

HRESULT PicsDefault::AddItem(RatObjectID roid, LPVOID pData)
{
    HRESULT hres = S_OK;

    switch (roid) {
    case ROID_EXTENSION:
        {           /* we support no extensions below the rating system level */
            PicsExtension *pExtension = (PicsExtension *)pData;
            if (pExtension != NULL)
                delete pExtension;
        }
        break;

    case ROID_INTEGER:
        etfInteger.Set((INT_PTR)pData);
        break;

    case ROID_LABELONLY:
        etfLabelled.Set((INT_PTR)pData);
        break;

    case ROID_MULTIVALUE:
        etfMulti.Set((INT_PTR)pData);
        break;

    case ROID_UNORDERED:
        etfUnordered.Set((INT_PTR)pData);
        break;

    case ROID_MIN:
        etnMin.Set((INT_PTR)pData);
        break;

    case ROID_MAX:
        etnMax.Set((INT_PTR)pData);
        break;

    default:
        assert(FALSE);  /* shouldn't have been given a ROID that wasn't in
                         * the table we passed to the parser! */
        hres = E_UNEXPECTED;
        break;
    }

    return hres;
}

void PicsDefault::Dump( void )
{
    fprintf( stdout,
             "  Default?\n" );
}

HRESULT PicsExtension::AddItem(RatObjectID roid, LPVOID pData)
{
    HRESULT hres = S_OK;

    switch (roid) {
    case ROID_OPTIONAL:
    case ROID_MANDATORY:
        /* Only data we should get is a label bureau string. */
        if (pData != NULL)
            m_pszRatingBureau = (LPSTR)pData;
        break;

    default:
        assert(FALSE);  /* shouldn't have been given a ROID that wasn't in
                         * the table we passed to the parser! */
        hres = E_UNEXPECTED;
        break;
    }

    return hres;
}

void PicsExtension::Dump( void )
{
    fprintf( stdout,
             "  Extension?\n" );
}

/***************************************************************************
    The main loop of the parser.
***************************************************************************/

/* ParseParenthesizedObjectContents is called with a text pointer pointing at
 * the first non-whitespace thing following the token identifying the type of
 * object.  It parses the rest of the contents of the object, up to and
 * including the ')' which closes it.  The array of AllowableOption structures
 * specifies which understood options are allowed to occur within this object.
 */
HRESULT RatFileParser::ParseParenthesizedObject(
    LPSTR *ppIn,                    /* where we are in the text stream */
    AllowableOption aao[],          /* allowable things inside this object */
    PicsObjectBase *pObject         /* object to set parameters into */
)
{
    HRESULT hres = S_OK;

    LPSTR pszCurrent = *ppIn;
    AllowableOption *pFound;

    for (pFound = aao; pFound->roid != ROID_INVALID; pFound++) {
        pFound->fdwOptions &= ~AO_SEEN;
    }

    pFound = NULL;

    while (*pszCurrent != ')' && *pszCurrent != '\0' && SUCCEEDED(hres)) {
        hres = ParseToOpening(&pszCurrent, aao, &pFound);
        if (SUCCEEDED(hres)) {
            LPVOID pData;
            hres = (*(aObjectDescriptions[pFound->roid].pHandler))(&pszCurrent, &pData, this);
            if (SUCCEEDED(hres)) {
                if ((pFound->fdwOptions & (AO_SINGLE | AO_SEEN)) == (AO_SINGLE | AO_SEEN))
                    hres = RAT_E_DUPLICATEITEM;
                else {
                    pFound->fdwOptions |= AO_SEEN;
                    hres = pObject->AddItem(pFound->roid, pData);
                    if (SUCCEEDED(hres)) {
                        if (*pszCurrent != ')')
                            hres = RAT_E_EXPECTEDRIGHT;
                        else
                            pszCurrent = FindNonWhite(pszCurrent+1);
                    }
                }
            }
        }
    }

    if (FAILED(hres))
        return hres;

    for (pFound = aao; pFound->roid != ROID_INVALID; pFound++) {
        if ((pFound->fdwOptions & (AO_MANDATORY | AO_SEEN)) == AO_MANDATORY)
            return RAT_E_MISSINGITEM;       /* mandatory item not found */
    }

    *ppIn = pszCurrent;

    return hres;
}


/*
int __cdecl main(int argc, char **argv)
{
    PicsRatingSystem            Rating;
    HANDLE                      hFile;
    HANDLE                      hFileMapping;
    VOID *                      pMem;

    assert( argc > 1 );

    hFile = CreateFile( argv[ 1 ],
                        GENERIC_READ,
                        0,
                        NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL );

    if ( hFile == INVALID_HANDLE_VALUE )
    {
        fprintf( stderr, "Error opening file %s\n", argv[ 1 ] );
        return 1;
    }

    hFileMapping = CreateFileMapping( hFile,
                                      NULL,
                                      PAGE_READONLY,
                                      0,
                                      0,
                                      NULL );

    if ( hFileMapping == NULL )
    {
        fprintf( stderr, "Error creating mapping for %s\n", argv[ 1 ] );
        CloseHandle( hFile );
        return 2;
    }

    pMem = MapViewOfFile( hFileMapping,
                          FILE_MAP_READ,
                          0,
                          0,
                          0 );

    if ( pMem == NULL )
    {
        fprintf( stderr, "Error mapping view to file %s\n", argv [1 ] );
        CloseHandle( hFileMapping );
        CloseHandle( hFile );
        return 3;
    }

    Rating.Parse( argv[ 1 ], (LPSTR) pMem );

    fprintf( stdout,
             "Dumping contents of RAT\n" );

    Rating.Dump();

    UnmapViewOfFile( pMem );
    CloseHandle( hFileMapping );
    CloseHandle( hFile );

    return 0;
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\cnfgprts\ratctl.cpp ===
// RatCtl.cpp : Implementation of the CRatCtrl OLE control class.

#include "stdafx.h"
#include <iadmw.h>
#include "cnfgprts.h"
#include "RatCtl.h"
#include "RatPpg.h"

#include "parserat.h"
#include "RatData.h"
#include "RatGenPg.h"
#include "RatSrvPg.h"

#include "wrapmb.h"
#include <isvctrl.h>
#include <winsock2.h>


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


IMPLEMENT_DYNCREATE(CRatCtrl, COleControl)


/////////////////////////////////////////////////////////////////////////////
// Message map

BEGIN_MESSAGE_MAP(CRatCtrl, COleControl)
    //{{AFX_MSG_MAP(CRatCtrl)
    //}}AFX_MSG_MAP
    ON_MESSAGE(OCM_COMMAND, OnOcmCommand)
    ON_OLEVERB(AFX_IDS_VERB_PROPERTIES, OnProperties)
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// Dispatch map

BEGIN_DISPATCH_MAP(CRatCtrl, COleControl)
    //{{AFX_DISPATCH_MAP(CRatCtrl)
    DISP_FUNCTION(CRatCtrl, "SetAdminTarget", SetAdminTarget, VT_EMPTY, VTS_BSTR VTS_BSTR)
    DISP_STOCKFUNC_DOCLICK()
    DISP_STOCKPROP_BORDERSTYLE()
    DISP_STOCKPROP_ENABLED()
    DISP_STOCKPROP_FONT()
    DISP_STOCKPROP_CAPTION()
    //}}AFX_DISPATCH_MAP
END_DISPATCH_MAP()


/////////////////////////////////////////////////////////////////////////////
// Event map

BEGIN_EVENT_MAP(CRatCtrl, COleControl)
    //{{AFX_EVENT_MAP(CRatCtrl)
    EVENT_STOCK_CLICK()
    EVENT_STOCK_KEYUP()
    //}}AFX_EVENT_MAP
END_EVENT_MAP()


/////////////////////////////////////////////////////////////////////////////
// Property pages

BEGIN_PROPPAGEIDS(CRatCtrl, 2)
    PROPPAGEID(CRatPropPage::guid)
    PROPPAGEID(CLSID_CFontPropPage)
END_PROPPAGEIDS(CRatCtrl)


/////////////////////////////////////////////////////////////////////////////
// Initialize class factory and guid

IMPLEMENT_OLECREATE_EX(CRatCtrl, "CNFGPRTS.RatCtrl.1",
    0xba634607, 0xb771, 0x11d0, 0x92, 0x96, 0, 0xc0, 0x4f, 0xb6, 0x67, 0x8b)


/////////////////////////////////////////////////////////////////////////////
// Type library ID and version

IMPLEMENT_OLETYPELIB(CRatCtrl, _tlid, _wVerMajor, _wVerMinor)


/////////////////////////////////////////////////////////////////////////////
// Interface IDs

const IID BASED_CODE IID_DRat =
        { 0xba634605, 0xb771, 0x11d0, { 0x92, 0x96, 0, 0xc0, 0x4f, 0xb6, 0x67, 0x8b } };
const IID BASED_CODE IID_DRatEvents =
        { 0xba634606, 0xb771, 0x11d0, { 0x92, 0x96, 0, 0xc0, 0x4f, 0xb6, 0x67, 0x8b } };


/////////////////////////////////////////////////////////////////////////////
// Control type information

static const DWORD BASED_CODE _dwRatOleMisc =
    OLEMISC_ACTIVATEWHENVISIBLE |
    OLEMISC_SETCLIENTSITEFIRST |
    OLEMISC_INSIDEOUT |
    OLEMISC_CANTLINKINSIDE |
    OLEMISC_ACTSLIKEBUTTON |
    OLEMISC_RECOMPOSEONRESIZE;

IMPLEMENT_OLECTLTYPE(CRatCtrl, IDS_RAT, _dwRatOleMisc)


/////////////////////////////////////////////////////////////////////////////
// CRatCtrl::CRatCtrlFactory::UpdateRegistry -
// Adds or removes system registry entries for CRatCtrl

BOOL CRatCtrl::CRatCtrlFactory::UpdateRegistry(BOOL bRegister)
{
    // TODO: Verify that your control follows apartment-model threading rules.
    // Refer to MFC TechNote 64 for more information.
    // If your control does not conform to the apartment-model rules, then
    // you must modify the code below, changing the 6th parameter from
    // afxRegApartmentThreading to 0.

    if (bRegister)
        return AfxOleRegisterControlClass(
            AfxGetInstanceHandle(),
            m_clsid,
            m_lpszProgID,
            IDS_RAT,
            IDB_RAT,
            afxRegApartmentThreading,
            _dwRatOleMisc,
            _tlid,
            _wVerMajor,
            _wVerMinor);
    else
        return AfxOleUnregisterClass(m_clsid, m_lpszProgID);
}

/////////////////////////////////////////////////////////////////////////////
// CRatCtrl::CRatCtrl - Constructor

CRatCtrl::CRatCtrl():
    m_fUpdateFont( FALSE ),
    m_hAccel( NULL ),
    m_cAccel( 0 )
    {
    InitializeIIDs(&IID_DRat, &IID_DRatEvents);
    }

/////////////////////////////////////////////////////////////////////////////
// CRatCtrl::~CRatCtrl - Destructor

CRatCtrl::~CRatCtrl()
    {
    if ( m_hAccel )
        DestroyAcceleratorTable( m_hAccel );
    m_hAccel = NULL;
    }

/////////////////////////////////////////////////////////////////////////////
// CRatCtrl::OnDraw - Drawing function

void CRatCtrl::OnDraw(
            CDC* pdc, const CRect& rcBounds, const CRect& rcInvalid)
    {
    DoSuperclassPaint(pdc, rcBounds);
    }

/////////////////////////////////////////////////////////////////////////////
// CRatCtrl::DoPropExchange - Persistence support

void CRatCtrl::DoPropExchange(CPropExchange* pPX)
    {
    ExchangeVersion(pPX, MAKELONG(_wVerMinor, _wVerMajor));
    COleControl::DoPropExchange(pPX);
    }

/////////////////////////////////////////////////////////////////////////////
// CRatCtrl::OnResetState - Reset control to default state

void CRatCtrl::OnResetState()
    {
    COleControl::OnResetState();  // Resets defaults found in DoPropExchange
    }

/////////////////////////////////////////////////////////////////////////////
// CRatCtrl::PreCreateWindow - Modify parameters for CreateWindowEx

BOOL CRatCtrl::PreCreateWindow(CREATESTRUCT& cs)
    {
    if ( cs.style & WS_CLIPSIBLINGS )
        cs.style ^= WS_CLIPSIBLINGS;
    cs.lpszClass = _T("BUTTON");
    return COleControl::PreCreateWindow(cs);
    }


/////////////////////////////////////////////////////////////////////////////
// CRatCtrl::IsSubclassedControl - This is a subclassed control

BOOL CRatCtrl::IsSubclassedControl()
    {
    return TRUE;
    }


/////////////////////////////////////////////////////////////////////////////
// CRatCtrl::OnOcmCommand - Handle command messages

LRESULT CRatCtrl::OnOcmCommand(WPARAM wParam, LPARAM lParam)
{
#ifdef _WIN32
    WORD wNotifyCode = HIWORD(wParam);
#else
    WORD wNotifyCode = HIWORD(lParam);
#endif

    return 0;
}


/////////////////////////////////////////////////////////////////////////////
// CRatCtrl message handlers

//---------------------------------------------------------------------------
void CRatCtrl::OnClick(USHORT iButton)
    {
    WSADATA wsaData;

    // in case there are any errors, prepare the error string
    CString sz;
    // set the name of the application correctly
    sz.LoadString( IDS_RAT_ERR_TITLE );
    // free the existing name, and copy in the new one
    free((void*)AfxGetApp()->m_pszAppName);
    AfxGetApp()->m_pszAppName = _tcsdup(sz);

    // start up WSA services
    if ( WSAStartup(MAKEWORD(1, 1), &wsaData) )
        return;

//DebugBreak();
    CWaitCursor wait;

    // initialize the metabase wrappings - pass in the name of the target machine
    // if one has been specified
    IMSAdminBase* pMB;
    if ( !FInitMetabaseWrapperEx( (LPTSTR)(LPCTSTR)m_szMachine, &pMB ) )
        {
        MessageBeep(0);
        WSACleanup();
        return;
        }

    // if there is no set metabase path - give it a test path
    if ( m_szMetaObject.IsEmpty() )
        m_szMetaObject = _T("/lm/w3svc/1/Root");

    // we have to be able to initialize the ratings data object
    CRatingsData            dataRatings(pMB);
    if ( !dataRatings.FInit(m_szMachine, m_szMetaObject) )
        {
        AfxMessageBox( IDS_RAT_READFILE_ERROR );
        FCloseMetabaseWrapperEx(&pMB);
        WSACleanup();
        return;
        }

    // pointers to the pages (construction may throw, so we need to be careful)
    CRatServicePage         pageService;
    CRatGenPage             pageSetRatings;

    // declare the property sheet
    CPropertySheet  propsheet( IDS_RAT_SHEETTITLE );

    // prepare the pages
    pageService.m_pRatData = &dataRatings;
    pageSetRatings.m_pRatData = &dataRatings;

    // add the pages to the sheet
    propsheet.AddPage( &pageService );
    propsheet.AddPage( &pageSetRatings );

    // turn on help
    propsheet.m_psh.dwFlags |= PSH_HASHELP;
    pageService.m_psp.dwFlags |= PSP_HASHELP;
    pageSetRatings.m_psp.dwFlags |= PSP_HASHELP;


    // Things could (potentially maybe) throw here, so better protect it.
    try
        {
        // run the propdsheet dialog
        // let the host container know that we are putting up a modal dialog
        PreModalDialog();
        // run the dialog
        if ( propsheet.DoModal() == IDOK )
            {
            // generate the label and save it into the metabase
//            dataRatings.SaveTheLable();
            }
        // let the host container know we are done with the modality
        PostModalDialog();
        }
    catch ( CException e )
        {
        }

    // close the metabase wrappings
    FCloseMetabaseWrapperEx(&pMB);
    WSACleanup();

    // don't fire anything off
    COleControl::OnClick(iButton);
    }

//---------------------------------------------------------------------------
void CRatCtrl::OnFontChanged()
    {
    m_fUpdateFont = TRUE;
    COleControl::OnFontChanged();
    }

//---------------------------------------------------------------------------
void CRatCtrl::SetAdminTarget(LPCTSTR szMachineName, LPCTSTR szMetaTarget)
    {
    m_szMachine = szMachineName;
    m_szMetaObject = szMetaTarget;
    }

//---------------------------------------------------------------------------
// an important method where we tell the container how to deal with us.
// pControlInfo is passed in by the container, although we are responsible
// for maintining the hAccel structure
void CRatCtrl::OnGetControlInfo(LPCONTROLINFO pControlInfo)
    {
    // do a rudimentary check to see if we understand pControlInfo
    if ( !pControlInfo || pControlInfo->cb < sizeof(CONTROLINFO) )
        return;

    // set the accelerator handle into place
    pControlInfo->hAccel = m_hAccel;
    pControlInfo->cAccel = m_cAccel;

    // when we have focus, we do want the enter key
    pControlInfo->dwFlags = CTRLINFO_EATS_RETURN;
    }

//---------------------------------------------------------------------------
// when the caption text has changed, we need to rebuild the accelerator handle
void CRatCtrl::OnTextChanged()
    {
    ACCEL   accel;
    int     iAccel;

    // get the new text
    CString sz = InternalGetText();
    sz.MakeLower();

    // if the handle has already been allocated, free it
    if ( m_hAccel )
        {
        DestroyAcceleratorTable( m_hAccel );
        m_hAccel = NULL;
        m_cAccel = 0;
        }

    // if there is a & character, then declare the accelerator
    iAccel = sz.Find(_T('&'));
    if ( iAccel >= 0 )
        {
        // fill in the accererator record
        accel.fVirt = FALT;
        accel.key = sz.GetAt(iAccel + 1);
        accel.cmd = (USHORT)GetDlgCtrlID();

        m_hAccel = CreateAcceleratorTable( &accel, 1 );
        if ( m_hAccel )
            m_cAccel = 1;

        // make sure the new accelerator table gets loaded
        ControlInfoChanged();
        }

    // finish with the default handling.
    COleControl::OnTextChanged();
    }

//---------------------------------------------------------------------------
void CRatCtrl::OnMnemonic(LPMSG pMsg)
    {
    OnClick((USHORT)GetDlgCtrlID());
    COleControl::OnMnemonic(pMsg);
    }

//---------------------------------------------------------------------------
void CRatCtrl::OnAmbientPropertyChange(DISPID dispid)
    {
    BOOL    flag;
    UINT    style;

    // do the right thing depending on the dispid
    switch ( dispid )
        {
        case DISPID_AMBIENT_DISPLAYASDEFAULT:
            if ( GetAmbientProperty( DISPID_AMBIENT_DISPLAYASDEFAULT, VT_BOOL, &flag ) )
                {
                style = GetWindowLong(
                        GetSafeHwnd(), // handle of window
                        GWL_STYLE  // offset of value to retrieve
                        );
                if ( flag )
                    style |= BS_DEFPUSHBUTTON;
                else
                    style ^= BS_DEFPUSHBUTTON;
                SetWindowLong(
                        GetSafeHwnd(), // handle of window
                        GWL_STYLE,  // offset of value to retrieve
                        style
                        );
                Invalidate(TRUE);
                }
            break;
        };

    COleControl::OnAmbientPropertyChange(dispid);
    }

//---------------------------------------------------------------------------
// the ole control container object specifically filters out the space
// key so we do not get it as a OnMnemonic call. Thus we need to look
// for it ourselves
void CRatCtrl::OnKeyUpEvent(USHORT nChar, USHORT nShiftState)
    {
    if ( nChar == _T(' ') )
        {
        OnClick((USHORT)GetDlgCtrlID());
        }
    COleControl::OnKeyUpEvent(nChar, nShiftState);
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\cnfgprts\parserat.h ===
/****************************************************************************\
 *
 *   PARSERAT.H --Structures for holding pics information
 *
 *   Created:   Jason Thomas
 *   Updated:   Ann McCurdy
 *   
\****************************************************************************/

#ifndef _PARSERAT_H_
#define _PARSERAT_H_




// output defines ---------------------------------------
#define OUTPUT_PICS




/*Array template---------------------------------------------------*/

/*Interface-------------------------------------------------------------------*/
template <class T>
class array {
    private:
        int nLen, nMax;
        T   *pData;
        void Destruct();
    public:
        array();
        ~array();

        BOOL Append(T v);
        int  Length() const;
        void ClearAll();
        void DeleteAll();

        T& operator[](int index);
};

/*definitions of everything*/

#ifndef ARRAY_CXX
#define ARRAY_CXX

/*Implementation------------------------------------------------------------*/
template <class T>
array<T>::array(){
    nLen  = nMax = 0;
    pData = NULL;
}

template <class T>
inline array<T>::~array() {
    if (pData) ::MemFree(pData);
    pData = NULL;
    nMax  = nLen = 0;
}

template <class T>
inline int array<T>::Length() const{
    return nLen;
}

template <class T>
inline T& array<T>::operator[](int index){
    assert(index<Length());
    assert(index>=0);
    assert(pData);
    return pData[index];
}

template <class T>
BOOL array<T>::Append(T v) {
    if (nLen == nMax){
        nMax  = nMax + 8;           /* grow by bigger chunks */
        T* pNew = (T*)::MemReAlloc(pData, sizeof(T)*nMax);
        if (pNew == NULL)
            return FALSE;
        pData = pNew;
    }
    assert(pData);
    assert(nMax);
    pData[nLen++] = v;
    return TRUE;
}

template <class T>
void array<T>::Destruct(){
    while (nLen){
        delete pData[--nLen];
    }
}

template <class T>
inline void array<T>::ClearAll() {
    nLen = 0;
}

template <class T>
inline void array<T>::DeleteAll() {
    Destruct();
}

#endif 
/* ARRAY_CXX */


#define P_INFINITY           9999
#define N_INFINITY          -9999

/*Simple PICS types------------------------------------------------*/

#if 0
class ET{
    private:
        BOOL m_fInit;
    public:
        ET();
        void Init();
        void UnInit();
        BOOL fIsInit();
};
#endif

class ETN
{
    private:
        INT_PTR r;
        BOOL m_fInit;
    public:
        ETN() { m_fInit = FALSE; }

        void Init() { m_fInit = TRUE; }
        void UnInit() { m_fInit = FALSE; }
        BOOL fIsInit() { return m_fInit; }

#ifdef DEBUG
        void  Set(INT_PTR rIn);
        INT_PTR Get();
#else
        void  Set(INT_PTR rIn) { Init(); r = rIn; }
        INT_PTR Get() { return r; }
#endif

        ETN*  Duplicate();
};

const UINT ETB_VALUE = 0x01;
const UINT ETB_ISINIT = 0x02;
class ETB
{
    private:
        UINT m_nFlags;
    public:
        ETB() { m_nFlags = 0; }

#ifdef DEBUG
        INT_PTR Get();
        void Set(INT_PTR b);
#else
        INT_PTR Get() { return m_nFlags & ETB_VALUE; }
        void Set(INT_PTR b) { m_nFlags = ETB_ISINIT | (b ? ETB_VALUE : 0); }
#endif

        ETB   *Duplicate();
        BOOL fIsInit() { return m_nFlags & ETB_ISINIT; }
};

class ETS
{
    private:
        char *pc;
    public:
        ETS() { pc = NULL; }
        ~ETS();
#ifdef DEBUG
        char* Get();
#else
        char *Get() { return pc; }
#endif
        void  Set(const char *pIn);
        ETS*  Duplicate();
        void  SetTo(char *pIn);

        BOOL fIsInit() { return pc != NULL; }
};

/*Complex PICS types-----------------------------------------------*/


enum RatObjectID
{
    ROID_INVALID,           /* dummy entry for terminating arrays */
    ROID_PICSDOCUMENT,      /* value representing the entire document (i.e., no token) */
    ROID_PICSVERSION,
    ROID_RATINGSYSTEM,
    ROID_RATINGSERVICE,
    ROID_RATINGBUREAU,
    ROID_BUREAUREQUIRED,
    ROID_CATEGORY,
    ROID_TRANSMITAS,
    ROID_LABEL,
    ROID_VALUE,
    ROID_DEFAULT,
    ROID_DESCRIPTION,
    ROID_EXTENSION,
    ROID_MANDATORY,
    ROID_OPTIONAL,
    ROID_ICON,
    ROID_INTEGER,
    ROID_LABELONLY,
    ROID_MAX,
    ROID_MIN,
    ROID_MULTIVALUE,
    ROID_NAME,
    ROID_UNORDERED
};

/* A RatObjectHandler parses the contents of a parenthesized object and
 * spits out a binary representation of that data, suitable for passing
 * to an object's AddItem function.  It does not consume the ')' which
 * closes the object.
 */
class RatFileParser;
typedef HRESULT (*RatObjectHandler)(LPSTR *ppszIn, LPVOID *ppOut, RatFileParser *pParser);


class PicsCategory;

class PicsObjectBase : public CObject
{
public:
    virtual HRESULT AddItem(RatObjectID roid, LPVOID pData) = 0;
    virtual HRESULT InitializeMyDefaults(PicsCategory *pCategory) = 0;
    virtual void Dump( void ) = 0;
};


const DWORD AO_SINGLE = 0x01;
const DWORD AO_SEEN = 0x02;
const DWORD AO_MANDATORY = 0x04;

struct AllowableOption
{
    RatObjectID roid;
    DWORD fdwOptions;
};


class PicsEnum : public PicsObjectBase
{
    private:
    public:
        ETS etstrName, etstrIcon, etstrDesc;
        ETN etnValue;

        PicsEnum() {}
        ~PicsEnum() {}

        HRESULT AddItem(RatObjectID roid, LPVOID pData);
        HRESULT InitializeMyDefaults(PicsCategory *pCategory);
        void Dump( void );
};

class PicsRatingSystem;

class PicsCategory : public PicsObjectBase
{
    public:
        PicsCategory():currentValue(0) {;}
        ~PicsCategory()
        {
            arrpPC.DeleteAll();
            arrpPE.DeleteAll();
        }

    private:
    public:
        array<PicsCategory*> arrpPC;
        array<PicsEnum*>     arrpPE;
        ETS   etstrTransmitAs, etstrName, etstrIcon, etstrDesc;
        ETN   etnMin,   etnMax;
        ETB   etfMulti, etfInteger, etfLabelled, etfUnordered;
        PicsRatingSystem *pPRS;

        WORD  currentValue;

        void FixupLimits();
        void SetParents(PicsRatingSystem *pOwner);

        HRESULT AddItem(RatObjectID roid, LPVOID pData);
        HRESULT InitializeMyDefaults(PicsCategory *pCategory);

        void Dump( void );

        // boydm
        void OutputLabel( CString &sz );
        BOOL FSetValuePair( CHAR chCat, WORD value );
};


class PicsDefault : public PicsObjectBase
{
public:
    ETB etfInteger, etfLabelled, etfMulti, etfUnordered;
    ETN etnMax, etnMin;

    PicsDefault() {}
    ~PicsDefault() {}

    HRESULT AddItem(RatObjectID roid, LPVOID pData);
    HRESULT InitializeMyDefaults(PicsCategory *pCategory);

    void Dump( void );
};


class PicsExtension : public PicsObjectBase
{
public:
    LPSTR m_pszRatingBureau;

    PicsExtension();
    ~PicsExtension();

    HRESULT AddItem(RatObjectID roid, LPVOID pData);
    HRESULT InitializeMyDefaults(PicsCategory *pCategory);

    void Dump( void );
};


class PicsRatingSystem : public PicsObjectBase
{
    private:
    public:
        array<PicsCategory*> arrpPC;
        ETS                  etstrFile, etstrName, etstrIcon, etstrDesc, 
                             etstrRatingService, etstrRatingSystem, etstrRatingBureau;
        ETN                  etnPicsVersion;
        ETB                  etbBureauRequired;
        PicsDefault *        m_pDefaultOptions;
        DWORD                dwFlags;
        UINT                 nErrLine;

        PicsRatingSystem() :
            m_pDefaultOptions( NULL ),
            dwFlags( 0 ),
            nErrLine( 0 ) {}
        
        ~PicsRatingSystem()
        {
            arrpPC.DeleteAll();
            if (m_pDefaultOptions != NULL)
                delete m_pDefaultOptions;
        }
            
        HRESULT Parse(LPSTR pStreamIn);

        HRESULT AddItem(RatObjectID roid, LPVOID pData);
        HRESULT InitializeMyDefaults(PicsCategory *pCategory);
        VOID Dump();
        void ReportError(HRESULT hres);

        void OutputLabels( CString &sz, CString szURL,CString szName, CString szStart, CString szEnd );
};

void SkipWhitespace(LPSTR *ppsz);
BOOL IsEqualToken(LPCSTR pszTokenStart, LPCSTR pszTokenEnd, LPCSTR pszTokenToMatch);
LPSTR FindTokenEnd(LPSTR pszStart);
HRESULT GetBool(LPSTR *ppszToken, BOOL *pfOut);
HRESULT ParseNumber(LPSTR *ppszNumber, INT *pnOut);

/*Memory utility functions-----------------------------------------------*/

inline void * WINAPI MemAlloc(long cb)
{
    return (void *)::LocalAlloc(LPTR, cb);
}
    
inline void * WINAPI MemReAlloc(void * pb, long cb)
{
    if (pb == NULL)
        return MemAlloc(cb);

    return (void *)::LocalReAlloc((HLOCAL)pb, cb, LMEM_MOVEABLE | LMEM_ZEROINIT);
}

inline BOOL WINAPI MemFree(void * pb)
{
    return (BOOL)HandleToUlong(::LocalFree((HLOCAL)pb));
}

/*String manipulation wrappers---------------------------------------------*/

#ifdef __cplusplus
extern "C" {
#endif

#define memcmpf(d,s,l)  memcmp((d),(s),(l))
#define memcpyf(d,s,l)  memcpy((d),(s),(l))
#define memmovef(d,s,l) MoveMemory((d),(s),(l))
#define memsetf(s,c,l)  memset((s),(c),(l))
#define strcatf(d,s)    strcat((d),(s))
#define strcmpf(s1,s2)  lstrcmp(s1,s2)
#define strcpyf(d,s)    strcpy((d),(s))
#define stricmpf(s1,s2) lstrcmpi(s1,s2)
#define strlenf(s)      strlen((s))
#define strchrf(s,c)    strchr((s),(c))
#define strrchrf(s,c)   strrchr((s),(c))
#define strspnf(s1,s2)  strspn((s1),(s2))
#define strnicmpf(s1,s2,i)  _strnicmp((s1),(s2),(i))
#define strncpyf(s1,s2,i)   strncpy((s1),(s2),(i))
#define strcspnf(s1,s2) strcspn((s1),(s2))
#define strtokf(s1,s2)  strtok((s1),(s2))
#define strstrf(s1,s2)  strstr((s1),(s2))


#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\cnfgprts\ratdata.cpp ===
// a class to maintain the PICS data. It reads and write it to the metabase and
// reads the file and all that. It also serves as a wrapper for the PICS parsing
// objects that have already been written elsewhere
// Created 4/18/97  by  BoydM


#include "stdafx.h"
#include <iadmw.h>
#include "cnfgprts.h"
#include "parserat.h"
#include "RatData.h"

#include <iiscnfg.h>
#include <wrapmb.h>
#include "metatool.h"

#include <isvctrl.h>

#include "mdobjs.h"
#include <winsock2.h>

// Here is the plan. First, we scan the local directory - looking for all
// the .rat files, load them and parse them


//----------------------------------------------------------------
CRatingsData::CRatingsData(IMSAdminBase* pMB):
        iRat(0),
        m_fEnabled( FALSE ),
        m_start_minute(0),
        m_start_hour(0),
        m_start_day(0),
        m_start_month(0),
        m_start_year(0),
        m_expire_minute(0),
        m_expire_hour(0),
        m_expire_day(0),
        m_expire_month(0),
        m_expire_year(0),
        m_pMB( pMB )
    {
    }

//----------------------------------------------------------------
CRatingsData::~CRatingsData()
    {
    // delete the rating systems
    DWORD nRats = (DWORD)rgbRats.GetSize();
    for ( DWORD iRat = 0; iRat < nRats; iRat++ )
        delete rgbRats[iRat];
    }


//----------------------------------------------------------------
BOOL CRatingsData::FCreateURL( CString &sz )
    {
    CHAR nameBuf[MAX_PATH+1];

    // start it off with the mandatory http header
    sz.LoadString( IDS_HTTP_HEADER );
    // get the host name of the machine
    if ( gethostname( nameBuf, sizeof(nameBuf)) )
        return FALSE;
    sz += nameBuf;

    // next, we need to add on the virtual path supplied by the metabase location
    // but that means starting by finding the root portion of the string
    CString szVir = m_szMeta;
    CString szRoot = _T("/Root");
    szVir = szVir.Right( szVir.GetLength() - szVir.Find(szRoot) );
    szVir = szVir.Right( szVir.GetLength() - szRoot.GetLength() );

    // concatenate and done
    sz += szVir;

    return TRUE;
    }


//----------------------------------------------------------------
// generate the label and save it into the metabase
void CRatingsData::SaveTheLable()
    {
    BOOL    fBuiltLabel = FALSE;
    BOOL    f;

    // prepare the metabase wrapper
    CWrapMetaBase   mbWrap;
    f = mbWrap.FInit(m_pMB);
    if ( !f ) return;

    // if the rating is NOT enabled, delete any existing label and return
    if ( !m_fEnabled )
        {
        // attempt to open the object we want to store into
        if ( mbWrap.Open( m_szMeta, METADATA_PERMISSION_WRITE ) )
            {
            // delete any existing PICS metaobject
//            f = mbWrap.DeleteData( _T(""), MD_HTTP_PICS, IIS_MD_UT_FILE, MULTISZ_METADATA );
            f = mbWrap.DeleteData( _T(""), MD_HTTP_PICS, MULTISZ_METADATA );
            // close the metabase
            mbWrap.Close();
            }
        //leave
        return;
        }
    else
        {
        CString szLabel;

        // first, we add the actual HTTP header to the header
//        szLabel = _T("Protocol: {PICS-1.0 {headers PICS-Label}}\nPICS-Label: ");
        szLabel = _T("PICS-Label: ");

        // create the URL string for this label
        CString szURL;
        FCreateURL( szURL );

        // create the modified string for this label
        CString szMod;
        CreateDateSz( szMod, m_start_day, m_start_month, m_start_year, m_start_hour, m_start_minute );

        // create the exipres string for this label
        CString szExpire;
        CreateDateSz( szExpire, m_expire_day, m_expire_month, m_expire_year, m_expire_hour, m_expire_minute );

        // tell each ratings system object to add its label to the string
        DWORD   nRatingSystems = (DWORD)rgbRats.GetSize();
        for ( DWORD iRat = 0; iRat < nRatingSystems; iRat++ )
            {
            // build the label string
            rgbRats[iRat]->OutputLabels( szLabel, szURL, m_szEmail, szMod, szExpire );
            }


        // the data gets saved as a multisz, so prep it up
        PTCHAR psz = szLabel.GetBuffer( szLabel.GetLength()+4 );

        DWORD   dw = szLabel.GetLength();

        // add the second null
        psz[dw + 1] = 0;
        psz[dw + 2] = 0;

        // save the data
        // save the PICS header string
    //            f = SetMetaData(&mbWrap, szPartial, MD_HTTP_PICS, IIS_MD_UT_FILE,
    //                psz, szLabel.GetLength()+2 );
//        f = SetMetaMultiSz( &mbWrap, m_szMeta, MD_HTTP_PICS, IIS_MD_UT_FILE,
//            psz, dw+2 );

        f = SetMetaMultiSz(m_pMB, m_szServer, m_szMeta, _T(""), MD_HTTP_PICS,
                    IIS_MD_UT_FILE, psz, dw+2, TRUE );


        // release the buffer
        szLabel.ReleaseBuffer();

        // these changes are permanent - so write them out
        if ( f )
            mbWrap.Save();
        }
    }

//----------------------------------------------------------------
BOOL CRatingsData::FInit( CString szServer, CString szMeta )
    {
    CWinApp*    pApp = AfxGetApp();
    CString     sz;
    BOOL        fGotSomething = FALSE;
    BOOL        fFoundAFile = FALSE;

    // store the target metabase location
    m_szServer = szServer;
    m_szMeta = szMeta;

    // build the search string
    CString szSearch;

    // the ratings files are in the system32 directory. First, get that
    // directory from the system. The first call is to get the size of the buffer.
    // add one for the terminating NULL
    DWORD cchSysDir = GetSystemDirectory( NULL, 0 ) + 1;
    // if we didn't get one - fail
    if ( cchSysDir == 1 ) return FALSE;

    // Now get it for real
    cchSysDir = GetSystemDirectory( szSearch.GetBuffer(cchSysDir), cchSysDir );
    szSearch.ReleaseBuffer();
    // if we didn't get one - fail
    if ( !cchSysDir ) return FALSE;

    // finish making it a proper search string

    //
    // RONALDM -- add .rat to only find rat files.
    //
    szSearch += _T("\\*.rat");

    // scan the local files looking for rat files. For each we find, load
    // them into the list of rat files
    BOOL        fKeepGoing = TRUE;
    CFileFind   finder;
    fFoundAFile = finder.FindFile( szSearch );
    while ( fFoundAFile )
        {
        // get rid of the directories right away
        if ( finder.MatchesMask( FILE_ATTRIBUTE_DIRECTORY ) )
            {
            // get the next file
            fFoundAFile = finder.FindNextFile();
            continue;
            }

        // get and normalize the path
        sz = finder.GetFilePath();
        sz.MakeLower();

        // if it is a rat file, go for it

        //
        // RONALDM -- changed the mask so that this is all that's necc.
        //
        //if ( sz.Find(_T(".rat")) > 0 )
            {
            // set the found flag based on if we can load it
            fGotSomething |= FLoadRatingsFile( sz );
            }

        // get the next file
        if ( !fKeepGoing )
            {
            fFoundAFile = FALSE;
            }
        else
            {
            fKeepGoing = finder.FindNextFile();
            }
        }

    // if we loaded a file, check what is in the metabase and load the values
    if ( fGotSomething )
        {
        LoadMetabaseValues();
        }
    else
        {
        // if we didn't find any rat files, tell the user and return
        AfxMessageBox( IDS_RAT_FINDFILE_ERROR );
        }

    // return the answer
    return fGotSomething;
    }

//----------------------------------------------------------------
// load a ratings file
BOOL CRatingsData::FLoadRatingsFile( CString szFilePath )
    {
    HANDLE                      hFile;
    HANDLE                      hFileMapping;
    VOID *                      pMem;
    BOOL                        fParsed = FALSE;

    hFile = CreateFile( szFilePath,
                                GENERIC_READ,
                                0,
                                NULL,
                                OPEN_EXISTING,
                                FILE_ATTRIBUTE_NORMAL,
                                NULL );

    if ( hFile == INVALID_HANDLE_VALUE )
        {
        return FALSE;
        }

    hFileMapping = CreateFileMapping( hFile,
                                NULL,
                                PAGE_READONLY,
                                0,
                                0,
                                NULL );

    if ( hFileMapping == NULL )
        {
        CloseHandle( hFile );
        return FALSE;
        }

    pMem = MapViewOfFile( hFileMapping,
                                FILE_MAP_READ,
                                0,
                                0,
                                0 );

    if ( pMem == NULL )
        {
        CloseHandle( hFileMapping );
        CloseHandle( hFile );
        return FALSE;
        }

    // parse this and load it in and all that stuff
    fParsed = FParseRatingsFile( (LPSTR) pMem, szFilePath );

    UnmapViewOfFile( pMem );
    CloseHandle( hFileMapping );
    CloseHandle( hFile );

    // return the answer
    return fParsed;
    }


//----------------------------------------------------------------
BOOL CRatingsData::FParseRatingsFile( LPSTR pData, CString szPath )
    {
    HRESULT hres;
    BOOL fSuccess = FALSE;

    // first, try and parse the data
    PicsRatingSystem*   pRating = new PicsRatingSystem();

    // parse the data
    hres = pRating->Parse( pData );
    fSuccess = (hres == 0);

    // if it didn't parse, leave now
    if ( !fSuccess )
        {
        delete pRating;
        return FALSE;
        }

    // add the rat to the list of parsed rats
    rgbRats.Add( pRating );

    return fSuccess;
    }


//----------------------------------------------------------------
// create a date string
void CRatingsData::CreateDateSz( CString &sz, WORD day, WORD month, WORD year, WORD hour, WORD minute )
    {
    // get the local time zone
    TIME_ZONE_INFORMATION   tZone;
    INT                     hrZone, mnZone;
    DWORD                   dwDaylight = GetTimeZoneInformation( &tZone );
	// Fix for 339525: Boyd, this could be negative and must be signed type!
    LONG					tBias;

    // First, calculate the correct bias - depending whether or not
    // we are in daylight savings time.
    if ( dwDaylight == TIME_ZONE_ID_DAYLIGHT )
    {
        tBias = tZone.Bias + tZone.DaylightBias;
    }
    else
    {
        tBias = tZone.Bias + tZone.StandardBias;
    }

    // calculate the hours and minutes offset for the time-zone
    hrZone = tBias / 60;
    mnZone = tBias % 60;

    // need to handle time zones east of GMT
    if ( hrZone < 0 )
        {
        hrZone *= (-1);
        mnZone *= (-1);
        // make the string
        sz.Format( _T("%04d.%02d.%02dT%02d:%02d+%02d%02d"), year, month, day, hour, minute, hrZone, mnZone );
        }
    else
        {
        // make the string
        sz.Format( _T("%04d.%02d.%02dT%02d:%02d-%02d%02d"), year, month, day, hour, minute, hrZone, mnZone );
        }
    }

//----------------------------------------------------------------
// read a date string
void CRatingsData::ReadDateSz( CString sz, WORD* pDay, WORD* pMonth, WORD* pYear, WORD* pHour, WORD* pMinute )
    {
    CString szNum;
    WORD    i;
    DWORD   dw;

    // year
    szNum = sz.Left( sz.Find(_T('.')) );
    i = (WORD)swscanf( szNum, _T("%d"), &dw );
    *pYear = (WORD)dw;
    sz = sz.Right( sz.GetLength() - szNum.GetLength() - 1 );

    // month
    szNum = sz.Left( sz.Find(_T('.')) );
    i = (WORD)swscanf( szNum, _T("%d"), &dw );
    *pMonth = (WORD)dw;
    sz = sz.Right( sz.GetLength() - szNum.GetLength() - 1 );

    // day
    szNum = sz.Left( sz.Find(_T('T')) );
    i = (WORD)swscanf( szNum, _T("%d"), &dw );
    *pDay = (WORD)dw;
    sz = sz.Right( sz.GetLength() - szNum.GetLength() - 1 );

    // hour
    szNum = sz.Left( sz.Find(_T(':')) );
    i = (WORD)swscanf( szNum, _T("%d"), &dw );
    *pHour = (WORD)dw;
    sz = sz.Right( sz.GetLength() - szNum.GetLength() - 1 );

    // minute
    szNum = sz.Left( 2 );
    i = (WORD)swscanf( szNum, _T("%d"), &dw );
    *pMinute = (WORD)dw;
    }

//----------------------------------------------------------------
// for simplicity's sake (and for the sake of gettings done) only check the
// metabase values against the first loaded ratings system. Everything I've
// been hearing is that there will be only one.
void CRatingsData::LoadMetabaseValues()
    {
    CString szRating;
    BOOL    f;

    // prepare the metabase wrapper
    CWrapMetaBase   mbWrap;
    f = mbWrap.FInit(m_pMB);
    if ( !f ) return;

    // if we succeded in building the lables, save it in the metabase
    // attempt to open the object we want to store into
    CString szMeta;

    // arg arg arg. For things like directories, the metapath may not exist
    // seperate the partial path from the base - the root is always SZ_ROOT
    szMeta = SZ_W3_ROOT;
    m_szMetaPartial = m_szMeta.Right(m_szMeta.GetLength() - szMeta.GetLength() );

    // save the data
    if ( mbWrap.Open( szMeta, METADATA_PERMISSION_READ ) )
        {
        DWORD   cbData;
        // attempt to read the data from the metabase
        WCHAR* pData= (WCHAR*)mbWrap.GetData( m_szMetaPartial, MD_HTTP_PICS, IIS_MD_UT_FILE, MULTISZ_METADATA,
                    &cbData, METADATA_INHERIT | METADATA_PARTIAL_PATH );

        // copy the string into place
        if ( pData )
            szRating = pData;
        // free the buffer
        mbWrap.FreeWrapData( pData );
        // close the metabase
        mbWrap.Close();

        // if we got the string, parse it and all that jazz
        if ( !szRating.IsEmpty() )
            ParseMetaRating( szRating );
        }
    }

//----------------------------------------------------------------
// NOTE: this is a pretty fragile reading of the PICS file. If things are
// not in the order that this file would write them back out in, it will fail.
// however, This will work on PICS ratings that this module has written out,
// which should pretty much be all of them
// it also assumes that one-letter abbreviations are used just about everywhere
#define RAT_PERSON_DETECTOR     _T("by \"")
#define RAT_LABEL_DETECTOR      _T("l ")
#define RAT_ON_DETECTOR         _T("on \"")
#define RAT_EXPIRE_DETECTOR     _T("exp \"")
#define RAT_RAT_DETECTOR        _T("r (")
void CRatingsData::ParseMetaRating( CString szRating )
    {
    CString     szScratch;

    // if we got here, then we know that the rating system is enabled
    m_fEnabled = TRUE;

    // operate on a copy of the data
    CString     szRat;

    // skip past the http headerpart
    szRat = szRating.Right( szRating.GetLength() - szRating.Find(_T("\"http://")) - 1 );
    szRat = szRat.Right( szRat.GetLength() - szRat.Find(_T('\"')) - 1 );
    szRat.TrimLeft();

    // the next bit should be the label indicator. Skip over it
    if ( szRat.Left(wcslen(RAT_LABEL_DETECTOR)) == RAT_LABEL_DETECTOR )
        szRat = szRat.Right( szRat.GetLength() - wcslen(RAT_LABEL_DETECTOR) );

    // we should now be at the author part. If it is there, load it in
    if ( szRat.Left(wcslen(RAT_PERSON_DETECTOR)) == RAT_PERSON_DETECTOR )
        {
        szRat = szRat.Right( szRat.GetLength() - wcslen(RAT_PERSON_DETECTOR) );
        m_szEmail = szRat.Left( szRat.Find(_T('\"')) );
        szRat = szRat.Right( szRat.GetLength() - m_szEmail.GetLength() - 1 );
        szRat.TrimLeft();
        }

    // next should be the modification date
    // we should now be at the author part. If we are, load it in
    if ( szRat.Left(wcslen(RAT_ON_DETECTOR)) == RAT_ON_DETECTOR )
        {
        szRat = szRat.Right( szRat.GetLength() - wcslen(RAT_ON_DETECTOR) );
        szScratch = szRat.Left( szRat.Find(_T('\"')) );
        szRat = szRat.Right( szRat.GetLength() - szScratch.GetLength() - 1 );
        szRat.TrimLeft();
        ReadDateSz( szScratch, &m_start_day, &m_start_month, &m_start_year,
                    &m_start_hour, &m_start_minute );
        }

    // next should be the expiration date
    // we should now be at the author part. If we are, load it in
    if ( szRat.Left(wcslen(RAT_EXPIRE_DETECTOR)) == RAT_EXPIRE_DETECTOR )
        {
        szRat = szRat.Right( szRat.GetLength() - wcslen(RAT_EXPIRE_DETECTOR) );
        szScratch = szRat.Left( szRat.Find(_T('\"')) );
        szRat = szRat.Right( szRat.GetLength() - szScratch.GetLength() - 1 );
        szRat.TrimLeft();
        ReadDateSz( szScratch, &m_expire_day, &m_expire_month, &m_expire_year,
                    &m_expire_hour, &m_expire_minute );
        }

    // we should now be at the actual ratings part. If we are, load it in as one string first
    if ( szRat.Left(wcslen(RAT_RAT_DETECTOR)) == RAT_RAT_DETECTOR )
        {
        szRat = szRat.Right( szRat.GetLength() - wcslen(RAT_RAT_DETECTOR) );
        szScratch = szRat.Left( szRat.Find(_T(')')) );
        szRat = szRat.Right( szRat.GetLength() - szScratch.GetLength() - 1 );
        szRat.TrimLeft();

        // loop through all the value pairs in the ratings string
        while ( szScratch.GetLength() )
            {
            // this part goes <ch> sp <ch> so that we know we can use chars 0 and 2
            ParseMetaPair( szScratch[0], szScratch[2] );

            // cut down the string
            szScratch = szScratch.Right( szScratch.GetLength() - 3 );
            szScratch.TrimLeft();
            }
        }

    }

//----------------------------------------------------------------
void CRatingsData::ParseMetaPair( TCHAR chCat, TCHAR chVal )
    {
    // check validity of the value character
    if ( (chVal < _T('0')) || (chVal > _T('9')) )
        return;

    // convert the value into a number - the quick way
    WORD    value = chVal - _T('0');

    // try all the categories
    DWORD nCat = rgbRats[0]->arrpPC.Length();
    for ( DWORD iCat = 0; iCat < nCat; iCat++ )
        {
        // stop at the first successful setting
        if ( rgbRats[0]->arrpPC[iCat]->FSetValuePair((CHAR)chCat, (CHAR)value) )
            break;
        }
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\cnfgprts\ratexprd.cpp ===
// RatExprD.cpp : implementation file
//

#include "stdafx.h"
#include "cnfgprts.h"
#include "RatExprD.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CRatExpireDlg dialog


//--------------------------------------------------------------------------
CRatExpireDlg::CRatExpireDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CRatExpireDlg::IDD, pParent),
        m_day( 0 ),
        m_month( 0 ),
        m_year( 0 )
    {
    //{{AFX_DATA_INIT(CRatExpireDlg)
        // NOTE: the ClassWizard will add member initialization here
    //}}AFX_DATA_INIT
    }

//--------------------------------------------------------------------------
void CRatExpireDlg::DoDataExchange(CDataExchange* pDX)
    {
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CRatExpireDlg)
    DDX_Control(pDX, IDC_MSACALCTRL, m_calendar);
    //}}AFX_DATA_MAP
    }


//--------------------------------------------------------------------------
BEGIN_MESSAGE_MAP(CRatExpireDlg, CDialog)
    //{{AFX_MSG_MAP(CRatExpireDlg)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CRatExpireDlg message handlers


//--------------------------------------------------------------------------
BOOL CRatExpireDlg::IsSystemDBCS( void )
    {
    WORD wPrimaryLangID = PRIMARYLANGID( GetSystemDefaultLangID() );

    return ( wPrimaryLangID == LANG_JAPANESE ||
        wPrimaryLangID == LANG_CHINESE ||
        wPrimaryLangID == LANG_KOREAN );
    } 

//--------------------------------------------------------------------------
BOOL CRatExpireDlg::OnInitDialog( )
    {
    SYSTEMTIME  time;

    // get the base class going
    BOOL f = CDialog::OnInitDialog();

    // set up the calendar in DBCS mode as appropriate - suggested by the japanese guys
    if ( IsSystemDBCS() )
        {
        m_calendar.SetDayLength( 0 );    // 0: localized one
        m_calendar.SetMonthLength( 0 );  // 0: localized one
        m_calendar.SetDayFont( NULL );   // use default
        m_calendar.SetGridFont( NULL );  // use default
        m_calendar.SetTitleFont( NULL ); // use default
        }

    //
    // Background colour looks weird if the dialog
    // is not gray
    //
    m_calendar.SetBackColor(GetSysColor(COLOR_BTNFACE));

    // now tell the calendar to focus on one year from today, or the supplied date
    // if there is one
    if ( m_year )
        {
 	    m_calendar.SetYear( m_year );
	    m_calendar.SetMonth( m_month );
	    m_calendar.SetDay( m_day );
       }
    else
        {
        // the default case - use one year from today
        GetLocalTime( &time );
 	    m_calendar.SetYear( time.wYear + 1 );
	    m_calendar.SetMonth( time.wMonth );
	    m_calendar.SetDay( time.wDay );
        }

    // return the answer
    return f;
    }

//--------------------------------------------------------------------------
void CRatExpireDlg::OnOK() 
    {
    // get the date
    m_day = m_calendar.GetDay();
    m_month = m_calendar.GetMonth();
    m_year = m_calendar.GetYear();

    // test if nothing is selected - check if the year is 0
    if ( m_year == 0 )
        {
        AfxMessageBox(IDS_NO_DATE_SELECTED);
        return;
        }

    // put it into a CTime so we can compare
    CTime  timeCal(m_year,m_month,m_day,12,0,0);

    // compare
    if ( timeCal < CTime::GetCurrentTime() )
        {
        if ( AfxMessageBox(IDS_EXPIRE_SET_PAST,MB_YESNO) == IDNO )
            return;
        }

    // let the dialog close
    CDialog::OnOK();
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\cnfgprts\ratdata.h ===
// ratings data class


class CRatingsData : public CObject
    {
    public:
        CRatingsData(IMSAdminBase* pMB);
        ~CRatingsData();

        IMSAdminBase*   m_pMB;


    // other data for/from the metabase
        BOOL    m_fEnabled;
        CString m_szEmail;

    // start date
        WORD    m_start_minute;
        WORD    m_start_hour;
        WORD    m_start_day;
        WORD    m_start_month;
        WORD    m_start_year;

    // expire date
        WORD    m_expire_minute;
        WORD    m_expire_hour;
        WORD    m_expire_day;
        WORD    m_expire_month;
        WORD    m_expire_year;

    // generate the label and save it into the metabase
        void SaveTheLable();

    // initialization
        BOOL    FInit( CString szServer, CString szMeta );

    // variables shared between the various pages
        // index of the currently selected rat parser
        DWORD   iRat;

        // the list of parsed rat files
        CTypedPtrArray<CObArray, PicsRatingSystem*> rgbRats;

    protected:
        // load a ratings file
        BOOL    FLoadRatingsFile( CString szFilePath );
        void    LoadMetabaseValues();
        void    ParseMetaRating( CString szRating );
        void    ParseMetaPair( TCHAR chCat, TCHAR chVal );

        // interpret the ratings file
        BOOL    FParseRatingsFile( LPSTR pData, CString szPath );

        // create the URL for the the item supplied for the metabase
        BOOL    FCreateURL( CString &sz );

        // create a date string
        void    CreateDateSz( CString &sz, WORD day, WORD month, WORD year, WORD hour, WORD minute );

        // read a date string
        void    ReadDateSz( CString sz, WORD* pDay, WORD* pMonth, WORD* pYear, WORD* pHour, WORD* pMinute );

        // target metabase location
        CString     m_szMeta;
        CString     m_szServer;

        CString     m_szMetaPartial;
    };
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\cnfgprts\ratctl.h ===
// RatCtl.h : Declaration of the CRatCtrl OLE control class.

/////////////////////////////////////////////////////////////////////////////
// CRatCtrl : See RatCtl.cpp for implementation.

class CRatCtrl : public COleControl
{
	DECLARE_DYNCREATE(CRatCtrl)

// Constructor
public:
	CRatCtrl();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CRatCtrl)
	public:
	virtual void OnDraw(CDC* pdc, const CRect& rcBounds, const CRect& rcInvalid);
	virtual void DoPropExchange(CPropExchange* pPX);
	virtual void OnResetState();
	virtual void OnClick(USHORT iButton);
	virtual void OnFontChanged();
	virtual void OnGetControlInfo(LPCONTROLINFO pControlInfo);
	virtual void OnTextChanged();
	virtual void OnMnemonic(LPMSG pMsg);
	virtual void OnAmbientPropertyChange(DISPID dispid);
	virtual void OnKeyUpEvent(USHORT nChar, USHORT nShiftState);
	//}}AFX_VIRTUAL

// Implementation
protected:
	~CRatCtrl();

	DECLARE_OLECREATE_EX(CRatCtrl)    // Class factory and guid
	DECLARE_OLETYPELIB(CRatCtrl)      // GetTypeInfo
	DECLARE_PROPPAGEIDS(CRatCtrl)     // Property page IDs
	DECLARE_OLECTLTYPE(CRatCtrl)		// Type name and misc status

	// Subclassed control support
	BOOL PreCreateWindow(CREATESTRUCT& cs);
	BOOL IsSubclassedControl();
	LRESULT OnOcmCommand(WPARAM wParam, LPARAM lParam);

// Message maps
	//{{AFX_MSG(CRatCtrl)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

// Dispatch maps
	//{{AFX_DISPATCH(CRatCtrl)
	afx_msg void SetAdminTarget(LPCTSTR szMachineName, LPCTSTR szMetaTarget);
	//}}AFX_DISPATCH
	DECLARE_DISPATCH_MAP()

// Event maps
	//{{AFX_EVENT(CRatCtrl)
	//}}AFX_EVENT
	DECLARE_EVENT_MAP()

// Dispatch and event IDs
public:
	enum {
	//{{AFX_DISP_ID(CRatCtrl)
	dispidSetAdminTarget = 1L,
	//}}AFX_DISP_ID
	};

protected:
    BOOL 	m_fUpdateFont;
    CString m_szMachine;
    CString m_szMetaObject;

    // the accelerator table
    HACCEL  m_hAccel;
    WORD    m_cAccel;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\cnfgprts\ratgenpg.h ===
// RatGenPg.h : header file
//
/////////////////////////////////////////////////////////////////////////////
// CRatGenPage dialog

class CRatGenPage : public CPropertyPage
{
	DECLARE_DYNCREATE(CRatGenPage)

// Construction
public:
	CRatGenPage();
	~CRatGenPage();
    
    // the data
    CRatingsData*   m_pRatData;

// Dialog Data
	//{{AFX_DATA(CRatGenPage)
	enum { IDD = IDD_RAT_SETRATING };
	CStatic	m_cstatic_moddate;
	CStatic	m_cstatic_moddate_title;
	CButton	m_cbutton_optional;
	CTreeCtrl	m_ctree_tree;
	CStatic	m_cstatic_title;
	CStatic	m_cstatic_rating;
	CStatic	m_cstatic_icon;
	CStatic	m_cstatic_expires;
	CStatic	m_cstatic_email;
	CStatic	m_cstatic_category;
	CSliderCtrl	m_cslider_slider;
	CEdit	m_cedit_person;
	CStatic	m_cstatic_description;
	CString	m_sz_description;
	BOOL	m_bool_enable;
	CString	m_sz_moddate;
	CString	m_sz_person;
	//}}AFX_DATA

   CDateTimeCtrl m_dtpDate;

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CRatGenPage)
	public:
	virtual BOOL OnSetActive();
	virtual BOOL OnApply();
	virtual void OnOK();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	virtual BOOL OnNotify(WPARAM wParam, LPARAM lParam, LRESULT* pResult);
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CRatGenPage)
	afx_msg void OnEnable();
	afx_msg void OnSelchangedTree(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnHScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar);
	afx_msg void OnChangeNamePerson();
	afx_msg void OnChangeModDate();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

    void DoHelp();

    // tell it to query the metabase and get any defaults
    BOOL    FInit();
    // load the parsed rat files into the tree
    BOOL    FLoadRatFiles();

    // utilities
    void EnableButtons();
    void UpdateRatingItems();
    void SetCurrentModDate();
    void UdpateDescription();
    void UpdateDateStrings();
    void SetModifiedTime();

    PicsCategory* GetTreeItemCategory( HTREEITEM hItem );
    void LoadSubCategories( PicsCategory* pParentCat, HTREEITEM hParent );

    // initialized flag
    BOOL        m_fInititialized;
    CImageList	m_imageList;

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\cnfgprts\ratexprd.h ===
// RatExprD.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CRatExpireDlg dialog
//{{AFX_INCLUDES()
#include "msacal70.h"
//}}AFX_INCLUDES

class CRatExpireDlg : public CDialog
{
// Construction
public:
	CRatExpireDlg(CWnd* pParent = NULL);   // standard constructor
virtual  BOOL OnInitDialog( );

    WORD    m_day;
    WORD    m_month;
    WORD    m_year;

// Dialog Data
	//{{AFX_DATA(CRatExpireDlg)
	enum { IDD = IDD_RAT_EXPIRE };
	CMsacal70	m_calendar;
	//}}AFX_DATA


// Overrides

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CRatExpireDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

    BOOL IsSystemDBCS( void );

	// Generated message map functions
	//{{AFX_MSG(CRatExpireDlg)
	virtual void OnOK();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\cnfgprts\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\cnfgprts\ratgenpg.cpp ===
// RatGenPg.cpp : implementation file
//

#include "stdafx.h"
#include <iadmw.h>
#include "cnfgprts.h"

#include "parserat.h"
#include "RatData.h"

#include "RatGenPg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


// enumerate the tree icon indexes
enum
    {
    IMAGE_SERVICE = 0,
    IMAGE_CATEGORY
    };

/////////////////////////////////////////////////////////////////////////////
// CRatGenPage property page

IMPLEMENT_DYNCREATE(CRatGenPage, CPropertyPage)

//--------------------------------------------------------------------------
CRatGenPage::CRatGenPage() : CPropertyPage(CRatGenPage::IDD),
        m_fInititialized( FALSE )
    {
    //{{AFX_DATA_INIT(CRatGenPage)
    m_sz_description = _T("");
    m_bool_enable = FALSE;
    m_sz_moddate = _T("");
    m_sz_person = _T("");
	//}}AFX_DATA_INIT
    }

//--------------------------------------------------------------------------
CRatGenPage::~CRatGenPage()
    {
    }

//--------------------------------------------------------------------------
void CRatGenPage::DoDataExchange(CDataExchange* pDX)
    {
    CPropertyPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CRatGenPage)
    DDX_Control(pDX, IDC_MOD_DATE, m_cstatic_moddate);
    DDX_Control(pDX, IDC_STATIC_MOD_DATE, m_cstatic_moddate_title);
    DDX_Control(pDX, IDC_TREE, m_ctree_tree);
    DDX_Control(pDX, IDC_TITLE, m_cstatic_title);
    DDX_Control(pDX, IDC_STATIC_RATING, m_cstatic_rating);
    DDX_Control(pDX, IDC_STATIC_ICON, m_cstatic_icon);
    DDX_Control(pDX, IDC_STATIC_EXPIRES, m_cstatic_expires);
    DDX_Control(pDX, IDC_STATIC_EMAIL, m_cstatic_email);
    DDX_Control(pDX, IDC_STATIC_CATEGORY, m_cstatic_category);
    DDX_Control(pDX, IDC_SLIDER, m_cslider_slider);
    DDX_Control(pDX, IDC_NAME_PERSON, m_cedit_person);
    DDX_Control(pDX, IDC_DESCRIPTION, m_cstatic_description);
    DDX_Text(pDX, IDC_DESCRIPTION, m_sz_description);
    DDX_Check(pDX, IDC_ENABLE, m_bool_enable);
    DDX_Text(pDX, IDC_MOD_DATE, m_sz_moddate);
    DDX_Text(pDX, IDC_NAME_PERSON, m_sz_person);
    DDV_MaxChars(pDX, m_sz_person, 200);
	//}}AFX_DATA_MAP

    DDX_Control(pDX, IDC_DTP_ABS_DATE, m_dtpDate);
    }


//--------------------------------------------------------------------------
BEGIN_MESSAGE_MAP(CRatGenPage, CPropertyPage)
    //{{AFX_MSG_MAP(CRatGenPage)
    ON_BN_CLICKED(IDC_ENABLE, OnEnable)
    ON_NOTIFY(TVN_SELCHANGED, IDC_TREE, OnSelchangedTree)
    ON_WM_HSCROLL()
    ON_EN_CHANGE(IDC_NAME_PERSON, OnChangeNamePerson)
    ON_EN_CHANGE(IDC_MOD_DATE, OnChangeModDate)
	//}}AFX_MSG_MAP
    ON_COMMAND(ID_HELP_FINDER,  DoHelp)
    ON_COMMAND(ID_HELP,         DoHelp)
    ON_COMMAND(ID_CONTEXT_HELP, DoHelp)
    ON_COMMAND(ID_DEFAULT_HELP, DoHelp)
END_MESSAGE_MAP()

//---------------------------------------------------------------------------
void CRatGenPage::DoHelp()
    {
    WinHelp( HIDD_RATINGS_RATING );
    }


//--------------------------------------------------------------------------
void CRatGenPage::EnableButtons()
    {
    UpdateData( TRUE );

    // enabling is based on whether or not things are enabled
    if ( m_bool_enable )
        {
        m_ctree_tree.EnableWindow( TRUE );
        m_cstatic_title.EnableWindow( TRUE );
        m_cstatic_rating.EnableWindow( TRUE );
        m_cstatic_icon.EnableWindow( TRUE );
        m_cstatic_expires.EnableWindow( TRUE );
        m_cstatic_email.EnableWindow( TRUE );
        m_cstatic_category.EnableWindow( TRUE );
        m_cslider_slider.EnableWindow( TRUE );
        m_cedit_person.EnableWindow( TRUE );
        m_cstatic_moddate.EnableWindow( TRUE );
        m_cstatic_moddate_title.EnableWindow( TRUE );
        m_cstatic_description.EnableWindow( TRUE );
        m_dtpDate.EnableWindow(TRUE);

        // also need to take care of the slider bar
        UpdateRatingItems();
        }
    else
        {
        // not enabled
        m_ctree_tree.EnableWindow( FALSE );
        m_cstatic_title.EnableWindow( FALSE );
        m_cstatic_rating.EnableWindow( FALSE );
        m_cstatic_icon.EnableWindow( FALSE );
        m_cstatic_email.EnableWindow( FALSE );
        m_cstatic_category.EnableWindow( FALSE );
        m_cedit_person.EnableWindow( FALSE );
        m_cstatic_moddate.EnableWindow( FALSE );
        m_cstatic_moddate_title.EnableWindow( FALSE );
        m_dtpDate.EnableWindow(FALSE);

        // don't just disable the slider and description - hide them!
        m_cslider_slider.ShowWindow( SW_HIDE );
        m_cstatic_description.ShowWindow( SW_HIDE );
        }
    }

//--------------------------------------------------------------------------
void CRatGenPage::UpdateRatingItems()
    {
    // get the selected item in the tree
    HTREEITEM hItem = m_ctree_tree.GetSelectedItem();

    // get the item category
    PicsCategory* pCat = GetTreeItemCategory( hItem );

    // if there is no item, or it is the root, hide the sliders
    if ( !pCat )
        {
        // don't just disable the slider and description - hide them!
        m_cslider_slider.ShowWindow( SW_HIDE );
        m_cstatic_description.ShowWindow( SW_HIDE );
        }
    else
        {
        // make sure the windows are showing and enabled
        m_cslider_slider.ShowWindow( SW_SHOW );
        m_cstatic_description.ShowWindow( SW_SHOW );
        m_cslider_slider.EnableWindow( TRUE );
        m_cstatic_description.EnableWindow( TRUE );

        // get the item category
        PicsCategory* pCat = GetTreeItemCategory( hItem );

        // set up the slider
        m_cslider_slider.SetRangeMin( 0 );
        m_cslider_slider.SetRangeMax( pCat->arrpPE.Length() - 1, TRUE );

        // set current value of the slider
        m_cslider_slider.SetPos( pCat->currentValue );

        // set up the description
        UdpateDescription();
        }
    }

//--------------------------------------------------------------------------
PicsCategory* CRatGenPage::GetTreeItemCategory( HTREEITEM hItem )
    {
    DWORD   iRat;
    DWORD   iCat = 0;

    // get the item's parent in the tree
    HTREEITEM hParent = m_ctree_tree.GetParentItem(hItem);

    // get the cat
    // IA64 - OK to cast as this is an index
    iCat = (DWORD)m_ctree_tree.GetItemData( hItem );

    // if the parent is null, return NULL to indicate that this is a root item
    if ( !hParent )
        return NULL;

    // if the parent is a root though, we can simply return the category
    if ( !m_ctree_tree.GetParentItem(hParent) )
        {
        // get the rat and the cat
    // IA64 - OK to cast as this is an index
        iRat = (DWORD)m_ctree_tree.GetItemData( hParent );
        // return the category
        return m_pRatData->rgbRats[iRat]->arrpPC[iCat];
        }
    else
        {
        // we are deeper in the tree. Get the parent category first
        PicsCategory* pParentCat = GetTreeItemCategory( hParent );
        // return the category
        return pParentCat->arrpPC[iCat];
        }
    // shouldn't get here
    return NULL;
    }

//--------------------------------------------------------------------------
void CRatGenPage::UpdateDateStrings()
    {
    CString sz;
    TCHAR    chBuff[MAX_PATH];
    int     i;

    SYSTEMTIME  sysTime;

    UpdateData( TRUE );

    // start with the epxiration date
    ZeroMemory( chBuff, sizeof(chBuff) );
    ZeroMemory( &sysTime, sizeof(sysTime) );
    sysTime.wDay = m_pRatData->m_expire_day;
    sysTime.wMonth = m_pRatData->m_expire_month;
    sysTime.wYear = m_pRatData->m_expire_year;

    m_dtpDate.SetTime(&sysTime);


    // now the modified date and time
    ZeroMemory( chBuff, sizeof(chBuff) );
    ZeroMemory( &sysTime, sizeof(sysTime) );
    sysTime.wDay = m_pRatData->m_start_day;
    sysTime.wMonth = m_pRatData->m_start_month;
    sysTime.wYear = m_pRatData->m_start_year;
    sysTime.wMinute = m_pRatData->m_start_minute;
    sysTime.wHour = m_pRatData->m_start_hour;

    i = GetDateFormat(
        LOCALE_USER_DEFAULT,    // locale for which date is to be formatted
        DATE_LONGDATE,  // flags specifying function options
        &sysTime,   // date to be formatted
        NULL,   // date format string
        chBuff, // buffer for storing formatted string
        sizeof(chBuff)  // size of buffer
       );
    m_sz_moddate = chBuff;

    ZeroMemory( chBuff, sizeof(chBuff) );
    i = GetTimeFormat(
        LOCALE_USER_DEFAULT,    // locale for which time is to be formatted
        TIME_NOSECONDS, // flags specifying function options
        &sysTime,   // time to be formatted
        NULL,   // time format string
        chBuff, // buffer for storing formatted string
        sizeof(chBuff)  // size, in bytes or characters, of the buffer
       );
    m_sz_moddate += ", ";
    m_sz_moddate += chBuff;

//    CTime timeModified( sysTime );
//    m_sz_moddate = timeModified.Format( "%#c" );

    // put it back
    UpdateData( FALSE );
    }

//--------------------------------------------------------------------------
// Update the text displayed in the description
void CRatGenPage::UdpateDescription()
    {
    // get the selected item in the tree
    HTREEITEM hItem = m_ctree_tree.GetSelectedItem();
    if ( !hItem ) return;

    // get the selected category object
    PicsCategory* pCat = GetTreeItemCategory( hItem );

    // shouldn't be any problem, but might as well check
    if ( !pCat )
        return;

    // get the current value
    WORD value = pCat->currentValue;

    // build the description string
    m_sz_description = pCat->arrpPE[value]->etstrName.Get();
    UpdateData( FALSE );
    }

//--------------------------------------------------------------------------
// tell it to query the metabase and get any defaults
BOOL CRatGenPage::FInit()
    {
    UpdateData( TRUE );

    // init the image list first
    // prepare the list's image list
    if ( m_imageList.Create( IDB_RATLIST, 16, 3, 0x00FF00FF ) )
        // set the image list into the list control
        m_ctree_tree.SetImageList( &m_imageList, TVSIL_NORMAL );

    // start with the parsed rat files
    if ( !FLoadRatFiles() )
        return FALSE;

    // do the right thing based on the ratings being enabled
    if ( m_pRatData->m_fEnabled )
        {
        // ratings are enabled.
        m_bool_enable = TRUE;
        m_sz_person = m_pRatData->m_szEmail;
        }
    else
        {
        // ratings are not enabled.
        m_bool_enable = FALSE;
        }

    // do the dates
    // if the mod date is not set give date today's as a default moddate
    if ( m_pRatData->m_start_year == 0 )
        {
        SetCurrentModDate();
        }



    //
    // Set the minimum of the date picker to today
    // and the maximum to Dec 31, 2035.
    // taken from Ron's code
    //
    CTime m_tmNow(CTime::GetCurrentTime());
    CTime tmThen(2035, 12, 31, 23, 59, 59);
    m_dtpDate.SetRange(&m_tmNow, &tmThen);

    // if there is no expire date, set it for one year after the mod date
    if ( m_pRatData->m_expire_year == 0 )
        {
        m_pRatData->m_expire_minute = 0;
        m_pRatData->m_expire_hour = 12;
        m_pRatData->m_expire_day = m_pRatData->m_start_day;
        m_pRatData->m_expire_month = m_pRatData->m_start_month;
        m_pRatData->m_expire_year = m_pRatData->m_start_year + 1;
        }

    // update the date strings
    UpdateDateStrings();

    // update the name string and the enabled switch as well
    m_sz_person = m_pRatData->m_szEmail;
    m_bool_enable = m_pRatData->m_fEnabled;

    // put the data back
    UpdateData( FALSE );

    EnableButtons();

    // success
    return TRUE;
    }

//--------------------------------------------------------------------------
// load the parsed rat files into the tree
BOOL CRatGenPage::FLoadRatFiles()
    {
    HTREEITEM   hRoot;
    HTREEITEM   hItem;
    CString     sz;

    // how many rat files are there?
    DWORD   nRatFiles = (DWORD)m_pRatData->rgbRats.GetSize();
    // loop them
    for ( DWORD iRat = 0; iRat < nRatFiles; iRat++ )
        {
        // get the rating system
        PicsRatingSystem*   pRating = m_pRatData->rgbRats[iRat];

        // get the root node name
        sz = pRating->etstrName.Get();

        // add the root node to the tree
        hRoot = m_ctree_tree.InsertItem( sz );
        // because the list is alphabetized, embed the iRat number in the item
        m_ctree_tree.SetItemData( hRoot, iRat );
        m_ctree_tree.SetItemImage( hRoot, IMAGE_SERVICE, IMAGE_SERVICE );

        // add the subnodes to the tree as well
        DWORD nCats = pRating->arrpPC.Length();
        // loop them
        for ( DWORD iCat = 0; iCat < nCats; iCat++ )
            {
            // get the category node name
            sz = pRating->arrpPC[iCat]->etstrName.Get();

            // add the category node to the tree
            hItem = m_ctree_tree.InsertItem( sz, hRoot );

            // because the list is alphabetized, embed the iCat number in the item
            m_ctree_tree.SetItemData( hItem, iCat );
            m_ctree_tree.SetItemImage( hItem, IMAGE_CATEGORY, IMAGE_CATEGORY );

            // even though there aren't any now, add any sub-categories
            LoadSubCategories( pRating->arrpPC[iCat], hItem );
            }

        // expand the rat node
        m_ctree_tree.Expand( hRoot, TVE_EXPAND );
        }

    return TRUE;
    }

//--------------------------------------------------------------------------
void CRatGenPage::LoadSubCategories( PicsCategory* pParentCat, HTREEITEM hParent )
    {
    CString sz;
    HTREEITEM hItem;

    // add the subnodes to the tree as well
    DWORD nCats = pParentCat->arrpPC.Length();
    // loop them
    for ( DWORD iCat = 0; iCat < nCats; iCat++ )
        {
        // get the category node name
        sz = pParentCat->arrpPC[iCat]->etstrName.Get();

        // add the category node to the tree
        hItem = m_ctree_tree.InsertItem( sz, hParent );

        // because the list is alphabetized, embed the iCat number in the item
        m_ctree_tree.SetItemData( hItem, iCat );
        m_ctree_tree.SetItemImage( hItem, IMAGE_CATEGORY, IMAGE_CATEGORY );

        // even though there aren't any now, add any sub-categories
        LoadSubCategories( pParentCat->arrpPC[iCat], hItem );
        }

    // if there were sub-categories, expand the parental node in the tree
    if ( nCats > 0 )
        m_ctree_tree.Expand( hParent, TVE_EXPAND );
    }


//--------------------------------------------------------------------------
void CRatGenPage::SetModifiedTime()
    {
    SetCurrentModDate();
    UpdateDateStrings();
    SetModified();
    }


/////////////////////////////////////////////////////////////////////////////
// CRatGenPage message handlers

//--------------------------------------------------------------------------
void CRatGenPage::OnEnable()
    {
    EnableButtons();
    SetModified();
    }

//--------------------------------------------------------------------------
BOOL CRatGenPage::OnSetActive()
    {
    // if it hasn't been initialized yet, do so
    if ( !m_fInititialized )
        {
        FInit();
        m_fInititialized = TRUE;
        }

    // enable the button appropriately
    EnableButtons();

    return CPropertyPage::OnSetActive();
    }

//--------------------------------------------------------------------------
void CRatGenPage::OnOK()
    {
    CPropertyPage::OnOK();
    }

//--------------------------------------------------------------------------
BOOL CRatGenPage::OnApply()
    {
    UpdateData( TRUE );

    // make sure there are no quote symbols in the name
    if ( m_sz_person.Find(_T('\"')) >= 0 )
        {
        AfxMessageBox( IDS_RAT_NAME_ERROR );
        return FALSE;
        }

    // put the data into place
    m_pRatData->m_fEnabled = m_bool_enable;
    m_pRatData->m_szEmail = m_sz_person;

    // set the expire date
    SYSTEMTIME  sysTime;
    ZeroMemory( &sysTime, sizeof(sysTime) );
    // get the date from the control
    m_dtpDate.GetTime(&sysTime);
    // set the date into place
    m_pRatData->m_expire_day = sysTime.wDay;
    m_pRatData->m_expire_month = sysTime.wMonth;
    m_pRatData->m_expire_year = sysTime.wYear;

    // generate the label and save it into the metabase
    m_pRatData->SaveTheLable();

    // we can now apply
    SetModified( FALSE );
    return CPropertyPage::OnApply();
    }

//--------------------------------------------------------------------------
void CRatGenPage::SetCurrentModDate()
    {
    SYSTEMTIME time;
    GetLocalTime( &time );

    m_pRatData->m_start_day = time.wDay;
    m_pRatData->m_start_month = time.wMonth;
    m_pRatData->m_start_year = time.wYear;
    m_pRatData->m_start_minute = time.wMinute;
    m_pRatData->m_start_hour = time.wHour;
    }

//--------------------------------------------------------------------------
void CRatGenPage::OnSelchangedTree(NMHDR* pNMHDR, LRESULT* pResult)
    {
    NM_TREEVIEW* pNMTreeView = (NM_TREEVIEW*)pNMHDR;
    UpdateRatingItems();
    *pResult = 0;
    }

//--------------------------------------------------------------------------
void CRatGenPage::OnHScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar)
    {
    // get the value of the slider
    WORD iPos = (WORD)m_cslider_slider.GetPos();

    // get the current item
    HTREEITEM   hItem = m_ctree_tree.GetSelectedItem();

    // get the selected category object
    PicsCategory* pCat = GetTreeItemCategory( hItem );

    // shouldn't be any problem, but might as well check
    if ( !pCat )
        return;

    // set the category value
    pCat->currentValue = iPos;

    // update the description
    UdpateDescription();

    // we can now apply
    SetModifiedTime();

    // update the mod date
    SetCurrentModDate();
    CPropertyPage::OnHScroll(nSBCode, nPos, pScrollBar);
    }

//--------------------------------------------------------------------------
void CRatGenPage::OnChangeNamePerson()
    {
    // we can now apply
    SetModifiedTime();
    }

//--------------------------------------------------------------------------
void CRatGenPage::OnChangeModDate()
    {
    // we can now apply
    SetModifiedTime();
    }


//--------------------------------------------------------------------------
// Stolen from w3scfg - the httppage.cpp file
BOOL
CRatGenPage::OnNotify(
    WPARAM wParam,
    LPARAM lParam,
    LRESULT * pResult
    )
/*++

Routine Description:

    Handle notification changes

Arguments:

    WPARAM wParam           : Control ID
    LPARAM lParam           : NMHDR *
    LRESULT * pResult       : Result pointer

Return Value:

    TRUE if handled, FALSE if not

--*/
{
    //
    // Message cracker crashes - so checking this here instead
    //
    if (wParam == IDC_DTP_ABS_DATE)
    {
        NMHDR * pHdr = (NMHDR *)lParam;
        if (pHdr->code == DTN_DATETIMECHANGE)
        {
            SetModified();
        }
    }

    //
    // Default behaviour -- go to the message map
    //
    return CPropertyPage::OnNotify(wParam, lParam, pResult);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\cnfgprts\ratppg.cpp ===
// RatPpg.cpp : Implementation of the CRatPropPage property page class.

#include "stdafx.h"
#include "cnfgprts.h"
#include "RatPpg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


IMPLEMENT_DYNCREATE(CRatPropPage, COlePropertyPage)


/////////////////////////////////////////////////////////////////////////////
// Message map

BEGIN_MESSAGE_MAP(CRatPropPage, COlePropertyPage)
	//{{AFX_MSG_MAP(CRatPropPage)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// Initialize class factory and guid

IMPLEMENT_OLECREATE_EX(CRatPropPage, "CNFGPRTS.RatPropPage.1",
	0xba634608, 0xb771, 0x11d0, 0x92, 0x96, 0, 0xc0, 0x4f, 0xb6, 0x67, 0x8b)


/////////////////////////////////////////////////////////////////////////////
// CRatPropPage::CRatPropPageFactory::UpdateRegistry -
// Adds or removes system registry entries for CRatPropPage

BOOL CRatPropPage::CRatPropPageFactory::UpdateRegistry(BOOL bRegister)
{
	if (bRegister)
		return AfxOleRegisterPropertyPageClass(
         AfxGetInstanceHandle(),
			m_clsid, 
         IDS_RAT_PPG,
         afxRegApartmentThreading
         );
	else
		return AfxOleUnregisterClass(m_clsid, NULL);
}


/////////////////////////////////////////////////////////////////////////////
// CRatPropPage::CRatPropPage - Constructor

CRatPropPage::CRatPropPage() :
	COlePropertyPage(IDD, IDS_RAT_PPG_CAPTION)
{
	//{{AFX_DATA_INIT(CRatPropPage)
	m_sz_caption = _T("");
	//}}AFX_DATA_INIT
}


/////////////////////////////////////////////////////////////////////////////
// CRatPropPage::DoDataExchange - Moves data between page and properties

void CRatPropPage::DoDataExchange(CDataExchange* pDX)
{
	//{{AFX_DATA_MAP(CRatPropPage)
	DDP_Text(pDX, IDC_CAPTIONEDIT, m_sz_caption, _T("Caption") );
	DDX_Text(pDX, IDC_CAPTIONEDIT, m_sz_caption);
	//}}AFX_DATA_MAP
	DDP_PostProcessing(pDX);
}


/////////////////////////////////////////////////////////////////////////////
// CRatPropPage message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\cnfgprts\ratsrvpg.cpp ===
// RatSrvPg.cpp : implementation file
//

#include "stdafx.h"
#include <iadmw.h>
#include "cnfgprts.h"

#include "parserat.h"
#include "RatData.h"

#include "RatSrvPg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CRatServicePage property page

IMPLEMENT_DYNCREATE(CRatServicePage, CPropertyPage)

CRatServicePage::CRatServicePage() : CPropertyPage(CRatServicePage::IDD)
{
	//{{AFX_DATA_INIT(CRatServicePage)
	m_sz_description = _T("");
	//}}AFX_DATA_INIT
}

CRatServicePage::~CRatServicePage()
{
}

void CRatServicePage::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CRatServicePage)
	DDX_Text(pDX, IDC_DESCRIPTION, m_sz_description);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CRatServicePage, CPropertyPage)
	//{{AFX_MSG_MAP(CRatServicePage)
	ON_BN_CLICKED(IDC_QUESTIONAIRE, OnQuestionaire)
	ON_BN_CLICKED(IDC_MOREINFO, OnMoreinfo)
	//}}AFX_MSG_MAP
    ON_COMMAND(ID_HELP_FINDER,  DoHelp)
    ON_COMMAND(ID_HELP,         DoHelp)
    ON_COMMAND(ID_CONTEXT_HELP, DoHelp)
    ON_COMMAND(ID_DEFAULT_HELP, DoHelp)
END_MESSAGE_MAP()

//---------------------------------------------------------------------------
void CRatServicePage::DoHelp()
    {
    WinHelp( HIDD_RATINGS_SERVICE );
    }

/////////////////////////////////////////////////////////////////////////////
// CRatServicePage message handlers

//--------------------------------------------------------------------------
void CRatServicePage::OnQuestionaire() 
    {
    // sometimes it takes a few moments of IE to get going
    CWaitCursor waitcursor;

    // get the URL of the ratings service place
    CString     szURL;
    szURL.LoadString( IDS_RATING_URL );

    // launch IE with the URL of the ratings service place
    ShellExecute(
        NULL,	// handle to parent window
        NULL,	// pointer to string that specifies operation to perform
        szURL,	// pointer to filename or folder name string
        NULL,	// pointer to string that specifies executable-file parameters 
        NULL,	// pointer to string that specifies default directory
        SW_SHOW 	// whether file is shown when opened
       );
    }

//--------------------------------------------------------------------------
void CRatServicePage::OnMoreinfo() 
    {
    // sometimes it takes a few moments of IE to get going
    CWaitCursor waitcursor;

    // if the string isn't there, fail
    if ( m_szMoreInfoURL.IsEmpty() )
        return;

    // go to the URL
    ShellExecute(
        NULL,	// handle to parent window
        NULL,	// pointer to string that specifies operation to perform
        m_szMoreInfoURL,	// pointer to filename or folder name string
        NULL,	// pointer to string that specifies executable-file parameters 
        NULL,	// pointer to string that specifies default directory
        SW_SHOW 	// whether file is shown when opened
       );
   }

//--------------------------------------------------------------------------
BOOL CRatServicePage::OnSetActive() 
    {
    UpdateData( TRUE );

    // put the proper display string into place
    m_sz_description = m_pRatData->rgbRats[m_pRatData->iRat]->etstrDesc.Get();
    // get the more info URL too
    m_szMoreInfoURL = m_pRatData->rgbRats[m_pRatData->iRat]->etstrRatingService.Get();

    UpdateData( FALSE );
    
    return CPropertyPage::OnSetActive();
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\cnfgprts\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by cnfgprts.rc
//
#define IDS_LOGUI                       1
#define IDB_LOGUI                       1
#define IDS_LOGUI_PPG                   2
#define IDB_RAT                         2
#define IDS_RAT                         3
#define IDB_APPS                        3
#define IDS_RAT_PPG                     4
#define IDS_APPS                        5
#define IDS_APPS_PPG                    6
#define IDC_DTP_ABS_DATE                3826
#define IDC_DTP_ABS_TIME                3827
#define IDS_LOGUI_PPG_CAPTION           10100
#define IDD_PROPPAGE_LOGUI              10100
#define IDS_RAT_PPG_CAPTION             10101
#define IDD_PROPPAGE_RAT                10101
#define IDS_APPS_PPG_CAPTION            10102
#define IDD_PROPPAGE_APPS               10102
#define IDS_RATING_URL                  10103
#define IDS_RAT_SHEETTITLE              10104
#define IDS_RAT_READFILE_ERROR          10105
#define IDS_RAT_FINDFILE_ERROR          10106
#define IDS_RAT_NAME_ERROR              10107
#define IDS_HTTP_HEADER                 10108
#define IDS_APP_SHEETTITLE              10109
#define IDS_LOG_INVALID_DIR             10110
#define IDS_APP_DEFAULT_ERROR           10110
#define IDS_APP_EXTENSION               10111
#define IDS_APP_EXE_PATH                10112
#define IDS_APP_MAP_REMOVE_CONFIRM      10113
#define IDS_APP_MAP_INVALID_PATH        10114
#define IDS_APP_MAP_INVALID_EXT         10115
#define IDS_ELLIPSIS                    10116
#define IDS_APP_MAP_FILTER              10117
#define IDS_HELPLOC_HELP                10118
#define IDS_APP_ONLY_ONE                10119
#define IDS_EXPIRE_SET_PAST             10120
#define IDS_LOGUI_DLL                   10121
#define IDS_APP_EXCLUSIONS              10122
#define IDS_APP_ERR_TITLE               10123
#define IDS_RAT_ERR_TITLE               10124
#define IDS_LOG_ERR_TITLE               10125
#define IDS_APP_ERR_EXT_REQUIRED        10126
#define IDS_SCRIPTS                     10127
#define IDS_NO_DATE_SELECTED            10128
#define IDS_ERR_LOG_PLUGIN              10129
#define IDS_APP_MAP_USE_VALID_DRIVE     10130
#define IDS_VERBS_ALL                   10131
#define IDS_ERR_NO_VERBS                10132
#define IDC_CAPTIONEDIT                 10201
#define IDD_LOG_GENERAL                 10201
#define IDC_LOG_AUTO_OPEN               10201
#define IDC_LOG_DAILY                   10202
#define IDD_RAT_SETRATING               10202
#define IDC_LOG_WEEKLY                  10203
#define IDD_RAT_SERVICE                 10203
#define IDI_ICON1                       10203
#define IDI_GLOBE                       10203
#define IDC_LOG_MONTHLY                 10204
#define IDC_LOG_WHENSIZE                10205
#define IDD_RAT_EXPIRE                  10205
#define IDC_SPIN                        10207
#define IDC_LOG_SIZE                    10208
#define IDC_LOG_DIRECTORY               10209
#define IDB_RATLIST                     10209
#define IDC_BROWSE                      10210
#define IDC_LOG_SIZE_UNITS              10211
#define IDC_LOG_FILE_SAMPLE             10212
#define IDC_TREE                        10213
#define IDD_APP_ASPMAIN                 10214
#define IDC_SLIDER                      10215
#define IDD_APP_ASPDEBUG                10215
#define IDC_DESCRIPTION                 10216
#define IDD_APP_APPMAP                  10216
#define IDD_APP_OTHER                   10217
#define IDC_NAME_PERSON                 10218
#define IDD_APP_EDITMAP                 10218
#define IDC_MOD_DATE                    10219
#define IDC_EXPIRES                     10220
#define IDD_APP_PROC                    10220
#define IDC_DATE_BUTTON                 10221
#define IDD_APP_RECYCLE                 10221
#define IDC_ENABLE                      10222
#define IDD_TIME_PICKER                 10222
#define IDC_QUESTIONAIRE                10223
#define IDC_MOREINFO                    10224
#define IDC_RATSYSTEM                   10225
#define IDC_TITLE                       10226
#define IDC_STATIC_ICON                 10227
#define IDC_STATIC_CATEGORY             10228
#define IDC_STATIC_RATING               10229
#define IDC_STATIC_OPTIONAL             10230
#define IDC_STATIC_EMAIL                10231
#define IDC_STATIC_MOD_DATE             10232
#define IDC_STATIC_EXPIRES              10233
#define IDC_MSACALCTRL                  10234
#define IDC_CHECK1                      10235
#define IDC_CHK_SCRIPT_ENGINE           10235
#define IDC_CHK_EXCEPTION_CATCH         10235
#define IDC_RECYCLE_TIMER               10235
#define IDC_CHECK2                      10236
#define IDC_CHK_ENABLE_BUFFERING        10236
#define IDC_CHK_FILE_EXISTS             10236
#define IDC_CHK_JAVA_DEBUG              10236
#define IDC_CHECK3                      10237
#define IDC_CHK_ENABLE_PARENTS          10237
#define IDC_CHECK4                      10238
#define IDC_CHK_WRITE_FAIL_TO_LOG       10238
#define IDC_CHECK5                      10239
#define IDC_EDIT1                       10240
#define IDC_EDT_SESSION_TIMEOUT         10240
#define IDC_EDT_EXECUTABLE              10240
#define IDC_TIMESPAN                    10240
#define IDC_EDIT2                       10241
#define IDC_EDT_NUM_ENGINES             10241
#define IDC_EDT_EXTENSION               10241
#define IDC_REQUEST_LIMIT               10241
#define IDC_COMBO1                      10242
#define IDC_CMBO_LANGUAGES              10242
#define IDC_EDIT3                       10243
#define IDC_EDT_SCRIPT_TIMEOUT          10243
#define IDC_EDT_EXCLUSIONS              10243
#define IDC_RADIO1                      10244
#define IDC_RDO_CACHE_ALL               10244
#define IDC_RADIO_ALL_VERBS             10244
#define IDC_RADIO2                      10245
#define IDC_RDO_CACHE_SIZE              10245
#define IDC_RADIO_LIMIT_VERBS           10245
#define IDC_EDIT4                       10246
#define IDC_EDT_CACHE_SIZE              10246
#define IDC_LIST1                       10247
#define IDC_LIST                        10247
#define IDC_RDO_CACHE_NONE              10247
#define IDC_BUTTON1                     10248
#define IDC_ADD                         10248
#define IDC_ADD_TIME                    10248
#define IDC_BUTTON2                     10249
#define IDC_REMOVE                      10249
#define IDC_BUTTON3                     10250
#define IDC_EDIT                        10250
#define IDC_CHK_ENABLE                  10251
#define IDC_CHK_SERVER_DEBUG            10251
#define IDC_CHK_BREAK                   10252
#define IDC_CHK_CLIENT_DEBUG            10252
#define IDC_RDO_SEND_DETAILED_ERROR     10253
#define IDC_RDO_SEND_DEF_ERROR          10254
#define IDC_DEFAULT_ERROR               10255
#define IDC_CHK_POOL_ODBC               10256
#define IDC_ODBC_TIMEOUT                10257
#define IDC_CGI_SECONDS                 10258
#define IDC_ODBC_TITLE                  10259
#define IDC_ODBC_SECONDS                10260
#define IDC_CGI_UNITS                   10261
#define IDC_ODBC_UNITS                  10262
#define IDC_CHK_ENABLE_SESSION          10263
#define IDC_SESSION_TITLE               10264
#define IDC_SESSION_UNITS               10265
#define IDC_CACHE_UNITS                 10266
#define IDC_LANG_TITLE                  10267
#define IDC_CHK_CACHE_ISAPI             10268
#define ID_HELPBTN                      10269
#define IDC_EDT_LANGUAGES               10270
#define IDC_RECYCLE_TIMESPAN            10271
#define IDC_RECYCLE_REQUESTS            10272
#define IDC_TIMES_LIST                  10273
#define IDC_TIME_PICKER                 10274

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        10223
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         10275
#define _APS_NEXT_SYMED_VALUE           10101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\cnfgprts\ratsrvpg.h ===
// RatSrvPg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CRatServicePage dialog

class CRatServicePage : public CPropertyPage
{
	DECLARE_DYNCREATE(CRatServicePage)

// Construction
public:
	CRatServicePage();
	~CRatServicePage();

    // the data
    CRatingsData*   m_pRatData;


// Dialog Data
	//{{AFX_DATA(CRatServicePage)
	enum { IDD = IDD_RAT_SERVICE };
	CString	m_sz_description;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CRatServicePage)
	public:
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CRatServicePage)
	afx_msg void OnQuestionaire();
	afx_msg void OnMoreinfo();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

    void DoHelp();

    CString m_szMoreInfoURL;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\cnfgprts\ratppg.h ===
// RatPpg.h : Declaration of the CRatPropPage property page class.

////////////////////////////////////////////////////////////////////////////
// CRatPropPage : See RatPpg.cpp.cpp for implementation.

class CRatPropPage : public COlePropertyPage
{
	DECLARE_DYNCREATE(CRatPropPage)
	DECLARE_OLECREATE_EX(CRatPropPage)

// Constructor
public:
	CRatPropPage();

// Dialog Data
	//{{AFX_DATA(CRatPropPage)
	enum { IDD = IDD_PROPPAGE_RAT };
	CString	m_sz_caption;
	//}}AFX_DATA

// Implementation
protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support

// Message maps
protected:
	//{{AFX_MSG(CRatPropPage)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\cnfgprts\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxctl.h>         // MFC support for OLE Controls
#include <afxdtctl.h>
#include <atlbase.h>

// Delete the two includes below if you do not wish to use the MFC
//  database classes
#ifndef _UNICODE
#include <afxdb.h>			// MFC database classes
#include <afxdao.h>			// MFC DAO database classes
#endif //_UNICODE

#include <afxcmn.h>			// MFC support for Windows Common Controls
#include <afxtempl.h>

#include <assert.h>

#include <aclapi.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\common\common.h ===
/*++

   Copyright    (c)    1994-1999    Microsoft Corporation

   Module  Name :

        comprop.h

   Abstract:

        Common properties header file

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/



#ifndef __COMPROP_H__
#define __COMPROP_H__

#ifdef _COMEXPORT
    #define COMDLL __declspec(dllexport)
#elif defined(_COMIMPORT)
    #define COMDLL __declspec(dllimport)
#elif defined(_COMSTATIC)
    #define COMDLL
#else
    #error "Must define either _COMEXPORT, _COMIMPORT or _COMSTATIC"
#endif // _COMEXPORT

#pragma warning(disable: 4275)
#pragma warning(disable: 4251)

#include <lmcons.h>
#include <iis64.h>
#include "inetcom.h"
#include "iisinfo.h"
#include "svcloc.h"

#include "..\common\resource.h"


//
// Memory Allocation Macros
//
#define AllocMem(cbSize)\
    ::LocalAlloc(LPTR, cbSize)

#define FreeMem(lp)\
    ::LocalFree(lp)

#define AllocMemByType(citems, type)\
    (type *)AllocMem(citems * sizeof(type))



//
// Program flow macros
//
#define FOREVER for(;;)

#define BREAK_ON_ERR_FAILURE(err)\
    if (err.Failed()) break;

#define BREAK_ON_NULL_PTR(lp)\
    if (lp == NULL) break;

//
// Safe allocators
//
#define SAFE_DELETE(obj)\
    if (obj != NULL) do { delete obj; obj = NULL; } while(0)

#define SAFE_DELETE_OBJECT(obj)\
    if (obj != NULL) do { DeleteObject(obj); obj = NULL; } while(0)

#define SAFE_FREEMEM(lp)\
    if (lp != NULL) do { FreeMem(lp); lp = NULL; } while(0)

#define SAFE_SYSFREESTRING(lp)\
    if (lp != NULL) do { ::SysFreeString(lp); lp = NULL; } while(0)

#define SAFE_AFXFREELIBRARY(hLib)\
    if (hLib != NULL) do { ::AfxFreeLibrary(hLib); hLib = NULL; } while(0)

#define SAFE_RELEASE(lpInterface)\
    if (lpInterface != NULL) do { lpInterface->Release(); lpInterface = NULL; } while(0)


//
// General purpose files
//
#include "debugafx.h"
#include "objplus.h"
#include "strfn.h"
#include "odlbox.h"
#include "msg.h"
#include "mdkeys.h"
#include "ipa.h"
#include "wizard.h"
//#include "registry.h"
#include "ddxv.h"
#include "objpick.h"
#include "accentry.h"
#include "sitesecu.h"
#include "utcls.h"
//#include "ipctl.h"
//#include "dtp.h"
#include "dirbrows.h"

extern "C" void WINAPI InitCommonDll();

#endif // __COMPROP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\common\accentry.cpp ===
/*++

   Copyright    (c)    1994-1999    Microsoft Corporation

   Module  Name :

        accentry.cpp

   Abstract:

        CAccessEntry class implementation

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:
         1/9/2000       sergeia     Cleaned out from usrbrows.cpp

--*/

//
// Include Files
//
#include "stdafx.h"
#include <iiscnfgp.h>
#include "common.h"
#include "objpick.h"
#include "accentry.h"



#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif


#define new DEBUG_NEW
#define SZ_USER_CLASS           _T("user")
#define SZ_GROUP_CLASS          _T("group")

BOOL
CAccessEntry::LookupAccountSid(
    OUT CString & strFullUserName,
    OUT int & nPictureID,
    IN  PSID pSid,
    IN  LPCTSTR lpstrSystemName /* OPTIONAL */
    )
/*++

Routine Description:

    Get a full user name and picture ID from the SID
    
Arguments:

    CString &strFullUserName        : Returns the user name
    int & nPictureID                : Returns offset into the imagemap that
                                      represents the account type.
    PSID pSid                       : Input SID pointer
    LPCTSTR lpstrSystemName         : System name or NULL
     
Return Value:

    TRUE for success, FALSE for failure.

--*/
{
    DWORD cbUserName = PATHLEN * sizeof(TCHAR);
    DWORD cbRefDomainName = PATHLEN * sizeof(TCHAR);

    CString strUserName;
    CString strRefDomainName;
    SID_NAME_USE SidToNameUse;

    LPTSTR lpUserName = strUserName.GetBuffer(PATHLEN);
    LPTSTR lpRefDomainName = strRefDomainName.GetBuffer(PATHLEN);
    BOOL fLookUpOK = ::LookupAccountSid(
        lpstrSystemName, 
        pSid, 
        lpUserName,
        &cbUserName, 
        lpRefDomainName, 
        &cbRefDomainName, 
        &SidToNameUse
        );

    strUserName.ReleaseBuffer();
    strRefDomainName.ReleaseBuffer();

    strFullUserName.Empty();

    if (fLookUpOK)
    {
        if (!strRefDomainName.IsEmpty()
            && strRefDomainName.CompareNoCase(_T("BUILTIN")))
        {
            strFullUserName += strRefDomainName;
            strFullUserName += "\\";
        }

        strFullUserName += strUserName;

        nPictureID = SidToNameUse;
    }
    else
    {
        strFullUserName.LoadString(IDS_UNKNOWN_USER);
        nPictureID = SidTypeUnknown;
    }

    //
    // SID_NAME_USE is 1-based
    //
    --nPictureID ;

    return fLookUpOK;
}



CAccessEntry::CAccessEntry(
    IN LPVOID pAce,
    IN BOOL fResolveSID
    )
/*++

Routine Description:

    Construct from an ACE

Arguments:

    LPVOID pAce         : Pointer to ACE object
    BOOL fResolveSID    : TRUE to resolve the SID immediately

Return Value:

    N/A

--*/
    : m_pSid(NULL),
      m_fSIDResolved(FALSE),
      m_fDeletable(TRUE),
      m_fInvisible(FALSE),
      m_nPictureID(SidTypeUnknown-1),   // SID_NAME_USE is 1-based
      m_lpstrSystemName(NULL),
      m_accMask(0L),
      m_fDeleted(FALSE),
      m_strUserName()
{
    MarkEntryAsClean();

    PACE_HEADER ph = (PACE_HEADER)pAce;
    PSID pSID = NULL;

    switch(ph->AceType)
    {
    case ACCESS_ALLOWED_ACE_TYPE:
        pSID = (PSID)&((PACCESS_ALLOWED_ACE)pAce)->SidStart;
        m_accMask = ((PACCESS_ALLOWED_ACE)pAce)->Mask;
        break;
        
    case ACCESS_DENIED_ACE_TYPE:
    case SYSTEM_AUDIT_ACE_TYPE:
    case SYSTEM_ALARM_ACE_TYPE:           
    default:
        //
        // Not supported!
        //
        ASSERT_MSG("Unsupported ACE type");
        break;
    }

    if (pSID == NULL)
    {
        return;
    }

    //
    // Allocate a new copy of the sid.
    //
    DWORD cbSize = ::RtlLengthSid(pSID);
    m_pSid = (PSID)AllocMem(cbSize); 
    if (m_pSid != NULL)
    {
       DWORD err = ::RtlCopySid(cbSize, m_pSid, pSID);
       ASSERT(err == ERROR_SUCCESS);
    }

    //
    // Only the non-deletable administrators have execute
    // privileges
    //
    m_fDeletable = (m_accMask & FILE_EXECUTE) == 0L;

    //
    // Enum_keys is a special access right that literally "everyone"
    // has, but it doesn't designate an operator, so it should not
    // show up in the operator list if this is the only right it has.
    //
    m_fInvisible = (m_accMask == MD_ACR_ENUM_KEYS);
    
    //SetAccessMask(lpAccessEntry);

    if (fResolveSID)
    {
        ResolveSID();
    }
}



CAccessEntry::CAccessEntry(
    IN ACCESS_MASK accPermissions,
    IN PSID pSid,
    IN LPCTSTR lpstrSystemName,     OPTIONAL
    IN BOOL fResolveSID
    )
/*++

Routine Description:

    Constructor from access permissions and SID.

Arguments:

    ACCESS_MASK accPermissions      : Access mask
    PSID pSid                       : Pointer to SID
    LPCTSTR lpstrSystemName         : Optional system name
    BOOL fResolveSID                : TRUE to resolve SID immediately

Return Value:

    N/A

--*/
    : m_pSid(NULL),
      m_fSIDResolved(FALSE),
      m_fDeletable(TRUE),
      m_fInvisible(FALSE),
      m_fDeleted(FALSE),
      m_nPictureID(SidTypeUnknown-1),   // SID_NAME_USE is 1-based
      m_strUserName(),
      m_lpstrSystemName(NULL),
      m_accMask(accPermissions)
{
    MarkEntryAsClean();

    //
    // Allocate a new copy of the sid.
    //
    DWORD cbSize = ::RtlLengthSid(pSid);
    m_pSid = (PSID)AllocMem(cbSize); 
    if (m_pSid != NULL)
    {
       DWORD err = ::RtlCopySid(cbSize, m_pSid, pSid);
       ASSERT(err == ERROR_SUCCESS);
    }
    if (lpstrSystemName != NULL)
    {
        m_lpstrSystemName = AllocTString(::lstrlen(lpstrSystemName) + 1);
        if (m_lpstrSystemName != NULL)
        {
           ::lstrcpy(m_lpstrSystemName, lpstrSystemName);
        }
    }

    if (fResolveSID)
    {
        TRACEEOLID("Bogus SID");
        ResolveSID();
    }
}



CAccessEntry::CAccessEntry(
    IN PSID pSid,
    IN LPCTSTR pszUserName,
    IN LPCTSTR pszClassName
    )
/*++

Routine Description:

    Constructor from access sid and user/class name.

Arguments:

    PSID pSid,              Pointer to SID
    LPCTSTR pszUserName     User name
    LPCTSTR pszClassName    User Class name

Return Value:

    N/A

--*/
    : m_pSid(NULL),
      m_fSIDResolved(pszUserName != NULL),
      m_fDeletable(TRUE),
      m_fInvisible(FALSE),
      m_fDeleted(FALSE),
      m_nPictureID(SidTypeUnknown-1),   // SID_NAME_USE is 1-based
      m_strUserName(pszUserName),
      m_lpstrSystemName(NULL),
      m_accMask(0)
{
    MarkEntryAsClean();

    //
    // Allocate a new copy of the sid.
    //
    DWORD cbSize = ::RtlLengthSid(pSid);
    m_pSid = (PSID)AllocMem(cbSize); 
    if (m_pSid != NULL)
    {
       DWORD err = ::RtlCopySid(cbSize, m_pSid, pSid);
       ASSERT(err == ERROR_SUCCESS);
    }
    if (lstrcmpi(SZ_USER_CLASS, pszClassName) == 0)
    {
        m_nPictureID = SidTypeUser - 1;
    }
    else if (lstrcmpi(SZ_GROUP_CLASS, pszClassName) == 0)
    {
        m_nPictureID = SidTypeGroup - 1;
    }
}




CAccessEntry::CAccessEntry(
    IN CAccessEntry & ae
    )
/*++

Routine Description:

    Copy constructor

Arguments:

    CAccessEntry & ae       : Source to copy from

Return Value:

    N/A

--*/
    : m_fSIDResolved(ae.m_fSIDResolved),
      m_fDeletable(ae.m_fDeletable),
      m_fInvisible(ae.m_fInvisible),
      m_fDeleted(ae.m_fDeleted),
      m_fDirty(ae.m_fDirty),
      m_nPictureID(ae.m_nPictureID),
      m_strUserName(ae.m_strUserName),
      m_lpstrSystemName(ae.m_lpstrSystemName),
      m_accMask(ae.m_accMask)
{
    DWORD cbSize = ::RtlLengthSid(ae.m_pSid);
    m_pSid = (PSID)AllocMem(cbSize); 
    if (m_pSid != NULL)
    {
       DWORD err = ::RtlCopySid(cbSize, m_pSid, ae.m_pSid);
       ASSERT(err == ERROR_SUCCESS);
    }
}




CAccessEntry::~CAccessEntry()
/*++

Routine Description:

    Destructor

Arguments:

    N/A

Return Value:

    N/A

--*/
{
    TRACEEOLID(_T("Destroying local copy of the SID"));
    ASSERT_PTR(m_pSid);
    FreeMem(m_pSid);

    if (m_lpstrSystemName != NULL)
    {
        FreeMem(m_lpstrSystemName);
    }
}




BOOL
CAccessEntry::ResolveSID()
/*++

Routine Description:

    Look up the user name and type.

Arguments:

    None

Return Value:

    TRUE for success, FALSE for failure.

Notes:

    This could take some time.

--*/
{
    //
    // Even if it fails, it will be considered
    // resolved
    //
    m_fSIDResolved = TRUE;   

    return CAccessEntry::LookupAccountSid(
        m_strUserName,
        m_nPictureID,
        m_pSid,
        m_lpstrSystemName
        );
}



void 
CAccessEntry::AddPermissions(
    IN ACCESS_MASK accNewPermissions
    )
/*++

Routine Description:

   Add permissions to this entry.

Arguments:

    ACCESS_MASK accNewPermissions       : New access permissions to be added

Return Value:

    None.

--*/
{
    m_accMask |= accNewPermissions;
    m_fInvisible = (m_accMask == MD_ACR_ENUM_KEYS);
    m_fDeletable = (m_accMask & FILE_EXECUTE) == 0L;
    MarkEntryAsChanged();
}



void 
CAccessEntry::RemovePermissions(
    IN ACCESS_MASK accPermissions
    )
/*++

Routine Description:

    Remove permissions from this entry.

Arguments:

    ACCESS_MASK accPermissions          : Access permissions to be taken away

--*/
{
    m_accMask &= ~accPermissions;
    MarkEntryAsChanged();
}

//
// Helper Functions
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



PSID
GetOwnerSID()
/*++

Routine Description:

    Return a pointer to the primary owner SID we're using.

Arguments:

    None

Return Value:

    Pointer to owner SID.

--*/
{
    PSID pSID = NULL;

    SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;

    if (!::AllocateAndInitializeSid(
        &NtAuthority, 
        2,
        SECURITY_BUILTIN_DOMAIN_RID,
        DOMAIN_ALIAS_RID_ADMINS, 
        0, 0, 0, 0, 0, 0,
        &pSID
        ))
    {
        TRACEEOLID("Unable to get primary SID " << ::GetLastError());
    }

    return pSID;
}



BOOL
BuildAclBlob(
    IN  CObListPlus & oblSID,
    OUT CBlob & blob
    )
/*++

Routine Description:

    Build a security descriptor blob from the access entries in the oblist

Arguments:

    CObListPlus & oblSID    : Input list of access entries
    CBlob & blob            : Output blob
    
Return Value:

    TRUE if the list is dirty.  If the list had no entries marked
    as dirty, the blob generated will be empty, and this function will
    return FALSE.

Notes:

    Entries marked as deleted will not be added to the list.

--*/
{
    ASSERT(blob.IsEmpty());

    BOOL fAclDirty = FALSE;
    CAccessEntry * pEntry;

    DWORD dwAclSize = sizeof(ACL) - sizeof(DWORD);
    CObListIter obli(oblSID);
    int cItems = 0;

    while(NULL != (pEntry = (CAccessEntry *)obli.Next()))
    {
        if (!pEntry->IsDeleted())
        {
            dwAclSize += GetLengthSid(pEntry->GetSid());
            dwAclSize += sizeof(ACCESS_ALLOWED_ACE);
            ++cItems;
        }

        if (pEntry->IsDirty())
        {
            fAclDirty = TRUE;
        }
    }

    if (fAclDirty)
    {
        //
        // Build the acl
        //
        PACL pacl = NULL;

        if (cItems > 0 && dwAclSize > 0)
        {
            pacl = (PACL)AllocMem(dwAclSize);
            if (pacl != NULL)
            {
               if (InitializeAcl(pacl, dwAclSize, ACL_REVISION))
               {
                   obli.Reset();    
                   while(NULL != (pEntry = (CAccessEntry *)obli.Next()))
                   {
                       if (!pEntry->IsDeleted())
                       {
                           VERIFY(AddAccessAllowedAce(
                               pacl, 
                               ACL_REVISION, 
                               pEntry->QueryAccessMask(),
                               pEntry->GetSid()
                               ));
                       }
                   }
               }
            }
            else
            {
               return FALSE;
            }
        }

         //
         // Build the security descriptor
         //
         PSECURITY_DESCRIPTOR pSD = 
             (PSECURITY_DESCRIPTOR)AllocMem(SECURITY_DESCRIPTOR_MIN_LENGTH);
         if (pSD != NULL)
         {
            VERIFY(InitializeSecurityDescriptor(pSD, SECURITY_DESCRIPTOR_REVISION));
            VERIFY(SetSecurityDescriptorDacl(pSD, TRUE, pacl, FALSE));
         }
         else
         {
            return FALSE;
         }

         //
         // Set owner and primary group
         //
         PSID pSID = GetOwnerSID();
         ASSERT(pSID);
         VERIFY(SetSecurityDescriptorOwner(pSD, pSID, TRUE));
         VERIFY(SetSecurityDescriptorGroup(pSD, pSID, TRUE));
     
         //
         // Convert to self-relative
         //
         PSECURITY_DESCRIPTOR pSDSelfRelative = NULL;
         DWORD dwSize = 0L;
         MakeSelfRelativeSD(pSD, pSDSelfRelative, &dwSize);
         pSDSelfRelative = AllocMem(dwSize);
         if (pSDSelfRelative != NULL)
         {
            MakeSelfRelativeSD(pSD, pSDSelfRelative, &dwSize);

            //
            // Blob takes ownership 
            //
            blob.SetValue(dwSize, (PBYTE)pSDSelfRelative, FALSE);
         }

         //
         // Clean up
         //
         FreeMem(pSD);
         FreeSid(pSID);
    }

    return fAclDirty;
}



DWORD
BuildAclOblistFromBlob(
    IN  CBlob & blob,
    OUT CObListPlus & oblSID
    )
/*++

Routine Description:

    Build an oblist of access entries from a security descriptor blob

Arguments:

    CBlob & blob            : Input blob
    CObListPlus & oblSID    : Output oblist of access entries
    
Return Value:

    Error return code

--*/
{
    PSECURITY_DESCRIPTOR pSD = NULL;

    if (!blob.IsEmpty())
    {
        pSD = (PSECURITY_DESCRIPTOR)blob.GetData();
    }

    if (pSD == NULL)
    {
        //
        // Empty...
        //
        return ERROR_SUCCESS;
    }

    if (!IsValidSecurityDescriptor(pSD))
    {
        return ::GetLastError();
    }

    ASSERT(GetSecurityDescriptorLength(pSD) == blob.GetSize());

    PACL pacl = NULL;
    BOOL fDaclPresent = FALSE;
    BOOL fDaclDef= FALSE;

    VERIFY(GetSecurityDescriptorDacl(pSD, &fDaclPresent, &pacl, &fDaclDef));

    if (!fDaclPresent || pacl == NULL)
    {
        return ERROR_SUCCESS;
    }

    if (!IsValidAcl(pacl))
    {
        return GetLastError();
    }

    CError err;

    for (WORD w = 0; w < pacl->AceCount; ++w)
    {
        PVOID pAce;

        if (GetAce(pacl, w, &pAce))
        {
            CAccessEntry * pEntry = new CAccessEntry(pAce, TRUE);

            if (pEntry)
            {
                oblSID.AddTail(pEntry);
            }
            else
            {
                TRACEEOLID("BuildAclOblistFromBlob: OOM");
                err = ERROR_NOT_ENOUGH_MEMORY;
                break;
            }
        }
        else
        {
            //
            // Save last error, but continue
            //
            err.GetLastWinError();
        }
    }

    //
    // Return last error
    //
    return err;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\common\ddxv.h ===
/*++

   Copyright    (c)    1994-1999    Microsoft Corporation

   Module  Name :

        ddxv.h

   Abstract:

        DDX/DDV Routine definitions

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager (cluster edition)

   Revision History:

--*/

#ifndef _DDXV_H_
#define _DDXV_H_



//
// Helper macro to convert ID of dialog child control to window handle
//
#define CONTROL_HWND(nID) (::GetDlgItem(m_hWnd, nID))



//
// Dummy password
//
extern LPCTSTR COMDLL g_lpszDummyPassword;

//
// Enforce minimum string length of a CString
//
void 
COMDLL
AFXAPI DDV_MinChars(
    IN CDataExchange * pDX, 
    IN CString const & value, 
    IN int nChars
    );

//
// Enforce minimum and maximum string lengths of a CString
//
void 
COMDLL
AFXAPI DDV_MinMaxChars(
    IN CDataExchange * pDX, 
    IN CString const & value,
    IN int nMinChars,
    IN int nMaxChars
    );

//
// Spin control ddx
//
void 
COMDLL
AFXAPI DDX_Spin(
    IN CDataExchange * pDX, 
    IN int nIDC, 
    IN OUT int & value
    );

//
// Enforce min/max spin control range
//
void 
COMDLL
AFXAPI DDV_MinMaxSpin(
    IN CDataExchange * pDX, 
    IN HWND hWndControl,
    IN int nLowerRange,
    IN int nUpperRange
    );

//
// Similar to DDX_Text -- but always display a dummy string.
//
void 
COMDLL
AFXAPI DDX_Password(
    IN CDataExchange * pDX, 
    IN int nIDC, 
    IN OUT CString & value,
    IN LPCTSTR lpszDummy
    );


//
// DDX_Text for CILong
//
void 
COMDLL
AFXAPI DDX_Text(
    IN CDataExchange * pDX, 
    IN int nIDC, 
    IN OUT CILong & value
    );



class COMDLL CConfirmDlg : public CDialog
/*++

Class Description:

    Confirmation dialog -- brought up by the password ddx whenever
    password confirmation is necessary.

Public Interface:

    CConfirmDlg   : Constructor

    GetPassword   : Password entered in the dialog

--*/
{
//
// Construction
//
public:
    CConfirmDlg(
        IN CWnd * pParent = NULL
        );

public:
    //
    // Get the password that was entered in the dialog
    //
    CString & GetPassword() { return m_strPassword; }

//
// Dialog Data
//
protected:
    //{{AFX_DATA(CConfirmDlg)
    enum { IDD = IDD_CONFIRM_PASSWORD };
    CString m_strPassword;
    //}}AFX_DATA

//
// Overrides
//
protected:
    //{{AFX_VIRTUAL(CConfirmDlg)
    protected:
    virtual void DoDataExchange(CDataExchange * pDX);
    //}}AFX_VIRTUAL

//
// Implementation
//
protected:
    //{{AFX_MSG(CConfirmDlg)
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};



#endif // _DDXV_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\common\commsg.h ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1994-1998           **/
/**********************************************************************/

/*
    wsockmsg.h

    This file is generated by the MC tool from the WSOCKMSG.MC message
    file.

    NOTE: Definitions below should match definitions in winsock.h

*/


#ifndef _WSOCKMSG_H_
#define _WSOCKMSG_H_


//
//  Values are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-+-----------------------+-------------------------------+
//  |Sev|C|R|     Facility          |               Code            |
//  +---+-+-+-----------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      R - is a reserved bit
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//
//
// Define the facility codes
//


//
// Define the severity codes
//


//
// MessageId: WSABASEERR
//
// MessageText:
//
//  WSABASEERR
//
#define WSABASEERR                       0x00002710L

//
// MessageId: WSAEINTR
//
// MessageText:
//
//  Interrupted system call.
//
#define WSAEINTR                         0x00002714L

//
// MessageId: WSAEBADF
//
// MessageText:
//
//  Bad file number.
//
#define WSAEBADF                         0x00002719L

//
// MessageId: WSAEACCES
//
// MessageText:
//
//  Access denied.
//
#define WSAEACCES                        0x0000271DL

//
// MessageId: WSAEFAULT
//
// MessageText:
//
//  Bad address.
//
#define WSAEFAULT                        0x0000271EL

//
// MessageId: WSAEINVAL
//
// MessageText:
//
//  Invalid argument.
//
#define WSAEINVAL                        0x00002726L

//
// MessageId: WSAEMFILE
//
// MessageText:
//
//  Too many open files.
//
#define WSAEMFILE                        0x00002728L

//
// MessageId: WSAEWOULDBLOCK
//
// MessageText:
//
//  Operation would block.
//
#define WSAEWOULDBLOCK                   0x00002733L

//
// MessageId: WSAEINPROGRESS
//
// MessageText:
//
//  Operation now in progress.
//
#define WSAEINPROGRESS                   0x00002734L

//
// MessageId: WSAEALREADY
//
// MessageText:
//
//  Operation already in progress.
//
#define WSAEALREADY                      0x00002735L

//
// MessageId: WSAENOTSOCK
//
// MessageText:
//
//  Socket operation on non-socket.
//
#define WSAENOTSOCK                      0x00002736L

//
// MessageId: WSAEDESTADDRREQ
//
// MessageText:
//
//  Destination address required.
//
#define WSAEDESTADDRREQ                  0x00002737L

//
// MessageId: WSAEMSGSIZE
//
// MessageText:
//
//  Message too long.
//
#define WSAEMSGSIZE                      0x00002738L

//
// MessageId: WSAEPROTOTYPE
//
// MessageText:
//
//  Protocol is wrong type for socket.
//
#define WSAEPROTOTYPE                    0x00002739L

//
// MessageId: WSAENOPROTOOPT
//
// MessageText:
//
//  Bad protocol option.
//
#define WSAENOPROTOOPT                   0x0000273AL

//
// MessageId: WSAEPROTONOSUPPORT
//
// MessageText:
//
//  Protocol not supported.
//
#define WSAEPROTONOSUPPORT               0x0000273BL

//
// MessageId: WSAESOCKNOSUPPORT
//
// MessageText:
//
//  Socket type not supported.
//
#define WSAESOCKNOSUPPORT                0x0000273CL

//
// MessageId: WSAEOPNOTSUPP
//
// MessageText:
//
//  Operation not supported on socket.
//
#define WSAEOPNOTSUPP                    0x0000273DL

//
// MessageId: WSAEPFNOSUPPORT
//
// MessageText:
//
//  Protocol family not supported.
//
#define WSAEPFNOSUPPORT                  0x0000273EL

//
// MessageId: WSAEAFNOSUPPORT
//
// MessageText:
//
//  Address family not supported by protocol family.
//
#define WSAEAFNOSUPPORT                  0x0000273FL

//
// MessageId: WSAEADDRINUSE
//
// MessageText:
//
//  Address already in use.
//
#define WSAEADDRINUSE                    0x00002740L

//
// MessageId: WSAEADDRNOTAVAIL
//
// MessageText:
//
//  Can't assign requested address.
//
#define WSAEADDRNOTAVAIL                 0x00002741L

//
// MessageId: WSAENETDOWN
//
// MessageText:
//
//  Network is down.
//
#define WSAENETDOWN                      0x00002742L

//
// MessageId: WSAENETUNREACH
//
// MessageText:
//
//  ICMP network unreachable.
//
#define WSAENETUNREACH                   0x00002743L

//
// MessageId: WSAENETRESET
//
// MessageText:
//
//  Network was reset.
//
#define WSAENETRESET                     0x00002744L

//
// MessageId: WSAECONNABORTED
//
// MessageText:
//
//  Software caused connection abort.
//
#define WSAECONNABORTED                  0x00002745L

//
// MessageId: WSAECONNRESET
//
// MessageText:
//
//  Connection reset by peer.
//
#define WSAECONNRESET                    0x00002746L

//
// MessageId: WSAENOBUFS
//
// MessageText:
//
//  No buffer space is supported.
//
#define WSAENOBUFS                       0x00002747L

//
// MessageId: WSAEISCONN
//
// MessageText:
//
//  Socket is already connected.
//
#define WSAEISCONN                       0x00002748L

//
// MessageId: WSAENOTCONN
//
// MessageText:
//
//  Socket is not connected.
//
#define WSAENOTCONN                      0x00002749L

//
// MessageId: WSAESHUTDOWN
//
// MessageText:
//
//  Can't send after socket shutdown.
//
#define WSAESHUTDOWN                     0x0000274AL

//
// MessageId: WSAETOOMANYREFS
//
// MessageText:
//
//  Too many references.
//
#define WSAETOOMANYREFS                  0x0000274BL

//
// MessageId: WSAETIMEDOUT
//
// MessageText:
//
//  Connection timed out.
//
#define WSAETIMEDOUT                     0x0000274CL

//
// MessageId: WSAECONNREFUSED
//
// MessageText:
//
//  Connection refused.
//
#define WSAECONNREFUSED                  0x0000274DL

//
// MessageId: WSAELOOP
//
// MessageText:
//
//  Too many levels of symbolic links.
//
#define WSAELOOP                         0x0000274EL

//
// MessageId: WSAENAMETOOLONG
//
// MessageText:
//
//  Name too long.
//
#define WSAENAMETOOLONG                  0x0000274FL

//
// MessageId: WSAEHOSTDOWN
//
// MessageText:
//
//  Host is down.
//
#define WSAEHOSTDOWN                     0x00002750L

//
// MessageId: WSAEHOSTUNREACH
//
// MessageText:
//
//  Host is unreachable.
//
#define WSAEHOSTUNREACH                  0x00002751L

//
// MessageId: WSAENOTEMPTY
//
// MessageText:
//
//  Directory not empty.
//
#define WSAENOTEMPTY                     0x00002752L

//
// MessageId: WSAEPROCLIM
//
// MessageText:
//
//  WSAEPROCLIM
//
#define WSAEPROCLIM                      0x00002753L

//
// MessageId: WSAEUSERS
//
// MessageText:
//
//  WSAEUSERS
//
#define WSAEUSERS                        0x00002754L

//
// MessageId: WSAEDQUOT
//
// MessageText:
//
//  Disk quota exceeded.
//
#define WSAEDQUOT                        0x00002755L

//
// MessageId: WSAESTALE
//
// MessageText:
//
//  WSAESTALE
//
#define WSAESTALE                        0x00002756L

//
// MessageId: WSAEREMOTE
//
// MessageText:
//
//  The object is remote.
//
#define WSAEREMOTE                       0x00002757L

//
// MessageId: WSASYSNOTREADY
//
// MessageText:
//
//  System not ready.
//
#define WSASYSNOTREADY                   0x0000276BL

//
// MessageId: WSAVERNOTSUPPORTED
//
// MessageText:
//
//  Version is not supported.
//
#define WSAVERNOTSUPPORTED               0x0000276CL

//
// MessageId: WSANOTINITIALISED
//
// MessageText:
//
//  Not initialized.
//
#define WSANOTINITIALISED                0x0000276DL

//
// MessageId: WSAEDISCON
//
// MessageText:
//
//  Disconnected.
//
#define WSAEDISCON                       0x00002775L

//
// MessageId: WSAHOST_NOT_FOUND
//
// MessageText:
//
//  Host not found.
//
#define WSAHOST_NOT_FOUND                0x00002AF9L

//
// MessageId: WSATRY_AGAIN
//
// MessageText:
//
//  Try again.
//
#define WSATRY_AGAIN                     0x00002AFAL

//
// MessageId: WSANO_RECOVERY
//
// MessageText:
//
//  Non-recoverable error.
//
#define WSANO_RECOVERY                   0x00002AFBL

//
// MessageId: WSANO_DATA
//
// MessageText:
//
//  No data record available.
//
#define WSANO_DATA                       0x00002AFCL


#endif // _WSOCKMSG_H_

/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1994-1998           **/
/**********************************************************************/

/*
    mtxmsg.h

    NOTE: Definitions below should match definitions in mtxadmin.h

*/


#ifndef _MTXMSG_H_
#define _MTXMSG_H_

//
// MessageId: E_MTS_OBJECTERRORS
//
// MessageText:
//
//  Some object-level errors occurred.
//
#define E_MTS_OBJECTERRORS               0x80110401L

//
// MessageId: E_MTS_OBJECTINVALID
//
// MessageText:
//
//  Object is inconsistent or damaged.
//
#define E_MTS_OBJECTINVALID              0x80110402L

//
// MessageId: E_MTS_KEYMISSING
//
// MessageText:
//
//  Object could not be found.
//
#define E_MTS_KEYMISSING                 0x80110403L

//
// MessageId: E_MTS_ALREADYINSTALLED
//
// MessageText:
//
//  Component is already installed.
//
#define E_MTS_ALREADYINSTALLED           0x80110404L

//
// MessageId: E_MTS_DOWNLOADFAILED
//
// MessageText:
//
//  Could not download files.
//
#define E_MTS_DOWNLOADFAILED             0x80110405L

//
// MessageId: E_MTS_PDFWRITEFAIL
//
// MessageText:
//
//  Failure to write to PDF file.
//
#define E_MTS_PDFWRITEFAIL               0x80110407L

//
// MessageId: E_MTS_PDFREADFAIL
//
// MessageText:
//
//  Failure reading from PDF file.
//
#define E_MTS_PDFREADFAIL                0x80110408L

//
// MessageId: E_MTS_PDFVERSION
//
// MessageText:
//
//  Version mismatch in PDF file.
//
#define E_MTS_PDFVERSION                 0x80110409L

///////////////////////////////////////////////////////////////////////////////

#pragma message Warning: IDs are out of sync in mtxadmin.h

///////////////////////////////////////////////////////////////////////////////
//MessageId=+1 Facility=MTX Severity=CoError SymbolicName=E_MTS_COREQCOMPINSTALLED
//Language=English
//A co-requisite Component is already installed.
//.
//
// MessageId: E_MTS_BADPATH
//
// MessageText:
//
//  Invalid or no access to source or destination path.
//
#define E_MTS_BADPATH                    0x8011040AL

//
// MessageId: E_MTS_PACKAGEEXISTS
//
// MessageText:
//
//  Installing package already exists.
//
#define E_MTS_PACKAGEEXISTS              0x8011040BL

//
// MessageId: E_MTS_ROLEEXISTS
//
// MessageText:
//
//  Installing role already exists.
//
#define E_MTS_ROLEEXISTS                 0x8011040CL

//
// MessageId: E_MTS_CANTCOPYFILE
//
// MessageText:
//
//  A file cannot be copied.
//
#define E_MTS_CANTCOPYFILE               0x8011040DL

//
// MessageId: E_MTS_NOTYPELIB
//
// MessageText:
//
//  Export without typelib fails.
//
#define E_MTS_NOTYPELIB                  0x8011040EL

//
// MessageId: E_MTS_NOUSER
//
// MessageText:
//
//  No such NT user.
//
#define E_MTS_NOUSER                     0x8011040FL

//
// MessageId: E_MTS_INVALIDUSERIDS
//
// MessageText:
//
//  One or all userids in a package (import) are invalid.
//
#define E_MTS_INVALIDUSERIDS             0x80110410L

//
// MessageId: E_MTS_USERPASSWDNOTVALID
//
// MessageText:
//
//  User/password validation failed.
//
#define E_MTS_USERPASSWDNOTVALID         0x80110414L

//
// MessageId: E_MTS_CLSIDORIIDMISMATCH
//
// MessageText:
//
//  The GUIDs in the package don't match the component's GUIDs.
//
#define E_MTS_CLSIDORIIDMISMATCH         0x80110418L

#endif // _MTXMSG_H_
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1993                **/
/**********************************************************************/

/*
    webcluserr.h

    This file is generated by the MC tool from the WEBCLUSERR.MC message
    file.


    FILE HISTORY:
        AMallet   14-June-1999  Created

*/


#ifndef _WEBCLUSERR_H_
#define _WEBCLUSERR_H_

#define FACILITY_APPSERVER          0x400
#define SEV_SUCCESS                 0x0
#define SEV_INFORMATIONAL           0x1
#define SEV_WARNING                 0x2
#define SEV_ERROR                   0x3

#define MAKE_AS_HRESULT(sev, code) \
  ((HRESULT) (((unsigned long)(sev)<<31) | ((unsigned long)(FACILITY_APPSERVER)<<16) | ((unsigned long)(code))) )



//
// MessageId: AS_ERROR_BAD_OS
//
// MessageText:
//
//  This feature requires a different OS version [Win2k Advanced Server or higher] 
//
#define AS_ERROR_BAD_OS                  0xC0140001L

//
// MessageId: AS_ERROR_NLB_NOT_INSTALLED
//
// MessageText:
//
//  The Windows Load Balancing Service is not installed on this machine
//
#define AS_ERROR_NLB_NOT_INSTALLED       0xC0140002L

//
// MessageId: AS_ERROR_MACHINE_ALREADY_IN_CLUSTER
//
// MessageText:
//
//  This machine is already part of an Application Server cluster
//
#define AS_ERROR_MACHINE_ALREADY_IN_CLUSTER 0xC0140003L

//
// MessageId: AS_ERROR_BAD_IIS_VERSION
//
// MessageText:
//
//  This feature requires a later version of IIS than is currently installed on this machine
//
#define AS_ERROR_BAD_IIS_VERSION         0xC0140004L

//
// MessageId: AS_ERROR_MACHINE_NOT_IN_CLUSTER
//
// MessageText:
//
//  This machine is not part of an Application Server cluster
//
#define AS_ERROR_MACHINE_NOT_IN_CLUSTER  0xC0140005L

//
// MessageId: AS_ERROR_INVALID_PARTITION
//
// MessageText:
//
//  The partition ID is not valid.
//
#define AS_ERROR_INVALID_PARTITION       0xC0140006L

//
// MessageId: AS_ERROR_MACHINE_ALREADY_IN_PARTITION
//
// MessageText:
//
//  The machine is already part of the partition. 
//
#define AS_ERROR_MACHINE_ALREADY_IN_PARTITION 0xC0140007L

//
// MessageId: AS_ERROR_SVC_NOT_INSTALLED
//
// MessageText:
//
//  A necessary service is not installed. 
//
#define AS_ERROR_SVC_NOT_INSTALLED       0xC0140008L

//
// MessageId: AS_ERROR_INVALID_SITE_BINDING
//
// MessageText:
//
//  A site is bound to an illegal IP address. 
//
#define AS_ERROR_INVALID_SITE_BINDING    0xC0140009L

//
// MessageId: AS_ERROR_BAD_SUBNET
//
// MessageText:
//
//  The machine is on a different subnet.
//
#define AS_ERROR_BAD_SUBNET              0xC014000AL

//
// MessageId: AS_ERROR_MASTER_NOT_FOUND
//
// MessageText:
//
//  The cluster master could not be located.
//
#define AS_ERROR_MASTER_NOT_FOUND        0xC014000BL

//
// MessageId: AS_ERROR_NOT_CLUSTER_MASTER
//
// MessageText:
//
//  This machine is not the cluster master. 
//
#define AS_ERROR_NOT_CLUSTER_MASTER      0xC014000CL

//
// MessageId: AS_ERROR_DIFFERENT_CLUSTER
//
// MessageText:
//
//  This machine is part of a different cluster.
//
#define AS_ERROR_DIFFERENT_CLUSTER       0xC014000DL

//
// MessageId: AS_ERROR_WRONG_MEMBERSHIP
//
// MessageText:
//
//  This machine is part of a different domain/workgroup than the cluster controller.
//
#define AS_ERROR_WRONG_MEMBERSHIP        0xC014000EL

//
// MessageId: AS_ERROR_SVC_SHUTTING_DOWN
//
// MessageText:
//
//  This WebCluster service is shutting down. 
//
#define AS_ERROR_SVC_SHUTTING_DOWN       0xC014000FL

//
// MessageId: AS_ERROR_NOT_INITIALIZED
//
// MessageText:
//
//  The object was not initialized.
//
#define AS_ERROR_NOT_INITIALIZED         0xC0140010L

//
// MessageId: AS_ERROR_INVALID_CLUSTER_IP
//
// MessageText:
//
//  The cluster IP address and/or subnet mask is invalid.
//
#define AS_ERROR_INVALID_CLUSTER_IP      0xC0140011L

//
// MessageId: AS_ERROR_INVALID_DEDICATED_IP
//
// MessageText:
//
//  The dedicated IP address and/or subnet mask is invalid.
//
#define AS_ERROR_INVALID_DEDICATED_IP    0xC0140012L

//
// MessageId: AS_ERROR_NO_NIC
//
// MessageText:
//
//  No netcard was supplied.
//
#define AS_ERROR_NO_NIC                  0xC0140013L

//
// MessageId: AS_ERROR_ALREADY_INITIALIZED
//
// MessageText:
//
//  The object was already initialized.
//
#define AS_ERROR_ALREADY_INITIALIZED     0xC0140014L

//
// MessageId: AS_ERROR_NETWORK_CFG_CONFLICT
//
// MessageText:
//
//  Network properties are already being modified.
//
#define AS_ERROR_NETWORK_CFG_CONFLICT    0xC0140015L    

//
// MessageId: AS_ERROR_CONFLICTING_ACTION
//
// MessageText:
//
//  An administrative action is in progress that conflicts with the requested action.
//
#define AS_ERROR_CONFLICTING_ACTION      0xC0140016L    

//
// MessageId: AS_ERROR_STALE_DATA
//
// MessageText:
//
//  A more recent copy of the data exists.
//
#define AS_ERROR_STALE_DATA              0xC0140017L

//
// MessageId: AS_ERROR_CONTROLLER_CHANGING
//
// MessageText:
//
//  A cluster controller change is in progress.
//
#define AS_ERROR_CONTROLLER_CHANGING     0xC0140018L

//
// MessageId: AS_ERROR_CONTROLLER_NOT_CHANGING
//
// MessageText:
//
//  There is no cluster controller change currently in progress.
//
#define AS_ERROR_CONTROLLER_NOT_CHANGING 0xC0140019L

//
// MessageId: AS_ERROR_CONTROLLER_EXISTS
//
// MessageText:
//
//  There is already a cluster controller.
//
#define AS_ERROR_CONTROLLER_EXISTS       0xC014001AL

//
// MessageId: AS_ERROR_CONTROLLER_UNREACHABLE
//
// MessageText:
//
//  The cluster controller could not be reached.
//
#define AS_ERROR_CONTROLLER_UNREACHABLE  0xC014001BL

//
// MessageId: AS_ERROR_NLB_NOT_BOUND
//
// MessageText:
//
//  Network Load Balancing isn't bound to any network card.
//
#define AS_ERROR_NLB_NOT_BOUND           0xC014001CL

//
// MessageId: AS_ERROR_NLB_CONFLICTING_HOST_PRIORITY
//
// MessageText:
//
//  The server has a conflicting NLB host priority.
//
#define AS_ERROR_NLB_CONFLICTING_HOST_PRIORITY 0xC014001DL

//
// MessageId: AS_ERROR_NLB_ONLY_ONE_NIC
//
// MessageText:
//
//  The server has only one network card. 
//
#define AS_ERROR_NLB_ONLY_ONE_NIC        0xC014001EL

//
// MessageId: AS_ERROR_NLB_UNSUPP_PORTRULES
//
// MessageText:
//
//  The server has unsupported (probably failover) NLB port rules.
//
#define AS_ERROR_NLB_UNSUPP_PORTRULES    0xC014001FL

//
// MessageId: AS_ERROR_NLB_UNMANAGEABLE_CONFIG
//
// MessageText:
//
//  The server has an NLB or network configuration that prevents it from going into managed NLB mode.
//
#define AS_ERROR_NLB_UNMANAGEABLE_CONFIG 0xC0140020L


#endif  // _WEBCLUSERR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\common\accentry.h ===
/*++

   Copyright    (c)    1994-1999    Microsoft Corporation

   Module  Name :

        accentry.h

   Abstract:

        CAccessEntry class definitions

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:
        
        1/9/2000     sergeia    Cleaned out from usrbrows.h to left only CAccessEntry

--*/

#ifndef _ACCENTRY_H
#define _ACCENTRY_H

#ifndef _SHLOBJ_H_
#include <shlobj.h>
#endif // _SHLOBJ_H_

class COMDLL CAccessEntry : public CObjectPlus
/*++

Class Description:

    An access description entry, containing a SID and ACCESS mask
    of rights specifically granted.

Public Interface:

    LookupAccountSid        : Resolve account name to SID

    CAccessEntry            : Constructors
    ~CAccessEntry           : Destructor

    ResolveSID              : Resolve account name to SID
    operator ==             : Comparison operator
    AddPermissions          : Add to access mask
    RemovePermissions       : Remove from access mask
    MarkEntryAsNew          : Flag object as new
    MarkEntryAsClean        : Remove dirty flag
    QueryUserName           : Get the account name
    QueryPictureID          : Get 0-based bitmap offset for account
    GetSid                  : Get the SID
    QueryAccessMask         : Get the raw Access granted bits
    IsDirty                 : Determine if item has changed
    IsDeleted               : Determine if item is flagged for deletion
    IsVisible               : Determine if item should be shown in listbox
    FlagForDeletion         : Flag object for deletion or reset that flag
    IsSIDResolved           : Return TRUE if the SID has already been resolved
    HasAppropriateAccess    : Compare access bits to see if the objects has
                              specific permissions
    HasSomeAccess           : Check to see if object has at least one
                              permission bit set.
    IsDeletable             : Determine if object can be deleted

--*/
{
public:
    //
    // Helper function to look up account sid
    //
    static BOOL LookupAccountSid(
        IN  CString & str,
        OUT int & nPictureID,
        OUT PSID pSid,
        IN  LPCTSTR lpstrSystemName = NULL
        );

//
// Construction/Destruction
//
public:
    CAccessEntry(
        IN LPVOID pAce,
        IN BOOL fResolveSID = FALSE
        );

    CAccessEntry(
        IN ACCESS_MASK accPermissions,
        IN PSID pSid,
        IN LPCTSTR lpstrSystemName = NULL,
        IN BOOL fResolveSID = FALSE
        );

    CAccessEntry(
        IN PSID pSid,
        IN LPCTSTR pszUserName,
        IN LPCTSTR pszClassName
        );

    CAccessEntry(
        IN CAccessEntry& ae
        );

    ~CAccessEntry();

//
// Operations
//
public:
    //void SetAccessMask(LPACCESS_ENTRY lpAccessEntry);
    BOOL ResolveSID();
    BOOL operator ==(const CAccessEntry & acc) const;
    BOOL operator ==(const PSID pSid) const;
    void AddPermissions(ACCESS_MASK accnewPermissions);
    void RemovePermissions(ACCESS_MASK accPermissions);
    void MarkEntryAsNew();
    void MarkEntryAsClean();
    void MarkEntryAsChanged();

//
// Access Functions
//
public:
    LPCTSTR QueryUserName() const;

    //
    // The "picture" id is the 0-based index of the
    // bitmap that goes with this entry, and which
    // is used for display in the listbox.
    //
    int QueryPictureID() const;

    PSID GetSid();

    ACCESS_MASK QueryAccessMask() const;

    //
    // Check to see if this entry has undergone
    // any changes since we called it up
    //
    BOOL IsDirty() const;

    BOOL IsDeleted() const;

    BOOL IsVisible() const;

    void FlagForDeletion(
        IN BOOL fDelete = TRUE
        );

    //
    // Check to see if we've already looked up the
    // name of this SID
    //
    BOOL IsSIDResolved() const;

    //
    // Check to see if the add flag has been set for this
    // entry.
    //
    /*
    BOOL IsNew() const;

    //
    // Check to see if the update flag has been set for this
    // entry.
    //
    BOOL IsDifferent() const;
    */

    //
    // See if the entry has the access mask required.
    //
    BOOL HasAppropriateAccess(ACCESS_MASK accTargetMask) const;

    //
    // Check to see if the entry has at least some
    // privileges (if it doesn't, it should be deleted)
    //
    BOOL HasSomeAccess() const;

    //
    // See if this is a deletable entry
    //
    BOOL IsDeletable() const;

private:
    ACCESS_MASK m_accMask;
    CString m_strUserName;
    LPTSTR m_lpstrSystemName;
    PSID m_pSid;
    BOOL m_fDirty;
    BOOL m_fSIDResolved;
    BOOL m_fDeletable;
    BOOL m_fInvisible;
    BOOL m_fDeleted;
    int m_nPictureID;
    int m_fUpdates;
};



//
// Helper functions
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



//
// Convert an oblist of CAccessEntry objects to a blob
//
BOOL COMDLL BuildAclBlob(
    IN  CObListPlus & oblSID,
    OUT CBlob & blob
    );

//
// Reverse the above.  Build an oblist of CAccessEntry lists from
// a blob.
//
DWORD COMDLL BuildAclOblistFromBlob(
    IN  CBlob & blob,
    OUT CObListPlus & oblSID
    );

//
// Build a blob representing an ACL with the local domain group
//
DWORD COMDLL BuildAdminAclBlob(
    OUT CBlob & blob
    );


//
// Inline Expansion
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

inline int CAccessEntry::QueryPictureID() const
{
    ASSERT(m_fSIDResolved);
    return m_nPictureID;
}

inline LPCTSTR CAccessEntry::QueryUserName() const
{
    return m_strUserName;
}

inline PSID CAccessEntry::GetSid()
{
    return m_pSid;
}

inline ACCESS_MASK CAccessEntry::QueryAccessMask() const
{
    return m_accMask;
}

inline BOOL CAccessEntry::IsDirty() const
{
    return m_fDirty;
}

inline BOOL CAccessEntry::IsDeleted() const
{
    return m_fDeleted;
}

inline BOOL CAccessEntry::IsVisible() const
{
    return !m_fInvisible;
}

inline void CAccessEntry::FlagForDeletion(
    IN BOOL fDelete
    )
{
    m_fDirty = TRUE;
    m_fDeleted = fDelete;
}

inline BOOL CAccessEntry::IsSIDResolved() const
{
    return m_fSIDResolved;
}

/*
inline BOOL CAccessEntry::IsNew() const
{
    return (m_fUpdates & UPD_ADDED) != 0;
}

inline BOOL CAccessEntry::IsDifferent() const
{
    return (m_fUpdates & UPD_CHANGED) != 0;
}

inline void CAccessEntry::SetAccessMask(
    IN LPACCESS_ENTRY lpAccessEntry
    )
{
    m_accMask = lpAccessEntry->AccessRights;
}

*/

inline BOOL CAccessEntry::HasAppropriateAccess(
    IN ACCESS_MASK accTargetMask
    ) const
{
    return (m_accMask & accTargetMask) == accTargetMask;
}

inline BOOL CAccessEntry::HasSomeAccess() const
{
    return m_accMask;
}

inline BOOL CAccessEntry::IsDeletable() const
{
    return m_fDeletable;
}

inline BOOL  CAccessEntry::operator ==(
    IN const CAccessEntry & acc
    ) const
{
    return ::EqualSid(acc.m_pSid, m_pSid);
}

inline BOOL CAccessEntry::operator ==(
    IN const PSID pSid
    ) const
{
    return ::EqualSid(pSid, m_pSid);
}

inline void  CAccessEntry::MarkEntryAsNew()
{
    m_fDirty = TRUE;
    //m_fUpdates |= UPD_ADDED;
}

inline void CAccessEntry::MarkEntryAsClean()
{
    m_fDirty = FALSE;
    //m_fUpdates = UPD_NONE;
}

inline void CAccessEntry::MarkEntryAsChanged()
{
    m_fDirty = TRUE;
    //m_fUpdates = UPD_CHANGED;
}

#endif // _ACCENTRY_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\common\debugafx.h ===
/*++

   Copyright    (c)    1994-1999    Microsoft Corporation

   Module  Name :

        debugafx.h

   Abstract:

        Debugging routines using AFX/MFC extensions

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/



#ifndef _DEBUGAFX_H
#define _DEBUGAFX_H



#if defined(_DEBUG) || DBG
    //
    // Defined private ASSERT macros because they're not available
    // in SDK builds (which always uses retail MFC)
    //
    #undef ATLASSERT
    #undef ASSERT
    #undef _ASSERTE
    #undef VERIFY

    #define _ASSERTE(expr)\
            do { if (!(expr) &&\
                    (IISUIFireAssert(__FILE__, __TIMESTAMP__, __LINE__, #expr)==1))\
                 DebugBreak(); } while (0)

    #define ASSERT(expr)    _ASSERTE(expr)

    #define VERIFY(expr)    _ASSERTE(expr)
    #define ATLASSERT(expr) _ASSERTE(expr)

    #define ASSERT_PTR(ptr)                 _ASSERTE(ptr != NULL);
    #define ASSERT_READ_PTR(ptr)            _ASSERTE(ptr != NULL && !IsBadReadPtr(ptr, sizeof(*ptr)));
    #define ASSERT_READ_PTR2(ptr, cb)       _ASSERTE(ptr != NULL && !IsBadReadPtr(ptr, cb));
    #define ASSERT_WRITE_PTR(ptr)           _ASSERTE(ptr != NULL && !IsBadWritePtr(ptr, sizeof(*ptr)));
    #define ASSERT_WRITE_PTR2(ptr, cb)      _ASSERTE(ptr != NULL && !IsBadWritePtr(ptr, cb));
    #define ASSERT_READ_WRITE_PTR(ptr)      ASSERT_READ_PTR(ptr); ASSERT_WRITE_PTR(ptr);
    #define ASSERT_READ_WRITE_PTR2(ptr, cb) ASSERT_READ_PTR2(ptr, cb); && ASSERT_WRITE_PTR2(ptr, cb);
    #define ASSERT_MSG(msg)\
            do { if (IISUIFireAssert(__FILE__, __TIMESTAMP__, __LINE__, msg)==1)\
                 DebugBreak(); } while (0)

    int COMDLL IISUIFireAssert(
        const char * filename,
        const char * timestamp,
        int linenum,
        const char * expr
        );

#else
    //
    // Retail
    //
    #define ASSERT_PTR(ptr)           
    #define ASSERT_READ_PTR(ptr)
    #define ASSERT_READ_PTR2(ptr, cb)
    #define ASSERT_WRITE_PTR(ptr)
    #define ASSERT_WRITE_PTR2(ptr, cb)
    #define ASSERT_READ_WRITE_PTR(ptr)
    #define ASSERT_READ_WRITE_PTR2(ptr, cb)
    #define ASSERT_MSG(msg)                 

#endif // _DEBUG || DBG



#if defined(_DEBUG) || DBG

#ifndef _DEBUG
    //
    // SDK Build environment
    //
    extern COMDLL CDumpContext afxDump;
    extern COMDLL BOOL afxTraceEnabled;
#endif // _DEBUG

    //
    // ENUM for special debug output control tokens
    //
    enum ENUM_DEBUG_AFX 
    { 
        EDBUG_AFX_EOL = -1 
    };

    #define TRACEFMTPGM        DbgFmtPgm(THIS_FILE, __LINE__)
    #define TRACEOUT(x)        { afxDump << x; }
    #define TRACEEOL(x)        { afxDump << x << EDBUG_AFX_EOL; }
    #define TRACEEOLID(x)      { afxDump << TRACEFMTPGM << x << EDBUG_AFX_EOL; }
    #define TRACEEOLERR(err,x) { if (err) TRACEEOLID(x) }

    //
    // Append an EOL onto the debug output stream
    //
    COMDLL CDumpContext & operator <<(
        IN CDumpContext & out,
        IN ENUM_DEBUG_AFX edAfx
        );

#ifndef UNICODE

    COMDLL CDumpContext & operator <<(
        IN CDumpContext & out,
        IN LPCWSTR pwchStr
        );

#endif UNICODE

    //
    // Format a program name and line number for output (removes the path info)
    //
    COMDLL extern LPCSTR DbgFmtPgm(
        IN LPCSTR szFn,
        IN int line
        );

    COMDLL CDumpContext & operator <<(
        IN CDumpContext & out,
        IN const GUID & guid
        );

#else // !_DEBUG

    //
    // Retail definitions
    //
    #define TRACEOUT(x)              ;
    #define TRACEEOL(x)              ;
    #define TRACEEOLID(x)            ;
    #define TRACEEOLERR(err, x)      ;

#endif // _DEBUG

    #define TRACE_RETURN(msg, err) TRACEEOLID(msg); return err;
    #define TRACE_NOTIMPL(msg)     TRACE_RETURN(msg, E_NOTIMPL);
    #define TRACE_NOINTERFACE(msg) TRACE_RETURN(msg, E_NOINTERFACE);
    #define TRACE_UNEXPECTED(msg)  TRACE_RETURN(msg, E_UNEXPECTED);
    #define TRACE_POINTER(msg)     TRACE_RETURN(msg, E_POINTER);

#endif // _DEBUGAFX_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\common\ddxv.cpp ===
/*++

   Copyright    (c)    1994-1999    Microsoft Corporation

   Module  Name :

        ddxv.cpp

   Abstract:

        DDX/DDV Routines

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/

//
// Include Files
//
#include "stdafx.h"
#include "common.h"


#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif


#define new DEBUG_NEW



//
// Prototype for external function
//
void AFXAPI AfxSetWindowText(HWND hWndCtrl, LPCTSTR lpszNew);

//
// Numeric strings cannot be longer than 32 digits
//
#define NUMERIC_BUFF_SIZE (32)

//
// Dummy password used for display purposes
//
LPCTSTR g_lpszDummyPassword = _T("**********");


extern HINSTANCE hDLLInstance;




void 
AFXAPI DDV_MinChars(
    IN CDataExchange * pDX,
    IN CString const & value,
    IN int nChars
    )
/*++

Routine Description:

    Validate CString using a minimum string length

Arguments:

    CDataExchange * pDX   : Data exchange structure
    CString const & value : String to be validated
    int nChars            : Minimum length of string

Return Value:

    None

--*/
{
    if (pDX->m_bSaveAndValidate && value.GetLength() < nChars)
    {
        TCHAR szT[NUMERIC_BUFF_SIZE + 1];
        wsprintf(szT, _T("%d"), nChars);
        CString prompt;
        ::AfxFormatString1(prompt, IDS_DDX_MINIMUM, szT);
        ::AfxMessageBox(prompt, MB_ICONEXCLAMATION, IDS_DDX_MINIMUM);
        //
        // exception prep
        //
        prompt.Empty(); 
        pDX->Fail();
    }
}



void 
AFXAPI DDV_MinMaxChars(
    IN CDataExchange * pDX,
    IN CString const & value,
    IN int nMinChars,
    IN int nMaxChars
    )
/*++

Routine Description:

    Validate CString using a minimum and maximum string length.

Arguments:

    CDataExchange * pDX   : Data exchange structure
    CString const & value : String to be validated
    int nMinChars         : Minimum length of string
    int nMaxChars         : Maximum length of string

Return Value:

    None

--*/
{
    if (pDX->m_bSaveAndValidate)
    {
        UINT nID;
        TCHAR szT[NUMERIC_BUFF_SIZE + 1];

        if (value.GetLength() < nMinChars)
        {
            nID = IDS_DDX_MINIMUM;
            ::wsprintf(szT, _T("%d"), nMinChars);
        }
        else if (value.GetLength() > nMaxChars)
        {
            nID = AFX_IDP_PARSE_STRING_SIZE;
            ::wsprintf(szT, _T("%d"), nMaxChars);
        }
        else
        {
            //
            // Passes both our tests, it's ok.
            //
            return;
        }

        CString prompt;
        ::AfxFormatString1(prompt, nID, szT);
        ::AfxMessageBox(prompt, MB_ICONEXCLAMATION, nID);

        //
        // exception prep
        //
        prompt.Empty(); 

        pDX->Fail();
    }
    else if (pDX->m_hWndLastControl != NULL && pDX->m_bEditLastControl)
    {
        //
        // limit the control max-chars automatically
        //
        ::SendMessage(pDX->m_hWndLastControl, EM_LIMITTEXT, nMaxChars, 0);
    }
}



void 
AFXAPI DDX_Spin(
    IN CDataExchange * pDX,
    IN int nIDC,
    IN OUT int & value
    )
/*++

Routine Description:

    Save/store data from spinbutton control

Arguments:

    CDataExchange * pDX : Data exchange structure
    int nIDC            : Control ID of the spinbutton control
    int & value         : Value to be saved or stored

Return Value:

    None

--*/
{
    HWND hWndCtrl = pDX->PrepareCtrl(nIDC);
    if (pDX->m_bSaveAndValidate)
    {
        value = (int)LOWORD(::SendMessage(hWndCtrl, UDM_GETPOS, 0, 0L));
    }
    else
    {
        ::SendMessage(hWndCtrl, UDM_SETPOS, 0, MAKELPARAM(value, 0));
    }
}



void 
AFXAPI DDV_MinMaxSpin(
    IN CDataExchange * pDX,
    IN HWND hWndControl,
    IN int minVal,
    IN int maxVal
    )
/*++

Routine Description:

    Enforce minimum/maximum spin button range

Arguments:

    CDataExchange * pDX : Data exchange structure
    HWND hWndControl    : Control window handle
    int minVal          : Minimum value
    int maxVal          : Maximum value

Return Value:

    None

Note:

    Unlike most data validation routines, this one
    MUST be used prior to an accompanying DDX_Spin()
    function.  This is because spinbox controls have a
    native limit of 0-100.  Also, this function requires
    a window handle to the child control.  The
    CONTROL_HWND macro can be used for this.

--*/
{
    ASSERT(minVal <= maxVal);
    
    if (!pDX->m_bSaveAndValidate && hWndControl != NULL)
    {
        //
        // limit the control range automatically
        //
        ::SendMessage(hWndControl, UDM_SETRANGE, 0, MAKELPARAM(maxVal, minVal));
    }
}



void 
AFXAPI DDX_Password(
    IN CDataExchange * pDX,
    IN int nIDC,
    IN OUT CString & value,
    IN LPCTSTR lpszDummy
    )
/*++

Routine Description:

    DDX_Text for passwords.  Always display a dummy string
    instead of the real password, and ask for confirmation
    if the password has changed

Arguments:

    CDataExchange * pDX : Data exchange structure
    int nIDC            : Control ID
    CString & value     : value
    LPCTSTR lpszDummy   : Dummy password string to be displayed

Return Value:

    None

--*/
{
    HWND hWndCtrl = pDX->PrepareEditCtrl(nIDC);

    if (pDX->m_bSaveAndValidate)
    {
        if (!::SendMessage(hWndCtrl, EM_GETMODIFY, 0, 0))
        {
            TRACEEOLID("No changes -- skipping");
            return;
        }

        CString strNew;
        int nLen = ::GetWindowTextLength(hWndCtrl);
        ::GetWindowText(hWndCtrl, strNew.GetBufferSetLength(nLen), nLen + 1);
        strNew.ReleaseBuffer();

        /*
        if (strNew == value)
        {
            TRACEEOLID("Password already matches -- skipping");
            return;
        }
        */

        //
        // Password has changed -- ask for confirmation
        //
        HINSTANCE hOld = AfxGetResourceHandle();
        AfxSetResourceHandle(hDLLInstance);

        CConfirmDlg dlg;

        if (dlg.DoModal() == IDOK)
        {
            if (strNew.Compare(dlg.GetPassword()) == 0)
            {
                //
                // Password ok, pass it on
                //
                value = strNew;
                return;
            }
            else
            {
                //
                // No match, bad password
                //
                ::AfxMessageBox(IDS_PASSWORD_NO_MATCH);
            }
        }
        AfxSetResourceHandle(hOld);

        //
        // throw exception
        //
        pDX->Fail();        
    }
    else
    {
        //
        // Put the dummy password string in the edit control
        //
        if (!value.IsEmpty())
        {
            ::AfxSetWindowText(hWndCtrl, lpszDummy);
        }
    }
}



void 
AFXAPI DDX_Text(
    IN CDataExchange * pDX,
    IN int nIDC,
    IN OUT CILong & value
    )
/*++

Routine Description:

    DDX_Text for CILong class.  CILong takes care of all the dirty
    work for output and input.

Arguments:

    CDataExchange * pDX : Data exchange structure
    int nIDC            : Control ID code
    CILong & value      : value

Return Value:

    None

--*/
{
    HWND hWndCtrl = pDX->PrepareEditCtrl(nIDC);
    pDX->m_bEditLastControl = TRUE;

    TCHAR szT[NUMERIC_BUFF_SIZE + 1];

    if (pDX->m_bSaveAndValidate)
    {
        LONG l;

        ::GetWindowText(hWndCtrl, szT, NUMERIC_BUFF_SIZE);
        
        if (CINumber::ConvertStringToLong(szT, l))
        {
            value = l;
        }
        else
        {
            HINSTANCE hOld = AfxGetResourceHandle();
            AfxSetResourceHandle(hDLLInstance);

            ::AfxMessageBox(IDS_INVALID_NUMBER);

            AfxSetResourceHandle(hOld);

            //
            // Throw exception
            //
            pDX->Fail();
        }
    }
    else
    {
        ::wsprintf(szT, _T("%s"), (LPCTSTR)value);
        ::AfxSetWindowText(hWndCtrl, szT);
    }
}



CConfirmDlg::CConfirmDlg(
    IN CWnd * pParent OPTIONAL
    )
/*++

Routine Description:

    Constructor for the confirmation dialog -- brought up by the password ddx
    whenever password confirmation is necessary.

Arguments:

    CWnd * pParent : Optional parent window

Return Value:

    None

--*/
    : CDialog(CConfirmDlg::IDD, pParent)
{
    //{{AFX_DATA_INIT(CConfirmDlg)
    m_strPassword = _T("");
    //}}AFX_DATA_INIT
}



void 
CConfirmDlg::DoDataExchange(
    IN CDataExchange * pDX
    )
/*++

Routine Description:

    Initialise/Store control data

Arguments:

    CDataExchange* pDX - DDX/DDV control structure

Return Value:

    N/A

--*/
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CConfirmDlg)
    DDX_Text(pDX, IDC_EDIT_CONFIRM_PASSWORD, m_strPassword);
    //}}AFX_DATA_MAP
}



//
// Message Handlers
//
BEGIN_MESSAGE_MAP(CConfirmDlg, CDialog)
    //{{AFX_MSG_MAP(CConfirmDlg)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\common\debugafx.cpp ===
/*++

   Copyright    (c)    1994-1999    Microsoft Corporation

   Module  Name :

        debugafx.cpp

   Abstract:

        Debugging routines using AFX/MFC extensions

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/



//
// Include Files
//
#include "stdafx.h"
#include "common.h"


#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif



#define new DEBUG_NEW



#if defined(_DEBUG) || DBG



int 
IISUIFireAssert(
    const char * filename,
    const char * timestamp,
    int linenum,
    const char * expr
    )
{
    char sz[4096];
    char * pch = sz;

    pch += wsprintfA(pch, 
        "-------------------------------------------------------------------------------\n"
        "ASSERT FAILURE!\n"
        "-------------------------------------------------------------------------------\n"
        "File:\t\t%s\n"
        "Line:\t\t%u\n"
        "Time Stamp:\t%s\n"
        "-------------------------------------------------------------------------------\n",
        filename, linenum, timestamp
        );
        
    if (expr)
    {
        wsprintfA(pch, "Expression:\t%s\n"
        "-------------------------------------------------------------------------------\n",
        expr
        );
    } 

    TRACEEOL(sz);

    int nReturn = MessageBoxA(
        NULL, 
        sz, 
        "ASSERT FAILURE!", 
        MB_ABORTRETRYIGNORE | MB_DEFBUTTON1 | MB_ICONHAND
        );
    
    if (nReturn == IDABORT)
    {
        exit(-1);
    }
    
    //
    // Return 1 to break, 0 to ignore
    //
    return (nReturn == IDRETRY);
}



#endif // _DEBUG || DBG



#if defined(_DEBUG) || DBG



#ifndef _DEBUG
    //
    // SDK build links with retail MFC.  Swiped code from MFC sources.  Some
    // modifications.
    //
    COMDLL CDumpContext afxDump;
    COMDLL BOOL afxTraceEnabled = TRUE;

    void 
    CDumpContext::OutputString(LPCTSTR lpsz)
    {
        if (m_pFile == NULL)
        {
            OutputDebugString(lpsz);
            return;
        }

        m_pFile->Write(lpsz, lstrlen(lpsz)*sizeof(TCHAR));
    }

    CDumpContext::CDumpContext(CFile * pFile)
    {
        if (pFile)
        {
            ASSERT_PTR(pFile);
        }

        m_pFile = pFile;
        m_nDepth = 0;
    }

    void 
    CDumpContext::Flush()
    {
        if (m_pFile)
        {
            m_pFile->Flush();
        }
    }

    CDumpContext& CDumpContext::operator<<(LPCTSTR lpsz)
    {
        if (lpsz == NULL)
        {
            OutputString(_T("(NULL)"));
            return *this;
        }

        if (m_pFile == NULL)
        {
            TCHAR szBuffer[512];
            LPTSTR lpBuf = szBuffer;

            while (*lpsz != '\0')
            {
                if (lpBuf > szBuffer + ARRAY_SIZE(szBuffer) - 3)
                {
                    *lpBuf = '\0';
                    OutputString(szBuffer);
                    lpBuf = szBuffer;
                }

                if (*lpsz == '\n')
                {
                    *lpBuf++ = '\r';
                }

                *lpBuf++ = *lpsz++;
            }

            *lpBuf = '\0';
            OutputString(szBuffer);
            return *this;
        }

        m_pFile->Write(lpsz, lstrlen(lpsz) * sizeof(TCHAR));
        return *this;
    }

    CDumpContext& CDumpContext::operator<<(BYTE by)
    {
        TCHAR szBuffer[32];

        wsprintf(szBuffer, _T("%d"), (int)by);
        OutputString(szBuffer);

        return *this;
    }

    CDumpContext& CDumpContext::operator<<(WORD w)
    {
        TCHAR szBuffer[32];

        wsprintf(szBuffer, _T("%u"), (UINT) w);
        OutputString(szBuffer);

        return *this;
    }

    CDumpContext& CDumpContext::operator<<(UINT u)
    {
        TCHAR szBuffer[32];

        wsprintf(szBuffer, _T("0x%X"), u);
        OutputString(szBuffer);

        return *this;
    }

    CDumpContext& CDumpContext::operator<<(LONG l)
    {
        TCHAR szBuffer[32];

        wsprintf(szBuffer, _T("%ld"), l);
        OutputString(szBuffer);

        return *this;
    }

    CDumpContext& CDumpContext::operator<<(DWORD dw)
    {
        TCHAR szBuffer[32];

        wsprintf(szBuffer, _T("%lu"), dw);
        OutputString(szBuffer);

        return *this;
    }

    CDumpContext& CDumpContext::operator<<(int n)
    {
        TCHAR szBuffer[32];

        wsprintf(szBuffer, _T("%d"), n);
        OutputString(szBuffer);

        return *this;
    }

    CDumpContext& CDumpContext::operator<<(const CObject * pOb)
    {
        if (pOb == NULL)
        {
            *this << _T("NULL");
        }
        else
        {
            pOb->Dump(*this);
        }

        return *this;
    }

    CDumpContext& CDumpContext::operator<<(const CObject & ob)
    {
        return *this << &ob;
    }

    CDumpContext& CDumpContext::operator<<(const void * lp)
    {
        TCHAR szBuffer[32];

        wsprintf(szBuffer, _T("$%p"), lp);
        OutputString(szBuffer);

        return *this;
    }

    void 
    CDumpContext::HexDump(
        LPCTSTR lpszLine, 
        BYTE * pby,
        int nBytes, 
        int nWidth
        )
    {
        ASSERT(nBytes > 0);
        ASSERT(nWidth > 0);
        ASSERT(AfxIsValidString(lpszLine));
        ASSERT(AfxIsValidAddress(pby, nBytes, FALSE));

        int nRow = 0;
        TCHAR szBuffer[32];

        while (nBytes--)
        {
            if (nRow == 0)
            {
                wsprintf(szBuffer, lpszLine, pby);
                *this << szBuffer;
            }

            wsprintf(szBuffer, _T(" %02X"), *pby++);
            *this << szBuffer;

            if (++nRow >= nWidth)
            {
                *this << _T("\n");
                nRow = 0;
            }
        }

        if (nRow != 0)
        {
            *this << _T("\n");
        }
    }

    /////////////////////////////////////////////////////////////////////////////

    #ifdef _UNICODE
    
    CDumpContext & CDumpContext::operator<<(LPCSTR lpsz)
    {
        if (lpsz == NULL)
        {
            OutputString(L"(NULL)");
            return *this;
        }

        TCHAR szBuffer[512];
        _mbstowcsz(szBuffer, lpsz, ARRAY_SIZE(szBuffer));
        return *this << szBuffer;
    }

    #else   //_UNICODE

    CDumpContext& CDumpContext::operator<<(LPCWSTR lpsz)
    {
        if (lpsz == NULL)
        {
            OutputString("(NULL)");
            return *this;
        }

        char szBuffer[512];
        _wcstombsz(szBuffer, lpsz, ARRAY_SIZE(szBuffer));
        return *this << szBuffer;
    }

    #endif  //!_UNICODE

//
// End of block of code copied from MFC
//
#endif // _DEBUG



LPCSTR
DbgFmtPgm(
    IN LPCSTR szFn,
    IN int line
    )
/*++

Routine Description:

    Format debugging string containing file name and line number.  Remove
    the path portion of the file name if present.

Arguments:

    LPCSTR szFn : File name (ANSI)
    int line    : Line number

Return Value:

    Pointer to the internal buffer

--*/
{
    LPCSTR pszTail = szFn + lstrlenA(szFn);
    static CHAR szBuff[MAX_PATH + 1];

    for ( /**/; pszTail > szFn; --pszTail)
    {
        if (*pszTail == '\\' || *pszTail == ':')
        {
            ++pszTail;
            break;
        }
    }

    wsprintfA(szBuff, "[%s:%d] ", pszTail, line);

    return szBuff;
}



CDumpContext & 
operator <<(
    IN OUT CDumpContext & out,
    IN ENUM_DEBUG_AFX edAfx
    )
/*++

Routine Description:

    Output debugging control character to the debug context

Arguments:

    CDumpContext & out : Output debugging context
    edAfx              : Control character

Return Value:

    Output debugging context reference

--*/
{
    static CHAR * szEol = "\r\n";

    switch (edAfx)
    {
    case EDBUG_AFX_EOL:
        out << szEol;
        break;

    default:
        break;
    }

    return out;
}



#ifndef UNICODE



CDumpContext & 
operator <<(
    IN OUT CDumpContext & out,
    IN LPCWSTR pwchStr
    )
/*++

Routine Description:

    Insert a wide-character string into the output stream. For non-UNICODE only,
    as this functions would be handled by the generic 'T' function otherwise.

Arguments:

    CDumpContext & out : Output debugging context
    pwchStr            : Wide character string

Return Value:

    Output debugging context reference

--*/
{
    size_t cwch ;

    if (pwchStr == NULL)
    {
        out << "<null>";
    }
    else if ((cwch = ::wcslen(pwchStr )) > 0)
    {
        CHAR * pszTemp = (LPSTR)AllocMem(cwch + 2);

        if (pszTemp != NULL)
        {
            for (int i = 0; pwchStr[i]; ++i)
            {
                pszTemp[i] = (CHAR)pwchStr[i];
            }

            pszTemp[i] = 0;
            out << pszTemp;
            FreeMem(pszTemp);
        }
        else
        {
            out << "<memerr>";
        }
    }
    else
    {
        out << "\"\"";
    }

    return out;
}



#endif // UNICODE



CDumpContext & 
operator <<(
    IN CDumpContext & out,
    IN const GUID & guid
    )
/*++

Routine Description:

    Dump a GUID to the debugger

Arguments:

    CDumpContext & out : Output debugging context
    GUID & guid        : GUID

Return Value:

    Output debugging context reference

--*/
{
    out << "{ "
        << guid.Data1 
        << "," 
        << guid.Data2
        << "," 
        << guid.Data3 
        << "," 
        << guid.Data4 
        << "}";

    return out;
}


#endif // _DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\common\dirbrows.h ===
/*++

   Copyright    (c)    1994-1999    Microsoft Corporation

   Module Name :

        dirbrows.h

   Abstract:

        Directory Browser Dialog definitions

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/



#ifndef _DIRBROWS_H
#define _DIRBROWS_H



#ifndef _SHLOBJ_H_
#include <shlobj.h>
#endif // _SHLOBJ_H_



class COMDLL CDirBrowseDlg
/*++

Class Description:

    Directory browsing dialog.  Use the shell browser functionality to
    return a folder.  Optionally allow conversion of remote paths to 
    UNC paths.

Public Interface:

    CDirBrowseDlg   : Construct the dialog
    ~CDirBrowseDlg  : Destruct the dialog
    GetFullPath     : Get the full path selected

--*/
{
//
// Construction
//
public:
    //
    // standard constructor
    //
    CDirBrowseDlg(
        IN CWnd * pParent = NULL,
        IN LPCTSTR lpszInitialDir = NULL
        );

    ~CDirBrowseDlg();

public:
    LPCTSTR GetFullPath(
        OUT CString & str,
        IN  BOOL fConvertToUNC = TRUE
        ) const;

    virtual int DoModal();

protected:
    TCHAR m_szBuffer[MAX_PATH + 1];
    CComBSTR m_bstrTitle;
    CString m_strInitialDir;
    BROWSEINFO m_bi;
};



#endif // _DIRBROWS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\common\dirbrows.cpp ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module Name :

        dirbrows.cpp

   Abstract:

        Directory Browser Dialog.  Allow browsing for directories only.
        optionally allows UNC conversions for remote paths.

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/

//
// Include Files
//
#include "stdafx.h"
#include "common.h"
#include "dirbrows.h"
#include <dlgs.h>



#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif


extern HINSTANCE hDLLInstance;



static
int 
BrowseCallbackProc(
   IN HWND hwnd,    
   IN UINT uMsg,    
   IN LPARAM lParam,    
   IN LPARAM lpData 
   )
/*++

Routine Description:

    Callback function for the folder browser

Arguments:

    hwnd     : Handle to the browse dialog box. The callback function can 
               send the following messages to this window:

               BFFM_ENABLEOK      Enables the OK button if the wParam parameter 
                                  is nonzero or disables it if wParam is zero.
               BFFM_SETSELECTION  Selects the specified folder. The lParam 
                                  parameter is the PIDL of the folder to select 
                                  if wParam is FALSE, or it is the path of the 
                                  folder otherwise.
               BFFM_SETSTATUSTEXT Sets the status text to the null-terminated 
                                  string specified by the lParam parameter.
 
    uMsg     : Value identifying the event. This parameter can be one of the 
               following values:

               0                  Initialize dir path.  lParam is the path.

               BFFM_INITIALIZED   The browse dialog box has finished 
                                  initializing. lpData is NULL.
               BFFM_SELCHANGED    The selection has changed. lpData 
                                  is a pointer to the item identifier list for 
                                  the newly selected folder.
 
    lParam   : Message-specific value. For more information, see the 
               description of uMsg.

    lpData   : Application-defined value that was specified in the lParam 
               member of the BROWSEINFO structure.

Return Value:

    0

--*/
{
   lpData;
    static LPCTSTR lpstrDir = NULL;

    switch(uMsg)
    {
    case 0:
        lpstrDir = (LPCTSTR)lParam;
        break;

    case BFFM_INITIALIZED:
        //
        // Dialog initialized -- select desired folder
        //
        if (lpstrDir != NULL)
        {
            ::SendMessage(hwnd, BFFM_SETSELECTION, TRUE, (LPARAM)lpstrDir);
        }
        break;
    }

    return 0;
}



CDirBrowseDlg::CDirBrowseDlg(
    IN CWnd * pParent         OPTIONAL,
    IN LPCTSTR lpszInitialDir OPTIONAL
    )
/*++

Routine Description:

    Constructor for directory browser dialog

Arguments:

    CWnd * pParent         : Parent window or NULL
    LPCTSTR lpszInitialDir : Initial directory, or NULL for current directory

Return Value:

    N/A

--*/
    : m_strInitialDir(lpszInitialDir)
{
    VERIFY(m_bstrTitle.LoadString(hDLLInstance, IDS_BROWSE_DIRECTORY));

    m_bi.pidlRoot = NULL;
    m_bi.hwndOwner = pParent ? pParent->m_hWnd : NULL;
    m_bi.pszDisplayName = m_szBuffer;
    m_bi.lpszTitle = m_bstrTitle;
    m_bi.ulFlags = BIF_RETURNFSANCESTORS | BIF_RETURNONLYFSDIRS,
    m_bi.lpfn = BrowseCallbackProc;
    m_bi.lParam = 0;

    //
    // Let the callback function know the default dir is
    //
    lpszInitialDir = !m_strInitialDir.IsEmpty() 
        ? (LPCTSTR)m_strInitialDir : NULL;
    BrowseCallbackProc(m_bi.hwndOwner, 0, (LPARAM)lpszInitialDir, NULL);
}



CDirBrowseDlg::~CDirBrowseDlg()
/*++

Routine Description:

    Destructor for directory browser dialog

Arguments:

    N/A

Return Value:

    N/A

--*/
{
    if (m_bi.pidlRoot != NULL)
    {
        LPITEMIDLIST pidl = (LPITEMIDLIST)m_bi.pidlRoot;

        //
        // Free using shell allocator
        //
        LPMALLOC pMalloc;
        if (::SHGetMalloc(&pMalloc) == NOERROR)
        {
            pMalloc->Free(pidl);
            pMalloc->Release();
        }
    }
}



/* virtual */
int 
CDirBrowseDlg::DoModal()
/*++

Routine Description:

    Display the browser dialog, and fill in the selected directory path.

Arguments:

    None

Return Value:

    IDOK if the OK button was pressed, IDCANCEL otherwise.

--*/
{
    BOOL fSelectionMade = FALSE;

    //
    // Get the Shell's default allocator
    //
    LPMALLOC pMalloc;
    if (::SHGetMalloc(&pMalloc) == NOERROR)
    {
        LPITEMIDLIST pidl;

        if ((pidl = ::SHBrowseForFolder(&m_bi)) != NULL)
        {
            if (::SHGetPathFromIDList(pidl, m_szBuffer))
            {
                fSelectionMade = TRUE;
            }
            else
            {
                //
                // OK Pressed, but no path found
                //
                ::AfxMessageBox(IDS_BAD_BROWSE);
            }

            //
            // Free the PIDL allocated by SHBrowseForFolder.
            //
            pMalloc->Free(pidl);
        }

        //
        // Release the shell's allocator.
        //
        pMalloc->Release();
    }

    return fSelectionMade ? IDOK : IDCANCEL;
}



LPCTSTR
CDirBrowseDlg::GetFullPath(
    OUT CString & strName,
    IN  BOOL fConvertToUNC
    ) const
/*++

Routine Description:

    Get the full path selected.  Optionally allow a remote path to be
    converted to a UNC path.

Arguments:

    CString & strName  : String in which to return the directory path
    BOOL fConvertToUNC : If TRUE, then if the drive selected is a network
                         drive, convert the path to a UNC path.

Return Value:

    A pointer to the directory path string or NULL in case of error.

Notes:

    This function should be called only after the dialog has been dismissed.

--*/
{
    LPCTSTR lp = NULL;

    try
    {
        strName = m_szBuffer;
        lp = strName;

        if (fConvertToUNC && lp != NULL)
        {
            //
            // If it's network drive, convert it to a UNC path
            //
            CString strDrive, strUNC;

            if (IsNetworkPath(strName, &strDrive, &strUNC))
            {
                strUNC += (lp + 2);
                strName = strUNC;
            }

            lp = strName;
        }
    }
    catch(CMemoryException * e)
    {
        TRACEEOLID("!!!exception getting path");
        strName.Empty();
        e->ReportError();
        e->Delete();
    }

    return lp;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\common\guid.cpp ===
/*++

   Copyright    (c)    1994-1999    Microsoft Corporation

   Module  Name :

        guid.cpp

   Abstract:

        Initialization as required by initguid

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager (cluster edition)

   Revision History:

--*/

//
// Include Files
//
#include <stdafx.h>
#include <winsvc.h>

#include <objbase.h>
#include <initguid.h>

#include <iwamreg.h>
#include <iadmw.h>
#include <iisrsta.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\common\idlg.cpp ===
/*++

   Copyright    (c)    1994-1999    Microsoft Corporation

   Module  Name :

        idlg.cpp

   Abstract:

        Inheritance Dialog

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/

//
// Include Files
//
#include "stdafx.h"
#include "common.h"
#include "idlg.h"



#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif


#define new DEBUG_NEW


extern HINSTANCE hDLLInstance;


//
// Inheritance dialog
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

CInheritanceDlg::CInheritanceDlg(
    IN DWORD dwMetaID,
    IN BOOL fWrite,
    IN CComAuthInfo * pAuthInfo,            OPTIONAL
    IN LPCTSTR lpstrMetaRoot,
    IN CStringList & strlMetaChildNodes,
    IN LPCTSTR lpstrPropertyName,           OPTIONAL
    IN CWnd * pParent                       OPTIONAL
    )
/*++

Routine Description:

    Inheritance dialog constructor.  This constructor assumes GetDataPaths()
    has already been called.

Arguments:

    DWORD dwMetaID                      : Meta ID
    BOOL fWrite                         : TRUE from write, FALSE from delete
    CIISServer * pAuthInfo              : Auth info object or NULL
    LPCTSTR lpstrMetaRoot               : Meta root
    CStringList & strlMetaChildNodes    : List of child nodes from GetDataPaths
    LPCTSTR lpstrPropertyName           : Optional text string for the property
    CWnd * pParent                      : Optional parent window

Return Value:

    None

--*/
    : m_fWrite(fWrite),
      m_fEmpty(TRUE),
      m_fUseTable(TRUE),
      m_strMetaRoot(lpstrMetaRoot),
      m_strPropertyName(lpstrPropertyName ? lpstrPropertyName : _T("")),
      m_mk(pAuthInfo),
      CDialog(CInheritanceDlg::IDD, pParent)
{
    m_strlMetaChildNodes = strlMetaChildNodes;

    VERIFY(CMetaKey::GetMDFieldDef(
        dwMetaID, 
        m_dwMDIdentifier, 
        m_dwMDAttributes, 
        m_dwMDUserType,
        m_dwMDDataType
        ));

    Initialize();
}



CInheritanceDlg::CInheritanceDlg(
    IN DWORD dwMetaID,
    IN BOOL fWrite,
    IN CComAuthInfo * pAuthInfo,            OPTIONAL
    IN LPCTSTR lpstrMetaRoot,
    IN LPCTSTR lpstrPropertyName,           OPTIONAL
    IN CWnd * pParent                       OPTIONAL
    )
/*++

Routine Description:

    Inheritance dialog constructor.  This constructor will call GetDataPaths().

Arguments:

    DWORD dwMetaID                      : Meta ID
    BOOL fWrite                         : TRUE from write, FALSE from delete
    CComAuthInfo * pAuthInfo            : Auth info or NULL
    LPCTSTR lpstrMetaRoot               : Meta root
    LPCTSTR lpstrPropertyName           : Optional text string for the property
    CWnd * pParent                      : Optional parent window

Return Value:

    None

--*/
    : m_fWrite(fWrite),
      m_fEmpty(TRUE),
      m_fUseTable(TRUE),
      m_strMetaRoot(lpstrMetaRoot),
      m_strlMetaChildNodes(),
      m_strPropertyName(lpstrPropertyName ? lpstrPropertyName : _T("")),
      m_mk(pAuthInfo),
      CDialog(CInheritanceDlg::IDD, pParent)
{
    //
    // Specify the resources to use
    //
    HINSTANCE hOldRes = AfxGetResourceHandle();
    AfxSetResourceHandle(hDLLInstance);

    VERIFY(CMetaKey::GetMDFieldDef(
        dwMetaID, 
        m_dwMDIdentifier, 
        m_dwMDAttributes, 
        m_dwMDUserType,
        m_dwMDDataType
        ));

    //
    // Need to do our own GetDataPaths()
    //
    CError err(GetDataPaths());

    if (!err.MessageBoxOnFailure())
    {
        Initialize();
    }

    //
    // Restore the resources
    //
    AfxSetResourceHandle(hOldRes);
}



CInheritanceDlg::CInheritanceDlg(
    IN BOOL    fTryToFindInTable,
    IN DWORD   dwMDIdentifier,
    IN DWORD   dwMDAttributes,
    IN DWORD   dwMDUserType,
    IN DWORD   dwMDDataType,
    IN LPCTSTR lpstrPropertyName,
    IN BOOL    fWrite,
    IN CComAuthInfo * pAuthInfo,        OPTIONAL
    IN LPCTSTR lpstrMetaRoot,
    IN CWnd *  pParent                  OPTIONAL
    )
/*++

Routine Description:

    Inheritance dialog constructor.  This constructor will call GetDataPaths(),
    and will use the specified parameters if the property ID does not exist
    in the property table

Arguments:

    BOOL    fTryToFindInTable           : If TRUE, first look in table
    DWORD   dwMDIdentifier              : Metadata identifier
    DWORD   dwMDAttributes              : Metadata attributes
    DWORD   dwMDUserType                : Metadata user type
    DWORD   dwMDDataType                : Metadata data type
    LPCTSTR lpstrPropertyName           : Text string for the property
    BOOL    fWrite                      : TRUE from write, FALSE from delete
    CComAuthInfo * pAuthInfo            : Authentication info or NULL.
    LPCTSTR lpstrMetaRoot               : Meta root
    CWnd *  pParent                     : Optional parent window

Return Value:

    None

--*/
    : m_fWrite(fWrite),
      m_fEmpty(TRUE),
      m_fUseTable(FALSE),
      m_strMetaRoot(lpstrMetaRoot),
      m_strlMetaChildNodes(),
      m_mk(pAuthInfo),
      CDialog(CInheritanceDlg::IDD, pParent)
{
    //
    // Specify the resources to use
    //
    HINSTANCE hOldRes = AfxGetResourceHandle();
    AfxSetResourceHandle(hDLLInstance);

    if (fTryToFindInTable && !CMetaKey::GetMDFieldDef(
        dwMDIdentifier, 
        m_dwMDIdentifier, 
        m_dwMDAttributes, 
        m_dwMDUserType,
        m_dwMDDataType
        ))
    {
        //
        // Did not exist in the table, use specified parameters
        //
        m_dwMDIdentifier  = dwMDIdentifier;
        m_dwMDAttributes  = dwMDAttributes;
        m_dwMDUserType    = dwMDUserType;
        m_dwMDDataType    = dwMDDataType;
        m_strPropertyName = lpstrPropertyName;
    }


    //
    // Need to do our own GetDataPaths()
    //
    CError err(GetDataPaths());

    if (!err.MessageBoxOnFailure())
    {
        Initialize();
    }

    //
    // Restore the resources
    //
    AfxSetResourceHandle(hOldRes);
}



HRESULT
CInheritanceDlg::GetDataPaths()
/*++

Routine Description:

    GetDataPaths()

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    //ASSERT(!m_strServer.IsEmpty());

    CError err(m_mk.QueryResult());

    if (err.Succeeded())
    {
        err = m_mk.GetDataPaths( 
            m_strlMetaChildNodes,
            m_dwMDIdentifier,
            m_dwMDDataType,
            m_strMetaRoot
            );
    }

    return err;
}



void
CInheritanceDlg::Initialize()
/*++

Routine Description:

    Initialize data members.  Set the m_fEmpty flag to determine if
    it is necessary to proceed.

Arguments:

    None

Return Value:

    None

--*/
{
    //{{AFX_DATA_INIT(CInheritanceDlg)
    //}}AFX_DATA_INIT

    CMetabasePath::CleanMetaPath(m_strMetaRoot);

    if (m_fUseTable && !CMetaKey::IsPropertyInheritable(m_dwMDIdentifier))
    {
        //
        // No point in displaying non-inheritable properties
        //
        return;
    }

    switch(m_dwMDIdentifier)
    {
    //
    // Ignore these properties, even though they are inheritable
    //
    case MD_VR_PATH:
    case MD_DOWNLEVEL_ADMIN_INSTANCE:
    case MD_APP_ISOLATED:
    case MD_APP_FRIENDLY_NAME:
        return;
    }

    //
    // Check to see if the current metabase path contains an instance
    //
    CString strTmp;
    m_fHasInstanceInMaster = FriendlyInstance(m_strMetaRoot, strTmp);

    //
    // If property name was not specified in the constructor, load default
    // one from table.
    //
    if (m_strPropertyName.IsEmpty())
    {
        ASSERT(m_fUseTable);

        //
        // Specify the resources to use
        //
        HINSTANCE hOldRes = AfxGetResourceHandle();
        AfxSetResourceHandle(hDLLInstance);

        VERIFY(CMetaKey::GetPropertyDescription(
            m_dwMDIdentifier, 
            m_strPropertyName
            ));

        AfxSetResourceHandle(hOldRes);
    }

    //
    // Go through the list of metapaths, and clean them
    // up.
    //
    POSITION pos = m_strlMetaChildNodes.GetHeadPosition();

    while(pos)
    {
        CString & strMetaPath = m_strlMetaChildNodes.GetNext(pos);
        CMetabasePath::CleanMetaPath(strMetaPath);
    }

    //
    // If the special info key (lm/service/info) is in the list, remove it.
    // We only need to this if the key that is getting the
    // change (m_strMetaRoot) is the service master property (lm/service).
    // If it is anything else, then the special "info" key cannot be below
    // it so we don't need to check. Thus the first test is to see if there
    // is only one "/" character. If there is only one, then we know it is
    // the service and we can go ahead and do the test.  In some ways,
    // mfc is a pain, so we limited to the CString methods to do this
    // copy the root into the temp string.
    //
    int iSlash = m_strMetaRoot.ReverseFind(SZ_MBN_SEP_CHAR);

    if (iSlash >= 0)
    {
        strTmp = m_strMetaRoot.Left(iSlash);

        //
        // Now make sure that there aren't any more slashes
        //
        if (strTmp.Find(SZ_MBN_SEP_CHAR) == -1)
        {
            //
            // Now build the path to the special info key by adding it
            // to the meta root
            //
            strTmp = m_strMetaRoot + SZ_MBN_SEP_CHAR + IIS_MD_SVC_INFO_PATH;

            TRACEEOLID("Removing any descendants of " << strTmp);

            //
            // Search the list for the info key and remove it if we find it
            //
            pos = m_strlMetaChildNodes.GetHeadPosition();

            while(pos)
            {
                POSITION pos2 = pos;
                CString & strMetaPath = m_strlMetaChildNodes.GetNext(pos);
                TRACEEOLID("Checking " << strMetaPath);

                if (strTmp.CompareNoCase(
                    strMetaPath.Left(strTmp.GetLength())) == 0)
                {
                    TRACEEOLID("Removing service/info metapath from list");
                    m_strlMetaChildNodes.RemoveAt(pos2);
                }
            }
        }
    }

    //
    // Remove the first item if it's the current metapath
    //
    pos = m_strlMetaChildNodes.GetHeadPosition();
    if (pos)
    {
        TRACEEOLID("Stripping " << m_strMetaRoot);

        CString & strMetaPath = m_strlMetaChildNodes.GetAt(pos);

        if (strMetaPath.CompareNoCase(m_strMetaRoot) == 0)
        {
            TRACEEOLID("Removing current metapath from list");
            m_strlMetaChildNodes.RemoveHead();
        }
    }

    m_fEmpty = m_strlMetaChildNodes.GetCount() == 0;
}



/* virtual */
INT_PTR
//int
CInheritanceDlg::DoModal()
/*++

Routine Description:

    Display the dialog.

Arguments:

    None

Return Value:

    IDOK if the OK button was pressed, IDCANCEL otherwise.

--*/
{
    //
    // Specify the resources to use
    //
    HINSTANCE hOldRes = AfxGetResourceHandle();
    AfxSetResourceHandle(hDLLInstance);

    INT_PTR answer = CDialog::DoModal();

    //
    // restore the resources
    //
    AfxSetResourceHandle(hOldRes);

    return answer;
}




void
CInheritanceDlg::DoDataExchange(
    IN CDataExchange * pDX
    )
/*++

Routine Description:

    Initialise/Store control data

Arguments:

    CDataExchange * pDX - DDX/DDV control structure

Return Value:

    None

--*/
{
    CDialog::DoDataExchange(pDX);

    //{{AFX_DATA_MAP(CInheritanceDlg)
    DDX_Control(pDX, IDC_LIST_CHILD_NODES, m_list_ChildNodes);
    //}}AFX_DATA_MAP
}



//
// Message Map
//
BEGIN_MESSAGE_MAP(CInheritanceDlg, CDialog)
    //{{AFX_MSG_MAP(CInheritanceDlg)
    ON_BN_CLICKED(IDC_BUTTON_SELECT_ALL, OnButtonSelectAll)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()



BOOL
CInheritanceDlg::FriendlyInstance(
    IN  CString & strMetaRoot,
    OUT CString & strFriendly
    )
/*++

Routine Description:

    Replace the instance number with its descriptive name.

Arguments:

    CString & strMetaRoot       : Metabase path
    CString & strFriendly       : Converted output friendly path.

Return Value:

    TRUE if the path contained an instance number.

--*/
{
    //
    // Break into fields
    //
    // CODEWORK: make static like BuildMetaPath
    //
    LPCTSTR lp = _tcschr(strMetaRoot, SZ_MBN_SEP_CHAR); // lm

    if (lp != NULL)
    {
        LPCTSTR lp2 = lp;
        CString strService(++lp2);
        lp = _tcschr(++lp, SZ_MBN_SEP_CHAR);  // service name

        if (lp == NULL)
        {
            //
            // Master Instance (can never be a descendant)
            //
            //strFriendly = m_strWebMaster;
            return FALSE;
        }
        else
        {
            strService.ReleaseBuffer(DIFF(lp - lp2));
        }
        TRACEEOLID(strService);

        DWORD dwInstance = _ttol(++lp);
        TRACEEOLID(dwInstance);
        lp = _tcschr(lp, SZ_MBN_SEP_CHAR);       // Instance #

        if (lp != NULL)
        {
            lp = _tcschr(++lp, SZ_MBN_SEP_CHAR); // Skip "ROOT"
        }

        HRESULT hr = m_mk.Open(
            METADATA_PERMISSION_READ, 
            CMetabasePath(strService, dwInstance)
            );

        if (SUCCEEDED(hr))
        {
            CString strComment;
            hr = m_mk.QueryValue(MD_SERVER_COMMENT, strComment);
            m_mk.Close();

            if (FAILED(hr) || strComment.IsEmpty())
            {
                strFriendly.Format(
                    SZ_MBN_MACHINE SZ_MBN_SEP_STR _T("%s") SZ_MBN_SEP_STR _T("%d"),
                    (LPCTSTR)strService,
                    dwInstance
                    );
            }
            else
            {
                strFriendly.Format(
                    SZ_MBN_MACHINE SZ_MBN_SEP_STR _T("%s") SZ_MBN_SEP_STR _T("%s"),
                    (LPCTSTR)strService,
                    (LPCTSTR)strComment
                    );
            }

            TRACEEOLID(strFriendly);

            //
            // Append the rest of the path
            //
            if (lp != NULL)
            {
                strFriendly += lp;
            }

            return TRUE;
        }
    }

    return FALSE;
}



CString &
CInheritanceDlg::CleanDescendantPath(
    IN OUT CString & strMetaPath
    )
/*++

Routine Description:

    Clean the descendant metabase path.  The path is shown
    as a descendant of the current metabase root, and instance
    numbers are replaced with their description names.

Arguments:

    CString & strMetaPath   : Metabase path to be treated

Return Value:

    Reference to the cleaned-up path.

--*/
{
    //
    // This better be a descendant!
    //
    ASSERT(strMetaPath.GetLength() >= m_strMetaRoot.GetLength());
    ASSERT(!::_tcsnicmp(strMetaPath, m_strMetaRoot, m_strMetaRoot.GetLength()));

    // we do care only about something below LM
    CString machine_path;
    CMetabasePath::GetMachinePath(strMetaPath, machine_path);
    if (machine_path.CompareNoCase(SZ_MBN_MACHINE) == 0)
    {
       if (!m_fHasInstanceInMaster)
       {
           //
           // Need to replace the instance number with the friendly
           // name.
           //
           CString strTmp;
           VERIFY(FriendlyInstance(strMetaPath, strTmp));
           strMetaPath = strTmp;
       }

       strMetaPath = strMetaPath.Mid(m_strMetaRoot.GetLength() + 1);
    }
    return strMetaPath;
}



//
// Message Handlers
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



BOOL
CInheritanceDlg::OnInitDialog()
/*++

Routine Description:

    WM_INITDIALOG handler.  Initialize the dialog.

Arguments:

    None.

Return Value:

    TRUE if focus is to be set automatically, FALSE if the focus
    is already set.

--*/
{
    CDialog::OnInitDialog();

    //
    // Get friendly name for the property, and set the text.
    //
    CString strPrompt; 
    CComBSTR bstrFmt;
    VERIFY(bstrFmt.LoadString(hDLLInstance, IDS_INHERITANCE_PROMPT));
    strPrompt.Format(bstrFmt, (LPCTSTR)m_strPropertyName);
    GetDlgItem(IDC_STATIC_PROMPT)->SetWindowText(strPrompt);

    //
    // Turn inherited nodes into friendly paths, and add them
    // to the listbox.  Note the "current" node should have been
    // deleted at this stage.
    //
    POSITION pos = m_strlMetaChildNodes.GetHeadPosition();

    while(pos)
    {
        CString strNode = m_strlMetaChildNodes.GetNext(pos);
        m_list_ChildNodes.AddString(CleanDescendantPath(strNode));
    }

    return TRUE;
}



void
CInheritanceDlg::OnButtonSelectAll()
/*++

Routine Description:

    'Select All' button handler

Arguments:

    None

Return Value:

    None

--*/
{
    //
    // Select all entries
    //
    if (m_list_ChildNodes.GetCount() == 1)
    {
        //
        // SelItemRange refuses to do a single member
        //
        m_list_ChildNodes.SetSel(0, TRUE);
    }
    else
    {
        m_list_ChildNodes.SelItemRange(
            TRUE, 
            0, 
            m_list_ChildNodes.GetCount() - 1
            );
    }
}



void
CInheritanceDlg::OnOK()
/*++

Routine Description:

    'OK' button handler

Arguments:

    None

Return Value:

    None

--*/
{
    //
    // Now delete the property for all selected child nodes.
    // Grab from the orginal list, and not the listbox
    // as the latter have been frienly-fied, and is no longer
    // usable.
    //
    int cItems = m_list_ChildNodes.GetCount();
    ASSERT(cItems > 0);

    CString strMetaPath;
    CError err(m_mk.QueryResult());

    if (err.Succeeded())
    {
        int i = 0;
        POSITION pos = m_strlMetaChildNodes.GetHeadPosition();

        while(pos)
        {
            strMetaPath = m_strlMetaChildNodes.GetNext(pos);

            if (m_list_ChildNodes.GetSel(i++) > 0)
            {
                TRACEEOLID("Deleting property on " << strMetaPath);

                err = m_mk.Open(METADATA_PERMISSION_WRITE, strMetaPath);

                if (err.Failed())
                {
                    break;
                }

                err = m_mk.DeleteValue(m_dwMDIdentifier);

                m_mk.Close();

                if (err.Failed())
                {
                    break;
                }
            }
        }
    }

    if (!err.MessageBoxOnFailure())
    {
        //
        // Dialog can be dismissed
        //
        CDialog::OnOK();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\common\iisui.cpp ===
/*++

   Copyright    (c)    1994-1999    Microsoft Corporation

   Module  Name :

        iisui.cpp

   Abstract:

        DLL Main entry point.

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager (cluster edition)

   Revision History:

--*/



//
// Include Files
//
#include "stdafx.h"
#include "common.h"

#ifdef _COMEXPORT

HINSTANCE hDLLInstance;

//
// Dll Version Only
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



STDAPI
DllRegisterServer()
{
    return S_OK;
}



STDAPI
DllUnregisterServer()
{
    return S_OK;
}



static AFX_EXTENSION_MODULE commonDLL = {NULL, NULL};



extern "C" int APIENTRY
DllMain(
    IN HINSTANCE hInstance,
    IN DWORD dwReason,
    IN LPVOID lpReserved
    )
/*++

Routine Description:

    DLL Main entry point

Arguments:

    HINSTANCE hInstance : Instance handle
    DWORD dwReason      : DLL_PROCESS_ATTACH, etc
    LPVOID lpReserved   : Reserved value

Return Value:

    1 for succesful initialisation, 0 for failed initialisation

--*/
{
   lpReserved;

   int res = 1;

    switch (dwReason)
    {
    case DLL_PROCESS_ATTACH:
        ASSERT(hInstance != NULL);
        hDLLInstance = hInstance;
        res = ::AfxInitExtensionModule(commonDLL, hInstance);
        InitErrorFunctionality();
        InitIntlSettings();
#if defined(_DEBUG) || DBG
        afxTraceEnabled = TRUE;
#endif // _DEBUG
        break;

    case DLL_PROCESS_DETACH:
        //
        // termination
        //
        TerminateIntlSettings();
        TerminateErrorFunctionality();
        ::AfxTermExtensionModule(commonDLL);
        break;
    }
    return res;
}


extern "C" void WINAPI
InitCommonDll()
{
    new CDynLinkLibrary(commonDLL);
//    hDLLInstance = commonDLL.hResource;
}


#endif // IISUI_EXPORTS
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\common\makefile.inc ===
#
# Since we don't support multiple mc files or msg0001.bin
# blobs, we combine them into a single .mc file.
#
# all: mtxmsg.h wsockmsg.h webcluserr.h commsg.rc

commsg.rc msg00001.bin: commsg.mc
    mc -v commsg.mc -r .\ -h .\

commsg.mc: mtxmsg.mc wsockmsg.mc ..\..\inc\webcluserr.mc wsockmsg.h mtxmsg.h webcluserr.h
    copy /A wsockmsg.mc+mtxmsg.mc+..\..\inc\webcluserr.mc commsg.mc

wsockmsg.h: wsockmsg.mc
    mc -d -v wsockmsg.mc -r .\ -h .\

mtxmsg.h: mtxmsg.mc
    mc -o -v mtxmsg.mc -r .\ -h .\

webcluserr.h: ..\..\inc\webcluserr.mc
    mc -o -v ..\..\inc\webcluserr.mc -r .\ -h .\

clean::
    -del wsockmsg.h   wsockmsg.rc
    -del mtxmsg.h     mtxmsg.rc
    -del webcluserr.h webcluserr.rc
    -del commsg.h     commsg.rc     commsg.mc msg0001.bin
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\common\idlg.h ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        idlg.h

   Abstract:

        Inheritance Dialog Definitions

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/

#ifndef __IDLG__H__
#define __IDLG__H__



class COMDLL CInheritanceDlg : public CDialog
/*++

Class Description:

    Inheritance override checker dialog.

Public Interface:

    CInheritanceDlg         : Constructor

    IsEmpty                 : Check to see if there are overrides.

Notes:

    There are two constructors.  One which assumes GetDataPaths() has
    already been called, and which takes the results from GetDataPaths()
    as a CStringList, and a second constructor which will make the GetDataPaths
    automatically.

    In either case, the calling process should check IsEmpty() right after
    constructing the dialog to see if DoModal() needs to be called.  If
    IsEmpty() returns TRUE, there's no reason to call DoModal().

--*/
{
//
// fWrite parameter helper definitions
//
#define FROM_WRITE_PROPERTY     (TRUE)
#define FROM_DELETE_PROPERTY    (FALSE)

//
// Construction
//
public:
    //
    // Standard constructor (GetDataPaths() already called)
    //
    CInheritanceDlg(
        IN DWORD dwMetaID,
        IN BOOL fWrite,
        IN CComAuthInfo * pAuthInfo,
        IN LPCTSTR lpstrMetaRoot,
        IN CStringList & strlMetaChildNodes,
        IN LPCTSTR lpstrPropertyName            = NULL,
        IN CWnd * pParent                       = NULL
        );

    //
    // Constructor which will call GetDataPaths()
    //
    CInheritanceDlg(
        IN DWORD dwMetaID,
        IN BOOL fWrite,
        IN CComAuthInfo * pAuthInfo,
        IN LPCTSTR lpstrMetaRoot,
        IN LPCTSTR lpstrPropertyName            = NULL,
        IN CWnd * pParent                       = NULL
        );

    //
    // Constructor which will call GetDataPaths(), and which
    // does not use the predefined property table unless
    // fTryToFindInTable is TRUE, in which case it will attempt
    // to use the table first, and use the specified parameters
    // only if the property ID is not found in the table.
    //
    CInheritanceDlg(
        IN BOOL    fTryToFindInTable,
        IN DWORD   dwMDIdentifier,
        IN DWORD   dwMDAttributes,
        IN DWORD   dwMDUserType,
        IN DWORD   dwMDDataType,
        IN LPCTSTR lpstrPropertyName,
        IN BOOL    fWrite,
        IN CComAuthInfo * pAuthInfo,
        IN LPCTSTR lpstrMetaRoot,
        IN CWnd *  pParent                      = NULL                     
        );

//
// Access
//
public:
    virtual INT_PTR DoModal();
//    virtual int DoModal();
    
    //
    // Check to see if there's a reason to continue displaying
    // the dialog.
    //
    BOOL IsEmpty() const { return m_fEmpty; }

//
// Dialog Data
//
protected:
    //{{AFX_DATA(CInheritanceDlg)
    enum { IDD = IDD_INHERITANCE };
    CListBox m_list_ChildNodes;
    //}}AFX_DATA

//
// Overrides
//
protected:
    //{{AFX_VIRTUAL(CInheritanceDlg)
    protected:
    virtual void DoDataExchange(CDataExchange * pDX);
    //}}AFX_VIRTUAL

//
// Implementation
//
protected:
    //{{AFX_MSG(CInheritanceDlg)
    virtual BOOL OnInitDialog();
    virtual void OnOK();
    afx_msg void OnButtonSelectAll();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

    void Initialize();
    HRESULT GetDataPaths();

    BOOL FriendlyInstance(
        IN  CString & strMetaRoot,
        OUT CString & strFriendly
        );

    CString & CleanDescendantPath(
        IN OUT CString & strMetaPath
        );

private:
    BOOL    m_fWrite;
    BOOL    m_fEmpty;
    BOOL    m_fHasInstanceInMaster;
    BOOL    m_fUseTable;
    DWORD   m_dwMDIdentifier;
    DWORD   m_dwMDAttributes;
    DWORD   m_dwMDUserType;
    DWORD   m_dwMDDataType;
    CString m_strMetaRoot;
    //CString m_strServer;
    CString m_strPropertyName;
    CStringListEx m_strlMetaChildNodes;
    CMetaKey m_mk;
};


#endif // __IDLG__H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\common\ipa.cpp ===
/*++

   Copyright    (c)    1994-1999    Microsoft Corporation

   Module  Name :

        ipa.cpp

   Abstract:

        IP Address value and helper functions

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/



//
// Include Files
//
#include "stdafx.h"
#include "common.h"
#include <winsock2.h>


#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif


#define new DEBUG_NEW



//
// Calling instance
//
extern HINSTANCE hDLLInstance;



/* static */
DWORD
CIPAddress::StringToLong(
    IN LPCTSTR lpstr,
    IN int nLength
    )
/*++

Routine Description:

    Static function to convert an ip address string of the form "1.2.3.4"
    to a a single 32 bit number.

Arguments:

    LPCTSTR lpstr : String ip address
    int nLength   : Length of string

Return Value:

    32 bit ip address.

--*/
{
    DWORD dwIPValue = 0L;

    if (nLength > 0)
    {
        u_long ul = 0;

#ifdef UNICODE

        try
        {
            //
            // Convert to ANSI
            //
            LPSTR pszDest = AllocAnsiString(lpstr);
            ul = ::inet_addr(pszDest);
            FreeMem(pszDest);
        }
        catch(CException * e)
        {
            TRACEEOLID("!!!Exception converting string to ip address");
            e->ReportError();
            e->Delete();
        }

#else

        ul = ::inet_addr(lpstr);

#endif // UNICODE

        //
        // Convert to host byte order.
        //
        dwIPValue = (DWORD)::ntohl(ul);
    }

    return dwIPValue;
}



/* static */
LPTSTR
CIPAddress::LongToString(
    IN  const DWORD dwIPAddress,
    OUT LPTSTR lpStr,
    IN  int cbSize
    )
/*++

Routine Description:

    Static function to convert a 32 bit number to a CString of the format
    "1.2.3.4"

Arguments:

    const DWORD dwIPAddress : 32 bit ip address to be converted to string
    LPTSTR lpStr            : Destination string
    int cbSize              : Size of destination string

Return Value:

    Pointer to string buffer

--*/
{
    struct in_addr ipaddr;

    //
    // Convert the unsigned long to network byte order
    //
    ipaddr.s_addr = ::htonl((u_long)dwIPAddress);

    //
    // Convert the IP address value to a string
    //
    LPCSTR pchAddr = ::inet_ntoa(ipaddr);

#ifdef UNICODE

    VERIFY(::MultiByteToWideChar(CP_ACP, 0L, pchAddr, -1, lpStr, cbSize));

#else

    ::lstrcpy(lpStr, pchAddr);

#endif // UNICODE

    return lpStr;
}



/* static */
LPCTSTR
CIPAddress::LongToString(
    IN  const DWORD dwIPAddress,
    OUT CString & str
    )
/*++

Routine Description:

    Static function to convert a 32 bit number to a CString of the format
    "1.2.3.4"

Arguments:

    const DWORD dwIPAddress : 32 bit ip address to be converted to string
    CString & str           : Destination string

Return Value:

    Pointer to string buffer

--*/
{
    struct in_addr ipaddr;

    //
    // Convert the unsigned long to network byte order
    //
    ipaddr.s_addr = ::htonl((u_long)dwIPAddress);

    //
    // Convert the IP address value to a string
    //
    LPCSTR pchAddr = ::inet_ntoa(ipaddr);

    try
    {
        str = pchAddr;
    }
    catch(CMemoryException * e)
    {
        TRACEEOLID("!!!Exception converting ip address to string");
        e->ReportError();
        e->Delete();
    }

    return (LPCTSTR)str;
}



/* static */
LPCTSTR
CIPAddress::LongToString(
    IN  const DWORD dwIPAddress,
    OUT CComBSTR & bstr
    )
/*++

Routine Description:

    Static function to convert a 32 bit number to a CComBSTR of the format
    "1.2.3.4"

Arguments:

    const DWORD dwIPAddress : 32 bit ip address to be converted to string
    CComBSTR & bstr         : Destination string

Return Value:

    Pointer to string buffer

--*/
{
    struct in_addr ipaddr;

    //
    // Convert the unsigned long to network byte order
    //
    ipaddr.s_addr = ::htonl((u_long)dwIPAddress);

    //
    // Convert the IP address value to a string
    //
    bstr = ::inet_ntoa(ipaddr);

    return bstr;
}




/* static */
LPBYTE
CIPAddress::DWORDtoLPBYTE(
    IN  DWORD  dw,
    OUT LPBYTE lpBytes
    )
/*++

Routine Description:

    Convert a DWORD to a byte array of 4 bytes.  No size
    checking is performed.

Arguments:

    DWORD  dw      : 32 bit ip address
    LPBYTE lpBytes : Byte stream

Return Value:

    Pointer to the input buffer.

--*/
{
    lpBytes[0] = (BYTE)GETIP_FIRST(dw);
    lpBytes[1] = (BYTE)GETIP_SECOND(dw);
    lpBytes[2] = (BYTE)GETIP_THIRD(dw);
    lpBytes[3] = (BYTE)GETIP_FOURTH(dw);

    return lpBytes;
}



CIPAddress::CIPAddress()
/*++

Routine Description:

    Constructor

Arguments:

    None

Return Value:

    N/A

--*/
    : m_dwIPAddress(0L)
{
}



CIPAddress::CIPAddress(
    IN DWORD dwIPAddress,
    IN BOOL fNetworkByteOrder
    )
/*++

Routine Description:

    Constructor.

Arguments:

    DWORD dwIPAddress      : IP address value
    BOOL fNetworkByteOrder : if TRUE, value must be converted to host byte
                             order, otherwise is assumed to already be in
                             host byte order.

Return Value:

    N/A

--*/
{
    if (fNetworkByteOrder)
    {
        //
        // Convert to host byte order
        //
        dwIPAddress = (DWORD)::ntohl((u_long)dwIPAddress);
    }

    m_dwIPAddress = dwIPAddress;
}



CIPAddress::CIPAddress(
    IN BYTE b1,
    IN BYTE b2,
    IN BYTE b3,
    IN BYTE b4
    )
/*++

Routine Description:

    Constructor.

Arguments:

    BYTE b1 : First octet
    BYTE b2 : Second octet
    BYTE b3 : Third octet
    BYTE b4 : Fourth octet

Return Value:

    N/A

Notes:

    This is already assumed to be in host order

--*/
    : m_dwIPAddress(MAKEIPADDRESS(b1, b2, b3, b4))
{
}



CIPAddress::CIPAddress(
    IN LPBYTE lpBytes,
    IN BOOL  fNetworkByteOrder OPTIONAL
    )
/*++

Routine Description:

    Construct from byte stream

Arguments:

    LPBYTE lpBytes           : Byte stream
    BOOL  fNetworkByteOrder  : TRUE if the byte stream is in network byte order

Return Value:

    N/A

--*/
{
   lpBytes;
   fNetworkByteOrder;
}



CIPAddress::CIPAddress(
    IN const CIPAddress & ia
    )
/*++

Routine Description:

    Copy Constructor.

Arguments:

    const CIPAddress & ia

Return Value:

    N/A

--*/
    : m_dwIPAddress(ia.m_dwIPAddress)
{
}



CIPAddress::CIPAddress(
    IN LPCTSTR lpstr,
    IN int nLength
    )
/*++

Routine Description:

    Constructor.

Arguments:

    LPCTSTR lpstr : string ip value
    int nLength   : length of string

Return Value:

    N/A

--*/
{
    m_dwIPAddress = CIPAddress::StringToLong(lpstr, nLength);
}



CIPAddress::CIPAddress(
    const CString & str
    )
/*++

Routine Description:

    Constructor.

Arguments:

    const CString & str : IP Address string

Return Value:

    N/A

--*/
{
    m_dwIPAddress = CIPAddress::StringToLong(str);
}



const CIPAddress &
CIPAddress::operator =(
    IN const CIPAddress & ia
    )
/*++

Routine Description:

    Assignment operator

Arguments:

    const CIPAddress & ia : Source ip address

Return Value:

    Current object

--*/
{
    m_dwIPAddress = ia.m_dwIPAddress;

    return *this;
}



const CIPAddress &
CIPAddress::operator =(
    IN const DWORD dwIPAddress
    )
/*++

Routine Description:

    Assignment operator

Arguments:

    const DWORD dwIPAddress : Source ip address

Return Value:

    Current object

--*/
{
    m_dwIPAddress = dwIPAddress;

    return *this;
}



const CIPAddress &
CIPAddress::operator =(
    IN LPCTSTR lpstr
    )
/*++

Routine Description:

    Assignment operator

Arguments:

    LPCTSTR lpstr : Source string

Return Value:

    Current object

--*/
{
    m_dwIPAddress = CIPAddress::StringToLong(lpstr, ::lstrlen(lpstr));

    return *this;
}



const CIPAddress &
CIPAddress::operator =(
    IN const CString & str
    )
/*++

Routine Description:

    Assignment operator

Arguments:

    const CString & str : Source string

Return Value:

    Current object

--*/
{
    m_dwIPAddress = CIPAddress::StringToLong(str);

    return *this;
}



int
CIPAddress::CompareItem(
    IN const CIPAddress & ia
    ) const
/*++

Routine Description:

    Compare two ip addresses

Arguments:

    const CIPAddress & ia : IP Address to compare this to

Return Value:

    +1 if the current ip address is greater,
     0 if the two ip addresses are the same
    -1 if the current ip address is less,

--*/
{
    return (DWORD)ia < m_dwIPAddress
           ? +1
           : (DWORD)ia == m_dwIPAddress
                ? 0
                : -1;
}



CIPAddress::operator LPCTSTR() const
/*++

Routine Description:

    Conversion operator

Arguments:

    N/A

Return Value:

    Pointer to converted string

--*/
{
    static TCHAR szIPAddress[] = _T("xxx.xxx.xxx.xxx");

    return CIPAddress::LongToString(
        m_dwIPAddress,
        szIPAddress,
        ARRAY_SIZE(szIPAddress)
        );
}



CIPAddress::operator CString() const
/*++

Routine Description:

    Conversion operator

Arguments:

    N/A

Return Value:

    Converted string

--*/
{
    CString str;

    CIPAddress::LongToString(m_dwIPAddress, str);

    return str;
}



DWORD
CIPAddress::QueryIPAddress(
    IN BOOL fNetworkByteOrder
    ) const
/*++

Routine Description:

    Get the ip address as a 32 bit number

Arguments:

    BOOL fNetworkByteOrder : If TRUE, convert to network byte order

Return Value:

    32 bit ip address

--*/
{
    return fNetworkByteOrder
        ? ::htonl((u_long)m_dwIPAddress)
        : m_dwIPAddress;
}



//
// IP Address helper functions
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



DWORD
PopulateComboWithKnownIpAddresses(
    IN  LPCTSTR lpszServer,
    IN  CComboBox & combo,
    IN  CIPAddress & iaIpAddress,
    OUT CObListPlus & oblIpAddresses,
    OUT int & nIpAddressSel
    )
/*++

Routine Description:

    Fill a combo box with known ip addresses

Arguments:

    LPCTSTR lpszServer           : Server whose ip addresses to obtain
                                  (can be computer name or ip address)

    CComboBox & combo            : Combo box to populate
    CIPAddress & iaIpAddress     : IP Address to select
    CObListPlus & oblIpAddresses : Returns an oblist of CIPAddress objects
    int & nIpAddressSel          : Returns selected IP address

Return Value:

    Error return code

--*/
{
    //
    // Start clean
    //
    oblIpAddresses.RemoveAll();
    combo.ResetContent();

    //
    // Don't like \\names
    //
    lpszServer = PURE_COMPUTER_NAME(lpszServer);
    struct hostent * pHostEntry = NULL;

    if (_istdigit(*lpszServer))
    {
        //
        // Get by ip address
        //
        u_long ul = (DWORD)CIPAddress(lpszServer);
        ul = ::htonl(ul);   // convert to network order.
        pHostEntry = ::gethostbyaddr((CHAR *)&ul, sizeof(ul), PF_INET);
    }
    else
    {
        //
        // Get by domain name
        //
        const char FAR * lpszAnsiServer = NULL;

#ifdef UNICODE

        CHAR szAnsi[255];

        if (::WideCharToMultiByte(CP_ACP, 0L, lpszServer, -1,  szAnsi,
            sizeof(szAnsi), NULL, NULL) > 0)
        {
            lpszAnsiServer = szAnsi;
        }
#else
        lpszAnsiServer = lpszServer;
#endif // UNICODE

        if (lpszAnsiServer)
        {
            pHostEntry = ::gethostbyname(lpszAnsiServer);
        }
    }

    //
    // We'll always have the 'default' server id
    // selected
    //
    CComBSTR bstr, bstrDefault;
    VERIFY(bstrDefault.LoadString(hDLLInstance, IDS_ALL_UNASSIGNED));

    nIpAddressSel = -1;
    CIPAddress * pia = new CIPAddress;

    if (!pia)
    {
        TRACEEOLID("PopulateComboWithKnownIpAddresses: OOM");
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    oblIpAddresses.AddTail(pia);
    int nNewSel = combo.AddString(bstrDefault);

    if (iaIpAddress == *pia)
    {
        //
        // Remember selection
        //
        nIpAddressSel = nNewSel;
    }

    if (pHostEntry != NULL)
    {
        int n = 0;
        while (((DWORD *)pHostEntry->h_addr_list[n]) != NULL)
        {
            //
            // Convert from network byte order
            //
            pia = new CIPAddress(
               *((DWORD *)(pHostEntry->h_addr_list[n++])), TRUE);

            if (!pia)
            {
                TRACEEOLID("PopulateComboWithKnownIpAddresses: OOM");
                return ERROR_NOT_ENOUGH_MEMORY;
            }

            nNewSel = combo.AddString(pia->QueryIPAddress(bstr));
            oblIpAddresses.AddTail(pia);

            if (iaIpAddress == *pia)
            {
                //
                // This is our current ip address, save index
                // for selection
                //
                nIpAddressSel = nNewSel;
            }
        }
    }

    if (nIpAddressSel < 0)
    {
        //
        // Ok, the IP address selected is not part of the
        // list.  Add it to the list, and select it.
        //
        pia = new CIPAddress(iaIpAddress);

        if (!pia)
        {
            TRACEEOLID("PopulateComboWithKnownIpAddresses: OOM");
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        nIpAddressSel = combo.AddString(pia->QueryIPAddress(bstr));
        oblIpAddresses.AddTail(pia);
    }

    combo.SetCurSel(nIpAddressSel);

    return ERROR_SUCCESS;
}



BOOL
FetchIpAddressFromCombo(
    IN  CComboBox & combo,
    IN  CObListPlus & oblIpAddresses,
    OUT CIPAddress & ia
    )
/*++

Routine Description:

    Helper function to fetch an ip address from the combo box.
    The combo box may not have a selection, in which case whatever
    is in the edit box is used

Arguments:

    CComboBox & combo               : Combo box
    CObListPlus & oblIpAddresses    : Oblist of ip addresses
    CIPAddress & ia                 : Returns the ip address

Return Value:

    TRUE if a valid IP address is found, FALSE otherwise.

--*/
{
    int nSel = combo.GetCurSel();

    if (nSel >= 0)
    {
        //
        // Fetch selected item
        //
        CIPAddress * pia = (CIPAddress *)oblIpAddresses.Index(nSel);
        ASSERT_PTR(pia);
        if (pia != NULL)
        {
            ia = *pia;
            return TRUE;
        }
        else
        {
           return FALSE;
        }
    }

    //
    // Try to make an ip address out of what's in the editbox
    //
    CString str;
    combo.GetWindowText(str);

    if (!str.IsEmpty())
    {
        ia = str;
        if (!ia.IsZeroValue() && !ia.IsBadValue())
        {
            return TRUE;
        }
    }

    //
    // No good
    //
    ::AfxMessageBox(IDS_INVALID_IP_ADDRESS);

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\common\msg.cpp ===
/*++

   Copyright    (c)    1994-1999    Microsoft Corporation

   Module  Name :

        msg.cpp

   Abstract:

        Message Functions

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/

#include "stdafx.h"
#include <lmerr.h>
#include <lmcons.h>
#include <winsock2.h>
#include "common.h"
#include <pudebug.h>

//
// Needed for appsrv facility code.
//
//#include "webcluserr.h"


#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif


#define new DEBUG_NEW


extern HINSTANCE hDLLInstance;



#ifdef _MT

    //
    // Thread protected stuff
    //
    #define RaiseThreadProtection() \
        do {\
            EnterCriticalSection(&_csSect);\
        } while(0)
    #define LowerThreadProtection() \
        do {\
            LeaveCriticalSection(&_csSect);\
        } while (0)

    static CRITICAL_SECTION _csSect;

#else

    #pragma message("Module is not thread-safe.")

    #define RaiseThreadProtection()
    #define LowerThreadProtection()

#endif // _MT




BOOL
InitErrorFunctionality()
/*++

Routine Description:

    Initialize CError class, and allocate static objects

Arguments:

    None:

Return Value:

    TRUE for success, FALSE for failure

--*/
{
#ifdef _MT
    INITIALIZE_CRITICAL_SECTION(&_csSect);
#endif // _MT

    BOOL fOK = CError::AllocateStatics();

    return fOK;
}



void
TerminateErrorFunctionality()
/*++

Routine Description:

    De-initialize CError class, freeing up static objects

Arguments:

    None

Return Value:

    None

--*/
{
    CError::DeAllocateStatics();

#ifdef _MT
    DeleteCriticalSection(&_csSect);
#endif // _MT

}

//
// Static Initialization:
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

const TCHAR g_cszNull[] = _T("(Null)");
const TCHAR CError::s_chEscape = _T('%');        // Error text escape
const TCHAR CError::s_chEscText = _T('h');       // Escape code for text
const TCHAR CError::s_chEscNumber = _T('H');     // Escape code for error code
LPCTSTR CError::s_cszLMDLL = _T("netmsg.dll");   // LM Error File
LPCTSTR CError::s_cszWSDLL = _T("iisui.dll");   // Winsock error file
LPCTSTR CError::s_cszFacility[] = 
{
    /* FACILITY_NULL        */ NULL,
    /* FACILITY_RPC         */ NULL,
    /* FACILITY_DISPATCH    */ NULL,            
    /* FACILITY_STORAGE     */ NULL,
    /* FACILITY_ITF         */ NULL,
    /* FACILITY_DS          */ NULL,
    /* 6                    */ NULL,
    /* FACILITY_WIN32       */ NULL,
    /* FACILITY_WINDOWS     */ NULL,
    /* FACILITY_SSPI        */ NULL,
    /* FACILITY_CONTROL     */ NULL,
    /* FACILITY_CERT        */ NULL,
    /* FACILITY_INTERNET    */ _T("metadata.dll"),
    /* FACILITY_MEDIASERVER */ NULL,
    /* FACILITY_MSMQ        */ NULL,
    /* FACILITY_SETUPAPI    */ NULL,
    /* FACILITY_SCARD       */ NULL,
    /* 17 (MTX)             */ _T("iisui.dll"),
};

HRESULT CError::s_cdwMinLMErr = NERR_BASE; 
HRESULT CError::s_cdwMaxLMErr = MAX_NERR;
HRESULT CError::s_cdwMinWSErr = WSABASEERR;    
HRESULT CError::s_cdwMaxWSErr = WSABASEERR + 2000;    
DWORD   CError::s_cdwFacilities = (sizeof(CError::s_cszFacility)\
    / sizeof(CError::s_cszFacility[0]));

//
// Allocated objects (static MFC objects in a DLL are a no-no)
//
CString * CError::s_pstrDefError;
CString * CError::s_pstrDefSuccs;
CMapDWORDtoCString * CError::s_pmapFacilities;
BOOL CError::s_fAllocated = FALSE;



/* protected */
/* static */
BOOL
CError::AllocateStatics()
/*++

Routine Description:

    Allocate static objects

Arguments:

    None

Return Value:

    TRUE for successfull allocation, FALSE otherwise

--*/
{
    RaiseThreadProtection();

    if (!AreStaticsAllocated())
    {
        try
        {
            CError::s_pstrDefError   = new CString;
            CError::s_pstrDefSuccs   = new CString(_T("0x%08lx"));
            CError::s_pmapFacilities = new CMapDWORDtoCString;
            s_fAllocated = TRUE;

            LPTSTR lp = CError::s_pstrDefError->GetBuffer(255);
            
            if (!::LoadString(
                hDLLInstance,
                IDS_NO_MESSAGE,
                lp,
                255
                ))
            {
                //
                // Just in case we didn't load this message from the resources
                //
                ASSERT_MSG("Unable to load resource message");
                lstrcpy(lp, _T("Error Code: 0x%08lx"));
            }

            CError::s_pstrDefError->ReleaseBuffer();
        }
        catch(CMemoryException * e)
        {
            TRACEEOLID("Initialization Failed");
            e->ReportError();
            e->Delete();
        }
    }

    LowerThreadProtection();

    return AreStaticsAllocated();
}



/* protected */
/* static */
void
CError::DeAllocateStatics()
/*++

Routine Description:

    Clean up allocations

Arguments:

    N/A

Return Value:

    N/A

--*/
{

    RaiseThreadProtection();

    if (AreStaticsAllocated())
    {
        SAFE_DELETE(CError::s_pstrDefError);
        SAFE_DELETE(CError::s_pstrDefSuccs);
        SAFE_DELETE(CError::s_pmapFacilities);

        s_fAllocated = FALSE;
    }

    LowerThreadProtection();
}



/* static */
HRESULT 
CError::CvtToInternalFormat(
    IN HRESULT hrCode
    )
/*++

Routine Description:

    Convert WIN32 or HRESULT code to internal (HRESULT) format.

Arguments:

    DWORD dwCode        Error code

Return Value:

    HRESULT

Notes:

    HRESULTS are left as is.  Lanman and Winsock errors are converted
    to HRESULTS using private facility codes.

--*/
{
    if (IS_HRESULT(hrCode))
    {
        return hrCode;
    }

    if(hrCode >= s_cdwMinLMErr && hrCode <= s_cdwMaxLMErr)
    {
        return MAKE_HRESULT(SEVERITY_ERROR, FACILITY_LANMAN, (DWORD)hrCode);
    }

    if (hrCode >= s_cdwMinWSErr && hrCode <= s_cdwMaxWSErr)
    {
        return MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WINSOCK, (DWORD)hrCode);
    }

    return HResult(hrCode);    
}



/* static */ 
void 
CError::RegisterFacility(
    IN DWORD dwFacility,
    IN LPCSTR lpDLL         OPTIONAL
    )
/*++

Routine Description:

    Register a DLL for a given facility code.  Use NULL to unregister
    the DLL name.

Arguments:

    DWORD dwFacility : Facility code
    LPCSTR lpDLL     : DLL Name.

Return Value:

    None

--*/
{
    RaiseThreadProtection();

    ASSERT(AreStaticsAllocated());

    if (lpDLL == NULL)
    {
        //
        // Remove the facility
        //
        s_pmapFacilities->RemoveKey(dwFacility);
    }
    else
    {
        CString str(lpDLL);

        //
        // Register facility
        //
        s_pmapFacilities->SetAt(dwFacility, str);
    }

    LowerThreadProtection();
}


        
/* static */
LPCTSTR 
CError::FindFacility(
    IN DWORD dwFacility
    )
/*++

Routine Description:

    Determine if a DLL name has been registered for the given facility
    code.

Arguments:

    DWORD dwFacility        : Facility code

Return Value:

    Returns the DLL name, or NULL.

--*/
{
    RaiseThreadProtection();

    ASSERT(AreStaticsAllocated());

    LPCTSTR pRes = NULL;
    CString strDLL;

    if (s_pmapFacilities->Lookup(dwFacility, strDLL))
    {
        pRes = strDLL;
    }

    LowerThreadProtection();

    return pRes;
}



CError::~CError()
/*++

Routine Description:

    Destructor

Arguments:

    None

Return Value:

    N/A

--*/
{
}



const CError & 
CError::Construct(
    IN HRESULT hr
    )
/*++

Routine Description:

    construct with new value.

Arguments:
    
    HRESULT hr : New value, either an HRESULT or a WIN32
                 error code.

Return Value:

    Reference to current object

--*/
{
    ASSERT(AreStaticsAllocated());

    m_hrCode = CvtToInternalFormat(hr);

    return *this;
}



const CError & 
CError::Construct(
    IN const CError & err
    )
/*++

Routine Description:

    Assign new value.

Arguments:
    
    CError & err    : Error code

Return Value:

    Reference to current object

--*/
{
    ASSERT(AreStaticsAllocated());

    m_hrCode = err.m_hrCode;

    return *this;
}



int
CError::MessageBox(
    IN UINT    nType,
    IN UINT    nHelpContext OPTIONAL
    ) const
/*++

Routine Description:

    Display error message in a message box

Arguments:

    HRESULT hrCode       : HRESULT error code
    UINT    nType        : See AfxMessageBox for documentation
    UINT    nHelpContext : See AfxMessageBox for documentation

Return Value:

    AfxMessageBox return code

--*/
{
    CString strMsg;

    nHelpContext;
    HWND hwndParent = NULL;
    TextFromHRESULT(strMsg);

    //
    // Try to find the main window (hopefully an MFC app)
    //
    CWnd * pWnd = ::AfxGetMainWnd();
    if (pWnd)
    {
        hwndParent = pWnd->m_hWnd;
    }

    return ::MessageBox(hwndParent, strMsg, NULL, nType);
}




//
// Extend CString just to get at FormatV publically
//
class CStringEx : public CString
{
public:
    void FormatV(LPCTSTR lpszFormat, va_list argList)
    {
       LPTSTR p = GetBuffer(1024);
       VERIFY(-1 != _vsntprintf(p, 1024, lpszFormat, argList));
       ReleaseBuffer(-1);
    }
};



int 
CError::MessageBoxFormat(
    IN UINT nFmt,
    IN UINT nType,
    IN UINT nHelpContext,
    ...
    ) const
/*++

Routine Description:

    Display formatted error message in messagebox.  The format
    string (given as a resource ID) is a normal printf-style
    string, with the additional parameter of %h, which takes
    the text equivalent of the error message, or %H, which takes
    the error return code itself.

Arguments:

    UINT    nFmt         : Resource format
    UINT    nType        : See AfxMessageBox for documentation
    UINT    nHelpContext : See AfxMessageBox for documentation
    ...                    More as needed for sprintf

Return Value:

    AfxMessageBox return code
    
--*/
{
    CString strFmt;
    CStringEx strMsg;

    strFmt.LoadString(nFmt);

    //
    // First expand the error
    //
    TextFromHRESULTExpand(strFmt);

    va_list marker;
    va_start(marker, nHelpContext);
    strMsg.FormatV(strFmt, marker);
    va_end(marker);

    //
    // Ensure we have a CWinApp
    //
    if (AfxGetApp() != NULL)
    {
        return ::AfxMessageBox(strMsg, nType, nHelpContext);
    }

    //
    // Else hang the message box off the desktop.
    // this must be a console app
    //

#ifndef _CONSOLE
    
    ASSERT_MSG("No winapp detected -- using desktop as parent handle");

#endif // _CONSOLE

    return ::MessageBox(NULL, strMsg, NULL, nType);
}


BOOL 
CError::MessageBoxOnFailure(
    IN UINT nType,
    IN UINT nHelpContext    OPTIONAL
    ) const
/*++

Routine Description:

    Display message box if the current error is a failure
    condition, else do nothing

Arguments:

    UINT    nType        : See AfxMessageBox for documentation
    UINT    nHelpContext : See AfxMessageBox for documentation

Return Value:

    TRUE if a messagebox was shown, FALSE otherwise

--*/
{
    if (Failed())
    {
        MessageBox(nType, nHelpContext);
        return TRUE;
    }

    return FALSE;
}



BOOL 
CError::HasOverride(
    OUT UINT * pnMessage        OPTIONAL
    ) const
/*++

Routine Description:

    Check to see if a given HRESULT has an override

Arguments:

    HRESULT hrCode              : HRESULT to check for
    UINT * pnMessage            : Optionally returns the override

Return Value:

    TRUE if there is an override, FALSE if there is not.

--*/
{
    ASSERT(AreStaticsAllocated());

    UINT nID;
    HRESULT hrCode = CvtToInternalFormat(m_hrCode);
    BOOL fResult = mapOverrides.Lookup(hrCode, nID);

    if (fResult && pnMessage != NULL)
    {
        *pnMessage = nID;
    }

    return fResult;
}



UINT
CError::AddOverride(
    IN HRESULT    hrCode,
    IN UINT       nMessage
    )
/*++

Routine Description:

    Add an override for a specific HRESULT.

Arguments:

    HRESULT    hrCode       : HRESULT to override
    UINT       nMessage     : New message, or -1 to remove override

Return Value:

    The previous override, or -1

--*/
{
    ASSERT(AreStaticsAllocated());

    UINT nPrev;
    hrCode = CvtToInternalFormat(hrCode);

    //
    // Fetch the current override
    //
    if (!mapOverrides.Lookup(hrCode, nPrev))
    {
        //
        // Didn't exist
        //
        nPrev = REMOVE_OVERRIDE;
    }

    if (nMessage == REMOVE_OVERRIDE)
    {
        //
        // Remove the override
        //
        mapOverrides.RemoveKey(hrCode);
    }
    else
    {
        //
        // Set new override
        //
        mapOverrides.SetAt(hrCode, nMessage);
    }

    return nPrev;
}



void
CError::RemoveAllOverrides()
/*++

Routine Description:

    Remove all overrides

Arguments:

    None

Return Value:

    None

--*/
{
    ASSERT(AreStaticsAllocated());
    mapOverrides.RemoveAll();
}



HRESULT
CError::TextFromHRESULT(
    OUT LPTSTR  szBuffer,
    OUT DWORD   cchBuffer
    ) const
/*++

Routine Description:

    Get text from the given HRESULT.  Based on the range that the HRESULT
    falls in and the facility code, find the location of the message,
    and fetch it.

Arguments:

    HRESULT hrCode      HRESULT or (DWORD WIN32 error) whose message to get
    LPTSTR  szBuffer    Buffer to load message text into
    DWORD   cchBuffer   Size of buffer in characters.

Return Value:

    HRESULT error code depending on whether the message was
    found.  If the message was not found, some generic message
    is synthesized in the buffer if a buffer is provided.

    ERROR_FILE_NOT_FOUND        No message found
    ERROR_INSUFFICIENT_BUFFER   Buffer is a NULL pointer or too small

--*/
{
    HRESULT hrReturn = ERROR_SUCCESS;

    //
    // First check to see if this message is overridden
    //
    UINT nID;
    HRESULT hrCode = m_hrCode;

    if (HasOverride(&nID))
    {
        //
        // Message overridden.  Load replacement message
        // instead.
        //
        BOOL fSuccess;

        //
        // Attempt to load from calling process first
        //
        if (FALSE == (fSuccess = ::LoadString(
                           ::GetModuleHandle(NULL), nID, szBuffer, cchBuffer)))
        {
            //
            // Try this dll
            //
            fSuccess = ::LoadString(hDLLInstance, nID, szBuffer, cchBuffer);
        }

        if (fSuccess)
        {
            //
            // Everything ok
            //
            return hrReturn;
        }

        //
        // Message didn't exist, skip the override, and 
        // load as normal.
        //
        TRACEEOLID("Couldn't load " << nID);
        ASSERT_MSG("Attempted override failed");
    }

    LPCTSTR lpDll    = NULL;
    HINSTANCE hDll   = NULL;
    DWORD dwFacility = HRESULT_FACILITY(hrCode);
//    DWORD dwSeverity = HRESULT_SEVERITY(hrCode);
    DWORD dwCode     = HRESULT_CODE(hrCode);
    BOOL  fSuccess   = Succeeded(hrCode);

    //
    // Strip off meaningless internal facility codes
    //
    if (dwFacility == FACILITY_LANMAN || dwFacility == FACILITY_WINSOCK)
    {
        dwFacility = FACILITY_NULL;
        hrCode   = (HRESULT)dwCode;
    }

    DWORD dwFlags = FORMAT_MESSAGE_IGNORE_INSERTS | 
                    FORMAT_MESSAGE_MAX_WIDTH_MASK;

    //
    // Since we allow both HRESULTS and WIN32 codes to be
    // used here, we can't rely on the private FACILITY code 
    // for lanman and winsock.
    //
    if(hrCode >= s_cdwMinLMErr && hrCode <= s_cdwMaxLMErr)
    {
        //
        // Lanman error
        //
        lpDll = s_cszLMDLL;
    }
    else if (hrCode >= s_cdwMinWSErr && hrCode <= s_cdwMaxWSErr)
    {
        //
        // Winsock error
        //
        lpDll = s_cszWSDLL;
    }
    else
    {
        //
        // Attempt to determine message location from facility code.
        // Check for registered facility first.
        //
        lpDll = FindFacility(dwFacility);

        if (lpDll == NULL)
        {
            if (dwFacility < s_cdwFacilities)
            {
                lpDll = s_cszFacility[dwFacility];
            }
            else
            {
                ASSERT_MSG("Bogus FACILITY code encountered.");
                lpDll = NULL;
            }
        }
    }

    do
    {
        if (szBuffer == NULL || cchBuffer <= 0)
        {
            hrReturn = HResult(ERROR_INSUFFICIENT_BUFFER);
            break;
        }

        if (lpDll)
        {
            //
            // Load message file
            //
            hDll = ::LoadLibraryEx(
                lpDll,
                NULL,
                LOAD_LIBRARY_AS_DATAFILE
                );

            if (hDll == NULL)
            {
                hrReturn = ::GetLastHRESULT();
                break;
            }

            dwFlags |= FORMAT_MESSAGE_FROM_HMODULE;
        }
        else
        {
            dwFlags |= FORMAT_MESSAGE_FROM_SYSTEM;
        }

        DWORD dwResult = 0L;
        DWORD dwID = hrCode;
        HINSTANCE hSource = hDll;

        while(!dwResult)
        {
            dwResult = ::FormatMessage(
                dwFlags,
                (LPVOID)hSource,
                dwID,
                0,
                szBuffer,
                cchBuffer,
                NULL
                );

            if (dwResult > 0)
            {
                //
                // Successfully got a message
                //
                hrReturn = ERROR_SUCCESS;
                break;
            } 

            hrReturn = ::GetLastHRESULT();
    
            if (dwID != dwCode && !fSuccess)
            {
                //
                // Try the SCODE portion of the error from win32
                // if this is an error message
                //
                dwID = dwCode;
                hSource = NULL;
                continue;
            }

            //
            // Failed to obtain a message
            //
            hrReturn = HResult(ERROR_FILE_NOT_FOUND);
            break;
        }
    }
    while(FALSE);

    if(hDll != NULL)
    {
        ::FreeLibrary(hDll);
    }

    if (Failed(hrReturn))
    {
        //
        // Unable to find the message, synthesize something with
        // the code in it if there's room (+8 for the number)
        //
        CString & strMsg = (fSuccess ? *s_pstrDefSuccs : *s_pstrDefError);

        if (cchBuffer > (DWORD)strMsg.GetLength() + 8)
        {
            TRACEEOLID("Substituting default message for " << (DWORD)m_hrCode);
            wsprintf(szBuffer, (LPCTSTR)strMsg, m_hrCode);
        }
        else
        {
            //
            // Not enough room for message code
            //
            ASSERT_MSG("Buffer too small for default message -- left blank");
            *szBuffer = _T('\0');
        }
    }

    return hrReturn;
}



HRESULT 
CError::TextFromHRESULT(
    OUT CString & strBuffer
    ) const
/*++

Routine Description:

    Similar to the function above, but use a CString

Arguments:

    HRESULT hrCode         HRESULT or (DWORD WIN32 error) whose message to get
    CString & strBuffer    Buffer to load message text into

Return Value:

    HRESULT error code depending on whether the message was
    found.  If the message was not found, some generic message
    is synthesized in the buffer if a buffer is provided.

    ERROR_FILE_NOT_FOUND   No message found

--*/
{
    DWORD cchBuffer = 255;
    HRESULT hr = S_OK;

    for (;;)
    {
        LPTSTR szBuffer = strBuffer.GetBuffer(cchBuffer + 1);

        if (szBuffer == NULL)
        {
            return HResult(ERROR_NOT_ENOUGH_MEMORY);
        }

        hr = TextFromHRESULT(szBuffer, cchBuffer);

        if (Win32Error(hr) != ERROR_INSUFFICIENT_BUFFER)
        {
            //
            // Done!
            //
            break;
        }

        //
        // Insufficient buffer, enlarge and try again
        //
        cchBuffer *= 2;
    }

    strBuffer.ReleaseBuffer();

    return hr;
}



BOOL
CError::ExpandEscapeCode(
    IN  LPTSTR szBuffer,
    IN  DWORD cchBuffer,
    OUT IN LPTSTR & lp,
    IN  CString & strReplacement,
    OUT HRESULT & hr
    ) const
/*++

Routine Description:

    Expand escape code

Arguments:

    LPTSTR szBuffer             Buffer
    DWORD cchBuffer             Size of buffer
    LPTSTR & lp                 Pointer to escape code
    CString & strReplacement    Message to replace the escape code
    HRESULT & hr                Returns HRESULT in case of failure

Return Value:

    TRUE if the replacement was successful, FALSE otherwise.
    In the case of failure, hr will return an HRESULT.
    In the case of success, lp will be advanced past the
    replacement string.

--*/
{
    //
    // Make sure there's room (account for terminating NULL)
    // Free up 2 spaces for the escape code.
    //
    int cchFmt = lstrlen(szBuffer) - 2;
    int cchReplacement = strReplacement.GetLength();
    int cchRemainder = lstrlen(lp + 2);

    if (    lp != NULL && (lp + 2) != NULL 
       &&   (DWORD)(cchReplacement + cchFmt) < cchBuffer
       )
    {
        //
        // Put it in
        //
        MoveMemory(
            lp + cchReplacement,
            lp + 2,
            (cchRemainder + 1) * sizeof(TCHAR)
            );
        CopyMemory(lp, strReplacement, cchReplacement * sizeof(TCHAR));
        lp += cchReplacement;
        
        return TRUE;
    }

    hr = HResult(ERROR_INSUFFICIENT_BUFFER);

    return FALSE;
}



LPCTSTR 
CError::TextFromHRESULTExpand(
    OUT LPTSTR  szBuffer,
    OUT DWORD   cchBuffer,
    OUT HRESULT * phResult  OPTIONAL
    ) const
/*++

Routine Description:

    Expand %h/%H strings in szBuffer to text from HRESULT,
    or error code respectively within the limits of szBuffer.

Arguments:

    LPTSTR  szBuffer    Buffer to load message text into
    DWORD   cchBuffer   Buffer size in characters
    HRESULT * phResult  Optional return code

Return Value:

    Pointer to string.

--*/
{
    HRESULT hr = S_OK;

    if (szBuffer == NULL || cchBuffer <= 0)
    {
        hr = HResult(ERROR_INSUFFICIENT_BUFFER);
    }
    else
    {
        //
        // Look for the escape sequence
        //
        int cReplacements = 0;
        CString strMessage;
        LPTSTR lp = szBuffer;

        while (*lp)
        {
            if (*lp == s_chEscape)
            {
                switch(*(lp + 1))
                {
                case s_chEscText:
                    //
                    // Replace escape code with text message
                    //
                    hr = TextFromHRESULT(strMessage);

                    if (ExpandEscapeCode(
                        szBuffer,
                        cchBuffer,
                        lp,
                        strMessage,
                        hr
                        ))
                    {
                        ++cReplacements;
                    }
                    break;

                case s_chEscNumber:
                    //
                    // Replace escape code with numeric error code
                    //
                    strMessage.Format(_T("0x%08x"), m_hrCode);

                    if (ExpandEscapeCode(
                        szBuffer,
                        cchBuffer,
                        lp,
                        strMessage,
                        hr
                        ))
                    {
                        ++cReplacements;
                    }
                    break;

                default:
                    //
                    // Regular printf-style escape sequence.
                    //
                    break;
                }
            }

            ++lp;
        }

        if (!cReplacements)
        {
            //
            // Got to the end without finding any escape codes.
            //
            hr = HResult(ERROR_INVALID_PARAMETER);
        }
    }

    if (phResult)
    {
        *phResult = hr;
    }

    return szBuffer;
}



LPCTSTR 
CError::TextFromHRESULTExpand(
    OUT CString & strBuffer
    ) const
/*++

Routine Description:

    Expand %h string in strBuffer to text from HRESULT

Arguments:

    CString & strBuffer Buffer to load message text into

Return Value:

    Pointer to string.

--*/
{
    DWORD cchBuffer = strBuffer.GetLength() + 1024;

    for (;;)
    {
        LPTSTR szBuffer = strBuffer.GetBuffer(cchBuffer + 1);

        if (szBuffer != NULL)
        {
            HRESULT hr;

            TextFromHRESULTExpand(szBuffer, cchBuffer, &hr);

            if (Win32Error(hr) != ERROR_INSUFFICIENT_BUFFER)
            {
                //
                // Done!
                //
                break;
            }

            //
            // Insufficient buffer, enlarge and try again
            //
            cchBuffer *= 2;
        }
    }

    strBuffer.ReleaseBuffer();

    return strBuffer;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\common\mdkeys.cpp ===
/*++

   Copyright    (c)    1994-2001    Microsoft Corporation

   Module  Name :
        mdkeys.cpp

   Abstract:
        Metabase key wrapper class

   Author:
        Ronald Meijer (ronaldm)
        Sergei Antonov (sergeia)

   Project:
        Internet Services Manager

   Revision History:

--*/



//
// Include Files
//
#include "stdafx.h"
#include "common.h"
#include "idlg.h"
#include "mdkeys.h"
//#include <acsmb.h> 
//#include <iisrf.h>



#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif



#define new DEBUG_NEW


extern HINSTANCE hDLLInstance;


//
// Constants
//
#define MB_TIMEOUT          (15000)     // Timeout in milliseconds 
#define MB_INIT_BUFF_SIZE   (  256)     // Initial buffer size



//
// CComAuthInfo implementation
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



/* static */
BOOL
CComAuthInfo::SplitUserNameAndDomain(
    IN OUT CString & strUserName,
    IN CString & strDomainName
    )
/*++

Routine Description:

    Split the user name and domain from the given
    username, which is in the format "domain\user".

    Return TRUE if the user name contained a domain
    FALSE if it did not

Arguments:

    CString & strUserName   : User name which may contain a domain name
    CString & strDomainName : Output domain name ("." if local)

Return Value:

    TRUE if a domain is split off

--*/
{
    //
    // Assume local
    //
    strDomainName = _T(".");
    int nSlash = strUserName.Find(_T("\\"));

    if (nSlash >= 0)
    {
        strDomainName = strUserName.Left(nSlash);
        strUserName = strUserName.Mid(nSlash + 1);

        return TRUE;
    }

    return FALSE;
}



/* static */
DWORD
CComAuthInfo::VerifyUserPassword(
    IN LPCTSTR lpstrUserName,
    IN LPCTSTR lpstrPassword
    )
/*++

Routine Description:

    Verify the usernamer password combo checks out

Arguments:

    LPCTSTR lpstrUserName   : Domain/username combo
    LPCTSTR lpstrPassword   : Password

Return Value:

    ERROR_SUCCESS if the password checks out, an error code
    otherwise.

--*/
{
    CString strDomain;
    CString strUser(lpstrUserName);
    CString strPassword(lpstrPassword);

    SplitUserNameAndDomain(strUser, strDomain);

    //
    // In order to look up an account name, this process
    // must first be granted the privilege of doing so.
    //
    CError err;
    {
        HANDLE hToken;
        LUID AccountLookupValue;
        TOKEN_PRIVILEGES tkp;

        do
        {
            if (!::OpenProcessToken(GetCurrentProcess(),
                TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
                &hToken)
                )
            {
                err.GetLastWinError();
                break;
            }

            if (!::LookupPrivilegeValue(NULL, SE_TCB_NAME, &AccountLookupValue))
            {
                err.GetLastWinError();
                break;
            }

            tkp.PrivilegeCount = 1;
            tkp.Privileges[0].Luid = AccountLookupValue;
            tkp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

            ::AdjustTokenPrivileges(
                hToken,
                FALSE,
                &tkp,
                sizeof(TOKEN_PRIVILEGES),
                (PTOKEN_PRIVILEGES)NULL,
                (PDWORD)NULL
                );

            err.GetLastWinError();

            if (err.Failed())
            {
                break;
            }

            HANDLE hUser = NULL;

            if (::LogonUser(
                strUser.GetBuffer(0),
                strDomain.GetBuffer(0),
                strPassword.GetBuffer(0),
                LOGON32_LOGON_NETWORK,
                LOGON32_PROVIDER_DEFAULT,
                &hUser
                ))
            {
                //
                // Success!
                //
                CloseHandle(hUser);
            }
            else
            {
                err.GetLastWinError();
            }

            //
            // Remove the privilege
            //
        }
        while(FALSE);
    }

    HANDLE hUser = NULL;

    if (::LogonUser(
        strUser.GetBuffer(0),
        strDomain.GetBuffer(0),
        strPassword.GetBuffer(0),
        LOGON32_LOGON_NETWORK,
        LOGON32_PROVIDER_DEFAULT,
        &hUser))
    {
        //
        // Success!
        //
        CloseHandle(hUser);
    }
    else
    {
        err.GetLastWinError();
    }

    return err;
}



CComAuthInfo::CComAuthInfo(
    IN LPCOLESTR lpszServerName     OPTIONAL,
    IN LPCOLESTR lpszUserName       OPTIONAL,
    IN LPCOLESTR lpszPassword       OPTIONAL
    )
/*++

Routine Description:

    Construct CIIServer object

Argument:

    LPCOLESTR lpszServerName     : Server name or NULL for local computer
    LPCOLESTR lpszUserName       : User name of blank for no impersonation
    LPCOLESTR lpszPassword       : Password (might be blank or NULL)

Return Value:

    N/A

--*/
    : m_bstrServerName(),
      m_bstrUserName(lpszUserName),
      m_bstrPassword(lpszPassword),
      m_fLocal(FALSE)
{
    SetComputerName(lpszServerName);
}



CComAuthInfo::CComAuthInfo(
    IN CComAuthInfo & auth
    )
/*++

Routine Description:

    Copy constructor

Arguments:

    CComAuthInfo & auth    : Source object to copy from

Return Value:

    N/A

--*/
    : m_bstrServerName(auth.m_bstrServerName),
      m_bstrUserName(auth.m_bstrUserName),
      m_bstrPassword(auth.m_bstrPassword),
      m_fLocal(auth.m_fLocal)
{
}



CComAuthInfo::CComAuthInfo(
    IN CComAuthInfo * pAuthInfo        OPTIONAL
    )
/*++

Routine Description:

    Copy constructor

Arguments:

    CComAuthInfo * pAuthInfo    : Source object to copy from (or NULL)

Return Value:

    N/A

--*/
    : m_bstrServerName(),
      m_bstrUserName(),
      m_bstrPassword(),
      m_fLocal(FALSE)
{
    if (pAuthInfo)
    {
        //
        // Full authentication information available
        //
        m_bstrUserName = pAuthInfo->m_bstrUserName;
        m_bstrPassword = pAuthInfo->m_bstrPassword;
        m_bstrServerName = pAuthInfo->m_bstrServerName;
        m_fLocal = pAuthInfo->m_fLocal;
    }
    else
    {
        //
        // Local computer w/o impersonation
        //
        SetComputerName(NULL);
    }
}



CComAuthInfo & 
CComAuthInfo::operator =(
    IN CComAuthInfo & auth
    )
/*++

Routine Description:

    Assignment operator

Arguments:

    CComAuthInfo & auth     : Source object to copy from

Return Value:

    Reference to current object

--*/
{
    m_bstrServerName = auth.m_bstrServerName;
    m_bstrUserName   = auth.m_bstrUserName;
    m_bstrPassword   = auth.m_bstrPassword;
    m_fLocal         = auth.m_fLocal;

    return *this;
}



CComAuthInfo & 
CComAuthInfo::operator =(
    IN CComAuthInfo * pAuthInfo       OPTIONAL
    )
/*++

Routine Description:

    Assignment operator

Arguments:

    CComAuthInfo * pAuthInfo : Source object to copy from (or NULL)

Return Value:

    Reference to current object

--*/
{
    if (pAuthInfo)
    {
        m_bstrUserName = pAuthInfo->m_bstrUserName;
        m_bstrPassword = pAuthInfo->m_bstrPassword;
        SetComputerName(pAuthInfo->m_bstrServerName);
    }
    else
    {
        //
        // Local computer w/o impersonation
        //
        m_bstrUserName.Empty();
        m_bstrPassword.Empty();
        SetComputerName(NULL);
    }

    return *this;
}




CComAuthInfo & 
CComAuthInfo::operator =(
    IN LPCTSTR lpszServerName
    )
/*++

Routine Description:

    Assignment operator.  Assign computer name w/o impersonation

Arguments:

    LPCTSTR lpszServerName      : Source server name

Return Value:

    Reference to current object

--*/
{
    RemoveImpersonation();
    SetComputerName(lpszServerName);

    return *this;
}



void
CComAuthInfo::SetComputerName(
    IN LPCOLESTR lpszServerName   OPTIONAL
    )
/*++

Routine Description:

    Store the computer name.  Determine if its local.

Arguments:

    LPCOLESTR lpszServername  : Server name.  NULL indicates the local computer

Return Value:

    None

--*/
{
    if (lpszServerName && *lpszServerName)
    {
        //
        // Specific computer name specified
        //
        m_bstrServerName = lpszServerName;
        m_fLocal = ::IsServerLocal(lpszServerName);
        TRACEEOLID("Computer name " << lpszServerName << " Local: " << m_fLocal);
    }
    else
    {
        //
        // Use local computer name
        //
        // CODEWORK: Cache static version of computername maybe?
        // 
        TCHAR szLocalServer[MAX_PATH + 1];
        DWORD dwSize = MAX_PATH;

        VERIFY(::GetComputerName(szLocalServer, &dwSize));
        m_bstrServerName = szLocalServer;
        m_fLocal = TRUE;
        TRACEEOLID("Using local computer name " << szLocalServer);
    }
}



void     
CComAuthInfo::SetImpersonation(
    IN LPCOLESTR lpszUser, 
    IN LPCOLESTR lpszPassword
    )
/*++

Routine Description:

    Set impersonation parameters

Arguments:

    LPCOLESTR lpszUser          : User name
    LPCOLESTR lpszPassword      : Password

Return Value:

    None

--*/
{
    m_bstrUserName = lpszUser;
    StorePassword(lpszPassword);
}



void     
CComAuthInfo::RemoveImpersonation()
/*++

Routine Description:

    Remove impersonation parameters

Arguments:

    None

Return Value:

    None

--*/
{
    m_bstrUserName.Empty();
    m_bstrPassword.Empty();
}


COSERVERINFO * 
CComAuthInfo::CreateServerInfoStruct() const
{
    return (CComAuthInfo::CreateServerInfoStruct(RPC_C_AUTHN_LEVEL_CONNECT));
}



COSERVERINFO * 
CComAuthInfo::CreateServerInfoStruct(DWORD dwAuthnLevel) const
/*++

Routine Description:

    Create the server info structure.  Might return NULL for the no frills case.

Arguments:

    NULL

Return Value:

    A COSERVERINFO structure, or NULL if the computer is local, and no
    impersonation is required.

Notes:

    Caller must call FreeServerInfoStruct() to prevent memory leaks

--*/
{
    //
    // Be smart about the server name; optimize for local
    // computer name.
    //
    if (m_fLocal && !UsesImpersonation())
    {
        //
        // Special, no-frills case. 
        //
        return NULL;
    }

    //
    // Create the COM server info for CoCreateInstanceEx
    //
    COSERVERINFO * pcsiName = NULL;

    do
    {
        pcsiName = (COSERVERINFO *)AllocMem(sizeof(COSERVERINFO));

        if (!pcsiName)
        {
            break;
        }

        pcsiName->pwszName = m_bstrServerName;

        //
        // Set impersonation 
        //
        if (UsesImpersonation())
        {
            COAUTHINFO * pAuthInfo = (COAUTHINFO *)AllocMem(sizeof(COAUTHINFO));

            if (!pAuthInfo)
            {
                break;
            }

            COAUTHIDENTITY * pAuthIdentityData = 
                (COAUTHIDENTITY *)AllocMem(sizeof(COAUTHIDENTITY));

            if (!pAuthIdentityData)
            {
                break;
            }

            CString strUserName(m_bstrUserName);
            CString strPassword(m_bstrPassword);
            CString strDomain;

            //
            // Break up domain\username combo
            //
            SplitUserNameAndDomain(strUserName, strDomain);

            pAuthIdentityData->UserLength = strUserName.GetLength();

            if (pAuthIdentityData->UserLength)
            {
                pAuthIdentityData->User = AllocString(
                    strUserName, 
                    strUserName.GetLength()
                    );
            }

            pAuthIdentityData->DomainLength = strDomain.GetLength();

            if (pAuthIdentityData->DomainLength)
            {
                pAuthIdentityData->Domain = AllocString(
                    strDomain,
                    strDomain.GetLength()
                    );
            }

            pAuthIdentityData->PasswordLength = strPassword.GetLength();

            if (pAuthIdentityData->PasswordLength)
            {
                pAuthIdentityData->Password = AllocString(
                    strPassword,
                    strPassword.GetLength()
                    );
            }

            // RPC_C_AUTHN_LEVEL_DEFAULT       0 
            // RPC_C_AUTHN_LEVEL_NONE          1 
            // RPC_C_AUTHN_LEVEL_CONNECT       2 
            // RPC_C_AUTHN_LEVEL_CALL          3 
            // RPC_C_AUTHN_LEVEL_PKT           4 
            // RPC_C_AUTHN_LEVEL_PKT_INTEGRITY 5 
            // RPC_C_AUTHN_LEVEL_PKT_PRIVACY   6 
            // you can only specify stuff stronger than RPC_C_AUTHN_LEVEL_CONNECT
            if (dwAuthnLevel >= RPC_C_AUTHN_LEVEL_CONNECT && dwAuthnLevel <= RPC_C_AUTHN_LEVEL_PKT_PRIVACY)
            {
                pAuthInfo->dwAuthnLevel = dwAuthnLevel;
            }
            else
            {
                pAuthInfo->dwAuthnLevel = RPC_C_AUTHN_LEVEL_CONNECT;
            }
            pAuthIdentityData->Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE;
            pAuthInfo->dwImpersonationLevel = RPC_C_IMP_LEVEL_IMPERSONATE;
            pAuthInfo->dwAuthnSvc = RPC_C_AUTHN_WINNT;
            pAuthInfo->dwAuthzSvc = RPC_C_AUTHZ_NONE;
            pAuthInfo->pwszServerPrincName = NULL;
            pAuthInfo->dwCapabilities = EOAC_NONE;
            pAuthInfo->pAuthIdentityData = pAuthIdentityData;
            pcsiName->pAuthInfo = pAuthInfo;
        }
    }
    while(FALSE);

    return pcsiName;
}



void 
CComAuthInfo::FreeServerInfoStruct(
    IN COSERVERINFO * pServerInfo
    ) const
/*++

Routine Description:

    As mentioned above -- free the server info structure

Arguments:

    COSERVERINFO * pServerInfo  : Server info structure

Return Value:

    None

--*/
{
    if (pServerInfo)
    {
        if (pServerInfo->pAuthInfo)
        {
            if (pServerInfo->pAuthInfo->pAuthIdentityData)
            {
                if (pServerInfo->pAuthInfo->pAuthIdentityData)
                {
                    SAFE_FREEMEM(pServerInfo->pAuthInfo->pAuthIdentityData->User);
                    SAFE_FREEMEM(pServerInfo->pAuthInfo->pAuthIdentityData->Domain);
                    SAFE_FREEMEM(pServerInfo->pAuthInfo->pAuthIdentityData->Password);
                    FreeMem(pServerInfo->pAuthInfo->pAuthIdentityData);
                }
            }

            FreeMem(pServerInfo->pAuthInfo);
        }

        FreeMem(pServerInfo);
    }
}



HRESULT
CComAuthInfo::ApplyProxyBlanket(
    IN OUT IUnknown * pInterface
    )
/*++

Routine Description:

    Set security information on the interface.  The user name is of the form
    domain\username.

Arguments:

    IUnknown * pInterface       : Interface

Return Value:

    HRESULT

--*/
{
    HRESULT hr = S_OK;

    COSERVERINFO * pcsiName = CreateServerInfoStruct();

    //
    // This method should only be called if we're using impersonation.
    // so the pcsiName returned should never be NULL.
    //
    ASSERT(pcsiName && pcsiName->pAuthInfo);

    if (pcsiName && pcsiName->pAuthInfo)
    {
        hr =  ::CoSetProxyBlanket(
            pInterface,
            pcsiName->pAuthInfo->dwAuthnSvc,
            pcsiName->pAuthInfo->dwAuthzSvc,
            pcsiName->pAuthInfo->pwszServerPrincName,
            pcsiName->pAuthInfo->dwAuthnLevel,
            pcsiName->pAuthInfo->dwImpersonationLevel,
            pcsiName->pAuthInfo->pAuthIdentityData,
            pcsiName->pAuthInfo->dwCapabilities    
            );

        FreeServerInfoStruct(pcsiName);
    }

    return hr;
}



//
// CMetabasePath implemention
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



const LPCTSTR CMetabasePath::_cszMachine = SZ_MBN_MACHINE;
const LPCTSTR CMetabasePath::_cszRoot    = SZ_MBN_ROOT;
const LPCTSTR CMetabasePath::_cszSep     = SZ_MBN_SEP_STR;
const TCHAR   CMetabasePath::_chSep      = SZ_MBN_SEP_CHAR;



/* static */
LPCTSTR
CMetabasePath::ConvertToParentPath(
    OUT IN CString & strMetaPath
    )
/*++

Routine Description:

    Given the path, convert it to the parent path
    e.g. "foo/bar/etc" returns "foo/bar"

Arguments:

    CString & strMetaPath    : Path to be converted

Return value:

    Pointer to the converted path, or NULL in case of error

--*/
{
    TRACEEOLID("Getting parent path of " << strMetaPath);

    LPTSTR lpszPath = strMetaPath.GetBuffer(1);
    LPTSTR lpszTail = lpszPath + lstrlen(lpszPath) - 1;
    LPTSTR lpszReturn = NULL;

    do
    {
        if (lpszTail <= lpszPath)
        {
            break;
        }

        //
        // Strip trailing backslash
        //
        if (*lpszTail == _chSep)
        {
            *lpszTail-- = _T('\0');
        }

        //
        // Search for parent
        //
        while (lpszTail > lpszPath && *lpszTail != _chSep)
        {
            --lpszTail;
        }

        if (lpszTail <= lpszPath)
        {
            break;
        }

        *lpszTail = _T('\0');

        lpszReturn = lpszPath;
    }
    while(FALSE);

    strMetaPath.ReleaseBuffer();

    TRACEEOLID("Parent path should be " << strMetaPath);

    return lpszReturn;
}



/* static */
LPCTSTR
CMetabasePath::TruncatePath(
    IN  int     nLevel,          
    IN  LPCTSTR lpszMDPath,
    OUT CString & strNewPath,
    OUT CString * pstrRemainder     OPTIONAL
    )
/*++

Routine Description:

    Truncate the given metabase path at the given level, that is, 
    the nLevel'th separator in the path, starting at 0, where 0 will
    always give lpszPath back whether it started with a separator or not.

    Examples: 

        "/lm/w3svc/1/foo" at level 2 returns "/lm/w3svc" as does
        "lm/w3svc/1/foo".
    
Arguments:

    int     nLevel             0-based separator count to truncate at.
    LPTSTR lpszMDPath          Fully-qualified metabase path
    CString & strNewPath       Returns truncated path
    CString * pstrRemainder    Optionally returns the remainder past
                               the nLevel'th separator.

Return Value:

    The truncated path at the level requested.  See examples above. *pstrRemainder
    returns the remainder of the path.  If the path does not contain nLevel
    worth of separators, the entire path is returned, and the remainder will be
    blank. 

--*/
{
    ASSERT_PTR(lpszMDPath);
    ASSERT(nLevel >= 0);

    if (!lpszMDPath || nLevel < 0)
    {
        TRACEEOLID("TruncatePath: Invalid parameter");
        return NULL;
    }

    TRACEEOLID("Source Path: " << lpszMDPath);

    //
    // Skip the first sep whether it exists or not
    //
    LPCTSTR lp = *lpszMDPath == _chSep ? lpszMDPath + 1 : lpszMDPath;
    LPCTSTR lpRem = NULL;
    int cSeparators = 0;

    if (nLevel)
    {
        //
        // Advance to the requested separator level
        //
        while (*lp)
        {
            if (*lp == _chSep)
            {
                if (++cSeparators == nLevel)
                {
                    break;
                }
            }

            ++lp;
        }

        if (!*lp)
        {
            //
            // End of path is considered a separator
            //
            ++cSeparators;
        }

        ASSERT(cSeparators <= nLevel);

        if (cSeparators == nLevel)
        {
            //
            // Break up the strings
            //
            strNewPath = lpszMDPath;
            strNewPath.ReleaseBuffer((int)(lp - lpszMDPath));

            TRACEEOLID("Path truncated at level " << nLevel << ": " << strNewPath);

            if (*lp)
            {
                lpRem = ++lp;
                TRACEEOLID("Remainder: " << lpRem);
            }
        }
    }

    //
    // Return remainder
    //
    if (pstrRemainder && lpRem)
    {
        ASSERT_WRITE_PTR(pstrRemainder);
        *pstrRemainder = lpRem;
    }

    return strNewPath;
}



/* static */
DWORD 
CMetabasePath::GetInstanceNumber(
    IN LPCTSTR lpszMDPath
    )
/*++

Routine Description:

    Get the number of the instance referred to in the given metabase
    path.  
    
    Examples:  "lm/w3svc/1/foo/bar" will return 1
               "lm/w3svc/"          will return 0 (master instance)
               "lm/bogus/path/"     will return 0xffffffff (error)

Arguments:

    LPCTSTR lpszMDPath      : A metabase path.

Return Value:

    Instance number (0 indicates master instance)
    or 0xffffffff if the path is in error.

--*/
{
    TRACEEOLID("Determining instance number of " << lpszMDPath);
    DWORD dwInstance = 0xffffffff;

    CString strService, strInst;

    if (GetServicePath(lpszMDPath, strService, &strInst))
    {
        if (strInst.IsEmpty())
        {
            dwInstance = MASTER_INSTANCE;
        }
        else
        {
            if (_istdigit(strInst.GetAt(0)))  
            {
                dwInstance = _ttol(strInst);
            }
        }
    }

    return dwInstance;
}



/* static */
LPCTSTR
CMetabasePath::GetLastNodeName(
    IN  LPCTSTR lpszMDPath,
    OUT CString & strNodeName
    )
/*++

Routine Description:

    Get the last nodename off the metabase path

    Example:

        "/lm/foo/bar/"      returns "bar"

Arguments:

    LPCTSTR lpszMDPath      : Metabase path

Return Value:

    Pointer to the node name or NULL in case of a malformed path.

--*/
{
    ASSERT_PTR(lpszMDPath);

    if (!lpszMDPath || !*lpszMDPath)
    {
        return NULL;
    }

    TRACEEOLID("Getting last node name from " << lpszMDPath);

    LPCTSTR lp;
    LPCTSTR lpTail;
    lp = lpTail = lpszMDPath + lstrlen(lpszMDPath) - 1;

    //
    // Skip trailing separator
    //
    if (*lp == _chSep)
    {
        --lpTail;
        --lp;
    }

    strNodeName.Empty();

    while (*lp && *lp != _chSep)
    {
        strNodeName += *(lp--);
    }

    strNodeName.MakeReverse();

    TRACEEOLID("Node is " << strNodeName);
    
    return strNodeName;    
}



/* static */
void
CMetabasePath::SplitMetaPathAtInstance(
    IN  LPCTSTR lpszMDPath,
    OUT CString & strParent,
    OUT CString & strAlias
    )
/*++

Routine Description:

    Split the given path into parent metabase root and alias, with the root
    being the instance path, and the alias everything following the
    instance.

Arguments:

    LPCTSTR lpszMDPath  : Input path
    CString & strParent : Outputs the parent path
    CString & strAlias  : Outputs the alias name

Return Value:

    None.

--*/
{
    ASSERT_PTR(lpszMDPath);

    TRACEEOLID("Source Path " << lpszMDPath);

    strParent = lpszMDPath;
    strAlias.Empty();

    LPTSTR lp = strParent.GetBuffer(0);
    ASSERT_PTR(lp);

    if (!lp)
    {
        //
        // This is just about impossible
        //
        return;
    }

    int cSeparators = 0;
    int iChar = 0;

    //
    // Looking for "LM/sss/ddd/" <-- 3d slash:
    //
    while (*lp && cSeparators < 2)
    {
        if (*lp++ == _chSep)
        {
            ++cSeparators;
        }

        ++iChar;
    }

    if (!*lp)
    {
        //
        // Bogus format
        //
        ASSERT_MSG("Bogus Format");
        return;
    }

    if (_istdigit(*lp))
    {
        //
        // Not at the master instance, skip one more.
        //
        while (*lp)
        {
            ++iChar;

            if (*lp++ == _chSep)
            {
                break;
            }
        }

        if (!*lp)
        {
            //
            // Bogus format
            //
            ASSERT_MSG("Bogus Format");
            return;
        }
    }

    strAlias = strParent.Mid(iChar);
    strParent.ReleaseBuffer(--iChar);

    TRACEEOLID("Broken up into " << strParent);
    TRACEEOLID("           and " << strAlias);
}



/* static */
BOOL 
CMetabasePath::IsHomeDirectoryPath(
    IN LPCTSTR lpszMetaPath
    )
/*++

Routine Description:

    Determine if the path given describes a root directory

Arguments:

    LPCTSTR lpszMetaPath        : Metabase path

Return Value:

    TRUE if the path describes a root directory, 
    FALSE if it does not

--*/
{
    ASSERT_READ_PTR(lpszMetaPath);

    LPTSTR lpNode = lpszMetaPath ? _tcsrchr(lpszMetaPath, _chSep) : NULL;

    if (lpNode)
    {
        return _tcsicmp(++lpNode, _cszRoot) == 0;
    }

    return FALSE;
}



/* static */
BOOL 
CMetabasePath::IsMasterInstance(
    IN LPCTSTR lpszMDPath
    )
/*++

Routine Description:

    Determine if the given metabase path points to the master instance
    (site).  This is essentially the service path.

Arguments:

    LPCTSTR lpszMDPath  : Metabase path.

Return Value:

    TRUE if the path is the master instance,
    FALSE otherwise.

--*/
{
    ASSERT_READ_PTR(lpszMDPath);

    if (!lpszMDPath || !*lpszMDPath)
    {
        return FALSE;
    }

    TRACEEOLID("Checking path " << lpszMDPath);

    CString strService;
    CString strRemainder;

    LPCTSTR lpPath = TruncatePath(2, lpszMDPath, strService, &strRemainder);

    return lpPath && !strService.IsEmpty() && strRemainder.IsEmpty();
}



/* static */
LPCTSTR
CMetabasePath::GetServiceInfoPath(
    IN  LPCTSTR lpszMDPath,
    OUT CString & strInfoPath,   
    IN  LPCTSTR lpszDefService      OPTIONAL
    )
/*++

Routine Description:

    Generate the appropriate metabase service info path for the given
    metabase path.  

    For example:

        "lm/w3svc/1/foo/bar"    Generates "lm/w3svc/info"

Arguments:

    LPCTSTR lpszMDPath      : Input metabase path
    CString & strInfoPath   : Returns the info path
    LPCTSTR lpszDefService  : Optionally specifies the default service to
                              use (e.g "w3svc") if no service could be found
                              in the path.
    
Return Value:

    The info metabase path or NULL if one could not be generated.

--*/
{
    //
    // Capability info stored off the service path ("lm/w3svc").
    //
    CString strService;
    CString strRem;
   
    //
    // Strip off everything past the service
    //
    if (!TruncatePath(2, lpszMDPath, strService, &strRem)
      || strService.IsEmpty())
    {
        if (!lpszDefService)
        {
            TRACEEOLID("Unable to generate info path");
            return NULL;
        }

        TRACEEOLID("Using default service for info path");

        //
        // Machine path (no service).  Use web as default service to
        // look for capability and version info.
        //
        strService = CMetabasePath(TRUE, lpszDefService);
    }

    strInfoPath = CMetabasePath(FALSE, strService, SZ_MBN_INFO);
    TRACEEOLID("Using " << strInfoPath << " to look for capability info");

    return strInfoPath;
}
 


/* static */
LPCTSTR
CMetabasePath::CleanMetaPath(
    IN OUT CString & strMetaRoot
    )
/*++

Routine Description:

    Clean up the metabase path to one valid for internal consumption.
    This removes the beginning and trailing slashes off the path.

Arguments:

    CString & strMetaRoot       : Metabase path to be cleaned up.

Return Value:

    Pointer to the metabase path

--*/
{
    TRACEEOLID("Dirty metapath: " << strMetaRoot);

    if (!strMetaRoot.IsEmpty())
    {
        if (strMetaRoot[strMetaRoot.GetLength() - 1] == _chSep)
        {
            strMetaRoot.ReleaseBuffer(strMetaRoot.GetLength() - 1);
        }

        if (!strMetaRoot.IsEmpty() && strMetaRoot[0] == _chSep)
        {
            strMetaRoot = strMetaRoot.Right(strMetaRoot.GetLength() - 1);
        }
    }

    TRACEEOLID("Clean metapath: " << strMetaRoot);

    return strMetaRoot;
}



CMetabasePath::CMetabasePath(
    IN BOOL    fAddBasePath,
    IN LPCTSTR lpszMDPath,
    IN LPCTSTR lpszMDPath2  OPTIONAL,
    IN LPCTSTR lpszMDPath3  OPTIONAL,
    IN LPCTSTR lpszMDPath4  OPTIONAL
    )
/*++

Routine Description:

    Constructor.

Arguments:

    BOOL    fAddBasePath    : TRUE to prepend base path ("LM")
                              FALSE if the path is complete
    LPCTSTR lpszMDPath      : Metabase path
    LPCTSTR lpszMDPath2     : Optional child path
    LPCTSTR lpszMDPath3     : Optional child path
    LPCTSTR lpszMDPath4     : Optional child path

Return Value:

    N/A

--*/
    : m_strMetaPath()
{
    ASSERT_READ_PTR(lpszMDPath);

    if (fAddBasePath)
    {
        m_strMetaPath = _cszMachine;
        AppendPath(lpszMDPath);
    }
    else
    {
        m_strMetaPath = lpszMDPath;
    }

    //
    // Add optional path components
    //    
    AppendPath(lpszMDPath2);
    AppendPath(lpszMDPath3);
    AppendPath(lpszMDPath4);
}



CMetabasePath::CMetabasePath(
    IN  LPCTSTR lpszSvc,        OPTIONAL
    IN  DWORD   dwInstance,     OPTIONAL
    IN  LPCTSTR lpszParentPath, OPTIONAL
    IN  LPCTSTR lpszAlias       OPTIONAL
    )
/*++

Routine Description:

    Constructor.  Construct with path components.

Arguments:

    LPCTSTR lpszSvc         : Service (may be NULL or "")
    DWORD   dwInstance      : Instance number (may be 0 for master)
    LPCTSTR lpszParentPath  : Parent path (may be NULL or "")
    LPCTSTR lpszAlias       : Alias (may be NULL or "")

Return Value:

    N/A

--*/
    : m_strMetaPath()
{
    BuildMetaPath(lpszSvc, dwInstance, lpszParentPath, lpszAlias);
}



void 
CMetabasePath::AppendPath(
    IN LPCTSTR lpszPath
    )
/*++

Routine Description:

    Append path to current metabase path

Arguments:

    LPCTSTR lpszPath        : Metabase path

Return Value:

    None

--*/
{
    if (lpszPath && *lpszPath)
    {
        m_strMetaPath += _cszSep;
        m_strMetaPath += lpszPath;
    }
}



void 
CMetabasePath::AppendPath(
    IN DWORD dwInstance
    )
/*++

Routine Description:

    Append path to current metabase path

Arguments:

    DWORD dwInstance        : Instance path

Return Value:

    None

--*/
{
    if (!IS_MASTER_INSTANCE(dwInstance))
    {
        TCHAR szInstance[] = _T("4000000000");
        _ltot(dwInstance, szInstance, 10);

        m_strMetaPath += _cszSep;
        m_strMetaPath += szInstance;
    }
}



void
CMetabasePath::BuildMetaPath(
    IN  LPCTSTR lpszSvc            OPTIONAL,
    IN  LPCTSTR lpszInstance       OPTIONAL,
    IN  LPCTSTR lpszParentPath     OPTIONAL,
    IN  LPCTSTR lpszAlias          OPTIONAL
    )
/*++

Routine Description:

    Build a complete metapath with the given service name, instance
    number and optional path components.

Arguments:

    LPCTSTR lpszSvc         : Service (may be NULL or "")
    LPCTSTR lpszInstance    : Instance (may be NULL or "")
    LPCTSTR lpszParentPath  : Parent path (may be NULL or "")
    LPCTSTR lpszAlias       : Alias (may be NULL or "")

Return Value:

    Pointer to internal buffer containing the path.

--*/
{
    m_strMetaPath = _cszMachine;

    AppendPath(lpszSvc);
    AppendPath(lpszInstance);
    AppendPath(lpszParentPath);

    if (lpszAlias && *lpszAlias)
    {
        //
        // Special case: If the alias is root, but we're
        // at the master instance, ignore this.
        //
        if (lpszInstance || ::lstrcmpi(_cszRoot, lpszAlias))
        {
            m_strMetaPath += _cszSep;
            m_strMetaPath += lpszAlias;
        }
    }

    TRACEEOLID("Generated metapath: " << m_strMetaPath );
}




void
CMetabasePath::BuildMetaPath(
    IN  LPCTSTR lpszSvc            OPTIONAL,
    IN  DWORD   dwInstance         OPTIONAL,
    IN  LPCTSTR lpszParentPath     OPTIONAL,
    IN  LPCTSTR lpszAlias          OPTIONAL
    )
/*++

Routine Description:

    Build a complete metapath with the given service name, instance
    number and optional path components.

Arguments:

    LPCTSTR lpszSvc         : Service (may be NULL or "")
    DWORD   dwInstance      : Instance number (may be 0 for master)
    LPCTSTR lpszParentPath  : Parent path (may be NULL or "")
    LPCTSTR lpszAlias       : Alias (may be NULL or "")

Return Value:

    Pointer to internal buffer containing the path.

--*/
{
    m_strMetaPath = _cszMachine;

    AppendPath(lpszSvc);
    AppendPath(dwInstance);
    AppendPath(lpszParentPath);

    if (lpszAlias && *lpszAlias)
    {
        //
        // Special case: If the alias is root, but we're
        // at the master instance, ignore this.
        //
        if (!IS_MASTER_INSTANCE(dwInstance) || ::lstrcmpi(_cszRoot, lpszAlias))
        {
            m_strMetaPath += _cszSep;
            m_strMetaPath += lpszAlias;
        }
    }

    TRACEEOLID("Generated metapath: " << m_strMetaPath );
}




//
// CIISInterface class
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



CIISInterface::CIISInterface(
    IN CComAuthInfo * pAuthInfo,    OPTIONAL
    IN HRESULT hrInterface          OPTIONAL
    )
/*++

Routine Description:

    Base class constructor.  

Arguments:

    CComAuthInfo * pAuthInfo : Auth info or NULL for local computer
    HRESULT hrInterface      : Initial error code. S_OK by default.

Return Value:

    N/A

--*/
    : m_auth(pAuthInfo),
      m_hrInterface(hrInterface)
{
}



HRESULT 
CIISInterface::Create(
    IN  int   cInterfaces,       
    IN  const IID rgIID[],      
    IN  const GUID rgCLSID[],    
    OUT int * pnInterface,          OPTIONAL
    OUT IUnknown ** ppInterface 
    )
/*++

Routine Description:

    Create interface.  This will try a range of interfaces in order of priority.

Arguments:

    int   cInterfaces       : Number of interfaces in array.
    const IID * rgIID       : Array if IIDs
    const GUID * rgCLSID    : Array of CLSIDs
    int * pnInterface       : Returns the interface index that was successful.
                              or NULL if not interested.
    IUnknown ** ppInterface : Returns pointer to the interface.

Return Value:

    HRESULT

Notes:

    This will attempt to create an interface, in order of declaration in 
    the IID and CLSIS arrays.  The first successful interface to be created
    will have its index returned in *pnInterfaces.

--*/
{
    ASSERT(cInterfaces > 0);
    ASSERT(rgIID && rgCLSID && ppInterface);
    
    COSERVERINFO * pcsiName = m_auth.CreateServerInfoStruct();

    MULTI_QI rgmqResults;
    CError err;
    int nInterface;

    ZeroMemory(&rgmqResults, sizeof(rgmqResults));
    //
    // Try to create the interface in order
    //
    for (nInterface = 0; nInterface < cInterfaces; ++nInterface)
    {
        rgmqResults.pIID = &rgIID[nInterface];

        TRACEEOLID("Attempting to create interface #" << nInterface);
        err = ::CoCreateInstanceEx(
            rgCLSID[nInterface],
            NULL,
            CLSCTX_SERVER,
            pcsiName,
            1,
            &rgmqResults
            );

        if (err.Succeeded() || err.Win32Error() == ERROR_ACCESS_DENIED)
        {
            break;
        }
        ZeroMemory(&rgmqResults, sizeof(rgmqResults));
    }

    if(err.Succeeded())
    {
        //
        // Save the interface pointer
        //
        ASSERT_PTR(rgmqResults.pItf);
        *ppInterface = rgmqResults.pItf;

        if (pnInterface)
        {
            //
            // Store successful interface index
            //
            *pnInterface = nInterface;
        }

        //
        // Strangely enough, I now have still have to apply
        // the proxy blanket.  Apparently this is by design.
        //
        if (m_auth.UsesImpersonation())
        {
            ApplyProxyBlanket();
        }
    }

    //
    // Clean up
    //
    m_auth.FreeServerInfoStruct(pcsiName);

    return err;
}



//
// CMetaInterface class
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



CMetaInterface::CMetaInterface(
    IN CComAuthInfo * pAuthInfo        OPTIONAL
    )
/*++

Routine Description:

    Construct and initialize the interface

Arguments:

    CComAuthInfo * pAuthInfo    : Authentication info.  NULL indicates 
                                  the local computer.

Return Value:

    N/A

--*/
    : CIISInterface(pAuthInfo),
      m_pInterface(NULL),
      m_iTimeOutValue(MB_TIMEOUT)
{
    //
    // Initialize the interface
    //
    m_hrInterface = Create();
}



CMetaInterface::CMetaInterface(
    IN CMetaInterface * pInterface
    )
/*++

Routine Description:

    Construct from existing interface (Copy Constructor)

Arguments:

    CMetaInterface * pInterface : Existing interface

Return Value:

    N/A

Notes:
        
    Object will not take ownership of the interface,
    it will merely add to the reference count, and 
    release it upon destruction

BUGBUG:

    if pInterface is NULL, this will AV.

--*/
    : CIISInterface(&pInterface->m_auth, pInterface->m_hrInterface),
      m_pInterface(pInterface->m_pInterface),
      m_iTimeOutValue(pInterface->m_iTimeOutValue)
{
    ASSERT_READ_PTR(m_pInterface);
    m_pInterface->AddRef();
}



CMetaInterface::~CMetaInterface()
/*++

Routine Description:

    Destructor -- releases the interface

Arguments:

    N/A

Return Value:

    N/A

--*/
{
    SAFE_RELEASE(m_pInterface);
}



//
// CMetaKey class
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

//
// Helper macros
//
#define ASSURE_PROPER_INTERFACE()\
    if (!HasInterface()) { ASSERT_MSG("No interface"); return MD_ERROR_NOT_INITIALIZED; }

#define ASSURE_OPEN_KEY()\
    if (!m_hKey && !m_fAllowRootOperations) { ASSERT_MSG("No open key"); return HRESULT_FROM_WIN32(ERROR_INVALID_HANDLE); }

#define FETCH_PROPERTY_DATA_OR_FAIL(dwID, md)\
    ZeroMemory(&md, sizeof(md)); \
    if (!GetMDFieldDef(dwID, md.dwMDIdentifier, md.dwMDAttributes, md.dwMDUserType, md.dwMDDataType))\
    { ASSERT_MSG("Bad property ID"); return HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER); }

//
// Static Initialization
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



#define MD_SERVER_PLATFORM              (IIS_MD_SERVER_BASE+100 )
#define MD_SERVER_VERSION_MAJOR         (IIS_MD_SERVER_BASE+101 )
#define MD_SERVER_VERSION_MINOR         (IIS_MD_SERVER_BASE+102 )
#define MD_SERVER_CAPABILITIES          (IIS_MD_SERVER_BASE+103 )


//
// Metabase table
//
const CMetaKey::MDFIELDDEF CMetaKey::s_rgMetaTable[] =
{
    ///////////////////////////////////////////////////////////////////////////
    //
    // !!!IMPORTANT!!! This table must be sorted on dwMDIdentifier.  (Will
    // ASSERT if not not sorted)
    //
    { MD_MAX_BANDWIDTH,                   METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, DWORD_METADATA,   0                                  },
    { MD_KEY_TYPE,                        METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, STRING_METADATA,  0                                  },
    { MD_SERVER_COMMAND,                  METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, DWORD_METADATA,   0                                  },
    { MD_CONNECTION_TIMEOUT,              METADATA_INHERIT,                          IIS_MD_UT_SERVER, DWORD_METADATA,   IDS_MD_CONNECTION_TIMEOUT          },
    { MD_MAX_CONNECTIONS,                 METADATA_INHERIT,                          IIS_MD_UT_SERVER, DWORD_METADATA,   IDS_MD_MAX_CONNECTIONS             },
    { MD_SERVER_COMMENT,                  METADATA_INHERIT,                          IIS_MD_UT_SERVER, STRING_METADATA,  IDS_MD_SERVER_COMMENT              },
    { MD_SERVER_STATE,                    METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, DWORD_METADATA,   0                                  },
    { MD_SERVER_AUTOSTART,                METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, DWORD_METADATA,   0                                  },
    { MD_SERVER_SIZE,                     METADATA_INHERIT,                          IIS_MD_UT_SERVER, DWORD_METADATA,   IDS_MD_SERVER_SIZE                 },
    { MD_SERVER_LISTEN_BACKLOG,           METADATA_INHERIT,                          IIS_MD_UT_SERVER, DWORD_METADATA,   IDS_MD_SERVER_LISTEN_BACKLOG       },
    { MD_SERVER_LISTEN_TIMEOUT,           METADATA_INHERIT,                          IIS_MD_UT_SERVER, DWORD_METADATA,   IDS_MD_SERVER_LISTEN_TIMEOUT       },
    { MD_DOWNLEVEL_ADMIN_INSTANCE,        METADATA_INHERIT,                          IIS_MD_UT_SERVER, DWORD_METADATA,   IDS_MD_DOWNLEVEL_ADMIN_INSTANCE    },
    { MD_SERVER_BINDINGS,                 METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, MULTISZ_METADATA, 0                                  },
    { MD_WIN32_ERROR,                     METADATA_VOLATILE,                         IIS_MD_UT_FILE,   DWORD_METADATA,   0                                  },
    { MD_SERVER_PLATFORM,                 METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, DWORD_METADATA,   0                                  },
    { MD_SERVER_VERSION_MAJOR,            METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, DWORD_METADATA,   0                                  },
    { MD_SERVER_VERSION_MINOR,            METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, DWORD_METADATA,   0                                  },
    { MD_SERVER_CAPABILITIES,             METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, DWORD_METADATA,   0                                  },
    { MD_SECURE_BINDINGS,                 METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, MULTISZ_METADATA, 0                                  },
    { MD_FILTER_LOAD_ORDER,               METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, STRING_METADATA,  0                                  },
    { MD_FILTER_IMAGE_PATH,               METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, STRING_METADATA,  0                                  },
    { MD_FILTER_STATE,                    METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, DWORD_METADATA,   0                                  },
    { MD_FILTER_ENABLED,                  METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, DWORD_METADATA,   0                                  },
    { MD_FILTER_FLAGS,                    METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, DWORD_METADATA,   0                                  },
    { MD_AUTH_CHANGE_URL,                 METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, DWORD_METADATA,   0                                  },
    { MD_AUTH_EXPIRED_URL,                METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, STRING_METADATA,  0                                  },
    { MD_AUTH_NOTIFY_PWD_EXP_URL,         METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, STRING_METADATA,  0                                  },
    { MD_ADV_NOTIFY_PWD_EXP_IN_DAYS,      METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, DWORD_METADATA,   0                                  },
    { MD_ADV_CACHE_TTL,                   METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, DWORD_METADATA,   0                                  },
    { MD_NET_LOGON_WKS,                   METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, DWORD_METADATA,   0                                  },
    { MD_USE_HOST_NAME,                   METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, DWORD_METADATA,   0                                  },
    { MD_AUTH_EXPIRED_UNSECUREURL,        METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, STRING_METADATA,  0                                  },
    { MD_AUTH_CHANGE_FLAGS,               METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, DWORD_METADATA,   0                                  },
    { MD_AUTH_NOTIFY_PWD_EXP_UNSECUREURL, METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, STRING_METADATA,  0                                  },
    { MD_FRONTPAGE_WEB,                   METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, DWORD_METADATA,   0                                  },
    { MD_MAPCERT,                         METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, STRING_METADATA,  0                                  },
    { MD_MAPNTACCT,                       METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, STRING_METADATA,  0                                  },
    { MD_MAPNAME,                         METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, STRING_METADATA,  0                                  },
    { MD_MAPENABLED,                      METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, STRING_METADATA,  0                                  },
    { MD_MAPREALM,                        METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, STRING_METADATA,  0                                  },
    { MD_MAPPWD,                          METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, STRING_METADATA,  0                                  },
    { MD_ITACCT,                          METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, STRING_METADATA,  0                                  },
    { MD_CPP_CERT11,                      METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, BINARY_METADATA,  0                                  },
    { MD_SERIAL_CERT11,                   METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, BINARY_METADATA,  0                                  },
    { MD_CPP_CERTW,                       METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, BINARY_METADATA,  0                                  },
    { MD_SERIAL_CERTW,                    METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, BINARY_METADATA,  0                                  },
    { MD_CPP_DIGEST,                      METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, BINARY_METADATA,  0                                  },
    { MD_SERIAL_DIGEST,                   METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, BINARY_METADATA,  0                                  },
    { MD_CPP_ITA,                         METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, BINARY_METADATA,  0                                  },
    { MD_SERIAL_ITA,                      METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, BINARY_METADATA,  0                                  },
    { MD_FRONTPAGE_WEB,                   METADATA_INHERIT,                          IIS_MD_UT_SERVER, BINARY_METADATA,  0                                  },
    { MD_APP_FRIENDLY_NAME,               METADATA_INHERIT,                          IIS_MD_UT_WAM,    STRING_METADATA,  IDS_MD_APP_FRIENDLY_NAME           },
    { MD_APP_ROOT,                        METADATA_INHERIT,                          IIS_MD_UT_WAM,    STRING_METADATA,  IDS_MD_APP_ROOT                    },
    { MD_APP_ISOLATED,                    METADATA_INHERIT,                          IIS_MD_UT_WAM,    DWORD_METADATA,   IDS_MD_APP_ISOLATED                },
    { MD_CPU_LIMITS_ENABLED,              METADATA_INHERIT,                          IIS_MD_UT_SERVER, DWORD_METADATA,   IDS_MD_CPU_LIMITS_ENABLED          },
    { MD_CPU_RESET_INTERVAL,              METADATA_INHERIT,                          IIS_MD_UT_SERVER, DWORD_METADATA,   0          },
    { MD_CPU_LIMIT_LOGEVENT,              METADATA_INHERIT,                          IIS_MD_UT_SERVER, DWORD_METADATA,   IDS_MD_CPU_LIMIT_LOGEVENT          },
    { MD_CPU_LIMIT_PRIORITY,              METADATA_INHERIT,                          IIS_MD_UT_SERVER, DWORD_METADATA,   IDS_MD_CPU_LIMIT_PRIORITY          },
    { MD_CPU_LIMIT_PROCSTOP,              METADATA_INHERIT,                          IIS_MD_UT_SERVER, DWORD_METADATA,   IDS_MD_CPU_LIMIT_PROCSTOP          },
    { MD_CPU_LIMIT_PAUSE,                 METADATA_INHERIT,                          IIS_MD_UT_SERVER, DWORD_METADATA,   IDS_MD_CPU_LIMIT_PAUSE             },
    { MD_HC_COMPRESSION_DIRECTORY,        METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, STRING_METADATA,  0                                  },
    { MD_HC_DO_DYNAMIC_COMPRESSION,       METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, DWORD_METADATA,   0                                  },
    { MD_HC_DO_STATIC_COMPRESSION,        METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, DWORD_METADATA,   0                                  },
    { MD_HC_DO_DISK_SPACE_LIMITING,       METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, DWORD_METADATA,   0                                  },
    { MD_HC_MAX_DISK_SPACE_USAGE,         METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, DWORD_METADATA,   0                                  },
    { MD_VR_PATH,                         METADATA_INHERIT,                          IIS_MD_UT_FILE,   STRING_METADATA,  IDS_MD_VR_PATH                     },
    { MD_VR_USERNAME,                     METADATA_INHERIT,                          IIS_MD_UT_FILE,   STRING_METADATA,  IDS_MD_VR_USERNAME                 },
    { MD_VR_PASSWORD,                     METADATA_INHERIT | METADATA_SECURE,        IIS_MD_UT_FILE,   STRING_METADATA,  IDS_MD_VR_PASSWORD                 },
    { MD_VR_ACL,                          METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_FILE,   BINARY_METADATA,  0                                  },
    { MD_VR_UPDATE,                       METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_FILE,   DWORD_METADATA,   0                                  },
    { MD_LOG_TYPE,                        METADATA_INHERIT,                          IIS_MD_UT_FILE,   DWORD_METADATA,   IDS_MD_LOG_TYPE                    },
    { MD_LOGFILE_DIRECTORY,               METADATA_INHERIT,                          IIS_MD_UT_FILE,   EXPANDSZ_METADATA,IDS_MD_LOGFILE_DIRECTORY           },
    { MD_LOGFILE_PERIOD,                  METADATA_INHERIT,                          IIS_MD_UT_FILE,   DWORD_METADATA,   IDS_MD_LOGFILE_PERIOD              },
    { MD_LOGFILE_TRUNCATE_SIZE,           METADATA_INHERIT,                          IIS_MD_UT_FILE,   DWORD_METADATA,   IDS_MD_LOGFILE_TRUNCATE_SIZE       },
    { MD_LOGSQL_DATA_SOURCES,             METADATA_INHERIT,                          IIS_MD_UT_FILE,   STRING_METADATA,  IDS_MD_LOGSQL_DATA_SOURCES         },
    { MD_LOGSQL_TABLE_NAME,               METADATA_INHERIT,                          IIS_MD_UT_FILE,   STRING_METADATA,  IDS_MD_LOGSQL_TABLE_NAME           },
    { MD_LOGSQL_USER_NAME,                METADATA_INHERIT,                          IIS_MD_UT_FILE,   STRING_METADATA,  IDS_MD_LOGSQL_USER_NAME            },
    { MD_LOGSQL_PASSWORD,                 METADATA_INHERIT | METADATA_SECURE,        IIS_MD_UT_FILE,   STRING_METADATA,  IDS_MD_LOGSQL_PASSWORD             },
    { MD_LOG_PLUGIN_ORDER,                METADATA_INHERIT,                          IIS_MD_UT_SERVER, STRING_METADATA,  IDS_MD_LOG_PLUGIN_ORDER            },
    { MD_LOGEXT_FIELD_MASK,               METADATA_INHERIT,                          IIS_MD_UT_SERVER, DWORD_METADATA,   IDS_MD_LOGEXT_FIELD_MASK           },
    { MD_LOGFILE_LOCALTIME_ROLLOVER,      METADATA_INHERIT,                          IIS_MD_UT_SERVER, DWORD_METADATA,   IDS_MD_LOGFILE_LOCALTIME_ROLLOVER  },
    { MD_CPU_LOGGING_MASK,                METADATA_INHERIT,                          IIS_MD_UT_SERVER, DWORD_METADATA,   IDS_MD_CPU_LOGGING_MASK            },
    { MD_EXIT_MESSAGE,                    METADATA_INHERIT,                          IIS_MD_UT_SERVER, STRING_METADATA,  IDS_MD_EXIT_MESSAGE                },
    { MD_GREETING_MESSAGE,                METADATA_INHERIT,                          IIS_MD_UT_SERVER, MULTISZ_METADATA, IDS_MD_GREETING_MESSAGE            },
    { MD_MAX_CLIENTS_MESSAGE,             METADATA_INHERIT,                          IIS_MD_UT_SERVER, STRING_METADATA,  IDS_MD_MAX_CLIENTS_MESSAGE         },
    { MD_MSDOS_DIR_OUTPUT,                METADATA_INHERIT,                          IIS_MD_UT_SERVER, DWORD_METADATA,   IDS_MD_MSDOS_DIR_OUTPUT            },
    { MD_ALLOW_ANONYMOUS,                 METADATA_INHERIT,                          IIS_MD_UT_SERVER, DWORD_METADATA,   IDS_MD_ALLOW_ANONYMOUS             },
    { MD_ANONYMOUS_ONLY,                  METADATA_INHERIT,                          IIS_MD_UT_SERVER, DWORD_METADATA,   IDS_MD_ANONYMOUS_ONLY              },
    { MD_LOG_ANONYMOUS,                   METADATA_INHERIT,                          IIS_MD_UT_SERVER, DWORD_METADATA,   IDS_MD_LOG_ANONYMOUS               },
    { MD_LOG_NONANONYMOUS,                METADATA_INHERIT,                          IIS_MD_UT_SERVER, DWORD_METADATA,   IDS_MD_LOG_NONANONYMOUS            },
    { MD_BANNER_MESSAGE,				  METADATA_INHERIT,                          IIS_MD_UT_SERVER, MULTISZ_METADATA, 0									},
    { MD_SSL_PUBLIC_KEY,                  METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, BINARY_METADATA,  0                                  },
    { MD_SSL_PRIVATE_KEY,                 METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, BINARY_METADATA,  0                                  },
    { MD_SSL_KEY_PASSWORD,                METADATA_SECURE,                           IIS_MD_UT_SERVER, BINARY_METADATA,  0                                  },
    { MD_SSL_CERT_HASH,                   METADATA_INHERIT,                          IIS_MD_UT_SERVER, BINARY_METADATA,  0                                  },
    { MD_SSL_CERT_STORE_NAME,             METADATA_INHERIT,                          IIS_MD_UT_SERVER, STRING_METADATA,  0                                  },
    { MD_SSL_CTL_IDENTIFIER,              METADATA_INHERIT,                          IIS_MD_UT_SERVER, STRING_METADATA,  0                                  },
    { MD_SSL_CTL_STORE_NAME,              METADATA_INHERIT,                          IIS_MD_UT_SERVER, STRING_METADATA,  0                                  },
    { MD_SSL_USE_DS_MAPPER,               METADATA_INHERIT,                          IIS_MD_UT_SERVER, DWORD_METADATA,   0                                  },
    { MD_AUTHORIZATION,                   METADATA_INHERIT,                          IIS_MD_UT_FILE,   DWORD_METADATA,   IDS_MD_AUTHORIZATION               },
    { MD_REALM,                           METADATA_INHERIT,                          IIS_MD_UT_FILE,   STRING_METADATA,  IDS_MD_REALM                       },
    { MD_HTTP_EXPIRES,                    METADATA_INHERIT,                          IIS_MD_UT_FILE,   STRING_METADATA,  IDS_MD_HTTP_EXPIRES                },
    { MD_HTTP_PICS,                       METADATA_INHERIT,                          IIS_MD_UT_FILE,   MULTISZ_METADATA, IDS_MD_HTTP_PICS                   },
    { MD_HTTP_CUSTOM,                     METADATA_INHERIT,                          IIS_MD_UT_FILE,   MULTISZ_METADATA, IDS_MD_HTTP_CUSTOM                 },
    { MD_DIRECTORY_BROWSING,              METADATA_INHERIT,                          IIS_MD_UT_FILE,   DWORD_METADATA,   IDS_MD_DIRECTORY_BROWSING          },
    { MD_DEFAULT_LOAD_FILE,               METADATA_INHERIT,                          IIS_MD_UT_FILE,   STRING_METADATA,  IDS_MD_DEFAULT_LOAD_FILE           },
    { MD_CONTENT_NEGOTIATION,             METADATA_INHERIT,                          IIS_MD_UT_FILE,   DWORD_METADATA,   IDS_MD_CONTENT_NEGOTIATION         },
    { MD_CUSTOM_ERROR,                    METADATA_INHERIT,                          IIS_MD_UT_FILE,   MULTISZ_METADATA, IDS_MD_CUSTOM_ERROR                },
    { MD_FOOTER_DOCUMENT,                 METADATA_INHERIT,                          IIS_MD_UT_FILE,   STRING_METADATA,  IDS_MD_FOOTER_DOCUMENT             },
    { MD_FOOTER_ENABLED,                  METADATA_INHERIT,                          IIS_MD_UT_FILE,   DWORD_METADATA,   IDS_MD_FOOTER_ENABLED              },
    { MD_HTTP_REDIRECT,                   METADATA_INHERIT,                          IIS_MD_UT_FILE,   STRING_METADATA,  IDS_MD_HTTP_REDIRECT               },
    { MD_DEFAULT_LOGON_DOMAIN,            METADATA_INHERIT,                          IIS_MD_UT_FILE,   STRING_METADATA,  IDS_MD_DEFAULT_LOGON_DOMAIN        },
    { MD_LOGON_METHOD,                    METADATA_INHERIT,                          IIS_MD_UT_FILE,   DWORD_METADATA,   IDS_MD_LOGON_METHOD                },
    { MD_SCRIPT_MAPS,                     METADATA_INHERIT,                          IIS_MD_UT_FILE,   MULTISZ_METADATA, IDS_MD_SCRIPT_MAPS                 },
    { MD_MIME_MAP,                        METADATA_INHERIT,                          IIS_MD_UT_FILE,   MULTISZ_METADATA, IDS_MD_MIME_MAP                    },
    { MD_ACCESS_PERM,                     METADATA_INHERIT,                          IIS_MD_UT_FILE,   DWORD_METADATA,   IDS_MD_ACCESS_PERM                 },
    { MD_IP_SEC,                          METADATA_INHERIT | METADATA_REFERENCE,     IIS_MD_UT_FILE,   BINARY_METADATA,  IDS_MD_IP_SEC                      },
    { MD_ANONYMOUS_USER_NAME,             METADATA_INHERIT,                          IIS_MD_UT_FILE,   STRING_METADATA,  IDS_MD_ANONYMOUS_USER_NAME         },
    { MD_ANONYMOUS_PWD,                   METADATA_INHERIT | METADATA_SECURE,        IIS_MD_UT_FILE,   STRING_METADATA,  IDS_MD_ANONYMOUS_PWD               },
    { MD_ANONYMOUS_USE_SUBAUTH,           METADATA_INHERIT,                          IIS_MD_UT_FILE,   DWORD_METADATA,   IDS_MD_ANONYMOUS_USE_SUBAUTH       },
    { MD_DONT_LOG,                        METADATA_INHERIT,                          IIS_MD_UT_FILE,   DWORD_METADATA,   IDS_MD_DONT_LOG                    },
    { MD_ADMIN_ACL,                       METADATA_INHERIT | METADATA_SECURE | METADATA_REFERENCE,IIS_MD_UT_SERVER, BINARY_METADATA,  IDS_MD_ADMIN_ACL      },
    { MD_SSI_EXEC_DISABLED,               METADATA_INHERIT,                          IIS_MD_UT_FILE,   DWORD_METADATA,   IDS_MD_SSI_EXEC_DISABLED           },
    { MD_SSL_ACCESS_PERM,                 METADATA_INHERIT,                          IIS_MD_UT_FILE,   DWORD_METADATA,   IDS_MD_SSL_ACCESS_PERM             },
    { MD_NTAUTHENTICATION_PROVIDERS,      METADATA_INHERIT,                          IIS_MD_UT_FILE,   STRING_METADATA,  IDS_MD_NTAUTHENTICATION_PROVIDERS  },
    { MD_SCRIPT_TIMEOUT,                  METADATA_INHERIT,                          IIS_MD_UT_FILE,   DWORD_METADATA,   IDS_MD_SCRIPT_TIMEOUT              },
    { MD_CACHE_EXTENSIONS,                METADATA_INHERIT,                          IIS_MD_UT_FILE,   DWORD_METADATA,   IDS_MD_CACHE_EXTENSIONS            },
    { MD_CREATE_PROCESS_AS_USER,          METADATA_INHERIT,                          IIS_MD_UT_SERVER, DWORD_METADATA,   IDS_MD_CREATE_PROCESS_AS_USER      },
    { MD_CREATE_PROC_NEW_CONSOLE,         METADATA_INHERIT,                          IIS_MD_UT_SERVER, DWORD_METADATA,   IDS_MD_CREATE_PROC_NEW_CONSOLE     },
    { MD_POOL_IDC_TIMEOUT,                METADATA_INHERIT,                          IIS_MD_UT_FILE,   DWORD_METADATA,   IDS_MD_POOL_IDC_TIMEOUT            },
    { MD_ALLOW_KEEPALIVES,                METADATA_INHERIT,                          IIS_MD_UT_FILE,   DWORD_METADATA,   IDS_MD_ALLOW_KEEPALIVES            },
    { MD_IS_CONTENT_INDEXED,              METADATA_INHERIT,                          IIS_MD_UT_FILE,   DWORD_METADATA,   IDS_MD_IS_CONTENT_INDEXED          },
    { MD_ISM_ACCESS_CHECK,                METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_FILE,   DWORD_METADATA,   0                                  },
    { MD_ASP_BUFFERINGON,                 METADATA_INHERIT,                          ASP_MD_UT_APP,    DWORD_METADATA,   IDS_ASP_BUFFERINGON                },
    { MD_ASP_LOGERRORREQUESTS,            METADATA_INHERIT,                          IIS_MD_UT_WAM,    DWORD_METADATA,   IDS_ASP_LOGERRORREQUESTS           },
    { MD_ASP_SCRIPTERRORSSENTTOBROWSER,   METADATA_INHERIT,                          ASP_MD_UT_APP,    DWORD_METADATA,   IDS_ASP_SCRIPTERRORSSENTTOBROWSER  },
    { MD_ASP_SCRIPTERRORMESSAGE,          METADATA_INHERIT,                          ASP_MD_UT_APP,    STRING_METADATA,  IDS_ASP_SCRIPTERRORMESSAGE         },
    { MD_ASP_SCRIPTFILECACHESIZE,         METADATA_INHERIT,                          IIS_MD_UT_WAM,    DWORD_METADATA,   IDS_ASP_SCRIPTFILECACHESIZE        },
    { MD_ASP_SCRIPTENGINECACHEMAX,        METADATA_INHERIT,                          IIS_MD_UT_WAM,    DWORD_METADATA,   IDS_ASP_SCRIPTENGINECACHEMAX       },
    { MD_ASP_SCRIPTTIMEOUT,               METADATA_INHERIT,                          ASP_MD_UT_APP,    DWORD_METADATA,   IDS_ASP_SCRIPTTIMEOUT              },
    { MD_ASP_SESSIONTIMEOUT,              METADATA_INHERIT,                          ASP_MD_UT_APP,    DWORD_METADATA,   IDS_ASP_SESSIONTIMEOUT             },
    { MD_ASP_ENABLEPARENTPATHS,           METADATA_INHERIT,                          ASP_MD_UT_APP,    DWORD_METADATA,   IDS_ASP_ENABLEPARENTPATHS          },
    { MD_ASP_ALLOWSESSIONSTATE,           METADATA_INHERIT,                          ASP_MD_UT_APP,    DWORD_METADATA,   IDS_ASP_ALLOWSESSIONSTATE          },
    { MD_ASP_SCRIPTLANGUAGE,              METADATA_INHERIT,                          ASP_MD_UT_APP,    STRING_METADATA,  IDS_ASP_SCRIPTLANGUAGE             },
    { MD_ASP_EXCEPTIONCATCHENABLE,        METADATA_INHERIT,                          IIS_MD_UT_WAM,    DWORD_METADATA,   IDS_ASP_EXCEPTIONCATCHENABLE       },
    { MD_ASP_ENABLESERVERDEBUG,           METADATA_INHERIT,                          ASP_MD_UT_APP,    DWORD_METADATA,   IDS_ASP_ENABLESERVERDEBUG          },
    { MD_ASP_ENABLECLIENTDEBUG,           METADATA_INHERIT,                          ASP_MD_UT_APP,    DWORD_METADATA,   IDS_ASP_ENABLECLIENTDEBUG          },

    { MD_WAM_USER_NAME,                   METADATA_INHERIT,                          IIS_MD_UT_SERVER, STRING_METADATA,  0                                  },
    { MD_WAM_PWD,                         METADATA_INHERIT,                          IIS_MD_UT_SERVER, STRING_METADATA,  0                                  },
    //
    // IIS6 Application Pools
    //
    { MD_APPPOOL_PERIODIC_RESTART_TIME,   METADATA_INHERIT,                          IIS_MD_UT_SERVER, DWORD_METADATA,   0                                  },
    { MD_APPPOOL_PERIODIC_RESTART_REQUEST_COUNT,
                                          METADATA_INHERIT,                          IIS_MD_UT_SERVER, DWORD_METADATA,   0                                  },
    { MD_APPPOOL_MAX_PROCESS_COUNT,       METADATA_INHERIT,                          IIS_MD_UT_SERVER, DWORD_METADATA,   0                                  },
    { MD_APPPOOL_PINGING_ENABLED,         METADATA_INHERIT,                          IIS_MD_UT_SERVER, DWORD_METADATA,   0                                  },
    { MD_APPPOOL_IDLE_TIMEOUT,            METADATA_INHERIT,                          IIS_MD_UT_SERVER, DWORD_METADATA,   0                                  },
    { MD_APPPOOL_RAPID_FAIL_PROTECTION_ENABLED,            
                                          METADATA_INHERIT,                          IIS_MD_UT_SERVER, DWORD_METADATA,   0                                  },
    { MD_APPPOOL_ORPHAN_PROCESSES_FOR_DEBUGGING,            
                                          METADATA_INHERIT,                          IIS_MD_UT_SERVER, DWORD_METADATA,   0                                  },
    { MD_APPPOOL_STARTUP_TIMELIMIT,       METADATA_INHERIT,                          IIS_MD_UT_SERVER, DWORD_METADATA,   0                                  },
    { MD_APPPOOL_SHUTDOWN_TIMELIMIT,      METADATA_INHERIT,                          IIS_MD_UT_SERVER, DWORD_METADATA,   0                                  },
    { MD_APPPOOL_PING_INTERVAL,           METADATA_INHERIT,                          IIS_MD_UT_SERVER, DWORD_METADATA,   0                                  },
    { MD_APPPOOL_ORPHAN_ACTION,           METADATA_INHERIT,                          IIS_MD_UT_SERVER, STRING_METADATA,  0                                  },
    { MD_APPPOOL_UL_APPPOOL_QUEUE_LENGTH,            
                                          METADATA_INHERIT,                          IIS_MD_UT_SERVER, DWORD_METADATA,   0                                  },
    { MD_APPPOOL_FRIENDLY_NAME,           METADATA_INHERIT,                          IIS_MD_UT_SERVER, STRING_METADATA,  0                                  },
    { MD_APPPOOL_PERIODIC_RESTART_SCHEDULE,           
                                          METADATA_INHERIT,                          IIS_MD_UT_SERVER, MULTISZ_METADATA, 0                                  },
    { MD_APPPOOL_IDENTITY_TYPE,           METADATA_INHERIT,                          IIS_MD_UT_SERVER, DWORD_METADATA,   0                                  },
    { MD_CPU_ACTION,                      METADATA_INHERIT,                          IIS_MD_UT_SERVER, DWORD_METADATA,   0                                  },
    { MD_CPU_LIMIT,                       METADATA_INHERIT,                          IIS_MD_UT_SERVER, DWORD_METADATA,   0                                  },
    { MD_APPPOOL_PERIODIC_RESTART_MEMORY, METADATA_INHERIT,                          IIS_MD_UT_SERVER, DWORD_METADATA,   0                                  },
    { MD_RAPID_FAIL_PROTECTION_INTERVAL,  METADATA_INHERIT,                          IIS_MD_UT_SERVER, DWORD_METADATA,   0                                  },
    { MD_RAPID_FAIL_PROTECTION_MAX_CRASHES, 
										  METADATA_INHERIT,                          IIS_MD_UT_SERVER, DWORD_METADATA,   0                                  },
    { MD_APP_APPPOOL_ID,                  METADATA_INHERIT,                          IIS_MD_UT_SERVER, STRING_METADATA,  0                                  },
    // Global parameters
    { MD_MAX_GLOBAL_BANDWIDTH,			  METADATA_INHERIT,                          IIS_MD_UT_SERVER, DWORD_METADATA,   0                                  },
    { MD_MAX_GLOBAL_CONNECTIONS,          METADATA_INHERIT,                          IIS_MD_UT_SERVER, DWORD_METADATA,   0                                  },
    { MD_GLOBAL_STANDARD_APP_MODE_ENABLED,METADATA_INHERIT,                          IIS_MD_UT_SERVER, DWORD_METADATA,   0                                  },
    { MD_GLOBAL_LOG_IN_UTF_8,             METADATA_INHERIT,                          IIS_MD_UT_SERVER, DWORD_METADATA,   0                                  },
    { MD_ROOT_ENABLE_EDIT_WHILE_RUNNING,  METADATA_INHERIT,                          IIS_MD_UT_SERVER, DWORD_METADATA,   0                                  },
};



#define NUM_ENTRIES (sizeof(CMetaKey::s_rgMetaTable) / sizeof(CMetaKey::s_rgMetaTable[0]))



/* static */
int
CMetaKey::MapMDIDToTableIndex(
    IN DWORD dwID
    )
/*++

Routine Description:

    Map MD id value to table index.  Return -1 if not found

Arguments:

    DWORD dwID : MD id value

Return Value:

    Index into the table that coresponds to the MD id value

--*/
{
#ifdef _DEBUG

    {
        //
        // Do a quick verification that our metadata
        // table is sorted correctly.
        //
        static BOOL fTableChecked = FALSE;

        if (!fTableChecked)
        {
            for (int n = 1; n < NUM_ENTRIES; ++n)
            {
                if (s_rgMetaTable[n].dwMDIdentifier
                    <= s_rgMetaTable[n - 1].dwMDIdentifier)
                {
                    TRACEEOLID("MD ID Table is out of order: Item is "
                        << n
                        << " "
                        << s_rgMetaTable[n].dwMDIdentifier
                        );
                    ASSERT_MSG("MD ID Table out of order");
                }
            }

            //
            // But only once.
            //
            ++fTableChecked;
        }
    }

#endif // _DEBUG

    //
    // Look up the ID in the table using a binary search
    //
    int nRange = NUM_ENTRIES;
    int nLow = 0;
    int nHigh = nRange - 1;
    int nMid;
    int nHalf;

    while (nLow <= nHigh)
    {
        if (0 != (nHalf = nRange / 2))
        {
            nMid  = nLow + (nRange & 1 ? nHalf : (nHalf - 1));

            if (s_rgMetaTable[nMid].dwMDIdentifier == dwID)
            {
                return nMid;
            }
            else if (s_rgMetaTable[nMid].dwMDIdentifier > dwID)
            {
                nHigh  = --nMid;
                nRange = nRange & 1 ? nHalf : nHalf - 1;
            }
            else
            {
                nLow   = ++nMid;
                nRange = nHalf;
            }
        }
        else if (nRange)
        {
            return s_rgMetaTable[nLow].dwMDIdentifier == dwID ? nLow : -1;
        }
        else
        {
            break;
        }
    }

    return -1;
}



/* static */
BOOL
CMetaKey::GetMDFieldDef(
    IN  DWORD dwID,
    OUT DWORD & dwMDIdentifier,
    OUT DWORD & dwMDAttributes,
    OUT DWORD & dwMDUserType,
    OUT DWORD & dwMDDataType
    )
/*++

Routine Description:

    Get information about metabase property

Arguments:

    DWORD dwID                  : Meta ID
    DWORD & dwMDIdentifier      : Meta parms
    DWORD & dwMDAttributes      : Meta parms
    DWORD & dwMDUserType        : Meta parms
    DWORD & dwMDDataType        : Meta parms

Return Value:

    TRUE for success, FALSE for failure.

--*/
{
    int nID = MapMDIDToTableIndex(dwID);

    if (nID == -1)
    {
        //
        // Unrecognized meta data ID
        //
        ASSERT_MSG("Unrecognized meta data id");
        return FALSE;
    }

    dwMDIdentifier = s_rgMetaTable[nID].dwMDIdentifier;
    dwMDAttributes = s_rgMetaTable[nID].dwMDAttributes;
    dwMDUserType   = s_rgMetaTable[nID].dwMDUserType;
    dwMDDataType   = s_rgMetaTable[nID].dwMDDataType;

    return TRUE;
}



/* static */
BOOL
CMetaKey::IsPropertyInheritable(
    IN DWORD dwID
    )
/*++

Routine Description:

    Check to see if the given property is inheritable

Arguments:

    DWORD dwID      : Metabase ID

Return Value:

    TRUE if the metabase ID is inheritable, FALSE otherwise.

--*/
{
    int nID = MapMDIDToTableIndex(dwID);

    if (nID == -1)
    {
        //
        // Unrecognized meta data ID
        //
        ASSERT_MSG("Unrecognized meta data ID");
        return FALSE;
    }

    return (s_rgMetaTable[nID].dwMDAttributes & METADATA_INHERIT) != 0;
}



/* static */
BOOL
CMetaKey::GetPropertyDescription(
    IN  DWORD dwID,
    OUT CString & strName
    )
/*++

Routine Description:

    Get a description for the given property

Arguments:

    DWORD dwID            : Property ID
    CString & strName     : Returns friendly property name

Return Value:

    TRUE for success, FALSE for failure

--*/
{
    int nID = MapMDIDToTableIndex(dwID);

    if (nID == -1)
    {
        //
        // Unrecognized meta data ID
        //
        ASSERT_MSG("Unrecognized meta data ID");
        return FALSE;
    }

    UINT uID = s_rgMetaTable[nID].uStringID;

    BOOL fResult = TRUE;

    if (uID > 0)
    {
        fResult = (strName.LoadString(uID) != 0);
    }
    else
    {
        //
        // Don't have a friendly name -- fake it
        //
        CComBSTR bstrFmt;
        VERIFY(bstrFmt.LoadString(hDLLInstance, IDS_INHERITANCE_NO_NAME));

        strName.Format(bstrFmt, dwID);
    }

    return fResult;
}



CMetaKey::CMetaKey(
    IN CComAuthInfo * pAuthInfo     OPTIONAL
    )
/*++

Routine Description:

    Constructor that creates the interface, but does not open the key.
    This is the ONLY constructor that allows operations from
    METDATA_MASTER_ROOT_HANDLE (read operations obviously)

Arguments:

    CComAuthInfo * pAuthInfo  : If NULL, opens interface on local machine

Return Value:

    N/A

--*/
    : CMetaInterface(pAuthInfo),
      m_hKey(METADATA_MASTER_ROOT_HANDLE),
      m_hBase(NULL),
      m_hrKey(S_OK),
      m_dwFlags(0L),
      m_cbInitialBufferSize(MB_INIT_BUFF_SIZE),
      m_strMetaPath(),
      m_fAllowRootOperations(TRUE),
      m_fOwnKey(TRUE)
{
    m_hrKey = CMetaInterface::QueryResult(); 

    //
    // Do not open key
    //
}



CMetaKey::CMetaKey(
    IN CMetaInterface * pInterface
    )
/*++

Routine Description:

    Construct with pre-existing interface.  Does not
    open any keys

Arguments:

    CMetaInterface * pInterface       : Preexisting interface

Return Value:

    N/A

--*/
    : CMetaInterface(pInterface),
      m_hKey(NULL),
      m_hBase(NULL),
      m_strMetaPath(),
      m_dwFlags(0L),
      m_cbInitialBufferSize(MB_INIT_BUFF_SIZE),
      m_fAllowRootOperations(TRUE),
      m_fOwnKey(TRUE)
{
    m_hrKey = CMetaInterface::QueryResult(); 
}        



CMetaKey::CMetaKey(
    IN CComAuthInfo * pAuthInfo,    OPTIONAL
    IN LPCTSTR lpszMDPath,          OPTIONAL
    IN DWORD   dwFlags,               
    IN METADATA_HANDLE hkBase
    )
/*++

Routine Description:

    Fully defined constructor that opens a key

Arguments:

    CComAuthInfo * pAuthInfo : Auth info or NULL
    LPCTSTR lpszMDPath       : Path or NULL
    DWORD   dwFlags          : Open permissions
    METADATA_HANDLE hkBase   : Base key

Return Value:

    N/A

--*/
    : CMetaInterface(pAuthInfo),
      m_hKey(NULL),
      m_hBase(NULL),
      m_dwFlags(0L),
      m_cbInitialBufferSize(MB_INIT_BUFF_SIZE),
      m_fAllowRootOperations(FALSE),
      m_strMetaPath(),
      m_fOwnKey(TRUE)
{
    m_hrKey = CMetaInterface::QueryResult(); 

    if (SUCCEEDED(m_hrKey))
    {
        m_hrKey = Open(dwFlags, lpszMDPath, hkBase);
    }
}



CMetaKey::CMetaKey(
    IN CMetaInterface * pInterface,
    IN LPCTSTR lpszMDPath,              OPTIONAL
    IN DWORD   dwFlags,               
    IN METADATA_HANDLE hkBase
    )
/*++

Routine Description:

    Fully defined constructor that opens a key

Arguments:

    CMetaInterface * pInterface : Existing interface
    DWORD   dwFlags             : Open permissions
    METADATA_HANDLE hkBase      : Base key
    LPCTSTR lpszMDPath          : Path or NULL

Return Value:

    N/A

--*/
    : CMetaInterface(pInterface),
      m_hKey(NULL),
      m_hBase(NULL),
      m_strMetaPath(),
      m_dwFlags(0L),
      m_cbInitialBufferSize(MB_INIT_BUFF_SIZE),
      m_fAllowRootOperations(FALSE),
      m_fOwnKey(TRUE)
{
    m_hrKey = CMetaInterface::QueryResult(); 

    if (SUCCEEDED(m_hrKey))
    {
        m_hrKey = Open(dwFlags, lpszMDPath, hkBase);
    }
}



CMetaKey::CMetaKey(
    IN BOOL  fOwnKey,
    IN CMetaKey * pKey
    )
/*++

Routine Description:

    Copy constructor. 

Arguments:

    BOOL  fOwnKey               : TRUE to take ownership of the key
    const CMetaKey * pKey       : Existing key

Return Value:

    N/A

--*/
    : CMetaInterface(pKey),
      m_hKey(pKey->m_hKey),
      m_hBase(pKey->m_hBase),
      m_dwFlags(pKey->m_dwFlags),
      m_cbInitialBufferSize(pKey->m_cbInitialBufferSize),
      m_fAllowRootOperations(pKey->m_fAllowRootOperations),
      m_hrKey(pKey->m_hrKey),
      m_strMetaPath(pKey->m_strMetaPath),
      m_fOwnKey(fOwnKey)
{
    //
    // No provisions for anything else at the moment
    //
    ASSERT(!m_fOwnKey);
}



CMetaKey::~CMetaKey()
/*++

Routine Description:

    Destructor -- Close the key.

Arguments:

    N/A

Return Value:

    N/A

--*/
{
    if (IsOpen() && m_fOwnKey)
    {
        Close();
    }
}



/* virtual */
BOOL 
CMetaKey::Succeeded() const
/*++

Routine Description:

    Determine if object was constructed successfully

Arguments:

    None

Return Value:

    TRUE for success, FALSE for failure

--*/
{
    return SUCCEEDED(m_hrKey);
}



/* virtual */
HRESULT 
CMetaKey::QueryResult() const
/*++

Routine Description:

    Return the construction error for this object

Arguments:

    None

Return Value:

    HRESULT from construction errors

--*/
{
    return m_hrKey;
}



HRESULT 
CMetaKey::Open(
    IN DWORD dwFlags,                
    IN LPCTSTR lpszMDPath,          OPTIONAL
    IN METADATA_HANDLE hkBase
    )
/*++

Routine Description:

    Attempt to open a metabase key

Arguments:

    DWORD dwFlags           : Permission flags
    LPCTSTR lpszMDPath      : Optional path
    METADATA_HANDLE hkBase  : Base metabase key

Return Value:

    HRESULT

--*/
{
    ASSURE_PROPER_INTERFACE();

    if (m_hKey != NULL)
    {
        ASSERT_MSG("Attempting to open key that already has an open handle");

        TRACEEOLID("Closing that key");
        Close();
    }

    //
    // Base key is stored for reopen purposes only
    //
    m_hBase = hkBase;
    m_strMetaPath = lpszMDPath;
    m_dwFlags = dwFlags;

    return OpenKey(m_hBase, m_strMetaPath, m_dwFlags, &m_hKey);
}



HRESULT 
CMetaKey::CreatePathFromFailedOpen()
/*++

Routine Description:

    If the path doesn't exist, create it.  This method should be
    called after an Open call failed (because it will have initialized
    m_strMetaPath.

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    CString strParentPath;
    CString strObjectName;
    CString strSavePath(m_strMetaPath);

    CMetabasePath::SplitMetaPathAtInstance(
        m_strMetaPath, 
        strParentPath, 
        strObjectName
        );

    CError err(Open(
        METADATA_PERMISSION_WRITE,
        strParentPath
        ));

    if (err.Succeeded())
    {
        //
        // This really should never fail, because we're opening
        // the path at the instance.
        //
        err = AddKey(strObjectName);
    }

    if (IsOpen())
    {
        Close();
    }

    //
    // The previous open wiped out the path...
    //
    m_strMetaPath = strSavePath;

    return err;
}



HRESULT
CMetaKey::Close()
/*++

Routine Description:

    Close the currently open key.

Arguments:

    N/A

Return Value:

    N/A

--*/
{
    ASSURE_PROPER_INTERFACE();

    HRESULT hr = S_OK;

    ASSERT(m_hKey != NULL);
    ASSERT(m_fOwnKey);

    if (m_hKey)
    {
        hr = CloseKey(m_hKey);

        if (SUCCEEDED(hr))
        {
            m_hKey = NULL;
        }
    }

    return hr;
}



HRESULT
CMetaKey::ConvertToParentPath(
    IN  BOOL fImmediate
    )
/*++

Routine Description:

    Change the path to the parent path.

Arguments:

    BOOL fImmediate     : If TRUE, the immediate parent's path will be used
                          if FALSE, the first parent that really exists

Return Value:

    HRESULT

        ERROR_INVALID_PARAMETER if there is no valid path

--*/
{
    BOOL fIsOpen = IsOpen();

    if (fIsOpen)
    {
        Close();
    }

    CError err;

    FOREVER
    {
        if (!CMetabasePath::ConvertToParentPath(m_strMetaPath))
        {
            //
            // There is no parent path
            //
            err = ERROR_INVALID_PARAMETER;
            break;
        }

        err = ReOpen();

        //
        // Path not found is the only valid error
        // other than success.
        //
        if (fImmediate 
            || err.Succeeded() 
            || err.Win32Error() != ERROR_PATH_NOT_FOUND)
        {
            break;
        }
    }

    //
    // Remember to reset the construction error
    // which referred to the parent path.
    //
    m_hrKey = err;

    return err;
}




/* protected */
HRESULT
CMetaKey::GetPropertyValue(
    IN  DWORD dwID,
    OUT IN DWORD & dwSize,               OPTIONAL
    OUT IN void *& pvData,               OPTIONAL
    OUT IN DWORD * pdwDataType,          OPTIONAL
    IN  BOOL * pfInheritanceOverride,    OPTIONAL
    IN  LPCTSTR lpszMDPath,              OPTIONAL
    OUT DWORD * pdwAttributes            OPTIONAL
    )
/*++

Routine Description:

    Get metadata on the currently open key.

Arguments:

    DWORD dwID                      : Property ID number
    DWORD & dwSize                  : Buffer size (could be 0)
    void *& pvData                  : Buffer -- will allocate if NULL
    DWORD * pdwDataType             : NULL or on in  contains valid data types,
                                    :         on out contains actual data type
    BOOL * pfInheritanceOverride    : NULL or on forces inheritance on/off
    LPCTSTR lpszMDPath              : Optional path off the open key
    DWORD * pdwAttributes           : Optionally returns attributes    

Return Value:

    HRESULT 

    ERROR_INVALID_HANDLE        : If the handle is not open
    ERROR_INVALID_PARAMETER     : If the property id is not found,
                                  or the data type doesn't match requested type
    ERROR_OUTOFMEMORY           : Out of memory

--*/
{
    ASSURE_PROPER_INTERFACE();
    ASSURE_OPEN_KEY();

    METADATA_RECORD mdRecord;
    FETCH_PROPERTY_DATA_OR_FAIL(dwID, mdRecord);

    //
    // If unable to find this property ID in our table, or
    // if we specified a desired type, and this type doesn't 
    // match it, give up.
    //
    if (pdwDataType && *pdwDataType != ALL_METADATA 
        && *pdwDataType != mdRecord.dwMDDataType)
    {
        ASSERT_MSG("Invalid parameter");
        return HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
    }

    //
    // Check to see if inheritance behaviour is overridden
    //
    if (pfInheritanceOverride)
    {
        if (*pfInheritanceOverride)
        {
            mdRecord.dwMDAttributes |= METADATA_INHERIT;
        }
        else
        {
            mdRecord.dwMDAttributes &= ~METADATA_INHERIT;
        }
    }

    //
    // This causes a bad parameter error on input otherwise
    //
    mdRecord.dwMDAttributes &= ~METADATA_REFERENCE;

    //
    // If we're looking for inheritable properties, the path
    // doesn't have to be completely specified.
    //
    if (mdRecord.dwMDAttributes & METADATA_INHERIT)
    {
        mdRecord.dwMDAttributes |= (METADATA_PARTIAL_PATH | METADATA_ISINHERITED);
    }

    ASSERT(dwSize > 0 || pvData == NULL);
    
    mdRecord.dwMDDataLen = dwSize;
    mdRecord.pbMDData = (LPBYTE)pvData;

    //
    // If no buffer provided, allocate one.
    //
    HRESULT hr = S_OK;
    BOOL fBufferTooSmall = FALSE;
    BOOL fAllocatedMemory = FALSE;
    DWORD dwInitSize = m_cbInitialBufferSize;

    do
    {
        if(mdRecord.pbMDData == NULL)
        {
            mdRecord.dwMDDataLen = dwInitSize;
            mdRecord.pbMDData = (LPBYTE)AllocMem(dwInitSize);

            if(mdRecord.pbMDData == NULL && dwInitSize > 0)
            {
                hr = HRESULT_FROM_WIN32(ERROR_OUTOFMEMORY);
                break;
            }

            ++fAllocatedMemory;
        }

        //
        // Get the data
        //
        DWORD dwRequiredDataLen = 0;
        hr = GetData(m_hKey, lpszMDPath, &mdRecord, &dwRequiredDataLen);

        //
        // Re-fetch the buffer if it's too small.
        //
        fBufferTooSmall = 
            (HRESULT_CODE(hr) == ERROR_INSUFFICIENT_BUFFER) && fAllocatedMemory;

        if(fBufferTooSmall)
        {
            //
            // Delete the old buffer, and set up for a re-fetch.
            //
            FreeMem(mdRecord.pbMDData);
            mdRecord.pbMDData = NULL;
            dwInitSize = dwRequiredDataLen;
        }
    }
    while(fBufferTooSmall);

    //
    // Failed
    //
    if(FAILED(hr) && fAllocatedMemory)
    {
        FreeMem(mdRecord.pbMDData);
        mdRecord.pbMDData = NULL;
    }

    dwSize = mdRecord.dwMDDataLen;
    pvData = mdRecord.pbMDData;

    if (pdwDataType != NULL)
    {
        //
        // Return actual data type
        //
        *pdwDataType = mdRecord.dwMDDataType;
    }

    if (pdwAttributes != NULL)
    {
        //
        // Return data attributes
        //
        *pdwAttributes =  mdRecord.dwMDAttributes;
    }

    return hr;
}



/* protected */
HRESULT 
CMetaKey::GetDataPaths( 
    OUT CStringListEx & strlDataPaths,
    IN  DWORD   dwMDIdentifier,
    IN  DWORD   dwMDDataType,
    IN  LPCTSTR lpszMDPath              OPTIONAL
    )
/*++

Routine Description:

    Get data paths

Arguments:


Return Value:

    HRESULT

--*/
{
    ASSURE_PROPER_INTERFACE();
    ASSURE_OPEN_KEY();

    //
    // Start with a small buffer
    //
    DWORD  dwMDBufferSize = 1024;
    LPTSTR lpszBuffer = NULL;
    CError err;

    do
    {
        if (lpszBuffer != NULL)
        {
            FreeMem(lpszBuffer);
        }

        lpszBuffer = AllocTString(dwMDBufferSize);

        if (lpszBuffer == NULL)
        {
            err = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        err = CMetaInterface::GetDataPaths(
            m_hKey,
            lpszMDPath,
            dwMDIdentifier,
            dwMDDataType,
            dwMDBufferSize,
            lpszBuffer,
            &dwMDBufferSize
            );
    }
    while(err.Win32Error() == ERROR_INSUFFICIENT_BUFFER);

    if (err.Win32Error() == ERROR_PATH_NOT_FOUND)
    {
        //
        // That's ok... this is some sort of physical directory
        // that doesn't currently exist in the metabase, and
        // which therefore doesn't have any descendants anyway.
        //
        ZeroMemory(lpszBuffer, dwMDBufferSize);
        err.Reset();
    }

    if (err.Succeeded())
    {
        ConvertDoubleNullListToStringList(lpszBuffer, strlDataPaths);
        FreeMem(lpszBuffer);
    }

    return err;
}



HRESULT
CMetaKey::CheckDescendants(
    IN DWORD   dwID,
    IN CComAuthInfo * pAuthInfo, OPTIONAL
    IN LPCTSTR lpszMDPath         OPTIONAL
    )
/*++

Routine Description:

    Check for descendant overrides;  If there are any, bring up a dialog
    that displays them, and give the user the opportunity the remove
    the overrides.

Arguments:

    DWORD dwID               : Property ID
    CComAuthInfo * pAuthInfo : Server or NULL
    LPCTSTR lpszMDPath       : Metabase path or NULL

Return Value:

    HRESULT

--*/
{
    ASSURE_PROPER_INTERFACE();

    HRESULT hr = S_OK;

    METADATA_RECORD mdRecord;
    FETCH_PROPERTY_DATA_OR_FAIL(dwID, mdRecord);

    if (mdRecord.dwMDAttributes & METADATA_INHERIT)
    {
        CStringListEx strlDataPaths;

        hr = GetDataPaths( 
            strlDataPaths,
            mdRecord.dwMDIdentifier,
            mdRecord.dwMDDataType,
            lpszMDPath
            );

        if (SUCCEEDED(hr) && !strlDataPaths.IsEmpty())
        {
            //
            // Bring up the inheritance override dialog
            //
            CInheritanceDlg dlg(
                dwID,
                FROM_WRITE_PROPERTY,
                pAuthInfo,
                lpszMDPath,
                strlDataPaths
                );

            if (!dlg.IsEmpty())
            {
                dlg.DoModal();
            }
        }
    }

    return hr;
}



/* protected */
HRESULT
CMetaKey::SetPropertyValue(
    IN DWORD dwID,
    IN DWORD dwSize,
    IN void * pvData,
    IN BOOL * pfInheritanceOverride,    OPTIONAL
    IN LPCTSTR lpszMDPath               OPTIONAL
    )
/*++

Routine Description:

    Set metadata on the open key.  The key must have been opened with
    write permission.

Arguments:

    DWORD dwID                      : Property ID
    DWORD dwSize                    : Size of data
    void * pvData                   : Data buffer
    BOOL * pfInheritanceOverride    : NULL or forces inheritance on/off
    LPCTSTR lpszMDPath              : Optional path off the open key

Return Value:

    HRESULT 

    ERROR_INVALID_HANDLE            : If the handle is not open
    ERROR_INVALID_PARAMETER         : If the property id is not found,
                                      or the buffer is NULL or of size 0

--*/
{
    ASSURE_PROPER_INTERFACE();
    ASSURE_OPEN_KEY();

    if (pvData == NULL && dwSize != 0)
    {
        ASSERT_MSG("No Data");
        return HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
    }

    METADATA_RECORD mdRecord;
    FETCH_PROPERTY_DATA_OR_FAIL(dwID, mdRecord);

    if (pfInheritanceOverride)
    {
        if (*pfInheritanceOverride)
        {
            mdRecord.dwMDAttributes |= METADATA_INHERIT;
        }
        else
        {
            mdRecord.dwMDAttributes &= ~METADATA_INHERIT;
        }
    }

    mdRecord.dwMDDataLen = dwSize;
    mdRecord.pbMDData = (LPBYTE)pvData;

    return SetData(m_hKey, lpszMDPath, &mdRecord);
}



/* protected */
HRESULT 
CMetaKey::GetAllData(
    IN  DWORD dwMDAttributes,
    IN  DWORD dwMDUserType,
    IN  DWORD dwMDDataType,
    OUT DWORD * pdwMDNumEntries,
    OUT DWORD * pdwMDDataLen,
    OUT PBYTE * ppbMDData,
    IN  LPCTSTR lpszMDPath              OPTIONAL
    )
/*++

Routine Description:

    Get all data off the open key.  Buffer is created automatically.

Arguments:

    DWORD dwMDAttributes            : Attributes
    DWORD dwMDUserType              : User type to fetch
    DWORD dwMDDataType              : Data type to fetch
    DWORD * pdwMDNumEntries         : Returns number of entries read
    DWORD * pdwMDDataLen            : Returns size of data buffer
    PBYTE * ppbMDData               : Returns data buffer
    LPCTSTR lpszMDPath              : Optional data path        

Return Value:

    HRESULT

--*/
{
    ASSURE_PROPER_INTERFACE();
    ASSURE_OPEN_KEY();

    //
    // Check for valid parameters
    //
    if(!pdwMDDataLen || !ppbMDData || !pdwMDNumEntries)
    {
        return HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
    }

    HRESULT hr = S_OK;
    BOOL fBufferTooSmall = FALSE;
    DWORD dwMDDataSetNumber;
    DWORD dwRequiredBufferSize;
    DWORD dwInitSize = m_cbInitialBufferSize;
    *ppbMDData = NULL;

    do
    {
        *pdwMDDataLen = dwInitSize;
        *ppbMDData = (LPBYTE)AllocMem(dwInitSize);

        if (ppbMDData == NULL && dwInitSize > 0)
        {
            hr = HRESULT_FROM_WIN32(ERROR_OUTOFMEMORY);
            break;
        }

        hr = CMetaInterface::GetAllData(
            m_hKey,
            lpszMDPath,
            dwMDAttributes,
            dwMDUserType,
            dwMDDataType,
            pdwMDNumEntries,
            &dwMDDataSetNumber,
            *pdwMDDataLen,
            *ppbMDData,
            &dwRequiredBufferSize
            );

        //
        // Re-fetch the buffer if it's too small.
        //
        fBufferTooSmall = (HRESULT_CODE(hr) == ERROR_INSUFFICIENT_BUFFER);

        if(fBufferTooSmall)
        {
            //
            // Delete the old buffer, and set up for a re-fetch.
            //
            SAFE_FREEMEM(*ppbMDData);
            dwInitSize = dwRequiredBufferSize;
        }
    }
    while (fBufferTooSmall);

    if (FAILED(hr))
    {
        //
        // No good, be sure we don't leak anything
        //
        SAFE_FREEMEM(*ppbMDData);
        dwInitSize = 0L;
    }

    return hr;
}



HRESULT
CMetaKey::QueryValue(
    IN  DWORD dwID,
    IN  OUT DWORD & dwValue,
    IN  BOOL * pfInheritanceOverride, OPTIONAL
    IN  LPCTSTR lpszMDPath,           OPTIONAL
    OUT DWORD * pdwAttributes         OPTIONAL
    )
/*++

Routine Description:

    Fetch data as a DWORD

Arguments:

    DWORD dwID                      : Property ID
    DWORD & dwValue                 : Returns the value read in
    BOOL * pfInheritanceOverride    : NULL or forces inheritance on/off
    LPCTSTR lpszMDPath              : Optional path off the open key
    DWORD * pdwAttributes           : Optionally returns attributes    

Return Value:

    HRESULT

--*/
{
    DWORD dwSize = sizeof(dwValue);
    DWORD dwDataType = DWORD_METADATA;
    void * pvData = &dwValue;

    return GetPropertyValue(
        dwID, 
        dwSize, 
        pvData, 
        &dwDataType, 
        pfInheritanceOverride,
        lpszMDPath,
        pdwAttributes
        );
}



HRESULT
CMetaKey::QueryValue(
    IN  DWORD dwID,
    IN  OUT CString & strValue,
    IN  BOOL * pfInheritanceOverride, OPTIONAL
    IN  LPCTSTR lpszMDPath,           OPTIONAL
    OUT DWORD * pdwAttributes         OPTIONAL
    )
/*++

Routine Description:

    Fetch data as a string

Arguments:

    DWORD dwID                      : Property ID
    DWORD & strValue                : Returns the value read in
    BOOL * pfInheritanceOverride    : NULL or forces inheritance on/off
    LPCTSTR lpszMDPath              : Optional path off the open key
    DWORD * pdwAttributes           : Optionally returns attributes    

Return Value:

    HRESULT

--*/
{
    //
    // Get GetData allocate the buffer for us
    //
    DWORD dwSize = 0;
    DWORD dwDataType = ALL_METADATA;
    LPTSTR lpData = NULL;

    HRESULT hr = GetPropertyValue(
        dwID, 
        dwSize, 
        (void *&)lpData, 
        &dwDataType,
        pfInheritanceOverride,
        lpszMDPath,
        pdwAttributes
        );

    if (SUCCEEDED(hr))
    {
        //
        // Notes: consider optional auto-expansion on EXPANDSZ_METADATA
        // (see registry functions), and data type conversions for DWORD
        // or MULTISZ_METADATA or BINARY_METADATA
        //
        if (dwDataType == EXPANDSZ_METADATA || dwDataType == STRING_METADATA)
        {
            try
            {
                strValue = lpData;
            }
            catch(CMemoryException * e)
            {
                hr = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
                strValue.Empty();
                e->Delete();
            }
        }
        else
        {
            hr = HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
        }
    }

    if (lpData)
    {
        FreeMem(lpData);
    }

    return hr;
}



HRESULT
CMetaKey::QueryValue(
    IN  DWORD dwID,
    IN  OUT CComBSTR & strValue,
    IN  BOOL * pfInheritanceOverride, OPTIONAL
    IN  LPCTSTR lpszMDPath,           OPTIONAL
    OUT DWORD * pdwAttributes         OPTIONAL
    )
/*++

Routine Description:

    Fetch data as a string

Arguments:

    DWORD dwID                      : Property ID
    DWORD & CComBSTR                : Returns the value read in
    BOOL * pfInheritanceOverride    : NULL or forces inheritance on/off
    LPCTSTR lpszMDPath              : Optional path off the open key
    DWORD * pdwAttributes           : Optionally returns attributes    

Return Value:

    HRESULT

--*/
{
    //
    // Get GetData allocate the buffer for us
    //
    DWORD dwSize = 0;
    DWORD dwDataType = ALL_METADATA;
    LPTSTR lpData = NULL;

    HRESULT hr = GetPropertyValue(
        dwID, 
        dwSize, 
        (void *&)lpData, 
        &dwDataType,
        pfInheritanceOverride,
        lpszMDPath,
        pdwAttributes
        );

    if (SUCCEEDED(hr))
    {
        //
        // Notes: consider optional auto-expansion on EXPANDSZ_METADATA
        // (see registry functions), and data type conversions for DWORD
        // or MULTISZ_METADATA or BINARY_METADATA
        //
        if (dwDataType == EXPANDSZ_METADATA || dwDataType == STRING_METADATA)
        {
            strValue = lpData;
        }
        else
        {
            hr = HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
        }
    }

    if (lpData)
    {
        FreeMem(lpData);
    }

    return hr;
}




HRESULT
CMetaKey::QueryValue(
    IN  DWORD dwID,
    IN  OUT CStringListEx & strlValue,
    IN  BOOL * pfInheritanceOverride, OPTIONAL
    IN  LPCTSTR lpszMDPath,           OPTIONAL
    OUT DWORD * pdwAttributes         OPTIONAL
    )
/*++

Routine Description:

    Fetch data as a stringlist

Arguments:

    DWORD dwID                      : Property ID
    DWORD & strlValue               : Returns the value read in
    BOOL * pfInheritanceOverride    : NULL or forces inheritance on/off
    LPCTSTR lpszMDPath              : Optional path off the open key
    DWORD * pdwAttributes           : Optionally returns attributes    

Return Value:

    HRESULT

--*/
{
    //
    // Get GetData allocate the buffer for us
    //
    DWORD dwSize = 0;
    DWORD dwDataType = MULTISZ_METADATA;
    LPTSTR lpData = NULL;

    HRESULT hr = GetPropertyValue(
        dwID, 
        dwSize, 
        (void *&)lpData, 
        &dwDataType,
        pfInheritanceOverride,
        lpszMDPath,
        pdwAttributes
        );

    if (SUCCEEDED(hr))
    {
        //
        // Notes: Consider accepting a single STRING
        //
        ASSERT(dwDataType == MULTISZ_METADATA);

        DWORD err = ConvertDoubleNullListToStringList(
            lpData,
            strlValue,
            dwSize / sizeof(TCHAR)
            );
        hr = HRESULT_FROM_WIN32(err);
    }

    if (lpData)
    {
        FreeMem(lpData);
    }

    return hr;
}



HRESULT
CMetaKey::QueryValue(
    IN  DWORD dwID,
    IN  OUT CBlob & blValue,
    IN  BOOL * pfInheritanceOverride, OPTIONAL
    IN  LPCTSTR lpszMDPath,           OPTIONAL
    OUT DWORD * pdwAttributes         OPTIONAL
    )
/*++

Routine Description:

    Fetch data as a binary blob

Arguments:

    DWORD dwID                      : Property ID
    DWORD CBlob & blValue           : Returns the binary blob
    BOOL * pfInheritanceOverride    : NULL or forces inheritance on/off
    LPCTSTR lpszMDPath              : Optional path off the open key
    DWORD * pdwAttributes           : Optionally returns attributes    

Return Value:

    HRESULT

--*/
{
    //
    // Get GetData allocate the buffer for us
    //
    DWORD dwSize = 0;
    DWORD dwDataType = BINARY_METADATA;
    LPBYTE pbData = NULL;

    HRESULT hr = GetPropertyValue(
        dwID, 
        dwSize, 
        (void *&)pbData, 
        &dwDataType,
        pfInheritanceOverride,
        lpszMDPath,
        pdwAttributes
        );

    if (SUCCEEDED(hr))
    {
        //
        // Blob takes ownership of the data, so don't free it...
        //
        ASSERT_READ_PTR2(pbData, dwSize);
        blValue.SetValue(dwSize, pbData, FALSE);
    }

    return hr;
}



HRESULT 
CMetaKey::SetValue(
    IN DWORD dwID,
    IN CStringListEx & strlValue,
    IN BOOL * pfInheritanceOverride,        OPTIONAL
    IN LPCTSTR lpszMDPath                   OPTIONAL
    )
/*++

Routine Description:

    Store data as string

Arguments:

    DWORD dwID                   : Property ID
    CStringListEx & strlValue    : Value to be written
    BOOL * pfInheritanceOverride : NULL or forces inheritance on/off
    LPCTSTR lpszMDPath           : Optional path (or NULL or "")

Return Value:

    HRESULT

--*/
{
    DWORD cCharacters;
    LPTSTR lpstr = NULL;

    //
    // Flatten value
    //
    ConvertStringListToDoubleNullList(
       strlValue,
       cCharacters,
       lpstr
       );

    HRESULT hr = SetPropertyValue(
        dwID,
        cCharacters * sizeof(TCHAR),
        (void *)lpstr,
        pfInheritanceOverride,
        lpszMDPath
        );

    SAFE_FREEMEM(lpstr);

    return hr;
}


HRESULT 
CMetaKey::SetValue(
    IN DWORD dwID,
    IN CBlob & blValue,
    IN BOOL * pfInheritanceOverride,    OPTIONAL     
    IN LPCTSTR lpszMDPath               OPTIONAL        
    )
/*++

Routine Description:

    Store data as binary

Arguments:

    DWORD dwID                   : Property ID
    CBlob & blValue              : Value to be written
    BOOL * pfInheritanceOverride : NULL or forces inheritance on/off
    LPCTSTR lpszMDPath           : Optional path (or NULL or "")

Return Value:

    HRESULT

--*/
{
    return SetPropertyValue(
        dwID,
        blValue.GetSize(),
        (void *)blValue.GetData(),
        pfInheritanceOverride,
        lpszMDPath
        );
}



HRESULT
CMetaKey::DeleteValue(
    DWORD   dwID,
    LPCTSTR lpszMDPath      OPTIONAL
    )
/*++

Routine Description:

    Delete data

Arguments:

    DWORD   dwID            : Property ID of property to be deleted
    LPCTSTR lpszMDPath      : Optional path (or NULL or "")

Return Value:

    HRESULT

--*/
{
    ASSURE_PROPER_INTERFACE();
    ASSURE_OPEN_KEY();

    METADATA_RECORD mdRecord;
    FETCH_PROPERTY_DATA_OR_FAIL(dwID, mdRecord);

    return DeleteData(
        m_hKey,
        lpszMDPath,
        mdRecord.dwMDIdentifier,
        mdRecord.dwMDDataType
        );
}



HRESULT 
CMetaKey::DoesPathExist(
    IN LPCTSTR lpszMDPath
    )
/*++

Routine Description:

    Determine if the path exists

Arguments:

    LPCTSTR lpszMDPath      : Relative path off the open key

Return Value:

    HRESULT, or S_OK if the path exists.

--*/
{
    ASSURE_PROPER_INTERFACE();
    ASSURE_OPEN_KEY();

    FILETIME ft;

    return GetLastChangeTime(m_hKey, lpszMDPath, &ft, FALSE);
}



HRESULT
CMetaInterface::Regenerate()
/*++

Routine Description:

    Attempt to recreate the interface pointer.  This assumes that the interface
    had been successfully created before, but has become invalid at some
    point afterwards.

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    ASSERT_PTR(m_pInterface);           // Must have been initialised

    SAFE_RELEASE(m_pInterface);

    m_hrInterface = Create();

    return m_hrInterface;
}



//
// CWamInterface class
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



CWamInterface::CWamInterface(
    IN CComAuthInfo * pAuthInfo         OPTIONAL
    )
/*++

Routine Description:

    Construct and initialize the interface.

Arguments:

    CComAuthInfo * pAuthInfo   : Auth info.  NULL indicates the local computer.

Return Value:

    N/A

--*/
    : CIISInterface(pAuthInfo),
      m_pInterface(NULL),
      m_fSupportsPooledProc(FALSE)
{
    //
    // Initialize the interface
    //
    m_hrInterface = Create();
}



CWamInterface::CWamInterface(
    IN CWamInterface * pInterface
    )
/*++

Routine Description:

    Construct from existing interface (copy constructor)

Arguments:

    CWamInterface * pInterface  : Existing interface

Return Value:

    N/A

--*/
    : CIISInterface(&pInterface->m_auth, pInterface->m_hrInterface),
      m_pInterface(pInterface->m_pInterface),
      m_fSupportsPooledProc(FALSE)
{
    ASSERT_PTR(m_pInterface);
    m_pInterface->AddRef();
}



CWamInterface::~CWamInterface()
/*++

Routine Description:

    Destructor -- releases the interface.

Arguments:

    N/A

Return Value:

    N/A

--*/
{
    SAFE_RELEASE(m_pInterface);
}



/* protected */
HRESULT
CWamInterface::Create()
/*++

Routine Description:
    Create the interface with DCOM

Arguments:
    None

Return Value:
    HRESULT 

Notes:
    First, it will attempt to create the new interface, if it
    fails, it will attempt to create the downlevel interface

--*/
{
    CLSID rgCLSID[2];
    IID   rgIID[2];

    rgCLSID[1] = rgCLSID[0] = CLSID_WamAdmin;
    rgIID[0] = IID_IWamAdmin2;
    rgIID[1] = IID_IWamAdmin;
    
    ASSERT(ARRAY_SIZE(rgCLSID) == ARRAY_SIZE(rgIID));
    int cInterfaces = ARRAY_SIZE(rgCLSID);
    int iInterface;
    
    HRESULT hr = CIISInterface::Create(
        cInterfaces,
        rgIID, 
        rgCLSID, 
        &iInterface, 
        (IUnknown **)&m_pInterface
        );

    if (SUCCEEDED(hr))
    {
        //
        // Only supported on IWamAdmin2
        //
        m_fSupportsPooledProc = (rgIID[iInterface] == IID_IWamAdmin2);
    }

    return hr;
}



HRESULT 
CWamInterface::AppCreate( 
    IN LPCTSTR szMDPath,
    IN DWORD   dwAppProtection
    )
/*++

Routine Description:

    Create  application

Arguments:

    LPCTSTR szMDPath      : Metabase path
    DWORD dwAppProtection : APP_INPROC     to create in-proc app
                            APP_OUTOFPROC  to create out-of-proc app
                            APP_POOLEDPROC to create a pooled-proc app

Return Value:

    HRESULT (ERROR_INVALID_PARAMETER if unsupported protection state is requested)

--*/
{
    if (m_fSupportsPooledProc)
    {
        //
        // Interface pointer is really IWamAdmin2, so call the new method
        //
        return ((IWamAdmin2 *)m_pInterface)->AppCreate2(szMDPath, dwAppProtection);
    }

    //
    // Call the downlevel API
    //
    if (dwAppProtection == APP_INPROC || dwAppProtection == APP_OUTOFPROC)
    {
        BOOL fInProc = (dwAppProtection == APP_INPROC);
    
        ASSERT_PTR(m_pInterface);
        return m_pInterface->AppCreate(szMDPath, fInProc);
    }

    return CError(ERROR_INVALID_PARAMETER);
}



//
// CMetaback Class
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<


const LPCTSTR CMetaBack::s_szMasterAppRoot =\
    SZ_MBN_SEP_STR SZ_MBN_MACHINE SZ_MBN_SEP_STR SZ_MBN_WEB;


CMetaBack::CMetaBack(
    IN CComAuthInfo * pAuthInfo        OPTIONAL
    )
/*++

Routine Description:

    Constructor for metabase backup/restore operations class.  This object
    is both a WAM interface and a METABASE interface.

Arguments:

    CComAuthInfo * pAuthInfo    : Auth info.  NULL indicates the local computer.

Return Value:

    N/A

--*/
    : m_dwIndex(0),
      CMetaInterface(pAuthInfo),
      CWamInterface(pAuthInfo)
{
}



/* virtual */
BOOL 
CMetaBack::Succeeded() const
/*++

Routine Description:

    Determine if object was constructed successfully.

Arguments:

    None

Return Value:

    TRUE for success, FALSE for failure

--*/
{
    return CMetaInterface::Succeeded() && CWamInterface::Succeeded();
}



/* virtual */
HRESULT 
CMetaBack::QueryResult() const
/*++

Routine Description:

    Return the construction error for this object

Arguments:

    None

Return Value:

    HRESULT from construction errors

--*/
{
    //
    // Both interfaces must have constructed successfully
    //
    HRESULT hr = CMetaInterface::QueryResult();

    if (SUCCEEDED(hr))
    {
        hr = CWamInterface::QueryResult();
    }    

    return hr;
}



HRESULT 
CMetaBack::Restore(
    IN LPCTSTR lpszLocation,
    IN DWORD dwVersion
    )
/*++

Routine Description:

    Restore metabase

Arguments:

    DWORD dwVersion         : Backup version
    LPCTSTR lpszLocation    : Backup location

Return Value:

    HRESULT

--*/
{
    //
    // Backup and restore the application information from a restore
    //
    CString strPath(s_szMasterAppRoot);
    HRESULT hr = AppDeleteRecoverable(strPath, TRUE);

    if (SUCCEEDED(hr))
    {
        hr = CMetaInterface::Restore(lpszLocation, dwVersion, 0);

        if (SUCCEEDED(hr))
        {
            hr = AppRecover(strPath, TRUE);
        }
    }

    return hr;
}


HRESULT
CMetaBack::BackupWithPassword(
    IN LPCTSTR lpszLocation,
	IN LPCTSTR lpszPassword
    )
{
    return CMetaInterface::BackupWithPassword(
        lpszLocation, 
        MD_BACKUP_NEXT_VERSION, 
        MD_BACKUP_SAVE_FIRST,
		lpszPassword
        );
}

HRESULT 
CMetaBack::RestoreWithPassword(
    IN LPCTSTR lpszLocation,
    IN DWORD dwVersion,
    IN LPCTSTR lpszPassword
    )
/*++

Routine Description:

    Restore metabase

Arguments:

    DWORD dwVersion         : Backup version
    LPCTSTR lpszLocation    : Backup location
    LPCTSTR lpszPassword    : Backup password

Return Value:

    HRESULT

--*/
{
    //
    // Backup and restore the application information from a restore
    //
   // BUGBUG: clear it out, why we had an error "parameter is incorrect" from AppDeleteRecoverable
    CString strPath(s_szMasterAppRoot);
    HRESULT hr;// = AppDeleteRecoverable(strPath, TRUE);

//    if (SUCCEEDED(hr))
//    {
        hr = CMetaInterface::RestoreWithPassword(lpszLocation, dwVersion, 0, lpszPassword);

//        if (SUCCEEDED(hr))
//        {
//            hr = AppRecover(strPath, TRUE);
//        }
//    }

    return hr;
}


//
// CIISSvcControl class
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



CIISSvcControl::CIISSvcControl(
    IN CComAuthInfo * pAuthInfo        OPTIONAL
    )
/*++

Routine Description:

    Construct and initialize the interface.

Arguments:

    CComAuthInfo * pAuthInfo    : Auth info.  NULL indicates the local computer.

Return Value:

    N/A

--*/
    : CIISInterface(pAuthInfo),
      m_pInterface(NULL)
{
    //
    // Initialize the interface
    //
    m_hrInterface = Create();
}



CIISSvcControl::CIISSvcControl(
    IN CIISSvcControl * pInterface
    )
/*++

Routine Description:

    Construct from existing interface (copy constructor)

Arguments:

    CIISSvcControl * pInterface  : Existing interface

Return Value:

    N/A

--*/
    : CIISInterface(&pInterface->m_auth, pInterface->m_hrInterface),
      m_pInterface(pInterface->m_pInterface)
{
    ASSERT_PTR(m_pInterface);
    m_pInterface->AddRef();
}



CIISSvcControl::~CIISSvcControl()
/*++

Routine Description:

    Destructor -- releases the interface.

Arguments:

    N/A

Return Value:

    N/A

--*/
{
    SAFE_RELEASE(m_pInterface);
}



//
// CMetaEnumerator Clas
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



CMetaEnumerator::CMetaEnumerator(
    IN CComAuthInfo * pAuthInfo     OPTIONAL,
    IN LPCTSTR lpszMDPath           OPTIONAL,
    IN METADATA_HANDLE hkBase       OPTIONAL
    )
/*++

Routine Description:

    Metabase enumerator constructor.  This constructor creates a new interface
    and opens a key.

Arguments:

    CComAuthInfo * pAuthInfo : Auth info.  NULL indicates the local computer.
    LPCTSTR lpszMDPath       : Metabase path
    METADATA_HANDLE hkBase   : Metabase handle

Return Value:

    N/A

--*/
    : CMetaKey(pAuthInfo, lpszMDPath, METADATA_PERMISSION_READ, hkBase),
      m_dwIndex(0L)
{
}



CMetaEnumerator::CMetaEnumerator(
    IN CMetaInterface * pInterface,
    IN LPCTSTR lpszMDPath,                  OPTIONAL
    IN METADATA_HANDLE hkBase               OPTIONAL
    )
/*++

Routine Description:

    Metabase enumerator constructor.  This constructor uses an existing
    interface and opens a key.

Arguments:

    CMetaInterface * pInterface : Existing interface
    LPCTSTR lpszMDPath          : Metabase path
    METADATA_HANDLE hkBase      : Metabase handle

Return Value:

    N/A

--*/
    : CMetaKey(pInterface, lpszMDPath, METADATA_PERMISSION_READ, hkBase),
      m_dwIndex(0L)
{
}



CMetaEnumerator::CMetaEnumerator(
    IN BOOL fOwnKey,
    IN CMetaKey * pKey
    )
/*++

Routine Description:

    Metabase enumerator constructor.  This constructor uses an existing
    interface and open key.

Arguments:

    BOOL fOwnKey            : TRUE if we own the key (destructor will close)
    CMetaKey * pKey         : Open key

Return Value:

    N/A

--*/
    : CMetaKey(fOwnKey, pKey),
      m_dwIndex(0L)
{
}



HRESULT
CMetaEnumerator::Next(
    OUT CString & strKey,
    IN  LPCTSTR lpszMDPath      OPTIONAL
    )
/*++

Routine Description:

    Get the next subkey

Arguments:

    CString & str           Returns keyname
    LPCTSTR lpszMDPath      Optional subpath

Return Value:

    HRESULT

--*/
{
    ASSURE_PROPER_INTERFACE();
    ASSURE_OPEN_KEY();

    LPTSTR lpKey = strKey.GetBuffer(MAX_PATH);
    HRESULT hr = EnumKeys(m_hKey, lpszMDPath, lpKey, m_dwIndex++);
    strKey.ReleaseBuffer();

    return hr;        
}



HRESULT
CMetaEnumerator::Next(
    OUT DWORD & dwKey,
    OUT CString & strKey,
    IN  LPCTSTR lpszMDPath      OPTIONAL
    )
/*++

Routine Description:

    Get the next subkey as a DWORD.  This skips non-numeric
    keynames (including 0) until the first numeric key name 

Arguments:

    DWORD & dwKey           Numeric key
    CString & strKey        Same key in string format
    LPCTSTR lpszMDPath      Optional subpath

Return Value:

    HRESULT

--*/
{
    ASSURE_PROPER_INTERFACE();
    ASSURE_OPEN_KEY();

    HRESULT hr = S_OK;
    BOOL fContinue = TRUE;

    while (fContinue)
    {
        fContinue = FALSE;

        LPTSTR lpKey = strKey.GetBuffer(MAX_PATH);
        hr = EnumKeys(m_hKey, lpszMDPath, lpKey, m_dwIndex++);
        strKey.ReleaseBuffer();

        if (SUCCEEDED(hr))
        {
            if (FALSE == (dwKey = _ttoi((LPCTSTR)strKey)))
            {
                //
                // Ignore this one
                //
                fContinue = TRUE;
            }
        }
    }
    
    return hr;        
}



//
// CIISApplication class
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<</



CIISApplication::CIISApplication(
    IN CComAuthInfo * pAuthInfo   OPTIONAL,
    IN LPCTSTR lpszMetapath
    )
/*++

Routine Description:

    Construct IIS application.        

Arguments:

    CComAuthInfo * pAuthInfo : Authentication info.  NULL indicates the
                               local computer.
    LPCTSTR lpszMetapath     : Metabase path

Return Value:

    N/A

--*/
    : CWamInterface(pAuthInfo),
      CMetaKey(pAuthInfo),
      m_dwProcessProtection(APP_INPROC),
      m_dwAppState(APPSTATUS_NOTDEFINED),
      m_strFriendlyName(),
      m_strAppRoot(),
      m_strWamPath(lpszMetapath)
{
    CommonConstruct();
}



void
CIISApplication::CommonConstruct()
/*++

Routine Description:

    Perform common construction

Arguments:

    None

Return Value:

    None

--*/
{
    //
    // Munge the metapath so that WAM doesn't cough up a hairball.
    //


    //
    // BUGBUG: CleanMetaPath() disabled currently
    //

    if (m_strWamPath[0] != SZ_MBN_SEP_CHAR)
    {
        m_strWamPath = SZ_MBN_SEP_CHAR + m_strWamPath;
    }

    do
    {
        m_hrApp = CWamInterface::QueryResult();

        if (FAILED(m_hrApp))
        {
            break;
        }

        m_hrApp = RefreshAppState();

        if (HRESULT_CODE(m_hrApp) == ERROR_PATH_NOT_FOUND)
        {
            //
            // "Path Not Found" errors are acceptable, since
            // the application may not yet exist.
            //
            m_hrApp = S_OK;
        }
    }
    while(FALSE);
}



/* virtual */
BOOL 
CIISApplication::Succeeded() const
/*++

Routine Description:

    Determine if object was constructed successfully

Arguments:

    None

Return Value:

    TRUE for success, FALSE for failure

--*/
{
    return CMetaInterface::Succeeded() 
        && CWamInterface::Succeeded()
        && SUCCEEDED(m_hrApp);
}



/* virtual */
HRESULT 
CIISApplication::QueryResult() const
/*++

Routine Description:

    Return the construction error for this object

Arguments:

    None

Return Value:

    HRESULT from construction errors

--*/
{
    //
    // Both interfaces must have constructed successfully
    //
    HRESULT hr = CMetaInterface::QueryResult();

    if (SUCCEEDED(hr))
    {
        hr = CWamInterface::QueryResult();

        if (SUCCEEDED(hr))
        {
            hr = m_hrApp;
        }
    }    

    return hr;
}



HRESULT 
CIISApplication::RefreshAppState()
/*++

Routine Description:

    Refresh the application state

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    ASSERT(!m_strWamPath.IsEmpty());

    HRESULT hr, hrKeys;

    hr = AppGetStatus(m_strWamPath, &m_dwAppState);

    if (FAILED(hr))
    {
        m_dwAppState = APPSTATUS_NOTDEFINED;
    }

    m_strAppRoot.Empty();
    hrKeys = QueryValue(MD_APP_ROOT, m_strAppRoot, NULL, m_strWamPath);

    m_dwProcessProtection = APP_INPROC;
    hrKeys = QueryValue(
        MD_APP_ISOLATED, 
        m_dwProcessProtection, 
        NULL, 
        m_strWamPath
        );

    hrKeys = QueryValue(
        MD_APP_APPPOOL_ID,
        m_strAppPoolId,
        NULL,
        m_strWamPath
        );

    m_strFriendlyName.Empty();
    hrKeys = QueryValue(
        MD_APP_FRIENDLY_NAME, 
        m_strFriendlyName, 
        NULL, 
        m_strWamPath
        );

    return hr;
}



HRESULT 
CIISApplication::Create(
    IN LPCTSTR lpszName,        OPTIONAL
    IN DWORD dwAppProtection
    )
/*++

Routine Description:

    Create the application

Arguments:

    LPCTSTR lpszName      : Application name
    DWORD dwAppProtection : APP_INPROC     to create in-proc app
                            APP_OUTOFPROC  to create out-of-proc app
                            APP_POOLEDPROC to create a pooled-proc app

Return Value:

    HRESULT

--*/
{
    ASSERT(!m_strWamPath.IsEmpty());
    HRESULT hr = AppCreate(m_strWamPath, dwAppProtection);

    if (SUCCEEDED(hr))
    {
        //
        // Write the friendly app name, which we maintain
        // ourselves.  Empty it first, because we might
        // have picked up a name from inheritance.
        //
        m_strFriendlyName.Empty(); 
        hr = WriteFriendlyName(lpszName);

        RefreshAppState();
    }

    return hr;
}

HRESULT
CIISApplication::CreatePooled(
	LPCTSTR name, 
	DWORD mode,
	LPCTSTR pool_id, 
	BOOL fCreatePool)
{
    ASSERT(!m_strWamPath.IsEmpty());
	ASSERT(NULL != pool_id);
	HRESULT hr = CreateApplication(m_strWamPath, mode, pool_id, fCreatePool);
	if (SUCCEEDED(hr))
	{
        m_strFriendlyName.Empty(); 
        hr = WriteFriendlyName(name);
        RefreshAppState();
	}
	return hr;
}

HRESULT 
CIISApplication::WriteFriendlyName(
    IN LPCTSTR lpszName
    )
/*++

Routine Description:

    Write the friendly name.  This will not write anything
    if the name is the same as it was

Arguments:

    LPCTSTR lpszName        : New friendly name

Return Value:

    HRESULT

--*/
{
    HRESULT hr = S_OK;    

    if (m_strFriendlyName.CompareNoCase(lpszName) != 0)
    {
        hr = Open(METADATA_PERMISSION_WRITE, m_strWamPath);

        if (SUCCEEDED(hr))
        {
            ASSERT_PTR(lpszName);

            CString str(lpszName);    
            hr = SetValue(MD_APP_FRIENDLY_NAME, str);
            Close();

            if (SUCCEEDED(hr))
            {
                m_strFriendlyName = lpszName;
            }
        }
    }

    return hr;
}

HRESULT 
CIISApplication::WritePoolId(LPCTSTR id)
{
    HRESULT hr = S_OK;    

    if (m_strAppPoolId.CompareNoCase(id) != 0)
    {
        hr = Open(METADATA_PERMISSION_WRITE, m_strWamPath);

        if (SUCCEEDED(hr))
        {
            ASSERT_PTR(id);

            CString str(id);    
            hr = SetValue(MD_APP_APPPOOL_ID, str);
            Close();

            if (SUCCEEDED(hr))
            {
                m_strAppPoolId = id;
            }
        }
    }
    return hr;
}

/////////////////////////////////////////////////////////
// CIISAppPool class

CIISAppPool::CIISAppPool(
    IN CComAuthInfo * pAuthInfo   OPTIONAL,
    IN LPCTSTR lpszMetapath
    )
/*++

Routine Description:

    Construct IIS application pool.        

Arguments:

    CComAuthInfo * pAuthInfo : Authentication info.  NULL indicates the
                               local computer.
    LPCTSTR lpszMetapath     : Metabase path

Return Value:

    N/A

--*/
    : CWamInterface(pAuthInfo),
      CMetaKey(pAuthInfo),
      m_dwPoolState(0),
      m_strFriendlyName(),
      m_strWamPath(lpszMetapath)
{
    if (m_strWamPath[0] != SZ_MBN_SEP_CHAR)
    {
        m_strWamPath = SZ_MBN_SEP_CHAR + m_strWamPath;
    }

    do
    {
        if (FAILED(m_hrPool = CWamInterface::QueryResult()))
        {
            break;
        }
        if (MD_ERROR_DATA_NOT_FOUND == (m_hrPool = RefreshState())
            || HRESULT_CODE(m_hrPool) == ERROR_PATH_NOT_FOUND)
        {
            //
            // "Path Not Found" errors are acceptable, since
            // the pool may not yet exist.
            //
            m_hrPool = S_OK;
        }
    }
    while(FALSE);
}

HRESULT 
CIISAppPool::RefreshState()
{
    ASSERT(!m_strWamPath.IsEmpty());

    HRESULT hr;

    m_strFriendlyName.Empty();
    hr = QueryValue(
        MD_APPPOOL_FRIENDLY_NAME, 
        m_strFriendlyName, 
        NULL, 
        m_strWamPath
        );

    return hr;
}

/* virtual */
HRESULT 
CIISAppPool::QueryResult() const
/*++

Routine Description:

    Return the construction error for this object

Arguments:

    None

Return Value:

    HRESULT from construction errors

--*/
{
    //
    // Both interfaces must have constructed successfully
    //
    HRESULT hr = CMetaInterface::QueryResult();

    if (SUCCEEDED(hr))
    {
        hr = CWamInterface::QueryResult();

        if (SUCCEEDED(hr))
        {
            hr = m_hrPool;
        }
    }    

    return hr;
}

/* virtual */
BOOL 
CIISAppPool::Succeeded() const
/*++

Routine Description:

    Determine if object was constructed successfully

Arguments:

    None

Return Value:

    TRUE for success, FALSE for failure

--*/
{
    return CMetaInterface::Succeeded() 
        && CWamInterface::Succeeded()
        && SUCCEEDED(m_hrPool);
}

HRESULT
CIISAppPool::EnumerateApplications(CStringListEx& apps)
{
    CString pool;
    BSTR bstr = NULL;

    CMetabasePath::GetLastNodeName(m_strWamPath, pool);
    CError err = CWamInterface::EnumerateApplicationsInPool(
        pool, &bstr);
    if (err.Succeeded())
    {
        ConvertDoubleNullListToStringList(bstr, apps);
    }
#ifdef _DEBUG
    err.MessageBoxOnFailure();
#endif
    SysFreeString(bstr);
    return err;
}

HRESULT
CIISAppPool::Create(LPCTSTR name)
{
    CString id;
    if (name != NULL)
    {
        id = name;
    }
    else
    {
        CMetabasePath::GetLastNodeName(m_strWamPath, id);
    }
    CError err = CWamInterface::CreateApplicationPool(id);

    return err;
}

HRESULT
CIISAppPool::Delete(LPCTSTR id)
{
    CError err = CWamInterface::DeleteApplicationPool(id);

    return err;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\common\ipa.h ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        ipa.h

   Abstract:

        IP Address value

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/

#ifndef _IPA_H
#define _IPA_H

//
// IP Address Conversion Macros
//
#ifdef MAKEIPADDRESS
#undef MAKEIPADDRESS
#endif // MAKEIPADDRESS

#define MAKEIPADDRESS(b1,b2,b3,b4) (((DWORD)(b1)<<24) +\
                                    ((DWORD)(b2)<<16) +\
                                    ((DWORD)(b3)<< 8) +\
                                    ((DWORD)(b4)))

#ifndef GETIP_FIRST

  #define GETIP_FIRST(x)             ((x>>24) & 0xff)
  #define GETIP_SECOND(x)            ((x>>16) & 0xff)
  #define GETIP_THIRD(x)             ((x>> 8) & 0xff)
  #define GETIP_FOURTH(x)            ((x)     & 0xff)

#endif // GETIP_FIRST

//
// Some predefined IP values
//
#define NULL_IP_ADDRESS     (DWORD)(0x00000000)
#define NULL_IP_MASK        (DWORD)(0xFFFFFFFF)
#define BAD_IP_ADDRESS      (DWORD)(0xFFFFFFFF)



class COMDLL CIPAddress : public CObjectPlus
/*++

Class Description:

    IP Address classes.  Winsock is required to be initialized for this
    to work.

Public Interface:

    CIPAddress                 : Various constructors

    operator =                 : Assignment operator
    operator ==                : Comparison operators
    operator const DWORD       : Cast operator
    operator LPCTSTR           : Cast operator
    operator CString           : Cast operator
    CompareItem                : Comparison function
    QueryIPAddress             : Get the ip address value
    QueryNetworkOrderIPAddress : Get the ip address value (network order)
    QueryHostOrderIPAddress    : Get the ip address value (host order)

    StringToLong               : Convert ip address string to 32 bit number
    LongToString               : Convert 32 bit value to ip address string

--*/
{
//
// Helper Functions
//
public:
    static DWORD StringToLong(
        IN LPCTSTR lpstr,
        IN int nLength
        );

    static DWORD StringToLong(
        IN const CString & str
        );

    static DWORD StringToLong(
        IN const CComBSTR & bstr
        );

    static LPCTSTR LongToString(
        IN  const DWORD dwIPAddress,
        OUT CString & str
        );

    static LPCTSTR LongToString(
        IN  const DWORD dwIPAddress,
        OUT CComBSTR & bstr
        );

    static LPTSTR LongToString(
        IN  const DWORD dwIPAddress,
        OUT LPTSTR lpStr,
        IN  int cbSize
        );

    static LPBYTE DWORDtoLPBYTE(
        IN  DWORD  dw,
        OUT LPBYTE lpBytes
        );

public:
    //
    // Constructors
    //
    CIPAddress();

    //
    // Construct from DWORD
    //
    CIPAddress(
        IN DWORD dwIPValue,
        IN BOOL  fNetworkByteOrder = FALSE
        );

    //
    // Construct from byte stream
    //
    CIPAddress(
        IN LPBYTE lpBytes,
        IN BOOL  fNetworkByteOrder = FALSE
        );

    //
    // Construct from octets
    //
    CIPAddress(
        IN BYTE b1,
        IN BYTE b2,
        IN BYTE b3,
        IN BYTE b4
        );

    //
    // Copy constructor
    //
    CIPAddress(
        IN const CIPAddress & ia
        );

    //
    // Construct from string
    //
    CIPAddress(
        IN LPCTSTR lpstr,
        IN int nLength
        );

    //
    // Construct from CString
    //
    CIPAddress(
        IN const CString & str
        );

//
// Access Functions
//
public:
    int CompareItem(
        IN const CIPAddress & ia
        ) const;

    //
    // Query IP address value as a dword
    //
    DWORD QueryIPAddress(
        IN BOOL fNetworkByteOrder = FALSE
        ) const;

    //
    // Get the ip address value as a byte stream
    //
    LPBYTE QueryIPAddress(
        OUT LPBYTE lpBytes,
        IN  BOOL fNetworkByteOrder = FALSE
        ) const;

    //
    // Get the ip address as a CString
    //
    LPCTSTR QueryIPAddress(
        OUT CString & strAddress
        ) const;

    //
    // Get the ip address as a CComBSTR
    //
    LPCTSTR QueryIPAddress(
        OUT CComBSTR & bstrAddress
        ) const;

    //
    // Get ip address in network byte order DWORD
    //
    DWORD QueryNetworkOrderIPAddress() const;

    //
    // Get the ip address in host byte order DWORD
    //
    DWORD QueryHostOrderIPAddress() const;

    //
    // Assignment operators
    //
    const CIPAddress & operator =(
        IN const DWORD dwIPAddress
        );

    const CIPAddress & operator =(
        IN LPCTSTR lpstr
        );

    const CIPAddress & operator =(
        IN const CString & str
        );

    const CIPAddress & operator =(
        IN const CIPAddress & ia
        );

    //
    // Comparison operators
    //
    BOOL operator ==(
        IN const CIPAddress & ia
        ) const;

    BOOL operator ==(
        IN DWORD dwIPAddress
        ) const;

    BOOL operator !=(
        IN const CIPAddress & ia
        ) const;

    BOOL operator !=(
        IN DWORD dwIPAddress
        ) const;

    //
    // Conversion operators
    //
    operator const DWORD() const { return m_dwIPAddress; }
    operator LPCTSTR() const;
    operator CString() const;

    //
    // Value Verification Helpers
    //
    void SetZeroValue();
    BOOL IsZeroValue() const;
    BOOL IsBadValue() const;

private:
    DWORD m_dwIPAddress;
};



//
// Inline Expansion
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

inline /* static */ DWORD CIPAddress::StringToLong(
    IN const CString & str
    )
{
    return CIPAddress::StringToLong(str, str.GetLength());
}

inline /* static */ DWORD CIPAddress::StringToLong(
    IN const CComBSTR & bstr
    )
{
    return CIPAddress::StringToLong(bstr, bstr.Length());
}

inline LPCTSTR CIPAddress::QueryIPAddress(
    OUT CString & strAddress
    ) const
{
    return LongToString(m_dwIPAddress, strAddress);
}

inline LPCTSTR CIPAddress::QueryIPAddress(
    OUT CComBSTR & bstrAddress
    ) const
{
    return LongToString(m_dwIPAddress, bstrAddress);
}
        
inline DWORD CIPAddress::QueryNetworkOrderIPAddress() const
{
    return QueryIPAddress(TRUE);
}

inline DWORD CIPAddress::QueryHostOrderIPAddress() const
{
    return QueryIPAddress(FALSE);
}

inline BOOL CIPAddress::operator ==(
    IN const CIPAddress & ia
    ) const
{
    return CompareItem(ia) == 0;
}

inline BOOL CIPAddress::operator ==(
    IN DWORD dwIPAddress
    ) const
{
    return m_dwIPAddress == dwIPAddress;
}

inline BOOL CIPAddress::operator !=(
    IN const CIPAddress & ia
    ) const
{
    return CompareItem(ia) != 0;
}

inline BOOL CIPAddress::operator !=(
    IN DWORD dwIPAddress
    ) const
{
    return m_dwIPAddress != dwIPAddress;
}

inline void CIPAddress::SetZeroValue() 
{
    m_dwIPAddress = NULL_IP_ADDRESS;
}

inline BOOL CIPAddress::IsZeroValue() const
{
    return m_dwIPAddress == NULL_IP_ADDRESS;
}

inline BOOL CIPAddress::IsBadValue() const
{
    return m_dwIPAddress == BAD_IP_ADDRESS;
}



//
// Helper function to build a list of known IP addresses,
// and add them to a combo box
//
DWORD 
COMDLL
PopulateComboWithKnownIpAddresses(
    IN  LPCTSTR lpszServer,
    IN  CComboBox & combo,
    IN  CIPAddress & iaIpAddress,
    OUT CObListPlus & oblIpAddresses,
    OUT int & nIpAddressSel
    );

//
// Helper function to get an ip address from a combo/edit/list
// control
//
BOOL 
COMDLL
FetchIpAddressFromCombo(
    IN  CComboBox & combo,
    IN  CObListPlus & oblIpAddresses,
    OUT CIPAddress & ia
    );

#endif // _IPA_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\common\mdkeys.h ===
/*++

   Copyright    (c)    1994-2000    Microsoft Corporation

   Module Name :
        mdkeys.h

   Abstract:
        Metabase key wrapper classes
        Wam admin interface wrapper class
        App admin interface wrapper class

   Author:
        Ronald Meijer (ronaldm)
        Sergei Antonov (sergeia)

   Project:
        Internet Services Manager

   Revision History:

--*/

#ifndef _MDKEYS_H_
#define _MDKEYS_H_



//
// Include Files
//
#include <iadmw.h>
#include <iwamreg.h>
#include <iiscnfgp.h>
#include <winsvc.h>
#include <iisrsta.h>

//
// Forward definitions
//
class CBlob;



//
// Use this instance number to denote the master
//
#define MASTER_INSTANCE       (0)
#define IS_MASTER_INSTANCE(i) (i == MASTER_INSTANCE)



//
// Metabase node constants, used for static initialization of const
// strings further down.  Defined here with #defines for easier 
// concatenation later.
//
#define SZ_MBN_MACHINE      _T("LM")
#define SZ_MBN_FILTERS      _T("Filters")
#define SZ_MBN_MIMEMAP      _T("MimeMap")
#define SZ_MBN_TEMPLATES    _T("Templates")
#define SZ_MBN_INFO         _T("Info")
#define SZ_MBN_ROOT         _T("Root")
#define SZ_MBN_COMPRESSION  _T("Compression")
#define SZ_MBN_PARAMETERS   _T("Parameters")
#define SZ_MBN_SEP_CHAR     _T('/')
#define SZ_MBN_SEP_STR      _T("/")
#define SZ_MBN_WEB          _T("W3SVC")
#define SZ_MBN_FTP          _T("MSFTPSVC")
#define SZ_MBN_APP_POOLS    _T("AppPools")

class CIISInterface;
class COMDLL CComAuthInfo
/*++

Class Description:

    Server/authentication information.  Contains optional 
    impersonation parameters. Typically used in the construction in 
    CIISInterface.

Public Interface:

    CComAuthInfo            : Constructor.  Impersonation optional
    operator=               : Assignment operators
    CreateServerInfoStruct  : Helper function for use in COM
    FreeServerInfoStruct    : As above.

Notes:

    Because there's an operator for a pointer to itself and because
    CIISInterface copies the information at construction time, a 
    CComAuthInfo can safely be constructed on the stack as a parameter
    to CIISInterface derived classes.

--*/
{
//
// Constructor/Destructor
//
public:
    //
    // Standard Constructor.  NULL for servername indicates
    // local computer.
    //
    CComAuthInfo(
        IN LPCOLESTR lpszServerName  = NULL,    
        IN LPCOLESTR lpszUserName    = NULL,
        IN LPCOLESTR lpszPassword    = NULL
        );

    //
    // Copy Constructors
    //
    CComAuthInfo(
        IN CComAuthInfo & auth
        );

    CComAuthInfo(
        IN CComAuthInfo * pAuthInfo OPTIONAL
        );

//
// Assignment operators
//
public:
    CComAuthInfo & operator =(CComAuthInfo & auth);
    CComAuthInfo & operator =(CComAuthInfo * pAuthInfo);
    CComAuthInfo & operator =(LPCTSTR lpszServerName);

//
// Access
//
public:
    COSERVERINFO * CreateServerInfoStruct() const;
    COSERVERINFO * CreateServerInfoStruct(DWORD dwAuthnLevel) const;
    void FreeServerInfoStruct(COSERVERINFO * pServerInfo) const;

    LPOLESTR QueryServerName() const { return m_bstrServerName; }
    LPOLESTR QueryUserName() const { return m_bstrUserName; }
    LPOLESTR QueryPassword() const { return m_bstrPassword; }
    BOOL     IsLocal() const { return m_fLocal; }
    BOOL     UsesImpersonation() const { return m_bstrUserName.Length() > 0; }
    void     SetImpersonation(LPCOLESTR lpszUser, LPCOLESTR lpszPassword);
    void     RemoveImpersonation();
    void     StorePassword(LPCOLESTR lpszPassword);

public:
    HRESULT  ApplyProxyBlanket(IUnknown * pInterface);
    
//
// Conversion Operators
//
public:
    operator LPOLESTR() { return QueryServerName(); }
    operator CComAuthInfo *() { return this; }

//
// Static Helpers
//
public:
    //
    // Given domain\username, split into user name and domain
    //
    static BOOL SplitUserNameAndDomain(
        IN OUT CString & strUserName,
        IN CString & strDomainName
        );

    //
    // Verify username and password are correct
    //
    static DWORD VerifyUserPassword(
        IN LPCTSTR lpstrUserName,
        IN LPCTSTR lpstrPassword
        );

protected:
    //
    // Store the computer name (NULL for local computer)
    //
    void SetComputerName(
        IN LPCOLESTR lpszServerName   OPTIONAL
        );

private:
    CComBSTR    m_bstrServerName;
    CComBSTR    m_bstrUserName;
    CComBSTR    m_bstrPassword;
    BOOL        m_fLocal;
};



class COMDLL CMetabasePath
/*++

Class Description:

    Metabase path class.  This is a helper class to build complete
    metabase paths out of various components.

    Example: CMetaKey(CComAuthInfo("ronaldm3"), CMetabasePath(SZ_WEBSVC, dwInstance, _T("root")));

--*/
{
    //
    // Metabase components in order
    //
    enum
    {
        iBlank,                    // Sep 0
        iMachine,                  // LM
        iService,                  // e.g. lm/w3svc
        iInstance,                 // e.g. lm/w3svc/1
        iRootDirectory,            // e.g. lm/w3svc/1/root
        iSubDirectory,             // e.g. lm/w3vsc/1/root/foobar
    };

//
// Metabase helper functions.
//
public:
    //
    // Clean metabase path
    //
    static LPCTSTR CleanMetaPath(
        IN OUT CString & strMetaRoot
        );

    //
    // Find out the instance number from the given metabase path
    //
    static DWORD GetInstanceNumber(LPCTSTR lpszMDPath);

    //
    // Get the last nodename in the given metabase path
    //
    static LPCTSTR GetLastNodeName(
        IN  LPCTSTR lpszMDPath,
        OUT CString & strNodeName
        );

    //
    // Truncate the path at a given sub path
    //
    static LPCTSTR TruncatePath(
        IN  int     nLevel,          
        IN  LPCTSTR lpszMDPath,
        OUT CString & strNewPath,
        OUT CString * pstrRemainder = NULL
        );

    static LPCTSTR GetMachinePath(
        IN  LPCTSTR lpszMDPath,
        OUT CString & strNewPath,
        OUT CString * pstrRemainder = NULL
        );

    static LPCTSTR GetServicePath(
        IN  LPCTSTR lpszMDPath,
        OUT CString & strNewPath,
        OUT CString * pstrRemainder = NULL
        );

    static LPCTSTR GetInstancePath(
        IN  LPCTSTR lpszMDPath,
        OUT CString & strNewPath,
        OUT CString * pstrRemainder = NULL
        );

    static LPCTSTR GetRootPath(
        IN  LPCTSTR lpszMDPath,
        OUT CString & strNewPath,
        OUT CString * pstrRemainder = NULL
        );

    //
    // Determine the path to the info node that's relevant
    // to this metabase path.
    //
    static LPCTSTR GetServiceInfoPath(
        IN  LPCTSTR lpszMDPath,
        OUT CString & strInfoPath,   
        IN  LPCTSTR lpszDefService  = SZ_MBN_WEB
        );

    //
    // Change path to parent node
    //
    static LPCTSTR ConvertToParentPath(
        OUT IN CString & strMetaPath
        );

    //
    // Determine if the path describes a home directory path
    //
    static BOOL IsHomeDirectoryPath(
        IN LPCTSTR lpszMDPath
        );

    //
    // Determine if the path describes the 'master' instance (site)
    //
    static BOOL IsMasterInstance(
        IN LPCTSTR lpszMDPath
        );

    //
    // Split the metapath at the instance border
    //
    static void SplitMetaPathAtInstance(
        IN  LPCTSTR lpszMDPath,
        OUT CString & strParent,
        OUT CString & strAlias
        );
 

//
// Constructor/Destructor
//
public:
    CMetabasePath(
        IN BOOL    fAddBasePath,
        IN LPCTSTR lpszMDPath,
        IN LPCTSTR lpszMDPath2 = NULL,
        IN LPCTSTR lpszMDPath3 = NULL,
        IN LPCTSTR lpszMDPath4 = NULL
        );

    //
    // Construct with path components
    //
    CMetabasePath(
        IN  LPCTSTR lpszSvc        = NULL,    
        IN  DWORD   dwInstance     = MASTER_INSTANCE,
        IN  LPCTSTR lpszParentPath = NULL,        
        IN  LPCTSTR lpszAlias      = NULL    
        );

//
// Access
//
public:
    BOOL    IsHomeDirectoryPath() const { return IsHomeDirectoryPath(m_strMetaPath); }
    LPCTSTR QueryMetaPath() const { return m_strMetaPath; }

//
// Conversion Operators
//
public:
    operator LPCTSTR() const { return QueryMetaPath(); }

//
// Helpers
//
protected:
    void BuildMetaPath(  
        IN  LPCTSTR lpszSvc,
        IN  LPCTSTR szInstance,
        IN  LPCTSTR lpszParentPath,
        IN  LPCTSTR lpszAlias           
        );

    void BuildMetaPath(  
        IN  LPCTSTR lpszSvc,
        IN  DWORD   dwInstance,
        IN  LPCTSTR lpszParentPath,
        IN  LPCTSTR lpszAlias           
        );

    void AppendPath(LPCTSTR lpszPath);
    void AppendPath(DWORD dwInstance);

protected:
    //
    // Metabase path components
    //
    static const LPCTSTR _cszMachine;     
    static const LPCTSTR _cszRoot;        
    static const LPCTSTR _cszSep;         
    static const TCHAR   _chSep;          

private:
    CString m_strMetaPath;
};



class COMDLL CIISInterface
/*++

Class Description:

    Base interface class for IIS interfaces.  Most client COM-wrappers
    should derive from this class so that they can easily pick up
    share authentication and proxy blanket information methods.

Virtual Interface:

    Succeeded           : Return TRUE if item constructed successfully
    QueryResult         : Return construction error code

Public Interface:

    operator BOOL       : Cast to TRUE/FALSE depending on success
    operator HRESULT    : Cast to the HRESULT status

    QueryServerName     : Get the server name
    IsLocal             : Determine if the interface is on the local machine

--*/
{
//
// Constructor/Destructor
//
public:
    CIISInterface(
        IN CComAuthInfo * pAuthInfo,
        IN HRESULT hrInterface    = S_OK
        );

//
// Interface:
//
public:
    CComAuthInfo * QueryAuthInfo() { return &m_auth; }
    LPCOLESTR QueryServerName() const { return m_auth.QueryServerName(); }
    BOOL IsLocal() const { return m_auth.IsLocal(); }

//
// Virtual Interface:
//
public:
    virtual BOOL Succeeded() const { return SUCCEEDED(m_hrInterface); }
    virtual HRESULT QueryResult() const { return m_hrInterface; }
    virtual HRESULT ChangeProxyBlanket(
        IN LPCOLESTR lpszUserName, 
        IN LPCOLESTR lpszPassword
        );

//
// Conversion Operators
//
public:
    operator BOOL() const { return Succeeded(); }
    operator HRESULT() const { return m_hrInterface; }

protected:
    virtual HRESULT ApplyProxyBlanket() = 0;
    HRESULT Create(
        IN  int   cInterfaces,       
        IN  const IID rgIID[],      
        IN  const GUID rgCLSID[],    
        OUT int * pnInterface,          OPTIONAL
        OUT IUnknown ** ppInterface 
        );

protected:
    CComAuthInfo m_auth;
    HRESULT    m_hrInterface;
};



class COMDLL CMetaInterface : public CIISInterface
/*++

Class description:

    Metabase interface class.

Virtual Interface:

    Succeeded           : Return TRUE if item constructed successfully
    QueryResult         : Return construction error code

Public Interface:

    Regenerate          : Recreate the interface

--*/
{
public:
    //
    // Destructor destroys the interface
    //
    virtual ~CMetaInterface();

//
// Constructor/Destructor
//
protected:
    //
    // Fully defined constructor that creates the interface.
    // Use NULL to indicate the local computer name
    //
    CMetaInterface(
        IN CComAuthInfo * pServer
        );

    //
    // Construct from existing interface
    //
    CMetaInterface(
        IN CMetaInterface * pInterface
        );

public:
    //
    // Rebuild the interface
    //
    HRESULT Regenerate();

protected:
    virtual HRESULT ApplyProxyBlanket();

    //
    // Create a metadata object in this server. This function initializes the
    // metadata object with DCOM.
    //
    HRESULT Create();

    //
    // Make sure the interface has been created
    //
    BOOL HasInterface() const { return m_pInterface != NULL; }

//
// IADMW Interface -- all methods defines as inline at the end of this file.
//
protected:
    HRESULT OpenKey(
        IN  METADATA_HANDLE hkBase,
        IN  LPCTSTR lpszMDPath,
        IN  DWORD dwFlags,
        OUT METADATA_HANDLE * phMDNewHandle
        );

    HRESULT CloseKey(
        IN METADATA_HANDLE hKey
        );

    HRESULT SetLastChangeTime( 
        IN METADATA_HANDLE hMDHandle,
        IN LPCTSTR pszMDPath,
        IN FILETIME * pftMDLastChangeTime,
        IN BOOL bLocalTime
        );
        
    HRESULT GetLastChangeTime( 
        IN  METADATA_HANDLE hMDHandle,
        IN  LPCTSTR lpszMDPath,
        OUT FILETIME * pftMDLastChangeTime,
        IN  BOOL bLocalTime
        );

    HRESULT AddKey( 
        IN METADATA_HANDLE hKey,
        IN LPCTSTR lpszMDPath
        );

    HRESULT DeleteKey(
        IN METADATA_HANDLE hKey,
        IN LPCTSTR lpszMDPath
        );

    HRESULT DeleteChildKeys(
        IN METADATA_HANDLE hKey,
        IN LPCTSTR lpszMDPath
        );

    HRESULT EnumKeys(
        IN  METADATA_HANDLE hKey,
        IN  LPCTSTR lpszMDPath,
        OUT LPTSTR lpszMDName,
        IN  DWORD dwIndex
        );

    HRESULT CopyKey(
        IN METADATA_HANDLE hSourceKey,
        IN LPCTSTR lpszMDSourcePath,
        IN METADATA_HANDLE hDestKey,
        IN LPCTSTR lpszMDDestPath,
        IN BOOL fOverwrite,
        IN BOOL fCopy
        );

    HRESULT RenameKey(
        IN METADATA_HANDLE hKey,
        IN LPCTSTR lpszMDPath,
        IN LPCTSTR lpszNewName
        );

    HRESULT GetData(
        IN  METADATA_HANDLE hKey,
        IN  LPCTSTR lpszMDPath,
        OUT METADATA_RECORD * pmdRecord,
        OUT DWORD * pdwRequiredDataLen
        );

    HRESULT SetData(
        IN METADATA_HANDLE hKey,
        IN LPCTSTR lpszMDPath,
        IN METADATA_RECORD * pmdRecord
        );

    HRESULT DeleteData(
        IN METADATA_HANDLE hKey,
        IN LPCTSTR lpszMDPath,
        IN DWORD dwMDIdentifier,
        IN DWORD dwMDDataType
        );

    HRESULT EnumData(
        IN  METADATA_HANDLE hKey,
        IN  LPCTSTR lpszMDPath,
        OUT METADATA_RECORD * pmdRecord,
        IN  DWORD dwIndex,
        OUT DWORD * pdwRequiredDataLen
        );

    HRESULT GetAllData(
        IN  METADATA_HANDLE hKey,
        IN  LPCTSTR lpszMDPath,
        IN  DWORD dwMDAttributes,
        IN  DWORD dwMDUserType,
        IN  DWORD dwMDDataType,
        OUT DWORD * pdwMDNumDataEntries,
        OUT DWORD * pdwMDDataSetNumber,
        IN  DWORD dwMDBufferSize,
        OUT LPBYTE pbMDBuffer,
        OUT DWORD * pdwRequiredBufferSize
        );

    HRESULT DeleteAllData( 
        IN METADATA_HANDLE hKey,
        IN LPCTSTR lpszMDPath,
        IN DWORD dwMDUserType,
        IN DWORD dwMDDataType
        );

    HRESULT CopyData( 
        IN METADATA_HANDLE hMDSourceKey,
        IN LPCTSTR lpszMDSourcePath,
        IN METADATA_HANDLE hMDDestKey,
        IN LPCTSTR lpszMDDestPath,
        IN DWORD dwMDAttributes,
        IN DWORD dwMDUserType,
        IN DWORD dwMDDataType,
        IN BOOL fCopy
        );

    HRESULT GetDataPaths( 
        IN  METADATA_HANDLE hKey,
        IN  LPCTSTR lpszMDPath,
        IN  DWORD dwMDIdentifier,
        IN  DWORD dwMDDataType,
        IN  DWORD dwMDBufferSize,
        OUT LPTSTR lpszBuffer,
        OUT DWORD * pdwMDRequiredBufferSize
        );

    HRESULT Backup( 
        IN LPCTSTR lpszBackupLocation,
        IN DWORD dwMDVersion,
        IN DWORD dwMDFlags
        );

    HRESULT BackupWithPassword(
        IN LPCTSTR lpszBackupLocation,
        IN DWORD dwMDVersion,
        IN DWORD dwMDFlags,
		IN LPCTSTR lpszPassword
		);

    HRESULT Restore(    
        IN LPCTSTR lpszBackupLocation,
        IN DWORD dwMDVersion,
        IN DWORD dwMDFlags
        );

    HRESULT RestoreWithPassword(
        IN LPCTSTR lpszBackupLocation,
        IN DWORD dwMDVersion,
        IN DWORD dwMDFlags,
		IN LPCTSTR lpszPassword
		);

    HRESULT EnumBackups(
        OUT LPTSTR lpszBackupLocation,
        OUT DWORD * pdwMDVersion,
        OUT FILETIME * pftMDBackupTime,
        IN  DWORD dwIndex
        );

    HRESULT DeleteBackup(
        IN LPCTSTR lpszBackupLocation,
        IN DWORD dwMDVersion
        );

protected:
    IMSAdminBase * m_pInterface; 

private:
    int  m_iTimeOutValue;         
};



class COMDLL CMetaKey : public CMetaInterface
/*++

Class Description:

    Metabase key wrapper class

Public Interface:

    CMetaKey                    : Constructor
    ~CMetaKey                   : Destructor

    Succeeded                   : TRUE if key opened successfully.
    QueryResult                 : Get the HRESULT status

    QueryValue                  : Various overloaded methods to get values
    SetValue                    : Various overloaded methods to set values
    DeleteValue                 : Delete a value
    Open                        : Open key
    ReOpen                      : Re key that was opened before
    Close                       : Close key
    ConvertToParentPath         : Change path to parent path

    operator METADATA_HANDLE    : Cast to a metadata handle
    operator LPCTSTR            : Cast to the metabase path
    operator BOOL               : Cast to TRUE if the key is open, FALSE if not

    GetHandle                   : Obtain metadata handle
    IsOpen                      : TRUE if a key is open
    QueryMetaPath               : Get the relative metabase path
    QueryFlags                  : Get the open permissions

--*/
{
//
// Constructor/Destructor
//
public:
    //
    // Null constructor that only creates the interface.
    // A key constructed this way may read from META_ROOT_HANDLE.
    // This is not true of other constructors.
    //
    CMetaKey(
        IN CComAuthInfo * pServer
        );

    //
    // As above, using an existing interface
    //
    CMetaKey(
        IN CMetaInterface * pInterface
        );

    //
    // Fully defined constructor that opens a key
    //
    CMetaKey(
        IN CComAuthInfo * pServer,
        IN LPCTSTR lpszMDPath,
        IN DWORD   dwFlags        = METADATA_PERMISSION_READ,
        IN METADATA_HANDLE hkBase = METADATA_MASTER_ROOT_HANDLE
        );

    //
    // As above, using an existing interface
    //
    CMetaKey(
        IN CMetaInterface * pInterface,
        IN LPCTSTR lpszMDPath,
        IN DWORD   dwFlags        = METADATA_PERMISSION_READ,
        IN METADATA_HANDLE hkBase = METADATA_MASTER_ROOT_HANDLE
        );

    //
    // Copy constructor, might or might not own the key
    //
    CMetaKey(
        IN BOOL  fOwnKey,
        IN CMetaKey * pKey
        );

    //
    // Destructor -- closes key.
    //
    virtual ~CMetaKey();

//
// Interface
//
public:
    //
    // Fetch a DWORD
    //
    HRESULT QueryValue(
        IN  DWORD dwID, 
        OUT DWORD & dwValue,
        IN  BOOL * pfInheritanceOverride = NULL,
        IN  LPCTSTR lpszMDPath           = NULL,
        OUT DWORD * pdwAttributes        = NULL
        );

    //
    // Fetch a boolean
    //
    HRESULT QueryValue(
        IN  DWORD dwID, 
        OUT BOOL & fValue,
        IN  BOOL * pfInheritanceOverride = NULL,
        IN  LPCTSTR lpszMDPath           = NULL,
        OUT DWORD * pdwAttributes        = NULL
        );

    //
    // Fetch a string
    //
    HRESULT QueryValue(
        IN  DWORD dwID, 
        OUT CString & strValue, 
        IN  BOOL * pfInheritanceOverride = NULL,
        IN  LPCTSTR lpszMDPath           = NULL,
        OUT DWORD * pdwAttributes        = NULL
        );

    //
    // Fetch a BSTR
    //
    HRESULT QueryValue(
        IN  DWORD dwID, 
        OUT CComBSTR & strValue, 
        IN  BOOL * pfInheritanceOverride = NULL,
        IN  LPCTSTR lpszMDPath           = NULL,
        OUT DWORD * pdwAttributes        = NULL
        );

    //
    // Fetch a string list
    //
    HRESULT QueryValue(
        IN  DWORD dwID, 
        OUT CStringListEx & strlValue, 
        IN  BOOL * pfInheritanceOverride = NULL,
        IN  LPCTSTR lpszMDPath           = NULL,
        OUT DWORD * pdwAttributes        = NULL
        );

    //
    // Fetch binary blob
    //
    HRESULT QueryValue(
        IN  DWORD dwID, 
        OUT CBlob & blValue, 
        IN  BOOL * pfInheritanceOverride = NULL,
        IN  LPCTSTR lpszMDPath           = NULL,
        OUT DWORD * pdwAttributes        = NULL
        );

    //
    // Store a DWORD
    //
    HRESULT SetValue(
        IN DWORD dwID,
        IN DWORD dwValue,
        IN BOOL * pfInheritanceOverride = NULL,
        IN LPCTSTR lpszMDPath           = NULL
        );

    //
    // Store a BOOL
    //
    HRESULT SetValue(
        IN DWORD dwID,
        IN BOOL fValue,
        IN BOOL * pfInheritanceOverride = NULL,
        IN LPCTSTR lpszMDPath           = NULL
        );

    //
    // Store a string
    //
    HRESULT SetValue(
        IN DWORD dwID,
        IN CString & strValue,
        IN BOOL * pfInheritanceOverride = NULL,
        IN LPCTSTR lpszMDPath           = NULL
        );

    //
    // Store a BSTR
    //
    HRESULT SetValue(
        IN DWORD dwID,
        IN CComBSTR & strValue,
        IN BOOL * pfInheritanceOverride = NULL,
        IN LPCTSTR lpszMDPath           = NULL
        );


    //
    // Store a stringlist
    //
    HRESULT SetValue(
        IN DWORD dwID,
        IN CStringListEx & strlValue,
        IN BOOL * pfInheritanceOverride  = NULL,
        IN LPCTSTR lpszMDPath            = NULL
        );

    //
    // Store a binary blob
    //
    HRESULT SetValue(
        IN DWORD dwID,
        IN CBlob & blValue,
        IN BOOL * pfInheritanceOverride  = NULL,
        IN LPCTSTR lpszMDPath            = NULL
        );

    //
    // Delete Value:
    //
    HRESULT DeleteValue(
        IN DWORD   dwID,
        IN LPCTSTR lpszMDPath = NULL
        );

    //
    // Check for path existance
    //
    HRESULT DoesPathExist(
        IN LPCTSTR lpszMDPath
        );

    //
    // Create current path (which we attempted to open, and got
    // a path not found error on).
    //
    HRESULT CreatePathFromFailedOpen();

    //
    // Check for descendant overrides
    //
    HRESULT CheckDescendants(
        IN DWORD   dwID,
        IN CComAuthInfo * pServer,
        IN LPCTSTR lpszMDPath       = NULL
        );

    //
    // Open key
    //
    HRESULT Open(
        IN DWORD   dwFlags,
        IN LPCTSTR lpszMDPath       = NULL,
        IN METADATA_HANDLE hkBase   = METADATA_MASTER_ROOT_HANDLE 
        );

    //
    // Re-open previously opened key
    //
    HRESULT ReOpen(
        IN DWORD   dwFlags
        );

    //
    // As above using the same permissions as before
    //
    HRESULT ReOpen();

    //
    // Open the parent object
    // 
    HRESULT ConvertToParentPath(
        IN  BOOL fImmediate
        );

    //
    // Close key, set it to NULL, but doesn't destroy the interface
    //
    HRESULT Close();

    //
    // Add key
    //
    HRESULT AddKey(
        IN LPCTSTR lpszMDPath
        );

    //
    // Delete key off currently open key
    //
    HRESULT DeleteKey(
        IN LPCTSTR lpszMDPath
        );

    //
    // Rename key off currently open key
    //
    HRESULT RenameKey(
        IN LPCTSTR lpszMDPath,
        IN LPCTSTR lpszNewName
        );

    //
    // Get list of descendant nodes that override
    // a specific value
    //
    HRESULT GetDataPaths( 
        OUT CStringListEx & strlNodes,
        IN  DWORD dwMDIdentifier,
        IN  DWORD dwMDDataType,
        IN  LPCTSTR lpszMDPath = NULL
        );


//
// Access
//
public:
    METADATA_HANDLE GetHandle() const { return m_hKey; }
    METADATA_HANDLE GetBase() const   { return m_hBase; }
    LPCTSTR QueryMetaPath() const     { return m_strMetaPath; }
    DWORD QueryFlags() const          { return m_dwFlags; }
    BOOL IsOpen() const               { return m_hKey != NULL; }
    BOOL IsHomeDirectoryPath() const ;

//
// Conversion operators
//
public:
    operator METADATA_HANDLE() const  { return GetHandle(); }
    operator LPCTSTR() const          { return QueryMetaPath(); }
    operator BOOL() const             { return IsOpen(); }

//
// Virtual Interface:
//
public:
    virtual BOOL Succeeded() const;
    virtual HRESULT QueryResult() const;

//
// Protected members
//
protected:
    //
    // Get data
    //
    HRESULT GetPropertyValue(
        IN  DWORD dwID,
        OUT IN DWORD & dwSize,
        OUT IN void *& pvData,
        OUT IN DWORD * pdwDataType           = NULL,
        IN  BOOL * pfInheritanceOverride     = NULL,
        IN  LPCTSTR lpszMDPath               = NULL,
        OUT DWORD * pdwAttributes            = NULL
        );

    //
    // Store data
    //
    HRESULT SetPropertyValue(
        IN DWORD dwID,
        IN DWORD dwSize,
        IN void * pvData,
        IN BOOL * pfInheritanceOverride = NULL,
        IN LPCTSTR lpszMDPath           = NULL
        );

    //
    // Get All Data off the open key
    //
    HRESULT GetAllData(
        IN  DWORD dwMDAttributes,
        IN  DWORD dwMDUserType,
        IN  DWORD dwMDDataType,
        OUT DWORD * pdwMDNumEntries,
        OUT DWORD * pdwMDDataLen,
        OUT PBYTE * ppbMDData,
        IN  LPCTSTR lpszMDPath  = NULL
        );

//
// Property Table Methods
//
protected:
    //
    // Metabase table entry definition
    //
    typedef struct tagMDFIELDDEF
    {
        DWORD dwMDIdentifier;
        DWORD dwMDAttributes;
        DWORD dwMDUserType;
        DWORD dwMDDataType;
        UINT  uStringID;
    } MDFIELDDEF;

    static const MDFIELDDEF s_rgMetaTable[];

//
// CODEWORK: Ideally, these should be protected, but are used
//           by idlg.
//
public:
    static BOOL GetMDFieldDef(
        IN  DWORD dwID,
        OUT DWORD & dwMDIdentifier,
        OUT DWORD & dwMDAttributes,
        OUT DWORD & dwMDUserType,
        OUT DWORD & dwMDDataType
        );

    //
    // Map metabase ID value to table index
    //
    static int MapMDIDToTableIndex(
        IN DWORD dwID
        );

//
// Allow limited access to the table
//
public:
    static BOOL IsPropertyInheritable(
        IN DWORD dwID
        );

    static BOOL GetPropertyDescription(
        IN  DWORD dwID, 
        OUT CString & strName
        );

protected:
    BOOL    m_fAllowRootOperations;
    BOOL    m_fOwnKey;
    DWORD   m_cbInitialBufferSize;    
    DWORD   m_dwFlags;
    HRESULT m_hrKey;
    CString m_strMetaPath;
    METADATA_HANDLE m_hKey;
    METADATA_HANDLE m_hBase;
};



class COMDLL CWamInterface : public CIISInterface
/*++

Class description:

    WAM interface class

Virtual Interface:

    Succeeded           : Return TRUE if item constructed successfully
    QueryResult         : Return construction error code

Public Interface:

    SupportsPooledProc  : Check to see if pooled out of proc is supported.

--*/
{
//
// App Protection States:
//
public:
    enum
    {
        //
        // Note: order must match MD_APP_ISOLATED values
        //
        APP_INPROC,
        APP_OUTOFPROC,
        APP_POOLEDPROC,
    };

//
// Constructor/Destructor
//
public:
    //
    // Destructor destroys the interface
    //
    virtual ~CWamInterface();

protected:
    //
    // Fully defined constructor that creates the interface.
    // Use NULL to create the interface on the local computer
    //
    CWamInterface(
        IN CComAuthInfo * pServer
        );

    //
    // Construct from existing interface.  
    //
    CWamInterface(
        IN CWamInterface * pInterface
        );

//
// Access
//
public:
    BOOL SupportsPooledProc() const { return m_fSupportsPooledProc; }

protected:
    virtual HRESULT ApplyProxyBlanket();

    //
    // Create a wam object in this server. This function initializes the
    // object with DCOM.
    //
    HRESULT Create();

    //
    // Make sure the interface has been created
    //
    BOOL HasInterface() const { return m_pInterface != NULL; }

//
// IWAM Interface
//
protected:
    HRESULT AppCreate( 
        IN LPCTSTR szMDPath,
        IN DWORD dwAppProtection
        );
    
    HRESULT AppDelete( 
        IN LPCTSTR szMDPath,
        IN BOOL fRecursive
        );
    
    HRESULT AppUnLoad( 
        IN LPCTSTR szMDPath,
        IN BOOL fRecursive
        );
    
    HRESULT AppGetStatus( 
        IN  LPCTSTR szMDPath,
        OUT DWORD * pdwAppStatus
        );
    
    HRESULT AppDeleteRecoverable( 
        IN LPCTSTR szMDPath,
        IN BOOL fRecursive
        );
    
    HRESULT AppRecover( 
        IN LPCTSTR szMDPath,
        IN BOOL fRecursive
        );

//
// IIISApplicationAdmin interface
//
    HRESULT CreateApplication(
        LPCWSTR szMDPath,
        DWORD dwAppMode,
        LPCWSTR szAppPoolId,
        BOOL fCreatePool
        );
    
    HRESULT DeleteApplication(
        LPCWSTR szMDPath,
        BOOL fRecursive
        );
    
    HRESULT CreateApplicationPool(
        LPCWSTR szMDPath
        );
    
    HRESULT DeleteApplicationPool(
        LPCWSTR szMDPath
        );
    
    HRESULT RecycleApplicationPool(
        LPCWSTR szMDPath
        );
    
    HRESULT EnumerateApplicationsInPool(
        LPCWSTR szMDPath,
        BSTR   *pbstr
        );
    
    HRESULT GetProcessMode(
        DWORD * pdwMode
        );

protected:
    IWamAdmin * m_pInterface;

private:
    BOOL m_fSupportsPooledProc;
};

class COMDLL CMetaBack : public CMetaInterface, public CWamInterface
/*++

Class Description:

    Metabase backup/restore class

Virtual Interface:

    Succeeded           : Return TRUE if item constructed successfully
    QueryResult         : Return construction error code

Public Interface:

    Reset               : Enum first existing backup
    Next                : Enum next existing backup
    Backup              : Create new backup
    Delete              : Delete existing backup
    Restore             : Restore from existing backup

--*/
{
public:
    //
    // Construct and create the interfaces.  Use NULL to create
    // on the local computer.
    //
    CMetaBack(
        IN CComAuthInfo * pServer
        );

//
// Virtual Interface
//
public:
    virtual BOOL Succeeded() const;
    virtual HRESULT QueryResult() const;

//
// Interface
//
public:
    //
    // Reset counter
    //
    void Reset() { m_dwIndex = 0L; }

    HRESULT Next(
        OUT DWORD * pdwVersion,
        OUT LPTSTR lpszLocation,
        OUT FILETIME * pftBackupTime
        );

    HRESULT Backup(
        IN LPCTSTR lpszLocation
        );

    HRESULT BackupWithPassword(
        IN LPCTSTR lpszLocation,
		IN LPCTSTR lpszPassword
		);

    HRESULT Delete(
        IN LPCTSTR lpszLocation,
        IN DWORD dwVersion
        );

    HRESULT Restore(
        IN LPCTSTR lpszLocation,
        IN DWORD dwVersion
        );

    HRESULT RestoreWithPassword(
        IN LPCTSTR lpszLocation,
        IN DWORD dwVersion,
		IN LPCTSTR lpszPassword
        );

protected:
    virtual HRESULT ApplyProxyBlanket();

protected:
    static const LPCTSTR s_szMasterAppRoot;

private:
    DWORD m_dwIndex;
};



class COMDLL CMetaEnumerator : public CMetaKey
/*++

Class Description:

    Metabase key enumerator

Public Interface:

    CMetaEnumerator     : Constructor
    
    Reset               : Reset the enumerator
    Next                : Get next key

--*/
{
public:
    //
    // Constructor creates a new interface and opens a key
    //
    CMetaEnumerator(
        IN CComAuthInfo * pServer,
        IN LPCTSTR lpszMDPath     = NULL,
        IN METADATA_HANDLE hkBase = METADATA_MASTER_ROOT_HANDLE
        );

    //
    // Constructor which uses an existing interface and opens
    // a new key
    //
    CMetaEnumerator(
        IN CMetaInterface * pInterface,
        IN LPCTSTR lpszMDPath     = NULL,
        IN METADATA_HANDLE hkBase = METADATA_MASTER_ROOT_HANDLE
        );

    //
    // Constructor which uses an open key
    //
    CMetaEnumerator(
        IN BOOL fOwnKey,
        IN CMetaKey * pKey
        );

//
// Interface:
//
public:
    //
    // Reset counter
    //
    void Reset() { m_dwIndex = 0L; }

    //
    // Get next key as string.
    //
    HRESULT Next(
        OUT CString & strKey,
        IN  LPCTSTR lpszMDPath = NULL
        );

    //
    // Get next key as a DWORD (numeric keys only)
    //
    HRESULT Next(
        OUT DWORD & dwKey,
        OUT CString & strKey,
        IN  LPCTSTR lpszMDPath = NULL
        );

private:
    DWORD m_dwIndex;
};



class COMDLL CIISApplication : public CWamInterface, public CMetaKey
/*++

Class Description:

    IIS Application class

Virtual Interface:

    Succeeded           : Return TRUE if item constructed successfully
    QueryResult         : Return construction error code

Public Interface:

    RefreshState        : Refresh application state
    QueryAppState       : Return current application state
    IsEnabledApplication: Return TRUE if appplication is enabled. 
    Create              : Create app
    Delete              : Delete app
    Unload              : Unload app
    DeleteRecoverable   : Delete w. recovery allowed
    Recover             : Recover
    WriteFriendlyName   : Write friendly name to metabase

--*/
{
//
// Constructor/Destructor
//
public:
    CIISApplication(
        IN CComAuthInfo * pServer,
        IN LPCTSTR lpszMetapath
        );

//
// Virtual Interface:
//
public:
    virtual BOOL Succeeded() const;
    virtual HRESULT QueryResult() const;

//
// Interface
//
public:
    DWORD   QueryAppState() const { return m_dwAppState; }
    LPCTSTR QueryWamPath() const { return m_strWamPath; }
    BOOL    IsEnabledApplication() const;
    HRESULT RefreshAppState();
    HRESULT Create(LPCTSTR lpszName, DWORD dwAppProtection);
	HRESULT CreatePooled(LPCTSTR lpszName, DWORD dwAppMode,
		LPCTSTR pool_id, BOOL fCreatePool = FALSE);
    HRESULT Delete(BOOL fRecursive = FALSE);
    HRESULT Unload(BOOL fRecursive = FALSE);
    HRESULT DeleteRecoverable(BOOL fRecursive = FALSE);
    HRESULT Recover(BOOL fRecursive = FALSE);
    HRESULT WriteFriendlyName(LPCTSTR lpszName);
    HRESULT WritePoolId(LPCTSTR id);

public:
    BOOL IsInproc() const { return m_dwProcessProtection == APP_INPROC; }
    BOOL IsOutOfProc() const { return m_dwProcessProtection == APP_OUTOFPROC; }
    BOOL IsPooledProc() const { return m_dwProcessProtection == APP_POOLEDPROC; }

public:
    DWORD   m_dwProcessProtection;
    CString m_strAppPoolId;
    CString m_strFriendlyName;
    CString m_strAppRoot;

protected:
    void CommonConstruct();

private:
    DWORD   m_dwAppState;
    CString m_strWamPath;
    HRESULT m_hrApp;
};

class COMDLL CIISAppPool : public CWamInterface, public CMetaKey
{
public:
    CIISAppPool(
        IN CComAuthInfo * pServer,
        IN LPCTSTR lpszMetapath = NULL
        );
//
// Virtual Interface:
//
public:
    virtual BOOL Succeeded() const;
    virtual HRESULT QueryResult() const;

//
// Interface
//
public:
    HRESULT RefreshState();
    DWORD QueryPoolState() const { return m_dwPoolState; }
    LPCTSTR QueryWamPath() const { return m_strWamPath; }
    HRESULT Create(LPCTSTR lpszName = NULL);
    HRESULT Delete(LPCTSTR id);
    HRESULT WriteFriendlyName(LPCTSTR lpszName);
    HRESULT EnumerateApplications(CStringListEx& list);

public:
    CString m_strAppPoolId;
    CString m_strFriendlyName;

private:
    DWORD m_dwPoolState;
    CString m_strWamPath;
    HRESULT m_hrPool;
};

class COMDLL CIISSvcControl : public CIISInterface
/*++

Class description:

    IIS Service control

Virtual Interface:

    Succeeded           : Return TRUE if item constructed successfully
    QueryResult         : Return construction error code

--*/
{
//
// Constructor/Destructor
//
public:
    //
    // Fully defined constructor that creates the interface.
    // Use NULL to create the interface on the local computer
    //
    CIISSvcControl(
        IN CComAuthInfo * pServer
        );

    //
    // Construct from existing interface.  
    //
    CIISSvcControl(
        IN CIISSvcControl * pInterface
        );

    //
    // Destructor destroys the interface
    //
    virtual ~CIISSvcControl();

protected:
    //
    // Create an object in this server. This function initializes the
    // object with DCOM.
    //
    HRESULT Create();

    //
    // Make sure the interface has been created
    //
    BOOL HasInterface() const { return m_pInterface != NULL; }

//
// Interface
//
public:
    //
    // Stop services
    //
    HRESULT Stop(
        IN DWORD dwTimeoutMsecs,
        IN BOOL fForce
        );

    //
    // Start services
    //
    HRESULT Start(
        IN DWORD dwTimeoutMsecs
        );

    //
    // Reboot
    //
    HRESULT Reboot(
        IN DWORD dwTimeouMsecs,
        IN BOOL fForceAppsClosed
        );

    //
    // Status
    //
    HRESULT Status(
        IN  DWORD dwBufferSize,
        OUT LPBYTE pbBuffer,
        OUT DWORD * MDRequiredBufferSize,
        OUT DWORD * pdwNumServices
        );

    //
    // Kill
    //
    HRESULT Kill();

protected:
    virtual HRESULT ApplyProxyBlanket();

protected:
    IIisServiceControl * m_pInterface; 
};


//
// Inline Expansion
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

inline void CComAuthInfo::StorePassword(LPCOLESTR lpszPassword)
{
    m_bstrPassword = lpszPassword;
}

inline /* virtual */ HRESULT CIISInterface::ChangeProxyBlanket(
    IN LPCOLESTR lpszUserName, 
    IN LPCOLESTR lpszPassword
    )
{
    m_auth.SetImpersonation(lpszUserName, lpszPassword);
    return ApplyProxyBlanket();
}

inline /*static */ LPCTSTR CMetabasePath::GetMachinePath(
    IN  LPCTSTR lpszMDPath,
    OUT CString & strNewPath,
    OUT CString * pstrRemainder
    )
{
    return TruncatePath(iMachine, lpszMDPath, strNewPath, pstrRemainder);
}

inline /* static */ LPCTSTR CMetabasePath::GetServicePath(
    IN  LPCTSTR lpszMDPath,
    OUT CString & strNewPath,
    OUT CString * pstrRemainder
    )
{
    return TruncatePath(iService, lpszMDPath, strNewPath, pstrRemainder);
}

inline /* static */ LPCTSTR CMetabasePath::GetInstancePath(
    IN  LPCTSTR lpszMDPath,
    OUT CString & strNewPath,
    OUT CString * pstrRemainder
    )
{
    return TruncatePath(iInstance, lpszMDPath, strNewPath, pstrRemainder);
}

inline /* static */ LPCTSTR CMetabasePath::GetRootPath(
    IN  LPCTSTR lpszMDPath,
    OUT CString & strNewPath,
    OUT CString * pstrRemainder
    )
{
    return TruncatePath(iRootDirectory, lpszMDPath, strNewPath, pstrRemainder);
}

inline HRESULT CMetaInterface::Create()
{
    return CIISInterface::Create(
        1,
        &IID_IMSAdminBase, 
        &CLSID_MSAdminBase, 
        NULL,
        (IUnknown **)&m_pInterface
        );
}

inline /* virtual */ HRESULT CMetaInterface::ApplyProxyBlanket()
{
    return m_auth.ApplyProxyBlanket(m_pInterface);
}

inline HRESULT CMetaInterface::OpenKey(
    IN  METADATA_HANDLE hkBase,
    IN  LPCTSTR lpszMDPath,
    IN  DWORD dwFlags,
    OUT METADATA_HANDLE * phMDNewHandle
    )
{
    ASSERT_PTR(m_pInterface);
    return m_pInterface->OpenKey(
        hkBase,
        lpszMDPath,
        dwFlags,
        m_iTimeOutValue,
        phMDNewHandle
        );
}

inline HRESULT CMetaInterface::CloseKey(
    IN METADATA_HANDLE hKey
    )
{
    ASSERT_PTR(m_pInterface);
    return m_pInterface->CloseKey(hKey);
}

inline HRESULT CMetaInterface::SetLastChangeTime( 
    IN METADATA_HANDLE hMDHandle,
    IN LPCTSTR pszMDPath,
    IN FILETIME * pftMDLastChangeTime,
    IN BOOL bLocalTime
    )
{
    ASSERT_PTR(m_pInterface);
    return m_pInterface->SetLastChangeTime(
        hMDHandle,
        pszMDPath,
        pftMDLastChangeTime,
        bLocalTime
        );
}
        
inline HRESULT CMetaInterface::GetLastChangeTime( 
    IN  METADATA_HANDLE hMDHandle,
    IN  LPCTSTR lpszMDPath,
    OUT FILETIME * pftMDLastChangeTime,
    IN  BOOL bLocalTime
    )
{
    ASSERT_PTR(m_pInterface);
    return m_pInterface->GetLastChangeTime(
        hMDHandle,
        lpszMDPath,
        pftMDLastChangeTime,
        bLocalTime
        );
}

inline HRESULT CMetaInterface::AddKey( 
    IN METADATA_HANDLE hKey,
    IN LPCTSTR lpszMDPath
    )
{
    ASSERT_PTR(m_pInterface);
    return m_pInterface->AddKey(hKey, lpszMDPath);
}

inline HRESULT CMetaInterface::DeleteKey(
    IN METADATA_HANDLE hKey,
    IN LPCTSTR lpszMDPath
    )
{
    ASSERT_PTR(m_pInterface);
    return m_pInterface->DeleteKey(hKey, lpszMDPath);
}

inline HRESULT CMetaInterface::DeleteChildKeys(
    IN METADATA_HANDLE hKey,
    IN LPCTSTR lpszMDPath
    )
{
    ASSERT_PTR(m_pInterface);
    return m_pInterface->DeleteChildKeys(hKey, lpszMDPath);
}

inline HRESULT CMetaInterface::EnumKeys(
    IN  METADATA_HANDLE hKey,
    IN  LPCTSTR lpszMDPath,
    OUT LPTSTR lpszMDName,
    IN  DWORD dwIndex
    )
{
    ASSERT_PTR(m_pInterface);
    return m_pInterface->EnumKeys(hKey, lpszMDPath, lpszMDName, dwIndex);
}        

inline HRESULT CMetaInterface::CopyKey(
    IN METADATA_HANDLE hSourceKey,
    IN LPCTSTR lpszMDSourcePath,
    IN METADATA_HANDLE hDestKey,
    IN LPCTSTR lpszMDDestPath,
    IN BOOL fOverwrite,
    IN BOOL fCopy
    )
{
    ASSERT_PTR(m_pInterface);
    return m_pInterface->CopyKey(
        hSourceKey,
        lpszMDSourcePath,
        hDestKey,
        lpszMDDestPath,
        fOverwrite,
        fCopy
        );        
}

inline HRESULT CMetaInterface::RenameKey(
    IN METADATA_HANDLE hKey,
    IN LPCTSTR lpszMDPath,
    IN LPCTSTR lpszNewName
    )
{   
    ASSERT_PTR(m_pInterface);     
    return m_pInterface->RenameKey(hKey, lpszMDPath, lpszNewName);
}

inline HRESULT CMetaInterface::GetData(
    IN  METADATA_HANDLE hKey,
    IN  LPCTSTR lpszMDPath,
    OUT METADATA_RECORD * pmdRecord,
    OUT DWORD * pdwRequiredDataLen
    )
{
    ASSERT_PTR(m_pInterface);
    return m_pInterface->GetData(
        hKey,
        lpszMDPath,
        pmdRecord,
        pdwRequiredDataLen
        );
}

inline HRESULT CMetaInterface::SetData(
    IN METADATA_HANDLE hKey,
    IN LPCTSTR lpszMDPath,
    IN METADATA_RECORD * pmdRecord
    )
{
    ASSERT_PTR(m_pInterface);
    return m_pInterface->SetData(
        hKey,
        lpszMDPath,
        pmdRecord
        );
}

inline HRESULT CMetaInterface::DeleteData(
    IN METADATA_HANDLE hKey,
    IN LPCTSTR lpszMDPath,
    IN DWORD dwMDIdentifier,
    IN DWORD dwMDDataType
    )
{
    ASSERT_PTR(m_pInterface);
    return m_pInterface->DeleteData(
        hKey,
        lpszMDPath,
        dwMDIdentifier,
        dwMDDataType
        );
}

inline HRESULT CMetaInterface::EnumData(
    IN  METADATA_HANDLE hKey,
    IN  LPCTSTR lpszMDPath,
    OUT METADATA_RECORD * pmdRecord,
    IN  DWORD dwIndex,
    OUT DWORD * pdwRequiredDataLen
    )
{
    ASSERT_PTR(m_pInterface);
    return m_pInterface->EnumData(
        hKey,
        lpszMDPath,
        pmdRecord,
        dwIndex,
        pdwRequiredDataLen
        );
}

inline HRESULT CMetaInterface::GetAllData(
    IN  METADATA_HANDLE hKey,
    IN  LPCTSTR lpszMDPath,
    IN  DWORD dwMDAttributes,
    IN  DWORD dwMDUserType,
    IN  DWORD dwMDDataType,
    OUT DWORD * pdwMDNumDataEntries,
    OUT DWORD * pdwMDDataSetNumber,
    IN  DWORD dwMDBufferSize,
    OUT LPBYTE pbMDBuffer,
    OUT DWORD * pdwRequiredBufferSize
    )
{
    ASSERT_PTR(m_pInterface);
    return m_pInterface->GetAllData(
        hKey,
        lpszMDPath,
        dwMDAttributes,
        dwMDUserType,
        dwMDDataType,
        pdwMDNumDataEntries,
        pdwMDDataSetNumber,
        dwMDBufferSize,
        pbMDBuffer,
        pdwRequiredBufferSize
        );
}    

inline HRESULT CMetaInterface::DeleteAllData( 
    IN METADATA_HANDLE hKey,
    IN LPCTSTR lpszMDPath,
    IN DWORD dwMDUserType,
    IN DWORD dwMDDataType
    )
{
    ASSERT_PTR(m_pInterface);
    return m_pInterface->DeleteAllData(
        hKey, 
        lpszMDPath, 
        dwMDUserType, 
        dwMDDataType
        );
}

inline HRESULT CMetaInterface::CopyData( 
    IN METADATA_HANDLE hMDSourceKey,
    IN LPCTSTR lpszMDSourcePath,
    IN METADATA_HANDLE hMDDestKey,
    IN LPCTSTR lpszMDDestPath,
    IN DWORD dwMDAttributes,
    IN DWORD dwMDUserType,
    IN DWORD dwMDDataType,
    IN BOOL fCopy
    )
{
    ASSERT_PTR(m_pInterface);
    return m_pInterface->CopyData(
        hMDSourceKey,
        lpszMDSourcePath,
        hMDDestKey,
        lpszMDDestPath,
        dwMDAttributes,
        dwMDUserType,
        dwMDDataType,
        fCopy
        );
}

inline HRESULT CMetaInterface::GetDataPaths( 
    IN  METADATA_HANDLE hKey,
    IN  LPCTSTR lpszMDPath,
    IN  DWORD dwMDIdentifier,
    IN  DWORD dwMDDataType,
    IN  DWORD dwMDBufferSize,
    OUT LPTSTR lpszBuffer,
    OUT DWORD * pdwMDRequiredBufferSize
    )
{
    ASSERT_PTR(m_pInterface);
    return m_pInterface->GetDataPaths(
        hKey,
        lpszMDPath,
        dwMDIdentifier,
        dwMDDataType,
        dwMDBufferSize,
        lpszBuffer,
        pdwMDRequiredBufferSize
        );
}

inline HRESULT CMetaInterface::Backup( 
    IN LPCTSTR lpszBackupLocation,
    IN DWORD dwMDVersion,
    IN DWORD dwMDFlags
    )
{
    ASSERT_PTR(m_pInterface);
    return m_pInterface->Backup(lpszBackupLocation, dwMDVersion, dwMDFlags);
}

inline HRESULT CMetaInterface::BackupWithPassword( 
    IN LPCTSTR lpszBackupLocation,
    IN DWORD dwMDVersion,
    IN DWORD dwMDFlags,
	IN LPCTSTR lpszPassword
    )
{
    ASSERT(m_pInterface != NULL);
	HRESULT hr = S_OK;
	IMSAdminBase2 * pInterface2 = NULL;
	if (SUCCEEDED(hr = m_pInterface->QueryInterface(IID_IMSAdminBase2, (void **)&pInterface2)))
	{
		hr = pInterface2->BackupWithPasswd(lpszBackupLocation, dwMDVersion, dwMDFlags, lpszPassword);
		pInterface2->Release();
	}
    return hr;
}

inline HRESULT CMetaInterface::Restore(    
    IN LPCTSTR lpszBackupLocation,
    IN DWORD dwMDVersion,
    IN DWORD dwMDFlags
    )
{
    ASSERT_PTR(m_pInterface);
    return m_pInterface->Restore(lpszBackupLocation, dwMDVersion, dwMDFlags);
}

inline HRESULT CMetaInterface::RestoreWithPassword(    
    IN LPCTSTR lpszBackupLocation,
    IN DWORD dwMDVersion,
    IN DWORD dwMDFlags,
	IN LPCTSTR lpszPassword
    )
{
    ASSERT(m_pInterface != NULL);
	HRESULT hr = S_OK;
	IMSAdminBase2 * pInterface2 = NULL;
	if (SUCCEEDED(hr = m_pInterface->QueryInterface(IID_IMSAdminBase2, (void **)&pInterface2)))
	{
		hr = pInterface2->RestoreWithPasswd(lpszBackupLocation, dwMDVersion, dwMDFlags, lpszPassword);
		pInterface2->Release();
	}
    return hr;
}

inline HRESULT CMetaInterface::EnumBackups(
    OUT LPTSTR lpszBackupLocation,
    OUT DWORD * pdwMDVersion,
    OUT FILETIME * pftMDBackupTime,
    IN  DWORD dwIndex
    )
{
    ASSERT_PTR(m_pInterface);
    return m_pInterface->EnumBackups(
        lpszBackupLocation,
        pdwMDVersion,
        pftMDBackupTime,
        dwIndex
        );    
}

inline HRESULT CMetaInterface::DeleteBackup(
    IN LPCTSTR lpszBackupLocation,
    IN DWORD dwMDVersion
    )
{
    ASSERT_PTR(m_pInterface);
    return m_pInterface->DeleteBackup(lpszBackupLocation, dwMDVersion);
}        

inline HRESULT CMetaKey::AddKey(
    IN LPCTSTR lpszMDPath
    )
{
    return CMetaInterface::AddKey(m_hKey, lpszMDPath);    
}

inline HRESULT CMetaKey::DeleteKey(
    IN LPCTSTR lpszMDPath
    )
{
    return CMetaInterface::DeleteKey(m_hKey, lpszMDPath);    
}

inline HRESULT CMetaKey::RenameKey(
    IN LPCTSTR lpszMDPath,
    IN LPCTSTR lpszNewName
    )
{
    return CMetaInterface::RenameKey(m_hKey, lpszMDPath, lpszNewName);    
}

inline HRESULT CMetaKey::ReOpen()
{
    return Open(m_dwFlags, m_strMetaPath, m_hBase);
}

inline HRESULT CMetaKey::ReOpen(DWORD dwFlags)
{
    return Open(dwFlags, m_strMetaPath, m_hBase);
}

inline BOOL CMetaKey::IsHomeDirectoryPath() const
{ 
    return CMetabasePath::IsHomeDirectoryPath(m_strMetaPath); 
}

inline HRESULT CMetaKey::QueryValue(
    IN  DWORD dwID, 
    OUT BOOL & fValue,
    IN  BOOL * pfInheritanceOverride,
    IN  LPCTSTR lpszMDPath,
    OUT DWORD * pdwAttributes        
    )
{
    ASSERT(sizeof(DWORD) == sizeof(BOOL));
    return CMetaKey::QueryValue(
        dwID, 
        (DWORD &)fValue, 
        pfInheritanceOverride, 
        lpszMDPath,
        pdwAttributes
        );
}

inline HRESULT CMetaKey::SetValue(
    IN DWORD dwID,
    IN DWORD dwValue,
    IN BOOL * pfInheritanceOverride,    OPTIONAL
    IN LPCTSTR lpszMDPath               OPTIONAL
    )
{
    return SetPropertyValue(
        dwID, 
        sizeof(dwValue), 
        &dwValue, 
        pfInheritanceOverride,
        lpszMDPath
        );
}

inline HRESULT CMetaKey::SetValue(
    IN DWORD dwID,
    IN BOOL fValue,
    IN BOOL * pfInheritanceOverride,
    IN LPCTSTR lpszMDPath
    )
{
    ASSERT(sizeof(DWORD) == sizeof(BOOL));
    return CMetaKey::SetValue(
        dwID,
        (DWORD)fValue,
        pfInheritanceOverride,
        lpszMDPath
        );
}

inline HRESULT CMetaKey::SetValue(
    IN DWORD dwID,
    IN CString & strValue,
    IN BOOL * pfInheritanceOverride,    OPTIONAL
    IN LPCTSTR lpszMDPath               OPTIONAL
    )
{
    return SetPropertyValue(
        dwID,
        (strValue.GetLength() + 1) * sizeof(TCHAR),
        (void *)(LPCTSTR)strValue,
        pfInheritanceOverride,
        lpszMDPath
        );
}

inline HRESULT CWamInterface::AppDelete( 
    IN LPCTSTR szMDPath,
    IN BOOL fRecursive
    )
{
    ASSERT_PTR(m_pInterface);
    return m_pInterface->AppDelete(szMDPath, fRecursive);
}

inline HRESULT CWamInterface::AppUnLoad( 
    IN LPCTSTR szMDPath,
    IN BOOL fRecursive
    )
{
    ASSERT_PTR(m_pInterface);
    return m_pInterface->AppUnLoad(szMDPath, fRecursive);
}

inline HRESULT CWamInterface::AppGetStatus( 
    IN  LPCTSTR szMDPath,
    OUT DWORD * pdwAppStatus
    )
{
    ASSERT_PTR(m_pInterface);
    return m_pInterface->AppGetStatus(szMDPath, pdwAppStatus);
}

inline HRESULT CWamInterface::AppDeleteRecoverable( 
    IN LPCTSTR szMDPath,
    IN BOOL fRecursive
    )
{
    ASSERT_PTR(m_pInterface);
    return m_pInterface->AppDeleteRecoverable(szMDPath, fRecursive);
}

inline HRESULT CWamInterface::AppRecover( 
    IN LPCTSTR szMDPath,
    IN BOOL fRecursive
    )
{
    ASSERT_PTR(m_pInterface);
    return m_pInterface->AppRecover(szMDPath, fRecursive);
}

inline HRESULT CWamInterface::CreateApplication(
    LPCWSTR szMDPath,
    DWORD dwAppMode,
    LPCWSTR szAppPoolId,
    BOOL fCreatePool
    )
{
    CComQIPtr<IIISApplicationAdmin, &IID_IIISApplicationAdmin> pAppAdmin = m_pInterface;
    if (pAppAdmin != NULL)
    {
        return pAppAdmin->CreateApplication(
            szMDPath, dwAppMode, szAppPoolId, fCreatePool);
    }
    else
        return E_NOINTERFACE;
}
    
inline HRESULT CWamInterface::DeleteApplication(
    LPCWSTR szMDPath,
    BOOL fRecursive
    )
{
    CComQIPtr<IIISApplicationAdmin, &IID_IIISApplicationAdmin> pAppAdmin = m_pInterface;
    if (pAppAdmin != NULL)
    {
        return pAppAdmin->DeleteApplication(szMDPath, fRecursive);
    }
    else
        return E_NOINTERFACE;
}

inline HRESULT CWamInterface::CreateApplicationPool(
    LPCWSTR szMDPath
    )
{
    CComQIPtr<IIISApplicationAdmin, &IID_IIISApplicationAdmin> pAppAdmin = m_pInterface;
    if (pAppAdmin != NULL)
    {
        return pAppAdmin->CreateApplicationPool(szMDPath);
    }
    return E_NOINTERFACE;
}

inline HRESULT CWamInterface::DeleteApplicationPool(
    LPCWSTR szMDPath
    )
{
    CComQIPtr<IIISApplicationAdmin, &IID_IIISApplicationAdmin> pAppAdmin = m_pInterface;
    if (pAppAdmin != NULL)
    {
        return pAppAdmin->DeleteApplicationPool(szMDPath);
    }
    else
        return E_NOINTERFACE;
}

inline HRESULT CWamInterface::RecycleApplicationPool(
    LPCWSTR szMDPath
    )
{
    CComQIPtr<IIISApplicationAdmin, &IID_IIISApplicationAdmin> pAppAdmin = m_pInterface;
    if (pAppAdmin != NULL)
    {
        return pAppAdmin->RecycleApplicationPool(szMDPath);
    }
    else
        return E_NOINTERFACE;
}

inline HRESULT CWamInterface::EnumerateApplicationsInPool(
    LPCTSTR szMDPath,
    BSTR * pbstr)
{
    IIISApplicationAdmin * pAppAdmin = NULL;
    HRESULT hr = m_pInterface->QueryInterface(IID_IIISApplicationAdmin, (void **)&pAppAdmin);
    if (SUCCEEDED(hr))
    {
        hr = pAppAdmin->EnumerateApplicationsInPool(
                    szMDPath, pbstr);
        pAppAdmin->Release();
    }
    return hr;
}

inline HRESULT CWamInterface::GetProcessMode(
    DWORD * pdwMode
    )
{
    CComQIPtr<IIISApplicationAdmin, &IID_IIISApplicationAdmin> pAppAdmin = m_pInterface;
    if (pAppAdmin != NULL)
    {
        return pAppAdmin->GetProcessMode(pdwMode);
    }
    else
        return E_NOINTERFACE;
}

inline /* virtual */ HRESULT CWamInterface::ApplyProxyBlanket()
{
    return m_auth.ApplyProxyBlanket(m_pInterface);
}

////////////////////////////

inline /* virtual */ HRESULT CMetaBack::ApplyProxyBlanket()
{
    HRESULT hr = CMetaInterface::ApplyProxyBlanket();
    return SUCCEEDED(hr) ? CWamInterface::ApplyProxyBlanket() : hr;
}

inline HRESULT CMetaBack::Next(
    OUT DWORD * pdwVersion,
    OUT LPTSTR lpszLocation,
    OUT FILETIME * pftBackupTime
    )
{
    return EnumBackups(
        lpszLocation,
        pdwVersion,
        pftBackupTime,
        m_dwIndex++
        );
}

inline HRESULT CMetaBack::Backup(
    IN LPCTSTR lpszLocation
    )
{
    return CMetaInterface::Backup(
        lpszLocation, 
        MD_BACKUP_NEXT_VERSION, 
        MD_BACKUP_SAVE_FIRST
        );
}

inline HRESULT CMetaBack::Delete(
    IN LPCTSTR lpszLocation,
    IN DWORD dwVersion
    )
{
    return DeleteBackup(lpszLocation, dwVersion);
}

inline BOOL CIISApplication::IsEnabledApplication() const
{
    return m_dwAppState == APPSTATUS_STOPPED 
        || m_dwAppState == APPSTATUS_RUNNING;
}

inline HRESULT CIISApplication::Delete(
    IN BOOL fRecursive
    )
{
    ASSERT(!m_strWamPath.IsEmpty());
    return AppDelete(m_strWamPath, fRecursive);
}

inline HRESULT CIISApplication::Unload(
    IN BOOL fRecursive
    )
{
    ASSERT(!m_strWamPath.IsEmpty());
    return AppUnLoad(m_strWamPath, fRecursive);
}

inline HRESULT CIISApplication::DeleteRecoverable(
    IN BOOL fRecursive
    )
{
    ASSERT(!m_strWamPath.IsEmpty());
    return AppDeleteRecoverable(m_strWamPath, fRecursive);
}

inline HRESULT CIISApplication::Recover(
    IN BOOL fRecursive
    )
{
    ASSERT(!m_strWamPath.IsEmpty());
    return AppRecover(m_strWamPath, fRecursive);
}

inline HRESULT CIISSvcControl::Create()
{
    return CIISInterface::Create(
        1,
        &IID_IIisServiceControl, 
        &CLSID_IisServiceControl, 
        NULL, 
        (IUnknown **)&m_pInterface
        );
}

inline HRESULT CIISSvcControl::Stop(
    IN DWORD dwTimeoutMsecs,
    IN BOOL fForce
    )
{
    ASSERT_PTR(m_pInterface);
    return m_pInterface->Stop(dwTimeoutMsecs, (DWORD)fForce);
}

inline HRESULT CIISSvcControl::Start(
    IN DWORD dwTimeoutMsecs
    )
{
    ASSERT_PTR(m_pInterface);
    return m_pInterface->Start(dwTimeoutMsecs);
}

inline HRESULT CIISSvcControl::Reboot(
    IN DWORD dwTimeouMsecs,
    IN BOOL fForceAppsClosed
    )
{
    ASSERT_PTR(m_pInterface);
    return m_pInterface->Reboot(dwTimeouMsecs, (DWORD)fForceAppsClosed);
}

inline HRESULT CIISSvcControl::Status(
    IN  DWORD dwBufferSize,
    OUT LPBYTE pbBuffer,
    OUT DWORD * MDRequiredBufferSize,
    OUT DWORD * pdwNumServices
    )
{
    ASSERT_PTR(m_pInterface);
    return m_pInterface->Status(
        dwBufferSize, 
        pbBuffer,
        MDRequiredBufferSize,
        pdwNumServices
        );
}

inline HRESULT CIISSvcControl::Kill()
{
    ASSERT_PTR(m_pInterface);
    return m_pInterface->Kill();
}

inline /* virtual */ HRESULT CIISSvcControl::ApplyProxyBlanket()
{
    return m_auth.ApplyProxyBlanket(m_pInterface);
}

#endif // _MDKEYS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\common\objpick.cpp ===
// objpick.cpp: implementation of the CGetUser class and the 
//              CGetComputer class using the object picker
//
//////////////////////////////////////////////////////////////////////
#include "stdafx.h"

#include <iads.h>           

#include <objsel.h>
#include <adshlp.h>
#include <winsock2.h>
#include <comdef.h>
#include "common.h"

#include "objpick.h"
#include "accentry.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif


#define BREAK_ON_FAIL_HRESULT(hr)       \
    if (FAILED(hr)) { TRACE(_T("line %u err 0x%x\n"), __LINE__, hr); break; }

UINT g_cfDsObjectPicker; // = ::RegisterClipboardFormat(CFSTR_DSOP_DS_SELECTION_LIST);

HRESULT InitObjectPickerForGroups(IDsObjectPicker *pDsObjectPicker, 
                                  BOOL fMultiselect,
                                  LPCTSTR pszMachineName,
                                  BOOL bUsersOnly);
HRESULT InitObjectPickerForComputers(IDsObjectPicker *pDsObjectPicker);

DWORD ObjPickGetHostName(DWORD dwIpAddr, CString & strHostName);
DWORD ObjPickNameOrIpToHostname(CString & strNameOrIp, CString & strHostName);


CAccessEntryArray::~CAccessEntryArray()
{
    for (int i = 0; i < GetSize(); i++)
        delete GetAt(i);
}

//////////////////////////////////////////////////////////////////////
// CGetUsers Class
//////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////


void    
FormatName(LPCTSTR pszFullName, LPCTSTR pszDomainName, CString & strDisplay)
{
    strDisplay.Format(_T("%s\\%s"), pszDomainName, pszFullName);
}

CGetUsers::CGetUsers(LPCTSTR pszMachineName, BOOL fMultiselect)
    : m_MachineName(pszMachineName),
      m_fMultiselect(fMultiselect)
{
}

CGetUsers::~CGetUsers()
{

}

BOOL
CGetUsers::GetUsers(HWND hwndParent, BOOL bUsersOnly)
{
    HRESULT             hr = S_OK;
    IDsObjectPicker *   pDsObjectPicker = NULL;
    IDataObject *       pdo = NULL;
    BOOL                fSuccess = TRUE;

    hr = CoInitialize(NULL);
    if (FAILED(hr)) 
        return FALSE;

    do
    {
        //
        // Create an instance of the object picker.  The implementation in
        // objsel.dll is apartment model.
        //
        hr = CoCreateInstance(CLSID_DsObjectPicker,
                              NULL,
                              CLSCTX_INPROC_SERVER,
                              IID_IDsObjectPicker,
                              (void **) &pDsObjectPicker);
        BREAK_ON_FAIL_HRESULT(hr);

        hr = InitObjectPickerForGroups(pDsObjectPicker, m_fMultiselect, m_MachineName, bUsersOnly);
        BREAK_ON_FAIL_HRESULT(hr);

        //
        // Invoke the modal dialog.
        //
        hr = pDsObjectPicker->InvokeDialog(hwndParent, &pdo);
        BREAK_ON_FAIL_HRESULT(hr);

        //
        // If the user hit Cancel, hr == S_FALSE
        //
        if (hr == S_FALSE)
        {
            TRACE(_T("User canceled object picker dialog\n"));
            fSuccess = FALSE;
            break;
        }

        //
        // Process the user's selections
        //
        ASSERT(pdo);
        ProcessSelectedObjects(pdo);

        pdo->Release();
        pdo = NULL;

    } while (0);

    if (pDsObjectPicker)
    {
        pDsObjectPicker->Release();
    }
    
    CoUninitialize();

    if (FAILED(hr) || S_FALSE == hr)
        fSuccess = FALSE;

    return fSuccess;
}

void
CGetUsers::ProcessSelectedObjects(IDataObject *pdo)
{
    HRESULT hr = S_OK;

    STGMEDIUM stgmedium =
    {
        TYMED_HGLOBAL,
        NULL,
        NULL
    };

    if (g_cfDsObjectPicker == 0)
       g_cfDsObjectPicker = ::RegisterClipboardFormat(CFSTR_DSOP_DS_SELECTION_LIST);
    ASSERT(g_cfDsObjectPicker != 0);

    FORMATETC formatetc =
    {
        (CLIPFORMAT)g_cfDsObjectPicker,
        NULL,
        DVASPECT_CONTENT,
        -1,
        TYMED_HGLOBAL
    };

    BOOL fGotStgMedium = FALSE;

    do
    {
        hr = pdo->GetData(&formatetc, &stgmedium);
        BREAK_ON_FAIL_HRESULT(hr);

        fGotStgMedium = TRUE;

        PDS_SELECTION_LIST pDsSelList =
            (PDS_SELECTION_LIST) GlobalLock(stgmedium.hGlobal);

        if (!pDsSelList)
        {
            TRACE(_T("GlobalLock error %u\n"), GetLastError());
            break;
        }

        // create the path name thing
        IADsPathname * pIADsPathname;
        hr = CoCreateInstance(CLSID_Pathname, NULL, CLSCTX_INPROC_SERVER,
                             IID_IADsPathname, (PVOID *)&pIADsPathname);
        BREAK_ON_FAIL_HRESULT(hr);
        if (FAILED(hr = pIADsPathname->SetDisplayType(ADS_DISPLAY_VALUE_ONLY)))
        {
            pIADsPathname->Release();
            break;
        }
        for (UINT i = 0; i < pDsSelList->cItems; i++)
        {
            PSID psid = NULL;
            DS_SELECTION * pDsSel = &(pDsSelList->aDsSelection[i]);
            if (pDsSel->pvarFetchedAttributes != NULL)
            {
               hr = SafeArrayAccessData(V_ARRAY(pDsSel->pvarFetchedAttributes), &psid);
            }
            if (psid != NULL)
            {
                LPWSTR pwzADsPath = pDsSel->pwzADsPath;
                if (FAILED(hr = pIADsPathname->Set(pwzADsPath, ADS_SETTYPE_FULL)))
                    continue;
                long lnNumPathElements = 0;
                if (FAILED(hr = pIADsPathname->GetNumElements(&lnNumPathElements)))
                    continue;
                BSTR bstrUser = NULL, bstrDomain = NULL;
                if (FAILED(hr = pIADsPathname->GetElement(0, &bstrUser)))
                    continue;
                switch (lnNumPathElements)
                {
                    case 1:
                        hr = pIADsPathname->Retrieve(ADS_FORMAT_SERVER, &bstrDomain);
                        break;

                    case 2:  // nt4, nt5 domain
                    case 3:  // local domain
                        hr = pIADsPathname->GetElement(1, &bstrDomain);
                        break;

                    default:
                        ASSERT(FALSE);
                        hr = E_FAIL;
                }
                if (FAILED(hr))
                    continue;
                CString name;
                FormatName(bstrUser, bstrDomain, name);
                if (bstrDomain != NULL)
                    SysFreeString(bstrDomain);
                if (bstrUser != NULL)
                    SysFreeString(bstrUser);
                CAccessEntry * entry = 
                    new CAccessEntry(psid, name, pDsSel->pwzClass);
                Add(entry);
            }
        }
        pIADsPathname->Release();
        GlobalUnlock(stgmedium.hGlobal);

    } while (0);

    if (fGotStgMedium)
    {
        ReleaseStgMedium(&stgmedium);
    }
}


//////////////////////////////////////////////////////////////////////
// CGetComputer Class
//////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CGetComputer::CGetComputer()
{
}

CGetComputer::~CGetComputer()
{
}

BOOL
CGetComputer::GetComputer(HWND hwndParent)
{
    HRESULT             hr = S_OK;
    IDsObjectPicker *   pDsObjectPicker = NULL;
    IDataObject *       pdo = NULL;
    BOOL                fSuccess = TRUE;

    hr = CoInitialize(NULL);
    if (FAILED(hr)) 
        return FALSE;

    do
    {
        //
        // Create an instance of the object picker.  The implementation in
        // objsel.dll is apartment model.
        //
        hr = CoCreateInstance(CLSID_DsObjectPicker,
                              NULL,
                              CLSCTX_INPROC_SERVER,
                              IID_IDsObjectPicker,
                              (void **) &pDsObjectPicker);
        BREAK_ON_FAIL_HRESULT(hr);

        //
        // Reinitialize the object picker to choose computers
        //

        hr = InitObjectPickerForComputers(pDsObjectPicker);
        BREAK_ON_FAIL_HRESULT(hr);

        //
        // Now pick a computer
        //

        hr = pDsObjectPicker->InvokeDialog(hwndParent, &pdo);
        BREAK_ON_FAIL_HRESULT(hr);

        //
        // If the user hit Cancel, hr == S_FALSE
        //
        if (hr == S_FALSE)
        {
            TRACE(_T("User canceled object picker dialog\n"));
            fSuccess = FALSE;
            break;
        }

        ASSERT(pdo);
        ProcessSelectedObjects(pdo);

        pdo->Release();
        pdo = NULL;
    
    } while (0);

    if (pDsObjectPicker)
    {
        pDsObjectPicker->Release();
    }
    
    CoUninitialize();

    if (FAILED(hr))
        fSuccess = FALSE;

    return fSuccess;
}


void
CGetComputer::ProcessSelectedObjects(IDataObject *pdo)
{
    HRESULT hr = S_OK;

    STGMEDIUM stgmedium =
    {
        TYMED_HGLOBAL,
        NULL,
        NULL
    };

    if (g_cfDsObjectPicker == 0)
       g_cfDsObjectPicker = ::RegisterClipboardFormat(CFSTR_DSOP_DS_SELECTION_LIST);
    ASSERT(g_cfDsObjectPicker != 0);

    FORMATETC formatetc =
    {
        (CLIPFORMAT)g_cfDsObjectPicker,
        NULL,
        DVASPECT_CONTENT,
        -1,
        TYMED_HGLOBAL
    };

    BOOL fGotStgMedium = FALSE;

    do
    {
        hr = pdo->GetData(&formatetc, &stgmedium);
        BREAK_ON_FAIL_HRESULT(hr);

        fGotStgMedium = TRUE;

        PDS_SELECTION_LIST pDsSelList =
            (PDS_SELECTION_LIST) GlobalLock(stgmedium.hGlobal);

        if (!pDsSelList)
        {
            TRACE(_T("GlobalLock error %u\n"), GetLastError());
            break;
        }

        CString strTemp = pDsSelList->aDsSelection[0].pwzName;
        if (strTemp.Left(2) == _T("\\\\"))
            strTemp = pDsSelList->aDsSelection[0].pwzName[2];

        if (ERROR_SUCCESS != ObjPickNameOrIpToHostname(strTemp, m_strComputerName))
        {
            //we use the name from the object picker if we failed to convert it into hostname
            m_strComputerName = strTemp;
        }

        GlobalUnlock(stgmedium.hGlobal);

    } while (0);

    if (fGotStgMedium)
    {
        ReleaseStgMedium(&stgmedium);
    }
}

//+--------------------------------------------------------------------------
//
//  Function:   InitObjectPickerForGroups
//
//  Synopsis:   Call IDsObjectPicker::Initialize with arguments that will
//              set it to allow the user to pick one or more groups.
//
//  Arguments:  [pDsObjectPicker] - object picker interface instance
//
//  Returns:    Result of calling IDsObjectPicker::Initialize.
//
//  History:    10-14-1998   DavidMun   Created
//              1-8-2000     SergeiA    Adapted for IIS
//
//---------------------------------------------------------------------------
HRESULT
InitObjectPickerForGroups(IDsObjectPicker *pDsObjectPicker, 
                          BOOL fMultiselect,
                          LPCTSTR pszMachineName,
                          BOOL bUsersOnly)
{
    //
    // Prepare to initialize the object picker.
    // Set up the array of scope initializer structures.
    //

    static const int     SCOPE_INIT_COUNT = 5;
    DSOP_SCOPE_INIT_INFO aScopeInit[SCOPE_INIT_COUNT];

    ZeroMemory(aScopeInit, sizeof(DSOP_SCOPE_INIT_INFO) * SCOPE_INIT_COUNT);

    //
    // Target computer scope.  This adds a "Look In" entry for the
    // target computer.  Computer scopes are always treated as
    // downlevel (i.e., they use the WinNT provider).
    //

    aScopeInit[0].cbSize = sizeof(DSOP_SCOPE_INIT_INFO);
    aScopeInit[0].flType = DSOP_SCOPE_TYPE_TARGET_COMPUTER;
    aScopeInit[0].flScope = DSOP_SCOPE_FLAG_STARTING_SCOPE;
    aScopeInit[0].FilterFlags.Uplevel.flBothModes = DSOP_FILTER_USERS;
    aScopeInit[0].FilterFlags.flDownlevel = DSOP_DOWNLEVEL_FILTER_USERS;
    if (!bUsersOnly)
    {
       aScopeInit[0].FilterFlags.flDownlevel |= 
//            DSOP_DOWNLEVEL_FILTER_ALL_WELLKNOWN_SIDS;
            DSOP_DOWNLEVEL_FILTER_LOCAL_GROUPS;
    }

    //
    // The domain to which the target computer is joined.  Note we're
    // combining two scope types into flType here for convenience.
    //

    aScopeInit[1].cbSize = sizeof(DSOP_SCOPE_INIT_INFO);
    aScopeInit[1].flScope = DSOP_SCOPE_FLAG_WANT_PROVIDER_WINNT;
    aScopeInit[1].flType = 
          DSOP_SCOPE_TYPE_UPLEVEL_JOINED_DOMAIN
      |   DSOP_SCOPE_TYPE_DOWNLEVEL_JOINED_DOMAIN;
    aScopeInit[1].FilterFlags.Uplevel.flNativeModeOnly = DSOP_FILTER_USERS;
    if (!bUsersOnly)
    {
      aScopeInit[1].FilterFlags.Uplevel.flNativeModeOnly |= 
            DSOP_FILTER_GLOBAL_GROUPS_SE
         |  DSOP_FILTER_UNIVERSAL_GROUPS_SE
         |  DSOP_FILTER_DOMAIN_LOCAL_GROUPS_SE;
    }
    aScopeInit[1].FilterFlags.Uplevel.flMixedModeOnly = DSOP_FILTER_USERS;
    if (!bUsersOnly)
    {
       aScopeInit[1].FilterFlags.Uplevel.flMixedModeOnly |= DSOP_FILTER_GLOBAL_GROUPS_SE;
    }
    aScopeInit[1].FilterFlags.flDownlevel = DSOP_DOWNLEVEL_FILTER_USERS;
    if (!bUsersOnly)
    {
       aScopeInit[1].FilterFlags.flDownlevel |= DSOP_DOWNLEVEL_FILTER_GLOBAL_GROUPS;
    }

    //
    // The domains in the same forest (enterprise) as the domain to which
    // the target machine is joined.  Note these can only be DS-aware
    //

    aScopeInit[2].cbSize = sizeof(DSOP_SCOPE_INIT_INFO);
    aScopeInit[2].flType = DSOP_SCOPE_TYPE_ENTERPRISE_DOMAIN;
    aScopeInit[2].flScope = DSOP_SCOPE_FLAG_WANT_PROVIDER_WINNT;
    
    aScopeInit[2].FilterFlags.Uplevel.flNativeModeOnly = DSOP_FILTER_USERS;
    if (!bUsersOnly)
    {
       aScopeInit[2].FilterFlags.Uplevel.flNativeModeOnly |=
            DSOP_FILTER_GLOBAL_GROUPS_SE
         |  DSOP_FILTER_UNIVERSAL_GROUPS_SE;
    }
    aScopeInit[2].FilterFlags.Uplevel.flMixedModeOnly = DSOP_FILTER_USERS;
    if (!bUsersOnly)
    {
       aScopeInit[2].FilterFlags.Uplevel.flMixedModeOnly |= 
            DSOP_FILTER_GLOBAL_GROUPS_SE;
    }
    //
    // Domains external to the enterprise but trusted directly by the
    // domain to which the target machine is joined.
    //
    // If the target machine is joined to an NT4 domain, only the
    // external downlevel domain scope applies, and it will cause
    // all domains trusted by the joined domain to appear.
    //

    aScopeInit[3].cbSize = sizeof(DSOP_SCOPE_INIT_INFO);
    aScopeInit[3].flScope = DSOP_SCOPE_FLAG_WANT_PROVIDER_WINNT;
    aScopeInit[3].flType =
         DSOP_SCOPE_TYPE_EXTERNAL_UPLEVEL_DOMAIN
      |  DSOP_SCOPE_TYPE_EXTERNAL_DOWNLEVEL_DOMAIN;

    aScopeInit[3].FilterFlags.Uplevel.flNativeModeOnly = DSOP_FILTER_USERS;
    if (!bUsersOnly)
    {
       aScopeInit[3].FilterFlags.Uplevel.flNativeModeOnly |= 
            DSOP_FILTER_GLOBAL_GROUPS_SE
         |  DSOP_FILTER_UNIVERSAL_GROUPS_SE;
    }

    aScopeInit[3].FilterFlags.Uplevel.flMixedModeOnly = DSOP_FILTER_USERS;
    if (!bUsersOnly)
    {
       aScopeInit[3].FilterFlags.Uplevel.flMixedModeOnly |= 
            DSOP_FILTER_GLOBAL_GROUPS_SE;
    }

    aScopeInit[3].FilterFlags.flDownlevel = DSOP_DOWNLEVEL_FILTER_USERS;
    if (!bUsersOnly)
    {
       aScopeInit[3].FilterFlags.flDownlevel |= 
            DSOP_DOWNLEVEL_FILTER_GLOBAL_GROUPS;
    }

    //
    // The Global Catalog
    //

    aScopeInit[4].cbSize = sizeof(DSOP_SCOPE_INIT_INFO);
    aScopeInit[4].flScope = DSOP_SCOPE_FLAG_WANT_PROVIDER_WINNT;
    aScopeInit[4].flType = DSOP_SCOPE_TYPE_GLOBAL_CATALOG;

    // Only native mode applies to gc scope.

    aScopeInit[4].FilterFlags.Uplevel.flNativeModeOnly = DSOP_FILTER_USERS;
    if (!bUsersOnly)
    {
       aScopeInit[4].FilterFlags.Uplevel.flNativeModeOnly |= 
            DSOP_FILTER_GLOBAL_GROUPS_SE
         |  DSOP_FILTER_UNIVERSAL_GROUPS_SE;
    }

    //
    // Put the scope init array into the object picker init array
    //

    DSOP_INIT_INFO  InitInfo;
    ZeroMemory(&InitInfo, sizeof(InitInfo));

    InitInfo.cbSize = sizeof(InitInfo);

    //
    // The pwzTargetComputer member allows the object picker to be
    // retargetted to a different computer.  It will behave as if it
    // were being run ON THAT COMPUTER.
    //

    InitInfo.pwzTargetComputer = pszMachineName;
    InitInfo.cDsScopeInfos = SCOPE_INIT_COUNT;
    InitInfo.aDsScopeInfos = aScopeInit;
    InitInfo.flOptions = (fMultiselect) ? DSOP_FLAG_MULTISELECT : 0;

    LPCTSTR attrs[] = {_T("ObjectSid")};
    InitInfo.cAttributesToFetch = sizeof(attrs) / sizeof(attrs[0]);
    InitInfo.apwzAttributeNames = attrs;

    //
    // Note object picker makes its own copy of InitInfo.  Also note
    // that Initialize may be called multiple times, last call wins.
    //

    HRESULT hr = pDsObjectPicker->Initialize(&InitInfo);
#ifdef _DEBUG
    if (FAILED(hr))
    {
        ULONG i;

        for (i = 0; i < SCOPE_INIT_COUNT; i++)
        {
            if (FAILED(InitInfo.aDsScopeInfos[i].hr))
            {
                TRACE(_T("Initialization failed because of scope %u\n"), i);
            }
        }
    }
#endif
    return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   InitObjectPickerForComputers
//
//  Synopsis:   Call IDsObjectPicker::Initialize with arguments that will
//              set it to allow the user to pick a single computer object.
//
//  Arguments:  [pDsObjectPicker] - object picker interface instance
//
//  Returns:    Result of calling IDsObjectPicker::Initialize.
//
//  History:    10-14-1998   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
InitObjectPickerForComputers(IDsObjectPicker *pDsObjectPicker)
{
    //
    // Prepare to initialize the object picker.
    // Set up the array of scope initializer structures.
    //

    static const int     SCOPE_INIT_COUNT = 2;
    DSOP_SCOPE_INIT_INFO aScopeInit[SCOPE_INIT_COUNT];

    ZeroMemory(aScopeInit, sizeof(DSOP_SCOPE_INIT_INFO) * SCOPE_INIT_COUNT);

    //
    // Build a scope init struct for everything except the joined domain.
    //

    aScopeInit[0].cbSize = sizeof(DSOP_SCOPE_INIT_INFO);
    aScopeInit[0].flType = DSOP_SCOPE_TYPE_ENTERPRISE_DOMAIN
                           | DSOP_SCOPE_TYPE_GLOBAL_CATALOG
                           | DSOP_SCOPE_TYPE_EXTERNAL_UPLEVEL_DOMAIN
                           | DSOP_SCOPE_TYPE_EXTERNAL_DOWNLEVEL_DOMAIN
                           | DSOP_SCOPE_TYPE_WORKGROUP
                           | DSOP_SCOPE_TYPE_USER_ENTERED_UPLEVEL_SCOPE
                           | DSOP_SCOPE_TYPE_USER_ENTERED_DOWNLEVEL_SCOPE;
    aScopeInit[0].FilterFlags.Uplevel.flBothModes =
        DSOP_FILTER_COMPUTERS;
    aScopeInit[0].FilterFlags.flDownlevel = DSOP_DOWNLEVEL_FILTER_COMPUTERS;


    //
    // scope for the joined domain, make it the default
    //
    aScopeInit[1].cbSize = sizeof(DSOP_SCOPE_INIT_INFO);
    aScopeInit[1].flType = DSOP_SCOPE_TYPE_UPLEVEL_JOINED_DOMAIN
                           | DSOP_SCOPE_TYPE_DOWNLEVEL_JOINED_DOMAIN;
    aScopeInit[1].FilterFlags.Uplevel.flBothModes =
        DSOP_FILTER_COMPUTERS;
    aScopeInit[1].FilterFlags.flDownlevel = DSOP_DOWNLEVEL_FILTER_COMPUTERS;

    aScopeInit[1].flScope = DSOP_SCOPE_FLAG_STARTING_SCOPE;

    //
    // Put the scope init array into the object picker init array
    //

    DSOP_INIT_INFO  InitInfo;
    ZeroMemory(&InitInfo, sizeof(InitInfo));

    InitInfo.cbSize = sizeof(InitInfo);
    InitInfo.pwzTargetComputer = NULL;  // NULL == local machine
    InitInfo.cDsScopeInfos = SCOPE_INIT_COUNT;
    InitInfo.aDsScopeInfos = aScopeInit;

    //
    // Note object picker makes its own copy of InitInfo.  Also note
    // that Initialize may be called multiple times, last call wins.
    //

    return pDsObjectPicker->Initialize(&InitInfo);
}

//Use WinSock to the host name based on the ip address
DWORD
ObjPickGetHostName
(
    DWORD       dwIpAddr,
    CString &   strHostName
)
{
    CString strName;

    //
    //  Call the Winsock API to get host name information.
    //
    strHostName.Empty();

    ULONG ulAddrInNetOrder = ::htonl( (ULONG) dwIpAddr ) ;

    HOSTENT * pHostInfo = ::gethostbyaddr( (CHAR *) & ulAddrInNetOrder,
                                           sizeof ulAddrInNetOrder,
                                           PF_INET ) ;
    if ( pHostInfo == NULL )
    {
        return ::WSAGetLastError();
    }

    // copy the name
    LPTSTR pBuf = strName.GetBuffer(256);
    ZeroMemory(pBuf, 256);

    ::MultiByteToWideChar(CP_ACP, 
                          MB_PRECOMPOSED, 
                          pHostInfo->h_name, 
                          -1, 
                          pBuf, 
                          256);

    strName.ReleaseBuffer();
    strName.MakeUpper();

    int nDot = strName.Find(_T("."));

    if (nDot != -1)
        strHostName = strName.Left(nDot);
    else
        strHostName = strName;

    return NOERROR;
}

//Convert any valid name of a machine (IP address, NetBios name or fully qualified DNS name)
//to the host name
DWORD ObjPickNameOrIpToHostname(CString & strNameOrIp, CString & strHostName)
{
    DWORD dwErr = ERROR_SUCCESS;
    CString strTemp;

    CIPAddress ia(strNameOrIp);
    if (!ia.IsValid())
    {
        dwErr = ObjPickGetHostName((DWORD)ia, strTemp);
    }
    else
    {
         // just want the host name
         int nDot = strNameOrIp.Find('.');
         if (nDot != -1)
         {
             strTemp = strNameOrIp.Left(nDot);
         }
         else
         {
             strTemp = strNameOrIp;
         }
    }

    if (ERROR_SUCCESS == dwErr)
    {
        strHostName = strTemp;
    }

    return dwErr;
}

BOOL
GetIUsrAccount(
    IN  LPCTSTR lpstrServer,
    IN  CWnd * pParent,      OPTIONAL
    OUT CString & str
    )
/*++

Routine Description:

    Helper function to browse for IUSR Account

Arguments:

    LPCTSTR lpstrServer : Server
    CWnd * pParent      : Parent window
    CString & str       : Will contain the selected account

Return Value:

    TRUE if an account was selected FALSE if not

--*/
{
    CGetUsers usrBrowser(lpstrServer);
    BOOL bRes = usrBrowser.GetUsers(pParent->GetSafeHwnd(), TRUE);
    if (bRes)
    {
       if (usrBrowser.GetSize() != 0)
       {
         str = usrBrowser.GetAt(0)->QueryUserName();
       }
       else
          bRes = FALSE;
    }
    return bRes;
}

BOOL
GetIUsrAccount(
    LPCTSTR lpstrServer,
    CWnd * pParent,
    TCHAR * pBuffer,
    int size
    )
/*++

Routine Description:

    Helper function to browse for IUSR Account

Arguments:

    LPCTSTR lpstrServer : Server
    CWnd * pParent      : Parent window
    CString & str       : Will contain the selected account

Return Value:

    TRUE if an account was selected FALSE if not

--*/
{
    CGetUsers usrBrowser(lpstrServer);
    BOOL bRes = usrBrowser.GetUsers(pParent->GetSafeHwnd(), TRUE);
    if (bRes)
    {
       if (usrBrowser.GetSize() != 0)
       {
          lstrcpyn(pBuffer, usrBrowser.GetAt(0)->QueryUserName(), size - 1);
       }
       else
          bRes = FALSE;
    }
    return bRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\common\objpick.h ===
// objpick.cpp: implementation of the CGetUser class and the 
//              CGetComputer class using the object picker
//
//////////////////////////////////////////////////////////////////////
#ifndef OBJPICK_H
#define OBJPICK_H

//
// A list of names (e.g., users, groups, machines, and etc)
//

BOOL COMDLL GetIUsrAccount(
    IN  LPCTSTR lpstrServer,
    IN  CWnd * pParent,
    OUT CString & str
    );

BOOL COMDLL GetIUsrAccount(
    LPCTSTR lpstrServer,
    CWnd * pParent,
    LPTSTR pBuffer,
    int size
    );

void    FormatName(LPCTSTR pszFullName, LPCTSTR pszDomainName, CString & strDisplay);

class CAccessEntry;

class CAccessEntryArray : public CArray<CAccessEntry *, CAccessEntry *&>
{
public:
    CAccessEntryArray() {}
    ~CAccessEntryArray();
};

class COMDLL CGetUsers : public CAccessEntryArray
{
public:
    CGetUsers(LPCTSTR pszMachineName, BOOL fMultiselect = FALSE);
    ~CGetUsers();

    BOOL    GetUsers(HWND hwndOwner, BOOL bUsersOnly = FALSE);

protected:
    void    ProcessSelectedObjects(IDataObject *pdo);

protected:
    BOOL    m_fMultiselect;
    CString m_MachineName;
};

class COMDLL CGetComputer 
{
public:
    CGetComputer();
    ~CGetComputer();

    BOOL    GetComputer(HWND hwndOwner);

protected:
    void    ProcessSelectedObjects(IDataObject *pdo);

public:
    CString     m_strComputerName;
};

#endif // OBJPICK_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\common\msg.h ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        msg.h

   Abstract:

        Message Functions Definitions

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/

#ifndef _MSG_H
#define _MSG_H


//
// Slightly easier syntax to register a facility
//
#define REGISTER_FACILITY(dwCode, lpSource)\
    CError::RegisterFacility(dwCode, lpSource)


//
// Helper Function
//
HRESULT GetLastHRESULT();



BOOL InitErrorFunctionality();
void TerminateErrorFunctionality();



typedef struct tagFACILITY
{
    LPCTSTR lpszDll;
    UINT    nTextID;
} FACILITY;



typedef CMap<DWORD, DWORD &, CString, CString &> CMapDWORDtoCString;
typedef CMap<HRESULT, HRESULT &, UINT, UINT &>   CMapHRESULTtoUINT;



class COMDLL CError
/*++

Class Description:

    Error handling class, works for both HRESULT and old-style DWORD
    error codes.  Construct with or assign a DWORD or HRESULT error
    return code, and the object can then be used to determine success
    or failure, and the object provides text for the error code either
    directly, in a message, or formatted with additional text.  Also,
    the CError object understands the range of winsock errors and
    lanman errors, and looks for them in the appropriate places.
    The object can be referenced as a BOOL, a DWORD, an HRESULT, or
    a LPCTSTR as a success/failure, a WIN32 error, and HRESULT or
    the text equivalent respectively.

    Example of typical programme flow:

    CError err(FunctionWhichReturnsHresult());

    //
    // Use IDS_MY_ERROR for access denied errors for the
    // duration of this scope.
    //
    err.AddOverride(ERROR_ACCESS_DENIED, IDS_MY_ERROR);

    if (!err.MessageBoxOnFailure())
    {
        //
        // If we failed, this already displayed the error
        // message in a messagebox.  Only when we succeed
        // we get here.
        //
        ... stuff ...
    }

    SomeWinApiWhichSetsLastError();
    err.GetLastWinError();
    if (err.Failed())
    {
        printf("WIN32 Error code %ld\nHRESULT %ld\nText: %s\n",
            (DWORD)err,
            (HRESULT)err,
            (LPCTSTR)err
            );
    }

Public Interface:

    TextFromHRESULT         : Convert HRESULT to text
    TextFromHRESULTExpand   : Expand %h string to error text, %H to error code
    MessageBox              : Display error in a messagebox
    MessageBoxFormat        : Use %h string as format in messagebox
    MessageBoxOnFailure     : Display message if error is a failure
    AddOverride             : Add message override with string ID
    RemoveOverride          : Remove message override
    RegisterFacility        : Register facility
    UnregisterFacility      : Unregister facility
    Succeeded               : Determine if the error code indicates a success
    Failed                  : Determine if the error code indicates a failure

    CError                  : Constructors
    Reset                   : Reset error code
    GetLastWinError         : Assign internal code to GetLastError
    SetLastWinError         : Set last error from internal code

    operator =              : Assignment operators
    operator ==             : Comparison operators
    operator !=             : Comparison operators
    operator LPOLESTR       : Conversion operator
    operator LPCTSTR        : Conversion operator
    operator HRESULT        : Conversion operator
    operator DWORD          : Conversion operator
    operator BOOL           : Conversion operator

--*/
{
#define IS_HRESULT(hr)  (hr & 0xffff0000)
#define REMOVE_OVERRIDE ((UINT)-1)
#define NO_HELP_CONTEXT ((UINT)-1)
#define USE_LAST_ERROR  (TRUE)

//
// Private Internal FACILITY codes
//
#define FACILITY_WINSOCK    (0xffe)
#define FACILITY_LANMAN     (0xfff)

//
// Static Helpers
//
public:
    //
    // Success/Failure determinants, works regardless
    // of whether hrCode is a DWORD or HRESULT
    //
    static BOOL Succeeded(HRESULT hrCode);
    static BOOL Failed(HRESULT hrCode);

    //
    // Guarantee return is WIN32 error code
    //
    static DWORD Win32Error(HRESULT hrCode) { return HRESULT_CODE(hrCode); }

    //
    // Guarantee return is a true HRESULT
    //
    static HRESULT HResult(HRESULT hrCode) { return HRESULT_FROM_WIN32(hrCode); }

    //
    // Register a DLL for a given facility code.
    // Use NULL to unregister the facility
    //
    static void RegisterFacility(
        IN DWORD dwFacility,
        IN LPCSTR lpDLL = NULL
        );

    static void UnregisterFacility(
        IN DWORD dwFacility
        );

//
// Constructor/Destructor
//
public:
    //
    // If constructed with TRUE, the object is initialized to
    // last error.  It's set to ERROR_SUCCESS otherwise (default case)
    //
    CError();
    CError(HRESULT hrCode);
    CError(DWORD   dwCode);
    ~CError();

//
// Helpers
//
public:
    BOOL Succeeded() const { return SUCCEEDED(m_hrCode); }
    BOOL Failed() const { return FAILED(m_hrCode); }

    HRESULT TextFromHRESULT(
        OUT LPTSTR szBuffer,
        OUT DWORD  cchBuffer
        ) const;

    HRESULT TextFromHRESULT(
        OUT CString & strMsg
        ) const;

    LPCTSTR TextFromHRESULTExpand(
        OUT LPTSTR  szBuffer,
        OUT DWORD   cchBuffer,
        OUT HRESULT * phResult = NULL
        ) const;

    LPCTSTR TextFromHRESULTExpand(
        OUT CString & strBuffer
        ) const;

    int MessageBox(
        IN UINT nType = MB_OK | MB_ICONWARNING,
        IN UINT nHelpContext = NO_HELP_CONTEXT
        ) const;

    BOOL MessageBoxOnFailure(
        IN UINT nType = MB_OK | MB_ICONWARNING,
        IN UINT nHelpContext = NO_HELP_CONTEXT
        ) const;

    int MessageBoxFormat(
        IN UINT nFmt,
        IN UINT nType,
        IN UINT nHelpContext,
        ...
        ) const;

    void Reset();
    void GetLastWinError();
    void SetLastWinError() const;
    DWORD Win32Error() const;
    HRESULT HResult() const { return m_hrCode; }

    //
    // Add override for specific error code.
    // Use -1 to remove the override.  This function
    // will return the previous override (or -1)
    //
    UINT AddOverride(
        IN HRESULT hrCode,
        IN UINT    nMessage = REMOVE_OVERRIDE
        );         

    void RemoveOverride(
        IN HRESULT hrCode
        );
        
    void RemoveAllOverrides();   

protected:
    //
    // Expand escape code
    //
    BOOL ExpandEscapeCode(
        IN  LPTSTR szBuffer,
        IN  DWORD cchBuffer,
        OUT IN LPTSTR & lp,
        IN  CString & strReplacement,
        OUT HRESULT & hr
        ) const;

    //
    // Check for override message
    //
    BOOL HasOverride(
        OUT UINT * pnMessage = NULL
        ) const;

//
// Assignment Operators
//
public:
    const CError & operator =(HRESULT hr);
    const CError & operator =(const CError & err);

// 
// Comparison Operators
//
public:
    const BOOL operator ==(HRESULT hr);
    const BOOL operator ==(CError & err);
    const BOOL operator !=(HRESULT hr);
    const BOOL operator !=(CError & err);

//
// Conversion Operators
//
public:
    operator const HRESULT() const { return m_hrCode; }
    operator const DWORD() const;
    operator const BOOL() const;
    operator LPOLESTR();
    operator LPCTSTR();

#if defined(_DEBUG) || DBG

public:
    //
    // CDumpContext stream operator
    //
    inline friend CDumpContext & AFXAPI operator <<(
        IN OUT CDumpContext & dc,
        IN const CError & value
        )
    {
        return dc << (DWORD)value.m_hrCode;
    }

#endif // _DEBUG

protected:
    static HRESULT CvtToInternalFormat(HRESULT hrCode);

    //
    // Check for FACILITY dll
    //
    static LPCTSTR FindFacility(
        IN DWORD dwFacility
        );

protected:
    friend BOOL InitErrorFunctionality();
    friend void TerminateErrorFunctionality();
    static BOOL AllocateStatics();
    static void DeAllocateStatics();
    static BOOL AreStaticsAllocated() { return s_fAllocated; }

protected:
    static const TCHAR s_chEscape;    // Escape character
    static const TCHAR s_chEscText;   // Escape code for text
    static const TCHAR s_chEscNumber; // Escape code for error code
    static LPCTSTR s_cszLMDLL;        // Lanman Message DLL
    static LPCTSTR s_cszWSDLL;        // Winsock Message DLL
    static LPCTSTR s_cszFacility[];   // Facility Table
    static HRESULT s_cdwMinLMErr;     // Lanman Error Range
    static HRESULT s_cdwMaxLMErr;     // Lanman Error Range
    static HRESULT s_cdwMinWSErr;     // Winsock Error Range
    static HRESULT s_cdwMaxWSErr;     // Winsock Error Range
    static DWORD   s_cdwFacilities;   // Number of facility items

    //
    // Allocated objects 
    //
    static CString * s_pstrDefError;  // Default Error String
    static CString * s_pstrDefSuccs;  // Default Success String
    static CMapDWORDtoCString * s_pmapFacilities;
    static BOOL s_fAllocated;

protected:
    const CError & Construct(HRESULT hr);
    const CError & Construct(const CError & err);
    CMapHRESULTtoUINT  mapOverrides;

private:
    HRESULT m_hrCode;
    CString m_str;
};



//
// Inline Expansions
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

inline HRESULT GetLastHRESULT()
{
    return CError::HResult(::GetLastError());
}

inline /* static */ BOOL CError::Succeeded(HRESULT hrCode)
{
    //
    // Works with either HRESULT or WIN32 error code
    //
    return IS_HRESULT(hrCode)
        ? SUCCEEDED(hrCode)
        : hrCode == ERROR_SUCCESS;
}

inline /* static */ BOOL CError::Failed(HRESULT hrCode)
{
    //
    // Works with either HRESULT or WIN32 error code
    //
    return IS_HRESULT(hrCode)
        ? FAILED(hrCode)
        : hrCode != ERROR_SUCCESS;
}

inline /* static */ void CError::UnregisterFacility(
    IN DWORD dwFacility
    )
{
    RegisterFacility(dwFacility, NULL);
}

inline CError::CError()
{
    Construct(S_OK);
}

inline CError::CError(HRESULT hrCode)
{
    Construct(hrCode);
}

inline CError::CError(DWORD dwCode)
{
    Construct((HRESULT)dwCode);
}

inline DWORD CError::Win32Error() const
{
    return CError::Win32Error(m_hrCode);
}

inline void CError::Reset()
{
    m_hrCode = S_OK;
}

inline void CError::GetLastWinError()
{
    Construct(::GetLastError());
}

inline void CError::SetLastWinError() const
{
    ::SetLastError(Win32Error(m_hrCode));
}

inline void CError::RemoveOverride(
    IN HRESULT hrCode
    )
{
    (void)CError::AddOverride(hrCode, REMOVE_OVERRIDE);
}

inline const CError & CError::operator =(HRESULT hr)
{
    return Construct(hr);
}

inline const CError & CError::operator =(const CError & err)
{
    return Construct(err);
}

inline const BOOL CError::operator ==(HRESULT hr)
{
    return m_hrCode == hr;
}

inline const BOOL CError::operator ==(CError & err)
{
    return m_hrCode == err.m_hrCode;
}

inline const BOOL CError::operator !=(HRESULT hr)
{
    return m_hrCode != hr;
}

inline const BOOL CError::operator !=(CError & err)
{
    return m_hrCode != err.m_hrCode;
}

inline CError::operator const DWORD() const
{
    return Win32Error();
}

inline CError::operator const BOOL() const
{
    return Succeeded();
}

inline CError::operator LPOLESTR()
{
    TextFromHRESULT(m_str);
    return m_str.GetBuffer(0);
}
    
inline CError::operator LPCTSTR()
{
    TextFromHRESULT(m_str);
    return m_str;
}

//
// AfxMessageBox helpers
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

inline BOOL NoYesMessageBox(UINT nID)
{
    return AfxMessageBox(nID, MB_YESNO|MB_ICONQUESTION|MB_DEFBUTTON2) == IDYES;
}

inline BOOL NoYesMessageBox(CString & str)
{
    return AfxMessageBox(str, MB_YESNO|MB_ICONQUESTION|MB_DEFBUTTON2) == IDYES;
}

inline BOOL YesNoMessageBox(UINT nID)
{
    return AfxMessageBox(nID, MB_YESNO|MB_ICONQUESTION|MB_DEFBUTTON1) == IDYES;
}

inline BOOL YesNoMessageBox(CString & str)
{
    return AfxMessageBox(str, MB_YESNO|MB_ICONQUESTION|MB_DEFBUTTON1) == IDYES;
}

#endif // _MSG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\common\odlbox.cpp ===
/*++

   Copyright    (c)    1994-1999    Microsoft Corporation

   Module  Name :

        odlbox.cpp

   Abstract:

        Owner draw listbox/combobox base classes

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager (cluster edition)

   Revision History:

--*/

//
// Include Files
//
#include "stdafx.h"
#include "common.h"



#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif



#define new DEBUG_NEW

#define BMP_LEFT_OFFSET  (1)          // Space allotted to the left of bitmap
#define BMP_RIGHT_OFFSET (3)          // Space allotted to the right of bitmap

//
// Ellipses are shown when column text doesn't fit in the display
//
const TCHAR g_szEllipses[] = _T("...");
int g_nLenEllipses = (sizeof(g_szEllipses) / sizeof(g_szEllipses[0])) - 1;

//
// Registry value for columns
//
const TCHAR g_szRegColumns[] = _T("Columns");

//
// Column Value Separator
//
const TCHAR g_szColValueSep[] = _T(" ");



void
GetDlgCtlRect(
    IN  HWND hWndParent,
    IN  HWND hWndControl,
    OUT LPRECT lprcControl
    )
/*++

Routine Description:

    Get the control rectangle coordinates relative to its parent.  This can
    then be used in e.g. SetWindowPos()

Arguments:

    HWND hWndParent    : Parent window handle
    HWND hWndControl   : Control window handle
    LPRECT lprcControl : Control rectangle to be filled in

Return Value:

    None

--*/
{
#define MapWindowRect(hwndFrom, hwndTo, lprc)\
     MapWindowPoints((hwndFrom), (hwndTo), (POINT *)(lprc), 2)

    ::GetWindowRect(hWndControl, lprcControl);
    ::MapWindowRect(NULL, hWndParent, lprcControl);
}



void
FitPathToControl(
    IN CWnd & wndControl,
    IN LPCTSTR lpstrPath
    )
/*++

Routine Description:

    Display the given path in the given control, using ellipses
    to ensure that the path fits within the control.

Arguments:

    CWnd & wndControl       : Control to display on
    LPCTSTR lpstrPath       : Path

Return Value:

    None

--*/
{
    CString strDisplay(lpstrPath);
    UINT uLength = strDisplay.GetLength() + 4;  // Account for ell.
    LPTSTR lp = strDisplay.GetBuffer(uLength);

    if (lp)
    {
        CDC * pDC = wndControl.GetDC();
        ASSERT_PTR(pDC);

        if (pDC != NULL)
        {
            CRect rc;
            wndControl.GetClientRect(&rc);
            pDC->DrawText(lp, uLength, &rc, DT_PATH_ELLIPSIS | DT_MODIFYSTRING);
            wndControl.ReleaseDC(pDC);
        }

        strDisplay.ReleaseBuffer();
        wndControl.SetWindowText(strDisplay);
    }
}



void
ActivateControl(
    IN CWnd & wndControl,
    IN BOOL fShow
    )
/*++

Routine Description:

    Show/hide _AND_ enable/disable control window

Arguments:

    CWnd & wndControl           : Window in question
    BOOL fShow                  : TRUE to show/enable,
                                  FALSE to hide/disable

Return Value:

    None

Notes:

    Merely hiding a window does not disable it.  Use this function
    instead of ShowWindow() to do that.

--*/
{
    wndControl.ShowWindow(fShow ? SW_SHOW : SW_HIDE);
    wndControl.EnableWindow(fShow);
}



BOOL
VerifyState()
/*++

Routine Description:

    Verify keyboard state

Arguments:

    None

Return Value:

    TRUE if keyboard is in specified state
    FALSE otherwise.

--*/
{
    SHORT s1, s2;
    s1 = GetKeyState(VK_SHIFT);
    s2 = GetKeyState(VK_CONTROL);

    return (s1 & 0x8000) && (s2 & 0x8000);
}



BOOL
CMappedBitmapButton::LoadMappedBitmaps(
    IN UINT nIDBitmapResource,
    IN UINT nIDBitmapResourceSel,
    IN UINT nIDBitmapResourceFocus,
    IN UINT nIDBitmapResourceDisabled
    )
/*++

Routine Description:

    LoadBitmaps will load one, two, three or all four bitmaps
    returns TRUE if all specified images are loaded.  This
    will map the buttons to the default colours

Arguments:

    UINT nIDBitmapResource           : Standard button
    UINT nIDBitmapResourceSel        : Selected button
    UINT nIDBitmapResourceFocus      : Button with focus
    UINT nIDBitmapResourceDisabled   : Disabled button

--*/
{
    //
    // delete old bitmaps (if present)
    //
    m_bitmap.DeleteObject();
    m_bitmapSel.DeleteObject();
    m_bitmapFocus.DeleteObject();
    m_bitmapDisabled.DeleteObject();

    if (!m_bitmap.LoadMappedBitmap(nIDBitmapResource))
    {
        TRACEEOLID("Failed to load bitmap for normal image.");

        return FALSE;   // need this one image
    }

    BOOL bAllLoaded = TRUE;
    if (nIDBitmapResourceSel != 0)
    {
        if (!m_bitmapSel.LoadMappedBitmap(nIDBitmapResourceSel))
        {
            TRACEEOLID("Failed to load bitmap for selected image.");
            bAllLoaded = FALSE;
        }
    }
    if (nIDBitmapResourceFocus != 0)
    {
        if (!m_bitmapFocus.LoadMappedBitmap(nIDBitmapResourceFocus))
        {
            bAllLoaded = FALSE;
        }
    }

    if (nIDBitmapResourceDisabled != 0)
    {
        if (!m_bitmapDisabled.LoadMappedBitmap(nIDBitmapResourceDisabled))
        {
            bAllLoaded = FALSE;
        }
    }

    return bAllLoaded;
}



CRMCListBoxResources::CRMCListBoxResources(
    IN int bmId,
    IN int nBitmaps,
    IN COLORREF rgbBackground
    )
/*++

Routine Description:

    Constructor

Arguments:

    int bmId               : Bitmap resource ID
    int nBitmaps           : Number of bitmaps
    COLORREF rgbBackground : Background colour to mask out

Return Value:

    N/A

--*/
    : m_idBitmap(bmId),
      m_rgbColorTransparent(rgbBackground),
      m_nBitmaps(nBitmaps),
      m_nBitmapHeight(0),
      m_nBitmapWidth(-1),    // Set Later
      m_fInitialized(FALSE)
{
    ASSERT(m_nBitmaps > 0);
    GetSysColors();
    PrepareBitmaps();
}



CRMCListBoxResources::~CRMCListBoxResources()
/*++

Routine Description:

    Destructor

Arguments:

    N/A

Return Value:

    N/A

--*/
{
    UnprepareBitmaps();
}



void
CRMCListBoxResources::UnprepareBitmaps()
/*++

Routine Description:

    Free up bitmap resources

Arguments:

    N/A

Return Value:

    N/A

--*/
{
    ASSERT(m_fInitialized);

    if (m_fInitialized)
    {
        CBitmap * pBmp = (CBitmap *)CGdiObject::FromHandle(m_hOldBitmap);
        ASSERT_READ_PTR(pBmp);

        VERIFY(m_dcFinal.SelectObject(pBmp));
        VERIFY(m_dcFinal.DeleteDC());
        VERIFY(m_bmpScreen.DeleteObject());

        m_fInitialized = FALSE;
    }
}



void
CRMCListBoxResources::PrepareBitmaps()
/*++

Routine Description:

    Prepare 2 rows of bitmaps.  One with the selection colour background,
    and one with the ordinary listbox background.

Arguments:

    None

Return Value:

    None

--*/
{
    ASSERT(m_idBitmap);

    //
    // Clean up if we were already initialised
    //
    if (m_fInitialized)
    {
        UnprepareBitmaps();
    }

    //
    // create device contexts compatible with screen
    //
    CDC dcImage;
    CDC dcMasks;

    VERIFY(dcImage.CreateCompatibleDC(0));
    VERIFY(dcMasks.CreateCompatibleDC(0));

    VERIFY(m_dcFinal.CreateCompatibleDC(0));

    CBitmap bitmap;
    VERIFY(bitmap.LoadBitmap(m_idBitmap));

    BITMAP bm;
    VERIFY(bitmap.GetObject(sizeof(BITMAP), &bm));

    //
    // Each bitmap is assumed to be the same size.
    //
    m_nBitmapWidth = bm.bmWidth / m_nBitmaps;
    ASSERT(m_nBitmapWidth > 0);

    const int bmWidth = bm.bmWidth;
    const int bmHeight = bm.bmHeight;
    m_nBitmapHeight = bmHeight;

    CBitmap * pOldImageBmp = dcImage.SelectObject(&bitmap);
    ASSERT_PTR(pOldImageBmp);

    CBitmap bmpMasks;
    VERIFY(bmpMasks.CreateBitmap(bmWidth, bmHeight * 2, 1, 1, NULL));

    CBitmap * pOldMaskBmp = (CBitmap *)dcMasks.SelectObject(&bmpMasks);
    ASSERT_PTR(pOldMaskBmp);

    //
    // create the foreground and object masks
    //
    COLORREF crOldBk = dcImage.SetBkColor(m_rgbColorTransparent);
    dcMasks.BitBlt(0, 0, bmWidth, bmHeight, &dcImage, 0, 0, SRCCOPY);
    dcMasks.BitBlt(0, 0, bmWidth, bmHeight, &dcImage, 0, bmHeight, SRCAND);
    dcImage.SetBkColor(crOldBk);
    dcMasks.BitBlt(0, bmHeight, bmWidth, bmHeight, &dcMasks, 0, 0, NOTSRCCOPY);

    //
    // create DC to hold final image
    //
    VERIFY(m_bmpScreen.CreateCompatibleBitmap(&dcImage, bmWidth, bmHeight * 2));
    CBitmap * pOldBmp = (CBitmap*)m_dcFinal.SelectObject(&m_bmpScreen);
    ASSERT_PTR(pOldBmp);
    m_hOldBitmap = pOldBmp->m_hObject;

    CBrush b1, b2;
    VERIFY(b1.CreateSolidBrush(m_rgbColorHighlight));
    VERIFY(b2.CreateSolidBrush(m_rgbColorWindow));

    m_dcFinal.FillRect(CRect(0, 0, bmWidth, bmHeight), &b1);
    m_dcFinal.FillRect(CRect(0, bmHeight, bmWidth, bmHeight * 2), &b2);

    //
    // mask out the object pixels in the destination
    //
    m_dcFinal.BitBlt(0, 0, bmWidth, bmHeight, &dcMasks, 0, 0, SRCAND);

    //
    // mask out the background pixels in the image
    //
    dcImage.BitBlt(0, 0, bmWidth, bmHeight, &dcMasks, 0, bmHeight, SRCAND);

    //
    // XOR the revised image into the destination
    //
    m_dcFinal.BitBlt(0, 0, bmWidth, bmHeight, &dcImage, 0, 0, SRCPAINT);

    //
    // mask out the object pixels in the destination
    //
    m_dcFinal.BitBlt(0, bmHeight, bmWidth, bmHeight, &dcMasks, 0, 0, SRCAND);

    //
    // XOR the revised image into the destination
    //
    m_dcFinal.BitBlt(0, bmHeight, bmWidth, bmHeight, &dcImage, 0, 0, SRCPAINT);

    VERIFY(dcMasks.SelectObject(pOldMaskBmp));
    VERIFY(dcImage.SelectObject(pOldImageBmp));

    //
    // The result of all of this mucking about is a bitmap identical with the
    // one loaded from the resources but with the lower row of bitmaps having
    // their background changed from transparent1 to the window background
    // and the upper row having their background changed from transparent2 to
    // the highlight colour.  A derived CRMCListBox can BitBlt the relevant part
    // of the image into an item's device context for a transparent bitmap
    // effect which does not take any extra time over a normal BitBlt.
    //
    m_fInitialized = TRUE;
}



void
CRMCListBoxResources::SysColorChanged()
/*++

Routine Description:

    Respond to change in system colours by rebuilding the resources

Arguments:

    None

Return Value:

    None

--*/
{
    //
    // Reinitialise bitmaps and syscolors. This should be called from
    // the parent of the CRMCListBoxResources object from
    // the OnSysColorChange() function.
    //
    GetSysColors();
    PrepareBitmaps();
}



void
CRMCListBoxResources::GetSysColors()
/*++

Routine Description:

    Get sytem colours

Arguments:

    None

Return Value:

    None

--*/
{
    m_rgbColorWindow = ::GetSysColor(COLOR_WINDOW);
    m_rgbColorHighlight = ::GetSysColor(COLOR_HIGHLIGHT);
    m_rgbColorWindowText = ::GetSysColor(COLOR_WINDOWTEXT);
    m_rgbColorHighlightText = ::GetSysColor(COLOR_HIGHLIGHTTEXT);
}


CRMCListBoxDrawStruct::CRMCListBoxDrawStruct(
    IN CDC * pDC,
    IN RECT * pRect,
    IN BOOL sel,
    IN DWORD_PTR item,
    IN int itemIndex,
    IN const CRMCListBoxResources * pres
    )
/*++

Routine Description:

    Constructor

Arguments:

    CDC * pdc                           : Device context
    RECT * pRect                        : Rectange to paint into
    BOOL sel                            : TRUE if selected
    DWORD item                          : item
    int itemIndex                       : item index
    const CRMCListBoxResources * pres    : Pointer to resources

Return Value:

    N/A

--*/
    : m_pDC(pDC),
      m_Sel(sel),
      m_ItemData(item),
      m_ItemIndex(itemIndex),
      m_pResources(pres)
{
    m_Rect.CopyRect(pRect);
}



CODLBox::CODLBox()
/*++

Routine Description:

    Constructor for CODLBox -- abstract base class for both CRMCComboBox,
    and CRMCListBox

Arguments:

    None

Return Value:

    N/A

--*/
    : m_lfHeight(0),
      m_pResources(NULL),
      m_auTabs(),
      m_pWnd(NULL)
{
}



CODLBox::~CODLBox()
/*++

Routine Description:

    Destructor

Arguments:

    N/A

Return Value:

    N/A

--*/
{
}



/* virtual */
BOOL
CODLBox::Initialize()
/*++

Routine Description:

    Listbox/combobox is being created

Arguments:

    None

Return Value:

    TRUE for success, FALSE for failure

--*/
{
    //
    // Derived control must be attached at this point
    //
    ASSERT_PTR(m_pWnd);

    //
    // GetFont returns non NULL when the control is in a dialog box
    //
    CFont * pFont = m_pWnd->GetFont();

    if(pFont == NULL)
    {
        LOGFONT lf;
        CFont fontTmp;

        ::GetObject(::GetStockObject(SYSTEM_FONT), sizeof(LOGFONT), &lf);
        fontTmp.CreateFontIndirect(&lf);

        CalculateTextHeight(&fontTmp);
    }
    else
    {
        CalculateTextHeight(pFont);
    }

    return TRUE;
}



BOOL
CODLBox::ChangeFont(
    IN CFont * pFont
    )
/*++

Routine Description:

    Change the control font the specified font

Arguments:

    CFont * pFont : Pointer to the new font to be used

Return Value:

    TRUE for success, FALSE for failure

--*/
{
    ASSERT_PTR(m_pResources);
    ASSERT_PTR(m_pWnd);

    if( pFont == NULL || m_pResources == NULL
     || m_pWnd == NULL || m_pWnd->m_hWnd == NULL
      )
    {
        TRACEEOLID("Invalid state of the control.  Can't change font");
        return FALSE;
    }

    //
    // Don't reflect changes immediately
    //
    m_pWnd->SetRedraw(FALSE);

    m_pWnd->SetFont(pFont, TRUE);
    CalculateTextHeight(pFont);

    int nItems = __GetCount();
    int bmHeight = m_pResources->BitmapHeight();
    int nHeight = bmHeight > m_lfHeight ? bmHeight : m_lfHeight;

    for(int i = 0; i < nItems; ++i)
    {
        __SetItemHeight(i, nHeight);
    }

    //
    // Now reflect the change visually
    //
    m_pWnd->SetRedraw(TRUE);
    m_pWnd->Invalidate();

    return TRUE;
}



void
CODLBox::AttachResources(
    IN const CRMCListBoxResources * pRes
    )
/*++

Routine Description:

    Attach the bitmaps

Arguments:

    const CRMCListBoxResources * pRes : pointer to resources to be attached

Return Value:

    None

--*/
{
    if(pRes != m_pResources)
    {
        ASSERT_READ_PTR(pRes);
        m_pResources = pRes;

        if(m_pWnd != NULL && m_pWnd->m_hWnd != NULL)
        {
            //
            // if window was created already, redraw everything.
            //
            m_pWnd->Invalidate();
        }
    }
}



/* static */
int
CODLBox::GetRequiredWidth(
    IN CDC * pDC,
    IN const CRect & rc,
    IN LPCTSTR lpstr,
    IN int nLength
    )
/*++

Routine Description:

    Determine required display width of the string

Arguments:

    CDC * pDC         : Pointer to device context to use
    const CRect & rc  : Starting rectangle
    LPCTSTR lpstr     : String whose width is to be displayed
    int nLength       : Length (in characters of the string

Return Value:

    The display width that the string would need to be displayed on the
    given device context

--*/
{
#ifdef _DEBUG

    pDC->AssertValid();

#endif // _DEBUG

    CRect rcTmp(rc);

    pDC->DrawText(
        lpstr,
        nLength,
        &rcTmp,
        DT_CALCRECT | DT_LEFT | DT_SINGLELINE | DT_NOPREFIX | DT_VCENTER
        );

    return rcTmp.Width();
}



/* static */
BOOL
CODLBox::ColumnText(
    IN CDC * pDC,
    IN int nLeft,
    IN int nTop,
    IN int nRight,
    IN int nBottom,
    IN LPCTSTR lpstr
    )
/*++

Routine Description:

    Display text limited by a rectangle.  Use ellipses if the text is too wide
    to fit inside the given dimensions.

Arguments:

    CDC * pDC     : Pointer to display context to use
    int nLeft     : Left coordinate
    int nTop      : Top coordinate
    int nRight    : Right coordinate
    int nBottom   : Bottom coordinate
    LPCTSTR lpstr : String to be displayed

Return Value:

    TRUE for success, FALSE for failure

--*/
{
    BOOL fSuccess = TRUE;

#ifdef _DEBUG

    pDC->AssertValid();

#endif // _DEBUG

    CString str;
    CRect rc(nLeft, nTop, nRight, nBottom);

    int nAvailWidth = rc.Width();
    int nLength = ::lstrlen(lpstr);

    try
    {
        if (GetRequiredWidth(pDC, rc, lpstr, nLength) <= nAvailWidth)
        {
            //
            // Sufficient space, display as is.
            //
            str = lpstr;
        }
        else
        {
            //
            // Build a string with ellipses until it
            // fits
            //
            LPTSTR lpTmp = str.GetBuffer(nLength + g_nLenEllipses);
            while (nLength)
            {
                ::lstrcpyn(lpTmp, lpstr, nLength);
                ::lstrcpy(lpTmp + nLength - 1, g_szEllipses);

                if (GetRequiredWidth(pDC, rc, lpTmp,
                    nLength + g_nLenEllipses) <= nAvailWidth)
                {
                    break;
                }

                --nLength;
            }

            str = lpTmp;
        }

        pDC->DrawText(
           str,
           &rc,
           DT_LEFT | DT_SINGLELINE | DT_NOPREFIX | DT_VCENTER
           );

    }
    catch(CMemoryException * e)
    {
        //
        // Mem failure
        //
        fSuccess = FALSE;
        e->ReportError();
        e->Delete();
    }

    return fSuccess;
}



void
CODLBox::ComputeMargins(
    IN  CRMCListBoxDrawStruct & ds,
    IN  int nCol,
    OUT int & nLeft,
    OUT int & nRight
    )
/*++

Routine Description:

    Compute the left and right margins of the given column.

Arguments:

    CRMCListBoxDrawStruct & ds : Drawing structure
    int nCol                  : Column whose margins we're interested in
    int & nLeft               : Left column
    int & nRight              : Right column

Return Value:

    None

--*/
{
    nLeft = ds.m_Rect.left;
    nRight = ds.m_Rect.right;

    //
    // Find tab value associated with column index (0-based),
    // and adjust left and right
    //
    ASSERT(nCol <= NumTabs());

    if (nCol > 0)
    {
        if (nCol <= NumTabs())
        {
            nLeft += m_auTabs[nCol-1];
        }
    }
    if (nCol < NumTabs())
    {
        nRight = m_auTabs[nCol];
    }
}



BOOL
CODLBox::DrawBitmap(
    IN CRMCListBoxDrawStruct & ds,
    IN int nCol,
    IN int nID
    )
/*++

Routine Description:

    Draw a bitmap in the given column.  Bitmap are always placed on the
    leftmost side of the column if there is sufficient space.

Arguments:

    CRMCListBoxDrawStruct & ds : Drawing structure
    int nCol                  : Column to place bitmap in
    int nID                   : Bitmap ID (offset within the bitmap resources)

Return Value:

    None

--*/
{
    CDC * pBmpDC = (CDC *)&ds.m_pResources->dcBitMap();

#ifdef _DEBUG

    pBmpDC->AssertValid();

#endif // _DEBUG

    //
    // Select the bitmap with either a selection or
    // a regular background
    //
    int bm_h = ds.m_Sel ? 0 : ds.m_pResources->BitmapHeight();
    int bm_w = ds.m_pResources->BitmapWidth() * nID;

    int nLeft, nRight;
    ComputeMargins(ds, nCol, nLeft, nRight);
    nLeft += BMP_LEFT_OFFSET;

    //
    // Check to make sure there's enough room before
    // drawing the bitmap.
    //
    if (nRight - nLeft >= ds.m_pResources->BitmapWidth())
    {
        ds.m_pDC->BitBlt(
            nLeft,
            ds.m_Rect.top,
            ds.m_pResources->BitmapWidth(),
            ds.m_pResources->BitmapHeight(),
            pBmpDC,
            bm_w,
            bm_h,
            SRCCOPY
            );
    }

    return TRUE;
}



BOOL
CODLBox::ColumnText(
    IN CRMCListBoxDrawStruct & ds,
    IN int nCol,
    IN BOOL fSkipBitmap,
    IN LPCTSTR lpstr
    )
/*++

Routine Description:

    Draw column text.

Arguments:

    CRMCListBoxDrawStruct & ds : Drawing structure
    int nCol                  : Column to place bitmap in
    BOOL fSkipBitmap          : If TRUE, increment lefthand column by the width
                                of a bitmap
    LPCTSTR lpstr             : String to be displayed.  May be truncated as
                                necessary

Return Value:

    TRUE for success, FALSE for failure

--*/
{
    int nLeft, nRight;

    ComputeMargins(ds, nCol, nLeft, nRight);

    //
    // Optionally adjust for bitmap
    //
    if (fSkipBitmap)
    {
        nLeft += (ds.m_pResources->BitmapWidth() + BMP_RIGHT_OFFSET);
    }

    return CODLBox::ColumnText(
        ds.m_pDC,
        nLeft,
        ds.m_Rect.top,
        nRight,
        ds.m_Rect.bottom,
        lpstr
        );
}



void
CODLBox::CalculateTextHeight(
    IN CFont * pFont
    )
/*++

Routine Description:

    Calculate and set the text height of font

Arguments:

    CFont * pFont : Pointer to the font to be used.

Return Value:

    None

--*/
{
    ASSERT_PTR(m_pWnd);

    CClientDC dc(m_pWnd);
    CFont * pOldFont = dc.SelectObject(pFont);

    TEXTMETRIC tm;
    dc.GetTextMetrics(&tm);
    m_lfHeight = tm.tmHeight;

    dc.SelectObject(pOldFont);
}



int
CODLBox::AddTab(
    IN UINT uTab
    )
/*++

Routine Description:

    Add a tab to the end of the list (e.g the right side of the header)

Arguments:

    UINT uTab : Tab value to set

Return Value:

    The index of the new tab

--*/
{
    return (int)m_auTabs.Add(uTab);
}



int
CODLBox::AddTabFromHeaders(
    IN CWnd & wndLeft,
    IN CWnd & wndRight
    )
/*++

Routine Description:

    Add a tab to the end of the list (e.g the right side of the header),
    but compute the tab by taking the difference in left-hand coordinat of two
    window controls (usually static header text)

Arguments:

    CWnd & wndLeft   : Left window
    CWnd & wndRight  : Right window

Return Value:

    The index of the new tab

--*/
{
    CRect rcLeft, rcRight;

    wndLeft.GetWindowRect(&rcLeft);
    wndRight.GetWindowRect(&rcRight);

    ASSERT(rcRight.left > rcLeft.left);

    return AddTab(rcRight.left - rcLeft.left - 1);
}



int
CODLBox::AddTabFromHeaders(
    IN UINT idLeft,
    IN UINT idRight
    )
/*++

Routine Description:

    Similar to the function above, but use the control IDs.  The parent
    window is assumed to be the same as the parent window of the listbox

Arguments:

    UINT idLeft  : ID of the left control
    UINT idRight : ID of the right control

Return Value:

    The index of the new tab or -1 in case of failure

--*/
{
    ASSERT_PTR(m_pWnd);

    if (m_pWnd == NULL)
    {
        //
        // Should have associated window handle by now
        //
        return -1;
    }

    CWnd * pLeft = m_pWnd->GetParent()->GetDlgItem(idLeft);
    CWnd * pRight = m_pWnd->GetParent()->GetDlgItem(idRight);

    ASSERT_READ_PTR(pLeft);
    ASSERT_READ_PTR(pRight);

    if (!pLeft || !pRight)
    {
        //
        // One or both control IDs were not valid
        //
        return -1;
    }

    return AddTabFromHeaders(*pLeft, *pRight);
}



void
CODLBox::InsertTab(
    IN int nIndex,
    IN UINT uTab
    )
/*++

Routine Description:

    Insert a tab at the given index

Arguments:

    int nIndex : Column index at which the tab is to be inserted
    UINT uTab  : Tab value to set

Return Value:

    None

--*/
{
    m_auTabs.InsertAt(nIndex, uTab);
}



void
CODLBox::RemoveTab(
    IN int nIndex,
    IN int nCount
    )
/*++

Routine Description:

    Remove one or more tabs

Arguments:

    int nIndex : Column index at which to start removing tabs
    int nCount : Number of tabs to be removed

Return Value:

    None

--*/
{
    m_auTabs.RemoveAt(nIndex, nCount);
}



void
CODLBox::RemoveAllTabs()
/*++

Routine Description:

    Remove all tabs

Arguments:

    None

Return Value:

    None

--*/
{
    m_auTabs.RemoveAll();
}



void
CODLBox::__DrawItem(
    IN LPDRAWITEMSTRUCT lpDIS
    )
/*++

Routine Description:

    Draw an item.  This will draw the focus and selection state, and then
    call out to the derived class to draw the item.

Arguments:

    LPDRAWITEMSTRUCT lpDIS : The drawitem structure

Return Value:

    None

--*/
{
    //
    // Need to attach resources before creation/adding items
    //
    ASSERT_PTR(m_pResources);

    CDC * pDC = CDC::FromHandle(lpDIS->hDC);

#ifdef _DEBUG

    pDC->AssertValid();

#endif // _DEBUG

    //
    // Draw focus rectangle when no items in listbox
    //
    if(lpDIS->itemID == (UINT)-1)
    {
        if(lpDIS->itemAction & ODA_FOCUS)
        {
            //
            // rcItem.bottom seems to be 0 for variable height list boxes
            //
            lpDIS->rcItem.bottom = m_lfHeight;
            pDC->DrawFocusRect(&lpDIS->rcItem);
        }

        return;
    }
    else
    {
        BOOL fSelChange   = (lpDIS->itemAction & ODA_SELECT) != 0;
        BOOL fFocusChange = (lpDIS->itemAction & ODA_FOCUS) != 0;
        BOOL fDrawEntire  = (lpDIS->itemAction & ODA_DRAWENTIRE) != 0;

        if(fSelChange || fDrawEntire)
        {
            BOOL fSel = (lpDIS->itemState & ODS_SELECTED) != 0;

            COLORREF hlite   = (fSel ? (m_pResources->ColorHighlight())
                                     : (m_pResources->ColorWindow()));
            COLORREF textcol = (fSel ? (m_pResources->ColorHighlightText())
                                     : (m_pResources->ColorWindowText()));
            pDC->SetBkColor(hlite);
            pDC->SetTextColor(textcol);

            //
            // fill the rectangle with the background colour.
            //
            pDC->ExtTextOut(0, 0, ETO_OPAQUE, &lpDIS->rcItem, NULL, 0, NULL);

            CRMCListBoxDrawStruct ds(pDC,
                (RECT *)&lpDIS->rcItem,
                fSel,
                (DWORD_PTR)lpDIS->itemData,
                lpDIS->itemID,
                m_pResources
                );

            //
            // Now call the draw function of the derived class
            //
            DrawItemEx(ds);
        }

        if (fFocusChange || (fDrawEntire && (lpDIS->itemState & ODS_FOCUS)))
        {
            pDC->DrawFocusRect(&lpDIS->rcItem);
        }
    }
}



void
CODLBox::__MeasureItem(
    IN OUT LPMEASUREITEMSTRUCT lpMIS
    )
/*++

Routine Description:

    Provide dimensions of given item

Arguments:

    LPMEASUREITEMSTRUCT lpMIS : Measure item structure

Return Value:

    None

--*/
{
    ASSERT_PTR(m_pResources);

//    int h = lpMIS->itemHeight;
    int ch = TextHeight();
    int bmHeight = m_pResources->BitmapHeight();

    lpMIS->itemHeight = ch < bmHeight ? bmHeight : ch;
}



CRMCListBoxHeader::CRMCListBoxHeader(
    IN DWORD dwStyle
    )
/*++

Routine Description:

    Constructor.

Arguments:

    DWORD dwStyle : Style bits

Return Value:

    N/A

--*/
    : m_pHCtrl(NULL),
      m_pListBox(NULL),
      m_dwStyle(dwStyle),
      m_fRespondToColumnWidthChanges(TRUE)
{
    m_pHCtrl = new CHeaderCtrl;
}



CRMCListBoxHeader::~CRMCListBoxHeader()
/*++

Routine Description:

    Destructor.

Arguments:

    N/A

Return Value:

    N/A

--*/
{
    //
    // Kill the header control and the
    // font
    //
    if (m_pHCtrl)
    {
        delete m_pHCtrl;
    }

    //
    // Leave the listbox pointer alone, as we don't
    // own it, but are merely associated with it.
    //
}

//
// Message Map
//
BEGIN_MESSAGE_MAP(CRMCListBoxHeader, CStatic)
    //{{AFX_MSG_MAP(CRMCListBoxHeader)
    ON_WM_DESTROY()
    //}}AFX_MSG_MAP

    ON_NOTIFY_RANGE(HDN_ENDTRACK,    0, 0xFFFF, OnHeaderEndTrack)
    ON_NOTIFY_RANGE(HDN_ITEMCHANGED, 0, 0xFFFF, OnHeaderItemChanged)
    ON_NOTIFY_RANGE(HDN_ITEMCLICK,   0, 0xFFFF, OnHeaderItemClick)

END_MESSAGE_MAP()



void
CRMCListBoxHeader::OnDestroy()
/*++

Routine Description:

    WM_DESTROY message handler.  When the control is being destroyed,
    also destroy the invisible static control.

Arguments:

    None

Return Value:

    None

--*/
{
    //
    // Destroy optional header control
    //
    if (m_pHCtrl)
    {
        m_pHCtrl->DestroyWindow();
    }

    CStatic::OnDestroy();
}



BOOL
CRMCListBoxHeader::Create(
    IN DWORD dwStyle,
    IN const RECT & rect,
    IN CWnd * pParentWnd,
    IN CHeaderListBox * pListBox,
    IN UINT nID
    )
/*++

Routine Description:

    Create the control.  This will first create an invisible static window,
    which is to take up the entire area of the listbox.  This static window
    then will be the parent to the listbox as well as this header control.

Arguments:

    DWORD dwStyle              : Creation style bits
    const RECT & rect          : Rectangle in which the header is to be created
    CWnd * pParentWnd          : Parent window
    CHeaderListBox * pListBox  : Associated listbox
    UINT nID                   : Control ID of the header

Return Value:

    TRUE for success, FALSE for failure

--*/
{
    //
    // Make sure the real header control exists by now
    //
    if (m_pHCtrl == NULL)
    {
        return FALSE;
    }

    //
    // Make sure there's an associated listbox
    //
    m_pListBox = pListBox;
    if (m_pListBox == NULL)
    {
        return FALSE;
    }

    //
    // Create the controlling static window as do-nothing window
    //
    if (!CStatic::Create(NULL, WS_VISIBLE | SS_BITMAP | WS_CHILD,
        rect, pParentWnd, 0xFFFF))
    {
        return FALSE;
    }

    //
    // Now create the header control. Its parent
    // window is this static control we just created
    //
    CRect rc(0, 0, 0 ,0);
    dwStyle |= (UseButtons() ? HDS_BUTTONS : 0L);
    VERIFY(m_pHCtrl->Create(dwStyle, rc, this, nID));

    //
    // Place header control as per style bits,
    // compute the desired layout, and move it
    //
    HD_LAYOUT hdl;
    WINDOWPOS wp;

    GetClientRect(&rc);
    hdl.prc = &rc;
    hdl.pwpos = &wp;

    m_pHCtrl->Layout(&hdl);
    m_pHCtrl->SetWindowPos(m_pListBox, wp.x, wp.y,
        wp.cx, wp.cy, wp.flags | SWP_SHOWWINDOW);

    //
    // And move our associated listbox just below it
    //
    ::GetDlgCtlRect(GetParent()->m_hWnd, m_pListBox->m_hWnd, &rc);
    rc.top += wp.cy - 1;

    //
    // Adjust if header is bigger than the entire listbox
    //
    if (rc.top > rc.bottom)
    {
        rc.top = rc.bottom;
    }
    // Fix for theme support. Make listbox and header children of the same static control
    m_pListBox->SetParent(this);
    GetParent()->ClientToScreen(&rc);
    ScreenToClient(&rc);
    m_pListBox->MoveWindow(rc.left, rc.top, rc.Width(), rc.Height());

    //
    // Make sure the header uses the right font
    //
    m_pHCtrl->SetFont(
        CFont::FromHandle((HFONT)::GetStockObject(DEFAULT_GUI_FONT)),
        FALSE
        );

    return TRUE;
}



void
CRMCListBoxHeader::OnHeaderEndTrack(
    IN  UINT nId,
    IN  NMHDR * pnmh,
    OUT LRESULT * pResult
    )
/*++

Routine Description:

    User has finished dragging the column divider.  If we're supposed to ensure
    that the last column is a stretch column, turn off the redraw now -- it
    will get turned back on after the column width changes have all been
    completed.  This will reduce the flash effect.

Arguments:

    UINT nId          : Control ID
    NMHDR * pnmh      : Notification header structure
    LRESULT * pResult : Result.  Will be set to 0 if the message was handled

Return Value:

    None (handled in pResult)

--*/
{
   pnmh;
   nId;

    if (DoesRespondToColumnWidthChanges() && UseStretch())
    {
        //
        // This will get turned back on in OnHeaderItemChanged
        //
        SetRedraw(FALSE);
    }

    *pResult = 0;
}



void
CRMCListBoxHeader::SetColumnWidth(
    IN int nCol,
    IN int nWidth
    )
/*++

Routine Description:

    Set the given column to the given width

Arguments:

    int nCol        : Column number
    int nWidth      : New width

Return Value:

    None

--*/
{
    ASSERT(nCol < QueryNumColumns());

    if (nCol >= QueryNumColumns())
    {
        return;
    }

    TRACEEOLID("Setting width of column  " << nCol << " to " << nWidth);

    HD_ITEM hdItem;

    hdItem.mask = HDI_WIDTH;
    hdItem.cxy = nWidth;
    VERIFY(SetItem(nCol, &hdItem));
}



void
CRMCListBoxHeader::OnHeaderItemChanged(
    IN  UINT nId,
    IN  NMHDR *pnmh,
    OUT LRESULT *pResult
    )
/*++

Routine Description:

    Handle change in header column width.  Note: we're actually tracking
    the HDN_ITEMCHANGED notification, not the HDN_ENDDRAG one, because
    the latter is sent out before the column widths in the structure have
    changed.

Arguments:

    UINT nId          : Control ID
    NMHDR * pnmh      : Notification header structure
    LRESULT * pResult : Result.  Will be set to 0 if the message was handled

Return Value:

    None (handled in pResult)

--*/
{
   nId;
    //
    // Adjust tabs in associate listbox if
    // column widths have changed
    //
    HD_NOTIFY * pNotify = (HD_NOTIFY *)pnmh;
    if (DoesRespondToColumnWidthChanges() && pNotify->pitem->mask & HDI_WIDTH)
    {
        ASSERT_PTR(m_pListBox);

        //
        // Stretch the last column
        //
        if (UseStretch())
        {
            //
            // Turn this off, as we don't want
            // to get in an infinite loop
            //
            RespondToColumnWidthChanges(FALSE);

            //
            // Compute available space
            //
            CRect rc;
            GetClientRect(&rc);

            //
            // See how much is taken up by preceding
            // columns
            //
            int nTotalWidth = 0;
            int cColumns = QueryNumColumns();
            int nLastCol = cColumns - 1;
            ASSERT(nLastCol >= 0);

            for (int nCol = 0; nCol < nLastCol; ++nCol)
            {
                int nWidth = GetColumnWidth(nCol);

                //
                // Each column must be at least one pixel wide
                //
                int nMaxWidth = rc.Width() - nTotalWidth - (nLastCol - nCol);
                if (nWidth > nMaxWidth)
                {
                    nWidth = nMaxWidth;
                    SetColumnWidth(nCol, nWidth);
                }

                nTotalWidth += nWidth;
            }

            //
            // Make sure the last column takes up the rest
            //
            if (rc.Width() > nTotalWidth)
            {
                SetColumnWidth(nLastCol, rc.Width() - nTotalWidth);
            }

            //
            // Turn this back on again
            //
            RespondToColumnWidthChanges(TRUE);

            //
            // Redraw will have been turned off in
            // OnHeaderEndTrack, now that all column
            // movement has completed, turn it back
            // on to draw the control in its current
            // state.
            //
            SetRedraw(TRUE);
            Invalidate();
        }

        //
        // Recompute tabs on associate listbox,
        // and force redraw on it.
        //
        m_pListBox->SetRedraw(FALSE);
        SetTabsFromHeader();
        m_pListBox->SetRedraw(TRUE);
        m_pListBox->Invalidate();
    }

    *pResult = 0;
}



void
CRMCListBoxHeader::OnHeaderItemClick(
    IN  UINT nId,
    IN  NMHDR *pnmh,
    OUT LRESULT *pResult
    )
/*++

Routine Description:

    A button has been clicked in the header control.  Pass it on
    to the real parent window.

Arguments:

    UINT nId          : Control ID
    NMHDR * pnmh      : Notification header structure
    LRESULT * pResult : Result.  Will be set to 0 if the message was handled

Return Value:

    None (handled in pResult)

--*/
{
    //
    // Pass notification on to parent
    //
    ASSERT(GetParent());
    GetParent()->SendMessage(WM_NOTIFY, (WPARAM)nId, (LPARAM)pnmh);
    *pResult = 0;
}



void
CRMCListBoxHeader::SetTabsFromHeader()
/*++

Routine Description:

    Set the tabs (which are cumulative) from the header control
    columns (which are not)

Arguments:

    None

Return Value:

    None

--*/
{
    //
    // Must have the same number of tabs
    // as header columns
    //
    ASSERT_PTR(m_pListBox);
    ASSERT(GetItemCount() == m_pListBox->NumTabs());

    int nTab = 0;
    for (int n = 0; n < m_pListBox->NumTabs(); ++n)
    {
        m_pListBox->SetTab(n, nTab += GetColumnWidth(n));
    }
}



int
CRMCListBoxHeader::GetItemCount() const
/*++

Routine Description:

    Get the number of items in the header

Arguments:

    None

Return Value:

    The number of items in the header (e.g. the number of columns)

--*/
{
    ASSERT_PTR(m_pHCtrl);
    return m_pHCtrl->GetItemCount();
}



BOOL
CRMCListBoxHeader::GetItem(
    IN  int nPos,
    OUT HD_ITEM * pHeaderItem
    ) const
/*++

Routine Description:

    Get information on specific position (column index)

Arguments:

    int nPos              : Column index
    HD_ITEM * pHeaderItem : Header item information

Return Value:

    TRUE for success, FALSE for failure (bad column index)

--*/
{
    ASSERT_PTR(m_pHCtrl);
    return m_pHCtrl->GetItem(nPos, pHeaderItem);
}



int
CRMCListBoxHeader::GetColumnWidth(
    IN int nPos
    ) const
/*++

Routine Description:

    Get column width of a specific column

Arguments:

    int nPos : Column index

Return Value:

    The column width of the given colum, or -1 in case of failure (bad
    column index)

--*/
{
    HD_ITEM hi;

    hi.mask = HDI_WIDTH;
    if (GetItem(nPos, &hi))
    {
        return hi.cxy;
    }

    return -1;
}



BOOL
CRMCListBoxHeader::SetItem(
    IN int nPos,
    IN HD_ITEM * pHeaderItem
    )
/*++***

Routine Description:

    Set information on specific position (column index)

Arguments:

    int nPos              : Column index
    HD_ITEM * pHeaderItem : Header item information

Return Value:

    TRUE for success, FALSE for failure (bad column index)

--*/
{
    ASSERT_PTR(m_pHCtrl);
    ASSERT_PTR(m_pListBox);

    if (!m_pHCtrl->SetItem(nPos, pHeaderItem))
    {
        return FALSE;
    }

    if (pHeaderItem->mask & HDI_WIDTH)
    {
        SetTabsFromHeader();
    }

    return TRUE;
}



int
CRMCListBoxHeader::InsertItem(
    IN int nPos,
    IN HD_ITEM * pHeaderItem
    )
/*++

Routine Description:

    insert information in specific position (column index)

Arguments:

    int nPos              : Column index
    HD_ITEM * pHeaderItem : Header item information

Return Value:

    The new index, or -1 in case of failure.

--*/
{
    ASSERT_PTR(m_pHCtrl);
    ASSERT_PTR(m_pListBox);

    int nCol = m_pHCtrl->InsertItem(nPos, pHeaderItem);
    if (nCol != -1)
    {
        //
        // Set 0-width tab, as tabs get recomputed anyway
        //
        m_pListBox->InsertTab(nPos, 0);
        SetTabsFromHeader();
    }

    return nCol;
}



BOOL
CRMCListBoxHeader::DeleteItem(
    IN int nPos
    )
/*++

Routine Description:

    Delete the given item (i.e. column)

Arguments:

    int nPos              : Column index

Return Value:

    TRUE for success, FALSE for failure (bad column index)

--*/
{
    ASSERT_PTR(m_pHCtrl);
    ASSERT_PTR(m_pListBox);

    if (!m_pHCtrl->DeleteItem(nPos))
    {
        return FALSE;
    }

    m_pListBox->RemoveTab(nPos, 1);

    return TRUE;
}



IMPLEMENT_DYNAMIC(CRMCListBoxHeader, CStatic);



CRMCListBox::CRMCListBox()
/*++

Routine Description:

    Constructor

Arguments:

    None

Return Value:

    N/A

--*/
    : m_fInitialized(FALSE),
      m_fMultiSelect(FALSE)
{
}



CRMCListBox::~CRMCListBox()
/*++

Routine Description:

    Destructor

Arguments:

    N/A

Return Value:

    N/A

--*/
{
}



//
// Message Map
//
BEGIN_MESSAGE_MAP(CRMCListBox, CListBox)
    //{{AFX_MSG_MAP(CRMCListBox)
    ON_WM_CREATE()
    ON_WM_DESTROY()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()



/* virtual */
BOOL
CRMCListBox::Initialize()
/*++

Routine Description:

    This function should be called directly when subclassing an existing
    listbox, otherwise OnCreate will take care of it.

Arguments:

    None

Return Value:

    TRUE for success, FALSE for failure

--*/
{
    //
    // Make sure we're only initialized once
    //
    if (m_fInitialized)
    {
        return TRUE;
    }

    //
    // Ensure the base class knows our window
    // handle
    //
    AttachWindow(this);

    if (!CODLBox::Initialize())
    {
        return FALSE;
    }

    m_fInitialized = TRUE;

    DWORD dwStyle = GetStyle();
    m_fMultiSelect = (dwStyle & (LBS_EXTENDEDSEL | LBS_MULTIPLESEL)) != 0;

    return m_fInitialized;
}



void
CRMCListBox::MeasureItem(
    IN LPMEASUREITEMSTRUCT lpMIS
    )
/*++

Routine Description:

    CListBox override to ODL base class

Arguments:

    LPMEASUREITEMSTRUCT lpMIS : Measure item structure

Return Value:

    None

--*/
{
    CODLBox::__MeasureItem(lpMIS);
}



void
CRMCListBox::DrawItem(
    IN LPDRAWITEMSTRUCT lpDIS
    )
/*++

Routine Description:

    CListBox override to ODL base class

Arguments:

    LPDRAWITEMSTRUCT lpDIS : Drawing item structure

Return Value:

    None

--*/
{
    CODLBox::__DrawItem(lpDIS);
}



/* virtual */
void
CRMCListBox::DrawItemEx(
    IN CRMCListBoxDrawStruct & dw
    )
/*++

Routine Description:

    Do-nothing extended draw function, which should
    be provided by the derived class.  This one will
    ASSERT, and should never be called.

Arguments:

    CRMCListBoxDrawStruct & dw   : Draw Structure

Return Value:

    None

--*/
{
   dw;
    ASSERT_MSG("Derived class did not provide DrawItemEx");
}



/* virtual */
int
CRMCListBox::__GetCount() const
/*++

Routine Description:

    Provide GetCount() to ODL base class

Arguments:

    None

Return Value:

    Count of items in the listbox

--*/
{
    return GetCount();
}



/* virtual */
int
CRMCListBox::__SetItemHeight(
    IN int nIndex,
    IN UINT cyItemHeight
    )
/*++

Routine Description:

    Provide SetItemHeight() to ODL base class

Arguments:

    None

Return Value:

    LB_ERR if the index or height is invalid.

--*/
{
    return SetItemHeight(nIndex, cyItemHeight);
}



int
CRMCListBox::OnCreate(
    IN LPCREATESTRUCT lpCreateStruct
    )
/*++

Routine Description:

    Listbox is being created

Arguments:

    LPCREATESTRUCT lpCreateStruct : Creation structure

Return Value:

    -1 for failure, 0 for success

--*/
{
    if (CListBox::OnCreate(lpCreateStruct) == -1)
    {
        return -1;
    }

    Initialize();

    return 0;
}



int
CRMCListBox::GetCurSel() const
/*++

Routine Description:

    Get the index of the current selected item

Arguments:

    None

Return Value:

    On multi-selection listbox, it will return
    the index of an item, iff that is the only
    item selected.

    On single-selection listbox, it behaves as
    normal.

--*/
{
    if (IsMultiSelect())
    {
        //
        // We only like it if one item is selected
        //
        int nCurSel = LB_ERR;

        if (CListBox::GetSelCount() == 1)
        {
            if (CListBox::GetSelItems(1, &nCurSel) != 1)
            {
                nCurSel = LB_ERR;
            }
        }

        return nCurSel;
    }

    //
    // Single select listbox
    //
    return CListBox::GetCurSel();
}



int
CRMCListBox::SetCurSel(
    IN int nSelect
    )
/*++

Routine Description:

    Select an item.  On a multi-select listbox,
    this will deselect everything except the given
    item.

Arguments:

    int nSelect     : Index of the item to be selected, or
                      -1 to reset all selections.

Return Value:

    LB_ERR in case of error.

--*/
{
    if (IsMultiSelect())
    {
        //
        // Reset all selections
        //
        int nReturn = SelItemRange(FALSE, 0, GetCount() - 1);

        if (nSelect >= 0)
        {
            //
            // Ensure item is visible
            //
            nReturn = CListBox::SetSel(nSelect, TRUE);
            CListBox::SetCaretIndex(nSelect, 0);
        }

        return nReturn;
    }

    return CListBox::SetCurSel(nSelect);
}



int
CRMCListBox::GetSel(
    IN int nSel
    ) const
/*++

Routine Description:

    Determine if the given item is selected or not
    Works for both single and multi-select listboxes

Arguments:

    int nSel        : Item whose state to check

Return Value:

    LB_ERR in case of error, 0 if the item in question
    is not selected, a positive number if it is.

--*/
{
    if (IsMultiSelect())
    {
        return CListBox::GetSel(nSel);
    }

    //
    // Some magic for single select
    //
    if (nSel < 0 || nSel >= CListBox::GetCount())
    {
        return LB_ERR;
    }

    return nSel == CListBox::GetCurSel()
        ? TRUE
        : FALSE;
}



int
CRMCListBox::GetSelCount() const
/*++

Routine Description:

    Return count of selected items.  Works for both
    single and multi select (in the former case,
    it will return zero or one only)

Arguments:

    None

Return Value:

    Count of selected items

--*/
{
    if (IsMultiSelect())
    {
        return CListBox::GetSelCount();
    }

    return GetCurSel() != LB_ERR ? 1 : 0;
}



void *
CRMCListBox::GetSelectedListItem(
    OUT int * pnSel     OPTIONAL
    )
/*++

Routine Description:

    Return the single selected item in the list or NULL

Arguments:

    int * pnSel     : Optionally returns the selected index

Returns:

    The currently selected (single) item, or NULL
    if 0 or more than one items is selected.  Works for
    both multi-select and single select.

--*/
{
    void * pItem = NULL;

    int nCurSel = GetCurSel();
    if (nCurSel >= 0)
    {
        //
        // Get item properties
        //
        pItem = GetItemDataPtr(nCurSel);
        if (pnSel)
        {
            *pnSel = nCurSel;
        }
    }

    return pItem;
}



void *
CRMCListBox::GetNextSelectedItem(
    IN OUT int * pnStartingIndex
    )
/*++

Routine Description:

    Return the next selected item starting at a specific
    index.

Arguments:

    int *pnStartingIndex          : Starting index (>= 0)

Return Value:

    Pointer to next selected item, or NULL if there are
    none left.

    The starting index will be updated to reflect the current
    index, LB_ERR if no more selected items remain.

--*/
{
    ASSERT_READ_WRITE_PTR(pnStartingIndex);

    if (!pnStartingIndex)
    {
        return NULL;
    }

    ASSERT(*pnStartingIndex >= 0);

    if (*pnStartingIndex < 0)
    {
        *pnStartingIndex = 0;
    }

    if (IsMultiSelect())
    {
        //
        // Multi-select -- loop through
        // until found
        //
        BOOL fFoundItem = FALSE;

        while (*pnStartingIndex < GetCount())
        {
            if (CListBox::GetSel(*pnStartingIndex) > 0)
            {
                ++fFoundItem;
                break;
            }

            ++(*pnStartingIndex);
        }

        if (!fFoundItem)
        {
            *pnStartingIndex = LB_ERR;
        }
    }
    else
    {
        //
        // Single select listbox, so there's no
        // looping through -- either the selected item
        // (if any) is in range or it isn't.
        //
        int nCurSel = CListBox::GetCurSel();
        *pnStartingIndex = (nCurSel >= *pnStartingIndex) ? nCurSel : LB_ERR;
    }

    return (*pnStartingIndex != LB_ERR)
        ? GetItemDataPtr(*pnStartingIndex)
        : NULL;
}



BOOL
CRMCListBox::SelectItem(
    IN void * pItemData
    )
/*++

Routine Description:

    Select the listbox item with the given data pointer

Arguments:

    void * pItemData : Item to search for

Return Value:

    TRUE if the item was found and selected, FALSE otherwise

Notes:

    On a multi-select listbox, this will unselect
    all other items in the listbox.

--*/
{
    if (pItemData != NULL)
    {
        for (int n = 0; n < GetCount(); ++n)
        {
            if (pItemData == GetItemDataPtr(n))
            {
                SetCurSel(n);

                return TRUE;
            }
        }
    }

    if (!IsMultiSelect())
    {
        //
        // Set no selection
        //
        SetCurSel(-1);
    }

    return FALSE;
}



void
CRMCListBox::InvalidateSelection(
    IN int nSel
    )
/*++

Routine Description:

    Force a repaint of the given selection

Arguments:

    int nSel : Index of the item to be repainted

Return Value:

    None

--*/
{
    CRect rc;

    if (GetItemRect(nSel, &rc) != LB_ERR)
    {
        InvalidateRect(&rc, TRUE);
    }
}



IMPLEMENT_DYNAMIC(CRMCListBox,CListBox);



CHeaderListBox::CHeaderListBox(
    IN DWORD dwStyle,
    IN LPCTSTR lpRegKey OPTIONAL
    )
/*++

Routine Description:

    Constructor

Arguments:

    DWORD   dwStyle  : Style bits (see HLS_*)
    LPCTSTR lpRegKey : If specified, the registry key where the column
                       sizes will be stored.

Return Value:

    None

--*/
    : m_strRegKey(),
      m_fInitialized(FALSE)
{
    m_pHeader = new CRMCListBoxHeader(dwStyle);
    if (lpRegKey)
    {
        GenerateRegistryKey(m_strRegKey, lpRegKey);
    }
}



CHeaderListBox::~CHeaderListBox()
/*++

Routine Description:

    Destructor

Arguments:

    N/A

Return Value:

    N/A

--*/
{
    //
    // Clean up header control
    //
    ASSERT_PTR(m_pHeader);

    if (m_pHeader != NULL)
    {
        delete m_pHeader;
    }
}



//
// Message map
//
BEGIN_MESSAGE_MAP(CHeaderListBox, CRMCListBox)
    //{{AFX_MSG_MAP(CHeaderListBox)
    ON_WM_CREATE()
    ON_WM_DESTROY()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()



/* virtual */
BOOL
CHeaderListBox::Initialize()
/*++

Routine Description:

    This function should be called directly when subclassing an existing
    listbox, otherwise OnCreate will take care of it, and this function
    should not be called

Arguments:

    None

Return Value:

    TRUE for success, FALSE for failure

--*/
{
    //
    // Make sure we're only initialized once
    //
    if (m_fInitialized)
    {
        return TRUE;
    }

    if (!CRMCListBox::Initialize())
    {
        return FALSE;
    }

    //
    // Create header control
    //
    ASSERT_PTR(m_pHeader);

    if (m_pHeader)
    {
        TRACEEOLID("Creating Header");

        //
        // Create it in our location exactly
        //
        CRect rc;
        ::GetDlgCtlRect(GetParent()->m_hWnd, m_hWnd, &rc);

        //
        // Make sure the header control shares the same parent
        // as we do,
        //
        ASSERT(GetParent());

        #ifndef CCS_NOHILITE
        #define CCS_NOHILITE 0x00000010L
        #endif

        DWORD dwStyle = WS_VISIBLE | CCS_TOP | CCS_NODIVIDER | WS_BORDER
            | HDS_HORZ;

        if (!m_pHeader->Create(dwStyle, rc, GetParent(), this, 0xFFFF))
        {
            return FALSE;
        }
    }

    m_fInitialized = TRUE;

    return TRUE;
}



int
CHeaderListBox::QueryColumnWidth(
    IN int nCol
    ) const
/*++

Routine Description:

    Get the width of the specified column

Arguments:

    int nCol : The column

Return Value:

    The width of the column, or -1 if the column index was out of range

--*/
{
    ASSERT(nCol < QueryNumColumns());

    if (nCol >= QueryNumColumns())
    {
        return -1;
    }

    HD_ITEM hdItem;

    hdItem.mask = HDI_WIDTH;
    VERIFY(GetHeaderItem(nCol, &hdItem));

    return hdItem.cxy;
}



BOOL
CHeaderListBox::SetColumnWidth(
    IN int nCol,
    IN int nWidth
    )
/*++

Routine Description:

    Set the width of the specified column

Arguments:

    int nCol   : The column
    int nWidth : New width

Return Value:

    TRUE for success, FALSE for failure

--*/
{
    ASSERT(nCol < QueryNumColumns());

    if (nCol >= QueryNumColumns())
    {
        return FALSE;
    }

    TRACEEOLID("Setting width of column  " << nCol << " to " << nWidth);

    HD_ITEM hdItem;
    hdItem.mask = HDI_WIDTH;
    hdItem.cxy = nWidth;
    VERIFY(SetHeaderItem(nCol, &hdItem));

    return TRUE;
}



BOOL
CHeaderListBox::SetWidthsFromReg()
/*++

Routine Description:

    Attempt to set the column widths from the registry
    value we were initialized with.

Arguments:

    None

Return Value:

    TRUE if the column widths were succesfully set from the registry,
    FALSE otherwise

--*/
{
    if (m_strRegKey.IsEmpty())
    {
        //
        // No reg key specified
        //
        return FALSE;
    }

    //
    // Try to read the current column sizes from the registry
    //
    CRegKey rkUser;
    if (ERROR_SUCCESS != rkUser.Create(HKEY_CURRENT_USER, m_strRegKey))
    {
        //
        // Path doesn't exist -- no problem.
        //
        return FALSE;
    }

    //
    // Don't auto adjust
    //
    m_pHeader->RespondToColumnWidthChanges(FALSE);

    CRect rc;
    m_pHeader->GetClientRect(&rc);

    CError err;

    try
    {
        TCHAR buf[MAX_PATH];
        DWORD count = MAX_PATH;
        int nTotalWidth = 0;

        err = rkUser.QueryValue(buf, g_szRegColumns, &count);

        if (err.Succeeded() && lstrlen(buf) > 0)
        {
            LPTSTR lpstrValue = buf;
            LPTSTR lpWidth = _tcstok(lpstrValue, g_szColValueSep);

            for (int n = 0; n < QueryNumColumns(); ++n)
            {
                ASSERT_PTR(lpWidth);

                if (lpWidth == NULL)
                {
                    err = ERROR_INVALID_PARAMETER;
                    break;
                }

                //
                // Sanity check
                //
                int nWidth = _ttoi(lpWidth);
                if (nWidth <= 0 || (nTotalWidth + nWidth > rc.Width()))
                {
                    ASSERT_MSG("column width invalid");

                    return FALSE;
                }

                nTotalWidth += nWidth;

                VERIFY(SetColumnWidth(n, nWidth));

                lpWidth = _tcstok(NULL, g_szColValueSep);
            }
        }
    }
    catch(CMemoryException * e)
    {
        err = ERROR_NOT_ENOUGH_MEMORY;
        e->Delete();
    }
    //
    // Turn auto-adjust back on
    //
    m_pHeader->RespondToColumnWidthChanges(TRUE);

//    if (err.Win32Error() == ERROR_FILE_NOT_FOUND)
//    {
//       // No problem, it is first run. We will set defaults.
//       return err;
//    }
    return err;
}



void
CHeaderListBox::DistributeColumns()
/*++

Routine Description:

    Proportion the column widths of over the entire width of the
    header control while maintaining relative proportions.

Arguments:

    None

Return Value:

    None

--*/
{
    //
    // Obtain available width
    //
    ASSERT_PTR(m_pHeader);

    CRect rc;
    m_pHeader->GetClientRect(&rc);

    //
    // Get current total width
    //
    int nTotalWeight = 0;
    int nCol;
    for (nCol = 0; nCol < QueryNumColumns(); ++nCol)
    {
        nTotalWeight += QueryColumnWidth(nCol);
    }

    //
    // And spread out the width, maintaining the same
    // proportions
    //

    //
    // Temporarily ignore changes
    //
    m_pHeader->RespondToColumnWidthChanges(FALSE);
    int cColumns = QueryNumColumns();

    for (nCol = 0; nCol < cColumns; ++nCol)
    {
        int nWidth = QueryColumnWidth(nCol);
        nWidth = rc.Width() * nWidth / nTotalWeight;
        VERIFY(SetColumnWidth(nCol, nWidth));
    }

    //
    // Turn changes back on
    //
    m_pHeader->RespondToColumnWidthChanges(TRUE);
}



int
CHeaderListBox::InsertColumn(
    IN int nCol,
    IN int nWeight,
    IN UINT nStringID,
    IN HINSTANCE hResInst
    )
/*++

Routine Description:

    Insert column.  The width of the column is actually a relative
    "weight" of the column which needs to be adjusted later.  The
    return value is the column number or -1 if the column is not inserted.

Arguments:

    int nCol        : Column number
    int nWeight     : Relative weight of column
    UINT nStringID  : Resource string ID

Return Value:

    Index of the column, or -1 in case of failure

--*/
{
    CString strColName;
    HD_ITEM hdItem;

    HINSTANCE hInst = AfxGetResourceHandle();
    AfxSetResourceHandle(hResInst);
    VERIFY(strColName.LoadString(nStringID));
    AfxSetResourceHandle(hInst);

    hdItem.mask = HDI_FORMAT | HDI_WIDTH | HDI_TEXT;
    hdItem.fmt = HDF_STRING | HDF_LEFT;
    hdItem.pszText = (LPTSTR)(LPCTSTR)strColName;
    hdItem.cchTextMax = strColName.GetLength();
    hdItem.cxy = nWeight;

    return InsertHeaderItem(nCol, &hdItem);
}



int
CHeaderListBox::OnCreate(
    IN LPCREATESTRUCT lpCreateStruct
    )
/*++

Routine Description:

    Listbox is being created

Arguments:

    LPCREATESTRUCT lpCreateStruct : Creation structure

Return Value:

    0 for success, -1 for failure

--*/
{
    if (CRMCListBox::OnCreate(lpCreateStruct) == -1)
    {
        return -1;
    }

    Initialize();

    return 0;
}



BOOL
CHeaderListBox::EnableWindow(
    IN BOOL bEnable
    )
/*++

Routine Description:

    Enable/disable the control.

Arguments:

    BOOL bEnable : TRUE to enable the control, FALSE to disable

Return Value:

    Indicates the state before the EnableWindow member function was called.
    The return value is nonzero if the window was previously disabled. The
    return value is 0 if the window was previously enabled or an error
    occurred.

--*/
{
    if (m_pHeader)
    {
        m_pHeader->EnableWindow(bEnable);
    }

    return CRMCListBox::EnableWindow(bEnable);
}



BOOL
CHeaderListBox::ShowWindow(
    IN int nCmdShow
    )
/*++

Routine Description:

    Show/hide the window

Arguments:

    int nCmdShow : SW_ flag such as SW_SHOW or SW_HIDE

Return Value:

    If the window was previously visible, the return value is TRUE. If the
    window was previously hidden, the return value is FALSE.

--*/
{
    if (m_pHeader)
    {
        m_pHeader->ShowWindow(nCmdShow);
    }

    return CRMCListBox::ShowWindow(nCmdShow);
}



void
CHeaderListBox::OnDestroy()
/*++

Routine Description:

    Handle destruction of the control

Arguments:

    None

Return Value:

    None

--*/
{
    //
    // Destroy optional header control
    //
    ASSERT_PTR(m_pHeader);

    if (m_pHeader)
    {
        if (!m_strRegKey.IsEmpty())
        {
            //
            // Try to write the current column sizes to the registry
            //
            CError err;

            CRegKey rkUser;
            
            rkUser.Create(HKEY_CURRENT_USER, m_strRegKey);

            int nWidth;
            TCHAR szValue[32];
            CString strValue;

            try
            {
                for (int n = 0; n < GetHeaderItemCount(); ++n)
                {
                    if (n > 0)
                    {
                        //
                        // Put in field separator
                        //
                        strValue += g_szColValueSep;
                    }

                    nWidth = m_pHeader->GetColumnWidth(n);
                    strValue += ::_itot(nWidth, szValue, 10);
                }

                err = rkUser.SetValue(strValue, g_szRegColumns);
            }
            catch(CMemoryException * e)
            {
                err = ERROR_NOT_ENOUGH_MEMORY;
                e->Delete();
            }

            err.MessageBoxOnFailure();
        }

        m_pHeader->DestroyWindow();
    }

    CRMCListBox::OnDestroy();
}



IMPLEMENT_DYNAMIC(CHeaderListBox, CRMCListBox);



CRMCComboBox::CRMCComboBox()
/*++

Routine Description:

    Constructor

Arguments:

    None

Return Value:

    N/A

--*/
    : m_fInitialized(FALSE)
{
}



CRMCComboBox::~CRMCComboBox()
/*++

Routine Description:

    Destructor

Arguments:

    N/A

Return Value:

    N/A

--*/
{
}



//
// Message Map
//
BEGIN_MESSAGE_MAP(CRMCComboBox, CComboBox)
    //{{AFX_MSG_MAP(CRMCComboBox)
    ON_WM_CREATE()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()




/* virtual */
BOOL
CRMCComboBox::Initialize()
/*++

Routine Description:

    This function should be called directly when subclassing an existing
    combobox, otherwise OnCreate will take care of it.

Arguments:

    None

Return Value:

    TRUE for success, FALSE for failure

--*/
{
    //
    // Make sure we're only initialized once
    //
    if (m_fInitialized)
    {
        return TRUE;
    }

    //
    // Ensure the base class knows our window
    // handle
    //
    AttachWindow(this);

    if (!CODLBox::Initialize())
    {
        return FALSE;
    }

    m_fInitialized = TRUE;

    return TRUE;
}



void
CRMCComboBox::MeasureItem(
    IN LPMEASUREITEMSTRUCT lpMIS
    )
/*++

Routine Description:

    CComboBox override to ODL base class

Arguments:

    LPMEASUREITEMSTRUCT lpMIS : Measure item structure

Return Value:

    None

--*/
{
    CODLBox::__MeasureItem(lpMIS);
}



void
CRMCComboBox::DrawItem(
    IN LPDRAWITEMSTRUCT lpDIS
    )
/*++

Routine Description:

    CListBox override to ODL base class

Arguments:

    LPDRAWITEMSTRUCT lpDIS : Drawing item structure

Return Value:

    None

--*/
{
    CODLBox::__DrawItem(lpDIS);
}



/* virtual */
void
CRMCComboBox::DrawItemEx(
    IN CRMCListBoxDrawStruct & dw
    )
/*++

Routine Description:

    Do-nothing extended draw function, which should
    be provided by the derived class.  This one will
    ASSERT, and should never be called.

Arguments:

    CRMCListBoxDrawStruct & dw   : Draw Structure

Return Value:

    None

--*/
{
   dw;
    ASSERT_MSG("Derived class did not provide DrawItemEx");
}



int
CRMCComboBox::OnCreate(
    IN LPCREATESTRUCT lpCreateStruct
    )
/*++

Routine Description:

    Combo box is being created

Arguments:

    LPCREATESTRUCT lpCreateStruct : Creation structure

Return Value:

    -1 for failure, 0 for success

--*/
{
    if (CComboBox::OnCreate(lpCreateStruct) == -1)
    {
        return -1;
    }

    Initialize();

    return 0;
}



/* virtual */
int
CRMCComboBox::__GetCount() const
/*++

Routine Description:

    Provide CComboBox::GetCount() functionality to base class

Arguments:

    None

Return Value:

    Get the count of items in the combo box

--*/
{
    return GetCount();
}



/* virtual */
int
CRMCComboBox::__SetItemHeight(
    IN int nIndex,
    IN UINT cyItemHeight
    )
/*++

Routine Description:

    Provide CListBox::SetItemHeight() functionality to base class.

Arguments:

    int nIndex        : Index of the item
    UINT cyItemHeight : Height of the item

Return Value:

    SetItemHeight return value.

--*/
{
    return SetItemHeight(nIndex, cyItemHeight);
}



IMPLEMENT_DYNAMIC(CRMCComboBox,CComboBox);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\common\objplus.cpp ===
/*++

   Copyright    (c)    1994-1999    Microsoft Corporation

   Module  Name :

        objplus.cpp

   Abstract:

        Base object classes

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager (cluster edition)

   Revision History:

--*/



//
// Include Files
//
#include "stdafx.h"
#include "common.h"

#include <stdlib.h>
#include <memory.h>
#include <ctype.h>



#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif



#define new DEBUG_NEW



CObjHelper::CObjHelper()
/*++

Routine Description:

    Constructor for super object help class

Arguments:

    None

Return Value:

    N/A

--*/
    : m_ctor_err(ERROR_SUCCESS),
      m_api_err(ERROR_SUCCESS),
      m_fDirty(FALSE),
      m_time_created(::GetCurrentTime())
{
}



void
CObjHelper::ReportError(
    IN LONG errInConstruction
    )
/*++

Routine Description:

    Set the constructor error code, and dump the error message to
    the debugging context.

Arguments:

    LONG errInConstruction : Error code

Return Value:

    None

--*/
{
    TRACEEOLID("CObjectPlus construction failure, error = "
        << errInConstruction);

    m_ctor_err = errInConstruction;
}



LONG
CObjHelper::SetApiErr(
    IN LONG errApi
    )
/*++

Routine Description:

    Set the API error code.

Arguments:

    LONG errApi  : API error code

Return Value:

    The API error code

--*/
{
    return m_api_err = errApi;
}



BOOL
CObjHelper::IsValid() const
/*++

Routine Description:

    Determine if the object is in a valid state

Arguments:

    LONG errApi  : API error code

Return Value:

    TRUE if the the object is in a valid state, FALSE otherwise

--*/
{
    return QueryError() == 0;
}



DWORD
CObjHelper::QueryAge() const
/*++

Routine Description:

    Determine the age of the object.

Arguments:

    None

Return Value:

    time_t value indicating the age of the object.

--*/
{
    DWORD dwTime = ::GetCurrentTime(),
          dwDiff;

    if (dwTime < m_time_created)
    {
        dwDiff = dwTime + (((DWORD)-1) - (m_time_created - 1));
    }
    else
    {
        dwDiff = dwTime - m_time_created;
    }

    return dwDiff;
}



#ifdef _DEBUG



void
CObjHelper::AssertValid() const
/*++

Routine Description:

    Assert the object if the object is in a valid state

Arguments:

    None

Return Value:

    None

--*/
{
    ASSERT(IsValid());
}



#endif // _DEBUG



CObjectPlus::CObjectPlus()
/*++

Routine Description:

    Constructor of extended object

Arguments:

    None

Return Value:

    N/A

--*/
{
}



int
CObjectPlus::Compare(
    IN const CObjectPlus * pob
    ) const
/*++

Routine Description:

    Compare one object with another:  default implementation orders objects
    by creation time.  Return -1, 0 or 1.

Arguments:

    const CObjectPlus * pob : Object to be compared against

Return Value:

    -1 if this object is < than the compared object
     0 if this object is == to the compared object
    +1 if this object is > than the compared object

--*/
{
    return QueryCreationTime() < pob->QueryCreationTime()
        ? -1
        : QueryCreationTime() != pob->QueryCreationTime();
}



CObListPlus::CObListPlus(
    IN int nBlockSize
    )
/*++

Routine Description:

    Subclass of CObList whose default behavior is to destroy its
    contents during its own destruction

Arguments:

    int nBlockSize : Initial block size

Return Value:

    None

--*/
    : CObList(nBlockSize),
      m_fOwned(TRUE)
{
}



CObListPlus::~CObListPlus()
/*++

Routine Description:

    Destructor.  If the objects are owned, clean them up.

Arguments:

    N/A

Return Value:

    N/A

--*/
{
    RemoveAll();
}



void
CObListPlus::RemoveAll()
/*++

Routine Description:

    Remove all the objects in the list if the list owns its objects

Arguments:

    None

Return Value:

    None

--*/
{
    if (m_fOwned)
    {
        //
        // Remove and discard all the objects
        //
        while (!IsEmpty())
        {
            CObject * pob = RemoveHead();
            delete pob ;
        }
    }
    else
    {
        //
        // Just remove the object pointers
        //
        CObList::RemoveAll();
    }
}



CObject *
CObListPlus::Index(
    IN int index
    )
/*++

Routine Description:

    Get object by index

Arguments:

    int index  : The index of the object to be returned

Return Value:

    The object, or NULL if the index is invalid

--*/
{
   CObListIter obli(*this);

   CObject * pob = NULL;

   for (int i = 0; (NULL != (pob = obli.Next())) && i++ < index; /**/ );

   return pob;
}



BOOL
CObListPlus::RemoveIndex(
    IN int index
    )
/*++

Routine Description:

    Remove object by index

Arguments:

    int index  : The index of the object to be removed

Return Value:

    The object, or NULL if the index is invalid

--*/
{
    int i;
    POSITION pos;
    CObListIter obli(*this);
    CObject * pob;

    for (i = 0, pos = obli.QueryPosition();
        (NULL != (pob = obli.Next())) && i < index;
        i++, pos = obli.QueryPosition());

    if (pob && i == index)
    {
        RemoveAt(pos);

        return TRUE;
    }

    return FALSE;
}



BOOL
CObListPlus::Remove(
    IN CObject * pob
    )
/*++

Routine Description:

    Remove the first (and hopefully only) occurrence of an object
    pointer from this list.

Arguments:

    CObject * pob : The object to be removed

Return Value:

    TRUE if the object was found and succesfully removed, FALSE otherwise

--*/
{
    POSITION pos = Find(pob);

    if (pos == NULL)
    {
        return FALSE;
    }

    RemoveAt(pos);

    return TRUE;
}



void
CObListPlus::RemoveAt(
    IN POSITION & pos
    )
/*++

Routine Description:

    Override of RemoveAt to delete the pointer at the position
    given

Arguments:

    POSITION pos        : Position of item to delete

Return Value:

    None.

Notes:

    The item will only be deleted if this is an "owned" list.

--*/
{
    CObject * pItem = GetAt(pos);

    CObList::RemoveAt(pos);

    if (m_fOwned)
    {
        delete pItem;
    }
}



BOOL
CObListPlus::SetAll(
    IN BOOL fDirty
    )
/*++

Routine Description:

    Set all elements to dirty or clean.  Return TRUE if any element was dirty.

Arguments:

    BOOL fDirty : Dirty flag to set the objects with

Return Value:

    TRUE if any element was dirty.

--*/
{
    int cDirtyItems = 0;
    CObjectPlus * pob;
    CObListIter obli(*this);

    while (NULL != (pob = (CObjectPlus *)obli.Next()))
    {
        cDirtyItems += pob->IsDirty();
        pob->SetDirty(fDirty);
    }

    SetDirty(fDirty);

    return cDirtyItems > 0;
}



int
CObListPlus::FindElement(
    IN CObject * pobSought
    ) const
/*++

Routine Description:

    Find the object in the list.

Arguments:

    CObject * pobSought : Object to be looked for

Return Value:

    The index of the object, or -1 if it wasn't found.

--*/
{
    CObject * pob;
    CObListIter obli(*this);

    for (int i = 0;
        (NULL != (pob = obli.Next())) && pob != pobSought;
        i++);

    return pob
        ? i
        : -1;
}


//
// Sorting structure
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

typedef struct
{
    CObjectPlus * pObj;                        // Pointer to object to be sorted
    CObjectPlus::PCOBJPLUS_ORDER_FUNC  pFunc;  // Pointer to ordering function
} CBOWNEDLIST_SORT_HELPER;



int _cdecl
CObListPlus::SortHelper(
    IN const void * pa,
    IN const void * pb
    )
/*++

Routine Description:

    This static member function is used to quick sort an array of structures
    as declared above.  Each element contains the object pointer and a
    pointer to the object's member function to be invoked for comparison.

Arguments:

    const void * pa      : Sorting help struct 1
    const void * pb      : Sorting help struct 2

Return Value:

    Sort return code

--*/
{
    CBOWNEDLIST_SORT_HELPER *pHelp1 = (CBOWNEDLIST_SORT_HELPER *)pa,
                            *pHelp2 = (CBOWNEDLIST_SORT_HELPER *)pb;

    return (pHelp1->pObj->*pHelp1->pFunc)(pHelp2->pObj);
}



DWORD
CObListPlus::Sort(
    IN CObjectPlus::PCOBJPLUS_ORDER_FUNC pOrderFunc
    )
/*++

Routine Description:

    Sort the list by recreating it entirely.

Arguments:

    CObjectPlus::PCOBJPLUS_ORDER_FUNC pOrderFunc : Ordering function

Return Value:

    Error code

--*/
{
    DWORD err = ERROR_SUCCESS;
    int cItems = (int)GetCount();

    if (cItems < 2)
    {
        return err;
    }

    CObjectPlus * pObNext;
    CObListIter obli(*this);
    BOOL fOwned = SetOwnership(FALSE);
    int i;

    CBOWNEDLIST_SORT_HELPER * paSortHelpers = NULL;

    //
    // Allocate the helper array
    //
    paSortHelpers = AllocMemByType(cItems, CBOWNEDLIST_SORT_HELPER);
    if (paSortHelpers == NULL)
    {
       return ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // Fill the helper array.
    //
    for (i = 0; NULL != (pObNext = (CObjectPlus *)obli.Next()); i++)
    {
        paSortHelpers[i].pFunc = pOrderFunc;
        paSortHelpers[i].pObj = pObNext;
    }

    //
    // Release all object pointer references.  Note that we
    // forced "owned" to FALSE above.
    //
    RemoveAll();
    ASSERT(GetCount() == 0);

    //
    // Sort the helper array
    //
    ::qsort( (void *) paSortHelpers,
         cItems,
         sizeof(paSortHelpers[0]),
         SortHelper
         );

    //
    // Refill the list from the helper array.
    //
    for (i = 0; i < cItems; i++ )
    {
        AddTail(paSortHelpers[i].pObj);
    }

    ASSERT(GetCount() == cItems);

    //
    // Delete the working array
    //
    FreeMem(paSortHelpers);

    //
    // Restore the object ownership state
    //
    SetOwnership(fOwned);

    return err;
}



CObListIter::CObListIter(
    IN const CObListPlus & obList
    )
/*++

Routine Description:

    Constructor of ObOwnedList iterator

Arguments:

    const CObListPlus & obList : List to be iterated

Return Value:

    N/A

--*/
    : m_obList(obList)
{
    Reset();
}



void
CObListIter::Reset()
/*++

Routine Description:

    Reset the iterator

Arguments:

    None

Return Value:

    None

--*/
{
    m_pos = m_obList.GetCount()
        ? m_obList.GetHeadPosition()
        : NULL;
}



CObject * CObListIter::Next()
/*++

Routine Description:

    Get the next object in the list, or NULL

Arguments:

    None

Return Value:

    The next object in the list, or NULL

--*/
{
    return m_pos == NULL
        ? NULL
        : m_obList.GetNext(m_pos);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\common\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by iisui.rc
//
#define chx1                            0x0410
#define stc1                            0x0440
#define stc2                            0x0441
#define stc3                            0x0442
#define stc4                            0x0443
#define lst1                            0x0460
#define lst2                            0x0461
#define cmb1                            0x0470
#define cmb2                            0x0471
#define edt1                            0x0480
#define IDC_STATIC_WZ_WELCOME           4000
#define IDC_STATIC_WZ_TITLE             4001
#define IDC_STATIC_WZ_SUBTITLE          4002
#define IDC_STATIC_WZ_BODY              4003
#define IDC_STATIC_WZ_CLICK             4004
#define IDC_STATIC_WZ_HEADER_DIVIDER    4005
#define IDC_ED_BOLD1                    4011
#define IDC_ED_BOLD2                    4012
#define IDC_ED_BOLD3                    4013
#define IDC_ED_BOLD4                    4014
#define IDC_ED_BOLD5                    4015
#define IDB_UP                          10013
#define IDB_UPFOC                       10014
#define IDB_UPDIS                       10015
#define IDB_UPINV                       10016
#define IDB_DOWN                        10017
#define IDB_DOWNFOC                     10018
#define IDB_DOWNDIS                     10019
#define IDB_DOWNINV                     10020
#define IDB_ACLUSERS                    10021
#define IDI_AUTHENTICATION              10050
#define IDI_GRANTED                     10051
#define IDI_DENIED                      10052
#define IDC_EDIT_CONFIRM_PASSWORD       11007
#define IDC_BUTTON_ADD                  11008
#define IDC_IPA_SUBNET_MASK             11010
#define IDC_STATIC_PASSWORD             11011
#define IDC_BUTTON_EDIT                 11012
#define IDC_BUTTON_REMOVE               11013
#define IDC_LIST_IP_ADDRESSES           11014
#define IDC_RADIO_GRANTED               11018
#define IDC_RADIO_DENIED                11019
#define IDC_RADIO_SINGLE                11020
#define IDC_RADIO_MULTIPLE              11021
#define IDC_STATIC_SUBNET_MASK          11022
#define IDC_STATIC_IP_ADDRESS           11023
#define IDC_IPA_IPADDRESS               11024
#define IDC_BUTTON_DNS                  11025
#define IDC_EDIT_DNS_NAME               11026
#define IDC_STATIC_BY_DEFAULT           11027
#define IDC_STATIC_EXCEPT               11028
#define IDC_ICON_GRANTED                11029
#define IDC_ICON_DENIED                 11030
#define IDC_RADIO_DOMAIN                11033
#define IDC_EDIT_DOMAIN                 11034
#define IDC_LIST_CHILD_NODES            11042
#define IDC_BUTTON_SELECT_ALL           11043
#define IDC_STATIC_PROMPT               11044
#define IDC_STATIC_GROUP_DETAILS        11045
#define IDC_BUTTON_E3                   11048
#define IDC_STATIC_ERROR_ICON           11049
#define IDC_STATIC_DIR_NAME             11050
#define IDC_EDIT_NEW_DIRECTORY_NAME     11051
#define IDC_EDIT_USERNAME               11052
#define IDC_STATIC_USERNAME             11054
#define IDC_BUTTON_CHECK_PASSWORD       11055
#define IDC_BUTTON_BROWSE_USERS         11056
#define IDD_CONFIRM_PASSWORD            15000
#define IDD_DIRBROWSE                   15006
#define IDD_INHERITANCE                 15012
#define IDD_ERROR                       15013
#define IDD_WIZARD_BOOKEND              15020
#define IDS_DDX_MINIMUM                 20110
#define IDS_PASSWORD_NO_MATCH           20111
#define IDS_INHERITANCE_NO_NAME         20112
#define IDS_INHERITANCE_PROMPT          20113
#define IDS_FMT_SECURITY                20127
#define IDS_NO_MESSAGE                  20132
#define IDS_DEFAULT_IP                  20133
#define IDS_INVALID_NUMBER              20134
#define IDS_SELECT_ADMIN                20135
#define IDS_BROWSE_DOMAIN               20136
#define IDS_SELECT_IUSR_ACCOUNT         20137
#define IDS_PASSWORD_OK                 20138
#define IDS_MD_CONNECTION_TIMEOUT       20200
#define IDS_MD_MAX_CONNECTIONS          20201
#define IDS_MD_SERVER_COMMENT           20202
#define IDS_MD_SERVER_SIZE              20203
#define IDS_MD_SERVER_LISTEN_BACKLOG    20204
#define IDS_MD_SERVER_LISTEN_TIMEOUT    20205
#define IDS_MD_DOWNLEVEL_ADMIN_INSTANCE 20206
#define IDS_MD_APP_FRIENDLY_NAME        20207
#define IDS_MD_APP_ROOT                 20208
#define IDS_MD_APP_ISOLATED             20209
#define IDS_MD_VR_PATH                  20210
#define IDS_MD_VR_USERNAME              20211
#define IDS_MD_VR_PASSWORD              20212
#define IDS_MD_EXIT_MESSAGE             20213
#define IDS_MD_GREETING_MESSAGE         20214
#define IDS_MD_MAX_CLIENTS_MESSAGE      20215
#define IDS_MD_MSDOS_DIR_OUTPUT         20216
#define IDS_MD_ALLOW_ANONYMOUS          20217
#define IDS_MD_ANONYMOUS_ONLY           20218
#define IDS_MD_LOG_ANONYMOUS            20219
#define IDS_MD_LOG_NONANONYMOUS         20220
#define IDS_MD_AUTHORIZATION            20221
#define IDS_MD_REALM                    20222
#define IDS_MD_HTTP_EXPIRES             20223
#define IDS_MD_HTTP_PICS                20224
#define IDS_MD_HTTP_CUSTOM              20225
#define IDS_MD_DIRECTORY_BROWSING       20226
#define IDS_MD_DEFAULT_LOAD_FILE        20227
#define IDS_MD_CONTENT_NEGOTIATION      20228
#define IDS_MD_CUSTOM_ERROR             20229
#define IDS_MD_FOOTER_DOCUMENT          20230
#define IDS_MD_FOOTER_ENABLED           20231
#define IDS_MD_HTTP_REDIRECT            20232
#define IDS_MD_DEFAULT_LOGON_DOMAIN     20233
#define IDS_MD_LOGON_METHOD             20234
#define IDS_MD_SCRIPT_MAPS              20235
#define IDS_MD_MIME_MAP                 20236
#define IDS_MD_ACCESS_PERM              20237
#define IDS_MD_HEADER_DOCUMENT          20238
#define IDS_MD_HEADER_ENABLED           20239
#define IDS_MD_IP_SEC                   20240
#define IDS_MD_ANONYMOUS_USER_NAME      20241
#define IDS_MD_ANONYMOUS_PWD            20242
#define IDS_MD_ANONYMOUS_USE_SUBAUTH    20243
#define IDS_MD_DONT_LOG                 20244
#define IDS_MD_ADMIN_ACL                20245
#define IDS_MD_SSI_EXEC_DISABLED        20246
#define IDS_MD_SSL_ACCESS_PERM          20247
#define IDS_MD_NTAUTHENTICATION_PROVIDERS 20248
#define IDS_MD_SCRIPT_TIMEOUT           20249
#define IDS_MD_CACHE_EXTENSIONS         20250
#define IDS_MD_CREATE_PROCESS_AS_USER   20251
#define IDS_MD_CREATE_PROC_NEW_CONSOLE  20252
#define IDS_MD_POOL_IDC_TIMEOUT         20253
#define IDS_MD_ALLOW_KEEPALIVES         20254
#define IDS_MD_IS_CONTENT_INDEXED       20255
#define IDS_ASP_BUFFERINGON             20256
#define IDS_ASP_LOGERRORREQUESTS        20257
#define IDS_ASP_SCRIPTERRORSSENTTOBROWSER 20258
#define IDS_ASP_SCRIPTERRORMESSAGE      20259
#define IDS_ASP_SCRIPTFILECACHESIZE     20260
#define IDS_ASP_SCRIPTENGINECACHEMAX    20261
#define IDS_ASP_SCRIPTTIMEOUT           20262
#define IDS_ASP_SESSIONTIMEOUT          20263
#define IDS_ASP_ENABLEPARENTPATHS       20264
#define IDS_ASP_ALLOWSESSIONSTATE       20265
#define IDS_ASP_SCRIPTLANGUAGE          20266
#define IDS_ASP_EXCEPTIONCATCHENABLE    20267
#define IDS_ASP_ENABLESERVERDEBUG       20268
#define IDS_ASP_ENABLECLIENTDEBUG       20269
#define IDS_MD_LOG_PLUGIN_ORDER         20270
#define IDS_MD_LOGEXT_FIELD_MASK        20271
#define IDS_MD_LOG_TYPE                 20272
#define IDS_MD_LOGFILE_DIRECTORY        20273
#define IDS_MD_LOGFILE_PERIOD           20274
#define IDS_MD_LOGFILE_TRUNCATE_SIZE    20275
#define IDS_MD_LOGSQL_DATA_SOURCES      20276
#define IDS_MD_LOGSQL_TABLE_NAME        20277
#define IDS_MD_LOGSQL_USER_NAME         20278
#define IDS_MD_LOGSQL_PASSWORD          20279
#define IDS_MD_CPU_LIMITS_ENABLED       20280
#define IDS_MD_CPU_LIMIT_LOGEVENT       20281
#define IDS_MD_CPU_LIMIT_PRIORITY       20282
#define IDS_MD_CPU_LIMIT_PAUSE          20283
#define IDS_MD_CPU_LIMIT_PROCSTOP       20284
#define IDS_MD_LOGFILE_LOCALTIME_ROLLOVER 20285
#define IDS_MD_CPU_LOGGING_MASK         20286
#define IDS_BROWSE_DIRECTORY            20287
#define IDS_BAD_BROWSE                  20288
#define IDS_ALL_UNASSIGNED              20289
#define IDS_INVALID_IP_ADDRESS          20290
#define IDS_UNKNOWN_USER                20291
#define IDS_WIZ_NEXT                    20355
#define IDS_WIZ_FINISH                  20356
//#define IDS_ADDRESS_RESTRICTIONS        21013
#define IDS_ADDRESS_IP                  21015
//#define IDS_ACL_ADMINS                  21022
//#define IDS_ACL_EV_READ                 21023
//#define IDS_ACL_EV_WRITE                21024
//#define IDS_ACL_EV_EXEC                 21025
//#define IDS_ACL_SUMMARY                 21026
//#define IDS_ACL_NONE                    21027
//#define IDS_ACL_REPLACEMENT             21028
//#define IDS_ACL_ADDED                   21029
//#define IDS_ACL_ADMIN                   21030
//#define IDS_ACL_EVR                     21031
//#define IDS_ACL_READ                    21032
//#define IDS_ACL_READ_CONTROL            21033
//#define IDS_ACL_READ_ATTRIB             21034
//#define IDS_ACL_READ_PROP               21035
//#define IDS_ACL_WRITE                   21036
//#define IDS_ACL_APPEND                  21037
//#define IDS_ACL_DELETE                  21038
//#define IDS_ACL_WRITE_ATTRIB            21039
//#define IDS_ACL_WRITE_PROP              21040
//#define IDS_ACL_EXECUTE                 21041
//#define IDS_ACL_LIST_OBJECT             21042
#define IDS_ERR_RPC_NA                  50000
#define IDS_ERR_INTERFACE               50001
#define IDS_ERR_ODBC                    50002
#define IDS_ERR_NO_MESSAGE              50003
#define IDS_ERR_CANT_START_SERVICE      50004
#define IDS_ERR_METABASE_ERROR          50005
#define IDS_ERR_DUP_VROOT               50006
#define IDS_ERR_NO_INTERFACE            50007
#define IDS_ERR_NO_SHUTDOWN             50008
#define IDS_ERR_NO_BACKUP_RESTORE       50009
#define IDS_ERR_CANNOT_RESTORE          50010
#define IDS_ERR_RPC_NA_SHORT            50011
#define IDS_ERR_ACCESS_DENIED           50012

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\common\objplus.h ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        objplus.h

   Abstract:

        Base object class definitions

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/

#ifndef _COMMON_H_
#define _COMMON_H_



//
// Forward declarations
//
class CObjHelper;
class CObjectPlus;
class CObListPlus;
class CObListIter;



class COMDLL CObjHelper
/*++

Class Description:

    Helper class for control of construction and API errors

Public Interface:

    IsValid           : Determine if the object is in a valid state.
    operator BOOL     : Boolean cast to IsValid()
    SetDirty          : Set or reset the dirty flag
    IsDirty           : Query the dirty state of the object
    QueryCreationTime : Query the creation time of the object
    QueryAge          : Query the age of the object
    ReportError       : Query/set construction failure
    QueryError        : Query the error code of the object
    QueryApiErr       : Query/set API error code
    ResetErrors       : Reset all error codes
    SetApiErr         : Echoes the error to the caller
    AssertValid       : Assert the object is in a valid state (debug only)

--*/
{
protected:
    //
    // Protected constructor: Not to be declared independently.
    //
    CObjHelper();

public:
    virtual BOOL IsValid() const;
    operator BOOL();

    //
    // Update the Dirty flag
    //
    void SetDirty(
        IN BOOL fDirty = TRUE
        );

    //
    // Query the Dirty flag
    //
    BOOL IsDirty() const { return m_fDirty; }

    //
    // Return the creation time of this object
    //
    DWORD QueryCreationTime() const { return m_time_created; }

    //
    // Return the elapsed time this object has been alive.
    //
    DWORD QueryAge() const;

    //
    // Query/set construction failure
    //
    void ReportError(
        IN LONG errInConstruction
        );

    //
    // Fetch construction error
    //
    LONG QueryError() const { return m_ctor_err; }

    //
    // Query/set API errors.
    //
    LONG QueryApiErr() const { return m_api_err; }

    //
    // Reset all error conditions.
    //
    void ResetErrors();

    //
    // SetApiErr() echoes the error to the caller.
    // for use in expressions.
    //
    LONG SetApiErr(
        IN LONG errApi = ERROR_SUCCESS
        );

#ifdef _DEBUG

    void AssertValid() const;

#endif // _DEBUG

protected:
    LONG  m_ctor_err;
    LONG  m_api_err;
    DWORD m_time_created;
    BOOL  m_fDirty;
};



class COMDLL CObjectPlus : public CObject, public CObjHelper
/*++

Class Description:

    Super CObject class.

Public Interface:

    CObjectPlus       : Constructor
    Compare           : Compare one object with another

--*/
{
public:
    CObjectPlus();

    //
    // Compare one object with another
    //
    virtual int Compare(
        IN const CObjectPlus * pob
        ) const;

    //
    // Define a typedef for an ordering function.
    //
    typedef int (CObjectPlus::*PCOBJPLUS_ORDER_FUNC)(
        IN const CObjectPlus * pobOther
        ) const;
};



class COMDLL CObListPlus : public CObList, public CObjHelper
/*++

Class Description:

    Object pointer list which optionally "owns" the objects pointed to, and
    with facility to sort.  If the list "owns" its objects, the destructor
    will clean up its member objects.

Public Interface:

    CObListPlus      : Constructor
    ~CObListPlus     : Destructor

    SetOwnership     : Set/reset ownership bit
    Index            : Get object by index
    RemoveIndex      : Remove object by index
    Remove           : Remove object
    RemoveAt         : Remove object at position
    RemoveAll        : Remove all objects
    FindElement      : Find object
    SetAll           : Set/Reset the dirty flag of all objects
    AddTail          : Add new object to the tail of the list
    Sort             : Sort the list elements with sorting function provided

--*/
{
//
// Constructor/Destructor
//
public:
    CObListPlus(
        IN int nBlockSize = 10
        );

    virtual ~CObListPlus();

//
// Access
//
public:
    BOOL SetOwnership(
        IN BOOL fOwned = TRUE
        );

    //
    // Return object at the given index
    //
    CObject * Index(
        IN int index
        );

    //
    // Remove item the given index
    //
    BOOL RemoveIndex(
        IN int index
        );

    //
    // Remove the given object from the list
    //
    BOOL Remove(
        IN CObject * pob
        );

    //
    // Remove the item at the given position
    //
    void RemoveAt(
        IN POSITION & pos
        );

    //
    // Remove all items from the list
    //
    void RemoveAll();

    int FindElement(
        IN CObject * pobSought
        ) const;

    //
    // Set all elements to dirty or clean.  Return TRUE if
    // any element was dirty.
    //
    BOOL SetAll(
        IN BOOL fDirty = FALSE
        );

    //
    // Sort the list elements according to the
    // given ordering function.  Return error code
    //
    DWORD Sort(
        IN CObjectPlus::PCOBJPLUS_ORDER_FUNC pOrderFunc
        );

protected:
    static int _cdecl SortHelper(
        IN const void * pa,
        IN const void * pb
        );

protected:
    BOOL m_fOwned;
};



class COMDLL CObListIter : public CObjectPlus
/*++

Class Description:

    Object iteration class

Public Interface:

    CObListIter       : Constructor
    Next              : Get next object
    Reset             : Reset the iteration index
    QueryPosition     : Query the current iteration index
    SetPosition       : Set the current position in the list by POSITION

--*/
{
public:
    CObListIter(
        IN const CObListPlus & obList
        );

    CObject * Next();
    void Reset();
    POSITION QueryPosition() const { return m_pos; }

    void SetPosition(
        IN POSITION pos
        );

protected:
    POSITION m_pos;
    const CObListPlus & m_obList;
};



//
// Inline Expansion
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

inline CObjHelper::operator BOOL()
{
    return IsValid();
}

inline void CObjHelper::SetDirty(
    IN BOOL fDirty 
    )
{
    m_fDirty = fDirty;
}

inline void CObjHelper::ResetErrors()
{
    m_ctor_err = m_api_err = ERROR_SUCCESS;
}

inline BOOL CObListPlus::SetOwnership(
    IN BOOL fOwned
    )
{
    BOOL fOld = m_fOwned;
    m_fOwned = fOwned;

    return fOld;
}

inline void CObListIter::SetPosition(
    IN POSITION pos
    )
{
    m_pos = pos;
}

#endif // _COMMON_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\common\odlbox.h ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        odlbox.h

   Abstract:

        Owner draw listbox/combobox base class

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/

#ifndef _ODLBOX_H
#define _ODLBOX_H



//
// Get control rect in terms of
// parent coordinates
//
void COMDLL GetDlgCtlRect(
    IN  HWND hWndParent,
    IN  HWND hWndControl,
    OUT LPRECT lprcControl
    );


//
// Fit path to the given control
//
void COMDLL FitPathToControl(
    IN CWnd & wndControl,
    IN LPCTSTR lpstrPath
    );


//
// Show/hide _AND_ enable/disable control
//
void COMDLL ActivateControl(
    IN CWnd & wndControl,
    IN BOOL fShow          = TRUE
    );

//
// Helper
//
inline void DeActivateControl(CWnd & wndControl)
{
    ActivateControl(wndControl, FALSE);
}

BOOL COMDLL VerifyState();


class COMDLL CMappedBitmapButton : public CBitmapButton
/*++

Class Description:

    Similar to CBitmapbutton, but use ::LoadMappedBitmap to reflect
    propert colour mapping.

Public Interface:

    CMappedBitmapButton     : Constructor

--*/
{
//
// Constructor
//
public:
    CMappedBitmapButton();

protected:
    BOOL LoadMappedBitmaps(
        UINT nIDBitmapResource,
        UINT nIDBitmapResourceSel = 0,
        UINT nIDBitmapResourceFocus = 0,
        UINT nIDBitmapResourceDisabled = 0
        );
};



class COMDLL CUpButton : public CMappedBitmapButton
/*++

Class Description:

    Up button.

Public Interface:

    CUpButton       : Constructor; does everything

--*/
{
public:
    CUpButton();
};



class COMDLL CDownButton : public CMappedBitmapButton
/*++

Class Description:

    Down button

Public Interface:

    CDownButton     : Constructor; does everything

--*/
{
public:
    CDownButton();
};



class COMDLL CRMCListBoxResources
{
/*++

Class Description:

    Listbox resources, a series of bitmaps for use by the listbox.  Will
    generate bitmaps against the proper background colours for both
    selected and non-selected states.

Public Interface:

    CRMCListBoxResources  : Constructor
    ~CRMCListBoxResources : Destructor

    SysColorChanged       : Regenerate bitmaps in response to change in colours
    DcBitMap              : Get final DC
    BitmapHeight          : Get bitmap height
    BitmapWidth           : Get bitmap width
    ColorWindow           : Get currently set window colour
    ColorHighlight        : Get currently set highlight colour
    ColorWindowText       : Get currently set window text colour
    ColorHighlightText    : Get currently set text highlight colour

--*/
//
// Constructor
//
public:
    CRMCListBoxResources(
        IN int bmId,
        IN int nBitmapWidth,
        IN COLORREF crBackground = RGB(0,255,0) /* Green */
        );

    ~CRMCListBoxResources();

//
// Interface
//
public:
    void SysColorChanged();
    const CDC & dcBitMap() const;
    int BitmapHeight() const;
    int BitmapWidth() const;
    COLORREF ColorWindow() const;
    COLORREF ColorHighlight() const;
    COLORREF ColorWindowText() const;
    COLORREF ColorHighlightText() const;

//
// Internal Helpers
//
protected:
    void GetSysColors();
    void PrepareBitmaps();
    void UnprepareBitmaps();
    void UnloadResources();
    void LoadResources();

private:
    COLORREF m_rgbColorWindow;
    COLORREF m_rgbColorHighlight;
    COLORREF m_rgbColorWindowText;
    COLORREF m_rgbColorHighlightText;
    COLORREF m_rgbColorTransparent;
    HGDIOBJ  m_hOldBitmap;
    CBitmap  m_bmpScreen;
    CDC      m_dcFinal;
    BOOL     m_fInitialized;
    int      m_idBitmap;
    int      m_nBitmapHeight;
    int      m_nBitmapWidth;
    int      m_nBitmaps;
};



class COMDLL CRMCListBoxDrawStruct
{
/*++

Class Description:

    Drawing information passed on to ODLBox

Public Interface:

    CRMCListBoxDrawStruct  : Constructor

--*/
public:
    CRMCListBoxDrawStruct(
        IN CDC * pDC,
        IN RECT * pRect,
        IN BOOL sel,
        IN DWORD_PTR item,
        IN int itemIndex,
        IN const CRMCListBoxResources * pres
        );

public:
    const CRMCListBoxResources * m_pResources;
    int   m_ItemIndex;
    CDC * m_pDC;
    CRect m_Rect;
    BOOL  m_Sel;
    DWORD_PTR m_ItemData;
};



/* abstract */ class COMDLL CODLBox
/*++

Class Description:

    abstract base class for owner-draw listbox and combobox

Public Interface:

    AttachResources   : Attach the resource structure to the list/combo box
    ChangeFont        : Change the font
    NumTabs           : Get the number of tabs currently set
    AddTab            : Add tab
    AddTabFromHeaders : Add tab computed from the difference in left coordinate
                        of two controls.
    InsertTab         : Insert a tab
    RemoveTab         : Remove a tab
    RemoveAllTabs     : Remove all tabs
    SetTab            : Set tab value
    GetTab            : Get tab value
    TextHeight        : Get the text height of the current font
    __GetCount        : Pure virtual function to get the number of items in the
                        list/combo box
    __SetItemHeight   : Pure virtual function to set the text height of the font

--*/
{
//
// Operations
//
public:
    void AttachResources(
        IN const CRMCListBoxResources * pResources
        );

    BOOL ChangeFont(
        CFont * pNewFont
        );

    int NumTabs() const;

    int AddTab(
        IN UINT uTab
        );

    int AddTabFromHeaders(
        IN CWnd & wndLeft,
        IN CWnd & wndRight
        );

    int AddTabFromHeaders(
        IN UINT idLeft,
        IN UINT idRight
        );

    void InsertTab(
        IN int nIndex,
        IN UINT uTab
        );

    void RemoveTab(
        IN int nIndex,
        IN int nCount = 1
        );

    void RemoveAllTabs();

    void SetTab(
        IN int nIndex,
        IN UINT uTab
        );

    UINT GetTab(
        IN int nIndex
        ) const;

    int TextHeight() const;

    /* pure */ virtual int __GetCount() const = 0;

    /* pure */ virtual int __SetItemHeight(
        IN int nIndex,
        IN UINT cyItemHeight
        ) = 0;

protected:
    CODLBox();
    ~CODLBox();

protected:
    //
    // Determine required display width of the string
    //
    static int GetRequiredWidth(
        IN CDC * pDC,
        IN const CRect & rc,
        IN LPCTSTR lpstr,
        IN int nLength
        );

    //
    // Helper function to display text in a limited rectangle
    //
    static BOOL ColumnText(
        IN CDC * pDC,
        IN int left,
        IN int top,
        IN int right,
        IN int bottom,
        IN LPCTSTR str
        );

protected:
    //
    // Helper functions for displaying bitmaps and text
    //
    BOOL DrawBitmap(
        IN CRMCListBoxDrawStruct & ds,
        IN int nCol,
        IN int nID
        );

    BOOL ColumnText(
        IN CRMCListBoxDrawStruct & ds,
        IN int nCol,
        IN BOOL fSkipBitmap,
        IN LPCTSTR lpstr
        );

    void ComputeMargins(
        IN  CRMCListBoxDrawStruct & ds,
        IN  int nCol,
        OUT int & nLeft,
        OUT int & nRight
        );

protected:
    void CalculateTextHeight(
        IN CFont * pFont
        );

    void AttachWindow(
        IN CWnd * pWnd
        );

protected:
    //
    // must override this to provide drawing of item
    //
    /* pure */ virtual void DrawItemEx(
        IN CRMCListBoxDrawStruct & dw
        ) = 0;

    void __MeasureItem(
        IN OUT LPMEASUREITEMSTRUCT lpMIS
        );

    void __DrawItem(
        IN LPDRAWITEMSTRUCT lpDIS
        );

    virtual BOOL Initialize();

protected:
    int m_lfHeight;
    const CRMCListBoxResources* m_pResources;

private:
    //
    // Window handle -- to be attached by derived class
    //
    CWnd * m_pWnd;
    CUIntArray m_auTabs;
};


//
// Forward decleration
//
class CHeaderListBox;



//
// Styles for listbox headers
//
#define HLS_STRETCH         (0x00000001)
#define HLS_BUTTONS         (0x00000002)

#define HLS_DEFAULT         (HLS_STRETCH | HLS_BUTTONS)



class COMDLL CRMCListBoxHeader : public CStatic
/*++

Class Description:

    Header object to be used in conjunction with listbox

Public Interface:

    CRMCListBoxHeader            : Constructor
    ~CRMCListBoxHeader           : Destructor

    Create                      : Create control

    GetItemCount                : Get the number of items in the header control
    GetColumnWidth              : Get column width of a specific column
    QueryNumColumns             : Get the number of columns in the listbox
    SetColumnWidth              : Set the width of specified column
    GetItem                     : Get header item information about specific
                                  column
    SetItem                     : Set header item information about specific
                                  column
    InsertItem                  : Insert header item
    DeleteItem                  : Delete header item
    RespondToColumnWidthChanges : Set response flagg

--*/
{
    DECLARE_DYNAMIC(CRMCListBoxHeader)

public:
    //
    // Constructor
    //
    CRMCListBoxHeader(
        IN DWORD dwStyle = HLS_DEFAULT
        );

    ~CRMCListBoxHeader();

    //
    // Create control
    //
    BOOL Create(
        IN DWORD dwStyle,
        IN const RECT & rect,
        IN CWnd * pParentWnd,
        IN CHeaderListBox * pListBox,
        IN UINT nID
        );

//
// Header control stuff
//
public:
    int GetItemCount() const;

    int GetColumnWidth(
        IN int nPos
        ) const;

    BOOL GetItem(
        IN int nPos,
        IN HD_ITEM * pHeaderItem
        ) const;

    BOOL SetItem(
        IN int nPos,
        IN HD_ITEM * pHeaderItem
        );

    int InsertItem(
        IN int nPos,
        IN HD_ITEM * phdi
        );

    BOOL DeleteItem(
        IN int nPos
        );

    void SetColumnWidth(
        IN int nCol,
        IN int nWidth
        );

    BOOL DoesRespondToColumnWidthChanges() const;

    void RespondToColumnWidthChanges(
        IN BOOL fRespond = TRUE
        );

    int QueryNumColumns() const;

protected:
    //{{AFX_MSG(CRMCListBoxHeader)
    afx_msg void OnDestroy();
    //}}AFX_MSG

    afx_msg void OnHeaderItemChanged(UINT nId, NMHDR * n, LRESULT * l);
    afx_msg void OnHeaderEndTrack(UINT nId, NMHDR * n, LRESULT * l);
    afx_msg void OnHeaderItemClick(UINT nId, NMHDR * n, LRESULT * l);

    DECLARE_MESSAGE_MAP()

    void CRMCListBoxHeader::SetTabsFromHeader();

    BOOL UseStretch() const;
    BOOL UseButtons() const;

private:
    CHeaderCtrl * m_pHCtrl;
    CHeaderListBox * m_pListBox;
    DWORD m_dwStyle;
    BOOL m_fRespondToColumnWidthChanges;

};



class COMDLL CRMCListBox : public CListBox, public CODLBox
/*++

Class Description:

    Super listbox class.  Its methods work for both
    single selection, and multi selection listboxes.

Public Interface:

    CRMCListBox          : Constructor
    ~CRMCListBox         : Destructor

    Initialize          : Initialize the control

    __GetCount          : Get the count of items in the listbox
    __SetItemHeight     : Set the item height in the listbox
    InvalidateSelection : Invalidate selection

--*/
{
    DECLARE_DYNAMIC(CRMCListBox)

public:
    //
    // Plain Construction
    //
    CRMCListBox();
    virtual ~CRMCListBox();
    virtual BOOL Initialize();

//
// Implementation
//
public:
    virtual int __GetCount() const;

    virtual int __SetItemHeight(
        IN int nIndex,
        IN UINT cyItemHeight
        );

    //
    // Invalidate item
    //
    void InvalidateSelection(
        IN int nSel
        );

    //
    // Select single item
    //
    int SetCurSel(int nSelect);

    //
    // Get index of selected item.  For multi-selects
    // with more than 1 selected, it will return LB_ERR
    //
    int GetCurSel() const;

    //
    // Check to see if item is selected
    //
    int GetSel(int nSel) const;

    //
    // Get count of selected items
    //
    int GetSelCount() const;

    //
    // Get next select item (single or multi-select).
    // Returns NULL if no further selected items available
    //
    void * GetNextSelectedItem(
        IN OUT int * pnStartingIndex
        );

    //
    // Select a single item (works for multi and single
    // select listboxes)
    //
    BOOL SelectItem(
        IN void * pItemData = NULL
        );

    //
    // Get the item at the single selection (works for both
    // multi and single selection listboxes).  Return NULL
    // if fewer than or more than one is selected.
    //
    void * GetSelectedListItem(
        OUT int * pnSel = NULL
        );

protected:
    //
    // Do-nothing drawitemex for non-owner draw listboxes.
    //
    virtual void DrawItemEx(
        IN CRMCListBoxDrawStruct & dw
        );

    virtual void MeasureItem(
        IN OUT LPMEASUREITEMSTRUCT lpMIS
        );

    virtual void DrawItem(
        IN LPDRAWITEMSTRUCT lpDIS
        );

protected:
    //{{AFX_MSG(CRMCListBox)
    afx_msg int  OnCreate(LPCREATESTRUCT lpCreateStruct);
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

//
// Helpers
//
protected:
    BOOL IsMultiSelect() const;

private:
    BOOL m_fInitialized;
    BOOL m_fMultiSelect;
};


//
// Column Definition Structure
//
typedef struct tagODL_COLUMN_DEF
{
    int nWeight;
    UINT nLabelID;
} ODL_COLUMN_DEF;



//
// Enhanced Column Definition Structure (Can't
// be used in global structures in an AFXEXT dll
// because of the CObjectPlus reference)
//
typedef struct tagODL_COLUMN_DEF_EX
{
    ODL_COLUMN_DEF cd;
    CObjectPlus::PCOBJPLUS_ORDER_FUNC pSortFn;
} ODL_COLUMN_DEF_EX;



class COMDLL CHeaderListBox : public CRMCListBox
/*++

Class Description:

    Header listbox class. When using this class, do not use the tabbing
    functions of the base class.  These will be set by the header control.

Public Interface:

    CHeaderListBox      : Constructor
    ~CHeaderListBox     : Destructor

    Initialize          : Initialize the control
    QueryNumColumns     : Get the number of columns in the listbox
    QueryColumnWidth    : Get the width of specified column
    SetColumnWidth      : Set the width of specified column

--*/
{
    DECLARE_DYNAMIC(CHeaderListBox)

public:
    //
    // Plain Construction
    //
    CHeaderListBox(
        IN DWORD dwStyle = HLS_DEFAULT,
        LPCTSTR lpRegKey = NULL
        );

    virtual ~CHeaderListBox();

    virtual BOOL Initialize();

public:
    BOOL EnableWindow(
        IN BOOL bEnable = TRUE
        );

    BOOL ShowWindow(
        IN int nCmdShow
        );

    int QueryNumColumns() const;

    int QueryColumnWidth(
        IN int nCol
        ) const;

    BOOL SetColumnWidth(
        IN int nCol,
        IN int nWidth
        );

//
// Header Control Attachment Access
//
protected:
    int GetHeaderItemCount() const;

    BOOL GetHeaderItem(
        IN int nPos,
        IN HD_ITEM * pHeaderItem
        ) const;

    BOOL SetHeaderItem(
        IN int nPos,
        IN HD_ITEM * pHeaderItem
        );

    int InsertHeaderItem(
        IN int nPos,
        IN HD_ITEM * phdi
        );

    BOOL DeleteHeaderItem(
        IN int nPos
        );

    CRMCListBoxHeader * GetHeader();

    int InsertColumn(
        IN int nCol,
        IN int nWeight,
        IN UINT nStringID,
        IN HINSTANCE hResInst
        );

    void ConvertColumnWidth(
        IN int nCol,
        IN int nTotalWeight,
        IN int nTotalWidth
        );

    BOOL SetWidthsFromReg();

    void DistributeColumns();

protected:
    //{{AFX_MSG(CHeaderListBox)
    afx_msg int  OnCreate(LPCREATESTRUCT lpCreateStruct);
    afx_msg void OnDestroy();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

private:
    BOOL m_fInitialized;
    CString m_strRegKey;
    CRMCListBoxHeader * m_pHeader;
};



class COMDLL CRMCComboBox : public CComboBox, public CODLBox
/*++

Class Description:

    Super combo box class

Public Interface:

    CRMCComboBox        : Constructor
    ~CRMCComboBox       : Destructor

    Initialize          : Initialize the control

    __GetCount          : Get the count of items in the combobox
    __SetItemHeight     : Set the item height in the combobox
    InvalidateSelection : Invalidate selection

--*/
{
    DECLARE_DYNAMIC(CRMCComboBox)

//
// Construction
//
public:
    CRMCComboBox();
    virtual BOOL Initialize();

//
// Implementation
//
public:
    virtual ~CRMCComboBox();

    virtual int __GetCount() const;

    virtual int __SetItemHeight(
        IN int nIndex,
        IN UINT cyItemHeight
        );

    void InvalidateSelection(
        IN int nSel
        );

protected:
    //
    // Do-nothing drawitemex for non-owner draw comboboxes.
    //
    virtual void DrawItemEx(
        IN CRMCListBoxDrawStruct & dw
        );

    virtual void MeasureItem(
        IN OUT LPMEASUREITEMSTRUCT lpMIS
        );

    virtual void DrawItem(
        IN LPDRAWITEMSTRUCT lpDIS
        );

protected:
    //{{AFX_MSG(CRMCComboBox)
    afx_msg int  OnCreate(LPCREATESTRUCT lpCreateStruct);
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

private:
    BOOL m_fInitialized;
};



//
// Inline Expansion
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

inline CMappedBitmapButton::CMappedBitmapButton()
{
};

inline CUpButton::CUpButton()
{
   LoadMappedBitmaps(IDB_UP, IDB_UPINV, IDB_UPFOC, IDB_UPDIS);
}

inline CDownButton::CDownButton()
{
   LoadMappedBitmaps(IDB_DOWN, IDB_DOWNINV, IDB_DOWNFOC, IDB_DOWNDIS);
}

inline const CDC & CRMCListBoxResources::dcBitMap() const
{
    return m_dcFinal;
}

inline int CRMCListBoxResources::BitmapHeight() const
{
    return m_nBitmapHeight;
}

inline int CRMCListBoxResources::BitmapWidth() const
{
    return m_nBitmapWidth;
}

inline COLORREF CRMCListBoxResources::ColorWindow() const
{
    return m_rgbColorWindow;
}

inline COLORREF CRMCListBoxResources::ColorHighlight() const
{
    return m_rgbColorHighlight;
}

inline COLORREF CRMCListBoxResources::ColorWindowText() const
{
    return m_rgbColorWindowText;
}

inline COLORREF CRMCListBoxResources::ColorHighlightText() const
{
    return m_rgbColorHighlightText;
}

inline int CODLBox::NumTabs() const
{
    return (int)m_auTabs.GetSize();
}

inline void CODLBox::SetTab(
    IN int nIndex,
    IN UINT uTab
    )
{
    ASSERT(nIndex >= 0 && nIndex < NumTabs());
    m_auTabs[nIndex] = uTab;
}

inline UINT CODLBox::GetTab(
    IN int nIndex
    ) const
{
    ASSERT(nIndex >= 0 && nIndex < NumTabs());
    return m_auTabs[nIndex];
}

inline int CODLBox::TextHeight() const
{
    return m_lfHeight;
}

inline void CODLBox::AttachWindow(
    IN CWnd * pWnd
    )
{
    m_pWnd = pWnd;
}

inline BOOL CRMCListBoxHeader::DoesRespondToColumnWidthChanges() const
{
    return m_fRespondToColumnWidthChanges;
}

inline void CRMCListBoxHeader::RespondToColumnWidthChanges(
    IN BOOL fRespond
    )
{
    m_fRespondToColumnWidthChanges = fRespond;
}

inline int CRMCListBoxHeader::QueryNumColumns() const
{
    return GetItemCount();
}

inline BOOL CRMCListBoxHeader::UseStretch() const
{
    return (m_dwStyle & HLS_STRETCH) != 0L;
}

inline BOOL CRMCListBoxHeader::UseButtons() const
{
    return (m_dwStyle & HLS_BUTTONS) != 0L;
}

inline int CHeaderListBox::QueryNumColumns() const
{
    return GetHeaderItemCount();
}

inline int CHeaderListBox::GetHeaderItemCount() const
{
    ASSERT_PTR(m_pHeader);
    return m_pHeader->GetItemCount();
}

inline BOOL CHeaderListBox::GetHeaderItem(
    IN int nPos,
    IN HD_ITEM * pHeaderItem
    ) const
{
    ASSERT_PTR(m_pHeader);
    return m_pHeader->GetItem(nPos, pHeaderItem);
}

inline BOOL CHeaderListBox::SetHeaderItem(
    IN int nPos,
    IN HD_ITEM * pHeaderItem
    )
{
    ASSERT_PTR(m_pHeader);
    return m_pHeader->SetItem(nPos, pHeaderItem);
}

inline int CHeaderListBox::InsertHeaderItem(
    IN int nPos,
    IN HD_ITEM * phdi
    )
{
    ASSERT_PTR(m_pHeader);
    return m_pHeader->InsertItem(nPos, phdi);
}

inline BOOL CHeaderListBox::DeleteHeaderItem(
    IN int nPos
    )
{
    ASSERT_PTR(m_pHeader);
    return m_pHeader->DeleteItem(nPos);
}

inline CRMCListBoxHeader * CHeaderListBox::GetHeader()
{
    return m_pHeader;
}

inline BOOL CRMCListBox::IsMultiSelect() const
{
    ASSERT(m_fInitialized);
    return m_fMultiSelect;
}


#endif  // _ODLBOX_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\common\stdafx.h ===
#ifndef __STDAFX_H__
#define __STDAFX_H__

#define VC_EXTRALEAN

#include <ctype.h>

extern "C"
{
    #include <nt.h>
    #include <ntrtl.h>
    #include <nturtl.h>
}

#undef STRICT
#undef VERIFY
#undef ASSERT



#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000


#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED



#include <afxwin.h>
#include <afxdisp.h>
#include <afxext.h>         // MFC extensions
#include <afxcoll.h>        // collection class
#include <afxtempl.h>
#include <afxcmn.h>

#include <atlbase.h>

#include <iiscnfg.h>
#include <inetreg.h>
#include <lmcons.h>
#include <tchar.h>

#include <aclapi.h>

//{{AFX_INSERT_LOCATION}}


#endif // __STDAFX_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\common\sitesecu.cpp ===
/*++

   Copyright    (c)    1994-1999    Microsoft Corporation

   Module  Name :

        sitesecu.cpp

   Abstract:

        Site Security property page

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager (cluster edition)

   Revision History:

--*/

//
// Include Files
//
#include "stdafx.h"
#include "common.h"


#undef dllexp
#include <tcpdllp.hxx>
#define  _RDNS_STANDALONE
#include <rdns.hxx>


#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif // _DEBUG



//#ifdef _DEBUG
//
// Careful here... This may cause build failure
//
extern "C" DEBUG_PRINTS * g_pDebug = NULL;
//#endif // _DEBUG


#define new DEBUG_NEW




CIPAccessDescriptor::CIPAccessDescriptor(
    IN BOOL fGranted 
    )
/*++

Routine Description:

    Dummy Constructor for access description object.  Assumes a single IP
    address of 0.0.0.0

Arguments:
    
    BOOL fGranted : TRUE for 'grant' access, FALSE for 'deny' access      

Return Value:

    N/A

--*/
    : m_fGranted(fGranted),
      m_adtType(CIPAccessDescriptor::ADT_SINGLE),
      m_iaIPAddress(NULL_IP_ADDRESS),
      m_iaSubnetMask(NULL_IP_MASK),
      m_strDomain()
{
}




CIPAccessDescriptor::CIPAccessDescriptor(
    IN const CIPAccessDescriptor & ac
    )
/*++

Routine Description:

    Copy constructor for access description object

Arguments:

    const CIPAccessDescriptor & ac : Source access description object    

Return Value:

    N/A

--*/
    : m_fGranted(ac.m_fGranted),
      m_adtType(ac.m_adtType),
      m_iaIPAddress(ac.m_iaIPAddress),
      m_iaSubnetMask(ac.m_iaSubnetMask),
      m_strDomain(ac.m_strDomain)
{
}



CIPAccessDescriptor::CIPAccessDescriptor(
    IN BOOL fGranted,
    IN DWORD dwIPAddress,
    IN DWORD dwSubnetMask,    OPTIONAL
    IN BOOL fNetworkByteOrder OPTIONAL
    )
/*++

Routine Description:

    Constructor for ip range (ip address/subnet mask pair) 
    access description object.

Arguments:

    BOOL fGranted          : TRUE for 'grant' access, FALSE for 'deny' access      
    DWORD dwIPAddress      : IP Address
    DWORD dwSubnetMask     : The subnet mask or 0xffffffff
    BOOL fNetworkByteOrder : If TRUE, the ip address and subnet mask are in 
                             network byte order

Return Value:

    N/A

--*/
{
    SetValues(fGranted, dwIPAddress, dwSubnetMask, fNetworkByteOrder);
}



CIPAccessDescriptor::CIPAccessDescriptor(
    IN BOOL fGranted,
    IN LPCTSTR lpstrDomain
    )
/*++

Routine Description:

    Constructor for domain name access description object.

Arguments:

    BOOL fGranted       : TRUE for 'grant' access, FALSE for 'deny' access      
    LPCTSTR lpstrDomain : The domain name

Return Value:

    N/A

--*/
{
    SetValues(fGranted, lpstrDomain);
}


void
CIPAccessDescriptor::SetValues(
    IN BOOL fGranted,
    IN DWORD dwIPAddress,
    IN DWORD dwSubnetMask,
    IN BOOL fNetworkByteOrder OPTIONAL
    )
/*++

Routine Description:

    Set values for 'ip range (ip address and subnet mask)' access descriptor,
    or a single ip address if  the mask is 0xffffffff

Arguments:

    BOOL fGranted          : TRUE for 'grant' access, FALSE for 'deny' access
    DWORD dwIPAddress      : IP Address
    DWORD dwSubnetMask     : The subnet mask or ffffffff
    BOOL fNetworkByteOrder : If TRUE, the ip address and subnet mask are in 
                             network byte order

Return Value:

    None

Notes:

    If the subnetmask is 0xffffffff this describes a single ip address.

--*/
{
    m_fGranted = fGranted;
    m_adtType = (dwSubnetMask == NULL_IP_MASK) ? ADT_SINGLE : ADT_MULTIPLE;
    m_iaIPAddress = CIPAddress(dwIPAddress, fNetworkByteOrder);
    m_iaSubnetMask = CIPAddress(dwSubnetMask, fNetworkByteOrder);

    //
    // Not used:
    //
    m_strDomain.Empty();
}



void
CIPAccessDescriptor::SetValues(
    IN BOOL fGranted,
    IN LPCTSTR lpstrDomain
    )
/*++

Routine Description:

    Set values for 'domain name' access descriptor

Arguments:

    BOOL fGranted       : TRUE for 'grant' access, FALSE for 'deny' access
    LPCTSTR lpstrDomain : The domain name

Return Value:

    None

--*/
{
    m_fGranted = fGranted;
    m_adtType = ADT_DOMAIN;

    try
    {
        m_strDomain = lpstrDomain;
    }
    catch(CMemoryException * e)
    {
        TRACEEOLID("!!!exception assigning domain name");
        e->ReportError();
        e->Delete();
    }

    //
    // Not used:
    //
    m_iaIPAddress.SetZeroValue();
    m_iaSubnetMask.SetZeroValue();
}



BOOL 
CIPAccessDescriptor::DuplicateInList(
    IN CObListPlus & oblList
    )
/*++

Routine Description:

    Check to see if a duplicate exists in the provided oblist

Arguments:

    CObListPlus & oblList

Return Value:

    TRUE if a duplicate exists, FALSE otherwise.

Notes:

    As there's no information how this list might be sorted at this point,
    and the list is likely to be small, the search is sequential.

--*/
{
    CObListIter obli(oblList);
    CIPAccessDescriptor * pAccess;

    TRACEEOLID("Looking for duplicate access descriptors");
    while (pAccess = (CIPAccessDescriptor *)obli.Next())
    {
        ASSERT_READ_PTR(pAccess);

        //
        // Eliminate the item itself from the list, and look
        // only for duplicates.
        //
        if (pAccess != this && *this == *pAccess)
        {
            TRACEEOLID("Duplicate access descriptor found");
            return TRUE;
        }
    }

    TRACEEOLID("No duplicate access descriptor found");

    return FALSE;
}



BOOL
CIPAccessDescriptor::operator ==(
    IN const CIPAccessDescriptor & ac
    ) const
/*++

Routine Description:

    Compare against another access descriptor.

Arguments:

    const CIPAccessDescriptor & ac : Object to be compared against

Return Value:

    TRUE if the two are identical

--*/
{
    if ( m_fGranted != ac.m_fGranted
      || m_adtType != ac.m_adtType)
    {
        return FALSE;
    }

    if (IsDomainName())
    {
        return m_strDomain.CompareNoCase(ac.m_strDomain) == 0;
    }

    return m_iaIPAddress == ac.m_iaIPAddress
        && m_iaSubnetMask == ac.m_iaSubnetMask;
}



int
CIPAccessDescriptor::OrderByAddress(
    IN const CObjectPlus * pobAccess
    ) const
/*++

Routine Description:

    Compare two access descriptors against each other. 
    Sorting criteria are in the following order:

    1) 'Granted' sorts before 'Denied'
    2) Domain names are sorted before ip addresses, and are
       sorted alphabetically.
    3) IP Address and IP Address/subnet mask pairs are sorted
       by ip address.

Arguments:

    const CObjectPlus * pobAccess : This really refers to another 
                                    CIPAccessDescriptor to be compared to.

Return Value:

    Sort (+1, 0, -1) return value

--*/
{
    const CIPAccessDescriptor * pob = (CIPAccessDescriptor *)pobAccess;

    //
    // First sort by access/denied
    //
    int n1 = HasAccess() ? 1 : 0;
    int n2 = pob->HasAccess() ? 1 : 0;

    if (n2 != n1)
    {
        //
        // Grant sorts before denied
        //
        return n2 - n1;
    }

    //
    // Secondly, try to sort by domain name (domain name sorts before
    // ip address and ip address/subnet mask objects)
    //
    n1 = IsDomainName() ? 1 : 0;
    n2 = pob->IsDomainName() ? 1 : 0;

    if (n1 != n2)
    {
        //
        // Domain names sort before ip addresses
        //
        return n2 - n1;
    }

    if (n1 && n2)
    {
        //
        // Both are domain names.  Sort alphabetically
        //
        return ::lstrcmpi(QueryDomainName(), pob->QueryDomainName());
    }

    //
    // IP address is the third key.
    //
    return QueryIPAddress().CompareItem(pob->QueryIPAddress());
}



DWORD
AddAccessEntries(
    IN  ADDRESS_CHECK & ac,
    IN  BOOL fName,
    IN  BOOL fGrant,
    OUT CObListPlus & oblAccessList,
    OUT DWORD & cEntries
    )
/*++

Routine Description:

    Add specific kind of addresses from the list to the oblist of
    access entries

Arguments:

    ADDRESS_CHECK & ac              : Address list input object
    BOOL fName                      : TRUE for names, FALSE for ip
    BOOL fGrant                     : TRUE for granted, FALSE for denied        
    CObListPlus & oblAccessList     : ObList to add access entries to
    int & cEntries                  : Returns the number of entries
    
Return Value:

    Error code

Notes:

    Sentinel entries (ip 0.0.0.0) are not added to the oblist, but
    are reflected in the cEntries return value

--*/
{
    DWORD i;
    DWORD dwFlags;

    if (fName)
    {
        //
        // Domain names
        //
        LPSTR lpName;

        cEntries = ac.GetNbName(fGrant);

        for (i = 0L; i < cEntries; ++i)
        {
            if (ac.GetName(fGrant, i,  &lpName, &dwFlags))
            {
                CString strDomain(lpName);

                if (!(dwFlags & DNSLIST_FLAG_NOSUBDOMAIN))
                {
                    strDomain = _T("*.") + strDomain;
                }

                oblAccessList.AddTail(new CIPAccessDescriptor(fGrant, strDomain));
            }
        }
    }
    else
    {
        //
        // IP Addresses
        //
        LPBYTE lpMask;
        LPBYTE lpAddr;
        cEntries = ac.GetNbAddr(fGrant);

        for (i = 0L; i < cEntries; ++i)
        {
            if (ac.GetAddr(fGrant, i,  &dwFlags, &lpMask, &lpAddr))
            {
                DWORD dwIP = MAKEIPADDRESS(lpAddr[0], lpAddr[1], lpAddr[2], lpAddr[3]);
                DWORD dwMask = MAKEIPADDRESS(lpMask[0], lpMask[1], lpMask[2], lpMask[3]);

                if (dwIP == NULL_IP_ADDRESS && dwMask == NULL_IP_MASK)
                {
                    //
                    // Sentinel in the grant list is not added, but
                    // also not subtracted from the count of entries,
                    // which is correct behaviour, since this is
                    // how default grant/deny by default is determined.
                    //
                    TRACEEOLID("Ignoring sentinel");
                }
                else
                {
                    oblAccessList.AddTail(
                        new CIPAccessDescriptor(
                           fGrant,
                           dwIP,
                           dwMask,
                           FALSE
                           )
                        );
                }
            }
        }
    }

    return ERROR_SUCCESS;
}



DWORD
BuildIplOblistFromBlob(
    IN  CBlob & blob,
    OUT CObListPlus & oblAccessList,
    OUT BOOL & fGrantByDefault
    )
/*++

Routine Description:

    Convert a blob to an oblist of access descriptors.

Arguments:

    CBlob & blob                : Input binary large object(blob)
    CObListPlus & oblAccessList : Output oblist of access descriptors
    BOOL & fGrantByDefault      : Returns TRUE if access is granted
                                  by default, FALSE otherwise

Return Value:

    Error Return Code

--*/
{
    oblAccessList.RemoveAll();

    if (blob.IsEmpty())
    {
        return ERROR_SUCCESS;
    }

    ADDRESS_CHECK ac;
    ac.BindCheckList(blob.GetData(), blob.GetSize());

    DWORD cGrantAddr, cGrantName, cDenyAddr, cDenyName;

    //                   Name/IP Granted/Deny
    // ============================================================
    AddAccessEntries(ac, TRUE,   TRUE,  oblAccessList, cGrantName);
    AddAccessEntries(ac, FALSE,  TRUE,  oblAccessList, cGrantAddr);
    AddAccessEntries(ac, TRUE,   FALSE, oblAccessList, cDenyName);
    AddAccessEntries(ac, FALSE,  FALSE, oblAccessList, cDenyAddr);

    ac.UnbindCheckList();

    fGrantByDefault = (cDenyAddr + cDenyName != 0L)
        || (cGrantAddr + cGrantName == 0L);

    return ERROR_SUCCESS;
}  



LPSTR 
PrepareDomainName(
    IN  LPSTR lpName,
    OUT DWORD * pdwFlags
    )
/*++

Routine Description:

    Check to see if the domain name contains a wild card,
    if so remove it.  Set the flags based on the domain name

Arguments:

    LPSTR  lpName       : Input domain name
    DWORD * pdwFlags    : Return the flags for AddName

Return:

    Pointer to the cleaned up domain name

--*/
{
    *pdwFlags = 0L;

    if (!strncmp(lpName, "*.", 2))
    {
        return lpName + 2;
    }

    *pdwFlags |= DNSLIST_FLAG_NOSUBDOMAIN;

    return lpName;
}



void
BuildIplBlob(
    IN  CObListPlus & oblAccessList,
    IN  BOOL fGrantByDefault,
    OUT CBlob & blob
    )
/*++

Routine Description:

    Build a blob from an oblist of access descriptors

Arguments:

    CObListPlus & oblAccessList  : Input oblist of access descriptors
    BOOL fGrantByDefault         : TRUE if access is granted by default
    CBlob & blob                 : Output blob

Return Value:

    None

Notes:

    If fGrantByDefault is FALSE, e.g. access is to be denied by
    default, but nobody is specifically granted access, then add
    a dummy entry 0.0.0.0 to the grant list.

    If grant by default is on, then granted entries will not be
    added to the blob.  Similart for denied entries if deny by
    default is on.

--*/
{
    ADDRESS_CHECK ac;

    ac.BindCheckList();

    int cItems = 0;

    CObListIter obli(oblAccessList);
    const CIPAccessDescriptor * pAccess;

    //
    // Should be empty to start with.
    //
    ASSERT(blob.IsEmpty());
    blob.CleanUp();

    BYTE bMask[4];
    BYTE bIp[4];

    while (pAccess = (CIPAccessDescriptor *)obli.Next())
    {
        ASSERT_READ_PTR(pAccess);

        if (pAccess->HasAccess() == fGrantByDefault)
        {
            //
            // Skip this entry -- it's irrelevant
            //
            continue;
        }

        if (pAccess->IsDomainName())
        {
            LPSTR lpName = AllocAnsiString(pAccess->QueryDomainName());
            if (lpName)
            {
                DWORD dwFlags;
                LPSTR lpDomain = PrepareDomainName(lpName, &dwFlags);
                ac.AddName(
                    pAccess->HasAccess(),
                    lpDomain,
                    dwFlags
                    );
                FreeMem(lpName);
            }
        }
        else
        {
            //
            // Build with network byte order
            //
            ac.AddAddr(
                pAccess->HasAccess(),
                AF_INET, 
                CIPAddress::DWORDtoLPBYTE(pAccess->QuerySubnetMask(FALSE), bMask),
                CIPAddress::DWORDtoLPBYTE(pAccess->QueryIPAddress(FALSE), bIp)  
                );
        }

        ++cItems;
    }

    if (cItems == 0 && !fGrantByDefault)
    {
        //
        // List is empty.  If deny by default is on, create
        // a dummy sentinel entry to grant access to single
        // address 0.0.0.0, otherwise we're ok.
        //
        ac.AddAddr(
            TRUE,
            AF_INET, 
            CIPAddress::DWORDtoLPBYTE(NULL_IP_MASK, bMask),
            CIPAddress::DWORDtoLPBYTE(NULL_IP_ADDRESS, bIp)  
            );
        ++cItems;
    }

    if (cItems > 0)
    {
        blob.SetValue(ac.QueryCheckListSize(), ac.QueryCheckListPtr(), TRUE);
    }

    ac.UnbindCheckList();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\common\sitesecu.h ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        sitesecu.h

   Abstract:

        Site Security property page definitions

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/

#ifndef _SITESECU_H_
#define _SITESECU_H_



#define DEFAULT_GRANTED     0
#define DEFAULT_DENIED      1



class COMDLL CIPAccessDescriptor : public CObjectPlus
/*++

Class Description:

    Access description object

Public Interface:

    CIPAccessDescriptor : Various overload constructors for the different types

    SetValues         : Set values, overloaded on a per type basis
    DuplicateInList   : Check to see if a duplicate entry exists in the list
    GrantAccess       : Grant or deny access
    HasAccess         : Query whether the object describes a 'grant' or 'deny'
                        item
    IsSingle          : Query whether the object describes a single IP address
    IsMultiple        : Query whether the object describes a range of ip 
                        addresses
    IsDomainName      : Query whether the object describes a domain name
    QueryIPAddress    : Get the object's IP address
    QuerySubnetMask   : Get the object's subnet mask value
    QueryDomainName   : Get the object's domain name
    operator ==       : Comparison operator
    OrderByAddress    : Sorting helper

--*/
{
protected:
    //
    // Access descriptor types
    //
    enum AD_TYPE
    {
        ADT_SINGLE,
        ADT_MULTIPLE,
        ADT_DOMAIN,
    };

//
// Constructors
//
public:
    //
    // Construct NULL descriptor
    //
    CIPAccessDescriptor(
        IN BOOL fGranted = TRUE
        );

    //
    // Copy Constructor
    //
    CIPAccessDescriptor(
        IN const CIPAccessDescriptor & ac
        );

    //
    // Construct with ip address(ip address/subnet mask) descriptor
    // if subnet massk is ffffffff this describes a single ip address
    //
    CIPAccessDescriptor(
        IN BOOL fGranted,
        IN DWORD dwIpAddress,
        IN DWORD dwSubnetMask = NULL_IP_MASK,
        IN BOOL fNetworkByteOrder = FALSE
        );

    //
    // Construct domain name descriptor
    //
    CIPAccessDescriptor(
        IN BOOL fGranted,
        IN LPCTSTR lpstrDomain
        );

//
// Interface
//
public:
    //
    // Set ip address/ip range value
    //
    void SetValues(
        IN BOOL fGranted,
        IN DWORD dwIpAddress,
        IN DWORD dwSubnetMask = NULL_IP_MASK,
        BOOL fNetworkByteOrder = FALSE
        );

    //
    // Set domain name
    //
    void SetValues(
        IN BOOL fGranted,
        IN LPCTSTR lpstrDomain
        );

    //
    // Check to see if a duplicate exists in the 
    // list.  
    //
    BOOL DuplicateInList(
        IN CObListPlus & oblList
        );
        
//
// Access
//
public:
    //
    // Access Functions
    //
    BOOL HasAccess() const;

    //
    // Grant/deny access
    //
    void GrantAccess(
        IN BOOL fGranted = TRUE
        );

    //
    // TRUE if this item is single ip address
    //
    BOOL IsSingle() const;

    //
    // True if this item describes an ip range
    //
    BOOL IsMultiple() const;

    //
    // True if this item describes a domain name
    //
    BOOL IsDomainName() const;

    //
    // Get the ip address as a DWORD
    //
    DWORD QueryIPAddress(
        IN BOOL fNetworkByteOrder
        ) const;

    //
    // Get the ip address as ip address object
    //
    CIPAddress QueryIPAddress() const;

    //
    // Get the subnet mask as a DWORD
    //
    DWORD QuerySubnetMask(
        IN BOOL fNetworkByteOrder
        ) const;

    //
    // Get the subnet mask as an ip address object
    //
    CIPAddress QuerySubnetMask() const;

    //
    // Get the domain name
    //
    LPCTSTR QueryDomainName() const;

public:
    //
    // Comparison Operator
    //
    BOOL operator ==(
        IN const CIPAccessDescriptor & ac
        ) const;

    //
    // Sorting Helper
    //
    int OrderByAddress(
        IN const CObjectPlus * pobAccess
        ) const;

private:
    BOOL m_fGranted;
    AD_TYPE m_adtType;
    CString m_strDomain;
    CIPAddress m_iaIPAddress;
    CIPAddress m_iaSubnetMask;
};



//
// Helper Functions
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<


//
// Convert an oblist of access descriptors to a blob
//
void 
COMDLL 
BuildIplBlob(
    IN  CObListPlus & oblAccessList,
    IN  BOOL fGrantByDefault,
    OUT CBlob & blob
    );


//
// Reverse the above, build an oblist of access descriptors
// from a blob
//
DWORD 
COMDLL 
BuildIplOblistFromBlob(
    IN  CBlob & blob,
    OUT CObListPlus & oblAccessList,
    OUT BOOL & fGrantByDefault
    );



//
// Inline Expansion
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

inline BOOL CIPAccessDescriptor::HasAccess() const
{
    return m_fGranted;
}

inline void CIPAccessDescriptor::GrantAccess(
    IN BOOL fGranted
    )
{
    m_fGranted = fGranted;
}

inline BOOL CIPAccessDescriptor::IsSingle() const
{
    return m_adtType == ADT_SINGLE;
}

inline BOOL CIPAccessDescriptor::IsMultiple() const
{
    return m_adtType == ADT_MULTIPLE;
}

inline BOOL CIPAccessDescriptor::IsDomainName() const
{
    return m_adtType == ADT_DOMAIN;
}

inline DWORD CIPAccessDescriptor::QueryIPAddress(
    IN BOOL fNetworkByteOrder
    ) const
{
    ASSERT(!IsDomainName());
    return m_iaIPAddress.QueryIPAddress(fNetworkByteOrder);
}

inline CIPAddress CIPAccessDescriptor::QueryIPAddress() const
{
    ASSERT(!IsDomainName());
    return m_iaIPAddress;
}

inline DWORD CIPAccessDescriptor::QuerySubnetMask(
    IN BOOL fNetworkByteOrder
    ) const
{
    ASSERT(!IsDomainName());
    return m_iaSubnetMask.QueryIPAddress(fNetworkByteOrder);
}

inline CIPAddress CIPAccessDescriptor::QuerySubnetMask() const
{
    ASSERT(!IsDomainName());
    return m_iaSubnetMask;
}

inline LPCTSTR CIPAccessDescriptor::QueryDomainName() const
{
    ASSERT(IsDomainName());
    return (LPCTSTR)m_strDomain;
}



#endif  // _SITESECU_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\common\utcls.cpp ===
/*++

   Copyright    (c)    1994-1999    Microsoft Corporation

   Module  Name :

        utcls.cpp

   Abstract:

        Internet Properties base classes

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/


//
// Include Files
//
#include "stdafx.h"
#include "common.h"
#include "idlg.h"

#include "mmc.h"

extern "C"
{
    #include <lm.h>
}

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif


#define new DEBUG_NEW


#define SZ_REG_KEY_BASE  _T("Software\\Microsoft\\%s")


BOOL
IsServerLocal(
    IN LPCTSTR lpszServer
    )
/*++

Routine Description:

    Check to see if the given name refers to the local machine

Arguments:

    LPCTSTR lpszServer   : Server name

Return Value:

    TRUE if the given name refers to the local computer, FALSE otherwise

Note:

    Doesn't work if the server is an ip address

--*/
{
    TCHAR szComputerName[MAX_COMPUTERNAME_LENGTH + 1];
    DWORD dwSize = sizeof(szComputerName);

    //
    // CODEWORK(?): we're not checking for all the ip addresses
    //              on the local box or full dns names.
    //
    //              Try GetComputerNameEx when we're building with NT5 
    //              settings.
    //
    return (!lstrcmpi(_T("localhost"), PURE_COMPUTER_NAME(lpszServer))
         || !lstrcmp( _T("127.0.0.1"), PURE_COMPUTER_NAME(lpszServer)))
         || (GetComputerName(szComputerName, &dwSize) 
             && !lstrcmpi(szComputerName, PURE_COMPUTER_NAME(lpszServer)));
}



BOOL
GetVolumeInformationSystemFlags(
    IN  LPCTSTR lpszPath,
    OUT DWORD * pdwSystemFlags
    )
/*++

Routine Description:

    Get the system flags for the path in question

Arguments:

    LPCTSTR lpszPath            : Path
    DWORD * pdwSystemFlags      : Returns system flags

Return Value:

    TRUE for success, FALSE for failure.

--*/
{
    ASSERT_WRITE_PTR(pdwSystemFlags);

    TRACEEOLID("Getting system flags for " << lpszPath);

    DWORD dwMaxComponentLength;
    TCHAR szRoot[MAX_PATH + 1];
    TCHAR szFileSystem[MAX_PATH + 1];

    //
    // Generating root path
    //
    if (IsUNCName(lpszPath))
    {
        //
        // Root path of a UNC path is \\foo\bar\
        //
        ASSERT(lstrlen(lpszPath) < MAX_PATH);

        int cSlashes = 0;
        LPCTSTR lpszSrc = lpszPath;
        LPTSTR lpszDst = szRoot;

        while (cSlashes < 4 && *lpszSrc)
        {
            if ((*lpszDst++ = *lpszSrc++) == '\\')
            {
                ++cSlashes;
            }
        }    

        if (!*lpszSrc)
        {
            *lpszDst++ = '\\';
        }

        *lpszDst = '\0';
    }
    else
    {
        ::wsprintf(szRoot, _T("%c:\\"), *lpszPath);
    }

    TRACEEOLID("Root path is " << szRoot);
    
    return ::GetVolumeInformation(
        szRoot,
        NULL,
        0,
        NULL,
        &dwMaxComponentLength,
        pdwSystemFlags,
        szFileSystem,
        STRSIZE(szFileSystem)
        );
}



LPCTSTR
GenerateRegistryKey(
    OUT CString & strBuffer,
    IN  LPCTSTR lpszSubKey OPTIONAL
    )
/*++

Routine Description:

    Generate a registry key name based on the current app, and a
    provided subkey (optional)

Arguments:

    CString & strBuffer : Buffer to create registry key name into.
    LPCTSTR lpszSubKey  : Subkey name or NULL

Return Value:

    Pointer to the registry key value 

--*/
{
    try
    {
        //
        // Use the app name as the primary registry name
        //
        CWinApp * pApp = ::AfxGetApp();

        if (!pApp)
        {
            ASSERT_MSG("No app object -- can't generate registry key name");

            return NULL;
        }

        strBuffer.Format(SZ_REG_KEY_BASE, pApp->m_pszAppName);

        if (lpszSubKey)
        {
            strBuffer += _T("\\");
            strBuffer += lpszSubKey;
        }

        TRACEEOLID("Registry key is " << strBuffer);
    }
    catch(CMemoryException * e)
    {
        TRACEEOLID("!!!exception building regkey");
        e->ReportError();
        e->Delete();
        return NULL;
    }

    return strBuffer;
}







//
// CBlob Implementation
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<


CBlob::CBlob() 
/*++

Routine Description:

    NULL constructor

Arguments:

    None

Return Value:

    N/A

--*/
    : m_pbItem(NULL), 
      m_dwSize(0L)
{
}



CBlob::CBlob(
    IN DWORD dwSize,
    IN PBYTE pbItem,
    IN BOOL fMakeCopy
    )
/*++

Routine Description:

    Constructor

Arguments:

    DWORD dwSize        : Size of memory block
    PBYTE pbItem        : Pointer to memory block
    BOOL fMakeCopy      : If TRUE, makes a copy of the memory block.
                          If FALSE, takes ownership of the pointer.

Return Value:

    N/A

--*/
    : m_pbItem(NULL),
      m_dwSize(0L)
{
    SetValue(dwSize, pbItem, fMakeCopy);
}



CBlob::CBlob(
    IN const CBlob & blob
    )
/*++

Routine Description:

    Copy constructor

Arguments:

    const CBlob & blob      : Source blob

Return Value:

    N/A

Notes:

    This contructor makes a copy of the memory block in question.

--*/
    : m_pbItem(NULL),
      m_dwSize(0L)
{
    SetValue(blob.GetSize(), blob.m_pbItem, TRUE);
}



void
CBlob::SetValue(
    IN DWORD dwSize,
    IN PBYTE pbItem,
    IN BOOL fMakeCopy OPTIONAL
    )
/*++

Routine Description:

    Assign the value to this binary object.  If fMakeCopy is FALSE,
    the blob will take ownership of the pointer, otherwise a copy
    will be made.

Arguments:

    DWORD dwSize        : Size in bytes
    PBYTE pbItem        : Byte streadm
    BOOL fMakeCopy      : If true, make a copy, else assign pointer

Return Value:

    None

--*/
{
    ASSERT_READ_PTR2(pbItem, dwSize);

    if (!IsEmpty())
    {
        TRACEEOLID("Assigning value to non-empty blob.  Cleaning up");
        CleanUp();
    }

    if (dwSize > 0L)
    {
        //
        // Make private copy
        //
        m_dwSize = dwSize;

        if (fMakeCopy)
        {
            m_pbItem = (PBYTE)AllocMem(m_dwSize);
            if (NULL != m_pbItem)
            {
               CopyMemory(m_pbItem, pbItem, dwSize);
            }
        }
        else
        {
            m_pbItem = pbItem;
        }
    }
}



void 
CBlob::CleanUp()
/*++

Routine Description:

    Delete data pointer, and reset pointer and size.

Arguments:

    None

Return Value:

    None

--*/
{
    if (m_pbItem)
    {
        FreeMem(m_pbItem);
    }

    m_pbItem = NULL;
    m_dwSize = 0L;
}



CBlob & 
CBlob::operator =(
    IN const CBlob & blob
    )
/*++

Routine Description:

    Assign values from another CBlob. 

Arguments:

    const CBlob & blob      : Source blob

Return Value:

    Reference to this object

--*/
{
    //
    // Make copy of data
    //
    SetValue(blob.GetSize(), blob.m_pbItem, TRUE);

    return *this;
}



BOOL 
CBlob::operator ==(
    IN const CBlob & blob
    ) const
/*++

Routine Description:
    
    Compare two binary large objects.  In order to match, the objects
    must be the same size, and byte identical.

Arguments:

    const CBlob & blob      : Blob to compare against.

Return Value:

    TRUE if the objects match, FALSE otherwise.

--*/
{
    if (GetSize() != blob.GetSize())
    {
        return FALSE;
    }

    return memcmp(m_pbItem, blob.m_pbItem, GetSize()) == 0;    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\common\strfn.cpp ===
/*++

   Copyright    (c)    1994-1999    Microsoft Corporation

   Module  Name :

        strfrn.cpp

   Abstract:

        String Functions

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager (cluster edition)

   Revision History:

--*/

//
// Include Files
//
#include "stdafx.h"
#include "common.h"
#include <pudebug.h>


#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif


#define new DEBUG_NEW


#ifdef _MT

    //
    // Thread protected stuff
    //
    #define RaiseThreadProtection() EnterCriticalSection(&_csSect)
    #define LowerThreadProtection() LeaveCriticalSection(&_csSect)

    static CRITICAL_SECTION _csSect;

#else

    #pragma message("Module is not thread-safe")

    #define RaiseThreadProtection()
    #define LowerThreadProtection()

#endif // _MT

#define MAKE_NULL(obj) { if (obj) delete obj, obj = NULL; }


//
// Text copy functions
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



BOOL
PCToUnixText(
    OUT LPWSTR & lpstrDestination,
    IN  const CString strSource
    )
/*++

Routine Description:

    Convert CR/LF string to LF string (T String to W String).  Destination
    string will be allocated.

Arguments:

    LPWSTR & lpstrDestination : Destination string
    const CString & strSource : Source string

Return Value:

    TRUE for success, FALSE for failure.

--*/
{
    int cch = strSource.GetLength() + 1;
    lpstrDestination = (LPWSTR)AllocMem(cch * sizeof(WCHAR));

    if (lpstrDestination != NULL)
    {
        LPCTSTR lpS = strSource;
        LPWSTR lpD = lpstrDestination;

        do
        {
            if (*lpS != _T('\r'))
            {

#ifdef UNICODE
                *lpD++ = *lpS;
#else
                ::MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, lpS, 1, lpD++, 1);
#endif // UNICODE

            }
        }
        while (*lpS++);

        return TRUE;
    }

    return FALSE;
}



BOOL
UnixToPCText(
    OUT CString & strDestination,
    IN  LPCWSTR lpstrSource
    )
/*++

Routine Description:

    Expand LF to CR/LF (no allocation necessary) W String to T String.

Arguments:

    CString & strDestination : Destination string
    LPCWSTR lpstrSource      : Source string

Return Value:

    TRUE for success, FALSE for failure.

--*/
{
    BOOL fSuccess = FALSE;

    try
    {
        LPCWSTR lpS = lpstrSource;

        //
        // Since we're doubling every linefeed length, assume
        // the worst possible expansion to start with.
        //
        int cch = (::lstrlenW(lpstrSource) + 1) * 2;
        LPTSTR lpD = strDestination.GetBuffer(cch);

        do
        {
            if (*lpS == L'\n')
            {
                *lpD++ = _T('\r');
            }

#ifdef UNICODE
            *lpD++ = *lpS;
#else
            ::WideCharToMultiByte(CP_ACP, 0, lpS, 1, lpD++, 1, NULL, NULL);
#endif // UNICODE

        }
        while (*lpS++);

        strDestination.ReleaseBuffer();

        ++fSuccess;
    }
    catch(CMemoryException * e)
    {
        TRACEEOLID("Exception in UnixToPCText");
        e->ReportError();
        e->Delete();
    }

    return fSuccess;
}

/*

BOOL
TextToText(
    OUT LPWSTR & lpstrDestination,
    IN  const CString & strSource
    )
/*++

Routine Description:

    Straight copy with allocation. T String to W String.

Arguments:

    LPWSTR & lpstrDestination : Destination string
    const CString & strSource : Source string

Return Value:

    TRUE for success, FALSE for failure.

--/
{
    int cch = strSource.GetLength() + 1;
    lpstrDestination = (LPWSTR)AllocMem(cch * sizeof(WCHAR));

    if (lpstrDestination != NULL)
    {
        TWSTRCPY(lpstrDestination, strSource, cch);
        return TRUE;
    }

    return FALSE;
}



#ifndef UNICODE



#define WBUFF_SIZE  255



LPWSTR
ReferenceAsWideString(
    IN LPCTSTR str
    )
/*++

Routine Description:

    Reference a T string as a W string (non-unicode only).

Arguments:

    LPCTSTR str : Source string

Return Value:

    Wide char pointer to wide string.

Notes:

    This uses an internal wide char buffer, which will be overwritten
    by subsequent calls to this function.

--/
{
    static WCHAR wchBuff[WBUFF_SIZE + 1];

    ::MultiByteToWideChar(
        CP_ACP,
        MB_PRECOMPOSED,
        str,
        -1,
        wchBuff,
        WBUFF_SIZE + 1
        );

    return wchBuff;
}



#endif !UNICODE


*/


LPSTR
AllocAnsiString(
    IN LPCTSTR lpString
    )
/*++

Routine Description:

    Convert the wide string to an ansi (multi-byte) string, which is allocated
    by this function

Arguments:

    LPCTSTR lpString        : Input wide string

Return Value:

    Pointer to the allocated string

--*/
{
    //
    // Character counts are DBCS friendly
    //
    int cChars = lstrlen(lpString);
    int nLength = (cChars * 2) + 1;
    LPSTR lp = (LPSTR)AllocMem(nLength);

    if (lp)
    {
        ::WideCharToMultiByte(
            CP_ACP,
            0,
            lpString,
            cChars + 1,
            lp,
            nLength,
            NULL,
            NULL
            );
    }

    return lp;
}




LPTSTR
AllocString(
    IN LPCTSTR lpString,
    IN int nLen 
    )
/*++

Routine Description:

    Allocate and copy string

Arguments:

    LPCTSTR lpString        : Input string
    int nLen                : Length or -1 to autodetermine

Return Value:

    Pointer to the allocated string

--*/
{
    if (nLen < 0)
    {
        nLen = lstrlen(lpString);
    }
    
    LPTSTR lp = (LPTSTR)AllocMem((nLen + 1) * sizeof(TCHAR));

    if (lp)
    {
        lstrcpy(lp, lpString);
    }

    return lp;
}



BOOL
IsUNCName(
    IN const CString & strDirPath
    )
/*++

Routine Description:

    Determine if the given string path is a UNC path.

Arguments:

    const CString & strDirPath : Directory path string

Return Value:

    TRUE if the path is a UNC path, FALSE otherwise.

Notes:

    Any string of the form \\foo\bar\whatever is considered a UNC path,
    with the exception of \\.\device paths.  No validation for the 
    existance occurs, only for the correct format.

--*/
{
    if (strDirPath.GetLength() >= 5)  // It must be at least as long as \\x\y,
    {                                 //
        LPCTSTR lp = strDirPath;      //
        if (*lp == _T('\\')           // It must begin with \\,
         && *(lp + 1) == _T('\\')     //
         && *(lp + 2) != _T('.')      // This is a device.
         && _tcschr(lp + 3, _T('\\')) // And have at least one more \ after that
           )
        {
            //
            // Yes, it's a UNC path
            //
            return TRUE;
        }
    }

    //
    // No, it's not
    //
    return FALSE;
}



BOOL 
IsDevicePath(
    IN const CString & strDirPath
    )
/*++

Routine Description:

    Determine if the given path is of the form "\\.\foobar"

Arguments:

    const CString & strDirPath : Directory path string

Return Value:

    TRUE if the path given is a device path, 
    FALSE if it is not.

--*/
{
    LPCTSTR lpszDevice = _T("\\\\.\\");

    return _tcsnccmp(strDirPath, lpszDevice, lstrlen(lpszDevice)) == 0;
}


BOOL
PathIsValid(LPCTSTR path)
{
    LPCTSTR p = path;
    BOOL rc = TRUE;
    if (p == NULL || *p == 0)
        return FALSE;
    while (*p != 0)
    {
        switch (*p)
        {
        case TEXT('|'):
        case TEXT('>'):
        case TEXT('<'):
        case TEXT('/'):
        case TEXT('?'):
        case TEXT('*'):
//        case TEXT(';'):
//        case TEXT(','):
        case TEXT('"'):
            rc = FALSE;
            break;
        default:
            if (*p < TEXT(' '))
            {
                rc = FALSE;
            }
            break;
        }
        if (!rc)
        {
            break;
        }
        p++;
    }
    return rc;
}


BOOL
IsFullyQualifiedPath(
    IN const CString & strDirPath
    )
/*++

Routine Description:

    Determine if the given string is a fully qualified path name

Arguments:

    const CString & strDirPath : Directory path string

Return Value:

    TRUE if the path is a fully qualified path name


--*/
{
    return strDirPath.GetLength() >= 3
        && strDirPath[1] == _T(':')
        && strDirPath[2] == _T('\\');
}



BOOL
IsNetworkPath(
    IN  const CString & strDirPath,
    OUT CString * pstrDrive,        OPTIONAL
    OUT CString * pstrUNC           OPTIONAL
    )
/*++

Routine Description:

    Determine if the path exists on a network directory
    in the context of the local machine.

Arguments:

    const CString & strDirPath : Directory path string
    CString * pstrDrive        : Returns drive
    CString * pstrUNC          : Returns UNC path

Return Value:

    TRUE if the path is a network path, FALSE if it is local.

Notes:

    Only fully qualified paths with drive letters are checked.

--*/
{
    BOOL fUNC = FALSE;
    CString strDrive;

    try
    {
        if (pstrDrive == NULL)
        {
            pstrDrive = &strDrive;
        }

        ASSERT(strDirPath[1] == _T(':'));

        if (strDirPath[1] == _T(':'))
        {
            *pstrDrive = _T("?:");

            //
            // Fill in actual drive letter
            //
            pstrDrive->SetAt(0, strDirPath[0]);
            UINT nType = GetDriveType(*pstrDrive);

            //
            // DRIVE_NO_ROOT_DIR? this is a little dodgy, but
            // this is the result I get back after browsing
            // using a file open dialog.  Weird.
            //
            fUNC = (nType == DRIVE_NO_ROOT_DIR || nType == DRIVE_REMOTE);
        }

        //
        // Return UNC path if requested
        //
        if (fUNC && pstrUNC != NULL)
        {
            DWORD dwSize = _MAX_PATH;
            LPTSTR lp = pstrUNC->GetBuffer(dwSize);
            ::WNetGetConnection(*pstrDrive, lp, &dwSize);
            pstrUNC->ReleaseBuffer();
        }
    }
    catch(CException * e)
    {
        e->ReportError();
        e->Delete();
    }

    return fUNC;
}



LPCTSTR
MakeUNCPath(
    IN OUT CString & strDir,
    IN LPCTSTR lpszOwner,
    IN LPCTSTR lpszDirectory
    )
/*++

Routine Description:

    Convert the given directory to a UNC path.

Arguments:

    CString & strDir      : UNC String.
    LPCTSTR lpszOwner     : Computer name
    LPCTSTR lpszDirectory : Source string

Return Value:

    Pointer to strDir

Notes:

    The owner may or may not start with "\\".  If it doesn't, the
    backslashes are provided.

--*/
{
    //
    // Try to make make a unc path out of the directory
    //
    ASSERT(lpszDirectory[1] == _T(':'));

    strDir.Format(
        _T("\\\\%s\\%c$\\%s"),
        PURE_COMPUTER_NAME(lpszOwner),
        lpszDirectory[0],
        lpszDirectory + 3
        );

    return (LPCTSTR)strDir;
}



BOOL
IsURLName(
    IN const CString & strDirPath
    )
/*++

Routine Description:

    Determine if the given string path is an URL path.

Arguments:

    const CString & strDirPath : Directory path string

Return Value:

    TRUE if the path is an URL path, FALSE otherwise.

Notes:

    Any string of the form protocol://whatever is considered an URL path

--*/
{
    if (strDirPath.GetLength() >= 4)  // It must be at least as long as x://
    {                                 //
        if (strDirPath.Find(_T("://")) > 0) // Must contain ://
        {
            //
            // Yes, it's an URL path
            //
            return TRUE;
        }
    }

    //
    // No, it's not
    //
    return FALSE;
}



int
CStringFindNoCase(
    IN const CString & strSrc,
    IN LPCTSTR lpszSub
    )
/*++

Routine Description:

    This should be CString::FindNoCase().  Same as CString::Find(),
    but case-insensitive.

Arguments:

    const CString & strSrc  : Source string
    LPCTSTR lpszSub         : String to look for.

Return Value:

    The position of the substring, or -1 if not found.

--*/
{
    LPCTSTR lp1 = strSrc;
    LPCTSTR lp2, lp3;
    int nPos = -1;

    while (*lp1)
    {
        lp2 = lp1;
        lp3 = lpszSub;

        while(*lp2 && *lp3 && _totupper(*lp2) == _totupper(*lp3))
        {
            ++lp2;
            ++lp3;
        }

        if (!*lp3)
        {
            //
            // Found the substring
            //
            nPos = (int)(lp1 - (LPCTSTR)strSrc);
            break;
        }
    
        ++lp1;                    
    }

    return nPos;
}



DWORD
ReplaceStringInString(
    OUT IN CString & strBuffer,
    IN  CString & strTarget,
    IN  CString & strReplacement,
    IN  BOOL fCaseSensitive
    )
/*++

Routine Description:

    Replace the first occurrence of a string with a second string
    inside a third string.

Arguments:

    CString & strBuffer         : Buffer in which to replace
    CString & strTarget         : String to look for
    CString & strReplacement    : String to replace it with
    BOOL fCaseSensitive         : TRUE for case sensitive replacement.
    
Return Value:

    ERROR_SUCCESS for successful replacement.
    ERROR_INVALID_PARAMETER if any string is empty,
    ERROR_FILE_NOT_FOUND if the target string doesn't exist, or
    another win32 error code indicating failure.

--*/
{
    if (strBuffer.IsEmpty() || strTarget.IsEmpty() || strReplacement.IsEmpty())
    {
        return ERROR_INVALID_PARAMETER;
    }

    DWORD err = ERROR_FILE_NOT_FOUND;
    int nPos = fCaseSensitive 
        ? strBuffer.Find(strTarget)
        : CStringFindNoCase(strBuffer, strTarget);

    if (nPos >= 0)
    {
        try
        {
            CString str(strBuffer.Left(nPos));

            str += strReplacement;
            str += strBuffer.Mid(nPos + strTarget.GetLength());
            strBuffer = str;

            err = ERROR_SUCCESS;
        }
        catch(CMemoryException * e)
        {
            e->Delete();
            err = ERROR_NOT_ENOUGH_MEMORY;
        }
    }    

    return err;
}




DWORD
DeflateEnvironmentVariablePath(
    IN LPCTSTR lpszEnvVar,
    IN OUT CString & strTarget
    )
/*++

Routine Description:

    Take a path, and if the path represents a superset of the
    path in the environment variable given, replace the relevant
    portion of the path with the environment variable.

Arguments:

    LPCTSTR lpszEnvVar      : Environment variable
    CString & strTarget     : Path

Return Value:

    ERROR_SUCCESS if the replacement was done succesfully,
    ERROR_FILE_NOT_FOUND if the path represented by the environment
    variable is not contained within the string, or an other win32
    error for error conditions

--*/
{
    CError err;
    CString strEnv;

    if (!::GetEnvironmentVariable(
        lpszEnvVar,
        strEnv.GetBuffer(_MAX_PATH),
        _MAX_PATH
        ))
    {
        err.SetLastWinError();
    }

    strEnv.ReleaseBuffer();

    if (err.Succeeded())
    {
        try
        {
            CString strReplacement(_T("%"));
            strReplacement += lpszEnvVar;
            strReplacement += _T("%");

            err = ReplaceStringInString(
                strTarget,
                strEnv,
                strReplacement,
                FALSE 
                );
        }
        catch(CMemoryException * e)
        {
            err = ERROR_NOT_ENOUGH_MEMORY;
            e->Delete();
        }
    }

    return err;
}



LPCTSTR
GUIDToCString(
    IN  REFGUID guid,
    OUT CString & str
    )
/*++

Routine Description:

    Convert a GUID to a CString, returning pointer to the string

Arguments:

    REFGUID       : GUID to be converted
    CString & str : Output string buffer

Return Value:

    Pointer to the string

--*/
{
    LPTSTR lpGUID = str.GetBuffer(MAX_PATH);

    if (lpGUID)
    {
        ::StringFromGUID2(guid, lpGUID, MAX_PATH);
        str.ReleaseBuffer();
    }

    return str;
}



int
CountCharsToDoubleNull(
    IN LPCTSTR lp
    )
/*++

Routine Description:

    Count TCHARS up to and including the double NULL.

Arguments:

    LPCTSTR lp       : TCHAR Stream

Return Value:

    Number of chars up to and including the double NULL

--*/
{
    int cChars = 0;

    for(;;)
    {
        ++cChars;

        if (lp[0] == _T('\0') && lp[1] == _T('\0'))
        {
            return ++cChars;
        }

        ++lp;
    }
}



DWORD
ConvertDoubleNullListToStringList(
    IN  LPCTSTR lpstrSrc,
    OUT CStringList & strlDest,
    IN  int cChars                  OPTIONAL
    )
/*++

Routine Description:

    Convert a double null terminate list of null terminated strings to a more
    manageable CStringListEx

Arguments:

    LPCTSTR lpstrSrc       : Source list of strings
    CStringList & strlDest : Destination string list.
    int cChars             : Number of characters in double NULL list. if
                             -1, autodetermine length

Return Value:

    ERROR_SUCCESS           if the list was converted properly
    ERROR_INVALID_PARAMETER if the list was empty
    ERROR_NOT_ENOUGH_MEMORY if there was a mem exception

--*/
{
    DWORD err = ERROR_SUCCESS;

    if (lpstrSrc == NULL)
    {
        return ERROR_INVALID_PARAMETER;
    }

    if (cChars < 0)
    {
        //
        // Calculate our own size.  This might be off if multiple
        // blank linkes (0) appear in the multi_sz, so the character
        // size is definitely preferable
        //
        cChars = CountCharsToDoubleNull(lpstrSrc);
    }

    try
    {
        strlDest.RemoveAll();

        if (cChars == 2 && *lpstrSrc == _T('\0'))
        {
            //
            // Special case: MULTI_SZ containing only
            // a double NULL are in fact blank entirely.
            //
            // N.B. IMHO this is a metabase bug -- RonaldM
            //
            --cChars;
        }

        //
        // Grab strings until only the final NULL remains
        //
        while (cChars > 1)
        {
            CString strTmp = lpstrSrc;
            strlDest.AddTail(strTmp);
            lpstrSrc += (strTmp.GetLength() + 1);
            cChars -= (strTmp.GetLength() + 1);
        }
    }
    catch(CMemoryException * e)
    {
        TRACEEOLID("!!! exception building stringlist");
        err = ERROR_NOT_ENOUGH_MEMORY;
        e->Delete();
    }

    return err;
}



DWORD
ConvertStringListToDoubleNullList(
    IN  CStringList & strlSrc,
    OUT DWORD & cchDest,
    OUT LPTSTR & lpstrDest
    )
/*++

Routine Description:

    Flatten the string list into a double null terminated list
    of null terminated strings.

Arguments:

    CStringList & strlSrc : Source string list
    DWORD & cchDest       : Size in characters of the resultant array
                            (including terminating NULLs)
    LPTSTR & lpstrDest    : Allocated flat array.

Return Value:

    ERROR_SUCCESS           if the list was converted properly
    ERROR_INVALID_PARAMETER if the list was empty
    ERROR_NOT_ENOUGH_MEMORY if there was a mem exception

--*/
{
    cchDest = 0;
    lpstrDest = NULL;
    BOOL fNullPad = FALSE;

    //
    // Compute total size in characters
    //
    POSITION pos;

    for(pos = strlSrc.GetHeadPosition(); pos != NULL; /**/ )
    {
        CString & str = strlSrc.GetNext(pos);

        TRACEEOLID(str);

        cchDest += str.GetLength() + 1;
    }

    if (!cchDest)
    {
        //
        // Special case: A totally empty MULTI_SZ
        // in fact consists of 2 (final) NULLS, instead
        // of 1 (final) NULL.  This is required by the
        // metabase, but should be a bug.  See note
        // at reversal function above.
        //
        ++cchDest;
        fNullPad = TRUE;
    }

    //
    // Remember final NULL
    //
    cchDest += 1;

    lpstrDest = AllocTString(cchDest);

    if (lpstrDest == NULL)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    LPTSTR pch = lpstrDest;

    for(pos = strlSrc.GetHeadPosition(); pos != NULL; /**/ )
    {
        CString & str = strlSrc.GetNext(pos);

        lstrcpy(pch, (LPCTSTR)str);
        pch += str.GetLength();
        *pch++ = _T('\0');
    }

    *pch++ = _T('\0');

    if (fNullPad)
    {
        *pch++ = _T('\0');
    }

    return ERROR_SUCCESS;
}



int
ConvertSepLineToStringList(
    IN  LPCTSTR lpstrIn,
    OUT CStringList & strlOut,
    IN  LPCTSTR lpstrSep
    )
/*++

Routine Description:

    Convert a line containing multiple strings separated by
    a given character to a CStringListEx

Arguments:

    LPCTSTR lpstrIn         : Input line
    CStringListEx & strlOut : Output stringlist
    LPCTSTR lpstrSep        : List of separators

Return Value:

    The number of items added

--*/
{
    int cItems = 0;
    strlOut.RemoveAll();

    try
    {
        CString strSrc(lpstrIn);
        LPTSTR lp = strSrc.GetBuffer(0);
        lp = _tcstok(lp, lpstrSep);

        while (lp)
        {
            CString str(lp);

            strlOut.AddTail(str);
            lp = _tcstok(NULL, lpstrSep);
            ++cItems;
        }
    }
    catch(CMemoryException * e)
    {
        TRACEEOLID("Exception converting CSV list to stringlist");
        e->ReportError();
        e->Delete();
    }

    return cItems;
}




LPCTSTR
ConvertStringListToSepLine(
    IN  CStringList & strlIn,
    OUT CString & strOut,
    IN  LPCTSTR lpstrSep
    )
/*++

Routine Description:

    Convert stringlist into a single CString, each entry separated by the given
    separator string.

Arguments:

    CStringListEx & strlIn  : Input stringlist
    CString & strOut        : Output string
    LPCTSTR lpstrSep        : Separator string

Return Value:

    Pointer to the output string.

--*/
{
    strOut.Empty();
    POSITION pos = strlIn.GetHeadPosition();

    while(pos)
    {
        CString & str = strlIn.GetNext(pos);

        strOut += str;
        strOut += lpstrSep;
    }

    //
    // Fix for bug #286824
    // Remove separator from the last line: it looks ugly in edit control
    //
    if (!strOut.IsEmpty())
    {
        strOut.GetBufferSetLength(strOut.GetLength() - 1);
        strOut.ReleaseBuffer();
    }

    return strOut;
}



BOOL
CStringListEx::operator ==(
    IN const CStringList & strl
    )
/*++

Routine Description:

    Compare against CStringList.  In order for two CStringLists to match,
    they must match in every element, which must be in the same order.

Arguments:

    CStringList strl       : String list to compare against.

Return Value:

    TRUE if the two string lists are identical

--*/
{
    if (strl.GetCount() != GetCount())
    {
        return FALSE;
    }

    POSITION posa = strl.GetHeadPosition();
    POSITION posb = GetHeadPosition();

    while (posa)
    {
        ASSERT(posa);
        ASSERT(posb);

        CString & strA = strl.GetNext(posa);
        CString & strB = GetNext(posb);

        if (strA != strB)
        {
            return FALSE;
        }
    }

    return TRUE;
}



CStringListEx & 
CStringListEx::operator =(
    IN const CStringList & strl
    )
/*++

Routine Description:

    Assignment operator

Arguments:

    const CStringList & strl        : Source stringlist

Return Value:

    Reference to this

--*/
{
    RemoveAll();
    POSITION pos = strl.GetHeadPosition();

    while(pos)
    {
        CString & str = strl.GetNext(pos);
        AddTail(str);
    }

    return *this;
}



BOOL
CvtStringToLong(
    IN  LPCTSTR lpNumber,
    OUT DWORD * pdwValue
    )
/*++

Routine Description:

    Helper function to convert string (hex or decimal) to a dword.

Arguments:

    LPCTSTR lpNumber        : Input number
    DWORD * pdwValue        : Returns the value

Return Value:

    TRUE for success, FALSE for failure

--*/
{
    const TCHAR rgchHex[] = _T("00112233445566778899aAbBcCdDeEfF");

    DWORD dwResult = 0L;
    DWORD dwResultPrev = 0L;

    //
    // Assume a decimal base
    //
    DWORD dwBase = 10L;

    ASSERT_READ_PTR(lpNumber);
    ASSERT_WRITE_PTR(pdwValue);

    while (*lpNumber == _T(' ') || *lpNumber == _T('0'))
    {
        ++lpNumber;
    }

    if (*lpNumber == _T('x') || *lpNumber == _T('X'))
    {
        dwBase = 16L;
        ++lpNumber;
    }

    while (*lpNumber)
    {
        DWORD dwDigit;

        //
        // Search the character in the hexadecimal string
        //
        LPCTSTR pchDigit =  _tcschr(rgchHex, *lpNumber);

        if (!pchDigit)
        {
            //
            // Character is not found
            //
            return FALSE;
        }

        dwDigit = DIFF(pchDigit - rgchHex) >> 1;

        if (dwDigit >= dwBase)
        {
            //
            // Hexadecimal character in a decimal integer
            //
            return FALSE;
        }

        dwResultPrev = dwResult;
        dwResult *= dwBase;
        dwResult += dwDigit;

        if (dwResult < dwResultPrev)
        {
            //
            // Overflow
            //
            return FALSE;
        }

        //
        // Parse the next character
        //
        ++lpNumber;
    }

    *pdwValue = dwResult;

    return TRUE;
}



const LPCTSTR g_cszMonths[] =
{
    _T("Jan"),
    _T("Feb"),
    _T("Mar"),
    _T("Apr"),
    _T("May"),
    _T("Jun"),
    _T("Jul"),
    _T("Aug"),
    _T("Sep"),
    _T("Oct"),
    _T("Nov"),
    _T("Dec"),
};



const LPCTSTR g_cszWeekDays[] =
{
    _T("Sun"),
    _T("Mon"),
    _T("Tue"),
    _T("Wed"),
    _T("Thu"),
    _T("Fri"),
    _T("Sat"),
};



inline BOOL SkipTillDigit(LPCTSTR & lp)
{
    while (lp && *lp && !_istdigit(*lp)) ++lp;

    return lp != NULL;
}



inline BOOL SkipPastDigits(LPCTSTR & lp)
{
    while (lp && *lp && _istdigit(*lp)) ++lp;

    return lp != NULL;
}



BOOL
FetchIntField(
    LPCTSTR & lp,
    int & n
    )
{
    if (SkipTillDigit(lp))
    {
        n = _ttoi(lp);
        if (n < 0)
        {
            ASSERT_MSG("Bogus string->int");
            return FALSE;
        }

        return SkipPastDigits(lp);
    }

    return FALSE;
}



BOOL
MatchString(
    LPCTSTR lpTarget,
    const LPCTSTR * rglp,
    int cElements,
    int & idx
    )
{
    for (idx = 0; idx < cElements; ++idx)
    {
        if (!_tcsnicmp(lpTarget, rglp[idx], _tcslen(rglp[idx])))
        {
            return TRUE;
        }
    }

    return FALSE;
}



static g_dwCurrentTimeZone = TIME_ZONE_ID_INVALID;
static TIME_ZONE_INFORMATION g_tzInfo;




BOOL
CvtGMTStringToInternal(
    IN  LPCTSTR lpTime,
    OUT time_t * ptValue
    )
/*++

Routine Description:

    Convert GMT string to time in the local timezone format

Arguments:

    IN  LPCSTSTR lpTime             : Input time string
    OUT time_t * ptValue            : Output time_t

Return Value:

    TRUE for success, FALSE for failure

--*/
{
    ASSERT_READ_PTR(lpTime);
    ASSERT_WRITE_PTR(ptValue);

    int year, month, day, hour, minutes, seconds;

    do
    {
        if (!lpTime || !ptValue)
        {
            break;
        }

        if (!FetchIntField(lpTime, day))
        {
            break;
        }

        ++lpTime;   // Skip separator

        if (!MatchString(lpTime, g_cszMonths, 12, month))
        {
            break;
        }

        ++month; // 0-based.

        if (!FetchIntField(lpTime, year)    ||
            !FetchIntField(lpTime, hour)    ||
            !FetchIntField(lpTime, minutes) ||
            !FetchIntField(lpTime, seconds))
        {
            break;
        }

        if (year < 100)
        {
            year += ((year < 50) ? 2000 : 1900);
        }

        CTime time(year, month, day, hour, minutes, seconds);
        if (time.GetTime() == (time_t)-1L)
        {
            break;
        }

        *ptValue = time.GetTime();

        TRACEEOLID("GMT Time is " << ctime(ptValue));

        //
        // Adjust for local time zone
        //
        RaiseThreadProtection();

        if (g_dwCurrentTimeZone == TIME_ZONE_ID_INVALID) 
        {
            //
            // GetTimeZoneInfo() is expensive, so cache its output
            //
            g_dwCurrentTimeZone = GetTimeZoneInformation(&g_tzInfo);
        }

        LowerThreadProtection();

        if (g_dwCurrentTimeZone != TIME_ZONE_ID_INVALID)
        {
            _tzset();

            struct tm * tb = localtime(ptValue);

            BOOL fDST = tb->tm_isdst;

            RaiseThreadProtection();
            *ptValue -= (g_tzInfo.Bias * 60L);

            TRACEEOLID("local time (w/o dst adjustment) is " << ctime(ptValue));

            if (fDST)
            {
                *ptValue -= (g_tzInfo.DaylightBias * 60L);
            }
            else
            {
                //
                // Almost always this is zero
                //
                *ptValue -= (g_tzInfo.StandardBias * 60L);
            }
            LowerThreadProtection();

            TRACEEOLID("Local time adjusted for dst is " << ctime(ptValue));
        }

        //
        // Time OK
        //
        return TRUE;
    }
    while(FALSE);

    //
    // Set max abs timeout value.
    //
    CTime time(2037, 12, 31, 0, 0, 0);
    *ptValue = (time_t)time.GetTime();

    return FALSE;
}



void
CvtInternalToGMTString(
    IN  time_t tm,
    OUT CString & str
    )
/*++

Routine Description:

    Reverse of the above function.  Convert internal time_t to a GMT
    time string (converting to GM time in the process)

Arguments:

    time_t tm       : Input time_t
    CString & str   : Out CString

Return Value:

    None

--*/
{
    try
    {
        _tzset();

        struct tm * tb = gmtime(&tm);

        str.Format(
            _T("%-3.3s, %02d %-3.3s %4d %02d:%02d:%02d GMT"),
            g_cszWeekDays[tb->tm_wday],
            tb->tm_mday,
            g_cszMonths[tb->tm_mon],
            tb->tm_year + 1900,
            tb->tm_hour,
            tb->tm_min,
            tb->tm_sec
            );

        TRACEEOLID("Time string is " << str);
    }
    catch(CMemoryException * e)
    {
        e->ReportError();
        e->Delete();
    }
}



//
// International numeric strings
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



//
// Initialize library
//
BOOL
InitIntlSettings()
{
#ifdef _MT
    INITIALIZE_CRITICAL_SECTION(&_csSect);
#endif // _MT

    return CINumber::Allocate();
}



//
// De-initialize library
//
void
TerminateIntlSettings()
{
    CINumber::DeAllocate();

#ifdef _MT
    DeleteCriticalSection(&_csSect);
#endif // _MT
}



//
// Static Member Initialization
//
// NOTE: MFC classes CANNOT be global in an AFX extension, as they
//       will not be initialized properly.  Solution is to allocate them.
//
CString * CINumber::_pstrThousandSeparator = NULL;
CString * CINumber::_pstrDecimalPoint = NULL;
CString * CINumber::_pstrBadNumber = NULL;
CString * CINumber::_pstrCurrency = NULL;
CString * CINumber::_pstr = NULL;
BOOL CINumber::_fAllocated = FALSE;
BOOL CINumber::_fCurrencyPrefix = TRUE;
BOOL CINumber::_fInitialized = FALSE;



CINumber::CINumber()
/*++

Routine Description:

    Constructor

Arguments:

    None

Return Value:

    None

--*/
{
    if (!CINumber::_fInitialized)
    {
        CINumber::Initialize();
    }
}



CINumber::~CINumber()
/*++

Routine Description:

    Destructor

Arguments:

    None

Return Value:

    None

--*/
{
}



/* static */
BOOL
CINumber::Allocate()
/*++

Routine Description:

    Allocate with US settings

Arguments:

    None

Return Value:

    TRUE if allocation was successfull, FALSE otherwise

--*/
{
    RaiseThreadProtection();

    ASSERT(!IsAllocated());

    if (!IsAllocated())
    {
        try
        {
            //
            // NOTE: Cannot use globals for these, because
            //       they will not be initialized properly
            //       when used in an extension dll.
            //
            CINumber::_pstrThousandSeparator = new CString(_T(","));
            CINumber::_pstrDecimalPoint = new CString(_T("."));
            CINumber::_pstrBadNumber = new CString(_T("--"));
            CINumber::_pstrCurrency = new CString(_T("$ "));
            CINumber::_pstr = new CString;
            _fAllocated = TRUE;
        }
        catch(CMemoryException * e)
        {
            TRACEEOLID("Initialization Failed");
            e->ReportError();
            e->Delete();
        }
    }

    LowerThreadProtection();

    return IsAllocated();
}



/* static */
void
CINumber::DeAllocate()
/*++

Routine Description:

    Clean up allocations

Arguments:

    N/A

Return Value:

    N/A

--*/
{
    RaiseThreadProtection();
    
    ASSERT(IsAllocated());

    if (IsAllocated())
    {
        MAKE_NULL(CINumber::_pstrThousandSeparator);
        MAKE_NULL(CINumber::_pstrDecimalPoint);
        MAKE_NULL(CINumber::_pstrBadNumber);
        MAKE_NULL(CINumber::_pstrCurrency);
        MAKE_NULL(CINumber::_pstr);
    }

    LowerThreadProtection();

    _fAllocated = FALSE;
}



/* static */
BOOL
CINumber::Initialize(
    IN BOOL fUserSetting /* TRUE */
    )
/*++

Routine Description:

    Initialize all the international settings, such as thousand
    separators and decimal points

Parameters:

    BOOL    fUserSetting        If TRUE, use current user settings,
                                if FALSE use system settings.
Return Value:

    TRUE for success, FALSE for failure

Notes:

    Note that this function only needs to be explicitly called
    when the country settings have changed, or when system
    settings are desired (user is default)

--*/
{
#define MAXLEN  6

    int cErrors = 0;

    TRACEEOLID("Getting locale-dependend information");

    ASSERT(IsAllocated());
    if (!IsAllocated())
    {
        Allocate();
    }

    RaiseThreadProtection();

    try
    {
        LCID lcid = fUserSetting
            ? ::GetUserDefaultLCID()
            : GetSystemDefaultLCID();

        LCTYPE lctype = fUserSetting ? 0 : LOCALE_NOUSEROVERRIDE;

        //
        // Get Decimal Point
        //
        if (!::GetLocaleInfo(
            lcid,
            LOCALE_SDECIMAL | lctype,
            CINumber::_pstrDecimalPoint->GetBuffer(MAXLEN),
            MAXLEN
            ))
        {
            TRACEEOLID("Unable to get intl decimal point");
            ++cErrors;
        }

        CINumber::_pstrDecimalPoint->ReleaseBuffer();

        //
        // Get Thousand Separator
        //
        if (!::GetLocaleInfo(
            lcid, LOCALE_STHOUSAND | lctype,
            CINumber::_pstrThousandSeparator->GetBuffer(MAXLEN),
            MAXLEN
            ))
        {
            TRACEEOLID("Unable to get 1000 separator");
            ++cErrors;
        }

        CINumber::_pstrThousandSeparator->ReleaseBuffer();

#ifndef _UNICODE
        //
        // Some countries have a space as a 1000 separator,
        // but for some reason, this is ansi 160, which
        // shows up as a space fine on windows apps,
        // looks like garbage on console apps.
        //
        if ((*CINumber::_pstrThousandSeparator)[0] == CHAR(160))
        {
            CINumber::_pstrThousandSeparator->SetAt(0, ' ');
            TRACEEOLID("Space 1000 separator substituted");
        }
#endif // _UNICODE

        //
        // Get currency symbol
        //
        if (!::GetLocaleInfo(
            lcid,
            LOCALE_SCURRENCY | lctype,
            CINumber::_pstrCurrency->GetBuffer(MAXLEN),
            MAXLEN
            ))
        {
            TRACEEOLID("Unable to get currency symbol");
            ++cErrors;
        }

        CINumber::_pstrCurrency->ReleaseBuffer();
    }

    catch(CMemoryException * e)
    {
        TRACEEOLID("!!!exception in getting intl settings:");
        e->ReportError();
        e->Delete();
        ++cErrors;
    }

    TRACEEOLID("Thousand Separator . . . . . : " << *CINumber::_pstrThousandSeparator);
    TRACEEOLID("Decimal Point  . . . . . . . : " << *CINumber::_pstrDecimalPoint);
    TRACEEOLID("Currency Symbol. . . . . . . : " << *CINumber::_pstrCurrency);
    TRACEEOLID("Bad number . . . . . . . . . : " << *CINumber::_pstrBadNumber);
    TRACEEOLID("Currency Prefix. . . . . . . : " << CINumber::_fCurrencyPrefix);

    CINumber::_fInitialized = TRUE;

    LowerThreadProtection();

    return cErrors == 0;
}



/* static */
double
CINumber::BuildFloat(
    IN const LONG lInteger,
    IN const LONG lFraction
    )
/*++

Return Value:

    Combine integer and fraction to form float

Parameters:

    const LONG lInteger       Integer portion
    const LONG lFraction      Fractional portion

Return Value:

    float value

--*/
{
    double flValue = 0.0;

    //
    // Negative fractions?
    //
    ASSERT(lFraction >= 0);

    if (lFraction >= 0)
    {
        flValue = (double)lFraction;

        while (flValue >= 1.0)
        {
            flValue /= 10.0;
        }

        //
        // Re-add (or subtract if the original number
        // was negative) the fractional part
        //
        if (lInteger > 0L)
        {
            flValue += (double)lInteger;
        }
        else
        {
            flValue -= (double)lInteger;
            flValue = -flValue;
        }
    }

    return flValue;
}



/* static */
LPCTSTR
CINumber::ConvertLongToString(
    IN  const LONG lSrc,
    OUT CString & str
    )
/*++

CINumber::ConvertLongToString

Purpose:

    Convert long number to string with 1000 separators

Parameters:

    const LONG lSrc         Source number
    CString & str           String to write to

Return Value:

    Pointer to converted string

--*/
{
    LPTSTR lpOutString = str.GetBuffer(16);

    //
    // Forget about the negative sign for now.
    //
    LONG lNum = (lSrc >= 0L) ? lSrc : -lSrc;
    int outstrlen = 0;

    do
    {
        lpOutString[outstrlen++] = _T('0') + (TCHAR)(lNum % 10L);
        lNum /= 10L;

        //
        // if more digits left and we're on a 1000 boundary (printed 3 digits,
        // or 3 digits + n*(3 digits + 1 comma), then print a 1000 separator.
        // Note: will only work if the 1000 separator is 1 character.
        //
        ASSERT(CINumber::_pstrThousandSeparator->GetLength() == 1);

        if (lNum != 0L && (outstrlen == 3 || outstrlen == 7 || outstrlen == 11))
        {
            lstrcpy(lpOutString + outstrlen, *CINumber::_pstrThousandSeparator);
            outstrlen += CINumber::_pstrThousandSeparator->GetLength();
        }

    }
    while (lNum > 0L);

    //
    // Add a negative sign if necessary.
    //
    if (lSrc < 0L)
    {
        lpOutString[outstrlen++] = _T('-');
    }

    str.ReleaseBuffer(outstrlen);
    str.MakeReverse();

    return (LPCTSTR)str;
}



/* static */
LPCTSTR
CINumber::ConvertFloatToString(
    IN const double flSrc,
    IN int nPrecision,
    OUT CString & str
    )
/*++

Routine Description:

    Convert floating point number to string represenation

Parameters:

    const double flSrc          Source floating point number
    int nPrecision              Number of decimal points
    CString & str               String to convert to

Return Value:

    Pointer to converted string.

--*/
{
    //
    // Forget about the negative sign for now,
    // and the fractional portion.
    //
    TCHAR szFraction[256];
    LPCTSTR lpFraction = NULL;

    ::_stprintf(szFraction, _T("%.*f"), nPrecision, flSrc);
    lpFraction = ::_tcschr(szFraction, _T('.') );
    ASSERT(lpFraction != NULL);
    ++lpFraction;

    CINumber::ConvertLongToString((LONG)flSrc, str);

    str += *CINumber::_pstrDecimalPoint + lpFraction;

    return (LPCTSTR)str;
}



/* static */
BOOL
CINumber::ConvertStringToLong(
    IN  LPCTSTR lpsrc,
    OUT LONG & lValue
    )
/*++

Routine Description:

    Convert string to long integer.  1000 Separators will be treated
    correctly.

Parameters:

    LPCTSTR lpsrc       Source string
    LONG & lValue       Value to convert to.  Will be 0 in case of error

Return Value:

    TRUE for success, FALSE for failure.

--*/
{
    CString strNumber(lpsrc);
    LONG lBase = 1L;
    BOOL fNegative = FALSE;

    lValue = 0L;

    //
    // Empty strings are invalid
    //
    if (strNumber.IsEmpty())
    {
        return FALSE;
    }

    //
    // Check for negative sign (at the end only)
    //
    if (strNumber[0] == _T('-'))
    {
        fNegative = TRUE;
    }

    strNumber.MakeReverse();

    //
    // Strip negative sign
    //
    if (fNegative)
    {
        strNumber.ReleaseBuffer(strNumber.GetLength()-1);
    }

    //
    // Make sure the 1000 separator is only 1 char.  See note below
    //
    ASSERT(CINumber::_pstrThousandSeparator->GetLength() == 1);

    for (int i = 0; i < strNumber.GetLength(); ++i)
    {
        if ((strNumber[i] >= _T('0')) && (strNumber[i] <= _T('9')))
        {
            LONG lDigit = (LONG)(strNumber[i] - _T('0'));
            if (lDigit != 0L)
            {
                LONG lOldValue = lValue;
                LONG lDelta = (lDigit * lBase);
                if (lDelta / lDigit != lBase)
                {
                    TRACEEOLID("Overflow!");
                    lValue = 0x7fffffff;

                    return FALSE;
                }

                lValue += lDelta;

                if (lValue - lDelta != lOldValue)
                {
                    TRACEEOLID("Overflow!");
                    lValue = 0x7fffffff;

                    return FALSE;
                }
            }

            lBase *= 10L;
        }
        //
        // It's not a digit, maybe a thousand separator?
        // CAVEAT: If a thousand separator of more than
        //         one character is used, this won't work.
        //
        else if ((strNumber[i] != (*CINumber::_pstrThousandSeparator)[0])
             || (i != 3) && (i != 7) && (i != 11))
        {
            //
            // This is just invalid, since it is not a thousand
            // separator in the proper location, nor a negative
            // sign.
            //
            TRACEEOLID("Invalid character " << (BYTE)strNumber[i] << " encountered");
            return FALSE;
        }
    }

    if (fNegative)
    {
        lValue = -lValue;
    }

    return TRUE;
}



/* static */
BOOL
CINumber::ConvertStringToFloat(
    IN  LPCTSTR lpsrc,
    OUT double & flValue
    )
/*++

Routine Description:

    Convert fully decorated floating point string to double

Parameters:

    LPCTSTR lpsrc       Source string
    double & flValue    float value generated from string

Return Value:

    TRUE for success, FALSE for failure

--*/
{
    CString strNumber(lpsrc);

    //
    // This only works if the decimal point is a
    // single character
    //
    ASSERT(CINumber::_pstrDecimalPoint->GetLength() == 1);

    //
    // Strip off the > 0 part
    //
    LONG lFraction = 0;

    int nPoint = strNumber.ReverseFind((*CINumber::_pstrDecimalPoint)[0]);

    if (nPoint >= 0)
    {
        //
        // Convert fractional part
        //
        LPCTSTR lpszFraction = (LPCTSTR)strNumber + ++nPoint;
        lFraction = ::_ttol(lpszFraction);
        strNumber.ReleaseBuffer(--nPoint);
    }

    //
    // Convert integer part
    //
    LONG lInteger;

    if (ConvertStringToLong(strNumber, lInteger))
    {
        flValue = CINumber::BuildFloat(lInteger, lFraction);
        return TRUE;
    }

    return FALSE;
}



CILong::CILong()
/*++

Routine Description:

    Constructor without arguments

Parameters:

    None.

Return Value:

    N/A

--*/
    : m_lValue(0L)
{
}



CILong::CILong(
    IN LONG lValue
    )
/*++

Routine Description:

    Constructor taking LONG argument

Parameters:

    LONG lValue     Value to be set

Return Value:

    N/A

--*/
    : m_lValue(lValue)
{
}



CILong::CILong(
    IN LPCTSTR lpszValue
    )
/*++

Routine Description:

    Constructor taking string argument

Parameters:

    LPCTSTR lpszValue       String number

Return Value:

    N/A

--*/
{
    ConvertStringToLong(lpszValue, m_lValue);
}



CILong &
CILong::operator =(
    IN LONG lValue
    )
/*++

Routine Description:

    Assignment operator taking long value

Parameters:

    LONG lValue     Value to be set

Return Value:

    this object

--*/
{
    m_lValue = lValue;

    return *this;
}



CILong &
CILong::operator =(
    IN LPCTSTR lpszValue
    )
/*++

Routine Description:

    Assignment operator taking string value

Parameters:

    LPCTSTR lpszValue       String number

Return Value:

    this object

--*/
{
    ConvertStringToLong(lpszValue, m_lValue);

    return *this;
}



//
// Arithmetic Shorthand operators
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



CILong &
CILong::operator +=(
    IN const LONG lValue
    )
{
    m_lValue += lValue;

    return *this;
}



//
// As above
//
CILong &
CILong::operator +=(
    IN const LPCTSTR lpszValue
    )
{
    LONG lValue;

    ConvertStringToLong(lpszValue, lValue);

    m_lValue += lValue;

    return *this;
}



//
// As above
//
CILong &
CILong::operator +=(
    IN const CILong& value
    )
{
    m_lValue += value.m_lValue;

    return *this;
}



//
// As above
//
CILong &
CILong::operator -=(
    IN const LONG lValue
    )
{
    m_lValue -= lValue;

    return *this;
}



//
// As above
//
CILong &
CILong::operator -=(
    IN const LPCTSTR lpszValue
    )
{
    LONG lValue;

    ConvertStringToLong(lpszValue, lValue);

    m_lValue -= lValue;

    return *this;
}



//
// As above
//
CILong &
CILong::operator -=(
    IN const CILong & value
    )
{
    m_lValue -= value.m_lValue;

    return *this;
}



//
// As above
//
CILong &
CILong::operator *=(
    IN const LONG lValue
    )
{
    m_lValue *= lValue;

    return *this;
}



//
// As above
//
CILong &
CILong::operator *=(
    IN const LPCTSTR lpszValue
    )
{
    LONG lValue;

    ConvertStringToLong(lpszValue, lValue);

    m_lValue *= lValue;

    return *this;
}



//
// As above
//
CILong &
CILong::operator *=(
    IN const CILong & value
    )               
{
    m_lValue *= value.m_lValue;

    return *this;
}



//
// As above
//
CILong &
CILong::operator /=(
    IN const LONG lValue
    )
{
    m_lValue /= lValue;

    return *this;
}



//
// As above
//
CILong &
CILong::operator /=(
    IN const LPCTSTR lpszValue
    )
{
    LONG lValue;

    ConvertStringToLong(lpszValue, lValue);
    if (lValue != 0)
    {
      m_lValue /= lValue;
    }

    return *this;
}



//
// As above
//
CILong &
CILong::operator /=(
    IN const CILong& value
    )
{
    m_lValue /= value.m_lValue;

    return *this;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\common\strfn.h ===
/*++

   Copyright    (c)    1994-1999    Microsoft Corporation

   Module  Name :

        strfrn.h

   Abstract:

        String Functions

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager (Cluster Edition)

   Revision History:

--*/

#ifndef _STRFN_H
#define _STRFN_H

//
// Helper Macros
//

//
// Get number of array elements
//
#define ARRAY_SIZE(a)    (sizeof(a)/sizeof(a[0]))

//
// Compute size of string array in characters.  That is, don't count
// the terminal null.
//
#define STRSIZE(str)     (ARRAY_SIZE(str)-1)

//
// Get byte count of array
//
#define ARRAY_BYTES(a)   (sizeof(a) * sizeof(a[0]))

//
// Get byte count of character elements of a string -- again
// by not including the terminating NULL.
//
#define STRBYTES(str)    (ARRAY_BYTES(str) - sizeof(str[0]))

//
// Size in bits
//
#define SIZE_IN_BITS(u)  (sizeof(u) * 8)

#define AllocTString(cch)\
    (LPTSTR)AllocMem((cch) * sizeof(TCHAR))

#define IS_NETBIOS_NAME(lpstr) (*lpstr == _T('\\'))

//
// Return the portion of a computer name without the backslashes
//
#define PURE_COMPUTER_NAME(lpstr) (IS_NETBIOS_NAME(lpstr) ? lpstr + 2 : lpstr)

//
// Convert CR/LF to LF
//
BOOL 
COMDLL 
PCToUnixText(
    OUT LPWSTR & lpstrDestination,
    IN  const CString strSource
    );

//
// Expand LF to CR/LF (no allocation necessary)
//
BOOL 
COMDLL 
UnixToPCText(
    OUT CString & strDestination,
    IN  LPCWSTR lpstrSource
    );

/*
//
// Straight copy
//
BOOL
COMDLL 
TextToText(
    OUT LPWSTR & lpstrDestination,
    IN  const CString & strSource
    );
*/

LPSTR 
COMDLL 
AllocAnsiString(
    IN LPCTSTR lpString
    );

LPTSTR 
COMDLL 
AllocString(
    IN LPCTSTR lpString,
    IN int nLen = -1        // -1 to autodetermine
    );

/*
#ifdef UNICODE

    //
    // Copy W string to T string
    // 
    #define WTSTRCPY(dst, src, cch) \
        lstrcpy(dst, src)

    //
    // Copy T string to W string
    //
    #define TWSTRCPY(dst, src, cch) \
        lstrcpy(dst, src)

    //
    // Reference a T String as a W String (a nop in Unicode)
    //
    #define TWSTRREF(str)   ((LPWSTR)str)

#else

    //
    // Convert a T String to a temporary W Buffer, and
    // return a pointer to this internal buffer
    //
    LPWSTR ReferenceAsWideString(LPCTSTR str);

    //
    // Copy W string to T string
    // 
    #define WTSTRCPY(dst, src, cch) \
        WideCharToMultiByte(CP_ACP, 0, src, -1, dst, cch, NULL, NULL)

    //
    // Copy T string to W string
    //
    #define TWSTRCPY(dst, src, cch) \
        MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, src, -1, dst, cch)

    //
    // Reference a T String as a W String 
    //
    #define TWSTRREF(str)   ReferenceAsWideString(str)

#endif // UNICODE

*/

//
// Determine if the given string is a UNC name
//
BOOL 
COMDLL 
IsUNCName(
    IN const CString & strDirPath
    );

//
// Determine if the path is e.g. an IFS path
//
BOOL 
COMDLL 
IsDevicePath(
    IN const CString & strDirPath
    );

//
// Determine if the path is a fully qualified path in the context
// of the local machine
//
BOOL 
COMDLL 
IsFullyQualifiedPath(
    IN const CString & strDirPath
    );

BOOL
COMDLL
PathIsValid(LPCTSTR path);
//
// Determine if the path exists on a network directory in the context
// of the local machine
//
BOOL 
COMDLL 
IsNetworkPath(
    IN  const CString & strDirPath,
    OUT CString * pstrDrive = NULL,
    OUT CString * pstrUNC = NULL
    );

//
// Determine if the given string is an URL path
//
BOOL 
COMDLL 
IsURLName(
    IN const CString & strDirPath
    );

//
// Determine if the given string describes a relative URL path
//
inline BOOL IsRelURLPath(
    IN LPCTSTR lpPath
    )
{
    ASSERT_READ_PTR(lpPath);
    return *lpPath == _T('/');
}

//
// Determine if the given path describes a wild-carded redirection
// path (starts with *;)
//
inline BOOL IsWildcardedRedirectPath(
    IN LPCTSTR lpPath
    )
{
    ASSERT_READ_PTR(lpPath);
    return lpPath[0] == '*' && lpPath[1] == ';';
}

//
// Determine if the account is local (doesn't have a computer name)
//
inline BOOL IsLocalAccount(
    IN CString & strAccount
    )
{
    return strAccount.Find(_T('\\')) == -1;
}

//
// Convert local path to UNC path
//
LPCTSTR COMDLL MakeUNCPath(
    IN OUT CString & strDir,
    IN LPCTSTR lpszOwner,
    IN LPCTSTR lpszDirectory
    );

//
// Convert GUID to a CString
//
LPCTSTR COMDLL GUIDToCString(
    IN  REFGUID guid,
    OUT CString & str
    );

//
// Convert double-null terminated string to a CStringList
//
DWORD COMDLL ConvertDoubleNullListToStringList(
    IN  LPCTSTR lpstrSrc,
    OUT CStringList & strlDest,
    IN  int cChars = -1
    );

//
// Go from a CStringList to a double null terminated list
//
DWORD COMDLL ConvertStringListToDoubleNullList(
    IN  CStringList & strlSrc,
    OUT DWORD & cchDest,
    OUT LPTSTR & lpstrDest
    );

//
// Convert separated list of strings to CStringList
//
int COMDLL ConvertSepLineToStringList(
    IN  LPCTSTR lpstrIn,
    OUT CStringList & strlOut,
    IN  LPCTSTR lpstrSep
    );

//
// Reverse function of the above
//
LPCTSTR COMDLL ConvertStringListToSepLine(
    IN  CStringList & strlIn,
    OUT CString & strOut,
    IN  LPCTSTR lpstrSep
    );

//
// Advanced atol which recognises hex strings
//
BOOL COMDLL CvtStringToLong(
    IN  LPCTSTR lpNumber,
    OUT DWORD * pdwValue
    );

//
// GMT string to time_t
//
BOOL COMDLL CvtGMTStringToInternal(
    IN  LPCTSTR lpTime,
    OUT time_t * ptValue
    );

//
// time_t to GMT string
//
void COMDLL CvtInternalToGMTString(
    IN  time_t tm,
    OUT CString & str
    );

//
// CString.Find() that's not case-sensitive
//
int COMDLL CStringFindNoCase(
    IN const CString & strSrc,
    IN LPCTSTR lpszSub
    );

//
// Replace the first occurrance of one string
// inside another one.  Return error code
//
DWORD COMDLL ReplaceStringInString(
    OUT IN CString & strBuffer,
    IN  CString & strTarget,
    IN  CString & strReplacement,
    IN  BOOL fCaseSensitive
    );

//
// Replace a path in strTarget with the 
// environment variable lpszEnvVar if that
// strTarget path is a superset of the path
// pointed to by lpszEnvVar
//
DWORD COMDLL DeflateEnvironmentVariablePath(
    IN LPCTSTR lpszEnvVar,
    IN OUT CString & strTarget
    );



class COMDLL CStringListEx : public CStringList
/*++

Class Description:

    Superclass of CStringList with comparison and assignment
    operators.

Public Interface:

    operator ==       Comparison operator
    operator !=       Comparison operator
    operator =        Assignment operator  

--*/
{
//
// ctor
//
public:
    CStringListEx(int nBlockSize = 10) : CStringList(nBlockSize) {};

//
// Operators
//
public:
    BOOL operator == (const CStringList & strl);           
    BOOL operator != (const CStringList & strl) { return !operator ==(strl); }
    CStringListEx & operator =(const CStringList & strl);
};



class COMDLL CINumber
/*++

Class Description:

    Base class for international-friendly number formatting

Public Interface:

NOTES: Consider making this class a template

--*/
{
public:
    static BOOL Initialize(BOOL fUserSetting = TRUE);
    static CString * _pstrBadNumber;
    static BOOL UseSystemDefault();
    static BOOL UseUserDefault();
    static BOOL IsInitialized();
    static LPCTSTR QueryThousandSeparator();
    static LPCTSTR QueryDecimalPoint();
    static LPCTSTR QueryCurrency();
    static double BuildFloat(const LONG lInteger, const LONG lFraction);
    static LPCTSTR ConvertLongToString(const LONG lSrc, CString & str);
    static LPCTSTR ConvertFloatToString(
        IN const double flSrc, 
        IN int nPrecision, 
        OUT CString & str
        );

    static BOOL ConvertStringToLong(LPCTSTR lpsrc, LONG & lValue);
    static BOOL ConvertStringToFloat(LPCTSTR lpsrc, double & flValue);

protected:
    CINumber();
    ~CINumber();

protected:
    friend BOOL InitIntlSettings();
    friend void TerminateIntlSettings();
    static BOOL Allocate();
    static void DeAllocate();
    static BOOL IsAllocated();

protected:
    static CString * _pstr;

private:
    static CString * _pstrThousandSeparator;
    static CString * _pstrDecimalPoint;
    static CString * _pstrCurrency;
    static BOOL _fCurrencyPrefix;
    static BOOL _fInitialized;
    static BOOL _fAllocated;
};



class COMDLL CILong : public CINumber
/*++

Class Description:

    International-friendly LONG number

Public Interface:


--*/
{
public:
    //
    // Constructors
    //
    CILong();
    CILong(LONG lValue);
    CILong(LPCTSTR lpszValue);

public:
    //
    // Assignment Operators
    //
    CILong & operator =(LONG lValue);
    CILong & operator =(LPCTSTR lpszValue);

    //
    // Shorthand Operators
    //
    CILong & operator +=(const LONG lValue);
    CILong & operator +=(const LPCTSTR lpszValue);
    CILong & operator +=(const CILong & value);
    CILong & operator -=(const LONG lValue);
    CILong & operator -=(const LPCTSTR lpszValue);
    CILong & operator -=(const CILong & value);
    CILong & operator *=(const LONG lValue);
    CILong & operator *=(const LPCTSTR lpszValue);
    CILong & operator *=(const CILong & value);
    CILong & operator /=(const LONG lValue);
    CILong & operator /=(const LPCTSTR lpszValue);
    CILong & operator /=(const CILong & value);

    //
    // Comparison operators
    //
    BOOL operator ==(LONG value);
    BOOL operator !=(CILong& value);

    //
    // Conversion operators
    //
    operator const LONG() const;
    operator LPCTSTR() const;

    inline friend CArchive & AFXAPI operator <<(CArchive & ar, CILong & value)
    {
        return (ar << value.m_lValue);
    }

    inline friend CArchive & AFXAPI operator >>(CArchive & ar, CILong & value)
    {
        return (ar >> value.m_lValue);
    }

#if defined(_DEBUG) || DBG

    //
    // CDumpContext stream operator
    //
    inline friend CDumpContext & AFXAPI operator<<(
        CDumpContext & dc, 
        const CILong & value
        )
    {
        return (dc << value.m_lValue);
    }

#endif // _DEBUG

protected:
    LONG m_lValue;
};



//
// Inline Expansion
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

inline /* static */ BOOL CINumber::UseSystemDefault()
{
    return Initialize(FALSE);
}

inline /* static */ BOOL CINumber::UseUserDefault()
{
    return Initialize(TRUE);
}

inline /* static */ BOOL CINumber::IsInitialized()
{
    return _fInitialized;
}

inline /* static */ LPCTSTR CINumber::QueryThousandSeparator()
{
    return (LPCTSTR)*_pstrThousandSeparator;
}

inline /* static */ LPCTSTR CINumber::QueryDecimalPoint()
{
    return (LPCTSTR)*_pstrDecimalPoint;
}

inline /* static */ LPCTSTR CINumber::QueryCurrency()
{
    return (LPCTSTR)*_pstrCurrency;
}

inline /* static */ BOOL CINumber::IsAllocated()
{
    return _fAllocated;
}

inline BOOL CILong::operator ==(LONG value)
{
    return m_lValue == value;
}

inline BOOL CILong::operator !=(CILong& value)
{
    return m_lValue != value.m_lValue;
}

inline CILong::operator const LONG() const
{
    return m_lValue;
}

inline CILong::operator LPCTSTR() const
{
    return CINumber::ConvertLongToString(m_lValue, *CINumber::_pstr);
}

#endif // _STRFN_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\common\utcls.h ===
/*++

   Copyright    (c)    1994-1999    Microsoft Corporation

   Module  Name :

        utcls.h

   Abstract:

        Some utility functions and classes.

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/

#ifndef _UTCLS_H_
#define _UTCLS_H_

//
// CDialog parameters
//
#define USE_DEFAULT_CAPTION (0)

//
// Determine if the given server name refers to the local machine
//
BOOL 
COMDLL
IsServerLocal(
    IN LPCTSTR lpszServer       
    );

//
// Get volume information system flags for the given path
//
BOOL 
COMDLL
GetVolumeInformationSystemFlags(
    IN  LPCTSTR lpszPath,
    OUT DWORD * pdwSystemFlags
    );

//
// Build registry key name
//
LPCTSTR COMDLL GenerateRegistryKey(
    OUT CString & strBuffer,    
    IN  LPCTSTR lpszSubKey = NULL
    );



class COMDLL CBlob
/*++

Class Description:

    Binary large object class, which owns its pointer

Public Interface:

    CBlob           : Constructors
    ~CBlob          : Destructor

    SetValue        : Assign the value
    GetSize         : Get the byte size
    GetData         : Get pointer to the byte stream

--*/
{
//
// Constructors/Destructor
//
public:
    //
    // Initialize empty blob
    //
    CBlob();

    //
    // Initialize with binary data
    //
    CBlob(
        IN DWORD dwSize,
        IN PBYTE pbItem,
        IN BOOL fMakeCopy = TRUE
        );

    //
    // Copy constructor
    //
    CBlob(IN const CBlob & blob);

    //
    // Destructor destroys the pointer
    //    
    ~CBlob();

//
// Operators
//
public:
    CBlob & operator =(const CBlob & blob);
    BOOL operator ==(const CBlob & blob) const;
    BOOL operator !=(const CBlob & blob) const { return !operator ==(blob); }

//
// Access
//
public: 
    //
    // Clean up internal data
    //
    void CleanUp();

    //
    // Set the current value of the blob
    //
    void SetValue(
        IN DWORD dwSize,
        IN PBYTE pbItem,
        IN BOOL fMakeCopy = TRUE
        );

    //
    // TRUE if the blob is currently empty
    //
    BOOL IsEmpty() const { return m_dwSize == 0L; }

    //
    // Return the size of the blob in bytes
    //
    DWORD GetSize() const { return m_dwSize; }

    //
    // Get a pointer to the byte stream
    //
    PBYTE GetData();

private:
    DWORD m_dwSize;
    PBYTE m_pbItem;
};



//
// Inline Expansion
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

inline CBlob::~CBlob()
{
    CleanUp();
}

inline PBYTE CBlob::GetData()
{
    return m_pbItem;
}





#endif // _UTCLS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\common\wizard.cpp ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        wizard.cpp

   Abstract:

        Enhanced dialog and IIS Wizard pages, including
        support for Wizard '97

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/



//
// Include Files
//
#include "stdafx.h"
#include "common.h"

extern HINSTANCE hDLLInstance;

BOOL
CreateSpecialDialogFont(
    IN CWnd * pDlg,
    IN OUT CFont * pfontSpecial,
    IN LONG lfOffsetWeight,     OPTIONAL
    IN LONG lfOffsetHeight,     OPTIONAL
    IN LONG lfOffsetWidth,      OPTIONAL
    IN BOOL fItalic,            OPTIONAL
    IN BOOL fUnderline          OPTIONAL
    )
/*++

Routine Description:

    From the dialog font, create special effects font.

Arguments:

    CWnd * pDlg         : Pointer to dialog
    CFont * pfontSpecial: Font object to be created.
    LONG lfOffsetWeight : Change in font weight
    LONG lfOffsetHeight : Value to add to height (will autonegate for truetype)
    LONG lfOffsetWidth  : Value to add to width (ignored for truetype)
    BOOL fItalic        : If true, reverses italic
    BOOL fUnderline     : If true, reverses underline

Return Value:

    TRUE for success, FALSE for failure.

--*/
{
    ASSERT_READ_PTR(pDlg);
    ASSERT_READ_WRITE_PTR(pfontSpecial);        // Font must be allocated
    ASSERT((HFONT)(*pfontSpecial) == NULL);     // But not yet created

    if (pDlg && pfontSpecial)
    {
        //
        // Use dialog font as basis.
        //
        CFont * pfontDlg = pDlg->GetFont();
        ASSERT_PTR(pfontDlg);

        if (pfontDlg)
        {
            LOGFONT lf;

            if (pfontDlg->GetLogFont(&lf))
            {
                lf.lfWeight += lfOffsetWeight;

                if (lf.lfHeight < 0)
                {
                    //
                    // truetype font, ignore widths
                    //
                    lf.lfHeight -= lfOffsetHeight;
                    ASSERT(lf.lfWidth == 0);
                }
                else
                {
                    //
                    // Non-true type font
                    //
                    lf.lfHeight += lfOffsetHeight;
                    lf.lfWidth += lfOffsetWidth;
                }

                if (fItalic)
                {
                    lf.lfItalic = !lf.lfItalic;
                }

                if (fUnderline)
                {
                    lf.lfUnderline = !lf.lfUnderline;
                }

                return pfontSpecial->CreateFontIndirect(&lf);
            }
        }
    }

    return FALSE;
}



void
ApplyFontToControls(
    IN CWnd * pdlg,
    IN CFont * pfont,
    IN UINT nFirst,
    IN UINT nLast
    )
/*++

Routine Description:

    Helper function to apply a font to a range of controls in a dialog.

Arguments:

    CWnd * pdlg      : Pointer to dialog
    CFont * pfont    : Font to apply
    UINT nFirst      : First control ID
    UINT nLast       : Last control ID (Not all need exist)

Return Value:

    None

Notes:

    The control IDs are expected to exist sequentially.  That is,
    the first id in the range nFirst to nLast that doesn't exist
    will break the loop.

---*/
{
    ASSERT((HFONT)(*pfont) != NULL);
    ASSERT(nFirst <= nLast);

    CWnd * pCtl;
    for (UINT n = nFirst; n <= nLast; ++n)
    {
        pCtl = pdlg->GetDlgItem(n);

        if (!pCtl)
        {
            break;
        }

        pCtl->SetFont(pfont);
    }
}



IMPLEMENT_DYNCREATE(CEmphasizedDialog, CDialog)



//
// Message Map
//
BEGIN_MESSAGE_MAP(CEmphasizedDialog, CDialog)
    ON_WM_DESTROY()
END_MESSAGE_MAP()



//
// Message Handlers
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



BOOL 
CEmphasizedDialog::OnInitDialog()
/*++

Routine Description:

    WM_INITDIALOG handler.

Arguments:

    None

Return:

    TRUE unless a control has received focus.

--*/
{
    BOOL bReturn = CDialog::OnInitDialog();

    if (CreateSpecialDialogFont(this, &m_fontBold))
    {
        //
        // Apply bold font
        //
        ApplyFontToControls(this, &m_fontBold, IDC_ED_BOLD1, IDC_ED_BOLD5);
    }

    return bReturn;
}



void 
CEmphasizedDialog::OnDestroy()
/*++

Routine Description:

    Cleanup internal structures
    
Arguments:

    None

Return Value:

    None

--*/
{
    m_fontBold.DeleteObject();

    CDialog::OnDestroy();
}



IMPLEMENT_DYNCREATE(CIISWizardSheet, CPropertySheet)



//
// Static Initialization
//
const int CIISWizardSheet::s_cnBoldDeltaFont   = +500;
const int CIISWizardSheet::s_cnBoldDeltaHeight = +8;
const int CIISWizardSheet::s_cnBoldDeltaWidth  = +3;



CIISWizardSheet::CIISWizardSheet(
    IN UINT nWelcomeBitmap,
    IN UINT nHeaderBitmap,
    IN COLORREF rgbForeColor,
    IN COLORREF rgbBkColor
    )
/*++

Routine Description:

    Wizard sheet constructor.  Specifying a welcome bitmap
    make the sheet wizard '97 compliant.

Arguments:

    UINT nWelcomeBitmap     : Resource ID of welcome bitmap
    UINT nHeaderBitmap      : Resource ID of header bitmap

Return Value:

    N/A

--*/
    : CPropertySheet()
{
    m_psh.dwFlags &= ~(PSH_HASHELP);
    SetWizardMode();

    m_rgbWindow     = GetSysColor(COLOR_WINDOW);
    m_rgbWindowText = GetSysColor(COLOR_WINDOWTEXT);

    if (nWelcomeBitmap)
    {
        //
        // Load bitmaps, replacing colours.
        //
        COLORMAP crMap[2];
        
        crMap[0].from = rgbBkColor;
        crMap[0].to = m_rgbWindow;
        crMap[1].from = rgbForeColor;
        crMap[1].to = m_rgbWindowText;

        //
        // Half tone the foreground colour
        //
        if (m_rgbWindowText == RGB(0,0,0))
        {
            BYTE bRed, bGreen, bBlue;
            bRed   = GetRValue(m_rgbWindowText);
            bGreen = GetGValue(m_rgbWindowText);
            bBlue  = GetBValue(m_rgbWindowText);
        
            crMap[1].to = RGB( ((255 - bRed) * 2 / 3), ((255 - bGreen) * 2 / 3), ((255 - bBlue) * 2 / 3) );
        }
        else
        {
            crMap[1].to = m_rgbWindowText;
        }

        VERIFY(m_bmpWelcome.LoadBitmap(nWelcomeBitmap));
        m_bmpWelcome.GetBitmap(&m_bmWelcomeInfo);

        VERIFY(m_bmpHeader.LoadMappedBitmap(nHeaderBitmap));
        m_bmpHeader.GetBitmap(&m_bmHeaderInfo);

        m_psh.dwFlags |= PSH_WIZARD_LITE;
    }
}



void 
CIISWizardSheet::EnableButton(
    IN int nID, 
    IN BOOL fEnable         OPTIONAL
    )
/*++

Routine Description:

    Enable/disable sheet button

Arguments:

    int nID         : Button ID (IDCANCEL, etc)
    BOOL fEnable    : TRUE to enable, FALSE to disable

Return Value:

    None

--*/
{
    CWnd * pButton = GetDlgItem(nID);

    if (pButton)
    {
        pButton->EnableWindow(fEnable);
    }
}



//
// Message Map
//
BEGIN_MESSAGE_MAP(CIISWizardSheet, CPropertySheet)
    ON_WM_DESTROY()
END_MESSAGE_MAP()



//
// Message Handlers
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



BOOL 
CIISWizardSheet::OnInitDialog()
/*++

Routine Description:

    WM_INITDIALOG handler.  Resize the sheet to the proper
    size, and set up some basic information

Arguments:

    None

Return:

    TRUE unless a control has received focus.

--*/
{
    if (IsWizard97())
    {
        //
        // Create special fonts.
        //
        // Title font is same size as dialog, but bold
        // Welcome font is much bolder (+500), and 3 sizes larger.
        // Specifying a +1 in width increase is on the unlikely chance
        // that the dialog font is not true-type.
        //                                                            
        VERIFY(CreateSpecialDialogFont(this, &m_fontTitle));
        VERIFY(CreateSpecialDialogFont(
            this, 
            &m_fontWelcome, 
            s_cnBoldDeltaFont, 
            s_cnBoldDeltaHeight, 
            s_cnBoldDeltaWidth
            ));
    }

    //
    // Load default brush (transparent brush);
    //
    VERIFY(m_brBkgnd = (HBRUSH)GetStockObject(HOLLOW_BRUSH));

    //
    // Create the window brush
    //
    VERIFY(m_brWindow.CreateSolidBrush(m_rgbWindow));

    BOOL bResult = CPropertySheet::OnInitDialog();

    if (IsWizard97())
    {
        // 
        // Get temporary DC for dialog - Will be released in dc destructor
        //
        CClientDC dc(this);

        //
        // Create compatible memory DCs using the dialogs DC
        //
        VERIFY(m_dcMemWelcome.CreateCompatibleDC(&dc));
        VERIFY(m_dcMemHeader.CreateCompatibleDC(&dc));

        //
        // Save state to be restored later.
        //
        CBitmap * pbmpOldWelcome, 
                * pbmpOldHeader;

        VERIFY(pbmpOldWelcome   = m_dcMemWelcome.SelectObject(&m_bmpWelcome));
        VERIFY(m_hbmpOldWelcome = (HBITMAP)pbmpOldWelcome->GetSafeHandle());
        VERIFY(pbmpOldHeader    = m_dcMemHeader.SelectObject(&m_bmpHeader));
        VERIFY(m_hbmpOldHeader  = (HBITMAP)pbmpOldHeader->GetSafeHandle());
    }

    return bResult;
}



void 
CIISWizardSheet::OnDestroy()
/*++

Routine Description:

    Cleanup internal structures

Arguments:

    None

Return Value:

    None

--*/
{
    CPropertySheet::OnDestroy();

    if (IsWizard97())
    {
        //
        // Restore memory DCs
        //
        ASSERT(m_hbmpOldWelcome != NULL);
        ASSERT(m_hbmpOldHeader != NULL);
        VERIFY(m_dcMemWelcome.SelectObject(
            CBitmap::FromHandle(m_hbmpOldWelcome)
            ));
        VERIFY(m_dcMemHeader.SelectObject(
            CBitmap::FromHandle(m_hbmpOldHeader)
            ));

        //
        // Clean up the bitmaps
        //
        m_bmpWelcome.DeleteObject();
        m_bmpHeader.DeleteObject();
        m_brWindow.DeleteObject();
       
        //
        // Destructors will take care of the rest.
        //
    }
}




void
CIISWizardSheet::WinHelp(
    IN DWORD dwData,
    IN UINT nCmd
    )
/*++

Routine Description:

    'Help' handler.  Implemented to ensure no response for F1,
    instead of the bogus "Topic not found" error.

Arguments:

    DWORD dwData        : Help data
    UINT nCmd           : Help command

Return Value:

    None

--*/
{
    //
    // Eat the help command
    //
}



IMPLEMENT_DYNCREATE(CIISWizardPage, CPropertyPage)



//
// Margin for header bitmap
//
const int CIISWizardPage::s_cnHeaderOffset = 2;



CIISWizardPage::CIISWizardPage(
    IN UINT nIDTemplate,            OPTIONAL
    IN UINT nIDCaption,             OPTIONAL
    IN BOOL fHeaderPage,            OPTIONAL
    IN UINT nIDHeaderTitle,         OPTIONAL
    IN UINT nIDSubHeaderTitle       OPTIONAL
    )
/*++

Routine Description:

    Header wizard page 

Arguments:

    UINT nIDTemplate        : Resource template
    UINT nIDCaption         : caption ID
    BOOL fHeaderPage        : TRUE for header page, FALSE for welcome page
    UINT nIDHeaderTitle     : Header title
    UINT nIDSubHeaderTitle  : Subheader title.

Return Value:

    N/A

--*/
    : CPropertyPage(nIDTemplate, nIDCaption),
      m_strTitle(),
      m_strSubTitle(),
      m_rcFillArea(0, 0, 0, 0),
      m_ptOrigin(0, 0),
      m_fUseHeader(fHeaderPage)
{
    m_psp.dwFlags &= ~(PSP_HASHELP); // No Help

    if (nIDHeaderTitle)
    {
        ASSERT(IsHeaderPage());
        VERIFY(m_strTitle.LoadString(nIDHeaderTitle));
    }

    if (nIDSubHeaderTitle)
    {
        ASSERT(IsHeaderPage());
        VERIFY(m_strSubTitle.LoadString(nIDSubHeaderTitle));
    }

    m_psp.dwFlags |= PSP_HIDEHEADER; // Wizard97
}



BOOL
CIISWizardPage::ValidateString(
    IN  CEdit & edit,
    OUT CString & str,
    IN  int nMin,
    IN  int nMax
    )
/*++

Routine Description:

    Since normal 'DoDataExchange' validation happens on every entrance
    and exit of a property page, it's not well suited to wizards.  This
    function is to be called on 'next' only to do validation.

Arguments:

    CEdit & edit        : Edit box where the string is to be gotten from
    CString & str       : String to be validated
    int nMin            : Minimum length
    int nMax            : Maximum length

Return Value:

    TRUE if the string is within the limits, FALSE otherwise.

--*/
{
    ASSERT(nMin <= nMax);

    UINT nID;
    TCHAR szT[33];

    edit.GetWindowText(str);

    if (str.GetLength() < nMin)
    {
        nID = IDS_DDX_MINIMUM;
        ::wsprintf(szT, _T("%d"), nMin);
    }
    else if (str.GetLength() > nMax)
    {
        nID = AFX_IDP_PARSE_STRING_SIZE;
        ::wsprintf(szT, _T("%d"), nMax);
    }
    else
    {
        //
        // Passes both our tests, it's ok.
        //
        return TRUE;
    }

    //
    // Highlight and puke
    //
    edit.SetSel(0,-1);
    edit.SetFocus();

    CString prompt;
    ::AfxFormatString1(prompt, nID, szT);
    ::AfxMessageBox(prompt, MB_ICONEXCLAMATION, nID);

    return FALSE;
}



//
// Message Map
//
BEGIN_MESSAGE_MAP(CIISWizardPage, CPropertyPage)
    ON_WM_CTLCOLOR()
    ON_WM_ERASEBKGND()
END_MESSAGE_MAP()



//
// Message Handlers
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
BOOL IsControlAboveDivider(HWND TheWholeTing,CWnd * pWnd,CWnd * pDiv)
{
    CRect rcClient;
    CRect rcClientDiv;
    if (pDiv != NULL && pWnd != NULL)
    {
        pWnd->GetClientRect(&rcClient);
        pDiv->GetClientRect(&rcClientDiv);

        GetDlgCtlRect(TheWholeTing, pWnd->m_hWnd, &rcClient);
        GetDlgCtlRect(TheWholeTing, pDiv->m_hWnd, &rcClientDiv);

        if (rcClientDiv.top > rcClient.top)
        {
            return TRUE;
        }
    }
    return FALSE;
}


HBRUSH 
CIISWizardPage::OnCtlColor(
    IN CDC * pDC, 
    IN CWnd * pWnd, 
    IN UINT nCtlColor
    )
/*++

Routine Description:

    Handle control colour.  Ensure a true transparent
    background colouring.

Arguments:

    CDC * pDC       : Device context
    CWnd * pWnd     : Pointer to window
    UINT nCtlColor  : Ctrl type ID

Return Value:

    Handle to brush to be used for background painting

--*/
{
    BOOL bSetBackGroundColor = FALSE;

    if (IsWizard97())
    {
        {
            switch (nCtlColor)    
            {        
                case CTLCOLOR_STATIC:
                    // option/check boxes are CTLCOLOR_STATIC's as well as simple static texts...
                    // problem is that option/check boxes look ugly (can't even see them)
                    // if we set the background color, so make sure that
                    // we don't do this on the option/check boxes...
                    if (IsHeaderPage())
                    {
                        if (TRUE == IsControlAboveDivider(m_hWnd,pWnd,GetDlgItem(IDC_STATIC_WZ_HEADER_DIVIDER)))
                        {
                            bSetBackGroundColor = TRUE;
                        }
                    }
                    else
                    {
                        bSetBackGroundColor = TRUE;
                    }
                    break;
                case CTLCOLOR_BTN:
                //case CTLCOLOR_EDIT:
                //case CTLCOLOR_LISTBOX:
                //case CTLCOLOR_SCROLLBAR:
                case CTLCOLOR_DLG:
                    bSetBackGroundColor = TRUE;
                    break;
            }
        }
    }

    if (bSetBackGroundColor)
    {
        //
        // Have text and controls be painted smoothly over bitmap
        // without using default background colour
        //
        pDC->SetBkMode(TRANSPARENT);
        pDC->SetTextColor(QueryWindowTextColor());

        return GetBackgroundBrush();
    }
    //
    // Default processing...
    //
    return CPropertyPage::OnCtlColor(pDC, pWnd, nCtlColor);
}



BOOL 
CIISWizardPage::OnEraseBkgnd(
    IN CDC * pDC
    )
/*++

Routine Description:

    Handle erasing the background colour of the dialog

Arguments:

    CDC * pDC       : Device context

Return Value:

    TRUE if no further works needs to be done.
    FALSE otherwise.

--*/
{
    if (IsWizard97())
    {
        //
        // Cache height/width of the fill area, and compute
        // the origin of the destination bitmap.
        //
        if (m_rcFillArea.Width() == 0)
        {
            //
            // Not yet cached, compute values
            //
            CRect rcClient;

            GetClientRect(&rcClient);

            if (IsHeaderPage())
            {
                //
                // Fill the upper rectangle above
                // the divider
                //
                CWnd * pDiv = GetDlgItem(IDC_STATIC_WZ_HEADER_DIVIDER);
                ASSERT_PTR(pDiv);

                if (pDiv != NULL)
                {
                    m_rcFillArea = rcClient;                    
                    GetDlgCtlRect(m_hWnd, pDiv->m_hWnd, &rcClient);
                    m_rcFillArea.bottom = rcClient.top;
        
                    //
                    // Figure out a place for the bitmap
                    // to go.  If any coordinate is negative,
                    // the bitmap will not be displayed
                    //                    
                    TRACEEOLID(
                        "Fill area  : " << m_rcFillArea.Height() 
                        << "x"          << m_rcFillArea.Width()
                        );
                    TRACEEOLID(
                        "Bitmap size: " << QueryBitmapHeight()
                        << "x"          << QueryBitmapWidth()
                        );

                    ASSERT(m_rcFillArea.Width()  >= QueryBitmapWidth());
                    ASSERT(m_rcFillArea.Height() >= QueryBitmapHeight()); 

                    //
                    // Find a place for the header box properly offset from the
                    // margins
                    //
                    m_ptOrigin.y = 
                        (m_rcFillArea.Height() - QueryBitmapHeight() + 1) / 2;
                    m_ptOrigin.x = m_rcFillArea.Width() 
                        - QueryBitmapWidth() 
                        + 1
                        - (__max(s_cnHeaderOffset, m_ptOrigin.y));
                }   
            }      
            else
            {
                //
                // Fill the entire client are
                //
                m_rcFillArea = rcClient;
            }
        }
        
        //
        // Fill background colour with window colour
        //
        pDC->FillRect(&m_rcFillArea, GetWindowBrush());

        //
        // Draw the background picture if there's room.
        //
        if (m_ptOrigin.x >= 0 && m_ptOrigin.y >= 0)
        {
            pDC->BitBlt( 
                m_ptOrigin.x,
                m_ptOrigin.y,
                QueryBitmapWidth() - 1, 
                QueryBitmapHeight() - 1,
                GetBitmapMemDC(), 
                0, 
                0, 
                SRCCOPY 
                );
        }

        /*

        //
        // Scale bitmap appropriately -- looks grainy
        //
        int nHeight = rc.Height();

        double dDelta = (double)nHeight / (double)(QueryBitmapHeight() - 1);

        int nWidth = (int)((double)(QueryBitmapWidth() - 1) * dDelta);

        pDC->StretchBlt( 
            0,
            0,
            nWidth,
            nHeight,    
            GetBitmapMemDC(), 
            0, 
            0, 
            QueryBitmapWidth() - 1, 
            QueryBitmapHeight() - 1,
            SRCCOPY 
            );

         */

        //
        // No more background painting needed
        //
        return TRUE;    
    }

    //
    // No background images of any kind
    //
    return CPropertyPage::OnEraseBkgnd(pDC);
}



BOOL
CIISWizardPage::OnInitDialog()
/*++

Routine Description:

    Handle WM_INITIDIALOG.  Load the appropriate 
    bitmaps, and create the brushes and fonts as needed.

Arguments:

    None

Return Value:

    TRUE unless a control has received initial focus

--*/
{
    CPropertyPage::OnInitDialog();

    //
    // Fake the WIZARD97 look
    //
    if (IsWizard97())
    {
        if (IsHeaderPage())
        {
            CWnd * pCtlTitle = GetDlgItem(IDC_STATIC_WZ_TITLE);
            CWnd * pCtlSubTitle = GetDlgItem(IDC_STATIC_WZ_SUBTITLE);
            ASSERT_PTR(pCtlTitle);
            ASSERT_PTR(pCtlSubTitle);

            if (pCtlTitle)
            {
                pCtlTitle->SetFont(GetSpecialFont());

                if (!m_strTitle.IsEmpty())
                {
                    pCtlTitle->SetWindowText(m_strTitle);
                }
            }

            if (pCtlSubTitle && !m_strSubTitle.IsEmpty())
            {
                pCtlSubTitle->SetWindowText(m_strSubTitle);
            }
        }
        else
        {
            CWnd * pCtl = GetDlgItem(IDC_STATIC_WZ_WELCOME);
            ASSERT_PTR(pCtl);

            if (pCtl)
            {
                pCtl->SetFont(GetSpecialFont());
            }
        }

        //
        // Apply fonts
        //
        ApplyFontToControls(this, GetBoldFont(), IDC_ED_BOLD1, IDC_ED_BOLD5);
    }

    return TRUE;  
}


                            
//
// CIISWizardBookEnd page
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



IMPLEMENT_DYNCREATE(CIISWizardBookEnd, CIISWizardPage)



CIISWizardBookEnd::CIISWizardBookEnd(
    IN HRESULT * phResult,
    IN UINT nIDWelcomeTxtSuccess,
    IN UINT nIDWelcomeTxtFailure,
    IN UINT nIDCaption,             OPTIONAL
    IN UINT nIDBodyTxtSuccess,      OPTIONAL
    IN UINT nIDBodyTxtFailure,      OPTIONAL
    IN UINT nIDClickTxt,            OPTIONAL
    IN UINT nIDTemplate             OPTIONAL
    )
/*++

Routine Description:

    Constructor for success/failure page

Arguments:

    HRESULT * phResult          : Address of result code
    UINT nIDWelcomeTxtSuccess   : Success message
    UINT nIDWelcomeTxtFailure   : Failure message
    UINT nIDCaption             : Template caption
    UINT nIDBodyTxtSuccess      : Body text for success
    UINT nIDBodyTxtFailure      : Body text for success
    UINT nIDClickTxt            : Click message
    UINT nIDTemplate            : Dialog template
    

Return Value:

    N/A

--*/
    : CIISWizardPage(
        nIDTemplate ? nIDTemplate : CIISWizardBookEnd::IDD,
        nIDCaption
        ),
      m_phResult(phResult),
      m_strWelcomeSuccess(),
      m_strWelcomeFailure(),
      m_strBodySuccess(),
      m_strBodyFailure(),
      m_strClick()
{
    ASSERT_PTR(m_phResult); // Must know success/failure

    VERIFY(m_strWelcomeSuccess.LoadString(nIDWelcomeTxtSuccess));
    VERIFY(m_strWelcomeFailure.LoadString(nIDWelcomeTxtFailure));
    VERIFY(m_strClick.LoadString(nIDClickTxt ? nIDClickTxt : IDS_WIZ_FINISH));

    if (nIDBodyTxtSuccess)
    {
        VERIFY(m_strBodySuccess.LoadString(nIDBodyTxtSuccess));
    }

    if (nIDBodyTxtFailure)
    {
        VERIFY(m_strBodyFailure.LoadString(nIDBodyTxtFailure));
    }
    else
    {
        //
        // Error text only by default
        //
        m_strBodyFailure = _T("%h");
    }
}



CIISWizardBookEnd::CIISWizardBookEnd(
    IN UINT nIDWelcomeTxt,        
    IN UINT nIDCaption,         OPTIONAL
    IN UINT nIDBodyTxt,
    IN UINT nIDClickTxt,        OPTIONAL
    IN UINT nIDTemplate
    )
/*++

Routine Description:

    Constructor for welcome page

Arguments:

    UINT nIDWelcomeTxt          : Welcome message
    UINT nIDCaption             : Template
    UINT nIDBodyTxt             : Body text
    UINT nIDClickTxt            : Click message
    UINT nIDTemplate            : Dialog template

Return Value:

    N/A

--*/
    : CIISWizardPage(
        nIDTemplate ? nIDTemplate : CIISWizardBookEnd::IDD,
        nIDCaption
        ),
      m_phResult(NULL),
      m_strWelcomeSuccess(),
      m_strWelcomeFailure(),
      m_strBodySuccess(),
      m_strBodyFailure(),
      m_strClick()
{
    VERIFY(m_strWelcomeSuccess.LoadString(nIDWelcomeTxt));

    if (nIDBodyTxt)
    {
        VERIFY(m_strBodySuccess.LoadString(nIDBodyTxt));
    }

    VERIFY(m_strClick.LoadString(nIDClickTxt ? nIDClickTxt : IDS_WIZ_NEXT));
}



//
// Message Map
//
BEGIN_MESSAGE_MAP(CIISWizardBookEnd, CIISWizardPage)
    //{{AFX_MSG_MAP(CIISWizardBookEnd)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()



BOOL 
CIISWizardBookEnd::OnSetActive() 
/*++

Routine Description:

    Activation handler

Arguments:

    None

Return Value:

    TRUE to display the page, FALSE otherwise.

--*/
{
    if (IsWelcomePage())
    {
        GetDlgItem(IDC_STATIC_WZ_WELCOME)->SetWindowText(m_strWelcomeSuccess);
        GetDlgItem(IDC_STATIC_WZ_BODY)->SetWindowText(m_strBodySuccess);
    }
    else
    {
        CError err(*m_phResult);

        GetDlgItem(IDC_STATIC_WZ_WELCOME)->SetWindowText(
            err.Succeeded() ? m_strWelcomeSuccess : m_strWelcomeFailure
            );

        //
        // Build body text string and expand error messages
        //
        CString strBody = err.Succeeded() ? m_strBodySuccess : m_strBodyFailure;
        err.TextFromHRESULTExpand(strBody);

        GetDlgItem(IDC_STATIC_WZ_BODY)->SetWindowText(strBody);
    }

    DWORD dwFlags = IsWelcomePage() ? PSWIZB_NEXT : PSWIZB_FINISH;

    SetWizardButtons(dwFlags);

    return CIISWizardPage::OnSetActive();
}



BOOL 
CIISWizardBookEnd::OnInitDialog() 
/*++

Routine Description:

    WM_INITDIALOG handler.  Initialize the dialog.

Arguments:

    None.

Return Value:

    TRUE if no focus is to be set automatically, FALSE if the focus
    is already set.

--*/
{
    CIISWizardPage::OnInitDialog();

    //
    // Make the "Click 'foo' to continue" message bold as well.
    //
    if (m_hWnd != NULL)
    // This paranoia check to shut down PREFIX
    {
       ApplyFontToControls(this, GetBoldFont(), IDC_STATIC_WZ_CLICK, IDC_STATIC_WZ_CLICK);

       GetDlgItem(IDC_STATIC_WZ_CLICK)->SetWindowText(m_strClick);

       //
       // Remove Cancel Button on the completion page only.
       //
       EnableSheetButton(IDCANCEL, IsWelcomePage());
    }
    return TRUE;  
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\common2\debugatl.h ===
/*++

   Copyright    (c)    1994-1999    Microsoft Corporation

   Module  Name :

        debugafx.h

   Abstract:

        Debugging routines using ATL extensions

   Author:

        Ronald Meijer (ronaldm)
        Sergei Antonov (sergeia)

   Project:

        Internet Services Manager

   Revision History:
        3/20/2000    sergeia        Made this compatible to ATL, not MFC

--*/
#ifndef _DEBUGATL_H
#define _DEBUGATL_H

#if defined(_DEBUG) || DBG

    #undef ATLASSERT
    #undef ASSERT
    #undef _ASSERTE
    #undef VERIFY

    #define _ASSERTE(expr)\
            do { if (!(expr) &&\
                    (IISUIFireAssert(__FILE__, __TIMESTAMP__, __LINE__, #expr)==1))\
                 DebugBreak(); } while (0)

    #define ASSERT(expr)    _ASSERTE(expr)

    #define VERIFY(expr)    _ASSERTE(expr)
    #define ATLASSERT(expr) _ASSERTE(expr)

    #define ASSERT_PTR(ptr)                 _ASSERTE(ptr != NULL);
    #define ASSERT_READ_PTR(ptr)            _ASSERTE(ptr != NULL && !IsBadReadPtr(ptr, sizeof(*ptr)));
    #define ASSERT_READ_PTR2(ptr, cb)       _ASSERTE(ptr != NULL && !IsBadReadPtr(ptr, cb));
    #define ASSERT_WRITE_PTR(ptr)           _ASSERTE(ptr != NULL && !IsBadWritePtr(ptr, sizeof(*ptr)));
    #define ASSERT_WRITE_PTR2(ptr, cb)      _ASSERTE(ptr != NULL && !IsBadWritePtr(ptr, cb));
    #define ASSERT_READ_WRITE_PTR(ptr)      ASSERT_READ_PTR(ptr); ASSERT_WRITE_PTR(ptr);
    #define ASSERT_READ_WRITE_PTR2(ptr, cb) ASSERT_READ_PTR2(ptr, cb); && ASSERT_WRITE_PTR2(ptr, cb);
    #define ASSERT_MSG(msg)\
            do { if (IISUIFireAssert(__FILE__, __TIMESTAMP__, __LINE__, msg)==1)\
                 DebugBreak(); } while (0)

    int _EXPORT
    IISUIFireAssert(
        const char * filename,
        const char * timestamp,
        int linenum,
        const char * expr
        );

#else
    //
    // Retail
    //
    #undef ATLASSERT
    #undef ASSERT
    #undef VERIFY

    #define ATLASSERT
    #define ASSERT
    #define VERIFY(exp)    (exp)
    #define ASSERT_PTR(ptr)           
    #define ASSERT_READ_PTR(ptr)
    #define ASSERT_READ_PTR2(ptr, cb)
    #define ASSERT_WRITE_PTR(ptr)
    #define ASSERT_WRITE_PTR2(ptr, cb)
    #define ASSERT_READ_WRITE_PTR(ptr)
    #define ASSERT_READ_WRITE_PTR2(ptr, cb)
    #define ASSERT_MSG(msg)                 

#endif // _DEBUG || DBG


#ifndef TRACE
   #define TRACE                   ATLTRACE
#endif

#ifndef TRACE0
  #ifdef _DEBUG
    #define TRACE0(fmt) TRACE(fmt)
    #define TRACE1(fmt, a1) TRACE(fmt, a1)
    #define TRACE2(fmt, a1, a2) TRACE(fmt, a1, a2)
    #define TRACE3(fmt, a1, a2, a3) TRACE(fmt, a1, a2, a3)
    #define TRACE4(fmt, a1, a2, a3, a4) TRACE(fmt, a1, a2, a3, a4)
  #else // _DEBUG
    #define TRACE0(fmt)
    #define TRACE1(fmt, a1)
    #define TRACE2(fmt, a1, a2)
    #define TRACE3(fmt, a1, a2, a3)
    #define TRACE4(fmt, a1, a2, a3, a4)
  #endif // _DEBUG
#endif // TRACE0

#if defined(_DEBUG) || DBG
   #define TRACEEOLID(msg)\
      do {TRACE("%s %d %s\n", __FILE__, __LINE__, msg); } while (FALSE)
   #define TRACEEOLERR(err,x) { if (err) TRACEEOLID(x) }
   #define TRACEEOL(msg)\
       do {TRACE("%s\n", msg);} while (FALSE)
#else
   #define TRACEEOLID(msg)
   #define TRACEEOLERR(err,x)
   #define TRACEEOL(msg)
#endif

#define TRACE_RETURN(msg, err) TRACEEOLID(msg); return err;
#define TRACE_NOTIMPL(msg)     TRACE_RETURN(msg, E_NOTIMPL);
#define TRACE_NOINTERFACE(msg) TRACE_RETURN(msg, E_NOINTERFACE);
#define TRACE_UNEXPECTED(msg)  TRACE_RETURN(msg, E_UNEXPECTED);
#define TRACE_POINTER(msg)     TRACE_RETURN(msg, E_POINTER);

#endif // _DEBUGATL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\common2\common.h ===
/*++

   Copyright    (c)    1994-2000   Microsoft Corporation

   Module  Name :

        common.h

   Abstract:

        Common properties header file

   Author:

        Ronald Meijer (ronaldm)
        Sergei Antonov (sergeia)

   Project:

        Internet Services Manager

   Revision History:
        2/17/2000    sergeia     removed dependency on MFC

--*/



#ifndef __COMPROP_H__
#define __COMPROP_H__


#include <lmcons.h>
#include <wincrypt.h>
#include <iis64.h>
#include "inetcom.h"
#include "iisinfo.h"
#include "svcloc.h"

#include "resource.h"

#ifndef _DLLEXP
    #define _EXPORT              __declspec(dllimport)
#else
    #define _EXPORT              __declspec(dllexport)
#endif


//
// Memory Allocation Macros
//
//#define AllocMem(cbSize)\
//    ::LocalAlloc(LPTR, cbSize)

//#define FreeMem(lp)\
//    ::LocalFree(lp)

//#define AllocMemByType(citems, type)\
//    (type *)AllocMem(citems * sizeof(type))



//
// Program flow macros
//
#define FOREVER for(;;)

#define BREAK_ON_ERR_FAILURE(err)\
    if (err.Failed()) break;

#define BREAK_ON_NULL_PTR(lp)\
    if (lp == NULL) break;

#define BREAK_ON_FAILURE(hr)\
    if (FAILED(hr)) break

//
// Safe allocators
//
#define SAFE_DELETE(obj)\
    if (obj != NULL) do { delete obj; obj = NULL; } while(0)

#define SAFE_DELETE_OBJECT(obj)\
    if (obj != NULL) do { DeleteObject(obj); obj = NULL; } while(0)

#define SAFE_FREEMEM(lp)\
    if (lp != NULL) do { FreeMem(lp); lp = NULL; } while(0)

#define SAFE_SYSFREESTRING(lp)\
    if (lp != NULL) do { ::SysFreeString(lp); lp = NULL; } while(0)

#define SAFE_RELEASE(lpInterface)\
    if (lpInterface != NULL) do { lpInterface->Release(); lpInterface = NULL; } while(0)


#define IS_NETBIOS_NAME(lpstr) (*lpstr == _T('\\'))
//
// Return the portion of a computer name without the backslashes
//
#define PURE_COMPUTER_NAME(lpstr) (IS_NETBIOS_NAME(lpstr) ? lpstr + 2 : lpstr)

#define ARRAY_SIZE(a)    (sizeof(a)/sizeof(a[0]))
#define STRSIZE(str)     (ARRAY_SIZE(str)-1)
#define ARRAY_BYTES(a)   (sizeof(a) * sizeof(a[0]))
#define STRBYTES(str)    (ARRAY_BYTES(str) - sizeof(str[0]))

//
// General purpose files
//
#include "iiscstring.h"
typedef IIS::CString CString;

#include "debugatl.h"
#include "utcls.h"
//#include "objplus.h"
//#include "strfn.h"
//#include "odlbox.h"
#include "error.h"
#include "mdkeys.h"
//#include "ipa.h"
//#include "wizard.h"
//#include "registry.h"
//#include "ddxv.h"
//#include "objpick.h"
//#include "accentry.h"
//#include "sitesecu.h"
//#include "ipctl.h"
//#include "dtp.h"
//#include "dirbrows.h"
#include "FileChooser.h"



#endif // __COMPROP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\common\wizard.h ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        wizard.h

   Abstract:

        Enhanced dialog and IIS MMC Wizards definitions

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/

#ifndef __IISUI_WIZARD_H__
#define __IISUI_WIZARD_H__



//
// CIISWizardPage parameters
//
#define HEADER_PAGE         (TRUE)
#define WELCOME_PAGE        (FALSE)
#define USE_DEFAULT_CAPTION (0)



#if (_WIN32_IE < 0x0400)
//
// Defined in comctrl.h.  Defined here because NT 5 MFC42.dll are
// defined with _WIN32_IE 0x300
//
#pragma message("Warning: privately defining _WIN32_IE definitions")
#define PSH_WIZARD97               0x00002000
#define ICC_INTERNET_CLASSES       0x00000800
#define PSP_HIDEHEADER             0x00000800
#define PSP_USEHEADERTITLE         0x00001000
#define PSP_USEHEADERSUBTITLE      0x00002000
#define PSH_WIZARD_LITE            0x00400000
#endif // _WIN32_IE



//
// Using dialog font as a basis, create a new special effects font
//
BOOL COMDLL CreateSpecialDialogFont(
    IN CWnd * pdlg,                 // Source dialog
    IN OUT CFont * pfontSpecial,    // Font to be used must be allocated already
    IN LONG lfOffsetWeight = +300,  // Assuming boldification
    IN LONG lfOffsetHeight = +0,    // Assuming no change in height
    IN LONG lfOffsetWidth  = +0,    // Assuming no change in width (or true type)
    IN BOOL fItalic        = FALSE, // Do not invert italic state
    IN BOOL fUnderline     = FALSE  // Do not invert underline state
    );



//
// Apply fonts to child controls of a dialog
//
void COMDLL ApplyFontToControls(
    IN CWnd * pdlg,                 // Parent dialog
    IN CFont * pfont,               // Font to be applied
    IN UINT nFirst,                 // First control ID in the series
    IN UINT nLast                   // Last control ID in the series
    );



class COMDLL CEmphasizedDialog : public CDialog
/*++

Class Description:

    A standard CDialog that allows use of emphasized fonts as follows:

    control ID      Meaning
    --------------------------------------------------------------------------
    IDC_ED_BOLD1    Dialog font, bold-faced.
    IDC_ED_BOLD2    Dialog font, bold-faced.
    IDC_ED_BOLD3    Dialog font, bold-faced.
    IDC_ED_BOLD4    Dialog font, bold-faced.
    IDC_ED_BOLD5    Dialog font, bold-faced.

    Note: others might be added as needed.

Public Interface:

    CEmphasizedDialog   : Constructor

--*/
{
    DECLARE_DYNCREATE(CEmphasizedDialog)

//
// Constructors
//
public:
    CEmphasizedDialog(LPCTSTR lpszTemplateName, CWnd * pParentWnd = NULL);
    CEmphasizedDialog(UINT nIDTemplate, CWnd * pParentWnd = NULL);
    CEmphasizedDialog();

protected:
    virtual BOOL OnInitDialog();
    afx_msg void OnDestroy();

    DECLARE_MESSAGE_MAP()

private:
    CFont   m_fontBold;
};



class COMDLL CIISWizardSheet : public CPropertySheet
/*++

Class Description:

    IIS Wizard sheet base class
    
Public Interface:    

    CIISWizardSheet     : Constructor

    IsWizard97          : TRUE if the wizard is in '97 mode
    GetSpecialFont      : Get pointer to special font
    GetBitmapMemDC      : Get memory DC where bitmap resides.
    GetBackgroundBrush  : Get background brush
    QueryBitmapWidth    : Get bitmap width
    QueryBitmapHeight   : Get bitmap height

Notes:

    The sheets will be shown in wizard '97 format
    if a welcome bitmap ID is specified.  In that
    case, a header bitmap ID must also be specified.

    Additionally, the same control IDs as used in CEmphasizedDialog
    above have special meaning.

--*/
{
    DECLARE_DYNCREATE(CIISWizardSheet)

//
// Construction
//
public:
    //
    // Specifying a welcome bitmap make the wizard
    // wizard '97, otherwise it's a plain-old wizard
    // page.
    //
    CIISWizardSheet(
        IN UINT nWelcomeBitmap     = 0,
        IN UINT nHeaderBitmap      = 0,
        IN COLORREF rgbForeColor   = RGB(0,0,0),      // Black
        IN COLORREF rgbBkColor     = RGB(255,255,255) // White
        );

//
// Access
//
public:
    BOOL IsWizard97() const;
    CFont * GetSpecialFont(BOOL fHeader);
    CFont * GetBoldFont() { return &m_fontTitle; }
    CFont * GetBigFont() { return &m_fontWelcome; }
    CDC * GetBitmapMemDC(BOOL fHeader);
    HBRUSH GetBackgroundBrush() const { return m_brBkgnd; }
    CBrush * GetWindowBrush() { return &m_brWindow; }
    LONG QueryBitmapWidth(BOOL fHeader) const;
    LONG QueryBitmapHeight(BOOL fHeader) const;
    COLORREF QueryWindowColor() const { return m_rgbWindow; }
    COLORREF QueryWindowTextColor() const { return m_rgbWindowText; }
    void EnableButton(int nID, BOOL fEnable = TRUE);

protected:
    virtual BOOL OnInitDialog();
    virtual void WinHelp(DWORD dwData, UINT nCmd = HELP_CONTEXT);
    afx_msg void OnDestroy();

    DECLARE_MESSAGE_MAP()

protected:
    static const int s_cnBoldDeltaFont;
    static const int s_cnBoldDeltaHeight;
    static const int s_cnBoldDeltaWidth;

protected:
    COLORREF m_rgbWindow;
    COLORREF m_rgbWindowText;

private:
    CFont   m_fontWelcome;
    CFont   m_fontTitle;
    HBRUSH  m_brBkgnd;       
    CBrush  m_brWindow;
    CBitmap m_bmpWelcome;
    CBitmap m_bmpHeader;
    BITMAP  m_bmWelcomeInfo;        
    BITMAP  m_bmHeaderInfo;
    CDC     m_dcMemWelcome;     
    CDC     m_dcMemHeader;     
    HBITMAP m_hbmpOldWelcome;   
    HBITMAP m_hbmpOldHeader;   
};



class COMDLL CIISWizardPage : public CPropertyPage
/*++

Class Description:

    IIS Wizard page base class

Public Interface:

    CIISWizardPage      : Constructor

    ValidateString      : DDX/DDV Helper

Notes:

    If the sheet is constructed with bitmap IDs, the
    pages will be displayed in wizard '97 format.  
    Wizard '97 pages will be displayed in either welcome
    page or header page format.  The welcome page will
    be displayed on a welcome bitmap background, with
    the welcome text (IDC_STATIC_WZ_WELCOME) displayed
    in large bold.  Header pages (ordinary pages), display
    IDC_STATIC_WZ_TITLE in bold, and use the header bitmap
    at the top of the page.

    Special control IDs:
    --------------------

        IDC_STATIC_WZ_WELCOME    - Welcome text displayed in bold
        IDC_STATIC_WZ_TITLE      - Title text displayed in bold
        IDC_STATIC_WZ_SUBTITLE   - Subtitle text

--*/
{
    DECLARE_DYNCREATE(CIISWizardPage)

//
// Construction
//
public:
    CIISWizardPage(
        IN UINT nIDTemplate        = 0,
        IN UINT nIDCaption         = USE_DEFAULT_CAPTION,
        IN BOOL fHeaderPage        = FALSE,
        IN UINT nIDHeaderTitle     = USE_DEFAULT_CAPTION,
        IN UINT nIDSubHeaderTitle  = USE_DEFAULT_CAPTION
        );

public:
    //
    // DDX/DDV Helper
    //
    BOOL ValidateString(
        IN  CEdit & edit,
        OUT CString & str,
        IN  int nMin,
        IN  int nMax
        );

//
// Interface
//
protected:
    virtual BOOL OnInitDialog();
    afx_msg HBRUSH OnCtlColor(CDC * pDC, CWnd * pWnd, UINT nCtlColor);
    afx_msg BOOL OnEraseBkgnd(CDC * pDC);
    DECLARE_MESSAGE_MAP()

//
// Sheet Access
//
protected:
    CIISWizardSheet * GetSheet() const;
    void SetWizardButtons(DWORD dwFlags);
    void EnableSheetButton(int nID, BOOL fEnable = TRUE);
    BOOL IsWizard97() const;
    BOOL IsHeaderPage() const { return m_fUseHeader; }
    CFont * GetSpecialFont();
    CFont * GetBoldFont();
    CFont * GetBigFont();
    CDC   * GetBitmapMemDC();
    HBRUSH GetBackgroundBrush() const;
    CBrush * GetWindowBrush();
    LONG QueryBitmapWidth() const;
    LONG QueryBitmapHeight() const;
    COLORREF QueryWindowColor() const;
    COLORREF QueryWindowTextColor() const;

protected:
    static const int s_cnHeaderOffset;

private:
    BOOL    m_fUseHeader;    // TRUE to use header
    CRect   m_rcFillArea;    // Fill area
    CPoint  m_ptOrigin;      // Bitmap origin
    CString m_strTitle;      // Title text
    CString m_strSubTitle;   // Subtitle text
};



class COMDLL CIISWizardBookEnd : public CIISWizardPage
/*++

Class Description:

    Welcome / Completion Page

Public Interface:

    CIISWizardBookEnd    : Constructor

Notes:

    The resource template is not required.  If not provided,
    a default template will be used.

    Special control IDs (on the dialog template):
    ---------------------------------------------

        IDC_STATIC_WZ_WELCOME    - Welcome text displayed in bold
        IDC_STATIC_WZ_BODY       - Body text will be placed here
        IDC_STATIC_WZ_CLICK      - Click instructions.

    The click instructions default to something sensible, and body text
    will default to the error text on a failure page and to nothing on 
    success and welcome page.  The body text may include the %h/%H 
    escape sequences for CError on a success/failure page.

--*/
{
    DECLARE_DYNCREATE(CIISWizardBookEnd)

public:
    //
    // Constructor for success/failure completion page
    //
    CIISWizardBookEnd(
        IN HRESULT * phResult,
        IN UINT nIDWelcomeTxtSuccess ,
        IN UINT nIDWelcomeTxtFailure,
        IN UINT nIDCaption           = USE_DEFAULT_CAPTION,
        IN UINT nIDBodyTxtSuccess    = USE_DEFAULT_CAPTION,
        IN UINT nIDBodyTxtFailure    = USE_DEFAULT_CAPTION,
        IN UINT nIDClickTxt          = USE_DEFAULT_CAPTION,
        IN UINT nIDTemplate          = 0
        );

    //
    // Constructor for a welcome page
    //
    CIISWizardBookEnd(
        IN UINT nIDWelcomeTxt        = 0,
        IN UINT nIDCaption           = USE_DEFAULT_CAPTION,
        IN UINT nIDBodyTxt           = USE_DEFAULT_CAPTION,
        IN UINT nIDClickTxt          = USE_DEFAULT_CAPTION,
        IN UINT nIDTemplate          = 0
        );

//
// Dialog Data
//
protected:
    //{{AFX_DATA(CPWWelcome)
    enum { IDD = IDD_WIZARD_BOOKEND };
    //}}AFX_DATA

//
// Overrides
//
protected:
    //{{AFX_VIRTUAL(CIISWizardBookEnd)
    public:
    virtual BOOL OnSetActive();
    //}}AFX_VIRTUAL

//
// Implementation
//
protected:
    // Generated message map functions
    //{{AFX_MSG(CPWTemplate)
    virtual BOOL OnInitDialog();
    //}}AFX_MSG

    DECLARE_MESSAGE_MAP()

    BOOL IsWelcomePage() const { return m_phResult == NULL; }

private:
    HRESULT * m_phResult;
    CString m_strWelcomeSuccess;
    CString m_strWelcomeFailure;
    CString m_strBodySuccess;
    CString m_strBodyFailure;
    CString m_strClick;
};



//
// Inline Expansion
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

inline CEmphasizedDialog::CEmphasizedDialog(
    IN LPCTSTR lpszTemplateName,
    IN CWnd * pParentWnd
    )
    : CDialog(lpszTemplateName, pParentWnd)
{
}

inline CEmphasizedDialog::CEmphasizedDialog(
    IN UINT nIDTemplate,
    IN CWnd * pParentWnd
    )
    : CDialog(nIDTemplate, pParentWnd)
{
}

inline CEmphasizedDialog::CEmphasizedDialog()
    : CDialog()
{
}

inline BOOL CIISWizardSheet::IsWizard97() const
{
    return ((HBITMAP)m_bmpWelcome != NULL);
}

inline CFont * CIISWizardSheet::GetSpecialFont(BOOL fHeader)
{
    return fHeader ? &m_fontTitle : &m_fontWelcome;
}

inline CDC * CIISWizardSheet::GetBitmapMemDC(BOOL fHeader)
{
    return fHeader ? &m_dcMemHeader : &m_dcMemWelcome;
}

inline LONG CIISWizardSheet::QueryBitmapWidth(BOOL fHeader) const
{
    return fHeader ? m_bmHeaderInfo.bmWidth : m_bmWelcomeInfo.bmWidth;
}

inline LONG CIISWizardSheet::QueryBitmapHeight(BOOL fHeader) const
{
    return fHeader ? m_bmHeaderInfo.bmHeight : m_bmWelcomeInfo.bmHeight;
}

inline CIISWizardSheet * CIISWizardPage::GetSheet() const
{
    return (CIISWizardSheet *)GetParent();
}

inline void CIISWizardPage::SetWizardButtons(DWORD dwFlags)
{
    GetSheet()->SetWizardButtons(dwFlags);
}

inline void CIISWizardPage::EnableSheetButton(int nID, BOOL fEnable)
{
    GetSheet()->EnableButton(nID, fEnable);
}

inline BOOL CIISWizardPage::IsWizard97() const
{
    return GetSheet()->IsWizard97();
}

inline CFont * CIISWizardPage::GetSpecialFont()
{
    ASSERT(IsWizard97());
    return GetSheet()->GetSpecialFont(m_fUseHeader);
}

inline CFont * CIISWizardPage::GetBoldFont()
{
    ASSERT(IsWizard97());
    return GetSheet()->GetBoldFont();
}

inline CFont * CIISWizardPage::GetBigFont()
{
    ASSERT(IsWizard97());
    return GetSheet()->GetBigFont();
}

inline CDC * CIISWizardPage::GetBitmapMemDC()
{
    ASSERT(IsWizard97());
    return GetSheet()->GetBitmapMemDC(m_fUseHeader);
}

inline LONG CIISWizardPage::QueryBitmapWidth() const
{
    ASSERT(IsWizard97());
    return GetSheet()->QueryBitmapWidth(m_fUseHeader);
}

inline LONG CIISWizardPage::QueryBitmapHeight() const
{
    ASSERT(IsWizard97());
    return GetSheet()->QueryBitmapHeight(m_fUseHeader);
}

inline HBRUSH CIISWizardPage::GetBackgroundBrush() const
{
    ASSERT(IsWizard97());
    return GetSheet()->GetBackgroundBrush();
}

inline CBrush * CIISWizardPage::GetWindowBrush()
{
    ASSERT(IsWizard97());
    return GetSheet()->GetWindowBrush();
}

inline COLORREF CIISWizardPage::QueryWindowColor() const 
{ 
    ASSERT(IsWizard97());
    return GetSheet()->QueryWindowColor();
}

inline COLORREF CIISWizardPage::QueryWindowTextColor() const
{ 
    ASSERT(IsWizard97());
    return GetSheet()->QueryWindowTextColor();
}


#endif // __IISUI_WIZARD_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\common2\debugatl.cpp ===
/*++

   Copyright    (c)    1994-1999    Microsoft Corporation

   Module  Name :
        debugafx.cpp

   Abstract:
        Debugging routines using AFX/MFC extensions

   Author:
        Ronald Meijer (ronaldm)
        Sergei Antonov (sergeia)

   Project:
        Internet Services Manager

   Revision History:
        3/20/2000    sergeia        Made this compatible to ATL, not MFC
--*/



//
// Include Files
//
#include "stdafx.h"
#include "common.h"

#if defined(_DEBUG) || DBG

int 
IISUIFireAssert(
    const char * filename,
    const char * timestamp,
    int linenum,
    const char * expr
    )
{
    char sz[4096];
    char * pch = sz;

    pch += wsprintfA(pch, 
        "-------------------------------------------------------------------------------\n"
        "ASSERT FAILURE!\n"
        "-------------------------------------------------------------------------------\n"
        "File:\t\t%s\n"
        "Line:\t\t%u\n"
        "Time Stamp:\t%s\n"
        "-------------------------------------------------------------------------------\n",
        filename, linenum, timestamp
        );
        
    if (expr)
    {
        wsprintfA(pch, "Expression:\t%s\n"
        "-------------------------------------------------------------------------------\n",
        expr
        );
    } 

    TRACEEOL(sz);

    int nReturn = MessageBoxA(
        NULL, 
        sz, 
        "ASSERT FAILURE!", 
        MB_ABORTRETRYIGNORE | MB_DEFBUTTON1 | MB_ICONHAND
        );
    
    if (nReturn == IDABORT)
    {
        exit(-1);
    }
    
    //
    // Return 1 to break, 0 to ignore
    //
    return (nReturn == IDRETRY);
}


#endif // _DEBUG || DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\common2\guid.cpp ===
/*++

   Copyright    (c)    1994-1999    Microsoft Corporation

   Module  Name :

        guid.cpp

   Abstract:

        Initialization as required by initguid

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager (cluster edition)

   Revision History:

--*/

//
// Include Files
//
#include <stdafx.h>
#include <winsvc.h>

#include <objbase.h>
#include <initguid.h>

#include <iwamreg.h>
#include <iadmw.h>
#include <iisrsta.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\common2\error.h ===
/*++

   Copyright    (c)    1994-2000    Microsoft Corporation

   Module  Name :

        error.h

   Abstract:

        Message Functions Definitions

   Author:

        Ronald Meijer (ronaldm)
        Sergei Antonov (sergeia)

   Project:

        Internet Services Manager

   Revision History:
        2/17/2000    sergeia     removed dependency on MFC

--*/

#ifndef _ERROR_H
#define _ERROR_H

#pragma warning(disable:4786) // Disable warning for names > 256

//
// Slightly easier syntax to register a facility
//
#define REGISTER_FACILITY(dwCode, lpSource)\
    CError::RegisterFacility(dwCode, lpSource)

//
// Helper Function
//
HRESULT GetLastHRESULT();
BOOL InitErrorFunctionality();
void TerminateErrorFunctionality();


typedef struct tagFACILITY
{
    LPCTSTR lpszDll;
    UINT    nTextID;
} FACILITY;

#pragma warning(disable : 4231)
#pragma warning(disable : 4251)

//typedef std::map<DWORD, CString> CMapDWORDtoCString;
//typedef std::map<HRESULT, UINT> CMapHRESULTtoUINT;

class CFacilityMap : public std::map<DWORD, CString>
{
};

class COverridesMap : public std::map<HRESULT, UINT>
{
public:
   COverridesMap()
   {
   }
   ~COverridesMap()
   {
   }
};

class _EXPORT CError
/*++

Class Description:

    Error handling class, works for both HRESULT and old-style DWORD
    error codes.  Construct with or assign a DWORD or HRESULT error
    return code, and the object can then be used to determine success
    or failure, and the object provides text for the error code either
    directly, in a message, or formatted with additional text.  Also,
    the CError object understands the range of winsock errors and
    lanman errors, and looks for them in the appropriate places.
    The object can be referenced as a BOOL, a DWORD, an HRESULT, or
    a LPCTSTR as a success/failure, a WIN32 error, and HRESULT or
    the text equivalent respectively.

    Example of typical programme flow:

    CError err(FunctionWhichReturnsHresult());

    //
    // Use IDS_MY_ERROR for access denied errors for the
    // duration of this scope.
    //
    err.AddOverride(ERROR_ACCESS_DENIED, IDS_MY_ERROR);

    if (!err.MessageBoxOnFailure())
    {
        //
        // If we failed, this already displayed the error
        // message in a messagebox.  Only when we succeed
        // we get here.
        //
        ... stuff ...
    }

    SomeWinApiWhichSetsLastError();
    err.GetLastWinError();
    if (err.Failed())
    {
        printf("WIN32 Error code %ld\nHRESULT %ld\nText: %s\n",
            (DWORD)err,
            (HRESULT)err,
            (LPCTSTR)err
            );
    }

Public Interface:

    TextFromHRESULT         : Convert HRESULT to text
    TextFromHRESULTExpand   : Expand %h string to error text, %H to error code
    MessageBox              : Display error in a messagebox
    MessageBoxFormat        : Use %h string as format in messagebox
    MessageBoxOnFailure     : Display message if error is a failure
    AddOverride             : Add message override with string ID
    RemoveOverride          : Remove message override
    RegisterFacility        : Register facility
    UnregisterFacility      : Unregister facility
    Succeeded               : Determine if the error code indicates a success
    Failed                  : Determine if the error code indicates a failure

    CError                  : Constructors
    Reset                   : Reset error code
    GetLastWinError         : Assign internal code to GetLastError
    SetLastWinError         : Set last error from internal code

    operator =              : Assignment operators
    operator ==             : Comparison operators
    operator !=             : Comparison operators
    operator LPOLESTR       : Conversion operator
    operator LPCTSTR        : Conversion operator
    operator HRESULT        : Conversion operator
    operator DWORD          : Conversion operator
    operator BOOL           : Conversion operator

--*/
{
#define IS_HRESULT(hr)  (hr & 0xffff0000)
#define REMOVE_OVERRIDE ((UINT)-1)
#define NO_HELP_CONTEXT ((UINT)-1)
#define USE_LAST_ERROR  (TRUE)

//
// Private Internal FACILITY codes
//
#define FACILITY_WINSOCK    (0xffe)
#define FACILITY_LANMAN     (0xfff)

//
// Static Helpers
//
public:
    //
    // Success/Failure determinants, works regardless
    // of whether hrCode is a DWORD or HRESULT
    //
    static BOOL Succeeded(HRESULT hrCode);
    static BOOL Failed(HRESULT hrCode);

    //
    // Guarantee return is WIN32 error code
    //
    static DWORD Win32Error(HRESULT hrCode) { return HRESULT_CODE(hrCode); }

    //
    // Guarantee return is a true HRESULT
    //
    static HRESULT HResult(HRESULT hrCode) { return HRESULT_FROM_WIN32(hrCode); }

    //
    // Register a DLL for a given facility code.
    // Use NULL to unregister the facility
    //
    static void RegisterFacility(
        IN DWORD dwFacility,
        IN LPCSTR lpDLL = NULL
        );

    static void UnregisterFacility(
        IN DWORD dwFacility
        );

//
// Constructor/Destructor
//
public:
    //
    // If constructed with TRUE, the object is initialized to
    // last error.  It's set to ERROR_SUCCESS otherwise (default case)
    //
    CError();
    CError(HRESULT hrCode);
    CError(DWORD   dwCode);
    ~CError();

//
// Helpers
//
public:
    BOOL Succeeded() const { return SUCCEEDED(m_hrCode); }
    BOOL Failed() const { return FAILED(m_hrCode); }

    HRESULT TextFromHRESULT(
        OUT LPTSTR szBuffer,
        OUT DWORD  cchBuffer
        ) const;

    HRESULT TextFromHRESULT(
        OUT CString & strMsg
        ) const;

    LPCTSTR TextFromHRESULTExpand(
        OUT LPTSTR  szBuffer,
        OUT DWORD   cchBuffer,
        OUT HRESULT * phResult = NULL
        ) const;

    LPCTSTR TextFromHRESULTExpand(
        OUT CString & strBuffer
        ) const;

    int MessageBox(
        IN UINT nType = MB_OK | MB_ICONWARNING,
        IN UINT nHelpContext = NO_HELP_CONTEXT
        ) const;

    BOOL MessageBoxOnFailure(
        IN UINT nType = MB_OK | MB_ICONWARNING,
        IN UINT nHelpContext = NO_HELP_CONTEXT
        ) const;

    int MessageBoxFormat(
        IN HINSTANCE hInst,
        IN UINT nFmt,
        IN UINT nType,
        IN UINT nHelpContext,
        ...
        ) const;

    void Reset();
    void GetLastWinError();
    void SetLastWinError() const;
    DWORD Win32Error() const;
    HRESULT HResult() const { return m_hrCode; }

    //
    // Add override for specific error code.
    // Use -1 to remove the override.  This function
    // will return the previous override (or -1)
    //
    UINT AddOverride(
        IN HRESULT hrCode,
        IN UINT    nMessage = REMOVE_OVERRIDE
        );         

    void RemoveOverride(
        IN HRESULT hrCode
        );
        
    void RemoveAllOverrides();   

protected:
    //
    // Expand escape code
    //
    BOOL ExpandEscapeCode(
        IN  LPTSTR szBuffer,
        IN  DWORD cchBuffer,
        OUT IN LPTSTR & lp,
        IN  CString & strReplacement,
        OUT HRESULT & hr
        ) const;

    //
    // Check for override message
    //
    BOOL HasOverride(
        OUT UINT * pnMessage = NULL
        ) const;

//
// Assignment Operators
//
public:
    const CError & operator =(HRESULT hr);
    const CError & operator =(const CError & err);

// 
// Comparison Operators
//
public:
    const BOOL operator ==(HRESULT hr);
    const BOOL operator ==(CError & err);
    const BOOL operator !=(HRESULT hr);
    const BOOL operator !=(CError & err);

//
// Conversion Operators
//
public:
    operator const HRESULT() const { return m_hrCode; }
    operator const DWORD() const;
    operator const BOOL() const;
    operator LPOLESTR();
    operator LPCTSTR();

protected:
    static HRESULT CvtToInternalFormat(HRESULT hrCode);

    //
    // Check for FACILITY dll
    //
    static LPCTSTR FindFacility(
        IN DWORD dwFacility
        );

protected:
    friend BOOL InitErrorFunctionality();
    friend void TerminateErrorFunctionality();
    static BOOL AllocateStatics();
    static void DeAllocateStatics();
    static BOOL AreStaticsAllocated();

protected:
    static const TCHAR s_chEscape;    // Escape character
    static const TCHAR s_chEscText;   // Escape code for text
    static const TCHAR s_chEscNumber; // Escape code for error code
    static LPCTSTR s_cszLMDLL;        // Lanman Message DLL
    static LPCTSTR s_cszWSDLL;        // Winsock Message DLL
    static LPCTSTR s_cszFacility[];   // Facility Table
    static HRESULT s_cdwMinLMErr;     // Lanman Error Range
    static HRESULT s_cdwMaxLMErr;     // Lanman Error Range
    static HRESULT s_cdwMinWSErr;     // Winsock Error Range
    static HRESULT s_cdwMaxWSErr;     // Winsock Error Range
    static DWORD   s_cdwFacilities;   // Number of facility items

    //
    // Allocated objects 
    //
    static CString * s_pstrDefError;  // Default Error String
    static CString * s_pstrDefSuccs;  // Default Success String
    static CFacilityMap * s_pmapFacilities;
    static BOOL s_fAllocated;

protected:
    const CError & Construct(HRESULT hr);
    const CError & Construct(const CError & err);
    COverridesMap mapOverrides;

private:
    HRESULT m_hrCode;
    CString m_str;
};



//
// Inline Expansions
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

inline HRESULT GetLastHRESULT()
{
    return CError::HResult(::GetLastError());
}

inline /* static */ BOOL CError::Succeeded(HRESULT hrCode)
{
    //
    // Works with either HRESULT or WIN32 error code
    //
    return IS_HRESULT(hrCode)
        ? SUCCEEDED(hrCode)
        : hrCode == ERROR_SUCCESS;
}

inline /* static */ BOOL CError::Failed(HRESULT hrCode)
{
    //
    // Works with either HRESULT or WIN32 error code
    //
    return IS_HRESULT(hrCode)
        ? FAILED(hrCode)
        : hrCode != ERROR_SUCCESS;
}

inline /* static */ void CError::UnregisterFacility(
    IN DWORD dwFacility
    )
{
    RegisterFacility(dwFacility, NULL);
}

inline CError::CError()
{
    Construct(S_OK);
}

inline CError::CError(HRESULT hrCode)
{
    Construct(hrCode);
}

inline CError::CError(DWORD dwCode)
{
    Construct((HRESULT)dwCode);
}

inline DWORD CError::Win32Error() const
{
    return CError::Win32Error(m_hrCode);
}

inline void CError::Reset()
{
    m_hrCode = S_OK;
}

inline void CError::GetLastWinError()
{
    Construct(::GetLastError());
}

inline void CError::SetLastWinError() const
{
    ::SetLastError(Win32Error(m_hrCode));
}

inline void CError::RemoveOverride(
    IN HRESULT hrCode
    )
{
    (void)CError::AddOverride(hrCode, REMOVE_OVERRIDE);
}

inline const CError & CError::operator =(HRESULT hr)
{
    return Construct(hr);
}

inline const CError & CError::operator =(const CError & err)
{
    return Construct(err);
}

inline const BOOL CError::operator ==(HRESULT hr)
{
    return m_hrCode == hr;
}

inline const BOOL CError::operator ==(CError & err)
{
    return m_hrCode == err.m_hrCode;
}

inline const BOOL CError::operator !=(HRESULT hr)
{
    return m_hrCode != hr;
}

inline const BOOL CError::operator !=(CError & err)
{
    return m_hrCode != err.m_hrCode;
}

inline CError::operator const DWORD() const
{
    return Win32Error();
}

inline CError::operator const BOOL() const
{
    return Succeeded();
}

//inline CError::operator LPOLESTR()
//{
//    TextFromHRESULT(m_str);
//    return m_str.c_str();
//}
    
inline CError::operator LPCTSTR()
{
    TextFromHRESULT(m_str);
    return m_str;
}

//
// AfxMessageBox helpers
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

inline BOOL NoYesMessageBox(CString& str)
{
   CString strCaption;
   strCaption.LoadString(_Module.GetResourceInstance(), IDS_APP_TITLE);
   return ::MessageBox(::GetFocus(), str, strCaption, MB_YESNO|MB_ICONQUESTION|MB_DEFBUTTON2) == IDYES;
}

inline BOOL NoYesMessageBox(UINT nID)
{
   CString strText;
   strText.LoadString(_Module.GetResourceInstance(), nID);
   return NoYesMessageBox(strText);
}

inline BOOL YesNoMessageBox(CString& str)
{
   CString strCaption;
   strCaption.LoadString(_Module.GetResourceInstance(), IDS_APP_TITLE);
   return ::MessageBox(::GetFocus(), str, strCaption, MB_YESNO|MB_ICONQUESTION|MB_DEFBUTTON1) == IDYES;
}

inline BOOL YesNoMessageBox(UINT nID)
{
   CString strText;
   strText.LoadString(_Module.GetResourceInstance(), nID);
   return YesNoMessageBox(strText);
}

#endif // _ERROR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\common2\filechooser.h ===
//
// FileChooser.h
//
#ifndef _FILE_CHOOSER_H
#define _FILE_CHOOSER_H

#pragma warning(disable : 4275)

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

class CFileChooser;
class CFileChooserEdit;

class CFilterEntry
{
public:
   CFilterEntry() 
   {
   }
   CFilterEntry(LPCTSTR text, LPCTSTR ext)
      : m_text(text), m_ext(ext)
   {
   }
   CString m_text;
   CString m_ext;
};

#define FC_UNDEFINED             0x00000000
#define FC_FORWRITE              0x00000001
#define FC_AUTOCOMPLETION        0x00000002
// Put "*.ext" to edit initially if no file with default
// extensions was found in the initial directory
#define FC_WILDCARD_DEFAULT      0x00000004
// Set "description (*.ext)" to FileDialog filter
#define FC_WILDCARD_DESC         0x00000008
// prefill the path edit with default file name
#define FC_PREPARE_DEFAULT       0x00000010
// supress file existance check
#define FC_PATH_CHECK            0x00000020
// Check if entered filename with any of default extensions
// are available in the current directory. If yes, choose it
#define FC_CHECK_FILENAME_ONLY   0x00000040
#define FC_DIRECTORY_ONLY        0x00000080
#define FC_HIDEREADONLY          0x00000100
#define FC_COMMANDLINE           0x00000200

#define FC_DEFAULT\
   FC_AUTOCOMPLETION | FC_WILDCARD_DESC | FC_WILDCARD_DEFAULT | FC_PATH_CHECK
#define FC_DEFAULT_READ\
   FC_DEFAULT | FC_HIDEREADONLY
#define FC_DEFAULT_WRITE\
   FC_DEFAULT | FC_FORWRITE

#define FC_SUCCESS               0x00000000
#define FC_FILE_DOES_NOT_EXIST   0x00000001
#define FC_FILENAME_IS_DIRECTORY 0x00000002
#define FC_FILENAME_IS_FILE      0x00000003
#define FC_TEXT_IS_INVALID       0x00000004
#define FC_WRONG_FORMAT          0x00000005
#define FC_NO_CLOSING_QUOTE      0x00000006

class _EXPORT CFileChooser : 
   public CWindowImpl<CFileChooser>
{
   friend class CFileChooserButton;
public:
   CFileChooser()
      :  m_pParent(NULL),
         m_bDoReplaceFile(FALSE),
         m_bEditDirty(FALSE),
         m_bTextValid(TRUE),
         m_bDialogActive(FALSE),
         m_bInternalChange(FALSE),
         m_dwStyle(FC_UNDEFINED),
         m_ofn_Flags(0),
         m_edit(this, 1),
         m_button(this, 2)
   {
   }
   ~CFileChooser()
   {
   }

BEGIN_MSG_MAP(CFileChooser)
ALT_MSG_MAP(1)
    MESSAGE_HANDLER(WM_CHAR, OnEditChar)
	MESSAGE_HANDLER(WM_SETFOCUS, OnEditSetFocus)
	MESSAGE_HANDLER(WM_KILLFOCUS, OnEditKillFocus)
    REFLECT_NOTIFICATIONS()
ALT_MSG_MAP(2)
    MESSAGE_HANDLER(BM_SETSTATE, OnSetBrowseState)
END_MSG_MAP()

   BOOL Init(CWindow * pParent, DWORD dwStyle, UINT idEdit, UINT idButton);
   DWORD GetStyle() const
   {
      return m_dwStyle;
   }
   DWORD SetStyle(DWORD dwStyle)
   {
      DWORD dw = m_dwStyle;
      m_dwStyle = dwStyle;
      return dw;
   }
   BOOL StyleBitSet(DWORD bit)
   {
      return 0 != (m_dwStyle & bit);
   }
   BOOL OpenForRead()
   {
      return !StyleBitSet(FC_FORWRITE);
   }
   void AddStyle(DWORD dwStyle)
   {
      m_dwStyle |= dwStyle;
   }
   void RemoveStyle(DWORD dwStyle)
   {
      m_dwStyle &= ~dwStyle;
   }
   void SetOfnFlags(DWORD flags)
   {
      m_ofn_Flags = flags;
   }
   DWORD GetOfnFlags()
   {
      return m_ofn_Flags;
   }
   void SetDialogTitle(LPCTSTR strTitle)
   {
      m_strTitle = strTitle;
   }
   DWORD GetFileName(CString& str);
   void SetPath(const CString& str);
   void AddExtension(LPCTSTR text, LPCTSTR ext);
   void AddExtension(HINSTANCE hInst, UINT idText, UINT idExt);
   int BrowseForFolderCallback(HWND hwnd, UINT uMsg, LPARAM lParam);
   void OnEditChange();
   void OnPaste();

protected:
   void OnBrowseBtn();
   void CreateFilter(CString& strFilter, CString& strDefExt);
   void CreateDefaultPathForRead();
   BOOL BrowseForFile(CString& strPath, CString& strFile);
   BOOL BrowseForFolder(CString& strPath);
   LRESULT OnEditChar(UINT nMsg, WPARAM, LPARAM, BOOL&);
   LRESULT OnEditSetFocus(UINT nMsg, WPARAM, LPARAM, BOOL&);
   LRESULT OnEditKillFocus(UINT nMsg, WPARAM, LPARAM, BOOL&);
   LRESULT OnSetBrowseState(UINT nMsg, WPARAM, LPARAM, BOOL&);
//   LRESULT OnEditPaste(UINT nMsg, WPARAM, LPARAM, BOOL&);
   LRESULT OnEditCommand(UINT nMsg, WPARAM, LPARAM, BOOL&);
   BOOL HasEditFocus();
   BOOL IsValidChar(UINT nChar, BOOL bExcludeWildcards = TRUE);
   BOOL IsValidPath(LPCTSTR);
   void SetCompactedPath(LPCTSTR path);
   void SetPathToEdit(LPCTSTR path);
   int ExtractPath(LPTSTR path);
   int ExtractArgs(LPTSTR buf);
   void GetText(LPTSTR buf);
   int GetFilterIndex(const CString& fileName);

protected:
   DWORD m_ofn_Flags;
   CWindow * m_pParent;
   CContainedWindow m_edit;
   CContainedWindow m_button;
   DWORD m_dwStyle;
   CString m_strPath;
   LPTSTR m_pPathTemp;
   CString m_strTitle;
   std::list<CFilterEntry> m_ext;
   BOOL m_bDoReplaceFile;
   BOOL m_bEditDirty;
   BOOL m_bTextValid;
   BOOL m_bDialogActive;
   BOOL m_bInternalChange;
};

#endif   //_FILE_CHOOSER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\common2\filechooser.cpp ===
//
// FileChooser.cpp
//
#include "stdafx.h"
#include "common.h"
#include "FileChooser.h"
#include <Shlwapi.h>
#include <shellapi.h>
#include <ShlObj.h>
#include <CommDlg.h>

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

const TCHAR QuotMark = _T('\"');
const TCHAR AllExt[] = _T(".*");

//---------------------

BOOL 
CFileChooser::Init(CWindow * pParent, DWORD dwStyle, UINT idEdit, UINT idButton)
{
   ASSERT(NULL != pParent);
   ASSERT(NULL != pParent->GetDlgItem(idEdit));
   ASSERT(NULL != pParent->GetDlgItem(idButton));
   
   m_pParent = pParent;
   SetStyle(dwStyle);

   VERIFY(m_edit.SubclassWindow(pParent->GetDlgItem(idEdit)));
   if (StyleBitSet(FC_AUTOCOMPLETION))
   {
      SHAutoComplete(pParent->GetDlgItem(idEdit), SHACF_FILESYSTEM);
   }

   VERIFY(m_button.SubclassWindow(pParent->GetDlgItem(idButton)));

   return FALSE;
}

// External SetPath
void 
CFileChooser::SetPath(const CString& path)
{
   m_strPath = path;
   if (OpenForRead() && StyleBitSet(FC_PREPARE_DEFAULT))
      CreateDefaultPathForRead();
   SetPathToEdit(m_strPath);
   m_bEditDirty = FALSE;
}

BOOL 
CFileChooser::HasEditFocus()
{
   return GetFocus() == m_edit.m_hWnd;
}

void 
CFileChooser::SetPathToEdit(LPCTSTR path)
{
   if (HasEditFocus())
   {
      m_edit.SetWindowText(path);
   }
   else
   {
      SetCompactedPath(path);
   }
}

void 
CFileChooser::CreateDefaultPathForRead()
{
	if (!PathFileExists(m_strPath))
	{
		// try to find first file with the first extension
      // from the extensions list
      BOOL bDefaultSet = FALSE;
      BOOL bPathEmpty = m_strPath.IsEmpty();
      TCHAR find_str[MAX_PATH];
		WIN32_FIND_DATA find_data;
      if (bPathEmpty)
      {
         GetCurrentDirectory(MAX_PATH, find_str);
         m_strPath = find_str;
      }
      else
      {
         StrCpy(find_str, m_strPath);
         if (!PathIsDirectory(find_str))
         {
		      PathRemoveFileSpec(find_str);
         }
      }
	  PathAppend(find_str, _T("*"));
      std::list<CFilterEntry>::iterator it;
      for (it = m_ext.begin(); it != m_ext.end(); it++)
      {
         CString ext = (*it).m_ext;
		   PathAddExtension(find_str, ext);
		   HANDLE hFind = FindFirstFile(find_str, &find_data);
		   if (	hFind != INVALID_HANDLE_VALUE 
			   && (find_data.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0
			   )
		   {
            if (!bPathEmpty)
            {
               TCHAR buf[MAX_PATH];
               StrCpy(buf, m_strPath);
			      PathRemoveFileSpec(buf);
               m_strPath = buf;
            }
			   m_strPath += find_data.cFileName;
			   FindClose(hFind);
            bDefaultSet = TRUE;
            break;
		   }
      }
      if (!bDefaultSet && StyleBitSet(FC_WILDCARD_DEFAULT))
      {
	     // if nothing found, just attach *.ext to the path
         // find_str was prepared before as xxx\*.
		 m_strPath = find_str;
         if (!m_ext.empty())
         {
            m_strPath += m_ext.front().m_ext;
         }
         else
         {
            m_strPath += _T("*");
         }
      }
    }
}

BOOL 
CFileChooser::IsValidChar(UINT nChar, BOOL bExcludeWildcards)
{
   switch (PathGetCharType((TCHAR)nChar))
   {
   case GCT_INVALID:
      return FALSE;
   case GCT_WILD:
      return !bExcludeWildcards;
   case GCT_LFNCHAR:
   case GCT_SEPARATOR:
   case GCT_SHORTCHAR:
      break;
   }
   return TRUE;
}

BOOL 
CFileChooser::IsValidPath(LPCTSTR path)
{
   UINT len = lstrlen(path);
   BOOL bRes = TRUE;
   for (UINT i = 0; i < len; i++)
   {
      TCHAR c = path[i];
      if (!IsValidChar(c))
      {
         bRes = FALSE;
         break;
      }
   }
   return bRes;
}

// Character filtering routine for the edit control.
// Returns TRUE if character should be passed to the CEdit
//
LRESULT 
CFileChooser::OnEditChar(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
   UINT nChar = wParam;
   UINT nRepCount = (UINT)lParam & 0xFFFF;
   UINT nFlags = (UINT)((lParam & 0xFFFF0000) >> 16);
   bHandled = TRUE;
   if (IsValidChar(nChar))
   {
       bHandled = FALSE;
   }
   else
   {
      switch (nChar)
      {
      case VK_DELETE:
      case VK_BACK:
      case _T('/'):
         bHandled = FALSE;
         break;
      case _T('"'):
         bHandled = !StyleBitSet(FC_COMMANDLINE);
         break;
      }
   }
   m_bEditDirty = !bHandled;
   return 0;
}

// Text was pasted to edit control
void 
CFileChooser::OnPaste()
{
   TCHAR buf[MAX_PATH];
   int len = m_edit.GetWindowText(buf, MAX_PATH);
   for (int i = 0; i < len || IsValidChar(buf[i]); i++)
      ;
   if (i < len)
   {
      m_edit.SendMessage(EM_SETSEL, i, len - 1);
      m_bTextValid = FALSE;
      m_bEditDirty = FALSE;
   }
   else
   {
      m_strPath = buf;
      SetPathToEdit(buf);
      m_bEditDirty = TRUE;
   }
}

void 
CFileChooser::OnEditChange()
{
	if (!m_bInternalChange)
    {
		m_bEditDirty = TRUE;
    }
}

LRESULT 
CFileChooser::OnEditSetFocus(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    m_bInternalChange = TRUE;
    m_edit.SetWindowText(m_strPath);
    m_bInternalChange = FALSE;
    bHandled = FALSE;
    return 0;
}

LRESULT 
CFileChooser::OnEditKillFocus(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
   // update internal string buffer with path
   TCHAR buf[MAX_PATH];
   ZeroMemory(buf, MAX_PATH);
   if (m_bEditDirty)
   {
      m_edit.GetWindowText(buf, MAX_PATH);
      m_strPath = buf;
   }
   m_bInternalChange = TRUE;
   SetCompactedPath(m_strPath);
   m_bInternalChange = FALSE;
   m_bEditDirty = FALSE;
   bHandled = FALSE;
   return 0;
}

LRESULT 
CFileChooser::OnSetBrowseState(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
   // We are producing dialog on the way back
   if (!wParam)
   {
      OnBrowseBtn();
   }
   bHandled = FALSE;
   return 0;
}

void 
CFileChooser::SetCompactedPath(LPCTSTR path)
{
   // compact path before writing to edit
   CRect rc;
   m_edit.GetClientRect(&rc);
   HDC dc = m_edit.GetDC();
   TCHAR buf[MAX_PATH] = {0};
   StrCpy(buf, path);
   PathMakePretty(buf);
   PathCompactPath(dc, buf, rc.Width());
   m_edit.ReleaseDC(dc);
   m_edit.SetWindowText(buf);
}

DWORD 
CFileChooser::GetFileName(CString& strFile)
{
   DWORD dwRes = FC_SUCCESS;
   TCHAR str[MAX_PATH];
   BOOL expanded = FALSE;

   if (  !m_bTextValid
      || FC_SUCCESS != ExtractPath(str)
      || !IsValidPath(str)
      )
      return FC_TEXT_IS_INVALID;
   if (StyleBitSet(FC_PATH_CHECK))
   {
      if (OpenForRead())
      {
          TCHAR str_exp[MAX_PATH];
          lstrcpy(str_exp, str);
          DoEnvironmentSubst(str_exp, MAX_PATH);
          expanded = lstrcmpi(str, str_exp) != 0;

          if (!PathFileExists(str_exp) && !PathIsDirectory(str_exp))
	      {
            BOOL bFound = FALSE;
            if (StyleBitSet(FC_CHECK_FILENAME_ONLY))
            {
		         // try with default extension(s) if it is just filename
               // without any extensions
               LPTSTR p = PathFindExtension(str_exp);
               if (p != NULL && *p == 0)
               {
                  CString strExt, strTest = str_exp;
                  std::list<CFilterEntry>::iterator it;
                  for (it = m_ext.begin(); it != m_ext.end(); it++)
                  {
                     strExt = (*it).m_ext;
		               if (PathFileExists(strTest + strExt))
                     {
                        StrCat(str, strExt);
                        bFound = TRUE;
                        break;
                     }
                  }
               }
            }
            if (!bFound)
               dwRes = FC_FILE_DOES_NOT_EXIST;
	      }
	      else if (PathIsDirectory(str_exp))
	      {
            if (!StyleBitSet(FC_DIRECTORY_ONLY))
            {
               PathAddBackslash(str);
               dwRes = FC_FILENAME_IS_DIRECTORY;
            }
	      }
         else if (StyleBitSet(FC_DIRECTORY_ONLY))
         {
            if (PathFileExists(str_exp))
               dwRes = FC_FILENAME_IS_FILE;
         }
      }
      else if (StyleBitSet(FC_FORWRITE))
      {
         // TODO: make sure we have write access to this path
      }
   }
   if (dwRes == FC_SUCCESS)
   {
      if (StyleBitSet(FC_COMMANDLINE) || expanded)
      {
         // We are returning whole command line, get it again
         GetText(str);
      }
      strFile = str;
   }
   return dwRes;
}

BOOL 
CFileChooser::BrowseForFile(CString& strPath, CString& strFile)
{
   BOOL bRes = FALSE;
   OPENFILENAME ofn;
   TCHAR buf[MAX_PATH];

   ZeroMemory(&ofn, sizeof(OPENFILENAME));
   StrCpy(buf, strFile);
   ofn.lStructSize = sizeof(OPENFILENAME);
   // We are not using template
   ofn.hInstance = NULL;
   ofn.Flags |= m_ofn_Flags;
   ofn.Flags |= OFN_NOCHANGEDIR | OFN_OVERWRITEPROMPT;
   if (OpenForRead())
      ofn.Flags |= OFN_FILEMUSTEXIST;
    else
		ofn.Flags |= (OFN_NOREADONLYRETURN | OFN_NOTESTFILECREATE | OFN_HIDEREADONLY);
#if (_WIN32_WINNT >= 0x0500)
   ofn.FlagsEx &= ~(OFN_EX_NOPLACESBAR);
#endif
   // Create filter using our extensions list
   CString strFilter, strDefExt;
   CreateFilter(strFilter, strDefExt);
	ofn.lpstrDefExt = strDefExt;
	ofn.lpstrFile = buf;
	ofn.nMaxFile = MAX_PATH;
	ofn.lpstrInitialDir = strPath.IsEmpty() ? NULL : (LPCTSTR)strPath;
	ofn.lpstrFilter = strFilter;
	ofn.nFilterIndex = GetFilterIndex(strFile);
   // We better set the owner, or this dialog will be visible on task bar
   ofn.hwndOwner = m_pParent->m_hWnd;
   ofn.lpstrTitle = m_strTitle; 

   if (StyleBitSet(FC_HIDEREADONLY))
      ofn.Flags |= OFN_HIDEREADONLY;
   if (!StyleBitSet(FC_FORWRITE))
      bRes = GetOpenFileName(&ofn);
   else
      bRes = GetSaveFileName(&ofn);
	if (bRes)
	{
		m_bDoReplaceFile = TRUE;
	}
   else
   {
#ifdef _DEBUG
      DWORD dwError;
      ASSERT(0 == (dwError = CommDlgExtendedError()));
#endif
   }

	strFile = buf;

   return bRes;
}


static int CALLBACK 
FileChooserCallback(HWND hwnd, UINT uMsg, LPARAM lParam, LPARAM lpData)
{
   CFileChooser * pThis = (CFileChooser *)lpData;
   ASSERT(pThis != NULL);
   return pThis->BrowseForFolderCallback(hwnd, uMsg, lParam);
}

int CFileChooser::BrowseForFolderCallback(HWND hwnd, UINT uMsg, LPARAM lParam)
{
   switch (uMsg)
   {
   case BFFM_INITIALIZED:
      ASSERT(m_pPathTemp != NULL);
      if (::PathIsNetworkPath(m_pPathTemp))
         return 0;
      while (!::PathIsDirectory(m_pPathTemp))
      {
         if (0 == ::PathRemoveFileSpec(m_pPathTemp) && !::PathIsRoot(m_pPathTemp))
         {
            return 0;
         }
         DWORD attr = GetFileAttributes(m_pPathTemp);
         if (StyleBitSet(FC_FORWRITE) && (attr & FILE_ATTRIBUTE_READONLY) == 0)
            break;
      }
      ::SendMessage(hwnd, BFFM_SETSELECTION, TRUE, (LPARAM)m_pPathTemp);
      break;
   case BFFM_SELCHANGED:
      {
         LPITEMIDLIST pidl = (LPITEMIDLIST)lParam;
         TCHAR path[MAX_PATH];
         if (SHGetPathFromIDList(pidl, path))
         {
            ::SendMessage(hwnd, BFFM_ENABLEOK, 0, !PathIsNetworkPath(path));
         }
      }
      break;
   case BFFM_VALIDATEFAILED:
      break;
   }
   return 0;
}

BOOL 
CFileChooser::BrowseForFolder(CString& strPath)
{
   LPITEMIDLIST  pidl = NULL;
   HRESULT hr;
   BOOL bRes = FALSE;

   if (SUCCEEDED(hr = CoInitialize(NULL)))
   {
      if (SUCCEEDED(SHGetFolderLocation(NULL, CSIDL_DRIVES, NULL, 0, &pidl)))
      {
         LPITEMIDLIST pidList = NULL;
         BROWSEINFO bi;
         TCHAR buf[MAX_PATH];
         ZeroMemory(&bi, sizeof(bi));
         int drive = PathGetDriveNumber(strPath);
         if (GetDriveType(PathBuildRoot(buf, drive)) == DRIVE_FIXED)
         {
            StrCpy(buf, strPath);
         }
         else
         {
             buf[0] = 0;
         }
         
         bi.hwndOwner = m_pParent->m_hWnd;
         bi.pidlRoot = pidl;
         bi.pszDisplayName = m_pPathTemp = buf;
         bi.lpszTitle = m_strTitle;
         bi.ulFlags |= BIF_NEWDIALOGSTYLE | BIF_RETURNONLYFSDIRS/* | BIF_EDITBOX*/;
         bi.lpfn = FileChooserCallback;
         bi.lParam = (LPARAM)this;

         pidList = SHBrowseForFolder(&bi);
         if (  pidList != NULL
            && SHGetPathFromIDList(pidList, buf)
            )
         {
            strPath = buf;
            bRes = TRUE;
         }
         IMalloc * pMalloc;
         VERIFY(SUCCEEDED(SHGetMalloc(&pMalloc)));
         if (pidl != NULL)
            pMalloc->Free(pidl);
         pMalloc->Release();
      }
      CoUninitialize();
   }
   return bRes;
}

void
CFileChooser::AddExtension(HINSTANCE hInst, UINT idText, UINT idExt)
{
   CString text, ext;
   if (text.LoadString(hInst, idText) && ext.LoadString(hInst, idExt))
   {
      AddExtension(text, ext);
   }
}

void 
CFileChooser::AddExtension(LPCTSTR text, LPCTSTR ext)
{
   ASSERT(ext != NULL && *ext == _T('.'));
   CFilterEntry entry(text, ext);
   m_ext.push_back(entry);
}

const TCHAR cDelimiter = _T('\n');

void 
CFileChooser::CreateFilter(CString& strFilter, CString& strDefExt)
{
   strFilter.Empty();
   strDefExt.Empty();
   BOOL bExtDone = FALSE;
   std::list<CFilterEntry>::iterator it;
   for (it = m_ext.begin(); it != m_ext.end(); it++)
   {
      CFilterEntry entry = (*it);
      strFilter += entry.m_text;
      if (m_dwStyle & FC_WILDCARD_DESC)
      {
         strFilter += _T(" (*");
         strFilter += entry.m_ext;
         strFilter += _T(")");
      }
      strFilter += cDelimiter;
      strFilter += _T('*');
      strFilter += entry.m_ext;
      strFilter += cDelimiter;
      if (!bExtDone)
      {
         LPCTSTR pExt = entry.m_ext;
         strDefExt = 
            *pExt == _T('.') ? pExt + 1 : pExt;
         bExtDone = TRUE;
      }
   }
   if (!strFilter.IsEmpty())
   {
      strFilter += cDelimiter;
      for (int i = 0; i < strFilter.GetLength(); i++)
      {
         if (strFilter[i] == cDelimiter)
            strFilter.SetAt(i, 0);
      }
   }
}

int
CFileChooser::GetFilterIndex(const CString& fileName)
{
   LPTSTR p = PathFindExtension(fileName);
   if (p == NULL)
      p = (LPTSTR)AllExt;
   std::list<CFilterEntry>::iterator it;
   int idx = 1;
   for (it = m_ext.begin(); it != m_ext.end(); it++, idx++)
   {
      if (StrCmpI((*it).m_ext, p) == 0)
         return idx;
   }
   return 0;
}

void
CFileChooser::GetText(LPTSTR buf)
{
   ASSERT(buf != NULL);

   if (m_bEditDirty)
   {
      m_edit.GetWindowText(buf, MAX_PATH);
   }
   else
   {
      StrCpy(buf, m_strPath);
   }
}

int
CFileChooser::ExtractPath(LPTSTR path)
{
   ASSERT(path != NULL);
   int rc = FC_SUCCESS;
   TCHAR buf[MAX_PATH] = {0};
   LPTSTR start = buf;

   GetText(buf);

   if (StyleBitSet(FC_COMMANDLINE))
   {
      if (*buf == QuotMark)
      {
         LPTSTR end = StrChr(++start, QuotMark);
         if (end == NULL)
         {
            // Wrong format, closing quotation mark is not set
            rc = FC_NO_CLOSING_QUOTE;
            // Return part of the path up to first space
            PathRemoveArgs(buf);
         }
         else
         {
            ++end;
            *end = 0;
            PathUnquoteSpaces(buf);
            start = buf;
         }
      }
      else
      {
         PathRemoveArgs(buf);
      }
   }

   StrCpy(path, start);

   return rc;
}

int
CFileChooser::ExtractArgs(LPTSTR buf)
{
   ASSERT(buf != NULL);

   int rc = FC_SUCCESS;

   GetText(buf);
   LPTSTR p = PathGetArgs(buf);
   if (p != NULL)
   {
      StrCpy(buf, p);
   }
   else
   {
      *buf = 0;
   }
   return rc;
}

void 
CFileChooser::OnBrowseBtn()
{
   BOOL bRes = FALSE;
   if (m_bDialogActive)
      return;
   m_bDialogActive = TRUE;
   TCHAR path[MAX_PATH] = {0};
   TCHAR args[MAX_PATH] = {0};

   int rc = ExtractPath(path);
   if (StyleBitSet(FC_COMMANDLINE))
   {
      ExtractArgs(args);
   }
	CString strFile, strBuffer;
//	m_strPath = path;
   strBuffer = path;

   if (StyleBitSet(FC_FORWRITE))
   {
	   if (!PathIsDirectory(path))
	   {
		   if (PathRemoveFileSpec(path))
		   {
			   // check if path part of filename exists
			   if (PathIsDirectory(path))
			   {
				   // we will use non-path part of spec as a filename
				   strFile = PathFindFileName(strBuffer);
			   }
			   else
			   {
				   // it is wrong path, use default one
				   // TODO: actually I need to take from filespec all existent
				   // chunks of path and filename, for example c:\aa\bb\cc\dd.txt,
				   // if c:\aa\bb exists, then strPath should be set to c:\aa\bb,
				   // and strFile to dd.txt
				   path[0] = 0;
			   }
		   }
		   else
		   {
			   // it is filename only
			   strFile = strBuffer;
			   path[0] = 0;
		   }
	   }
   }
   else
   {
      if (!PathIsDirectory(path))
      {
	      strFile = PathFindFileName(path);
	      PathRemoveFileSpec(path);
      }
   }
   CString strPath(path);
   if (StyleBitSet(FC_DIRECTORY_ONLY))
   {
      bRes = BrowseForFolder(strPath);
      if (bRes)
      {
         StrCpy(path, strPath);
      }
   }
   else
   {
      bRes = BrowseForFile(strPath, strFile);
      if (bRes)
      {
         StrCpy(path, strFile);
      }
   }
   if (bRes)
   {
      if (StyleBitSet(FC_COMMANDLINE))
      {
         PathQuoteSpaces(path);
         m_strPath = path;
         if (*args != 0)
         {
            m_strPath += _T(' ');
            m_strPath += args;
         }
      }
      else
         m_strPath = path;
      SetPathToEdit(m_strPath);
      m_bEditDirty = FALSE;
   }
   m_bDialogActive = FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\common2\error.cpp ===
/*++

   Copyright    (c)    1994-1999    Microsoft Corporation

   Module  Name :

        msg.cpp

   Abstract:

        Message Functions

   Author:

        Ronald Meijer (ronaldm)
        Sergei Antonov (sergeia)

   Project:

        Internet Services Manager (cluster edition)

   Revision History:
        2/18/2000    sergeia     removed dependency on MFC

--*/

#include "stdafx.h"
#include <lmerr.h>
#include <lmcons.h>
#include "common.h"

extern CComModule _Module;

#ifdef _MT

    //
    // Thread protected stuff
    //
    #define RaiseThreadProtection() \
        do {\
            EnterCriticalSection(&_csSect);\
        } while(0)
    #define LowerThreadProtection() \
        do {\
            LeaveCriticalSection(&_csSect);\
        } while (0)

    static CRITICAL_SECTION _csSect;

#else

    #pragma message("Module is not thread-safe.")

    #define RaiseThreadProtection()
    #define LowerThreadProtection()

#endif // _MT

BOOL
InitErrorFunctionality()
/*++

Routine Description:

    Initialize CError class, and allocate static objects

Arguments:

    None:

Return Value:

    TRUE for success, FALSE for failure

--*/
{
#ifdef _MT
   InitializeCriticalSection(&_csSect);
#endif // _MT

    BOOL fOK = CError::AllocateStatics();

    if (fOK)
    {
//        REGISTER_FACILITY(FACILITY_APPSERVER, "iisui2.dll");
    }

    return fOK;
}



void
TerminateErrorFunctionality()
/*++

Routine Description:

    De-initialize CError class, freeing up static objects

Arguments:

    None

Return Value:

    None

--*/
{
    CError::DeAllocateStatics();

#ifdef _MT
    DeleteCriticalSection(&_csSect);
#endif // _MT
}

//
// Static Initialization:
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

const TCHAR g_cszNull[] = _T("(Null)");
const TCHAR CError::s_chEscape = _T('%');        // Error text escape
const TCHAR CError::s_chEscText = _T('h');       // Escape code for text
const TCHAR CError::s_chEscNumber = _T('H');     // Escape code for error code
LPCTSTR CError::s_cszLMDLL = _T("netmsg.dll");   // LM Error File
LPCTSTR CError::s_cszWSDLL = _T("iisui2.dll");   // Winsock error file
LPCTSTR CError::s_cszFacility[] = 
{
    /* FACILITY_NULL        */ NULL,
    /* FACILITY_RPC         */ NULL,
    /* FACILITY_DISPATCH    */ NULL,            
    /* FACILITY_STORAGE     */ NULL,
    /* FACILITY_ITF         */ NULL,
    /* FACILITY_DS          */ NULL,
    /* 6                    */ NULL,
    /* FACILITY_WIN32       */ NULL,
    /* FACILITY_WINDOWS     */ NULL,
    /* FACILITY_SSPI        */ NULL,
    /* FACILITY_CONTROL     */ NULL,
    /* FACILITY_CERT        */ NULL,
    /* FACILITY_INTERNET    */ _T("metadata.dll"),
    /* FACILITY_MEDIASERVER */ NULL,
    /* FACILITY_MSMQ        */ NULL,
    /* FACILITY_SETUPAPI    */ NULL,
    /* FACILITY_SCARD       */ NULL,
    /* 17 (MTX)             */ _T("iisui2.dll"),
};

HRESULT CError::s_cdwMinLMErr = NERR_BASE; 
HRESULT CError::s_cdwMaxLMErr = MAX_NERR;
HRESULT CError::s_cdwMinWSErr = WSABASEERR;    
HRESULT CError::s_cdwMaxWSErr = WSABASEERR + 2000;    
DWORD   CError::s_cdwFacilities = (sizeof(CError::s_cszFacility)\
    / sizeof(CError::s_cszFacility[0]));

//
// Allocated objects
//
CString * CError::s_pstrDefError;
CString * CError::s_pstrDefSuccs;
CFacilityMap * CError::s_pmapFacilities;
BOOL CError::s_fAllocated = FALSE;



/* protected */
/* static */
BOOL
CError::AllocateStatics()
/*++

Routine Description:

    Allocate static objects

Arguments:

    None

Return Value:

    TRUE for successfull allocation, FALSE otherwise

--*/
{
    RaiseThreadProtection();

    if (!AreStaticsAllocated())
    {
        try
        {
            CError::s_pstrDefError   = new CString;
            CError::s_pstrDefSuccs   = new CString(_T("0x%08lx"));
            CError::s_pmapFacilities = new CFacilityMap;
            s_fAllocated = TRUE;

            if (!CError::s_pstrDefError->LoadString(_Module.GetResourceInstance(), IDS_NO_MESSAGE))
            {
                //
                // Just in case we didn't load this message from the resources
                //
                ASSERT_MSG("Unable to load resource message");
                *s_pstrDefError = _T("Error Code: 0x%08lx");
            }
        }
        catch(std::bad_alloc)
        {
            ASSERT_MSG("Initialization Failed");
        }
    }

    LowerThreadProtection();

    return AreStaticsAllocated();
}



/* protected */
/* static */
void
CError::DeAllocateStatics()
/*++

Routine Description:

    Clean up allocations

Arguments:

    N/A

Return Value:

    N/A

--*/
{

    RaiseThreadProtection();

    if (AreStaticsAllocated())
    {
        SAFE_DELETE(CError::s_pstrDefError);
        SAFE_DELETE(CError::s_pstrDefSuccs);
        SAFE_DELETE(CError::s_pmapFacilities);

        s_fAllocated = FALSE;
    }

    LowerThreadProtection();
}


/*static*/ BOOL 
CError::AreStaticsAllocated() 
{ 
   return s_fAllocated; 
}

/* static */
HRESULT 
CError::CvtToInternalFormat(
    IN HRESULT hrCode
    )
/*++

Routine Description:

    Convert WIN32 or HRESULT code to internal (HRESULT) format.

Arguments:

    DWORD dwCode        Error code

Return Value:

    HRESULT

Notes:

    HRESULTS are left as is.  Lanman and Winsock errors are converted
    to HRESULTS using private facility codes.

--*/
{
    if (IS_HRESULT(hrCode))
    {
        return hrCode;
    }

    if(hrCode >= s_cdwMinLMErr && hrCode <= s_cdwMaxLMErr)
    {
        return MAKE_HRESULT(SEVERITY_ERROR, FACILITY_LANMAN, (DWORD)hrCode);
    }

    if (hrCode >= s_cdwMinWSErr && hrCode <= s_cdwMaxWSErr)
    {
        return MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WINSOCK, (DWORD)hrCode);
    }

    return HResult(hrCode);    
}



/* static */ 
void 
CError::RegisterFacility(
    IN DWORD dwFacility,
    IN LPCSTR lpDLL         OPTIONAL
    )
/*++

Routine Description:

    Register a DLL for a given facility code.  Use NULL to unregister
    the DLL name.

Arguments:

    DWORD dwFacility : Facility code
    LPCSTR lpDLL     : DLL Name.

Return Value:

    None

--*/
{
    RaiseThreadProtection();

    ASSERT(AreStaticsAllocated());

    if (lpDLL == NULL)
    {
        //
        // Remove the facility
        //
        s_pmapFacilities->erase(dwFacility);
    }
    else
    {
        CString str(lpDLL);

        //
        // Register facility
        //
        s_pmapFacilities->insert(s_pmapFacilities->begin(), 
           CFacilityMap::value_type(dwFacility, str));
    }

    LowerThreadProtection();
}


        
/* static */
LPCTSTR 
CError::FindFacility(
    IN DWORD dwFacility
    )
/*++

Routine Description:

    Determine if a DLL name has been registered for the given facility
    code.

Arguments:

    DWORD dwFacility        : Facility code

Return Value:

    Returns the DLL name, or NULL.

--*/
{
    RaiseThreadProtection();

    ASSERT(AreStaticsAllocated());

    LPCTSTR pRes = NULL;
    CFacilityMap::iterator it = s_pmapFacilities->find(dwFacility);
    if (it != s_pmapFacilities->end())
    {
        pRes = (*it).second;
    }

    LowerThreadProtection();

    return pRes;
}



CError::~CError()
/*++

Routine Description:

    Destructor

Arguments:

    None

Return Value:

    N/A

--*/
{
}



const CError & 
CError::Construct(
    IN HRESULT hr
    )
/*++

Routine Description:

    construct with new value.

Arguments:
    
    HRESULT hr : New value, either an HRESULT or a WIN32
                 error code.

Return Value:

    Reference to current object

--*/
{
    ASSERT(AreStaticsAllocated());

    m_hrCode = CvtToInternalFormat(hr);

    return *this;
}



const CError & 
CError::Construct(
    IN const CError & err
    )
/*++

Routine Description:

    Assign new value.

Arguments:
    
    CError & err    : Error code

Return Value:

    Reference to current object

--*/
{
    ASSERT(AreStaticsAllocated());

    m_hrCode = err.m_hrCode;

    return *this;
}



int
CError::MessageBox(
    IN UINT    nType,
    IN UINT    nHelpContext OPTIONAL
    ) const
/*++

Routine Description:

    Display error message in a message box

Arguments:

    HRESULT hrCode       : HRESULT error code
    UINT    nType        : See AfxMessageBox for documentation
    UINT    nHelpContext : See AfxMessageBox for documentation

Return Value:

    AfxMessageBox return code

--*/
{
    CString strMsg;
    TextFromHRESULT(strMsg);
    return ::MessageBox(::GetAncestor(::GetFocus(), GA_ROOT), strMsg, NULL, nType);
}




//
// Extend CString just to get at FormatV publically
//
class CStringEx : public CString
{
public:
    void FormatV(LPCTSTR lpszFormat, va_list argList)
    {
        CString::FormatV(lpszFormat, argList);
    }
};



int 
CError::MessageBoxFormat(
    IN HINSTANCE hInst,
    IN UINT nFmt,
    IN UINT nType,
    IN UINT nHelpContext,
    ...
    ) const
/*++

Routine Description:

    Display formatted error message in messagebox.  The format
    string (given as a resource ID) is a normal printf-style
    string, with the additional parameter of %h, which takes
    the text equivalent of the error message, or %H, which takes
    the error return code itself.

Arguments:

    UINT    nFmt         : Resource format
    UINT    nType        : See AfxMessageBox for documentation
    UINT    nHelpContext : See AfxMessageBox for documentation
    ...                    More as needed for sprintf

Return Value:

    AfxMessageBox return code
    
--*/
{
    CString strFmt;
    CStringEx strMsg;

    strFmt.LoadString(hInst, nFmt);

    //
    // First expand the error
    //
    TextFromHRESULTExpand(strFmt);

    va_list marker;
    va_start(marker, nHelpContext);
    strMsg.FormatV(strFmt, marker);
    va_end(marker);

    return ::MessageBox(::GetFocus(), strMsg, NULL, nType);
}


BOOL 
CError::MessageBoxOnFailure(
    IN UINT nType,
    IN UINT nHelpContext    OPTIONAL
    ) const
/*++

Routine Description:

    Display message box if the current error is a failure
    condition, else do nothing

Arguments:

    UINT    nType        : See AfxMessageBox for documentation
    UINT    nHelpContext : See AfxMessageBox for documentation

Return Value:

    TRUE if a messagebox was shown, FALSE otherwise

--*/
{
    if (Failed())
    {
        MessageBox(nType, nHelpContext);
        return TRUE;
    }

    return FALSE;
}



BOOL 
CError::HasOverride(
    OUT UINT * pnMessage        OPTIONAL
    ) const
/*++

Routine Description:

    Check to see if a given HRESULT has an override

Arguments:

    HRESULT hrCode              : HRESULT to check for
    UINT * pnMessage            : Optionally returns the override

Return Value:

    TRUE if there is an override, FALSE if there is not.

--*/
{
   ASSERT(AreStaticsAllocated());

   HRESULT hrCode = CvtToInternalFormat(m_hrCode);
   if (!mapOverrides.empty())
   {
       COverridesMap::const_iterator it = mapOverrides.find(hrCode);
       if (it != mapOverrides.end())
       {
           if (pnMessage != NULL)
              *pnMessage = (*it).second;
           return TRUE;
       }
   }
   return FALSE;
}



UINT
CError::AddOverride(
    IN HRESULT    hrCode,
    IN UINT       nMessage
    )
/*++

Routine Description:

    Add an override for a specific HRESULT.

Arguments:

    HRESULT    hrCode       : HRESULT to override
    UINT       nMessage     : New message, or -1 to remove override

Return Value:

    The previous override, or -1

--*/
{
    ASSERT(AreStaticsAllocated());

    UINT nPrev;
    hrCode = CvtToInternalFormat(hrCode);

    //
    // Fetch the current override
    //
    COverridesMap::iterator it = mapOverrides.find(hrCode);
    nPrev = (it == mapOverrides.end()) ? REMOVE_OVERRIDE : (*it).second;

    if (nMessage == REMOVE_OVERRIDE)
    {
        //
        // Remove the override
        //
        mapOverrides.erase(hrCode);
    }
    else
    {
        //
        // Set new override
        //
        mapOverrides[hrCode] = nMessage;
    }

    return nPrev;
}



void
CError::RemoveAllOverrides()
/*++

Routine Description:

    Remove all overrides

Arguments:

    None

Return Value:

    None

--*/
{
    ASSERT(AreStaticsAllocated());
    mapOverrides.clear();
}



HRESULT
CError::TextFromHRESULT(
    OUT LPTSTR  szBuffer,
    OUT DWORD   cchBuffer
    ) const
/*++

Routine Description:

    Get text from the given HRESULT.  Based on the range that the HRESULT
    falls in and the facility code, find the location of the message,
    and fetch it.

Arguments:

    HRESULT hrCode      HRESULT or (DWORD WIN32 error) whose message to get
    LPTSTR  szBuffer    Buffer to load message text into
    DWORD   cchBuffer   Size of buffer in characters.

Return Value:

    HRESULT error code depending on whether the message was
    found.  If the message was not found, some generic message
    is synthesized in the buffer if a buffer is provided.

    ERROR_FILE_NOT_FOUND        No message found
    ERROR_INSUFFICIENT_BUFFER   Buffer is a NULL pointer or too small

--*/
{
    HRESULT hrReturn = ERROR_SUCCESS;

    //
    // First check to see if this message is overridden
    //
    UINT nID;
    HRESULT hrCode = m_hrCode;

    if (HasOverride(&nID))
    {
        //
        // Message overridden.  Load replacement message
        // instead.
        //
        BOOL fSuccess;

        //
        // Attempt to load from calling process first
        //
        if (!(fSuccess = ::LoadString(
            ::GetModuleHandle(NULL), 
            nID, 
            szBuffer, 
            cchBuffer
            )))
        {
            //
            // Try this dll
            //
            fSuccess = ::LoadString(
                _Module.GetResourceInstance(), 
                nID, 
                szBuffer, 
                cchBuffer
                );
        }

        if (fSuccess)
        {
            //
            // Everything ok
            //
            return hrReturn;
        }

        //
        // Message didn't exist, skip the override, and 
        // load as normal.
        //
        TRACE("Couldn't load %d\n", nID);
        ASSERT_MSG("Attempted override failed");
    }

    LPCTSTR lpDll    = NULL;
    HINSTANCE hDll   = NULL;
    DWORD dwFacility = HRESULT_FACILITY(hrCode);
    DWORD dwSeverity = HRESULT_SEVERITY(hrCode);
    DWORD dwCode     = HRESULT_CODE(hrCode);
    BOOL  fSuccess   = Succeeded(hrCode);

    //
    // Strip off meaningless internal facility codes
    //
    if (dwFacility == FACILITY_LANMAN || dwFacility == FACILITY_WINSOCK)
    {
        dwFacility = FACILITY_NULL;
        hrCode   = (HRESULT)dwCode;
    }

    DWORD dwFlags = FORMAT_MESSAGE_IGNORE_INSERTS | 
                    FORMAT_MESSAGE_MAX_WIDTH_MASK;

    //
    // Since we allow both HRESULTS and WIN32 codes to be
    // used here, we can't rely on the private FACILITY code 
    // for lanman and winsock.
    //
    if(hrCode >= s_cdwMinLMErr && hrCode <= s_cdwMaxLMErr)
    {
        //
        // Lanman error
        //
        lpDll = s_cszLMDLL;
    }
    else if (hrCode >= s_cdwMinWSErr && hrCode <= s_cdwMaxWSErr)
    {
        //
        // Winsock error
        //
        lpDll = s_cszWSDLL;
    }
    else
    {
        //
        // Attempt to determine message location from facility code.
        // Check for registered facility first.
        //
        lpDll = FindFacility(dwFacility);

        if (lpDll == NULL)
        {
            if (dwFacility < s_cdwFacilities)
            {
                lpDll = s_cszFacility[dwFacility];
            }
            else
            {
                ASSERT_MSG("Bogus FACILITY code encountered.");
                lpDll = NULL;
            }
        }
    }

    do
    {
        if (szBuffer == NULL || cchBuffer <= 0)
        {
            hrReturn = HResult(ERROR_INSUFFICIENT_BUFFER);
            break;
        }

        if (lpDll)
        {
            //
            // Load message file
            //
            hDll = ::LoadLibraryEx(
                lpDll,
                NULL,
                LOAD_LIBRARY_AS_DATAFILE
                );

            if (hDll == NULL)
            {
                hrReturn = ::GetLastHRESULT();
                break;
            }

            dwFlags |= FORMAT_MESSAGE_FROM_HMODULE;
        }
        else
        {
            dwFlags |= FORMAT_MESSAGE_FROM_SYSTEM;
        }

        DWORD dwResult = 0L;
        DWORD dwID = hrCode;
        HINSTANCE hSource = hDll;

        while(!dwResult)
        {
            dwResult = ::FormatMessage(
                dwFlags,
                (LPVOID)hSource,
                dwID,
                0,
                szBuffer,
                cchBuffer,
                NULL
                );

            if (dwResult > 0)
            {
                //
                // Successfully got a message
                //
                hrReturn = ERROR_SUCCESS;
                break;
            } 

            hrReturn = ::GetLastHRESULT();
    
            if (dwID != dwCode && !fSuccess)
            {
                //
                // Try the SCODE portion of the error from win32
                // if this is an error message
                //
                dwID = dwCode;
                hSource = NULL;
                continue;
            }

            //
            // Failed to obtain a message
            //
            hrReturn = HResult(ERROR_FILE_NOT_FOUND);
            break;
        }
    }
    while(FALSE);

    if(hDll != NULL)
    {
        ::FreeLibrary(hDll);
    }

    if (Failed(hrReturn))
    {
        //
        // Unable to find the message, synthesize something with
        // the code in it if there's room (+8 for the number)
        //
        CString & strMsg = (fSuccess ? *s_pstrDefSuccs : *s_pstrDefError);

        if (cchBuffer > (DWORD)strMsg.GetLength() + 8)
        {
            TRACE("Substituting default message for %d\n", (DWORD)m_hrCode);
            wsprintf(szBuffer, (LPCTSTR)strMsg, m_hrCode);
        }
        else
        {
            //
            // Not enough room for message code
            //
            ASSERT_MSG("Buffer too small for default message -- left blank");
            *szBuffer = _T('\0');
        }
    }

    return hrReturn;
}



HRESULT 
CError::TextFromHRESULT(
    OUT CString & strBuffer
    ) const
/*++

Routine Description:

    Similar to the function above, but use a CString

Arguments:

    HRESULT hrCode         HRESULT or (DWORD WIN32 error) whose message to get
    CString & strBuffer    Buffer to load message text into

Return Value:

    HRESULT error code depending on whether the message was
    found.  If the message was not found, some generic message
    is synthesized in the buffer if a buffer is provided.

    ERROR_FILE_NOT_FOUND   No message found

--*/
{
   DWORD cchBuffer = 255;
   HRESULT hr = S_OK;
   LPTSTR p = NULL;

   for (;;)
   {
      p = strBuffer.get_allocator().allocate(cchBuffer, p);
      if (p == NULL)
      {
         return HResult(ERROR_NOT_ENOUGH_MEMORY);
      }

      hr = TextFromHRESULT(p, cchBuffer - 1);
      if (Win32Error(hr) != ERROR_INSUFFICIENT_BUFFER)
      {
         //
         // Done!
         //
         strBuffer.assign(p);
         break;
      }

      //
      // Insufficient buffer, enlarge and try again
      //
      cchBuffer *= 2;
   }
   if (p != NULL)
   {
      strBuffer.get_allocator().deallocate(p, cchBuffer);
   }
   return hr;
}



BOOL
CError::ExpandEscapeCode(
    IN  LPTSTR szBuffer,
    IN  DWORD cchBuffer,
    OUT IN LPTSTR & lp,
    IN  CString & strReplacement,
    OUT HRESULT & hr
    ) const
/*++

Routine Description:

    Expand escape code

Arguments:

    LPTSTR szBuffer             Buffer
    DWORD cchBuffer             Size of buffer
    LPTSTR & lp                 Pointer to escape code
    CString & strReplacement    Message to replace the escape code
    HRESULT & hr                Returns HRESULT in case of failure

Return Value:

    TRUE if the replacement was successful, FALSE otherwise.
    In the case of failure, hr will return an HRESULT.
    In the case of success, lp will be advanced past the
    replacement string.

--*/
{
    //
    // Make sure there's room (account for terminating NULL)
    // Free up 2 spaces for the escape code.
    //
    int cchFmt = lstrlen(szBuffer) - 2;
    int cchReplacement = strReplacement.GetLength();
    int cchRemainder = lstrlen(lp + 2);

    if ((DWORD)(cchReplacement + cchFmt) < cchBuffer)
    {
        //
        // Put it in
        //
        MoveMemory(
            lp + cchReplacement,
            lp + 2,
            (cchRemainder + 1) * sizeof(TCHAR)
            );
        CopyMemory(lp, strReplacement, cchReplacement * sizeof(TCHAR));
        lp += cchReplacement;
        
        return TRUE;
    }

    hr = HResult(ERROR_INSUFFICIENT_BUFFER);

    return FALSE;
}



LPCTSTR 
CError::TextFromHRESULTExpand(
    OUT LPTSTR  szBuffer,
    OUT DWORD   cchBuffer,
    OUT HRESULT * phResult  OPTIONAL
    ) const
/*++

Routine Description:

    Expand %h/%H strings in szBuffer to text from HRESULT,
    or error code respectively within the limits of szBuffer.

Arguments:

    LPTSTR  szBuffer    Buffer to load message text into
    DWORD   cchBuffer   Buffer size in characters
    HRESULT * phResult  Optional return code

Return Value:

    Pointer to string.

--*/
{
    HRESULT hr = S_OK;

    if (szBuffer == NULL || cchBuffer <= 0)
    {
        hr = HResult(ERROR_INSUFFICIENT_BUFFER);
    }
    else
    {
        //
        // Look for the escape sequence
        //
        int cReplacements = 0;
        CString strMessage;
        LPTSTR lp = szBuffer;

        while (*lp)
        {
            if (*lp == s_chEscape)
            {
                switch(*(lp + 1))
                {
                case s_chEscText:
                    //
                    // Replace escape code with text message
                    //
                    hr = TextFromHRESULT(strMessage);

                    if (ExpandEscapeCode(
                        szBuffer,
                        cchBuffer,
                        lp,
                        strMessage,
                        hr
                        ))
                    {
                        ++cReplacements;
                    }
                    break;

                case s_chEscNumber:
                    //
                    // Replace escape code with numeric error code
                    //
                    strMessage.Format(_T("0x%08x"), m_hrCode);

                    if (ExpandEscapeCode(
                        szBuffer,
                        cchBuffer,
                        lp,
                        strMessage,
                        hr
                        ))
                    {
                        ++cReplacements;
                    }
                    break;

                default:
                    //
                    // Regular printf-style escape sequence.
                    //
                    break;
                }
            }

            ++lp;
        }

        if (!cReplacements)
        {
            //
            // Got to the end without finding any escape codes.
            //
            hr = HResult(ERROR_INVALID_PARAMETER);
        }
    }

    if (phResult)
    {
        *phResult = hr;
    }

    return szBuffer;
}



LPCTSTR 
CError::TextFromHRESULTExpand(
    OUT CString & strBuffer
    ) const
/*++

Routine Description:

    Expand %h string in strBuffer to text from HRESULT

Arguments:

    CString & strBuffer Buffer to load message text into

Return Value:

    Pointer to string.

--*/
{
   DWORD cchBuffer = strBuffer.GetLength() + 1024;
   LPTSTR p = NULL;
   for (;;)
   {
      p = strBuffer.get_allocator().allocate(cchBuffer, p);

      if (p != NULL)
      {
         HRESULT hr;

         TextFromHRESULTExpand(p, cchBuffer - 1, &hr);

         if (Win32Error(hr) != ERROR_INSUFFICIENT_BUFFER)
         {
            //
            // Done!
            //
            strBuffer.assign(p);
            break;
         }

         //
         // Insufficient buffer, enlarge and try again
         //
         cchBuffer *= 2;
      }
   }
   if (p != NULL)
   {
      strBuffer.get_allocator().deallocate(p, cchBuffer);
   }

   return strBuffer;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\common2\iisuihelper.cpp ===
#include "stdafx.h"
#include "resource.h"
#include <initguid.h>

#include "common.h"

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    lpReserved;
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance);
        DisableThreadLibraryCalls(hInstance);
        InitErrorFunctionality();
    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
        TerminateErrorFunctionality();
        _Module.Term();
    }
    return TRUE;    // ok
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\common2\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\common2\inheritancedlg.h ===
/*++

   Copyright    (c)    1994-2000    Microsoft Corporation

   Module  Name :

        inheritancedlg.h

   Abstract:

        Inheritance Dialog Definitions

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/

#ifndef __INHERITANCEDLG__H__
#define __INHERITANCEDLG__H__


class CListBoxNodes : public CWindowImpl<CListBoxNodes, CListBox>
{
public:
   BEGIN_MSG_MAP(CListBoxNodes)
   END_MSG_MAP()
};

/*++

Class Description:

    Inheritance override checker dialog.

Public Interface:

    CInheritanceDlg         : Constructor
    IsEmpty                 : Check to see if there are overrides.

Notes:

    There are two constructors.  One which assumes GetDataPaths() has
    already been called, and which takes the results from GetDataPaths()
    as a CStringList, and a second constructor which will make the GetDataPaths
    automatically.

    In either case, the calling process should check IsEmpty() right after
    constructing the dialog to see if DoModal() needs to be called.  If
    IsEmpty() returns TRUE, there's no reason to call DoModal().

--*/
class CInheritanceDlg : 
   public CDialogImpl<CInheritanceDlg>,
   public CWinDataExchange<CInheritanceDlg>
{
//
// fWrite parameter helper definitions
//
#define FROM_WRITE_PROPERTY     (TRUE)
#define FROM_DELETE_PROPERTY    (FALSE)

//
// Construction
//
public:
   CInheritanceDlg() :
      m_fWrite(FALSE), m_fEmpty(FALSE), m_fHasInstanceInMaster(FALSE), m_fUseTable(FALSE),
      m_dwMDIdentifier(0), m_dwMDAttributes(0), m_dwMDUserType(0), m_dwMDDataType(0),
      m_mk((CComAuthInfo *)NULL)
   {
   }
   //
   // Standard constructor (GetDataPaths() already called)
   //
   CInheritanceDlg(
         DWORD dwMetaID,
         BOOL fWrite,
         CComAuthInfo * pAuthInfo,
         LPCTSTR lpstrMetaRoot,
         CStringListEx & strlMetaChildNodes,
         LPCTSTR lpstrPropertyName = NULL,
         HWND hwndParent = NULL
         );

    //
    // Constructor which will call GetDataPaths()
    //
    CInheritanceDlg(
         DWORD dwMetaID,
         BOOL fWrite,
         CComAuthInfo * pAuthInfo,
         LPCTSTR lpstrMetaRoot,
         LPCTSTR lpstrPropertyName            = NULL,
         HWND hwndParent                      = NULL
         );

    //
    // Constructor which will call GetDataPaths(), and which
    // does not use the predefined property table unless
    // fTryToFindInTable is TRUE, in which case it will attempt
    // to use the table first, and use the specified parameters
    // only if the property ID is not found in the table.
    //
    CInheritanceDlg(
         BOOL    fTryToFindInTable,
         DWORD   dwMDIdentifier,
         DWORD   dwMDAttributes,
         DWORD   dwMDUserType,
         DWORD   dwMDDataType,
         LPCTSTR lpstrPropertyName,
         BOOL    fWrite,
         CComAuthInfo * pAuthInfo,
         LPCTSTR lpstrMetaRoot,
         HWND    hwndParent = NULL                     
         );
public:
    enum { IDD = IDD_INHERITANCE };
    //
    // Check to see if there's a reason to continue displaying
    // the dialog.
    //
    BOOL IsEmpty() const { return m_fEmpty; }

//
// Dialog Data
//
protected:
    CListBoxNodes m_list_ChildNodes;

//
// Implementation
//
protected:
   BEGIN_MSG_MAP_EX(CInheritanceDlg)
      MSG_WM_INITDIALOG(OnInitDialog)
      COMMAND_HANDLER_EX(IDOK, BN_CLICKED, OnOK)
      COMMAND_HANDLER_EX(IDC_BUTTON_SELECT_ALL, BN_CLICKED, OnButtonSelectAll)
   END_MSG_MAP()

   LRESULT OnInitDialog(HWND hwnd, LPARAM lParam);
   void OnOK(WORD wNotifyCode, WORD wID, HWND hwndCtrl);
   void OnButtonSelectAll(WORD wNotifyCode, WORD wID, HWND hwndCtrl);

   BEGIN_DDX_MAP(CInheritanceDlg)
      DDX_CONTROL(IDC_LIST_CHILD_NODES, m_list_ChildNodes)
   END_DDX_MAP()

   void Initialize();
   HRESULT GetDataPaths();

   BOOL FriendlyInstance(
        IN  CString & strMetaRoot,
        OUT CString & strFriendly
        );

   CString & CleanDescendantPath(
        IN OUT CString & strMetaPath
        );

private:
   BOOL    m_fWrite;
   BOOL    m_fEmpty;
   BOOL    m_fHasInstanceInMaster;
   BOOL    m_fUseTable;
   DWORD   m_dwMDIdentifier;
   DWORD   m_dwMDAttributes;
   DWORD   m_dwMDUserType;
   DWORD   m_dwMDDataType;
   CString m_strMetaRoot;
   //CString m_strServer;
   CString m_strPropertyName;
   CStringListEx m_strlMetaChildNodes;
   CMetaKey m_mk;
};


#endif // __INHERITANCEDLG__H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\common2\inheritancedlg.cpp ===
/*++

   Copyright    (c)    1994-1999    Microsoft Corporation

   Module  Name :

        idlg.cpp

   Abstract:

        Inheritance Dialog

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager (cluster edition)

   Revision History:

--*/

//
// Include Files
//
#include "stdafx.h"
#include "common.h"
#include "inheritancedlg.h"



//
// Inheritance dialog
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

CInheritanceDlg::CInheritanceDlg(
    DWORD dwMetaID,
    BOOL fWrite,
    CComAuthInfo * pAuthInfo,
    LPCTSTR lpstrMetaRoot,
    CStringListEx& strlMetaChildNodes,
    LPCTSTR lpstrPropertyName,
    HWND hwndParent
    )
/*++

Routine Description:

    Inheritance dialog constructor.  This constructor assumes GetDataPaths()
    has already been called.

Arguments:

    DWORD dwMetaID                      : Meta ID
    BOOL fWrite                         : TRUE from write, FALSE from delete
    CIISServer * pAuthInfo              : Auth info object or NULL
    LPCTSTR lpstrMetaRoot               : Meta root
    CStringList & strlMetaChildNodes    : List of child nodes from GetDataPaths
    LPCTSTR lpstrPropertyName           : Optional text string for the property
    CWnd * pParent                      : Optional parent window

Return Value:

    None

--*/
    : m_fWrite(fWrite),
      m_fEmpty(TRUE),
      m_fUseTable(TRUE),
      m_strMetaRoot(lpstrMetaRoot),
      m_strPropertyName(lpstrPropertyName ? lpstrPropertyName : _T("")),
      m_mk(pAuthInfo)
//      CDialog(CInheritanceDlg::IDD, hwndParent)
{
    m_strlMetaChildNodes = strlMetaChildNodes;

    VERIFY(CMetaKey::GetMDFieldDef(
        dwMetaID, 
        m_dwMDIdentifier, 
        m_dwMDAttributes, 
        m_dwMDUserType,
        m_dwMDDataType
        ));

    Initialize();
}



CInheritanceDlg::CInheritanceDlg(
    DWORD dwMetaID,
    BOOL fWrite,
    CComAuthInfo * pAuthInfo,
    LPCTSTR lpstrMetaRoot,
    LPCTSTR lpstrPropertyName,
    HWND hwndParent
    )
/*++

Routine Description:

    Inheritance dialog constructor.  This constructor will call GetDataPaths().

Arguments:

    DWORD dwMetaID                      : Meta ID
    BOOL fWrite                         : TRUE from write, FALSE from delete
    CComAuthInfo * pAuthInfo            : Auth info or NULL
    LPCTSTR lpstrMetaRoot               : Meta root
    LPCTSTR lpstrPropertyName           : Optional text string for the property
    CWnd * pParent                      : Optional parent window

Return Value:

    None

--*/
    : m_fWrite(fWrite),
      m_fEmpty(TRUE),
      m_fUseTable(TRUE),
      m_strMetaRoot(lpstrMetaRoot),
      m_strlMetaChildNodes(),
      m_strPropertyName(lpstrPropertyName ? lpstrPropertyName : _T("")),
      m_mk(pAuthInfo)
//      CDialog(CInheritanceDlg::IDD, pParent)
{
    //
    // Specify the resources to use
    //
//    HINSTANCE hOldRes = AfxGetResourceHandle();
//    AfxSetResourceHandle(hDLLInstance);

    VERIFY(CMetaKey::GetMDFieldDef(
        dwMetaID, 
        m_dwMDIdentifier, 
        m_dwMDAttributes, 
        m_dwMDUserType,
        m_dwMDDataType
        ));

    //
    // Need to do our own GetDataPaths()
    //
    CError err(GetDataPaths());

    if (!err.MessageBoxOnFailure())
    {
        Initialize();
    }

    //
    // Restore the resources
    //
//    AfxSetResourceHandle(hOldRes);
}



CInheritanceDlg::CInheritanceDlg(
    BOOL    fTryToFindInTable,
    DWORD   dwMDIdentifier,
    DWORD   dwMDAttributes,
    DWORD   dwMDUserType,
    DWORD   dwMDDataType,
    LPCTSTR lpstrPropertyName,
    BOOL    fWrite,
    CComAuthInfo * pAuthInfo,
    LPCTSTR lpstrMetaRoot,
    HWND hwndParent
    )
/*++

Routine Description:

    Inheritance dialog constructor.  This constructor will call GetDataPaths(),
    and will use the specified parameters if the property ID does not exist
    in the property table

Arguments:

    BOOL    fTryToFindInTable           : If TRUE, first look in table
    DWORD   dwMDIdentifier              : Metadata identifier
    DWORD   dwMDAttributes              : Metadata attributes
    DWORD   dwMDUserType                : Metadata user type
    DWORD   dwMDDataType                : Metadata data type
    LPCTSTR lpstrPropertyName           : Text string for the property
    BOOL    fWrite                      : TRUE from write, FALSE from delete
    CComAuthInfo * pAuthInfo            : Authentication info or NULL.
    LPCTSTR lpstrMetaRoot               : Meta root
    CWnd *  pParent                     : Optional parent window

Return Value:

    None

--*/
    : m_fWrite(fWrite),
      m_fEmpty(TRUE),
      m_fUseTable(FALSE),
      m_strMetaRoot(lpstrMetaRoot),
      m_strlMetaChildNodes(),
      m_mk(pAuthInfo)
//      CDialog(CInheritanceDlg::IDD, pParent)
{
    //
    // Specify the resources to use
    //
//    HINSTANCE hOldRes = AfxGetResourceHandle();
//    AfxSetResourceHandle(hDLLInstance);

    if (fTryToFindInTable && !CMetaKey::GetMDFieldDef(
        dwMDIdentifier, 
        m_dwMDIdentifier, 
        m_dwMDAttributes, 
        m_dwMDUserType,
        m_dwMDDataType
        ))
    {
        //
        // Did not exist in the table, use specified parameters
        //
        m_dwMDIdentifier  = dwMDIdentifier;
        m_dwMDAttributes  = dwMDAttributes;
        m_dwMDUserType    = dwMDUserType;
        m_dwMDDataType    = dwMDDataType;
        m_strPropertyName = lpstrPropertyName;
    }


    //
    // Need to do our own GetDataPaths()
    //
    CError err(GetDataPaths());

    if (!err.MessageBoxOnFailure())
    {
        Initialize();
    }

    //
    // Restore the resources
    //
//    AfxSetResourceHandle(hOldRes);
}



HRESULT
CInheritanceDlg::GetDataPaths()
/*++

Routine Description:

    GetDataPaths()

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    //ASSERT(!m_strServer.IsEmpty());

    CError err(m_mk.QueryResult());

    if (err.Succeeded())
    {
        err = m_mk.GetDataPaths( 
            m_strlMetaChildNodes,
            m_dwMDIdentifier,
            m_dwMDDataType,
            m_strMetaRoot
            );
    }

    return err;
}



void
CInheritanceDlg::Initialize()
/*++

Routine Description:

    Initialize data members.  Set the m_fEmpty flag to determine if
    it is necessary to proceed.

Arguments:

    None

Return Value:

    None

--*/
{
    CMetabasePath::CleanMetaPath(m_strMetaRoot);

    if (m_fUseTable && !CMetaKey::IsPropertyInheritable(m_dwMDIdentifier))
    {
        //
        // No point in displaying non-inheritable properties
        //
        return;
    }

    switch(m_dwMDIdentifier)
    {
    //
    // Ignore these properties, even though they are inheritable
    //
    case MD_VR_PATH:
    case MD_APP_ISOLATED:
    case MD_APP_FRIENDLY_NAME:
        return;
    }

    //
    // Check to see if the current metabase path contains an instance
    //
    CString strTmp;
    m_fHasInstanceInMaster = FriendlyInstance(m_strMetaRoot, strTmp);

    //
    // If property name was not specified in the constructor, load default
    // one from table.
    //
    if (m_strPropertyName.IsEmpty())
    {
        ASSERT(m_fUseTable);

        //
        // Specify the resources to use
        //
//        HINSTANCE hOldRes = AfxGetResourceHandle();
//        AfxSetResourceHandle(hDLLInstance);

        VERIFY(CMetaKey::GetPropertyDescription(
            m_dwMDIdentifier, 
            m_strPropertyName
            ));

//        AfxSetResourceHandle(hOldRes);
    }

    //
    // Go through the list of metapaths, and clean them
    // up.
    //
    CStringListEx::iterator it = m_strlMetaChildNodes.begin();
    while (it != m_strlMetaChildNodes.end())
    {
        CString& strMetaPath = (*it++);
        CMetabasePath::CleanMetaPath(strMetaPath);
    }

    //
    // If the special info key (lm/service/info) is in the list, remove it.
    // We only need to this if the key that is getting the
    // change (m_strMetaRoot) is the service master property (lm/service).
    // If it is anything else, then the special "info" key cannot be below
    // it so we don't need to check. Thus the first test is to see if there
    // is only one "/" character. If there is only one, then we know it is
    // the service and we can go ahead and do the test.  In some ways,
    // mfc is a pain, so we limited to the CString methods to do this
    // copy the root into the temp string.
    //
    int iSlash = m_strMetaRoot.ReverseFind(SZ_MBN_SEP_CHAR);

    if (iSlash >= 0)
    {
        strTmp = m_strMetaRoot.Left(iSlash);

        //
        // Now make sure that there aren't any more slashes
        //
        if (strTmp.Find(SZ_MBN_SEP_CHAR) == -1)
        {
            //
            // Now build the path to the special info key by adding it
            // to the meta root
            //
            strTmp = m_strMetaRoot + SZ_MBN_SEP_CHAR + IIS_MD_SVC_INFO_PATH;

            TRACE("Removing any descendants of %s\n", strTmp);

            //
            // Search the list for the info key and remove it if we find it
            //
            it = m_strlMetaChildNodes.begin();
            while (it != m_strlMetaChildNodes.end())
            {
                CString & strMetaPath = (*it);
                if (strTmp.CompareNoCase(strMetaPath.Left(strTmp.GetLength())) == 0)
                {
                    TRACEEOLID("Removing service/info metapath from list");
                    m_strlMetaChildNodes.erase(it);
                }
                it++;
            }
        }
    }

    //
    // Remove the first item if it's the current metapath
    //
    it = m_strlMetaChildNodes.begin();
    if (it != m_strlMetaChildNodes.end())
    {
        TRACE("Stripping %s\n", m_strMetaRoot);

        CString & strMetaPath = (*it);
        if (strMetaPath.CompareNoCase(m_strMetaRoot) == 0)
        {
            TRACEEOLID("Removing current metapath from list");
            m_strlMetaChildNodes.pop_front();
        }
    }

    m_fEmpty = m_strlMetaChildNodes.size() == 0;
}

#if 0
int
CInheritanceDlg::DoModal()
/*++

Routine Description:

    Display the dialog.

Arguments:

    None

Return Value:

    IDOK if the OK button was pressed, IDCANCEL otherwise.

--*/
{
    //
    // Specify the resources to use
    //
//    HINSTANCE hOldRes = AfxGetResourceHandle();
//    AfxSetResourceHandle(hDLLInstance);

    int answer = CDialog::DoModal();

    //
    // restore the resources
    //
//    AfxSetResourceHandle(hOldRes);

    return answer;
}
#endif


#if 0

void
CInheritanceDlg::DoDataExchange(
    IN CDataExchange * pDX
    )
/*++

Routine Description:

    Initialise/Store control data

Arguments:

    CDataExchange * pDX - DDX/DDV control structure

Return Value:

    None

--*/
{
    CDialog::DoDataExchange(pDX);

    //{{AFX_DATA_MAP(CInheritanceDlg)
    DDX_Control(pDX, IDC_LIST_CHILD_NODES, m_list_ChildNodes);
    //}}AFX_DATA_MAP
}


//
// Message Map
//
BEGIN_MESSAGE_MAP(CInheritanceDlg, CDialog)
    //{{AFX_MSG_MAP(CInheritanceDlg)
    ON_BN_CLICKED(IDC_BUTTON_SELECT_ALL, OnButtonSelectAll)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()
#endif


BOOL
CInheritanceDlg::FriendlyInstance(CString& strMetaRoot, CString& strFriendly)
/*++

Routine Description:

    Replace the instance number with its descriptive name.

Arguments:

    CString & strMetaRoot       : Metabase path
    CString & strFriendly       : Converted output friendly path.

Return Value:

    TRUE if the path contained an instance number.

--*/
{
    //
    // Break into fields
    //
    // CODEWORK: make static like BuildMetaPath
    //
   int n = CMetabasePath::GetInstanceNumber(strMetaRoot);
   if (n == 0)
   {
      // Master instance
      return FALSE;
   }
   CString service, instance;
   if (CMetabasePath::GetServicePath(strMetaRoot, service, NULL))
   {
      int len = strMetaRoot.GetLength();
      int pos = strMetaRoot.Find(SZ_MBN_SEP_CHAR);
      if (pos != -1)
      {
         HRESULT hr = m_mk.Open(METADATA_PERMISSION_READ, CMetabasePath(service, n));
         if (SUCCEEDED(hr))
         {
            CString comment;
            hr = m_mk.QueryValue(MD_SERVER_COMMENT, comment);
            m_mk.Close();

            if (FAILED(hr) || comment.IsEmpty())
            {
               strFriendly.Format(
                    SZ_MBN_MACHINE SZ_MBN_SEP_STR _T("%s") SZ_MBN_SEP_STR _T("%d"),
                    service,
                    n
                    );
            }
            else
            {
               strFriendly.Format(
                    SZ_MBN_MACHINE SZ_MBN_SEP_STR _T("%s") SZ_MBN_SEP_STR _T("%s"),
                    service,
                    comment
                    );
            }

            TRACEEOLID(strFriendly);

            //
            // Append the rest of the path
            //
            CString tail;
            CMetabasePath::SplitMetaPathAtInstance(strMetaRoot, instance, tail);
            strFriendly += tail;
   
            return TRUE;
         }
      }
   }
   return FALSE;
}



CString&
CInheritanceDlg::CleanDescendantPath(CString& strMetaPath)
/*++

Routine Description:

    Clean the descendant metabase path.  The path is shown
    as a descendant of the current metabase root, and instance
    numbers are replaced with their description names.

Arguments:

    CString & strMetaPath   : Metabase path to be treated

Return Value:

    Reference to the cleaned-up path.

--*/
{
    //
    // This better be a descendant!
    //
    ASSERT(strMetaPath.GetLength() >= m_strMetaRoot.GetLength());
    ASSERT(!::_tcsnicmp(strMetaPath, m_strMetaRoot, m_strMetaRoot.GetLength()));

    if (!m_fHasInstanceInMaster)
    {
        //
        // Need to replace the instance number with the friendly
        // name.
        //
        CString strTmp;
        VERIFY(FriendlyInstance(strMetaPath, strTmp));
        strMetaPath = strTmp;
    }

    strMetaPath = strMetaPath.Mid(m_strMetaRoot.GetLength() + 1);

    return strMetaPath;
}



//
// Message Handlers
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



LRESULT
CInheritanceDlg::OnInitDialog(HWND hwnd, LPARAM lParam)
/*++

Routine Description:

    WM_INITDIALOG handler.  Initialize the dialog.

Arguments:

    None.

Return Value:

    TRUE if focus is to be set automatically, FALSE if the focus
    is already set.

--*/
{
    //
    // Get friendly name for the property, and set the text.
    //
    CString strPrompt; 
    strPrompt.Format(_Module.GetResourceInstance(), 
       IDS_INHERITANCE_PROMPT, (LPCTSTR)m_strPropertyName);
    ::SetWindowText(GetDlgItem(IDC_STATIC_PROMPT), strPrompt);

    //
    // Turn inherited nodes into friendly paths, and add them
    // to the listbox.  Note the "current" node should have been
    // deleted at this stage.
    //
    CStringListEx::iterator pos = m_strlMetaChildNodes.begin();

    while (pos != m_strlMetaChildNodes.end())
    {
        CString strNode = (*pos++);
        m_list_ChildNodes.AddString(CleanDescendantPath(strNode));
    }
    return TRUE;
}



void
CInheritanceDlg::OnButtonSelectAll(WORD wNotifyCode, WORD wID, HWND hwndCtrl)
/*++

Routine Description:

    'Select All' button handler

Arguments:

    None

Return Value:

    None

--*/
{
   ASSERT(wNotifyCode == BN_CLICKED);
   ASSERT(wID == IDC_BUTTON_SELECT_ALL);
    //
    // Select all entries
    //
    if (m_list_ChildNodes.GetCount() == 1)
    {
        //
        // SelItemRange refuses to do a single member
        //
        m_list_ChildNodes.SetSel(0, TRUE);
    }
    else
    {
        m_list_ChildNodes.SelItemRange(TRUE, 0, m_list_ChildNodes.GetCount() - 1);
    }
}



void
CInheritanceDlg::OnOK(WORD wNotifyCode, WORD wID, HWND hwndCtrl)
/*++

Routine Description:

    'OK' button handler

Arguments:

    None

Return Value:

    None

--*/
{
   ASSERT(wNotifyCode == BN_CLICKED);
   ASSERT(wID == IDOK);
    //
    // Now delete the property for all selected child nodes.
    // Grab from the orginal list, and not the listbox
    // as the latter have been frienly-fied, and is no longer
    // usable.
    //
    int cItems = m_list_ChildNodes.GetCount();
    ASSERT(cItems > 0);

    CString strMetaPath;
    CError err(m_mk.QueryResult());

    if (err.Succeeded())
    {
        int i = 0;
        CStringListEx::iterator pos = m_strlMetaChildNodes.begin();
        while (pos != m_strlMetaChildNodes.end())
        {
            strMetaPath = (*pos++);

            if (m_list_ChildNodes.GetSel(i++) > 0)
            {
                TRACE("Deleting property on %s\n", strMetaPath);

                err = m_mk.Open(METADATA_PERMISSION_WRITE, strMetaPath);

                if (err.Failed())
                {
                    break;
                }

                err = m_mk.DeleteValue(m_dwMDIdentifier);

                m_mk.Close();

                if (err.Failed())
                {
                    break;
                }
            }
        }
    }

    if (!err.MessageBoxOnFailure())
    {
        //
        // Dialog can be dismissed
        //
        EndDialog(IDOK);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\common2\mdkeys.cpp ===
/*++

   Copyright    (c)    1994-2000    Microsoft Corporation

   Module  Name :

        mdkeys.cpp

   Abstract:

        Metabase key wrapper class

   Author:

        Ronald Meijer (ronaldm)
        Sergei Antonov (sergeia)

   Project:

        Internet Services Manager

   Revision History:
        2/17/2000    sergeia     removed dependency on MFC

--*/

//
// Include Files
//
#include "stdafx.h"
#include "common.h"
#include "inheritancedlg.h"
#include "mdkeys.h"


//
// Constants
//
#define MB_TIMEOUT          (15000)     // Timeout in milliseconds 
#define MB_INIT_BUFF_SIZE   (  256)     // Initial buffer size


//
// CComAuthInfo implementation
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

/* static */
BOOL
CComAuthInfo::SplitUserNameAndDomain(
    IN OUT CString & strUserName,
    IN CString & strDomainName
    )
/*++

Routine Description:

    Split the user name and domain from the given
    username, which is in the format "domain\user".

    Return TRUE if the user name contained a domain
    FALSE if it did not

Arguments:

    CString & strUserName   : User name which may contain a domain name
    CString & strDomainName : Output domain name ("." if local)

Return Value:

    TRUE if a domain is split off

--*/
{
    //
    // Assume local
    //
    strDomainName = _T(".");
    int nSlash = strUserName.Find(_T("\\"));

    if (nSlash >= 0)
    {
        strDomainName = strUserName.Left(nSlash);
        strUserName = strUserName.Mid(nSlash + 1);

        return TRUE;
    }

    return FALSE;
}


/* static */
DWORD
CComAuthInfo::VerifyUserPassword(
    IN LPCTSTR lpstrUserName,
    IN LPCTSTR lpstrPassword
    )
/*++

Routine Description:

    Verify the usernamer password combo checks out

Arguments:

    LPCTSTR lpstrUserName   : Domain/username combo
    LPCTSTR lpstrPassword   : Password

Return Value:

    ERROR_SUCCESS if the password checks out, an error code
    otherwise.

--*/
{
    CString strDomain;
    CString strUser(lpstrUserName);
    CString strPassword(lpstrPassword);

    SplitUserNameAndDomain(strUser, strDomain);

    //
    // In order to look up an account name, this process
    // must first be granted the privilege of doing so.
    //
    CError err;
    {
        HANDLE hToken;
        LUID AccountLookupValue;
        TOKEN_PRIVILEGES tkp;

        do
        {
            if (!::OpenProcessToken(GetCurrentProcess(),
                  TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
                  &hToken)
               )
            {
                err.GetLastWinError();
                break;
            }

            if (!::LookupPrivilegeValue(NULL, SE_TCB_NAME, &AccountLookupValue))
            {
                err.GetLastWinError();
                break;
            }

            tkp.PrivilegeCount = 1;
            tkp.Privileges[0].Luid = AccountLookupValue;
            tkp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

            ::AdjustTokenPrivileges(
                hToken,
                FALSE,
                &tkp,
                sizeof(TOKEN_PRIVILEGES),
                (PTOKEN_PRIVILEGES)NULL,
                (PDWORD)NULL
                );

            err.GetLastWinError();

            if (err.Failed())
            {
                break;
            }

            HANDLE hUser = NULL;

            if (::LogonUser(
                (LPTSTR)(LPCTSTR)strUser,
                (LPTSTR)(LPCTSTR)strDomain,
                (LPTSTR)(LPCTSTR)strPassword,
                LOGON32_LOGON_NETWORK,
                LOGON32_PROVIDER_DEFAULT,
                &hUser
                ))
            {
                //
                // Success!
                //
                CloseHandle(hUser);
            }
            else
            {
                err.GetLastWinError();
            }

            //
            // Remove the privilege
            //
        }
        while(FALSE);
    }

    HANDLE hUser = NULL;

    if (::LogonUser(
        (LPTSTR)(LPCTSTR)strUser,
        (LPTSTR)(LPCTSTR)strDomain,
        (LPTSTR)(LPCTSTR)strPassword,
        LOGON32_LOGON_NETWORK,
        LOGON32_PROVIDER_DEFAULT,
        &hUser))
    {
        //
        // Success!
        //
        CloseHandle(hUser);
    }
    else
    {
        err.GetLastWinError();
    }

    return err;
}



CComAuthInfo::CComAuthInfo(
    IN LPCOLESTR lpszServerName     OPTIONAL,
    IN LPCOLESTR lpszUserName       OPTIONAL,
    IN LPCOLESTR lpszPassword       OPTIONAL
    )
/*++

Routine Description:

    Construct CIIServer object

Argument:

    LPCOLESTR lpszServerName     : Server name or NULL for local computer
    LPCOLESTR lpszUserName       : User name of blank for no impersonation
    LPCOLESTR lpszPassword       : Password (might be blank or NULL)

Return Value:

    N/A

--*/
    : m_bstrServerName(),
      m_bstrUserName(lpszUserName),
      m_bstrPassword(lpszPassword),
      m_fLocal(FALSE)
{
    SetComputerName(lpszServerName);
}



CComAuthInfo::CComAuthInfo(
    IN CComAuthInfo & auth
    )
/*++

Routine Description:

    Copy constructor

Arguments:

    CComAuthInfo & auth    : Source object to copy from

Return Value:

    N/A

--*/
    : m_bstrServerName(auth.m_bstrServerName),
      m_bstrUserName(auth.m_bstrUserName),
      m_bstrPassword(auth.m_bstrPassword),
      m_fLocal(auth.m_fLocal)
{
}



CComAuthInfo::CComAuthInfo(
    IN CComAuthInfo * pAuthInfo        OPTIONAL
    )
/*++

Routine Description:

    Copy constructor

Arguments:

    CComAuthInfo * pAuthInfo    : Source object to copy from (or NULL)

Return Value:

    N/A

--*/
    : m_bstrServerName(),
      m_bstrUserName(),
      m_bstrPassword(),
      m_fLocal(FALSE)
{
    if (pAuthInfo)
    {
        //
        // Full authentication information available
        //
        m_bstrUserName = pAuthInfo->m_bstrUserName;
        m_bstrPassword = pAuthInfo->m_bstrPassword;
        m_bstrServerName = pAuthInfo->m_bstrServerName;
        m_fLocal = pAuthInfo->m_fLocal;
    }
    else
    {
        //
        // Local computer w/o impersonation
        //
        SetComputerName(NULL);
    }
}



CComAuthInfo & 
CComAuthInfo::operator =(
    IN CComAuthInfo & auth
    )
/*++

Routine Description:

    Assignment operator

Arguments:

    CComAuthInfo & auth     : Source object to copy from

Return Value:

    Reference to current object

--*/
{
    m_bstrServerName = auth.m_bstrServerName;
    m_bstrUserName   = auth.m_bstrUserName;
    m_bstrPassword   = auth.m_bstrPassword;
    m_fLocal         = auth.m_fLocal;

    return *this;
}



CComAuthInfo & 
CComAuthInfo::operator =(
    IN CComAuthInfo * pAuthInfo       OPTIONAL
    )
/*++

Routine Description:

    Assignment operator

Arguments:

    CComAuthInfo * pAuthInfo : Source object to copy from (or NULL)

Return Value:

    Reference to current object

--*/
{
    if (pAuthInfo)
    {
        m_bstrUserName = pAuthInfo->m_bstrUserName;
        m_bstrPassword = pAuthInfo->m_bstrPassword;
        SetComputerName(pAuthInfo->m_bstrServerName);
    }
    else
    {
        //
        // Local computer w/o impersonation
        //
        m_bstrUserName.Empty();
        m_bstrPassword.Empty();
        SetComputerName(NULL);
    }

    return *this;
}


CComAuthInfo & 
CComAuthInfo::operator =(
    IN LPCTSTR lpszServerName
    )
/*++

Routine Description:

    Assignment operator.  Assign computer name w/o impersonation

Arguments:

    LPCTSTR lpszServerName      : Source server name

Return Value:

    Reference to current object

--*/
{
    RemoveImpersonation();
    SetComputerName(lpszServerName);

    return *this;
}



void
CComAuthInfo::SetComputerName(
    IN LPCOLESTR lpszServerName   OPTIONAL
    )
/*++

Routine Description:

    Store the computer name.  Determine if its local.

Arguments:

    LPCOLESTR lpszServername  : Server name.  NULL indicates the local computer

Return Value:

    None

--*/
{
    if (lpszServerName && *lpszServerName)
    {
        //
        // Specific computer name specified
        //
        m_bstrServerName = lpszServerName;
        m_fLocal = ::IsServerLocal(lpszServerName);
    }
    else
    {
        //
        // Use local computer name
        //
        // CODEWORK: Cache static version of computername maybe?
        // 
        TCHAR szLocalServer[MAX_PATH + 1];
        DWORD dwSize = MAX_PATH;

        VERIFY(::GetComputerName(szLocalServer, &dwSize));
        m_bstrServerName = szLocalServer;
        m_fLocal = TRUE;
    }
}



void     
CComAuthInfo::SetImpersonation(
    IN LPCOLESTR lpszUser, 
    IN LPCOLESTR lpszPassword
    )
/*++

Routine Description:

    Set impersonation parameters

Arguments:

    LPCOLESTR lpszUser          : User name
    LPCOLESTR lpszPassword      : Password

Return Value:

    None

--*/
{
    m_bstrUserName = lpszUser;
    StorePassword(lpszPassword);
}



void     
CComAuthInfo::RemoveImpersonation()
/*++

Routine Description:

    Remove impersonation parameters

Arguments:

    None

Return Value:

    None

--*/
{
    m_bstrUserName.Empty();
    m_bstrPassword.Empty();
}

COSERVERINFO * 
CComAuthInfo::CreateServerInfoStruct() const
{
    return (CComAuthInfo::CreateServerInfoStruct(RPC_C_AUTHN_LEVEL_CONNECT));
}

COSERVERINFO * 
CComAuthInfo::CreateServerInfoStruct(DWORD dwAuthnLevel) const
/*++

Routine Description:

    Create the server info structure.  Might return NULL for the no frills case.

Arguments:

    NULL

Return Value:

    A COSERVERINFO structure, or NULL if the computer is local, and no
    impersonation is required.

Notes:

    Caller must call FreeServerInfoStruct() to prevent memory leaks

--*/
{
    //
    // Be smart about the server name; optimize for local
    // computer name.
    //
    if (m_fLocal && !UsesImpersonation())
    {
        //
        // Special, no-frills case. 
        //
        return NULL;
    }

    //
    // Create the COM server info for CoCreateInstanceEx
    //
    COSERVERINFO * pcsiName = NULL;

    do
    {
        pcsiName = new COSERVERINFO;

        if (!pcsiName)
        {
            break;
        }
        ZeroMemory(pcsiName, sizeof(COSERVERINFO));
        pcsiName->pwszName = m_bstrServerName;

        //
        // Set impersonation 
        //
        if (UsesImpersonation())
        {
            COAUTHINFO * pAuthInfo = new COAUTHINFO;

            if (!pAuthInfo)
            {
                break;
            }
            ZeroMemory(pAuthInfo, sizeof(COAUTHINFO));

            COAUTHIDENTITY * pAuthIdentityData = new COAUTHIDENTITY;

            if (!pAuthIdentityData)
            {
                break;
            }
            ZeroMemory(pAuthIdentityData, sizeof(COAUTHIDENTITY));

            CString strUserName(m_bstrUserName);
            CString strPassword(m_bstrPassword);
            CString strDomain;

            //
            // Break up domain\username combo
            //
            SplitUserNameAndDomain(strUserName, strDomain);

            pAuthIdentityData->UserLength = strUserName.GetLength();

            if (pAuthIdentityData->UserLength != 0)
            {
                pAuthIdentityData->User = StrDup(strUserName);
            }

            pAuthIdentityData->DomainLength = strDomain.GetLength();

            if (pAuthIdentityData->DomainLength != 0)
            {
                pAuthIdentityData->Domain = StrDup(strDomain);
            }

            pAuthIdentityData->PasswordLength = strPassword.GetLength();

            if (pAuthIdentityData->PasswordLength)
            {
                pAuthIdentityData->Password = StrDup(strPassword);
            }

            // RPC_C_AUTHN_LEVEL_DEFAULT       0 
            // RPC_C_AUTHN_LEVEL_NONE          1 
            // RPC_C_AUTHN_LEVEL_CONNECT       2 
            // RPC_C_AUTHN_LEVEL_CALL          3 
            // RPC_C_AUTHN_LEVEL_PKT           4 
            // RPC_C_AUTHN_LEVEL_PKT_INTEGRITY 5 
            // RPC_C_AUTHN_LEVEL_PKT_PRIVACY   6 
            // you can only specify stuff stronger than RPC_C_AUTHN_LEVEL_CONNECT
            if (dwAuthnLevel >= RPC_C_AUTHN_LEVEL_CONNECT && dwAuthnLevel <= RPC_C_AUTHN_LEVEL_PKT_PRIVACY)
            {
                pAuthInfo->dwAuthnLevel = dwAuthnLevel;
            }
            else
            {
                pAuthInfo->dwAuthnLevel = RPC_C_AUTHN_LEVEL_CONNECT;
            }
            pAuthIdentityData->Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE;
            pAuthInfo->dwImpersonationLevel = RPC_C_IMP_LEVEL_IMPERSONATE;
            pAuthInfo->dwAuthnSvc = RPC_C_AUTHN_WINNT;
            pAuthInfo->dwAuthzSvc = RPC_C_AUTHZ_NONE;
            pAuthInfo->pwszServerPrincName = NULL;
            pAuthInfo->dwCapabilities = EOAC_NONE;
            pAuthInfo->pAuthIdentityData = pAuthIdentityData;
            pcsiName->pAuthInfo = pAuthInfo;
        }
    }
    while(FALSE);

    return pcsiName;
}



void 
CComAuthInfo::FreeServerInfoStruct(
    IN COSERVERINFO * pServerInfo
    ) const
/*++

Routine Description:

    As mentioned above -- free the server info structure

Arguments:

    COSERVERINFO * pServerInfo  : Server info structure

Return Value:

    None

--*/
{
    if (pServerInfo)
    {
        if (pServerInfo->pAuthInfo)
        {
            if (pServerInfo->pAuthInfo->pAuthIdentityData)
            {
                if (pServerInfo->pAuthInfo->pAuthIdentityData)
                {
                    LocalFree(pServerInfo->pAuthInfo->pAuthIdentityData->User);
                    LocalFree(pServerInfo->pAuthInfo->pAuthIdentityData->Domain);
                    LocalFree(pServerInfo->pAuthInfo->pAuthIdentityData->Password);
                    delete pServerInfo->pAuthInfo->pAuthIdentityData;
                }
            }

            delete pServerInfo->pAuthInfo;
        }

        delete pServerInfo;
    }
}



HRESULT
CComAuthInfo::ApplyProxyBlanket(
    IN OUT IUnknown * pInterface
    )
/*++

Routine Description:

    Set security information on the interface.  The user name is of the form
    domain\username.

Arguments:

    IUnknown * pInterface       : Interface

Return Value:

    HRESULT

--*/
{
    HRESULT hr = S_OK;

    COSERVERINFO * pcsiName = CreateServerInfoStruct();

    //
    // This method should only be called if we're using impersonation.
    // so the pcsiName returned should never be NULL.
    //
    ATLASSERT(pcsiName && pcsiName->pAuthInfo);

    DWORD dwAuthSvc, dwAuthzSvc, dwAuthnLevel, dwImplLevel, dwCaps;
    OLECHAR * pServerPrincName;
    RPC_AUTH_IDENTITY_HANDLE pAuthInfo;

    hr = ::CoQueryProxyBlanket(
       pInterface,
       &dwAuthSvc,
       &dwAuthzSvc,
       &pServerPrincName,
       &dwAuthnLevel,
       &dwImplLevel,
       &pAuthInfo,
       &dwCaps);

    if (pcsiName && pcsiName->pAuthInfo)
    {
        hr =  ::CoSetProxyBlanket(
            pInterface,
            pcsiName->pAuthInfo->dwAuthnSvc,
            pcsiName->pAuthInfo->dwAuthzSvc,
            pcsiName->pAuthInfo->pwszServerPrincName,
            pcsiName->pAuthInfo->dwAuthnLevel,
            pcsiName->pAuthInfo->dwImpersonationLevel,
            pcsiName->pAuthInfo->pAuthIdentityData,
            pcsiName->pAuthInfo->dwCapabilities    
            );

        FreeServerInfoStruct(pcsiName);
    }

    return hr;
}


//
// CMetabasePath implemention
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



const LPCTSTR CMetabasePath::_cszMachine = SZ_MBN_MACHINE;
const LPCTSTR CMetabasePath::_cszRoot    = SZ_MBN_ROOT;
const LPCTSTR CMetabasePath::_cszSep     = SZ_MBN_SEP_STR;
const TCHAR   CMetabasePath::_chSep      = SZ_MBN_SEP_CHAR;
const CString CMetabasePath::_anySep     = SZ_MBN_ANYSEP_STR;

/*static*/
BOOL
CMetabasePath::IsSeparator(TCHAR c)
{
   return _anySep.find(c) != CString::npos;
}

/* static */
LPCTSTR
CMetabasePath::ConvertToParentPath(
    CString& strMetaPath
    )
/*++

Routine Description:

    Given the path, convert it to the parent path
    e.g. "foo/bar/etc" returns "foo/bar"

Arguments:

    CString & strMetaPath    : Path to be converted

Return value:

    Pointer to the converted path, or NULL in case of error

--*/
{
//   TRACE(_T("Getting parent path of %s\n"), strMetaPath);

   CString::size_type pos, pos_head;
   if ((pos = strMetaPath.find_last_of(SZ_MBN_ANYSEP_STR)) == strMetaPath.length() - 1)
   {
      strMetaPath.erase(pos);
   }
   pos = strMetaPath.find_last_of(SZ_MBN_ANYSEP_STR);
   if (pos == CString::npos)
      return strMetaPath;
   pos_head = strMetaPath.find_first_of(SZ_MBN_ANYSEP_STR);
   if (pos_head != pos)
   {
      strMetaPath.erase(pos);
   }

//   TRACE(_T("Parent path should be %s\n"), strMetaPath);

   return strMetaPath;
}

LPCTSTR
CMetabasePath::ConvertToParentPath(
    CMetabasePath& path
    )
{
   return CMetabasePath::ConvertToParentPath(path.m_strMetaPath);
}

/* static */
LPCTSTR
CMetabasePath::TruncatePath(
    int nLevel,          
    LPCTSTR lpszMDPath,
    CString & strNewPath,
    CString * pstrRemainder     OPTIONAL
    )
/*++

Routine Description:

    Truncate the given metabase path at the given level, that is, 
    the nLevel'th separator in the path, starting at 0, where 0 will
    always give lpszPath back whether it started with a separator or not.

    Examples: 

        "/lm/w3svc/1/foo" at level 2 returns "/lm/w3svc" as does
        "lm/w3svc/1/foo".
    
Arguments:

    int     nLevel             0-based separator count to truncate at.
    LPTSTR lpszMDPath          Fully-qualified metabase path
    CString & strNewPath       Returns truncated path
    CString * pstrRemainder    Optionally returns the remainder past
                               the nLevel'th separator.

Return Value:

    The truncated path at the level requested.  See examples above. *pstrRemainder
    returns the remainder of the path.  If the path does not contain nLevel
    worth of separators, the entire path is returned, and the remainder will be
    blank. 

--*/
{
//    ASSERT_PTR(lpszMDPath);
    ATLASSERT(nLevel >= 0);

    if (!lpszMDPath || nLevel < 0)
    {
//        TRACE(_T("TruncatePath: Invalid parameter\n"));
        return NULL;
    }

//    TRACE(_T("Source Path: %s\n"), lpszMDPath);

    //
    // Skip the first sep whether it exists or not
    //
    LPCTSTR lp = IsSeparator(*lpszMDPath) ? lpszMDPath + 1 : lpszMDPath;
    LPCTSTR lpRem = NULL;
    int cSeparators = 0;

    if (nLevel)
    {
        //
        // Advance to the requested separator level
        //
        while (*lp)
        {
            if (IsSeparator(*lp))
            {
                if (++cSeparators == nLevel)
                {
                    break;
                }
            }

            ++lp;
        }

        if (!*lp)
        {
            //
            // End of path is considered a separator
            //
            ++cSeparators;
        }

        ATLASSERT(cSeparators <= nLevel);

        if (cSeparators == nLevel)
        {
            //
            // Break up the strings
            //
            strNewPath = lpszMDPath;
            strNewPath.erase(lp - lpszMDPath);

//            TRACE(_T("Path truncated at level %d : %s\n"), nLevel, strNewPath);

            if (*lp)
            {
                lpRem = ++lp;
//                TRACE(_T("Remainder: %s\n"), lpRem);
            }
        }
    }

    //
    // Return remainder
    //
    if (pstrRemainder && lpRem)
    {
//        ASSERT_WRITE_PTR(pstrRemainder);
        *pstrRemainder = lpRem;
    }

    return strNewPath;
}



/* static */
DWORD 
CMetabasePath::GetInstanceNumber(
    IN LPCTSTR lpszMDPath
    )
/*++

Routine Description:

    Get the number of the instance referred to in the given metabase
    path.  
    
    Examples:  "lm/w3svc/1/foo/bar" will return 1
               "lm/w3svc/"          will return 0 (master instance)
               "lm/bogus/path/"     will return 0xffffffff (error)

Arguments:

    LPCTSTR lpszMDPath      : A metabase path.

Return Value:

    Instance number (0 indicates master instance)
    or 0xffffffff if the path is in error.

--*/
{
//    TRACE(_T("Determining instance number of %s\n"), lpszMDPath);
    DWORD dwInstance = 0xffffffff;

    CString strService, strInst;

    if (GetServicePath(lpszMDPath, strService, &strInst))
    {
        if (strInst.IsEmpty())
        {
            dwInstance = MASTER_INSTANCE;
        }
        else
        {
            if (_istdigit(strInst.GetAt(0)))  
            {
                dwInstance = _ttol(strInst);
            }
        }
    }

    return dwInstance;
}



/* static */
LPCTSTR
CMetabasePath::GetLastNodeName(
    IN  LPCTSTR lpszMDPath,
    OUT CString & strNodeName
    )
/*++

Routine Description:

    Get the last nodename off the metabase path

    Example:

        "/lm/foo/bar/"      returns "bar"

Arguments:

    LPCTSTR lpszMDPath      : Metabase path

Return Value:

    Pointer to the node name or NULL in case of a malformed path.

--*/
{
//    ASSERT_PTR(lpszMDPath);

    if (!lpszMDPath || !*lpszMDPath)
    {
        return NULL;
    }

//    TRACE(_T("Getting last node name from %s\n"), lpszMDPath);

    LPCTSTR lp;
    LPCTSTR lpTail;
    lp = lpTail = lpszMDPath + lstrlen(lpszMDPath) - 1;

    //
    // Skip trailing separator
    //
    if (IsSeparator(*lp))
    {
        --lpTail;
        --lp;
    }

    strNodeName.Empty();

    while (*lp && !IsSeparator(*lp))
    {
        strNodeName += *(lp--);
    }

    strNodeName.MakeReverse();

//    TRACE(_T("Node is %s\n"), strNodeName);
    
    return strNodeName;    
}



/* static */
void
CMetabasePath::SplitMetaPathAtInstance(
    LPCTSTR lpszMDPath,
    CString & strParent,
    CString & strAlias
    )
/*++

Routine Description:

    Split the given path into parent metabase root and alias, with the root
    being the instance path, and the alias everything following the
    instance.

Arguments:

    LPCTSTR lpszMDPath  : Input path
    CString & strParent : Outputs the parent path
    CString & strAlias  : Outputs the alias name

Return Value:

    None.

--*/
{
//    ASSERT_PTR(lpszMDPath);

//    TRACE(_T("Source Path %s\n"), lpszMDPath);

    strParent = lpszMDPath;
    strAlias.Empty();

    LPTSTR lp = (LPTSTR)lpszMDPath;

    if (lp == NULL)
    {
       return;
    }

    int cSeparators = 0;
    int iChar = 0;

    //
    // Looking for "LM/sss/ddd/" <-- 3d slash:
    //
    while (*lp && cSeparators < 2)
    {
        if (IsSeparator(*lp))
        {
            ++cSeparators;
        }

        ++iChar;
    }

    if (!*lp)
    {
        //
        // Bogus format
        //
        ASSERT_MSG("Bogus Format");
        return;
    }

    if (_istdigit(*lp))
    {
        //
        // Not at the master instance, skip one more.
        //
        while (*lp)
        {
            ++iChar;

            if (IsSeparator(*lp++))
            {
                break;
            }
        }

        if (!*lp)
        {
            //
            // Bogus format
            //
            ASSERT_MSG("Bogus Format");
            return;
        }
    }

    strAlias = strParent.Mid(iChar);
    strParent.erase(iChar);

//    TRACE(_T("Broken up into %s\n"), strParent);
//    TRACE(_T("           and %s\n"), strAlias);
}



/* static */
BOOL 
CMetabasePath::IsHomeDirectoryPath(
    IN LPCTSTR lpszMetaPath
    )
/*++

Routine Description:

    Determine if the path given describes a root directory

Arguments:

    LPCTSTR lpszMetaPath        : Metabase path

Return Value:

    TRUE if the path describes a root directory, 
    FALSE if it does not

--*/
{
//    ASSERT_READ_PTR(lpszMetaPath);

    LPTSTR lpNode = lpszMetaPath ? StrPBrk(lpszMetaPath, _anySep) : NULL;

    if (lpNode)
    {
        return _tcsicmp(++lpNode, _cszRoot) == 0;
    }

    return FALSE;
}



/* static */
BOOL 
CMetabasePath::IsMasterInstance(
    IN LPCTSTR lpszMDPath
    )
/*++

Routine Description:

    Determine if the given metabase path points to the master instance
    (site).  This is essentially the service path.

Arguments:

    LPCTSTR lpszMDPath  : Metabase path.

Return Value:

    TRUE if the path is the master instance,
    FALSE otherwise.

--*/
{
//    ASSERT_READ_PTR(lpszMDPath);

    if (!lpszMDPath || !*lpszMDPath)
    {
        return FALSE;
    }

//    TRACE(_T("Checking path %s\n"), lpszMDPath);

    CString strService;
    CString strRemainder;

    LPCTSTR lpPath = TruncatePath(2, lpszMDPath, strService, &strRemainder);

    return lpPath && !strService.IsEmpty() && strRemainder.IsEmpty();
}



/* static */
LPCTSTR
CMetabasePath::GetServiceInfoPath(
    IN  LPCTSTR lpszMDPath,
    OUT CString & strInfoPath,   
    IN  LPCTSTR lpszDefService      OPTIONAL
    )
/*++

Routine Description:

    Generate the appropriate metabase service info path for the given
    metabase path.  

    For example:

        "lm/w3svc/1/foo/bar"    Generates "lm/w3svc/info"

Arguments:

    LPCTSTR lpszMDPath      : Input metabase path
    CString & strInfoPath   : Returns the info path
    LPCTSTR lpszDefService  : Optionally specifies the default service to
                              use (e.g "w3svc") if no service could be found
                              in the path.
    
Return Value:

    The info metabase path or NULL if one could not be generated.

--*/
{
    //
    // Capability info stored off the service path ("lm/w3svc").
    //
    CString strService;
    CString strRem;
   
    //
    // Strip off everything past the service
    //
    if (!TruncatePath(2, lpszMDPath, strService, &strRem)
      || strService.IsEmpty())
    {
        if (!lpszDefService)
        {
//            TRACEEOLID("Unable to generate info path");
            return NULL;
        }

        TRACEEOLID("Using default service for info path");

        //
        // Machine path (no service).  Use web as default service to
        // look for capability and version info.
        //
        strService = CMetabasePath(TRUE, lpszDefService);
    }

    strInfoPath = CMetabasePath(FALSE, strService, SZ_MBN_INFO);
//    TRACE("Using %s to look for capability info\n", strInfoPath);

    return strInfoPath;
}
 


/* static */
LPCTSTR
CMetabasePath::CleanMetaPath(
    IN OUT CString & strMetaRoot
    )
/*++

Routine Description:

    Clean up the metabase path to one valid for internal consumption.
    This removes the beginning and trailing slashes off the path.

Arguments:

    CString & strMetaRoot       : Metabase path to be cleaned up.

Return Value:

    Pointer to the metabase path

--*/
{
   if (!strMetaRoot.IsEmpty())
   {
      int hd = strMetaRoot.find_first_not_of(SZ_MBN_ANYSEP_STR);
      int tl = strMetaRoot.find_last_not_of(SZ_MBN_ANYSEP_STR);
      if (hd == CString::npos && tl == CString::npos)
      {
         // path contains only separators
         strMetaRoot.erase();
         return strMetaRoot;
      }
      else if (hd != CString::npos)
      {
         if (tl != CString::npos)
            tl++;
         strMetaRoot = strMetaRoot.substr(hd, tl - hd);
      }
#if 0
        while (strMetaRoot.GetLength() > 0 
            && IsSeparator(strMetaRoot[strMetaRoot.GetLength() - 1]))
        {
            strMetaRoot.erase(strMetaRoot.GetLength() - 1);
        }

        while (strMetaRoot.GetLength() > 0 
           && IsSeparator(strMetaRoot[0]))
        {
            strMetaRoot = strMetaRoot.Right(strMetaRoot.GetLength() - 1);
        }
#endif
        // looks like IISAdmin works only with separators "/"
       for (int i = 0; i < strMetaRoot.GetLength(); i++)
       {
          if (IsSeparator(strMetaRoot[i]))
             strMetaRoot.SetAt(i, _chSep);
       }
   }
   return strMetaRoot;
}


/* static */
LPCTSTR
CMetabasePath::CleanMetaPath(
    IN OUT CMetabasePath & path
    )
{
   return CleanMetaPath(path.m_strMetaPath);
}

CMetabasePath::CMetabasePath(
    IN BOOL    fAddBasePath,
    IN LPCTSTR lpszMDPath,
    IN LPCTSTR lpszMDPath2  OPTIONAL,
    IN LPCTSTR lpszMDPath3  OPTIONAL,
    IN LPCTSTR lpszMDPath4  OPTIONAL
    )
/*++

Routine Description:

    Constructor.

Arguments:

    BOOL    fAddBasePath    : TRUE to prepend base path ("LM")
                              FALSE if the path is complete
    LPCTSTR lpszMDPath      : Metabase path
    LPCTSTR lpszMDPath2     : Optional child path
    LPCTSTR lpszMDPath3     : Optional child path
    LPCTSTR lpszMDPath4     : Optional child path

Return Value:

    N/A

--*/
    : m_strMetaPath()
{
//    This will fail for NULL pointer
//    ASSERT_READ_PTR(lpszMDPath);

    if (fAddBasePath)
    {
        m_strMetaPath = _cszMachine;
        AppendPath(lpszMDPath);
    }
    else
    {
        m_strMetaPath = lpszMDPath;
    }

    //
    // Add optional path components
    //    
    AppendPath(lpszMDPath2);
    AppendPath(lpszMDPath3);
    AppendPath(lpszMDPath4);
}



CMetabasePath::CMetabasePath(
    IN  LPCTSTR lpszSvc,        OPTIONAL
    IN  DWORD   dwInstance,     OPTIONAL
    IN  LPCTSTR lpszParentPath, OPTIONAL
    IN  LPCTSTR lpszAlias       OPTIONAL
    )
/*++

Routine Description:

    Constructor.  Construct with path components.

Arguments:

    LPCTSTR lpszSvc         : Service (may be NULL or "")
    DWORD   dwInstance      : Instance number (may be 0 for master)
    LPCTSTR lpszParentPath  : Parent path (may be NULL or "")
    LPCTSTR lpszAlias       : Alias (may be NULL or "")

Return Value:

    N/A

--*/
    : m_strMetaPath()
{
    BuildMetaPath(lpszSvc, dwInstance, lpszParentPath, lpszAlias);
}



void 
CMetabasePath::AppendPath(
    IN LPCTSTR lpszPath
    )
/*++

Routine Description:

    Append path to current metabase path

Arguments:

    LPCTSTR lpszPath        : Metabase path

Return Value:

    None

--*/
{
    if (lpszPath && *lpszPath)
    {
        m_strMetaPath += _cszSep;
        m_strMetaPath += lpszPath;
    }
}



void 
CMetabasePath::AppendPath(
    IN DWORD dwInstance
    )
/*++

Routine Description:

    Append path to current metabase path

Arguments:

    DWORD dwInstance        : Instance path

Return Value:

    None

--*/
{
//    ASSERT(dwInstance >= 0);

    if (!IS_MASTER_INSTANCE(dwInstance))
    {
        TCHAR szInstance[] = _T("4000000000");
        _ltot(dwInstance, szInstance, 10);

        m_strMetaPath += _cszSep;
        m_strMetaPath += szInstance;
    }
}



void
CMetabasePath::BuildMetaPath(
    IN  LPCTSTR lpszSvc            OPTIONAL,
    IN  LPCTSTR lpszInstance       OPTIONAL,
    IN  LPCTSTR lpszParentPath     OPTIONAL,
    IN  LPCTSTR lpszAlias          OPTIONAL
    )
/*++

Routine Description:

    Build a complete metapath with the given service name, instance
    number and optional path components.

Arguments:

    LPCTSTR lpszSvc         : Service (may be NULL or "")
    LPCTSTR lpszInstance    : Instance (may be NULL or "")
    LPCTSTR lpszParentPath  : Parent path (may be NULL or "")
    LPCTSTR lpszAlias       : Alias (may be NULL or "")

Return Value:

    Pointer to internal buffer containing the path.

--*/
{
    m_strMetaPath = _cszMachine;

    AppendPath(lpszSvc);
    AppendPath(lpszInstance);
    AppendPath(lpszParentPath);

    if (lpszAlias && *lpszAlias)
    {
        //
        // Special case: If the alias is root, but we're
        // at the master instance, ignore this.
        //
        if (lpszInstance || ::lstrcmpi(_cszRoot, lpszAlias))
        {
            m_strMetaPath += _cszSep;
            m_strMetaPath += lpszAlias;
        }
    }

//    TRACE(_T("Generated metapath: %s\n"), m_strMetaPath );
}




void
CMetabasePath::BuildMetaPath(
    IN  LPCTSTR lpszSvc            OPTIONAL,
    IN  DWORD   dwInstance         OPTIONAL,
    IN  LPCTSTR lpszParentPath     OPTIONAL,
    IN  LPCTSTR lpszAlias          OPTIONAL
    )
/*++

Routine Description:

    Build a complete metapath with the given service name, instance
    number and optional path components.

Arguments:

    LPCTSTR lpszSvc         : Service (may be NULL or "")
    DWORD   dwInstance      : Instance number (may be 0 for master)
    LPCTSTR lpszParentPath  : Parent path (may be NULL or "")
    LPCTSTR lpszAlias       : Alias (may be NULL or "")

Return Value:

    Pointer to internal buffer containing the path.

--*/
{
    m_strMetaPath = _cszMachine;

    AppendPath(lpszSvc);
    AppendPath(dwInstance);
    AppendPath(lpszParentPath);

    if (lpszAlias && *lpszAlias)
    {
        //
        // Special case: If the alias is root, but we're
        // at the master instance, ignore this.
        //
        if (!IS_MASTER_INSTANCE(dwInstance) || ::lstrcmpi(_cszRoot, lpszAlias))
        {
            m_strMetaPath += _cszSep;
            m_strMetaPath += lpszAlias;
        }
    }

//    TRACE(_T("Generated metapath: %s\n"), m_strMetaPath);
}


//
// CIISInterface class
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



CIISInterface::CIISInterface(
    IN CComAuthInfo * pAuthInfo,    OPTIONAL
    IN HRESULT hrInterface          OPTIONAL
    )
/*++

Routine Description:

    Base class constructor.  

Arguments:

    CComAuthInfo * pAuthInfo : Auth info or NULL for local computer
    HRESULT hrInterface      : Initial error code. S_OK by default.

Return Value:

    N/A

--*/
    : m_auth(pAuthInfo),
      m_hrInterface(hrInterface)
{
}



HRESULT 
CIISInterface::Create(
    IN  int   cInterfaces,       
    IN  const IID rgIID[],      
    IN  const GUID rgCLSID[],    
    OUT int * pnInterface,          OPTIONAL
    OUT IUnknown ** ppInterface 
    )
/*++

Routine Description:

    Create interface.  This will try a range of interfaces in order of priority.

Arguments:

    int   cInterfaces       : Number of interfaces in array.
    const IID * rgIID       : Array if IIDs
    const GUID * rgCLSID    : Array of CLSIDs
    int * pnInterface       : Returns the interface index that was successful.
                              or NULL if not interested.
    IUnknown ** ppInterface : Returns pointer to the interface.

Return Value:

    HRESULT

Notes:

    This will attempt to create an interface, in order of declaration in 
    the IID and CLSIS arrays.  The first successful interface to be created
    will have its index returned in *pnInterfaces.

--*/
{
    ASSERT(cInterfaces > 0);
    ASSERT(rgIID && rgCLSID && ppInterface);
    
    COSERVERINFO * pcsiName = m_auth.CreateServerInfoStruct();

    MULTI_QI rgmqResults;
    
    CError err;
    int    nInterface;

    //
    // Try to create the interface in order
    //
    for (nInterface = 0; nInterface < cInterfaces; ++nInterface)
    {
        ZeroMemory(&rgmqResults, sizeof(rgmqResults));
        rgmqResults.pIID = &rgIID[nInterface];

//        TRACE("Attempting to create interface #%d\n", nInterface);
        err = ::CoCreateInstanceEx(
            rgCLSID[nInterface],
            NULL,
            CLSCTX_SERVER,
            pcsiName,
            1,
            &rgmqResults
            );

        if (err.Succeeded() || err.Win32Error() == ERROR_ACCESS_DENIED)
        {
            break;
        }
    }

    if(err.Succeeded())
    {
        //
        // Save the interface pointer
        //
        ASSERT_PTR(rgmqResults.pItf);
        *ppInterface = rgmqResults.pItf;

        if (pnInterface)
        {
            //
            // Store successful interface index
            //
            *pnInterface = nInterface;
        }

        //
        // Strangely enough, I now have still have to apply
        // the proxy blanket.  Apparently this is by design.
        //
        if (m_auth.UsesImpersonation())
        {
            ApplyProxyBlanket();
        }
    }

    //
    // Clean up
    //
    m_auth.FreeServerInfoStruct(pcsiName);

    return err;
}


//
// CMetaInterface class
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

CMetaInterface::CMetaInterface(
    IN CComAuthInfo * pAuthInfo        OPTIONAL
    )
/*++

Routine Description:

    Construct and initialize the interface

Arguments:

    CComAuthInfo * pAuthInfo    : Authentication info.  NULL indicates 
                                  the local computer.

Return Value:

    N/A

--*/
    : CIISInterface(pAuthInfo),
      m_pInterface(NULL),
      m_iTimeOutValue(MB_TIMEOUT)
{
    //
    // Initialize the interface
    //
    m_hrInterface = Create();
}



CMetaInterface::CMetaInterface(
    IN CMetaInterface * pInterface
    )
/*++

Routine Description:

    Construct from existing interface (Copy Constructor)

Arguments:

    CMetaInterface * pInterface : Existing interface

Return Value:

    N/A

Notes:
        
    Object will not take ownership of the interface,
    it will merely add to the reference count, and 
    release it upon destruction

BUGBUG:

    if pInterface is NULL, this will AV.

--*/
    : CIISInterface(&pInterface->m_auth, pInterface->m_hrInterface),
      m_pInterface(pInterface->m_pInterface),
      m_iTimeOutValue(pInterface->m_iTimeOutValue)
{
    ASSERT_READ_PTR(m_pInterface);
    m_pInterface->AddRef();
}



CMetaInterface::~CMetaInterface()
/*++

Routine Description:

    Destructor -- releases the interface

Arguments:

    N/A

Return Value:

    N/A

--*/
{
    SAFE_RELEASE(m_pInterface);
}


HRESULT 
CMetaInterface::Create()
{
    return CIISInterface::Create(
        1,
        &IID_IMSAdminBase, 
        &CLSID_MSAdminBase, 
        NULL,
        (IUnknown **)&m_pInterface
        );
}

//
// CMetaKey class
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

//
// Helper macros
//
#define ASSURE_PROPER_INTERFACE()\
    if (!HasInterface()) { ASSERT_MSG("No interface"); return MD_ERROR_NOT_INITIALIZED; }

#define ASSURE_OPEN_KEY()\
    if (!m_hKey && !m_fAllowRootOperations) { ASSERT_MSG("No open key"); return HRESULT_FROM_WIN32(ERROR_INVALID_HANDLE); }

#define FETCH_PROPERTY_DATA_OR_FAIL(dwID, md)\
    ZeroMemory(&md, sizeof(md)); \
    if (!GetMDFieldDef(dwID, md.dwMDIdentifier, md.dwMDAttributes, md.dwMDUserType, md.dwMDDataType))\
    { ASSERT_MSG("Bad property ID"); return HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER); }

//
// Static Initialization
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



#define MD_SERVER_PLATFORM              (IIS_MD_SERVER_BASE+100 )
#define MD_SERVER_VERSION_MAJOR         (IIS_MD_SERVER_BASE+101 )
#define MD_SERVER_VERSION_MINOR         (IIS_MD_SERVER_BASE+102 )
#define MD_SERVER_CAPABILITIES          (IIS_MD_SERVER_BASE+103 )

#ifndef MD_APP_PERIODIC_RESTART_TIME
#define MD_APP_PERIODIC_RESTART_TIME         2111
#endif
#ifndef MD_APP_PERIODIC_RESTART_REQUESTS
#define MD_APP_PERIODIC_RESTART_REQUESTS     2112
#endif
#ifndef MD_APP_PERIODIC_RESTART_SCHEDULE
#define MD_APP_PERIODIC_RESTART_SCHEDULE     2113
#endif
#ifndef MD_ASP_DISKTEMPLATECACHEDIRECTORY
#define MD_ASP_DISKTEMPLATECACHEDIRECTORY    7036
#endif
#ifndef MD_ASP_MAXDISKTEMPLATECACHEFILES
#define MD_ASP_MAXDISKTEMPLATECACHEFILES     7040
#endif
//
// Metabase table
//
const CMetaKey::MDFIELDDEF CMetaKey::s_rgMetaTable[] =
{
    ///////////////////////////////////////////////////////////////////////////
    //
    // !!!IMPORTANT!!! This table must be sorted on dwMDIdentifier.  (Will
    // ASSERT if not not sorted)
    //
    { MD_MAX_BANDWIDTH,                   METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, DWORD_METADATA,   0                                  },
    { MD_KEY_TYPE,                        METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, STRING_METADATA,  0                                  },
    { MD_SERVER_COMMAND,                  METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, DWORD_METADATA,   0                                  },
    { MD_CONNECTION_TIMEOUT,              METADATA_INHERIT,                          IIS_MD_UT_SERVER, DWORD_METADATA,   IDS_MD_CONNECTION_TIMEOUT          },
    { MD_MAX_CONNECTIONS,                 METADATA_INHERIT,                          IIS_MD_UT_SERVER, DWORD_METADATA,   IDS_MD_MAX_CONNECTIONS             },
    { MD_SERVER_COMMENT,                  METADATA_INHERIT,                          IIS_MD_UT_SERVER, STRING_METADATA,  IDS_MD_SERVER_COMMENT              },
    { MD_SERVER_STATE,                    METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, DWORD_METADATA,   0                                  },
    { MD_SERVER_AUTOSTART,                METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, DWORD_METADATA,   0                                  },
    { MD_SERVER_SIZE,                     METADATA_INHERIT,                          IIS_MD_UT_SERVER, DWORD_METADATA,   IDS_MD_SERVER_SIZE                 },
    { MD_SERVER_LISTEN_BACKLOG,           METADATA_INHERIT,                          IIS_MD_UT_SERVER, DWORD_METADATA,   IDS_MD_SERVER_LISTEN_BACKLOG       },
    { MD_SERVER_LISTEN_TIMEOUT,           METADATA_INHERIT,                          IIS_MD_UT_SERVER, DWORD_METADATA,   IDS_MD_SERVER_LISTEN_TIMEOUT       },
    { MD_SERVER_BINDINGS,                 METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, MULTISZ_METADATA, 0                                  },
    { MD_WIN32_ERROR,                     METADATA_VOLATILE,                         IIS_MD_UT_FILE,   DWORD_METADATA,   0                                  },
    { MD_SERVER_PLATFORM,                 METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, DWORD_METADATA,   0                                  },
    { MD_SERVER_VERSION_MAJOR,            METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, DWORD_METADATA,   0                                  },
    { MD_SERVER_VERSION_MINOR,            METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, DWORD_METADATA,   0                                  },
    { MD_SERVER_CAPABILITIES,             METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, DWORD_METADATA,   0                                  },
    { MD_SECURE_BINDINGS,                 METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, MULTISZ_METADATA, 0                                  },
    { MD_FILTER_LOAD_ORDER,               METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, STRING_METADATA,  0                                  },
    { MD_FILTER_IMAGE_PATH,               METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, STRING_METADATA,  0                                  },
    { MD_FILTER_STATE,                    METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, DWORD_METADATA,   0                                  },
    { MD_FILTER_ENABLED,                  METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, DWORD_METADATA,   0                                  },
    { MD_FILTER_FLAGS,                    METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, DWORD_METADATA,   0                                  },
    { MD_AUTH_CHANGE_URL,                 METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, DWORD_METADATA,   0                                  },
    { MD_AUTH_EXPIRED_URL,                METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, STRING_METADATA,  0                                  },
    { MD_AUTH_NOTIFY_PWD_EXP_URL,         METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, STRING_METADATA,  0                                  },
    { MD_ADV_NOTIFY_PWD_EXP_IN_DAYS,      METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, DWORD_METADATA,   0                                  },
    { MD_ADV_CACHE_TTL,                   METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, DWORD_METADATA,   0                                  },
    { MD_NET_LOGON_WKS,                   METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, DWORD_METADATA,   0                                  },
    { MD_USE_HOST_NAME,                   METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, DWORD_METADATA,   0                                  },
    { MD_AUTH_EXPIRED_UNSECUREURL,        METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, STRING_METADATA,  0                                  },
    { MD_AUTH_CHANGE_FLAGS,               METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, DWORD_METADATA,   0                                  },
    { MD_AUTH_NOTIFY_PWD_EXP_UNSECUREURL, METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, STRING_METADATA,  0                                  },
    { MD_FRONTPAGE_WEB,                   METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, DWORD_METADATA,   0                                  },
    { MD_MAPCERT,                         METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, STRING_METADATA,  0                                  },
    { MD_MAPNTACCT,                       METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, STRING_METADATA,  0                                  },
    { MD_MAPNAME,                         METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, STRING_METADATA,  0                                  },
    { MD_MAPENABLED,                      METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, STRING_METADATA,  0                                  },
    { MD_MAPREALM,                        METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, STRING_METADATA,  0                                  },
    { MD_MAPPWD,                          METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, STRING_METADATA,  0                                  },
    { MD_ITACCT,                          METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, STRING_METADATA,  0                                  },
    { MD_CPP_CERT11,                      METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, BINARY_METADATA,  0                                  },
    { MD_SERIAL_CERT11,                   METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, BINARY_METADATA,  0                                  },
    { MD_CPP_CERTW,                       METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, BINARY_METADATA,  0                                  },
    { MD_SERIAL_CERTW,                    METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, BINARY_METADATA,  0                                  },
    { MD_CPP_DIGEST,                      METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, BINARY_METADATA,  0                                  },
    { MD_SERIAL_DIGEST,                   METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, BINARY_METADATA,  0                                  },
    { MD_CPP_ITA,                         METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, BINARY_METADATA,  0                                  },
    { MD_SERIAL_ITA,                      METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, BINARY_METADATA,  0                                  },
    { MD_APP_FRIENDLY_NAME,               METADATA_INHERIT,                          IIS_MD_UT_WAM,    STRING_METADATA,  IDS_MD_APP_FRIENDLY_NAME           },
    { MD_APP_ROOT,                        METADATA_INHERIT,                          IIS_MD_UT_WAM,    STRING_METADATA,  IDS_MD_APP_ROOT                    },
    { MD_APP_ISOLATED,                    METADATA_INHERIT,                          IIS_MD_UT_WAM,    DWORD_METADATA,   IDS_MD_APP_ISOLATED                },
// new stuff
    { MD_APP_PERIODIC_RESTART_TIME,       METADATA_INHERIT,                          IIS_MD_UT_WAM,    DWORD_METADATA,   0                                  },
    { MD_APP_PERIODIC_RESTART_REQUESTS,   METADATA_INHERIT,                          IIS_MD_UT_WAM,    DWORD_METADATA,   0                                  },
    { MD_APP_PERIODIC_RESTART_SCHEDULE,   METADATA_INHERIT,                          IIS_MD_UT_WAM,    MULTISZ_METADATA, 0                                  },
// end new stuff
    { MD_CPU_LIMITS_ENABLED,              METADATA_INHERIT,                          IIS_MD_UT_SERVER, DWORD_METADATA,   IDS_MD_CPU_LIMITS_ENABLED          },
    { MD_CPU_LIMIT_LOGEVENT,              METADATA_INHERIT,                          IIS_MD_UT_SERVER, DWORD_METADATA,   IDS_MD_CPU_LIMIT_LOGEVENT          },
    { MD_CPU_LIMIT_PRIORITY,              METADATA_INHERIT,                          IIS_MD_UT_SERVER, DWORD_METADATA,   IDS_MD_CPU_LIMIT_PRIORITY          },
    { MD_CPU_LIMIT_PROCSTOP,              METADATA_INHERIT,                          IIS_MD_UT_SERVER, DWORD_METADATA,   IDS_MD_CPU_LIMIT_PROCSTOP          },
    { MD_CPU_LIMIT_PAUSE,                 METADATA_INHERIT,                          IIS_MD_UT_SERVER, DWORD_METADATA,   IDS_MD_CPU_LIMIT_PAUSE             },
    { MD_HC_COMPRESSION_DIRECTORY,        METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, STRING_METADATA,  0                                  },
    { MD_HC_DO_DYNAMIC_COMPRESSION,       METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, DWORD_METADATA,   0                                  },
    { MD_HC_DO_STATIC_COMPRESSION,        METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, DWORD_METADATA,   0                                  },
    { MD_HC_DO_DISK_SPACE_LIMITING,       METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, DWORD_METADATA,   0                                  },
    { MD_HC_MAX_DISK_SPACE_USAGE,         METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, DWORD_METADATA,   0                                  },
    { MD_VR_PATH,                         METADATA_INHERIT,                          IIS_MD_UT_FILE,   STRING_METADATA,  IDS_MD_VR_PATH                     },
    { MD_VR_USERNAME,                     METADATA_INHERIT,                          IIS_MD_UT_FILE,   STRING_METADATA,  IDS_MD_VR_USERNAME                 },
    { MD_VR_PASSWORD,                     METADATA_INHERIT | METADATA_SECURE,        IIS_MD_UT_FILE,   STRING_METADATA,  IDS_MD_VR_PASSWORD                 },
    { MD_VR_ACL,                          METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_FILE,   BINARY_METADATA,  0                                  },
    { MD_VR_UPDATE,                       METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_FILE,   DWORD_METADATA,   0                                  },
    { MD_LOG_TYPE,                        METADATA_INHERIT,                          IIS_MD_UT_FILE,   DWORD_METADATA,   IDS_MD_LOG_TYPE                    },
    { MD_LOGFILE_DIRECTORY,               METADATA_INHERIT,                          IIS_MD_UT_FILE,   STRING_METADATA,  IDS_MD_LOGFILE_DIRECTORY           },
    { MD_LOGFILE_PERIOD,                  METADATA_INHERIT,                          IIS_MD_UT_FILE,   DWORD_METADATA,   IDS_MD_LOGFILE_PERIOD              },
    { MD_LOGFILE_TRUNCATE_SIZE,           METADATA_INHERIT,                          IIS_MD_UT_FILE,   DWORD_METADATA,   IDS_MD_LOGFILE_TRUNCATE_SIZE       },
    { MD_LOGSQL_DATA_SOURCES,             METADATA_INHERIT,                          IIS_MD_UT_FILE,   STRING_METADATA,  IDS_MD_LOGSQL_DATA_SOURCES         },
    { MD_LOGSQL_TABLE_NAME,               METADATA_INHERIT,                          IIS_MD_UT_FILE,   STRING_METADATA,  IDS_MD_LOGSQL_TABLE_NAME           },
    { MD_LOGSQL_USER_NAME,                METADATA_INHERIT,                          IIS_MD_UT_FILE,   STRING_METADATA,  IDS_MD_LOGSQL_USER_NAME            },
    { MD_LOGSQL_PASSWORD,                 METADATA_INHERIT | METADATA_SECURE,        IIS_MD_UT_FILE,   STRING_METADATA,  IDS_MD_LOGSQL_PASSWORD             },
    { MD_LOG_PLUGIN_ORDER,                METADATA_INHERIT,                          IIS_MD_UT_SERVER, STRING_METADATA,  IDS_MD_LOG_PLUGIN_ORDER            },
    { MD_LOGEXT_FIELD_MASK,               METADATA_INHERIT,                          IIS_MD_UT_SERVER, DWORD_METADATA,   IDS_MD_LOGEXT_FIELD_MASK           },
    { MD_LOGFILE_LOCALTIME_ROLLOVER,      METADATA_INHERIT,                          IIS_MD_UT_SERVER, DWORD_METADATA,   IDS_MD_LOGFILE_LOCALTIME_ROLLOVER  },
    { MD_CPU_LOGGING_MASK,                METADATA_INHERIT,                          IIS_MD_UT_SERVER, DWORD_METADATA,   IDS_MD_CPU_LOGGING_MASK            },
    { MD_EXIT_MESSAGE,                    METADATA_INHERIT,                          IIS_MD_UT_SERVER, STRING_METADATA,  IDS_MD_EXIT_MESSAGE                },
    { MD_GREETING_MESSAGE,                METADATA_INHERIT,                          IIS_MD_UT_SERVER, MULTISZ_METADATA, IDS_MD_GREETING_MESSAGE            },
    { MD_MAX_CLIENTS_MESSAGE,             METADATA_INHERIT,                          IIS_MD_UT_SERVER, STRING_METADATA,  IDS_MD_MAX_CLIENTS_MESSAGE         },
    { MD_MSDOS_DIR_OUTPUT,                METADATA_INHERIT,                          IIS_MD_UT_SERVER, DWORD_METADATA,   IDS_MD_MSDOS_DIR_OUTPUT            },
    { MD_ALLOW_ANONYMOUS,                 METADATA_INHERIT,                          IIS_MD_UT_SERVER, DWORD_METADATA,   IDS_MD_ALLOW_ANONYMOUS             },
    { MD_ANONYMOUS_ONLY,                  METADATA_INHERIT,                          IIS_MD_UT_SERVER, DWORD_METADATA,   IDS_MD_ANONYMOUS_ONLY              },
    { MD_LOG_ANONYMOUS,                   METADATA_INHERIT,                          IIS_MD_UT_SERVER, DWORD_METADATA,   IDS_MD_LOG_ANONYMOUS               },
    { MD_LOG_NONANONYMOUS,                METADATA_INHERIT,                          IIS_MD_UT_SERVER, DWORD_METADATA,   IDS_MD_LOG_NONANONYMOUS            },
    { MD_SSL_PUBLIC_KEY,                  METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, BINARY_METADATA,  0                                  },
    { MD_SSL_PRIVATE_KEY,                 METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, BINARY_METADATA,  0                                  },
    { MD_SSL_KEY_PASSWORD,                METADATA_SECURE,                           IIS_MD_UT_SERVER, BINARY_METADATA,  0                                  },
    { MD_SSL_CERT_HASH,                   METADATA_INHERIT,                          IIS_MD_UT_SERVER, BINARY_METADATA,  0                                  },
    { MD_SSL_CERT_STORE_NAME,             METADATA_INHERIT,                          IIS_MD_UT_SERVER, STRING_METADATA,  0                                  },
    { MD_SSL_CTL_IDENTIFIER,              METADATA_INHERIT,                          IIS_MD_UT_SERVER, STRING_METADATA,  0                                  },
    { MD_SSL_CTL_STORE_NAME,              METADATA_INHERIT,                          IIS_MD_UT_SERVER, STRING_METADATA,  0                                  },
    { MD_SSL_USE_DS_MAPPER,               METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, DWORD_METADATA,   0                                  },
    { MD_AUTHORIZATION,                   METADATA_INHERIT,                          IIS_MD_UT_FILE,   DWORD_METADATA,   IDS_MD_AUTHORIZATION               },
    { MD_REALM,                           METADATA_INHERIT,                          IIS_MD_UT_FILE,   STRING_METADATA,  IDS_MD_REALM                       },
    { MD_HTTP_EXPIRES,                    METADATA_INHERIT,                          IIS_MD_UT_FILE,   STRING_METADATA,  IDS_MD_HTTP_EXPIRES                },
    { MD_HTTP_PICS,                       METADATA_INHERIT,                          IIS_MD_UT_FILE,   MULTISZ_METADATA, IDS_MD_HTTP_PICS                   },
    { MD_HTTP_CUSTOM,                     METADATA_INHERIT,                          IIS_MD_UT_FILE,   MULTISZ_METADATA, IDS_MD_HTTP_CUSTOM                 },
    { MD_DIRECTORY_BROWSING,              METADATA_INHERIT,                          IIS_MD_UT_FILE,   DWORD_METADATA,   IDS_MD_DIRECTORY_BROWSING          },
    { MD_DEFAULT_LOAD_FILE,               METADATA_INHERIT,                          IIS_MD_UT_FILE,   STRING_METADATA,  IDS_MD_DEFAULT_LOAD_FILE           },
    { MD_CONTENT_NEGOTIATION,             METADATA_INHERIT,                          IIS_MD_UT_FILE,   DWORD_METADATA,   IDS_MD_CONTENT_NEGOTIATION         },
    { MD_CUSTOM_ERROR,                    METADATA_INHERIT,                          IIS_MD_UT_FILE,   MULTISZ_METADATA, IDS_MD_CUSTOM_ERROR                },
    { MD_FOOTER_DOCUMENT,                 METADATA_INHERIT,                          IIS_MD_UT_FILE,   STRING_METADATA,  IDS_MD_FOOTER_DOCUMENT             },
    { MD_FOOTER_ENABLED,                  METADATA_INHERIT,                          IIS_MD_UT_FILE,   DWORD_METADATA,   IDS_MD_FOOTER_ENABLED              },
    { MD_HTTP_REDIRECT,                   METADATA_INHERIT,                          IIS_MD_UT_FILE,   STRING_METADATA,  IDS_MD_HTTP_REDIRECT               },
    { MD_DEFAULT_LOGON_DOMAIN,            METADATA_INHERIT,                          IIS_MD_UT_FILE,   STRING_METADATA,  IDS_MD_DEFAULT_LOGON_DOMAIN        },
    { MD_LOGON_METHOD,                    METADATA_INHERIT,                          IIS_MD_UT_FILE,   DWORD_METADATA,   IDS_MD_LOGON_METHOD                },
    { MD_SCRIPT_MAPS,                     METADATA_INHERIT,                          IIS_MD_UT_FILE,   MULTISZ_METADATA, IDS_MD_SCRIPT_MAPS                 },
    { MD_MIME_MAP,                        METADATA_INHERIT,                          IIS_MD_UT_FILE,   MULTISZ_METADATA, IDS_MD_MIME_MAP                    },
    { MD_ACCESS_PERM,                     METADATA_INHERIT,                          IIS_MD_UT_FILE,   DWORD_METADATA,   IDS_MD_ACCESS_PERM                 },
    { MD_IP_SEC,                          METADATA_INHERIT | METADATA_REFERENCE,     IIS_MD_UT_FILE,   BINARY_METADATA,  IDS_MD_IP_SEC                      },
    { MD_ANONYMOUS_USER_NAME,             METADATA_INHERIT,                          IIS_MD_UT_FILE,   STRING_METADATA,  IDS_MD_ANONYMOUS_USER_NAME         },
    { MD_ANONYMOUS_PWD,                   METADATA_INHERIT | METADATA_SECURE,        IIS_MD_UT_FILE,   STRING_METADATA,  IDS_MD_ANONYMOUS_PWD               },
    { MD_ANONYMOUS_USE_SUBAUTH,           METADATA_INHERIT,                          IIS_MD_UT_FILE,   DWORD_METADATA,   IDS_MD_ANONYMOUS_USE_SUBAUTH       },
    { MD_DONT_LOG,                        METADATA_INHERIT,                          IIS_MD_UT_FILE,   DWORD_METADATA,   IDS_MD_DONT_LOG                    },
    { MD_ADMIN_ACL,                       METADATA_INHERIT | METADATA_SECURE | METADATA_REFERENCE,IIS_MD_UT_SERVER, BINARY_METADATA,  IDS_MD_ADMIN_ACL      },
    { MD_SSI_EXEC_DISABLED,               METADATA_INHERIT,                          IIS_MD_UT_FILE,   DWORD_METADATA,   IDS_MD_SSI_EXEC_DISABLED           },
    { MD_SSL_ACCESS_PERM,                 METADATA_INHERIT,                          IIS_MD_UT_FILE,   DWORD_METADATA,   IDS_MD_SSL_ACCESS_PERM             },
    { MD_NTAUTHENTICATION_PROVIDERS,      METADATA_INHERIT,                          IIS_MD_UT_FILE,   STRING_METADATA,  IDS_MD_NTAUTHENTICATION_PROVIDERS  },
    { MD_SCRIPT_TIMEOUT,                  METADATA_INHERIT,                          IIS_MD_UT_FILE,   DWORD_METADATA,   IDS_MD_SCRIPT_TIMEOUT              },
    { MD_CACHE_EXTENSIONS,                METADATA_INHERIT,                          IIS_MD_UT_FILE,   DWORD_METADATA,   IDS_MD_CACHE_EXTENSIONS            },
    { MD_CREATE_PROCESS_AS_USER,          METADATA_INHERIT,                          IIS_MD_UT_SERVER, DWORD_METADATA,   IDS_MD_CREATE_PROCESS_AS_USER      },
    { MD_CREATE_PROC_NEW_CONSOLE,         METADATA_INHERIT,                          IIS_MD_UT_SERVER, DWORD_METADATA,   IDS_MD_CREATE_PROC_NEW_CONSOLE     },
    { MD_POOL_IDC_TIMEOUT,                METADATA_INHERIT,                          IIS_MD_UT_FILE,   DWORD_METADATA,   IDS_MD_POOL_IDC_TIMEOUT            },
    { MD_ALLOW_KEEPALIVES,                METADATA_INHERIT,                          IIS_MD_UT_FILE,   DWORD_METADATA,   IDS_MD_ALLOW_KEEPALIVES            },
    { MD_IS_CONTENT_INDEXED,              METADATA_INHERIT,                          IIS_MD_UT_FILE,   DWORD_METADATA,   IDS_MD_IS_CONTENT_INDEXED          },
    { MD_ISM_ACCESS_CHECK,                METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_FILE,   DWORD_METADATA,   0                                  },
    { MD_ASP_BUFFERINGON,                 METADATA_INHERIT,                          ASP_MD_UT_APP,    DWORD_METADATA,   IDS_ASP_BUFFERINGON                },
    { MD_ASP_LOGERRORREQUESTS,            METADATA_INHERIT,                          IIS_MD_UT_WAM,    DWORD_METADATA,   IDS_ASP_LOGERRORREQUESTS           },
    { MD_ASP_SCRIPTERRORSSENTTOBROWSER,   METADATA_INHERIT,                          ASP_MD_UT_APP,    DWORD_METADATA,   IDS_ASP_SCRIPTERRORSSENTTOBROWSER  },
    { MD_ASP_SCRIPTERRORMESSAGE,          METADATA_INHERIT,                          ASP_MD_UT_APP,    STRING_METADATA,  IDS_ASP_SCRIPTERRORMESSAGE         },
    { MD_ASP_SCRIPTFILECACHESIZE,         METADATA_INHERIT,                          IIS_MD_UT_WAM,    DWORD_METADATA,   IDS_ASP_SCRIPTFILECACHESIZE        },
    { MD_ASP_SCRIPTENGINECACHEMAX,        METADATA_INHERIT,                          IIS_MD_UT_WAM,    DWORD_METADATA,   IDS_ASP_SCRIPTENGINECACHEMAX       },
    { MD_ASP_SCRIPTTIMEOUT,               METADATA_INHERIT,                          ASP_MD_UT_APP,    DWORD_METADATA,   IDS_ASP_SCRIPTTIMEOUT              },
    { MD_ASP_SESSIONTIMEOUT,              METADATA_INHERIT,                          ASP_MD_UT_APP,    DWORD_METADATA,   IDS_ASP_SESSIONTIMEOUT             },
    { MD_ASP_ENABLEPARENTPATHS,           METADATA_INHERIT,                          ASP_MD_UT_APP,    DWORD_METADATA,   IDS_ASP_ENABLEPARENTPATHS          },
    { MD_ASP_ALLOWSESSIONSTATE,           METADATA_INHERIT,                          ASP_MD_UT_APP,    DWORD_METADATA,   IDS_ASP_ALLOWSESSIONSTATE          },
    { MD_ASP_SCRIPTLANGUAGE,              METADATA_INHERIT,                          ASP_MD_UT_APP,    STRING_METADATA,  IDS_ASP_SCRIPTLANGUAGE             },
    { MD_ASP_EXCEPTIONCATCHENABLE,        METADATA_INHERIT,                          IIS_MD_UT_WAM,    DWORD_METADATA,   IDS_ASP_EXCEPTIONCATCHENABLE       },
    { MD_ASP_ENABLESERVERDEBUG,           METADATA_INHERIT,                          ASP_MD_UT_APP,    DWORD_METADATA,   IDS_ASP_ENABLESERVERDEBUG          },
    { MD_ASP_ENABLECLIENTDEBUG,           METADATA_INHERIT,                          ASP_MD_UT_APP,    DWORD_METADATA,   IDS_ASP_ENABLECLIENTDEBUG          },
    { MD_ASP_DISKTEMPLATECACHEDIRECTORY,  METADATA_INHERIT,                          IIS_MD_UT_WAM,    STRING_METADATA,  0                                  },
    { MD_ASP_MAXDISKTEMPLATECACHEFILES,   METADATA_INHERIT,                          IIS_MD_UT_WAM,    DWORD_METADATA,   0                                  },
    { MD_WAM_USER_NAME,                   METADATA_INHERIT,                          IIS_MD_UT_WAM,    STRING_METADATA,  0                                  },
    { MD_WAM_PWD,                         METADATA_INHERIT,                          IIS_MD_UT_WAM,    STRING_METADATA,  0                                  }
};



#define NUM_ENTRIES (sizeof(CMetaKey::s_rgMetaTable) / sizeof(CMetaKey::s_rgMetaTable[0]))



/* static */
int
CMetaKey::MapMDIDToTableIndex(
    IN DWORD dwID
    )
/*++

Routine Description:

    Map MD id value to table index.  Return -1 if not found

Arguments:

    DWORD dwID : MD id value

Return Value:

    Index into the table that coresponds to the MD id value

--*/
{
#ifdef _DEBUG

    {
        //
        // Do a quick verification that our metadata
        // table is sorted correctly.
        //
        static BOOL fTableChecked = FALSE;

        if (!fTableChecked)
        {
            for (int n = 1; n < NUM_ENTRIES; ++n)
            {
                if (s_rgMetaTable[n].dwMDIdentifier
                    <= s_rgMetaTable[n - 1].dwMDIdentifier)
                {
//                    TRACE("MD ID Table is out of order: Item is %d %s\n", n, s_rgMetaTable[n].dwMDIdentifier);
                    ASSERT_MSG("MD ID Table out of order");
                }
            }

            //
            // But only once.
            //
            ++fTableChecked;
        }
    }

#endif // _DEBUG

    //
    // Look up the ID in the table using a binary search
    //
    int nRange = NUM_ENTRIES;
    int nLow = 0;
    int nHigh = nRange - 1;
    int nMid;
    int nHalf;

    while (nLow <= nHigh)
    {
        if (nHalf = nRange / 2)
        {
            nMid  = nLow + (nRange & 1 ? nHalf : (nHalf - 1));

            if (s_rgMetaTable[nMid].dwMDIdentifier == dwID)
            {
                return nMid;
            }
            else if (s_rgMetaTable[nMid].dwMDIdentifier > dwID)
            {
                nHigh  = --nMid;
                nRange = nRange & 1 ? nHalf : nHalf - 1;
            }
            else
            {
                nLow   = ++nMid;
                nRange = nHalf;
            }
        }
        else if (nRange)
        {
            return s_rgMetaTable[nLow].dwMDIdentifier == dwID ? nLow : -1;
        }
        else
        {
            break;
        }
    }

    return -1;
}



/* static */
BOOL
CMetaKey::GetMDFieldDef(
    IN  DWORD dwID,
    OUT DWORD & dwMDIdentifier,
    OUT DWORD & dwMDAttributes,
    OUT DWORD & dwMDUserType,
    OUT DWORD & dwMDDataType
    )
/*++

Routine Description:

    Get information about metabase property

Arguments:

    DWORD dwID                  : Meta ID
    DWORD & dwMDIdentifier      : Meta parms
    DWORD & dwMDAttributes      : Meta parms
    DWORD & dwMDUserType        : Meta parms
    DWORD & dwMDDataType        : Meta parms

Return Value:

    TRUE for success, FALSE for failure.

--*/
{
    int nID = MapMDIDToTableIndex(dwID);

    if (nID == -1)
    {
        //
        // Unrecognized meta data ID
        //
        ASSERT_MSG("Unrecognized meta data id");
        return FALSE;
    }

    dwMDIdentifier = s_rgMetaTable[nID].dwMDIdentifier;
    dwMDAttributes = s_rgMetaTable[nID].dwMDAttributes;
    dwMDUserType   = s_rgMetaTable[nID].dwMDUserType;
    dwMDDataType   = s_rgMetaTable[nID].dwMDDataType;

    return TRUE;
}



/* static */
BOOL
CMetaKey::IsPropertyInheritable(
    IN DWORD dwID
    )
/*++

Routine Description:

    Check to see if the given property is inheritable

Arguments:

    DWORD dwID      : Metabase ID

Return Value:

    TRUE if the metabase ID is inheritable, FALSE otherwise.

--*/
{
    int nID = MapMDIDToTableIndex(dwID);

    if (nID == -1)
    {
        //
        // Unrecognized meta data ID
        //
        ASSERT_MSG("Unrecognized meta data ID");
        return FALSE;
    }

    return (s_rgMetaTable[nID].dwMDAttributes & METADATA_INHERIT) != 0;
}



/* static */
BOOL
CMetaKey::GetPropertyDescription(
    IN  DWORD dwID,
    OUT CString & strName
    )
/*++

Routine Description:

    Get a description for the given property

Arguments:

    DWORD dwID            : Property ID
    CString & strName     : Returns friendly property name

Return Value:

    TRUE for success, FALSE for failure

--*/
{
    int nID = MapMDIDToTableIndex(dwID);

    if (nID == -1)
    {
        //
        // Unrecognized meta data ID
        //
        ASSERT_MSG("Unrecognized meta data ID");
        return FALSE;
    }

    UINT uID = s_rgMetaTable[nID].uStringID;

    BOOL fResult = TRUE;

    if (uID > 0)
    {
        fResult = (strName.LoadString(_Module.GetResourceInstance(), uID) != 0);
    }
    else
    {
        //
        // Don't have a friendly name -- fake it
        //
        CComBSTR bstrFmt;
        VERIFY(bstrFmt.LoadString(_Module.GetResourceInstance(), IDS_INHERITANCE_NO_NAME));

        strName.Format(bstrFmt, dwID);
    }

    return fResult;
}



CMetaKey::CMetaKey(
    IN CComAuthInfo * pAuthInfo     OPTIONAL
    )
/*++

Routine Description:

    Constructor that creates the interface, but does not open the key.
    This is the ONLY constructor that allows operations from
    METDATA_MASTER_ROOT_HANDLE (read operations obviously)

Arguments:

    CComAuthInfo * pAuthInfo  : If NULL, opens interface on local machine

Return Value:

    N/A

--*/
    : CMetaInterface(pAuthInfo),
      m_hKey(METADATA_MASTER_ROOT_HANDLE),
      m_hBase(NULL),
      m_hrKey(S_OK),
      m_dwFlags(0L),
      m_cbInitialBufferSize(MB_INIT_BUFF_SIZE),
      m_strMetaPath(),
      m_fAllowRootOperations(TRUE),
      m_fOwnKey(TRUE)
{
    m_hrKey = CMetaInterface::QueryResult(); 

    //
    // Do not open key
    //
}



CMetaKey::CMetaKey(
    IN CMetaInterface * pInterface
    )
/*++

Routine Description:

    Construct with pre-existing interface.  Does not
    open any keys

Arguments:

    CMetaInterface * pInterface       : Preexisting interface

Return Value:

    N/A

--*/
    : CMetaInterface(pInterface),
      m_hKey(NULL),
      m_hBase(NULL),
      m_strMetaPath(),
      m_dwFlags(0L),
      m_cbInitialBufferSize(MB_INIT_BUFF_SIZE),
      m_fAllowRootOperations(TRUE),
      m_fOwnKey(TRUE)
{
    m_hrKey = CMetaInterface::QueryResult(); 
}        



CMetaKey::CMetaKey(
    IN CComAuthInfo * pAuthInfo,    OPTIONAL
    IN LPCTSTR lpszMDPath,          OPTIONAL
    IN DWORD   dwFlags,               
    IN METADATA_HANDLE hkBase
    )
/*++

Routine Description:

    Fully defined constructor that opens a key

Arguments:

    CComAuthInfo * pAuthInfo : Auth info or NULL
    LPCTSTR lpszMDPath       : Path or NULL
    DWORD   dwFlags          : Open permissions
    METADATA_HANDLE hkBase   : Base key

Return Value:

    N/A

--*/
    : CMetaInterface(pAuthInfo),
//    : CMetaInterface((CComAuthInfo *)NULL),
      m_hKey(NULL),
      m_hBase(NULL),
      m_dwFlags(0L),
      m_cbInitialBufferSize(MB_INIT_BUFF_SIZE),
      m_fAllowRootOperations(FALSE),
      m_strMetaPath(),
      m_fOwnKey(TRUE)
{
    m_hrKey = CMetaInterface::QueryResult(); 

    if (SUCCEEDED(m_hrKey))
    {
        m_hrKey = Open(dwFlags, lpszMDPath, hkBase);
    }
}



CMetaKey::CMetaKey(
    IN CMetaInterface * pInterface,
    IN LPCTSTR lpszMDPath,              OPTIONAL
    IN DWORD   dwFlags,               
    IN METADATA_HANDLE hkBase
    )
/*++

Routine Description:

    Fully defined constructor that opens a key

Arguments:

    CMetaInterface * pInterface : Existing interface
    DWORD   dwFlags             : Open permissions
    METADATA_HANDLE hkBase      : Base key
    LPCTSTR lpszMDPath          : Path or NULL

Return Value:

    N/A

--*/
    : CMetaInterface(pInterface),
      m_hKey(NULL),
      m_hBase(NULL),
      m_strMetaPath(),
      m_dwFlags(0L),
      m_cbInitialBufferSize(MB_INIT_BUFF_SIZE),
      m_fAllowRootOperations(FALSE),
      m_fOwnKey(TRUE)
{
    m_hrKey = CMetaInterface::QueryResult(); 

    if (SUCCEEDED(m_hrKey))
    {
        m_hrKey = Open(dwFlags, lpszMDPath, hkBase);
    }
}



CMetaKey::CMetaKey(
    IN BOOL  fOwnKey,
    IN CMetaKey * pKey
    )
/*++

Routine Description:

    Copy constructor. 

Arguments:

    BOOL  fOwnKey               : TRUE to take ownership of the key
    const CMetaKey * pKey       : Existing key

Return Value:

    N/A

--*/
    : CMetaInterface(pKey),
      m_hKey(pKey->m_hKey),
      m_hBase(pKey->m_hBase),
      m_dwFlags(pKey->m_dwFlags),
      m_cbInitialBufferSize(pKey->m_cbInitialBufferSize),
      m_fAllowRootOperations(pKey->m_fAllowRootOperations),
      m_hrKey(pKey->m_hrKey),
      m_strMetaPath(pKey->m_strMetaPath),
      m_fOwnKey(fOwnKey)
{
    //
    // No provisions for anything else at the moment
    //
    ASSERT(!m_fOwnKey);
}



CMetaKey::~CMetaKey()
/*++

Routine Description:

    Destructor -- Close the key.

Arguments:

    N/A

Return Value:

    N/A

--*/
{
    if (IsOpen() && m_fOwnKey)
    {
        Close();
    }
}



/* virtual */
BOOL 
CMetaKey::Succeeded() const
/*++

Routine Description:

    Determine if object was constructed successfully

Arguments:

    None

Return Value:

    TRUE for success, FALSE for failure

--*/
{
    return SUCCEEDED(m_hrKey);
}



/* virtual */
HRESULT 
CMetaKey::QueryResult() const
/*++

Routine Description:

    Return the construction error for this object

Arguments:

    None

Return Value:

    HRESULT from construction errors

--*/
{
    return m_hrKey;
}



HRESULT 
CMetaKey::Open(
    IN DWORD dwFlags,                
    IN LPCTSTR lpszMDPath,          OPTIONAL
    IN METADATA_HANDLE hkBase
    )
/*++

Routine Description:

    Attempt to open a metabase key

Arguments:

    DWORD dwFlags           : Permission flags
    LPCTSTR lpszMDPath      : Optional path
    METADATA_HANDLE hkBase  : Base metabase key

Return Value:

    HRESULT

--*/
{
    ASSURE_PROPER_INTERFACE();

    if (m_hKey != NULL)
    {
        ASSERT_MSG("Attempting to open key that already has an open handle");

//        TRACEEOLID("Closing that key");
        Close();
    }

    //
    // Base key is stored for reopen purposes only
    //
    m_hBase = hkBase;
    m_strMetaPath = lpszMDPath;
    m_dwFlags = dwFlags;

    return OpenKey(m_hBase, m_strMetaPath, m_dwFlags, &m_hKey);
}



HRESULT 
CMetaKey::CreatePathFromFailedOpen()
/*++

Routine Description:

    If the path doesn't exist, create it.  This method should be
    called after an Open call failed (because it will have initialized
    m_strMetaPath.

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    CString strParentPath;
    CString strObjectName;
    CString strSavePath(m_strMetaPath);

    CMetabasePath::SplitMetaPathAtInstance(
        m_strMetaPath, 
        strParentPath, 
        strObjectName
        );

    CError err(Open(
        METADATA_PERMISSION_WRITE,
        strParentPath
        ));

    if (err.Succeeded())
    {
        //
        // This really should never fail, because we're opening
        // the path at the instance.
        //
        err = AddKey(strObjectName);
    }

    if (IsOpen())
    {
        Close();
    }

    //
    // The previous open wiped out the path...
    //
    m_strMetaPath = strSavePath;

    return err;
}



HRESULT
CMetaKey::Close()
/*++

Routine Description:

    Close the currently open key.

Arguments:

    N/A

Return Value:

    N/A

--*/
{
    ASSURE_PROPER_INTERFACE();

    HRESULT hr = S_OK;

    ASSERT(m_hKey != NULL);
    ASSERT(m_fOwnKey);

    if (m_hKey)
    {
        hr = CloseKey(m_hKey);

        if (SUCCEEDED(hr))
        {
            m_hKey = NULL;
        }
    }

    return hr;
}



HRESULT
CMetaKey::ConvertToParentPath(
    IN  BOOL fImmediate
    )
/*++

Routine Description:

    Change the path to the parent path.

Arguments:

    BOOL fImmediate     : If TRUE, the immediate parent's path will be used
                          if FALSE, the first parent that really exists

Return Value:

    HRESULT

        ERROR_INVALID_PARAMETER if there is no valid path

--*/
{
    BOOL fIsOpen = IsOpen();

    if (fIsOpen)
    {
        Close();
    }

    CError err;

    FOREVER
    {
        if (!CMetabasePath::ConvertToParentPath(m_strMetaPath))
        {
            //
            // There is no parent path
            //
            err = ERROR_INVALID_PARAMETER;
            break;
        }

        err = ReOpen();

        //
        // Path not found is the only valid error
        // other than success.
        //
        if (fImmediate 
            || err.Succeeded() 
            || err.Win32Error() != ERROR_PATH_NOT_FOUND)
        {
            break;
        }
    }

    //
    // Remember to reset the construction error
    // which referred to the parent path.
    //
    m_hrKey = err;

    return err;
}




/* protected */
HRESULT
CMetaKey::GetPropertyValue(
    IN  DWORD dwID,
    OUT IN DWORD & dwSize,               OPTIONAL
    OUT IN void *& pvData,               OPTIONAL
    OUT IN DWORD * pdwDataType,          OPTIONAL
    IN  BOOL * pfInheritanceOverride,    OPTIONAL
    IN  LPCTSTR lpszMDPath,              OPTIONAL
    OUT DWORD * pdwAttributes            OPTIONAL
    )
/*++

Routine Description:

    Get metadata on the currently open key.

Arguments:

    DWORD dwID                      : Property ID number
    DWORD & dwSize                  : Buffer size (could be 0)
    void *& pvData                  : Buffer -- will allocate if NULL
    DWORD * pdwDataType             : NULL or on in  contains valid data types,
                                    :         on out contains actual data type
    BOOL * pfInheritanceOverride    : NULL or on forces inheritance on/off
    LPCTSTR lpszMDPath              : Optional path off the open key
    DWORD * pdwAttributes           : Optionally returns attributes    

Return Value:

    HRESULT 

    ERROR_INVALID_HANDLE        : If the handle is not open
    ERROR_INVALID_PARAMETER     : If the property id is not found,
                                  or the data type doesn't match requested type
    ERROR_OUTOFMEMORY           : Out of memory

--*/
{
    ASSURE_PROPER_INTERFACE();
    ASSURE_OPEN_KEY();

    METADATA_RECORD mdRecord;
    FETCH_PROPERTY_DATA_OR_FAIL(dwID, mdRecord);

    //
    // If unable to find this property ID in our table, or
    // if we specified a desired type, and this type doesn't 
    // match it, give up.
    //
    if (pdwDataType && *pdwDataType != ALL_METADATA 
        && *pdwDataType != mdRecord.dwMDDataType)
    {
        ASSERT_MSG("Invalid parameter");
        return HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
    }

    //
    // Check to see if inheritance behaviour is overridden
    //
    if (pfInheritanceOverride)
    {
        if (*pfInheritanceOverride)
        {
            mdRecord.dwMDAttributes |= METADATA_INHERIT;
        }
        else
        {
            mdRecord.dwMDAttributes &= ~METADATA_INHERIT;
        }
    }

    //
    // This causes a bad parameter error on input otherwise
    //
    mdRecord.dwMDAttributes &= ~METADATA_REFERENCE;

    //
    // If we're looking for inheritable properties, the path
    // doesn't have to be completely specified.
    //
    if (mdRecord.dwMDAttributes & METADATA_INHERIT)
    {
        mdRecord.dwMDAttributes |= (METADATA_PARTIAL_PATH | METADATA_ISINHERITED);
    }

    ASSERT(dwSize > 0 || pvData == NULL);
    
    mdRecord.dwMDDataLen = dwSize;
    mdRecord.pbMDData = (LPBYTE)pvData;

    //
    // If no buffer provided, allocate one.
    //
    HRESULT hr = S_OK;
    BOOL fBufferTooSmall = FALSE;
    BOOL fAllocatedMemory = FALSE;
    DWORD dwInitSize = m_cbInitialBufferSize;

    do
    {
        if(mdRecord.pbMDData == NULL)
        {
            mdRecord.dwMDDataLen = dwInitSize;
            mdRecord.pbMDData = new BYTE[dwInitSize];

            if(mdRecord.pbMDData == NULL && dwInitSize > 0)
            {
                hr = HRESULT_FROM_WIN32(ERROR_OUTOFMEMORY);
                break;
            }

            ++fAllocatedMemory;
        }

        //
        // Get the data
        //
        DWORD dwRequiredDataLen = 0;
        hr = GetData(m_hKey, lpszMDPath, &mdRecord, &dwRequiredDataLen);

        //
        // Re-fetch the buffer if it's too small.
        //
        fBufferTooSmall = 
            (HRESULT_CODE(hr) == ERROR_INSUFFICIENT_BUFFER) && fAllocatedMemory;

        if(fBufferTooSmall)
        {
            //
            // Delete the old buffer, and set up for a re-fetch.
            //
            delete [] mdRecord.pbMDData;
            mdRecord.pbMDData = NULL;
            dwInitSize = dwRequiredDataLen;
        }
    }
    while(fBufferTooSmall);

    //
    // Failed
    //
   if (FAILED(hr) && fAllocatedMemory)
   {
       delete [] mdRecord.pbMDData;
       mdRecord.pbMDData = NULL;
   }

   dwSize = mdRecord.dwMDDataLen;
   pvData = mdRecord.pbMDData;

   if (pdwDataType != NULL)
   {
      //
      // Return actual data type
      //
      *pdwDataType = mdRecord.dwMDDataType;
   }

   if (pdwAttributes != NULL)
   {
      //
      // Return data attributes
      //
      *pdwAttributes =  mdRecord.dwMDAttributes;
   }

   return hr;
}



/* protected */
HRESULT 
CMetaKey::GetDataPaths( 
    OUT CStringListEx & strlDataPaths,
    IN  DWORD   dwMDIdentifier,
    IN  DWORD   dwMDDataType,
    IN  LPCTSTR lpszMDPath              OPTIONAL
    )
/*++

Routine Description:

    Get data paths

Arguments:


Return Value:

    HRESULT

--*/
{
    ASSURE_PROPER_INTERFACE();
    ASSURE_OPEN_KEY();

    //
    // Start with a small buffer
    //
    DWORD  dwMDBufferSize = 1024;
    LPTSTR lpszBuffer = NULL;
    CError err;

    do
    {
        delete [] lpszBuffer;
        lpszBuffer = new TCHAR[dwMDBufferSize];

        if (lpszBuffer == NULL)
        {
            err = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        err = CMetaInterface::GetDataPaths(
            m_hKey,
            lpszMDPath,
            dwMDIdentifier,
            dwMDDataType,
            dwMDBufferSize,
            lpszBuffer,
            &dwMDBufferSize
            );
    }
    while(err.Win32Error() == ERROR_INSUFFICIENT_BUFFER);

    if (err.Win32Error() == ERROR_PATH_NOT_FOUND)
    {
        //
        // That's ok... this is some sort of physical directory
        // that doesn't currently exist in the metabase, and
        // which therefore doesn't have any descendants anyway.
        //
        ZeroMemory(lpszBuffer, dwMDBufferSize);
        err.Reset();
    }

    if (err.Succeeded())
    {
        strlDataPaths.ConvertFromDoubleNullList(lpszBuffer);
        delete [] lpszBuffer;
    }

    return err;
}



HRESULT
CMetaKey::CheckDescendants(
    IN DWORD   dwID,
    IN CComAuthInfo * pAuthInfo, OPTIONAL
    IN LPCTSTR lpszMDPath         OPTIONAL
    )
/*++

Routine Description:

    Check for descendant overrides;  If there are any, bring up a dialog
    that displays them, and give the user the opportunity the remove
    the overrides.

Arguments:

    DWORD dwID               : Property ID
    CComAuthInfo * pAuthInfo : Server or NULL
    LPCTSTR lpszMDPath       : Metabase path or NULL

Return Value:

    HRESULT

--*/
{
    ASSURE_PROPER_INTERFACE();

    HRESULT hr = S_OK;

    METADATA_RECORD mdRecord;
    FETCH_PROPERTY_DATA_OR_FAIL(dwID, mdRecord);

    if (mdRecord.dwMDAttributes & METADATA_INHERIT)
    {
        CStringListEx strlDataPaths;

        hr = GetDataPaths( 
            strlDataPaths,
            mdRecord.dwMDIdentifier,
            mdRecord.dwMDDataType,
            lpszMDPath
            );

        if (SUCCEEDED(hr) && !strlDataPaths.empty())
        {
            //
            // Bring up the inheritance override dialog
            //
            CInheritanceDlg dlg(
                dwID,
                FROM_WRITE_PROPERTY,
                pAuthInfo,
                lpszMDPath,
                strlDataPaths
                );

            if (!dlg.IsEmpty())
            {
                dlg.DoModal();
            }
        }
    }

    return hr;
}



/* protected */
HRESULT
CMetaKey::SetPropertyValue(
    IN DWORD dwID,
    IN DWORD dwSize,
    IN void * pvData,
    IN BOOL * pfInheritanceOverride,    OPTIONAL
    IN LPCTSTR lpszMDPath               OPTIONAL
    )
/*++

Routine Description:

    Set metadata on the open key.  The key must have been opened with
    write permission.

Arguments:

    DWORD dwID                      : Property ID
    DWORD dwSize                    : Size of data
    void * pvData                   : Data buffer
    BOOL * pfInheritanceOverride    : NULL or forces inheritance on/off
    LPCTSTR lpszMDPath              : Optional path off the open key

Return Value:

    HRESULT 

    ERROR_INVALID_HANDLE            : If the handle is not open
    ERROR_INVALID_PARAMETER         : If the property id is not found,
                                      or the buffer is NULL or of size 0

--*/
{
    ASSURE_PROPER_INTERFACE();
    ASSURE_OPEN_KEY();

    if (pvData == NULL && dwSize != 0)
    {
        ASSERT_MSG("No Data");
        return HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
    }

    METADATA_RECORD mdRecord;
    FETCH_PROPERTY_DATA_OR_FAIL(dwID, mdRecord);

    if (pfInheritanceOverride)
    {
        if (*pfInheritanceOverride)
        {
            mdRecord.dwMDAttributes |= METADATA_INHERIT;
        }
        else
        {
            mdRecord.dwMDAttributes &= ~METADATA_INHERIT;
        }
    }

    mdRecord.dwMDDataLen = dwSize;
    mdRecord.pbMDData = (LPBYTE)pvData;

    return SetData(m_hKey, lpszMDPath, &mdRecord);
}



/* protected */
HRESULT 
CMetaKey::GetAllData(
    IN  DWORD dwMDAttributes,
    IN  DWORD dwMDUserType,
    IN  DWORD dwMDDataType,
    OUT DWORD * pdwMDNumEntries,
    OUT DWORD * pdwMDDataLen,
    OUT PBYTE * ppbMDData,
    IN  LPCTSTR lpszMDPath              OPTIONAL
    )
/*++

Routine Description:

    Get all data off the open key.  Buffer is created automatically.

Arguments:

    DWORD dwMDAttributes            : Attributes
    DWORD dwMDUserType              : User type to fetch
    DWORD dwMDDataType              : Data type to fetch
    DWORD * pdwMDNumEntries         : Returns number of entries read
    DWORD * pdwMDDataLen            : Returns size of data buffer
    PBYTE * ppbMDData               : Returns data buffer
    LPCTSTR lpszMDPath              : Optional data path        

Return Value:

    HRESULT

--*/
{
    ASSURE_PROPER_INTERFACE();
    ASSURE_OPEN_KEY();

    //
    // Check for valid parameters
    //
    if(!pdwMDDataLen || !ppbMDData || !pdwMDNumEntries)
    {
        return HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
    }

    HRESULT hr = S_OK;
    BOOL fBufferTooSmall = FALSE;
    DWORD dwMDDataSetNumber;
    DWORD dwRequiredBufferSize;
    DWORD dwInitSize = m_cbInitialBufferSize;
    *ppbMDData = NULL;

    do
    {
        *pdwMDDataLen = dwInitSize;
        *ppbMDData = new BYTE[dwInitSize];

        if (ppbMDData == NULL && dwInitSize > 0)
        {
            hr = HRESULT_FROM_WIN32(ERROR_OUTOFMEMORY);
            break;
        }

        hr = CMetaInterface::GetAllData(
            m_hKey,
            lpszMDPath,
            dwMDAttributes,
            dwMDUserType,
            dwMDDataType,
            pdwMDNumEntries,
            &dwMDDataSetNumber,
            *pdwMDDataLen,
            *ppbMDData,
            &dwRequiredBufferSize
            );

        //
        // Re-fetch the buffer if it's too small.
        //
        fBufferTooSmall = (HRESULT_CODE(hr) == ERROR_INSUFFICIENT_BUFFER);

        if(fBufferTooSmall)
        {
            //
            // Delete the old buffer, and set up for a re-fetch.
            //
            delete [] *ppbMDData;
            dwInitSize = dwRequiredBufferSize;
        }
    }
    while (fBufferTooSmall);

    if (FAILED(hr))
    {
        //
        // No good, be sure we don't leak anything
        //
        delete [] *ppbMDData;
        dwInitSize = 0L;
    }

    return hr;
}



HRESULT
CMetaKey::QueryValue(
    IN  DWORD dwID,
    IN  OUT DWORD & dwValue,
    IN  BOOL * pfInheritanceOverride, OPTIONAL
    IN  LPCTSTR lpszMDPath,           OPTIONAL
    OUT DWORD * pdwAttributes         OPTIONAL
    )
/*++

Routine Description:

    Fetch data as a DWORD

Arguments:

    DWORD dwID                      : Property ID
    DWORD & dwValue                 : Returns the value read in
    BOOL * pfInheritanceOverride    : NULL or forces inheritance on/off
    LPCTSTR lpszMDPath              : Optional path off the open key
    DWORD * pdwAttributes           : Optionally returns attributes    

Return Value:

    HRESULT

--*/
{
    DWORD dwSize = sizeof(dwValue);
    DWORD dwDataType = DWORD_METADATA;
    void * pvData = &dwValue;

    return GetPropertyValue(
        dwID, 
        dwSize, 
        pvData, 
        &dwDataType, 
        pfInheritanceOverride,
        lpszMDPath,
        pdwAttributes
        );
}



HRESULT
CMetaKey::QueryValue(
    IN  DWORD dwID,
    IN  OUT CString & strValue,
    IN  BOOL * pfInheritanceOverride, OPTIONAL
    IN  LPCTSTR lpszMDPath,           OPTIONAL
    OUT DWORD * pdwAttributes         OPTIONAL
    )
/*++

Routine Description:

    Fetch data as a string

Arguments:

    DWORD dwID                      : Property ID
    DWORD & strValue                : Returns the value read in
    BOOL * pfInheritanceOverride    : NULL or forces inheritance on/off
    LPCTSTR lpszMDPath              : Optional path off the open key
    DWORD * pdwAttributes           : Optionally returns attributes    

Return Value:

    HRESULT

--*/
{
   //
   // Get GetData allocate the buffer for us
   //
   DWORD dwSize = 0;
   DWORD dwDataType = ALL_METADATA;
   LPTSTR lpData = NULL;

   HRESULT hr = GetPropertyValue(
        dwID, 
        dwSize, 
        (void *&)lpData, 
        &dwDataType,
        pfInheritanceOverride,
        lpszMDPath,
        pdwAttributes
        );

   if (SUCCEEDED(hr))
   {
      //
      // Notes: consider optional auto-expansion on EXPANDSZ_METADATA
      // (see registry functions), and data type conversions for DWORD
      // or MULTISZ_METADATA or BINARY_METADATA
      //
      if (dwDataType == EXPANDSZ_METADATA || dwDataType == STRING_METADATA)
      {
         try
         {
            strValue = lpData;
         }
         catch(std::bad_alloc)
         {
            hr = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
         }
      }
      else
      {
         hr = HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
      }
   }

   if (lpData)
   {
      delete [] lpData;
   }
   return hr;
}



HRESULT
CMetaKey::QueryValue(
    IN  DWORD dwID,
    IN  OUT CComBSTR & strValue,
    IN  BOOL * pfInheritanceOverride, OPTIONAL
    IN  LPCTSTR lpszMDPath,           OPTIONAL
    OUT DWORD * pdwAttributes         OPTIONAL
    )
/*++

Routine Description:

    Fetch data as a string

Arguments:

    DWORD dwID                      : Property ID
    DWORD & CComBSTR                : Returns the value read in
    BOOL * pfInheritanceOverride    : NULL or forces inheritance on/off
    LPCTSTR lpszMDPath              : Optional path off the open key
    DWORD * pdwAttributes           : Optionally returns attributes    

Return Value:

    HRESULT

--*/
{
    //
    // Get GetData allocate the buffer for us
    //
    DWORD dwSize = 0;
    DWORD dwDataType = ALL_METADATA;
    LPTSTR lpData = NULL;

    HRESULT hr = GetPropertyValue(
        dwID, 
        dwSize, 
        (void *&)lpData, 
        &dwDataType,
        pfInheritanceOverride,
        lpszMDPath,
        pdwAttributes
        );

    if (SUCCEEDED(hr))
    {
        //
        // Notes: consider optional auto-expansion on EXPANDSZ_METADATA
        // (see registry functions), and data type conversions for DWORD
        // or MULTISZ_METADATA or BINARY_METADATA
        //
        if (dwDataType == EXPANDSZ_METADATA || dwDataType == STRING_METADATA)
        {
            strValue = lpData;
        }
        else
        {
            hr = HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
        }
    }

    if (lpData)
    {
        delete [] lpData;
    }

    return hr;
}




HRESULT
CMetaKey::QueryValue(
    IN  DWORD dwID,
    IN  OUT CStringListEx & strlValue,
    IN  BOOL * pfInheritanceOverride, OPTIONAL
    IN  LPCTSTR lpszMDPath,           OPTIONAL
    OUT DWORD * pdwAttributes         OPTIONAL
    )
/*++

Routine Description:

    Fetch data as a stringlist

Arguments:

    DWORD dwID                      : Property ID
    DWORD & strlValue               : Returns the value read in
    BOOL * pfInheritanceOverride    : NULL or forces inheritance on/off
    LPCTSTR lpszMDPath              : Optional path off the open key
    DWORD * pdwAttributes           : Optionally returns attributes    

Return Value:

    HRESULT

--*/
{
    //
    // Get GetData allocate the buffer for us
    //
    DWORD dwSize = 0;
    DWORD dwDataType = MULTISZ_METADATA;
    LPTSTR lpData = NULL;

    HRESULT hr = GetPropertyValue(
        dwID, 
        dwSize, 
        (void *&)lpData, 
        &dwDataType,
        pfInheritanceOverride,
        lpszMDPath,
        pdwAttributes
        );

    if (SUCCEEDED(hr))
    {
        //
        // Notes: Consider accepting a single STRING
        //
        ASSERT(dwDataType == MULTISZ_METADATA);

        DWORD err = strlValue.ConvertFromDoubleNullList(lpData, dwSize / sizeof(TCHAR));
        hr = HRESULT_FROM_WIN32(err);
    }

    if (lpData)
    {
        delete [] lpData;
    }

    return hr;
}



HRESULT
CMetaKey::QueryValue(
    IN  DWORD dwID,
    IN  OUT CBlob & blValue,
    IN  BOOL * pfInheritanceOverride, OPTIONAL
    IN  LPCTSTR lpszMDPath,           OPTIONAL
    OUT DWORD * pdwAttributes         OPTIONAL
    )
/*++

Routine Description:

    Fetch data as a binary blob

Arguments:

    DWORD dwID                      : Property ID
    DWORD CBlob & blValue           : Returns the binary blob
    BOOL * pfInheritanceOverride    : NULL or forces inheritance on/off
    LPCTSTR lpszMDPath              : Optional path off the open key
    DWORD * pdwAttributes           : Optionally returns attributes    

Return Value:

    HRESULT

--*/
{
    //
    // Get GetData allocate the buffer for us
    //
    DWORD dwSize = 0;
    DWORD dwDataType = BINARY_METADATA;
    LPBYTE pbData = NULL;

    HRESULT hr = GetPropertyValue(
        dwID, 
        dwSize, 
        (void *&)pbData, 
        &dwDataType,
        pfInheritanceOverride,
        lpszMDPath,
        pdwAttributes
        );

    if (SUCCEEDED(hr))
    {
        //
        // Blob takes ownership of the data, so don't free it...
        //
        ASSERT_READ_PTR2(pbData, dwSize);
        blValue.SetValue(dwSize, pbData, FALSE);
    }

    return hr;
}



HRESULT 
CMetaKey::SetValue(
    IN DWORD dwID,
    IN CStringListEx & strlValue,
    IN BOOL * pfInheritanceOverride,        OPTIONAL
    IN LPCTSTR lpszMDPath                   OPTIONAL
    )
/*++

Routine Description:

    Store data as string

Arguments:

    DWORD dwID                   : Property ID
    CStringListEx & strlValue    : Value to be written
    BOOL * pfInheritanceOverride : NULL or forces inheritance on/off
    LPCTSTR lpszMDPath           : Optional path (or NULL or "")

Return Value:

    HRESULT

--*/
{
    DWORD cCharacters;
    LPTSTR lpstr = NULL;

    //
    // Flatten value
    //
    strlValue.ConvertToDoubleNullList(cCharacters, lpstr);

    HRESULT hr = SetPropertyValue(
        dwID,
        cCharacters * sizeof(TCHAR),
        (void *)lpstr,
        pfInheritanceOverride,
        lpszMDPath
        );

    delete [] lpstr;

    return hr;
}


HRESULT 
CMetaKey::SetValue(
    IN DWORD dwID,
    IN CBlob & blValue,
    IN BOOL * pfInheritanceOverride,    OPTIONAL     
    IN LPCTSTR lpszMDPath               OPTIONAL        
    )
/*++

Routine Description:

    Store data as binary

Arguments:

    DWORD dwID                   : Property ID
    CBlob & blValue              : Value to be written
    BOOL * pfInheritanceOverride : NULL or forces inheritance on/off
    LPCTSTR lpszMDPath           : Optional path (or NULL or "")

Return Value:

    HRESULT

--*/
{
    return SetPropertyValue(
        dwID,
        blValue.GetSize(),
        (void *)blValue.GetData(),
        pfInheritanceOverride,
        lpszMDPath
        );
}



HRESULT
CMetaKey::DeleteValue(
    DWORD   dwID,
    LPCTSTR lpszMDPath      OPTIONAL
    )
/*++

Routine Description:

    Delete data

Arguments:

    DWORD   dwID            : Property ID of property to be deleted
    LPCTSTR lpszMDPath      : Optional path (or NULL or "")

Return Value:

    HRESULT

--*/
{
    ASSURE_PROPER_INTERFACE();
    ASSURE_OPEN_KEY();

    METADATA_RECORD mdRecord;
    FETCH_PROPERTY_DATA_OR_FAIL(dwID, mdRecord);

    return DeleteData(
        m_hKey,
        lpszMDPath,
        mdRecord.dwMDIdentifier,
        mdRecord.dwMDDataType
        );
}



HRESULT 
CMetaKey::DoesPathExist(
    IN LPCTSTR lpszMDPath
    )
/*++

Routine Description:

    Determine if the path exists

Arguments:

    LPCTSTR lpszMDPath      : Relative path off the open key

Return Value:

    HRESULT, or S_OK if the path exists.

--*/
{
    ASSURE_PROPER_INTERFACE();
    ASSURE_OPEN_KEY();

    FILETIME ft;

    return GetLastChangeTime(m_hKey, lpszMDPath, &ft, FALSE);
}



HRESULT
CMetaInterface::Regenerate()
/*++

Routine Description:

    Attempt to recreate the interface pointer.  This assumes that the interface
    had been successfully created before, but has become invalid at some
    point afterwards.

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    ASSERT_PTR(m_pInterface);           // Must have been initialised

    SAFE_RELEASE(m_pInterface);

    m_hrInterface = Create();

    return m_hrInterface;
}



//
// CWamInterface class
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



CWamInterface::CWamInterface(
    IN CComAuthInfo * pAuthInfo         OPTIONAL
    )
/*++

Routine Description:

    Construct and initialize the interface.

Arguments:

    CComAuthInfo * pAuthInfo   : Auth info.  NULL indicates the local computer.

Return Value:

    N/A

--*/
    : CIISInterface(pAuthInfo),
      m_pInterface(NULL),
      m_fSupportsPooledProc(FALSE)
{
    //
    // Initialize the interface
    //
    m_hrInterface = Create();
}



CWamInterface::CWamInterface(
    IN CWamInterface * pInterface
    )
/*++

Routine Description:

    Construct from existing interface (copy constructor)

Arguments:

    CWamInterface * pInterface  : Existing interface

Return Value:

    N/A

--*/
    : CIISInterface(&pInterface->m_auth, pInterface->m_hrInterface),
      m_pInterface(pInterface->m_pInterface),
      m_fSupportsPooledProc(FALSE)
{
    ASSERT_PTR(m_pInterface);
    m_pInterface->AddRef();
}



CWamInterface::~CWamInterface()
/*++

Routine Description:

    Destructor -- releases the interface.

Arguments:

    N/A

Return Value:

    N/A

--*/
{
    SAFE_RELEASE(m_pInterface);
}



/* protected */
HRESULT
CWamInterface::Create()
/*++

Routine Description:

    Create the interface with DCOM

Arguments:

    None

Return Value:

    HRESULT 

Notes:

    First, it will attempt to create the new interface, if it
    fails, it will attempt to create the downlevel interface

--*/
{
    CLSID rgCLSID[2];
    IID   rgIID[2];

    rgCLSID[1] = rgCLSID[0] = CLSID_WamAdmin;
    rgIID[0] = IID_IWamAdmin2;
    rgIID[1] = IID_IWamAdmin;
    
    ASSERT(ARRAY_SIZE(rgCLSID) == ARRAY_SIZE(rgIID));
    int cInterfaces = ARRAY_SIZE(rgCLSID);
    int iInterface;
    
    HRESULT hr = CIISInterface::Create(
        cInterfaces,
        rgIID, 
        rgCLSID, 
        &iInterface, 
        (IUnknown **)&m_pInterface
        );

    if (SUCCEEDED(hr))
    {
        //
        // Only supported on IWamAdmin2
        //
        m_fSupportsPooledProc = (rgIID[iInterface] == IID_IWamAdmin2);
    }

    return hr;
}



HRESULT 
CWamInterface::AppCreate( 
    IN LPCTSTR szMDPath,
    IN DWORD   dwAppProtection
    )
/*++

Routine Description:

    Create  application

Arguments:

    LPCTSTR szMDPath      : Metabase path
    DWORD dwAppProtection : APP_INPROC     to create in-proc app
                            APP_OUTOFPROC  to create out-of-proc app
                            APP_POOLEDPROC to create a pooled-proc app

Return Value:

    HRESULT (ERROR_INVALID_PARAMETER if unsupported protection state is requested)

--*/
{
    if (m_fSupportsPooledProc)
    {
        //
        // Interface pointer is really IWamAdmin2, so call the new method
        //
        return ((IWamAdmin2 *)m_pInterface)->AppCreate2(szMDPath, dwAppProtection);
    }

    //
    // Call the downlevel API
    //
    if (dwAppProtection == APP_INPROC || dwAppProtection == APP_OUTOFPROC)
    {
        BOOL fInProc = (dwAppProtection == APP_INPROC);
    
        ASSERT_PTR(m_pInterface);
        return m_pInterface->AppCreate(szMDPath, fInProc);
    }

    return CError(ERROR_INVALID_PARAMETER);
}



//
// CMetaback Class
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<


const LPCTSTR CMetaBack::s_szMasterAppRoot =\
    SZ_MBN_SEP_STR SZ_MBN_MACHINE SZ_MBN_SEP_STR SZ_MBN_WEB;


CMetaBack::CMetaBack(
    IN CComAuthInfo * pAuthInfo        OPTIONAL
    )
/*++

Routine Description:

    Constructor for metabase backup/restore operations class.  This object
    is both a WAM interface and a METABASE interface.

Arguments:

    CComAuthInfo * pAuthInfo    : Auth info.  NULL indicates the local computer.

Return Value:

    N/A

--*/
    : m_dwIndex(0),
      CMetaInterface(pAuthInfo),
      CWamInterface(pAuthInfo)
{
}



/* virtual */
BOOL 
CMetaBack::Succeeded() const
/*++

Routine Description:

    Determine if object was constructed successfully.

Arguments:

    None

Return Value:

    TRUE for success, FALSE for failure

--*/
{
    return CMetaInterface::Succeeded() && CWamInterface::Succeeded();
}



/* virtual */
HRESULT 
CMetaBack::QueryResult() const
/*++

Routine Description:

    Return the construction error for this object

Arguments:

    None

Return Value:

    HRESULT from construction errors

--*/
{
    //
    // Both interfaces must have constructed successfully
    //
    HRESULT hr = CMetaInterface::QueryResult();

    if (SUCCEEDED(hr))
    {
        hr = CWamInterface::QueryResult();
    }    

    return hr;
}



HRESULT 
CMetaBack::Restore(
    IN LPCTSTR lpszLocation,
    IN DWORD dwVersion
    )
/*++

Routine Description:

    Restore metabase

Arguments:

    DWORD dwVersion         : Backup version
    LPCTSTR lpszLocation    : Backup location

Return Value:

    HRESULT

--*/
{
    //
    // Backup and restore the application information from a restore
    //
    CString strPath(s_szMasterAppRoot);
    HRESULT hr = AppDeleteRecoverable(strPath, TRUE);

    if (SUCCEEDED(hr))
    {
        hr = CMetaInterface::Restore(lpszLocation, dwVersion, 0);

        if (SUCCEEDED(hr))
        {
            hr = AppRecover(strPath, TRUE);
        }
    }

    return hr;
}



//
// CIISSvcControl class
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



CIISSvcControl::CIISSvcControl(
    IN CComAuthInfo * pAuthInfo        OPTIONAL
    )
/*++

Routine Description:

    Construct and initialize the interface.

Arguments:

    CComAuthInfo * pAuthInfo    : Auth info.  NULL indicates the local computer.

Return Value:

    N/A

--*/
    : CIISInterface(pAuthInfo),
      m_pInterface(NULL)
{
    //
    // Initialize the interface
    //
    m_hrInterface = Create();
}



CIISSvcControl::CIISSvcControl(
    IN CIISSvcControl * pInterface
    )
/*++

Routine Description:

    Construct from existing interface (copy constructor)

Arguments:

    CIISSvcControl * pInterface  : Existing interface

Return Value:

    N/A

--*/
    : CIISInterface(&pInterface->m_auth, pInterface->m_hrInterface),
      m_pInterface(pInterface->m_pInterface)
{
    ASSERT_PTR(m_pInterface);
    m_pInterface->AddRef();
}



CIISSvcControl::~CIISSvcControl()
/*++

Routine Description:

    Destructor -- releases the interface.

Arguments:

    N/A

Return Value:

    N/A

--*/
{
    SAFE_RELEASE(m_pInterface);
}


#ifdef KEVLAR
//
// CWebCluster class
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



CWebCluster::CWebCluster(
    IN CComAuthInfo * pAuthInfo        OPTIONAL
    )
/*++

Routine Description:

    Construct and initialize the interface.

Arguments:

    CComAuthInfo * pAuthInfo : Authentication information.  
                               NULL indicates the local computer
    
Return Value:

    N/A

--*/
    : CIISInterface(pAuthInfo),
      m_pInterface(NULL)
{
    //
    // Initialize the interface
    //
    m_hrInterface = Create();
}



/* virtual */
CWebCluster::~CWebCluster()
/*++

Routine Description:

    Destructor -- releases the interface.

Arguments:

    N/A

Return Value:

    N/A

--*/
{
    SAFE_RELEASE(m_pInterface);
}

#endif // KEVLAR

//
// CMetaEnumerator Clas
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



CMetaEnumerator::CMetaEnumerator(
    IN CComAuthInfo * pAuthInfo     OPTIONAL,
    IN LPCTSTR lpszMDPath           OPTIONAL,
    IN METADATA_HANDLE hkBase       OPTIONAL
    )
/*++

Routine Description:

    Metabase enumerator constructor.  This constructor creates a new interface
    and opens a key.

Arguments:

    CComAuthInfo * pAuthInfo : Auth info.  NULL indicates the local computer.
    LPCTSTR lpszMDPath       : Metabase path
    METADATA_HANDLE hkBase   : Metabase handle

Return Value:

    N/A

--*/
    : CMetaKey(pAuthInfo, lpszMDPath, METADATA_PERMISSION_READ, hkBase),
      m_dwIndex(0L)
{
}



CMetaEnumerator::CMetaEnumerator(
    IN CMetaInterface * pInterface,
    IN LPCTSTR lpszMDPath,                  OPTIONAL
    IN METADATA_HANDLE hkBase               OPTIONAL
    )
/*++

Routine Description:

    Metabase enumerator constructor.  This constructor uses an existing
    interface and opens a key.

Arguments:

    CMetaInterface * pInterface : Existing interface
    LPCTSTR lpszMDPath          : Metabase path
    METADATA_HANDLE hkBase      : Metabase handle

Return Value:

    N/A

--*/
    : CMetaKey(pInterface, lpszMDPath, METADATA_PERMISSION_READ, hkBase),
      m_dwIndex(0L)
{
}



CMetaEnumerator::CMetaEnumerator(
    IN BOOL fOwnKey,
    IN CMetaKey * pKey
    )
/*++

Routine Description:

    Metabase enumerator constructor.  This constructor uses an existing
    interface and open key.

Arguments:

    BOOL fOwnKey            : TRUE if we own the key (destructor will close)
    CMetaKey * pKey         : Open key

Return Value:

    N/A

--*/
    : CMetaKey(fOwnKey, pKey),
      m_dwIndex(0L)
{
}



HRESULT
CMetaEnumerator::Next(
    OUT CString & strKey,
    IN  LPCTSTR lpszMDPath      OPTIONAL
    )
/*++

Routine Description:

    Get the next subkey

Arguments:

    CString & str           Returns keyname
    LPCTSTR lpszMDPath      Optional subpath

Return Value:

    HRESULT

--*/
{
    ASSURE_PROPER_INTERFACE();
    ASSURE_OPEN_KEY();

    TCHAR buf[MAX_PATH];
    HRESULT hr = EnumKeys(m_hKey, lpszMDPath, buf, m_dwIndex++);
    if (SUCCEEDED(hr))
       strKey = buf;

    return hr;        
}



HRESULT
CMetaEnumerator::Next(
    OUT DWORD & dwKey,
    OUT CString & strKey,
    IN  LPCTSTR lpszMDPath      OPTIONAL
    )
/*++

Routine Description:

    Get the next subkey as a DWORD.  This skips non-numeric
    keynames (including 0) until the first numeric key name 

Arguments:

    DWORD & dwKey           Numeric key
    CString & strKey        Same key in string format
    LPCTSTR lpszMDPath      Optional subpath

Return Value:

    HRESULT

--*/
{
    ASSURE_PROPER_INTERFACE();
    ASSURE_OPEN_KEY();

    HRESULT hr;
    TCHAR buf[MAX_PATH];

    while (TRUE)
    {
        if (SUCCEEDED(hr = EnumKeys(m_hKey, lpszMDPath, buf, m_dwIndex++)))
        {
            if (0 != (dwKey = _ttoi(buf)))
            {
               strKey = buf;
               break;
            }
        }
        else
           break;
    }
    
    return hr;        
}


// This method moved from inline to remove dependency on IIDs and CLSIDs
HRESULT 
CIISSvcControl::Create()
{
    return CIISInterface::Create(
        1,
        &IID_IIisServiceControl, 
        &CLSID_IisServiceControl, 
        NULL, 
        (IUnknown **)&m_pInterface
        );
}


//
// CIISApplication class
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<</



CIISApplication::CIISApplication(
    IN CComAuthInfo * pAuthInfo   OPTIONAL,
    IN LPCTSTR lpszMetapath
    )
/*++

Routine Description:

    Construct IIS application.        

Arguments:

    CComAuthInfo * pAuthInfo : Authentication info.  NULL indicates the
                               local computer.
    LPCTSTR lpszMetapath     : Metabase path

Return Value:

    N/A

--*/
    : CWamInterface(pAuthInfo),
      CMetaKey(pAuthInfo),
      m_dwProcessProtection(APP_INPROC),
      m_dwAppState(APPSTATUS_NOTDEFINED),
      m_strFriendlyName(),
      m_strAppRoot(),
      m_strWamPath(lpszMetapath)
{
    CommonConstruct();
}



void
CIISApplication::CommonConstruct()
/*++

Routine Description:

    Perform common construction

Arguments:

    None

Return Value:

    None

--*/
{
    //
    // Munge the metapath so that WAM doesn't cough up a hairball.
    //


    //
    // BUGBUG: CleanMetaPath() disabled currently
    //

    if (m_strWamPath[0] != SZ_MBN_SEP_CHAR)
    {
        m_strWamPath = SZ_MBN_SEP_CHAR + m_strWamPath;
    }

    do
    {
        m_hrApp = CWamInterface::QueryResult();

        if (FAILED(m_hrApp))
        {
            break;
        }

        m_hrApp = RefreshAppState();

        if (HRESULT_CODE(m_hrApp) == ERROR_PATH_NOT_FOUND)
        {
            //
            // "Path Not Found" errors are acceptable, since
            // the application may not yet exist.
            //
            m_hrApp = S_OK;
        }
    }
    while(FALSE);
}



/* virtual */
BOOL 
CIISApplication::Succeeded() const
/*++

Routine Description:

    Determine if object was constructed successfully

Arguments:

    None

Return Value:

    TRUE for success, FALSE for failure

--*/
{
    return CMetaInterface::Succeeded() 
        && CWamInterface::Succeeded()
        && SUCCEEDED(m_hrApp);
}



/* virtual */
HRESULT 
CIISApplication::QueryResult() const
/*++

Routine Description:

    Return the construction error for this object

Arguments:

    None

Return Value:

    HRESULT from construction errors

--*/
{
    //
    // Both interfaces must have constructed successfully
    //
    HRESULT hr = CMetaInterface::QueryResult();

    if (SUCCEEDED(hr))
    {
        hr = CWamInterface::QueryResult();

        if (SUCCEEDED(hr))
        {
            hr = m_hrApp;
        }
    }    

    return hr;
}



HRESULT 
CIISApplication::RefreshAppState()
/*++

Routine Description:

    Refresh the application state

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    ASSERT(!m_strWamPath.IsEmpty());

    HRESULT hr, hrKeys;

    hr = AppGetStatus(m_strWamPath, &m_dwAppState);

    if (FAILED(hr))
    {
        m_dwAppState = APPSTATUS_NOTDEFINED;
    }

    m_strAppRoot.Empty();
    hrKeys = QueryValue(MD_APP_ROOT, m_strAppRoot, NULL, m_strWamPath);

    m_dwProcessProtection = APP_INPROC;
    hrKeys = QueryValue(
        MD_APP_ISOLATED, 
        m_dwProcessProtection, 
        NULL, 
        m_strWamPath
        );

    m_strFriendlyName.Empty();
    hrKeys = QueryValue(
        MD_APP_FRIENDLY_NAME, 
        m_strFriendlyName, 
        NULL, 
        m_strWamPath
        );

    return hr;
}



HRESULT 
CIISApplication::Create(
    IN LPCTSTR lpszName,        OPTIONAL
    IN DWORD dwAppProtection
    )
/*++

Routine Description:

    Create the application

Arguments:

    LPCTSTR lpszName      : Application name
    DWORD dwAppProtection : APP_INPROC     to create in-proc app
                            APP_OUTOFPROC  to create out-of-proc app
                            APP_POOLEDPROC to create a pooled-proc app

Return Value:

    HRESULT

--*/
{
    ASSERT(!m_strWamPath.IsEmpty());
    HRESULT hr = AppCreate(m_strWamPath, dwAppProtection);

    if (SUCCEEDED(hr))
    {
        //
        // Write the friendly app name, which we maintain
        // ourselves.  Empty it first, because we might
        // have picked up a name from inheritance.
        //
        m_strFriendlyName.Empty(); 
        hr = WriteFriendlyName(lpszName);

        RefreshAppState();
    }

    return hr;
}



HRESULT 
CIISApplication::WriteFriendlyName(
    IN LPCTSTR lpszName
    )
/*++

Routine Description:

    Write the friendly name.  This will not write anything
    if the name is the same as it was

Arguments:

    LPCTSTR lpszName        : New friendly name

Return Value:

    HRESULT

--*/
{
    HRESULT hr = S_OK;    

    if (m_strFriendlyName.CompareNoCase(lpszName) != 0)
    {
        hr = Open(METADATA_PERMISSION_WRITE, m_strWamPath);

        if (SUCCEEDED(hr))
        {
            ASSERT_PTR(lpszName);

            CString str(lpszName);    
            hr = SetValue(MD_APP_FRIENDLY_NAME, str);
            Close();

            if (SUCCEEDED(hr))
            {
                m_strFriendlyName = lpszName;
            }
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\common2\iiscstring.cpp ===
//
//    IISCStringImpl.cpp
//
//////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"

#pragma warning(disable:4786) // Disable warning for names > 256

#include "common.h"
#include <algorithm>
#include <deque>
#include <TCHAR.h>
#include "IISCString.h"

//////////////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////////
// Constructors
///////////////////////////////////////////////////////////////////////////
CString::CString()
      :  std::basic_string<TCHAR>() 
{
}

CString::CString(const CString& strInput)
      :  std::basic_string<TCHAR>(strInput) 
{
}

CString::CString(const std::basic_string<TCHAR>& strInput)
      :  std::basic_string<TCHAR>(strInput) 
{
}

CString::CString(TCHAR ch, int nRepeat /* = 1*/)
      :  std::basic_string<TCHAR>(nRepeat, ch) 
{
}

CString::CString(LPCTSTR p)
      :  std::basic_string<TCHAR>(p) 
{
}

#ifdef _UNICODE
CString::CString(LPCSTR strInput)
{
   int len = strlen(strInput);
   TCHAR * buf = (TCHAR *)_alloca(len * (sizeof(TCHAR) + 1));
   if (0 != MultiByteToWideChar(CP_THREAD_ACP, MB_PRECOMPOSED,
      strInput, len, buf, len))
   {
      assign(buf);
   }
   else
   {
      ATLASSERT(FALSE);
   }
}
#endif

#ifndef _UNICODE
CString::CString(LPCWSTR strInput)
{
   int len = wstrlen(strInput);
   int buflen = len * (sizeof(TCHAR) + 1);
   TCHAR * buf = (TCHAR *)_alloca(buflen);
   if (0 != WideCharToMultiByte(CP_THREAD_ACP, 0,
      strInput, len, buf, buflen))
   {
      assign(buf);
   }
   else
   {
      ATLASSERT(FALSE);
   }
}
#endif

CString::CString(const CComBSTR& bstr)
{
   assign((LPCTSTR)bstr.m_str);
}

CString::~CString()
{
}

///////////////////////////////////////////////////////////////////////////
// The string as an array
///////////////////////////////////////////////////////////////////////////

int CString::GetLength() const
{
   return length();
};

bool CString::IsEmpty() const
{
   return empty();
};

void CString::Empty()
{
   erase();
};

TCHAR CString::GetAt(int nIndex) const
{
	ATLASSERT(nIndex >= 0);
   return at(nIndex);
};

TCHAR CString::operator[](int nIndex) const
{
	// same as GetAt
	ATLASSERT(nIndex >= 0);
	return at(nIndex);
}

void CString::SetAt(int nIndex, TCHAR ch)
{
   at(nIndex) = ch;
};

const CString& CString::operator=(const CString& stringSrc)
{
   assign(stringSrc);
	return *this;
}

const CString& CString::operator=(LPCTSTR p)
{
   // Here we will have a problem if NULL pointer is passed because
   // later STL will call wcslen(NULL) which uses *p without test.
   // We will emulate the result by erasing current string
   if (p == NULL)
      erase();
   // another problem is when we assign string to self, like str = str.c_str()
   // STL deletes data and then assign it resulting in garbage
   else if (p != this->data())
      assign(p);
   return *this;
}

#ifdef _UNICODE
const CString& CString::operator=(const unsigned char * lpsz)
{ 
   int len = strlen((const char *)lpsz);
   TCHAR * buf = (TCHAR *)_alloca(len * (sizeof(TCHAR) + 1));
   if (0 != MultiByteToWideChar(CP_THREAD_ACP, MB_PRECOMPOSED, (const char *)lpsz, -1, buf, len))
   {
      assign(buf);
   }
   else
   {
      ATLASSERT(FALSE);
   }
   return *this; 
}
#endif

const CString& CString::operator=(TCHAR c)
{
   assign(1, c);
   return *this;
}

#ifdef _UNICODE
const CString& CString::operator+=(char ch)
{ 
   *this += (TCHAR)ch; 
   return *this; 
}

const CString& CString::operator=(char ch)
{ 
   *this = (TCHAR)ch; 
   return *this; 
}

CString __stdcall operator+(const CString& string, char ch)
{ 
   return string + (TCHAR)ch; 
}

CString __stdcall operator+(char ch, const CString& string)
{ 
   return (TCHAR)ch + string; 
}
#endif

const CString& CString::operator+=(TCHAR ch)
{ 
   append(1, ch);
   return *this;
}

const CString& CString::operator+=(const CString& s)
{ 
   append(s); 
   return *this; 
}

const CString& CString::operator+=(LPCTSTR p)
{ 
   append(p); 
   return *this; 
}

static int __stdcall _LoadString(HINSTANCE hInstance, UINT nID, LPTSTR lpszBuf, UINT nMaxBuf)
{
#ifdef _DEBUG
	// LoadString without annoying warning from the Debug kernel if the
	//  segment containing the string is not present
	if (::FindResource(hInstance, MAKEINTRESOURCE((nID>>4)+1), RT_STRING) == NULL)
	{
		lpszBuf[0] = '\0';
		return 0; // not found
	}
#endif //_DEBUG
	int nLen = ::LoadString(hInstance, nID, lpszBuf, nMaxBuf);
	if (nLen == 0)
		lpszBuf[0] = '\0';
	return nLen;
}

#ifdef _UNICODE
#define CHAR_FUDGE 1    // one TCHAR unused is good enough
#else
#define CHAR_FUDGE 2    // two BYTES unused for case of DBC last char
#endif

#define INITIAL_SIZE    256

BOOL CString::LoadString(HINSTANCE hInstance, UINT id)
{
	// try fixed buffer first (to avoid wasting space in the heap)
	TCHAR szTemp[INITIAL_SIZE];
	int nCount =  sizeof(szTemp) / sizeof(szTemp[0]);
	int nLen = _LoadString(hInstance, id, szTemp, nCount);
	if (nCount - nLen > CHAR_FUDGE)
	{
		*this = szTemp;
		return nLen > 0;
	}

	// try buffer size of 512, then larger size until entire string is retrieved
	int nSize = INITIAL_SIZE;
   LPTSTR p = NULL;
	do
	{
		nSize += INITIAL_SIZE;
      p = get_allocator().allocate(nSize, p);
		nLen = _LoadString(hInstance, id, p, nSize - 1);
	} while (nSize - nLen <= CHAR_FUDGE);
   if (nLen > 0)
      assign(p, nLen);

	return nLen > 0;
}

///////////////////////////////////////////////////////////////////////////
// Comparison
///////////////////////////////////////////////////////////////////////////

int CString::Compare(const TCHAR * psz) const
{
   if (psz == NULL)
      return this->empty() ? 0 : 1;
   return compare(psz);
};

int CString::CompareNoCase(const TCHAR * psz) const
{
   if (psz == NULL)
      return this->empty() ? 0 : 1;
   return _tcsicmp(c_str(), psz);
};

int CString::Collate(const TCHAR * psz) const
{
   if (psz == NULL)
      return this->empty() ? 0 : 1;
   return _tcscoll(c_str(), psz);
};

///////////////////////////////////////////////////////////////////////////
// Extraction
///////////////////////////////////////////////////////////////////////////

CString CString::Mid(int nFirst) const
{
   return substr(nFirst);
};

CString CString::Mid(int nFirst, int nCount) const
{
   return substr(nFirst, nCount);
};

CString CString::Left(int nCount) const
{
   return substr(0, nCount);
};

CString CString::Right(int nCount) const
{
   return substr(length() - nCount, nCount);
};

CString CString::SpanIncluding(const TCHAR * pszCharSet) const
{
   return substr(0, find_first_not_of(pszCharSet));
};

CString CString::SpanExcluding(const TCHAR * pszCharSet) const
{
   return substr(0, find_first_of(pszCharSet));
};

///////////////////////////////////////////////////////////////////////////
// Other Conversions
///////////////////////////////////////////////////////////////////////////

void CString::MakeUpper()
{
   std::for_each(begin(), end(), _totupper);
};

void CString::MakeLower()
{
   std::for_each(begin(), end(), _totlower);
};

void CString::MakeReverse()
{
   std::reverse(begin(), end());
};

void CString::TrimLeft()
{
   while (_istspace(at(0)))
	   erase(0, 1);
};

void CString::TrimRight()
{
   while (_istspace(at(length() - 1)))
	   erase(length() - 1, 1);
};

#define BUFFER_SIZE     1024

void __cdecl CString::FormatV(LPCTSTR lpszFormat, va_list argList)
{
   TCHAR buf[BUFFER_SIZE];
   if (-1 != _vsntprintf(buf, BUFFER_SIZE, lpszFormat, argList))
   {
      assign(buf);
   }
}

// formatting (using wsprintf style formatting)
void __cdecl CString::Format(LPCTSTR lpszFormat, ...)
{
	va_list argList;
	va_start(argList, lpszFormat);
	FormatV(lpszFormat, argList);
	va_end(argList);
}

void __cdecl CString::Format(HINSTANCE hInst, UINT nFormatID, ...)
{
	CString strFormat;
	BOOL bRet = strFormat.LoadString(hInst, nFormatID);
	bRet;	// ref
	ATLASSERT(bRet != 0);

	va_list argList;
	va_start(argList, nFormatID);
	FormatV(strFormat, argList);
	va_end(argList);
}

// formatting (using FormatMessage style formatting)
BOOL CString::FormatMessage(LPCTSTR lpszFormat, ...)
{
	// format message into temporary buffer lpszTemp
	va_list argList;
	va_start(argList, lpszFormat);
	LPTSTR lpszTemp;
	BOOL bRet = TRUE;

	if (::FormatMessage(FORMAT_MESSAGE_FROM_STRING|FORMAT_MESSAGE_ALLOCATE_BUFFER,
		lpszFormat, 0, 0, (LPTSTR)&lpszTemp, 0, &argList) == 0 ||
		lpszTemp == NULL)
		bRet = FALSE;

	// assign lpszTemp into the resulting string and free the temporary
	*this = lpszTemp;
	LocalFree(lpszTemp);
	va_end(argList);
	return bRet;
}

BOOL CString::FormatMessage(HINSTANCE hInst, UINT nFormatID, ...)
{
	// get format string from string table
	CString strFormat;
	BOOL bRetTmp = strFormat.LoadString(hInst, nFormatID);
	bRetTmp;	// ref
	ATLASSERT(bRetTmp != 0);

	// format message into temporary buffer lpszTemp
	va_list argList;
	va_start(argList, nFormatID);
	LPTSTR lpszTemp;
	BOOL bRet = TRUE;

	if (::FormatMessage(
            FORMAT_MESSAGE_FROM_STRING|FORMAT_MESSAGE_ALLOCATE_BUFFER,
		      strFormat, 0, 0, (LPTSTR)&lpszTemp, 0, &argList) == 0 || lpszTemp == NULL
      )
		bRet = FALSE;

	// assign lpszTemp into the resulting string and free lpszTemp
	*this = lpszTemp;
	LocalFree(lpszTemp);
	va_end(argList);
	return bRet;
}

///////////////////////////////////////////////////////////////////////////
// Searching
///////////////////////////////////////////////////////////////////////////
int CString::Find(TCHAR ch) const
{
   return find(ch);
};

int CString::Find(const TCHAR * psz) const
{
   if (psz == NULL)
      return -1;
   return find(psz);
};

int CString::ReverseFind(TCHAR ch) const
{
   return rfind(ch);
};

int CString::FindOneOf(const TCHAR * psz) const
{
   if (psz == NULL)
      return -1;
   return find_first_of(psz);
};

///////////////////////////////////////////////////////////////////////////
// Operators
///////////////////////////////////////////////////////////////////////////

CString::operator const TCHAR *() const
{ 
   return c_str(); 
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\common2\mdkeys.h ===
/*++

   Copyright    (c)    1994-2000    Microsoft Corporation

   Module Name :

        mdkeys.h

   Abstract:

        Metabase key wrapper classes

   Author:

        Ronald Meijer (ronaldm)
        Sergei Antonov (sergeia)

   Project:

        Internet Services Manager

   Revision History:
        2/17/2000    sergeia     removed dependency on MFC

--*/

#ifndef _MDKEYS_H_
#define _MDKEYS_H_

//
// Include Files
//
#include <iadmw.h>
#include <iwamreg.h>
#include <iiscnfgp.h>
#include <winsvc.h>
#include <iisrsta.h>

//
// Forward definitions
//
class CBlob;

//
// Use this instance number to denote the master
//
#define MASTER_INSTANCE       (0)
#define IS_MASTER_INSTANCE(i) (i == MASTER_INSTANCE)

//
// Metabase node constants, used for static initialization of const
// strings further down.  Defined here with #defines for easier 
// concatenation later.
//
#define SZ_MBN_MACHINE      _T("LM")
#define SZ_MBN_FILTERS      _T("Filters")
#define SZ_MBN_MIMEMAP      _T("MimeMap")
#define SZ_MBN_TEMPLATES    _T("Templates")
#define SZ_MBN_INFO         _T("Info")
#define SZ_MBN_ROOT         _T("Root")
#define SZ_MBN_COMPRESSION  _T("Compression")
#define SZ_MBN_PARAMETERS   _T("Parameters")
#define SZ_MBN_SEP_CHAR     _T('/')
#define SZ_MBN_SEP_STR      _T("/")
#define SZ_MBN_ANYSEP_STR   _T("/\\")
#define SZ_MBN_WEB          _T("W3SVC")
#define SZ_MBN_FTP          _T("MSFTPSVC")


class CIISInterface;

class _EXPORT CComAuthInfo
/*++

Class Description:

    Server/authentication information.  Contains optional 
    impersonation parameters. Typically used in the construction in 
    CIISInterface.

Public Interface:

    CComAuthInfo            : Constructor.  Impersonation optional
    operator=               : Assignment operators
    CreateServerInfoStruct  : Helper function for use in COM
    FreeServerInfoStruct    : As above.

Notes:

    Because there's an operator for a pointer to itself and because
    CIISInterface copies the information at construction time, a 
    CComAuthInfo can safely be constructed on the stack as a parameter
    to CIISInterface derived classes.

--*/
{
//
// Constructor/Destructor
//
public:
    //
    // Standard Constructor.  NULL for servername indicates
    // local computer.
    //
    CComAuthInfo(
        LPCOLESTR lpszServerName  = NULL,    
        LPCOLESTR lpszUserName    = NULL,
        LPCOLESTR lpszPassword    = NULL
        );

    //
    // Copy Constructors
    //
    CComAuthInfo(
        CComAuthInfo & auth
        );

    CComAuthInfo(
        CComAuthInfo * pAuthInfo OPTIONAL
        );

//
// Assignment operators
//
public:
    CComAuthInfo & operator =(CComAuthInfo & auth);
    CComAuthInfo & operator =(CComAuthInfo * pAuthInfo);
    CComAuthInfo & operator =(LPCTSTR lpszServerName);

//
// Access
//
public:
    COSERVERINFO * CreateServerInfoStruct() const;
    COSERVERINFO * CreateServerInfoStruct(DWORD dwAuthnLevel) const;
    void FreeServerInfoStruct(COSERVERINFO * pServerInfo) const;

    LPOLESTR QueryServerName() const { return m_bstrServerName; }
    LPOLESTR QueryUserName() const { return m_bstrUserName; }
    LPOLESTR QueryPassword() const { return m_bstrPassword; }
    BOOL     IsLocal() const { return m_fLocal; }
    BOOL     UsesImpersonation() const { return m_bstrUserName.Length() > 0; }
    void     SetImpersonation(LPCOLESTR lpszUser, LPCOLESTR lpszPassword);
    void     RemoveImpersonation();
    void     StorePassword(LPCOLESTR lpszPassword);

public:
    HRESULT  ApplyProxyBlanket(IUnknown * pInterface);
    
//
// Conversion Operators
//
public:
    operator LPOLESTR() { return QueryServerName(); }
    operator CComAuthInfo *() { return this; }

//
// Static Helpers
//
public:
    //
    // Given domain\username, split into user name and domain
    //
    static BOOL SplitUserNameAndDomain(
        CString & strUserName,
        CString & strDomainName
        );

    //
    // Verify username and password are correct
    //
    static DWORD VerifyUserPassword(
        LPCTSTR lpstrUserName,
        LPCTSTR lpstrPassword
        );

protected:
    //
    // Store the computer name (NULL for local computer)
    //
    void SetComputerName(
        LPCOLESTR lpszServerName   OPTIONAL
        );

private:
    CComBSTR    m_bstrServerName;
    CComBSTR    m_bstrUserName;
    CComBSTR    m_bstrPassword;
    BOOL        m_fLocal;
};

class _EXPORT CMetabasePath
/*++

Class Description:

    Metabase path class.  This is a helper class to build complete
    metabase paths out of various components.

    Example: CMetaKey(CComAuthInfo("ronaldm3"), CMetabasePath(SZ_WEBSVC, dwInstance, _T("root")));

--*/
{
    //
    // Metabase components in order
    //
    enum
    {
        iBlank,                    // Sep 0
        iMachine,                  // LM
        iService,                  // e.g. lm/w3svc
        iInstance,                 // e.g. lm/w3svc/1
        iRootDirectory,            // e.g. lm/w3svc/1/root
        iSubDirectory,             // e.g. lm/w3vsc/1/root/foobar
    };

//
// Metabase helper functions.
//
public:
    //
    // Clean metabase path
    //
    static LPCTSTR CleanMetaPath(
        CString & strMetaRoot
        );

    static LPCTSTR CleanMetaPath(
        CMetabasePath & path
        );

    //
    // Find the instance number from the given metabase path
    //
    static DWORD GetInstanceNumber(LPCTSTR lpszMDPath);

    //
    // Get the last nodename in the given metabase path
    //
    static LPCTSTR GetLastNodeName(
         LPCTSTR lpszMDPath,
        CString & strNodeName
        );

    //
    // Truncate the path at a given sub path
    //
    static LPCTSTR TruncatePath(
        int     nLevel,          
        LPCTSTR lpszMDPath,
        CString & strNewPath,
        CString * pstrRemainder = NULL
        );

    static LPCTSTR GetMachinePath(
        LPCTSTR lpszMDPath,
        CString & strNewPath,
        CString * pstrRemainder = NULL
        );

    static LPCTSTR GetServicePath(
        LPCTSTR lpszMDPath,
        CString & strNewPath,
        CString * pstrRemainder = NULL
        );

    static LPCTSTR GetInstancePath(
        LPCTSTR lpszMDPath,
        CString & strNewPath,
        CString * pstrRemainder = NULL
        );

    static LPCTSTR GetRootPath(
        LPCTSTR lpszMDPath,
        CString & strNewPath,
        CString * pstrRemainder = NULL
        );

    //
    // Determine the path to the info node that's relevant
    // to this metabase path.
    //
    static LPCTSTR GetServiceInfoPath(
        LPCTSTR lpszMDPath,
        CString & strInfoPath,   
        LPCTSTR lpszDefService  = SZ_MBN_WEB
        );

    //
    // Change path to parent node
    //
    static LPCTSTR ConvertToParentPath(
        CString & strMetaPath
        );

    static LPCTSTR ConvertToParentPath(
        CMetabasePath& path
        );

    //
    // Determine if the path describes a home directory path
    //
    static BOOL IsHomeDirectoryPath(
        LPCTSTR lpszMDPath
        );

    //
    // Determine if the path describes the 'master' instance (site)
    //
    static BOOL IsMasterInstance(
        LPCTSTR lpszMDPath
        );

    //
    // Split the metapath at the instance border
    //
    static void SplitMetaPathAtInstance(
        LPCTSTR lpszMDPath,
        CString & strParent,
        CString & strAlias
        );

    static BOOL IsSeparator(TCHAR c);
 

//
// Constructor/Destructor
//
public:
    CMetabasePath(
        BOOL    fAddBasePath,
        LPCTSTR lpszMDPath,
        LPCTSTR lpszMDPath2 = NULL,
        LPCTSTR lpszMDPath3 = NULL,
        LPCTSTR lpszMDPath4 = NULL
        );

    //
    // Construct with path components
    //
    CMetabasePath(
         LPCTSTR lpszSvc        = NULL,    
         DWORD   dwInstance     = MASTER_INSTANCE,
         LPCTSTR lpszParentPath = NULL,        
         LPCTSTR lpszAlias      = NULL    
        );

//
// Access
//
public:
    BOOL    IsHomeDirectoryPath() const { return IsHomeDirectoryPath(m_strMetaPath); }
    LPCTSTR QueryMetaPath() const { return m_strMetaPath; }

//
// Conversion Operators
//
public:
    operator LPCTSTR() const { return QueryMetaPath(); }

//
// Helpers
//
protected:
    void BuildMetaPath(  
        LPCTSTR lpszSvc,
        LPCTSTR szInstance,
        LPCTSTR lpszParentPath,
        LPCTSTR lpszAlias           
        );

    void BuildMetaPath(  
        LPCTSTR lpszSvc,
        DWORD   dwInstance,
        LPCTSTR lpszParentPath,
        LPCTSTR lpszAlias           
        );

    void AppendPath(LPCTSTR lpszPath);
    void AppendPath(DWORD dwInstance);

protected:
    //
    // Metabase path components
    //
    static const LPCTSTR _cszMachine;     
    static const LPCTSTR _cszRoot;        
    static const LPCTSTR _cszSep;         
    static const TCHAR   _chSep;          
    static const CString _anySep;

private:
    CString m_strMetaPath;
};

class _EXPORT CIISInterface
/*++

Class Description:

    Base interface class for IIS interfaces.  Most client COM-wrappers
    should derive from this class so that they can easily pick up
    share authentication and proxy blanket information methods.

Virtual Interface:

    Succeeded           : Return TRUE if item constructed successfully
    QueryResult         : Return construction error code

Public Interface:

    operator BOOL       : Cast to TRUE/FALSE depending on success
    operator HRESULT    : Cast to the HRESULT status

    QueryServerName     : Get the server name
    IsLocal             : Determine if the interface is on the local machine

--*/
{
//
// Constructor/Destructor
//
public:
    CIISInterface(
        CComAuthInfo * pAuthInfo,
        HRESULT hrInterface    = S_OK
        );

//
// Interface:
//
public:
    CComAuthInfo * QueryAuthInfo() { return &m_auth; }
    LPCOLESTR QueryServerName() const { return m_auth.QueryServerName(); }
    BOOL IsLocal() const { return m_auth.IsLocal(); }

//
// Virtual Inter